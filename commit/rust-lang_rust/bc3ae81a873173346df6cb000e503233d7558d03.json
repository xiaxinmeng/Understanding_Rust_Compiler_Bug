{"sha": "bc3ae81a873173346df6cb000e503233d7558d03", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjM2FlODFhODczMTczMzQ2ZGY2Y2IwMDBlNTAzMjMzZDc1NThkMDM=", "commit": {"author": {"name": "Vladyslav Katasonov", "email": "cpud47@gmail.com", "date": "2021-02-03T07:57:11Z"}, "committer": {"name": "Vladyslav Katasonov", "email": "cpud47@gmail.com", "date": "2021-02-03T07:57:11Z"}, "message": "initial version of extract function assist\n\nthere are a few currently limitations:\n* no modifications of function body\n* does not handle mutability and references\n* no method support\n* may produce incorrect results", "tree": {"sha": "e313503ad7fc44ff8681bcd0e02d8853a98c5bc9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e313503ad7fc44ff8681bcd0e02d8853a98c5bc9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc3ae81a873173346df6cb000e503233d7558d03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc3ae81a873173346df6cb000e503233d7558d03", "html_url": "https://github.com/rust-lang/rust/commit/bc3ae81a873173346df6cb000e503233d7558d03", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc3ae81a873173346df6cb000e503233d7558d03/comments", "author": {"login": "cpud36", "id": 4218373, "node_id": "MDQ6VXNlcjQyMTgzNzM=", "avatar_url": "https://avatars.githubusercontent.com/u/4218373?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cpud36", "html_url": "https://github.com/cpud36", "followers_url": "https://api.github.com/users/cpud36/followers", "following_url": "https://api.github.com/users/cpud36/following{/other_user}", "gists_url": "https://api.github.com/users/cpud36/gists{/gist_id}", "starred_url": "https://api.github.com/users/cpud36/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cpud36/subscriptions", "organizations_url": "https://api.github.com/users/cpud36/orgs", "repos_url": "https://api.github.com/users/cpud36/repos", "events_url": "https://api.github.com/users/cpud36/events{/privacy}", "received_events_url": "https://api.github.com/users/cpud36/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cpud36", "id": 4218373, "node_id": "MDQ6VXNlcjQyMTgzNzM=", "avatar_url": "https://avatars.githubusercontent.com/u/4218373?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cpud36", "html_url": "https://github.com/cpud36", "followers_url": "https://api.github.com/users/cpud36/followers", "following_url": "https://api.github.com/users/cpud36/following{/other_user}", "gists_url": "https://api.github.com/users/cpud36/gists{/gist_id}", "starred_url": "https://api.github.com/users/cpud36/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cpud36/subscriptions", "organizations_url": "https://api.github.com/users/cpud36/orgs", "repos_url": "https://api.github.com/users/cpud36/repos", "events_url": "https://api.github.com/users/cpud36/events{/privacy}", "received_events_url": "https://api.github.com/users/cpud36/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e66cde76460d61cb19a19e4bb7bc1f6642e993d", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e66cde76460d61cb19a19e4bb7bc1f6642e993d", "html_url": "https://github.com/rust-lang/rust/commit/7e66cde76460d61cb19a19e4bb7bc1f6642e993d"}], "stats": {"total": 848, "additions": 848, "deletions": 0}, "files": [{"sha": "1a6cfebed41bd64b654e8bb0b8e1488b5ea1a0c5", "filename": "crates/assists/src/handlers/extract_function.rs", "status": "added", "additions": 819, "deletions": 0, "changes": 819, "blob_url": "https://github.com/rust-lang/rust/blob/bc3ae81a873173346df6cb000e503233d7558d03/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc3ae81a873173346df6cb000e503233d7558d03/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=bc3ae81a873173346df6cb000e503233d7558d03", "patch": "@@ -0,0 +1,819 @@\n+use either::Either;\n+use hir::{HirDisplay, Local};\n+use ide_db::defs::{Definition, NameRefClass};\n+use rustc_hash::FxHashSet;\n+use stdx::format_to;\n+use syntax::{\n+    ast::{\n+        self,\n+        edit::{AstNodeEdit, IndentLevel},\n+        AstNode, NameOwner,\n+    },\n+    Direction, SyntaxElement,\n+    SyntaxKind::{self, BLOCK_EXPR, BREAK_EXPR, COMMENT, PATH_EXPR, RETURN_EXPR},\n+    SyntaxNode, TextRange,\n+};\n+use test_utils::mark;\n+\n+use crate::{\n+    assist_context::{AssistContext, Assists},\n+    AssistId,\n+};\n+\n+// Assist: extract_function\n+//\n+// Extracts selected statements into new function.\n+//\n+// ```\n+// fn main() {\n+//     let n = 1;\n+//     $0let m = n + 2;\n+//     let k = m + n;$0\n+//     let g = 3;\n+// }\n+// ```\n+// ->\n+// ```\n+// fn main() {\n+//     let n = 1;\n+//     fun_name(n);\n+//     let g = 3;\n+// }\n+//\n+// fn $0fun_name(n: i32) {\n+//     let m = n + 2;\n+//     let k = m + n;\n+// }\n+// ```\n+pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    if ctx.frange.range.is_empty() {\n+        return None;\n+    }\n+\n+    let node = ctx.covering_element();\n+    if node.kind() == COMMENT {\n+        mark::hit!(extract_function_in_comment_is_not_applicable);\n+        return None;\n+    }\n+\n+    let node = match node {\n+        syntax::NodeOrToken::Node(n) => n,\n+        syntax::NodeOrToken::Token(t) => t.parent(),\n+    };\n+\n+    let mut body = None;\n+    if node.text_range() == ctx.frange.range {\n+        body = FunctionBody::from_whole_node(node.clone());\n+    }\n+    if body.is_none() && node.kind() == BLOCK_EXPR {\n+        body = FunctionBody::from_range(&node, ctx.frange.range);\n+    }\n+    if body.is_none() {\n+        body = FunctionBody::from_whole_node(node.clone());\n+    }\n+    if body.is_none() {\n+        body = node.ancestors().find_map(FunctionBody::from_whole_node);\n+    }\n+    let body = body?;\n+\n+    let insert_after = body.scope_for_fn_insertion()?;\n+\n+    let module = ctx.sema.scope(&insert_after).module()?;\n+\n+    let expr = body.tail_expr();\n+    let ret_ty = match expr {\n+        Some(expr) => {\n+            // TODO: can we do assist when type is unknown?\n+            //       We can insert something like `-> ()`\n+            let ty = ctx.sema.type_of_expr(&expr)?;\n+            Some(ty.display_source_code(ctx.db(), module.into()).ok()?)\n+        }\n+        None => None,\n+    };\n+\n+    let target_range = match &body {\n+        FunctionBody::Expr(expr) => expr.syntax().text_range(),\n+        FunctionBody::Span { .. } => ctx.frange.range,\n+    };\n+\n+    let mut params = local_variables(&body, &ctx)\n+        .into_iter()\n+        .map(|node| node.source(ctx.db()))\n+        .filter(|src| src.file_id.original_file(ctx.db()) == ctx.frange.file_id)\n+        .map(|src| match src.value {\n+            Either::Left(pat) => {\n+                (pat.syntax().clone(), pat.name(), ctx.sema.type_of_pat(&pat.into()))\n+            }\n+            Either::Right(it) => (it.syntax().clone(), it.name(), ctx.sema.type_of_self(&it)),\n+        })\n+        .filter(|(node, _, _)| !body.contains_node(node))\n+        .map(|(_, name, ty)| {\n+            let ty = ty\n+                .and_then(|ty| ty.display_source_code(ctx.db(), module.into()).ok())\n+                .unwrap_or_else(|| \"()\".to_string());\n+\n+            let name = name.unwrap().to_string();\n+\n+            Param { name, ty }\n+        })\n+        .collect::<Vec<_>>();\n+    deduplicate_params(&mut params);\n+\n+    acc.add(\n+        AssistId(\"extract_function\", crate::AssistKind::RefactorExtract),\n+        \"Extract into function\",\n+        target_range,\n+        move |builder| {\n+\n+            let fun = Function { name: \"fun_name\".to_string(), params, ret_ty, body };\n+\n+            builder.replace(target_range, format_replacement(&fun));\n+\n+            let indent = IndentLevel::from_node(&insert_after);\n+\n+            let fn_def = format_function(&fun, indent);\n+            let insert_offset = insert_after.text_range().end();\n+            builder.insert(insert_offset, fn_def);\n+        },\n+    )\n+}\n+\n+fn format_replacement(fun: &Function) -> String {\n+    let mut buf = String::new();\n+    format_to!(buf, \"{}(\", fun.name);\n+    {\n+        let mut it = fun.params.iter();\n+        if let Some(param) = it.next() {\n+            format_to!(buf, \"{}\", param.name);\n+        }\n+        for param in it {\n+            format_to!(buf, \", {}\", param.name);\n+        }\n+    }\n+    format_to!(buf, \")\");\n+\n+    if fun.has_unit_ret() {\n+        format_to!(buf, \";\");\n+    }\n+\n+    buf\n+}\n+\n+struct Function {\n+    name: String,\n+    params: Vec<Param>,\n+    ret_ty: Option<String>,\n+    body: FunctionBody,\n+}\n+\n+impl Function {\n+    fn has_unit_ret(&self) -> bool {\n+        match &self.ret_ty {\n+            Some(ty) => ty == \"()\",\n+            None => true,\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct Param {\n+    name: String,\n+    ty: String,\n+}\n+\n+fn format_function(fun: &Function, indent: IndentLevel) -> String {\n+    let mut fn_def = String::new();\n+    format_to!(fn_def, \"\\n\\n{}fn $0{}(\", indent, fun.name);\n+    {\n+        let mut it = fun.params.iter();\n+        if let Some(param) = it.next() {\n+            format_to!(fn_def, \"{}: {}\", param.name, param.ty);\n+        }\n+        for param in it {\n+            format_to!(fn_def, \", {}: {}\", param.name, param.ty);\n+        }\n+    }\n+\n+    format_to!(fn_def, \")\");\n+    if !fun.has_unit_ret() {\n+        if let Some(ty) = &fun.ret_ty {\n+            format_to!(fn_def, \" -> {}\", ty);\n+        }\n+    }\n+    format_to!(fn_def, \" {{\");\n+\n+    match &fun.body {\n+        FunctionBody::Expr(expr) => {\n+            fn_def.push('\\n');\n+            let expr = expr.indent(indent);\n+            format_to!(fn_def, \"{}{}\", indent + 1, expr.syntax());\n+            fn_def.push('\\n');\n+        }\n+        FunctionBody::Span { elements, leading_indent } => {\n+            format_to!(fn_def, \"{}\", leading_indent);\n+            for e in elements {\n+                format_to!(fn_def, \"{}\", e);\n+            }\n+            if !fn_def.ends_with('\\n') {\n+                fn_def.push('\\n');\n+            }\n+        }\n+    }\n+    format_to!(fn_def, \"{}}}\", indent);\n+\n+    fn_def\n+}\n+\n+#[derive(Debug)]\n+enum FunctionBody {\n+    Expr(ast::Expr),\n+    Span { elements: Vec<SyntaxElement>, leading_indent: String },\n+}\n+\n+impl FunctionBody {\n+    fn from_whole_node(node: SyntaxNode) -> Option<Self> {\n+        match node.kind() {\n+            PATH_EXPR => None,\n+            BREAK_EXPR => ast::BreakExpr::cast(node).and_then(|e| e.expr()).map(Self::Expr),\n+            RETURN_EXPR => ast::ReturnExpr::cast(node).and_then(|e| e.expr()).map(Self::Expr),\n+            BLOCK_EXPR => ast::BlockExpr::cast(node)\n+                .filter(|it| it.is_standalone())\n+                .map(Into::into)\n+                .map(Self::Expr),\n+            _ => ast::Expr::cast(node).map(Self::Expr),\n+        }\n+    }\n+\n+    fn from_range(node: &SyntaxNode, range: TextRange) -> Option<FunctionBody> {\n+        let mut first = node.token_at_offset(range.start()).left_biased()?;\n+        let last = node.token_at_offset(range.end()).right_biased()?;\n+\n+        let mut leading_indent = String::new();\n+\n+        let leading_trivia = first\n+            .siblings_with_tokens(Direction::Prev)\n+            .skip(1)\n+            .take_while(|e| e.kind() == SyntaxKind::WHITESPACE && e.as_token().is_some());\n+\n+        for e in leading_trivia {\n+            let token = e.as_token().unwrap();\n+            let text = token.text();\n+            match text.rfind('\\n') {\n+                Some(pos) => {\n+                    leading_indent = text[pos..].to_owned();\n+                    break;\n+                }\n+                None => first = token.clone(),\n+            }\n+        }\n+\n+        let mut elements: Vec<_> = first\n+            .siblings_with_tokens(Direction::Next)\n+            .take_while(|e| e.as_token() != Some(&last))\n+            .collect();\n+\n+        if !(last.kind() == SyntaxKind::WHITESPACE && last.text().lines().count() <= 2) {\n+            elements.push(last.into());\n+        }\n+\n+        Some(FunctionBody::Span { elements, leading_indent })\n+    }\n+\n+    fn tail_expr(&self) -> Option<ast::Expr> {\n+        match &self {\n+            FunctionBody::Expr(expr) => Some(expr.clone()),\n+            FunctionBody::Span { elements, .. } => {\n+                elements.iter().rev().find_map(|e| e.as_node()).cloned().and_then(ast::Expr::cast)\n+            }\n+        }\n+    }\n+\n+    fn scope_for_fn_insertion(&self) -> Option<SyntaxNode> {\n+        match self {\n+            FunctionBody::Expr(e) => scope_for_fn_insertion(e.syntax()),\n+            FunctionBody::Span { elements, .. } => {\n+                let node = elements.iter().find_map(|e| e.as_node())?;\n+                scope_for_fn_insertion(&node)\n+            }\n+        }\n+    }\n+\n+    fn descendants(&self) -> impl Iterator<Item = SyntaxNode> + '_ {\n+        match self {\n+            FunctionBody::Expr(expr) => Either::Right(expr.syntax().descendants()),\n+            FunctionBody::Span { elements, .. } => Either::Left(\n+                elements\n+                    .iter()\n+                    .filter_map(SyntaxElement::as_node)\n+                    .flat_map(SyntaxNode::descendants),\n+            ),\n+        }\n+    }\n+\n+    fn contains_node(&self, node: &SyntaxNode) -> bool {\n+        fn is_node(body: &FunctionBody, n: &SyntaxNode) -> bool {\n+            match body {\n+                FunctionBody::Expr(expr) => n == expr.syntax(),\n+                FunctionBody::Span { elements, .. } => {\n+                    // FIXME: can it be quadratic?\n+                    elements.iter().filter_map(SyntaxElement::as_node).any(|e| e == n)\n+                }\n+            }\n+        }\n+\n+        node.ancestors().any(|a| is_node(self, &a))\n+    }\n+}\n+\n+fn scope_for_fn_insertion(node: &SyntaxNode) -> Option<SyntaxNode> {\n+    let mut ancestors = node.ancestors().peekable();\n+    let mut last_ancestor = None;\n+    while let Some(next_ancestor) = ancestors.next() {\n+        match next_ancestor.kind() {\n+            SyntaxKind::SOURCE_FILE => break,\n+            SyntaxKind::ITEM_LIST => {\n+                if ancestors.peek().map(|a| a.kind()) == Some(SyntaxKind::MODULE) {\n+                    break;\n+                }\n+            }\n+            _ => {}\n+        }\n+        last_ancestor = Some(next_ancestor);\n+    }\n+    last_ancestor\n+}\n+\n+fn deduplicate_params(params: &mut Vec<Param>) {\n+    let mut seen_params = FxHashSet::default();\n+    params.retain(|p| seen_params.insert(p.name.clone()));\n+}\n+\n+/// Returns a vector of local variables that are refferenced in `body`\n+fn local_variables(body: &FunctionBody, ctx: &AssistContext) -> Vec<Local> {\n+    body\n+        .descendants()\n+        .filter_map(ast::NameRef::cast)\n+        .filter_map(|name_ref| NameRefClass::classify(&ctx.sema, &name_ref))\n+        .map(|name_kind| name_kind.referenced(ctx.db()))\n+        .filter_map(|definition| match definition {\n+            Definition::Local(local) => Some(local),\n+            _ => None,\n+        })\n+        .collect()\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn no_args_from_binary_expr() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn foo() {\n+    foo($01 + 1$0);\n+}\"#,\n+            r#\"\n+fn foo() {\n+    foo(fun_name());\n+}\n+\n+fn $0fun_name() -> i32 {\n+    1 + 1\n+}\"#,\n+        );\n+    }\n+    \n+    #[test]\n+    fn no_args_from_binary_expr_in_module() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+mod bar {\n+    fn foo() {\n+        foo($01 + 1$0);\n+    }\n+}\"#,\n+            r#\"\n+mod bar {\n+    fn foo() {\n+        foo(fun_name());\n+    }\n+\n+    fn $0fun_name() -> i32 {\n+        1 + 1\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_args_from_binary_expr_indented() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn foo() {\n+    $0{ 1 + 1 }$0;\n+}\"#,\n+            r#\"\n+fn foo() {\n+    fun_name();\n+}\n+\n+fn $0fun_name() -> i32 {\n+    { 1 + 1 }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_args_from_stmt_with_last_expr() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn foo() -> i32 {\n+    let k = 1;\n+    $0let m = 1;\n+    m + 1$0\n+}\"#,\n+            r#\"\n+fn foo() -> i32 {\n+    let k = 1;\n+    fun_name()\n+}\n+\n+fn $0fun_name() -> i32 {\n+    let m = 1;\n+    m + 1\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_args_from_stmt_unit() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn foo() {\n+    let k = 3;\n+    $0let m = 1;\n+    let n = m + 1;$0\n+    let g = 5;\n+}\"#,\n+            r#\"\n+fn foo() {\n+    let k = 3;\n+    fun_name();\n+    let g = 5;\n+}\n+\n+fn $0fun_name() {\n+    let m = 1;\n+    let n = m + 1;\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_args_from_loop_unit() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn foo() {\n+    $0loop {\n+        let m = 1;\n+    }$0\n+}\"#,\n+            r#\"\n+fn foo() {\n+    fun_name()\n+}\n+\n+fn $0fun_name() -> ! {\n+    loop {\n+        let m = 1;\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_args_from_loop_with_return() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn foo() {\n+    let v = $0loop {\n+        let m = 1;\n+        break m;\n+    }$0;\n+}\"#,\n+            r#\"\n+fn foo() {\n+    let v = fun_name();\n+}\n+\n+fn $0fun_name() -> i32 {\n+    loop {\n+        let m = 1;\n+        break m;\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_args_from_match() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn foo() {\n+    let v: i32 = $0match Some(1) {\n+        Some(x) => x,\n+        None => 0,\n+    }$0;\n+}\"#,\n+            r#\"\n+fn foo() {\n+    let v: i32 = fun_name();\n+}\n+\n+fn $0fun_name() -> i32 {\n+    match Some(1) {\n+        Some(x) => x,\n+        None => 0,\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn argument_form_expr() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+fn foo() -> u32 {\n+    let n = 2;\n+    $0n+2$0\n+}\",\n+            r\"\n+fn foo() -> u32 {\n+    let n = 2;\n+    fun_name(n)\n+}\n+\n+fn $0fun_name(n: u32) -> u32 {\n+    n+2\n+}\",\n+        )\n+    }\n+\n+    #[test]\n+    fn argument_used_twice_form_expr() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+fn foo() -> u32 {\n+    let n = 2;\n+    $0n+n$0\n+}\",\n+            r\"\n+fn foo() -> u32 {\n+    let n = 2;\n+    fun_name(n)\n+}\n+\n+fn $0fun_name(n: u32) -> u32 {\n+    n+n\n+}\",\n+        )\n+    }\n+\n+    #[test]\n+    fn two_arguments_form_expr() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+fn foo() -> u32 {\n+    let n = 2;\n+    let m = 3;\n+    $0n+n*m$0\n+}\",\n+            r\"\n+fn foo() -> u32 {\n+    let n = 2;\n+    let m = 3;\n+    fun_name(n, m)\n+}\n+\n+fn $0fun_name(n: u32, m: u32) -> u32 {\n+    n+n*m\n+}\",\n+        )\n+    }\n+\n+    #[test]\n+    fn argument_and_locals() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+fn foo() -> u32 {\n+    let n = 2;\n+    $0let m = 1;\n+    n + m$0\n+}\",\n+            r\"\n+fn foo() -> u32 {\n+    let n = 2;\n+    fun_name(n)\n+}\n+\n+fn $0fun_name(n: u32) -> u32 {\n+    let m = 1;\n+    n + m\n+}\",\n+        )\n+    }\n+\n+    #[test]\n+    fn in_comment_is_not_applicable() {\n+        mark::check!(extract_function_in_comment_is_not_applicable);\n+        check_assist_not_applicable(extract_function, r\"fn main() { 1 + /* $0comment$0 */ 1; }\");\n+    }\n+\n+    #[test]\n+    fn part_of_expr_stmt() {\n+        check_assist(\n+            extract_function,\n+            \"\n+fn foo() {\n+    $01$0 + 1;\n+}\",\n+            \"\n+fn foo() {\n+    fun_name() + 1;\n+}\n+\n+fn $0fun_name() -> i32 {\n+    1\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn function_expr() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn foo() {\n+    $0bar(1 + 1)$0\n+}\"#,\n+            r#\"\n+fn foo() {\n+    fun_name();\n+}\n+\n+fn $0fun_name() {\n+    bar(1 + 1)\n+}\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn extract_from_nested() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+fn main() {\n+    let x = true;\n+    let tuple = match x {\n+        true => ($02 + 2$0, true)\n+        _ => (0, false)\n+    };\n+}\",\n+            r\"\n+fn main() {\n+    let x = true;\n+    let tuple = match x {\n+        true => (fun_name(), true)\n+        _ => (0, false)\n+    };\n+}\n+\n+fn $0fun_name() -> i32 {\n+    2 + 2\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn param_from_closure() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+fn main() {\n+    let lambda = |x: u32| $0x * 2$0;\n+}\",\n+            r\"\n+fn main() {\n+    let lambda = |x: u32| fun_name(x);\n+}\n+\n+fn $0fun_name(x: u32) -> u32 {\n+    x * 2\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn extract_return_stmt() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+fn foo() -> u32 {\n+    $0return 2 + 2$0;\n+}\",\n+            r\"\n+fn foo() -> u32 {\n+    return fun_name();\n+}\n+\n+fn $0fun_name() -> u32 {\n+    2 + 2\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn does_not_add_extra_whitespace() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+fn foo() -> u32 {\n+\n+\n+    $0return 2 + 2$0;\n+}\",\n+            r\"\n+fn foo() -> u32 {\n+\n+\n+    return fun_name();\n+}\n+\n+fn $0fun_name() -> u32 {\n+    2 + 2\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn break_stmt() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+fn main() {\n+    let result = loop {\n+        $0break 2 + 2$0;\n+    };\n+}\",\n+            r\"\n+fn main() {\n+    let result = loop {\n+        break fun_name();\n+    };\n+}\n+\n+fn $0fun_name() -> i32 {\n+    2 + 2\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn extract_cast() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+fn main() {\n+    let v = $00f32 as u32$0;\n+}\",\n+            r\"\n+fn main() {\n+    let v = fun_name();\n+}\n+\n+fn $0fun_name() -> u32 {\n+    0f32 as u32\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn return_not_applicable() {\n+        check_assist_not_applicable(extract_function, r\"fn foo() { $0return$0; } \");\n+    }\n+}"}, {"sha": "062a902ab0f6453bce30784e845c481831e8cfe6", "filename": "crates/assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc3ae81a873173346df6cb000e503233d7558d03/crates%2Fassists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc3ae81a873173346df6cb000e503233d7558d03/crates%2Fassists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Flib.rs?ref=bc3ae81a873173346df6cb000e503233d7558d03", "patch": "@@ -117,6 +117,7 @@ mod handlers {\n     mod convert_integer_literal;\n     mod early_return;\n     mod expand_glob_import;\n+    mod extract_function;\n     mod extract_struct_from_enum_variant;\n     mod extract_variable;\n     mod fill_match_arms;\n@@ -174,6 +175,7 @@ mod handlers {\n             early_return::convert_to_guarded_return,\n             expand_glob_import::expand_glob_import,\n             move_module_to_file::move_module_to_file,\n+            extract_function::extract_function,\n             extract_struct_from_enum_variant::extract_struct_from_enum_variant,\n             extract_variable::extract_variable,\n             fill_match_arms::fill_match_arms,"}, {"sha": "e84f208a3844c4a5702762f359391f1c1d18fd4e", "filename": "crates/assists/src/tests/generated.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/bc3ae81a873173346df6cb000e503233d7558d03/crates%2Fassists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc3ae81a873173346df6cb000e503233d7558d03/crates%2Fassists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Ftests%2Fgenerated.rs?ref=bc3ae81a873173346df6cb000e503233d7558d03", "patch": "@@ -256,6 +256,33 @@ fn qux(bar: Bar, baz: Baz) {}\n     )\n }\n \n+#[test]\n+fn doctest_extract_function() {\n+    check_doc_test(\n+        \"extract_function\",\n+        r#####\"\n+fn main() {\n+    let n = 1;\n+    $0let m = n + 2;\n+    let k = m + n;$0\n+    let g = 3;\n+}\n+\"#####,\n+        r#####\"\n+fn main() {\n+    let n = 1;\n+    fun_name(n);\n+    let g = 3;\n+}\n+\n+fn $0fun_name(n: i32) {\n+    let m = n + 2;\n+    let k = m + n;\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_extract_struct_from_enum_variant() {\n     check_doc_test("}]}