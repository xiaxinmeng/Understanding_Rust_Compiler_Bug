{"sha": "7a9f3078e50fdadc28ac0718dc11c83d62a3fb18", "node_id": "C_kwDOAAsO6NoAKDdhOWYzMDc4ZTUwZmRhZGMyOGFjMDcxOGRjMTFjODNkNjJhM2ZiMTg", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2022-07-23T12:56:58Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2022-07-23T12:56:58Z"}, "message": "Remove Clean trait implementation for hir::Ty and middle::Ty", "tree": {"sha": "5c0e5f86164f15c4475904b8d1a22601d1ba4fd5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c0e5f86164f15c4475904b8d1a22601d1ba4fd5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a9f3078e50fdadc28ac0718dc11c83d62a3fb18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a9f3078e50fdadc28ac0718dc11c83d62a3fb18", "html_url": "https://github.com/rust-lang/rust/commit/7a9f3078e50fdadc28ac0718dc11c83d62a3fb18", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a9f3078e50fdadc28ac0718dc11c83d62a3fb18/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "47ba93596586783efd41df7b8ea84f4f1e37f923", "url": "https://api.github.com/repos/rust-lang/rust/commits/47ba93596586783efd41df7b8ea84f4f1e37f923", "html_url": "https://github.com/rust-lang/rust/commit/47ba93596586783efd41df7b8ea84f4f1e37f923"}], "stats": {"total": 289, "additions": 153, "deletions": 136}, "files": [{"sha": "c43fd1ad24173ecec40c04761352794aeb858686", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a9f3078e50fdadc28ac0718dc11c83d62a3fb18/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a9f3078e50fdadc28ac0718dc11c83d62a3fb18/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=7a9f3078e50fdadc28ac0718dc11c83d62a3fb18", "patch": "@@ -121,7 +121,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 unsafety: hir::Unsafety::Normal,\n                 generics: new_generics,\n                 trait_: Some(trait_ref.clean(self.cx)),\n-                for_: ty.clean(self.cx),\n+                for_: clean_middle_ty(ty, self.cx, None),\n                 items: Vec::new(),\n                 polarity,\n                 kind: ImplKind::Auto,"}, {"sha": "c64c5895079be91547c30d15cc7368baf83f35ba", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a9f3078e50fdadc28ac0718dc11c83d62a3fb18/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a9f3078e50fdadc28ac0718dc11c83d62a3fb18/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=7a9f3078e50fdadc28ac0718dc11c83d62a3fb18", "patch": "@@ -116,14 +116,14 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                             // FIXME(eddyb) compute both `trait_` and `for_` from\n                             // the post-inference `trait_ref`, as it's more accurate.\n                             trait_: Some(trait_ref.0.clean(cx)),\n-                            for_: ty.0.clean(cx),\n+                            for_: clean_middle_ty(ty.0, cx, None),\n                             items: cx.tcx\n                                 .associated_items(impl_def_id)\n                                 .in_definition_order()\n                                 .map(|x| x.clean(cx))\n                                 .collect::<Vec<_>>(),\n                             polarity: ty::ImplPolarity::Positive,\n-                            kind: ImplKind::Blanket(Box::new(trait_ref.0.self_ty().clean(cx))),\n+                            kind: ImplKind::Blanket(Box::new(clean_middle_ty(trait_ref.0.self_ty(), cx, None))),\n                         })),\n                         cfg: None,\n                     });"}, {"sha": "7a4ec889ac75730514c8ed647fc4206b9cba39c4", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7a9f3078e50fdadc28ac0718dc11c83d62a3fb18/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a9f3078e50fdadc28ac0718dc11c83d62a3fb18/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=7a9f3078e50fdadc28ac0718dc11c83d62a3fb18", "patch": "@@ -16,8 +16,8 @@ use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{kw, sym, Symbol};\n \n use crate::clean::{\n-    self, clean_fn_decl_from_did_and_sig, clean_ty_generics, utils, Attributes, AttributesExt,\n-    Clean, ImplKind, ItemId, Type, Visibility,\n+    self, clean_fn_decl_from_did_and_sig, clean_middle_ty, clean_ty, clean_ty_generics, utils,\n+    Attributes, AttributesExt, Clean, ImplKind, ItemId, Type, Visibility,\n };\n use crate::core::DocContext;\n use crate::formats::item_type::ItemType;\n@@ -261,7 +261,7 @@ fn build_union(cx: &mut DocContext<'_>, did: DefId) -> clean::Union {\n \n fn build_type_alias(cx: &mut DocContext<'_>, did: DefId) -> clean::Typedef {\n     let predicates = cx.tcx.explicit_predicates_of(did);\n-    let type_ = cx.tcx.type_of(did).clean(cx);\n+    let type_ = clean_middle_ty(cx.tcx.type_of(did), cx, Some(did));\n \n     clean::Typedef {\n         type_,\n@@ -357,8 +357,8 @@ pub(crate) fn build_impl(\n     };\n \n     let for_ = match &impl_item {\n-        Some(impl_) => impl_.self_ty.clean(cx),\n-        None => tcx.type_of(did).clean(cx),\n+        Some(impl_) => clean_ty(impl_.self_ty, cx),\n+        None => clean_middle_ty(tcx.type_of(did), cx, Some(did)),\n     };\n \n     // Only inline impl if the implementing type is\n@@ -577,14 +577,14 @@ pub(crate) fn print_inlined_const(tcx: TyCtxt<'_>, did: DefId) -> String {\n \n fn build_const(cx: &mut DocContext<'_>, def_id: DefId) -> clean::Constant {\n     clean::Constant {\n-        type_: cx.tcx.type_of(def_id).clean(cx),\n+        type_: clean_middle_ty(cx.tcx.type_of(def_id), cx, Some(def_id)),\n         kind: clean::ConstantKind::Extern { def_id },\n     }\n }\n \n fn build_static(cx: &mut DocContext<'_>, did: DefId, mutable: bool) -> clean::Static {\n     clean::Static {\n-        type_: cx.tcx.type_of(did).clean(cx),\n+        type_: clean_middle_ty(cx.tcx.type_of(did), cx, Some(did)),\n         mutability: if mutable { Mutability::Mut } else { Mutability::Not },\n         expr: None,\n     }"}, {"sha": "6160783f652f120ec82f0b481303e0dce48dcc56", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 138, "deletions": 122, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/7a9f3078e50fdadc28ac0718dc11c83d62a3fb18/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a9f3078e50fdadc28ac0718dc11c83d62a3fb18/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=7a9f3078e50fdadc28ac0718dc11c83d62a3fb18", "patch": "@@ -239,11 +239,9 @@ impl<'tcx> Clean<'tcx, Lifetime> for hir::Lifetime {\n \n impl<'tcx> Clean<'tcx, Constant> for hir::ConstArg {\n     fn clean(&self, cx: &mut DocContext<'tcx>) -> Constant {\n+        let def_id = cx.tcx.hir().body_owner_def_id(self.value.body).to_def_id();\n         Constant {\n-            type_: cx\n-                .tcx\n-                .type_of(cx.tcx.hir().body_owner_def_id(self.value.body).to_def_id())\n-                .clean(cx),\n+            type_: clean_middle_ty(cx.tcx.type_of(def_id), cx, Some(def_id)),\n             kind: ConstantKind::Anonymous { body: self.value.body },\n         }\n     }\n@@ -297,7 +295,7 @@ impl<'tcx> Clean<'tcx, Option<WherePredicate>> for hir::WherePredicate<'tcx> {\n                     })\n                     .collect();\n                 WherePredicate::BoundPredicate {\n-                    ty: wbp.bounded_ty.clean(cx),\n+                    ty: clean_ty(wbp.bounded_ty, cx),\n                     bounds: wbp.bounds.iter().filter_map(|x| x.clean(cx)).collect(),\n                     bound_params,\n                 }\n@@ -309,8 +307,8 @@ impl<'tcx> Clean<'tcx, Option<WherePredicate>> for hir::WherePredicate<'tcx> {\n             },\n \n             hir::WherePredicate::EqPredicate(ref wrp) => WherePredicate::EqPredicate {\n-                lhs: wrp.lhs_ty.clean(cx),\n-                rhs: wrp.rhs_ty.clean(cx).into(),\n+                lhs: clean_ty(wrp.lhs_ty, cx),\n+                rhs: clean_ty(wrp.rhs_ty, cx).into(),\n             },\n         })\n     }\n@@ -348,7 +346,7 @@ impl<'tcx> Clean<'tcx, Option<WherePredicate>> for ty::PolyTraitPredicate<'tcx>\n \n         let poly_trait_ref = self.map_bound(|pred| pred.trait_ref);\n         Some(WherePredicate::BoundPredicate {\n-            ty: poly_trait_ref.skip_binder().self_ty().clean(cx),\n+            ty: clean_middle_ty(poly_trait_ref.skip_binder().self_ty(), cx, None),\n             bounds: vec![poly_trait_ref.clean(cx)],\n             bound_params: Vec::new(),\n         })\n@@ -383,7 +381,7 @@ impl<'tcx> Clean<'tcx, Option<WherePredicate>>\n         }\n \n         Some(WherePredicate::BoundPredicate {\n-            ty: ty.clean(cx),\n+            ty: clean_middle_ty(*ty, cx, None),\n             bounds: vec![GenericBound::Outlives(lt.clean(cx).expect(\"failed to clean lifetimes\"))],\n             bound_params: Vec::new(),\n         })\n@@ -393,7 +391,7 @@ impl<'tcx> Clean<'tcx, Option<WherePredicate>>\n impl<'tcx> Clean<'tcx, Term> for ty::Term<'tcx> {\n     fn clean(&self, cx: &mut DocContext<'tcx>) -> Term {\n         match self {\n-            ty::Term::Ty(ty) => Term::Type(ty.clean(cx)),\n+            ty::Term::Ty(ty) => Term::Type(clean_middle_ty(*ty, cx, None)),\n             ty::Term::Const(c) => Term::Constant(c.clean(cx)),\n         }\n     }\n@@ -402,7 +400,7 @@ impl<'tcx> Clean<'tcx, Term> for ty::Term<'tcx> {\n impl<'tcx> Clean<'tcx, Term> for hir::Term<'tcx> {\n     fn clean(&self, cx: &mut DocContext<'tcx>) -> Term {\n         match self {\n-            hir::Term::Ty(ty) => Term::Type(ty.clean(cx)),\n+            hir::Term::Ty(ty) => Term::Type(clean_ty(ty, cx)),\n             hir::Term::Const(c) => {\n                 let def_id = cx.tcx.hir().local_def_id(c.hir_id);\n                 Term::Constant(ty::Const::from_anon_const(cx.tcx, def_id).clean(cx))\n@@ -425,7 +423,7 @@ fn clean_projection<'tcx>(\n ) -> Type {\n     let lifted = ty.lift_to_tcx(cx.tcx).unwrap();\n     let trait_ = lifted.trait_ref(cx.tcx).clean(cx);\n-    let self_type = ty.self_ty().clean(cx);\n+    let self_type = clean_middle_ty(ty.self_ty(), cx, None);\n     let self_def_id = if let Some(def_id) = def_id {\n         cx.tcx.opt_parent(def_id).or(Some(def_id))\n     } else {\n@@ -476,7 +474,7 @@ impl<'tcx> Clean<'tcx, GenericParamDef> for ty::GenericParamDef {\n             }\n             ty::GenericParamDefKind::Type { has_default, synthetic, .. } => {\n                 let default = if has_default {\n-                    Some(clean_ty(cx.tcx.type_of(self.def_id), cx, Some(self.def_id)))\n+                    Some(clean_middle_ty(cx.tcx.type_of(self.def_id), cx, Some(self.def_id)))\n                 } else {\n                     None\n                 };\n@@ -494,7 +492,11 @@ impl<'tcx> Clean<'tcx, GenericParamDef> for ty::GenericParamDef {\n                 self.name,\n                 GenericParamDefKind::Const {\n                     did: self.def_id,\n-                    ty: Box::new(cx.tcx.type_of(self.def_id).clean(cx)),\n+                    ty: Box::new(clean_middle_ty(\n+                        cx.tcx.type_of(self.def_id),\n+                        cx,\n+                        Some(self.def_id),\n+                    )),\n                     default: match has_default {\n                         true => Some(Box::new(cx.tcx.const_param_default(self.def_id).to_string())),\n                         false => None,\n@@ -546,7 +548,7 @@ fn clean_generic_param<'tcx>(\n                 GenericParamDefKind::Type {\n                     did: did.to_def_id(),\n                     bounds,\n-                    default: default.map(|t| t.clean(cx)).map(Box::new),\n+                    default: default.map(|t| clean_ty(t, cx)).map(Box::new),\n                     synthetic,\n                 },\n             )\n@@ -555,7 +557,7 @@ fn clean_generic_param<'tcx>(\n             param.name.ident().name,\n             GenericParamDefKind::Const {\n                 did: did.to_def_id(),\n-                ty: Box::new(ty.clean(cx)),\n+                ty: Box::new(clean_ty(ty, cx)),\n                 default: default.map(|ct| {\n                     let def_id = cx.tcx.hir().local_def_id(ct.hir_id);\n                     Box::new(ty::Const::from_anon_const(cx.tcx, def_id).to_string())\n@@ -752,7 +754,7 @@ fn clean_ty_generics<'tcx>(\n         if let crate::core::ImplTraitParam::ParamIndex(idx) = param {\n             if let Some(proj) = impl_trait_proj.remove(&idx) {\n                 for (trait_did, name, rhs) in proj {\n-                    let rhs = rhs.clean(cx);\n+                    let rhs = clean_middle_ty(rhs, cx, None);\n                     simplify::merge_bounds(cx, &mut bounds, trait_did, name, &Term::Type(rhs));\n                 }\n             }\n@@ -926,7 +928,7 @@ fn clean_args_from_types_and_names<'tcx>(\n                 if name.is_empty() {\n                     name = kw::Underscore;\n                 }\n-                Argument { name, type_: ty.clean(cx), is_const: false }\n+                Argument { name, type_: clean_ty(ty, cx), is_const: false }\n             })\n             .collect(),\n     }\n@@ -945,7 +947,7 @@ fn clean_args_from_types_and_body_id<'tcx>(\n             .enumerate()\n             .map(|(i, ty)| Argument {\n                 name: name_from_pat(body.params[i].pat),\n-                type_: ty.clean(cx),\n+                type_: clean_ty(ty, cx),\n                 is_const: false,\n             })\n             .collect(),\n@@ -969,7 +971,7 @@ fn clean_fn_decl_from_did_and_sig<'tcx>(\n \n     // We assume all empty tuples are default return type. This theoretically can discard `-> ()`,\n     // but shouldn't change any code meaning.\n-    let output = match sig.skip_binder().output().clean(cx) {\n+    let output = match clean_middle_ty(sig.skip_binder().output(), cx, None) {\n         Type::Tuple(inner) if inner.is_empty() => DefaultReturn,\n         ty => Return(ty),\n     };\n@@ -983,7 +985,7 @@ fn clean_fn_decl_from_did_and_sig<'tcx>(\n                 .inputs()\n                 .iter()\n                 .map(|t| Argument {\n-                    type_: t.clean(cx),\n+                    type_: clean_middle_ty(*t, cx, None),\n                     name: names.next().map_or(kw::Empty, |i| i.name),\n                     is_const: false,\n                 })\n@@ -995,7 +997,7 @@ fn clean_fn_decl_from_did_and_sig<'tcx>(\n impl<'tcx> Clean<'tcx, FnRetTy> for hir::FnRetTy<'tcx> {\n     fn clean(&self, cx: &mut DocContext<'tcx>) -> FnRetTy {\n         match *self {\n-            Self::Return(typ) => Return(typ.clean(cx)),\n+            Self::Return(typ) => Return(clean_ty(typ, cx)),\n             Self::DefaultReturn(..) => DefaultReturn,\n         }\n     }\n@@ -1038,10 +1040,10 @@ impl<'tcx> Clean<'tcx, Item> for hir::TraitItem<'tcx> {\n         cx.with_param_env(local_did, |cx| {\n             let inner = match self.kind {\n                 hir::TraitItemKind::Const(ty, Some(default)) => AssocConstItem(\n-                    ty.clean(cx),\n+                    clean_ty(ty, cx),\n                     ConstantKind::Local { def_id: local_did, body: default },\n                 ),\n-                hir::TraitItemKind::Const(ty, None) => TyAssocConstItem(ty.clean(cx)),\n+                hir::TraitItemKind::Const(ty, None) => TyAssocConstItem(clean_ty(ty, cx)),\n                 hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Provided(body)) => {\n                     let m = clean_function(cx, sig, self.generics, body);\n                     MethodItem(m, None)\n@@ -1059,9 +1061,13 @@ impl<'tcx> Clean<'tcx, Item> for hir::TraitItem<'tcx> {\n                 hir::TraitItemKind::Type(bounds, Some(default)) => {\n                     let generics = enter_impl_trait(cx, |cx| self.generics.clean(cx));\n                     let bounds = bounds.iter().filter_map(|x| x.clean(cx)).collect();\n-                    let item_type = hir_ty_to_ty(cx.tcx, default).clean(cx);\n+                    let item_type = clean_middle_ty(hir_ty_to_ty(cx.tcx, default), cx, None);\n                     AssocTypeItem(\n-                        Typedef { type_: default.clean(cx), generics, item_type: Some(item_type) },\n+                        Typedef {\n+                            type_: clean_ty(default, cx),\n+                            generics,\n+                            item_type: Some(item_type),\n+                        },\n                         bounds,\n                     )\n                 }\n@@ -1086,17 +1092,17 @@ impl<'tcx> Clean<'tcx, Item> for hir::ImplItem<'tcx> {\n             let inner = match self.kind {\n                 hir::ImplItemKind::Const(ty, expr) => {\n                     let default = ConstantKind::Local { def_id: local_did, body: expr };\n-                    AssocConstItem(ty.clean(cx), default)\n+                    AssocConstItem(clean_ty(ty, cx), default)\n                 }\n                 hir::ImplItemKind::Fn(ref sig, body) => {\n                     let m = clean_function(cx, sig, self.generics, body);\n                     let defaultness = cx.tcx.associated_item(self.def_id).defaultness;\n                     MethodItem(m, Some(defaultness))\n                 }\n                 hir::ImplItemKind::TyAlias(hir_ty) => {\n-                    let type_ = hir_ty.clean(cx);\n+                    let type_ = clean_ty(hir_ty, cx);\n                     let generics = self.generics.clean(cx);\n-                    let item_type = hir_ty_to_ty(cx.tcx, hir_ty).clean(cx);\n+                    let item_type = clean_middle_ty(hir_ty_to_ty(cx.tcx, hir_ty), cx, None);\n                     AssocTypeItem(\n                         Typedef { type_, generics, item_type: Some(item_type) },\n                         Vec::new(),\n@@ -1125,7 +1131,7 @@ impl<'tcx> Clean<'tcx, Item> for ty::AssocItem {\n         let tcx = cx.tcx;\n         let kind = match self.kind {\n             ty::AssocKind::Const => {\n-                let ty = tcx.type_of(self.def_id).clean(cx);\n+                let ty = clean_middle_ty(tcx.type_of(self.def_id), cx, Some(self.def_id));\n \n                 let provided = match self.container {\n                     ty::ImplContainer(_) => true,\n@@ -1272,7 +1278,11 @@ impl<'tcx> Clean<'tcx, Item> for ty::AssocItem {\n                     if self.defaultness.has_value() {\n                         AssocTypeItem(\n                             Typedef {\n-                                type_: tcx.type_of(self.def_id).clean(cx),\n+                                type_: clean_middle_ty(\n+                                    tcx.type_of(self.def_id),\n+                                    cx,\n+                                    Some(self.def_id),\n+                                ),\n                                 generics,\n                                 // FIXME: should we obtain the Type from HIR and pass it on here?\n                                 item_type: None,\n@@ -1286,7 +1296,7 @@ impl<'tcx> Clean<'tcx, Item> for ty::AssocItem {\n                     // FIXME: when could this happen? Associated items in inherent impls?\n                     AssocTypeItem(\n                         Typedef {\n-                            type_: tcx.type_of(self.def_id).clean(cx),\n+                            type_: clean_middle_ty(tcx.type_of(self.def_id), cx, Some(self.def_id)),\n                             generics: Generics { params: Vec::new(), where_predicates: Vec::new() },\n                             item_type: None,\n                         },\n@@ -1337,7 +1347,7 @@ fn clean_qpath<'tcx>(hir_ty: &hir::Ty<'tcx>, cx: &mut DocContext<'tcx>) -> Type\n             // Try to normalize `<X as Y>::T` to a type\n             let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n             if let Some(normalized_value) = normalize(cx, ty) {\n-                return normalized_value.clean(cx);\n+                return clean_middle_ty(normalized_value, cx, None);\n             }\n \n             let trait_segments = &p.segments[..p.segments.len() - 1];\n@@ -1348,7 +1358,7 @@ fn clean_qpath<'tcx>(hir_ty: &hir::Ty<'tcx>, cx: &mut DocContext<'tcx>) -> Type\n             };\n             register_res(cx, trait_.res);\n             let self_def_id = DefId::local(qself.hir_id.owner.local_def_index);\n-            let self_type = qself.clean(cx);\n+            let self_type = clean_ty(qself, cx);\n             let should_show_cast = compute_should_show_cast(Some(self_def_id), &trait_, &self_type);\n             Type::QPath {\n                 assoc: Box::new(p.segments.last().expect(\"segments were empty\").clean(cx)),\n@@ -1368,7 +1378,7 @@ fn clean_qpath<'tcx>(hir_ty: &hir::Ty<'tcx>, cx: &mut DocContext<'tcx>) -> Type\n             let trait_ = hir::Path { span, res, segments: &[] }.clean(cx);\n             register_res(cx, trait_.res);\n             let self_def_id = res.opt_def_id();\n-            let self_type = qself.clean(cx);\n+            let self_type = clean_ty(qself, cx);\n             let should_show_cast = compute_should_show_cast(self_def_id, &trait_, &self_type);\n             Type::QPath {\n                 assoc: Box::new(segment.clean(cx)),\n@@ -1435,9 +1445,12 @@ fn maybe_expand_private_type_alias<'tcx>(\n                     _ => None,\n                 });\n                 if let Some(ty) = type_ {\n-                    substs.insert(ty_param_def_id.to_def_id(), SubstParam::Type(ty.clean(cx)));\n+                    substs.insert(ty_param_def_id.to_def_id(), SubstParam::Type(clean_ty(ty, cx)));\n                 } else if let Some(default) = *default {\n-                    substs.insert(ty_param_def_id.to_def_id(), SubstParam::Type(default.clean(cx)));\n+                    substs.insert(\n+                        ty_param_def_id.to_def_id(),\n+                        SubstParam::Type(clean_ty(default, cx)),\n+                    );\n                 }\n                 indices.types += 1;\n             }\n@@ -1464,70 +1477,68 @@ fn maybe_expand_private_type_alias<'tcx>(\n         }\n     }\n \n-    Some(cx.enter_alias(substs, |cx| ty.clean(cx)))\n+    Some(cx.enter_alias(substs, |cx| clean_ty(ty, cx)))\n }\n \n-impl<'tcx> Clean<'tcx, Type> for hir::Ty<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Type {\n-        use rustc_hir::*;\n-\n-        match self.kind {\n-            TyKind::Never => Primitive(PrimitiveType::Never),\n-            TyKind::Ptr(ref m) => RawPointer(m.mutbl, Box::new(m.ty.clean(cx))),\n-            TyKind::Rptr(ref l, ref m) => {\n-                // There are two times a `Fresh` lifetime can be created:\n-                // 1. For `&'_ x`, written by the user. This corresponds to `lower_lifetime` in `rustc_ast_lowering`.\n-                // 2. For `&x` as a parameter to an `async fn`. This corresponds to `elided_ref_lifetime in `rustc_ast_lowering`.\n-                //    See #59286 for more information.\n-                // Ideally we would only hide the `'_` for case 2., but I don't know a way to distinguish it.\n-                // Turning `fn f(&'_ self)` into `fn f(&self)` isn't the worst thing in the world, though;\n-                // there's no case where it could cause the function to fail to compile.\n-                let elided =\n-                    l.is_elided() || matches!(l.name, LifetimeName::Param(_, ParamName::Fresh));\n-                let lifetime = if elided { None } else { Some(l.clean(cx)) };\n-                BorrowedRef { lifetime, mutability: m.mutbl, type_: Box::new(m.ty.clean(cx)) }\n-            }\n-            TyKind::Slice(ty) => Slice(Box::new(ty.clean(cx))),\n-            TyKind::Array(ty, ref length) => {\n-                let length = match length {\n-                    hir::ArrayLen::Infer(_, _) => \"_\".to_string(),\n-                    hir::ArrayLen::Body(anon_const) => {\n-                        let def_id = cx.tcx.hir().local_def_id(anon_const.hir_id);\n-                        // NOTE(min_const_generics): We can't use `const_eval_poly` for constants\n-                        // as we currently do not supply the parent generics to anonymous constants\n-                        // but do allow `ConstKind::Param`.\n-                        //\n-                        // `const_eval_poly` tries to to first substitute generic parameters which\n-                        // results in an ICE while manually constructing the constant and using `eval`\n-                        // does nothing for `ConstKind::Param`.\n-                        let ct = ty::Const::from_anon_const(cx.tcx, def_id);\n-                        let param_env = cx.tcx.param_env(def_id);\n-                        print_const(cx, ct.eval(cx.tcx, param_env))\n-                    }\n-                };\n+pub(crate) fn clean_ty<'tcx>(ty: &hir::Ty<'tcx>, cx: &mut DocContext<'tcx>) -> Type {\n+    use rustc_hir::*;\n \n-                Array(Box::new(ty.clean(cx)), length)\n-            }\n-            TyKind::Tup(tys) => Tuple(tys.iter().map(|x| x.clean(cx)).collect()),\n-            TyKind::OpaqueDef(item_id, _) => {\n-                let item = cx.tcx.hir().item(item_id);\n-                if let hir::ItemKind::OpaqueTy(ref ty) = item.kind {\n-                    ImplTrait(ty.bounds.iter().filter_map(|x| x.clean(cx)).collect())\n-                } else {\n-                    unreachable!()\n+    match ty.kind {\n+        TyKind::Never => Primitive(PrimitiveType::Never),\n+        TyKind::Ptr(ref m) => RawPointer(m.mutbl, Box::new(clean_ty(m.ty, cx))),\n+        TyKind::Rptr(ref l, ref m) => {\n+            // There are two times a `Fresh` lifetime can be created:\n+            // 1. For `&'_ x`, written by the user. This corresponds to `lower_lifetime` in `rustc_ast_lowering`.\n+            // 2. For `&x` as a parameter to an `async fn`. This corresponds to `elided_ref_lifetime in `rustc_ast_lowering`.\n+            //    See #59286 for more information.\n+            // Ideally we would only hide the `'_` for case 2., but I don't know a way to distinguish it.\n+            // Turning `fn f(&'_ self)` into `fn f(&self)` isn't the worst thing in the world, though;\n+            // there's no case where it could cause the function to fail to compile.\n+            let elided =\n+                l.is_elided() || matches!(l.name, LifetimeName::Param(_, ParamName::Fresh));\n+            let lifetime = if elided { None } else { Some(l.clean(cx)) };\n+            BorrowedRef { lifetime, mutability: m.mutbl, type_: Box::new(clean_ty(m.ty, cx)) }\n+        }\n+        TyKind::Slice(ty) => Slice(Box::new(clean_ty(ty, cx))),\n+        TyKind::Array(ty, ref length) => {\n+            let length = match length {\n+                hir::ArrayLen::Infer(_, _) => \"_\".to_string(),\n+                hir::ArrayLen::Body(anon_const) => {\n+                    let def_id = cx.tcx.hir().local_def_id(anon_const.hir_id);\n+                    // NOTE(min_const_generics): We can't use `const_eval_poly` for constants\n+                    // as we currently do not supply the parent generics to anonymous constants\n+                    // but do allow `ConstKind::Param`.\n+                    //\n+                    // `const_eval_poly` tries to to first substitute generic parameters which\n+                    // results in an ICE while manually constructing the constant and using `eval`\n+                    // does nothing for `ConstKind::Param`.\n+                    let ct = ty::Const::from_anon_const(cx.tcx, def_id);\n+                    let param_env = cx.tcx.param_env(def_id);\n+                    print_const(cx, ct.eval(cx.tcx, param_env))\n                 }\n+            };\n+\n+            Array(Box::new(clean_ty(ty, cx)), length)\n+        }\n+        TyKind::Tup(tys) => Tuple(tys.iter().map(|ty| clean_ty(ty, cx)).collect()),\n+        TyKind::OpaqueDef(item_id, _) => {\n+            let item = cx.tcx.hir().item(item_id);\n+            if let hir::ItemKind::OpaqueTy(ref ty) = item.kind {\n+                ImplTrait(ty.bounds.iter().filter_map(|x| x.clean(cx)).collect())\n+            } else {\n+                unreachable!()\n             }\n-            TyKind::Path(_) => clean_qpath(self, cx),\n-            TyKind::TraitObject(bounds, ref lifetime, _) => {\n-                let bounds = bounds.iter().map(|bound| bound.clean(cx)).collect();\n-                let lifetime = if !lifetime.is_elided() { Some(lifetime.clean(cx)) } else { None };\n-                DynTrait(bounds, lifetime)\n-            }\n-            TyKind::BareFn(barefn) => BareFunction(Box::new(barefn.clean(cx))),\n-            // Rustdoc handles `TyKind::Err`s by turning them into `Type::Infer`s.\n-            TyKind::Infer | TyKind::Err => Infer,\n-            TyKind::Typeof(..) => panic!(\"unimplemented type {:?}\", self.kind),\n         }\n+        TyKind::Path(_) => clean_qpath(ty, cx),\n+        TyKind::TraitObject(bounds, ref lifetime, _) => {\n+            let bounds = bounds.iter().map(|bound| bound.clean(cx)).collect();\n+            let lifetime = if !lifetime.is_elided() { Some(lifetime.clean(cx)) } else { None };\n+            DynTrait(bounds, lifetime)\n+        }\n+        TyKind::BareFn(barefn) => BareFunction(Box::new(barefn.clean(cx))),\n+        // Rustdoc handles `TyKind::Err`s by turning them into `Type::Infer`s.\n+        TyKind::Infer | TyKind::Err => Infer,\n+        TyKind::Typeof(..) => panic!(\"unimplemented type {:?}\", ty.kind),\n     }\n }\n \n@@ -1562,7 +1573,11 @@ fn normalize<'tcx>(cx: &mut DocContext<'tcx>, ty: Ty<'_>) -> Option<Ty<'tcx>> {\n     }\n }\n \n-fn clean_ty<'tcx>(this: Ty<'tcx>, cx: &mut DocContext<'tcx>, def_id: Option<DefId>) -> Type {\n+pub(crate) fn clean_middle_ty<'tcx>(\n+    this: Ty<'tcx>,\n+    cx: &mut DocContext<'tcx>,\n+    def_id: Option<DefId>,\n+) -> Type {\n     trace!(\"cleaning type: {:?}\", this);\n     let ty = normalize(cx, this).unwrap_or(this);\n     match *ty.kind() {\n@@ -1573,17 +1588,19 @@ fn clean_ty<'tcx>(this: Ty<'tcx>, cx: &mut DocContext<'tcx>, def_id: Option<DefI\n         ty::Uint(uint_ty) => Primitive(uint_ty.into()),\n         ty::Float(float_ty) => Primitive(float_ty.into()),\n         ty::Str => Primitive(PrimitiveType::Str),\n-        ty::Slice(ty) => Slice(Box::new(ty.clean(cx))),\n+        ty::Slice(ty) => Slice(Box::new(clean_middle_ty(ty, cx, None))),\n         ty::Array(ty, n) => {\n             let mut n = cx.tcx.lift(n).expect(\"array lift failed\");\n             n = n.eval(cx.tcx, ty::ParamEnv::reveal_all());\n             let n = print_const(cx, n);\n-            Array(Box::new(ty.clean(cx)), n)\n-        }\n-        ty::RawPtr(mt) => RawPointer(mt.mutbl, Box::new(mt.ty.clean(cx))),\n-        ty::Ref(r, ty, mutbl) => {\n-            BorrowedRef { lifetime: r.clean(cx), mutability: mutbl, type_: Box::new(ty.clean(cx)) }\n+            Array(Box::new(clean_middle_ty(ty, cx, None)), n)\n         }\n+        ty::RawPtr(mt) => RawPointer(mt.mutbl, Box::new(clean_middle_ty(mt.ty, cx, None))),\n+        ty::Ref(r, ty, mutbl) => BorrowedRef {\n+            lifetime: r.clean(cx),\n+            mutability: mutbl,\n+            type_: Box::new(clean_middle_ty(ty, cx, None)),\n+        },\n         ty::FnDef(..) | ty::FnPtr(_) => {\n             let ty = cx.tcx.lift(this).expect(\"FnPtr lift failed\");\n             let sig = ty.fn_sig(cx.tcx);\n@@ -1660,7 +1677,7 @@ fn clean_ty<'tcx>(this: Ty<'tcx>, cx: &mut DocContext<'tcx>, def_id: Option<DefI\n \n             DynTrait(bounds, lifetime)\n         }\n-        ty::Tuple(t) => Tuple(t.iter().map(|t| t.clean(cx)).collect()),\n+        ty::Tuple(t) => Tuple(t.iter().map(|t| clean_middle_ty(t, cx, None)).collect()),\n \n         ty::Projection(ref data) => clean_projection(*data, cx, def_id),\n \n@@ -1747,17 +1764,11 @@ fn clean_ty<'tcx>(this: Ty<'tcx>, cx: &mut DocContext<'tcx>, def_id: Option<DefI\n     }\n }\n \n-impl<'tcx> Clean<'tcx, Type> for Ty<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Type {\n-        clean_ty(*self, cx, None)\n-    }\n-}\n-\n impl<'tcx> Clean<'tcx, Constant> for ty::Const<'tcx> {\n     fn clean(&self, cx: &mut DocContext<'tcx>) -> Constant {\n         // FIXME: instead of storing the stringified expression, store `self` directly instead.\n         Constant {\n-            type_: self.ty().clean(cx),\n+            type_: clean_middle_ty(self.ty(), cx, None),\n             kind: ConstantKind::TyConst { expr: self.to_string() },\n         }\n     }\n@@ -1766,13 +1777,18 @@ impl<'tcx> Clean<'tcx, Constant> for ty::Const<'tcx> {\n impl<'tcx> Clean<'tcx, Item> for hir::FieldDef<'tcx> {\n     fn clean(&self, cx: &mut DocContext<'tcx>) -> Item {\n         let def_id = cx.tcx.hir().local_def_id(self.hir_id).to_def_id();\n-        clean_field(def_id, self.ident.name, self.ty.clean(cx), cx)\n+        clean_field(def_id, self.ident.name, clean_ty(self.ty, cx), cx)\n     }\n }\n \n impl<'tcx> Clean<'tcx, Item> for ty::FieldDef {\n     fn clean(&self, cx: &mut DocContext<'tcx>) -> Item {\n-        clean_field(self.did, self.name, cx.tcx.type_of(self.did).clean(cx), cx)\n+        clean_field(\n+            self.did,\n+            self.name,\n+            clean_middle_ty(cx.tcx.type_of(self.did), cx, Some(self.did)),\n+            cx,\n+        )\n     }\n }\n \n@@ -1863,10 +1879,10 @@ impl<'tcx> Clean<'tcx, Path> for hir::Path<'tcx> {\n impl<'tcx> Clean<'tcx, GenericArgs> for hir::GenericArgs<'tcx> {\n     fn clean(&self, cx: &mut DocContext<'tcx>) -> GenericArgs {\n         if self.parenthesized {\n-            let output = self.bindings[0].ty().clean(cx);\n+            let output = clean_ty(self.bindings[0].ty(), cx);\n             let output =\n                 if output != Type::Tuple(Vec::new()) { Some(Box::new(output)) } else { None };\n-            let inputs = self.inputs().iter().map(|x| x.clean(cx)).collect::<Vec<_>>().into();\n+            let inputs = self.inputs().iter().map(|x| clean_ty(x, cx)).collect::<Vec<_>>().into();\n             GenericArgs::Parenthesized { inputs, output }\n         } else {\n             let args = self\n@@ -1877,7 +1893,7 @@ impl<'tcx> Clean<'tcx, GenericArgs> for hir::GenericArgs<'tcx> {\n                         GenericArg::Lifetime(lt.clean(cx))\n                     }\n                     hir::GenericArg::Lifetime(_) => GenericArg::Lifetime(Lifetime::elided()),\n-                    hir::GenericArg::Type(ty) => GenericArg::Type(ty.clean(cx)),\n+                    hir::GenericArg::Type(ty) => GenericArg::Type(clean_ty(ty, cx)),\n                     hir::GenericArg::Const(ct) => GenericArg::Const(Box::new(ct.clean(cx))),\n                     hir::GenericArg::Infer(_inf) => GenericArg::Infer,\n                 })\n@@ -1925,19 +1941,19 @@ fn clean_maybe_renamed_item<'tcx>(\n     cx.with_param_env(def_id, |cx| {\n         let kind = match item.kind {\n             ItemKind::Static(ty, mutability, body_id) => {\n-                StaticItem(Static { type_: ty.clean(cx), mutability, expr: Some(body_id) })\n+                StaticItem(Static { type_: clean_ty(ty, cx), mutability, expr: Some(body_id) })\n             }\n             ItemKind::Const(ty, body_id) => ConstantItem(Constant {\n-                type_: ty.clean(cx),\n+                type_: clean_ty(ty, cx),\n                 kind: ConstantKind::Local { body: body_id, def_id },\n             }),\n             ItemKind::OpaqueTy(ref ty) => OpaqueTyItem(OpaqueTy {\n                 bounds: ty.bounds.iter().filter_map(|x| x.clean(cx)).collect(),\n                 generics: ty.generics.clean(cx),\n             }),\n             ItemKind::TyAlias(hir_ty, generics) => {\n-                let rustdoc_ty = hir_ty.clean(cx);\n-                let ty = hir_ty_to_ty(cx.tcx, hir_ty).clean(cx);\n+                let rustdoc_ty = clean_ty(hir_ty, cx);\n+                let ty = clean_middle_ty(hir_ty_to_ty(cx.tcx, hir_ty), cx, None);\n                 TypedefItem(Typedef {\n                     type_: rustdoc_ty,\n                     generics: generics.clean(cx),\n@@ -2023,9 +2039,9 @@ fn clean_impl<'tcx>(\n         build_deref_target_impls(cx, &items, &mut ret);\n     }\n \n-    let for_ = impl_.self_ty.clean(cx);\n+    let for_ = clean_ty(impl_.self_ty, cx);\n     let type_alias = for_.def_id(&cx.cache).and_then(|did| match tcx.def_kind(did) {\n-        DefKind::TyAlias => Some(tcx.type_of(did).clean(cx)),\n+        DefKind::TyAlias => Some(clean_middle_ty(tcx.type_of(did), cx, Some(did))),\n         _ => None,\n     });\n     let mut make_item = |trait_: Option<Path>, for_: Type, items: Vec<Item>| {\n@@ -2234,7 +2250,7 @@ fn clean_maybe_renamed_foreign_item<'tcx>(\n                 ForeignFunctionItem(Function { decl, generics })\n             }\n             hir::ForeignItemKind::Static(ty, mutability) => {\n-                ForeignStaticItem(Static { type_: ty.clean(cx), mutability, expr: None })\n+                ForeignStaticItem(Static { type_: clean_ty(ty, cx), mutability, expr: None })\n             }\n             hir::ForeignItemKind::Type => ForeignTypeItem,\n         };"}, {"sha": "00d62b374845526cb92bf13f1eee68fee006a2a5", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7a9f3078e50fdadc28ac0718dc11c83d62a3fb18/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a9f3078e50fdadc28ac0718dc11c83d62a3fb18/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=7a9f3078e50fdadc28ac0718dc11c83d62a3fb18", "patch": "@@ -2,8 +2,9 @@ use crate::clean::auto_trait::AutoTraitFinder;\n use crate::clean::blanket_impl::BlanketImplFinder;\n use crate::clean::render_macro_matchers::render_macro_matcher;\n use crate::clean::{\n-    inline, Clean, Crate, ExternalCrate, Generic, GenericArg, GenericArgs, ImportSource, Item,\n-    ItemKind, Lifetime, Path, PathSegment, Primitive, PrimitiveType, Type, TypeBinding, Visibility,\n+    clean_middle_ty, inline, Clean, Crate, ExternalCrate, Generic, GenericArg, GenericArgs,\n+    ImportSource, Item, ItemKind, Lifetime, Path, PathSegment, Primitive, PrimitiveType, Type,\n+    TypeBinding, Visibility,\n };\n use crate::core::DocContext;\n use crate::formats::item_type::ItemType;\n@@ -91,7 +92,7 @@ pub(crate) fn substs_to_args<'tcx>(\n             skip_first = false;\n             None\n         }\n-        GenericArgKind::Type(ty) => Some(GenericArg::Type(ty.clean(cx))),\n+        GenericArgKind::Type(ty) => Some(GenericArg::Type(clean_middle_ty(ty, cx, None))),\n         GenericArgKind::Const(ct) => Some(GenericArg::Const(Box::new(ct.clean(cx)))),\n     }));\n     ret_val\n@@ -110,7 +111,7 @@ fn external_generic_args<'tcx>(\n         let inputs =\n             // The trait's first substitution is the one after self, if there is one.\n             match substs.iter().nth(if has_self { 1 } else { 0 }).unwrap().expect_ty().kind() {\n-                ty::Tuple(tys) => tys.iter().map(|t| t.clean(cx)).collect::<Vec<_>>().into(),\n+                ty::Tuple(tys) => tys.iter().map(|t| clean_middle_ty(t, cx, None)).collect::<Vec<_>>().into(),\n                 _ => return GenericArgs::AngleBracketed { args: args.into(), bindings: bindings.into() },\n             };\n         let output = None;"}]}