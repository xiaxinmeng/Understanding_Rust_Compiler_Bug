{"sha": "b0e55a83a82bae26851f442859acace2b94f5028", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwZTU1YTgzYTgyYmFlMjY4NTFmNDQyODU5YWNhY2UyYjk0ZjUwMjg=", "commit": {"author": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2016-08-23T00:56:52Z"}, "committer": {"name": "est31", "email": "MTest31@outlook.com", "date": "2016-12-30T14:15:44Z"}, "message": "Such large. Very 128. Much bits.\n\nThis commit introduces 128-bit integers. Stage 2 builds and produces a working compiler which\nunderstands and supports 128-bit integers throughout.\n\nThe general strategy used is to have rustc_i128 module which provides aliases for iu128, equal to\niu64 in stage9 and iu128 later. Since nowhere in rustc we rely on large numbers being supported,\nthis strategy is good enough to get past the first bootstrap stages to end up with a fully working\n128-bit capable compiler.\n\nIn order for this strategy to work, number of locations had to be changed to use associated\nmax_value/min_value instead of MAX/MIN constants as well as the min_value (or was it max_value?)\nhad to be changed to use xor instead of shift so both 64-bit and 128-bit based consteval works\n(former not necessarily producing the right results in stage1).\n\nThis commit includes manual merge conflict resolution changes from a rebase by @est31.", "tree": {"sha": "504f5ea6eb5cdfd756b3b005d24043f7cc0f4b1e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/504f5ea6eb5cdfd756b3b005d24043f7cc0f4b1e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b0e55a83a82bae26851f442859acace2b94f5028", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b0e55a83a82bae26851f442859acace2b94f5028", "html_url": "https://github.com/rust-lang/rust/commit/b0e55a83a82bae26851f442859acace2b94f5028", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b0e55a83a82bae26851f442859acace2b94f5028/comments", "author": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "html_url": "https://github.com/rust-lang/rust/commit/7f2d2afa9196ba6314a29e58d5324dbd9923c75e"}], "stats": {"total": 1300, "additions": 945, "deletions": 355}, "files": [{"sha": "cd2e8f101814199224c64f1a663c145a96e77bbf", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -153,12 +153,16 @@ clone_impl! { i8 }\n clone_impl! { i16 }\n clone_impl! { i32 }\n clone_impl! { i64 }\n+#[cfg(not(stage0))]\n+clone_impl! { i128 }\n \n clone_impl! { usize }\n clone_impl! { u8 }\n clone_impl! { u16 }\n clone_impl! { u32 }\n clone_impl! { u64 }\n+#[cfg(not(stage0))]\n+clone_impl! { u128 }\n \n clone_impl! { f32 }\n clone_impl! { f64 }"}, {"sha": "a78d27ea3afc1ea251a73e202ee669ed5ffc0158", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -681,6 +681,8 @@ mod impls {\n     partial_eq_impl! {\n         bool char usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64\n     }\n+    #[cfg(not(stage0))]\n+    partial_eq_impl! { u128 i128 }\n \n     macro_rules! eq_impl {\n         ($($t:ty)*) => ($(\n@@ -690,6 +692,8 @@ mod impls {\n     }\n \n     eq_impl! { () bool char usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n+    #[cfg(not(stage0))]\n+    eq_impl! { u128 i128 }\n \n     macro_rules! partial_ord_impl {\n         ($($t:ty)*) => ($(\n@@ -779,6 +783,8 @@ mod impls {\n     }\n \n     ord_impl! { char usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n+    #[cfg(not(stage0))]\n+    ord_impl! { u128 i128 }\n \n     #[unstable(feature = \"never_type_impls\", issue = \"35121\")]\n     impl PartialEq for ! {"}, {"sha": "ccd4343336f5ecde65dab99ea48a7eca99d361b3", "filename": "src/libcore/default.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibcore%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibcore%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdefault.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -144,12 +144,16 @@ default_impl! { u8, 0 }\n default_impl! { u16, 0 }\n default_impl! { u32, 0 }\n default_impl! { u64, 0 }\n+#[cfg(not(stage0))]\n+default_impl! { u128, 0 }\n \n default_impl! { isize, 0 }\n default_impl! { i8, 0 }\n default_impl! { i16, 0 }\n default_impl! { i32, 0 }\n default_impl! { i64, 0 }\n+#[cfg(not(stage0))]\n+default_impl! { i128, 0 }\n \n default_impl! { f32, 0.0f32 }\n default_impl! { f64, 0.0f64 }"}, {"sha": "7b6c2d488896533b936968990dc77cd3e42c42e6", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -30,6 +30,8 @@ trait Int: Zero + PartialEq + PartialOrd + Div<Output=Self> + Rem<Output=Self> +\n     fn to_u16(&self) -> u16;\n     fn to_u32(&self) -> u32;\n     fn to_u64(&self) -> u64;\n+    #[cfg(not(stage0))]\n+    fn to_u128(&self) -> u128;\n }\n \n macro_rules! doit {\n@@ -39,9 +41,13 @@ macro_rules! doit {\n         fn to_u16(&self) -> u16 { *self as u16 }\n         fn to_u32(&self) -> u32 { *self as u32 }\n         fn to_u64(&self) -> u64 { *self as u64 }\n+        #[cfg(not(stage0))]\n+        fn to_u128(&self) -> u128 { *self as u128 }\n     })*)\n }\n doit! { i8 i16 i32 i64 isize u8 u16 u32 u64 usize }\n+#[cfg(not(stage0))]\n+doit! { i128 u128 }\n \n /// A type that represents a specific radix\n #[doc(hidden)]\n@@ -59,11 +65,11 @@ trait GenericRadix {\n \n     /// Format an integer using the radix using a formatter.\n     fn fmt_int<T: Int>(&self, mut x: T, f: &mut fmt::Formatter) -> fmt::Result {\n-        // The radix can be as low as 2, so we need a buffer of at least 64\n+        // The radix can be as low as 2, so we need a buffer of at least 128\n         // characters for a base 2 number.\n         let zero = T::zero();\n         let is_nonnegative = x >= zero;\n-        let mut buf = [0; 64];\n+        let mut buf = [0; 128];\n         let mut curr = buf.len();\n         let base = T::from_u8(self.base());\n         if is_nonnegative {\n@@ -182,6 +188,8 @@ integer! { i8, u8 }\n integer! { i16, u16 }\n integer! { i32, u32 }\n integer! { i64, u64 }\n+#[cfg(not(stage0))]\n+integer! { i128, u128 }\n \n const DEC_DIGITS_LUT: &'static[u8] =\n     b\"0001020304050607080910111213141516171819\\\n@@ -203,14 +211,15 @@ macro_rules! impl_Display {\n                 // convert the negative num to positive by summing 1 to it's 2 complement\n                 (!self.$conv_fn()).wrapping_add(1)\n             };\n-            let mut buf: [u8; 20] = unsafe { mem::uninitialized() };\n+            let mut buf: [u8; 40] = unsafe { mem::uninitialized() };\n             let mut curr = buf.len() as isize;\n             let buf_ptr = buf.as_mut_ptr();\n             let lut_ptr = DEC_DIGITS_LUT.as_ptr();\n \n             unsafe {\n-                // eagerly decode 4 characters at a time\n-                if <$t>::max_value() as u64 >= 10000 {\n+                // need at least 16 bits for the 4-characters-at-a-time to work.\n+                if ::mem::size_of::<$t>() >= 2 {\n+                    // eagerly decode 4 characters at a time\n                     while n >= 10000 {\n                         let rem = (n % 10000) as isize;\n                         n /= 10000;\n@@ -256,6 +265,8 @@ macro_rules! impl_Display {\n \n impl_Display!(i8, u8, i16, u16, i32, u32: to_u32);\n impl_Display!(i64, u64: to_u64);\n+#[cfg(not(stage0))]\n+impl_Display!(i128, u128: to_u128);\n #[cfg(target_pointer_width = \"16\")]\n impl_Display!(isize, usize: to_u16);\n #[cfg(target_pointer_width = \"32\")]"}, {"sha": "92657a6d0b1ca3d3a49bf762d0a629f7a1fc42a8", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -186,6 +186,13 @@ pub trait Hasher {\n     fn write_u64(&mut self, i: u64) {\n         self.write(&unsafe { mem::transmute::<_, [u8; 8]>(i) })\n     }\n+    #[cfg(not(stage0))]\n+    /// Writes a single `u128` into this hasher.\n+    #[inline]\n+    #[unstable(feature = \"i128\", issue = \"35118\")]\n+    fn write_u128(&mut self, i: u128) {\n+        self.write(&unsafe { mem::transmute::<_, [u8; 16]>(i) })\n+    }\n     /// Writes a single `usize` into this hasher.\n     #[inline]\n     #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n@@ -220,6 +227,13 @@ pub trait Hasher {\n     fn write_i64(&mut self, i: i64) {\n         self.write_u64(i as u64)\n     }\n+    #[cfg(not(stage0))]\n+    /// Writes a single `i128` into this hasher.\n+    #[inline]\n+    #[unstable(feature = \"i128\", issue = \"35118\")]\n+    fn write_i128(&mut self, i: i128) {\n+        self.write_u128(i as u128)\n+    }\n     /// Writes a single `isize` into this hasher.\n     #[inline]\n     #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n@@ -362,6 +376,11 @@ mod impls {\n         (i64, write_i64),\n         (isize, write_isize),\n     }\n+    #[cfg(not(stage0))]\n+    impl_write! {\n+        (u128, write_u128),\n+        (i128, write_i128),\n+    }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl Hash for bool {"}, {"sha": "443f4b2ea8e424e8644bf6a4f1a349638d07da35", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -120,12 +120,20 @@ mod uint_macros;\n #[path = \"num/i32.rs\"]   pub mod i32;\n #[path = \"num/i64.rs\"]   pub mod i64;\n \n+// SNAP\n+#[cfg(not(stage0))]\n+#[path = \"num/i128.rs\"]   pub mod i128;\n+\n #[path = \"num/usize.rs\"] pub mod usize;\n #[path = \"num/u8.rs\"]    pub mod u8;\n #[path = \"num/u16.rs\"]   pub mod u16;\n #[path = \"num/u32.rs\"]   pub mod u32;\n #[path = \"num/u64.rs\"]   pub mod u64;\n \n+// SNAP\n+#[cfg(not(stage0))]\n+#[path = \"num/u128.rs\"]   pub mod u128;\n+\n #[path = \"num/f32.rs\"]   pub mod f32;\n #[path = \"num/f64.rs\"]   pub mod f64;\n "}, {"sha": "539ad00bd30e039b2df991c346358452c8dd7f4b", "filename": "src/libcore/nonzero.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibcore%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibcore%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnonzero.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -30,6 +30,10 @@ unsafe impl Zeroable for i32 {}\n unsafe impl Zeroable for u32 {}\n unsafe impl Zeroable for i64 {}\n unsafe impl Zeroable for u64 {}\n+#[cfg(not(stage0))]\n+unsafe impl Zeroable for i128 {}\n+#[cfg(not(stage0))]\n+unsafe impl Zeroable for u128 {}\n \n /// A wrapper type for raw pointers and integers that will never be\n /// NULL or 0 that might allow certain optimizations."}, {"sha": "6268271a1dcc57728d75864e94c06c3e1babf993", "filename": "src/libcore/num/i128.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibcore%2Fnum%2Fi128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibcore%2Fnum%2Fi128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi128.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The 128-bit signed integer type.\n+//!\n+//! *[See also the `i128` primitive type](../../std/primitive.i128.html).*\n+\n+#![unstable(feature = \"i128\", issue=\"35118\")]\n+\n+int_module! { i128 }"}, {"sha": "0f3a5baa2dd9ea85c9d5590e5b8ac72f82e66994", "filename": "src/libcore/num/i16.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibcore%2Fnum%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibcore%2Fnum%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi16.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -14,4 +14,4 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-int_module! { i16, 16 }\n+int_module! { i16 }"}, {"sha": "ea8b3a9145c6e94bddf791917d64288d2d04eefc", "filename": "src/libcore/num/i32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibcore%2Fnum%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibcore%2Fnum%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi32.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -14,4 +14,4 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-int_module! { i32, 32 }\n+int_module! { i32 }"}, {"sha": "aa21b1190aef568f252342cfed8f3dcd965fc7ad", "filename": "src/libcore/num/i64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibcore%2Fnum%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibcore%2Fnum%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi64.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -14,4 +14,4 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-int_module! { i64, 64 }\n+int_module! { i64 }"}, {"sha": "1bed4861594c91bcec80ba9e600bf137c88cc5ac", "filename": "src/libcore/num/i8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibcore%2Fnum%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibcore%2Fnum%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi8.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -14,4 +14,4 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-int_module! { i8, 8 }\n+int_module! { i8 }"}, {"sha": "630fac9d92f0f1ec440978a1464ae1207ec98bc8", "filename": "src/libcore/num/int_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibcore%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibcore%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint_macros.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -10,7 +10,7 @@\n \n #![doc(hidden)]\n \n-macro_rules! int_module { ($T:ident, $bits:expr) => (\n+macro_rules! int_module { ($T:ident) => (\n \n /// The smallest value that can be represented by this integer type.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "e0917f79c43dc83a976e6f8ee45d6a85a2a95706", "filename": "src/libcore/num/isize.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibcore%2Fnum%2Fisize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibcore%2Fnum%2Fisize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fisize.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -14,9 +14,4 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-#[cfg(target_pointer_width = \"16\")]\n-int_module! { isize, 16 }\n-#[cfg(target_pointer_width = \"32\")]\n-int_module! { isize, 32 }\n-#[cfg(target_pointer_width = \"64\")]\n-int_module! { isize, 64 }\n+int_module! { isize }"}, {"sha": "49e366a89760cafaf7449bd725198967a0b9670a", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 98, "deletions": 12, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -145,6 +145,8 @@ macro_rules! zero_one_impl {\n     )*)\n }\n zero_one_impl! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n+#[cfg(not(stage0))]\n+zero_one_impl! { u128 i128 }\n \n macro_rules! zero_one_impl_float {\n     ($($t:ty)*) => ($(\n@@ -191,7 +193,7 @@ macro_rules! int_impl {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub const fn min_value() -> Self {\n-            (-1 as Self) << ($BITS - 1)\n+            !0 ^ ((!0 as $UnsignedT) >> 1) as Self\n         }\n \n         /// Returns the largest value that can be represented by this integer type.\n@@ -1298,6 +1300,16 @@ impl i64 {\n         intrinsics::mul_with_overflow }\n }\n \n+// SNAP\n+#[cfg(not(stage0))]\n+#[lang = \"i128\"]\n+impl i128 {\n+    int_impl! { i128, u128, 128,\n+        intrinsics::add_with_overflow,\n+        intrinsics::sub_with_overflow,\n+        intrinsics::mul_with_overflow }\n+}\n+\n #[cfg(target_pointer_width = \"16\")]\n #[lang = \"isize\"]\n impl isize {\n@@ -2330,6 +2342,20 @@ impl u64 {\n         intrinsics::mul_with_overflow }\n }\n \n+// SNAP\n+#[cfg(not(stage0))]\n+#[lang = \"u128\"]\n+impl u128 {\n+    uint_impl! { u128, 128,\n+        intrinsics::ctpop,\n+        intrinsics::ctlz,\n+        intrinsics::cttz,\n+        intrinsics::bswap,\n+        intrinsics::add_with_overflow,\n+        intrinsics::sub_with_overflow,\n+        intrinsics::mul_with_overflow }\n+}\n+\n #[cfg(target_pointer_width = \"16\")]\n #[lang = \"usize\"]\n impl usize {\n@@ -2543,6 +2569,8 @@ macro_rules! from_str_radix_int_impl {\n     )*}\n }\n from_str_radix_int_impl! { isize i8 i16 i32 i64 usize u8 u16 u32 u64 }\n+#[cfg(not(stage0))]\n+from_str_radix_int_impl! { u128 i128 }\n \n /// The error type returned when a checked integral type conversion fails.\n #[unstable(feature = \"try_from\", issue = \"33417\")]\n@@ -2567,7 +2595,7 @@ impl fmt::Display for TryFromIntError {\n     }\n }\n \n-macro_rules! same_sign_from_int_impl {\n+macro_rules! same_sign_try_from_int_impl {\n     ($storage:ty, $target:ty, $($source:ty),*) => {$(\n         #[unstable(feature = \"try_from\", issue = \"33417\")]\n         impl TryFrom<$source> for $target {\n@@ -2586,16 +2614,30 @@ macro_rules! same_sign_from_int_impl {\n     )*}\n }\n \n-same_sign_from_int_impl!(u64, u8, u8, u16, u32, u64, usize);\n-same_sign_from_int_impl!(i64, i8, i8, i16, i32, i64, isize);\n-same_sign_from_int_impl!(u64, u16, u8, u16, u32, u64, usize);\n-same_sign_from_int_impl!(i64, i16, i8, i16, i32, i64, isize);\n-same_sign_from_int_impl!(u64, u32, u8, u16, u32, u64, usize);\n-same_sign_from_int_impl!(i64, i32, i8, i16, i32, i64, isize);\n-same_sign_from_int_impl!(u64, u64, u8, u16, u32, u64, usize);\n-same_sign_from_int_impl!(i64, i64, i8, i16, i32, i64, isize);\n-same_sign_from_int_impl!(u64, usize, u8, u16, u32, u64, usize);\n-same_sign_from_int_impl!(i64, isize, i8, i16, i32, i64, isize);\n+#[cfg(not(stage0))]\n+same_sign_try_from_int_impl!(u128, u8, u8, u16, u32, u64, u128, usize);\n+#[cfg(not(stage0))]\n+same_sign_try_from_int_impl!(i128, i8, i8, i16, i32, i64, i128, isize);\n+#[cfg(not(stage0))]\n+same_sign_try_from_int_impl!(u128, u16, u8, u16, u32, u64, u128, usize);\n+#[cfg(not(stage0))]\n+same_sign_try_from_int_impl!(i128, i16, i8, i16, i32, i64, i128, isize);\n+#[cfg(not(stage0))]\n+same_sign_try_from_int_impl!(u128, u32, u8, u16, u32, u64, u128, usize);\n+#[cfg(not(stage0))]\n+same_sign_try_from_int_impl!(i128, i32, i8, i16, i32, i64, i128, isize);\n+#[cfg(not(stage0))]\n+same_sign_try_from_int_impl!(u128, u64, u8, u16, u32, u64, u128, usize);\n+#[cfg(not(stage0))]\n+same_sign_try_from_int_impl!(i128, i64, i8, i16, i32, i64, i128, isize);\n+#[cfg(not(stage0))]\n+same_sign_try_from_int_impl!(u128, u128, u8, u16, u32, u64, u128, usize);\n+#[cfg(not(stage0))]\n+same_sign_try_from_int_impl!(i128, i128, i8, i16, i32, i64, i128, isize);\n+#[cfg(not(stage0))]\n+same_sign_try_from_int_impl!(u128, usize, u8, u16, u32, u64, u128, usize);\n+#[cfg(not(stage0))]\n+same_sign_try_from_int_impl!(i128, isize, i8, i16, i32, i64, i128, isize);\n \n macro_rules! cross_sign_from_int_impl {\n     ($unsigned:ty, $($signed:ty),*) => {$(\n@@ -2629,12 +2671,30 @@ macro_rules! cross_sign_from_int_impl {\n     )*}\n }\n \n+#[cfg(stage0)]\n cross_sign_from_int_impl!(u8, i8, i16, i32, i64, isize);\n+#[cfg(stage0)]\n cross_sign_from_int_impl!(u16, i8, i16, i32, i64, isize);\n+#[cfg(stage0)]\n cross_sign_from_int_impl!(u32, i8, i16, i32, i64, isize);\n+#[cfg(stage0)]\n cross_sign_from_int_impl!(u64, i8, i16, i32, i64, isize);\n+#[cfg(stage0)]\n cross_sign_from_int_impl!(usize, i8, i16, i32, i64, isize);\n \n+#[cfg(not(stage0))]\n+cross_sign_from_int_impl!(u8, i8, i16, i32, i64, i128, isize);\n+#[cfg(not(stage0))]\n+cross_sign_from_int_impl!(u16, i8, i16, i32, i64, i128, isize);\n+#[cfg(not(stage0))]\n+cross_sign_from_int_impl!(u32, i8, i16, i32, i64, i128, isize);\n+#[cfg(not(stage0))]\n+cross_sign_from_int_impl!(u64, i8, i16, i32, i64, i128, isize);\n+#[cfg(not(stage0))]\n+cross_sign_from_int_impl!(u128, i8, i16, i32, i64, i128, isize);\n+#[cfg(not(stage0))]\n+cross_sign_from_int_impl!(usize, i8, i16, i32, i64, i128, isize);\n+\n #[doc(hidden)]\n trait FromStrRadixHelper: PartialOrd + Copy {\n     fn min_value() -> Self;\n@@ -2662,6 +2722,8 @@ macro_rules! doit {\n     })*)\n }\n doit! { i8 i16 i32 i64 isize u8 u16 u32 u64 usize }\n+#[cfg(not(stage0))]\n+doit! { i128 u128 }\n \n fn from_str_radix<T: FromStrRadixHelper>(src: &str, radix: u32) -> Result<T, ParseIntError> {\n     use self::IntErrorKind::*;\n@@ -2795,27 +2857,51 @@ macro_rules! impl_from {\n impl_from! { u8, u16 }\n impl_from! { u8, u32 }\n impl_from! { u8, u64 }\n+#[cfg(not(stage0))]\n+impl_from! { u8, u128 }\n impl_from! { u8, usize }\n impl_from! { u16, u32 }\n impl_from! { u16, u64 }\n+#[cfg(not(stage0))]\n+impl_from! { u16, u128 }\n impl_from! { u32, u64 }\n+#[cfg(not(stage0))]\n+impl_from! { u32, u128 }\n+#[cfg(not(stage0))]\n+impl_from! { u64, u128 }\n \n // Signed -> Signed\n impl_from! { i8, i16 }\n impl_from! { i8, i32 }\n impl_from! { i8, i64 }\n+#[cfg(not(stage0))]\n+impl_from! { i8, i128 }\n impl_from! { i8, isize }\n impl_from! { i16, i32 }\n impl_from! { i16, i64 }\n+#[cfg(not(stage0))]\n+impl_from! { i16, i128 }\n impl_from! { i32, i64 }\n+#[cfg(not(stage0))]\n+impl_from! { i32, i128 }\n+#[cfg(not(stage0))]\n+impl_from! { i64, i128 }\n \n // Unsigned -> Signed\n impl_from! { u8, i16 }\n impl_from! { u8, i32 }\n impl_from! { u8, i64 }\n+#[cfg(not(stage0))]\n+impl_from! { u8, i128 }\n impl_from! { u16, i32 }\n impl_from! { u16, i64 }\n+#[cfg(not(stage0))]\n+impl_from! { u16, i128 }\n impl_from! { u32, i64 }\n+#[cfg(not(stage0))]\n+impl_from! { u32, i128 }\n+#[cfg(not(stage0))]\n+impl_from! { u64, i128 }\n \n // Note: integers can only be represented with full precision in a float if\n // they fit in the significand, which is 24 bits in f32 and 53 bits in f64."}, {"sha": "77291f687255e9fbd2961aa3911a27af4e509394", "filename": "src/libcore/num/u128.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibcore%2Fnum%2Fu128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibcore%2Fnum%2Fu128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu128.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The 128-bit unsigned integer type.\n+//!\n+//! *[See also the `u128` primitive type](../../std/primitive.u128.html).*\n+\n+#![unstable(feature = \"i128\", issue=\"35118\")]\n+uint_module! { u128 }"}, {"sha": "9c318216f1fbaf1bcdee03934e30faf5eae60eee", "filename": "src/libcore/num/u16.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibcore%2Fnum%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibcore%2Fnum%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu16.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -14,4 +14,4 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-uint_module! { u16, 16 }\n+uint_module! { u16 }"}, {"sha": "84367c2073833c3c5e55d23214c3e7d751414e2b", "filename": "src/libcore/num/u32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibcore%2Fnum%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibcore%2Fnum%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu32.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -14,4 +14,4 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-uint_module! { u32, 32 }\n+uint_module! { u32 }"}, {"sha": "cc48a28b22f69fb79fcb795fd1f6c1392c4063d3", "filename": "src/libcore/num/u64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibcore%2Fnum%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibcore%2Fnum%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu64.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -14,4 +14,4 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-uint_module! { u64, 64 }\n+uint_module! { u64 }"}, {"sha": "6c0daa7763ae1ed45ed46ae997e76115710b704d", "filename": "src/libcore/num/u8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibcore%2Fnum%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibcore%2Fnum%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu8.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -14,4 +14,4 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-uint_module! { u8, 8 }\n+uint_module! { u8 }"}, {"sha": "a3a2dc73e9c8e2ee70604b1e2c7ccdaae25901a5", "filename": "src/libcore/num/uint_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibcore%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibcore%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint_macros.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -10,7 +10,7 @@\n \n #![doc(hidden)]\n \n-macro_rules! uint_module { ($T:ident, $bits:expr) => (\n+macro_rules! uint_module { ($T:ident) => (\n \n /// The smallest value that can be represented by this integer type.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "0b6f1c73c5834c32e496b31d0ad096b7cce02fc4", "filename": "src/libcore/num/usize.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibcore%2Fnum%2Fusize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibcore%2Fnum%2Fusize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fusize.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -14,9 +14,4 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-#[cfg(target_pointer_width = \"16\")]\n-uint_module! { usize, 16 }\n-#[cfg(target_pointer_width = \"32\")]\n-uint_module! { usize, 32 }\n-#[cfg(target_pointer_width = \"64\")]\n-uint_module! { usize, 64 }\n+uint_module! { usize }"}, {"sha": "40d941a8b27e03d84e34cf8fbc06663439718e7d", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -268,6 +268,8 @@ macro_rules! add_impl {\n }\n \n add_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n+#[cfg(not(stage0))]\n+add_impl! { u128 i128 }\n \n /// The `Sub` trait is used to specify the functionality of `-`.\n ///\n@@ -341,6 +343,8 @@ macro_rules! sub_impl {\n }\n \n sub_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n+#[cfg(not(stage0))]\n+sub_impl! { u128 i128 }\n \n /// The `Mul` trait is used to specify the functionality of `*`.\n ///\n@@ -463,6 +467,8 @@ macro_rules! mul_impl {\n }\n \n mul_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n+#[cfg(not(stage0))]\n+mul_impl! { u128 i128 }\n \n /// The `Div` trait is used to specify the functionality of `/`.\n ///\n@@ -592,6 +598,8 @@ macro_rules! div_impl_integer {\n }\n \n div_impl_integer! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n+#[cfg(not(stage0))]\n+div_impl_integer! { u128 i128 }\n \n macro_rules! div_impl_float {\n     ($($t:ty)*) => ($(\n@@ -671,6 +679,9 @@ macro_rules! rem_impl_integer {\n }\n \n rem_impl_integer! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n+#[cfg(not(stage0))]\n+rem_impl_integer! { u128 i128 }\n+\n \n macro_rules! rem_impl_float {\n     ($($t:ty)*) => ($(\n@@ -766,6 +777,8 @@ macro_rules! neg_impl_unsigned {\n \n // neg_impl_unsigned! { usize u8 u16 u32 u64 }\n neg_impl_numeric! { isize i8 i16 i32 i64 f32 f64 }\n+#[cfg(not(stage0))]\n+neg_impl_numeric! { i128 }\n \n /// The `Not` trait is used to specify the functionality of unary `!`.\n ///\n@@ -824,6 +837,8 @@ macro_rules! not_impl {\n }\n \n not_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n+#[cfg(not(stage0))]\n+not_impl! { u128 i128 }\n \n /// The `BitAnd` trait is used to specify the functionality of `&`.\n ///\n@@ -907,6 +922,8 @@ macro_rules! bitand_impl {\n }\n \n bitand_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n+#[cfg(not(stage0))]\n+bitand_impl! { u128 i128 }\n \n /// The `BitOr` trait is used to specify the functionality of `|`.\n ///\n@@ -990,6 +1007,8 @@ macro_rules! bitor_impl {\n }\n \n bitor_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n+#[cfg(not(stage0))]\n+bitor_impl! { u128 i128 }\n \n /// The `BitXor` trait is used to specify the functionality of `^`.\n ///\n@@ -1076,6 +1095,8 @@ macro_rules! bitxor_impl {\n }\n \n bitxor_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n+#[cfg(not(stage0))]\n+bitxor_impl! { u128 i128 }\n \n /// The `Shl` trait is used to specify the functionality of `<<`.\n ///\n@@ -1166,17 +1187,23 @@ macro_rules! shl_impl_all {\n         shl_impl! { $t, u16 }\n         shl_impl! { $t, u32 }\n         shl_impl! { $t, u64 }\n+        #[cfg(not(stage0))]\n+        shl_impl! { $t, u128 }\n         shl_impl! { $t, usize }\n \n         shl_impl! { $t, i8 }\n         shl_impl! { $t, i16 }\n         shl_impl! { $t, i32 }\n         shl_impl! { $t, i64 }\n+        #[cfg(not(stage0))]\n+        shl_impl! { $t, i128 }\n         shl_impl! { $t, isize }\n     )*)\n }\n \n shl_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n+#[cfg(not(stage0))]\n+shl_impl_all! { u128 i128 }\n \n /// The `Shr` trait is used to specify the functionality of `>>`.\n ///\n@@ -1267,17 +1294,23 @@ macro_rules! shr_impl_all {\n         shr_impl! { $t, u16 }\n         shr_impl! { $t, u32 }\n         shr_impl! { $t, u64 }\n+        #[cfg(not(stage0))]\n+        shr_impl! { $t, u128 }\n         shr_impl! { $t, usize }\n \n         shr_impl! { $t, i8 }\n         shr_impl! { $t, i16 }\n         shr_impl! { $t, i32 }\n         shr_impl! { $t, i64 }\n+        #[cfg(not(stage0))]\n+        shr_impl! { $t, i128 }\n         shr_impl! { $t, isize }\n     )*)\n }\n \n shr_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n+#[cfg(not(stage0))]\n+shr_impl_all! { u128 i128 }\n \n /// The `AddAssign` trait is used to specify the functionality of `+=`.\n ///\n@@ -1334,6 +1367,8 @@ macro_rules! add_assign_impl {\n }\n \n add_assign_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n+#[cfg(not(stage0))]\n+add_assign_impl! { u128 i128 }\n \n /// The `SubAssign` trait is used to specify the functionality of `-=`.\n ///\n@@ -1390,6 +1425,8 @@ macro_rules! sub_assign_impl {\n }\n \n sub_assign_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n+#[cfg(not(stage0))]\n+sub_assign_impl! { u128 i128 }\n \n /// The `MulAssign` trait is used to specify the functionality of `*=`.\n ///\n@@ -1435,6 +1472,8 @@ macro_rules! mul_assign_impl {\n }\n \n mul_assign_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n+#[cfg(not(stage0))]\n+mul_assign_impl! { u128 i128 }\n \n /// The `DivAssign` trait is used to specify the functionality of `/=`.\n ///\n@@ -1479,6 +1518,8 @@ macro_rules! div_assign_impl {\n }\n \n div_assign_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n+#[cfg(not(stage0))]\n+div_assign_impl! { u128 i128 }\n \n /// The `RemAssign` trait is used to specify the functionality of `%=`.\n ///\n@@ -1523,6 +1564,8 @@ macro_rules! rem_assign_impl {\n }\n \n rem_assign_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n+#[cfg(not(stage0))]\n+rem_assign_impl! { u128 i128 }\n \n /// The `BitAndAssign` trait is used to specify the functionality of `&=`.\n ///\n@@ -1609,6 +1652,8 @@ macro_rules! bitand_assign_impl {\n }\n \n bitand_assign_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n+#[cfg(not(stage0))]\n+bitand_assign_impl! { u128 i128 }\n \n /// The `BitOrAssign` trait is used to specify the functionality of `|=`.\n ///\n@@ -1653,6 +1698,8 @@ macro_rules! bitor_assign_impl {\n }\n \n bitor_assign_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n+#[cfg(not(stage0))]\n+bitor_assign_impl! { u128 i128 }\n \n /// The `BitXorAssign` trait is used to specify the functionality of `^=`.\n ///\n@@ -1697,6 +1744,8 @@ macro_rules! bitxor_assign_impl {\n }\n \n bitxor_assign_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n+#[cfg(not(stage0))]\n+bitxor_assign_impl! { u128 i128 }\n \n /// The `ShlAssign` trait is used to specify the functionality of `<<=`.\n ///\n@@ -1749,17 +1798,23 @@ macro_rules! shl_assign_impl_all {\n         shl_assign_impl! { $t, u16 }\n         shl_assign_impl! { $t, u32 }\n         shl_assign_impl! { $t, u64 }\n+        #[cfg(not(stage0))]\n+        shl_assign_impl! { $t, u128 }\n         shl_assign_impl! { $t, usize }\n \n         shl_assign_impl! { $t, i8 }\n         shl_assign_impl! { $t, i16 }\n         shl_assign_impl! { $t, i32 }\n         shl_assign_impl! { $t, i64 }\n+        #[cfg(not(stage0))]\n+        shl_assign_impl! { $t, i128 }\n         shl_assign_impl! { $t, isize }\n     )*)\n }\n \n shl_assign_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n+#[cfg(not(stage0))]\n+shl_assign_impl_all! { u128 i128 }\n \n /// The `ShrAssign` trait is used to specify the functionality of `>>=`.\n ///\n@@ -1812,17 +1867,23 @@ macro_rules! shr_assign_impl_all {\n         shr_assign_impl! { $t, u16 }\n         shr_assign_impl! { $t, u32 }\n         shr_assign_impl! { $t, u64 }\n+        #[cfg(not(stage0))]\n+        shr_assign_impl! { $t, u128 }\n         shr_assign_impl! { $t, usize }\n \n         shr_assign_impl! { $t, i8 }\n         shr_assign_impl! { $t, i16 }\n         shr_assign_impl! { $t, i32 }\n         shr_assign_impl! { $t, i64 }\n+        #[cfg(not(stage0))]\n+        shr_assign_impl! { $t, i128 }\n         shr_assign_impl! { $t, isize }\n     )*)\n }\n \n shr_assign_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n+#[cfg(not(stage0))]\n+shr_assign_impl_all! { u128 i128 }\n \n /// The `Index` trait is used to specify the functionality of indexing operations\n /// like `container[index]` when used in an immutable context."}, {"sha": "ca26ddbe5a0eef18aafe20045454e57662b22b33", "filename": "src/libproc_macro/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibproc_macro%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibproc_macro%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2FCargo.toml?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -9,3 +9,4 @@ crate-type = [\"dylib\"]\n \n [dependencies]\n syntax = { path = \"../libsyntax\" }\n+rustc_i128 = { path = \"../librustc_i128\" }"}, {"sha": "51494885e73696addcd84337051035bbbfdbef5f", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -20,6 +20,7 @@ rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_llvm = { path = \"../librustc_llvm\" }\n+rustc_i128 = { path = \"../librustc_i128\" }\n serialize = { path = \"../libserialize\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "73ec9d8f8c8805ee0f56350277a48ed0515fb5a0", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -62,6 +62,9 @@ extern crate rustc_errors as errors;\n \n extern crate serialize as rustc_serialize; // used by deriving\n \n+// SNAP:\n+extern crate rustc_i128;\n+\n #[cfg(test)]\n extern crate test;\n "}, {"sha": "cd7859af8ee7b526a96e1d1776d4ef4a3641f89a", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -260,11 +260,13 @@ language_item_table! {\n     I16ImplItem,                     \"i16\",                     i16_impl;\n     I32ImplItem,                     \"i32\",                     i32_impl;\n     I64ImplItem,                     \"i64\",                     i64_impl;\n+    I128ImplItem,                     \"i128\",                   i128_impl;\n     IsizeImplItem,                   \"isize\",                   isize_impl;\n     U8ImplItem,                      \"u8\",                      u8_impl;\n     U16ImplItem,                     \"u16\",                     u16_impl;\n     U32ImplItem,                     \"u32\",                     u32_impl;\n     U64ImplItem,                     \"u64\",                     u64_impl;\n+    U128ImplItem,                    \"u128\",                    u128_impl;\n     UsizeImplItem,                   \"usize\",                   usize_impl;\n     F32ImplItem,                     \"f32\",                     f32_impl;\n     F64ImplItem,                     \"f64\",                     f64_impl;"}, {"sha": "380c5b0eb6f3b5bca9cd6ee080c1fc07b88c073b", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -194,11 +194,13 @@ pub struct CommonTypes<'tcx> {\n     pub i16: Ty<'tcx>,\n     pub i32: Ty<'tcx>,\n     pub i64: Ty<'tcx>,\n+    pub i128: Ty<'tcx>,\n     pub usize: Ty<'tcx>,\n     pub u8: Ty<'tcx>,\n     pub u16: Ty<'tcx>,\n     pub u32: Ty<'tcx>,\n     pub u64: Ty<'tcx>,\n+    pub u128: Ty<'tcx>,\n     pub f32: Ty<'tcx>,\n     pub f64: Ty<'tcx>,\n     pub never: Ty<'tcx>,\n@@ -359,11 +361,13 @@ impl<'tcx> CommonTypes<'tcx> {\n             i16: mk(TyInt(ast::IntTy::I16)),\n             i32: mk(TyInt(ast::IntTy::I32)),\n             i64: mk(TyInt(ast::IntTy::I64)),\n+            i128: mk(TyInt(ast::IntTy::I128)),\n             usize: mk(TyUint(ast::UintTy::Us)),\n             u8: mk(TyUint(ast::UintTy::U8)),\n             u16: mk(TyUint(ast::UintTy::U16)),\n             u32: mk(TyUint(ast::UintTy::U32)),\n             u64: mk(TyUint(ast::UintTy::U64)),\n+            u128: mk(TyUint(ast::UintTy::U128)),\n             f32: mk(TyFloat(ast::FloatTy::F32)),\n             f64: mk(TyFloat(ast::FloatTy::F64)),\n         }\n@@ -1304,6 +1308,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             ast::IntTy::I16  => self.types.i16,\n             ast::IntTy::I32  => self.types.i32,\n             ast::IntTy::I64  => self.types.i64,\n+            ast::IntTy::I128  => self.types.i128,\n         }\n     }\n \n@@ -1314,6 +1319,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             ast::UintTy::U16  => self.types.u16,\n             ast::UintTy::U32  => self.types.u32,\n             ast::UintTy::U64  => self.types.u64,\n+            ast::UintTy::U128  => self.types.u128,\n         }\n     }\n "}, {"sha": "67856cecad1ee3e4121f761ad89718f05a7f6f56", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 30, "deletions": 15, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -20,6 +20,7 @@ use ty::{self, Ty, TyCtxt, TypeFoldable};\n use syntax::ast::{FloatTy, IntTy, UintTy};\n use syntax::attr;\n use syntax_pos::DUMMY_SP;\n+use rustc_i128::{i128, u128};\n \n use std::cmp;\n use std::fmt;\n@@ -35,6 +36,7 @@ pub struct TargetDataLayout {\n     pub i16_align: Align,\n     pub i32_align: Align,\n     pub i64_align: Align,\n+    pub i128_align: Align,\n     pub f32_align: Align,\n     pub f64_align: Align,\n     pub pointer_size: Size,\n@@ -55,6 +57,8 @@ impl Default for TargetDataLayout {\n             i16_align: Align::from_bits(16, 16).unwrap(),\n             i32_align: Align::from_bits(32, 32).unwrap(),\n             i64_align: Align::from_bits(32, 64).unwrap(),\n+            // FIXME: i128 is correct?\n+            i128_align: Align::from_bits(64, 128).unwrap(),\n             f32_align: Align::from_bits(32, 32).unwrap(),\n             f64_align: Align::from_bits(64, 64).unwrap(),\n             pointer_size: Size::from_bits(64),\n@@ -117,6 +121,7 @@ impl TargetDataLayout {\n                         Ok(16) => &mut dl.i16_align,\n                         Ok(32) => &mut dl.i32_align,\n                         Ok(64) => &mut dl.i64_align,\n+                        Ok(128) => &mut dl.i128_align,\n                         Ok(_) => continue,\n                         Err(_) => {\n                             size(&s[1..], \"i\"); // For the user error.\n@@ -325,7 +330,8 @@ pub enum Integer {\n     I8,\n     I16,\n     I32,\n-    I64\n+    I64,\n+    I128,\n }\n \n impl Integer {\n@@ -368,22 +374,24 @@ impl Integer {\n     /// Find the smallest Integer type which can represent the signed value.\n     pub fn fit_signed(x: i64) -> Integer {\n         match x {\n-            -0x0000_0001...0x0000_0000 => I1,\n-            -0x0000_0080...0x0000_007f => I8,\n-            -0x0000_8000...0x0000_7fff => I16,\n-            -0x8000_0000...0x7fff_ffff => I32,\n-            _ => I64\n+            -0x0000_0000_0000_0001...0x0000_0000_0000_0000 => I1,\n+            -0x0000_0000_0000_0080...0x0000_0000_0000_007f => I8,\n+            -0x0000_0000_0000_8000...0x0000_0000_0000_7fff => I16,\n+            -0x0000_0000_8000_0000...0x0000_0000_7fff_ffff => I32,\n+            -0x8000_0000_0000_0000...0x7fff_ffff_ffff_ffff => I64,\n+            _ => I128\n         }\n     }\n \n     /// Find the smallest Integer type which can represent the unsigned value.\n     pub fn fit_unsigned(x: u64) -> Integer {\n         match x {\n-            0...0x0000_0001 => I1,\n-            0...0x0000_00ff => I8,\n-            0...0x0000_ffff => I16,\n-            0...0xffff_ffff => I32,\n-            _ => I64\n+            0...0x0000_0000_0000_0001 => I1,\n+            0...0x0000_0000_0000_00ff => I8,\n+            0...0x0000_0000_0000_ffff => I16,\n+            0...0x0000_0000_ffff_ffff => I32,\n+            0...0xffff_ffff_ffff_ffff => I64,\n+            _ => I128,\n         }\n     }\n \n@@ -406,6 +414,7 @@ impl Integer {\n             attr::SignedInt(IntTy::I16) | attr::UnsignedInt(UintTy::U16) => I16,\n             attr::SignedInt(IntTy::I32) | attr::UnsignedInt(UintTy::U32) => I32,\n             attr::SignedInt(IntTy::I64) | attr::UnsignedInt(UintTy::U64) => I64,\n+            attr::SignedInt(IntTy::I128) | attr::UnsignedInt(UintTy::U128) => I128,\n             attr::SignedInt(IntTy::Is) | attr::UnsignedInt(UintTy::Us) => {\n                 dl.ptr_sized_integer()\n             }\n@@ -486,6 +495,7 @@ impl Primitive {\n             Int(I16) => Size::from_bits(16),\n             Int(I32) | F32 => Size::from_bits(32),\n             Int(I64) | F64 => Size::from_bits(64),\n+            Int(I128) => Size::from_bits(128),\n             Pointer => dl.pointer_size\n         }\n     }\n@@ -497,6 +507,7 @@ impl Primitive {\n             Int(I16) => dl.i16_align,\n             Int(I32) => dl.i32_align,\n             Int(I64) => dl.i64_align,\n+            Int(I128) => dl.i128_align,\n             F32 => dl.f32_align,\n             F64 => dl.f64_align,\n             Pointer => dl.pointer_align\n@@ -1175,19 +1186,23 @@ impl<'a, 'gcx, 'tcx> Layout {\n \n                 if def.is_enum() && def.variants.iter().all(|v| v.fields.is_empty()) {\n                     // All bodies empty -> intlike\n-                    let (mut min, mut max, mut non_zero) = (i64::MAX, i64::MIN, true);\n+                    let (mut min, mut max, mut non_zero) = (i128::max_value(), i128::min_value(), true);\n                     for v in &def.variants {\n-                        let x = v.disr_val.to_u64_unchecked() as i64;\n+                        let x = v.disr_val.to_u128_unchecked() as i128;\n                         if x == 0 { non_zero = false; }\n                         if x < min { min = x; }\n                         if x > max { max = x; }\n                     }\n \n-                    let (discr, signed) = Integer::repr_discr(tcx, ty, &hints[..], min, max);\n+                    // FIXME: should take i128?\n+                    let (discr, signed) = Integer::repr_discr(tcx, ty, &hints[..],\n+                                                              min as i64,\n+                                                              max as i64);\n                     return success(CEnum {\n                         discr: discr,\n                         signed: signed,\n                         non_zero: non_zero,\n+                        // FIXME: should be u128?\n                         min: min as u64,\n                         max: max as u64\n                     });\n@@ -1232,7 +1247,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                 // non-empty body, explicit discriminants should have\n                 // been rejected by a checker before this point.\n                 for (i, v) in def.variants.iter().enumerate() {\n-                    if i as u64 != v.disr_val.to_u64_unchecked() {\n+                    if i as u128 != v.disr_val.to_u128_unchecked() {\n                         bug!(\"non-C-like enum {} with specified discriminants\",\n                             tcx.item_path_str(def.did));\n                     }"}, {"sha": "0b45ff94a93123bffad6a5c2f6ba43626a3bd439", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -51,11 +51,13 @@ impl IntTypeExt for attr::IntType {\n             SignedInt(ast::IntTy::I16)     => tcx.types.i16,\n             SignedInt(ast::IntTy::I32)     => tcx.types.i32,\n             SignedInt(ast::IntTy::I64)     => tcx.types.i64,\n+            SignedInt(ast::IntTy::I128)     => tcx.types.i128,\n             SignedInt(ast::IntTy::Is)   => tcx.types.isize,\n             UnsignedInt(ast::UintTy::U8)    => tcx.types.u8,\n             UnsignedInt(ast::UintTy::U16)   => tcx.types.u16,\n             UnsignedInt(ast::UintTy::U32)   => tcx.types.u32,\n             UnsignedInt(ast::UintTy::U64)   => tcx.types.u64,\n+            UnsignedInt(ast::UintTy::U128)   => tcx.types.u128,\n             UnsignedInt(ast::UintTy::Us) => tcx.types.usize,\n         }\n     }\n@@ -66,6 +68,7 @@ impl IntTypeExt for attr::IntType {\n             SignedInt(ast::IntTy::I16)   => ConstInt::I16(0),\n             SignedInt(ast::IntTy::I32)   => ConstInt::I32(0),\n             SignedInt(ast::IntTy::I64)   => ConstInt::I64(0),\n+            SignedInt(ast::IntTy::I128)   => ConstInt::I128(0),\n             SignedInt(ast::IntTy::Is) => match tcx.sess.target.int_type {\n                 ast::IntTy::I16 => ConstInt::Isize(ConstIsize::Is16(0)),\n                 ast::IntTy::I32 => ConstInt::Isize(ConstIsize::Is32(0)),\n@@ -76,6 +79,7 @@ impl IntTypeExt for attr::IntType {\n             UnsignedInt(ast::UintTy::U16) => ConstInt::U16(0),\n             UnsignedInt(ast::UintTy::U32) => ConstInt::U32(0),\n             UnsignedInt(ast::UintTy::U64) => ConstInt::U64(0),\n+            UnsignedInt(ast::UintTy::U128) => ConstInt::U128(0),\n             UnsignedInt(ast::UintTy::Us) => match tcx.sess.target.uint_type {\n                 ast::UintTy::U16 => ConstInt::Usize(ConstUsize::Us16(0)),\n                 ast::UintTy::U32 => ConstInt::Usize(ConstUsize::Us32(0)),\n@@ -91,11 +95,13 @@ impl IntTypeExt for attr::IntType {\n             (SignedInt(ast::IntTy::I16), ConstInt::I16(_)) => {},\n             (SignedInt(ast::IntTy::I32), ConstInt::I32(_)) => {},\n             (SignedInt(ast::IntTy::I64), ConstInt::I64(_)) => {},\n+            (SignedInt(ast::IntTy::I128), ConstInt::I128(_)) => {},\n             (SignedInt(ast::IntTy::Is), ConstInt::Isize(_)) => {},\n             (UnsignedInt(ast::UintTy::U8), ConstInt::U8(_)) => {},\n             (UnsignedInt(ast::UintTy::U16), ConstInt::U16(_)) => {},\n             (UnsignedInt(ast::UintTy::U32), ConstInt::U32(_)) => {},\n             (UnsignedInt(ast::UintTy::U64), ConstInt::U64(_)) => {},\n+            (UnsignedInt(ast::UintTy::U128), ConstInt::U128(_)) => {},\n             (UnsignedInt(ast::UintTy::Us), ConstInt::Usize(_)) => {},\n             _ => bug!(\"disr type mismatch: {:?} vs {:?}\", self, val),\n         }"}, {"sha": "7148e181bbd6d8aa0f8be0f0748b71f7bade0681", "filename": "src/librustc_const_eval/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_const_eval%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_const_eval%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2FCargo.toml?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -19,4 +19,5 @@ rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n syntax = { path = \"../libsyntax\" }\n graphviz = { path = \"../libgraphviz\" }\n-syntax_pos = { path = \"../libsyntax_pos\" }\n\\ No newline at end of file\n+syntax_pos = { path = \"../libsyntax_pos\" }\n+rustc_i128 = { path = \"../librustc_i128\" }"}, {"sha": "c736b4865e73834ac605581ae7f5d4f89f5b39d6", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 52, "deletions": 37, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -43,6 +43,8 @@ use std::cmp::Ordering;\n use rustc_const_math::*;\n use rustc_errors::DiagnosticBuilder;\n \n+use rustc_i128::{i128, u128};\n+\n macro_rules! math {\n     ($e:expr, $op:expr) => {\n         match $op {\n@@ -588,38 +590,43 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         if let hir::ExprLit(ref lit) = inner.node {\n             use syntax::ast::*;\n             use syntax::ast::LitIntType::*;\n-            const I8_OVERFLOW: u64 = ::std::i8::MAX as u64 + 1;\n-            const I16_OVERFLOW: u64 = ::std::i16::MAX as u64 + 1;\n-            const I32_OVERFLOW: u64 = ::std::i32::MAX as u64 + 1;\n-            const I64_OVERFLOW: u64 = ::std::i64::MAX as u64 + 1;\n+            const I8_OVERFLOW: u128 = i8::max_value() as u128 + 1;\n+            const I16_OVERFLOW: u128 = i16::max_value() as u128 + 1;\n+            const I32_OVERFLOW: u128 = i32::max_value() as u128 + 1;\n+            const I64_OVERFLOW: u128 = i64::max_value() as u128 + 1;\n+            const I128_OVERFLOW: u128 = i128::max_value() as u128 + 1;\n             match (&lit.node, ety.map(|t| &t.sty)) {\n                 (&LitKind::Int(I8_OVERFLOW, Unsuffixed), Some(&ty::TyInt(IntTy::I8))) |\n                 (&LitKind::Int(I8_OVERFLOW, Signed(IntTy::I8)), _) => {\n-                    return Ok(Integral(I8(::std::i8::MIN)))\n+                    return Ok(Integral(I8(i8::min_value())))\n                 },\n                 (&LitKind::Int(I16_OVERFLOW, Unsuffixed), Some(&ty::TyInt(IntTy::I16))) |\n                 (&LitKind::Int(I16_OVERFLOW, Signed(IntTy::I16)), _) => {\n-                    return Ok(Integral(I16(::std::i16::MIN)))\n+                    return Ok(Integral(I16(i16::min_value())))\n                 },\n                 (&LitKind::Int(I32_OVERFLOW, Unsuffixed), Some(&ty::TyInt(IntTy::I32))) |\n                 (&LitKind::Int(I32_OVERFLOW, Signed(IntTy::I32)), _) => {\n-                    return Ok(Integral(I32(::std::i32::MIN)))\n+                    return Ok(Integral(I32(i32::min_value())))\n                 },\n                 (&LitKind::Int(I64_OVERFLOW, Unsuffixed), Some(&ty::TyInt(IntTy::I64))) |\n                 (&LitKind::Int(I64_OVERFLOW, Signed(IntTy::I64)), _) => {\n-                    return Ok(Integral(I64(::std::i64::MIN)))\n+                    return Ok(Integral(I64(i64::min_value())))\n+                },\n+                (&LitKind::Int(I128_OVERFLOW, Unsuffixed), Some(&ty::TyInt(IntTy::I128))) |\n+                (&LitKind::Int(I128_OVERFLOW, Signed(IntTy::I128)), _) => {\n+                    return Ok(Integral(I128(i128::min_value())))\n                 },\n                 (&LitKind::Int(n, Unsuffixed), Some(&ty::TyInt(IntTy::Is))) |\n                 (&LitKind::Int(n, Signed(IntTy::Is)), _) => {\n                     match tcx.sess.target.int_type {\n                         IntTy::I16 => if n == I16_OVERFLOW {\n-                            return Ok(Integral(Isize(Is16(::std::i16::MIN))));\n+                            return Ok(Integral(Isize(Is16(i16::min_value()))));\n                         },\n                         IntTy::I32 => if n == I32_OVERFLOW {\n-                            return Ok(Integral(Isize(Is32(::std::i32::MIN))));\n+                            return Ok(Integral(Isize(Is32(i32::min_value()))));\n                         },\n                         IntTy::I64 => if n == I64_OVERFLOW {\n-                            return Ok(Integral(Isize(Is64(::std::i64::MIN))));\n+                            return Ok(Integral(Isize(Is64(i64::min_value()))));\n                         },\n                         _ => bug!(),\n                     }\n@@ -973,34 +980,39 @@ fn infer<'a, 'tcx>(i: ConstInt,\n         (&ty::TyInt(IntTy::I16), result @ I16(_)) => Ok(result),\n         (&ty::TyInt(IntTy::I32), result @ I32(_)) => Ok(result),\n         (&ty::TyInt(IntTy::I64), result @ I64(_)) => Ok(result),\n+        (&ty::TyInt(IntTy::I128), result @ I128(_)) => Ok(result),\n         (&ty::TyInt(IntTy::Is), result @ Isize(_)) => Ok(result),\n \n         (&ty::TyUint(UintTy::U8), result @ U8(_)) => Ok(result),\n         (&ty::TyUint(UintTy::U16), result @ U16(_)) => Ok(result),\n         (&ty::TyUint(UintTy::U32), result @ U32(_)) => Ok(result),\n         (&ty::TyUint(UintTy::U64), result @ U64(_)) => Ok(result),\n+        (&ty::TyUint(UintTy::U128), result @ U128(_)) => Ok(result),\n         (&ty::TyUint(UintTy::Us), result @ Usize(_)) => Ok(result),\n \n-        (&ty::TyInt(IntTy::I8), Infer(i)) => Ok(I8(i as i64 as i8)),\n-        (&ty::TyInt(IntTy::I16), Infer(i)) => Ok(I16(i as i64 as i16)),\n-        (&ty::TyInt(IntTy::I32), Infer(i)) => Ok(I32(i as i64 as i32)),\n-        (&ty::TyInt(IntTy::I64), Infer(i)) => Ok(I64(i as i64)),\n+        (&ty::TyInt(IntTy::I8), Infer(i)) => Ok(I8(i as i128 as i8)),\n+        (&ty::TyInt(IntTy::I16), Infer(i)) => Ok(I16(i as i128 as i16)),\n+        (&ty::TyInt(IntTy::I32), Infer(i)) => Ok(I32(i as i128 as i32)),\n+        (&ty::TyInt(IntTy::I64), Infer(i)) => Ok(I64(i as i128 as i64)),\n+        (&ty::TyInt(IntTy::I128), Infer(i)) => Ok(I128(i as i128)),\n         (&ty::TyInt(IntTy::Is), Infer(i)) => {\n-            Ok(Isize(ConstIsize::new_truncating(i as i64, tcx.sess.target.int_type)))\n+            Ok(Isize(ConstIsize::new_truncating(i as i128, tcx.sess.target.int_type)))\n         },\n \n         (&ty::TyInt(IntTy::I8), InferSigned(i)) => Ok(I8(i as i8)),\n         (&ty::TyInt(IntTy::I16), InferSigned(i)) => Ok(I16(i as i16)),\n         (&ty::TyInt(IntTy::I32), InferSigned(i)) => Ok(I32(i as i32)),\n-        (&ty::TyInt(IntTy::I64), InferSigned(i)) => Ok(I64(i)),\n+        (&ty::TyInt(IntTy::I64), InferSigned(i)) => Ok(I64(i as i64)),\n+        (&ty::TyInt(IntTy::I128), InferSigned(i)) => Ok(I128(i)),\n         (&ty::TyInt(IntTy::Is), InferSigned(i)) => {\n             Ok(Isize(ConstIsize::new_truncating(i, tcx.sess.target.int_type)))\n         },\n \n         (&ty::TyUint(UintTy::U8), Infer(i)) => Ok(U8(i as u8)),\n         (&ty::TyUint(UintTy::U16), Infer(i)) => Ok(U16(i as u16)),\n         (&ty::TyUint(UintTy::U32), Infer(i)) => Ok(U32(i as u32)),\n-        (&ty::TyUint(UintTy::U64), Infer(i)) => Ok(U64(i)),\n+        (&ty::TyUint(UintTy::U64), Infer(i)) => Ok(U64(i as u64)),\n+        (&ty::TyUint(UintTy::U128), Infer(i)) => Ok(U128(i)),\n         (&ty::TyUint(UintTy::Us), Infer(i)) => {\n             Ok(Usize(ConstUsize::new_truncating(i, tcx.sess.target.uint_type)))\n         },\n@@ -1071,21 +1083,23 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(\n }\n \n fn cast_const_int<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, val: ConstInt, ty: ty::Ty) -> CastResult {\n-    let v = val.to_u64_unchecked();\n+    let v = val.to_u128_unchecked();\n     match ty.sty {\n         ty::TyBool if v == 0 => Ok(Bool(false)),\n         ty::TyBool if v == 1 => Ok(Bool(true)),\n-        ty::TyInt(ast::IntTy::I8) => Ok(Integral(I8(v as i64 as i8))),\n-        ty::TyInt(ast::IntTy::I16) => Ok(Integral(I16(v as i64 as i16))),\n-        ty::TyInt(ast::IntTy::I32) => Ok(Integral(I32(v as i64 as i32))),\n-        ty::TyInt(ast::IntTy::I64) => Ok(Integral(I64(v as i64))),\n+        ty::TyInt(ast::IntTy::I8) => Ok(Integral(I8(v as i128 as i8))),\n+        ty::TyInt(ast::IntTy::I16) => Ok(Integral(I16(v as i128 as i16))),\n+        ty::TyInt(ast::IntTy::I32) => Ok(Integral(I32(v as i128 as i32))),\n+        ty::TyInt(ast::IntTy::I64) => Ok(Integral(I64(v as i128 as i64))),\n+        ty::TyInt(ast::IntTy::I128) => Ok(Integral(I128(v as i128))),\n         ty::TyInt(ast::IntTy::Is) => {\n-            Ok(Integral(Isize(ConstIsize::new_truncating(v as i64, tcx.sess.target.int_type))))\n+            Ok(Integral(Isize(ConstIsize::new_truncating(v as i128, tcx.sess.target.int_type))))\n         },\n         ty::TyUint(ast::UintTy::U8) => Ok(Integral(U8(v as u8))),\n         ty::TyUint(ast::UintTy::U16) => Ok(Integral(U16(v as u16))),\n         ty::TyUint(ast::UintTy::U32) => Ok(Integral(U32(v as u32))),\n-        ty::TyUint(ast::UintTy::U64) => Ok(Integral(U64(v))),\n+        ty::TyUint(ast::UintTy::U64) => Ok(Integral(U64(v as u64))),\n+        ty::TyUint(ast::UintTy::U128) => Ok(Integral(U128(v as u128))),\n         ty::TyUint(ast::UintTy::Us) => {\n             Ok(Integral(Usize(ConstUsize::new_truncating(v, tcx.sess.target.uint_type))))\n         },\n@@ -1115,13 +1129,13 @@ fn cast_const_float<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     match ty.sty {\n         ty::TyInt(_) | ty::TyUint(_) => {\n             let i = match val {\n-                F32(f) if f >= 0.0 => Infer(f as u64),\n+                F32(f) if f >= 0.0 => Infer(f as u128),\n                 FInfer { f64: f, .. } |\n-                F64(f) if f >= 0.0 => Infer(f as u64),\n+                F64(f) if f >= 0.0 => Infer(f as u128),\n \n-                F32(f) => InferSigned(f as i64),\n+                F32(f) => InferSigned(f as i128),\n                 FInfer { f64: f, .. } |\n-                F64(f) => InferSigned(f as i64)\n+                F64(f) => InferSigned(f as i128)\n             };\n \n             if let (InferSigned(_), &ty::TyUint(_)) = (i, &ty.sty) {\n@@ -1145,9 +1159,9 @@ fn cast_const_float<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n fn cast_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, val: ConstVal, ty: ty::Ty) -> CastResult {\n     match val {\n         Integral(i) => cast_const_int(tcx, i, ty),\n-        Bool(b) => cast_const_int(tcx, Infer(b as u64), ty),\n+        Bool(b) => cast_const_int(tcx, Infer(b as u128), ty),\n         Float(f) => cast_const_float(tcx, f, ty),\n-        Char(c) => cast_const_int(tcx, Infer(c as u64), ty),\n+        Char(c) => cast_const_int(tcx, Infer(c as u128), ty),\n         Function(_) => Err(UnimplementedConstVal(\"casting fn pointers\")),\n         ByteStr(b) => match ty.sty {\n             ty::TyRawPtr(_) => {\n@@ -1185,28 +1199,29 @@ fn lit_to_const<'a, 'tcx>(lit: &ast::LitKind,\n         LitKind::ByteStr(ref data) => Ok(ByteStr(data.clone())),\n         LitKind::Byte(n) => Ok(Integral(U8(n))),\n         LitKind::Int(n, Signed(ity)) => {\n-            infer(InferSigned(n as i64), tcx, &ty::TyInt(ity)).map(Integral)\n+            infer(InferSigned(n as i128), tcx, &ty::TyInt(ity)).map(Integral)\n         },\n \n+        // FIXME: this should become u128.\n         LitKind::Int(n, Unsuffixed) => {\n             match ty_hint.map(|t| &t.sty) {\n                 Some(&ty::TyInt(ity)) => {\n-                    infer(InferSigned(n as i64), tcx, &ty::TyInt(ity)).map(Integral)\n+                    infer(InferSigned(n as i128), tcx, &ty::TyInt(ity)).map(Integral)\n                 },\n                 Some(&ty::TyUint(uty)) => {\n-                    infer(Infer(n), tcx, &ty::TyUint(uty)).map(Integral)\n+                    infer(Infer(n as u128), tcx, &ty::TyUint(uty)).map(Integral)\n                 },\n-                None => Ok(Integral(Infer(n))),\n+                None => Ok(Integral(Infer(n as u128))),\n                 Some(&ty::TyAdt(adt, _)) => {\n                     let hints = tcx.lookup_repr_hints(adt.did);\n                     let int_ty = tcx.enum_repr_type(hints.iter().next());\n-                    infer(Infer(n), tcx, &int_ty.to_ty(tcx).sty).map(Integral)\n+                    infer(Infer(n as u128), tcx, &int_ty.to_ty(tcx).sty).map(Integral)\n                 },\n                 Some(ty_hint) => bug!(\"bad ty_hint: {:?}, {:?}\", ty_hint, lit),\n             }\n         },\n         LitKind::Int(n, Unsigned(ity)) => {\n-            infer(Infer(n), tcx, &ty::TyUint(ity)).map(Integral)\n+            infer(Infer(n as u128), tcx, &ty::TyUint(ity)).map(Integral)\n         },\n \n         LitKind::Float(n, fty) => {"}, {"sha": "67b4efdbd1f4474518860ae445b7cdaa5bd20408", "filename": "src/librustc_const_eval/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_const_eval%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_const_eval%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Flib.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -28,6 +28,7 @@\n #![feature(slice_patterns)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n+#![feature(const_fn)]\n \n extern crate arena;\n #[macro_use] extern crate syntax;\n@@ -41,6 +42,8 @@ extern crate graphviz;\n extern crate syntax_pos;\n extern crate serialize as rustc_serialize; // used by deriving\n \n+extern crate rustc_i128;\n+\n // NB: This module needs to be declared first so diagnostics are\n // registered before they are used.\n pub mod diagnostics;"}, {"sha": "3d7a4865e45af62fe436b883dd409b0a8ec3dff0", "filename": "src/librustc_const_math/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_const_math%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_const_math%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2FCargo.toml?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -12,3 +12,4 @@ crate-type = [\"dylib\"]\n log = { path = \"../liblog\" }\n serialize = { path = \"../libserialize\" }\n syntax = { path = \"../libsyntax\" }\n+rustc_i128 = { path = \"../librustc_i128\" }"}, {"sha": "1e9c2badd686096be1a1269c42b8b7c5bf6ce1a3", "filename": "src/librustc_const_math/err.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_const_math%2Ferr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_const_math%2Ferr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Ferr.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -74,11 +74,13 @@ impl ConstMathErr {\n             ULitOutOfRange(ast::UintTy::U16) => \"literal out of range for u16\",\n             ULitOutOfRange(ast::UintTy::U32) => \"literal out of range for u32\",\n             ULitOutOfRange(ast::UintTy::U64) => \"literal out of range for u64\",\n+            ULitOutOfRange(ast::UintTy::U128) => \"literal out of range for u128\",\n             ULitOutOfRange(ast::UintTy::Us) => \"literal out of range for usize\",\n             LitOutOfRange(ast::IntTy::I8) => \"literal out of range for i8\",\n             LitOutOfRange(ast::IntTy::I16) => \"literal out of range for i16\",\n             LitOutOfRange(ast::IntTy::I32) => \"literal out of range for i32\",\n             LitOutOfRange(ast::IntTy::I64) => \"literal out of range for i64\",\n+            LitOutOfRange(ast::IntTy::I128) => \"literal out of range for i128\",\n             LitOutOfRange(ast::IntTy::Is) => \"literal out of range for isize\",\n         }\n     }"}, {"sha": "a1b6ecf153a6e44a5c21f18b7f4d47439ffd5280", "filename": "src/librustc_const_math/int.rs", "status": "modified", "additions": 186, "deletions": 126, "changes": 312, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_const_math%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_const_math%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Fint.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -11,6 +11,7 @@\n use std::cmp::Ordering;\n use syntax::attr::IntType;\n use syntax::ast::{IntTy, UintTy};\n+use rustc_i128::{i128, u128};\n \n use super::is::*;\n use super::us::*;\n@@ -22,42 +23,65 @@ pub enum ConstInt {\n     I16(i16),\n     I32(i32),\n     I64(i64),\n+    I128(i128),\n     Isize(ConstIsize),\n     U8(u8),\n     U16(u16),\n     U32(u32),\n     U64(u64),\n+    U128(u128),\n     Usize(ConstUsize),\n-    Infer(u64),\n-    InferSigned(i64),\n+    // FIXME: i128\n+    Infer(u128),\n+    InferSigned(i128),\n }\n pub use self::ConstInt::*;\n \n \n macro_rules! bounds {\n-    ($($t:ident $min:ident $max:ident)*) => {\n-        mod as_u64 {\n-            $(\n-                #[allow(dead_code)]\n-                pub const $min: u64 = ::std::$t::MIN as u64;\n-                #[allow(dead_code)]\n-                pub const $max: u64 = ::std::$t::MAX as u64;\n-            )*\n-        }\n-        mod as_i64 {\n-            $(\n-                #[allow(dead_code)]\n-                pub const $min: i64 = ::std::$t::MIN as i64;\n-                #[allow(dead_code)]\n-                pub const $max: i64 = ::std::$t::MAX as i64;\n-            )*\n-        }\n+    ($ct: ty, $($t:ident $min:ident $max:ident)*) => {\n+        $(\n+            pub const $min: $ct = $t::min_value() as $ct;\n+            pub const $max: $ct = $t::max_value() as $ct;\n+        )*\n+    };\n+    ($ct: ty: $min_val: expr, $($t:ident $min:ident $max:ident)*) => {\n+        $(\n+            pub const $min: $ct = $min_val;\n+            pub const $max: $ct = $t::max_value() as $ct;\n+        )*\n+    }\n+}\n+\n+mod ubounds {\n+    #![allow(dead_code)]\n+    use rustc_i128::{u128, i128};\n+    // FIXME: min are problably all wrong for signed here.\n+    bounds!{u128: 0,\n+        i8 I8MIN I8MAX i16 I16MIN I16MAX i32 I32MIN I32MAX i64 I64MIN I64MAX i128 I128MIN I128MAX\n+        u8 U8MIN U8MAX u16 U16MIN U16MAX u32 U32MIN U32MAX u64 U64MIN U64MAX u128 U128MIN U128MAX\n+        isize IMIN IMAX usize UMIN UMAX\n     }\n }\n \n-bounds!{\n-    i8 I8MIN I8MAX i16 I16MIN I16MAX i32 I32MIN I32MAX i64 I64MIN I64MAX isize IMIN IMAX\n-    u8 U8MIN U8MAX u16 U16MIN U16MAX u32 U32MIN U32MAX u64 U64MIN U64MAX usize UMIN UMAX\n+mod ibounds {\n+    #![allow(dead_code)]\n+    use rustc_i128::i128;\n+    #[cfg(stage0)]\n+    pub const U64MIN: i128 = 0;\n+    #[cfg(stage0)]\n+    pub const U64MAX: i128 = i128::max_value();\n+    #[cfg(not(stage0))]\n+    bounds!(i128, u64 U64MIN U64MAX);\n+\n+    pub const U128MIN: i128 = 0;\n+    pub const U128MAX: i128 = i128::max_value();\n+\n+    bounds!{i128,\n+        i8 I8MIN I8MAX i16 I16MIN I16MAX i32 I32MIN I32MAX i64 I64MIN I64MAX i128 I128MIN I128MAX\n+        u8 U8MIN U8MAX u16 U16MIN U16MAX u32 U32MIN U32MAX\n+        isize IMIN IMAX usize UMIN UMAX\n+    }\n }\n \n impl ConstInt {\n@@ -68,46 +92,54 @@ impl ConstInt {\n             (InferSigned(_), InferSigned(_))\n             | (Infer(_), Infer(_)) => self, // no inference possible\n             // kindof wrong, you could have had values > I64MAX during computation of a\n-            (Infer(a @ 0...as_u64::I64MAX), InferSigned(_)) => InferSigned(a as i64),\n+            (Infer(a @ 0...ubounds::I64MAX), InferSigned(_)) => InferSigned(a as i128),\n             (Infer(_), InferSigned(_)) => return Err(ConstMathErr::NotInRange),\n             (_, InferSigned(_))\n             | (_, Infer(_)) => return other.infer(self).map(|(b, a)| (a, b)),\n \n-            (Infer(a @ 0...as_u64::I8MAX), I8(_)) => I8(a as i64 as i8),\n-            (Infer(a @ 0...as_u64::I16MAX), I16(_)) => I16(a as i64 as i16),\n-            (Infer(a @ 0...as_u64::I32MAX), I32(_)) => I32(a as i64 as i32),\n-            (Infer(a @ 0...as_u64::I64MAX), I64(_)) => I64(a as i64),\n-            (Infer(a @ 0...as_u64::I16MAX), Isize(Is16(_))) => Isize(Is16(a as i64 as i16)),\n-            (Infer(a @ 0...as_u64::I32MAX), Isize(Is32(_))) => Isize(Is32(a as i64 as i32)),\n-            (Infer(a @ 0...as_u64::I64MAX), Isize(Is64(_))) => Isize(Is64(a as i64)),\n-            (Infer(a @ 0...as_u64::U8MAX), U8(_)) => U8(a as u8),\n-            (Infer(a @ 0...as_u64::U16MAX), U16(_)) => U16(a as u16),\n-            (Infer(a @ 0...as_u64::U32MAX), U32(_)) => U32(a as u32),\n-            (Infer(a), U64(_)) => U64(a),\n-            (Infer(a @ 0...as_u64::U16MAX), Usize(Us16(_))) => Usize(Us16(a as u16)),\n-            (Infer(a @ 0...as_u64::U32MAX), Usize(Us32(_))) => Usize(Us32(a as u32)),\n-            (Infer(a), Usize(Us64(_))) => Usize(Us64(a)),\n+            (Infer(a @ 0...ubounds::I8MAX), I8(_)) => I8(a as i64 as i8),\n+            (Infer(a @ 0...ubounds::I16MAX), I16(_)) => I16(a as i64 as i16),\n+            (Infer(a @ 0...ubounds::I32MAX), I32(_)) => I32(a as i64 as i32),\n+            (Infer(a @ 0...ubounds::I64MAX), I64(_)) => I64(a as i64),\n+            (Infer(a @ 0...ubounds::I128MAX), I128(_)) => I128(a as i128),\n+            (Infer(a @ 0...ubounds::I16MAX), Isize(Is16(_))) => Isize(Is16(a as i64 as i16)),\n+            (Infer(a @ 0...ubounds::I32MAX), Isize(Is32(_))) => Isize(Is32(a as i64 as i32)),\n+            (Infer(a @ 0...ubounds::I64MAX), Isize(Is64(_))) => Isize(Is64(a as i64)),\n+            (Infer(a @ 0...ubounds::U8MAX), U8(_)) => U8(a as u8),\n+            (Infer(a @ 0...ubounds::U16MAX), U16(_)) => U16(a as u16),\n+            (Infer(a @ 0...ubounds::U32MAX), U32(_)) => U32(a as u32),\n+            (Infer(a @ 0...ubounds::U64MAX), U64(_)) => U64(a as u64),\n+            (Infer(a @ 0...ubounds::U128MAX), U128(_)) => U128(a as u128),\n+            (Infer(a @ 0...ubounds::U16MAX), Usize(Us16(_))) => Usize(Us16(a as u16)),\n+            (Infer(a @ 0...ubounds::U32MAX), Usize(Us32(_))) => Usize(Us32(a as u32)),\n+            (Infer(a @ 0...ubounds::U64MAX), Usize(Us64(_))) => Usize(Us64(a as u64)),\n \n             (Infer(_), _) => return Err(ConstMathErr::NotInRange),\n \n-            (InferSigned(a @ as_i64::I8MIN...as_i64::I8MAX), I8(_)) => I8(a as i8),\n-            (InferSigned(a @ as_i64::I16MIN...as_i64::I16MAX), I16(_)) => I16(a as i16),\n-            (InferSigned(a @ as_i64::I32MIN...as_i64::I32MAX), I32(_)) => I32(a as i32),\n-            (InferSigned(a), I64(_)) => I64(a),\n-            (InferSigned(a @ as_i64::I16MIN...as_i64::I16MAX), Isize(Is16(_))) => {\n+            (InferSigned(a @ ibounds::I8MIN...ibounds::I8MAX), I8(_)) => I8(a as i8),\n+            (InferSigned(a @ ibounds::I16MIN...ibounds::I16MAX), I16(_)) => I16(a as i16),\n+            (InferSigned(a @ ibounds::I32MIN...ibounds::I32MAX), I32(_)) => I32(a as i32),\n+            (InferSigned(a @ ibounds::I64MIN...ibounds::I64MAX), I64(_)) => I64(a as i64),\n+            (InferSigned(a @ ibounds::I128MIN...ibounds::I128MAX), I128(_)) => I128(a as i128),\n+            (InferSigned(a @ ibounds::I16MIN...ibounds::I16MAX), Isize(Is16(_))) => {\n                 Isize(Is16(a as i16))\n             },\n-            (InferSigned(a @ as_i64::I32MIN...as_i64::I32MAX), Isize(Is32(_))) => {\n+            (InferSigned(a @ ibounds::I32MIN...ibounds::I32MAX), Isize(Is32(_))) => {\n                 Isize(Is32(a as i32))\n             },\n-            (InferSigned(a), Isize(Is64(_))) => Isize(Is64(a)),\n-            (InferSigned(a @ 0...as_i64::U8MAX), U8(_)) => U8(a as u8),\n-            (InferSigned(a @ 0...as_i64::U16MAX), U16(_)) => U16(a as u16),\n-            (InferSigned(a @ 0...as_i64::U32MAX), U32(_)) => U32(a as u32),\n-            (InferSigned(a @ 0...as_i64::I64MAX), U64(_)) => U64(a as u64),\n-            (InferSigned(a @ 0...as_i64::U16MAX), Usize(Us16(_))) => Usize(Us16(a as u16)),\n-            (InferSigned(a @ 0...as_i64::U32MAX), Usize(Us32(_))) => Usize(Us32(a as u32)),\n-            (InferSigned(a @ 0...as_i64::I64MAX), Usize(Us64(_))) => Usize(Us64(a as u64)),\n+            (InferSigned(a @ ibounds::I64MIN...ibounds::I64MAX), Isize(Is64(_))) => {\n+                Isize(Is64(a as i64))\n+            },\n+            (InferSigned(a @ 0...ibounds::U8MAX), U8(_)) => U8(a as u8),\n+            (InferSigned(a @ 0...ibounds::U16MAX), U16(_)) => U16(a as u16),\n+            (InferSigned(a @ 0...ibounds::U32MAX), U32(_)) => U32(a as u32),\n+            // SNAP: replace with U64MAX\n+            (InferSigned(a @ 0...ibounds::I64MAX), U64(_)) => U64(a as u64),\n+            (InferSigned(a @ 0...ibounds::I128MAX), U128(_)) => U128(a as u128),\n+            (InferSigned(a @ 0...ibounds::U16MAX), Usize(Us16(_))) => Usize(Us16(a as u16)),\n+            (InferSigned(a @ 0...ibounds::U32MAX), Usize(Us32(_))) => Usize(Us32(a as u32)),\n+            // SNAP: replace with U64MAX\n+            (InferSigned(a @ 0...ibounds::I64MAX), Usize(Us64(_))) => Usize(Us64(a as u64)),\n             (InferSigned(_), _) => return Err(ConstMathErr::NotInRange),\n             _ => self, // already known types\n         };\n@@ -119,28 +151,34 @@ impl ConstInt {\n         match self {\n             Infer(i) => Infer(i),\n             InferSigned(i) if i < 0 => InferSigned(i),\n-            I8(i) if i < 0 => InferSigned(i as i64),\n-            I16(i) if i < 0 => InferSigned(i as i64),\n-            I32(i) if i < 0 => InferSigned(i as i64),\n-            I64(i) if i < 0 => InferSigned(i as i64),\n-            Isize(Is16(i)) if i < 0 => InferSigned(i as i64),\n-            Isize(Is32(i)) if i < 0 => InferSigned(i as i64),\n-            Isize(Is64(i)) if i < 0 => InferSigned(i as i64),\n-            InferSigned(i) => Infer(i as u64),\n-            I8(i) => Infer(i as u64),\n-            I16(i) => Infer(i as u64),\n-            I32(i) => Infer(i as u64),\n-            I64(i) => Infer(i as u64),\n-            Isize(Is16(i)) => Infer(i as u64),\n-            Isize(Is32(i)) => Infer(i as u64),\n-            Isize(Is64(i)) => Infer(i as u64),\n-            U8(i) => Infer(i as u64),\n-            U16(i) => Infer(i as u64),\n-            U32(i) => Infer(i as u64),\n-            U64(i) => Infer(i as u64),\n-            Usize(Us16(i)) => Infer(i as u64),\n-            Usize(Us32(i)) => Infer(i as u64),\n-            Usize(Us64(i)) => Infer(i),\n+            I8(i) if i < 0 => InferSigned(i as i128),\n+            I16(i) if i < 0 => InferSigned(i as i128),\n+            I32(i) if i < 0 => InferSigned(i as i128),\n+            I64(i) if i < 0 => InferSigned(i as i128),\n+            // FIXME: 1128, compare with i128\n+            I128(i) if i < 0 => InferSigned(i as i128),\n+            Isize(Is16(i)) if i < 0 => InferSigned(i as i128),\n+            Isize(Is32(i)) if i < 0 => InferSigned(i as i128),\n+            Isize(Is64(i)) if i < 0 => InferSigned(i as i128),\n+            InferSigned(i) => Infer(i as u128),\n+            I8(i) => Infer(i as u128),\n+            I16(i) => Infer(i as u128),\n+            I32(i) => Infer(i as u128),\n+            I64(i) => Infer(i as u128),\n+            // FIXME: i128\n+            I128(i) => Infer(i as u128),\n+            Isize(Is16(i)) => Infer(i as u128),\n+            Isize(Is32(i)) => Infer(i as u128),\n+            Isize(Is64(i)) => Infer(i as u128),\n+            U8(i) => Infer(i as u128),\n+            U16(i) => Infer(i as u128),\n+            U32(i) => Infer(i as u128),\n+            U64(i) => Infer(i as u128),\n+            // FIXME: i128\n+            U128(i) => Infer(i as u128),\n+            Usize(Us16(i)) => Infer(i as u128),\n+            Usize(Us32(i)) => Infer(i as u128),\n+            Usize(Us64(i)) => Infer(i as u128),\n         }\n     }\n \n@@ -153,67 +191,66 @@ impl ConstInt {\n             I16(_) => \"i16\",\n             I32(_) => \"i32\",\n             I64(_) => \"i64\",\n+            I128(_) => \"i128\",\n             Isize(_) => \"isize\",\n             U8(_) => \"u8\",\n             U16(_) => \"u16\",\n             U32(_) => \"u32\",\n             U64(_) => \"u64\",\n+            U128(_) => \"u128\",\n             Usize(_) => \"usize\",\n         }\n     }\n \n-    /// Erases the type and returns a u64.\n-    /// This is not the same as `-5i8 as u64` but as `-5i8 as i64 as u64`\n-    pub fn to_u64_unchecked(self) -> u64 {\n+    /// Erases the type and returns a u128.\n+    /// This is not the same as `-5i8 as u128` but as `-5i8 as i128 as u128`\n+    pub fn to_u128_unchecked(self) -> u128 {\n         match self.erase_type() {\n             ConstInt::Infer(i) => i,\n-            ConstInt::InferSigned(i) => i as u64,\n+            ConstInt::InferSigned(i) => i as u128,\n             _ => unreachable!(),\n         }\n     }\n \n     /// Converts the value to a `u32` if it's in the range 0...std::u32::MAX\n     pub fn to_u32(&self) -> Option<u32> {\n-        match *self {\n-            I8(v) if v >= 0 => Some(v as u32),\n-            I16(v) if v >= 0 => Some(v as u32),\n-            I32(v) if v >= 0 => Some(v as u32),\n-            InferSigned(v)\n-            | Isize(Is64(v))\n-            | I64(v) if v >= 0 && v <= ::std::u32::MAX as i64 => Some(v as u32),\n-            Isize(Is32(v)) if v >= 0 => Some(v as u32),\n-            Isize(Is16(v)) if v >= 0 => Some(v as u32),\n-            U8(v) => Some(v as u32),\n-            U16(v) => Some(v as u32),\n-            U32(v) => Some(v),\n-            Infer(v)\n-            | Usize(Us64(v))\n-            | U64(v) if v <= ::std::u32::MAX as u64 => Some(v as u32),\n-            Usize(Us32(v)) => Some(v),\n-            Usize(Us16(v)) => Some(v as u32),\n-            _ => None,\n-        }\n+        self.to_u128().and_then(|v| if v <= u32::max_value() as u128 {\n+            Some(v as u32)\n+        } else {\n+            None\n+        })\n     }\n \n-    /// Converts the value to a `u64` if it's >= 0\n+    /// Converts the value to a `u64` if it's in the range 0...std::u64::MAX\n     pub fn to_u64(&self) -> Option<u64> {\n+        self.to_u128().and_then(|v| if v <= u64::max_value() as u128 {\n+            Some(v as u64)\n+        } else {\n+            None\n+        })\n+    }\n+\n+    /// Converts the value to a `u128` if it's in the range 0...std::u128::MAX\n+    pub fn to_u128(&self) -> Option<u128> {\n         match *self {\n             Infer(v) => Some(v),\n-            InferSigned(v) if v >= 0 => Some(v as u64),\n-            I8(v) if v >= 0 => Some(v as u64),\n-            I16(v) if v >= 0 => Some(v as u64),\n-            I32(v) if v >= 0 => Some(v as u64),\n-            I64(v) if v >= 0 => Some(v as u64),\n-            Isize(Is16(v)) if v >= 0 => Some(v as u64),\n-            Isize(Is32(v)) if v >= 0 => Some(v as u64),\n-            Isize(Is64(v)) if v >= 0 => Some(v as u64),\n-            U8(v) => Some(v as u64),\n-            U16(v) => Some(v as u64),\n-            U32(v) => Some(v as u64),\n-            U64(v) => Some(v),\n-            Usize(Us16(v)) => Some(v as u64),\n-            Usize(Us32(v)) => Some(v as u64),\n-            Usize(Us64(v)) => Some(v),\n+            InferSigned(v) if v >= 0 => Some(v as u128),\n+            I8(v) if v >= 0 => Some(v as u128),\n+            I16(v) if v >= 0 => Some(v as u128),\n+            I32(v) if v >= 0 => Some(v as u128),\n+            I64(v) if v >= 0 => Some(v as u128),\n+            I128(v) if v >= 0 => Some(v as u128),\n+            Isize(Is16(v)) if v >= 0 => Some(v as u128),\n+            Isize(Is32(v)) if v >= 0 => Some(v as u128),\n+            Isize(Is64(v)) if v >= 0 => Some(v as u128),\n+            U8(v) => Some(v as u128),\n+            U16(v) => Some(v as u128),\n+            U32(v) => Some(v as u128),\n+            U64(v) => Some(v as u128),\n+            U128(v) => Some(v as u128),\n+            Usize(Us16(v)) => Some(v as u128),\n+            Usize(Us32(v)) => Some(v as u128),\n+            Usize(Us64(v)) => Some(v as u128),\n             _ => None,\n         }\n     }\n@@ -224,6 +261,7 @@ impl ConstInt {\n             I16(v) => v < 0,\n             I32(v) => v < 0,\n             I64(v) => v < 0,\n+            I128(v) => v < 0,\n             Isize(Is16(v)) => v < 0,\n             Isize(Is32(v)) => v < 0,\n             Isize(Is64(v)) => v < 0,\n@@ -239,13 +277,15 @@ impl ConstInt {\n             (I16(a), I16(b)) => Ok(a.cmp(&b)),\n             (I32(a), I32(b)) => Ok(a.cmp(&b)),\n             (I64(a), I64(b)) => Ok(a.cmp(&b)),\n+            (I128(a), I128(b)) => Ok(a.cmp(&b)),\n             (Isize(Is16(a)), Isize(Is16(b))) => Ok(a.cmp(&b)),\n             (Isize(Is32(a)), Isize(Is32(b))) => Ok(a.cmp(&b)),\n             (Isize(Is64(a)), Isize(Is64(b))) => Ok(a.cmp(&b)),\n             (U8(a), U8(b)) => Ok(a.cmp(&b)),\n             (U16(a), U16(b)) => Ok(a.cmp(&b)),\n             (U32(a), U32(b)) => Ok(a.cmp(&b)),\n             (U64(a), U64(b)) => Ok(a.cmp(&b)),\n+            (U128(a), U128(b)) => Ok(a.cmp(&b)),\n             (Usize(Us16(a)), Usize(Us16(b))) => Ok(a.cmp(&b)),\n             (Usize(Us32(a)), Usize(Us32(b))) => Ok(a.cmp(&b)),\n             (Usize(Us64(a)), Usize(Us64(b))) => Ok(a.cmp(&b)),\n@@ -265,13 +305,15 @@ impl ConstInt {\n             ConstInt::I16(i) => ConstInt::I16(add1!(i)),\n             ConstInt::I32(i) => ConstInt::I32(add1!(i)),\n             ConstInt::I64(i) => ConstInt::I64(add1!(i)),\n+            ConstInt::I128(i) => ConstInt::I128(add1!(i)),\n             ConstInt::Isize(ConstIsize::Is16(i)) => ConstInt::Isize(ConstIsize::Is16(add1!(i))),\n             ConstInt::Isize(ConstIsize::Is32(i)) => ConstInt::Isize(ConstIsize::Is32(add1!(i))),\n             ConstInt::Isize(ConstIsize::Is64(i)) => ConstInt::Isize(ConstIsize::Is64(add1!(i))),\n             ConstInt::U8(i) => ConstInt::U8(add1!(i)),\n             ConstInt::U16(i) => ConstInt::U16(add1!(i)),\n             ConstInt::U32(i) => ConstInt::U32(add1!(i)),\n             ConstInt::U64(i) => ConstInt::U64(add1!(i)),\n+            ConstInt::U128(i) => ConstInt::U128(add1!(i)),\n             ConstInt::Usize(ConstUsize::Us16(i)) => ConstInt::Usize(ConstUsize::Us16(add1!(i))),\n             ConstInt::Usize(ConstUsize::Us32(i)) => ConstInt::Usize(ConstUsize::Us32(add1!(i))),\n             ConstInt::Usize(ConstUsize::Us64(i)) => ConstInt::Usize(ConstUsize::Us64(add1!(i))),\n@@ -285,11 +327,13 @@ impl ConstInt {\n             ConstInt::I16(_) => Some(IntType::SignedInt(IntTy::I16)),\n             ConstInt::I32(_) => Some(IntType::SignedInt(IntTy::I32)),\n             ConstInt::I64(_) => Some(IntType::SignedInt(IntTy::I64)),\n+            ConstInt::I128(_) => Some(IntType::SignedInt(IntTy::I128)),\n             ConstInt::Isize(_) => Some(IntType::SignedInt(IntTy::Is)),\n             ConstInt::U8(_) => Some(IntType::UnsignedInt(UintTy::U8)),\n             ConstInt::U16(_) => Some(IntType::UnsignedInt(UintTy::U16)),\n             ConstInt::U32(_) => Some(IntType::UnsignedInt(UintTy::U32)),\n             ConstInt::U64(_) => Some(IntType::UnsignedInt(UintTy::U64)),\n+            ConstInt::U128(_) => Some(IntType::UnsignedInt(UintTy::U128)),\n             ConstInt::Usize(_) => Some(IntType::UnsignedInt(UintTy::Us)),\n             _ => None,\n         }\n@@ -317,13 +361,15 @@ impl ::std::fmt::Display for ConstInt {\n             I16(i) => write!(fmt, \"{}i16\", i),\n             I32(i) => write!(fmt, \"{}i32\", i),\n             I64(i) => write!(fmt, \"{}i64\", i),\n+            I128(i) => write!(fmt, \"{}i128\", i),\n             Isize(ConstIsize::Is64(i)) => write!(fmt, \"{}isize\", i),\n             Isize(ConstIsize::Is32(i)) => write!(fmt, \"{}isize\", i),\n             Isize(ConstIsize::Is16(i)) => write!(fmt, \"{}isize\", i),\n             U8(i) => write!(fmt, \"{}u8\", i),\n             U16(i) => write!(fmt, \"{}u16\", i),\n             U32(i) => write!(fmt, \"{}u32\", i),\n             U64(i) => write!(fmt, \"{}u64\", i),\n+            U128(i) => write!(fmt, \"{}u128\", i),\n             Usize(ConstUsize::Us64(i)) => write!(fmt, \"{}usize\", i),\n             Usize(ConstUsize::Us32(i)) => write!(fmt, \"{}usize\", i),\n             Usize(ConstUsize::Us16(i)) => write!(fmt, \"{}usize\", i),\n@@ -351,13 +397,15 @@ macro_rules! impl_binop {\n                     (I16(a), I16(b)) => a.$checked_func(b).map(I16),\n                     (I32(a), I32(b)) => a.$checked_func(b).map(I32),\n                     (I64(a), I64(b)) => a.$checked_func(b).map(I64),\n+                    (I128(a), I128(b)) => a.$checked_func(b).map(I128),\n                     (Isize(Is16(a)), Isize(Is16(b))) => a.$checked_func(b).map(Is16).map(Isize),\n                     (Isize(Is32(a)), Isize(Is32(b))) => a.$checked_func(b).map(Is32).map(Isize),\n                     (Isize(Is64(a)), Isize(Is64(b))) => a.$checked_func(b).map(Is64).map(Isize),\n                     (U8(a), U8(b)) => a.$checked_func(b).map(U8),\n                     (U16(a), U16(b)) => a.$checked_func(b).map(U16),\n                     (U32(a), U32(b)) => a.$checked_func(b).map(U32),\n                     (U64(a), U64(b)) => a.$checked_func(b).map(U64),\n+                    (U128(a), U128(b)) => a.$checked_func(b).map(U128),\n                     (Usize(Us16(a)), Usize(Us16(b))) => a.$checked_func(b).map(Us16).map(Usize),\n                     (Usize(Us32(a)), Usize(Us32(b))) => a.$checked_func(b).map(Us32).map(Usize),\n                     (Usize(Us64(a)), Usize(Us64(b))) => a.$checked_func(b).map(Us64).map(Usize),\n@@ -380,13 +428,15 @@ macro_rules! derive_binop {\n                     (I16(a), I16(b)) => Ok(I16(a.$func(b))),\n                     (I32(a), I32(b)) => Ok(I32(a.$func(b))),\n                     (I64(a), I64(b)) => Ok(I64(a.$func(b))),\n+                    (I128(a), I128(b)) => Ok(I128(a.$func(b))),\n                     (Isize(Is16(a)), Isize(Is16(b))) => Ok(Isize(Is16(a.$func(b)))),\n                     (Isize(Is32(a)), Isize(Is32(b))) => Ok(Isize(Is32(a.$func(b)))),\n                     (Isize(Is64(a)), Isize(Is64(b))) => Ok(Isize(Is64(a.$func(b)))),\n                     (U8(a), U8(b)) => Ok(U8(a.$func(b))),\n                     (U16(a), U16(b)) => Ok(U16(a.$func(b))),\n                     (U32(a), U32(b)) => Ok(U32(a.$func(b))),\n                     (U64(a), U64(b)) => Ok(U64(a.$func(b))),\n+                    (U128(a), U128(b)) => Ok(U128(a.$func(b))),\n                     (Usize(Us16(a)), Usize(Us16(b))) => Ok(Usize(Us16(a.$func(b)))),\n                     (Usize(Us32(a)), Usize(Us32(b))) => Ok(Usize(Us32(a.$func(b)))),\n                     (Usize(Us64(a)), Usize(Us64(b))) => Ok(Usize(Us64(a.$func(b)))),\n@@ -406,6 +456,11 @@ derive_binop!(BitAnd, bitand);\n derive_binop!(BitOr, bitor);\n derive_binop!(BitXor, bitxor);\n \n+#[cfg(not(stage0))]\n+const I128_MIN: i128 = ::std::i128::MIN;\n+#[cfg(stage0)]\n+const I128_MIN: i128 = ::std::i64::MIN;\n+\n fn check_division(\n     lhs: ConstInt,\n     rhs: ConstInt,\n@@ -417,6 +472,7 @@ fn check_division(\n         (I16(_), I16(0)) => Err(zerr),\n         (I32(_), I32(0)) => Err(zerr),\n         (I64(_), I64(0)) => Err(zerr),\n+        (I128(_), I128(0)) => Err(zerr),\n         (Isize(_), Isize(Is16(0))) => Err(zerr),\n         (Isize(_), Isize(Is32(0))) => Err(zerr),\n         (Isize(_), Isize(Is64(0))) => Err(zerr),\n@@ -426,6 +482,7 @@ fn check_division(\n         (U16(_), U16(0)) => Err(zerr),\n         (U32(_), U32(0)) => Err(zerr),\n         (U64(_), U64(0)) => Err(zerr),\n+        (U128(_), U128(0)) => Err(zerr),\n         (Usize(_), Usize(Us16(0))) => Err(zerr),\n         (Usize(_), Usize(Us32(0))) => Err(zerr),\n         (Usize(_), Usize(Us64(0))) => Err(zerr),\n@@ -435,10 +492,11 @@ fn check_division(\n         (I16(::std::i16::MIN), I16(-1)) => Err(Overflow(op)),\n         (I32(::std::i32::MIN), I32(-1)) => Err(Overflow(op)),\n         (I64(::std::i64::MIN), I64(-1)) => Err(Overflow(op)),\n+        (I128(I128_MIN), I128(-1)) => Err(Overflow(op)),\n         (Isize(Is16(::std::i16::MIN)), Isize(Is16(-1))) => Err(Overflow(op)),\n         (Isize(Is32(::std::i32::MIN)), Isize(Is32(-1))) => Err(Overflow(op)),\n         (Isize(Is64(::std::i64::MIN)), Isize(Is64(-1))) => Err(Overflow(op)),\n-        (InferSigned(::std::i64::MIN), InferSigned(-1)) => Err(Overflow(op)),\n+        (InferSigned(I128_MIN), InferSigned(-1)) => Err(Overflow(op)),\n \n         _ => Ok(()),\n     }\n@@ -454,6 +512,7 @@ impl ::std::ops::Div for ConstInt {\n             (I16(a), I16(b)) => Ok(I16(a/b)),\n             (I32(a), I32(b)) => Ok(I32(a/b)),\n             (I64(a), I64(b)) => Ok(I64(a/b)),\n+            (I128(a), I128(b)) => Ok(I128(a/b)),\n             (Isize(Is16(a)), Isize(Is16(b))) => Ok(Isize(Is16(a/b))),\n             (Isize(Is32(a)), Isize(Is32(b))) => Ok(Isize(Is32(a/b))),\n             (Isize(Is64(a)), Isize(Is64(b))) => Ok(Isize(Is64(a/b))),\n@@ -463,6 +522,7 @@ impl ::std::ops::Div for ConstInt {\n             (U16(a), U16(b)) => Ok(U16(a/b)),\n             (U32(a), U32(b)) => Ok(U32(a/b)),\n             (U64(a), U64(b)) => Ok(U64(a/b)),\n+            (U128(a), U128(b)) => Ok(U128(a/b)),\n             (Usize(Us16(a)), Usize(Us16(b))) => Ok(Usize(Us16(a/b))),\n             (Usize(Us32(a)), Usize(Us32(b))) => Ok(Usize(Us32(a/b))),\n             (Usize(Us64(a)), Usize(Us64(b))) => Ok(Usize(Us64(a/b))),\n@@ -484,6 +544,7 @@ impl ::std::ops::Rem for ConstInt {\n             (I16(a), I16(b)) => Ok(I16(a%b)),\n             (I32(a), I32(b)) => Ok(I32(a%b)),\n             (I64(a), I64(b)) => Ok(I64(a%b)),\n+            (I128(a), I128(b)) => Ok(I128(a%b)),\n             (Isize(Is16(a)), Isize(Is16(b))) => Ok(Isize(Is16(a%b))),\n             (Isize(Is32(a)), Isize(Is32(b))) => Ok(Isize(Is32(a%b))),\n             (Isize(Is64(a)), Isize(Is64(b))) => Ok(Isize(Is64(a%b))),\n@@ -493,6 +554,7 @@ impl ::std::ops::Rem for ConstInt {\n             (U16(a), U16(b)) => Ok(U16(a%b)),\n             (U32(a), U32(b)) => Ok(U32(a%b)),\n             (U64(a), U64(b)) => Ok(U64(a%b)),\n+            (U128(a), U128(b)) => Ok(U128(a%b)),\n             (Usize(Us16(a)), Usize(Us16(b))) => Ok(Usize(Us16(a%b))),\n             (Usize(Us32(a)), Usize(Us32(b))) => Ok(Usize(Us32(a%b))),\n             (Usize(Us64(a)), Usize(Us64(b))) => Ok(Usize(Us64(a%b))),\n@@ -512,13 +574,15 @@ impl ::std::ops::Shl<ConstInt> for ConstInt {\n             I16(a) => Ok(I16(overflowing!(a.overflowing_shl(b), Op::Shl))),\n             I32(a) => Ok(I32(overflowing!(a.overflowing_shl(b), Op::Shl))),\n             I64(a) => Ok(I64(overflowing!(a.overflowing_shl(b), Op::Shl))),\n+            I128(a) => Ok(I128(overflowing!(a.overflowing_shl(b), Op::Shl))),\n             Isize(Is16(a)) => Ok(Isize(Is16(overflowing!(a.overflowing_shl(b), Op::Shl)))),\n             Isize(Is32(a)) => Ok(Isize(Is32(overflowing!(a.overflowing_shl(b), Op::Shl)))),\n             Isize(Is64(a)) => Ok(Isize(Is64(overflowing!(a.overflowing_shl(b), Op::Shl)))),\n             U8(a) => Ok(U8(overflowing!(a.overflowing_shl(b), Op::Shl))),\n             U16(a) => Ok(U16(overflowing!(a.overflowing_shl(b), Op::Shl))),\n             U32(a) => Ok(U32(overflowing!(a.overflowing_shl(b), Op::Shl))),\n             U64(a) => Ok(U64(overflowing!(a.overflowing_shl(b), Op::Shl))),\n+            U128(a) => Ok(U128(overflowing!(a.overflowing_shl(b), Op::Shl))),\n             Usize(Us16(a)) => Ok(Usize(Us16(overflowing!(a.overflowing_shl(b), Op::Shl)))),\n             Usize(Us32(a)) => Ok(Usize(Us32(overflowing!(a.overflowing_shl(b), Op::Shl)))),\n             Usize(Us64(a)) => Ok(Usize(Us64(overflowing!(a.overflowing_shl(b), Op::Shl)))),\n@@ -537,13 +601,15 @@ impl ::std::ops::Shr<ConstInt> for ConstInt {\n             I16(a) => Ok(I16(overflowing!(a.overflowing_shr(b), Op::Shr))),\n             I32(a) => Ok(I32(overflowing!(a.overflowing_shr(b), Op::Shr))),\n             I64(a) => Ok(I64(overflowing!(a.overflowing_shr(b), Op::Shr))),\n+            I128(a) => Ok(I128(overflowing!(a.overflowing_shr(b), Op::Shr))),\n             Isize(Is16(a)) => Ok(Isize(Is16(overflowing!(a.overflowing_shr(b), Op::Shr)))),\n             Isize(Is32(a)) => Ok(Isize(Is32(overflowing!(a.overflowing_shr(b), Op::Shr)))),\n             Isize(Is64(a)) => Ok(Isize(Is64(overflowing!(a.overflowing_shr(b), Op::Shr)))),\n             U8(a) => Ok(U8(overflowing!(a.overflowing_shr(b), Op::Shr))),\n             U16(a) => Ok(U16(overflowing!(a.overflowing_shr(b), Op::Shr))),\n             U32(a) => Ok(U32(overflowing!(a.overflowing_shr(b), Op::Shr))),\n             U64(a) => Ok(U64(overflowing!(a.overflowing_shr(b), Op::Shr))),\n+            U128(a) => Ok(U128(overflowing!(a.overflowing_shr(b), Op::Shr))),\n             Usize(Us16(a)) => Ok(Usize(Us16(overflowing!(a.overflowing_shr(b), Op::Shr)))),\n             Usize(Us32(a)) => Ok(Usize(Us32(overflowing!(a.overflowing_shr(b), Op::Shr)))),\n             Usize(Us64(a)) => Ok(Usize(Us64(overflowing!(a.overflowing_shr(b), Op::Shr)))),\n@@ -561,22 +627,14 @@ impl ::std::ops::Neg for ConstInt {\n             I16(a) => Ok(I16(overflowing!(a.overflowing_neg(), Op::Neg))),\n             I32(a) => Ok(I32(overflowing!(a.overflowing_neg(), Op::Neg))),\n             I64(a) => Ok(I64(overflowing!(a.overflowing_neg(), Op::Neg))),\n+            I128(a) => Ok(I128(overflowing!(a.overflowing_neg(), Op::Neg))),\n             Isize(Is16(a)) => Ok(Isize(Is16(overflowing!(a.overflowing_neg(), Op::Neg)))),\n             Isize(Is32(a)) => Ok(Isize(Is32(overflowing!(a.overflowing_neg(), Op::Neg)))),\n             Isize(Is64(a)) => Ok(Isize(Is64(overflowing!(a.overflowing_neg(), Op::Neg)))),\n-            U8(0) => Ok(U8(0)),\n-            U16(0) => Ok(U16(0)),\n-            U32(0) => Ok(U32(0)),\n-            U64(0) => Ok(U64(0)),\n-            Usize(Us16(0)) => Ok(Usize(Us16(0))),\n-            Usize(Us32(0)) => Ok(Usize(Us32(0))),\n-            Usize(Us64(0)) => Ok(Usize(Us64(0))),\n-            U8(_) => Err(UnsignedNegation),\n-            U16(_) => Err(UnsignedNegation),\n-            U32(_) => Err(UnsignedNegation),\n-            U64(_) => Err(UnsignedNegation),\n-            Usize(_) => Err(UnsignedNegation),\n-            Infer(a @ 0...as_u64::I64MAX) => Ok(InferSigned(-(a as i64))),\n+            a@U8(0) | a@U16(0) | a@U32(0) | a@U64(0) | a@U128(0) |\n+            a@Usize(Us16(0)) | a@Usize(Us32(0)) | a@Usize(Us64(0)) => Ok(a),\n+            U8(_) | U16(_) | U32(_) | U64(_) | U128(_) | Usize(_) => Err(UnsignedNegation),\n+            Infer(a @ 0...ubounds::I64MAX) => Ok(InferSigned(-(a as i128))),\n             Infer(_) => Err(Overflow(Op::Neg)),\n             InferSigned(a) => Ok(InferSigned(overflowing!(a.overflowing_neg(), Op::Neg))),\n         }\n@@ -591,13 +649,15 @@ impl ::std::ops::Not for ConstInt {\n             I16(a) => Ok(I16(!a)),\n             I32(a) => Ok(I32(!a)),\n             I64(a) => Ok(I64(!a)),\n+            I128(a) => Ok(I128(!a)),\n             Isize(Is16(a)) => Ok(Isize(Is16(!a))),\n             Isize(Is32(a)) => Ok(Isize(Is32(!a))),\n             Isize(Is64(a)) => Ok(Isize(Is64(!a))),\n             U8(a) => Ok(U8(!a)),\n             U16(a) => Ok(U16(!a)),\n             U32(a) => Ok(U32(!a)),\n             U64(a) => Ok(U64(!a)),\n+            U128(a) => Ok(U128(!a)),\n             Usize(Us16(a)) => Ok(Usize(Us16(!a))),\n             Usize(Us32(a)) => Ok(Usize(Us32(!a))),\n             Usize(Us64(a)) => Ok(Usize(Us64(!a))),"}, {"sha": "19ae0c91fc5f9b2ddd435178c9abaf0afaef5341", "filename": "src/librustc_const_math/is.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_const_math%2Fis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_const_math%2Fis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Fis.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -10,6 +10,7 @@\n \n use syntax::ast;\n use super::err::*;\n+use rustc_i128::i128;\n \n /// Depending on the target only one variant is ever used in a compilation.\n /// Anything else is an error. This invariant is checked at several locations\n@@ -41,11 +42,11 @@ impl ConstIsize {\n             _ => unreachable!(),\n         }\n     }\n-    pub fn new_truncating(i: i64, target_int_ty: ast::IntTy) -> Self {\n+    pub fn new_truncating(i: i128, target_int_ty: ast::IntTy) -> Self {\n         match target_int_ty {\n             ast::IntTy::I16 => Is16(i as i16),\n             ast::IntTy::I32 => Is32(i as i32),\n-            ast::IntTy::I64 => Is64(i),\n+            ast::IntTy::I64 => Is64(i as i64),\n             _ => unreachable!(),\n         }\n     }"}, {"sha": "597344a2c82d01b9f675bf668fdae0a6ae56ba13", "filename": "src/librustc_const_math/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_const_math%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_const_math%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Flib.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -25,10 +25,14 @@\n \n #![feature(rustc_private)]\n #![feature(staged_api)]\n+#![feature(const_fn)]\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n \n+// SNAP: remove use of this crate\n+extern crate rustc_i128;\n+\n extern crate serialize as rustc_serialize; // used by deriving\n \n mod float;"}, {"sha": "9ebf5cab6bb06000a18d4125e3fb3942ddc9c365", "filename": "src/librustc_const_math/us.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_const_math%2Fus.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_const_math%2Fus.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Fus.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -10,6 +10,7 @@\n \n use syntax::ast;\n use super::err::*;\n+use rustc_i128::u128;\n \n /// Depending on the target only one variant is ever used in a compilation.\n /// Anything else is an error. This invariant is checked at several locations\n@@ -41,11 +42,11 @@ impl ConstUsize {\n             _ => unreachable!(),\n         }\n     }\n-    pub fn new_truncating(i: u64, target_uint_ty: ast::UintTy) -> Self {\n+    pub fn new_truncating(i: u128, target_uint_ty: ast::UintTy) -> Self {\n         match target_uint_ty {\n             ast::UintTy::U16 => Us16(i as u16),\n             ast::UintTy::U32 => Us32(i as u32),\n-            ast::UintTy::U64 => Us64(i),\n+            ast::UintTy::U64 => Us64(i as u64),\n             _ => unreachable!(),\n         }\n     }"}, {"sha": "79632394bf6b0afdf6be4012b0352d99b72c9f45", "filename": "src/librustc_i128/Cargo.toml", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_i128%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_i128%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_i128%2FCargo.toml?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -0,0 +1,9 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_i128\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"rustc_i128\"\n+path = \"lib.rs\"\n+crate-type = [\"dylib\"]"}, {"sha": "14604fc66ba86a570db7add72e332d0312c88610", "filename": "src/librustc_i128/lib.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_i128%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_i128%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_i128%2Flib.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -0,0 +1,16 @@\n+#![allow(non_camel_case_types)]\n+\n+#[cfg(stage0)]\n+pub type i128 = i64;\n+#[cfg(stage0)]\n+pub type u128 = u64;\n+\n+#[cfg(not(stage0))]\n+pub type i128 = int::_i128;\n+#[cfg(not(stage0))]\n+pub type u128 = int::_u128;\n+#[cfg(not(stage0))]\n+mod int {\n+    pub type _i128 = i128;\n+    pub type _u128 = u128;\n+}"}, {"sha": "272f8b4f64dbd65ef1ec6e291b40389a65904770", "filename": "src/librustc_lint/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_lint%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_lint%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2FCargo.toml?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -14,5 +14,6 @@ log = { path = \"../liblog\" }\n rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_const_eval = { path = \"../librustc_const_eval\" }\n+rustc_i128 = { path = \"../librustc_i128\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "a24edfaaac1c2fa3689aab276ab2f8bb47ecc0d3", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -47,6 +47,8 @@ extern crate rustc_back;\n extern crate rustc_const_eval;\n extern crate syntax_pos;\n \n+extern crate rustc_i128;\n+\n pub use rustc::lint;\n pub use rustc::middle;\n pub use rustc::session;"}, {"sha": "95e955bd6833e85edf233bfd16d339b57c6b0815", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 33, "deletions": 26, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -33,6 +33,8 @@ use syntax::codemap;\n \n use rustc::hir;\n \n+use rustc_i128::{i128, u128};\n+\n register_long_diagnostics! {\n E0519: r##\"\n It is not allowed to negate an unsigned integer.\n@@ -147,7 +149,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                     if let Some(bits) = opt_ty_bits {\n                         let exceeding = if let hir::ExprLit(ref lit) = r.node {\n                             if let ast::LitKind::Int(shift, _) = lit.node {\n-                                shift >= bits\n+                                shift as u64 >= bits\n                             } else {\n                                 false\n                             }\n@@ -182,12 +184,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                                     t\n                                 };\n                                 let (_, max) = int_ty_range(int_type);\n+                                let max = max as u128;\n                                 let negative = self.negated_expr_id == e.id;\n \n                                 // Detect literal value out of range [min, max] inclusive\n                                 // avoiding use of -min to prevent overflow/panic\n-                                if (negative && v > max as u64 + 1) ||\n-                                   (!negative && v > max as u64) {\n+                                if (negative && v > max + 1) ||\n+                                   (!negative && v > max) {\n                                     cx.span_lint(OVERFLOWING_LITERALS,\n                                                  e.span,\n                                                  &format!(\"literal out of range for {:?}\", t));\n@@ -204,7 +207,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                             t\n                         };\n                         let (min, max) = uint_ty_range(uint_type);\n-                        let lit_val: u64 = match lit.node {\n+                        let lit_val: u128 = match lit.node {\n                             // _v is u8, within range by definition\n                             ast::LitKind::Byte(_v) => return,\n                             ast::LitKind::Int(v, _) => v,\n@@ -264,23 +267,25 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n \n         // for isize & usize, be conservative with the warnings, so that the\n         // warnings are consistent between 32- and 64-bit platforms\n-        fn int_ty_range(int_ty: ast::IntTy) -> (i64, i64) {\n+        fn int_ty_range(int_ty: ast::IntTy) -> (i128, i128) {\n             match int_ty {\n-                ast::IntTy::Is => (i64::MIN, i64::MAX),\n-                ast::IntTy::I8 => (i8::MIN as i64, i8::MAX as i64),\n-                ast::IntTy::I16 => (i16::MIN as i64, i16::MAX as i64),\n-                ast::IntTy::I32 => (i32::MIN as i64, i32::MAX as i64),\n-                ast::IntTy::I64 => (i64::MIN, i64::MAX),\n+                ast::IntTy::Is => (i64::min_value() as i128, i64::max_value() as i128),\n+                ast::IntTy::I8 => (i8::min_value() as i64 as i128, i8::max_value() as i128),\n+                ast::IntTy::I16 => (i16::min_value() as i64 as i128, i16::max_value() as i128),\n+                ast::IntTy::I32 => (i32::min_value() as i64 as i128, i32::max_value() as i128),\n+                ast::IntTy::I64 => (i64::min_value() as i128, i64::max_value() as i128),\n+                ast::IntTy::I128 =>(i128::min_value() as i128, i128::max_value()),\n             }\n         }\n \n-        fn uint_ty_range(uint_ty: ast::UintTy) -> (u64, u64) {\n+        fn uint_ty_range(uint_ty: ast::UintTy) -> (u128, u128) {\n             match uint_ty {\n-                ast::UintTy::Us => (u64::MIN, u64::MAX),\n-                ast::UintTy::U8 => (u8::MIN as u64, u8::MAX as u64),\n-                ast::UintTy::U16 => (u16::MIN as u64, u16::MAX as u64),\n-                ast::UintTy::U32 => (u32::MIN as u64, u32::MAX as u64),\n-                ast::UintTy::U64 => (u64::MIN, u64::MAX),\n+                ast::UintTy::Us => (u64::min_value() as u128, u64::max_value() as u128),\n+                ast::UintTy::U8 => (u8::min_value() as u128, u8::max_value() as u128),\n+                ast::UintTy::U16 => (u16::min_value() as u128, u16::max_value() as u128),\n+                ast::UintTy::U32 => (u32::min_value() as u128, u32::max_value() as u128),\n+                ast::UintTy::U64 => (u64::min_value() as u128, u64::max_value() as u128),\n+                ast::UintTy::U128 => (u128::min_value(), u128::max_value()),\n             }\n         }\n \n@@ -298,6 +303,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                 ast::IntTy::I16 => 16 as u64,\n                 ast::IntTy::I32 => 32,\n                 ast::IntTy::I64 => 64,\n+                ast::IntTy::I128 => 128,\n             }\n         }\n \n@@ -308,6 +314,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                 ast::UintTy::U16 => 16,\n                 ast::UintTy::U32 => 32,\n                 ast::UintTy::U64 => 64,\n+                ast::UintTy::U128 => 128,\n             }\n         }\n \n@@ -327,28 +334,28 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n             match tcx.tables().node_id_to_type(expr.id).sty {\n                 ty::TyInt(int_ty) => {\n                     let (min, max) = int_ty_range(int_ty);\n-                    let lit_val: i64 = match lit.node {\n+                    let lit_val: i128 = match lit.node {\n                         hir::ExprLit(ref li) => {\n                             match li.node {\n                                 ast::LitKind::Int(v, ast::LitIntType::Signed(_)) |\n-                                ast::LitKind::Int(v, ast::LitIntType::Unsuffixed) => v as i64,\n-                                _ => return true,\n+                                ast::LitKind::Int(v, ast::LitIntType::Unsuffixed) => v as i128,\n+                                _ => return true\n                             }\n-                        }\n-                        _ => bug!(),\n+                        },\n+                        _ => bug!()\n                     };\n                     is_valid(norm_binop, lit_val, min, max)\n                 }\n                 ty::TyUint(uint_ty) => {\n-                    let (min, max): (u64, u64) = uint_ty_range(uint_ty);\n-                    let lit_val: u64 = match lit.node {\n+                    let (min, max) :(u128, u128) = uint_ty_range(uint_ty);\n+                    let lit_val: u128 = match lit.node {\n                         hir::ExprLit(ref li) => {\n                             match li.node {\n                                 ast::LitKind::Int(v, _) => v,\n-                                _ => return true,\n+                                _ => return true\n                             }\n-                        }\n-                        _ => bug!(),\n+                        },\n+                        _ => bug!()\n                     };\n                     is_valid(norm_binop, lit_val, min, max)\n                 }"}, {"sha": "efb06bdb73e3ad34c94562853fbf47a95a5ffa2f", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -508,6 +508,7 @@ extern \"C\" {\n     pub fn LLVMInt16TypeInContext(C: ContextRef) -> TypeRef;\n     pub fn LLVMInt32TypeInContext(C: ContextRef) -> TypeRef;\n     pub fn LLVMInt64TypeInContext(C: ContextRef) -> TypeRef;\n+    pub fn LLVMInt128TypeInContext(C: ContextRef) -> TypeRef;\n     pub fn LLVMIntTypeInContext(C: ContextRef, NumBits: c_uint) -> TypeRef;\n \n     pub fn LLVMGetIntTypeWidth(IntegerTy: TypeRef) -> c_uint;\n@@ -578,6 +579,7 @@ extern \"C\" {\n \n     // Operations on scalar constants\n     pub fn LLVMConstInt(IntTy: TypeRef, N: c_ulonglong, SignExtend: Bool) -> ValueRef;\n+    pub fn LLVMConstIntOfArbitraryPrecision(IntTy: TypeRef, Wn: c_uint, Ws: *const u64) -> ValueRef;\n     pub fn LLVMConstReal(RealTy: TypeRef, N: f64) -> ValueRef;\n     pub fn LLVMConstIntGetZExtValue(ConstantVal: ValueRef) -> c_ulonglong;\n     pub fn LLVMConstIntGetSExtValue(ConstantVal: ValueRef) -> c_longlong;"}, {"sha": "4bd98c087f5171bcfc6c00a85665113cc575b39e", "filename": "src/librustc_metadata/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_metadata%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_metadata%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2FCargo.toml?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -18,6 +18,7 @@ rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_llvm = { path = \"../librustc_llvm\" }\n+rustc_i128 = { path = \"../librustc_i128\" }\n serialize = { path = \"../libserialize\" }\n syntax = { path = \"../libsyntax\" }\n syntax_ext = { path = \"../libsyntax_ext\" }"}, {"sha": "3e3553dd1f229991805f25b912fac2665fcdf1e2", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -43,6 +43,8 @@ use syntax::attr;\n use syntax::ast::{self, NodeId};\n use syntax::codemap;\n use syntax_pos::{self, Span, BytePos, Pos, DUMMY_SP};\n+use syntax_pos::{self, Span, BytePos, Pos};\n+use rustc_i128::u128;\n \n pub struct DecodeContext<'a, 'tcx: 'a> {\n     opaque: opaque::Decoder<'a>,\n@@ -211,12 +213,14 @@ impl<'doc, 'tcx> Decoder for DecodeContext<'doc, 'tcx> {\n     decoder_methods! {\n         read_nil -> ();\n \n+        read_u128 -> u128;\n         read_u64 -> u64;\n         read_u32 -> u32;\n         read_u16 -> u16;\n         read_u8 -> u8;\n         read_usize -> usize;\n \n+        read_i128 -> i128;\n         read_i64 -> i64;\n         read_i32 -> i32;\n         read_i16 -> i16;"}, {"sha": "8ba3e7d82f2e2fbe64ee7a0006ba025660a16e89", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -45,9 +45,15 @@ extern crate rustc_back;\n extern crate rustc_const_math;\n extern crate rustc_data_structures;\n extern crate rustc_llvm;\n+extern crate rustc_i128;\n \n mod diagnostics;\n \n+pub use rustc::middle;\n+\n+#[macro_use]\n+mod macros;\n+\n mod astencode;\n mod index_builder;\n mod index;"}, {"sha": "7e26aa9a57bf57cfd09ac9a473aa5e2116535f3d", "filename": "src/librustc_mir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2FCargo.toml?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -17,5 +17,6 @@ rustc_const_eval = { path = \"../librustc_const_eval\" }\n rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_bitflags = { path = \"../librustc_bitflags\" }\n+rustc_i128 = { path = \"../librustc_i128\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "0aad96d27cc0676b99f41aa94cdfc6f5ad0d7f9b", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -15,6 +15,7 @@ use std;\n use rustc_const_math::{ConstMathErr, Op};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n+use rustc_i128::i128;\n \n use build::{BlockAnd, BlockAndExtension, Builder};\n use build::expr::category::{Category, RvalueFunc};\n@@ -347,6 +348,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     ast::IntTy::I16 => ConstInt::I16(-1),\n                     ast::IntTy::I32 => ConstInt::I32(-1),\n                     ast::IntTy::I64 => ConstInt::I64(-1),\n+                    ast::IntTy::I128 => ConstInt::I128(-1),\n                     ast::IntTy::Is => {\n                         let int_ty = self.hir.tcx().sess.target.int_type;\n                         let val = ConstIsize::new(-1, int_ty).unwrap();\n@@ -369,10 +371,12 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let literal = match ty.sty {\n             ty::TyInt(ity) => {\n                 let val = match ity {\n-                    ast::IntTy::I8  => ConstInt::I8(std::i8::MIN),\n-                    ast::IntTy::I16 => ConstInt::I16(std::i16::MIN),\n-                    ast::IntTy::I32 => ConstInt::I32(std::i32::MIN),\n-                    ast::IntTy::I64 => ConstInt::I64(std::i64::MIN),\n+                    ast::IntTy::I8  => ConstInt::I8(i8::min_value()),\n+                    ast::IntTy::I16 => ConstInt::I16(i16::min_value()),\n+                    ast::IntTy::I32 => ConstInt::I32(i32::min_value()),\n+                    ast::IntTy::I64 => ConstInt::I64(i64::min_value()),\n+                    // FIXME: i128\n+                    ast::IntTy::I128 => ConstInt::I128(i128::min_value()),\n                     ast::IntTy::Is => {\n                         let int_ty = self.hir.tcx().sess.target.int_type;\n                         let min = match int_ty {"}, {"sha": "99aa5cb0fa86eb1f5d735cd1b945f4f17d5937a2", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -66,6 +66,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     ast::UintTy::U16 => ConstInt::U16(0),\n                     ast::UintTy::U32 => ConstInt::U32(0),\n                     ast::UintTy::U64 => ConstInt::U64(0),\n+                    ast::UintTy::U128 => ConstInt::U128(0),\n                     ast::UintTy::Us => {\n                         let uint_ty = self.hir.tcx().sess.target.uint_type;\n                         let val = ConstUsize::new(0, uint_ty).unwrap();\n@@ -81,6 +82,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     ast::IntTy::I16 => ConstInt::I16(0),\n                     ast::IntTy::I32 => ConstInt::I32(0),\n                     ast::IntTy::I64 => ConstInt::I64(0),\n+                    ast::IntTy::I128 => ConstInt::I128(0),\n                     ast::IntTy::Is => {\n                         let int_ty = self.hir.tcx().sess.target.int_type;\n                         let val = ConstIsize::new(0, int_ty).unwrap();"}, {"sha": "a608275cefa0610da7d763139c3ec4159e7740fd", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -41,6 +41,8 @@ extern crate syntax_pos;\n extern crate rustc_const_math;\n extern crate rustc_const_eval;\n \n+extern crate rustc_i128;\n+\n pub mod diagnostics;\n \n pub mod build;"}, {"sha": "53fa87b52250dda836dc4823f7ece92cb69ac33e", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -1005,13 +1005,14 @@ impl PrimitiveTypeTable {\n         table.intern(\"i16\", TyInt(IntTy::I16));\n         table.intern(\"i32\", TyInt(IntTy::I32));\n         table.intern(\"i64\", TyInt(IntTy::I64));\n+        table.intern(\"i128\", TyInt(IntTy::I128));\n         table.intern(\"str\", TyStr);\n         table.intern(\"usize\", TyUint(UintTy::Us));\n         table.intern(\"u8\", TyUint(UintTy::U8));\n         table.intern(\"u16\", TyUint(UintTy::U16));\n         table.intern(\"u32\", TyUint(UintTy::U32));\n         table.intern(\"u64\", TyUint(UintTy::U64));\n-\n+        table.intern(\"u128\", TyUint(UintTy::U128));\n         table\n     }\n "}, {"sha": "93e2e472b75f13d22d4561c06df1165f4658418e", "filename": "src/librustc_trans/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_trans%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_trans%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2FCargo.toml?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -23,7 +23,8 @@ rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_incremental = { path = \"../librustc_incremental\" }\n rustc_llvm = { path = \"../librustc_llvm\" }\n+rustc_i128 = { path = \"../librustc_i128\" }\n rustc_platform_intrinsics = { path = \"../librustc_platform_intrinsics\" }\n serialize = { path = \"../libserialize\" }\n syntax = { path = \"../libsyntax\" }\n-syntax_pos = { path = \"../libsyntax_pos\" }\n\\ No newline at end of file\n+syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "3e564a7c6ed4d0aa15e35fe8498c094accae6fef", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -44,6 +44,8 @@ use syntax::ast;\n use syntax::symbol::{Symbol, InternedString};\n use syntax_pos::Span;\n \n+use rustc_i128::u128;\n+\n pub use context::{CrateContext, SharedCrateContext};\n \n pub fn type_is_fat_ptr<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n@@ -425,6 +427,16 @@ pub fn C_integral(t: Type, u: u64, sign_extend: bool) -> ValueRef {\n     }\n }\n \n+pub fn C_big_integral(t: Type, u: u128) -> ValueRef {\n+    if ::std::mem::size_of::<u128>() == 16 {\n+        unsafe {\n+            llvm::LLVMConstIntOfArbitraryPrecision(t.to_ref(), 2, &u as *const u128 as *const u64)\n+        }\n+    } else {\n+        C_integral(t, u as u64, false)\n+    }\n+}\n+\n pub fn C_floating_f64(f: f64, t: Type) -> ValueRef {\n     unsafe {\n         llvm::LLVMConstReal(t.to_ref(), f)"}, {"sha": "fd921b3c432908e4c2e11a2fd635b010772da277", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -24,6 +24,7 @@ use monomorphize::{Instance};\n use type_::Type;\n use type_of;\n use rustc::ty;\n+use rustc_i128::{i128, u128};\n \n use rustc::hir;\n "}, {"sha": "413b643740861a1cf047fe8de836a7bfcf69b9bf", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -1022,6 +1022,7 @@ fn declare_intrinsic(ccx: &CrateContext, key: &str) -> Option<ValueRef> {\n     let t_i16 = Type::i16(ccx);\n     let t_i32 = Type::i32(ccx);\n     let t_i64 = Type::i64(ccx);\n+    let t_i128 = Type::i128(ccx);\n     let t_f32 = Type::f32(ccx);\n     let t_f64 = Type::f64(ccx);\n \n@@ -1088,50 +1089,60 @@ fn declare_intrinsic(ccx: &CrateContext, key: &str) -> Option<ValueRef> {\n     ifn!(\"llvm.ctpop.i16\", fn(t_i16) -> t_i16);\n     ifn!(\"llvm.ctpop.i32\", fn(t_i32) -> t_i32);\n     ifn!(\"llvm.ctpop.i64\", fn(t_i64) -> t_i64);\n+    ifn!(\"llvm.ctpop.i128\", fn(t_i128) -> t_i128);\n \n     ifn!(\"llvm.ctlz.i8\", fn(t_i8 , i1) -> t_i8);\n     ifn!(\"llvm.ctlz.i16\", fn(t_i16, i1) -> t_i16);\n     ifn!(\"llvm.ctlz.i32\", fn(t_i32, i1) -> t_i32);\n     ifn!(\"llvm.ctlz.i64\", fn(t_i64, i1) -> t_i64);\n+    ifn!(\"llvm.ctlz.i128\", fn(t_i128, i1) -> t_i128);\n \n     ifn!(\"llvm.cttz.i8\", fn(t_i8 , i1) -> t_i8);\n     ifn!(\"llvm.cttz.i16\", fn(t_i16, i1) -> t_i16);\n     ifn!(\"llvm.cttz.i32\", fn(t_i32, i1) -> t_i32);\n     ifn!(\"llvm.cttz.i64\", fn(t_i64, i1) -> t_i64);\n+    ifn!(\"llvm.cttz.i128\", fn(t_i128, i1) -> t_i128);\n \n     ifn!(\"llvm.bswap.i16\", fn(t_i16) -> t_i16);\n     ifn!(\"llvm.bswap.i32\", fn(t_i32) -> t_i32);\n     ifn!(\"llvm.bswap.i64\", fn(t_i64) -> t_i64);\n+    ifn!(\"llvm.bswap.i128\", fn(t_i128) -> t_i128);\n \n     ifn!(\"llvm.sadd.with.overflow.i8\", fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n     ifn!(\"llvm.sadd.with.overflow.i16\", fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n     ifn!(\"llvm.sadd.with.overflow.i32\", fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n     ifn!(\"llvm.sadd.with.overflow.i64\", fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n+    ifn!(\"llvm.sadd.with.overflow.i128\", fn(t_i128, t_i128) -> mk_struct!{t_i128, i1});\n \n     ifn!(\"llvm.uadd.with.overflow.i8\", fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n     ifn!(\"llvm.uadd.with.overflow.i16\", fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n     ifn!(\"llvm.uadd.with.overflow.i32\", fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n     ifn!(\"llvm.uadd.with.overflow.i64\", fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n+    ifn!(\"llvm.uadd.with.overflow.i128\", fn(t_i128, t_i128) -> mk_struct!{t_i128, i1});\n \n     ifn!(\"llvm.ssub.with.overflow.i8\", fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n     ifn!(\"llvm.ssub.with.overflow.i16\", fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n     ifn!(\"llvm.ssub.with.overflow.i32\", fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n     ifn!(\"llvm.ssub.with.overflow.i64\", fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n+    ifn!(\"llvm.ssub.with.overflow.i128\", fn(t_i128, t_i128) -> mk_struct!{t_i128, i1});\n \n     ifn!(\"llvm.usub.with.overflow.i8\", fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n     ifn!(\"llvm.usub.with.overflow.i16\", fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n     ifn!(\"llvm.usub.with.overflow.i32\", fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n     ifn!(\"llvm.usub.with.overflow.i64\", fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n+    ifn!(\"llvm.usub.with.overflow.i128\", fn(t_i128, t_i128) -> mk_struct!{t_i128, i1});\n \n     ifn!(\"llvm.smul.with.overflow.i8\", fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n     ifn!(\"llvm.smul.with.overflow.i16\", fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n     ifn!(\"llvm.smul.with.overflow.i32\", fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n     ifn!(\"llvm.smul.with.overflow.i64\", fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n+    ifn!(\"llvm.smul.with.overflow.i128\", fn(t_i128, t_i128) -> mk_struct!{t_i128, i1});\n \n     ifn!(\"llvm.umul.with.overflow.i8\", fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n     ifn!(\"llvm.umul.with.overflow.i16\", fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n     ifn!(\"llvm.umul.with.overflow.i32\", fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n     ifn!(\"llvm.umul.with.overflow.i64\", fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n+    ifn!(\"llvm.umul.with.overflow.i128\", fn(t_i128, t_i128) -> mk_struct!{t_i128, i1});\n \n     ifn!(\"llvm.lifetime.start\", fn(t_i64,i8p) -> void);\n     ifn!(\"llvm.lifetime.end\", fn(t_i64, i8p) -> void);"}, {"sha": "b2d12c7e7d0f2a323130bdcefd4f74bdb2029b48", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -1460,7 +1460,8 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 llvm::LLVMRustDIBuilderCreateEnumerator(\n                     DIB(cx),\n                     name.as_ptr(),\n-                    v.disr_val.to_u64_unchecked())\n+                    // FIXME: what if enumeration has i128 discriminant?\n+                    v.disr_val.to_u128_unchecked() as u64)\n             }\n         })\n         .collect();"}, {"sha": "c5737c6e5f12c38a267e60f2937d6093fbd3e004", "filename": "src/librustc_trans/disr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_trans%2Fdisr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_trans%2Fdisr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdisr.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -26,7 +26,8 @@ impl ::std::ops::BitAnd for Disr {\n \n impl From<::rustc::ty::Disr> for Disr {\n     fn from(i: ::rustc::ty::Disr) -> Disr {\n-        Disr(i.to_u64_unchecked())\n+        // FIXME: what if discr has 128 bit discr?\n+        Disr(i.to_u128_unchecked() as u64)\n     }\n }\n "}, {"sha": "cc55a2b3e9a5802eda1e40c6a65d24d3f2e7df02", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -1167,6 +1167,8 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n \n // Returns the width of an int TypeVariant, and if it's signed or not\n // Returns None if the type is not an integer\n+// FIXME: there\u2019s multiple of this functions, investigate using some of the already existing\n+// stuffs.\n fn int_type_width_signed<'tcx>(sty: &ty::TypeVariants<'tcx>, ccx: &CrateContext)\n         -> Option<(u64, bool)> {\n     use rustc::ty::{TyInt, TyUint};\n@@ -1184,6 +1186,7 @@ fn int_type_width_signed<'tcx>(sty: &ty::TypeVariants<'tcx>, ccx: &CrateContext)\n             ast::IntTy::I16 => 16,\n             ast::IntTy::I32 => 32,\n             ast::IntTy::I64 => 64,\n+            ast::IntTy::I128 => 128,\n         }, true)),\n         TyUint(t) => Some((match t {\n             ast::UintTy::Us => {\n@@ -1198,6 +1201,7 @@ fn int_type_width_signed<'tcx>(sty: &ty::TypeVariants<'tcx>, ccx: &CrateContext)\n             ast::UintTy::U16 => 16,\n             ast::UintTy::U32 => 32,\n             ast::UintTy::U64 => 64,\n+            ast::UintTy::U128 => 128,\n         }, false)),\n         _ => None,\n     }"}, {"sha": "11bfa0d76c382e3e05da1a5427a0b3602b8d5064", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -57,6 +57,7 @@ extern crate rustc_const_eval;\n #[macro_use]\n #[no_link]\n extern crate rustc_bitflags;\n+extern crate rustc_i128;\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;"}, {"sha": "737ca634f0860e65576c21f788c9aadf6db4a117", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -25,7 +25,7 @@ use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use {abi, adt, base, Disr, machine};\n use callee::Callee;\n use common::{self, BlockAndBuilder, CrateContext, const_get_elt, val_ty};\n-use common::{C_array, C_bool, C_bytes, C_floating_f64, C_integral};\n+use common::{C_array, C_bool, C_bytes, C_floating_f64, C_integral, C_big_integral};\n use common::{C_null, C_struct, C_str_slice, C_undef, C_uint};\n use common::{const_to_opt_int, const_to_opt_uint};\n use consts;\n@@ -36,6 +36,7 @@ use value::Value;\n \n use syntax::ast;\n use syntax_pos::Span;\n+use rustc_i128::u128;\n \n use std::fmt;\n use std::ptr;\n@@ -75,6 +76,7 @@ impl<'tcx> Const<'tcx> {\n             ConstVal::Integral(I16(v)) => C_integral(Type::i16(ccx), v as u64, true),\n             ConstVal::Integral(I32(v)) => C_integral(Type::i32(ccx), v as u64, true),\n             ConstVal::Integral(I64(v)) => C_integral(Type::i64(ccx), v as u64, true),\n+            ConstVal::Integral(I128(v)) => C_big_integral(Type::i128(ccx), v as u128),\n             ConstVal::Integral(Isize(v)) => {\n                 let i = v.as_i64(ccx.tcx().sess.target.int_type);\n                 C_integral(Type::int(ccx), i as u64, true)\n@@ -83,6 +85,7 @@ impl<'tcx> Const<'tcx> {\n             ConstVal::Integral(U16(v)) => C_integral(Type::i16(ccx), v as u64, false),\n             ConstVal::Integral(U32(v)) => C_integral(Type::i32(ccx), v as u64, false),\n             ConstVal::Integral(U64(v)) => C_integral(Type::i64(ccx), v, false),\n+            ConstVal::Integral(U128(v)) => C_big_integral(Type::i128(ccx), v),\n             ConstVal::Integral(Usize(v)) => {\n                 let u = v.as_u64(ccx.tcx().sess.target.uint_type);\n                 C_integral(Type::int(ccx), u, false)"}, {"sha": "cca48737bb963e7d6dbb703c6e85c5c76fd50bcb", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -711,11 +711,13 @@ fn get_overflow_intrinsic(oop: OverflowOp, bcx: &BlockAndBuilder, ty: Ty) -> Val\n             TyInt(I16) => \"llvm.sadd.with.overflow.i16\",\n             TyInt(I32) => \"llvm.sadd.with.overflow.i32\",\n             TyInt(I64) => \"llvm.sadd.with.overflow.i64\",\n+            TyInt(I128) => \"llvm.sadd.with.overflow.i128\",\n \n             TyUint(U8) => \"llvm.uadd.with.overflow.i8\",\n             TyUint(U16) => \"llvm.uadd.with.overflow.i16\",\n             TyUint(U32) => \"llvm.uadd.with.overflow.i32\",\n             TyUint(U64) => \"llvm.uadd.with.overflow.i64\",\n+            TyUint(U128) => \"llvm.uadd.with.overflow.i128\",\n \n             _ => unreachable!(),\n         },\n@@ -724,11 +726,13 @@ fn get_overflow_intrinsic(oop: OverflowOp, bcx: &BlockAndBuilder, ty: Ty) -> Val\n             TyInt(I16) => \"llvm.ssub.with.overflow.i16\",\n             TyInt(I32) => \"llvm.ssub.with.overflow.i32\",\n             TyInt(I64) => \"llvm.ssub.with.overflow.i64\",\n+            TyInt(I128) => \"llvm.ssub.with.overflow.i128\",\n \n             TyUint(U8) => \"llvm.usub.with.overflow.i8\",\n             TyUint(U16) => \"llvm.usub.with.overflow.i16\",\n             TyUint(U32) => \"llvm.usub.with.overflow.i32\",\n             TyUint(U64) => \"llvm.usub.with.overflow.i64\",\n+            TyUint(U128) => \"llvm.usub.with.overflow.i128\",\n \n             _ => unreachable!(),\n         },\n@@ -737,11 +741,13 @@ fn get_overflow_intrinsic(oop: OverflowOp, bcx: &BlockAndBuilder, ty: Ty) -> Val\n             TyInt(I16) => \"llvm.smul.with.overflow.i16\",\n             TyInt(I32) => \"llvm.smul.with.overflow.i32\",\n             TyInt(I64) => \"llvm.smul.with.overflow.i64\",\n+            TyInt(I128) => \"llvm.smul.with.overflow.i128\",\n \n             TyUint(U8) => \"llvm.umul.with.overflow.i8\",\n             TyUint(U16) => \"llvm.umul.with.overflow.i16\",\n             TyUint(U32) => \"llvm.umul.with.overflow.i32\",\n             TyUint(U64) => \"llvm.umul.with.overflow.i64\",\n+            TyUint(U128) => \"llvm.umul.with.overflow.i128\",\n \n             _ => unreachable!(),\n         },"}, {"sha": "f6f91411225d9b0ecad02567763aa85b9aec5936", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -397,11 +397,13 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n             ty::TyInt(ast::IntTy::I16)   => output.push_str(\"i16\"),\n             ty::TyInt(ast::IntTy::I32)   => output.push_str(\"i32\"),\n             ty::TyInt(ast::IntTy::I64)   => output.push_str(\"i64\"),\n+            ty::TyInt(ast::IntTy::I128)   => output.push_str(\"i128\"),\n             ty::TyUint(ast::UintTy::Us)   => output.push_str(\"usize\"),\n             ty::TyUint(ast::UintTy::U8)   => output.push_str(\"u8\"),\n             ty::TyUint(ast::UintTy::U16)  => output.push_str(\"u16\"),\n             ty::TyUint(ast::UintTy::U32)  => output.push_str(\"u32\"),\n             ty::TyUint(ast::UintTy::U64)  => output.push_str(\"u64\"),\n+            ty::TyUint(ast::UintTy::U128)  => output.push_str(\"u128\"),\n             ty::TyFloat(ast::FloatTy::F32) => output.push_str(\"f32\"),\n             ty::TyFloat(ast::FloatTy::F64) => output.push_str(\"f64\"),\n             ty::TyAdt(adt_def, substs) => {"}, {"sha": "e8d8db2956b8af82400fa5ede8935dff5de5ae55", "filename": "src/librustc_trans/type_.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_trans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_trans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -94,6 +94,10 @@ impl Type {\n         ty!(llvm::LLVMInt64TypeInContext(ccx.llcx()))\n     }\n \n+    pub fn i128(ccx: &CrateContext) -> Type {\n+        ty!(llvm::LLVMInt128TypeInContext(ccx.llcx()))\n+    }\n+\n     // Creates an integer type with the given number of bits, e.g. i24\n     pub fn ix(ccx: &CrateContext, num_bits: u64) -> Type {\n         ty!(llvm::LLVMIntTypeInContext(ccx.llcx(), num_bits as c_uint))\n@@ -134,7 +138,8 @@ impl Type {\n             ast::IntTy::I8 => Type::i8(ccx),\n             ast::IntTy::I16 => Type::i16(ccx),\n             ast::IntTy::I32 => Type::i32(ccx),\n-            ast::IntTy::I64 => Type::i64(ccx)\n+            ast::IntTy::I64 => Type::i64(ccx),\n+            ast::IntTy::I128 => Type::i128(ccx),\n         }\n     }\n \n@@ -144,7 +149,8 @@ impl Type {\n             ast::UintTy::U8 => Type::i8(ccx),\n             ast::UintTy::U16 => Type::i16(ccx),\n             ast::UintTy::U32 => Type::i32(ccx),\n-            ast::UintTy::U64 => Type::i64(ccx)\n+            ast::UintTy::U64 => Type::i64(ccx),\n+            ast::UintTy::U128 => Type::i128(ccx),\n         }\n     }\n "}, {"sha": "4f41bbe9924b0f54fd37da4d9833625b27984aca", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -432,7 +432,9 @@ fn match_intrinsic_type_to_type<'tcx, 'a>(\n             (true,  32, &ty::TyInt(ast::IntTy::I32)) |\n             (false, 32, &ty::TyUint(ast::UintTy::U32)) |\n             (true,  64, &ty::TyInt(ast::IntTy::I64)) |\n-            (false, 64, &ty::TyUint(ast::UintTy::U64)) => {},\n+            (false, 64, &ty::TyUint(ast::UintTy::U64)) |\n+            (true,  128, &ty::TyInt(ast::IntTy::I128)) |\n+            (false, 128, &ty::TyUint(ast::UintTy::U128)) => {},\n             _ => simple_error(&format!(\"`{}`\", t),\n                               &format!(\"`{}{n}`\",\n                                        if signed {\"i\"} else {\"u\"},"}, {"sha": "5c3da4237bef261e6f7c8c91799e103083a374d0", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -435,6 +435,10 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 let lang_def_id = self.tcx.lang_items.i64_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n+            ty::TyInt(ast::IntTy::I128) => {\n+                let lang_def_id = self.tcx.lang_items.i128_impl();\n+                self.assemble_inherent_impl_for_primitive(lang_def_id);\n+            }\n             ty::TyInt(ast::IntTy::Is) => {\n                 let lang_def_id = self.tcx.lang_items.isize_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n@@ -455,6 +459,10 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 let lang_def_id = self.tcx.lang_items.u64_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n+            ty::TyUint(ast::UintTy::U128) => {\n+                let lang_def_id = self.tcx.lang_items.u128_impl();\n+                self.assemble_inherent_impl_for_primitive(lang_def_id);\n+            }\n             ty::TyUint(ast::UintTy::Us) => {\n                 let lang_def_id = self.tcx.lang_items.usize_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);"}, {"sha": "2b5a4515cd0d8d63c576253a3f3e9ad57e87d10d", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -160,6 +160,13 @@ impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OrphanChecker<'cx, 'tcx> {\n                                                   \"i64\",\n                                                   item.span);\n                     }\n+                    ty::TyInt(ast::IntTy::I128) => {\n+                        self.check_primitive_impl(def_id,\n+                                                  self.tcx.lang_items.i128_impl(),\n+                                                  \"i128\",\n+                                                  \"i128\",\n+                                                  item.span);\n+                    }\n                     ty::TyInt(ast::IntTy::Is) => {\n                         self.check_primitive_impl(def_id,\n                                                   self.tcx.lang_items.isize_impl(),\n@@ -195,6 +202,13 @@ impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OrphanChecker<'cx, 'tcx> {\n                                                   \"u64\",\n                                                   item.span);\n                     }\n+                    ty::TyUint(ast::UintTy::U128) => {\n+                        self.check_primitive_impl(def_id,\n+                                                  self.tcx.lang_items.u128_impl(),\n+                                                  \"u128\",\n+                                                  \"u128\",\n+                                                  item.span);\n+                    }\n                     ty::TyUint(ast::UintTy::Us) => {\n                         self.check_primitive_impl(def_id,\n                                                   self.tcx.lang_items.usize_impl(),"}, {"sha": "7ddf10375bf2384be2a361d3177219986e457d86", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -1060,11 +1060,13 @@ fn convert_union_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                     (attr::SignedInt(ast::IntTy::I16), ConstInt::I16(_)) |\n                     (attr::SignedInt(ast::IntTy::I32), ConstInt::I32(_)) |\n                     (attr::SignedInt(ast::IntTy::I64), ConstInt::I64(_)) |\n+                    (attr::SignedInt(ast::IntTy::I128), ConstInt::I128(_)) |\n                     (attr::SignedInt(ast::IntTy::Is), ConstInt::Isize(_)) |\n                     (attr::UnsignedInt(ast::UintTy::U8), ConstInt::U8(_)) |\n                     (attr::UnsignedInt(ast::UintTy::U16), ConstInt::U16(_)) |\n                     (attr::UnsignedInt(ast::UintTy::U32), ConstInt::U32(_)) |\n                     (attr::UnsignedInt(ast::UintTy::U64), ConstInt::U64(_)) |\n+                    (attr::UnsignedInt(ast::UintTy::U128), ConstInt::U128(_)) |\n                     (attr::UnsignedInt(ast::UintTy::Us), ConstInt::Usize(_)) => Some(i),\n                     (_, i) => {\n                         print_err(ConstVal::Integral(i));"}, {"sha": "6e9b66d564555ca6fe38dc8a1652269e636447d7", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 46, "deletions": 40, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -1513,8 +1513,8 @@ pub enum Type {\n \n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Copy, Debug)]\n pub enum PrimitiveType {\n-    Isize, I8, I16, I32, I64,\n-    Usize, U8, U16, U32, U64,\n+    Isize, I8, I16, I32, I64, I128,\n+    Usize, U8, U16, U32, U64, U128,\n     F32, F64,\n     Char,\n     Bool,\n@@ -1614,26 +1614,29 @@ impl PrimitiveType {\n     }\n \n     pub fn as_str(&self) -> &'static str {\n+        use PrimitiveType::*;\n         match *self {\n-            PrimitiveType::Isize => \"isize\",\n-            PrimitiveType::I8 => \"i8\",\n-            PrimitiveType::I16 => \"i16\",\n-            PrimitiveType::I32 => \"i32\",\n-            PrimitiveType::I64 => \"i64\",\n-            PrimitiveType::Usize => \"usize\",\n-            PrimitiveType::U8 => \"u8\",\n-            PrimitiveType::U16 => \"u16\",\n-            PrimitiveType::U32 => \"u32\",\n-            PrimitiveType::U64 => \"u64\",\n-            PrimitiveType::F32 => \"f32\",\n-            PrimitiveType::F64 => \"f64\",\n-            PrimitiveType::Str => \"str\",\n-            PrimitiveType::Bool => \"bool\",\n-            PrimitiveType::Char => \"char\",\n-            PrimitiveType::Array => \"array\",\n-            PrimitiveType::Slice => \"slice\",\n-            PrimitiveType::Tuple => \"tuple\",\n-            PrimitiveType::RawPointer => \"pointer\",\n+            Isize => \"isize\",\n+            I8 => \"i8\",\n+            I16 => \"i16\",\n+            I32 => \"i32\",\n+            I64 => \"i64\",\n+            I128 => \"i128\",\n+            Usize => \"usize\",\n+            U8 => \"u8\",\n+            U16 => \"u16\",\n+            U32 => \"u32\",\n+            U64 => \"u64\",\n+            U128 => \"u128\",\n+            F32 => \"f32\",\n+            F64 => \"f64\",\n+            Str => \"str\",\n+            Bool => \"bool\",\n+            Char => \"char\",\n+            Array => \"array\",\n+            Slice => \"slice\",\n+            Tuple => \"tuple\",\n+            RawPointer => \"pointer\",\n         }\n     }\n \n@@ -2486,6 +2489,7 @@ impl Clean<Vec<Item>> for doctree::Impl {\n fn build_deref_target_impls(cx: &DocContext,\n                             items: &[Item],\n                             ret: &mut Vec<Item>) {\n+    use PrimitiveType::*;\n     let tcx = cx.tcx;\n \n     for item in items {\n@@ -2505,25 +2509,27 @@ fn build_deref_target_impls(cx: &DocContext,\n             }\n         };\n         let did = match primitive {\n-            PrimitiveType::Isize => tcx.lang_items.isize_impl(),\n-            PrimitiveType::I8 => tcx.lang_items.i8_impl(),\n-            PrimitiveType::I16 => tcx.lang_items.i16_impl(),\n-            PrimitiveType::I32 => tcx.lang_items.i32_impl(),\n-            PrimitiveType::I64 => tcx.lang_items.i64_impl(),\n-            PrimitiveType::Usize => tcx.lang_items.usize_impl(),\n-            PrimitiveType::U8 => tcx.lang_items.u8_impl(),\n-            PrimitiveType::U16 => tcx.lang_items.u16_impl(),\n-            PrimitiveType::U32 => tcx.lang_items.u32_impl(),\n-            PrimitiveType::U64 => tcx.lang_items.u64_impl(),\n-            PrimitiveType::F32 => tcx.lang_items.f32_impl(),\n-            PrimitiveType::F64 => tcx.lang_items.f64_impl(),\n-            PrimitiveType::Char => tcx.lang_items.char_impl(),\n-            PrimitiveType::Bool => None,\n-            PrimitiveType::Str => tcx.lang_items.str_impl(),\n-            PrimitiveType::Slice => tcx.lang_items.slice_impl(),\n-            PrimitiveType::Array => tcx.lang_items.slice_impl(),\n-            PrimitiveType::Tuple => None,\n-            PrimitiveType::RawPointer => tcx.lang_items.const_ptr_impl(),\n+            Isize => tcx.lang_items.isize_impl(),\n+            I8 => tcx.lang_items.i8_impl(),\n+            I16 => tcx.lang_items.i16_impl(),\n+            I32 => tcx.lang_items.i32_impl(),\n+            I64 => tcx.lang_items.i64_impl(),\n+            I128 => tcx.lang_items.i128_impl(),\n+            Usize => tcx.lang_items.usize_impl(),\n+            U8 => tcx.lang_items.u8_impl(),\n+            U16 => tcx.lang_items.u16_impl(),\n+            U32 => tcx.lang_items.u32_impl(),\n+            U64 => tcx.lang_items.u64_impl(),\n+            U128 => tcx.lang_items.u128_impl(),\n+            F32 => tcx.lang_items.f32_impl(),\n+            F64 => tcx.lang_items.f64_impl(),\n+            Char => tcx.lang_items.char_impl(),\n+            Bool => None,\n+            Str => tcx.lang_items.str_impl(),\n+            Slice => tcx.lang_items.slice_impl(),\n+            Array => tcx.lang_items.slice_impl(),\n+            Tuple => None,\n+            RawPointer => tcx.lang_items.const_ptr_impl(),\n         };\n         if let Some(did) = did {\n             if !did.is_local() {"}, {"sha": "3213b4e4208be91e1240ecec4219ad6511d2a75b", "filename": "src/libserialize/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibserialize%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibserialize%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2FCargo.toml?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -10,3 +10,4 @@ crate-type = [\"dylib\", \"rlib\"]\n \n [dependencies]\n log = { path = \"../liblog\" }\n+rustc_i128 = { path = \"../librustc_i128\" }"}, {"sha": "80b0bfc7d3e32fdcf0d80ec49d747e6d3cc385a3", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -211,6 +211,8 @@ use std::string;\n use std::{char, f64, fmt, str};\n use std;\n \n+use rustc_i128::{i128, u128};\n+\n use Encodable;\n \n /// Represents a json value\n@@ -494,12 +496,14 @@ impl<'a> ::Encoder for Encoder<'a> {\n     }\n \n     fn emit_usize(&mut self, v: usize) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_u128(&mut self, _: u128) -> EncodeResult { unimplemented!() }\n     fn emit_u64(&mut self, v: u64) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_u32(&mut self, v: u32) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_u16(&mut self, v: u16) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_u8(&mut self, v: u8) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n \n     fn emit_isize(&mut self, v: isize) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_i128(&mut self, _: i128) -> EncodeResult { unimplemented!() }\n     fn emit_i64(&mut self, v: i64) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_i32(&mut self, v: i32) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_i16(&mut self, v: i16) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n@@ -742,12 +746,14 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n     }\n \n     fn emit_usize(&mut self, v: usize) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_u128(&mut self, _: u128) -> EncodeResult { unimplemented!() }\n     fn emit_u64(&mut self, v: u64) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_u32(&mut self, v: u32) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_u16(&mut self, v: u16) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_u8(&mut self, v: u8) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n \n     fn emit_isize(&mut self, v: isize) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_i128(&mut self, _: i128) -> EncodeResult { unimplemented!() }\n     fn emit_i64(&mut self, v: i64) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_i32(&mut self, v: i32) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_i16(&mut self, v: i16) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n@@ -2138,11 +2144,13 @@ impl ::Decoder for Decoder {\n     read_primitive! { read_u16, u16 }\n     read_primitive! { read_u32, u32 }\n     read_primitive! { read_u64, u64 }\n+    read_primitive! { read_u128, u128 }\n     read_primitive! { read_isize, isize }\n     read_primitive! { read_i8, i8 }\n     read_primitive! { read_i16, i16 }\n     read_primitive! { read_i32, i32 }\n     read_primitive! { read_i64, i64 }\n+    read_primitive! { read_i128, i128 }\n \n     fn read_f32(&mut self) -> DecodeResult<f32> { self.read_f64().map(|x| x as f32) }\n "}, {"sha": "7a4d1c7a0e449cc185f2fa70d96fb5c8f20f90ec", "filename": "src/libserialize/leb128.rs", "status": "modified", "additions": 31, "deletions": 30, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibserialize%2Fleb128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibserialize%2Fleb128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fleb128.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use rustc_i128::{i128, u128};\n+\n #[inline]\n fn write_to_vec(vec: &mut Vec<u8>, position: usize, byte: u8) {\n     if position == vec.len() {\n@@ -28,7 +30,6 @@ pub fn write_unsigned_leb128_to<W>(mut value: u64, mut write: W) -> usize\n     where W: FnMut(usize, u8)\n {\n     let mut position = 0;\n-\n     loop {\n         let mut byte = (value & 0x7F) as u8;\n         value >>= 7;\n@@ -52,14 +53,14 @@ pub fn write_unsigned_leb128(out: &mut Vec<u8>, start_position: usize, value: u6\n }\n \n #[inline]\n-pub fn read_unsigned_leb128(data: &[u8], start_position: usize) -> (u64, usize) {\n+pub fn read_unsigned_leb128(data: &[u8], start_position: usize) -> (u128, usize) {\n     let mut result = 0;\n     let mut shift = 0;\n     let mut position = start_position;\n     loop {\n         let byte = data[position];\n         position += 1;\n-        result |= ((byte & 0x7F) as u64) << shift;\n+        result |= ((byte & 0x7F) as u128) << shift;\n         if (byte & 0x80) == 0 {\n             break;\n         }\n@@ -76,7 +77,7 @@ pub fn read_unsigned_leb128(data: &[u8], start_position: usize) -> (u64, usize)\n /// The callback `write` is called once for each position\n /// that is to be written to with the byte to be encoded\n /// at that position.\n-pub fn write_signed_leb128_to<W>(mut value: i64, mut write: W) -> usize\n+pub fn write_signed_leb128_to<W>(mut value: i128, mut write: W) -> usize\n     where W: FnMut(usize, u8)\n {\n     let mut position = 0;\n@@ -92,43 +93,43 @@ pub fn write_signed_leb128_to<W>(mut value: i64, mut write: W) -> usize\n \n         write(position, byte);\n         position += 1;\n-\n         if !more {\n             break;\n         }\n     }\n-\n     position\n }\n \n-pub fn write_signed_leb128(out: &mut Vec<u8>, start_position: usize, value: i64) -> usize {\n+pub fn write_signed_leb128(out: &mut Vec<u8>, start_position: usize, value: i128) -> usize {\n     write_signed_leb128_to(value, |i, v| write_to_vec(out, start_position+i, v))\n }\n \n #[inline]\n-pub fn read_signed_leb128(data: &[u8], start_position: usize) -> (i64, usize) {\n-    let mut result = 0;\n-    let mut shift = 0;\n-    let mut position = start_position;\n-    let mut byte;\n-\n-    loop {\n-        byte = data[position];\n-        position += 1;\n-        result |= ((byte & 0x7F) as i64) << shift;\n-        shift += 7;\n-\n-        if (byte & 0x80) == 0 {\n-            break;\n-        }\n-    }\n-\n-    if (shift < 64) && ((byte & 0x40) != 0) {\n-        // sign extend\n-        result |= -(1i64 << shift);\n-    }\n-\n-    (result, position - start_position)\n+pub fn read_signed_leb128(data: &[u8], start_position: usize) -> (i128, usize) {\n+    let (l, r) = read_unsigned_leb128(data, start_position);\n+    (l as i128, r)\n+    // let mut result = 0;\n+    // let mut shift = 0;\n+    // let mut position = start_position;\n+    // let mut byte;\n+\n+    // loop {\n+    //     byte = data[position];\n+    //     position += 1;\n+    //     result |= ((byte & 0x7F) as i128) << shift;\n+    //     shift += 7;\n+\n+    //     if (byte & 0x80) == 0 {\n+    //         break;\n+    //     }\n+    // }\n+\n+    // if (shift < 64) && ((byte & 0x40) != 0) {\n+    //     // sign extend\n+    //     result |= -(1 << shift);\n+    // }\n+\n+    // (result, position - start_position)\n }\n \n #[test]"}, {"sha": "0979860189ca1d5973406733755f650044e22b8f", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -44,6 +44,8 @@ Core encoding and decoding interfaces.\n extern crate std_unicode;\n extern crate collections;\n \n+extern crate rustc_i128;\n+\n pub use self::serialize::{Decoder, Encoder, Decodable, Encodable};\n \n pub use self::serialize::{SpecializationError, SpecializedEncoder, SpecializedDecoder};"}, {"sha": "8a0648d5851a18b988ee74c08d6fb711a1de9284", "filename": "src/libserialize/opaque.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibserialize%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibserialize%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fopaque.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -13,6 +13,8 @@ use std::borrow::Cow;\n use std::io::{self, Write};\n use serialize;\n \n+use rustc_i128::{i128, u128};\n+\n // -----------------------------------------------------------------------------\n // Encoder\n // -----------------------------------------------------------------------------\n@@ -33,7 +35,7 @@ impl<'a> Encoder<'a> {\n macro_rules! write_uleb128 {\n     ($enc:expr, $value:expr) => {{\n         let pos = $enc.cursor.position() as usize;\n-        let bytes_written = write_unsigned_leb128($enc.cursor.get_mut(), pos, $value as u64);\n+        let bytes_written = write_unsigned_leb128($enc.cursor.get_mut(), pos, $value as u128);\n         $enc.cursor.set_position((pos + bytes_written) as u64);\n         Ok(())\n     }}\n@@ -42,7 +44,7 @@ macro_rules! write_uleb128 {\n macro_rules! write_sleb128 {\n     ($enc:expr, $value:expr) => {{\n         let pos = $enc.cursor.position() as usize;\n-        let bytes_written = write_signed_leb128($enc.cursor.get_mut(), pos, $value as i64);\n+        let bytes_written = write_signed_leb128($enc.cursor.get_mut(), pos, $value as i128);\n         $enc.cursor.set_position((pos + bytes_written) as u64);\n         Ok(())\n     }}\n@@ -59,6 +61,10 @@ impl<'a> serialize::Encoder for Encoder<'a> {\n         write_uleb128!(self, v)\n     }\n \n+    fn emit_u128(&mut self, v: u128) -> EncodeResult {\n+        write_uleb128!(self, v)\n+    }\n+\n     fn emit_u64(&mut self, v: u64) -> EncodeResult {\n         write_uleb128!(self, v)\n     }\n@@ -80,6 +86,10 @@ impl<'a> serialize::Encoder for Encoder<'a> {\n         write_sleb128!(self, v)\n     }\n \n+    fn emit_i128(&mut self, v: i128) -> EncodeResult {\n+        write_sleb128!(self, v)\n+    }\n+\n     fn emit_i64(&mut self, v: i64) -> EncodeResult {\n         write_sleb128!(self, v)\n     }\n@@ -184,6 +194,11 @@ impl<'a> serialize::Decoder for Decoder<'a> {\n         Ok(())\n     }\n \n+    #[inline]\n+    fn read_u128(&mut self) -> Result<u128, Self::Error> {\n+        read_uleb128!(self, u128)\n+    }\n+\n     #[inline]\n     fn read_u64(&mut self) -> Result<u64, Self::Error> {\n         read_uleb128!(self, u64)\n@@ -211,6 +226,11 @@ impl<'a> serialize::Decoder for Decoder<'a> {\n         read_uleb128!(self, usize)\n     }\n \n+    #[inline]\n+    fn read_i128(&mut self) -> Result<i128, Self::Error> {\n+        read_sleb128!(self, i128)\n+    }\n+\n     #[inline]\n     fn read_i64(&mut self) -> Result<i64, Self::Error> {\n         read_sleb128!(self, i64)"}, {"sha": "395f2ccbe6d28ef166780479f8b9f1c538dc4df1", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -20,18 +20,21 @@ use std::path;\n use std::rc::Rc;\n use std::cell::{Cell, RefCell};\n use std::sync::Arc;\n+use rustc_i128::{i128, u128};\n \n pub trait Encoder {\n     type Error;\n \n     // Primitive types:\n     fn emit_nil(&mut self) -> Result<(), Self::Error>;\n     fn emit_usize(&mut self, v: usize) -> Result<(), Self::Error>;\n+    fn emit_u128(&mut self, v: u128) -> Result<(), Self::Error>;\n     fn emit_u64(&mut self, v: u64) -> Result<(), Self::Error>;\n     fn emit_u32(&mut self, v: u32) -> Result<(), Self::Error>;\n     fn emit_u16(&mut self, v: u16) -> Result<(), Self::Error>;\n     fn emit_u8(&mut self, v: u8) -> Result<(), Self::Error>;\n     fn emit_isize(&mut self, v: isize) -> Result<(), Self::Error>;\n+    fn emit_i128(&mut self, v: i128) -> Result<(), Self::Error>;\n     fn emit_i64(&mut self, v: i64) -> Result<(), Self::Error>;\n     fn emit_i32(&mut self, v: i32) -> Result<(), Self::Error>;\n     fn emit_i16(&mut self, v: i16) -> Result<(), Self::Error>;\n@@ -144,11 +147,13 @@ pub trait Decoder {\n     // Primitive types:\n     fn read_nil(&mut self) -> Result<(), Self::Error>;\n     fn read_usize(&mut self) -> Result<usize, Self::Error>;\n+    fn read_u128(&mut self) -> Result<u128, Self::Error>;\n     fn read_u64(&mut self) -> Result<u64, Self::Error>;\n     fn read_u32(&mut self) -> Result<u32, Self::Error>;\n     fn read_u16(&mut self) -> Result<u16, Self::Error>;\n     fn read_u8(&mut self) -> Result<u8, Self::Error>;\n     fn read_isize(&mut self) -> Result<isize, Self::Error>;\n+    fn read_i128(&mut self) -> Result<i128, Self::Error>;\n     fn read_i64(&mut self) -> Result<i64, Self::Error>;\n     fn read_i32(&mut self) -> Result<i32, Self::Error>;\n     fn read_i16(&mut self) -> Result<i16, Self::Error>;\n@@ -328,6 +333,20 @@ impl Decodable for u64 {\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl Encodable for u128 {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        s.emit_u128(*self)\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl Decodable for u128 {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<u128, D::Error> {\n+        d.read_u128()\n+    }\n+}\n+\n impl Encodable for isize {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_isize(*self)\n@@ -388,6 +407,20 @@ impl Decodable for i64 {\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl Encodable for i128 {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        s.emit_i128(*self)\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl Decodable for i128 {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<i128, D::Error> {\n+        d.read_i128()\n+    }\n+}\n+\n impl Encodable for str {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_str(self)"}, {"sha": "f1e3996e825bfee7444d6fa777b265091e320540", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -301,6 +301,7 @@\n #![feature(unwind_attributes)]\n #![feature(vec_push_all)]\n #![feature(zero_one)]\n+#![feature(i128)]\n #![cfg_attr(test, feature(update_panic_count))]\n \n // Explicitly import the prelude. The compiler uses this same unstable attribute\n@@ -395,6 +396,9 @@ pub use core::i16;\n pub use core::i32;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::i64;\n+#[unstable(feature = \"i128\", issue = \"35118\")]\n+#[cfg(not(stage0))]\n+pub use core::i128;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::usize;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -423,6 +427,9 @@ pub use core_collections::string;\n pub use core_collections::vec;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use std_unicode::char;\n+#[unstable(feature = \"i128\", issue = \"35118\")]\n+#[cfg(not(stage0))]\n+pub use core::u128;\n \n pub mod f32;\n pub mod f64;"}, {"sha": "a200da6c293eae0ccd1d764d043e86ae5e877104", "filename": "src/libsyntax/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibsyntax%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibsyntax%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2FCargo.toml?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -15,3 +15,4 @@ rustc_bitflags = { path = \"../librustc_bitflags\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n+rustc_i128 = { path = \"../librustc_i128\" }"}, {"sha": "d1257a02a58f97f805dc52dadf1f466cc31938f9", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -33,6 +33,8 @@ use std::u32;\n \n use serialize::{self, Encodable, Decodable, Encoder, Decoder};\n \n+use rustc_i128::{u128, i128};\n+\n /// An identifier contains a Name (index into the interner\n /// table) and a SyntaxContext to track renaming and\n /// macro expansion per Flatt et al., \"Macros That Work Together\"\n@@ -1062,7 +1064,7 @@ pub enum LitKind {\n     /// A character literal (`'a'`)\n     Char(char),\n     /// An integer literal (`1`)\n-    Int(u64, LitIntType),\n+    Int(u128, LitIntType),\n     /// A float literal (`1f64` or `1E10f64`)\n     Float(Symbol, FloatTy),\n     /// A float literal without a suffix (`1.0 or 1.0E10`)\n@@ -1171,6 +1173,7 @@ pub enum IntTy {\n     I16,\n     I32,\n     I64,\n+    I128,\n }\n \n impl fmt::Debug for IntTy {\n@@ -1192,23 +1195,26 @@ impl IntTy {\n             IntTy::I8 => \"i8\",\n             IntTy::I16 => \"i16\",\n             IntTy::I32 => \"i32\",\n-            IntTy::I64 => \"i64\"\n+            IntTy::I64 => \"i64\",\n+            IntTy::I128 => \"i128\",\n         }\n     }\n \n-    pub fn val_to_string(&self, val: i64) -> String {\n+    pub fn val_to_string(&self, val: i128) -> String {\n         // cast to a u64 so we can correctly print INT64_MIN. All integral types\n         // are parsed as u64, so we wouldn't want to print an extra negative\n         // sign.\n-        format!(\"{}{}\", val as u64, self.ty_to_string())\n+        format!(\"{}{}\", val as u128, self.ty_to_string())\n     }\n \n     pub fn ty_max(&self) -> u64 {\n         match *self {\n             IntTy::I8 => 0x80,\n             IntTy::I16 => 0x8000,\n             IntTy::Is | IntTy::I32 => 0x80000000, // FIXME: actually ni about Is\n-            IntTy::I64 => 0x8000000000000000\n+            IntTy::I64 => 0x8000000000000000,\n+            // FIXME: i128\n+            IntTy::I128 => !0u64,\n         }\n     }\n \n@@ -1219,6 +1225,7 @@ impl IntTy {\n             IntTy::I16 => 16,\n             IntTy::I32 => 32,\n             IntTy::I64 => 64,\n+            IntTy::I128 => 128,\n         })\n     }\n }\n@@ -1230,6 +1237,7 @@ pub enum UintTy {\n     U16,\n     U32,\n     U64,\n+    U128,\n }\n \n impl UintTy {\n@@ -1239,11 +1247,12 @@ impl UintTy {\n             UintTy::U8 => \"u8\",\n             UintTy::U16 => \"u16\",\n             UintTy::U32 => \"u32\",\n-            UintTy::U64 => \"u64\"\n+            UintTy::U64 => \"u64\",\n+            UintTy::U128 => \"u128\",\n         }\n     }\n \n-    pub fn val_to_string(&self, val: u64) -> String {\n+    pub fn val_to_string(&self, val: u128) -> String {\n         format!(\"{}{}\", val, self.ty_to_string())\n     }\n \n@@ -1252,7 +1261,9 @@ impl UintTy {\n             UintTy::U8 => 0xff,\n             UintTy::U16 => 0xffff,\n             UintTy::Us | UintTy::U32 => 0xffffffff, // FIXME: actually ni about Us\n-            UintTy::U64 => 0xffffffffffffffff\n+            UintTy::U64 => 0xffffffffffffffff,\n+            // FIXME: i128\n+            UintTy::U128 => 0xffffffffffffffff,\n         }\n     }\n \n@@ -1263,6 +1274,7 @@ impl UintTy {\n             UintTy::U16 => 16,\n             UintTy::U32 => 32,\n             UintTy::U64 => 64,\n+            UintTy::U128 => 128,\n         })\n     }\n }"}, {"sha": "ab8a49b41f25ec876cdeb6a150eceaddf7086ab0", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -899,6 +899,8 @@ fn int_type_of_word(s: &str) -> Option<IntType> {\n         \"u32\" => Some(UnsignedInt(ast::UintTy::U32)),\n         \"i64\" => Some(SignedInt(ast::IntTy::I64)),\n         \"u64\" => Some(UnsignedInt(ast::UintTy::U64)),\n+        \"i128\" => Some(SignedInt(ast::IntTy::I128)),\n+        \"u128\" => Some(UnsignedInt(ast::UintTy::U128)),\n         \"isize\" => Some(SignedInt(ast::IntTy::Is)),\n         \"usize\" => Some(UnsignedInt(ast::UintTy::Us)),\n         _ => None\n@@ -945,7 +947,8 @@ impl IntType {\n             SignedInt(ast::IntTy::I8) | UnsignedInt(ast::UintTy::U8) |\n             SignedInt(ast::IntTy::I16) | UnsignedInt(ast::UintTy::U16) |\n             SignedInt(ast::IntTy::I32) | UnsignedInt(ast::UintTy::U32) |\n-            SignedInt(ast::IntTy::I64) | UnsignedInt(ast::UintTy::U64) => true,\n+            SignedInt(ast::IntTy::I64) | UnsignedInt(ast::UintTy::U64) |\n+            SignedInt(ast::IntTy::I128) | UnsignedInt(ast::UintTy::U128) => true,\n             SignedInt(ast::IntTy::Is) | UnsignedInt(ast::UintTy::Us) => false\n         }\n     }"}, {"sha": "28f0c297303e38f590c9775cd9f1990d2e26afdf", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -16,6 +16,7 @@ use codemap::{dummy_spanned, respan, Spanned};\n use ext::base::ExtCtxt;\n use ptr::P;\n use symbol::{Symbol, keywords};\n+use rustc_i128::u128;\n \n // Transitional reexports so qquote can find the paths it is looking for\n mod syntax {\n@@ -712,23 +713,26 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.expr(sp, ast::ExprKind::Lit(P(respan(sp, lit))))\n     }\n     fn expr_usize(&self, span: Span, i: usize) -> P<ast::Expr> {\n-        self.expr_lit(span, ast::LitKind::Int(i as u64, ast::LitIntType::Unsigned(ast::UintTy::Us)))\n+        self.expr_lit(span, ast::LitKind::Int(i as u128,\n+                                              ast::LitIntType::Unsigned(ast::UintTy::Us)))\n     }\n     fn expr_isize(&self, sp: Span, i: isize) -> P<ast::Expr> {\n         if i < 0 {\n-            let i = (-i) as u64;\n+            let i = (-i) as u128;\n             let lit_ty = ast::LitIntType::Signed(ast::IntTy::Is);\n             let lit = self.expr_lit(sp, ast::LitKind::Int(i, lit_ty));\n             self.expr_unary(sp, ast::UnOp::Neg, lit)\n         } else {\n-            self.expr_lit(sp, ast::LitKind::Int(i as u64, ast::LitIntType::Signed(ast::IntTy::Is)))\n+            self.expr_lit(sp, ast::LitKind::Int(i as u128,\n+                                                ast::LitIntType::Signed(ast::IntTy::Is)))\n         }\n     }\n     fn expr_u32(&self, sp: Span, u: u32) -> P<ast::Expr> {\n-        self.expr_lit(sp, ast::LitKind::Int(u as u64, ast::LitIntType::Unsigned(ast::UintTy::U32)))\n+        self.expr_lit(sp, ast::LitKind::Int(u as u128,\n+                                            ast::LitIntType::Unsigned(ast::UintTy::U32)))\n     }\n     fn expr_u8(&self, sp: Span, u: u8) -> P<ast::Expr> {\n-        self.expr_lit(sp, ast::LitKind::Int(u as u64, ast::LitIntType::Unsigned(ast::UintTy::U8)))\n+        self.expr_lit(sp, ast::LitKind::Int(u as u128, ast::LitIntType::Unsigned(ast::UintTy::U8)))\n     }\n     fn expr_bool(&self, sp: Span, value: bool) -> P<ast::Expr> {\n         self.expr_lit(sp, ast::LitKind::Bool(value))"}, {"sha": "d2eb2636e6b31deaff6bab62a6623e278efb3e16", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -19,6 +19,7 @@ use parse::token;\n use ptr::P;\n use tokenstream::{self, TokenTree};\n \n+\n /// Quasiquoting works via token trees.\n ///\n /// This is registered as a set of expression syntax extension called quote!\n@@ -40,6 +41,7 @@ pub mod rt {\n     pub use parse::new_parser_from_tts;\n     pub use syntax_pos::{BytePos, Span, DUMMY_SP};\n     pub use codemap::{dummy_spanned};\n+    use rustc_i128::{u128};\n \n     pub trait ToTokens {\n         fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree>;\n@@ -288,7 +290,7 @@ pub mod rt {\n                     } else {\n                         *self\n                     };\n-                    let lit = ast::LitKind::Int(val as u64, ast::LitIntType::Signed($tag));\n+                    let lit = ast::LitKind::Int(val as u128, ast::LitIntType::Signed($tag));\n                     let lit = P(ast::Expr {\n                         id: ast::DUMMY_NODE_ID,\n                         node: ast::ExprKind::Lit(P(dummy_spanned(lit))),\n@@ -310,7 +312,7 @@ pub mod rt {\n         (unsigned, $t:ty, $tag:expr) => (\n             impl ToTokens for $t {\n                 fn to_tokens(&self, cx: &ExtCtxt) -> Vec<TokenTree> {\n-                    let lit = ast::LitKind::Int(*self as u64, ast::LitIntType::Unsigned($tag));\n+                    let lit = ast::LitKind::Int(*self as u128, ast::LitIntType::Unsigned($tag));\n                     dummy_spanned(lit).to_tokens(cx)\n                 }\n             }"}, {"sha": "5d6808284f67edba031f3e3d15812035392fb706", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -46,8 +46,9 @@ pub extern crate rustc_errors as errors;\n extern crate syntax_pos;\n extern crate rustc_data_structures;\n \n-extern crate serialize as rustc_serialize; // used by deriving\n+extern crate rustc_i128;\n \n+extern crate serialize as rustc_serialize; // used by deriving\n \n // A variant of 'try!' that panics on an Err. This is used as a crutch on the\n // way towards a non-panic!-prone parser. It should be used for fatal parsing"}, {"sha": "32b61a88ac17f78c94b46a7390f7ab36e2030a6c", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -28,6 +28,8 @@ use std::path::{Path, PathBuf};\n use std::rc::Rc;\n use std::str;\n \n+use rustc_i128::u128;\n+\n pub type PResult<'a, T> = Result<T, DiagnosticBuilder<'a>>;\n \n #[macro_use]\n@@ -557,18 +559,20 @@ pub fn integer_lit(s: &str, suffix: Option<Symbol>, sd: &Handler, sp: Span) -> a\n             \"i16\" => ast::LitIntType::Signed(ast::IntTy::I16),\n             \"i32\" => ast::LitIntType::Signed(ast::IntTy::I32),\n             \"i64\" => ast::LitIntType::Signed(ast::IntTy::I64),\n+            \"i128\" => ast::LitIntType::Signed(ast::IntTy::I128),\n             \"usize\" => ast::LitIntType::Unsigned(ast::UintTy::Us),\n             \"u8\"  => ast::LitIntType::Unsigned(ast::UintTy::U8),\n             \"u16\" => ast::LitIntType::Unsigned(ast::UintTy::U16),\n             \"u32\" => ast::LitIntType::Unsigned(ast::UintTy::U32),\n             \"u64\" => ast::LitIntType::Unsigned(ast::UintTy::U64),\n+            \"u128\" => ast::LitIntType::Unsigned(ast::UintTy::U128),\n             suf => {\n                 // i<digits> and u<digits> look like widths, so lets\n                 // give an error message along those lines\n                 if looks_like_width_suffix(&['i', 'u'], suf) {\n                     sd.struct_span_err(sp, &format!(\"invalid width `{}` for integer literal\",\n                                              &suf[1..]))\n-                      .help(\"valid widths are 8, 16, 32 and 64\")\n+                      .help(\"valid widths are 8, 16, 32, 64 and 128\")\n                       .emit();\n                 } else {\n                     sd.struct_span_err(sp, &format!(\"invalid suffix `{}` for numeric literal\", suf))\n@@ -585,7 +589,7 @@ pub fn integer_lit(s: &str, suffix: Option<Symbol>, sd: &Handler, sp: Span) -> a\n     debug!(\"integer_lit: the type is {:?}, base {:?}, the new string is {:?}, the original \\\n            string was {:?}, the original suffix was {:?}\", ty, base, s, orig, suffix);\n \n-    match u64::from_str_radix(s, base) {\n+    match u128::from_str_radix(s, base) {\n         Ok(r) => ast::LitKind::Int(r, ty),\n         Err(_) => {\n             // small bases are lexed as if they were base 10, e.g, the string"}, {"sha": "2bb38433a26efc47e5c5ce0f8070c8bfb8093796", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -64,6 +64,8 @@ use std::path::{Path, PathBuf};\n use std::rc::Rc;\n use std::slice;\n \n+use rustc_i128::u128;\n+\n bitflags! {\n     flags Restrictions: u8 {\n         const RESTRICTION_STMT_EXPR         = 1 << 0,\n@@ -2044,7 +2046,7 @@ impl<'a> Parser<'a> {\n     pub fn mk_lit_u32(&mut self, i: u32, attrs: ThinVec<Attribute>) -> P<Expr> {\n         let span = &self.span;\n         let lv_lit = P(codemap::Spanned {\n-            node: LitKind::Int(i as u64, ast::LitIntType::Unsigned(UintTy::U32)),\n+            node: LitKind::Int(i as u128, ast::LitIntType::Unsigned(UintTy::U32)),\n             span: *span\n         });\n "}, {"sha": "60e1882fcf582c4ad36f4f423ce3c2b29405641c", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -30,6 +30,8 @@ use std_inject;\n use symbol::{Symbol, keywords};\n use tokenstream::{self, TokenTree};\n \n+use rustc_i128::i128;\n+\n use std::ascii;\n use std::io::{self, Write, Read};\n use std::iter;\n@@ -647,8 +649,7 @@ pub trait PrintState<'a> {\n             ast::LitKind::Int(i, t) => {\n                 match t {\n                     ast::LitIntType::Signed(st) => {\n-                        word(self.writer(),\n-                             &st.val_to_string(i as i64))\n+                        word(self.writer(), &st.val_to_string(i as i128))\n                     }\n                     ast::LitIntType::Unsigned(ut) => {\n                         word(self.writer(), &ut.val_to_string(i))"}, {"sha": "114bf437cfd3eea7432357fab731ad0748bd4182", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e55a83a82bae26851f442859acace2b94f5028/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=b0e55a83a82bae26851f442859acace2b94f5028", "patch": "@@ -782,12 +782,13 @@ fn find_repr_type_name(diagnostic: &Handler, type_attrs: &[ast::Attribute]) -> &\n                 attr::ReprInt(attr::SignedInt(ast::IntTy::I16)) => \"i16\",\n                 attr::ReprInt(attr::SignedInt(ast::IntTy::I32)) => \"i32\",\n                 attr::ReprInt(attr::SignedInt(ast::IntTy::I64)) => \"i64\",\n+                attr::ReprInt(attr::SignedInt(ast::IntTy::I128)) => \"i128\",\n \n                 attr::ReprInt(attr::UnsignedInt(ast::UintTy::Us)) => \"usize\",\n                 attr::ReprInt(attr::UnsignedInt(ast::UintTy::U8)) => \"u8\",\n                 attr::ReprInt(attr::UnsignedInt(ast::UintTy::U16)) => \"u16\",\n                 attr::ReprInt(attr::UnsignedInt(ast::UintTy::U32)) => \"u32\",\n-                attr::ReprInt(attr::UnsignedInt(ast::UintTy::U64)) => \"u64\",\n+                attr::ReprInt(attr::UnsignedInt(ast::UintTy::U128)) => \"u128\",\n             }\n         }\n     }"}]}