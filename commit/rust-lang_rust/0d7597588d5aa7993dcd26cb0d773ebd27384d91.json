{"sha": "0d7597588d5aa7993dcd26cb0d773ebd27384d91", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkNzU5NzU4OGQ1YWE3OTkzZGNkMjZjYjBkNzczZWJkMjczODRkOTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-07-22T05:39:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-07-22T05:39:48Z"}, "message": "Auto merge of #34724 - mitchmindtree:mpsc_receiver_try_recv, r=alexcrichton\n\nAdd a method to the mpsc::Receiver for producing a non-blocking iterator\n\nCurrently, the `mpsc::Receiver` offers methods for receiving values in both blocking (`recv`) and non-blocking (`try_recv`) flavours. However only blocking iteration over values is supported. This PR adds a non-blocking iterator to complement the `try_recv` method, just as the blocking iterator complements the `recv` method.\n\nUse-case\n-------------\n\nI predominantly use rust in my work on real-time systems and in particular real-time audio generation/processing. I use `mpsc::channel`s to communicate between threads in a purely non-blocking manner. I.e. I might send messages from the GUI thread to the audio thread to update the state of the dsp-graph, or from the audio thread to the GUI thread to display the RMS of each node. These are just a couple examples (I'm probably using 30+ channels across my various projects). I almost exclusively use the `mpsc::Receiver::try_recv` method to avoid blocking any of the real-time threads and causing unwanted glitching/stuttering. Now that I mention it, I can't think of a single time that I personally have used the `recv` method (though I can of course see why it would be useful, and perhaps the common case for many people).\n\nAs a result of this experience, I can't help but feel there is a large hole in the `Receiver` API.\n\n| blocking | non-blocking |\n|------------|--------------------|\n| `recv` | `try_recv` |\n| `iter` | \ud83d\ude40   |\n\nFor the most part, I've been working around this using `while let Ok(v) = r.try_recv() { ... }`, however as nice as this is, it is clearly no match for the Iterator API.\n\nAs an example, in the majority of my channel use cases I only want to check for *n* number of messages before breaking from the loop so that I don't miss the audio IO callback or hog the GUI thread for too long when an unexpectedly large number of messages are sent. Currently, I have to write something like this:\n\n```rust\nlet mut take = 100;\nwhile let Ok(msg) = rx.try_recv() {\n    // Do stuff with msg\n    if take == 0 {\n        break;\n    }\n    take -= 1;\n}\n```\n\nor wrap the `try_recv` call in a `Range<usize>`/`FilterMap` iterator combo.\n\nOn the other hand, this PR would allow for the following:\n\n```rust\nfor msg in rx.try_iter().take(100) {\n    // Do stuff with msg\n}\n```\n\nI imagine this might also be useful to game devs, embedded or anyone doing message passing across real-time threads.", "tree": {"sha": "b7f81a0c81d8e6c346c47e648724da25f83a991f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b7f81a0c81d8e6c346c47e648724da25f83a991f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d7597588d5aa7993dcd26cb0d773ebd27384d91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d7597588d5aa7993dcd26cb0d773ebd27384d91", "html_url": "https://github.com/rust-lang/rust/commit/0d7597588d5aa7993dcd26cb0d773ebd27384d91", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d7597588d5aa7993dcd26cb0d773ebd27384d91/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d46ed83e2e410d6c144657ef284f7ab649e3b70d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d46ed83e2e410d6c144657ef284f7ab649e3b70d", "html_url": "https://github.com/rust-lang/rust/commit/d46ed83e2e410d6c144657ef284f7ab649e3b70d"}, {"sha": "05af033b7fec63638497a9780e6b323d327d1e17", "url": "https://api.github.com/repos/rust-lang/rust/commits/05af033b7fec63638497a9780e6b323d327d1e17", "html_url": "https://github.com/rust-lang/rust/commit/05af033b7fec63638497a9780e6b323d327d1e17"}], "stats": {"total": 56, "additions": 56, "deletions": 0}, "files": [{"sha": "11f785dffd16a6b1f67cc0f5e542c02aa23c937a", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/0d7597588d5aa7993dcd26cb0d773ebd27384d91/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d7597588d5aa7993dcd26cb0d773ebd27384d91/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=0d7597588d5aa7993dcd26cb0d773ebd27384d91", "patch": "@@ -311,6 +311,17 @@ pub struct Iter<'a, T: 'a> {\n     rx: &'a Receiver<T>\n }\n \n+/// An iterator that attempts to yield all pending values for a receiver.\n+/// `None` will be returned when there are no pending values remaining or\n+/// if the corresponding channel has hung up.\n+///\n+/// This Iterator will never block the caller in order to wait for data to\n+/// become available. Instead, it will return `None`.\n+#[unstable(feature = \"receiver_try_iter\", issue = \"34931\")]\n+pub struct TryIter<'a, T: 'a> {\n+    rx: &'a Receiver<T>\n+}\n+\n /// An owning iterator over messages on a receiver, this iterator will block\n /// whenever `next` is called, waiting for a new message, and `None` will be\n /// returned when the corresponding channel has hung up.\n@@ -982,6 +993,16 @@ impl<T> Receiver<T> {\n     pub fn iter(&self) -> Iter<T> {\n         Iter { rx: self }\n     }\n+\n+    /// Returns an iterator that will attempt to yield all pending values.\n+    /// It will return `None` if there are no more pending values or if the\n+    /// channel has hung up. The iterator will never `panic!` or block the\n+    /// user by waiting for values.\n+    #[unstable(feature = \"receiver_try_iter\", issue = \"34931\")]\n+    pub fn try_iter(&self) -> TryIter<T> {\n+        TryIter { rx: self }\n+    }\n+\n }\n \n impl<T> select::Packet for Receiver<T> {\n@@ -1077,6 +1098,13 @@ impl<'a, T> Iterator for Iter<'a, T> {\n     fn next(&mut self) -> Option<T> { self.rx.recv().ok() }\n }\n \n+#[unstable(feature = \"receiver_try_iter\", issue = \"34931\")]\n+impl<'a, T> Iterator for TryIter<'a, T> {\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> { self.rx.try_recv().ok() }\n+}\n+\n #[stable(feature = \"receiver_into_iter\", since = \"1.1.0\")]\n impl<'a, T> IntoIterator for &'a Receiver<T> {\n     type Item = T;\n@@ -1814,6 +1842,34 @@ mod tests {\n         assert_eq!(count_rx.recv().unwrap(), 4);\n     }\n \n+    #[test]\n+    fn test_recv_try_iter() {\n+        let (request_tx, request_rx) = channel();\n+        let (response_tx, response_rx) = channel();\n+\n+        // Request `x`s until we have `6`.\n+        let t = thread::spawn(move|| {\n+            let mut count = 0;\n+            loop {\n+                for x in response_rx.try_iter() {\n+                    count += x;\n+                    if count == 6 {\n+                        return count;\n+                    }\n+                }\n+                request_tx.send(()).unwrap();\n+            }\n+        });\n+\n+        for _ in request_rx.iter() {\n+            if response_tx.send(2).is_err() {\n+                break;\n+            }\n+        }\n+\n+        assert_eq!(t.join().unwrap(), 6);\n+    }\n+\n     #[test]\n     fn test_recv_into_iter_owned() {\n         let mut iter = {"}]}