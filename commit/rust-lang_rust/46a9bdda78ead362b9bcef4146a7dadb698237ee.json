{"sha": "46a9bdda78ead362b9bcef4146a7dadb698237ee", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2YTliZGRhNzhlYWQzNjJiOWJjZWY0MTQ2YTdkYWRiNjk4MjM3ZWU=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-01-28T23:49:29Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-01-28T23:49:29Z"}, "message": "rustc: replace \"lvalue\" terminology with \"place\" in the code.", "tree": {"sha": "762250d4e8b981238105dff5a2e9b476298a625f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/762250d4e8b981238105dff5a2e9b476298a625f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/46a9bdda78ead362b9bcef4146a7dadb698237ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/46a9bdda78ead362b9bcef4146a7dadb698237ee", "html_url": "https://github.com/rust-lang/rust/commit/46a9bdda78ead362b9bcef4146a7dadb698237ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/46a9bdda78ead362b9bcef4146a7dadb698237ee/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "06a0e4f7ae6d2e23adff1fe84e2a988f6b77fa53", "url": "https://api.github.com/repos/rust-lang/rust/commits/06a0e4f7ae6d2e23adff1fe84e2a988f6b77fa53", "html_url": "https://github.com/rust-lang/rust/commit/06a0e4f7ae6d2e23adff1fe84e2a988f6b77fa53"}], "stats": {"total": 358, "additions": 179, "deletions": 179}, "files": [{"sha": "297586f140e346e91391f075d68a2d56adf11224", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/46a9bdda78ead362b9bcef4146a7dadb698237ee/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46a9bdda78ead362b9bcef4146a7dadb698237ee/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=46a9bdda78ead362b9bcef4146a7dadb698237ee", "patch": "@@ -1034,10 +1034,10 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           }\n \n           hir::ExprAssign(ref l, ref r) => {\n-            // see comment on lvalues in\n-            // propagate_through_lvalue_components()\n-            let succ = self.write_lvalue(&l, succ, ACC_WRITE);\n-            let succ = self.propagate_through_lvalue_components(&l, succ);\n+            // see comment on places in\n+            // propagate_through_place_components()\n+            let succ = self.write_place(&l, succ, ACC_WRITE);\n+            let succ = self.propagate_through_place_components(&l, succ);\n             self.propagate_through_expr(&r, succ)\n           }\n \n@@ -1047,11 +1047,11 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 let succ = self.propagate_through_expr(&l, succ);\n                 self.propagate_through_expr(&r, succ)\n             } else {\n-                // see comment on lvalues in\n-                // propagate_through_lvalue_components()\n-                let succ = self.write_lvalue(&l, succ, ACC_WRITE|ACC_READ);\n+                // see comment on places in\n+                // propagate_through_place_components()\n+                let succ = self.write_place(&l, succ, ACC_WRITE|ACC_READ);\n                 let succ = self.propagate_through_expr(&r, succ);\n-                self.propagate_through_lvalue_components(&l, succ)\n+                self.propagate_through_place_components(&l, succ)\n             }\n           }\n \n@@ -1121,14 +1121,14 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           hir::ExprInlineAsm(ref ia, ref outputs, ref inputs) => {\n             let succ = ia.outputs.iter().zip(outputs).rev().fold(succ, |succ, (o, output)| {\n-                // see comment on lvalues\n-                // in propagate_through_lvalue_components()\n+                // see comment on places\n+                // in propagate_through_place_components()\n                 if o.is_indirect {\n                     self.propagate_through_expr(output, succ)\n                 } else {\n                     let acc = if o.is_rw { ACC_WRITE|ACC_READ } else { ACC_WRITE };\n-                    let succ = self.write_lvalue(output, succ, acc);\n-                    self.propagate_through_lvalue_components(output, succ)\n+                    let succ = self.write_place(output, succ, acc);\n+                    self.propagate_through_place_components(output, succ)\n                 }\n             });\n \n@@ -1146,11 +1146,11 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         }\n     }\n \n-    fn propagate_through_lvalue_components(&mut self,\n+    fn propagate_through_place_components(&mut self,\n                                            expr: &Expr,\n                                            succ: LiveNode)\n                                            -> LiveNode {\n-        // # Lvalues\n+        // # Places\n         //\n         // In general, the full flow graph structure for an\n         // assignment/move/etc can be handled in one of two ways,\n@@ -1160,15 +1160,15 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         //\n         // The two kinds of graphs are:\n         //\n-        //    Tracked lvalue          Untracked lvalue\n+        //    Tracked place          Untracked place\n         // ----------------------++-----------------------\n         //                       ||\n         //         |             ||           |\n         //         v             ||           v\n         //     (rvalue)          ||       (rvalue)\n         //         |             ||           |\n         //         v             ||           v\n-        // (write of lvalue)     ||   (lvalue components)\n+        // (write of place)     ||   (place components)\n         //         |             ||           |\n         //         v             ||           v\n         //      (succ)           ||        (succ)\n@@ -1177,25 +1177,25 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         //\n         // I will cover the two cases in turn:\n         //\n-        // # Tracked lvalues\n+        // # Tracked places\n         //\n-        // A tracked lvalue is a local variable/argument `x`.  In\n+        // A tracked place is a local variable/argument `x`.  In\n         // these cases, the link_node where the write occurs is linked\n-        // to node id of `x`.  The `write_lvalue()` routine generates\n+        // to node id of `x`.  The `write_place()` routine generates\n         // the contents of this node.  There are no subcomponents to\n         // consider.\n         //\n-        // # Non-tracked lvalues\n+        // # Non-tracked places\n         //\n-        // These are lvalues like `x[5]` or `x.f`.  In that case, we\n+        // These are places like `x[5]` or `x.f`.  In that case, we\n         // basically ignore the value which is written to but generate\n         // reads for the components---`x` in these two examples.  The\n         // components reads are generated by\n-        // `propagate_through_lvalue_components()` (this fn).\n+        // `propagate_through_place_components()` (this fn).\n         //\n-        // # Illegal lvalues\n+        // # Illegal places\n         //\n-        // It is still possible to observe assignments to non-lvalues;\n+        // It is still possible to observe assignments to non-places;\n         // these errors are detected in the later pass borrowck.  We\n         // just ignore such cases and treat them as reads.\n \n@@ -1207,17 +1207,17 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         }\n     }\n \n-    // see comment on propagate_through_lvalue()\n-    fn write_lvalue(&mut self, expr: &Expr, succ: LiveNode, acc: u32)\n+    // see comment on propagate_through_place()\n+    fn write_place(&mut self, expr: &Expr, succ: LiveNode, acc: u32)\n                     -> LiveNode {\n         match expr.node {\n           hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n               self.access_path(expr.id, path, succ, acc)\n           }\n \n-          // We do not track other lvalues, so just propagate through\n+          // We do not track other places, so just propagate through\n           // to their subcomponents.  Also, it may happen that\n-          // non-lvalues occur here, because those are detected in the\n+          // non-places occur here, because those are detected in the\n           // later pass borrowck.\n           _ => succ\n         }\n@@ -1363,14 +1363,14 @@ fn check_arm<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, arm: &'tcx hir::Arm) {\n fn check_expr<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, expr: &'tcx Expr) {\n     match expr.node {\n       hir::ExprAssign(ref l, _) => {\n-        this.check_lvalue(&l);\n+        this.check_place(&l);\n \n         intravisit::walk_expr(this, expr);\n       }\n \n       hir::ExprAssignOp(_, ref l, _) => {\n         if !this.tables.is_method_call(expr) {\n-            this.check_lvalue(&l);\n+            this.check_place(&l);\n         }\n \n         intravisit::walk_expr(this, expr);\n@@ -1381,10 +1381,10 @@ fn check_expr<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, expr: &'tcx Expr) {\n           this.visit_expr(input);\n         }\n \n-        // Output operands must be lvalues\n+        // Output operands must be places\n         for (o, output) in ia.outputs.iter().zip(outputs) {\n           if !o.is_indirect {\n-            this.check_lvalue(output);\n+            this.check_place(output);\n           }\n           this.visit_expr(output);\n         }\n@@ -1409,7 +1409,7 @@ fn check_expr<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, expr: &'tcx Expr) {\n }\n \n impl<'a, 'tcx> Liveness<'a, 'tcx> {\n-    fn check_lvalue(&mut self, expr: &'tcx Expr) {\n+    fn check_place(&mut self, expr: &'tcx Expr) {\n         match expr.node {\n             hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n                 if let Def::Local(nid) = path.def {\n@@ -1423,7 +1423,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 }\n             }\n             _ => {\n-                // For other kinds of lvalues, no checks are required,\n+                // For other kinds of places, no checks are required,\n                 // and any embedded expressions are actually rvalues\n                 intravisit::walk_expr(self, expr);\n             }"}, {"sha": "45b595adfe7b8a8a5c104ecaf9ef0ffb9ee54cad", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/46a9bdda78ead362b9bcef4146a7dadb698237ee/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46a9bdda78ead362b9bcef4146a7dadb698237ee/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=46a9bdda78ead362b9bcef4146a7dadb698237ee", "patch": "@@ -26,8 +26,8 @@\n //!       | E.comp    // access to an interior component\n //!\n //! Imagine a routine ToAddr(Expr) that evaluates an expression and returns an\n-//! address where the result is to be found.  If Expr is an lvalue, then this\n-//! is the address of the lvalue.  If Expr is an rvalue, this is the address of\n+//! address where the result is to be found.  If Expr is a place, then this\n+//! is the address of the place.  If Expr is an rvalue, this is the address of\n //! some temporary spot in memory where the result is stored.\n //!\n //! Now, cat_expr() classifies the expression Expr and the address A=ToAddr(Expr)\n@@ -182,7 +182,7 @@ pub struct cmt_<'tcx> {\n     pub id: ast::NodeId,           // id of expr/pat producing this value\n     pub span: Span,                // span of same expr/pat\n     pub cat: Categorization<'tcx>, // categorization of expr\n-    pub mutbl: MutabilityCategory, // mutability of expr as lvalue\n+    pub mutbl: MutabilityCategory, // mutability of expr as place\n     pub ty: Ty<'tcx>,              // type of the expr (*see WARNING above*)\n     pub note: Note,                // Note about the provenance of this cmt\n }\n@@ -603,7 +603,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         match expr.node {\n           hir::ExprUnary(hir::UnDeref, ref e_base) => {\n             if self.tables.is_method_call(expr) {\n-                self.cat_overloaded_lvalue(expr, e_base, false)\n+                self.cat_overloaded_place(expr, e_base, false)\n             } else {\n                 let base_cmt = self.cat_expr(&e_base)?;\n                 self.cat_deref(expr, base_cmt, false)\n@@ -631,7 +631,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                 // The call to index() returns a `&T` value, which\n                 // is an rvalue. That is what we will be\n                 // dereferencing.\n-                self.cat_overloaded_lvalue(expr, base, true)\n+                self.cat_overloaded_place(expr, base, true)\n             } else {\n                 let base_cmt = self.cat_expr(&base)?;\n                 self.cat_index(expr, base_cmt, expr_ty, InteriorOffsetKind::Index)\n@@ -983,27 +983,27 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         ret\n     }\n \n-    fn cat_overloaded_lvalue(&self,\n+    fn cat_overloaded_place(&self,\n                              expr: &hir::Expr,\n                              base: &hir::Expr,\n                              implicit: bool)\n                              -> McResult<cmt<'tcx>> {\n-        debug!(\"cat_overloaded_lvalue: implicit={}\", implicit);\n+        debug!(\"cat_overloaded_place: implicit={}\", implicit);\n \n         // Reconstruct the output assuming it's a reference with the\n         // same region and mutability as the receiver. This holds for\n         // `Deref(Mut)::Deref(_mut)` and `Index(Mut)::index(_mut)`.\n-        let lvalue_ty = self.expr_ty(expr)?;\n+        let place_ty = self.expr_ty(expr)?;\n         let base_ty = self.expr_ty_adjusted(base)?;\n \n         let (region, mutbl) = match base_ty.sty {\n             ty::TyRef(region, mt) => (region, mt.mutbl),\n             _ => {\n-                span_bug!(expr.span, \"cat_overloaded_lvalue: base is not a reference\")\n+                span_bug!(expr.span, \"cat_overloaded_place: base is not a reference\")\n             }\n         };\n         let ref_ty = self.tcx.mk_ref(region, ty::TypeAndMut {\n-            ty: lvalue_ty,\n+            ty: place_ty,\n             mutbl,\n         });\n \n@@ -1386,7 +1386,7 @@ impl<'tcx> cmt_<'tcx> {\n         }\n     }\n \n-    /// Returns `FreelyAliasable(_)` if this lvalue represents a freely aliasable pointer type.\n+    /// Returns `FreelyAliasable(_)` if this place represents a freely aliasable pointer type.\n     pub fn freely_aliasable(&self) -> Aliasability {\n         // Maybe non-obvious: copied upvars can only be considered\n         // non-aliasable in once closures, since any other kind can be\n@@ -1453,7 +1453,7 @@ impl<'tcx> cmt_<'tcx> {\n                 \"static item\".to_string()\n             }\n             Categorization::Rvalue(..) => {\n-                \"non-lvalue\".to_string()\n+                \"non-place\".to_string()\n             }\n             Categorization::Local(vid) => {\n                 if tcx.hir.is_argument(vid) {"}, {"sha": "dad2d7a7c90fb4ffd33668b8b9844de3cd9cefa9", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46a9bdda78ead362b9bcef4146a7dadb698237ee/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46a9bdda78ead362b9bcef4146a7dadb698237ee/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=46a9bdda78ead362b9bcef4146a7dadb698237ee", "patch": "@@ -1112,7 +1112,7 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n     //    I mean that creating a binding into a ref-counted or managed value\n     //    would still count.)\n     //\n-    // 3. `ET`, which matches both rvalues like `foo()` as well as lvalues\n+    // 3. `ET`, which matches both rvalues like `foo()` as well as places\n     //    based on rvalues like `foo().x[2].y`.\n     //\n     // A subexpression `<rvalue>` that appears in a let initializer\n@@ -1283,7 +1283,7 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n     ///        | (ET)\n     ///        | <rvalue>\n     ///\n-    /// Note: ET is intended to match \"rvalues or lvalues based on rvalues\".\n+    /// Note: ET is intended to match \"rvalues or places based on rvalues\".\n     fn record_rvalue_scope<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n                                      expr: &hir::Expr,\n                                      blk_scope: Option<Scope>) {"}, {"sha": "3b644aa13f321cc8e9183f3490b56432480f885d", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/46a9bdda78ead362b9bcef4146a7dadb698237ee/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46a9bdda78ead362b9bcef4146a7dadb698237ee/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=46a9bdda78ead362b9bcef4146a7dadb698237ee", "patch": "@@ -733,29 +733,29 @@ pub enum TerminatorKind<'tcx> {\n     },\n \n     /// Drop the Place and assign the new value over it. This ensures\n-    /// that the assignment to LV occurs *even if* the destructor for\n+    /// that the assignment to `P` occurs *even if* the destructor for\n     /// place unwinds. Its semantics are best explained by by the\n     /// elaboration:\n     ///\n     /// ```\n     /// BB0 {\n-    ///   DropAndReplace(LV <- RV, goto BB1, unwind BB2)\n+    ///   DropAndReplace(P <- V, goto BB1, unwind BB2)\n     /// }\n     /// ```\n     ///\n     /// becomes\n     ///\n     /// ```\n     /// BB0 {\n-    ///   Drop(LV, goto BB1, unwind BB2)\n+    ///   Drop(P, goto BB1, unwind BB2)\n     /// }\n     /// BB1 {\n-    ///   // LV is now unitialized\n-    ///   LV <- RV\n+    ///   // P is now unitialized\n+    ///   P <- V\n     /// }\n     /// BB2 {\n-    ///   // LV is now unitialized -- its dtor panicked\n-    ///   LV <- RV\n+    ///   // P is now unitialized -- its dtor panicked\n+    ///   P <- V\n     /// }\n     /// ```\n     DropAndReplace {"}, {"sha": "96d69b4fba21a9a0255db52ed91da9714cc2d184", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46a9bdda78ead362b9bcef4146a7dadb698237ee/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46a9bdda78ead362b9bcef4146a7dadb698237ee/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=46a9bdda78ead362b9bcef4146a7dadb698237ee", "patch": "@@ -77,7 +77,7 @@ pub enum Adjust<'tcx> {\n     /// Go from a mut raw pointer to a const raw pointer.\n     MutToConstPointer,\n \n-    /// Dereference once, producing an lvalue.\n+    /// Dereference once, producing a place.\n     Deref(Option<OverloadedDeref<'tcx>>),\n \n     /// Take the address and produce either a `&` or `*` pointer."}, {"sha": "97fa94b5e5cf9c159ccba5baaec181549904f300", "filename": "src/librustc_borrowck/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46a9bdda78ead362b9bcef4146a7dadb698237ee/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46a9bdda78ead362b9bcef4146a7dadb698237ee/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=46a9bdda78ead362b9bcef4146a7dadb698237ee", "patch": "@@ -104,7 +104,7 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n \n     fn scope(&self, cmt: &mc::cmt<'tcx>) -> ty::Region<'tcx> {\n         //! Returns the maximal region scope for the which the\n-        //! lvalue `cmt` is guaranteed to be valid without any\n+        //! place `cmt` is guaranteed to be valid without any\n         //! rooting etc, and presuming `cmt` is not mutated.\n \n         match cmt.cat {"}, {"sha": "bfe894f9eb9408cea3f3f8f5cd940e3f8e4adbe9", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46a9bdda78ead362b9bcef4146a7dadb698237ee/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46a9bdda78ead362b9bcef4146a7dadb698237ee/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=46a9bdda78ead362b9bcef4146a7dadb698237ee", "patch": "@@ -170,7 +170,7 @@ fn build_borrowck_dataflow_data<'a, 'c, 'tcx, F>(this: &mut BorrowckCtxt<'a, 'tc\n     if !force_analysis && move_data.is_empty() && all_loans.is_empty() {\n         // large arrays of data inserted as constants can take a lot of\n         // time and memory to borrow-check - see issue #36799. However,\n-        // they don't have lvalues, so no borrow-check is actually needed.\n+        // they don't have places, so no borrow-check is actually needed.\n         // Recognize that case and skip borrow-checking.\n         debug!(\"skipping loan propagation for {:?} because of no loans\", body_id);\n         return None;"}, {"sha": "a90dcd1072f9513d5319650ffebbb4f7074fb815", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46a9bdda78ead362b9bcef4146a7dadb698237ee/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46a9bdda78ead362b9bcef4146a7dadb698237ee/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=46a9bdda78ead362b9bcef4146a7dadb698237ee", "patch": "@@ -153,7 +153,7 @@ pub struct Assignment {\n     /// span of node where assignment occurs\n     pub span: Span,\n \n-    /// id for l-value expression on lhs of assignment\n+    /// id for place expression on lhs of assignment\n     pub assignee_id: hir::ItemLocalId,\n }\n "}, {"sha": "ba966c9d4e3166f1c729e86dc82c5210820dac5c", "filename": "src/librustc_mir/borrow_check/flows.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/46a9bdda78ead362b9bcef4146a7dadb698237ee/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46a9bdda78ead362b9bcef4146a7dadb698237ee/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs?ref=46a9bdda78ead362b9bcef4146a7dadb698237ee", "patch": "@@ -15,28 +15,28 @@\n \n use rustc::mir::{BasicBlock, Location};\n \n-use dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n-use dataflow::{EverInitializedLvals, MovingOutStatements};\n+use dataflow::{MaybeInitializedPlaces, MaybeUninitializedPlaces};\n+use dataflow::{EverInitializedPlaces, MovingOutStatements};\n use dataflow::{ActiveBorrows, FlowAtLocation, FlowsAtLocation};\n use dataflow::move_paths::HasMoveData;\n use std::fmt;\n \n // (forced to be `pub` due to its use as an associated type below.)\n pub(crate) struct Flows<'b, 'gcx: 'tcx, 'tcx: 'b> {\n     pub borrows: FlowAtLocation<ActiveBorrows<'b, 'gcx, 'tcx>>,\n-    pub inits: FlowAtLocation<MaybeInitializedLvals<'b, 'gcx, 'tcx>>,\n-    pub uninits: FlowAtLocation<MaybeUninitializedLvals<'b, 'gcx, 'tcx>>,\n+    pub inits: FlowAtLocation<MaybeInitializedPlaces<'b, 'gcx, 'tcx>>,\n+    pub uninits: FlowAtLocation<MaybeUninitializedPlaces<'b, 'gcx, 'tcx>>,\n     pub move_outs: FlowAtLocation<MovingOutStatements<'b, 'gcx, 'tcx>>,\n-    pub ever_inits: FlowAtLocation<EverInitializedLvals<'b, 'gcx, 'tcx>>,\n+    pub ever_inits: FlowAtLocation<EverInitializedPlaces<'b, 'gcx, 'tcx>>,\n }\n \n impl<'b, 'gcx, 'tcx> Flows<'b, 'gcx, 'tcx> {\n     pub fn new(\n         borrows: FlowAtLocation<ActiveBorrows<'b, 'gcx, 'tcx>>,\n-        inits: FlowAtLocation<MaybeInitializedLvals<'b, 'gcx, 'tcx>>,\n-        uninits: FlowAtLocation<MaybeUninitializedLvals<'b, 'gcx, 'tcx>>,\n+        inits: FlowAtLocation<MaybeInitializedPlaces<'b, 'gcx, 'tcx>>,\n+        uninits: FlowAtLocation<MaybeUninitializedPlaces<'b, 'gcx, 'tcx>>,\n         move_outs: FlowAtLocation<MovingOutStatements<'b, 'gcx, 'tcx>>,\n-        ever_inits: FlowAtLocation<EverInitializedLvals<'b, 'gcx, 'tcx>>,\n+        ever_inits: FlowAtLocation<EverInitializedPlaces<'b, 'gcx, 'tcx>>,\n     ) -> Self {\n         Flows {\n             borrows,"}, {"sha": "c16d70a14db1941e1107adc60fc45a86343bf73e", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/46a9bdda78ead362b9bcef4146a7dadb698237ee/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46a9bdda78ead362b9bcef4146a7dadb698237ee/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=46a9bdda78ead362b9bcef4146a7dadb698237ee", "patch": "@@ -35,8 +35,8 @@ use dataflow::{do_dataflow, DebugFormatted};\n use dataflow::FlowAtLocation;\n use dataflow::MoveDataParamEnv;\n use dataflow::{DataflowAnalysis, DataflowResultsConsumer};\n-use dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n-use dataflow::{EverInitializedLvals, MovingOutStatements};\n+use dataflow::{MaybeInitializedPlaces, MaybeUninitializedPlaces};\n+use dataflow::{EverInitializedPlaces, MovingOutStatements};\n use dataflow::{BorrowData, Borrows, ReserveOrActivateIndex};\n use dataflow::{ActiveBorrows, Reservations};\n use dataflow::indexes::BorrowIndex;\n@@ -160,7 +160,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         id,\n         &attributes,\n         &dead_unwinds,\n-        MaybeInitializedLvals::new(tcx, mir, &mdpe),\n+        MaybeInitializedPlaces::new(tcx, mir, &mdpe),\n         |bd, i| DebugFormatted::new(&bd.move_data().move_paths[i]),\n     ));\n     let flow_uninits = FlowAtLocation::new(do_dataflow(\n@@ -169,7 +169,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         id,\n         &attributes,\n         &dead_unwinds,\n-        MaybeUninitializedLvals::new(tcx, mir, &mdpe),\n+        MaybeUninitializedPlaces::new(tcx, mir, &mdpe),\n         |bd, i| DebugFormatted::new(&bd.move_data().move_paths[i]),\n     ));\n     let flow_move_outs = FlowAtLocation::new(do_dataflow(\n@@ -187,7 +187,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         id,\n         &attributes,\n         &dead_unwinds,\n-        EverInitializedLvals::new(tcx, mir, &mdpe),\n+        EverInitializedPlaces::new(tcx, mir, &mdpe),\n         |bd, i| DebugFormatted::new(&bd.move_data().inits[i]),\n     ));\n "}, {"sha": "66ca74b0139a31a31af1ae94c6272cf0ed8ebf60", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46a9bdda78ead362b9bcef4146a7dadb698237ee/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46a9bdda78ead362b9bcef4146a7dadb698237ee/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=46a9bdda78ead362b9bcef4146a7dadb698237ee", "patch": "@@ -19,7 +19,7 @@ use std::io;\n use transform::MirSource;\n use util::liveness::{LivenessResults, LocalSet};\n use dataflow::FlowAtLocation;\n-use dataflow::MaybeInitializedLvals;\n+use dataflow::MaybeInitializedPlaces;\n use dataflow::move_paths::MoveData;\n \n use util as mir_util;\n@@ -71,7 +71,7 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     universal_regions: UniversalRegions<'tcx>,\n     mir: &Mir<'tcx>,\n     param_env: ty::ParamEnv<'gcx>,\n-    flow_inits: &mut FlowAtLocation<MaybeInitializedLvals<'cx, 'gcx, 'tcx>>,\n+    flow_inits: &mut FlowAtLocation<MaybeInitializedPlaces<'cx, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n ) -> (\n     RegionInferenceContext<'tcx>,"}, {"sha": "6c2037810d3260d831b5227f6f6b88fcd18428e2", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/46a9bdda78ead362b9bcef4146a7dadb698237ee/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46a9bdda78ead362b9bcef4146a7dadb698237ee/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs?ref=46a9bdda78ead362b9bcef4146a7dadb698237ee", "patch": "@@ -10,7 +10,7 @@\n \n use dataflow::{FlowAtLocation, FlowsAtLocation};\n use borrow_check::nll::region_infer::Cause;\n-use dataflow::MaybeInitializedLvals;\n+use dataflow::MaybeInitializedPlaces;\n use dataflow::move_paths::{HasMoveData, MoveData};\n use rustc::mir::{BasicBlock, Location, Mir};\n use rustc::mir::Local;\n@@ -34,7 +34,7 @@ pub(super) fn generate<'gcx, 'tcx>(\n     cx: &mut TypeChecker<'_, 'gcx, 'tcx>,\n     mir: &Mir<'tcx>,\n     liveness: &LivenessResults,\n-    flow_inits: &mut FlowAtLocation<MaybeInitializedLvals<'_, 'gcx, 'tcx>>,\n+    flow_inits: &mut FlowAtLocation<MaybeInitializedPlaces<'_, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n ) {\n     let tcx = cx.tcx();\n@@ -63,7 +63,7 @@ where\n     tcx: TyCtxt<'typeck, 'gcx, 'tcx>,\n     mir: &'gen Mir<'tcx>,\n     liveness: &'gen LivenessResults,\n-    flow_inits: &'gen mut FlowAtLocation<MaybeInitializedLvals<'flow, 'gcx, 'tcx>>,\n+    flow_inits: &'gen mut FlowAtLocation<MaybeInitializedPlaces<'flow, 'gcx, 'tcx>>,\n     move_data: &'gen MoveData<'tcx>,\n }\n "}, {"sha": "015eb8a3b6643bfddf5ddaed9837fc899cd70433", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46a9bdda78ead362b9bcef4146a7dadb698237ee/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46a9bdda78ead362b9bcef4146a7dadb698237ee/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=46a9bdda78ead362b9bcef4146a7dadb698237ee", "patch": "@@ -15,7 +15,7 @@ use borrow_check::nll::region_infer::Cause;\n use borrow_check::nll::region_infer::ClosureRegionRequirementsExt;\n use borrow_check::nll::universal_regions::UniversalRegions;\n use dataflow::FlowAtLocation;\n-use dataflow::MaybeInitializedLvals;\n+use dataflow::MaybeInitializedPlaces;\n use dataflow::move_paths::MoveData;\n use rustc::hir::def_id::DefId;\n use rustc::infer::{InferCtxt, InferOk, InferResult, LateBoundRegionConversionTime, UnitResult};\n@@ -100,7 +100,7 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n     mir_def_id: DefId,\n     universal_regions: &UniversalRegions<'tcx>,\n     liveness: &LivenessResults,\n-    flow_inits: &mut FlowAtLocation<MaybeInitializedLvals<'_, 'gcx, 'tcx>>,\n+    flow_inits: &mut FlowAtLocation<MaybeInitializedPlaces<'_, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n ) -> MirTypeckRegionConstraints<'tcx> {\n     let body_id = infcx.tcx.hir.as_local_node_id(mir_def_id).unwrap();"}, {"sha": "632bb5b34284da8e3eb2fab4607dbbc01437a3fb", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/46a9bdda78ead362b9bcef4146a7dadb698237ee/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46a9bdda78ead362b9bcef4146a7dadb698237ee/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=46a9bdda78ead362b9bcef4146a7dadb698237ee", "patch": "@@ -575,10 +575,10 @@ impl<'a, 'b, 'tcx> FindPlaceUses<'a, 'b, 'tcx> {\n     /// has a reservation at the time).\n     fn is_potential_use(context: PlaceContext) -> bool {\n         match context {\n-            // storage effects on an place do not activate it\n+            // storage effects on a place do not activate it\n             PlaceContext::StorageLive | PlaceContext::StorageDead => false,\n \n-            // validation effects do not activate an place\n+            // validation effects do not activate a place\n             //\n             // FIXME: Should they? Is it just another read? Or can we\n             // guarantee it won't dereference the stored address? How\n@@ -589,11 +589,11 @@ impl<'a, 'b, 'tcx> FindPlaceUses<'a, 'b, 'tcx> {\n             // AsmOutput existed, but it's not necessarily a pure overwrite.\n             // so it's possible this should activate the place.\n             PlaceContext::AsmOutput |\n-            // pure overwrites of an place do not activate it. (note\n+            // pure overwrites of a place do not activate it. (note\n             // PlaceContext::Call is solely about dest place)\n             PlaceContext::Store | PlaceContext::Call => false,\n \n-            // reads of an place *do* activate it\n+            // reads of a place *do* activate it\n             PlaceContext::Move |\n             PlaceContext::Copy |\n             PlaceContext::Drop |"}, {"sha": "e7c15625cbe2be9bbf946c81395ef3a0d8cde61c", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 52, "deletions": 52, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/46a9bdda78ead362b9bcef4146a7dadb698237ee/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46a9bdda78ead362b9bcef4146a7dadb698237ee/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=46a9bdda78ead362b9bcef4146a7dadb698237ee", "patch": "@@ -36,7 +36,7 @@ pub use self::storage_liveness::*;\n #[allow(dead_code)]\n pub(super) mod borrows;\n \n-/// `MaybeInitializedLvals` tracks all l-values that might be\n+/// `MaybeInitializedPlaces` tracks all places that might be\n /// initialized upon reaching a particular point in the control flow\n /// for a function.\n ///\n@@ -63,35 +63,35 @@ pub(super) mod borrows;\n /// }\n /// ```\n ///\n-/// To determine whether an l-value *must* be initialized at a\n+/// To determine whether a place *must* be initialized at a\n /// particular control-flow point, one can take the set-difference\n-/// between this data and the data from `MaybeUninitializedLvals` at the\n+/// between this data and the data from `MaybeUninitializedPlaces` at the\n /// corresponding control-flow point.\n ///\n /// Similarly, at a given `drop` statement, the set-intersection\n-/// between this data and `MaybeUninitializedLvals` yields the set of\n-/// l-values that would require a dynamic drop-flag at that statement.\n-pub struct MaybeInitializedLvals<'a, 'gcx: 'tcx, 'tcx: 'a> {\n+/// between this data and `MaybeUninitializedPlaces` yields the set of\n+/// places that would require a dynamic drop-flag at that statement.\n+pub struct MaybeInitializedPlaces<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     mir: &'a Mir<'tcx>,\n     mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>,\n }\n \n-impl<'a, 'gcx: 'tcx, 'tcx> MaybeInitializedLvals<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx: 'tcx, 'tcx> MaybeInitializedPlaces<'a, 'gcx, 'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                mir: &'a Mir<'tcx>,\n                mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>)\n                -> Self\n     {\n-        MaybeInitializedLvals { tcx: tcx, mir: mir, mdpe: mdpe }\n+        MaybeInitializedPlaces { tcx: tcx, mir: mir, mdpe: mdpe }\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HasMoveData<'tcx> for MaybeInitializedLvals<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> HasMoveData<'tcx> for MaybeInitializedPlaces<'a, 'gcx, 'tcx> {\n     fn move_data(&self) -> &MoveData<'tcx> { &self.mdpe.move_data }\n }\n \n-/// `MaybeUninitializedLvals` tracks all l-values that might be\n+/// `MaybeUninitializedPlaces` tracks all places that might be\n /// uninitialized upon reaching a particular point in the control flow\n /// for a function.\n ///\n@@ -118,42 +118,42 @@ impl<'a, 'gcx, 'tcx> HasMoveData<'tcx> for MaybeInitializedLvals<'a, 'gcx, 'tcx>\n /// }\n /// ```\n ///\n-/// To determine whether an l-value *must* be uninitialized at a\n+/// To determine whether a place *must* be uninitialized at a\n /// particular control-flow point, one can take the set-difference\n-/// between this data and the data from `MaybeInitializedLvals` at the\n+/// between this data and the data from `MaybeInitializedPlaces` at the\n /// corresponding control-flow point.\n ///\n /// Similarly, at a given `drop` statement, the set-intersection\n-/// between this data and `MaybeInitializedLvals` yields the set of\n-/// l-values that would require a dynamic drop-flag at that statement.\n-pub struct MaybeUninitializedLvals<'a, 'gcx: 'tcx, 'tcx: 'a> {\n+/// between this data and `MaybeInitializedPlaces` yields the set of\n+/// places that would require a dynamic drop-flag at that statement.\n+pub struct MaybeUninitializedPlaces<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     mir: &'a Mir<'tcx>,\n     mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>,\n }\n \n-impl<'a, 'gcx, 'tcx> MaybeUninitializedLvals<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> MaybeUninitializedPlaces<'a, 'gcx, 'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                mir: &'a Mir<'tcx>,\n                mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>)\n                -> Self\n     {\n-        MaybeUninitializedLvals { tcx: tcx, mir: mir, mdpe: mdpe }\n+        MaybeUninitializedPlaces { tcx: tcx, mir: mir, mdpe: mdpe }\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HasMoveData<'tcx> for MaybeUninitializedLvals<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> HasMoveData<'tcx> for MaybeUninitializedPlaces<'a, 'gcx, 'tcx> {\n     fn move_data(&self) -> &MoveData<'tcx> { &self.mdpe.move_data }\n }\n \n-/// `DefinitelyInitializedLvals` tracks all l-values that are definitely\n+/// `DefinitelyInitializedPlaces` tracks all places that are definitely\n /// initialized upon reaching a particular point in the control flow\n /// for a function.\n ///\n /// FIXME: Note that once flow-analysis is complete, this should be\n-/// the set-complement of MaybeUninitializedLvals; thus we can get rid\n+/// the set-complement of MaybeUninitializedPlaces; thus we can get rid\n /// of one or the other of these two. I'm inclined to get rid of\n-/// MaybeUninitializedLvals, simply because the sets will tend to be\n+/// MaybeUninitializedPlaces, simply because the sets will tend to be\n /// smaller in this analysis and thus easier for humans to process\n /// when debugging.\n ///\n@@ -180,43 +180,43 @@ impl<'a, 'gcx, 'tcx> HasMoveData<'tcx> for MaybeUninitializedLvals<'a, 'gcx, 'tc\n /// }\n /// ```\n ///\n-/// To determine whether an l-value *may* be uninitialized at a\n+/// To determine whether a place *may* be uninitialized at a\n /// particular control-flow point, one can take the set-complement\n /// of this data.\n ///\n /// Similarly, at a given `drop` statement, the set-difference between\n-/// this data and `MaybeInitializedLvals` yields the set of l-values\n+/// this data and `MaybeInitializedPlaces` yields the set of places\n /// that would require a dynamic drop-flag at that statement.\n-pub struct DefinitelyInitializedLvals<'a, 'gcx: 'tcx, 'tcx: 'a> {\n+pub struct DefinitelyInitializedPlaces<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     mir: &'a Mir<'tcx>,\n     mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>,\n }\n \n-impl<'a, 'gcx, 'tcx: 'a> DefinitelyInitializedLvals<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx: 'a> DefinitelyInitializedPlaces<'a, 'gcx, 'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                mir: &'a Mir<'tcx>,\n                mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>)\n                -> Self\n     {\n-        DefinitelyInitializedLvals { tcx: tcx, mir: mir, mdpe: mdpe }\n+        DefinitelyInitializedPlaces { tcx: tcx, mir: mir, mdpe: mdpe }\n     }\n }\n \n-impl<'a, 'gcx, 'tcx: 'a> HasMoveData<'tcx> for DefinitelyInitializedLvals<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx: 'a> HasMoveData<'tcx> for DefinitelyInitializedPlaces<'a, 'gcx, 'tcx> {\n     fn move_data(&self) -> &MoveData<'tcx> { &self.mdpe.move_data }\n }\n \n /// `MovingOutStatements` tracks the statements that perform moves out\n-/// of particular l-values. More precisely, it tracks whether the\n+/// of particular places. More precisely, it tracks whether the\n /// *effect* of such moves (namely, the uninitialization of the\n-/// l-value in question) can reach some point in the control-flow of\n+/// place in question) can reach some point in the control-flow of\n /// the function, or if that effect is \"killed\" by some intervening\n-/// operation reinitializing that l-value.\n+/// operation reinitializing that place.\n ///\n /// The resulting dataflow is a more enriched version of\n-/// `MaybeUninitializedLvals`. Both structures on their own only tell\n-/// you if an l-value *might* be uninitialized at a given point in the\n+/// `MaybeUninitializedPlaces`. Both structures on their own only tell\n+/// you if a place *might* be uninitialized at a given point in the\n /// control flow. But `MovingOutStatements` also includes the added\n /// data of *which* particular statement causing the deinitialization\n /// that the borrow checker's error message may need to report.\n@@ -241,7 +241,7 @@ impl<'a, 'gcx, 'tcx> HasMoveData<'tcx> for MovingOutStatements<'a, 'gcx, 'tcx> {\n     fn move_data(&self) -> &MoveData<'tcx> { &self.mdpe.move_data }\n }\n \n-/// `EverInitializedLvals` tracks all l-values that might have ever been\n+/// `EverInitializedPlaces` tracks all places that might have ever been\n /// initialized upon reaching a particular point in the control flow\n /// for a function, without an intervening `Storage Dead`.\n ///\n@@ -270,28 +270,28 @@ impl<'a, 'gcx, 'tcx> HasMoveData<'tcx> for MovingOutStatements<'a, 'gcx, 'tcx> {\n ///     c = S;                                 // {a, b, c, d }\n /// }\n /// ```\n-pub struct EverInitializedLvals<'a, 'gcx: 'tcx, 'tcx: 'a> {\n+pub struct EverInitializedPlaces<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     mir: &'a Mir<'tcx>,\n     mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>,\n }\n \n-impl<'a, 'gcx: 'tcx, 'tcx: 'a> EverInitializedLvals<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx: 'tcx, 'tcx: 'a> EverInitializedPlaces<'a, 'gcx, 'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                mir: &'a Mir<'tcx>,\n                mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>)\n                -> Self\n     {\n-        EverInitializedLvals { tcx: tcx, mir: mir, mdpe: mdpe }\n+        EverInitializedPlaces { tcx: tcx, mir: mir, mdpe: mdpe }\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HasMoveData<'tcx> for EverInitializedLvals<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> HasMoveData<'tcx> for EverInitializedPlaces<'a, 'gcx, 'tcx> {\n     fn move_data(&self) -> &MoveData<'tcx> { &self.mdpe.move_data }\n }\n \n \n-impl<'a, 'gcx, 'tcx> MaybeInitializedLvals<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> MaybeInitializedPlaces<'a, 'gcx, 'tcx> {\n     fn update_bits(sets: &mut BlockSets<MovePathIndex>, path: MovePathIndex,\n                    state: DropFlagState)\n     {\n@@ -302,7 +302,7 @@ impl<'a, 'gcx, 'tcx> MaybeInitializedLvals<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> MaybeUninitializedLvals<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> MaybeUninitializedPlaces<'a, 'gcx, 'tcx> {\n     fn update_bits(sets: &mut BlockSets<MovePathIndex>, path: MovePathIndex,\n                    state: DropFlagState)\n     {\n@@ -313,7 +313,7 @@ impl<'a, 'gcx, 'tcx> MaybeUninitializedLvals<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> DefinitelyInitializedLvals<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> DefinitelyInitializedPlaces<'a, 'gcx, 'tcx> {\n     fn update_bits(sets: &mut BlockSets<MovePathIndex>, path: MovePathIndex,\n                    state: DropFlagState)\n     {\n@@ -324,7 +324,7 @@ impl<'a, 'gcx, 'tcx> DefinitelyInitializedLvals<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> BitDenotation for MaybeInitializedLvals<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> BitDenotation for MaybeInitializedPlaces<'a, 'gcx, 'tcx> {\n     type Idx = MovePathIndex;\n     fn name() -> &'static str { \"maybe_init\" }\n     fn bits_per_block(&self) -> usize {\n@@ -375,7 +375,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for MaybeInitializedLvals<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> BitDenotation for MaybeUninitializedLvals<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> BitDenotation for MaybeUninitializedPlaces<'a, 'gcx, 'tcx> {\n     type Idx = MovePathIndex;\n     fn name() -> &'static str { \"maybe_uninit\" }\n     fn bits_per_block(&self) -> usize {\n@@ -430,7 +430,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for MaybeUninitializedLvals<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> BitDenotation for DefinitelyInitializedLvals<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> BitDenotation for DefinitelyInitializedPlaces<'a, 'gcx, 'tcx> {\n     type Idx = MovePathIndex;\n     fn name() -> &'static str { \"definite_init\" }\n     fn bits_per_block(&self) -> usize {\n@@ -561,7 +561,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for MovingOutStatements<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> BitDenotation for EverInitializedLvals<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> BitDenotation for EverInitializedPlaces<'a, 'gcx, 'tcx> {\n     type Idx = InitIndex;\n     fn name() -> &'static str { \"ever_init\" }\n     fn bits_per_block(&self) -> usize {\n@@ -657,21 +657,21 @@ impl<'a, 'gcx, 'tcx> BitDenotation for EverInitializedLvals<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> BitwiseOperator for MaybeInitializedLvals<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> BitwiseOperator for MaybeInitializedPlaces<'a, 'gcx, 'tcx> {\n     #[inline]\n     fn join(&self, pred1: usize, pred2: usize) -> usize {\n         pred1 | pred2 // \"maybe\" means we union effects of both preds\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> BitwiseOperator for MaybeUninitializedLvals<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> BitwiseOperator for MaybeUninitializedPlaces<'a, 'gcx, 'tcx> {\n     #[inline]\n     fn join(&self, pred1: usize, pred2: usize) -> usize {\n         pred1 | pred2 // \"maybe\" means we union effects of both preds\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> BitwiseOperator for DefinitelyInitializedLvals<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> BitwiseOperator for DefinitelyInitializedPlaces<'a, 'gcx, 'tcx> {\n     #[inline]\n     fn join(&self, pred1: usize, pred2: usize) -> usize {\n         pred1 & pred2 // \"definitely\" means we intersect effects of both preds\n@@ -685,7 +685,7 @@ impl<'a, 'gcx, 'tcx> BitwiseOperator for MovingOutStatements<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> BitwiseOperator for EverInitializedLvals<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> BitwiseOperator for EverInitializedPlaces<'a, 'gcx, 'tcx> {\n     #[inline]\n     fn join(&self, pred1: usize, pred2: usize) -> usize {\n         pred1 | pred2 // inits from both preds are in scope\n@@ -702,21 +702,21 @@ impl<'a, 'gcx, 'tcx> BitwiseOperator for EverInitializedLvals<'a, 'gcx, 'tcx> {\n // propagating, or you start at all-ones and then use Intersect as\n // your merge when propagating.\n \n-impl<'a, 'gcx, 'tcx> InitialFlow for MaybeInitializedLvals<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> InitialFlow for MaybeInitializedPlaces<'a, 'gcx, 'tcx> {\n     #[inline]\n     fn bottom_value() -> bool {\n         false // bottom = uninitialized\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> InitialFlow for MaybeUninitializedLvals<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> InitialFlow for MaybeUninitializedPlaces<'a, 'gcx, 'tcx> {\n     #[inline]\n     fn bottom_value() -> bool {\n         false // bottom = initialized (start_block_effect counters this at outset)\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> InitialFlow for DefinitelyInitializedLvals<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> InitialFlow for DefinitelyInitializedPlaces<'a, 'gcx, 'tcx> {\n     #[inline]\n     fn bottom_value() -> bool {\n         true // bottom = initialized (start_block_effect counters this at outset)\n@@ -730,7 +730,7 @@ impl<'a, 'gcx, 'tcx> InitialFlow for MovingOutStatements<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> InitialFlow for EverInitializedLvals<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> InitialFlow for EverInitializedPlaces<'a, 'gcx, 'tcx> {\n     #[inline]\n     fn bottom_value() -> bool {\n         false // bottom = no initialized variables by default"}, {"sha": "bd63198ecd0d273c127723a49efb48e62b00345d", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/46a9bdda78ead362b9bcef4146a7dadb698237ee/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46a9bdda78ead362b9bcef4146a7dadb698237ee/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=46a9bdda78ead362b9bcef4146a7dadb698237ee", "patch": "@@ -26,9 +26,9 @@ use std::path::PathBuf;\n use std::usize;\n \n pub use self::impls::{MaybeStorageLive};\n-pub use self::impls::{MaybeInitializedLvals, MaybeUninitializedLvals};\n-pub use self::impls::{DefinitelyInitializedLvals, MovingOutStatements};\n-pub use self::impls::EverInitializedLvals;\n+pub use self::impls::{MaybeInitializedPlaces, MaybeUninitializedPlaces};\n+pub use self::impls::{DefinitelyInitializedPlaces, MovingOutStatements};\n+pub use self::impls::EverInitializedPlaces;\n pub use self::impls::borrows::{Borrows, BorrowData};\n pub(crate) use self::impls::borrows::{ActiveBorrows, Reservations, ReserveOrActivateIndex};\n pub use self::at_location::{FlowAtLocation, FlowsAtLocation};"}, {"sha": "7b6ebc6fba8722e93d834113e02955e292e28c87", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/46a9bdda78ead362b9bcef4146a7dadb698237ee/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46a9bdda78ead362b9bcef4146a7dadb698237ee/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=46a9bdda78ead362b9bcef4146a7dadb698237ee", "patch": "@@ -86,7 +86,7 @@ impl MoveOutIndex {\n /// It follows a tree structure.\n ///\n /// Given `struct X { m: M, n: N }` and `x: X`, moves like `drop x.m;`\n-/// move *out* of the l-value `x.m`.\n+/// move *out* of the place `x.m`.\n ///\n /// The MovePaths representing `x.m` and `x.n` are siblings (that is,\n /// one of them will link to the other via the `next_sibling` field,\n@@ -222,7 +222,7 @@ impl fmt::Debug for Init {\n     }\n }\n \n-/// Tables mapping from an l-value to its MovePathIndex.\n+/// Tables mapping from a place to its MovePathIndex.\n #[derive(Debug)]\n pub struct MovePathLookup<'tcx> {\n     locals: IndexVec<Local, MovePathIndex>,\n@@ -247,7 +247,7 @@ pub enum LookupResult {\n impl<'tcx> MovePathLookup<'tcx> {\n     // Unlike the builder `fn move_path_for` below, this lookup\n     // alternative will *not* create a MovePath on the fly for an\n-    // unknown l-value, but will rather return the nearest available\n+    // unknown place, but will rather return the nearest available\n     // parent.\n     pub fn find(&self, place: &Place<'tcx>) -> LookupResult {\n         match *place {"}, {"sha": "701b7a07ac988f131f710cb6e8f0730b021d3344", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/46a9bdda78ead362b9bcef4146a7dadb698237ee/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46a9bdda78ead362b9bcef4146a7dadb698237ee/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=46a9bdda78ead362b9bcef4146a7dadb698237ee", "patch": "@@ -9,17 +9,17 @@ use interpret::memory::HasMemory;\n \n #[derive(Copy, Clone, Debug)]\n pub enum Place {\n-    /// An place referring to a value allocated in the `Memory` system.\n+    /// A place referring to a value allocated in the `Memory` system.\n     Ptr {\n-        /// An place may have an invalid (integral or undef) pointer,\n+        /// A place may have an invalid (integral or undef) pointer,\n         /// since it might be turned back into a reference\n         /// before ever being dereferenced.\n         ptr: Pointer,\n         align: Align,\n         extra: PlaceExtra,\n     },\n \n-    /// An place referring to a value on the stack. Represented by a stack frame index paired with\n+    /// A place referring to a value on the stack. Represented by a stack frame index paired with\n     /// a Mir local index.\n     Local { frame: usize, local: mir::Local },\n }\n@@ -33,7 +33,7 @@ pub enum PlaceExtra {\n }\n \n impl<'tcx> Place {\n-    /// Produces an Place that will error if attempted to be read from\n+    /// Produces a Place that will error if attempted to be read from\n     pub fn undef() -> Self {\n         Self::from_primval_ptr(PrimVal::Undef.into(), Align::from_bytes(1, 1).unwrap())\n     }"}, {"sha": "9eca343cb5edceb6fe45d11a0752fdb7d2f13252", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/46a9bdda78ead362b9bcef4146a7dadb698237ee/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46a9bdda78ead362b9bcef4146a7dadb698237ee/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=46a9bdda78ead362b9bcef4146a7dadb698237ee", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use dataflow::move_paths::{HasMoveData, MoveData, MovePathIndex, LookupResult};\n-use dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n+use dataflow::{MaybeInitializedPlaces, MaybeUninitializedPlaces};\n use dataflow::{DataflowResults};\n use dataflow::{on_all_children_bits, on_all_drop_children_bits};\n use dataflow::{drop_flag_effects_for_location, on_lookup_result_bits};\n@@ -60,11 +60,11 @@ impl MirPass for ElaborateDrops {\n             let dead_unwinds = find_dead_unwinds(tcx, mir, id, &env);\n             let flow_inits =\n                 do_dataflow(tcx, mir, id, &[], &dead_unwinds,\n-                            MaybeInitializedLvals::new(tcx, mir, &env),\n+                            MaybeInitializedPlaces::new(tcx, mir, &env),\n                             |bd, p| DebugFormatted::new(&bd.move_data().move_paths[p]));\n             let flow_uninits =\n                 do_dataflow(tcx, mir, id, &[], &dead_unwinds,\n-                            MaybeUninitializedLvals::new(tcx, mir, &env),\n+                            MaybeUninitializedPlaces::new(tcx, mir, &env),\n                             |bd, p| DebugFormatted::new(&bd.move_data().move_paths[p]));\n \n             ElaborateDropsCtxt {\n@@ -97,7 +97,7 @@ fn find_dead_unwinds<'a, 'tcx>(\n     let mut dead_unwinds = IdxSetBuf::new_empty(mir.basic_blocks().len());\n     let flow_inits =\n         do_dataflow(tcx, mir, id, &[], &dead_unwinds,\n-                    MaybeInitializedLvals::new(tcx, mir, &env),\n+                    MaybeInitializedPlaces::new(tcx, mir, &env),\n                     |bd, p| DebugFormatted::new(&bd.move_data().move_paths[p]));\n     for (bb, bb_data) in mir.basic_blocks().iter_enumerated() {\n         let location = match bb_data.terminator().kind {\n@@ -300,8 +300,8 @@ struct ElaborateDropsCtxt<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     mir: &'a Mir<'tcx>,\n     env: &'a MoveDataParamEnv<'tcx, 'tcx>,\n-    flow_inits: DataflowResults<MaybeInitializedLvals<'a, 'tcx, 'tcx>>,\n-    flow_uninits:  DataflowResults<MaybeUninitializedLvals<'a, 'tcx, 'tcx>>,\n+    flow_inits: DataflowResults<MaybeInitializedPlaces<'a, 'tcx, 'tcx>>,\n+    flow_uninits:  DataflowResults<MaybeUninitializedPlaces<'a, 'tcx, 'tcx>>,\n     drop_flags: FxHashMap<MovePathIndex, Local>,\n     patch: MirPatch<'tcx>,\n }"}, {"sha": "76283edac7284d60b711280aa7d341b647c8bafa", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/46a9bdda78ead362b9bcef4146a7dadb698237ee/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46a9bdda78ead362b9bcef4146a7dadb698237ee/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=46a9bdda78ead362b9bcef4146a7dadb698237ee", "patch": "@@ -22,7 +22,7 @@ use dataflow::{do_dataflow, DebugFormatted};\n use dataflow::MoveDataParamEnv;\n use dataflow::BitDenotation;\n use dataflow::DataflowResults;\n-use dataflow::{DefinitelyInitializedLvals, MaybeInitializedLvals, MaybeUninitializedLvals};\n+use dataflow::{DefinitelyInitializedPlaces, MaybeInitializedPlaces, MaybeUninitializedPlaces};\n use dataflow::move_paths::{MovePathIndex, LookupResult};\n use dataflow::move_paths::{HasMoveData, MoveData};\n use dataflow;\n@@ -50,15 +50,15 @@ impl MirPass for SanityCheck {\n         let dead_unwinds = IdxSetBuf::new_empty(mir.basic_blocks().len());\n         let flow_inits =\n             do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n-                        MaybeInitializedLvals::new(tcx, mir, &mdpe),\n+                        MaybeInitializedPlaces::new(tcx, mir, &mdpe),\n                         |bd, i| DebugFormatted::new(&bd.move_data().move_paths[i]));\n         let flow_uninits =\n             do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n-                        MaybeUninitializedLvals::new(tcx, mir, &mdpe),\n+                        MaybeUninitializedPlaces::new(tcx, mir, &mdpe),\n                         |bd, i| DebugFormatted::new(&bd.move_data().move_paths[i]));\n         let flow_def_inits =\n             do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n-                        DefinitelyInitializedLvals::new(tcx, mir, &mdpe),\n+                        DefinitelyInitializedPlaces::new(tcx, mir, &mdpe),\n                         |bd, i| DebugFormatted::new(&bd.move_data().move_paths[i]));\n \n         if has_rustc_mir_with(&attributes, \"rustc_peek_maybe_init\").is_some() {"}, {"sha": "65771068014992d107740b8cc1ab4a3b97540321", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46a9bdda78ead362b9bcef4146a7dadb698237ee/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46a9bdda78ead362b9bcef4146a7dadb698237ee/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=46a9bdda78ead362b9bcef4146a7dadb698237ee", "patch": "@@ -560,7 +560,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n     ///        ptr = cur\n     ///        cur = cur.offset(1)\n     ///    } else {\n-    ///        ptr = &mut LV[cur]\n+    ///        ptr = &mut P[cur]\n     ///        cur = cur + 1\n     ///    }\n     ///    drop(ptr)\n@@ -731,7 +731,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         if ptr_based {\n             let tmp_ty = tcx.mk_mut_ptr(self.place_ty(self.place));\n             let tmp = Place::Local(self.new_temp(tmp_ty));\n-            // tmp = &LV;\n+            // tmp = &P;\n             // cur = tmp as *mut T;\n             // end = Offset(cur, len);\n             drop_block_stmts.push(self.assign(&tmp, Rvalue::Ref("}, {"sha": "12698964d2e65ec7dc76f9b40c4754323d0e926a", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46a9bdda78ead362b9bcef4146a7dadb698237ee/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46a9bdda78ead362b9bcef4146a7dadb698237ee/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=46a9bdda78ead362b9bcef4146a7dadb698237ee", "patch": "@@ -545,7 +545,7 @@ impl<'a, 'tcx> ArgType<'tcx> {\n         self.mode == PassMode::Ignore\n     }\n \n-    /// Get the LLVM type for an place of the original Rust type of\n+    /// Get the LLVM type for a place of the original Rust type of\n     /// this argument/return, i.e. the result of `type_of::type_of`.\n     pub fn memory_ty(&self, cx: &CodegenCx<'a, 'tcx>) -> Type {\n         self.layout.llvm_type(cx)"}, {"sha": "416e3639bc180887cb56f6f88346f14137715fbe", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46a9bdda78ead362b9bcef4146a7dadb698237ee/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46a9bdda78ead362b9bcef4146a7dadb698237ee/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=46a9bdda78ead362b9bcef4146a7dadb698237ee", "patch": "@@ -209,7 +209,7 @@ enum Base {\n     Static(ValueRef)\n }\n \n-/// An place as seen from a constant.\n+/// A place as seen from a constant.\n #[derive(Copy, Clone)]\n struct ConstPlace<'tcx> {\n     base: Base,"}, {"sha": "7f5b353f79ef7994a71c9410a2fd256a9a61dd2e", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/46a9bdda78ead362b9bcef4146a7dadb698237ee/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46a9bdda78ead362b9bcef4146a7dadb698237ee/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=46a9bdda78ead362b9bcef4146a7dadb698237ee", "patch": "@@ -136,7 +136,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         };\n \n         if let Some(hir::MutMutable) = pick.autoref {\n-            self.convert_lvalue_derefs_to_mutable();\n+            self.convert_place_derefs_to_mutable();\n         }\n \n         ConfirmResult { callee, illegal_sized_bound }\n@@ -416,7 +416,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n     /// When we select a method with a mutable autoref, we have to go convert any\n     /// auto-derefs, indices, etc from `Deref` and `Index` into `DerefMut` and `IndexMut`\n     /// respectively.\n-    fn convert_lvalue_derefs_to_mutable(&self) {\n+    fn convert_place_derefs_to_mutable(&self) {\n         // Gather up expressions we want to munge.\n         let mut exprs = Vec::new();\n         exprs.push(self.self_expr);\n@@ -431,11 +431,11 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-        debug!(\"convert_lvalue_derefs_to_mutable: exprs={:?}\", exprs);\n+        debug!(\"convert_place_derefs_to_mutable: exprs={:?}\", exprs);\n \n         // Fix up autoderefs and derefs.\n         for (i, &expr) in exprs.iter().rev().enumerate() {\n-            debug!(\"convert_lvalue_derefs_to_mutable: i={} expr={:?}\", i, expr);\n+            debug!(\"convert_place_derefs_to_mutable: i={} expr={:?}\", i, expr);\n \n             // Fix up the autoderefs. Autorefs can only occur immediately preceding\n             // overloaded place ops, and will be fixed by them in order to get"}, {"sha": "483dd345286d433601cdd3d2728b73ee6ff5865a", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/46a9bdda78ead362b9bcef4146a7dadb698237ee/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46a9bdda78ead362b9bcef4146a7dadb698237ee/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=46a9bdda78ead362b9bcef4146a7dadb698237ee", "patch": "@@ -557,7 +557,7 @@ pub struct FnCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     ///   foo();}` or `{return; 22}`, where we would warn on the\n     ///   `foo()` or `22`.\n     ///\n-    /// - To permit assignment into a local variable or other lvalue\n+    /// - To permit assignment into a local variable or other place\n     ///   (including the \"return slot\") of type `!`.  This is allowed\n     ///   if **either** the type of value being assigned is `!`, which\n     ///   means the current code is dead, **or** the expression's\n@@ -2275,11 +2275,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// For the overloaded lvalue expressions (`*x`, `x[3]`), the trait\n+    /// For the overloaded place expressions (`*x`, `x[3]`), the trait\n     /// returns a type of `&T`, but the actual type we assign to the\n     /// *expression* is `T`. So this function just peels off the return\n     /// type by one layer to yield `T`.\n-    fn make_overloaded_lvalue_return_type(&self,\n+    fn make_overloaded_place_return_type(&self,\n                                           method: MethodCallee<'tcx>)\n                                           -> ty::TypeAndMut<'tcx>\n     {\n@@ -2373,7 +2373,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 self.apply_adjustments(base_expr, adjustments);\n \n                 self.write_method_call(expr.hir_id, method);\n-                (input_ty, self.make_overloaded_lvalue_return_type(method).ty)\n+                (input_ty, self.make_overloaded_place_return_type(method).ty)\n             });\n             if result.is_some() {\n                 return result;\n@@ -3650,7 +3650,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                     target: method.sig.inputs()[0]\n                                 }]);\n                             }\n-                            oprnd_t = self.make_overloaded_lvalue_return_type(method).ty;\n+                            oprnd_t = self.make_overloaded_place_return_type(method).ty;\n                             self.write_method_call(expr.hir_id, method);\n                         } else {\n                             type_error_struct!(tcx.sess, expr.span, oprnd_t, E0614,\n@@ -3682,7 +3682,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 match ty.sty {\n                     ty::TyRef(_, ref mt) | ty::TyRawPtr(ref mt) => {\n                         if self.is_place_expr(&oprnd) {\n-                            // Lvalues may legitimately have unsized types.\n+                            // Places may legitimately have unsized types.\n                             // For example, dereferences of a fat pointer and\n                             // the last field of a struct can be unsized.\n                             ExpectHasType(mt.ty)\n@@ -4245,7 +4245,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // ref mut, for soundness (issue #23116). In particular, in\n             // the latter case, we need to be clear that the type of the\n             // referent for the reference that results is *equal to* the\n-            // type of the lvalue it is referencing, and not some\n+            // type of the place it is referencing, and not some\n             // supertype thereof.\n             let init_ty = self.check_expr_with_needs(init, Needs::maybe_mut_place(m));\n             self.demand_eqtype(init.span, local_ty, init_ty);"}, {"sha": "ac7f54250d32b4a3e337b686605585688cf31784", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/46a9bdda78ead362b9bcef4146a7dadb698237ee/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46a9bdda78ead362b9bcef4146a7dadb698237ee/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=46a9bdda78ead362b9bcef4146a7dadb698237ee", "patch": "@@ -732,8 +732,8 @@ and [RFC 809] for more details.\n \"##,\n \n E0067: r##\"\n-The left-hand side of a compound assignment expression must be an lvalue\n-expression. An lvalue expression represents a memory location and includes\n+The left-hand side of a compound assignment expression must be a place\n+expression. A place expression represents a memory location and includes\n item paths (ie, namespaced variables), dereferences, indexing expressions,\n and field references.\n \n@@ -742,7 +742,7 @@ Let's start with some erroneous code examples:\n ```compile_fail,E0067\n use std::collections::LinkedList;\n \n-// Bad: assignment to non-lvalue expression\n+// Bad: assignment to non-place expression\n LinkedList::new() += 1;\n \n // ...\n@@ -783,14 +783,14 @@ function's return type and the value being returned.\n \"##,\n \n E0070: r##\"\n-The left-hand side of an assignment operator must be an lvalue expression. An\n-lvalue expression represents a memory location and can be a variable (with\n+The left-hand side of an assignment operator must be a place expression. An\n+place expression represents a memory location and can be a variable (with\n optional namespacing), a dereference, an indexing expression or a field\n reference.\n \n More details can be found in the [Expressions] section of the Reference.\n \n-[Expressions]: https://doc.rust-lang.org/reference/expressions.html#lvalues-rvalues-and-temporaries\n+[Expressions]: https://doc.rust-lang.org/reference/expressions.html#places-rvalues-and-temporaries\n \n Now, we can go further. Here are some erroneous code examples:\n \n@@ -806,7 +806,7 @@ fn some_other_func() {}\n \n fn some_function() {\n     SOME_CONST = 14; // error : a constant value cannot be changed!\n-    1 = 3; // error : 1 isn't a valid lvalue!\n+    1 = 3; // error : 1 isn't a valid place!\n     some_other_func() = 4; // error : we can't assign value to a function!\n     SomeStruct.x = 12; // error : SomeStruct a structure name but it is used\n                        // like a variable!"}, {"sha": "0dfe9cb970efbd8d7e0024059f3e9b871d03cf84", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46a9bdda78ead362b9bcef4146a7dadb698237ee/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46a9bdda78ead362b9bcef4146a7dadb698237ee/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=46a9bdda78ead362b9bcef4146a7dadb698237ee", "patch": "@@ -1439,7 +1439,7 @@ impl<'a> MethodDef<'a> {\n                                                          &catch_all_substructure);\n \n             // Final wrinkle: the self_args are expressions that deref\n-            // down to desired l-values, but we cannot actually deref\n+            // down to desired places, but we cannot actually deref\n             // them when they are fed as r-values into a tuple\n             // expression; here add a layer of borrowing, turning\n             // `(*self, *__arg_0, ...)` into `(&*self, &*__arg_0, ...)`.\n@@ -1516,7 +1516,7 @@ impl<'a> MethodDef<'a> {\n         } else {\n \n             // Final wrinkle: the self_args are expressions that deref\n-            // down to desired l-values, but we cannot actually deref\n+            // down to desired places, but we cannot actually deref\n             // them when they are fed as r-values into a tuple\n             // expression; here add a layer of borrowing, turning\n             // `(*self, *__arg_0, ...)` into `(&*self, &*__arg_0, ...)`."}]}