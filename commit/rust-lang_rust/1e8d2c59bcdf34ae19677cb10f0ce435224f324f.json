{"sha": "1e8d2c59bcdf34ae19677cb10f0ce435224f324f", "node_id": "C_kwDOAAsO6NoAKDFlOGQyYzU5YmNkZjM0YWUxOTY3N2NiMTBmMGNlNDM1MjI0ZjMyNGY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-19T01:13:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-19T01:13:08Z"}, "message": "Auto merge of #10478 - Jarcho:block_eq, r=xFrednet\n\n`SpanlessEq` improvements\n\nfixes #9775\n\nAlso includes a simplification to `consts::constant`'s interface since I was already touching the code.\n\nAt the start of `eq_expr` the check:\n```rust\nif !self.inner.allow_side_effects && left.span.ctxt() != right.span.ctxt() {\n    return false;\n}\n```\nwas removed. This was added in 49e2501 to handle `cfg` macros. This is better handled by the newly added `check_ctxt`.\n\nchangelog: [various lints]: Don't consider different `cfg!` expansions to be the same unless they are for the same config.\nchangelog: [various lints]: Don't consider the expansion of two different macros to be equal, even when they expand to the same token sequence.\nchangelog: [various lints]: Don't consider two blocks to be equal if they contain disabled code or empty macro expansions, unless those section contain the exact same token sequence.", "tree": {"sha": "e5f20d63c7ed387b380fe27d51f2f65738e16a87", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e5f20d63c7ed387b380fe27d51f2f65738e16a87"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e8d2c59bcdf34ae19677cb10f0ce435224f324f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e8d2c59bcdf34ae19677cb10f0ce435224f324f", "html_url": "https://github.com/rust-lang/rust/commit/1e8d2c59bcdf34ae19677cb10f0ce435224f324f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "392e9551d422f40a3077e31ea04fd81134bbeed1", "url": "https://api.github.com/repos/rust-lang/rust/commits/392e9551d422f40a3077e31ea04fd81134bbeed1", "html_url": "https://github.com/rust-lang/rust/commit/392e9551d422f40a3077e31ea04fd81134bbeed1"}, {"sha": "58132cb3b0ddadc2004a121f0bd85d12bf089ff6", "url": "https://api.github.com/repos/rust-lang/rust/commits/58132cb3b0ddadc2004a121f0bd85d12bf089ff6", "html_url": "https://github.com/rust-lang/rust/commit/58132cb3b0ddadc2004a121f0bd85d12bf089ff6"}], "stats": {"total": 753, "additions": 523, "deletions": 230}, "files": [{"sha": "a8dc0cb3b58150c9458ff2701fda4d2ae89f033c", "filename": "clippy_lints/src/assertions_on_constants.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Fassertions_on_constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Fassertions_on_constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassertions_on_constants.rs?ref=1e8d2c59bcdf34ae19677cb10f0ce435224f324f", "patch": "@@ -38,7 +38,7 @@ impl<'tcx> LateLintPass<'tcx> for AssertionsOnConstants {\n             _ => return,\n         };\n         let Some((condition, panic_expn)) = find_assert_args(cx, e, macro_call.expn) else { return };\n-        let Some((Constant::Bool(val), _)) = constant(cx, cx.typeck_results(), condition) else { return };\n+        let Some(Constant::Bool(val)) = constant(cx, cx.typeck_results(), condition) else { return };\n         if val {\n             span_lint_and_help(\n                 cx,"}, {"sha": "da756129db3ae34ed85720ee79b55109e922f7c3", "filename": "clippy_lints/src/casts/cast_nan_to_int.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Fcasts%2Fcast_nan_to_int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Fcasts%2Fcast_nan_to_int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fcast_nan_to_int.rs?ref=1e8d2c59bcdf34ae19677cb10f0ce435224f324f", "patch": "@@ -21,8 +21,8 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, cast_expr: &Expr<'_>,\n \n fn is_known_nan(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n     match constant(cx, cx.typeck_results(), e) {\n-        Some((Constant::F64(n), _)) => n.is_nan(),\n-        Some((Constant::F32(n), _)) => n.is_nan(),\n+        Some(Constant::F64(n)) => n.is_nan(),\n+        Some(Constant::F32(n)) => n.is_nan(),\n         _ => false,\n     }\n }"}, {"sha": "84b99ad5c243dd42ce19837b7cbd073774234c98", "filename": "clippy_lints/src/casts/cast_possible_truncation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Fcasts%2Fcast_possible_truncation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Fcasts%2Fcast_possible_truncation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fcast_possible_truncation.rs?ref=1e8d2c59bcdf34ae19677cb10f0ce435224f324f", "patch": "@@ -15,7 +15,7 @@ use rustc_target::abi::IntegerType;\n use super::{utils, CAST_ENUM_TRUNCATION, CAST_POSSIBLE_TRUNCATION};\n \n fn constant_int(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<u128> {\n-    if let Some((Constant::Int(c), _)) = constant(cx, cx.typeck_results(), expr) {\n+    if let Some(Constant::Int(c)) = constant(cx, cx.typeck_results(), expr) {\n         Some(c)\n     } else {\n         None"}, {"sha": "a83dfd94dc2268b9727a3d6dea33c1570562de97", "filename": "clippy_lints/src/casts/cast_sign_loss.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Fcasts%2Fcast_sign_loss.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Fcasts%2Fcast_sign_loss.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fcast_sign_loss.rs?ref=1e8d2c59bcdf34ae19677cb10f0ce435224f324f", "patch": "@@ -29,7 +29,7 @@ fn should_lint(cx: &LateContext<'_>, cast_op: &Expr<'_>, cast_from: Ty<'_>, cast\n             // Don't lint for positive constants.\n             let const_val = constant(cx, cx.typeck_results(), cast_op);\n             if_chain! {\n-                if let Some((Constant::Int(n), _)) = const_val;\n+                if let Some(Constant::Int(n)) = const_val;\n                 if let ty::Int(ity) = *cast_from.kind();\n                 if sext(cx.tcx, n, ity) >= 0;\n                 then {"}, {"sha": "3c55a563af455e9b5ea96ca42e2ffb49edd1174f", "filename": "clippy_lints/src/floating_point_arithmetic.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs?ref=1e8d2c59bcdf34ae19677cb10f0ce435224f324f", "patch": "@@ -114,7 +114,7 @@ declare_lint_pass!(FloatingPointArithmetic => [\n // Returns the specialized log method for a given base if base is constant\n // and is one of 2, 10 and e\n fn get_specialized_log_method(cx: &LateContext<'_>, base: &Expr<'_>) -> Option<&'static str> {\n-    if let Some((value, _)) = constant(cx, cx.typeck_results(), base) {\n+    if let Some(value) = constant(cx, cx.typeck_results(), base) {\n         if F32(2.0) == value || F64(2.0) == value {\n             return Some(\"log2\");\n         } else if F32(10.0) == value || F64(10.0) == value {\n@@ -193,8 +193,8 @@ fn check_ln1p(cx: &LateContext<'_>, expr: &Expr<'_>, receiver: &Expr<'_>) {\n             constant(cx, cx.typeck_results(), lhs),\n             constant(cx, cx.typeck_results(), rhs),\n         ) {\n-            (Some((value, _)), _) if F32(1.0) == value || F64(1.0) == value => rhs,\n-            (_, Some((value, _))) if F32(1.0) == value || F64(1.0) == value => lhs,\n+            (Some(value), _) if F32(1.0) == value || F64(1.0) == value => rhs,\n+            (_, Some(value)) if F32(1.0) == value || F64(1.0) == value => lhs,\n             _ => return,\n         };\n \n@@ -237,7 +237,7 @@ fn get_integer_from_float_constant(value: &Constant) -> Option<i32> {\n \n fn check_powf(cx: &LateContext<'_>, expr: &Expr<'_>, receiver: &Expr<'_>, args: &[Expr<'_>]) {\n     // Check receiver\n-    if let Some((value, _)) = constant(cx, cx.typeck_results(), receiver) {\n+    if let Some(value) = constant(cx, cx.typeck_results(), receiver) {\n         if let Some(method) = if F32(f32_consts::E) == value || F64(f64_consts::E) == value {\n             Some(\"exp\")\n         } else if F32(2.0) == value || F64(2.0) == value {\n@@ -258,7 +258,7 @@ fn check_powf(cx: &LateContext<'_>, expr: &Expr<'_>, receiver: &Expr<'_>, args:\n     }\n \n     // Check argument\n-    if let Some((value, _)) = constant(cx, cx.typeck_results(), &args[0]) {\n+    if let Some(value) = constant(cx, cx.typeck_results(), &args[0]) {\n         let (lint, help, suggestion) = if F32(1.0 / 2.0) == value || F64(1.0 / 2.0) == value {\n             (\n                 SUBOPTIMAL_FLOPS,\n@@ -298,7 +298,7 @@ fn check_powf(cx: &LateContext<'_>, expr: &Expr<'_>, receiver: &Expr<'_>, args:\n }\n \n fn check_powi(cx: &LateContext<'_>, expr: &Expr<'_>, receiver: &Expr<'_>, args: &[Expr<'_>]) {\n-    if let Some((value, _)) = constant(cx, cx.typeck_results(), &args[0]) {\n+    if let Some(value) = constant(cx, cx.typeck_results(), &args[0]) {\n         if value == Int(2) {\n             if let Some(parent) = get_parent_expr(cx, expr) {\n                 if let Some(grandparent) = get_parent_expr(cx, parent) {\n@@ -384,8 +384,8 @@ fn detect_hypot(cx: &LateContext<'_>, receiver: &Expr<'_>) -> Option<String> {\n                 _\n             ) = &add_rhs.kind;\n             if lmethod_name.as_str() == \"powi\" && rmethod_name.as_str() == \"powi\";\n-            if let Some((lvalue, _)) = constant(cx, cx.typeck_results(), largs_1);\n-            if let Some((rvalue, _)) = constant(cx, cx.typeck_results(), rargs_1);\n+            if let Some(lvalue) = constant(cx, cx.typeck_results(), largs_1);\n+            if let Some(rvalue) = constant(cx, cx.typeck_results(), rargs_1);\n             if Int(2) == lvalue && Int(2) == rvalue;\n             then {\n                 return Some(format!(\"{}.hypot({})\", Sugg::hir(cx, largs_0, \"..\").maybe_par(), Sugg::hir(cx, rargs_0, \"..\")));\n@@ -416,7 +416,7 @@ fn check_expm1(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if_chain! {\n         if let ExprKind::Binary(Spanned { node: BinOpKind::Sub, .. }, lhs, rhs) = expr.kind;\n         if cx.typeck_results().expr_ty(lhs).is_floating_point();\n-        if let Some((value, _)) = constant(cx, cx.typeck_results(), rhs);\n+        if let Some(value) = constant(cx, cx.typeck_results(), rhs);\n         if F32(1.0) == value || F64(1.0) == value;\n         if let ExprKind::MethodCall(path, self_arg, ..) = &lhs.kind;\n         if cx.typeck_results().expr_ty(self_arg).is_floating_point();\n@@ -669,8 +669,8 @@ fn check_radians(cx: &LateContext<'_>, expr: &Expr<'_>) {\n             mul_lhs,\n             mul_rhs,\n         ) = &div_lhs.kind;\n-        if let Some((rvalue, _)) = constant(cx, cx.typeck_results(), div_rhs);\n-        if let Some((lvalue, _)) = constant(cx, cx.typeck_results(), mul_rhs);\n+        if let Some(rvalue) = constant(cx, cx.typeck_results(), div_rhs);\n+        if let Some(lvalue) = constant(cx, cx.typeck_results(), mul_rhs);\n         then {\n             // TODO: also check for constant values near PI/180 or 180/PI\n             if (F32(f32_consts::PI) == rvalue || F64(f64_consts::PI) == rvalue) &&"}, {"sha": "521045a9fed8fb0f53dfd27253e70164aba508cf", "filename": "clippy_lints/src/fn_null_check.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Ffn_null_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Ffn_null_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffn_null_check.rs?ref=1e8d2c59bcdf34ae19677cb10f0ce435224f324f", "patch": "@@ -89,11 +89,7 @@ impl<'tcx> LateLintPass<'tcx> for FnNullCheck {\n \n                     // Catching:\n                     // (fn_ptr as *<const/mut> <ty>) == <const that evaluates to null_ptr>\n-                    _ if matches!(\n-                        constant(cx, cx.typeck_results(), to_check),\n-                        Some((Constant::RawPtr(0), _))\n-                    ) =>\n-                    {\n+                    _ if matches!(constant(cx, cx.typeck_results(), to_check), Some(Constant::RawPtr(0))) => {\n                         lint_expr(cx, expr);\n                     },\n "}, {"sha": "ee7973b82ab9708860f6bbec696fb39141a99e2e", "filename": "clippy_lints/src/implicit_saturating_add.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Fimplicit_saturating_add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Fimplicit_saturating_add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_saturating_add.rs?ref=1e8d2c59bcdf34ae19677cb10f0ce435224f324f", "patch": "@@ -101,10 +101,10 @@ fn get_int_max(ty: Ty<'_>) -> Option<u128> {\n fn get_const<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>) -> Option<(u128, BinOpKind, &'tcx Expr<'tcx>)> {\n     if let ExprKind::Binary(op, l, r) = expr.kind {\n         let tr = cx.typeck_results();\n-        if let Some((Constant::Int(c), _)) = constant(cx, tr, r) {\n+        if let Some(Constant::Int(c)) = constant(cx, tr, r) {\n             return Some((c, op.node, l));\n         };\n-        if let Some((Constant::Int(c), _)) = constant(cx, tr, l) {\n+        if let Some(Constant::Int(c)) = constant(cx, tr, l) {\n             return Some((c, invert_op(op.node)?, r));\n         }\n     }"}, {"sha": "7a269e98ff13b8674bfb11069bed70568202a911", "filename": "clippy_lints/src/index_refutable_slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Findex_refutable_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Findex_refutable_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Findex_refutable_slice.rs?ref=1e8d2c59bcdf34ae19677cb10f0ce435224f324f", "patch": "@@ -254,7 +254,7 @@ impl<'a, 'tcx> Visitor<'tcx> for SliceIndexLintingVisitor<'a, 'tcx> {\n                 let parent_id = map.parent_id(expr.hir_id);\n                 if let Some(hir::Node::Expr(parent_expr)) = map.find(parent_id);\n                 if let hir::ExprKind::Index(_, index_expr) = parent_expr.kind;\n-                if let Some((Constant::Int(index_value), _)) = constant(cx, cx.typeck_results(), index_expr);\n+                if let Some(Constant::Int(index_value)) = constant(cx, cx.typeck_results(), index_expr);\n                 if let Ok(index_value) = index_value.try_into();\n                 if index_value < max_suggested_slice;\n "}, {"sha": "22c14d9b04dd13d4df26776c14633deeb4b9fa0d", "filename": "clippy_lints/src/indexing_slicing.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Findexing_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Findexing_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Findexing_slicing.rs?ref=1e8d2c59bcdf34ae19677cb10f0ce435224f324f", "patch": "@@ -191,18 +191,14 @@ impl<'tcx> LateLintPass<'tcx> for IndexingSlicing {\n /// Returns a tuple of options with the start and end (exclusive) values of\n /// the range. If the start or end is not constant, None is returned.\n fn to_const_range(cx: &LateContext<'_>, range: higher::Range<'_>, array_size: u128) -> (Option<u128>, Option<u128>) {\n-    let s = range\n-        .start\n-        .map(|expr| constant(cx, cx.typeck_results(), expr).map(|(c, _)| c));\n+    let s = range.start.map(|expr| constant(cx, cx.typeck_results(), expr));\n     let start = match s {\n         Some(Some(Constant::Int(x))) => Some(x),\n         Some(_) => None,\n         None => Some(0),\n     };\n \n-    let e = range\n-        .end\n-        .map(|expr| constant(cx, cx.typeck_results(), expr).map(|(c, _)| c));\n+    let e = range.end.map(|expr| constant(cx, cx.typeck_results(), expr));\n     let end = match e {\n         Some(Some(Constant::Int(x))) => {\n             if range.limits == RangeLimits::Closed {"}, {"sha": "93d977a5c96b82a20b13ba66582a1c2aaddaa403", "filename": "clippy_lints/src/manual_strip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Fmanual_strip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Fmanual_strip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_strip.rs?ref=1e8d2c59bcdf34ae19677cb10f0ce435224f324f", "patch": "@@ -144,7 +144,7 @@ fn len_arg<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<&'tcx E\n \n // Returns the length of the `expr` if it's a constant string or char.\n fn constant_length(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<u128> {\n-    let (value, _) = constant(cx, cx.typeck_results(), expr)?;\n+    let value = constant(cx, cx.typeck_results(), expr)?;\n     match value {\n         Constant::Str(value) => Some(value.len() as u128),\n         Constant::Char(value) => Some(value.len_utf8() as u128),"}, {"sha": "55ec9d4474f59de08eef3a39d1c7ed28c296e581", "filename": "clippy_lints/src/matches/mod.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs?ref=1e8d2c59bcdf34ae19677cb10f0ce435224f324f", "patch": "@@ -25,9 +25,9 @@ mod wild_in_or_pats;\n \n use clippy_utils::msrvs::{self, Msrv};\n use clippy_utils::source::{snippet_opt, walk_span_to_context};\n-use clippy_utils::{higher, in_constant, is_span_match};\n+use clippy_utils::{higher, in_constant, is_span_match, tokenize_with_text};\n use rustc_hir::{Arm, Expr, ExprKind, Local, MatchSource, Pat};\n-use rustc_lexer::{tokenize, TokenKind};\n+use rustc_lexer::TokenKind;\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n@@ -1147,12 +1147,7 @@ fn span_contains_cfg(cx: &LateContext<'_>, s: Span) -> bool {\n         // Assume true. This would require either an invalid span, or one which crosses file boundaries.\n         return true;\n     };\n-    let mut pos = 0usize;\n-    let mut iter = tokenize(&snip).map(|t| {\n-        let start = pos;\n-        pos += t.len as usize;\n-        (t.kind, start..pos)\n-    });\n+    let mut iter = tokenize_with_text(&snip);\n \n     // Search for the token sequence [`#`, `[`, `cfg`]\n     while iter.any(|(t, _)| matches!(t, TokenKind::Pound)) {\n@@ -1163,7 +1158,7 @@ fn span_contains_cfg(cx: &LateContext<'_>, s: Span) -> bool {\n             )\n         });\n         if matches!(iter.next(), Some((TokenKind::OpenBracket, _)))\n-            && matches!(iter.next(), Some((TokenKind::Ident, range)) if &snip[range.clone()] == \"cfg\")\n+            && matches!(iter.next(), Some((TokenKind::Ident, \"cfg\")))\n         {\n             return true;\n         }"}, {"sha": "abf2525a61c68520b9511732e6f44d91645166b6", "filename": "clippy_lints/src/matches/overlapping_arms.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Fmatches%2Foverlapping_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Fmatches%2Foverlapping_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Foverlapping_arms.rs?ref=1e8d2c59bcdf34ae19677cb10f0ce435224f324f", "patch": "@@ -34,7 +34,7 @@ fn all_ranges<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>], ty: Ty<'tcx>)\n             if let Arm { pat, guard: None, .. } = *arm {\n                 if let PatKind::Range(ref lhs, ref rhs, range_end) = pat.kind {\n                     let lhs_const = match lhs {\n-                        Some(lhs) => constant(cx, cx.typeck_results(), lhs)?.0,\n+                        Some(lhs) => constant(cx, cx.typeck_results(), lhs)?,\n                         None => {\n                             let min_val_const = ty.numeric_min_val(cx.tcx)?;\n                             let min_constant = mir::ConstantKind::from_value(\n@@ -45,7 +45,7 @@ fn all_ranges<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>], ty: Ty<'tcx>)\n                         },\n                     };\n                     let rhs_const = match rhs {\n-                        Some(rhs) => constant(cx, cx.typeck_results(), rhs)?.0,\n+                        Some(rhs) => constant(cx, cx.typeck_results(), rhs)?,\n                         None => {\n                             let max_val_const = ty.numeric_max_val(cx.tcx)?;\n                             let max_constant = mir::ConstantKind::from_value("}, {"sha": "d1609eebfdca9dd5a66aa9ad3da342336762194a", "filename": "clippy_lints/src/methods/iter_nth_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Fmethods%2Fiter_nth_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Fmethods%2Fiter_nth_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiter_nth_zero.rs?ref=1e8d2c59bcdf34ae19677cb10f0ce435224f324f", "patch": "@@ -13,7 +13,7 @@ use super::ITER_NTH_ZERO;\n pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr<'_>, arg: &hir::Expr<'_>) {\n     if_chain! {\n         if is_trait_method(cx, expr, sym::Iterator);\n-        if let Some((Constant::Int(0), _)) = constant(cx, cx.typeck_results(), arg);\n+        if let Some(Constant::Int(0)) = constant(cx, cx.typeck_results(), arg);\n         then {\n             let mut applicability = Applicability::MachineApplicable;\n             span_lint_and_sugg("}, {"sha": "b631cd00cda4349c5c8f6d7f598558345efb9dae", "filename": "clippy_lints/src/methods/iterator_step_by_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Fmethods%2Fiterator_step_by_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Fmethods%2Fiterator_step_by_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiterator_step_by_zero.rs?ref=1e8d2c59bcdf34ae19677cb10f0ce435224f324f", "patch": "@@ -9,7 +9,7 @@ use super::ITERATOR_STEP_BY_ZERO;\n \n pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, arg: &'tcx hir::Expr<'_>) {\n     if is_trait_method(cx, expr, sym::Iterator) {\n-        if let Some((Constant::Int(0), _)) = constant(cx, cx.typeck_results(), arg) {\n+        if let Some(Constant::Int(0)) = constant(cx, cx.typeck_results(), arg) {\n             span_lint(\n                 cx,\n                 ITERATOR_STEP_BY_ZERO,"}, {"sha": "9a594d964ab22ea7bf7c64b9f4683df9998a9979", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=1e8d2c59bcdf34ae19677cb10f0ce435224f324f", "patch": "@@ -3770,13 +3770,13 @@ impl Methods {\n                     unnecessary_sort_by::check(cx, expr, recv, arg, true);\n                 },\n                 (\"splitn\" | \"rsplitn\", [count_arg, pat_arg]) => {\n-                    if let Some((Constant::Int(count), _)) = constant(cx, cx.typeck_results(), count_arg) {\n+                    if let Some(Constant::Int(count)) = constant(cx, cx.typeck_results(), count_arg) {\n                         suspicious_splitn::check(cx, name, expr, recv, count);\n                         str_splitn::check(cx, name, expr, recv, pat_arg, count, &self.msrv);\n                     }\n                 },\n                 (\"splitn_mut\" | \"rsplitn_mut\", [count_arg, _]) => {\n-                    if let Some((Constant::Int(count), _)) = constant(cx, cx.typeck_results(), count_arg) {\n+                    if let Some(Constant::Int(count)) = constant(cx, cx.typeck_results(), count_arg) {\n                         suspicious_splitn::check(cx, name, expr, recv, count);\n                     }\n                 },"}, {"sha": "bb4cdd2a6fa10c7264c1eb89c7761ee23caf2e30", "filename": "clippy_lints/src/methods/repeat_once.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Fmethods%2Frepeat_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Fmethods%2Frepeat_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Frepeat_once.rs?ref=1e8d2c59bcdf34ae19677cb10f0ce435224f324f", "patch": "@@ -1,4 +1,4 @@\n-use clippy_utils::consts::{constant_context, Constant};\n+use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet;\n use clippy_utils::ty::is_type_lang_item;\n@@ -14,7 +14,7 @@ pub(super) fn check<'tcx>(\n     recv: &'tcx Expr<'_>,\n     repeat_arg: &'tcx Expr<'_>,\n ) {\n-    if constant_context(cx, cx.typeck_results()).expr(repeat_arg) == Some(Constant::Int(1)) {\n+    if constant(cx, cx.typeck_results(), repeat_arg) == Some(Constant::Int(1)) {\n         let ty = cx.typeck_results().expr_ty(recv).peel_refs();\n         if ty.is_str() {\n             span_lint_and_sugg("}, {"sha": "5ea12c441840dfd91da132ef583445ca3f84142b", "filename": "clippy_lints/src/methods/str_splitn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs?ref=1e8d2c59bcdf34ae19677cb10f0ce435224f324f", "patch": "@@ -316,7 +316,7 @@ fn parse_iter_usage<'tcx>(\n                     };\n                 },\n                 (\"nth\" | \"skip\", [idx_expr]) if cx.tcx.trait_of_item(did) == Some(iter_id) => {\n-                    if let Some((Constant::Int(idx), _)) = constant(cx, cx.typeck_results(), idx_expr) {\n+                    if let Some(Constant::Int(idx)) = constant(cx, cx.typeck_results(), idx_expr) {\n                         let span = if name.ident.as_str() == \"nth\" {\n                             e.span\n                         } else {"}, {"sha": "f4863600ccc04c9bc2a15dc1df8fced9dc790b10", "filename": "clippy_lints/src/operators/absurd_extreme_comparisons.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Foperators%2Fabsurd_extreme_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Foperators%2Fabsurd_extreme_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Fabsurd_extreme_comparisons.rs?ref=1e8d2c59bcdf34ae19677cb10f0ce435224f324f", "patch": "@@ -121,7 +121,7 @@ fn detect_absurd_comparison<'tcx>(\n fn detect_extreme_expr<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<ExtremeExpr<'tcx>> {\n     let ty = cx.typeck_results().expr_ty(expr);\n \n-    let cv = constant(cx, cx.typeck_results(), expr)?.0;\n+    let cv = constant(cx, cx.typeck_results(), expr)?;\n \n     let which = match (ty.kind(), cv) {\n         (&ty::Bool, Constant::Bool(false)) | (&ty::Uint(_), Constant::Int(0)) => ExtremeType::Minimum,"}, {"sha": "5c240276b76d195f4e62edbe907bd34028a89c68", "filename": "clippy_lints/src/operators/arithmetic_side_effects.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Foperators%2Farithmetic_side_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Foperators%2Farithmetic_side_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Farithmetic_side_effects.rs?ref=1e8d2c59bcdf34ae19677cb10f0ce435224f324f", "patch": "@@ -113,7 +113,7 @@ impl ArithmeticSideEffects {\n         if let hir::ExprKind::Lit(lit) = actual.kind && let ast::LitKind::Int(n, _) = lit.node {\n             return Some(n)\n         }\n-        if let Some((Constant::Int(n), _)) = constant(cx, cx.typeck_results(), expr) {\n+        if let Some(Constant::Int(n)) = constant(cx, cx.typeck_results(), expr) {\n             return Some(n);\n         }\n         None"}, {"sha": "1fddf0f50e322513d4599900e5316fdbd31c174d", "filename": "clippy_lints/src/operators/bit_mask.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Foperators%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Foperators%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Fbit_mask.rs?ref=1e8d2c59bcdf34ae19677cb10f0ce435224f324f", "patch": "@@ -166,7 +166,7 @@ fn check_ineffective_gt(cx: &LateContext<'_>, span: Span, m: u128, c: u128, op:\n }\n \n fn fetch_int_literal(cx: &LateContext<'_>, lit: &Expr<'_>) -> Option<u128> {\n-    match constant(cx, cx.typeck_results(), lit)?.0 {\n+    match constant(cx, cx.typeck_results(), lit)? {\n         Constant::Int(n) => Some(n),\n         _ => None,\n     }"}, {"sha": "e18064b7061bf3d6344571a2a77fd7d240a3bc17", "filename": "clippy_lints/src/operators/cmp_nan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Foperators%2Fcmp_nan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Foperators%2Fcmp_nan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Fcmp_nan.rs?ref=1e8d2c59bcdf34ae19677cb10f0ce435224f324f", "patch": "@@ -18,7 +18,7 @@ pub(super) fn check(cx: &LateContext<'_>, e: &Expr<'_>, op: BinOpKind, lhs: &Exp\n }\n \n fn is_nan(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n-    if let Some((value, _)) = constant(cx, cx.typeck_results(), e) {\n+    if let Some(value) = constant(cx, cx.typeck_results(), e) {\n         match value {\n             Constant::F32(num) => num.is_nan(),\n             Constant::F64(num) => num.is_nan(),"}, {"sha": "f120be13836d87c2d715a3490f98520b82196215", "filename": "clippy_lints/src/operators/duration_subsec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Foperators%2Fduration_subsec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Foperators%2Fduration_subsec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Fduration_subsec.rs?ref=1e8d2c59bcdf34ae19677cb10f0ce435224f324f", "patch": "@@ -19,7 +19,7 @@ pub(crate) fn check<'tcx>(\n     if op == BinOpKind::Div\n         && let ExprKind::MethodCall(method_path, self_arg, [], _) = left.kind\n         && is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(self_arg).peel_refs(), sym::Duration)\n-        && let Some((Constant::Int(divisor), _)) = constant(cx, cx.typeck_results(), right)\n+        && let Some(Constant::Int(divisor)) = constant(cx, cx.typeck_results(), right)\n     {\n         let suggested_fn = match (method_path.ident.as_str(), divisor) {\n             (\"subsec_micros\", 1_000) | (\"subsec_nanos\", 1_000_000) => \"subsec_millis\","}, {"sha": "15dff126be76e5eabd7ed88517806c489a7de969", "filename": "clippy_lints/src/operators/float_cmp.rs", "status": "modified", "additions": 25, "deletions": 32, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Foperators%2Ffloat_cmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Foperators%2Ffloat_cmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Ffloat_cmp.rs?ref=1e8d2c59bcdf34ae19677cb10f0ce435224f324f", "patch": "@@ -1,4 +1,4 @@\n-use clippy_utils::consts::{constant, Constant};\n+use clippy_utils::consts::{constant_with_source, Constant};\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::get_item_name;\n use clippy_utils::sugg::Sugg;\n@@ -18,9 +18,16 @@ pub(crate) fn check<'tcx>(\n     right: &'tcx Expr<'_>,\n ) {\n     if (op == BinOpKind::Eq || op == BinOpKind::Ne) && (is_float(cx, left) || is_float(cx, right)) {\n-        if is_allowed(cx, left) || is_allowed(cx, right) {\n-            return;\n-        }\n+        let left_is_local = match constant_with_source(cx, cx.typeck_results(), left) {\n+            Some((c, s)) if !is_allowed(&c) => s.is_local(),\n+            Some(_) => return,\n+            None => true,\n+        };\n+        let right_is_local = match constant_with_source(cx, cx.typeck_results(), right) {\n+            Some((c, s)) if !is_allowed(&c) => s.is_local(),\n+            Some(_) => return,\n+            None => true,\n+        };\n \n         // Allow comparing the results of signum()\n         if is_signum(cx, left) && is_signum(cx, right) {\n@@ -34,10 +41,7 @@ pub(crate) fn check<'tcx>(\n             }\n         }\n         let is_comparing_arrays = is_array(cx, left) || is_array(cx, right);\n-        let (lint, msg) = get_lint_and_message(\n-            is_named_constant(cx, left) || is_named_constant(cx, right),\n-            is_comparing_arrays,\n-        );\n+        let (lint, msg) = get_lint_and_message(left_is_local && right_is_local, is_comparing_arrays);\n         span_lint_and_then(cx, lint, expr.span, msg, |diag| {\n             let lhs = Sugg::hir(cx, left, \"..\");\n             let rhs = Sugg::hir(cx, right, \"..\");\n@@ -59,44 +63,33 @@ pub(crate) fn check<'tcx>(\n     }\n }\n \n-fn get_lint_and_message(\n-    is_comparing_constants: bool,\n-    is_comparing_arrays: bool,\n-) -> (&'static rustc_lint::Lint, &'static str) {\n-    if is_comparing_constants {\n+fn get_lint_and_message(is_local: bool, is_comparing_arrays: bool) -> (&'static rustc_lint::Lint, &'static str) {\n+    if is_local {\n         (\n-            FLOAT_CMP_CONST,\n+            FLOAT_CMP,\n             if is_comparing_arrays {\n-                \"strict comparison of `f32` or `f64` constant arrays\"\n+                \"strict comparison of `f32` or `f64` arrays\"\n             } else {\n-                \"strict comparison of `f32` or `f64` constant\"\n+                \"strict comparison of `f32` or `f64`\"\n             },\n         )\n     } else {\n         (\n-            FLOAT_CMP,\n+            FLOAT_CMP_CONST,\n             if is_comparing_arrays {\n-                \"strict comparison of `f32` or `f64` arrays\"\n+                \"strict comparison of `f32` or `f64` constant arrays\"\n             } else {\n-                \"strict comparison of `f32` or `f64`\"\n+                \"strict comparison of `f32` or `f64` constant\"\n             },\n         )\n     }\n }\n \n-fn is_named_constant<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n-    if let Some((_, res)) = constant(cx, cx.typeck_results(), expr) {\n-        res\n-    } else {\n-        false\n-    }\n-}\n-\n-fn is_allowed<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n-    match constant(cx, cx.typeck_results(), expr) {\n-        Some((Constant::F32(f), _)) => f == 0.0 || f.is_infinite(),\n-        Some((Constant::F64(f), _)) => f == 0.0 || f.is_infinite(),\n-        Some((Constant::Vec(vec), _)) => vec.iter().all(|f| match f {\n+fn is_allowed(val: &Constant) -> bool {\n+    match val {\n+        &Constant::F32(f) => f == 0.0 || f.is_infinite(),\n+        &Constant::F64(f) => f == 0.0 || f.is_infinite(),\n+        Constant::Vec(vec) => vec.iter().all(|f| match f {\n             Constant::F32(f) => *f == 0.0 || (*f).is_infinite(),\n             Constant::F64(f) => *f == 0.0 || (*f).is_infinite(),\n             _ => false,"}, {"sha": "a2c3a4d8ba7752d794d7656dfdecb12131bdfa6c", "filename": "clippy_lints/src/operators/modulo_arithmetic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Foperators%2Fmodulo_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Foperators%2Fmodulo_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Fmodulo_arithmetic.rs?ref=1e8d2c59bcdf34ae19677cb10f0ce435224f324f", "patch": "@@ -40,7 +40,7 @@ struct OperandInfo {\n \n fn analyze_operand(operand: &Expr<'_>, cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<OperandInfo> {\n     match constant(cx, cx.typeck_results(), operand) {\n-        Some((Constant::Int(v), _)) => match *cx.typeck_results().expr_ty(expr).kind() {\n+        Some(Constant::Int(v)) => match *cx.typeck_results().expr_ty(expr).kind() {\n             ty::Int(ity) => {\n                 let value = sext(cx.tcx, v, ity);\n                 return Some(OperandInfo {\n@@ -58,10 +58,10 @@ fn analyze_operand(operand: &Expr<'_>, cx: &LateContext<'_>, expr: &Expr<'_>) ->\n             },\n             _ => {},\n         },\n-        Some((Constant::F32(f), _)) => {\n+        Some(Constant::F32(f)) => {\n             return Some(floating_point_operand_info(&f));\n         },\n-        Some((Constant::F64(f), _)) => {\n+        Some(Constant::F64(f)) => {\n             return Some(floating_point_operand_info(&f));\n         },\n         _ => {},"}, {"sha": "dd7ded491e792383cfb973c009f921dc1fca5997", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=1e8d2c59bcdf34ae19677cb10f0ce435224f324f", "patch": "@@ -319,7 +319,7 @@ fn check_range_bounds<'a>(cx: &'a LateContext<'_>, ex: &'a Expr<'_>) -> Option<R\n             _ => return None,\n         };\n         if let Some(id) = path_to_local(l) {\n-            if let Some((c, _)) = constant(cx, cx.typeck_results(), r) {\n+            if let Some(c) = constant(cx, cx.typeck_results(), r) {\n                 return Some(RangeBounds {\n                     val: c,\n                     expr: r,\n@@ -331,7 +331,7 @@ fn check_range_bounds<'a>(cx: &'a LateContext<'_>, ex: &'a Expr<'_>) -> Option<R\n                 });\n             }\n         } else if let Some(id) = path_to_local(r) {\n-            if let Some((c, _)) = constant(cx, cx.typeck_results(), l) {\n+            if let Some(c) = constant(cx, cx.typeck_results(), l) {\n                 return Some(RangeBounds {\n                     val: c,\n                     expr: l,\n@@ -451,8 +451,8 @@ fn check_reversed_empty_range(cx: &LateContext<'_>, expr: &Expr<'_>) {\n         if let Some(higher::Range { start: Some(start), end: Some(end), limits }) = higher::Range::hir(expr);\n         let ty = cx.typeck_results().expr_ty(start);\n         if let ty::Int(_) | ty::Uint(_) = ty.kind();\n-        if let Some((start_idx, _)) = constant(cx, cx.typeck_results(), start);\n-        if let Some((end_idx, _)) = constant(cx, cx.typeck_results(), end);\n+        if let Some(start_idx) = constant(cx, cx.typeck_results(), start);\n+        if let Some(end_idx) = constant(cx, cx.typeck_results(), end);\n         if let Some(ordering) = Constant::partial_cmp(cx.tcx, ty, &start_idx, &end_idx);\n         if is_empty_range(limits, ordering);\n         then {"}, {"sha": "ef19c6f4617295a4cef75847ee64064bc9a7550f", "filename": "clippy_lints/src/regex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fregex.rs?ref=1e8d2c59bcdf34ae19677cb10f0ce435224f324f", "patch": "@@ -122,7 +122,7 @@ fn lint_syntax_error(cx: &LateContext<'_>, error: &regex_syntax::Error, unescape\n }\n \n fn const_str<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> Option<String> {\n-    constant(cx, cx.typeck_results(), e).and_then(|(c, _)| match c {\n+    constant(cx, cx.typeck_results(), e).and_then(|c| match c {\n         Constant::Str(s) => Some(s),\n         _ => None,\n     })"}, {"sha": "4944381da24d59350effe1fbeab37eba24842bb7", "filename": "clippy_lints/src/transmute/transmute_null_to_fn.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_null_to_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_null_to_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_null_to_fn.rs?ref=1e8d2c59bcdf34ae19677cb10f0ce435224f324f", "patch": "@@ -31,9 +31,7 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, arg: &'t\n     match arg.kind {\n         // Catching:\n         // transmute over constants that resolve to `null`.\n-        ExprKind::Path(ref _qpath)\n-            if matches!(constant(cx, cx.typeck_results(), arg), Some((Constant::RawPtr(0), _))) =>\n-        {\n+        ExprKind::Path(ref _qpath) if matches!(constant(cx, cx.typeck_results(), arg), Some(Constant::RawPtr(0))) => {\n             lint_expr(cx, expr);\n             true\n         },"}, {"sha": "770914e99e1689c193651a09efc0d33cad08d614", "filename": "clippy_lints/src/transmute/transmuting_null.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Ftransmute%2Ftransmuting_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Ftransmute%2Ftransmuting_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmuting_null.rs?ref=1e8d2c59bcdf34ae19677cb10f0ce435224f324f", "patch": "@@ -1,4 +1,4 @@\n-use clippy_utils::consts::{constant_context, Constant};\n+use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::span_lint;\n use clippy_utils::{is_integer_literal, is_path_diagnostic_item};\n use rustc_hir::{Expr, ExprKind};\n@@ -16,9 +16,8 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, arg: &'t\n     }\n \n     // Catching transmute over constants that resolve to `null`.\n-    let mut const_eval_context = constant_context(cx, cx.typeck_results());\n     if let ExprKind::Path(ref _qpath) = arg.kind &&\n-        let Some(Constant::RawPtr(0)) = const_eval_context.expr(arg)\n+        let Some(Constant::RawPtr(0)) = constant(cx, cx.typeck_results(), arg)\n     {\n         span_lint(cx, TRANSMUTING_NULL, expr.span, LINT_MSG);\n         return true;"}, {"sha": "7329e508106d988053af17c9549df8c110594d88", "filename": "clippy_lints/src/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec.rs?ref=1e8d2c59bcdf34ae19677cb10f0ce435224f324f", "patch": "@@ -84,7 +84,7 @@ impl UselessVec {\n         let mut applicability = Applicability::MachineApplicable;\n         let snippet = match *vec_args {\n             higher::VecArgs::Repeat(elem, len) => {\n-                if let Some((Constant::Int(len_constant), _)) = constant(cx, cx.typeck_results(), len) {\n+                if let Some(Constant::Int(len_constant)) = constant(cx, cx.typeck_results(), len) {\n                     #[expect(clippy::cast_possible_truncation)]\n                     if len_constant as u64 * size_of(cx, elem) > self.too_large_for_stack {\n                         return;"}, {"sha": "992d41bc378c7c83ba3465a1866ea748505376e0", "filename": "clippy_utils/src/consts.rs", "status": "modified", "additions": 74, "deletions": 33, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fconsts.rs?ref=1e8d2c59bcdf34ae19677cb10f0ce435224f324f", "patch": "@@ -1,18 +1,21 @@\n #![allow(clippy::float_cmp)]\n \n+use crate::source::{get_source_text, walk_span_to_context};\n use crate::{clip, is_direct_expn_of, sext, unsext};\n use if_chain::if_chain;\n use rustc_ast::ast::{self, LitFloatType, LitKind};\n use rustc_data_structures::sync::Lrc;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::{BinOp, BinOpKind, Block, Expr, ExprKind, HirId, Item, ItemKind, Node, QPath, UnOp};\n+use rustc_lexer::tokenize;\n use rustc_lint::LateContext;\n use rustc_middle::mir;\n use rustc_middle::mir::interpret::Scalar;\n-use rustc_middle::ty::SubstsRef;\n use rustc_middle::ty::{self, EarlyBinder, FloatTy, ScalarInt, Ty, TyCtxt};\n+use rustc_middle::ty::{List, SubstsRef};\n use rustc_middle::{bug, span_bug};\n use rustc_span::symbol::Symbol;\n+use rustc_span::SyntaxContext;\n use std::cmp::Ordering::{self, Equal};\n use std::hash::{Hash, Hasher};\n use std::iter;\n@@ -227,27 +230,46 @@ pub fn lit_to_mir_constant(lit: &LitKind, ty: Option<Ty<'_>>) -> Constant {\n     }\n }\n \n+/// The source of a constant value.\n+pub enum ConstantSource {\n+    /// The value is determined solely from the expression.\n+    Local,\n+    /// The value is dependent on a defined constant.\n+    Constant,\n+}\n+impl ConstantSource {\n+    pub fn is_local(&self) -> bool {\n+        matches!(self, Self::Local)\n+    }\n+}\n+\n+/// Attempts to evaluate the expression as a constant.\n pub fn constant<'tcx>(\n     lcx: &LateContext<'tcx>,\n     typeck_results: &ty::TypeckResults<'tcx>,\n     e: &Expr<'_>,\n-) -> Option<(Constant, bool)> {\n-    let mut cx = ConstEvalLateContext {\n-        lcx,\n-        typeck_results,\n-        param_env: lcx.param_env,\n-        needed_resolution: false,\n-        substs: ty::List::empty(),\n-    };\n-    cx.expr(e).map(|cst| (cst, cx.needed_resolution))\n+) -> Option<Constant> {\n+    ConstEvalLateContext::new(lcx, typeck_results).expr(e)\n+}\n+\n+/// Attempts to evaluate the expression as a constant.\n+pub fn constant_with_source<'tcx>(\n+    lcx: &LateContext<'tcx>,\n+    typeck_results: &ty::TypeckResults<'tcx>,\n+    e: &Expr<'_>,\n+) -> Option<(Constant, ConstantSource)> {\n+    let mut ctxt = ConstEvalLateContext::new(lcx, typeck_results);\n+    let res = ctxt.expr(e);\n+    res.map(|x| (x, ctxt.source))\n }\n \n+/// Attempts to evaluate an expression only if it's value is not dependent on other items.\n pub fn constant_simple<'tcx>(\n     lcx: &LateContext<'tcx>,\n     typeck_results: &ty::TypeckResults<'tcx>,\n     e: &Expr<'_>,\n ) -> Option<Constant> {\n-    constant(lcx, typeck_results, e).and_then(|(cst, res)| if res { None } else { Some(cst) })\n+    constant_with_source(lcx, typeck_results, e).and_then(|(c, s)| s.is_local().then_some(c))\n }\n \n pub fn constant_full_int<'tcx>(\n@@ -296,29 +318,25 @@ impl Ord for FullInt {\n     }\n }\n \n-/// Creates a `ConstEvalLateContext` from the given `LateContext` and `TypeckResults`.\n-pub fn constant_context<'a, 'tcx>(\n-    lcx: &'a LateContext<'tcx>,\n-    typeck_results: &'a ty::TypeckResults<'tcx>,\n-) -> ConstEvalLateContext<'a, 'tcx> {\n-    ConstEvalLateContext {\n-        lcx,\n-        typeck_results,\n-        param_env: lcx.param_env,\n-        needed_resolution: false,\n-        substs: ty::List::empty(),\n-    }\n-}\n-\n pub struct ConstEvalLateContext<'a, 'tcx> {\n     lcx: &'a LateContext<'tcx>,\n     typeck_results: &'a ty::TypeckResults<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    needed_resolution: bool,\n+    source: ConstantSource,\n     substs: SubstsRef<'tcx>,\n }\n \n impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n+    fn new(lcx: &'a LateContext<'tcx>, typeck_results: &'a ty::TypeckResults<'tcx>) -> Self {\n+        Self {\n+            lcx,\n+            typeck_results,\n+            param_env: lcx.param_env,\n+            source: ConstantSource::Local,\n+            substs: List::empty(),\n+        }\n+    }\n+\n     /// Simple constant folding: Insert an expression, get a constant or none.\n     pub fn expr(&mut self, e: &Expr<'_>) -> Option<Constant> {\n         match e.kind {\n@@ -453,11 +471,9 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n                     .const_eval_resolve(self.param_env, mir::UnevaluatedConst::new(def_id, substs), None)\n                     .ok()\n                     .map(|val| rustc_middle::mir::ConstantKind::from_value(val, ty))?;\n-                let result = miri_to_const(self.lcx.tcx, result);\n-                if result.is_some() {\n-                    self.needed_resolution = true;\n-                }\n-                result\n+                let result = miri_to_const(self.lcx.tcx, result)?;\n+                self.source = ConstantSource::Constant;\n+                Some(result)\n             },\n             // FIXME: cover all usable cases.\n             _ => None,\n@@ -491,8 +507,33 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n \n     /// A block can only yield a constant if it only has one constant expression.\n     fn block(&mut self, block: &Block<'_>) -> Option<Constant> {\n-        if block.stmts.is_empty() {\n-            block.expr.as_ref().and_then(|b| self.expr(b))\n+        if block.stmts.is_empty()\n+            && let Some(expr) = block.expr\n+        {\n+            // Try to detect any `cfg`ed statements or empty macro expansions.\n+            let span = block.span.data();\n+            if span.ctxt == SyntaxContext::root() {\n+                if let Some(expr_span) = walk_span_to_context(expr.span, span.ctxt)\n+                    && let expr_lo = expr_span.lo()\n+                    && expr_lo >= span.lo\n+                    && let Some(src) = get_source_text(self.lcx, span.lo..expr_lo)\n+                    && let Some(src) = src.as_str()\n+                {\n+                    use rustc_lexer::TokenKind::{Whitespace, LineComment, BlockComment, Semi, OpenBrace};\n+                    if !tokenize(src)\n+                        .map(|t| t.kind)\n+                        .filter(|t| !matches!(t, Whitespace | LineComment { .. } | BlockComment { .. } | Semi))\n+                        .eq([OpenBrace])\n+                    {\n+                        self.source = ConstantSource::Constant;\n+                    }\n+                } else {\n+                    // Unable to access the source. Assume a non-local dependency.\n+                    self.source = ConstantSource::Constant;\n+                }\n+            }\n+\n+            self.expr(expr)\n         } else {\n             None\n         }"}, {"sha": "a49246a7832727a6c4c1d5d8854e71d5318f8b19", "filename": "clippy_utils/src/hir_utils.rs", "status": "modified", "additions": 159, "deletions": 47, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_utils%2Fsrc%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_utils%2Fsrc%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhir_utils.rs?ref=1e8d2c59bcdf34ae19677cb10f0ce435224f324f", "patch": "@@ -1,6 +1,7 @@\n use crate::consts::constant_simple;\n use crate::macros::macro_backtrace;\n-use crate::source::snippet_opt;\n+use crate::source::{get_source_text, snippet_opt, walk_span_to_context, SpanRange};\n+use crate::tokenize_with_text;\n use rustc_ast::ast::InlineAsmTemplatePiece;\n use rustc_data_structures::fx::FxHasher;\n use rustc_hir::def::Res;\n@@ -13,8 +14,9 @@ use rustc_hir::{\n use rustc_lexer::{tokenize, TokenKind};\n use rustc_lint::LateContext;\n use rustc_middle::ty::TypeckResults;\n-use rustc_span::{sym, Symbol};\n+use rustc_span::{sym, BytePos, ExpnKind, MacroKind, Symbol, SyntaxContext};\n use std::hash::{Hash, Hasher};\n+use std::ops::Range;\n \n /// Callback that is called when two expressions are not equal in the sense of `SpanlessEq`, but\n /// other conditions would make them equal.\n@@ -65,6 +67,8 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n     pub fn inter_expr(&mut self) -> HirEqInterExpr<'_, 'a, 'tcx> {\n         HirEqInterExpr {\n             inner: self,\n+            left_ctxt: SyntaxContext::root(),\n+            right_ctxt: SyntaxContext::root(),\n             locals: HirIdMap::default(),\n         }\n     }\n@@ -92,6 +96,8 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n \n pub struct HirEqInterExpr<'a, 'b, 'tcx> {\n     inner: &'a mut SpanlessEq<'b, 'tcx>,\n+    left_ctxt: SyntaxContext,\n+    right_ctxt: SyntaxContext,\n \n     // When binding are declared, the binding ID in the left expression is mapped to the one on the\n     // right. For example, when comparing `{ let x = 1; x + 2 }` and `{ let y = 1; y + 2 }`,\n@@ -126,52 +132,88 @@ impl HirEqInterExpr<'_, '_, '_> {\n     }\n \n     /// Checks whether two blocks are the same.\n+    #[expect(clippy::similar_names)]\n     fn eq_block(&mut self, left: &Block<'_>, right: &Block<'_>) -> bool {\n-        match (left.stmts, left.expr, right.stmts, right.expr) {\n-            ([], None, [], None) => {\n-                // For empty blocks, check to see if the tokens are equal. This will catch the case where a macro\n-                // expanded to nothing, or the cfg attribute was used.\n-                let (Some(left), Some(right)) = (\n-                    snippet_opt(self.inner.cx, left.span),\n-                    snippet_opt(self.inner.cx, right.span),\n-                ) else { return true };\n-                let mut left_pos = 0;\n-                let left = tokenize(&left)\n-                    .map(|t| {\n-                        let end = left_pos + t.len as usize;\n-                        let s = &left[left_pos..end];\n-                        left_pos = end;\n-                        (t, s)\n-                    })\n-                    .filter(|(t, _)| {\n-                        !matches!(\n-                            t.kind,\n-                            TokenKind::LineComment { .. } | TokenKind::BlockComment { .. } | TokenKind::Whitespace\n-                        )\n-                    })\n-                    .map(|(_, s)| s);\n-                let mut right_pos = 0;\n-                let right = tokenize(&right)\n-                    .map(|t| {\n-                        let end = right_pos + t.len as usize;\n-                        let s = &right[right_pos..end];\n-                        right_pos = end;\n-                        (t, s)\n-                    })\n-                    .filter(|(t, _)| {\n-                        !matches!(\n-                            t.kind,\n-                            TokenKind::LineComment { .. } | TokenKind::BlockComment { .. } | TokenKind::Whitespace\n-                        )\n-                    })\n-                    .map(|(_, s)| s);\n-                left.eq(right)\n-            },\n-            _ => {\n-                over(left.stmts, right.stmts, |l, r| self.eq_stmt(l, r))\n-                    && both(&left.expr, &right.expr, |l, r| self.eq_expr(l, r))\n-            },\n+        use TokenKind::{BlockComment, LineComment, Semi, Whitespace};\n+        if left.stmts.len() != right.stmts.len() {\n+            return false;\n+        }\n+        let lspan = left.span.data();\n+        let rspan = right.span.data();\n+        if lspan.ctxt != SyntaxContext::root() && rspan.ctxt != SyntaxContext::root() {\n+            // Don't try to check in between statements inside macros.\n+            return over(left.stmts, right.stmts, |left, right| self.eq_stmt(left, right))\n+                && both(&left.expr, &right.expr, |left, right| self.eq_expr(left, right));\n+        }\n+        if lspan.ctxt != rspan.ctxt {\n+            return false;\n         }\n+\n+        let mut lstart = lspan.lo;\n+        let mut rstart = rspan.lo;\n+\n+        for (left, right) in left.stmts.iter().zip(right.stmts) {\n+            if !self.eq_stmt(left, right) {\n+                return false;\n+            }\n+\n+            // Try to detect any `cfg`ed statements or empty macro expansions.\n+            let Some(lstmt_span) = walk_span_to_context(left.span, lspan.ctxt) else {\n+                return false;\n+            };\n+            let Some(rstmt_span) = walk_span_to_context(right.span, rspan.ctxt) else {\n+                return false;\n+            };\n+            let lstmt_span = lstmt_span.data();\n+            let rstmt_span = rstmt_span.data();\n+\n+            if lstmt_span.lo < lstart && rstmt_span.lo < rstart {\n+                // Can happen when macros expand to multiple statements, or rearrange statements.\n+                // Nothing in between the statements to check in this case.\n+                continue;\n+            }\n+            if lstmt_span.lo < lstart || rstmt_span.lo < rstart {\n+                // Only one of the blocks had a weird macro.\n+                return false;\n+            }\n+            if !eq_span_tokens(self.inner.cx, lstart..lstmt_span.lo, rstart..rstmt_span.lo, |t| {\n+                !matches!(t, Whitespace | LineComment { .. } | BlockComment { .. } | Semi)\n+            }) {\n+                return false;\n+            }\n+\n+            lstart = lstmt_span.hi;\n+            rstart = rstmt_span.hi;\n+        }\n+\n+        let (lend, rend) = match (left.expr, right.expr) {\n+            (Some(left), Some(right)) => {\n+                if !self.eq_expr(left, right) {\n+                    return false;\n+                }\n+                let Some(lexpr_span) = walk_span_to_context(left.span, lspan.ctxt) else {\n+                    return false;\n+                };\n+                let Some(rexpr_span) = walk_span_to_context(right.span, rspan.ctxt) else {\n+                    return false;\n+                };\n+                (lexpr_span.lo(), rexpr_span.lo())\n+            },\n+            (None, None) => (lspan.hi, rspan.hi),\n+            (Some(_), None) | (None, Some(_)) => return false,\n+        };\n+\n+        if lend < lstart && rend < rstart {\n+            // Can happen when macros rearrange the input.\n+            // Nothing in between the statements to check in this case.\n+            return true;\n+        } else if lend < lstart || rend < rstart {\n+            // Only one of the blocks had a weird macro\n+            return false;\n+        }\n+        eq_span_tokens(self.inner.cx, lstart..lend, rstart..rend, |t| {\n+            !matches!(t, Whitespace | LineComment { .. } | BlockComment { .. } | Semi)\n+        })\n     }\n \n     fn should_ignore(&mut self, expr: &Expr<'_>) -> bool {\n@@ -207,7 +249,7 @@ impl HirEqInterExpr<'_, '_, '_> {\n \n     #[expect(clippy::similar_names)]\n     pub fn eq_expr(&mut self, left: &Expr<'_>, right: &Expr<'_>) -> bool {\n-        if !self.inner.allow_side_effects && left.span.ctxt() != right.span.ctxt() {\n+        if !self.check_ctxt(left.span.ctxt(), right.span.ctxt()) {\n             return false;\n         }\n \n@@ -440,6 +482,45 @@ impl HirEqInterExpr<'_, '_, '_> {\n     fn eq_type_binding(&mut self, left: &TypeBinding<'_>, right: &TypeBinding<'_>) -> bool {\n         left.ident.name == right.ident.name && self.eq_ty(left.ty(), right.ty())\n     }\n+\n+    fn check_ctxt(&mut self, left: SyntaxContext, right: SyntaxContext) -> bool {\n+        if self.left_ctxt == left && self.right_ctxt == right {\n+            return true;\n+        } else if self.left_ctxt == left || self.right_ctxt == right {\n+            // Only one context has changed. This can only happen if the two nodes are written differently.\n+            return false;\n+        } else if left != SyntaxContext::root() {\n+            let mut left_data = left.outer_expn_data();\n+            let mut right_data = right.outer_expn_data();\n+            loop {\n+                use TokenKind::{BlockComment, LineComment, Whitespace};\n+                if left_data.macro_def_id != right_data.macro_def_id\n+                    || (matches!(left_data.kind, ExpnKind::Macro(MacroKind::Bang, name) if name == sym::cfg)\n+                        && !eq_span_tokens(self.inner.cx, left_data.call_site, right_data.call_site, |t| {\n+                            !matches!(t, Whitespace | LineComment { .. } | BlockComment { .. })\n+                        }))\n+                {\n+                    // Either a different chain of macro calls, or different arguments to the `cfg` macro.\n+                    return false;\n+                }\n+                let left_ctxt = left_data.call_site.ctxt();\n+                let right_ctxt = right_data.call_site.ctxt();\n+                if left_ctxt == SyntaxContext::root() && right_ctxt == SyntaxContext::root() {\n+                    break;\n+                }\n+                if left_ctxt == SyntaxContext::root() || right_ctxt == SyntaxContext::root() {\n+                    // Different lengths for the expansion stack. This can only happen if nodes are written differently,\n+                    // or shouldn't be compared to start with.\n+                    return false;\n+                }\n+                left_data = left_ctxt.outer_expn_data();\n+                right_data = right_ctxt.outer_expn_data();\n+            }\n+        }\n+        self.left_ctxt = left;\n+        self.right_ctxt = right;\n+        true\n+    }\n }\n \n /// Some simple reductions like `{ return }` => `return`\n@@ -1038,3 +1119,34 @@ pub fn hash_expr(cx: &LateContext<'_>, e: &Expr<'_>) -> u64 {\n     h.hash_expr(e);\n     h.finish()\n }\n+\n+#[expect(clippy::similar_names)]\n+fn eq_span_tokens(\n+    cx: &LateContext<'_>,\n+    left: impl SpanRange,\n+    right: impl SpanRange,\n+    pred: impl Fn(TokenKind) -> bool,\n+) -> bool {\n+    fn f(cx: &LateContext<'_>, left: Range<BytePos>, right: Range<BytePos>, pred: impl Fn(TokenKind) -> bool) -> bool {\n+        if let Some(lsrc) = get_source_text(cx, left)\n+            && let Some(lsrc) = lsrc.as_str()\n+            && let Some(rsrc) = get_source_text(cx, right)\n+            && let Some(rsrc) = rsrc.as_str()\n+        {\n+            let pred = |t: &(_, _)| pred(t.0);\n+            let map = |(_, x)| x;\n+\n+            let ltok = tokenize_with_text(lsrc)\n+                .filter(pred)\n+                .map(map);\n+            let rtok = tokenize_with_text(rsrc)\n+                .filter(pred)\n+                .map(map);\n+            ltok.eq(rtok)\n+        } else {\n+            // Unable to access the source. Conservatively assume the blocks aren't equal.\n+            false\n+        }\n+    }\n+    f(cx, left.into_range(), right.into_range(), pred)\n+}"}, {"sha": "575c29a6b6f97f3b6783ab84bd5c26daf53e338a", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=1e8d2c59bcdf34ae19677cb10f0ce435224f324f", "patch": "@@ -77,6 +77,7 @@ use std::sync::OnceLock;\n use std::sync::{Mutex, MutexGuard};\n \n use if_chain::if_chain;\n+use itertools::Itertools;\n use rustc_ast::ast::{self, LitKind, RangeLimits};\n use rustc_ast::Attribute;\n use rustc_data_structures::fx::FxHashMap;\n@@ -1498,7 +1499,7 @@ pub fn is_range_full(cx: &LateContext<'_>, expr: &Expr<'_>, container_path: Opti\n                 && let const_val = cx.tcx.valtree_to_const_val((bnd_ty, min_val.to_valtree()))\n                 && let min_const_kind = ConstantKind::from_value(const_val, bnd_ty)\n                 && let Some(min_const) = miri_to_const(cx.tcx, min_const_kind)\n-                && let Some((start_const, _)) = constant(cx, cx.typeck_results(), start)\n+                && let Some(start_const) = constant(cx, cx.typeck_results(), start)\n             {\n                 start_const == min_const\n             } else {\n@@ -1514,7 +1515,7 @@ pub fn is_range_full(cx: &LateContext<'_>, expr: &Expr<'_>, container_path: Opti\n                         && let const_val = cx.tcx.valtree_to_const_val((bnd_ty, max_val.to_valtree()))\n                         && let max_const_kind = ConstantKind::from_value(const_val, bnd_ty)\n                         && let Some(max_const) = miri_to_const(cx.tcx, max_const_kind)\n-                        && let Some((end_const, _)) = constant(cx, cx.typeck_results(), end)\n+                        && let Some(end_const) = constant(cx, cx.typeck_results(), end)\n                     {\n                         end_const == max_const\n                     } else {\n@@ -1546,7 +1547,7 @@ pub fn is_integer_const(cx: &LateContext<'_>, e: &Expr<'_>, value: u128) -> bool\n         return true;\n     }\n     let enclosing_body = cx.tcx.hir().enclosing_body_owner(e.hir_id);\n-    if let Some((Constant::Int(v), _)) = constant(cx, cx.tcx.typeck(enclosing_body), e) {\n+    if let Some(Constant::Int(v)) = constant(cx, cx.tcx.typeck(enclosing_body), e) {\n         return value == v;\n     }\n     false\n@@ -2490,6 +2491,17 @@ pub fn walk_to_expr_usage<'tcx, T>(\n     None\n }\n \n+/// Tokenizes the input while keeping the text associated with each token.\n+pub fn tokenize_with_text(s: &str) -> impl Iterator<Item = (TokenKind, &str)> {\n+    let mut pos = 0;\n+    tokenize(s).map(move |t| {\n+        let end = pos + t.len;\n+        let range = pos as usize..end as usize;\n+        pos = end;\n+        (t.kind, s.get(range).unwrap_or_default())\n+    })\n+}\n+\n /// Checks whether a given span has any comment token\n /// This checks for all types of comment: line \"//\", block \"/**\", doc \"///\" \"//!\"\n pub fn span_contains_comment(sm: &SourceMap, span: Span) -> bool {\n@@ -2506,23 +2518,11 @@ pub fn span_contains_comment(sm: &SourceMap, span: Span) -> bool {\n /// Comments are returned wrapped with their relevant delimiters\n pub fn span_extract_comment(sm: &SourceMap, span: Span) -> String {\n     let snippet = sm.span_to_snippet(span).unwrap_or_default();\n-    let mut comments_buf: Vec<String> = Vec::new();\n-    let mut index: usize = 0;\n-\n-    for token in tokenize(&snippet) {\n-        let token_range = index..(index + token.len as usize);\n-        index += token.len as usize;\n-        match token.kind {\n-            TokenKind::BlockComment { .. } | TokenKind::LineComment { .. } => {\n-                if let Some(comment) = snippet.get(token_range) {\n-                    comments_buf.push(comment.to_string());\n-                }\n-            },\n-            _ => (),\n-        }\n-    }\n-\n-    comments_buf.join(\"\\n\")\n+    let res = tokenize_with_text(&snippet)\n+        .filter(|(t, _)| matches!(t, TokenKind::BlockComment { .. } | TokenKind::LineComment { .. }))\n+        .map(|(_, s)| s)\n+        .join(\"\\n\");\n+    res\n }\n \n pub fn span_find_starting_semi(sm: &SourceMap, span: Span) -> Span {"}, {"sha": "0f60290644a18daba5232f76b4502961756e57d5", "filename": "clippy_utils/src/source.rs", "status": "modified", "additions": 51, "deletions": 1, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_utils%2Fsrc%2Fsource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/clippy_utils%2Fsrc%2Fsource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fsource.rs?ref=1e8d2c59bcdf34ae19677cb10f0ce435224f324f", "patch": "@@ -2,14 +2,64 @@\n \n #![allow(clippy::module_name_repetitions)]\n \n+use rustc_data_structures::sync::Lrc;\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LintContext};\n use rustc_session::Session;\n-use rustc_span::hygiene;\n use rustc_span::source_map::{original_sp, SourceMap};\n+use rustc_span::{hygiene, SourceFile};\n use rustc_span::{BytePos, Pos, Span, SpanData, SyntaxContext, DUMMY_SP};\n use std::borrow::Cow;\n+use std::ops::Range;\n+\n+/// A type which can be converted to the range portion of a `Span`.\n+pub trait SpanRange {\n+    fn into_range(self) -> Range<BytePos>;\n+}\n+impl SpanRange for Span {\n+    fn into_range(self) -> Range<BytePos> {\n+        let data = self.data();\n+        data.lo..data.hi\n+    }\n+}\n+impl SpanRange for SpanData {\n+    fn into_range(self) -> Range<BytePos> {\n+        self.lo..self.hi\n+    }\n+}\n+impl SpanRange for Range<BytePos> {\n+    fn into_range(self) -> Range<BytePos> {\n+        self\n+    }\n+}\n+\n+pub struct SourceFileRange {\n+    pub sf: Lrc<SourceFile>,\n+    pub range: Range<usize>,\n+}\n+impl SourceFileRange {\n+    /// Attempts to get the text from the source file. This can fail if the source text isn't\n+    /// loaded.\n+    pub fn as_str(&self) -> Option<&str> {\n+        self.sf.src.as_ref().and_then(|x| x.get(self.range.clone()))\n+    }\n+}\n+\n+/// Gets the source file, and range in the file, of the given span. Returns `None` if the span\n+/// extends through multiple files, or is malformed.\n+pub fn get_source_text(cx: &impl LintContext, sp: impl SpanRange) -> Option<SourceFileRange> {\n+    fn f(sm: &SourceMap, sp: Range<BytePos>) -> Option<SourceFileRange> {\n+        let start = sm.lookup_byte_offset(sp.start);\n+        let end = sm.lookup_byte_offset(sp.end);\n+        if !Lrc::ptr_eq(&start.sf, &end.sf) || start.pos > end.pos {\n+            return None;\n+        }\n+        let range = start.pos.to_usize()..end.pos.to_usize();\n+        Some(SourceFileRange { sf: start.sf, range })\n+    }\n+    f(cx.sess().source_map(), sp.into_range())\n+}\n \n /// Like `snippet_block`, but add braces if the expr is not an `ExprKind::Block`.\n pub fn expr_block<T: LintContext>("}, {"sha": "c6514a559340ceeb61e54aa43b1f4c32ba8b7451", "filename": "tests/ui/collapsible_if.fixed", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/tests%2Fui%2Fcollapsible_if.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/tests%2Fui%2Fcollapsible_if.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcollapsible_if.fixed?ref=1e8d2c59bcdf34ae19677cb10f0ce435224f324f", "patch": "@@ -1,5 +1,10 @@\n //@run-rustfix\n-#![allow(clippy::assertions_on_constants, clippy::equatable_if_let)]\n+#![allow(\n+    clippy::assertions_on_constants,\n+    clippy::equatable_if_let,\n+    clippy::nonminimal_bool,\n+    clippy::eq_op\n+)]\n \n #[rustfmt::skip]\n #[warn(clippy::collapsible_if)]"}, {"sha": "2c85b68df632c8209cd1b56104d59c3ddcf4bdf4", "filename": "tests/ui/collapsible_if.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/tests%2Fui%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/tests%2Fui%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcollapsible_if.rs?ref=1e8d2c59bcdf34ae19677cb10f0ce435224f324f", "patch": "@@ -1,5 +1,10 @@\n //@run-rustfix\n-#![allow(clippy::assertions_on_constants, clippy::equatable_if_let)]\n+#![allow(\n+    clippy::assertions_on_constants,\n+    clippy::equatable_if_let,\n+    clippy::nonminimal_bool,\n+    clippy::eq_op\n+)]\n \n #[rustfmt::skip]\n #[warn(clippy::collapsible_if)]"}, {"sha": "c687bae1acc524b033abda01444080b19958b9b1", "filename": "tests/ui/collapsible_if.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/tests%2Fui%2Fcollapsible_if.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/tests%2Fui%2Fcollapsible_if.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcollapsible_if.stderr?ref=1e8d2c59bcdf34ae19677cb10f0ce435224f324f", "patch": "@@ -1,5 +1,5 @@\n error: this `if` statement can be collapsed\n-  --> $DIR/collapsible_if.rs:9:5\n+  --> $DIR/collapsible_if.rs:14:5\n    |\n LL | /     if x == \"hello\" {\n LL | |         if y == \"world\" {\n@@ -17,7 +17,7 @@ LL +     }\n    |\n \n error: this `if` statement can be collapsed\n-  --> $DIR/collapsible_if.rs:15:5\n+  --> $DIR/collapsible_if.rs:20:5\n    |\n LL | /     if x == \"hello\" || x == \"world\" {\n LL | |         if y == \"world\" || y == \"hello\" {\n@@ -34,7 +34,7 @@ LL +     }\n    |\n \n error: this `if` statement can be collapsed\n-  --> $DIR/collapsible_if.rs:21:5\n+  --> $DIR/collapsible_if.rs:26:5\n    |\n LL | /     if x == \"hello\" && x == \"world\" {\n LL | |         if y == \"world\" || y == \"hello\" {\n@@ -51,7 +51,7 @@ LL +     }\n    |\n \n error: this `if` statement can be collapsed\n-  --> $DIR/collapsible_if.rs:27:5\n+  --> $DIR/collapsible_if.rs:32:5\n    |\n LL | /     if x == \"hello\" || x == \"world\" {\n LL | |         if y == \"world\" && y == \"hello\" {\n@@ -68,7 +68,7 @@ LL +     }\n    |\n \n error: this `if` statement can be collapsed\n-  --> $DIR/collapsible_if.rs:33:5\n+  --> $DIR/collapsible_if.rs:38:5\n    |\n LL | /     if x == \"hello\" && x == \"world\" {\n LL | |         if y == \"world\" && y == \"hello\" {\n@@ -85,7 +85,7 @@ LL +     }\n    |\n \n error: this `if` statement can be collapsed\n-  --> $DIR/collapsible_if.rs:39:5\n+  --> $DIR/collapsible_if.rs:44:5\n    |\n LL | /     if 42 == 1337 {\n LL | |         if 'a' != 'A' {\n@@ -102,7 +102,7 @@ LL +     }\n    |\n \n error: this `if` statement can be collapsed\n-  --> $DIR/collapsible_if.rs:95:5\n+  --> $DIR/collapsible_if.rs:100:5\n    |\n LL | /     if x == \"hello\" {\n LL | |         if y == \"world\" { // Collapsible\n@@ -119,15 +119,15 @@ LL +     }\n    |\n \n error: this `if` statement can be collapsed\n-  --> $DIR/collapsible_if.rs:154:5\n+  --> $DIR/collapsible_if.rs:159:5\n    |\n LL | /     if matches!(true, true) {\n LL | |         if matches!(true, true) {}\n LL | |     }\n    | |_____^ help: collapse nested if block: `if matches!(true, true) && matches!(true, true) {}`\n \n error: this `if` statement can be collapsed\n-  --> $DIR/collapsible_if.rs:159:5\n+  --> $DIR/collapsible_if.rs:164:5\n    |\n LL | /     if matches!(true, true) && truth() {\n LL | |         if matches!(true, true) {}"}, {"sha": "3914b45464c719f3b3b48627f347a3292a75f489", "filename": "tests/ui/match_same_arms.rs", "status": "modified", "additions": 81, "deletions": 1, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/tests%2Fui%2Fmatch_same_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/tests%2Fui%2Fmatch_same_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_same_arms.rs?ref=1e8d2c59bcdf34ae19677cb10f0ce435224f324f", "patch": "@@ -53,4 +53,84 @@ mod issue4244 {\n     }\n }\n \n-fn main() {}\n+macro_rules! m {\n+    (foo) => {};\n+    (bar) => {};\n+}\n+macro_rules! foo {\n+    () => {\n+        1\n+    };\n+}\n+macro_rules! bar {\n+    () => {\n+        1\n+    };\n+}\n+\n+fn main() {\n+    let x = 0;\n+    let _ = match 0 {\n+        0 => {\n+            m!(foo);\n+            x\n+        },\n+        1 => {\n+            m!(bar);\n+            x\n+        },\n+        _ => 1,\n+    };\n+\n+    let _ = match 0 {\n+        0 => {\n+            m!(foo);\n+            0\n+        },\n+        1 => {\n+            m!(bar);\n+            0\n+        },\n+        _ => 1,\n+    };\n+\n+    let _ = match 0 {\n+        0 => {\n+            let mut x = 0;\n+            #[cfg(not_enabled)]\n+            {\n+                x = 5;\n+            }\n+            #[cfg(not(not_enabled))]\n+            {\n+                x = 6;\n+            }\n+            x\n+        },\n+        1 => {\n+            let mut x = 0;\n+            #[cfg(also_not_enabled)]\n+            {\n+                x = 5;\n+            }\n+            #[cfg(not(also_not_enabled))]\n+            {\n+                x = 6;\n+            }\n+            x\n+        },\n+        _ => 0,\n+    };\n+\n+    let _ = match 0 {\n+        0 => foo!(),\n+        1 => bar!(),\n+        _ => 1,\n+    };\n+\n+    let _ = match 0 {\n+        0 => cfg!(not_enabled),\n+        1 => cfg!(also_not_enabled),\n+        _ => false,\n+    };\n+}"}, {"sha": "60b2975be04543f9649fde236d3a9c30cd257491", "filename": "tests/ui/match_same_arms2.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/tests%2Fui%2Fmatch_same_arms2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/tests%2Fui%2Fmatch_same_arms2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_same_arms2.rs?ref=1e8d2c59bcdf34ae19677cb10f0ce435224f324f", "patch": "@@ -239,4 +239,10 @@ fn main() {\n         3 => core::convert::identity::<u32>(todo!()),\n         _ => 5,\n     };\n+\n+    let _ = match 0 {\n+        0 => cfg!(not_enable),\n+        1 => cfg!(not_enable),\n+        _ => false,\n+    };\n }"}, {"sha": "8fb461bd28667e65f60981eccb6b49ef407a3e87", "filename": "tests/ui/match_same_arms2.stderr", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/tests%2Fui%2Fmatch_same_arms2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/tests%2Fui%2Fmatch_same_arms2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_same_arms2.stderr?ref=1e8d2c59bcdf34ae19677cb10f0ce435224f324f", "patch": "@@ -192,5 +192,20 @@ note: other arm here\n LL |         Some(Bar { x: 0, y: 5, .. }) => 1,\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 12 previous errors\n+error: this match arm has an identical body to another arm\n+  --> $DIR/match_same_arms2.rs:245:9\n+   |\n+LL |         1 => cfg!(not_enable),\n+   |         -^^^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         help: try merging the arm patterns: `1 | 0`\n+   |\n+   = help: or try changing either arm body\n+note: other arm here\n+  --> $DIR/match_same_arms2.rs:244:9\n+   |\n+LL |         0 => cfg!(not_enable),\n+   |         ^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 13 previous errors\n "}, {"sha": "2df87a26d6d150ebda1e88b9630384527a639c05", "filename": "tests/ui/partialeq_to_none.fixed", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/tests%2Fui%2Fpartialeq_to_none.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/tests%2Fui%2Fpartialeq_to_none.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpartialeq_to_none.fixed?ref=1e8d2c59bcdf34ae19677cb10f0ce435224f324f", "patch": "@@ -1,5 +1,6 @@\n //@run-rustfix\n #![warn(clippy::partialeq_to_none)]\n+#![allow(clippy::eq_op)]\n \n struct Foobar;\n "}, {"sha": "df6233b9afd6387ada1f2941cf3450f554a1aee8", "filename": "tests/ui/partialeq_to_none.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/tests%2Fui%2Fpartialeq_to_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/tests%2Fui%2Fpartialeq_to_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpartialeq_to_none.rs?ref=1e8d2c59bcdf34ae19677cb10f0ce435224f324f", "patch": "@@ -1,5 +1,6 @@\n //@run-rustfix\n #![warn(clippy::partialeq_to_none)]\n+#![allow(clippy::eq_op)]\n \n struct Foobar;\n "}, {"sha": "4f84862a22b8f092f8b87eeeaff9fa57beed3191", "filename": "tests/ui/partialeq_to_none.stderr", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/tests%2Fui%2Fpartialeq_to_none.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1e8d2c59bcdf34ae19677cb10f0ce435224f324f/tests%2Fui%2Fpartialeq_to_none.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpartialeq_to_none.stderr?ref=1e8d2c59bcdf34ae19677cb10f0ce435224f324f", "patch": "@@ -1,61 +1,61 @@\n error: binary comparison to literal `Option::None`\n-  --> $DIR/partialeq_to_none.rs:14:8\n+  --> $DIR/partialeq_to_none.rs:15:8\n    |\n LL |     if f != None { \"yay\" } else { \"nay\" }\n    |        ^^^^^^^^^ help: use `Option::is_some()` instead: `f.is_some()`\n    |\n    = note: `-D clippy::partialeq-to-none` implied by `-D warnings`\n \n error: binary comparison to literal `Option::None`\n-  --> $DIR/partialeq_to_none.rs:44:13\n+  --> $DIR/partialeq_to_none.rs:45:13\n    |\n LL |     let _ = x == None;\n    |             ^^^^^^^^^ help: use `Option::is_none()` instead: `x.is_none()`\n \n error: binary comparison to literal `Option::None`\n-  --> $DIR/partialeq_to_none.rs:45:13\n+  --> $DIR/partialeq_to_none.rs:46:13\n    |\n LL |     let _ = x != None;\n    |             ^^^^^^^^^ help: use `Option::is_some()` instead: `x.is_some()`\n \n error: binary comparison to literal `Option::None`\n-  --> $DIR/partialeq_to_none.rs:46:13\n+  --> $DIR/partialeq_to_none.rs:47:13\n    |\n LL |     let _ = None == x;\n    |             ^^^^^^^^^ help: use `Option::is_none()` instead: `x.is_none()`\n \n error: binary comparison to literal `Option::None`\n-  --> $DIR/partialeq_to_none.rs:47:13\n+  --> $DIR/partialeq_to_none.rs:48:13\n    |\n LL |     let _ = None != x;\n    |             ^^^^^^^^^ help: use `Option::is_some()` instead: `x.is_some()`\n \n error: binary comparison to literal `Option::None`\n-  --> $DIR/partialeq_to_none.rs:49:8\n+  --> $DIR/partialeq_to_none.rs:50:8\n    |\n LL |     if foobar() == None {}\n    |        ^^^^^^^^^^^^^^^^ help: use `Option::is_none()` instead: `foobar().is_none()`\n \n error: binary comparison to literal `Option::None`\n-  --> $DIR/partialeq_to_none.rs:51:8\n+  --> $DIR/partialeq_to_none.rs:52:8\n    |\n LL |     if bar().ok() != None {}\n    |        ^^^^^^^^^^^^^^^^^^ help: use `Option::is_some()` instead: `bar().ok().is_some()`\n \n error: binary comparison to literal `Option::None`\n-  --> $DIR/partialeq_to_none.rs:53:13\n+  --> $DIR/partialeq_to_none.rs:54:13\n    |\n LL |     let _ = Some(1 + 2) != None;\n    |             ^^^^^^^^^^^^^^^^^^^ help: use `Option::is_some()` instead: `Some(1 + 2).is_some()`\n \n error: binary comparison to literal `Option::None`\n-  --> $DIR/partialeq_to_none.rs:55:13\n+  --> $DIR/partialeq_to_none.rs:56:13\n    |\n LL |     let _ = { Some(0) } == None;\n    |             ^^^^^^^^^^^^^^^^^^^ help: use `Option::is_none()` instead: `{ Some(0) }.is_none()`\n \n error: binary comparison to literal `Option::None`\n-  --> $DIR/partialeq_to_none.rs:57:13\n+  --> $DIR/partialeq_to_none.rs:58:13\n    |\n LL |       let _ = {\n    |  _____________^\n@@ -77,31 +77,31 @@ LL ~     }.is_some();\n    |\n \n error: binary comparison to literal `Option::None`\n-  --> $DIR/partialeq_to_none.rs:67:13\n+  --> $DIR/partialeq_to_none.rs:68:13\n    |\n LL |     let _ = optref() == &&None;\n    |             ^^^^^^^^^^^^^^^^^^ help: use `Option::is_none()` instead: `optref().is_none()`\n \n error: binary comparison to literal `Option::None`\n-  --> $DIR/partialeq_to_none.rs:68:13\n+  --> $DIR/partialeq_to_none.rs:69:13\n    |\n LL |     let _ = &&None != optref();\n    |             ^^^^^^^^^^^^^^^^^^ help: use `Option::is_some()` instead: `optref().is_some()`\n \n error: binary comparison to literal `Option::None`\n-  --> $DIR/partialeq_to_none.rs:69:13\n+  --> $DIR/partialeq_to_none.rs:70:13\n    |\n LL |     let _ = **optref() == None;\n    |             ^^^^^^^^^^^^^^^^^^ help: use `Option::is_none()` instead: `optref().is_none()`\n \n error: binary comparison to literal `Option::None`\n-  --> $DIR/partialeq_to_none.rs:70:13\n+  --> $DIR/partialeq_to_none.rs:71:13\n    |\n LL |     let _ = &None != *optref();\n    |             ^^^^^^^^^^^^^^^^^^ help: use `Option::is_some()` instead: `optref().is_some()`\n \n error: binary comparison to literal `Option::None`\n-  --> $DIR/partialeq_to_none.rs:73:13\n+  --> $DIR/partialeq_to_none.rs:74:13\n    |\n LL |     let _ = None != *x;\n    |             ^^^^^^^^^^ help: use `Option::is_some()` instead: `(*x).is_some()`"}]}