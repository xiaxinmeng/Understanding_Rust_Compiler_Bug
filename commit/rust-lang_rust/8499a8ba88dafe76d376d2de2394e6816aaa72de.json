{"sha": "8499a8ba88dafe76d376d2de2394e6816aaa72de", "node_id": "C_kwDOAAsO6NoAKDg0OTlhOGJhODhkYWZlNzZkMzc2ZDJkZTIzOTRlNjgxNmFhYTcyZGU", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-03-17T21:55:02Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-03-17T21:55:02Z"}, "message": "Rollup merge of #94309 - eholk:issue-57017, r=tmandry\n\n[generator_interior] Be more precise with scopes of borrowed places\n\nPreviously the generator interior type checking analysis would use the nearest temporary scope as the scope of a borrowed value. This ends up being overly broad for cases such as:\n\n```rust\nfn status(_client_status: &Client) -> i16 {\n    200\n}\n\nfn main() {\n    let client = Client;\n    let g = move || match status(&client) {\n        _status => yield,\n    };\n    assert_send(g);\n}\n```\n\nIn this case, the borrow `&client` could be considered in scope for the entirety of the `match` expression, meaning it would be viewed as live across the `yield`, therefore making the generator not `Send`.\n\nIn most cases, we want to use the enclosing expression as the scope for a borrowed value which will be less than or equal to the nearest temporary scope. This PR changes the analysis to use the enclosing expression as the scope for most borrows, with the exception of borrowed RValues which are true temporary values that should have the temporary scope. There's one further exception where borrows of a copy such as happens in autoref cases also should be ignored despite being RValues.\n\nJoint work with `@nikomatsakis`\n\nFixes #57017\n\nr? `@tmandry`", "tree": {"sha": "770bdd93cabb8734a0411f33da4785fc0a97f4bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/770bdd93cabb8734a0411f33da4785fc0a97f4bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8499a8ba88dafe76d376d2de2394e6816aaa72de", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiM642CRBK7hj4Ov3rIwAA0qMIAE8cj5fvmKXU5ySmQ1e/OSCl\nruYFLw+jZY4WysIed7UHSgkDn0uBCV5MKxySc4K9O9ib6TW5ytOdQoYbZaHgsPtK\npbCfZVzNAJFfFTrsccUlHWxBZTXLtwZYoppJsTLjj8rISql93toYO1YC3LgIjWMD\nDaraCJthOygUbnLbKcPfnwwOa6ChuBJfCMBXGjyIYvuGp6Ag5TaJAqFx2mFiLCy3\nGIbWB3NEFAW82sArwd1ludPFe49myq2YUM9wSRK3IuO5iNJngjWgRZfSp2m1XhGz\nwp/sJVUWIfOlsrOb6k9xlfyji4DFWwMT7b6MH4w60MohNGtwubo/KzuxUfA6BEM=\n=ivyV\n-----END PGP SIGNATURE-----\n", "payload": "tree 770bdd93cabb8734a0411f33da4785fc0a97f4bf\nparent 07121c88ad63ff47649f0b0c533a5baa51371fc1\nparent 2fcd5427345154661f8d512745bdedaf072a55b6\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1647554102 +0100\ncommitter GitHub <noreply@github.com> 1647554102 +0100\n\nRollup merge of #94309 - eholk:issue-57017, r=tmandry\n\n[generator_interior] Be more precise with scopes of borrowed places\n\nPreviously the generator interior type checking analysis would use the nearest temporary scope as the scope of a borrowed value. This ends up being overly broad for cases such as:\n\n```rust\nfn status(_client_status: &Client) -> i16 {\n    200\n}\n\nfn main() {\n    let client = Client;\n    let g = move || match status(&client) {\n        _status => yield,\n    };\n    assert_send(g);\n}\n```\n\nIn this case, the borrow `&client` could be considered in scope for the entirety of the `match` expression, meaning it would be viewed as live across the `yield`, therefore making the generator not `Send`.\n\nIn most cases, we want to use the enclosing expression as the scope for a borrowed value which will be less than or equal to the nearest temporary scope. This PR changes the analysis to use the enclosing expression as the scope for most borrows, with the exception of borrowed RValues which are true temporary values that should have the temporary scope. There's one further exception where borrows of a copy such as happens in autoref cases also should be ignored despite being RValues.\n\nJoint work with `@nikomatsakis`\n\nFixes #57017\n\nr? `@tmandry`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8499a8ba88dafe76d376d2de2394e6816aaa72de", "html_url": "https://github.com/rust-lang/rust/commit/8499a8ba88dafe76d376d2de2394e6816aaa72de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8499a8ba88dafe76d376d2de2394e6816aaa72de/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07121c88ad63ff47649f0b0c533a5baa51371fc1", "url": "https://api.github.com/repos/rust-lang/rust/commits/07121c88ad63ff47649f0b0c533a5baa51371fc1", "html_url": "https://github.com/rust-lang/rust/commit/07121c88ad63ff47649f0b0c533a5baa51371fc1"}, {"sha": "2fcd5427345154661f8d512745bdedaf072a55b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/2fcd5427345154661f8d512745bdedaf072a55b6", "html_url": "https://github.com/rust-lang/rust/commit/2fcd5427345154661f8d512745bdedaf072a55b6"}], "stats": {"total": 157, "additions": 144, "deletions": 13}, "files": [{"sha": "ca5ae20dfcf003533283d0315f2fc5c5d79c8e9a", "filename": "compiler/rustc_typeck/src/check/generator_interior.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8499a8ba88dafe76d376d2de2394e6816aaa72de/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8499a8ba88dafe76d376d2de2394e6816aaa72de/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs?ref=8499a8ba88dafe76d376d2de2394e6816aaa72de", "patch": "@@ -13,7 +13,7 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::hir_id::HirIdSet;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{Arm, Expr, ExprKind, Guard, HirId, Pat, PatKind};\n-use rustc_middle::middle::region::{self, YieldData};\n+use rustc_middle::middle::region::{self, Scope, ScopeData, YieldData};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n@@ -369,7 +369,25 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n \n         self.expr_count += 1;\n \n-        let scope = self.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n+        debug!(\"is_borrowed_temporary: {:?}\", self.drop_ranges.is_borrowed_temporary(expr));\n+\n+        // Typically, the value produced by an expression is consumed by its parent in some way,\n+        // so we only have to check if the parent contains a yield (note that the parent may, for\n+        // example, store the value into a local variable, but then we already consider local\n+        // variables to be live across their scope).\n+        //\n+        // However, in the case of temporary values, we are going to store the value into a\n+        // temporary on the stack that is live for the current temporary scope and then return a\n+        // reference to it. That value may be live across the entire temporary scope.\n+        let scope = if self.drop_ranges.is_borrowed_temporary(expr) {\n+            self.region_scope_tree.temporary_scope(expr.hir_id.local_id)\n+        } else {\n+            debug!(\"parent_node: {:?}\", self.fcx.tcx.hir().find_parent_node(expr.hir_id));\n+            match self.fcx.tcx.hir().find_parent_node(expr.hir_id) {\n+                Some(parent) => Some(Scope { id: parent.local_id, data: ScopeData::Node }),\n+                None => self.region_scope_tree.temporary_scope(expr.hir_id.local_id),\n+            }\n+        };\n \n         // If there are adjustments, then record the final type --\n         // this is the actual value that is being produced."}, {"sha": "4fa7ed82c6a8456891c77c42ff8a224685e8c724", "filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8499a8ba88dafe76d376d2de2394e6816aaa72de/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8499a8ba88dafe76d376d2de2394e6816aaa72de/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges.rs?ref=8499a8ba88dafe76d376d2de2394e6816aaa72de", "patch": "@@ -18,6 +18,7 @@ use crate::check::FnCtxt;\n use hir::def_id::DefId;\n use hir::{Body, HirId, HirIdMap, Node};\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::stable_set::FxHashSet;\n use rustc_hir as hir;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n@@ -41,7 +42,7 @@ pub fn compute_drop_ranges<'a, 'tcx>(\n         let consumed_borrowed_places = find_consumed_and_borrowed(fcx, def_id, body);\n \n         let num_exprs = fcx.tcx.region_scope_tree(def_id).body_expr_count(body.id()).unwrap_or(0);\n-        let mut drop_ranges = build_control_flow_graph(\n+        let (mut drop_ranges, borrowed_temporaries) = build_control_flow_graph(\n             fcx.tcx.hir(),\n             fcx.tcx,\n             &fcx.typeck_results.borrow(),\n@@ -52,11 +53,20 @@ pub fn compute_drop_ranges<'a, 'tcx>(\n \n         drop_ranges.propagate_to_fixpoint();\n \n-        DropRanges { tracked_value_map: drop_ranges.tracked_value_map, nodes: drop_ranges.nodes }\n+        debug!(\"borrowed_temporaries = {borrowed_temporaries:?}\");\n+        DropRanges {\n+            tracked_value_map: drop_ranges.tracked_value_map,\n+            nodes: drop_ranges.nodes,\n+            borrowed_temporaries: Some(borrowed_temporaries),\n+        }\n     } else {\n         // If drop range tracking is not enabled, skip all the analysis and produce an\n         // empty set of DropRanges.\n-        DropRanges { tracked_value_map: FxHashMap::default(), nodes: IndexVec::new() }\n+        DropRanges {\n+            tracked_value_map: FxHashMap::default(),\n+            nodes: IndexVec::new(),\n+            borrowed_temporaries: None,\n+        }\n     }\n }\n \n@@ -161,6 +171,7 @@ impl TryFrom<&PlaceWithHirId<'_>> for TrackedValue {\n pub struct DropRanges {\n     tracked_value_map: FxHashMap<TrackedValue, TrackedValueIndex>,\n     nodes: IndexVec<PostOrderId, NodeInfo>,\n+    borrowed_temporaries: Option<FxHashSet<HirId>>,\n }\n \n impl DropRanges {\n@@ -174,6 +185,10 @@ impl DropRanges {\n             })\n     }\n \n+    pub fn is_borrowed_temporary(&self, expr: &hir::Expr<'_>) -> bool {\n+        if let Some(b) = &self.borrowed_temporaries { b.contains(&expr.hir_id) } else { true }\n+    }\n+\n     /// Returns a reference to the NodeInfo for a node, panicking if it does not exist\n     fn expect_node(&self, id: PostOrderId) -> &NodeInfo {\n         &self.nodes[id]"}, {"sha": "f4dd4cc010d3c82f2a2b96518ba4557af37d5fd9", "filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges/cfg_build.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8499a8ba88dafe76d376d2de2394e6816aaa72de/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8499a8ba88dafe76d376d2de2394e6816aaa72de/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs?ref=8499a8ba88dafe76d376d2de2394e6816aaa72de", "patch": "@@ -6,7 +6,7 @@ use hir::{\n     intravisit::{self, Visitor},\n     Body, Expr, ExprKind, Guard, HirId, LoopIdError,\n };\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::{fx::FxHashMap, stable_set::FxHashSet};\n use rustc_hir as hir;\n use rustc_index::vec::IndexVec;\n use rustc_middle::{\n@@ -27,14 +27,14 @@ pub(super) fn build_control_flow_graph<'tcx>(\n     consumed_borrowed_places: ConsumedAndBorrowedPlaces,\n     body: &'tcx Body<'tcx>,\n     num_exprs: usize,\n-) -> DropRangesBuilder {\n+) -> (DropRangesBuilder, FxHashSet<HirId>) {\n     let mut drop_range_visitor =\n         DropRangeVisitor::new(hir, tcx, typeck_results, consumed_borrowed_places, num_exprs);\n     intravisit::walk_body(&mut drop_range_visitor, body);\n \n     drop_range_visitor.drop_ranges.process_deferred_edges();\n \n-    drop_range_visitor.drop_ranges\n+    (drop_range_visitor.drop_ranges, drop_range_visitor.places.borrowed_temporaries)\n }\n \n /// This struct is used to gather the information for `DropRanges` to determine the regions of the"}, {"sha": "928daba0a7b3937db6eebaee61d693a122571e9f", "filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges/record_consumed_borrow.rs", "status": "modified", "additions": 72, "deletions": 2, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/8499a8ba88dafe76d376d2de2394e6816aaa72de/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8499a8ba88dafe76d376d2de2394e6816aaa72de/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs?ref=8499a8ba88dafe76d376d2de2394e6816aaa72de", "patch": "@@ -6,6 +6,7 @@ use crate::{\n use hir::{def_id::DefId, Body, HirId, HirIdMap};\n use rustc_data_structures::stable_set::FxHashSet;\n use rustc_hir as hir;\n+use rustc_middle::hir::place::{PlaceBase, Projection, ProjectionKind};\n use rustc_middle::ty::{ParamEnv, TyCtxt};\n \n pub(super) fn find_consumed_and_borrowed<'a, 'tcx>(\n@@ -27,8 +28,12 @@ pub(super) struct ConsumedAndBorrowedPlaces {\n     /// Note that this set excludes \"partial drops\" -- for example, a statement like `drop(x.y)` is\n     /// not considered a drop of `x`, although it would be a drop of `x.y`.\n     pub(super) consumed: HirIdMap<FxHashSet<TrackedValue>>,\n+\n     /// A set of hir-ids of values or variables that are borrowed at some point within the body.\n     pub(super) borrowed: FxHashSet<TrackedValue>,\n+\n+    /// A set of hir-ids of values or variables that are borrowed at some point within the body.\n+    pub(super) borrowed_temporaries: FxHashSet<HirId>,\n }\n \n /// Works with ExprUseVisitor to find interesting values for the drop range analysis.\n@@ -49,6 +54,7 @@ impl<'tcx> ExprUseDelegate<'tcx> {\n             places: ConsumedAndBorrowedPlaces {\n                 consumed: <_>::default(),\n                 borrowed: <_>::default(),\n+                borrowed_temporaries: <_>::default(),\n             },\n         }\n     }\n@@ -96,12 +102,76 @@ impl<'tcx> expr_use_visitor::Delegate<'tcx> for ExprUseDelegate<'tcx> {\n         &mut self,\n         place_with_id: &expr_use_visitor::PlaceWithHirId<'tcx>,\n         diag_expr_id: HirId,\n-        _bk: rustc_middle::ty::BorrowKind,\n+        bk: rustc_middle::ty::BorrowKind,\n+    ) {\n+        debug!(\n+            \"borrow: place_with_id = {place_with_id:?}, diag_expr_id={diag_expr_id:?}, \\\n+            borrow_kind={bk:?}\"\n+        );\n+\n+        self.places\n+            .borrowed\n+            .insert(TrackedValue::from_place_with_projections_allowed(place_with_id));\n+\n+        // Ordinarily a value is consumed by it's parent, but in the special case of a\n+        // borrowed RValue, we create a reference that lives as long as the temporary scope\n+        // for that expression (typically, the innermost statement, but sometimes the enclosing\n+        // block). We record this fact here so that later in generator_interior\n+        // we can use the correct scope.\n+        //\n+        // We special case borrows through a dereference (`&*x`, `&mut *x` where `x` is\n+        // some rvalue expression), since these are essentially a copy of a pointer.\n+        // In other words, this borrow does not refer to the\n+        // temporary (`*x`), but to the referent (whatever `x` is a borrow of).\n+        //\n+        // We were considering that we might encounter problems down the line if somehow,\n+        // some part of the compiler were to look at this result and try to use it to\n+        // drive a borrowck-like analysis (this does not currently happen, as of this writing).\n+        // But even this should be fine, because the lifetime of the dereferenced reference\n+        // found in the rvalue is only significant as an intermediate 'link' to the value we\n+        // are producing, and we separately track whether that value is live over a yield.\n+        // Example:\n+        //\n+        // ```notrust\n+        // fn identity<T>(x: &mut T) -> &mut T { x }\n+        // let a: A = ...;\n+        // let y: &'y mut A = &mut *identity(&'a mut a);\n+        //                    ^^^^^^^^^^^^^^^^^^^^^^^^^ the borrow we are talking about\n+        // ```\n+        //\n+        // The expression `*identity(...)` is a deref of an rvalue,\n+        // where the `identity(...)` (the rvalue) produces a return type\n+        // of `&'rv mut A`, where `'a: 'rv`. We then assign this result to\n+        // `'y`, resulting in (transitively) `'a: 'y` (i.e., while `y` is in use,\n+        // `a` will be considered borrowed).  Other parts of the code will ensure\n+        // that if `y` is live over a yield, `&'y mut A` appears in the generator\n+        // state. If `'y` is live, then any sound region analysis must conclude\n+        // that `'a` is also live. So if this causes a bug, blame some other\n+        // part of the code!\n+        let is_deref = place_with_id\n+            .place\n+            .projections\n+            .iter()\n+            .any(|Projection { kind, .. }| *kind == ProjectionKind::Deref);\n+\n+        if let (false, PlaceBase::Rvalue) = (is_deref, place_with_id.place.base) {\n+            self.places.borrowed_temporaries.insert(place_with_id.hir_id);\n+        }\n+    }\n+\n+    fn copy(\n+        &mut self,\n+        place_with_id: &expr_use_visitor::PlaceWithHirId<'tcx>,\n+        _diag_expr_id: HirId,\n     ) {\n-        debug!(\"borrow {:?}; diag_expr_id={:?}\", place_with_id, diag_expr_id);\n+        debug!(\"copy: place_with_id = {place_with_id:?}\");\n+\n         self.places\n             .borrowed\n             .insert(TrackedValue::from_place_with_projections_allowed(place_with_id));\n+\n+        // For copied we treat this mostly like a borrow except that we don't add the place\n+        // to borrowed_temporaries because the copy is consumed.\n     }\n \n     fn mutate("}, {"sha": "b08e08a27d04ec68fae0858c3bef26bf0a09913b", "filename": "compiler/rustc_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8499a8ba88dafe76d376d2de2394e6816aaa72de/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8499a8ba88dafe76d376d2de2394e6816aaa72de/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=8499a8ba88dafe76d376d2de2394e6816aaa72de", "patch": "@@ -47,6 +47,14 @@ pub trait Delegate<'tcx> {\n         bk: ty::BorrowKind,\n     );\n \n+    /// The value found at `place` is being copied.\n+    /// `diag_expr_id` is the id used for diagnostics (see `consume` for more details).\n+    fn copy(&mut self, place_with_id: &PlaceWithHirId<'tcx>, diag_expr_id: hir::HirId) {\n+        // In most cases, copying data from `x` is equivalent to doing `*&x`, so by default\n+        // we treat a copy of `x` as a borrow of `x`.\n+        self.borrow(place_with_id, diag_expr_id, ty::BorrowKind::ImmBorrow)\n+    }\n+\n     /// The path at `assignee_place` is being assigned to.\n     /// `diag_expr_id` is the id used for diagnostics (see `consume` for more details).\n     fn mutate(&mut self, assignee_place: &PlaceWithHirId<'tcx>, diag_expr_id: hir::HirId);\n@@ -836,9 +844,7 @@ fn delegate_consume<'a, 'tcx>(\n \n     match mode {\n         ConsumeMode::Move => delegate.consume(place_with_id, diag_expr_id),\n-        ConsumeMode::Copy => {\n-            delegate.borrow(place_with_id, diag_expr_id, ty::BorrowKind::ImmBorrow)\n-        }\n+        ConsumeMode::Copy => delegate.copy(place_with_id, diag_expr_id),\n     }\n }\n "}, {"sha": "1223a3037abc7e6bb3713fff2b867cd97bbf9ef8", "filename": "src/test/ui/generator/issue-57017.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8499a8ba88dafe76d376d2de2394e6816aaa72de/src%2Ftest%2Fui%2Fgenerator%2Fissue-57017.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8499a8ba88dafe76d376d2de2394e6816aaa72de/src%2Ftest%2Fui%2Fgenerator%2Fissue-57017.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fissue-57017.rs?ref=8499a8ba88dafe76d376d2de2394e6816aaa72de", "patch": "@@ -0,0 +1,22 @@\n+// check-pass\n+// compile-flags: -Zdrop-tracking\n+#![feature(generators, negative_impls)]\n+\n+struct Client;\n+\n+impl !Sync for Client {}\n+\n+fn status(_client_status: &Client) -> i16 {\n+    200\n+}\n+\n+fn assert_send<T: Send>(_thing: T) {}\n+\n+// This is the same bug as issue 57017, but using yield instead of await\n+fn main() {\n+    let client = Client;\n+    let g = move || match status(&client) {\n+        _status => yield,\n+    };\n+    assert_send(g);\n+}"}]}