{"sha": "0fc952372a1010bc567b1c183105e4fd3f395af0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmYzk1MjM3MmExMDEwYmM1NjdiMWMxODMxMDVlNGZkM2YzOTVhZjA=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-11-07T02:41:06Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-11-08T03:29:30Z"}, "message": "rustc: Support irrefutable patterns in function arguments. r=nmatsakis", "tree": {"sha": "4cf44e50cf87c1a151dfc17a543710e7df5218fc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4cf44e50cf87c1a151dfc17a543710e7df5218fc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0fc952372a1010bc567b1c183105e4fd3f395af0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0fc952372a1010bc567b1c183105e4fd3f395af0", "html_url": "https://github.com/rust-lang/rust/commit/0fc952372a1010bc567b1c183105e4fd3f395af0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0fc952372a1010bc567b1c183105e4fd3f395af0/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b223c9c4651ee2f4b8fe2af0136e657a0893caa4", "url": "https://api.github.com/repos/rust-lang/rust/commits/b223c9c4651ee2f4b8fe2af0136e657a0893caa4", "html_url": "https://github.com/rust-lang/rust/commit/b223c9c4651ee2f4b8fe2af0136e657a0893caa4"}], "stats": {"total": 551, "additions": 392, "deletions": 159}, "files": [{"sha": "c7139b169349c622acfaa3fd34a59fb8f2ed6142", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=0fc952372a1010bc567b1c183105e4fd3f395af0", "patch": "@@ -85,7 +85,7 @@ pub mod ct {\n     pub enum Piece { PieceString(~str), PieceConv(Conv), }\n     pub type ErrorFn = fn@(&str) -> ! ;\n \n-    pub fn parse_fmt_string(s: &str, error: ErrorFn) -> ~[Piece] {\n+    pub fn parse_fmt_string(s: &str, err: ErrorFn) -> ~[Piece] {\n         let mut pieces: ~[Piece] = ~[];\n         let lim = str::len(s);\n         let mut buf = ~\"\";\n@@ -103,15 +103,15 @@ pub mod ct {\n             if curr == ~\"%\" {\n                 i += 1;\n                 if i >= lim {\n-                    error(~\"unterminated conversion at end of string\");\n+                    err(~\"unterminated conversion at end of string\");\n                 }\n                 let curr2 = str::slice(s, i, i+1);\n                 if curr2 == ~\"%\" {\n                     buf += curr2;\n                     i += 1;\n                 } else {\n                     buf = flush_buf(move buf, &mut pieces);\n-                    let rs = parse_conversion(s, i, lim, error);\n+                    let rs = parse_conversion(s, i, lim, err);\n                     pieces.push(copy rs.piece);\n                     i = rs.next;\n                 }\n@@ -143,13 +143,13 @@ pub mod ct {\n         }\n     }\n     pub fn parse_conversion(s: &str, i: uint, lim: uint,\n-                            error: ErrorFn) ->\n+                            err: ErrorFn) ->\n        {piece: Piece, next: uint} {\n         let parm = parse_parameter(s, i, lim);\n         let flags = parse_flags(s, parm.next, lim);\n         let width = parse_count(s, flags.next, lim);\n         let prec = parse_precision(s, width.next, lim);\n-        let ty = parse_type(s, prec.next, lim, error);\n+        let ty = parse_type(s, prec.next, lim, err);\n         return {piece:\n                  PieceConv({param: parm.param,\n                              flags: copy flags.flags,\n@@ -239,9 +239,9 @@ pub mod ct {\n                 }\n             } else { {count: CountImplied, next: i} };\n     }\n-    pub fn parse_type(s: &str, i: uint, lim: uint, error: ErrorFn) ->\n+    pub fn parse_type(s: &str, i: uint, lim: uint, err: ErrorFn) ->\n        {ty: Ty, next: uint} {\n-        if i >= lim { error(~\"missing type in conversion\"); }\n+        if i >= lim { err(~\"missing type in conversion\"); }\n         let tstr = str::slice(s, i, i+1u);\n         // FIXME (#2249): Do we really want two signed types here?\n         // How important is it to be printf compatible?\n@@ -268,7 +268,7 @@ pub mod ct {\n                 TyFloat\n             } else if tstr == ~\"?\" {\n                 TyPoly\n-            } else { error(~\"unknown type in conversion: \" + tstr) };\n+            } else { err(~\"unknown type in conversion: \" + tstr) };\n         return {ty: t, next: i + 1u};\n     }\n }"}, {"sha": "11de9ab1a7e122c8c4ac11c101bf52ee8eafba48", "filename": "src/libcore/send_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Flibcore%2Fsend_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Flibcore%2Fsend_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsend_map.rs?ref=0fc952372a1010bc567b1c183105e4fd3f395af0", "patch": "@@ -35,7 +35,7 @@ pub trait SendMap<K:Eq Hash, V: Copy> {\n \n /// Open addressing with linear probing.\n pub mod linear {\n-    const initial_capacity: uint = 32u; // 2^5\n+    const INITIAL_CAPACITY: uint = 32u; // 2^5\n \n     struct Bucket<K:Eq Hash,V> {\n         hash: uint,\n@@ -62,7 +62,7 @@ pub mod linear {\n     }\n \n     pub fn LinearMap<K:Eq Hash,V>() -> LinearMap<K,V> {\n-        linear_map_with_capacity(32)\n+        linear_map_with_capacity(INITIAL_CAPACITY)\n     }\n \n     pub fn linear_map_with_capacity<K:Eq Hash,V>("}, {"sha": "e6fa3f2f9538af52e431533afe449d31c4e99e57", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=0fc952372a1010bc567b1c183105e4fd3f395af0", "patch": "@@ -959,15 +959,15 @@ extern mod llvm {\n     /** Opens an object file. */\n     fn LLVMCreateObjectFile(MemBuf: MemoryBufferRef) -> ObjectFileRef;\n     /** Closes an object file. */\n-    fn LLVMDisposeObjectFile(ObjectFile: ObjectFileRef);\n+    fn LLVMDisposeObjectFile(ObjFile: ObjectFileRef);\n \n     /** Enumerates the sections in an object file. */\n-    fn LLVMGetSections(ObjectFile: ObjectFileRef) -> SectionIteratorRef;\n+    fn LLVMGetSections(ObjFile: ObjectFileRef) -> SectionIteratorRef;\n     /** Destroys a section iterator. */\n     fn LLVMDisposeSectionIterator(SI: SectionIteratorRef);\n     /** Returns true if the section iterator is at the end of the section\n         list: */\n-    fn LLVMIsSectionIteratorAtEnd(ObjectFile: ObjectFileRef,\n+    fn LLVMIsSectionIteratorAtEnd(ObjFile: ObjectFileRef,\n                                   SI: SectionIteratorRef) -> Bool;\n     /** Moves the section iterator to point to the next section. */\n     fn LLVMMoveToNextSection(SI: SectionIteratorRef);\n@@ -1228,9 +1228,9 @@ struct object_file_res {\n     drop { llvm::LLVMDisposeObjectFile(self.ObjectFile); }\n }\n \n-fn object_file_res(ObjectFile: ObjectFileRef) -> object_file_res{\n+fn object_file_res(ObjFile: ObjectFileRef) -> object_file_res {\n     object_file_res {\n-        ObjectFile: ObjectFile\n+        ObjectFile: ObjFile\n     }\n }\n "}, {"sha": "98667a8e041500b029152fbe1c9ee064a793c496", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=0fc952372a1010bc567b1c183105e4fd3f395af0", "patch": "@@ -570,7 +570,20 @@ fn check_loans_in_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n                 visit::fk_anon(*) | visit::fk_fn_block(*) |\n                 visit::fk_method(*) | visit::fk_item_fn(*) |\n                 visit::fk_dtor(*) => {\n-                    self.fn_args = @decl.inputs.map(|i| i.id );\n+                    let mut fn_args = ~[];\n+                    for decl.inputs.each |input| {\n+                        // For the purposes of purity, only consider function-\n+                        // typed bindings in trivial patterns to be function\n+                        // arguments. For example, do not allow `f` and `g` in\n+                        // (f, g): (&fn(), &fn()) to be called.\n+                        match input.pat.node {\n+                            ast::pat_ident(_, _, None) => {\n+                                fn_args.push(input.pat.id);\n+                            }\n+                            _ => {} // Ignore this argument.\n+                        }\n+                    }\n+                    self.fn_args = @move fn_args;\n                 }\n             }\n "}, {"sha": "1c2899fe0be040755ec0366bff6b2b92f96f0b00", "filename": "src/librustc/middle/check_alt.rs", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Flibrustc%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Flibrustc%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_alt.rs?ref=0fc952372a1010bc567b1c183105e4fd3f395af0", "patch": "@@ -15,6 +15,8 @@ fn check_crate(tcx: ty::ctxt, crate: @crate) {\n     visit::visit_crate(*crate, (), visit::mk_vt(@{\n         visit_expr: |a,b,c| check_expr(tcx, a, b, c),\n         visit_local: |a,b,c| check_local(tcx, a, b, c),\n+        visit_fn: |kind, decl, body, sp, id, e, v|\n+            check_fn(tcx, kind, decl, body, sp, id, e, v),\n         .. *visit::default_visitor::<()>()\n     }));\n     tcx.sess.abort_if_errors();\n@@ -372,8 +374,8 @@ fn specialize(tcx: ty::ctxt, r: ~[@pat], ctor_id: ctor, arity: uint,\n             ty::ty_rec(flds) => flds,\n             _ => fail ~\"bad type for pat_rec\"\n         };\n-        let args = vec::map(ty_flds, |ty_f| {\n-            match vec::find(flds, |f| f.ident == ty_f.ident ) {\n+        let args = vec::map(ty_flds, |ty_fld| {\n+            match vec::find(flds, |f| f.ident == ty_fld.ident ) {\n               Some(f) => f.pat,\n               _ => wild()\n             }\n@@ -386,8 +388,8 @@ fn specialize(tcx: ty::ctxt, r: ~[@pat], ctor_id: ctor, arity: uint,\n             def_variant(_, variant_id) => {\n                 if variant(variant_id) == ctor_id {\n                     // XXX: Is this right? --pcw\n-                    let args = flds.map(|ty_f| {\n-                        match vec::find(flds, |f| f.ident == ty_f.ident) {\n+                    let args = flds.map(|ty_field| {\n+                        match vec::find(flds, |f| f.ident == ty_field.ident) {\n                             Some(f) => f.pat,\n                             _ => wild()\n                         }\n@@ -465,6 +467,23 @@ fn check_local(tcx: ty::ctxt, loc: @local, &&s: (), v: visit::vt<()>) {\n     }\n }\n \n+fn check_fn(tcx: ty::ctxt,\n+            kind: visit::fn_kind,\n+            decl: fn_decl,\n+            body: blk,\n+            sp: span,\n+            id: node_id,\n+            &&s: (),\n+            v: visit::vt<()>) {\n+    visit::visit_fn(kind, decl, body, sp, id, s, v);\n+    for decl.inputs.each |input| {\n+        if is_refutable(tcx, input.pat) {\n+            tcx.sess.span_err(input.pat.span,\n+                              ~\"refutable pattern in function argument\");\n+        }\n+    }\n+}\n+\n fn is_refutable(tcx: ty::ctxt, pat: &pat) -> bool {\n     match tcx.def_map.find(pat.id) {\n       Some(def_variant(enum_id, _)) => {"}, {"sha": "ec7c2ffc6f1da789bac90f45f91e759a9defed42", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=0fc952372a1010bc567b1c183105e4fd3f395af0", "patch": "@@ -414,9 +414,13 @@ fn visit_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n     debug!(\"creating fn_maps: %x\", ptr::addr_of(&(*fn_maps)) as uint);\n \n     for decl.inputs.each |arg| {\n-        debug!(\"adding argument %d\", arg.id);\n         let mode = ty::resolved_mode(self.tcx, arg.mode);\n-        (*fn_maps).add_variable(Arg(arg.id, arg.ident, mode));\n+        do pat_util::pat_bindings(self.tcx.def_map, arg.pat)\n+                |_bm, arg_id, _x, path| {\n+            debug!(\"adding argument %d\", arg_id);\n+            let ident = ast_util::path_to_ident(path);\n+            (*fn_maps).add_variable(Arg(arg_id, ident, mode));\n+        }\n     };\n \n     // gather up the various local variables, significant expressions,\n@@ -447,7 +451,7 @@ fn visit_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n     });\n     check_vt.visit_block(body, lsets, check_vt);\n     lsets.check_ret(id, sp, fk, entry_ln);\n-    lsets.warn_about_unused_args(sp, decl, entry_ln);\n+    lsets.warn_about_unused_args(decl, entry_ln);\n }\n \n fn visit_local(local: @local, &&self: @IrMaps, vt: vt<@IrMaps>) {\n@@ -937,8 +941,11 @@ impl Liveness {\n                 // the end.  This will prevent us from moving out of\n                 // such variables but also prevent us from registering\n                 // last uses and so forth.\n-                let var = self.variable(arg.id, blk.span);\n-                self.acc(self.s.exit_ln, var, ACC_READ);\n+                do pat_util::pat_bindings(self.tcx.def_map, arg.pat)\n+                        |_bm, arg_id, _sp, _path| {\n+                    let var = self.variable(arg_id, blk.span);\n+                    self.acc(self.s.exit_ln, var, ACC_READ);\n+                }\n               }\n               by_move | by_copy => {\n                 // These are owned modes.  If we don't use the\n@@ -1791,10 +1798,13 @@ impl @Liveness {\n         if name[0] == ('_' as u8) {None} else {Some(name)}\n     }\n \n-    fn warn_about_unused_args(sp: span, decl: fn_decl, entry_ln: LiveNode) {\n+    fn warn_about_unused_args(decl: fn_decl, entry_ln: LiveNode) {\n         for decl.inputs.each |arg| {\n-            let var = self.variable(arg.id, arg.ty.span);\n-            self.warn_about_unused(sp, entry_ln, var);\n+            do pat_util::pat_bindings(self.tcx.def_map, arg.pat)\n+                    |_bm, p_id, sp, _n| {\n+                let var = self.variable(p_id, sp);\n+                self.warn_about_unused(sp, entry_ln, var);\n+            }\n         }\n     }\n "}, {"sha": "66b75d5f1cd745befef0317deaa7948c5c949cd3", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 38, "deletions": 12, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=0fc952372a1010bc567b1c183105e4fd3f395af0", "patch": "@@ -28,8 +28,8 @@ use syntax::ast::{foreign_item, foreign_item_const, foreign_item_fn, ge};\n use syntax::ast::{gt, ident, impure_fn, inherited, item, item_class};\n use syntax::ast::{item_const, item_enum, item_fn, item_foreign_mod};\n use syntax::ast::{item_impl, item_mac, item_mod, item_trait, item_ty, le};\n-use syntax::ast::{local, local_crate, lt, method, module_ns, mul, ne, neg};\n-use syntax::ast::{node_id, pat, pat_enum, pat_ident, path, prim_ty};\n+use syntax::ast::{local, local_crate, lt, method, mode, module_ns, mul, ne};\n+use syntax::ast::{neg, node_id, pat, pat_enum, pat_ident, path, prim_ty};\n use syntax::ast::{pat_box, pat_lit, pat_range, pat_rec, pat_struct};\n use syntax::ast::{pat_tup, pat_uniq, pat_wild, private, provided, public};\n use syntax::ast::{required, rem, self_ty_, shl, shr, stmt_decl};\n@@ -103,12 +103,32 @@ struct Export2 {\n \n enum PatternBindingMode {\n     RefutableMode,\n-    IrrefutableMode\n+    LocalIrrefutableMode,\n+    ArgumentIrrefutableMode(mode)\n }\n \n impl PatternBindingMode : cmp::Eq {\n     pure fn eq(other: &PatternBindingMode) -> bool {\n-        (self as uint) == ((*other) as uint)\n+        match self {\n+            RefutableMode => {\n+                match *other {\n+                    RefutableMode => true,\n+                    _ => false\n+                }\n+            }\n+            LocalIrrefutableMode => {\n+                match *other {\n+                    LocalIrrefutableMode => true,\n+                    _ => false\n+                }\n+            }\n+            ArgumentIrrefutableMode(mode_a) => {\n+                match *other {\n+                    ArgumentIrrefutableMode(mode_b) => mode_a == mode_b,\n+                    _ => false\n+                }\n+            }\n+        }\n     }\n     pure fn ne(other: &PatternBindingMode) -> bool { !self.eq(other) }\n }\n@@ -3770,15 +3790,17 @@ impl Resolver {\n                 }\n                 Some(declaration) => {\n                     for declaration.inputs.each |argument| {\n-                        let name = argument.ident;\n-                        let def_like = dl_def(def_arg(argument.id,\n-                                                      argument.mode));\n-                        (*function_value_rib).bindings.insert(name, def_like);\n+                        let binding_mode =\n+                            ArgumentIrrefutableMode(argument.mode);\n+                        self.resolve_pattern(argument.pat,\n+                                             binding_mode,\n+                                             Immutable,\n+                                             None,\n+                                             visitor);\n \n                         self.resolve_type(argument.ty, visitor);\n \n-                        debug!(\"(resolving function) recorded argument `%s`\",\n-                               self.session.str_of(name));\n+                        debug!(\"(resolving function) recorded argument\");\n                     }\n \n                     self.resolve_type(declaration.output, visitor);\n@@ -4013,7 +4035,7 @@ impl Resolver {\n         }\n \n         // Resolve the pattern.\n-        self.resolve_pattern(local.node.pat, IrrefutableMode, mutability,\n+        self.resolve_pattern(local.node.pat, LocalIrrefutableMode, mutability,\n                              None, visitor);\n     }\n \n@@ -4249,10 +4271,14 @@ impl Resolver {\n \n                                     def_binding(pattern.id, binding_mode)\n                                 }\n-                                IrrefutableMode => {\n+                                LocalIrrefutableMode => {\n                                     // But for locals, we use `def_local`.\n                                     def_local(pattern.id, is_mutable)\n                                 }\n+                                ArgumentIrrefutableMode(argument_mode) => {\n+                                    // And for function arguments, `def_arg`.\n+                                    def_arg(pattern.id, argument_mode)\n+                                }\n                             };\n \n                             // Record the definition so that later passes"}, {"sha": "d3a69a889478b357b41575c2a936bc6c6df998f4", "filename": "src/librustc/middle/trans/alt.rs", "status": "modified", "additions": 63, "deletions": 15, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Flibrustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Flibrustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Falt.rs?ref=0fc952372a1010bc567b1c183105e4fd3f395af0", "patch": "@@ -1410,18 +1410,29 @@ fn trans_alt_inner(scope_cx: block,\n     return controlflow::join_blocks(scope_cx, dvec::unwrap(move arm_cxs));\n \n     fn mk_fail(bcx: block, sp: span, msg: ~str,\n-               done: @mut Option<BasicBlockRef>) -> BasicBlockRef {\n-        match *done { Some(bb) => return bb, _ => () }\n+               finished: @mut Option<BasicBlockRef>) -> BasicBlockRef {\n+        match *finished { Some(bb) => return bb, _ => () }\n         let fail_cx = sub_block(bcx, ~\"case_fallthrough\");\n         controlflow::trans_fail(fail_cx, Some(sp), msg);\n-        *done = Some(fail_cx.llbb);\n+        *finished = Some(fail_cx.llbb);\n         return fail_cx.llbb;\n     }\n }\n \n+enum IrrefutablePatternBindingMode {\n+    // Stores the association between node ID and LLVM value in `lllocals`.\n+    BindLocal,\n+    // Stores the association between node ID and LLVM value in `llargs`.\n+    BindArgument\n+}\n+\n // Not alt-related, but similar to the pattern-munging code above\n-fn bind_irrefutable_pat(bcx: block, pat: @ast::pat, val: ValueRef,\n-                        make_copy: bool) -> block {\n+fn bind_irrefutable_pat(bcx: block,\n+                        pat: @ast::pat,\n+                        val: ValueRef,\n+                        make_copy: bool,\n+                        binding_mode: IrrefutablePatternBindingMode)\n+                     -> block {\n     let _icx = bcx.insn_ctxt(\"alt::bind_irrefutable_pat\");\n     let ccx = bcx.fcx.ccx;\n     let mut bcx = bcx;\n@@ -1439,14 +1450,31 @@ fn bind_irrefutable_pat(bcx: block, pat: @ast::pat, val: ValueRef,\n                                    mode: ByRef, source: FromRvalue};\n                 let scratch = scratch_datum(bcx, binding_ty, false);\n                 datum.copy_to_datum(bcx, INIT, scratch);\n-                bcx.fcx.lllocals.insert(pat.id, local_mem(scratch.val));\n+                match binding_mode {\n+                    BindLocal => {\n+                        bcx.fcx.lllocals.insert(pat.id,\n+                                                local_mem(scratch.val));\n+                    }\n+                    BindArgument => {\n+                        bcx.fcx.llargs.insert(pat.id,\n+                                              local_mem(scratch.val));\n+                    }\n+                }\n                 add_clean(bcx, scratch.val, binding_ty);\n             } else {\n-                bcx.fcx.lllocals.insert(pat.id, local_mem(val));\n+                match binding_mode {\n+                    BindLocal => {\n+                        bcx.fcx.lllocals.insert(pat.id, local_mem(val));\n+                    }\n+                    BindArgument => {\n+                        bcx.fcx.llargs.insert(pat.id, local_mem(val));\n+                    }\n+                }\n             }\n \n             for inner.each |inner_pat| {\n-                bcx = bind_irrefutable_pat(bcx, *inner_pat, val, true);\n+                bcx = bind_irrefutable_pat(\n+                    bcx, *inner_pat, val, true, binding_mode);\n             }\n         }\n         ast::pat_enum(_, sub_pats) => {\n@@ -1460,7 +1488,8 @@ fn bind_irrefutable_pat(bcx: block, pat: @ast::pat, val: ValueRef,\n                             bcx = bind_irrefutable_pat(bcx,\n                                                        sub_pat[i],\n                                                        *argval,\n-                                                       make_copy);\n+                                                       make_copy,\n+                                                       binding_mode);\n                         }\n                     }\n                 }\n@@ -1473,8 +1502,11 @@ fn bind_irrefutable_pat(bcx: block, pat: @ast::pat, val: ValueRef,\n                             // This is the tuple variant case.\n                             for vec::eachi(elems) |i, elem| {\n                                 let fldptr = GEPi(bcx, val, struct_field(i));\n-                                bcx = bind_irrefutable_pat(bcx, *elem, fldptr,\n-                                                           make_copy);\n+                                bcx = bind_irrefutable_pat(bcx,\n+                                                           *elem,\n+                                                           fldptr,\n+                                                           make_copy,\n+                                                           binding_mode);\n                             }\n                         }\n                     }\n@@ -1491,24 +1523,40 @@ fn bind_irrefutable_pat(bcx: block, pat: @ast::pat, val: ValueRef,\n                 for vec::each(fields) |f| {\n                     let ix = ty::field_idx_strict(tcx, f.ident, field_tys);\n                     let fldptr = GEPi(bcx, val, struct_field(ix));\n-                    bcx = bind_irrefutable_pat(bcx, f.pat, fldptr, make_copy);\n+                    bcx = bind_irrefutable_pat(bcx,\n+                                               f.pat,\n+                                               fldptr,\n+                                               make_copy,\n+                                               binding_mode);\n                 }\n             }\n         }\n         ast::pat_tup(elems) => {\n             for vec::eachi(elems) |i, elem| {\n                 let fldptr = GEPi(bcx, val, [0u, i]);\n-                bcx = bind_irrefutable_pat(bcx, *elem, fldptr, make_copy);\n+                bcx = bind_irrefutable_pat(bcx,\n+                                           *elem,\n+                                           fldptr,\n+                                           make_copy,\n+                                           binding_mode);\n             }\n         }\n         ast::pat_box(inner) | ast::pat_uniq(inner) => {\n             let llbox = Load(bcx, val);\n             let unboxed = GEPi(bcx, llbox, [0u, abi::box_field_body]);\n-            bcx = bind_irrefutable_pat(bcx, inner, unboxed, true);\n+            bcx = bind_irrefutable_pat(bcx,\n+                                       inner,\n+                                       unboxed,\n+                                       true,\n+                                       binding_mode);\n         }\n         ast::pat_region(inner) => {\n             let loaded_val = Load(bcx, val);\n-            bcx = bind_irrefutable_pat(bcx, inner, loaded_val, true);\n+            bcx = bind_irrefutable_pat(bcx,\n+                                       inner,\n+                                       loaded_val,\n+                                       true,\n+                                       binding_mode);\n         }\n         ast::pat_wild | ast::pat_lit(_) | ast::pat_range(_, _) => ()\n     }"}, {"sha": "7a163afafccdd3f0efd288f1d7fb76e7f18cfc9b", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=0fc952372a1010bc567b1c183105e4fd3f395af0", "patch": "@@ -991,7 +991,11 @@ fn init_local(bcx: block, local: @ast::local) -> block {\n            bcx.to_str());\n     add_clean(bcx, llptr, ty);\n \n-    return alt::bind_irrefutable_pat(bcx, local.node.pat, llptr, false);\n+    return alt::bind_irrefutable_pat(bcx,\n+                                     local.node.pat,\n+                                     llptr,\n+                                     false,\n+                                     alt::BindLocal);\n }\n \n fn trans_stmt(cx: block, s: ast::stmt) -> block {\n@@ -1529,6 +1533,12 @@ fn copy_args_to_allocas(fcx: fn_ctxt,\n             }\n         }\n \n+        bcx = alt::bind_irrefutable_pat(bcx,\n+                                        args[arg_n].pat,\n+                                        llarg,\n+                                        false,\n+                                        alt::BindArgument);\n+\n         fcx.llargs.insert(arg_id, local_mem(llarg));\n \n         if fcx.ccx.sess.opts.extra_debuginfo {\n@@ -1658,7 +1668,9 @@ fn trans_enum_variant(ccx: @crate_ctxt,\n     let fn_args = vec::map(args, |varg|\n         {mode: ast::expl(ast::by_copy),\n          ty: varg.ty,\n-         ident: special_idents::arg,\n+         pat: ast_util::ident_to_pat(ccx.tcx.sess.next_node_id(),\n+                                     ast_util::dummy_sp(),\n+                                     special_idents::arg),\n          id: varg.id});\n     let fcx = new_fn_ctxt_w_id(ccx, ~[], llfndecl, variant.node.id, None,\n                                param_substs, None);\n@@ -1714,7 +1726,9 @@ fn trans_tuple_struct(ccx: @crate_ctxt,\n         {\n             mode: ast::expl(ast::by_copy),\n             ty: field.node.ty,\n-            ident: special_idents::arg,\n+            pat: ast_util::ident_to_pat(ccx.tcx.sess.next_node_id(),\n+                                        ast_util::dummy_sp(),\n+                                        special_idents::arg),\n             id: field.node.id\n         }\n     };"}, {"sha": "8badf672e817475e9882a4e3abb7f065fe39770e", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=0fc952372a1010bc567b1c183105e4fd3f395af0", "patch": "@@ -320,9 +320,9 @@ impl cleantype : cmp::Eq {\n type cleanup_path = {target: Option<BasicBlockRef>,\n                      dest: BasicBlockRef};\n \n-fn scope_clean_changed(info: scope_info) {\n-    if info.cleanup_paths.len() > 0u { info.cleanup_paths = ~[]; }\n-    info.landing_pad = None;\n+fn scope_clean_changed(scope_info: scope_info) {\n+    if scope_info.cleanup_paths.len() > 0u { scope_info.cleanup_paths = ~[]; }\n+    scope_info.landing_pad = None;\n }\n \n fn cleanup_type(cx: ty::ctxt, ty: ty::t) -> cleantype {\n@@ -361,11 +361,11 @@ fn add_clean(bcx: block, val: ValueRef, t: ty::t) {\n            ty_to_str(bcx.ccx().tcx, t));\n     let {root, rooted} = root_for_cleanup(bcx, val, t);\n     let cleanup_type = cleanup_type(bcx.tcx(), t);\n-    do in_scope_cx(bcx) |info| {\n-        info.cleanups.push(\n+    do in_scope_cx(bcx) |scope_info| {\n+        scope_info.cleanups.push(\n             clean(|a| glue::drop_ty_root(a, root, rooted, t),\n                   cleanup_type));\n-        scope_clean_changed(info);\n+        scope_clean_changed(scope_info);\n     }\n }\n \n@@ -375,11 +375,11 @@ fn add_clean_temp_immediate(cx: block, val: ValueRef, ty: ty::t) {\n            cx.to_str(), val_str(cx.ccx().tn, val),\n            ty_to_str(cx.ccx().tcx, ty));\n     let cleanup_type = cleanup_type(cx.tcx(), ty);\n-    do in_scope_cx(cx) |info| {\n-        info.cleanups.push(\n+    do in_scope_cx(cx) |scope_info| {\n+        scope_info.cleanups.push(\n             clean_temp(val, |a| glue::drop_ty_immediate(a, val, ty),\n                        cleanup_type));\n-        scope_clean_changed(info);\n+        scope_clean_changed(scope_info);\n     }\n }\n fn add_clean_temp_mem(bcx: block, val: ValueRef, t: ty::t) {\n@@ -389,22 +389,22 @@ fn add_clean_temp_mem(bcx: block, val: ValueRef, t: ty::t) {\n            ty_to_str(bcx.ccx().tcx, t));\n     let {root, rooted} = root_for_cleanup(bcx, val, t);\n     let cleanup_type = cleanup_type(bcx.tcx(), t);\n-    do in_scope_cx(bcx) |info| {\n-        info.cleanups.push(\n+    do in_scope_cx(bcx) |scope_info| {\n+        scope_info.cleanups.push(\n             clean_temp(val, |a| glue::drop_ty_root(a, root, rooted, t),\n                        cleanup_type));\n-        scope_clean_changed(info);\n+        scope_clean_changed(scope_info);\n     }\n }\n fn add_clean_free(cx: block, ptr: ValueRef, heap: heap) {\n     let free_fn = match heap {\n       heap_shared => |a| glue::trans_free(a, ptr),\n       heap_exchange => |a| glue::trans_unique_free(a, ptr)\n     };\n-    do in_scope_cx(cx) |info| {\n-        info.cleanups.push(clean_temp(ptr, free_fn,\n+    do in_scope_cx(cx) |scope_info| {\n+        scope_info.cleanups.push(clean_temp(ptr, free_fn,\n                                       normal_exit_and_unwind));\n-        scope_clean_changed(info);\n+        scope_clean_changed(scope_info);\n     }\n }\n \n@@ -413,20 +413,20 @@ fn add_clean_free(cx: block, ptr: ValueRef, heap: heap) {\n // this will be more involved. For now, we simply zero out the local, and the\n // drop glue checks whether it is zero.\n fn revoke_clean(cx: block, val: ValueRef) {\n-    do in_scope_cx(cx) |info| {\n+    do in_scope_cx(cx) |scope_info| {\n         let cleanup_pos = vec::position(\n-            info.cleanups,\n+            scope_info.cleanups,\n             |cu| match *cu {\n                 clean_temp(v, _, _) if v == val => true,\n                 _ => false\n             });\n         for cleanup_pos.each |i| {\n-            info.cleanups =\n-                vec::append(vec::slice(info.cleanups, 0u, *i),\n-                            vec::view(info.cleanups,\n+            scope_info.cleanups =\n+                vec::append(vec::slice(scope_info.cleanups, 0u, *i),\n+                            vec::view(scope_info.cleanups,\n                                       *i + 1u,\n-                                      info.cleanups.len()));\n-            scope_clean_changed(info);\n+                                      scope_info.cleanups.len()));\n+            scope_clean_changed(scope_info);\n         }\n     }\n }"}, {"sha": "fd18aaaf58ec6de87bf134da1df7d5e9441c9bc3", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 27, "deletions": 13, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=0fc952372a1010bc567b1c183105e4fd3f395af0", "patch": "@@ -664,13 +664,13 @@ fn create_local_var(bcx: block, local: @ast::local)\n }\n \n fn create_arg(bcx: block, arg: ast::arg, sp: span)\n-    -> @metadata<argument_md> unsafe {\n+    -> Option<@metadata<argument_md>> unsafe {\n     let fcx = bcx.fcx, cx = fcx.ccx;\n     let cache = get_cache(cx);\n     let tg = ArgVariableTag;\n     match cached_metadata::<@metadata<argument_md>>(\n         cache, ArgVariableTag, |md| md.data.id == arg.id) {\n-      option::Some(md) => return md,\n+      option::Some(md) => return Some(md),\n       option::None => ()\n     }\n \n@@ -680,18 +680,32 @@ fn create_arg(bcx: block, arg: ast::arg, sp: span)\n     let tymd = create_ty(cx, ty, arg.ty);\n     let filemd = create_file(cx, loc.file.name);\n     let context = create_function(bcx.fcx);\n-    let mdnode = create_var(tg, context.node, cx.sess.str_of(arg.ident),\n-                            filemd.node, loc.line as int, tymd.node);\n-    let mdval = @{node: mdnode, data: {id: arg.id}};\n-    update_cache(cache, tg, argument_metadata(mdval));\n \n-    let llptr = match fcx.llargs.get(arg.id) {\n-      local_mem(v) | local_imm(v) => v,\n-    };\n-    let declargs = ~[llmdnode(~[llptr]), mdnode];\n-    trans::build::Call(bcx, cx.intrinsics.get(~\"llvm.dbg.declare\"),\n-                       declargs);\n-    return mdval;\n+    match arg.pat.node {\n+        ast::pat_ident(_, path, _) => {\n+            // XXX: This is wrong; it should work for multiple bindings.\n+            let mdnode = create_var(tg,\n+                                    context.node,\n+                                    cx.sess.str_of(path.idents.last()),\n+                                    filemd.node,\n+                                    loc.line as int,\n+                                    tymd.node);\n+\n+            let mdval = @{node: mdnode, data: {id: arg.id}};\n+            update_cache(cache, tg, argument_metadata(mdval));\n+\n+            let llptr = match fcx.llargs.get(arg.id) {\n+              local_mem(v) | local_imm(v) => v,\n+            };\n+            let declargs = ~[llmdnode(~[llptr]), mdnode];\n+            trans::build::Call(bcx, cx.intrinsics.get(~\"llvm.dbg.declare\"),\n+                               declargs);\n+            return Some(mdval);\n+        }\n+        _ => {\n+            return None;\n+        }\n+    }\n }\n \n fn update_source_pos(cx: block, s: span) {"}, {"sha": "e2749db74aa6112cb756d9269c663cadae22a5c1", "filename": "src/librustc/middle/trans/deriving.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fderiving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fderiving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fderiving.rs?ref=0fc952372a1010bc567b1c183105e4fd3f395af0", "patch": "@@ -261,9 +261,9 @@ fn call_substructure_method(bcx: block,\n                                                         vtable_result);\n     let llfn = fn_data.llfn;\n \n-    let cb: &fn(block) -> Callee = |block| {\n+    let cb: &fn(block) -> Callee = |bloc| {\n         Callee {\n-            bcx: block,\n+            bcx: bloc,\n             data: Method(MethodData {\n                 llfn: llfn,\n                 llself: llselfval,"}, {"sha": "52f05eb44de0115430619c1582ec1d110016e17a", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=0fc952372a1010bc567b1c183105e4fd3f395af0", "patch": "@@ -2532,18 +2532,19 @@ fn type_param(ty: t) -> Option<uint> {\n \n // Returns the type and mutability of *t.\n //\n-// The parameter `expl` indicates if this is an *explicit* dereference.  Some\n-// types---notably unsafe ptrs---can only be dereferenced explicitly.\n-fn deref(cx: ctxt, t: t, expl: bool) -> Option<mt> {\n-    deref_sty(cx, &get(t).sty, expl)\n+// The parameter `explicit` indicates if this is an *explicit* dereference.\n+// Some types---notably unsafe ptrs---can only be dereferenced explicitly.\n+fn deref(cx: ctxt, t: t, explicit: bool) -> Option<mt> {\n+    deref_sty(cx, &get(t).sty, explicit)\n }\n-fn deref_sty(cx: ctxt, sty: &sty, expl: bool) -> Option<mt> {\n+\n+fn deref_sty(cx: ctxt, sty: &sty, explicit: bool) -> Option<mt> {\n     match *sty {\n       ty_rptr(_, mt) | ty_box(mt) | ty_uniq(mt) => {\n         Some(mt)\n       }\n \n-      ty_ptr(mt) if expl => {\n+      ty_ptr(mt) if explicit => {\n         Some(mt)\n       }\n \n@@ -3443,7 +3444,7 @@ fn provided_trait_methods(cx: ctxt, id: ast::def_id) -> ~[ast::ident] {\n                                   id))\n         }\n     } else {\n-        csearch::get_provided_trait_methods(cx, id).map(|info| info.ty.ident)\n+        csearch::get_provided_trait_methods(cx, id).map(|ifo| ifo.ty.ident)\n     }\n }\n "}, {"sha": "d9ab7306ac3aa0de2dafdb2d141dbc9d25cc8e75", "filename": "src/librustc/middle/typeck/check.rs", "status": "modified", "additions": 27, "deletions": 15, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=0fc952372a1010bc567b1c183105e4fd3f395af0", "patch": "@@ -267,7 +267,7 @@ fn check_fn(ccx: @crate_ctxt,\n         } else { None };\n \n         @fn_ctxt {\n-            self_impl_def_id: self_info.map(|info| info.def_id),\n+            self_impl_def_id: self_info.map(|self_info| self_info.def_id),\n             ret_ty: ret_ty,\n             indirect_ret_ty: indirect_ret_ty,\n             purity: purity,\n@@ -280,16 +280,16 @@ fn check_fn(ccx: @crate_ctxt,\n \n     // Update the self_info to contain an accurate self type (taking\n     // into account explicit self).\n-    let self_info = do self_info.chain_ref |info| {\n+    let self_info = do self_info.chain_ref |self_info| {\n         // If the self type is sty_static, we don't have a self ty.\n-        if info.explicit_self.node == ast::sty_static {\n+        if self_info.explicit_self.node == ast::sty_static {\n             None\n         } else  {\n             let self_region = fcx.in_scope_regions.find(ty::br_self);\n             let ty = method::transform_self_type_for_method(\n                 fcx.tcx(), self_region,\n-                info.self_ty, info.explicit_self.node);\n-            Some({self_ty: ty,.. *info})\n+                self_info.self_ty, self_info.explicit_self.node);\n+            Some({self_ty: ty,.. *self_info})\n         }\n     };\n \n@@ -306,8 +306,8 @@ fn check_fn(ccx: @crate_ctxt,\n       None => ()\n     }\n \n-    for self_info.each |info| {\n-        fcx.write_ty(info.self_id, info.self_ty);\n+    for self_info.each |self_info| {\n+        fcx.write_ty(self_info.self_id, self_info.self_ty);\n     }\n     for vec::each2(decl.inputs, arg_tys) |input, arg| {\n         fcx.write_ty(input.id, *arg);\n@@ -344,19 +344,31 @@ fn check_fn(ccx: @crate_ctxt,\n         };\n \n         // Add the self parameter\n-        for self_info.each |info| {\n-            assign(info.explicit_self.span,\n-                   info.self_id, Some(info.self_ty));\n+        for self_info.each |self_info| {\n+            assign(self_info.explicit_self.span,\n+                   self_info.self_id,\n+                   Some(self_info.self_ty));\n             debug!(\"self is assigned to %s\",\n-                   fcx.inh.locals.get(info.self_id).to_str());\n+                   fcx.inh.locals.get(self_info.self_id).to_str());\n         }\n \n         // Add formal parameters.\n         for vec::each2(arg_tys, decl.inputs) |arg_ty, input| {\n-            assign(input.ty.span, input.id, Some(*arg_ty));\n-            debug!(\"Argument %s is assigned to %s\",\n-                   tcx.sess.str_of(input.ident),\n-                   fcx.inh.locals.get(input.id).to_str());\n+            // Create type variables for each argument.\n+            do pat_util::pat_bindings(tcx.def_map, input.pat)\n+                    |_bm, pat_id, _sp, _path| {\n+                assign(input.ty.span, pat_id, None);\n+            }\n+\n+            // Check the pattern.\n+            let region = fcx.block_region();\n+            let pcx = {\n+                fcx: fcx,\n+                map: pat_id_map(tcx.def_map, input.pat),\n+                alt_region: region,\n+                block_region: region,\n+            };\n+            alt::check_pat(pcx, input.pat, *arg_ty);\n         }\n \n         // Add explicitly-declared locals."}, {"sha": "d7bee357b66bde300a4ed91cc7bb46259649cf4e", "filename": "src/librustc/middle/typeck/check/alt.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs?ref=0fc952372a1010bc567b1c183105e4fd3f395af0", "patch": "@@ -428,6 +428,9 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n             demand::eqtype(fcx, pat.span, ct, typ);\n         }\n         fcx.write_ty(pat.id, typ);\n+\n+        debug!(\"(checking alt) writing type for pat id %d\", pat.id);\n+\n         match sub {\n           Some(p) => check_pat(pcx, p, expected),\n           _ => ()"}, {"sha": "8000d2f733163f514146a274fba8ba6a8d351d39", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=0fc952372a1010bc567b1c183105e4fd3f395af0", "patch": "@@ -234,7 +234,10 @@ fn resolve_type_vars_in_fn(fcx: @fn_ctxt,\n                                    self_info.self_id);\n     }\n     for decl.inputs.each |arg| {\n-        resolve_type_vars_for_node(wbcx, arg.ty.span, arg.id);\n+        do pat_util::pat_bindings(fcx.tcx().def_map, arg.pat)\n+                |_bm, pat_id, span, _path| {\n+            resolve_type_vars_for_node(wbcx, span, pat_id);\n+        }\n     }\n     return wbcx.success;\n }"}, {"sha": "5ad3b27e619ed964cd0c3cc0b68a06b8919918bf", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=0fc952372a1010bc567b1c183105e4fd3f395af0", "patch": "@@ -856,8 +856,8 @@ impl CoherenceChecker {\n \n         debug!(\"(adding default methods for trait) processing trait\");\n \n-        for csearch::get_provided_trait_methods(tcx,\n-                                                trait_def_id).each |info| {\n+        for csearch::get_provided_trait_methods(tcx, trait_def_id).each\n+                                                |trait_method_info| {\n             debug!(\"(adding default methods for trait) found default method\");\n \n             // Create a new def ID for this provided method.\n@@ -868,11 +868,11 @@ impl CoherenceChecker {\n                 @ProvidedMethodInfo {\n                     method_info: @{\n                         did: new_did,\n-                        n_tps: info.ty.tps.len(),\n-                        ident: info.ty.ident,\n-                        self_type: info.ty.self_ty\n+                        n_tps: trait_method_info.ty.tps.len(),\n+                        ident: trait_method_info.ty.ident,\n+                        self_type: trait_method_info.ty.self_ty\n                     },\n-                    trait_method_def_id: info.def_id\n+                    trait_method_def_id: trait_method_info.def_id\n                 };\n \n             let method_infos = @DVec();"}, {"sha": "7452e41fac33760be7dfb070b0c044496a4ee002", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=0fc952372a1010bc567b1c183105e4fd3f395af0", "patch": "@@ -662,8 +662,8 @@ type expr = {id: node_id, callee_id: node_id, node: expr_, span: span};\n \n #[auto_serialize]\n #[auto_deserialize]\n-enum log_level { error, debug, other }\n-// 0 = error, 1 = debug, 2 = other\n+enum log_level { error, debug, log_other }\n+// 0 = error, 1 = debug, 2 = log_other\n \n #[auto_serialize]\n #[auto_deserialize]\n@@ -1137,7 +1137,7 @@ impl Ty : to_bytes::IterBytes {\n \n #[auto_serialize]\n #[auto_deserialize]\n-type arg = {mode: mode, ty: @Ty, ident: ident, id: node_id};\n+type arg = {mode: mode, ty: @Ty, pat: @pat, id: node_id};\n \n #[auto_serialize]\n #[auto_deserialize]"}, {"sha": "d3b879da7dd95737141f6f0bb3e942f959c11f2e", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=0fc952372a1010bc567b1c183105e4fd3f395af0", "patch": "@@ -274,6 +274,12 @@ fn ident_to_path(s: span, +i: ident) -> @path {\n       rp: None, types: ~[]}\n }\n \n+fn ident_to_pat(id: node_id, s: span, +i: ident) -> @pat {\n+    @{id: id,\n+      node: pat_ident(bind_by_value, ident_to_path(s, i), None),\n+      span: s}\n+}\n+\n pure fn is_unguarded(a: &arm) -> bool {\n     match a.guard {\n       None => true,"}, {"sha": "39e94291d8bb744b4c4a6c177eb7560e63bc8ce7", "filename": "src/libsyntax/ext/auto_serialize.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize.rs?ref=0fc952372a1010bc567b1c183105e4fd3f395af0", "patch": "@@ -515,7 +515,12 @@ fn mk_ser_method(\n     let ser_inputs = ~[{\n         mode: ast::infer(cx.next_id()),\n         ty: ty_s,\n-        ident: cx.ident_of(~\"__s\"),\n+        pat: @{id: cx.next_id(),\n+               node: ast::pat_ident(\n+                    ast::bind_by_value,\n+                    ast_util::ident_to_path(span, cx.ident_of(~\"__s\")),\n+                    None),\n+               span: span},\n         id: cx.next_id(),\n     }];\n \n@@ -570,7 +575,12 @@ fn mk_deser_method(\n     let deser_inputs = ~[{\n         mode: ast::infer(cx.next_id()),\n         ty: ty_d,\n-        ident: cx.ident_of(~\"__d\"),\n+        pat: @{id: cx.next_id(),\n+               node: ast::pat_ident(\n+                    ast::bind_by_value,\n+                    ast_util::ident_to_path(span, cx.ident_of(~\"__d\")),\n+                    None),\n+               span: span},\n         id: cx.next_id(),\n     }];\n \n@@ -1087,7 +1097,13 @@ fn mk_enum_deser_body(\n                         node: ast::ty_infer,\n                         span: span\n                     },\n-                    ident: cx.ident_of(~\"i\"),\n+                    pat: @{id: cx.next_id(),\n+                           node: ast::pat_ident(\n+                                ast::bind_by_value,\n+                                ast_util::ident_to_path(span,\n+                                                        cx.ident_of(~\"i\")),\n+                                None),\n+                           span: span},\n                     id: cx.next_id(),\n                 }],\n                 output: @{"}, {"sha": "ddf58ce0fef1cd9b14d60ee8d3397da71fc94c4b", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=0fc952372a1010bc567b1c183105e4fd3f395af0", "patch": "@@ -234,24 +234,27 @@ fn mk_ctxt(parse_sess: parse::parse_sess,\n     move ((move imp) as ext_ctxt)\n }\n \n-fn expr_to_str(cx: ext_ctxt, expr: @ast::expr, error: ~str) -> ~str {\n+fn expr_to_str(cx: ext_ctxt, expr: @ast::expr, err_msg: ~str) -> ~str {\n     match expr.node {\n       ast::expr_lit(l) => match l.node {\n         ast::lit_str(s) => return *s,\n-        _ => cx.span_fatal(l.span, error)\n+        _ => cx.span_fatal(l.span, err_msg)\n       },\n-      _ => cx.span_fatal(expr.span, error)\n+      _ => cx.span_fatal(expr.span, err_msg)\n     }\n }\n \n-fn expr_to_ident(cx: ext_ctxt, expr: @ast::expr, error: ~str) -> ast::ident {\n+fn expr_to_ident(cx: ext_ctxt,\n+                 expr: @ast::expr,\n+                 err_msg: ~str) -> ast::ident {\n     match expr.node {\n       ast::expr_path(p) => {\n         if vec::len(p.types) > 0u || vec::len(p.idents) != 1u {\n-            cx.span_fatal(expr.span, error);\n-        } else { return p.idents[0]; }\n+            cx.span_fatal(expr.span, err_msg);\n+        }\n+        return p.idents[0];\n       }\n-      _ => cx.span_fatal(expr.span, error)\n+      _ => cx.span_fatal(expr.span, err_msg)\n     }\n }\n "}, {"sha": "f03adb90f0bcf2c799378ca41e081cca72ca0bfa", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=0fc952372a1010bc567b1c183105e4fd3f395af0", "patch": "@@ -4,7 +4,7 @@\n // something smarter.\n \n use ast::{ident, node_id};\n-use ast_util::respan;\n+use ast_util::{ident_to_path, respan};\n use codemap::span;\n use ext::base::mk_ctxt;\n \n@@ -178,7 +178,12 @@ impl ext_ctxt: ext_ctxt_ast_builder {\n     fn arg(name: ident, ty: @ast::Ty) -> ast::arg {\n         {mode: ast::infer(self.next_id()),\n          ty: ty,\n-         ident: name,\n+         pat: @{id: self.next_id(),\n+                node: ast::pat_ident(\n+                    ast::bind_by_value,\n+                    ast_util::ident_to_path(self.empty_span(), name),\n+                    None),\n+                span: self.empty_span()},\n          id: self.next_id()}\n     }\n "}, {"sha": "8609124126c09e5ed450e23c73418776fc9b665d", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=0fc952372a1010bc567b1c183105e4fd3f395af0", "patch": "@@ -105,9 +105,9 @@ fn fold_attribute_(at: attribute, fld: ast_fold) ->\n //used in noop_fold_foreign_item and noop_fold_fn_decl\n fn fold_arg_(a: arg, fld: ast_fold) -> arg {\n     return {mode: a.mode,\n-         ty: fld.fold_ty(a.ty),\n-         ident: fld.fold_ident(a.ident),\n-         id: fld.new_id(a.id)};\n+            ty: fld.fold_ty(a.ty),\n+            pat: fld.fold_pat(a.pat),\n+            id: fld.new_id(a.id)};\n }\n //used in noop_fold_expr, and possibly elsewhere in the future\n fn fold_mac_(m: mac, fld: ast_fold) -> mac {"}, {"sha": "2b42dcc0ed06af8fc93378950e17a286c61f481f", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=0fc952372a1010bc567b1c183105e4fd3f395af0", "patch": "@@ -696,19 +696,21 @@ impl Parser {\n     // identifier names.\n     fn parse_arg_general(require_name: bool) -> arg {\n         let mut m;\n-        let i = if require_name || self.is_named_argument() {\n+        let pat = if require_name || self.is_named_argument() {\n             m = self.parse_arg_mode();\n-            let name = self.parse_value_ident();\n+            let pat = self.parse_pat(false);\n             self.expect(token::COLON);\n-            name\n+            pat\n         } else {\n             m = infer(self.get_id());\n-            special_idents::invalid\n+            ast_util::ident_to_pat(self.get_id(),\n+                                   copy self.last_span,\n+                                   special_idents::invalid)\n         };\n \n         let t = self.parse_ty(false);\n \n-        {mode: m, ty: t, ident: i, id: self.get_id()}\n+        {mode: m, ty: t, pat: pat, id: self.get_id()}\n     }\n \n     fn parse_arg() -> arg_or_capture_item {\n@@ -722,15 +724,15 @@ impl Parser {\n     fn parse_fn_block_arg() -> arg_or_capture_item {\n         do self.parse_capture_item_or |p| {\n             let m = p.parse_arg_mode();\n-            let i = p.parse_value_ident();\n+            let pat = p.parse_pat(false);\n             let t = if p.eat(token::COLON) {\n                 p.parse_ty(false)\n             } else {\n                 @{id: p.get_id(),\n                   node: ty_infer,\n                   span: mk_sp(p.span.lo, p.span.hi)}\n             };\n-            either::Left({mode: m, ty: t, ident: i, id: p.get_id()})\n+            either::Left({mode: m, ty: t, pat: pat, id: p.get_id()})\n         }\n     }\n \n@@ -1042,7 +1044,7 @@ impl Parser {\n             let lvl = self.parse_expr();\n             self.expect(token::COMMA);\n             let e = self.parse_expr();\n-            ex = expr_log(ast::other, lvl, e);\n+            ex = expr_log(ast::log_other, lvl, e);\n             hi = self.span.hi;\n             self.expect(token::RPAREN);\n         } else if self.eat_keyword(~\"assert\") {\n@@ -2708,6 +2710,11 @@ impl Parser {\n          }\n     }\n \n+    fn ident_to_path(i: ident) -> @path {\n+        @{span: self.last_span, global: false, idents: ~[i],\n+          rp: None, types: ~[]}\n+    }\n+\n     fn parse_trait_ref() -> @trait_ref {\n         @{path: self.parse_path_with_tps(false),\n           ref_id: self.get_id(), impl_id: self.get_id()}"}, {"sha": "0418f6776de6b8861b7e43665cb0c059997a9c42", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=0fc952372a1010bc567b1c183105e4fd3f395af0", "patch": "@@ -1386,7 +1386,7 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n         match lvl {\n           ast::debug => { word_nbsp(s, ~\"log\"); print_expr(s, expr); }\n           ast::error => { word_nbsp(s, ~\"log_err\"); print_expr(s, expr); }\n-          ast::other => {\n+          ast::log_other => {\n             word_nbsp(s, ~\"log\");\n             popen(s);\n             print_expr(s, lexp);\n@@ -1820,12 +1820,19 @@ fn print_arg(s: ps, input: ast::arg) {\n     ibox(s, indent_unit);\n     print_arg_mode(s, input.mode);\n     match input.ty.node {\n-      ast::ty_infer => print_ident(s, input.ident),\n+      ast::ty_infer => print_pat(s, input.pat),\n       _ => {\n-        if input.ident != parse::token::special_idents::invalid {\n-            print_ident(s, input.ident);\n-            word(s.s, ~\":\");\n-            space(s.s);\n+        match input.pat.node {\n+            ast::pat_ident(_, path, _) if\n+                path.idents.len() == 1 &&\n+                path.idents[0] == parse::token::special_idents::invalid => {\n+                // Do nothing.\n+            }\n+            _ => {\n+                print_pat(s, input.pat);\n+                word(s.s, ~\":\");\n+                space(s.s);\n+            }\n         }\n         print_type(s, input.ty);\n       }"}, {"sha": "42b869b6c34179677cb17ad247d02e882fc5161a", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=0fc952372a1010bc567b1c183105e4fd3f395af0", "patch": "@@ -277,7 +277,10 @@ fn visit_ty_params<E>(tps: ~[ty_param], e: E, v: vt<E>) {\n }\n \n fn visit_fn_decl<E>(fd: fn_decl, e: E, v: vt<E>) {\n-    for fd.inputs.each |a| { v.visit_ty(a.ty, e, v); }\n+    for fd.inputs.each |a| {\n+        v.visit_pat(a.pat, e, v);\n+        v.visit_ty(a.ty, e, v);\n+    }\n     v.visit_ty(fd.output, e, v);\n }\n "}, {"sha": "41be88168f21bf0f87d6d7c3ddf03b3f077d86db", "filename": "src/test/compile-fail/macro-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Ftest%2Fcompile-fail%2Fmacro-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Ftest%2Fcompile-fail%2Fmacro-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-2.rs?ref=0fc952372a1010bc567b1c183105e4fd3f395af0", "patch": "@@ -1,4 +1,4 @@\n-//error-pattern:is an expr, expected an identifier\n+//error-pattern:is an expr, expected a path\n fn main() {\n     #macro[[#mylambda[x, body],\n             {"}, {"sha": "daf8b06bc3186efe22038d36226eb5331d57f3bd", "filename": "src/test/compile-fail/nontrivial-fn-arg-pattern-in-pure-fn.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Ftest%2Fcompile-fail%2Fnontrivial-fn-arg-pattern-in-pure-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Ftest%2Fcompile-fail%2Fnontrivial-fn-arg-pattern-in-pure-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnontrivial-fn-arg-pattern-in-pure-fn.rs?ref=0fc952372a1010bc567b1c183105e4fd3f395af0", "patch": "@@ -0,0 +1,6 @@\n+pure fn call_first((x, _y): (&fn(), &fn())) {\n+    x();    //~ ERROR access to impure function prohibited in pure context\n+}\n+\n+fn main() {}\n+"}, {"sha": "5299d6a87c3769e61357aeba4b2604d77b0b68a9", "filename": "src/test/compile-fail/refutable-pattern-in-fn-arg.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Ftest%2Fcompile-fail%2Frefutable-pattern-in-fn-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Ftest%2Fcompile-fail%2Frefutable-pattern-in-fn-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frefutable-pattern-in-fn-arg.rs?ref=0fc952372a1010bc567b1c183105e4fd3f395af0", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+    let f = |3: int| io::println(\"hello\");  //~ ERROR refutable pattern\n+    f(4);\n+}\n+"}, {"sha": "223665381da1e3eb87d88cb936167dfd82a72acb", "filename": "src/test/compile-fail/regions-glb-free-free.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs?ref=0fc952372a1010bc567b1c183105e4fd3f395af0", "patch": "@@ -19,7 +19,7 @@ mod argparse {\n         fn set_desc(self, s: &str) -> Flag {\n             Flag { //~ ERROR cannot infer an appropriate lifetime\n                 name: self.name,\n-                desc: s, //~ ERROR cannot infer an appropriate lifetime\n+                desc: s,\n                 max_count: self.max_count,\n                 value: self.value\n             }"}, {"sha": "ce5acb14944ca59c8fe184cc31fd3425930dd641", "filename": "src/test/run-pass/pattern-in-closure.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Ftest%2Frun-pass%2Fpattern-in-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fc952372a1010bc567b1c183105e4fd3f395af0/src%2Ftest%2Frun-pass%2Fpattern-in-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpattern-in-closure.rs?ref=0fc952372a1010bc567b1c183105e4fd3f395af0", "patch": "@@ -0,0 +1,12 @@\n+struct Foo {\n+    x: int,\n+    y: int\n+}\n+\n+fn main() {\n+    let f = |(x, _): (int, int)| io::println((x + 1).to_str());\n+    let g = |Foo { x: x, y: y }: Foo| io::println((x + 1).to_str());\n+    f((2, 3));\n+    g(Foo { x: 1, y: 2 });\n+}\n+"}]}