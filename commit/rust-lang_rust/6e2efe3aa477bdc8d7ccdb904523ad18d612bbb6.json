{"sha": "6e2efe3aa477bdc8d7ccdb904523ad18d612bbb6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlMmVmZTNhYTQ3N2JkYzhkN2NjZGI5MDQ1MjNhZDE4ZDYxMmJiYjY=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2017-04-04T16:31:03Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2017-05-04T18:56:02Z"}, "message": "refactor NonZero, Shared, and Unique APIs\n\nMajor difference is that I removed Deref impls, as apparently LLVM has\ntrouble maintaining metadata with a `&ptr -> &ptr` API. This was cited\nas a blocker for ever stabilizing this API. It wasn't that ergonomic\nanyway.\n\n* Added `get` to NonZero to replace Deref impl\n* Added `as_ptr` to Shared/Unique to replace Deref impl\n* Added Unique's `as_ref` and `as_mut` conveniences to Shared\n* Added `::empty()` convenience constructor for Unique/Shared\n* Deprecated `as_mut_ptr` on Shared in favour of `as_ptr`\n* Improved documentation of types\n\nNote that Shared now only refers to *mut, and not *const", "tree": {"sha": "3a4b401ff3856ccfd94fb6cf22f04be44bdcfa08", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a4b401ff3856ccfd94fb6cf22f04be44bdcfa08"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e2efe3aa477bdc8d7ccdb904523ad18d612bbb6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e2efe3aa477bdc8d7ccdb904523ad18d612bbb6", "html_url": "https://github.com/rust-lang/rust/commit/6e2efe3aa477bdc8d7ccdb904523ad18d612bbb6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e2efe3aa477bdc8d7ccdb904523ad18d612bbb6/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "html_url": "https://github.com/rust-lang/rust/commit/ed1f26ddda15b2bcf613a257e813e8b02ee14dff"}], "stats": {"total": 184, "additions": 131, "deletions": 53}, "files": [{"sha": "d93085e96dbb2833910a6df764430669bc8a40d1", "filename": "src/libcore/nonzero.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6e2efe3aa477bdc8d7ccdb904523ad18d612bbb6/src%2Flibcore%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2efe3aa477bdc8d7ccdb904523ad18d612bbb6/src%2Flibcore%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnonzero.rs?ref=6e2efe3aa477bdc8d7ccdb904523ad18d612bbb6", "patch": "@@ -13,7 +13,7 @@\n             reason = \"needs an RFC to flesh out the design\",\n             issue = \"27730\")]\n \n-use ops::{CoerceUnsized, Deref};\n+use ops::CoerceUnsized;\n \n /// Unsafe trait to indicate what types are usable with the NonZero struct\n pub unsafe trait Zeroable {}\n@@ -46,15 +46,10 @@ impl<T: Zeroable> NonZero<T> {\n     pub const unsafe fn new(inner: T) -> NonZero<T> {\n         NonZero(inner)\n     }\n-}\n-\n-impl<T: Zeroable> Deref for NonZero<T> {\n-    type Target = T;\n \n-    #[inline]\n-    fn deref(&self) -> &T {\n-        let NonZero(ref inner) = *self;\n-        inner\n+    /// Gets the inner value.\n+    pub fn get(self) -> T {\n+        self.0\n     }\n }\n "}, {"sha": "a60abefc076504027bdc99141b9add789bda7060", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 127, "deletions": 44, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/6e2efe3aa477bdc8d7ccdb904523ad18d612bbb6/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2efe3aa477bdc8d7ccdb904523ad18d612bbb6/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=6e2efe3aa477bdc8d7ccdb904523ad18d612bbb6", "patch": "@@ -17,7 +17,7 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use intrinsics;\n-use ops::{CoerceUnsized, Deref};\n+use ops::CoerceUnsized;\n use fmt;\n use hash;\n use marker::{PhantomData, Unsize};\n@@ -957,13 +957,25 @@ impl<T: ?Sized> PartialOrd for *mut T {\n }\n \n /// A wrapper around a raw non-null `*mut T` that indicates that the possessor\n-/// of this wrapper owns the referent. This in turn implies that the\n-/// `Unique<T>` is `Send`/`Sync` if `T` is `Send`/`Sync`, unlike a raw\n-/// `*mut T` (which conveys no particular ownership semantics).  It\n-/// also implies that the referent of the pointer should not be\n-/// modified without a unique path to the `Unique` reference. Useful\n-/// for building abstractions like `Vec<T>` or `Box<T>`, which\n-/// internally use raw pointers to manage the memory that they own.\n+/// of this wrapper owns the referent. Useful for building abstractions like\n+/// `Box<T>`, `Vec<T>`, `String`, and `HashMap<K, V>`.\n+///\n+/// Unlike `*mut T`, `Unique<T>` behaves \"as if\" it were an instance of `T`.\n+/// It implements `Send`/`Sync` if `T` is `Send`/`Sync`. It also implies\n+/// the kind of strong aliasing guarantees an instance of `T` can expect:\n+/// the referent of the pointer should not be modified without a unique path to\n+/// its owning Unique.\n+///\n+/// If you're uncertain of whether it's correct to use `Unique` for your purposes,\n+/// consider using `Shared`, which has weaker semantics.\n+///\n+/// Unlike `*mut T`, the pointer must always be non-null, even if the pointer\n+/// is never dereferenced. This is so that enums may use this forbidden value\n+/// as a discriminant -- `Option<Unique<T>>` has the same size as `Unique<T>`.\n+/// However the pointer may still dangle if it isn't dereferenced.\n+///\n+/// Unlike `*mut T`, `Unique<T>` is covariant over `T`. This should always be correct\n+/// for any type which upholds Unique's aliasing requirements.\n #[allow(missing_debug_implementations)]\n #[unstable(feature = \"unique\", reason = \"needs an RFC to flesh out design\",\n            issue = \"27730\")]\n@@ -991,6 +1003,20 @@ unsafe impl<T: Send + ?Sized> Send for Unique<T> { }\n #[unstable(feature = \"unique\", issue = \"27730\")]\n unsafe impl<T: Sync + ?Sized> Sync for Unique<T> { }\n \n+#[unstable(feature = \"unique\", issue = \"27730\")]\n+impl<T: Sized> Unique<T> {\n+    /// Creates a new `Shared` that is dangling, but well-aligned.\n+    ///\n+    /// This is useful for initializing types which lazily allocate, like\n+    /// `Vec::new` does.\n+    pub fn empty() -> Self {\n+        unsafe {\n+            let ptr = mem::align_of::<T>() as *mut T;\n+            Unique::new(ptr)\n+        }\n+    }\n+}\n+\n #[unstable(feature = \"unique\", issue = \"27730\")]\n impl<T: ?Sized> Unique<T> {\n     /// Creates a new `Unique`.\n@@ -1002,41 +1028,72 @@ impl<T: ?Sized> Unique<T> {\n         Unique { pointer: NonZero::new(ptr), _marker: PhantomData }\n     }\n \n+    /// Acquires the underlying `*mut` pointer.\n+    pub fn as_ptr(self) -> *mut T {\n+        self.pointer.get() as *mut T\n+    }\n+\n     /// Dereferences the content.\n-    pub unsafe fn get(&self) -> &T {\n-        &**self.pointer\n+    ///\n+    /// The resulting lifetime is bound to self so this behaves \"as if\"\n+    /// it were actually an instance of T that is getting borrowed. If a longer\n+    /// (unbound) lifetime is needed, use `&*my_ptr.ptr()`.\n+    pub unsafe fn as_ref(&self) -> &T {\n+        &*self.as_ptr()\n     }\n \n     /// Mutably dereferences the content.\n-    pub unsafe fn get_mut(&mut self) -> &mut T {\n-        &mut ***self\n+    ///\n+    /// The resulting lifetime is bound to self so this behaves \"as if\"\n+    /// it were actually an instance of T that is getting borrowed. If a longer\n+    /// (unbound) lifetime is needed, use `&mut *my_ptr.ptr()`.\n+    pub unsafe fn as_mut(&mut self) -> &mut T {\n+        &mut *self.as_ptr()\n     }\n }\n \n-#[unstable(feature = \"unique\", issue = \"27730\")]\n-impl<T: ?Sized, U: ?Sized> CoerceUnsized<Unique<U>> for Unique<T> where T: Unsize<U> { }\n-\n-#[unstable(feature = \"unique\", issue= \"27730\")]\n-impl<T:?Sized> Deref for Unique<T> {\n-    type Target = *mut T;\n-\n-    #[inline]\n-    fn deref(&self) -> &*mut T {\n-        unsafe { mem::transmute(&*self.pointer) }\n+#[unstable(feature = \"shared\", issue = \"27730\")]\n+impl<T: ?Sized> Clone for Unique<T> {\n+    fn clone(&self) -> Self {\n+        *self\n     }\n }\n \n+#[unstable(feature = \"shared\", issue = \"27730\")]\n+impl<T: ?Sized> Copy for Unique<T> { }\n+\n+#[unstable(feature = \"unique\", issue = \"27730\")]\n+impl<T: ?Sized, U: ?Sized> CoerceUnsized<Unique<U>> for Unique<T> where T: Unsize<U> { }\n+\n #[unstable(feature = \"unique\", issue = \"27730\")]\n-impl<T> fmt::Pointer for Unique<T> {\n+impl<T: ?Sized> fmt::Pointer for Unique<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Pointer::fmt(&*self.pointer, f)\n+        fmt::Pointer::fmt(&self.as_ptr(), f)\n     }\n }\n \n-/// A wrapper around a raw non-null `*mut T` that indicates that the possessor\n+/// A wrapper around a raw `*mut T` that indicates that the possessor\n /// of this wrapper has shared ownership of the referent. Useful for\n-/// building abstractions like `Rc<T>` or `Arc<T>`, which internally\n-/// use raw pointers to manage the memory that they own.\n+/// building abstractions like `Rc<T>`, `Arc<T>`, or doubly-linked lists, which\n+/// internally use aliased raw pointers to manage the memory that they own.\n+///\n+/// This is similar to `Unique`, except that it doesn't make any aliasing\n+/// guarantees, and doesn't derive Send and Sync. Note that unlike `&T`,\n+/// Shared has no special mutability requirements. Shared may mutate data\n+/// aliased by other Shared pointers. More precise rules require Rust to\n+/// develop an actual aliasing model.\n+///\n+/// Unlike `*mut T`, the pointer must always be non-null, even if the pointer\n+/// is never dereferenced. This is so that enums may use this forbidden value\n+/// as a discriminant -- `Option<Shared<T>>` has the same size as `Shared<T>`.\n+/// However the pointer may still dangle if it isn't dereferenced.\n+///\n+/// Unlike `*mut T`, `Shared<T>` is covariant over `T`. If this is incorrect\n+/// for your use case, you should include some PhantomData in your type to\n+/// provide invariance, such as `PhantomData<Cell<T>>` or `PhantomData<&'a mut T>`.\n+/// Usually this won't be necessary; covariance is correct for Rc, Arc, and LinkedList\n+/// because they provide a public API that follows the normal shared XOR mutable\n+/// rules of Rust.\n #[allow(missing_debug_implementations)]\n #[unstable(feature = \"shared\", reason = \"needs an RFC to flesh out design\",\n            issue = \"27730\")]\n@@ -1060,23 +1117,59 @@ impl<T: ?Sized> !Send for Shared<T> { }\n #[unstable(feature = \"shared\", issue = \"27730\")]\n impl<T: ?Sized> !Sync for Shared<T> { }\n \n+#[unstable(feature = \"shared\", issue = \"27730\")]\n+impl<T: Sized> Shared<T> {\n+    /// Creates a new `Shared` that is dangling, but well-aligned.\n+    ///\n+    /// This is useful for initializing types which lazily allocate, like\n+    /// `Vec::new` does.\n+    pub fn empty() -> Self {\n+        unsafe {\n+            let ptr = mem::align_of::<T>() as *mut T;\n+            Shared::new(ptr)\n+        }\n+    }\n+}\n+\n #[unstable(feature = \"shared\", issue = \"27730\")]\n impl<T: ?Sized> Shared<T> {\n     /// Creates a new `Shared`.\n     ///\n     /// # Safety\n     ///\n     /// `ptr` must be non-null.\n-    pub unsafe fn new(ptr: *const T) -> Self {\n+    pub unsafe fn new(ptr: *mut T) -> Self {\n         Shared { pointer: NonZero::new(ptr), _marker: PhantomData }\n     }\n-}\n \n-#[unstable(feature = \"shared\", issue = \"27730\")]\n-impl<T: ?Sized> Shared<T> {\n+    /// Acquires the underlying `*mut` pointer.\n+    pub fn as_ptr(self) -> *mut T {\n+        self.pointer.get() as *mut T\n+    }\n+\n+    /// Dereferences the content.\n+    ///\n+    /// The resulting lifetime is bound to self so this behaves \"as if\"\n+    /// it were actually an instance of T that is getting borrowed. If a longer\n+    /// (unbound) lifetime is needed, use `&*my_ptr.ptr()`.\n+    pub unsafe fn as_ref(&self) -> &T {\n+        &*self.as_ptr()\n+    }\n+\n+    /// Mutably dereferences the content.\n+    ///\n+    /// The resulting lifetime is bound to self so this behaves \"as if\"\n+    /// it were actually an instance of T that is getting borrowed. If a longer\n+    /// (unbound) lifetime is needed, use `&mut *my_ptr.ptr_mut()`.\n+    pub unsafe fn as_mut(&mut self) -> &mut T {\n+        &mut *self.as_ptr()\n+    }\n+\n     /// Acquires the underlying pointer as a `*mut` pointer.\n+    #[rustc_deprecated(since = \"1.19\", reason = \"renamed to `as_ptr` for ergonomics/consistency\")]\n+    #[unstable(feature = \"shared\", issue = \"27730\")]\n     pub unsafe fn as_mut_ptr(&self) -> *mut T {\n-        **self as _\n+        self.as_ptr()\n     }\n }\n \n@@ -1094,18 +1187,8 @@ impl<T: ?Sized> Copy for Shared<T> { }\n impl<T: ?Sized, U: ?Sized> CoerceUnsized<Shared<U>> for Shared<T> where T: Unsize<U> { }\n \n #[unstable(feature = \"shared\", issue = \"27730\")]\n-impl<T: ?Sized> Deref for Shared<T> {\n-    type Target = *const T;\n-\n-    #[inline]\n-    fn deref(&self) -> &*const T {\n-        unsafe { mem::transmute(&*self.pointer) }\n-    }\n-}\n-\n-#[unstable(feature = \"shared\", issue = \"27730\")]\n-impl<T> fmt::Pointer for Shared<T> {\n+impl<T: ?Sized> fmt::Pointer for Shared<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Pointer::fmt(&*self.pointer, f)\n+        fmt::Pointer::fmt(&self.as_ptr(), f)\n     }\n }"}]}