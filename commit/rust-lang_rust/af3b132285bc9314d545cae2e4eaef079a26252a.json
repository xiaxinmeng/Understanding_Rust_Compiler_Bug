{"sha": "af3b132285bc9314d545cae2e4eaef079a26252a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmM2IxMzIyODViYzkzMTRkNTQ1Y2FlMmU0ZWFlZjA3OWEyNjI1MmE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-09-28T04:01:58Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-01T06:21:19Z"}, "message": "syntax: Remove usage of fmt!", "tree": {"sha": "1c7116cb4d82388a6eb3da6e4088448ea24016ba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c7116cb4d82388a6eb3da6e4088448ea24016ba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af3b132285bc9314d545cae2e4eaef079a26252a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af3b132285bc9314d545cae2e4eaef079a26252a", "html_url": "https://github.com/rust-lang/rust/commit/af3b132285bc9314d545cae2e4eaef079a26252a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af3b132285bc9314d545cae2e4eaef079a26252a/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e709bfd0dac1d5bbe5c97494980731b4d477e8f", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e709bfd0dac1d5bbe5c97494980731b4d477e8f", "html_url": "https://github.com/rust-lang/rust/commit/7e709bfd0dac1d5bbe5c97494980731b4d477e8f"}], "stats": {"total": 684, "additions": 342, "deletions": 342}, "files": [{"sha": "1cb30eaa040b2755ae3142941b3279aa1504d07e", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=af3b132285bc9314d545cae2e4eaef079a26252a", "patch": "@@ -505,7 +505,7 @@ impl<T:Freeze + Send> RWArc<T> {\n         let inner = x.unwrap();\n         let RWArcInner { failed: failed, data: data, _ } = inner;\n         if failed {\n-            fail2!(~\"Can't unwrap poisoned RWArc - another task failed inside!\")\n+            fail2!(\"Can't unwrap poisoned RWArc - another task failed inside!\")\n         }\n         data\n     }"}, {"sha": "16937e38695b789ad4b499907309d8975f160466", "filename": "src/libextra/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=af3b132285bc9314d545cae2e4eaef079a26252a", "patch": "@@ -125,7 +125,7 @@ pub fn test_main(args: &[~str], tests: ~[TestDescAndFn]) {\n     let opts =\n         match parse_opts(args) {\n             Some(Ok(o)) => o,\n-            Some(Err(msg)) => fail2!(msg),\n+            Some(Err(msg)) => fail2!(\"{}\", msg),\n             None => return\n         };\n     if !run_tests_console(&opts, tests) { fail2!(\"Some tests failed\"); }"}, {"sha": "4875ef6d3caa55c95dc3950a4f3cfcc392071895", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=af3b132285bc9314d545cae2e4eaef079a26252a", "patch": "@@ -221,7 +221,7 @@ impl AbiSet {\n             let data = abi.data();\n             for other_abi in abis.slice(0, i).iter() {\n                 let other_data = other_abi.data();\n-                debug!(\"abis=(%?,%?) datas=(%?,%?)\",\n+                debug2!(\"abis=({:?},{:?}) datas=({:?},{:?})\",\n                        abi, data.abi_arch,\n                        other_abi, other_data.abi_arch);\n                 match (&data.abi_arch, &other_data.abi_arch) {\n@@ -273,7 +273,7 @@ impl ToStr for AbiSet {\n             strs.push(abi.data().name);\n             true\n         };\n-        fmt!(\"\\\"%s\\\"\", strs.connect(\" \"))\n+        format!(\"\\\"{}\\\"\", strs.connect(\" \"))\n     }\n }\n \n@@ -306,7 +306,7 @@ fn cannot_combine(n: Abi, m: Abi) {\n                          (m == a && n == b));\n         }\n         None => {\n-            fail!(\"Invalid match not detected\");\n+            fail2!(\"Invalid match not detected\");\n         }\n     }\n }\n@@ -318,7 +318,7 @@ fn can_combine(n: Abi, m: Abi) {\n     set.add(m);\n     match set.check_valid() {\n         Some((_, _)) => {\n-            fail!(\"Valid match declared invalid\");\n+            fail2!(\"Valid match declared invalid\");\n         }\n         None => {}\n     }\n@@ -367,15 +367,15 @@ fn abi_to_str_c_aaps() {\n     let mut set = AbiSet::empty();\n     set.add(Aapcs);\n     set.add(C);\n-    debug!(\"set = %s\", set.to_str());\n+    debug2!(\"set = {}\", set.to_str());\n     assert!(set.to_str() == ~\"\\\"aapcs C\\\"\");\n }\n \n #[test]\n fn abi_to_str_rust() {\n     let mut set = AbiSet::empty();\n     set.add(Rust);\n-    debug!(\"set = %s\", set.to_str());\n+    debug2!(\"set = {}\", set.to_str());\n     assert!(set.to_str() == ~\"\\\"Rust\\\"\");\n }\n "}, {"sha": "f2d7ebdd5993fe7598562c635a24ae43e1442a21", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=af3b132285bc9314d545cae2e4eaef079a26252a", "patch": "@@ -47,8 +47,8 @@ impl Eq for Ident {\n             // if it should be non-hygienic (most things are), just compare the\n             // 'name' fields of the idents. Or, even better, replace the idents\n             // with Name's.\n-            fail!(fmt!(\"not allowed to compare these idents: %?, %?. Probably \\\n-                       related to issue #6993\", self, other));\n+            fail2!(\"not allowed to compare these idents: {:?}, {:?}.\n+                    Probably related to issue \\\\#6993\", self, other);\n         }\n     }\n     fn ne(&self, other: &Ident) -> bool {"}, {"sha": "105d222926e2326e42bbb8ead618ef11ae62ad45", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=af3b132285bc9314d545cae2e4eaef079a26252a", "patch": "@@ -66,7 +66,7 @@ pub fn path_ident_to_str(p: &path, i: Ident, itr: @ident_interner) -> ~str {\n     if p.is_empty() {\n         itr.get(i.name).to_owned()\n     } else {\n-        fmt!(\"%s::%s\", path_to_str(*p, itr), itr.get(i.name))\n+        format!(\"{}::{}\", path_to_str(*p, itr), itr.get(i.name))\n     }\n }\n \n@@ -96,7 +96,7 @@ pub fn impl_pretty_name(trait_ref: &Option<trait_ref>,\n             // XXX: this dollar sign is actually a relic of being one of the\n             //      very few valid symbol names on unix. These kinds of\n             //      details shouldn't be exposed way up here in the ast.\n-            let s = fmt!(\"%s$%s\",\n+            let s = format!(\"{}${}\",\n                          itr.get(trait_ref.path.segments.last().identifier.name),\n                          itr.get(ty_ident.name));\n             path_pretty_name(Ident::new(itr.gensym(s)), hash)\n@@ -185,7 +185,7 @@ impl Ctx {\n                                                          item,\n                                                          p));\n                     }\n-                    _ => fail!(\"struct def parent wasn't an item\")\n+                    _ => fail2!(\"struct def parent wasn't an item\")\n                 }\n             }\n         }\n@@ -426,7 +426,7 @@ pub fn map_decoded_item(diag: @mut span_handler,\n pub fn node_id_to_str(map: map, id: NodeId, itr: @ident_interner) -> ~str {\n     match map.find(&id) {\n       None => {\n-        fmt!(\"unknown node (id=%d)\", id)\n+        format!(\"unknown node (id={})\", id)\n       }\n       Some(&node_item(item, path)) => {\n         let path_str = path_ident_to_str(path, item.ident, itr);\n@@ -442,46 +442,46 @@ pub fn node_id_to_str(map: map, id: NodeId, itr: @ident_interner) -> ~str {\n           item_impl(*) => ~\"impl\",\n           item_mac(*) => ~\"macro\"\n         };\n-        fmt!(\"%s %s (id=%?)\", item_str, path_str, id)\n+        format!(\"{} {} (id={})\", item_str, path_str, id)\n       }\n       Some(&node_foreign_item(item, abi, _, path)) => {\n-        fmt!(\"foreign item %s with abi %? (id=%?)\",\n+        format!(\"foreign item {} with abi {:?} (id={})\",\n              path_ident_to_str(path, item.ident, itr), abi, id)\n       }\n       Some(&node_method(m, _, path)) => {\n-        fmt!(\"method %s in %s (id=%?)\",\n+        format!(\"method {} in {} (id={})\",\n              itr.get(m.ident.name), path_to_str(*path, itr), id)\n       }\n       Some(&node_trait_method(ref tm, _, path)) => {\n         let m = ast_util::trait_method_to_ty_method(&**tm);\n-        fmt!(\"method %s in %s (id=%?)\",\n+        format!(\"method {} in {} (id={})\",\n              itr.get(m.ident.name), path_to_str(*path, itr), id)\n       }\n       Some(&node_variant(ref variant, _, path)) => {\n-        fmt!(\"variant %s in %s (id=%?)\",\n+        format!(\"variant {} in {} (id={})\",\n              itr.get(variant.node.name.name), path_to_str(*path, itr), id)\n       }\n       Some(&node_expr(expr)) => {\n-        fmt!(\"expr %s (id=%?)\", pprust::expr_to_str(expr, itr), id)\n+        format!(\"expr {} (id={})\", pprust::expr_to_str(expr, itr), id)\n       }\n       Some(&node_callee_scope(expr)) => {\n-        fmt!(\"callee_scope %s (id=%?)\", pprust::expr_to_str(expr, itr), id)\n+        format!(\"callee_scope {} (id={})\", pprust::expr_to_str(expr, itr), id)\n       }\n       Some(&node_stmt(stmt)) => {\n-        fmt!(\"stmt %s (id=%?)\",\n+        format!(\"stmt {} (id={})\",\n              pprust::stmt_to_str(stmt, itr), id)\n       }\n       Some(&node_arg(pat)) => {\n-        fmt!(\"arg %s (id=%?)\", pprust::pat_to_str(pat, itr), id)\n+        format!(\"arg {} (id={})\", pprust::pat_to_str(pat, itr), id)\n       }\n       Some(&node_local(ident)) => {\n-        fmt!(\"local (id=%?, name=%s)\", id, itr.get(ident.name))\n+        format!(\"local (id={}, name={})\", id, itr.get(ident.name))\n       }\n       Some(&node_block(ref block)) => {\n-        fmt!(\"block %s (id=%?)\", pprust::block_to_str(block, itr), id)\n+        format!(\"block {} (id={})\", pprust::block_to_str(block, itr), id)\n       }\n       Some(&node_struct_ctor(_, _, path)) => {\n-        fmt!(\"struct_ctor %s (id=%?)\", path_to_str(*path, itr), id)\n+        format!(\"struct_ctor {} (id={})\", path_to_str(*path, itr), id)\n       }\n     }\n }\n@@ -491,6 +491,6 @@ pub fn node_item_query<Result>(items: map, id: NodeId,\n                                error_msg: ~str) -> Result {\n     match items.find(&id) {\n         Some(&node_item(it, _)) => query(it),\n-        _ => fail!(error_msg)\n+        _ => fail2!(\"{}\", error_msg)\n     }\n }"}, {"sha": "f93fc1e81da23065d13b8d1e1bba79b9e748d20d", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=af3b132285bc9314d545cae2e4eaef079a26252a", "patch": "@@ -45,7 +45,7 @@ pub fn stmt_id(s: &Stmt) -> NodeId {\n       StmtDecl(_, id) => id,\n       StmtExpr(_, id) => id,\n       StmtSemi(_, id) => id,\n-      StmtMac(*) => fail!(\"attempted to analyze unexpanded stmt\")\n+      StmtMac(*) => fail2!(\"attempted to analyze unexpanded stmt\")\n     }\n }\n \n@@ -72,7 +72,7 @@ pub fn def_id_of_def(d: Def) -> DefId {\n         local_def(id)\n       }\n \n-      DefPrimTy(_) => fail!()\n+      DefPrimTy(_) => fail2!()\n     }\n }\n \n@@ -756,7 +756,7 @@ pub fn new_mark_internal(m:Mrk, tail:SyntaxContext,table:&mut SCTable)\n         }\n         true => {\n             match table.mark_memo.find(&key) {\n-                None => fail!(~\"internal error: key disappeared 2013042901\"),\n+                None => fail2!(\"internal error: key disappeared 2013042901\"),\n                 Some(idxptr) => {*idxptr}\n             }\n         }\n@@ -783,7 +783,7 @@ pub fn new_rename_internal(id:Ident, to:Name, tail:SyntaxContext, table: &mut SC\n         }\n         true => {\n             match table.rename_memo.find(&key) {\n-                None => fail!(~\"internal error: key disappeared 2013042902\"),\n+                None => fail2!(\"internal error: key disappeared 2013042902\"),\n                 Some(idxptr) => {*idxptr}\n             }\n         }\n@@ -816,9 +816,9 @@ pub fn get_sctable() -> @mut SCTable {\n \n /// print out an SCTable for debugging\n pub fn display_sctable(table : &SCTable) {\n-    error!(\"SC table:\");\n+    error2!(\"SC table:\");\n     for (idx,val) in table.table.iter().enumerate() {\n-        error!(\"%4u : %?\",idx,val);\n+        error2!(\"{:4u} : {:?}\",idx,val);\n     }\n }\n \n@@ -880,7 +880,7 @@ pub fn resolve_internal(id : Ident,\n                             resolvedthis\n                         }\n                     }\n-                    IllegalCtxt() => fail!(~\"expected resolvable context, got IllegalCtxt\")\n+                    IllegalCtxt() => fail2!(\"expected resolvable context, got IllegalCtxt\")\n                 }\n             };\n             resolve_table.insert(key,resolved);\n@@ -921,7 +921,7 @@ pub fn marksof(ctxt: SyntaxContext, stopname: Name, table: &SCTable) -> ~[Mrk] {\n                     loopvar = tl;\n                 }\n             }\n-            IllegalCtxt => fail!(~\"expected resolvable context, got IllegalCtxt\")\n+            IllegalCtxt => fail2!(\"expected resolvable context, got IllegalCtxt\")\n         }\n     }\n }\n@@ -932,7 +932,7 @@ pub fn mtwt_outer_mark(ctxt: SyntaxContext) -> Mrk {\n     let sctable = get_sctable();\n     match sctable.table[ctxt] {\n         ast::Mark(mrk,_) => mrk,\n-        _ => fail!(\"can't retrieve outer mark when outside is not a mark\")\n+        _ => fail2!(\"can't retrieve outer mark when outside is not a mark\")\n     }\n }\n \n@@ -1064,7 +1064,7 @@ mod test {\n                     sc = tail;\n                     loop;\n                 }\n-                IllegalCtxt => fail!(\"expected resolvable context, got IllegalCtxt\")\n+                IllegalCtxt => fail2!(\"expected resolvable context, got IllegalCtxt\")\n             }\n         }\n     }"}, {"sha": "31905f6ccc7aa9e957d9eec4a44be42cb8d58a25", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=af3b132285bc9314d545cae2e4eaef079a26252a", "patch": "@@ -168,17 +168,17 @@ pub fn mk_sugared_doc_attr(text: @str, lo: BytePos, hi: BytePos) -> Attribute {\n /// span included in the `==` comparison a plain MetaItem.\n pub fn contains(haystack: &[@ast::MetaItem],\n                 needle: @ast::MetaItem) -> bool {\n-    debug!(\"attr::contains (name=%s)\", needle.name());\n+    debug2!(\"attr::contains (name={})\", needle.name());\n     do haystack.iter().any |item| {\n-        debug!(\"  testing: %s\", item.name());\n+        debug2!(\"  testing: {}\", item.name());\n         item.node == needle.node\n     }\n }\n \n pub fn contains_name<AM: AttrMetaMethods>(metas: &[AM], name: &str) -> bool {\n-    debug!(\"attr::contains_name (name=%s)\", name);\n+    debug2!(\"attr::contains_name (name={})\", name);\n     do metas.iter().any |item| {\n-        debug!(\"  testing: %s\", item.name());\n+        debug2!(\"  testing: {}\", item.name());\n         name == item.name()\n     }\n }\n@@ -279,23 +279,23 @@ pub fn test_cfg<AM: AttrMetaMethods, It: Iterator<AM>>\n     // this would be much nicer as a chain of iterator adaptors, but\n     // this doesn't work.\n     let some_cfg_matches = do metas.any |mi| {\n-        debug!(\"testing name: %s\", mi.name());\n+        debug2!(\"testing name: {}\", mi.name());\n         if \"cfg\" == mi.name() { // it is a #[cfg()] attribute\n-            debug!(\"is cfg\");\n+            debug2!(\"is cfg\");\n             no_cfgs = false;\n              // only #[cfg(...)] ones are understood.\n             match mi.meta_item_list() {\n                 Some(cfg_meta) => {\n-                    debug!(\"is cfg(...)\");\n+                    debug2!(\"is cfg(...)\");\n                     do cfg_meta.iter().all |cfg_mi| {\n-                        debug!(\"cfg(%s[...])\", cfg_mi.name());\n+                        debug2!(\"cfg({}[...])\", cfg_mi.name());\n                         match cfg_mi.node {\n                             ast::MetaList(s, ref not_cfgs) if \"not\" == s => {\n-                                debug!(\"not!\");\n+                                debug2!(\"not!\");\n                                 // inside #[cfg(not(...))], so these need to all\n                                 // not match.\n                                 not_cfgs.iter().all(|mi| {\n-                                    debug!(\"cfg(not(%s[...]))\", mi.name());\n+                                    debug2!(\"cfg(not({}[...]))\", mi.name());\n                                     !contains(cfg, *mi)\n                                 })\n                             }\n@@ -309,7 +309,7 @@ pub fn test_cfg<AM: AttrMetaMethods, It: Iterator<AM>>\n             false\n         }\n     };\n-    debug!(\"test_cfg (no_cfgs=%?, some_cfg_matches=%?)\", no_cfgs, some_cfg_matches);\n+    debug2!(\"test_cfg (no_cfgs={}, some_cfg_matches={})\", no_cfgs, some_cfg_matches);\n     no_cfgs || some_cfg_matches\n }\n \n@@ -359,7 +359,7 @@ pub fn require_unique_names(diagnostic: @mut span_handler,\n \n         if !set.insert(name) {\n             diagnostic.span_fatal(meta.span,\n-                                  fmt!(\"duplicate meta item `%s`\", name));\n+                                  format!(\"duplicate meta item `{}`\", name));\n         }\n     }\n }"}, {"sha": "de8f45c880d2acd160c3112b4d11780215d1ae8c", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=af3b132285bc9314d545cae2e4eaef079a26252a", "patch": "@@ -290,7 +290,7 @@ impl CodeMap {\n \n     pub fn mk_substr_filename(&self, sp: Span) -> ~str {\n         let pos = self.lookup_char_pos(sp.lo);\n-        return fmt!(\"<%s:%u:%u>\", pos.file.name,\n+        return format!(\"<{}:{}:{}>\", pos.file.name,\n                     pos.line, pos.col.to_uint());\n     }\n \n@@ -336,7 +336,7 @@ impl CodeMap {\n \n         let lo = self.lookup_char_pos_adj(sp.lo);\n         let hi = self.lookup_char_pos_adj(sp.hi);\n-        return fmt!(\"%s:%u:%u: %u:%u\", lo.filename,\n+        return format!(\"{}:{}:{}: {}:{}\", lo.filename,\n                     lo.line, lo.col.to_uint(), hi.line, hi.col.to_uint())\n     }\n \n@@ -374,7 +374,7 @@ impl CodeMap {\n         for fm in self.files.iter() { if filename == fm.name { return *fm; } }\n         //XXjdm the following triggers a mismatched type bug\n         //      (or expected function, found _|_)\n-        fail!(); // (\"asking for \" + filename + \" which we don't know about\");\n+        fail2!(); // (\"asking for \" + filename + \" which we don't know about\");\n     }\n }\n \n@@ -393,7 +393,7 @@ impl CodeMap {\n             }\n         }\n         if (a >= len) {\n-            fail!(\"position %u does not resolve to a source location\", pos.to_uint())\n+            fail2!(\"position {} does not resolve to a source location\", pos.to_uint())\n         }\n \n         return a;\n@@ -419,11 +419,11 @@ impl CodeMap {\n         let chpos = self.bytepos_to_local_charpos(pos);\n         let linebpos = f.lines[a];\n         let linechpos = self.bytepos_to_local_charpos(linebpos);\n-        debug!(\"codemap: byte pos %? is on the line at byte pos %?\",\n+        debug2!(\"codemap: byte pos {:?} is on the line at byte pos {:?}\",\n                pos, linebpos);\n-        debug!(\"codemap: char pos %? is on the line at char pos %?\",\n+        debug2!(\"codemap: char pos {:?} is on the line at char pos {:?}\",\n                chpos, linechpos);\n-        debug!(\"codemap: byte is on line: %?\", line);\n+        debug2!(\"codemap: byte is on line: {:?}\", line);\n         assert!(chpos >= linechpos);\n         return Loc {\n             file: f,\n@@ -435,7 +435,7 @@ impl CodeMap {\n     fn span_to_str_no_adj(&self, sp: Span) -> ~str {\n         let lo = self.lookup_char_pos(sp.lo);\n         let hi = self.lookup_char_pos(sp.hi);\n-        return fmt!(\"%s:%u:%u: %u:%u\", lo.file.name,\n+        return format!(\"{}:{}:{}: {}:{}\", lo.file.name,\n                     lo.line, lo.col.to_uint(), hi.line, hi.col.to_uint())\n     }\n \n@@ -450,15 +450,15 @@ impl CodeMap {\n     // Converts an absolute BytePos to a CharPos relative to the file it is\n     // located in\n     fn bytepos_to_local_charpos(&self, bpos: BytePos) -> CharPos {\n-        debug!(\"codemap: converting %? to char pos\", bpos);\n+        debug2!(\"codemap: converting {:?} to char pos\", bpos);\n         let idx = self.lookup_filemap_idx(bpos);\n         let map = self.files[idx];\n \n         // The number of extra bytes due to multibyte chars in the FileMap\n         let mut total_extra_bytes = 0;\n \n         for mbc in map.multibyte_chars.iter() {\n-            debug!(\"codemap: %?-byte char at %?\", mbc.bytes, mbc.pos);\n+            debug2!(\"codemap: {:?}-byte char at {:?}\", mbc.bytes, mbc.pos);\n             if mbc.pos < bpos {\n                 total_extra_bytes += mbc.bytes;\n                 // We should never see a byte position in the middle of a"}, {"sha": "03b47f89ab6cdca5cb37544e215aa12ca5a9b31b", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=af3b132285bc9314d545cae2e4eaef079a26252a", "patch": "@@ -69,7 +69,7 @@ struct CodemapT {\n impl span_handler for CodemapT {\n     fn span_fatal(@mut self, sp: Span, msg: &str) -> ! {\n         self.handler.emit(Some((self.cm, sp)), msg, fatal);\n-        fail!();\n+        fail2!();\n     }\n     fn span_err(@mut self, sp: Span, msg: &str) {\n         self.handler.emit(Some((self.cm, sp)), msg, error);\n@@ -95,7 +95,7 @@ impl span_handler for CodemapT {\n impl handler for HandlerT {\n     fn fatal(@mut self, msg: &str) -> ! {\n         self.emit.emit(None, msg, fatal);\n-        fail!();\n+        fail2!();\n     }\n     fn err(@mut self, msg: &str) {\n         self.emit.emit(None, msg, error);\n@@ -116,7 +116,7 @@ impl handler for HandlerT {\n           0u => return,\n           1u => s = ~\"aborting due to previous error\",\n           _  => {\n-            s = fmt!(\"aborting due to %u previous errors\",\n+            s = format!(\"aborting due to {} previous errors\",\n                      self.err_count);\n           }\n         }\n@@ -143,7 +143,7 @@ impl handler for HandlerT {\n }\n \n pub fn ice_msg(msg: &str) -> ~str {\n-    fmt!(\"internal compiler error: %s\", msg)\n+    format!(\"internal compiler error: {}\", msg)\n }\n \n pub fn mk_span_handler(handler: @mut handler, cm: @codemap::CodeMap)\n@@ -228,12 +228,12 @@ fn print_diagnostic(topic: &str, lvl: level, msg: &str) {\n     let stderr = io::stderr();\n \n     if !topic.is_empty() {\n-        stderr.write_str(fmt!(\"%s \", topic));\n+        stderr.write_str(format!(\"{} \", topic));\n     }\n \n-    print_maybe_styled(fmt!(\"%s: \", diagnosticstr(lvl)),\n+    print_maybe_styled(format!(\"{}: \", diagnosticstr(lvl)),\n                             term::attr::ForegroundColor(diagnosticcolor(lvl)));\n-    print_maybe_styled(fmt!(\"%s\\n\", msg), term::attr::Bold);\n+    print_maybe_styled(format!(\"{}\\n\", msg), term::attr::Bold);\n }\n \n pub struct DefaultEmitter;\n@@ -273,13 +273,13 @@ fn highlight_lines(cm: @codemap::CodeMap,\n     }\n     // Print the offending lines\n     for line in display_lines.iter() {\n-        io::stderr().write_str(fmt!(\"%s:%u \", fm.name, *line + 1u));\n+        io::stderr().write_str(format!(\"{}:{} \", fm.name, *line + 1u));\n         let s = fm.get_line(*line as int) + \"\\n\";\n         io::stderr().write_str(s);\n     }\n     if elided {\n         let last_line = display_lines[display_lines.len() - 1u];\n-        let s = fmt!(\"%s:%u \", fm.name, last_line + 1u);\n+        let s = format!(\"{}:{} \", fm.name, last_line + 1u);\n         let mut indent = s.len();\n         let mut out = ~\"\";\n         while indent > 0u {\n@@ -339,7 +339,7 @@ fn print_macro_backtrace(cm: @codemap::CodeMap, sp: Span) {\n     for ei in sp.expn_info.iter() {\n         let ss = ei.callee.span.map_default(~\"\", |span| cm.span_to_str(*span));\n         print_diagnostic(ss, note,\n-                         fmt!(\"in expansion of %s!\", ei.callee.name));\n+                         format!(\"in expansion of {}!\", ei.callee.name));\n         let ss = cm.span_to_str(ei.call_site);\n         print_diagnostic(ss, note, \"expansion site\");\n         print_macro_backtrace(cm, ei.call_site);"}, {"sha": "9241e8c4fbcb1a5df6e9e19650a1b6c220be4439", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=af3b132285bc9314d545cae2e4eaef079a26252a", "patch": "@@ -111,7 +111,7 @@ pub fn expand_asm(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n                         p.eat(&token::COMMA);\n                     }\n \n-                    let clob = fmt!(\"~{%s}\", p.parse_str());\n+                    let clob = format!(\"~\\\\{{}\\\\}\", p.parse_str());\n                     clobs.push(clob);\n                 }\n "}, {"sha": "3b4be1de3e81b34c69967cc565ea9318e2741f34", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=af3b132285bc9314d545cae2e4eaef079a26252a", "patch": "@@ -423,7 +423,7 @@ pub fn expr_to_str(cx: @ExtCtxt, expr: @ast::Expr, err_msg: &str) -> @str {\n pub fn check_zero_tts(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree],\n                       name: &str) {\n     if tts.len() != 0 {\n-        cx.span_fatal(sp, fmt!(\"%s takes no arguments\", name));\n+        cx.span_fatal(sp, format!(\"{} takes no arguments\", name));\n     }\n }\n \n@@ -433,12 +433,12 @@ pub fn get_single_str_from_tts(cx: @ExtCtxt,\n                                name: &str)\n                                -> @str {\n     if tts.len() != 1 {\n-        cx.span_fatal(sp, fmt!(\"%s takes 1 argument.\", name));\n+        cx.span_fatal(sp, format!(\"{} takes 1 argument.\", name));\n     }\n \n     match tts[0] {\n         ast::tt_tok(_, token::LIT_STR(ident)) => cx.str_of(ident),\n-        _ => cx.span_fatal(sp, fmt!(\"%s requires a string.\", name)),\n+        _ => cx.span_fatal(sp, format!(\"{} requires a string.\", name)),\n     }\n }\n \n@@ -539,11 +539,11 @@ impl <K: Eq + Hash + IterBytes + 'static, V: 'static> MapChain<K,V>{\n     // names? I think not.\n     // delaying implementing this....\n     pub fn each_key (&self, _f: &fn (&K)->bool) {\n-        fail!(\"unimplemented 2013-02-15T10:01\");\n+        fail2!(\"unimplemented 2013-02-15T10:01\");\n     }\n \n     pub fn each_value (&self, _f: &fn (&V) -> bool) {\n-        fail!(\"unimplemented 2013-02-15T10:02\");\n+        fail2!(\"unimplemented 2013-02-15T10:02\");\n     }\n \n     // Returns a copy of the value that the name maps to.\n@@ -586,7 +586,7 @@ impl <K: Eq + Hash + IterBytes + 'static, V: 'static> MapChain<K,V>{\n                 if satisfies_pred(map,&n,pred) {\n                     map.insert(key,ext);\n                 } else {\n-                    fail!(~\"expected map chain containing satisfying frame\")\n+                    fail2!(\"expected map chain containing satisfying frame\")\n                 }\n             },\n             ConsMapChain (~ref mut map, rest) => {"}, {"sha": "5b107a49175ad003d49241c842ef22b937865ee7", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=af3b132285bc9314d545cae2e4eaef079a26252a", "patch": "@@ -86,10 +86,10 @@ fn cs_clone(\n             all_fields = af;\n         },\n         EnumNonMatching(*) => cx.span_bug(span,\n-                                          fmt!(\"Non-matching enum variants in `deriving(%s)`\",\n+                                          format!(\"Non-matching enum variants in `deriving({})`\",\n                                                name)),\n         StaticEnum(*) | StaticStruct(*) => cx.span_bug(span,\n-                                                       fmt!(\"Static method in `deriving(%s)`\",\n+                                                       format!(\"Static method in `deriving({})`\",\n                                                             name))\n     }\n \n@@ -105,7 +105,7 @@ fn cs_clone(\n                 let ident = match o_id {\n                     Some(i) => i,\n                     None => cx.span_bug(span,\n-                                        fmt!(\"unnamed field in normal struct in `deriving(%s)`\",\n+                                        format!(\"unnamed field in normal struct in `deriving({})`\",\n                                              name))\n                 };\n                 cx.field_imm(span, ident, subcall(self_f))"}, {"sha": "91fe71c54145e5c4eda539c34d46d833482c78e9", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=af3b132285bc9314d545cae2e4eaef079a26252a", "patch": "@@ -84,7 +84,7 @@ fn decodable_substructure(cx: @ExtCtxt, span: Span,\n                     } else {\n                         let mut fields = vec::with_capacity(n);\n                         for i in range(0, n) {\n-                            fields.push(getarg(fmt!(\"_field%u\", i).to_managed(), i));\n+                            fields.push(getarg(format!(\"_field{}\", i).to_managed(), i));\n                         }\n                         cx.expr_call_ident(span, substr.type_ident, fields)\n                     }"}, {"sha": "d1c436c045d2b4cb66c71154c94e0da13a17c197", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=af3b132285bc9314d545cae2e4eaef079a26252a", "patch": "@@ -125,7 +125,7 @@ fn encodable_substructure(cx: @ExtCtxt, span: Span,\n             for (i, f) in fields.iter().enumerate() {\n                 let (name, val) = match *f {\n                     (Some(id), e, _) => (cx.str_of(id), e),\n-                    (None, e, _) => (fmt!(\"_field%u\", i).to_managed(), e)\n+                    (None, e, _) => (format!(\"_field{}\", i).to_managed(), e)\n                 };\n                 let enc = cx.expr_method_call(span, val, encode, ~[blkencoder]);\n                 let lambda = cx.lambda_expr_1(span, enc, blkarg);"}, {"sha": "f5e45eec7e0365924baab62ee01a38cccd397011", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=af3b132285bc9314d545cae2e4eaef079a26252a", "patch": "@@ -487,7 +487,7 @@ impl<'self> MethodDef<'self> {\n \n         for (i, ty) in self.args.iter().enumerate() {\n             let ast_ty = ty.to_ty(cx, span, type_ident, generics);\n-            let ident = cx.ident_of(fmt!(\"__arg_%u\", i));\n+            let ident = cx.ident_of(format!(\"__arg_{}\", i));\n             arg_tys.push((ident, ast_ty));\n \n             let arg_expr = cx.expr_ident(span, ident);\n@@ -582,7 +582,8 @@ impl<'self> MethodDef<'self> {\n         for i in range(0u, self_args.len()) {\n             let (pat, ident_expr) = create_struct_pattern(cx, span,\n                                                           type_ident, struct_def,\n-                                                          fmt!(\"__self_%u\", i), ast::MutImmutable);\n+                                                          format!(\"__self_{}\", i),\n+                                                          ast::MutImmutable);\n             patterns.push(pat);\n             raw_fields.push(ident_expr);\n         }\n@@ -767,7 +768,7 @@ impl<'self> MethodDef<'self> {\n             let current_match_str = if match_count == 0 {\n                 ~\"__self\"\n             } else {\n-                fmt!(\"__arg_%u\", match_count)\n+                format!(\"__arg_{}\", match_count)\n             };\n \n             let mut arms = ~[];\n@@ -948,7 +949,7 @@ fn create_struct_pattern(cx: @ExtCtxt,\n             }\n         };\n         let path = cx.path_ident(span,\n-                                 cx.ident_of(fmt!(\"%s_%u\", prefix, i)));\n+                                 cx.ident_of(format!(\"{}_{}\", prefix, i)));\n         paths.push(path.clone());\n         ident_expr.push((opt_id, cx.expr_path(path)));\n     }\n@@ -993,7 +994,7 @@ fn create_enum_variant_pattern(cx: @ExtCtxt,\n             let mut ident_expr = ~[];\n             for i in range(0u, variant_args.len()) {\n                 let path = cx.path_ident(span,\n-                                         cx.ident_of(fmt!(\"%s_%u\", prefix, i)));\n+                                         cx.ident_of(format!(\"{}_{}\", prefix, i)));\n \n                 paths.push(path.clone());\n                 ident_expr.push((None, cx.expr_path(path)));"}, {"sha": "a428c6704f9642077be8b6d16e63a74b6d100103", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=af3b132285bc9314d545cae2e4eaef079a26252a", "patch": "@@ -101,8 +101,8 @@ pub fn expand_meta_deriving(cx: @ExtCtxt,\n                             \"Default\" => expand!(default::expand_deriving_default),\n \n                             ref tname => {\n-                                cx.span_err(titem.span, fmt!(\"unknown \\\n-                                    `deriving` trait: `%s`\", *tname));\n+                                cx.span_err(titem.span, format!(\"unknown \\\n+                                    `deriving` trait: `{}`\", *tname));\n                                 in_items\n                             }\n                         }"}, {"sha": "63a45b06e164472c565bc8e7343c89fee44ed426", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=af3b132285bc9314d545cae2e4eaef079a26252a", "patch": "@@ -43,7 +43,7 @@ pub fn expand_env(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n \n     let var = expr_to_str(cx, exprs[0], \"expected string literal\");\n     let msg = match exprs.len() {\n-        1 => fmt!(\"Environment variable %s not defined\", var).to_managed(),\n+        1 => format!(\"Environment variable {} not defined\", var).to_managed(),\n         2 => expr_to_str(cx, exprs[1], \"expected string literal\"),\n         _ => cx.span_fatal(sp, \"env! takes 1 or 2 arguments\")\n     };"}, {"sha": "e8307bf578698844837a4de950df4e2b5076e4df", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 47, "deletions": 46, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=af3b132285bc9314d545cae2e4eaef079a26252a", "patch": "@@ -51,7 +51,7 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                     if (pth.segments.len() > 1u) {\n                         cx.span_fatal(\n                             pth.span,\n-                            fmt!(\"expected macro name without module \\\n+                            format!(\"expected macro name without module \\\n                                   separators\"));\n                     }\n                     let extname = &pth.segments[0].identifier;\n@@ -61,7 +61,7 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                         None => {\n                             cx.span_fatal(\n                                 pth.span,\n-                                fmt!(\"macro undefined: '%s'\", extnamestr))\n+                                format!(\"macro undefined: '{}'\", extnamestr))\n                         }\n                         Some(@SE(NormalTT(expandfun, exp_span))) => {\n                             cx.bt_push(ExpnInfo {\n@@ -92,8 +92,8 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                                     _ => {\n                                         cx.span_fatal(\n                                             pth.span,\n-                                            fmt!(\n-                                                \"non-expr macro in expr pos: %s\",\n+                                            format!(\n+                                                \"non-expr macro in expr pos: {}\",\n                                                 extnamestr\n                                             )\n                                         )\n@@ -119,7 +119,7 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                         _ => {\n                             cx.span_fatal(\n                                 pth.span,\n-                                fmt!(\"'%s' is not a tt-style macro\", extnamestr)\n+                                format!(\"'{}' is not a tt-style macro\", extnamestr)\n                             )\n                         }\n                     }\n@@ -353,13 +353,13 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n     let fm = fresh_mark();\n     let expanded = match (*extsbox).find(&extname.name) {\n         None => cx.span_fatal(pth.span,\n-                              fmt!(\"macro undefined: '%s!'\", extnamestr)),\n+                              format!(\"macro undefined: '{}!'\", extnamestr)),\n \n         Some(@SE(NormalTT(expander, span))) => {\n             if it.ident.name != parse::token::special_idents::invalid.name {\n                 cx.span_fatal(pth.span,\n-                              fmt!(\"macro %s! expects no ident argument, \\\n-                                    given '%s'\", extnamestr,\n+                              format!(\"macro {}! expects no ident argument, \\\n+                                    given '{}'\", extnamestr,\n                                    ident_to_str(&it.ident)));\n             }\n             cx.bt_push(ExpnInfo {\n@@ -377,7 +377,7 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n         Some(@SE(IdentTT(expander, span))) => {\n             if it.ident.name == parse::token::special_idents::invalid.name {\n                 cx.span_fatal(pth.span,\n-                              fmt!(\"macro %s! expects an ident argument\",\n+                              format!(\"macro {}! expects an ident argument\",\n                                    extnamestr));\n             }\n             cx.bt_push(ExpnInfo {\n@@ -393,7 +393,7 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n             expander.expand(cx, it.span, it.ident, marked_tts, marked_ctxt)\n         }\n         _ => cx.span_fatal(\n-            it.span, fmt!(\"%s! is not legal in item position\", extnamestr))\n+            it.span, format!(\"{}! is not legal in item position\", extnamestr))\n     };\n \n     let maybe_it = match expanded {\n@@ -402,7 +402,7 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n                 .and_then(|i| fld.fold_item(i))\n         }\n         MRExpr(_) => {\n-            cx.span_fatal(pth.span, fmt!(\"expr macro in item position: %s\", extnamestr))\n+            cx.span_fatal(pth.span, format!(\"expr macro in item position: {}\", extnamestr))\n         }\n         MRAny(any_macro) => {\n             any_macro.make_item()\n@@ -429,8 +429,8 @@ fn insert_macro(exts: SyntaxEnv, name: ast::Name, transformer: @Transformer) {\n         match t {\n             &@BlockInfo(BlockInfo {macros_escape:false,_}) => true,\n             &@BlockInfo(BlockInfo {_}) => false,\n-            _ => fail!(fmt!(\"special identifier %? was bound to a non-BlockInfo\",\n-                            special_block_name))\n+            _ => fail2!(\"special identifier {:?} was bound to a non-BlockInfo\",\n+                        special_block_name)\n         }\n     };\n     exts.insert_into_frame(name,transformer,intern(special_block_name),\n@@ -463,7 +463,7 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n     let extnamestr = ident_to_str(extname);\n     let fully_expanded: @ast::Stmt = match (*extsbox).find(&extname.name) {\n         None => {\n-            cx.span_fatal(pth.span, fmt!(\"macro undefined: '%s'\", extnamestr))\n+            cx.span_fatal(pth.span, format!(\"macro undefined: '{}'\", extnamestr))\n         }\n \n         Some(@SE(NormalTT(expandfun, exp_span))) => {\n@@ -496,7 +496,7 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n                 MRAny(any_macro) => any_macro.make_stmt(),\n                 _ => cx.span_fatal(\n                     pth.span,\n-                    fmt!(\"non-stmt macro in stmt pos: %s\", extnamestr))\n+                    format!(\"non-stmt macro in stmt pos: {}\", extnamestr))\n             };\n             let marked_after = mark_stmt(expanded,fm);\n \n@@ -521,7 +521,7 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n \n         _ => {\n             cx.span_fatal(pth.span,\n-                          fmt!(\"'%s' is not a tt-style macro\", extnamestr))\n+                          format!(\"'{}' is not a tt-style macro\", extnamestr))\n         }\n     };\n \n@@ -741,16 +741,16 @@ pub fn expand_block_elts(exts: SyntaxEnv, b: &Block, fld: &MacroExpander)\n fn mustbesome<T>(val : Option<T>) -> T {\n     match val {\n         Some(v) => v,\n-        None => fail!(\"rename_fold returned None\")\n+        None => fail2!(\"rename_fold returned None\")\n     }\n }\n \n // get the (innermost) BlockInfo from an exts stack\n fn get_block_info(exts : SyntaxEnv) -> BlockInfo {\n     match exts.find_in_topmost_frame(&intern(special_block_name)) {\n         Some(@BlockInfo(bi)) => bi,\n-        _ => fail!(fmt!(\"special identifier %? was bound to a non-BlockInfo\",\n-                       @\" block\"))\n+        _ => fail2!(\"special identifier {:?} was bound to a non-BlockInfo\",\n+                    @\" block\")\n     }\n }\n \n@@ -782,7 +782,7 @@ pub fn renames_to_fold(renames: @mut ~[(ast::Ident,ast::Name)]) -> @ast_fold {\n fn apply_pending_renames(folder : @ast_fold, stmt : ast::Stmt) -> @ast::Stmt {\n     match folder.fold_stmt(&stmt) {\n         Some(s) => s,\n-        None => fail!(fmt!(\"renaming of stmt produced None\"))\n+        None => fail2!(\"renaming of stmt produced None\")\n     }\n }\n \n@@ -813,23 +813,23 @@ pub fn std_macros() -> @str {\n     mod fmt_extension {\n         #[macro_escape];\n \n-        macro_rules! fmt(($($arg:tt)*) => (oldfmt!($($arg)*)))\n+        macro_rules! fmt(($($arg:tt)*) => (oldformat!($($arg)*)))\n \n         macro_rules! log(\n             ($lvl:expr, $arg:expr) => ({\n                 let lvl = $lvl;\n                 if lvl <= __log_level() {\n                     format_args!(|args| {\n                         ::std::logging::log(lvl, args)\n-                    }, \\\"{}\\\", fmt!(\\\"%?\\\", $arg))\n+                    }, \\\"{}\\\", format!(\\\"{:?}\\\", $arg))\n                 }\n             });\n             ($lvl:expr, $($arg:expr),+) => ({\n                 let lvl = $lvl;\n                 if lvl <= __log_level() {\n                     format_args!(|args| {\n                         ::std::logging::log(lvl, args)\n-                    }, \\\"{}\\\", fmt!($($arg),+))\n+                    }, \\\"{}\\\", format!($($arg),+))\n                 }\n             })\n         )\n@@ -842,13 +842,13 @@ pub fn std_macros() -> @str {\n \n         macro_rules! fail(\n             () => (\n-                fail!(\\\"explicit failure\\\")\n+                fail2!(\\\"explicit failure\\\")\n             );\n             ($msg:expr) => (\n                 ::std::sys::FailWithCause::fail_with($msg, file!(), line!())\n             );\n             ($( $arg:expr ),+) => (\n-                ::std::sys::FailWithCause::fail_with(fmt!( $($arg),+ ), file!(), line!())\n+                ::std::sys::FailWithCause::fail_with(format!( $($arg),+ ), file!(), line!())\n             )\n         )\n     }\n@@ -896,7 +896,7 @@ pub fn std_macros() -> @str {\n         };\n         ($cond:expr, $( $arg:expr ),+) => {\n             if !$cond {\n-                ::std::sys::FailWithCause::fail_with(fmt!( $($arg),+ ), file!(), line!())\n+                ::std::sys::FailWithCause::fail_with(format!( $($arg),+ ), file!(), line!())\n             }\n         }\n     )\n@@ -1164,7 +1164,7 @@ pub fn inject_std_macros(parse_sess: @mut parse::ParseSess,\n                                               ~[],\n                                               parse_sess) {\n         Some(item) => item,\n-        None => fail!(\"expected core macros to parse correctly\")\n+        None => fail2!(\"expected core macros to parse correctly\")\n     };\n \n     let injector = @Injector {\n@@ -1422,16 +1422,16 @@ mod test {\n     use util::parser_testing::{string_to_pat, string_to_tts, strs_to_idents};\n     use visit;\n \n-    // make sure that fail! is present\n+    // make sure that fail2! is present\n     #[test] fn fail_exists_test () {\n-        let src = @\"fn main() { fail!(\\\"something appropriately gloomy\\\");}\";\n+        let src = @\"fn main() { fail2!(\\\"something appropriately gloomy\\\");}\";\n         let sess = parse::new_parse_sess(None);\n         let crate_ast = parse::parse_crate_from_source_str(\n             @\"<test>\",\n             src,\n             ~[],sess);\n         let crate_ast = inject_std_macros(sess, ~[], crate_ast);\n-        // don't bother with striping, doesn't affect fail!.\n+        // don't bother with striping, doesn't affect fail2!.\n         expand_crate(sess,~[],crate_ast);\n     }\n \n@@ -1489,7 +1489,7 @@ mod test {\n             cfg,~[],sess);\n         match item_ast {\n             Some(_) => (), // success\n-            None => fail!(\"expected this to parse\")\n+            None => fail2!(\"expected this to parse\")\n         }\n     }\n \n@@ -1528,15 +1528,15 @@ mod test {\n         let marked_once_ctxt =\n             match marked_once[0] {\n                 ast::tt_tok(_,token::IDENT(id,_)) => id.ctxt,\n-                _ => fail!(fmt!(\"unexpected shape for marked tts: %?\",marked_once[0]))\n+                _ => fail2!(format!(\"unexpected shape for marked tts: {:?}\",marked_once[0]))\n             };\n         assert_eq!(mtwt_marksof(marked_once_ctxt,invalid_name),~[fm]);\n         let remarked = mtwt_cancel_outer_mark(marked_once,marked_once_ctxt);\n         assert_eq!(remarked.len(),1);\n         match remarked[0] {\n             ast::tt_tok(_,token::IDENT(id,_)) =>\n             assert_eq!(mtwt_marksof(id.ctxt,invalid_name),~[]),\n-            _ => fail!(fmt!(\"unexpected shape for marked tts: %?\",remarked[0]))\n+            _ => fail2!(format!(\"unexpected shape for marked tts: {:?}\",remarked[0]))\n         }\n     }\n \n@@ -1583,7 +1583,7 @@ mod test {\n \n     //fn expand_and_resolve(crate_str: @str) -> ast::crate {\n         //let expanded_ast = expand_crate_str(crate_str);\n-        // std::io::println(fmt!(\"expanded: %?\\n\",expanded_ast));\n+        // std::io::println(format!(\"expanded: {:?}\\n\",expanded_ast));\n         //mtwt_resolve_crate(expanded_ast)\n     //}\n     //fn expand_and_resolve_and_pretty_print (crate_str : @str) -> ~str {\n@@ -1693,8 +1693,8 @@ mod test {\n                                                     invalid_name);\n                     if (!(varref_name==binding_name)){\n                         std::io::println(\"uh oh, should match but doesn't:\");\n-                        std::io::println(fmt!(\"varref: %?\",varref));\n-                        std::io::println(fmt!(\"binding: %?\", bindings[binding_idx]));\n+                        std::io::println(format!(\"varref: {:?}\",varref));\n+                        std::io::println(format!(\"binding: {:?}\", bindings[binding_idx]));\n                         ast_util::display_sctable(get_sctable());\n                     }\n                     assert_eq!(varref_name,binding_name);\n@@ -1712,12 +1712,12 @@ mod test {\n                         println!(\"text of test case: \\\"{}\\\"\", teststr);\n                         println!(\"\");\n                         println!(\"uh oh, matches but shouldn't:\");\n-                        std::io::println(fmt!(\"varref: %?\",varref));\n+                        std::io::println(format!(\"varref: {:?}\",varref));\n                         // good lord, you can't make a path with 0 segments, can you?\n                         println!(\"varref's first segment's uint: {}, and string: \\\"{}\\\"\",\n                                  varref.segments[0].identifier.name,\n                                  ident_to_str(&varref.segments[0].identifier));\n-                        std::io::println(fmt!(\"binding: %?\", bindings[binding_idx]));\n+                        std::io::println(format!(\"binding: {:?}\", bindings[binding_idx]));\n                         ast_util::display_sctable(get_sctable());\n                     }\n                     assert!(!fail);\n@@ -1727,7 +1727,7 @@ mod test {\n     }\n \n     #[test] fn fmt_in_macro_used_inside_module_macro() {\n-        let crate_str = @\"macro_rules! fmt_wrap(($b:expr)=>(fmt!(\\\"left: %?\\\", $b)))\n+        let crate_str = @\"macro_rules! fmt_wrap(($b:expr)=>($b.to_str()))\n macro_rules! foo_module (() => (mod generated { fn a() { let xx = 147; fmt_wrap!(xx);}}))\n foo_module!()\n \";\n@@ -1739,7 +1739,7 @@ foo_module!()\n             bindings.iter().filter(|b|{@\"xx\" == (ident_to_str(*b))}).collect();\n         let cxbind = match cxbinds {\n             [b] => b,\n-            _ => fail!(\"expected just one binding for ext_cx\")\n+            _ => fail2!(\"expected just one binding for ext_cx\")\n         };\n         let resolved_binding = mtwt_resolve(*cxbind);\n         // find all the xx varrefs:\n@@ -1751,15 +1751,16 @@ foo_module!()\n                                      }).enumerate() {\n             if (mtwt_resolve(v.segments[0].identifier) != resolved_binding) {\n                 std::io::println(\"uh oh, xx binding didn't match xx varref:\");\n-                std::io::println(fmt!(\"this is xx varref # %?\",idx));\n-                std::io::println(fmt!(\"binding: %?\",cxbind));\n-                std::io::println(fmt!(\"resolves to: %?\",resolved_binding));\n-                std::io::println(fmt!(\"varref: %?\",v.segments[0].identifier));\n-                std::io::println(fmt!(\"resolves to: %?\",mtwt_resolve(v.segments[0].identifier)));\n+                std::io::println(format!(\"this is xx varref \\\\# {:?}\",idx));\n+                std::io::println(format!(\"binding: {:?}\",cxbind));\n+                std::io::println(format!(\"resolves to: {:?}\",resolved_binding));\n+                std::io::println(format!(\"varref: {:?}\",v.segments[0].identifier));\n+                std::io::println(format!(\"resolves to: {:?}\",\n+                                         mtwt_resolve(v.segments[0].identifier)));\n                 let table = get_sctable();\n                 std::io::println(\"SC table:\");\n                 for (idx,val) in table.table.iter().enumerate() {\n-                    std::io::println(fmt!(\"%4u : %?\",idx,val));\n+                    std::io::println(format!(\"{:4u} : {:?}\",idx,val));\n                 }\n             }\n             assert_eq!(mtwt_resolve(v.segments[0].identifier),resolved_binding);"}, {"sha": "cd364e7ad64a75e7e71ba834f5fd6e8e866ee991", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=af3b132285bc9314d545cae2e4eaef079a26252a", "patch": "@@ -34,7 +34,7 @@ pub fn expand_syntax_ext(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n         expr_to_str(cx, args[0],\n                     \"first argument to fmt! must be a string literal.\");\n     let fmtspan = args[0].span;\n-    debug!(\"Format string: %s\", fmt);\n+    debug2!(\"Format string: {}\", fmt);\n     fn parse_fmt_err_(cx: @ExtCtxt, sp: Span, msg: &str) -> ! {\n         cx.span_fatal(sp, msg);\n     }\n@@ -198,53 +198,53 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: Span,\n                               cx.expr_mut_addr_of(arg.span, buf));\n     }\n     fn log_conv(c: &Conv) {\n-        debug!(\"Building conversion:\");\n+        debug2!(\"Building conversion:\");\n         match c.param {\n-          Some(p) => { debug!(\"param: %s\", p.to_str()); }\n-          _ => debug!(\"param: none\")\n+          Some(p) => { debug2!(\"param: {}\", p.to_str()); }\n+          _ => debug2!(\"param: none\")\n         }\n         for f in c.flags.iter() {\n             match *f {\n-              FlagLeftJustify => debug!(\"flag: left justify\"),\n-              FlagLeftZeroPad => debug!(\"flag: left zero pad\"),\n-              FlagSpaceForSign => debug!(\"flag: left space pad\"),\n-              FlagSignAlways => debug!(\"flag: sign always\"),\n-              FlagAlternate => debug!(\"flag: alternate\")\n+              FlagLeftJustify => debug2!(\"flag: left justify\"),\n+              FlagLeftZeroPad => debug2!(\"flag: left zero pad\"),\n+              FlagSpaceForSign => debug2!(\"flag: left space pad\"),\n+              FlagSignAlways => debug2!(\"flag: sign always\"),\n+              FlagAlternate => debug2!(\"flag: alternate\")\n             }\n         }\n         match c.width {\n           CountIs(i) =>\n-              debug!(\"width: count is %s\", i.to_str()),\n+              debug2!(\"width: count is {}\", i.to_str()),\n           CountIsParam(i) =>\n-              debug!(\"width: count is param %s\", i.to_str()),\n-          CountIsNextParam => debug!(\"width: count is next param\"),\n-          CountImplied => debug!(\"width: count is implied\")\n+              debug2!(\"width: count is param {}\", i.to_str()),\n+          CountIsNextParam => debug2!(\"width: count is next param\"),\n+          CountImplied => debug2!(\"width: count is implied\")\n         }\n         match c.precision {\n           CountIs(i) =>\n-              debug!(\"prec: count is %s\", i.to_str()),\n+              debug2!(\"prec: count is {}\", i.to_str()),\n           CountIsParam(i) =>\n-              debug!(\"prec: count is param %s\", i.to_str()),\n-          CountIsNextParam => debug!(\"prec: count is next param\"),\n-          CountImplied => debug!(\"prec: count is implied\")\n+              debug2!(\"prec: count is param {}\", i.to_str()),\n+          CountIsNextParam => debug2!(\"prec: count is next param\"),\n+          CountImplied => debug2!(\"prec: count is implied\")\n         }\n         match c.ty {\n-          TyBool => debug!(\"type: bool\"),\n-          TyStr => debug!(\"type: str\"),\n-          TyChar => debug!(\"type: char\"),\n+          TyBool => debug2!(\"type: bool\"),\n+          TyStr => debug2!(\"type: str\"),\n+          TyChar => debug2!(\"type: char\"),\n           TyInt(s) => match s {\n-            Signed => debug!(\"type: signed\"),\n-            Unsigned => debug!(\"type: unsigned\")\n+            Signed => debug2!(\"type: signed\"),\n+            Unsigned => debug2!(\"type: unsigned\")\n           },\n-          TyBits => debug!(\"type: bits\"),\n+          TyBits => debug2!(\"type: bits\"),\n           TyHex(cs) => match cs {\n-            CaseUpper => debug!(\"type: uhex\"),\n-            CaseLower => debug!(\"type: lhex\"),\n+            CaseUpper => debug2!(\"type: uhex\"),\n+            CaseLower => debug2!(\"type: lhex\"),\n           },\n-          TyOctal => debug!(\"type: octal\"),\n-          TyFloat => debug!(\"type: float\"),\n-          TyPointer => debug!(\"type: pointer\"),\n-          TyPoly => debug!(\"type: poly\")\n+          TyOctal => debug2!(\"type: octal\"),\n+          TyFloat => debug2!(\"type: float\"),\n+          TyPointer => debug2!(\"type: pointer\"),\n+          TyPoly => debug2!(\"type: poly\")\n         }\n     }\n \n@@ -319,7 +319,7 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: Span,\n     let expected_nargs = n + 1u; // n conversions + the fmt string\n     if expected_nargs < nargs {\n         cx.span_fatal\n-            (sp, fmt!(\"too many arguments to fmt!. found %u, expected %u\",\n+            (sp, format!(\"too many arguments to fmt!. found {}, expected {}\",\n                            nargs, expected_nargs));\n     }\n "}, {"sha": "a9e5318db404245eb7d85611aa65077a32c6eefc", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=af3b132285bc9314d545cae2e4eaef079a26252a", "patch": "@@ -51,7 +51,7 @@ struct Context {\n \n impl Context {\n     /// Parses the arguments from the given list of tokens, returning None if\n-    /// there's a parse error so we can continue parsing other fmt! expressions.\n+    /// there's a parse error so we can continue parsing other format! expressions.\n     fn parse_args(&mut self, sp: Span,\n                   tts: &[ast::token_tree]) -> (@ast::Expr, Option<@ast::Expr>) {\n         let p = rsparse::new_parser_from_tts(self.ecx.parse_sess(),\n@@ -92,8 +92,8 @@ impl Context {\n                     }\n                     _ => {\n                         self.ecx.span_err(*p.span,\n-                                          fmt!(\"expected ident for named \\\n-                                                argument, but found `%s`\",\n+                                          format!(\"expected ident for named \\\n+                                                argument, but found `{}`\",\n                                                p.this_token_to_str()));\n                         return (extra, None);\n                     }\n@@ -104,8 +104,8 @@ impl Context {\n                 match self.names.find(&name) {\n                     None => {}\n                     Some(prev) => {\n-                        self.ecx.span_err(e.span, fmt!(\"duplicate argument \\\n-                                                        named `%s`\", name));\n+                        self.ecx.span_err(e.span, format!(\"duplicate argument \\\n+                                                        named `{}`\", name));\n                         self.ecx.parse_sess.span_diagnostic.span_note(\n                             prev.span, \"previously here\");\n                         loop\n@@ -207,13 +207,13 @@ impl Context {\n                         match arm.selector {\n                             Left(name) => {\n                                 self.ecx.span_err(self.fmtsp,\n-                                                  fmt!(\"duplicate selector \\\n-                                                       `%?`\", name));\n+                                                  format!(\"duplicate selector \\\n+                                                           `{:?}`\", name));\n                             }\n                             Right(idx) => {\n                                 self.ecx.span_err(self.fmtsp,\n-                                                  fmt!(\"duplicate selector \\\n-                                                       `=%u`\", idx));\n+                                                  format!(\"duplicate selector \\\n+                                                           `={}`\", idx));\n                             }\n                         }\n                     }\n@@ -227,7 +227,7 @@ impl Context {\n                 for arm in arms.iter() {\n                     if !seen_cases.insert(arm.selector) {\n                         self.ecx.span_err(self.fmtsp,\n-                                          fmt!(\"duplicate selector `%s`\",\n+                                          format!(\"duplicate selector `{}`\",\n                                                arm.selector));\n                     } else if arm.selector == \"\" {\n                         self.ecx.span_err(self.fmtsp,\n@@ -245,8 +245,8 @@ impl Context {\n         match arg {\n             Left(arg) => {\n                 if arg < 0 || self.args.len() <= arg {\n-                    let msg = fmt!(\"invalid reference to argument `%u` (there \\\n-                                    are %u arguments)\", arg, self.args.len());\n+                    let msg = format!(\"invalid reference to argument `{}` (there \\\n+                                    are {} arguments)\", arg, self.args.len());\n                     self.ecx.span_err(self.fmtsp, msg);\n                     return;\n                 }\n@@ -260,7 +260,7 @@ impl Context {\n                 let span = match self.names.find(&name) {\n                     Some(e) => e.span,\n                     None => {\n-                        let msg = fmt!(\"there is no argument named `%s`\", name);\n+                        let msg = format!(\"there is no argument named `{}`\", name);\n                         self.ecx.span_err(self.fmtsp, msg);\n                         return;\n                     }\n@@ -298,20 +298,20 @@ impl Context {\n         match (cur, ty) {\n             (Known(cur), Known(ty)) => {\n                 self.ecx.span_err(sp,\n-                                  fmt!(\"argument redeclared with type `%s` when \\\n-                                        it was previously `%s`\", ty, cur));\n+                                  format!(\"argument redeclared with type `{}` when \\\n+                                           it was previously `{}`\", ty, cur));\n             }\n             (Known(cur), _) => {\n                 self.ecx.span_err(sp,\n-                                  fmt!(\"argument used to format with `%s` was \\\n-                                        attempted to not be used for formatting\",\n-                                        cur));\n+                                  format!(\"argument used to format with `{}` was \\\n+                                           attempted to not be used for formatting\",\n+                                           cur));\n             }\n             (_, Known(ty)) => {\n                 self.ecx.span_err(sp,\n-                                  fmt!(\"argument previously used as a format \\\n-                                        argument attempted to be used as `%s`\",\n-                                        ty));\n+                                  format!(\"argument previously used as a format \\\n+                                           argument attempted to be used as `{}`\",\n+                                           ty));\n             }\n             (_, _) => {\n                 self.ecx.span_err(sp, \"argument declared with multiple formats\");\n@@ -405,7 +405,7 @@ impl Context {\n                         }).collect();\n                         let (lr, selarg) = match arm.selector {\n                             Left(t) => {\n-                                let p = ctpath(fmt!(\"%?\", t));\n+                                let p = ctpath(format!(\"{:?}\", t));\n                                 let p = self.ecx.path_global(sp, p);\n                                 (self.ecx.ident_of(\"Left\"),\n                                  self.ecx.expr_path(p))\n@@ -444,7 +444,7 @@ impl Context {\n                 ~[]\n             ), None);\n             let st = ast::item_static(ty, ast::MutImmutable, method);\n-            let static_name = self.ecx.ident_of(fmt!(\"__static_method_%u\",\n+            let static_name = self.ecx.ident_of(format!(\"__static_method_{}\",\n                                                      self.method_statics.len()));\n             // Flag these statics as `address_insignificant` so LLVM can\n             // merge duplicate globals as much as possible (which we're\n@@ -538,7 +538,7 @@ impl Context {\n         }\n     }\n \n-    /// Actually builds the expression which the ifmt! block will be expanded\n+    /// Actually builds the expression which the iformat! block will be expanded\n     /// to\n     fn to_expr(&self, extra: @ast::Expr) -> @ast::Expr {\n         let mut lets = ~[];\n@@ -584,13 +584,13 @@ impl Context {\n         //      foo(bar(&1))\n         // the lifetime of `1` doesn't outlast the call to `bar`, so it's not\n         // vald for the call to `foo`. To work around this all arguments to the\n-        // fmt! string are shoved into locals. Furthermore, we shove the address\n+        // format! string are shoved into locals. Furthermore, we shove the address\n         // of each variable because we don't want to move out of the arguments\n         // passed to this function.\n         for (i, &e) in self.args.iter().enumerate() {\n             if self.arg_types[i].is_none() { loop } // error already generated\n \n-            let name = self.ecx.ident_of(fmt!(\"__arg%u\", i));\n+            let name = self.ecx.ident_of(format!(\"__arg{}\", i));\n             let e = self.ecx.expr_addr_of(e.span, e);\n             lets.push(self.ecx.stmt_let(e.span, false, name, e));\n             locals.push(self.format_arg(e.span, Left(i),\n@@ -599,7 +599,7 @@ impl Context {\n         for (&name, &e) in self.names.iter() {\n             if !self.name_types.contains_key(&name) { loop }\n \n-            let lname = self.ecx.ident_of(fmt!(\"__arg%s\", name));\n+            let lname = self.ecx.ident_of(format!(\"__arg{}\", name));\n             let e = self.ecx.expr_addr_of(e.span, e);\n             lets.push(self.ecx.stmt_let(e.span, false, lname, e));\n             names[*self.name_positions.get(&name)] =\n@@ -662,8 +662,8 @@ impl Context {\n                     \"x\" => \"LowerHex\",\n                     \"X\" => \"UpperHex\",\n                     _ => {\n-                        self.ecx.span_err(sp, fmt!(\"unknown format trait \\\n-                                                    `%s`\", tyname));\n+                        self.ecx.span_err(sp, format!(\"unknown format trait \\\n+                                                       `{}`\", tyname));\n                         \"Dummy\"\n                     }\n                 }"}, {"sha": "24a5f9d5e3c8775b6ebeecd758af7295b8c21200", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=af3b132285bc9314d545cae2e4eaef079a26252a", "patch": "@@ -255,8 +255,8 @@ pub mod rt {\n             match res {\n                 Some(ast) => ast,\n                 None => {\n-                    error!(\"Parse error with ```\\n%s\\n```\", s);\n-                    fail!()\n+                    error2!(\"Parse error with ```\\n{}\\n```\", s);\n+                    fail2!()\n                 }\n             }\n         }\n@@ -484,7 +484,7 @@ fn mk_token(cx: @ExtCtxt, sp: Span, tok: &token::Token) -> @ast::Expr {\n                                       ~[mk_ident(cx, sp, ident)]);\n         }\n \n-        INTERPOLATED(_) => fail!(\"quote! with interpolated token\"),\n+        INTERPOLATED(_) => fail2!(\"quote! with interpolated token\"),\n \n         _ => ()\n     }\n@@ -522,7 +522,7 @@ fn mk_token(cx: @ExtCtxt, sp: Span, tok: &token::Token) -> @ast::Expr {\n         DOLLAR => \"DOLLAR\",\n         UNDERSCORE => \"UNDERSCORE\",\n         EOF => \"EOF\",\n-        _ => fail!()\n+        _ => fail2!()\n     };\n     cx.expr_ident(sp, id_ext(name))\n }\n@@ -547,7 +547,7 @@ fn mk_tt(cx: @ExtCtxt, sp: Span, tt: &ast::token_tree)\n         }\n \n         ast::tt_delim(ref tts) => mk_tts(cx, sp, **tts),\n-        ast::tt_seq(*) => fail!(\"tt_seq in quote!\"),\n+        ast::tt_seq(*) => fail2!(\"tt_seq in quote!\"),\n \n         ast::tt_nonterminal(sp, ident) => {\n "}, {"sha": "7db64feb809854e92fec357eb9f83e50011f6ce4", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=af3b132285bc9314d545cae2e4eaef079a26252a", "patch": "@@ -122,7 +122,7 @@ pub struct MatcherPos {\n pub fn copy_up(mpu: &matcher_pos_up) -> ~MatcherPos {\n     match *mpu {\n       matcher_pos_up(Some(ref mp)) => (*mp).clone(),\n-      _ => fail!()\n+      _ => fail2!()\n     }\n }\n \n@@ -384,14 +384,14 @@ pub fn parse(\n                 let nts = bb_eis.map(|ei| {\n                     match ei.elts[ei.idx].node {\n                       match_nonterminal(ref bind,ref name,_) => {\n-                        fmt!(\"%s ('%s')\", ident_to_str(name),\n+                        format!(\"{} ('{}')\", ident_to_str(name),\n                              ident_to_str(bind))\n                       }\n-                      _ => fail!()\n+                      _ => fail2!()\n                     } }).connect(\" or \");\n-                return error(sp, fmt!(\n+                return error(sp, format!(\n                     \"Local ambiguity: multiple parsing options: \\\n-                     built-in NTs %s or %u other options.\",\n+                     built-in NTs {} or {} other options.\",\n                     nts, next_eis.len()));\n             } else if (bb_eis.len() == 0u && next_eis.len() == 0u) {\n                 return failure(sp, ~\"No rules expected the token: \"\n@@ -412,7 +412,7 @@ pub fn parse(\n                         parse_nt(&rust_parser, ident_to_str(name))));\n                     ei.idx += 1u;\n                   }\n-                  _ => fail!()\n+                  _ => fail2!()\n                 }\n                 cur_eis.push(ei);\n "}, {"sha": "f8d48d00db9185d1fa7e3b06fbf1d38b984867d3", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=af3b132285bc9314d545cae2e4eaef079a26252a", "patch": "@@ -117,7 +117,7 @@ fn lookup_cur_matched(r: &mut TtReader, name: Ident) -> @named_match {\n     match r.interpolations.find_copy(&name) {\n         Some(s) => lookup_cur_matched_by_matched(r, s),\n         None => {\n-            r.sp_diag.span_fatal(r.cur_span, fmt!(\"unknown macro variable `%s`\",\n+            r.sp_diag.span_fatal(r.cur_span, format!(\"unknown macro variable `{}`\",\n                                                   ident_to_str(&name)));\n         }\n     }\n@@ -142,9 +142,9 @@ fn lockstep_iter_size(t: &token_tree, r: &mut TtReader) -> lis {\n             lis_constraint(r_len, ref r_id) => {\n                 let l_n = ident_to_str(l_id);\n                 let r_n = ident_to_str(r_id);\n-                lis_contradiction(fmt!(\"Inconsistent lockstep iteration: \\\n-                                       '%s' has %u items, but '%s' has %u\",\n-                                        l_n, l_len, r_n, r_len))\n+                lis_contradiction(format!(\"Inconsistent lockstep iteration: \\\n+                                           '{}' has {} items, but '{}' has {}\",\n+                                           l_n, l_len, r_n, r_len))\n             }\n           }\n         }\n@@ -294,7 +294,7 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n               matched_seq(*) => {\n                 r.sp_diag.span_fatal(\n                     r.cur_span, /* blame the macro writer */\n-                    fmt!(\"variable '%s' is still repeating at this depth\",\n+                    format!(\"variable '{}' is still repeating at this depth\",\n                          ident_to_str(&ident)));\n               }\n             }"}, {"sha": "909f5e5c4434aabc2caa34dad58c4e2740853c9b", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=af3b132285bc9314d545cae2e4eaef079a26252a", "patch": "@@ -892,7 +892,7 @@ mod test {\n                 let a_val = $a;\n                 let b_val = $b;\n                 if !(pred_val(a_val,b_val)) {\n-                    fail!(\"expected args satisfying %s, got %? and %?\",\n+                    fail2!(\"expected args satisfying {}, got {:?} and {:?}\",\n                           $predname, a_val, b_val);\n                 }\n             }"}, {"sha": "ca93cbaea39e07923f7dcf03d4d348418a3ad672", "filename": "src/libsyntax/opt_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=af3b132285bc9314d545cae2e4eaef079a26252a", "patch": "@@ -66,7 +66,7 @@ impl<T> OptVec<T> {\n \n     pub fn get<'a>(&'a self, i: uint) -> &'a T {\n         match *self {\n-            Empty => fail!(\"Invalid index %u\", i),\n+            Empty => fail2!(\"Invalid index {}\", i),\n             Vec(ref v) => &v[i]\n         }\n     }"}, {"sha": "dba2f0b94171745070da5fa06446a752359b427e", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=af3b132285bc9314d545cae2e4eaef079a26252a", "patch": "@@ -32,7 +32,7 @@ impl parser_attr for Parser {\n     fn parse_outer_attributes(&self) -> ~[ast::Attribute] {\n         let mut attrs: ~[ast::Attribute] = ~[];\n         loop {\n-            debug!(\"parse_outer_attributes: self.token=%?\",\n+            debug2!(\"parse_outer_attributes: self.token={:?}\",\n                    self.token);\n             match *self.token {\n               token::INTERPOLATED(token::nt_attr(*)) => {\n@@ -67,7 +67,7 @@ impl parser_attr for Parser {\n     // if permit_inner is true, then a trailing `;` indicates an inner\n     // attribute\n     fn parse_attribute(&self, permit_inner: bool) -> ast::Attribute {\n-        debug!(\"parse_attributes: permit_inner=%? self.token=%?\",\n+        debug2!(\"parse_attributes: permit_inner={:?} self.token={:?}\",\n                permit_inner, self.token);\n         let (span, value) = match *self.token {\n             INTERPOLATED(token::nt_attr(attr)) => {\n@@ -85,8 +85,8 @@ impl parser_attr for Parser {\n                 (mk_sp(lo, hi), meta_item)\n             }\n             _ => {\n-                self.fatal(fmt!(\"expected `#` but found `%s`\",\n-                                self.this_token_to_str()));\n+                self.fatal(format!(\"expected `\\\\#` but found `{}`\",\n+                                   self.this_token_to_str()));\n             }\n         };\n         let style = if permit_inner && *self.token == token::SEMI {"}, {"sha": "f163bec7d4eef3403dc352bce05ea5d516fef99a", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=af3b132285bc9314d545cae2e4eaef079a26252a", "patch": "@@ -134,7 +134,7 @@ pub fn strip_doc_comment_decoration(comment: &str) -> ~str {\n         return lines.connect(\"\\n\");\n     }\n \n-    fail!(\"not a doc-comment: %s\", comment);\n+    fail2!(\"not a doc-comment: {}\", comment);\n }\n \n fn read_to_eol(rdr: @mut StringReader) -> ~str {\n@@ -161,7 +161,7 @@ fn consume_non_eol_whitespace(rdr: @mut StringReader) {\n }\n \n fn push_blank_line_comment(rdr: @mut StringReader, comments: &mut ~[cmnt]) {\n-    debug!(\">>> blank-line comment\");\n+    debug2!(\">>> blank-line comment\");\n     let v: ~[~str] = ~[];\n     comments.push(cmnt {style: blank_line, lines: v, pos: rdr.last_pos});\n }\n@@ -179,9 +179,9 @@ fn consume_whitespace_counting_blank_lines(rdr: @mut StringReader,\n \n fn read_shebang_comment(rdr: @mut StringReader, code_to_the_left: bool,\n                                             comments: &mut ~[cmnt]) {\n-    debug!(\">>> shebang comment\");\n+    debug2!(\">>> shebang comment\");\n     let p = rdr.last_pos;\n-    debug!(\"<<< shebang comment\");\n+    debug2!(\"<<< shebang comment\");\n     comments.push(cmnt {\n         style: if code_to_the_left { trailing } else { isolated },\n         lines: ~[read_one_line_comment(rdr)],\n@@ -191,19 +191,19 @@ fn read_shebang_comment(rdr: @mut StringReader, code_to_the_left: bool,\n \n fn read_line_comments(rdr: @mut StringReader, code_to_the_left: bool,\n                                           comments: &mut ~[cmnt]) {\n-    debug!(\">>> line comments\");\n+    debug2!(\">>> line comments\");\n     let p = rdr.last_pos;\n     let mut lines: ~[~str] = ~[];\n     while rdr.curr == '/' && nextch(rdr) == '/' {\n         let line = read_one_line_comment(rdr);\n-        debug!(\"%s\", line);\n+        debug2!(\"{}\", line);\n         if is_doc_comment(line) { // doc-comments are not put in comments\n             break;\n         }\n         lines.push(line);\n         consume_non_eol_whitespace(rdr);\n     }\n-    debug!(\"<<< line comments\");\n+    debug2!(\"<<< line comments\");\n     if !lines.is_empty() {\n         comments.push(cmnt {\n             style: if code_to_the_left { trailing } else { isolated },\n@@ -242,14 +242,14 @@ fn trim_whitespace_prefix_and_push_line(lines: &mut ~[~str],\n         }\n         None => s,\n     };\n-    debug!(\"pushing line: %s\", s1);\n+    debug2!(\"pushing line: {}\", s1);\n     lines.push(s1);\n }\n \n fn read_block_comment(rdr: @mut StringReader,\n                       code_to_the_left: bool,\n                       comments: &mut ~[cmnt]) {\n-    debug!(\">>> block comment\");\n+    debug2!(\">>> block comment\");\n     let p = rdr.last_pos;\n     let mut lines: ~[~str] = ~[];\n     let col: CharPos = rdr.col;\n@@ -275,7 +275,7 @@ fn read_block_comment(rdr: @mut StringReader,\n     } else {\n         let mut level: int = 1;\n         while level > 0 {\n-            debug!(\"=== block comment level %d\", level);\n+            debug2!(\"=== block comment level {}\", level);\n             if is_eof(rdr) {\n                 (rdr as @mut reader).fatal(~\"unterminated block comment\");\n             }\n@@ -311,7 +311,7 @@ fn read_block_comment(rdr: @mut StringReader,\n     if !is_eof(rdr) && rdr.curr != '\\n' && lines.len() == 1u {\n         style = mixed;\n     }\n-    debug!(\"<<< block comment\");\n+    debug2!(\"<<< block comment\");\n     comments.push(cmnt {style: style, lines: lines, pos: p});\n }\n \n@@ -324,15 +324,15 @@ fn peeking_at_comment(rdr: @mut StringReader) -> bool {\n fn consume_comment(rdr: @mut StringReader,\n                    code_to_the_left: bool,\n                    comments: &mut ~[cmnt]) {\n-    debug!(\">>> consume comment\");\n+    debug2!(\">>> consume comment\");\n     if rdr.curr == '/' && nextch(rdr) == '/' {\n         read_line_comments(rdr, code_to_the_left, comments);\n     } else if rdr.curr == '/' && nextch(rdr) == '*' {\n         read_block_comment(rdr, code_to_the_left, comments);\n     } else if rdr.curr == '#' && nextch(rdr) == '!' {\n         read_shebang_comment(rdr, code_to_the_left, comments);\n-    } else { fail!(); }\n-    debug!(\"<<< consume comment\");\n+    } else { fail2!(); }\n+    debug2!(\"<<< consume comment\");\n }\n \n #[deriving(Clone)]\n@@ -378,11 +378,11 @@ pub fn gather_comments_and_literals(span_diagnostic:\n         let TokenAndSpan {tok: tok, sp: sp} = rdr.peek();\n         if token::is_lit(&tok) {\n             do with_str_from(rdr, bstart) |s| {\n-                debug!(\"tok lit: %s\", s);\n+                debug2!(\"tok lit: {}\", s);\n                 literals.push(lit {lit: s.to_owned(), pos: sp.lo});\n             }\n         } else {\n-            debug!(\"tok: %s\", token::to_str(get_ident_interner(), &tok));\n+            debug2!(\"tok: {}\", token::to_str(get_ident_interner(), &tok));\n         }\n         first_read = false;\n     }"}, {"sha": "640c7c220e5e294b090c043c70f5b7586e385aa8", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=af3b132285bc9314d545cae2e4eaef079a26252a", "patch": "@@ -133,7 +133,7 @@ impl reader for TtReader {\n     fn is_eof(@mut self) -> bool { self.cur_tok == token::EOF }\n     fn next_token(@mut self) -> TokenAndSpan {\n         let r = tt_next_token(self);\n-        debug!(\"TtReader: r=%?\", r);\n+        debug2!(\"TtReader: r={:?}\", r);\n         return r;\n     }\n     fn fatal(@mut self, m: ~str) -> ! {\n@@ -261,7 +261,7 @@ fn hex_digit_val(c: char) -> int {\n     if in_range(c, '0', '9') { return (c as int) - ('0' as int); }\n     if in_range(c, 'a', 'f') { return (c as int) - ('a' as int) + 10; }\n     if in_range(c, 'A', 'F') { return (c as int) - ('A' as int) + 10; }\n-    fail!();\n+    fail2!();\n }\n \n fn bin_digit_value(c: char) -> int { if c == '0' { return 0; } return 1; }\n@@ -569,8 +569,7 @@ fn scan_number(c: char, rdr: @mut StringReader) -> token::Token {\n                                ~\"int literal is too large\")\n         };\n \n-        debug!(\"lexing %s as an unsuffixed integer literal\",\n-               num_str);\n+        debug2!(\"lexing {} as an unsuffixed integer literal\", num_str);\n         return token::LIT_INT_UNSUFFIXED(parsed as i64);\n     }\n }"}, {"sha": "67bcab319562ee960e742bd891110cbea9dd6474", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=af3b132285bc9314d545cae2e4eaef079a26252a", "patch": "@@ -416,18 +416,18 @@ mod test {\n                         _ => assert_eq!(\"wrong 4\",\"correct\")\n                     },\n                     _ => {\n-                        error!(\"failing value 3: %?\",first_set);\n+                        error2!(\"failing value 3: {:?}\",first_set);\n                         assert_eq!(\"wrong 3\",\"correct\")\n                     }\n                 },\n                 _ => {\n-                    error!(\"failing value 2: %?\",delim_elts);\n+                    error2!(\"failing value 2: {:?}\",delim_elts);\n                     assert_eq!(\"wrong\",\"correct\");\n                 }\n \n             },\n             _ => {\n-                error!(\"failing value: %?\",tts);\n+                error2!(\"failing value: {:?}\",tts);\n                 assert_eq!(\"wrong 1\",\"correct\");\n             }\n         }"}, {"sha": "adf0c208da4df078acce458559d33c938a2e0a7d", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=af3b132285bc9314d545cae2e4eaef079a26252a", "patch": "@@ -261,10 +261,10 @@ impl ParserObsoleteMethods for Parser {\n               kind: ObsoleteSyntax,\n               kind_str: &str,\n               desc: &str) {\n-        self.span_err(sp, fmt!(\"obsolete syntax: %s\", kind_str));\n+        self.span_err(sp, format!(\"obsolete syntax: {}\", kind_str));\n \n         if !self.obsolete_set.contains(&kind) {\n-            self.sess.span_diagnostic.handler().note(fmt!(\"%s\", desc));\n+            self.sess.span_diagnostic.handler().note(format!(\"{}\", desc));\n             self.obsolete_set.insert(kind);\n         }\n     }"}, {"sha": "4dd09cbcbd2f9aa33fc9771b4706807bb980b3bf", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 58, "deletions": 59, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=af3b132285bc9314d545cae2e4eaef079a26252a", "patch": "@@ -362,17 +362,17 @@ impl Parser {\n     pub fn unexpected_last(&self, t: &token::Token) -> ! {\n         self.span_fatal(\n             *self.last_span,\n-            fmt!(\n-                \"unexpected token: `%s`\",\n+            format!(\n+                \"unexpected token: `{}`\",\n                 self.token_to_str(t)\n             )\n         );\n     }\n \n     pub fn unexpected(&self) -> ! {\n         self.fatal(\n-            fmt!(\n-                \"unexpected token: `%s`\",\n+            format!(\n+                \"unexpected token: `{}`\",\n                 self.this_token_to_str()\n             )\n         );\n@@ -385,8 +385,8 @@ impl Parser {\n             self.bump();\n         } else {\n             self.fatal(\n-                fmt!(\n-                    \"expected `%s` but found `%s`\",\n+                format!(\n+                    \"expected `{}` but found `{}`\",\n                     self.token_to_str(t),\n                     self.this_token_to_str()\n                 )\n@@ -414,9 +414,9 @@ impl Parser {\n             let actual = self.this_token_to_str();\n             self.fatal(\n                 if expected.len() != 1 {\n-                    fmt!(\"expected one of `%s` but found `%s`\", expect, actual)\n+                    format!(\"expected one of `{}` but found `{}`\", expect, actual)\n                 } else {\n-                    fmt!(\"expected `%s` but found `%s`\", expect, actual)\n+                    format!(\"expected `{}` but found `{}`\", expect, actual)\n                 }\n             )\n         }\n@@ -444,7 +444,7 @@ impl Parser {\n     // followed by some token from the set edible + inedible.  Recover\n     // from anticipated input errors, discarding erroneous characters.\n     pub fn commit_expr(&self, e: @Expr, edible: &[token::Token], inedible: &[token::Token]) {\n-        debug!(\"commit_expr %?\", e);\n+        debug2!(\"commit_expr {:?}\", e);\n         match e.node {\n             ExprPath(*) => {\n                 // might be unit-struct construction; check for recoverableinput error.\n@@ -464,7 +464,7 @@ impl Parser {\n     // followed by some token from the set edible + inedible.  Check\n     // for recoverable input errors, discarding erroneous characters.\n     pub fn commit_stmt(&self, s: @Stmt, edible: &[token::Token], inedible: &[token::Token]) {\n-        debug!(\"commit_stmt %?\", s);\n+        debug2!(\"commit_stmt {:?}\", s);\n         let _s = s; // unused, but future checks might want to inspect `s`.\n         if self.last_token.map_default(false, |t|is_ident_or_path(*t)) {\n             let expected = vec::append(edible.to_owned(), inedible);\n@@ -490,8 +490,8 @@ impl Parser {\n             }\n             _ => {\n                 self.fatal(\n-                    fmt!(\n-                        \"expected ident, found `%s`\",\n+                    format!(\n+                        \"expected ident, found `{}`\",\n                         self.this_token_to_str()\n                     )\n                 );\n@@ -536,8 +536,8 @@ impl Parser {\n     pub fn expect_keyword(&self, kw: keywords::Keyword) {\n         if !self.eat_keyword(kw) {\n             self.fatal(\n-                fmt!(\n-                    \"expected `%s`, found `%s`\",\n+                format!(\n+                    \"expected `{}`, found `{}`\",\n                     self.id_to_str(kw.to_ident()).to_str(),\n                     self.this_token_to_str()\n                 )\n@@ -549,14 +549,14 @@ impl Parser {\n     pub fn check_strict_keywords(&self) {\n         if token::is_strict_keyword(self.token) {\n             self.span_err(*self.last_span,\n-                          fmt!(\"found `%s` in ident position\", self.this_token_to_str()));\n+                          format!(\"found `{}` in ident position\", self.this_token_to_str()));\n         }\n     }\n \n     // signal an error if the current token is a reserved keyword\n     pub fn check_reserved_keywords(&self) {\n         if token::is_reserved_keyword(self.token) {\n-            self.fatal(fmt!(\"`%s` is a reserved keyword\", self.this_token_to_str()));\n+            self.fatal(format!(\"`{}` is a reserved keyword\", self.this_token_to_str()));\n         }\n     }\n \n@@ -571,7 +571,7 @@ impl Parser {\n                 self.span.lo + BytePos(1u),\n                 self.span.hi\n             ),\n-            _ => self.fatal(fmt!(\"expected `%s`, found `%s`\",\n+            _ => self.fatal(format!(\"expected `{}`, found `{}`\",\n                                  self.token_to_str(&token::GT),\n                                  self.this_token_to_str()))\n         }\n@@ -938,13 +938,13 @@ impl Parser {\n             };\n \n             let hi = p.last_span.hi;\n-            debug!(\"parse_trait_methods(): trait method signature ends in \\\n-                    `%s`\",\n+            debug2!(\"parse_trait_methods(): trait method signature ends in \\\n+                    `{}`\",\n                    self.this_token_to_str());\n             match *p.token {\n               token::SEMI => {\n                 p.bump();\n-                debug!(\"parse_trait_methods(): parsing required method\");\n+                debug2!(\"parse_trait_methods(): parsing required method\");\n                 // NB: at the moment, visibility annotations on required\n                 // methods are ignored; this could change.\n                 if vis != ast::inherited {\n@@ -963,7 +963,7 @@ impl Parser {\n                 })\n               }\n               token::LBRACE => {\n-                debug!(\"parse_trait_methods(): parsing provided method\");\n+                debug2!(\"parse_trait_methods(): parsing provided method\");\n                 let (inner_attrs, body) =\n                     p.parse_inner_attrs_and_block();\n                 let attrs = vec::append(attrs, inner_attrs);\n@@ -984,8 +984,8 @@ impl Parser {\n \n               _ => {\n                     p.fatal(\n-                        fmt!(\n-                            \"expected `;` or `{` but found `%s`\",\n+                        format!(\n+                            \"expected `;` or `\\\\{` but found `{}`\",\n                             self.this_token_to_str()\n                         )\n                     );\n@@ -1153,8 +1153,7 @@ impl Parser {\n             } = self.parse_path(LifetimeAndTypesAndBounds);\n             ty_path(path, bounds, ast::DUMMY_NODE_ID)\n         } else {\n-            self.fatal(fmt!(\"expected type, found token %?\",\n-                            *self.token));\n+            self.fatal(format!(\"expected type, found token {:?}\", *self.token));\n         };\n \n         let sp = mk_sp(lo, self.last_span.hi);\n@@ -1245,7 +1244,7 @@ impl Parser {\n             _ => 0\n         };\n \n-        debug!(\"parser is_named_argument offset:%u\", offset);\n+        debug2!(\"parser is_named_argument offset:{}\", offset);\n \n         if offset == 0 {\n             is_plain_ident_or_underscore(&*self.token)\n@@ -1261,7 +1260,7 @@ impl Parser {\n     pub fn parse_arg_general(&self, require_name: bool) -> arg {\n         let is_mutbl = self.eat_keyword(keywords::Mut);\n         let pat = if require_name || self.is_named_argument() {\n-            debug!(\"parse_arg_general parse_pat (require_name:%?)\",\n+            debug2!(\"parse_arg_general parse_pat (require_name:{:?})\",\n                    require_name);\n             self.parse_arg_mode();\n             let pat = self.parse_pat();\n@@ -1273,7 +1272,7 @@ impl Parser {\n             self.expect(&token::COLON);\n             pat\n         } else {\n-            debug!(\"parse_arg_general ident_to_pat\");\n+            debug2!(\"parse_arg_general ident_to_pat\");\n             ast_util::ident_to_pat(ast::DUMMY_NODE_ID,\n                                    *self.last_span,\n                                    special_idents::invalid)\n@@ -1581,7 +1580,7 @@ impl Parser {\n             }\n \n             _ => {\n-                self.fatal(fmt!(\"Expected a lifetime name\"));\n+                self.fatal(format!(\"Expected a lifetime name\"));\n             }\n         }\n     }\n@@ -1614,7 +1613,7 @@ impl Parser {\n                 token::GT => { return res; }\n                 token::BINOP(token::SHR) => { return res; }\n                 _ => {\n-                    self.fatal(fmt!(\"expected `,` or `>` after lifetime name, got: %?\",\n+                    self.fatal(format!(\"expected `,` or `>` after lifetime name, got: {:?}\",\n                                     *self.token));\n                 }\n             }\n@@ -2067,8 +2066,8 @@ impl Parser {\n               token::RPAREN | token::RBRACE | token::RBRACKET\n               => {\n                 p.fatal(\n-                    fmt!(\n-                        \"incorrect close delimiter: `%s`\",\n+                    format!(\n+                        \"incorrect close delimiter: `{}`\",\n                         p.this_token_to_str()\n                     )\n                 );\n@@ -2561,10 +2560,10 @@ impl Parser {\n                 // There may be other types of expressions that can\n                 // represent the callee in `for` and `do` expressions\n                 // but they aren't represented by tests\n-                debug!(\"sugary call on %?\", e.node);\n+                debug2!(\"sugary call on {:?}\", e.node);\n                 self.span_fatal(\n                     e.span,\n-                    fmt!(\"`%s` must be followed by a block call\", keyword));\n+                    format!(\"`{}` must be followed by a block call\", keyword));\n             }\n         }\n     }\n@@ -2759,8 +2758,8 @@ impl Parser {\n                 self.bump();\n                 if *self.token != token::RBRACE {\n                     self.fatal(\n-                        fmt!(\n-                            \"expected `}`, found `%s`\",\n+                        format!(\n+                            \"expected `\\\\}`, found `{}`\",\n                             self.this_token_to_str()\n                         )\n                     );\n@@ -3543,8 +3542,8 @@ impl Parser {\n     fn expect_self_ident(&self) {\n         if !self.is_self_ident() {\n             self.fatal(\n-                fmt!(\n-                    \"expected `self` but found `%s`\",\n+                format!(\n+                    \"expected `self` but found `{}`\",\n                     self.this_token_to_str()\n                 )\n             );\n@@ -3682,8 +3681,8 @@ impl Parser {\n                 }\n                 _ => {\n                     self.fatal(\n-                        fmt!(\n-                            \"expected `,` or `)`, found `%s`\",\n+                        format!(\n+                            \"expected `,` or `)`, found `{}`\",\n                             self.this_token_to_str()\n                         )\n                     );\n@@ -3920,7 +3919,7 @@ impl Parser {\n                 }\n             }\n             if fields.len() == 0 {\n-                self.fatal(fmt!(\"Unit-like struct definition should be written as `struct %s;`\",\n+                self.fatal(format!(\"Unit-like struct definition should be written as `struct {};`\",\n                                 get_ident_interner().get(class_name.name)));\n             }\n             self.bump();\n@@ -3949,9 +3948,9 @@ impl Parser {\n             fields = ~[];\n         } else {\n             self.fatal(\n-                fmt!(\n-                    \"expected `{`, `(`, or `;` after struct name \\\n-                    but found `%s`\",\n+                format!(\n+                    \"expected `\\\\{`, `(`, or `;` after struct name \\\n+                    but found `{}`\",\n                     self.this_token_to_str()\n                 )\n             );\n@@ -3995,7 +3994,7 @@ impl Parser {\n             token::RBRACE => {}\n             _ => {\n                 self.span_fatal(*self.span,\n-                                fmt!(\"expected `,`, or '}' but found `%s`\",\n+                                format!(\"expected `,`, or '\\\\}' but found `{}`\",\n                                      self.this_token_to_str()));\n             }\n         }\n@@ -4064,7 +4063,7 @@ impl Parser {\n                 attrs = attrs_remaining + attrs;\n                 first = false;\n             }\n-            debug!(\"parse_mod_items: parse_item_or_view_item(attrs=%?)\",\n+            debug2!(\"parse_mod_items: parse_item_or_view_item(attrs={:?})\",\n                    attrs);\n             match self.parse_item_or_view_item(attrs,\n                                                true /* macros allowed */) {\n@@ -4075,7 +4074,7 @@ impl Parser {\n                                  the module\");\n               }\n               _ => {\n-                self.fatal(fmt!(\"expected item but found `%s`\",\n+                self.fatal(format!(\"expected item but found `{}`\",\n                                 self.this_token_to_str()));\n               }\n             }\n@@ -4167,11 +4166,11 @@ impl Parser {\n                     (true, false) => default_path,\n                     (false, true) => secondary_path,\n                     (false, false) => {\n-                        self.span_fatal(id_sp, fmt!(\"file not found for module `%s`\", mod_name));\n+                        self.span_fatal(id_sp, format!(\"file not found for module `{}`\", mod_name));\n                     }\n                     (true, true) => {\n                         self.span_fatal(id_sp,\n-                                        fmt!(\"file for module `%s` found at both %s and %s\",\n+                                        format!(\"file for module `{}` found at both {} and {}\",\n                                              mod_name, default_path_str, secondary_path_str));\n                     }\n                 }\n@@ -4323,7 +4322,7 @@ impl Parser {\n             self.expect_keyword(keywords::Mod);\n         } else if *self.token != token::LBRACE {\n             self.span_fatal(*self.span,\n-                            fmt!(\"expected `{` or `mod` but found `%s`\",\n+                            format!(\"expected `\\\\{` or `mod` but found `{}`\",\n                                  self.this_token_to_str()));\n         }\n \n@@ -4340,8 +4339,8 @@ impl Parser {\n             _ => {\n                 if must_be_named_mod {\n                     self.span_fatal(*self.span,\n-                                    fmt!(\"expected foreign module name but \\\n-                                          found `%s`\",\n+                                    format!(\"expected foreign module name but \\\n+                                          found `{}`\",\n                                          self.this_token_to_str()));\n                 }\n \n@@ -4566,7 +4565,7 @@ impl Parser {\n                             if abis.contains(abi) {\n                                 self.span_err(\n                                     *self.span,\n-                                    fmt!(\"ABI `%s` appears twice\",\n+                                    format!(\"ABI `{}` appears twice\",\n                                          word));\n                             } else {\n                                 abis.add(abi);\n@@ -4576,9 +4575,9 @@ impl Parser {\n                         None => {\n                             self.span_err(\n                                 *self.span,\n-                                fmt!(\"illegal ABI: \\\n-                                      expected one of [%s], \\\n-                                      found `%s`\",\n+                                format!(\"illegal ABI: \\\n+                                      expected one of [{}], \\\n+                                      found `{}`\",\n                                      abi::all_names().connect(\", \"),\n                                      word));\n                         }\n@@ -4853,7 +4852,7 @@ impl Parser {\n \n         let first_ident = self.parse_ident();\n         let mut path = ~[first_ident];\n-        debug!(\"parsed view_path: %s\", self.id_to_str(first_ident));\n+        debug2!(\"parsed view_path: {}\", self.id_to_str(first_ident));\n         match *self.token {\n           token::EQ => {\n             // x = foo::bar\n@@ -5061,7 +5060,7 @@ impl Parser {\n                     break;\n                 }\n                 iovi_foreign_item(_) => {\n-                    fail!();\n+                    fail2!();\n                 }\n             }\n             attrs = self.parse_outer_attributes();\n@@ -5084,7 +5083,7 @@ impl Parser {\n                     items.push(item)\n                 }\n                 iovi_foreign_item(_) => {\n-                    fail!();\n+                    fail2!();\n                 }\n             }\n         }"}, {"sha": "d0faf917688d7ad9188aed11488429c27d2652ba", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=af3b132285bc9314d545cae2e4eaef079a26252a", "patch": "@@ -193,11 +193,11 @@ pub fn to_str(input: @ident_interner, t: &Token) -> ~str {\n         }\n         body\n       }\n-      LIT_STR(ref s) => { fmt!(\"\\\"%s\\\"\", ident_to_str(s).escape_default()) }\n+      LIT_STR(ref s) => { format!(\"\\\"{}\\\"\", ident_to_str(s).escape_default()) }\n \n       /* Name components */\n       IDENT(s, _) => input.get(s.name).to_owned(),\n-      LIFETIME(s) => fmt!(\"'%s\", input.get(s.name)),\n+      LIFETIME(s) => format!(\"'{}\", input.get(s.name)),\n       UNDERSCORE => ~\"_\",\n \n       /* Other */\n@@ -214,8 +214,8 @@ pub fn to_str(input: @ident_interner, t: &Token) -> ~str {\n                       nt_block(*) => ~\"block\",\n                       nt_stmt(*) => ~\"statement\",\n                       nt_pat(*) => ~\"pattern\",\n-                      nt_attr(*) => fail!(\"should have been handled\"),\n-                      nt_expr(*) => fail!(\"should have been handled above\"),\n+                      nt_attr(*) => fail2!(\"should have been handled\"),\n+                      nt_expr(*) => fail2!(\"should have been handled above\"),\n                       nt_ty(*) => ~\"type\",\n                       nt_ident(*) => ~\"identifier\",\n                       nt_path(*) => ~\"path\",\n@@ -269,7 +269,7 @@ pub fn flip_delimiter(t: &token::Token) -> token::Token {\n       RPAREN => LPAREN,\n       RBRACE => LBRACE,\n       RBRACKET => LBRACKET,\n-      _ => fail!()\n+      _ => fail2!()\n     }\n }\n \n@@ -553,7 +553,7 @@ pub fn fresh_name(src : &ast::Ident) -> Name {\n     // good error messages and uses of struct names in ambiguous could-be-binding\n     // locations. Also definitely destroys the guarantee given above about ptr_eq.\n     /*let num = rand::rng().gen_uint_range(0,0xffff);\n-    gensym(fmt!(\"%s_%u\",ident_to_str(src),num))*/\n+    gensym(format!(\"{}_{}\",ident_to_str(src),num))*/\n }\n \n // it looks like there oughta be a str_ptr_eq fn, but no one bothered to implement it?"}, {"sha": "58d73ad687c49cc59196e40c7f1cfe6f88b60271", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=af3b132285bc9314d545cae2e4eaef079a26252a", "patch": "@@ -111,7 +111,7 @@ impl token {\n \n pub fn tok_str(t: token) -> ~str {\n     match t {\n-        STRING(s, len) => return fmt!(\"STR(%s,%d)\", s, len),\n+        STRING(s, len) => return format!(\"STR({},{})\", s, len),\n         BREAK(_) => return ~\"BREAK\",\n         BEGIN(_) => return ~\"BEGIN\",\n         END => return ~\"END\",\n@@ -131,7 +131,7 @@ pub fn buf_str(toks: ~[token], szs: ~[int], left: uint, right: uint,\n         if i != left {\n             s.push_str(\", \");\n         }\n-        s.push_str(fmt!(\"%d=%s\", szs[i], tok_str(toks[i])));\n+        s.push_str(format!(\"{}={}\", szs[i], tok_str(toks[i])));\n         i += 1u;\n         i %= n;\n     }\n@@ -152,7 +152,7 @@ pub fn mk_printer(out: @io::Writer, linewidth: uint) -> @mut Printer {\n     // Yes 3, it makes the ring buffers big enough to never\n     // fall behind.\n     let n: uint = 3 * linewidth;\n-    debug!(\"mk_printer %u\", linewidth);\n+    debug2!(\"mk_printer {}\", linewidth);\n     let token: ~[token] = vec::from_elem(n, EOF);\n     let size: ~[int] = vec::from_elem(n, 0);\n     let scan_stack: ~[uint] = vec::from_elem(n, 0u);\n@@ -288,7 +288,7 @@ impl Printer {\n         self.token[self.right] = t;\n     }\n     pub fn pretty_print(&mut self, t: token) {\n-        debug!(\"pp ~[%u,%u]\", self.left, self.right);\n+        debug2!(\"pp ~[{},{}]\", self.left, self.right);\n         match t {\n           EOF => {\n             if !self.scan_stack_empty {\n@@ -305,18 +305,18 @@ impl Printer {\n                 self.left = 0u;\n                 self.right = 0u;\n             } else { self.advance_right(); }\n-            debug!(\"pp BEGIN(%d)/buffer ~[%u,%u]\",\n+            debug2!(\"pp BEGIN({})/buffer ~[{},{}]\",\n                    b.offset, self.left, self.right);\n             self.token[self.right] = t;\n             self.size[self.right] = -self.right_total;\n             self.scan_push(self.right);\n           }\n           END => {\n             if self.scan_stack_empty {\n-                debug!(\"pp END/print ~[%u,%u]\", self.left, self.right);\n+                debug2!(\"pp END/print ~[{},{}]\", self.left, self.right);\n                 self.print(t, 0);\n             } else {\n-                debug!(\"pp END/buffer ~[%u,%u]\", self.left, self.right);\n+                debug2!(\"pp END/buffer ~[{},{}]\", self.left, self.right);\n                 self.advance_right();\n                 self.token[self.right] = t;\n                 self.size[self.right] = -1;\n@@ -330,7 +330,7 @@ impl Printer {\n                 self.left = 0u;\n                 self.right = 0u;\n             } else { self.advance_right(); }\n-            debug!(\"pp BREAK(%d)/buffer ~[%u,%u]\",\n+            debug2!(\"pp BREAK({})/buffer ~[{},{}]\",\n                    b.offset, self.left, self.right);\n             self.check_stack(0);\n             self.scan_push(self.right);\n@@ -340,11 +340,11 @@ impl Printer {\n           }\n           STRING(s, len) => {\n             if self.scan_stack_empty {\n-                debug!(\"pp STRING('%s')/print ~[%u,%u]\",\n+                debug2!(\"pp STRING('{}')/print ~[{},{}]\",\n                        s, self.left, self.right);\n                 self.print(t, len);\n             } else {\n-                debug!(\"pp STRING('%s')/buffer ~[%u,%u]\",\n+                debug2!(\"pp STRING('{}')/buffer ~[{},{}]\",\n                        s, self.left, self.right);\n                 self.advance_right();\n                 self.token[self.right] = t;\n@@ -356,14 +356,14 @@ impl Printer {\n         }\n     }\n     pub fn check_stream(&mut self) {\n-        debug!(\"check_stream ~[%u, %u] with left_total=%d, right_total=%d\",\n+        debug2!(\"check_stream ~[{}, {}] with left_total={}, right_total={}\",\n                self.left, self.right, self.left_total, self.right_total);\n         if self.right_total - self.left_total > self.space {\n-            debug!(\"scan window is %d, longer than space on line (%d)\",\n+            debug2!(\"scan window is {}, longer than space on line ({})\",\n                    self.right_total - self.left_total, self.space);\n             if !self.scan_stack_empty {\n                 if self.left == self.scan_stack[self.bottom] {\n-                    debug!(\"setting %u to infinity and popping\", self.left);\n+                    debug2!(\"setting {} to infinity and popping\", self.left);\n                     self.size[self.scan_pop_bottom()] = size_infinity;\n                 }\n             }\n@@ -372,7 +372,7 @@ impl Printer {\n         }\n     }\n     pub fn scan_push(&mut self, x: uint) {\n-        debug!(\"scan_push %u\", x);\n+        debug2!(\"scan_push {}\", x);\n         if self.scan_stack_empty {\n             self.scan_stack_empty = false;\n         } else {\n@@ -408,7 +408,7 @@ impl Printer {\n         assert!((self.right != self.left));\n     }\n     pub fn advance_left(&mut self, x: token, L: int) {\n-        debug!(\"advnce_left ~[%u,%u], sizeof(%u)=%d\", self.left, self.right,\n+        debug2!(\"advnce_left ~[{},{}], sizeof({})={}\", self.left, self.right,\n                self.left, L);\n         if L >= 0 {\n             self.print(x, L);\n@@ -451,13 +451,13 @@ impl Printer {\n         }\n     }\n     pub fn print_newline(&mut self, amount: int) {\n-        debug!(\"NEWLINE %d\", amount);\n+        debug2!(\"NEWLINE {}\", amount);\n         (*self.out).write_str(\"\\n\");\n         self.pending_indentation = 0;\n         self.indent(amount);\n     }\n     pub fn indent(&mut self, amount: int) {\n-        debug!(\"INDENT %d\", amount);\n+        debug2!(\"INDENT {}\", amount);\n         self.pending_indentation += amount;\n     }\n     pub fn get_top(&mut self) -> print_stack_elt {\n@@ -480,9 +480,9 @@ impl Printer {\n         (*self.out).write_str(s);\n     }\n     pub fn print(&mut self, x: token, L: int) {\n-        debug!(\"print %s %d (remaining line space=%d)\", tok_str(x), L,\n+        debug2!(\"print {} {} (remaining line space={})\", tok_str(x), L,\n                self.space);\n-        debug!(\"%s\", buf_str(self.token.clone(),\n+        debug2!(\"{}\", buf_str(self.token.clone(),\n                              self.size.clone(),\n                              self.left,\n                              self.right,\n@@ -491,21 +491,21 @@ impl Printer {\n           BEGIN(b) => {\n             if L > self.space {\n                 let col = self.margin - self.space + b.offset;\n-                debug!(\"print BEGIN -> push broken block at col %d\", col);\n+                debug2!(\"print BEGIN -> push broken block at col {}\", col);\n                 self.print_stack.push(print_stack_elt {\n                     offset: col,\n                     pbreak: broken(b.breaks)\n                 });\n             } else {\n-                debug!(\"print BEGIN -> push fitting block\");\n+                debug2!(\"print BEGIN -> push fitting block\");\n                 self.print_stack.push(print_stack_elt {\n                     offset: 0,\n                     pbreak: fits\n                 });\n             }\n           }\n           END => {\n-            debug!(\"print END -> pop END\");\n+            debug2!(\"print END -> pop END\");\n             let print_stack = &mut *self.print_stack;\n             assert!((print_stack.len() != 0u));\n             print_stack.pop();\n@@ -514,24 +514,24 @@ impl Printer {\n             let top = self.get_top();\n             match top.pbreak {\n               fits => {\n-                debug!(\"print BREAK(%d) in fitting block\", b.blank_space);\n+                debug2!(\"print BREAK({}) in fitting block\", b.blank_space);\n                 self.space -= b.blank_space;\n                 self.indent(b.blank_space);\n               }\n               broken(consistent) => {\n-                debug!(\"print BREAK(%d+%d) in consistent block\",\n+                debug2!(\"print BREAK({}+{}) in consistent block\",\n                        top.offset, b.offset);\n                 self.print_newline(top.offset + b.offset);\n                 self.space = self.margin - (top.offset + b.offset);\n               }\n               broken(inconsistent) => {\n                 if L > self.space {\n-                    debug!(\"print BREAK(%d+%d) w/ newline in inconsistent\",\n+                    debug2!(\"print BREAK({}+{}) w/ newline in inconsistent\",\n                            top.offset, b.offset);\n                     self.print_newline(top.offset + b.offset);\n                     self.space = self.margin - (top.offset + b.offset);\n                 } else {\n-                    debug!(\"print BREAK(%d) w/o newline in inconsistent\",\n+                    debug2!(\"print BREAK({}) w/o newline in inconsistent\",\n                            b.blank_space);\n                     self.indent(b.blank_space);\n                     self.space -= b.blank_space;\n@@ -540,15 +540,15 @@ impl Printer {\n             }\n           }\n           STRING(s, len) => {\n-            debug!(\"print STRING(%s)\", s);\n+            debug2!(\"print STRING({})\", s);\n             assert_eq!(L, len);\n             // assert!(L <= space);\n             self.space -= len;\n             self.print_str(s);\n           }\n           EOF => {\n             // EOF should never get here.\n-            fail!();\n+            fail2!();\n           }\n         }\n     }"}, {"sha": "bc1a47212074271e7211f46a70afff8c8a23b912", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3b132285bc9314d545cae2e4eaef079a26252a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=af3b132285bc9314d545cae2e4eaef079a26252a", "patch": "@@ -453,10 +453,10 @@ pub fn print_type(s: @ps, ty: &ast::Ty) {\n           word(s.s, \")\");\n       }\n       ast::ty_mac(_) => {\n-          fail!(\"print_type doesn't know how to print a ty_mac\");\n+          fail2!(\"print_type doesn't know how to print a ty_mac\");\n       }\n       ast::ty_infer => {\n-          fail!(\"print_type shouldn't see a ty_infer\");\n+          fail2!(\"print_type shouldn't see a ty_infer\");\n       }\n \n     }\n@@ -709,7 +709,7 @@ pub fn print_struct(s: @ps,\n             popen(s);\n             do commasep(s, inconsistent, struct_def.fields) |s, field| {\n                 match field.node.kind {\n-                    ast::named_field(*) => fail!(\"unexpected named field\"),\n+                    ast::named_field(*) => fail2!(\"unexpected named field\"),\n                     ast::unnamed_field => {\n                         maybe_print_comment(s, field.span.lo);\n                         print_type(s, &field.node.ty);\n@@ -728,7 +728,7 @@ pub fn print_struct(s: @ps,\n \n         for field in struct_def.fields.iter() {\n             match field.node.kind {\n-                ast::unnamed_field => fail!(\"unexpected unnamed field\"),\n+                ast::unnamed_field => fail2!(\"unexpected unnamed field\"),\n                 ast::named_field(ident, visibility) => {\n                     hardbreak_if_not_bol(s);\n                     maybe_print_comment(s, field.span.lo);\n@@ -1017,7 +1017,7 @@ pub fn print_if(s: @ps, test: &ast::Expr, blk: &ast::Block,\n               }\n               // BLEAH, constraints would be great here\n               _ => {\n-                  fail!(\"print_if saw if with weird alternative\");\n+                  fail2!(\"print_if saw if with weird alternative\");\n               }\n             }\n           }\n@@ -1042,7 +1042,7 @@ pub fn print_mac(s: @ps, m: &ast::mac) {\n \n pub fn print_vstore(s: @ps, t: ast::Vstore) {\n     match t {\n-        ast::VstoreFixed(Some(i)) => word(s.s, fmt!(\"%u\", i)),\n+        ast::VstoreFixed(Some(i)) => word(s.s, format!(\"{}\", i)),\n         ast::VstoreFixed(None) => word(s.s, \"_\"),\n         ast::VstoreUniq => word(s.s, \"~\"),\n         ast::VstoreBox => word(s.s, \"@\"),\n@@ -1319,7 +1319,7 @@ pub fn print_expr(s: @ps, expr: &ast::Expr) {\n                         }\n                         end(s); // close enclosing cbox\n                     }\n-                    None => fail!()\n+                    None => fail2!()\n                 }\n             } else {\n                 // the block will close the pattern's ibox\n@@ -2299,7 +2299,7 @@ mod test {\n \n     fn string_check<T:Eq> (given : &T, expected: &T) {\n         if !(given == expected) {\n-            fail!(\"given %?, expected %?\", given, expected);\n+            fail2!(\"given {:?}, expected {:?}\", given, expected);\n         }\n     }\n "}]}