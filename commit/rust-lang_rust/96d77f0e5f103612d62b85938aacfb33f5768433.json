{"sha": "96d77f0e5f103612d62b85938aacfb33f5768433", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2ZDc3ZjBlNWYxMDM2MTJkNjJiODU5MzhhYWNmYjMzZjU3Njg0MzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-10T06:14:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-10T06:14:47Z"}, "message": "Auto merge of #70447 - ecstatic-morse:storage-live-always, r=tmandry\n\nAdd utility to find locals that don't use `StorageLive` annotations and use it for `MaybeStorageLive`\n\nAddresses https://github.com/rust-lang/rust/pull/70004#issuecomment-599271717 (cc @RalfJung).\n\nThe only dataflow analysis that is incorrect in this case is `MaybeStorageLive`. `transform/generator.rs` implemented custom handling for this class of locals, but other consumers of this analysis (there's one in [clippy](https://github.com/rust-lang/rust-clippy/blob/513b46793e98ce5b412d388a91f6371d6a9b290b/clippy_lints/src/redundant_clone.rs#L402)) would be incorrect.\n\nr? @tmandry", "tree": {"sha": "57e0c214f2601c35af8a446badc471b312c07801", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/57e0c214f2601c35af8a446badc471b312c07801"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/96d77f0e5f103612d62b85938aacfb33f5768433", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/96d77f0e5f103612d62b85938aacfb33f5768433", "html_url": "https://github.com/rust-lang/rust/commit/96d77f0e5f103612d62b85938aacfb33f5768433", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/96d77f0e5f103612d62b85938aacfb33f5768433/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c835b0cca83fe21090562603e4bda77c183ace3", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c835b0cca83fe21090562603e4bda77c183ace3", "html_url": "https://github.com/rust-lang/rust/commit/0c835b0cca83fe21090562603e4bda77c183ace3"}, {"sha": "209087b8fa26f28c847a5a98afa0bc52ed4f769b", "url": "https://api.github.com/repos/rust-lang/rust/commits/209087b8fa26f28c847a5a98afa0bc52ed4f769b", "html_url": "https://github.com/rust-lang/rust/commit/209087b8fa26f28c847a5a98afa0bc52ed4f769b"}], "stats": {"total": 164, "additions": 116, "deletions": 48}, "files": [{"sha": "cc63f5f39d53cf85b8432dbf60be31ce41a40c29", "filename": "src/librustc_mir/dataflow/impls/storage_liveness.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/96d77f0e5f103612d62b85938aacfb33f5768433/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d77f0e5f103612d62b85938aacfb33f5768433/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=96d77f0e5f103612d62b85938aacfb33f5768433", "patch": "@@ -2,12 +2,21 @@ pub use super::*;\n \n use crate::dataflow::BottomValue;\n use crate::dataflow::{self, GenKill, Results, ResultsRefCursor};\n+use crate::util::storage::AlwaysLiveLocals;\n use rustc_middle::mir::visit::{NonMutatingUseContext, PlaceContext, Visitor};\n use rustc_middle::mir::*;\n use std::cell::RefCell;\n \n-#[derive(Copy, Clone)]\n-pub struct MaybeStorageLive;\n+#[derive(Clone)]\n+pub struct MaybeStorageLive {\n+    always_live_locals: AlwaysLiveLocals,\n+}\n+\n+impl MaybeStorageLive {\n+    pub fn new(always_live_locals: AlwaysLiveLocals) -> Self {\n+        MaybeStorageLive { always_live_locals }\n+    }\n+}\n \n impl dataflow::AnalysisDomain<'tcx> for MaybeStorageLive {\n     type Idx = Local;\n@@ -19,9 +28,12 @@ impl dataflow::AnalysisDomain<'tcx> for MaybeStorageLive {\n     }\n \n     fn initialize_start_block(&self, body: &mir::Body<'tcx>, on_entry: &mut BitSet<Self::Idx>) {\n-        // The resume argument is live on function entry (we don't care about\n-        // the `self` argument)\n-        for arg in body.args_iter().skip(1) {\n+        assert_eq!(body.local_decls.len(), self.always_live_locals.domain_size());\n+        for local in self.always_live_locals.iter() {\n+            on_entry.insert(local);\n+        }\n+\n+        for arg in body.args_iter() {\n             on_entry.insert(arg);\n         }\n     }"}, {"sha": "e0b5f634bf3dfb38e4571bb76dbf1b22c0e8654e", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/96d77f0e5f103612d62b85938aacfb33f5768433/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d77f0e5f103612d62b85938aacfb33f5768433/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=96d77f0e5f103612d62b85938aacfb33f5768433", "patch": "@@ -24,6 +24,7 @@ use super::{\n     Immediate, MPlaceTy, Machine, MemPlace, MemPlaceMeta, Memory, OpTy, Operand, Place, PlaceTy,\n     ScalarMaybeUndef, StackPopJump,\n };\n+use crate::util::storage::AlwaysLiveLocals;\n \n pub struct InterpCx<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     /// Stores the `Machine` instance.\n@@ -610,17 +611,17 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             // Now mark those locals as dead that we do not want to initialize\n             match self.tcx.def_kind(instance.def_id()) {\n                 // statics and constants don't have `Storage*` statements, no need to look for them\n+                //\n+                // FIXME: The above is likely untrue. See\n+                // <https://github.com/rust-lang/rust/pull/70004#issuecomment-602022110>. Is it\n+                // okay to ignore `StorageDead`/`StorageLive` annotations during CTFE?\n                 Some(DefKind::Static) | Some(DefKind::Const) | Some(DefKind::AssocConst) => {}\n                 _ => {\n-                    for block in body.basic_blocks() {\n-                        for stmt in block.statements.iter() {\n-                            use rustc_middle::mir::StatementKind::{StorageDead, StorageLive};\n-                            match stmt.kind {\n-                                StorageLive(local) | StorageDead(local) => {\n-                                    locals[local].value = LocalValue::Dead;\n-                                }\n-                                _ => {}\n-                            }\n+                    // Mark locals that use `Storage*` annotations as dead on function entry.\n+                    let always_live = AlwaysLiveLocals::new(self.body());\n+                    for local in locals.indices() {\n+                        if !always_live.contains(local) {\n+                            locals[local].value = LocalValue::Dead;\n                         }\n                     }\n                 }"}, {"sha": "d25fd8ebb0c2bea75c73acac407a88ff3071539b", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 41, "deletions": 34, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/96d77f0e5f103612d62b85938aacfb33f5768433/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d77f0e5f103612d62b85938aacfb33f5768433/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=96d77f0e5f103612d62b85938aacfb33f5768433", "patch": "@@ -56,12 +56,13 @@ use crate::transform::simplify;\n use crate::transform::{MirPass, MirSource};\n use crate::util::dump_mir;\n use crate::util::liveness;\n+use crate::util::storage;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_index::bit_set::{BitMatrix, BitSet};\n use rustc_index::vec::{Idx, IndexVec};\n-use rustc_middle::mir::visit::{MutVisitor, PlaceContext, Visitor};\n+use rustc_middle::mir::visit::{MutVisitor, PlaceContext};\n use rustc_middle::mir::*;\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::GeneratorSubsts;\n@@ -222,6 +223,9 @@ struct TransformVisitor<'tcx> {\n     // A list of suspension points, generated during the transform\n     suspension_points: Vec<SuspensionPoint<'tcx>>,\n \n+    // The set of locals that have no `StorageLive`/`StorageDead` annotations.\n+    always_live_locals: storage::AlwaysLiveLocals,\n+\n     // The original RETURN_PLACE local\n     new_ret_local: Local,\n }\n@@ -416,19 +420,6 @@ fn replace_local<'tcx>(\n     new_local\n }\n \n-struct StorageIgnored(liveness::LiveVarSet);\n-\n-impl<'tcx> Visitor<'tcx> for StorageIgnored {\n-    fn visit_statement(&mut self, statement: &Statement<'tcx>, _location: Location) {\n-        match statement.kind {\n-            StatementKind::StorageLive(l) | StatementKind::StorageDead(l) => {\n-                self.0.remove(l);\n-            }\n-            _ => (),\n-        }\n-    }\n-}\n-\n struct LivenessInfo {\n     /// Which locals are live across any suspension point.\n     ///\n@@ -454,23 +445,19 @@ fn locals_live_across_suspend_points(\n     tcx: TyCtxt<'tcx>,\n     body: ReadOnlyBodyAndCache<'_, 'tcx>,\n     source: MirSource<'tcx>,\n+    always_live_locals: &storage::AlwaysLiveLocals,\n     movable: bool,\n ) -> LivenessInfo {\n     let def_id = source.def_id();\n     let body_ref: &Body<'_> = &body;\n \n     // Calculate when MIR locals have live storage. This gives us an upper bound of their\n     // lifetimes.\n-    let mut storage_live = MaybeStorageLive\n+    let mut storage_live = MaybeStorageLive::new(always_live_locals.clone())\n         .into_engine(tcx, body_ref, def_id)\n         .iterate_to_fixpoint()\n         .into_results_cursor(body_ref);\n \n-    // Find the MIR locals which do not use StorageLive/StorageDead statements.\n-    // The storage of these locals are always live.\n-    let mut ignored = StorageIgnored(BitSet::new_filled(body.local_decls.len()));\n-    ignored.visit_body(&body);\n-\n     // Calculate the MIR locals which have been previously\n     // borrowed (even if they are still active).\n     let borrowed_locals_results =\n@@ -515,11 +502,14 @@ fn locals_live_across_suspend_points(\n             }\n \n             storage_live.seek_before(loc);\n-            let storage_liveness = storage_live.get();\n+            let mut storage_liveness = storage_live.get().clone();\n+\n+            // Later passes handle the generator's `self` argument separately.\n+            storage_liveness.remove(SELF_ARG);\n \n             // Store the storage liveness for later use so we can restore the state\n             // after a suspension point\n-            storage_liveness_map.insert(block, storage_liveness.clone());\n+            storage_liveness_map.insert(block, storage_liveness);\n \n             requires_storage_cursor.seek_before(loc);\n             let storage_required = requires_storage_cursor.get().clone();\n@@ -551,8 +541,12 @@ fn locals_live_across_suspend_points(\n         .map(|live_here| renumber_bitset(&live_here, &live_locals))\n         .collect();\n \n-    let storage_conflicts =\n-        compute_storage_conflicts(body_ref, &live_locals, &ignored, requires_storage_results);\n+    let storage_conflicts = compute_storage_conflicts(\n+        body_ref,\n+        &live_locals,\n+        always_live_locals.clone(),\n+        requires_storage_results,\n+    );\n \n     LivenessInfo {\n         live_locals,\n@@ -590,18 +584,18 @@ fn renumber_bitset(\n fn compute_storage_conflicts(\n     body: &'mir Body<'tcx>,\n     stored_locals: &liveness::LiveVarSet,\n-    ignored: &StorageIgnored,\n+    always_live_locals: storage::AlwaysLiveLocals,\n     requires_storage: dataflow::Results<'tcx, MaybeRequiresStorage<'mir, 'tcx>>,\n ) -> BitMatrix<GeneratorSavedLocal, GeneratorSavedLocal> {\n-    assert_eq!(body.local_decls.len(), ignored.0.domain_size());\n     assert_eq!(body.local_decls.len(), stored_locals.domain_size());\n+\n     debug!(\"compute_storage_conflicts({:?})\", body.span);\n-    debug!(\"ignored = {:?}\", ignored.0);\n+    debug!(\"always_live = {:?}\", always_live_locals);\n \n-    // Storage ignored locals are not eligible for overlap, since their storage\n-    // is always live.\n-    let mut ineligible_locals = ignored.0.clone();\n-    ineligible_locals.intersect(&stored_locals);\n+    // Locals that are always live or ones that need to be stored across\n+    // suspension points are not eligible for overlap.\n+    let mut ineligible_locals = always_live_locals.into_inner();\n+    ineligible_locals.intersect(stored_locals);\n \n     // Compute the storage conflicts for all eligible locals.\n     let mut visitor = StorageConflictVisitor {\n@@ -697,6 +691,7 @@ fn compute_layout<'tcx>(\n     source: MirSource<'tcx>,\n     upvars: &Vec<Ty<'tcx>>,\n     interior: Ty<'tcx>,\n+    always_live_locals: &storage::AlwaysLiveLocals,\n     movable: bool,\n     body: &mut BodyAndCache<'tcx>,\n ) -> (\n@@ -710,7 +705,13 @@ fn compute_layout<'tcx>(\n         live_locals_at_suspension_points,\n         storage_conflicts,\n         storage_liveness,\n-    } = locals_live_across_suspend_points(tcx, read_only!(body), source, movable);\n+    } = locals_live_across_suspend_points(\n+        tcx,\n+        read_only!(body),\n+        source,\n+        always_live_locals,\n+        movable,\n+    );\n \n     // Erase regions from the types passed in from typeck so we can compare them with\n     // MIR types\n@@ -1180,7 +1181,10 @@ fn create_cases<'tcx>(\n                     }\n \n                     let l = Local::new(i);\n-                    if point.storage_liveness.contains(l) && !transform.remap.contains_key(&l) {\n+                    let needs_storage_live = point.storage_liveness.contains(l)\n+                        && !transform.remap.contains_key(&l)\n+                        && !transform.always_live_locals.contains(l);\n+                    if needs_storage_live {\n                         statements\n                             .push(Statement { source_info, kind: StatementKind::StorageLive(l) });\n                     }\n@@ -1276,11 +1280,13 @@ impl<'tcx> MirPass<'tcx> for StateTransform {\n             },\n         );\n \n+        let always_live_locals = storage::AlwaysLiveLocals::new(&body);\n+\n         // Extract locals which are live across suspension point into `layout`\n         // `remap` gives a mapping from local indices onto generator struct indices\n         // `storage_liveness` tells us which locals have live storage at suspension points\n         let (remap, layout, storage_liveness) =\n-            compute_layout(tcx, source, &upvars, interior, movable, body);\n+            compute_layout(tcx, source, &upvars, interior, &always_live_locals, movable, body);\n \n         let can_return = can_return(tcx, body);\n \n@@ -1294,6 +1300,7 @@ impl<'tcx> MirPass<'tcx> for StateTransform {\n             state_substs,\n             remap,\n             storage_liveness,\n+            always_live_locals,\n             suspension_points: Vec::new(),\n             new_ret_local,\n             discr_ty,"}, {"sha": "3e501193e8dc4b97d8c80279d3059c27eab7eec1", "filename": "src/librustc_mir/util/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/96d77f0e5f103612d62b85938aacfb33f5768433/src%2Flibrustc_mir%2Futil%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d77f0e5f103612d62b85938aacfb33f5768433/src%2Flibrustc_mir%2Futil%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fmod.rs?ref=96d77f0e5f103612d62b85938aacfb33f5768433", "patch": "@@ -3,6 +3,7 @@ pub mod borrowck_errors;\n pub mod def_use;\n pub mod elaborate_drops;\n pub mod patch;\n+pub mod storage;\n \n mod alignment;\n pub mod collect_writes;"}, {"sha": "0b7b1c29537f590eb9a8088849c17c412d352b64", "filename": "src/librustc_mir/util/storage.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/96d77f0e5f103612d62b85938aacfb33f5768433/src%2Flibrustc_mir%2Futil%2Fstorage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d77f0e5f103612d62b85938aacfb33f5768433/src%2Flibrustc_mir%2Futil%2Fstorage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fstorage.rs?ref=96d77f0e5f103612d62b85938aacfb33f5768433", "patch": "@@ -0,0 +1,47 @@\n+use rustc_index::bit_set::BitSet;\n+use rustc_middle::mir::visit::Visitor;\n+use rustc_middle::mir::{self, Local, Location};\n+\n+/// The set of locals in a MIR body that do not have `StorageLive`/`StorageDead` annotations.\n+///\n+/// These locals have fixed storage for the duration of the body.\n+//\n+// FIXME: Currently, we need to traverse the entire MIR to compute this. We should instead store it\n+// as a field in the `LocalDecl` for each `Local`.\n+#[derive(Debug, Clone)]\n+pub struct AlwaysLiveLocals(BitSet<Local>);\n+\n+impl AlwaysLiveLocals {\n+    pub fn new(body: &mir::Body<'tcx>) -> Self {\n+        let mut ret = AlwaysLiveLocals(BitSet::new_filled(body.local_decls.len()));\n+\n+        let mut vis = StorageAnnotationVisitor(&mut ret);\n+        vis.visit_body(body);\n+\n+        ret\n+    }\n+\n+    pub fn into_inner(self) -> BitSet<Local> {\n+        self.0\n+    }\n+}\n+\n+impl std::ops::Deref for AlwaysLiveLocals {\n+    type Target = BitSet<Local>;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+/// Removes locals that have `Storage*` annotations from `AlwaysLiveLocals`.\n+struct StorageAnnotationVisitor<'a>(&'a mut AlwaysLiveLocals);\n+\n+impl Visitor<'tcx> for StorageAnnotationVisitor<'_> {\n+    fn visit_statement(&mut self, statement: &mir::Statement<'tcx>, _location: Location) {\n+        use mir::StatementKind::{StorageDead, StorageLive};\n+        if let StorageLive(l) | StorageDead(l) = statement.kind {\n+            (self.0).0.remove(l);\n+        }\n+    }\n+}"}]}