{"sha": "6755fb8ba2300a121cb14bd79327c3eb730bc55d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3NTVmYjhiYTIzMDBhMTIxY2IxNGJkNzkzMjdjM2ViNzMwYmM1NWQ=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-02-26T14:21:26Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-03-02T20:38:21Z"}, "message": "schedule drops on bindings only after initializing them\n\nThis reduces the number of dynamic drops in libstd from 1141 to 899.\nHowever, without this change, the next patch would have created much\nmore dynamic drops.\n\nA basic merge unswitching hack reduced the number of dynamic drops to\n644, with no effect on stack usage. I should be writing a more dedicated\ndrop unswitching pass.\n\nNo performance measurements.", "tree": {"sha": "c5ac2bcc040c3ded0be760b28dac745caf947082", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c5ac2bcc040c3ded0be760b28dac745caf947082"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6755fb8ba2300a121cb14bd79327c3eb730bc55d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6755fb8ba2300a121cb14bd79327c3eb730bc55d", "html_url": "https://github.com/rust-lang/rust/commit/6755fb8ba2300a121cb14bd79327c3eb730bc55d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6755fb8ba2300a121cb14bd79327c3eb730bc55d/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5907ed63d329daefcd1680813d57e5ca00cd2fc2", "url": "https://api.github.com/repos/rust-lang/rust/commits/5907ed63d329daefcd1680813d57e5ca00cd2fc2", "html_url": "https://github.com/rust-lang/rust/commit/5907ed63d329daefcd1680813d57e5ca00cd2fc2"}], "stats": {"total": 170, "additions": 98, "deletions": 72}, "files": [{"sha": "a71d23e7e1e7ecf98a717219448c53dc0e8fd4fd", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6755fb8ba2300a121cb14bd79327c3eb730bc55d/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6755fb8ba2300a121cb14bd79327c3eb730bc55d/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=6755fb8ba2300a121cb14bd79327c3eb730bc55d", "patch": "@@ -161,6 +161,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n     fn create_drop_flag(&mut self, index: MovePathIndex) {\n         let tcx = self.tcx;\n         let patch = &mut self.patch;\n+        debug!(\"create_drop_flag({:?})\", self.mir.span);\n         self.drop_flags.entry(index).or_insert_with(|| {\n             patch.new_temp(tcx.types.bool)\n         });"}, {"sha": "3305cfc0dfe1a54a6cf4a461de8be5587cb4d1f7", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6755fb8ba2300a121cb14bd79327c3eb730bc55d/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6755fb8ba2300a121cb14bd79327c3eb730bc55d/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=6755fb8ba2300a121cb14bd79327c3eb730bc55d", "patch": "@@ -67,7 +67,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                 this.expr_into_pattern(block, pattern, init)\n                             }));\n                         } else {\n-                            this.storage_live_for_bindings(block, &pattern);\n+                            this.visit_bindings(&pattern, &mut |this, _, _, node, span, _| {\n+                                this.storage_live_binding(block, node, span);\n+                                this.schedule_drop_for_binding(node, span);\n+                            })\n                         }\n \n                         // Enter the visibility scope, after evaluating the initializer."}, {"sha": "fd39f511e6d6ec9d6a42a589b10655e6c452e3e6", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 50, "deletions": 70, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/6755fb8ba2300a121cb14bd79327c3eb730bc55d/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6755fb8ba2300a121cb14bd79327c3eb730bc55d/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=6755fb8ba2300a121cb14bd79327c3eb730bc55d", "patch": "@@ -123,16 +123,16 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             PatternKind::Binding { mode: BindingMode::ByValue,\n                                    var,\n                                    subpattern: None, .. } => {\n-                self.storage_live_for_bindings(block, &irrefutable_pat);\n-                let lvalue = Lvalue::Local(self.var_indices[&var]);\n-                return self.into(&lvalue, block, initializer);\n+                let lvalue = self.storage_live_binding(block, var, irrefutable_pat.span);\n+                unpack!(block = self.into(&lvalue, block, initializer));\n+                self.schedule_drop_for_binding(var, irrefutable_pat.span);\n+                block.unit()\n+            }\n+            _ => {\n+                let lvalue = unpack!(block = self.as_lvalue(block, initializer));\n+                self.lvalue_into_pattern(block, irrefutable_pat, &lvalue)\n             }\n-            _ => {}\n         }\n-        let lvalue = unpack!(block = self.as_lvalue(block, initializer));\n-        self.lvalue_into_pattern(block,\n-                                 irrefutable_pat,\n-                                 &lvalue)\n     }\n \n     pub fn lvalue_into_pattern(&mut self,\n@@ -174,79 +174,70 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                             scope_span: Span,\n                             pattern: &Pattern<'tcx>)\n                             -> Option<VisibilityScope> {\n-        match *pattern.kind {\n-            PatternKind::Binding { mutability, name, mode: _, var, ty, ref subpattern } => {\n-                if var_scope.is_none() {\n-                    var_scope = Some(self.new_visibility_scope(scope_span));\n-                }\n-                let source_info = SourceInfo {\n-                    span: pattern.span,\n-                    scope: var_scope.unwrap()\n-                };\n-                self.declare_binding(source_info, mutability, name, var, ty);\n-                if let Some(subpattern) = subpattern.as_ref() {\n-                    var_scope = self.declare_bindings(var_scope, scope_span, subpattern);\n-                }\n-            }\n-            PatternKind::Array { ref prefix, ref slice, ref suffix } |\n-            PatternKind::Slice { ref prefix, ref slice, ref suffix } => {\n-                for subpattern in prefix.iter().chain(slice).chain(suffix) {\n-                    var_scope = self.declare_bindings(var_scope, scope_span, subpattern);\n-                }\n-            }\n-            PatternKind::Constant { .. } | PatternKind::Range { .. } | PatternKind::Wild => {\n-            }\n-            PatternKind::Deref { ref subpattern } => {\n-                var_scope = self.declare_bindings(var_scope, scope_span, subpattern);\n-            }\n-            PatternKind::Leaf { ref subpatterns } |\n-            PatternKind::Variant { ref subpatterns, .. } => {\n-                for subpattern in subpatterns {\n-                    var_scope = self.declare_bindings(var_scope, scope_span, &subpattern.pattern);\n-                }\n+        self.visit_bindings(pattern, &mut |this, mutability, name, var, span, ty| {\n+            if var_scope.is_none() {\n+                var_scope = Some(this.new_visibility_scope(scope_span));\n             }\n-        }\n+            let source_info = SourceInfo {\n+                span: span,\n+                scope: var_scope.unwrap()\n+            };\n+            this.declare_binding(source_info, mutability, name, var, ty);\n+        });\n         var_scope\n     }\n \n-    /// Emit `StorageLive` for every binding in the pattern.\n-    pub fn storage_live_for_bindings(&mut self,\n-                                     block: BasicBlock,\n-                                     pattern: &Pattern<'tcx>) {\n-        match *pattern.kind {\n-            PatternKind::Binding { var, ref subpattern, .. } => {\n-                let lvalue = Lvalue::Local(self.var_indices[&var]);\n-                let source_info = self.source_info(pattern.span);\n-                self.cfg.push(block, Statement {\n-                    source_info: source_info,\n-                    kind: StatementKind::StorageLive(lvalue)\n-                });\n+    pub fn storage_live_binding(&mut self, block: BasicBlock, var: NodeId, span: Span)\n+                            -> Lvalue<'tcx>\n+    {\n+        let local_id = self.var_indices[&var];\n+        let source_info = self.source_info(span);\n+        self.cfg.push(block, Statement {\n+            source_info: source_info,\n+            kind: StatementKind::StorageLive(Lvalue::Local(local_id))\n+        });\n+        Lvalue::Local(local_id)\n+    }\n \n+    pub fn schedule_drop_for_binding(&mut self, var: NodeId, span: Span) {\n+        let local_id = self.var_indices[&var];\n+        let var_ty = self.local_decls[local_id].ty;\n+        let extent = self.hir.tcx().region_maps.var_scope(var);\n+        self.schedule_drop(span, extent, &Lvalue::Local(local_id), var_ty);\n+    }\n+\n+    pub fn visit_bindings<F>(&mut self, pattern: &Pattern<'tcx>, mut f: &mut F)\n+        where F: FnMut(&mut Self, Mutability, Name, NodeId, Span, Ty<'tcx>)\n+    {\n+        match *pattern.kind {\n+            PatternKind::Binding { mutability, name, var, ty, ref subpattern, .. } => {\n+                f(self, mutability, name, var, pattern.span, ty);\n                 if let Some(subpattern) = subpattern.as_ref() {\n-                    self.storage_live_for_bindings(block, subpattern);\n+                    self.visit_bindings(subpattern, f);\n                 }\n             }\n             PatternKind::Array { ref prefix, ref slice, ref suffix } |\n             PatternKind::Slice { ref prefix, ref slice, ref suffix } => {\n                 for subpattern in prefix.iter().chain(slice).chain(suffix) {\n-                    self.storage_live_for_bindings(block, subpattern);\n+                    self.visit_bindings(subpattern, f);\n                 }\n             }\n             PatternKind::Constant { .. } | PatternKind::Range { .. } | PatternKind::Wild => {\n             }\n             PatternKind::Deref { ref subpattern } => {\n-                self.storage_live_for_bindings(block, subpattern);\n+                self.visit_bindings(subpattern, f);\n             }\n             PatternKind::Leaf { ref subpatterns } |\n             PatternKind::Variant { ref subpatterns, .. } => {\n                 for subpattern in subpatterns {\n-                    self.storage_live_for_bindings(block, &subpattern.pattern);\n+                    self.visit_bindings(&subpattern.pattern, f);\n                 }\n             }\n         }\n     }\n }\n \n+\n /// List of blocks for each arm (and potentially other metadata in the\n /// future).\n struct ArmBlocks {\n@@ -691,25 +682,16 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n         // Assign each of the bindings. This may trigger moves out of the candidate.\n         for binding in bindings {\n-            // Find the variable for the `var_id` being bound. It\n-            // should have been created by a previous call to\n-            // `declare_bindings`.\n-            let var_index = self.var_indices[&binding.var_id];\n-\n+            let source_info = self.source_info(binding.span);\n+            let local = self.storage_live_binding(block, binding.var_id, binding.span);\n+            self.schedule_drop_for_binding(binding.var_id, binding.span);\n             let rvalue = match binding.binding_mode {\n                 BindingMode::ByValue =>\n                     Rvalue::Use(Operand::Consume(binding.source)),\n                 BindingMode::ByRef(region, borrow_kind) =>\n                     Rvalue::Ref(region, borrow_kind, binding.source),\n             };\n-\n-            let source_info = self.source_info(binding.span);\n-            self.cfg.push(block, Statement {\n-                source_info: source_info,\n-                kind: StatementKind::StorageLive(Lvalue::Local(var_index))\n-            });\n-            self.cfg.push_assign(block, source_info,\n-                                 &Lvalue::Local(var_index), rvalue);\n+            self.cfg.push_assign(block, source_info, &local, rvalue);\n         }\n     }\n \n@@ -730,8 +712,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             name: Some(name),\n             source_info: Some(source_info),\n         });\n-        let extent = self.hir.tcx().region_maps.var_scope(var_id);\n-        self.schedule_drop(source_info.span, extent, &Lvalue::Local(var), var_ty);\n         self.var_indices.insert(var_id, var);\n \n         debug!(\"declare_binding: var={:?}\", var);"}, {"sha": "c63db741e5ae8843bc1847dd1009cf34bc1abb29", "filename": "src/test/mir-opt/storage_ranges.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6755fb8ba2300a121cb14bd79327c3eb730bc55d/src%2Ftest%2Fmir-opt%2Fstorage_ranges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6755fb8ba2300a121cb14bd79327c3eb730bc55d/src%2Ftest%2Fmir-opt%2Fstorage_ranges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fstorage_ranges.rs?ref=6755fb8ba2300a121cb14bd79327c3eb730bc55d", "patch": "@@ -31,8 +31,8 @@ fn main() {\n //         _3 = &_4;\n //         StorageDead(_5);\n //         _2 = ();\n-//         StorageDead(_4);\n //         StorageDead(_3);\n+//         StorageDead(_4);\n //         StorageLive(_6);\n //         _6 = const 1i32;\n //         _0 = ();"}, {"sha": "55ac5ca067bf8a5ea32d7598a5e276636d8b4aa9", "filename": "src/test/run-pass/mir_drop_order.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/6755fb8ba2300a121cb14bd79327c3eb730bc55d/src%2Ftest%2Frun-pass%2Fmir_drop_order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6755fb8ba2300a121cb14bd79327c3eb730bc55d/src%2Ftest%2Frun-pass%2Fmir_drop_order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_drop_order.rs?ref=6755fb8ba2300a121cb14bd79327c3eb730bc55d", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::cell::RefCell;\n+\n+pub struct DropLogger<'a> {\n+    id: usize,\n+    log: &'a RefCell<Vec<usize>>\n+}\n+\n+impl<'a> Drop for DropLogger<'a> {\n+    fn drop(&mut self) {\n+        self.log.borrow_mut().push(self.id);\n+    }\n+}\n+\n+fn main() {\n+    let log = RefCell::new(vec![]);\n+    let d = |id| DropLogger { id: id, log: &log };\n+    let get = || -> Vec<_> {\n+        let mut m = log.borrow_mut();\n+        let n = m.drain(..);\n+        n.collect()\n+    };\n+\n+    {\n+        let _x = (d(0), &d(1), d(2), &d(3));\n+        // all borrows are extended - nothing has been dropped yet\n+        assert_eq!(get(), vec![]);\n+    }\n+    // in a let-statement, extended lvalues are dropped\n+    // *after* the let result (tho they have the same scope\n+    // as far as scope-based borrowck goes).\n+    assert_eq!(get(), vec![0, 2, 3, 1]);\n+}"}]}