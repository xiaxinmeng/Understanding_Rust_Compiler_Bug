{"sha": "772b1ce74524854b290191768373c700f7d38c75", "node_id": "C_kwDOAAsO6NoAKDc3MmIxY2U3NDUyNDg1NGIyOTAxOTE3NjgzNzNjNzAwZjdkMzhjNzU", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-03-10T18:59:20Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-03-10T18:59:20Z"}, "message": "Rollup merge of #108937 - lcnr:winnowing-enum, r=WaffleLapkin\n\nimprove readability of winnowing", "tree": {"sha": "11579bdbf9d337813e3cea7fabeb0210b9d6dcea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/11579bdbf9d337813e3cea7fabeb0210b9d6dcea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/772b1ce74524854b290191768373c700f7d38c75", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkC34ICRBK7hj4Ov3rIwAAVb0IAEsn0ZfXlmNZsnDbb7WUneEy\nD31e/FN62sqRARfzbYvPUadcqsjlT8muUtg/Ji4WFW2OD7XqukdzMVzfcm9HNgEq\nAHCWwlmCZcFrnGrI5qLzqeOagjOypPD9+XsbpMWWCVTlnGyUcJ+0OKIUCb24y9a0\n4IDy2bt2p1K4D+gpiqiY/RGRy1h1WblJtgv7HibWn4K/LgNe3VodfCj1mVFUYR89\nttAmxjCaflKqcJal/jO9ggXcUcvBcMjZttjUPPt/GLC2Offg37FY5oe1bs18X9Jg\n/R/CCST284kHM/J/ssU0P11f8j5T1ufrULE04gaeBUIkHYwKpyOfZiDLOPkekJw=\n=Iguy\n-----END PGP SIGNATURE-----\n", "payload": "tree 11579bdbf9d337813e3cea7fabeb0210b9d6dcea\nparent 76994625f82fdb8d92c3ca6ffeec3a824880b07d\nparent 14818e28d10f2dfb3e0bddbe3140b2cab7763442\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1678474760 +0100\ncommitter GitHub <noreply@github.com> 1678474760 +0100\n\nRollup merge of #108937 - lcnr:winnowing-enum, r=WaffleLapkin\n\nimprove readability of winnowing\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/772b1ce74524854b290191768373c700f7d38c75", "html_url": "https://github.com/rust-lang/rust/commit/772b1ce74524854b290191768373c700f7d38c75", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/772b1ce74524854b290191768373c700f7d38c75/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76994625f82fdb8d92c3ca6ffeec3a824880b07d", "url": "https://api.github.com/repos/rust-lang/rust/commits/76994625f82fdb8d92c3ca6ffeec3a824880b07d", "html_url": "https://github.com/rust-lang/rust/commit/76994625f82fdb8d92c3ca6ffeec3a824880b07d"}, {"sha": "14818e28d10f2dfb3e0bddbe3140b2cab7763442", "url": "https://api.github.com/repos/rust-lang/rust/commits/14818e28d10f2dfb3e0bddbe3140b2cab7763442", "html_url": "https://github.com/rust-lang/rust/commit/14818e28d10f2dfb3e0bddbe3140b2cab7763442"}], "stats": {"total": 107, "additions": 67, "deletions": 40}, "files": [{"sha": "ba4df2b3720efbbb041f89f63e8a39ab9adea0b5", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 67, "deletions": 40, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/772b1ce74524854b290191768373c700f7d38c75/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/772b1ce74524854b290191768373c700f7d38c75/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=772b1ce74524854b290191768373c700f7d38c75", "patch": "@@ -465,14 +465,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         if candidates.len() > 1 {\n             let mut i = 0;\n             while i < candidates.len() {\n-                let is_dup = (0..candidates.len()).filter(|&j| i != j).any(|j| {\n+                let should_drop_i = (0..candidates.len()).filter(|&j| i != j).any(|j| {\n                     self.candidate_should_be_dropped_in_favor_of(\n                         &candidates[i],\n                         &candidates[j],\n                         needs_infer,\n-                    )\n+                    ) == DropVictim::Yes\n                 });\n-                if is_dup {\n+                if should_drop_i {\n                     debug!(candidate = ?candidates[i], \"Dropping candidate #{}/{}\", i, candidates.len());\n                     candidates.swap_remove(i);\n                 } else {\n@@ -1842,16 +1842,22 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             ProjectionMatchesProjection::No\n         }\n     }\n+}\n \n-    ///////////////////////////////////////////////////////////////////////////\n-    // WINNOW\n-    //\n-    // Winnowing is the process of attempting to resolve ambiguity by\n-    // probing further. During the winnowing process, we unify all\n-    // type variables and then we also attempt to evaluate recursive\n-    // bounds to see if they are satisfied.\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+enum DropVictim {\n+    Yes,\n+    No,\n+}\n \n-    /// Returns `true` if `victim` should be dropped in favor of\n+/// ## Winnowing\n+///\n+/// Winnowing is the process of attempting to resolve ambiguity by\n+/// probing further. During the winnowing process, we unify all\n+/// type variables and then we also attempt to evaluate recursive\n+/// bounds to see if they are satisfied.\n+impl<'tcx> SelectionContext<'_, 'tcx> {\n+    /// Returns `DropVictim::Yes` if `victim` should be dropped in favor of\n     /// `other`. Generally speaking we will drop duplicate\n     /// candidates and prefer where-clause candidates.\n     ///\n@@ -1861,9 +1867,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         victim: &EvaluatedCandidate<'tcx>,\n         other: &EvaluatedCandidate<'tcx>,\n         needs_infer: bool,\n-    ) -> bool {\n+    ) -> DropVictim {\n         if victim.candidate == other.candidate {\n-            return true;\n+            return DropVictim::Yes;\n         }\n \n         // Check if a bound would previously have been removed when normalizing\n@@ -1887,11 +1893,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             // FIXME(@jswrenn): this should probably be more sophisticated\n-            (TransmutabilityCandidate, _) | (_, TransmutabilityCandidate) => false,\n+            (TransmutabilityCandidate, _) | (_, TransmutabilityCandidate) => DropVictim::No,\n \n             // (*)\n-            (BuiltinCandidate { has_nested: false } | ConstDestructCandidate(_), _) => true,\n-            (_, BuiltinCandidate { has_nested: false } | ConstDestructCandidate(_)) => false,\n+            (BuiltinCandidate { has_nested: false } | ConstDestructCandidate(_), _) => {\n+                DropVictim::Yes\n+            }\n+            (_, BuiltinCandidate { has_nested: false } | ConstDestructCandidate(_)) => {\n+                DropVictim::No\n+            }\n \n             (ParamCandidate(other), ParamCandidate(victim)) => {\n                 let same_except_bound_vars = other.skip_binder().trait_ref\n@@ -1905,28 +1915,27 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     // or the current one if tied (they should both evaluate to the same answer). This is\n                     // probably best characterized as a \"hack\", since we might prefer to just do our\n                     // best to *not* create essentially duplicate candidates in the first place.\n-                    other.bound_vars().len() <= victim.bound_vars().len()\n+                    if other.bound_vars().len() <= victim.bound_vars().len() {\n+                        DropVictim::Yes\n+                    } else {\n+                        DropVictim::No\n+                    }\n                 } else if other.skip_binder().trait_ref == victim.skip_binder().trait_ref\n                     && victim.skip_binder().constness == ty::BoundConstness::NotConst\n                     && other.skip_binder().polarity == victim.skip_binder().polarity\n                 {\n                     // Drop otherwise equivalent non-const candidates in favor of const candidates.\n-                    true\n+                    DropVictim::Yes\n                 } else {\n-                    false\n+                    DropVictim::No\n                 }\n             }\n \n             // Drop otherwise equivalent non-const fn pointer candidates\n-            (FnPointerCandidate { .. }, FnPointerCandidate { is_const: false }) => true,\n+            (FnPointerCandidate { .. }, FnPointerCandidate { is_const: false }) => DropVictim::Yes,\n \n-            // Global bounds from the where clause should be ignored\n-            // here (see issue #50825). Otherwise, we have a where\n-            // clause so don't go around looking for impls.\n-            // Arbitrarily give param candidates priority\n-            // over projection and object candidates.\n             (\n-                ParamCandidate(ref cand),\n+                ParamCandidate(ref other_cand),\n                 ImplCandidate(..)\n                 | ClosureCandidate { .. }\n                 | GeneratorCandidate\n@@ -1939,11 +1948,23 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 | TraitAliasCandidate\n                 | ObjectCandidate(_)\n                 | ProjectionCandidate(..),\n-            ) => !is_global(cand),\n-            (ObjectCandidate(_) | ProjectionCandidate(..), ParamCandidate(ref cand)) => {\n+            ) => {\n+                if is_global(other_cand) {\n+                    DropVictim::No\n+                } else {\n+                    // We have a where clause so don't go around looking\n+                    // for impls. Arbitrarily give param candidates priority\n+                    // over projection and object candidates.\n+                    //\n+                    // Global bounds from the where clause should be ignored\n+                    // here (see issue #50825).\n+                    DropVictim::Yes\n+                }\n+            }\n+            (ObjectCandidate(_) | ProjectionCandidate(..), ParamCandidate(ref victim_cand)) => {\n                 // Prefer these to a global where-clause bound\n                 // (see issue #50825).\n-                is_global(cand)\n+                if is_global(victim_cand) { DropVictim::Yes } else { DropVictim::No }\n             }\n             (\n                 ImplCandidate(_)\n@@ -1956,18 +1977,22 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 | TraitUpcastingUnsizeCandidate(_)\n                 | BuiltinCandidate { has_nested: true }\n                 | TraitAliasCandidate,\n-                ParamCandidate(ref cand),\n+                ParamCandidate(ref victim_cand),\n             ) => {\n                 // Prefer these to a global where-clause bound\n                 // (see issue #50825).\n-                is_global(cand) && other.evaluation.must_apply_modulo_regions()\n+                if is_global(victim_cand) && other.evaluation.must_apply_modulo_regions() {\n+                    DropVictim::Yes\n+                } else {\n+                    DropVictim::No\n+                }\n             }\n \n             (ProjectionCandidate(i, _), ProjectionCandidate(j, _))\n             | (ObjectCandidate(i), ObjectCandidate(j)) => {\n                 // Arbitrarily pick the lower numbered candidate for backwards\n                 // compatibility reasons. Don't let this affect inference.\n-                i < j && !needs_infer\n+                if i < j && !needs_infer { DropVictim::Yes } else { DropVictim::No }\n             }\n             (ObjectCandidate(_), ProjectionCandidate(..))\n             | (ProjectionCandidate(..), ObjectCandidate(_)) => {\n@@ -1987,7 +2012,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 | TraitUpcastingUnsizeCandidate(_)\n                 | BuiltinCandidate { .. }\n                 | TraitAliasCandidate,\n-            ) => true,\n+            ) => DropVictim::Yes,\n \n             (\n                 ImplCandidate(..)\n@@ -2001,7 +2026,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 | BuiltinCandidate { .. }\n                 | TraitAliasCandidate,\n                 ObjectCandidate(_) | ProjectionCandidate(..),\n-            ) => false,\n+            ) => DropVictim::No,\n \n             (&ImplCandidate(other_def), &ImplCandidate(victim_def)) => {\n                 // See if we can toss out `victim` based on specialization.\n@@ -2014,7 +2039,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 let tcx = self.tcx();\n                 if other.evaluation.must_apply_modulo_regions() {\n                     if tcx.specializes((other_def, victim_def)) {\n-                        return true;\n+                        return DropVictim::Yes;\n                     }\n                 }\n \n@@ -2060,13 +2085,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             // will then correctly report an inference error, since the\n                             // existence of multiple marker trait impls tells us nothing\n                             // about which one should actually apply.\n-                            !needs_infer\n+                            if needs_infer { DropVictim::No } else { DropVictim::Yes }\n                         }\n-                        Some(_) => true,\n-                        None => false,\n+                        Some(_) => DropVictim::Yes,\n+                        None => DropVictim::No,\n                     }\n                 } else {\n-                    false\n+                    DropVictim::No\n                 }\n             }\n \n@@ -2092,10 +2117,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 | TraitUpcastingUnsizeCandidate(_)\n                 | BuiltinCandidate { has_nested: true }\n                 | TraitAliasCandidate,\n-            ) => false,\n+            ) => DropVictim::No,\n         }\n     }\n+}\n \n+impl<'tcx> SelectionContext<'_, 'tcx> {\n     fn sized_conditions(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,"}]}