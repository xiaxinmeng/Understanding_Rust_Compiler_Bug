{"sha": "20e0395e66557a1be055ec3f11c35082bf9a5882", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwZTAzOTVlNjY1NTdhMWJlMDU1ZWMzZjExYzM1MDgyYmY5YTU4ODI=", "commit": {"author": {"name": "Yu Ding", "email": "dingelish@gmail.com", "date": "2019-01-01T22:55:33Z"}, "committer": {"name": "Yu Ding", "email": "dingelish@gmail.com", "date": "2019-01-01T22:55:33Z"}, "message": "Merge remote-tracking branch 'upstream/master'", "tree": {"sha": "7f83f22970099230abe62cb398e3e3ba8e585f4e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f83f22970099230abe62cb398e3e3ba8e585f4e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/20e0395e66557a1be055ec3f11c35082bf9a5882", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/20e0395e66557a1be055ec3f11c35082bf9a5882", "html_url": "https://github.com/rust-lang/rust/commit/20e0395e66557a1be055ec3f11c35082bf9a5882", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/20e0395e66557a1be055ec3f11c35082bf9a5882/comments", "author": {"login": "dingelish", "id": 1870436, "node_id": "MDQ6VXNlcjE4NzA0MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1870436?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dingelish", "html_url": "https://github.com/dingelish", "followers_url": "https://api.github.com/users/dingelish/followers", "following_url": "https://api.github.com/users/dingelish/following{/other_user}", "gists_url": "https://api.github.com/users/dingelish/gists{/gist_id}", "starred_url": "https://api.github.com/users/dingelish/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dingelish/subscriptions", "organizations_url": "https://api.github.com/users/dingelish/orgs", "repos_url": "https://api.github.com/users/dingelish/repos", "events_url": "https://api.github.com/users/dingelish/events{/privacy}", "received_events_url": "https://api.github.com/users/dingelish/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dingelish", "id": 1870436, "node_id": "MDQ6VXNlcjE4NzA0MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1870436?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dingelish", "html_url": "https://github.com/dingelish", "followers_url": "https://api.github.com/users/dingelish/followers", "following_url": "https://api.github.com/users/dingelish/following{/other_user}", "gists_url": "https://api.github.com/users/dingelish/gists{/gist_id}", "starred_url": "https://api.github.com/users/dingelish/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dingelish/subscriptions", "organizations_url": "https://api.github.com/users/dingelish/orgs", "repos_url": "https://api.github.com/users/dingelish/repos", "events_url": "https://api.github.com/users/dingelish/events{/privacy}", "received_events_url": "https://api.github.com/users/dingelish/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a3128116d258d2d715f55062f25ab9debe79be14", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3128116d258d2d715f55062f25ab9debe79be14", "html_url": "https://github.com/rust-lang/rust/commit/a3128116d258d2d715f55062f25ab9debe79be14"}, {"sha": "cae164753f557f668cb75610abda4f790981e5e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/cae164753f557f668cb75610abda4f790981e5e6", "html_url": "https://github.com/rust-lang/rust/commit/cae164753f557f668cb75610abda4f790981e5e6"}], "stats": {"total": 3084, "additions": 1704, "deletions": 1380}, "files": [{"sha": "7eb5e8067eda2d1e30d9e6ff10e8648042bf8201", "filename": "README.md", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -186,18 +186,15 @@ fetch snapshots, and an OS that can execute the available snapshot binaries.\n \n Snapshot binaries are currently built and tested on several platforms:\n \n-| Platform / Architecture        | x86 | x86_64 |\n-|--------------------------------|-----|--------|\n-| Windows (7, 8, Server 2008 R2) | \u2713   | \u2713      |\n-| Linux (2.6.18 or later)        | \u2713   | \u2713      |\n-| OSX (10.7 Lion or later)       | \u2713   | \u2713      |\n+| Platform / Architecture  | x86 | x86_64 |\n+|--------------------------|-----|--------|\n+| Windows (7, 8, 10, ...)  | \u2713   | \u2713      |\n+| Linux (2.6.18 or later)  | \u2713   | \u2713      |\n+| OSX (10.7 Lion or later) | \u2713   | \u2713      |\n \n You may find that other platforms work, but these are our officially\n supported build environments that are most likely to work.\n \n-Rust currently needs between 600MiB and 1.5GiB of RAM to build, depending on platform.\n-If it hits swap, it will take a very long time to build.\n-\n There is more advice about hacking on Rust in [CONTRIBUTING.md].\n \n [CONTRIBUTING.md]: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md"}, {"sha": "631f64a11dbae917a06deb289762a70c74455c30", "filename": "src/doc/rust.css", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Fdoc%2Frust.css", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Fdoc%2Frust.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.css?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -1,15 +1,3 @@\n-/**\n- * Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n- * file at the top-level directory of this distribution and at\n- * http://rust-lang.org/COPYRIGHT.\n- * With elements taken from Bootstrap v3.0.2 (MIT licensed).\n- *\n- * Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n- * http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n- * <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n- * option. This file may not be copied, modified, or distributed\n- * except according to those terms.\n- */\n @font-face {\n \tfont-family: 'Fira Sans';\n \tfont-style: normal;"}, {"sha": "7e87171a5edf7579adb492fcd076d2b20e19a2fd", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -2090,6 +2090,15 @@ impl VisibilityKind {\n             VisibilityKind::Restricted { .. } => true,\n         }\n     }\n+\n+    pub fn descr(&self) -> &'static str {\n+        match *self {\n+            VisibilityKind::Public => \"public\",\n+            VisibilityKind::Inherited => \"private\",\n+            VisibilityKind::Crate(..) => \"crate-visible\",\n+            VisibilityKind::Restricted { .. } => \"restricted\",\n+        }\n+    }\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]"}, {"sha": "002ac7cc7a9bba8dac6908b9daa4e7573d243068", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -494,22 +494,5 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for mir::ClosureOutlivesSubj\n \n impl_stable_hash_for!(struct mir::interpret::GlobalId<'tcx> { instance, promoted });\n \n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for mir::UserTypeAnnotation<'gcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            mir::UserTypeAnnotation::Ty(ref ty) => {\n-                ty.hash_stable(hcx, hasher);\n-            }\n-            mir::UserTypeAnnotation::TypeOf(ref def_id, ref substs) => {\n-                def_id.hash_stable(hcx, hasher);\n-                substs.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n-\n impl_stable_hash_for!(struct mir::UserTypeProjection<'tcx> { base, projs });\n impl_stable_hash_for!(struct mir::UserTypeProjections<'tcx> { contents });"}, {"sha": "b2fe4b7561c5a74cf76724178dc07c3510350012", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -1251,3 +1251,29 @@ impl_stable_hash_for!(\n         goal,\n     }\n );\n+\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for ty::UserTypeAnnotation<'gcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            ty::UserTypeAnnotation::Ty(ref ty) => {\n+                ty.hash_stable(hcx, hasher);\n+            }\n+            ty::UserTypeAnnotation::TypeOf(ref def_id, ref substs) => {\n+                def_id.hash_stable(hcx, hasher);\n+                substs.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a> HashStable<StableHashingContext<'a>> for ty::UserTypeAnnotationIndex {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        self.index().hash_stable(hcx, hasher);\n+    }\n+}"}, {"sha": "2936405ebd0b79a325db5cf62daff9f988c4cc09", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 92, "deletions": 33, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -27,9 +27,12 @@ use syntax::ast::{self, Name};\n use syntax::symbol::InternedString;\n use syntax_pos::{Span, DUMMY_SP};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n-use ty::subst::{CanonicalUserSubsts, Subst, Substs};\n-use ty::{self, AdtDef, CanonicalTy, ClosureSubsts, GeneratorSubsts, Region, Ty, TyCtxt};\n+use ty::subst::{Subst, Substs};\n use ty::layout::VariantIdx;\n+use ty::{\n+    self, AdtDef, CanonicalUserTypeAnnotations, ClosureSubsts, GeneratorSubsts, Region, Ty, TyCtxt,\n+    UserTypeAnnotationIndex, UserTypeAnnotation,\n+};\n use util::ppaux;\n \n pub use mir::interpret::AssertMessage;\n@@ -121,6 +124,9 @@ pub struct Mir<'tcx> {\n     /// variables and temporaries.\n     pub local_decls: LocalDecls<'tcx>,\n \n+    /// User type annotations\n+    pub user_type_annotations: CanonicalUserTypeAnnotations<'tcx>,\n+\n     /// Number of arguments this function takes.\n     ///\n     /// Starting at local 1, `arg_count` locals will be provided by the caller\n@@ -161,7 +167,8 @@ impl<'tcx> Mir<'tcx> {\n         source_scope_local_data: ClearCrossCrate<IndexVec<SourceScope, SourceScopeLocalData>>,\n         promoted: IndexVec<Promoted, Mir<'tcx>>,\n         yield_ty: Option<Ty<'tcx>>,\n-        local_decls: IndexVec<Local, LocalDecl<'tcx>>,\n+        local_decls: LocalDecls<'tcx>,\n+        user_type_annotations: CanonicalUserTypeAnnotations<'tcx>,\n         arg_count: usize,\n         upvar_decls: Vec<UpvarDecl>,\n         span: Span,\n@@ -185,6 +192,7 @@ impl<'tcx> Mir<'tcx> {\n             generator_drop: None,\n             generator_layout: None,\n             local_decls,\n+            user_type_annotations,\n             arg_count,\n             upvar_decls,\n             spread_arg: None,\n@@ -418,6 +426,7 @@ impl_stable_hash_for!(struct Mir<'tcx> {\n     generator_drop,\n     generator_layout,\n     local_decls,\n+    user_type_annotations,\n     arg_count,\n     upvar_decls,\n     spread_arg,\n@@ -2232,7 +2241,7 @@ pub enum AggregateKind<'tcx> {\n         &'tcx AdtDef,\n         VariantIdx,\n         &'tcx Substs<'tcx>,\n-        Option<UserTypeAnnotation<'tcx>>,\n+        Option<UserTypeAnnotationIndex>,\n         Option<usize>,\n     ),\n \n@@ -2446,38 +2455,11 @@ pub struct Constant<'tcx> {\n     /// indicate that `Vec<_>` was explicitly specified.\n     ///\n     /// Needed for NLL to impose user-given type constraints.\n-    pub user_ty: Option<UserTypeAnnotation<'tcx>>,\n+    pub user_ty: Option<UserTypeAnnotationIndex>,\n \n     pub literal: &'tcx ty::Const<'tcx>,\n }\n \n-/// A user-given type annotation attached to a constant.  These arise\n-/// from constants that are named via paths, like `Foo::<A>::new` and\n-/// so forth.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n-pub enum UserTypeAnnotation<'tcx> {\n-    Ty(CanonicalTy<'tcx>),\n-\n-    /// The canonical type is the result of `type_of(def_id)` with the\n-    /// given substitutions applied.\n-    TypeOf(DefId, CanonicalUserSubsts<'tcx>),\n-}\n-\n-EnumTypeFoldableImpl! {\n-    impl<'tcx> TypeFoldable<'tcx> for UserTypeAnnotation<'tcx> {\n-        (UserTypeAnnotation::Ty)(ty),\n-        (UserTypeAnnotation::TypeOf)(def, substs),\n-    }\n-}\n-\n-EnumLiftImpl! {\n-    impl<'a, 'tcx> Lift<'tcx> for UserTypeAnnotation<'a> {\n-        type Lifted = UserTypeAnnotation<'tcx>;\n-        (UserTypeAnnotation::Ty)(ty),\n-        (UserTypeAnnotation::TypeOf)(def, substs),\n-    }\n-}\n-\n /// A collection of projections into user types.\n ///\n /// They are projections because a binding can occur a part of a\n@@ -2537,6 +2519,48 @@ impl<'tcx> UserTypeProjections<'tcx> {\n     pub fn projections(&self) -> impl Iterator<Item=&UserTypeProjection<'tcx>> {\n         self.contents.iter().map(|&(ref user_type, _span)| user_type)\n     }\n+\n+    pub fn push_projection(\n+        mut self,\n+        user_ty: &UserTypeProjection<'tcx>,\n+        span: Span,\n+    ) -> Self {\n+        self.contents.push((user_ty.clone(), span));\n+        self\n+    }\n+\n+    fn map_projections(\n+        mut self,\n+        mut f: impl FnMut(UserTypeProjection<'tcx>) -> UserTypeProjection<'tcx>\n+    ) -> Self {\n+        self.contents = self.contents.drain(..).map(|(proj, span)| (f(proj), span)).collect();\n+        self\n+    }\n+\n+    pub fn index(self) -> Self {\n+        self.map_projections(|pat_ty_proj| pat_ty_proj.index())\n+    }\n+\n+    pub fn subslice(self, from: u32, to: u32) -> Self {\n+        self.map_projections(|pat_ty_proj| pat_ty_proj.subslice(from, to))\n+    }\n+\n+    pub fn deref(self) -> Self {\n+        self.map_projections(|pat_ty_proj| pat_ty_proj.deref())\n+    }\n+\n+    pub fn leaf(self, field: Field) -> Self {\n+        self.map_projections(|pat_ty_proj| pat_ty_proj.leaf(field))\n+    }\n+\n+    pub fn variant(\n+        self,\n+        adt_def: &'tcx AdtDef,\n+        variant_index: VariantIdx,\n+        field: Field,\n+    ) -> Self {\n+        self.map_projections(|pat_ty_proj| pat_ty_proj.variant(adt_def, variant_index, field))\n+    }\n }\n \n /// Encodes the effect of a user-supplied type annotation on the\n@@ -2556,12 +2580,45 @@ impl<'tcx> UserTypeProjections<'tcx> {\n ///   determined by finding the type of the `.0` field from `T`.\n #[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct UserTypeProjection<'tcx> {\n-    pub base: UserTypeAnnotation<'tcx>,\n+    pub base: UserTypeAnnotationIndex,\n     pub projs: Vec<ProjectionElem<'tcx, (), ()>>,\n }\n \n impl<'tcx> Copy for ProjectionKind<'tcx> { }\n \n+impl<'tcx> UserTypeProjection<'tcx> {\n+    pub(crate) fn index(mut self) -> Self {\n+        self.projs.push(ProjectionElem::Index(()));\n+        self\n+    }\n+\n+    pub(crate) fn subslice(mut self, from: u32, to: u32) -> Self {\n+        self.projs.push(ProjectionElem::Subslice { from, to });\n+        self\n+    }\n+\n+    pub(crate) fn deref(mut self) -> Self {\n+        self.projs.push(ProjectionElem::Deref);\n+        self\n+    }\n+\n+    pub(crate) fn leaf(mut self, field: Field) -> Self {\n+        self.projs.push(ProjectionElem::Field(field, ()));\n+        self\n+    }\n+\n+    pub(crate) fn variant(\n+        mut self,\n+        adt_def: &'tcx AdtDef,\n+        variant_index: VariantIdx,\n+        field: Field,\n+    ) -> Self {\n+        self.projs.push(ProjectionElem::Downcast(adt_def, variant_index));\n+        self.projs.push(ProjectionElem::Field(field, ()));\n+        self\n+    }\n+}\n+\n CloneTypeFoldableAndLiftImpls! { ProjectionKind<'tcx>, }\n \n impl<'tcx> TypeFoldable<'tcx> for UserTypeProjection<'tcx> {\n@@ -2970,6 +3027,7 @@ CloneTypeFoldableAndLiftImpls! {\n     SourceScope,\n     SourceScopeData,\n     SourceScopeLocalData,\n+    UserTypeAnnotationIndex,\n }\n \n BraceStructTypeFoldableImpl! {\n@@ -2983,6 +3041,7 @@ BraceStructTypeFoldableImpl! {\n         generator_drop,\n         generator_layout,\n         local_decls,\n+        user_type_annotations,\n         arg_count,\n         upvar_decls,\n         spread_arg,"}, {"sha": "67f85fbc8679ee133c2bd54722dea3c26807951c", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -1,4 +1,5 @@\n use hir::def_id::DefId;\n+use infer::canonical::Canonical;\n use ty::subst::Substs;\n use ty::{ClosureSubsts, GeneratorSubsts, Region, Ty};\n use mir::*;\n@@ -219,9 +220,10 @@ macro_rules! make_mir_visitor {\n \n             fn visit_user_type_annotation(\n                 &mut self,\n-                ty: & $($mutability)* UserTypeAnnotation<'tcx>,\n+                index: UserTypeAnnotationIndex,\n+                ty: & $($mutability)* Canonical<'tcx, UserTypeAnnotation<'tcx>>,\n             ) {\n-                self.super_user_type_annotation(ty);\n+                self.super_user_type_annotation(index, ty);\n             }\n \n             fn visit_region(&mut self,\n@@ -307,6 +309,14 @@ macro_rules! make_mir_visitor {\n                     self.visit_local_decl(local, & $($mutability)* mir.local_decls[local]);\n                 }\n \n+                for index in mir.user_type_annotations.indices() {\n+                    let (span, annotation) = & $($mutability)* mir.user_type_annotations[index];\n+                    self.visit_user_type_annotation(\n+                        index, annotation\n+                    );\n+                    self.visit_span(span);\n+                }\n+\n                 self.visit_span(&$($mutability)* mir.span);\n             }\n \n@@ -865,18 +875,14 @@ macro_rules! make_mir_visitor {\n \n             fn super_user_type_projection(\n                 &mut self,\n-                ty: & $($mutability)* UserTypeProjection<'tcx>,\n+                _ty: & $($mutability)* UserTypeProjection<'tcx>,\n             ) {\n-                let UserTypeProjection {\n-                    ref $($mutability)* base,\n-                    projs: _, // Note: Does not visit projection elems!\n-                } = *ty;\n-                self.visit_user_type_annotation(base);\n             }\n \n             fn super_user_type_annotation(\n                 &mut self,\n-                _ty: & $($mutability)* UserTypeAnnotation<'tcx>,\n+                _index: UserTypeAnnotationIndex,\n+                _ty: & $($mutability)* Canonical<'tcx, UserTypeAnnotation<'tcx>>,\n             ) {\n             }\n "}, {"sha": "b2f30564de93a5d387a7fe19a666d892df02691b", "filename": "src/librustc/traits/query/type_op/ascribe_user_type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -22,7 +22,7 @@ impl<'tcx> AscribeUserType<'tcx> {\n         user_substs: UserSubsts<'tcx>,\n         projs: &'tcx ty::List<ProjectionKind<'tcx>>,\n     ) -> Self {\n-        AscribeUserType { mir_ty, variance, def_id, user_substs, projs }\n+        Self { mir_ty, variance, def_id, user_substs, projs }\n     }\n }\n "}, {"sha": "32348e2e5046dbc6027f033996919435b723b20f", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 104, "deletions": 42, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -14,7 +14,7 @@ use hir::map as hir_map;\n use hir::map::DefPathHash;\n use lint::{self, Lint};\n use ich::{StableHashingContext, NodeIdHashingMode};\n-use infer::canonical::{CanonicalVarInfo, CanonicalVarInfos};\n+use infer::canonical::{Canonical, CanonicalVarInfo, CanonicalVarInfos};\n use infer::outlives::free_region_map::FreeRegionMap;\n use middle::cstore::CrateStoreDyn;\n use middle::cstore::EncodedMetadata;\n@@ -23,7 +23,7 @@ use middle::resolve_lifetime::{self, ObjectLifetimeDefault};\n use middle::stability;\n use mir::{self, Mir, interpret, ProjectionKind};\n use mir::interpret::Allocation;\n-use ty::subst::{CanonicalUserSubsts, Kind, Substs, Subst};\n+use ty::subst::{Kind, Substs, Subst};\n use ty::ReprOptions;\n use traits;\n use traits::{Clause, Clauses, GoalKind, Goal, Goals};\n@@ -38,8 +38,8 @@ use ty::GenericParamDefKind;\n use ty::layout::{LayoutDetails, TargetDataLayout, VariantIdx};\n use ty::query;\n use ty::steal::Steal;\n-use ty::BindingMode;\n-use ty::CanonicalTy;\n+use ty::subst::{UserSubsts, UnpackedKind};\n+use ty::{BoundVar, BindingMode};\n use ty::CanonicalPolyFnSig;\n use util::nodemap::{DefIdMap, DefIdSet, ItemLocalMap};\n use util::nodemap::{FxHashMap, FxHashSet};\n@@ -49,7 +49,7 @@ use rustc_data_structures::stable_hasher::{HashStable, hash_stable_hashmap,\n                                            StableHasher, StableHasherResult,\n                                            StableVec};\n use arena::{TypedArena, SyncDroplessArena};\n-use rustc_data_structures::indexed_vec::IndexVec;\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc_data_structures::sync::{self, Lrc, Lock, WorkerLocal};\n use std::any::Any;\n use std::borrow::Borrow;\n@@ -342,26 +342,21 @@ pub struct TypeckTables<'tcx> {\n     /// other items.\n     node_substs: ItemLocalMap<&'tcx Substs<'tcx>>,\n \n-    /// Stores the canonicalized types provided by the user. See also\n-    /// `AscribeUserType` statement in MIR.\n-    user_provided_tys: ItemLocalMap<CanonicalTy<'tcx>>,\n+    /// This will either store the canonicalized types provided by the user\n+    /// or the substitutions that the user explicitly gave (if any) attached\n+    /// to `id`. These will not include any inferred values. The canonical form\n+    /// is used to capture things like `_` or other unspecified values.\n+    ///\n+    /// For example, if the user wrote `foo.collect::<Vec<_>>()`, then the\n+    /// canonical substitutions would include only `for<X> { Vec<X> }`.\n+    ///\n+    /// See also `AscribeUserType` statement in MIR.\n+    user_provided_types: ItemLocalMap<CanonicalUserTypeAnnotation<'tcx>>,\n \n     /// Stores the canonicalized types provided by the user. See also\n     /// `AscribeUserType` statement in MIR.\n     pub user_provided_sigs: DefIdMap<CanonicalPolyFnSig<'tcx>>,\n \n-    /// Stores the substitutions that the user explicitly gave (if any)\n-    /// attached to `id`. These will not include any inferred\n-    /// values. The canonical form is used to capture things like `_`\n-    /// or other unspecified values.\n-    ///\n-    /// Example:\n-    ///\n-    /// If the user wrote `foo.collect::<Vec<_>>()`, then the\n-    /// canonical substitutions would include only `for<X> { Vec<X>\n-    /// }`.\n-    user_substs: ItemLocalMap<CanonicalUserSubsts<'tcx>>,\n-\n     adjustments: ItemLocalMap<Vec<ty::adjustment::Adjustment<'tcx>>>,\n \n     /// Stores the actual binding mode for all instances of hir::BindingAnnotation.\n@@ -432,11 +427,10 @@ impl<'tcx> TypeckTables<'tcx> {\n             local_id_root,\n             type_dependent_defs: Default::default(),\n             field_indices: Default::default(),\n-            user_provided_tys: Default::default(),\n+            user_provided_types: Default::default(),\n             user_provided_sigs: Default::default(),\n             node_types: Default::default(),\n             node_substs: Default::default(),\n-            user_substs: Default::default(),\n             adjustments: Default::default(),\n             pat_binding_modes: Default::default(),\n             pat_adjustments: Default::default(),\n@@ -491,17 +485,21 @@ impl<'tcx> TypeckTables<'tcx> {\n         }\n     }\n \n-    pub fn user_provided_tys(&self) -> LocalTableInContext<'_, CanonicalTy<'tcx>> {\n+    pub fn user_provided_types(\n+        &self\n+    ) -> LocalTableInContext<'_, CanonicalUserTypeAnnotation<'tcx>> {\n         LocalTableInContext {\n             local_id_root: self.local_id_root,\n-            data: &self.user_provided_tys\n+            data: &self.user_provided_types\n         }\n     }\n \n-    pub fn user_provided_tys_mut(&mut self) -> LocalTableInContextMut<'_, CanonicalTy<'tcx>> {\n+    pub fn user_provided_types_mut(\n+        &mut self\n+    ) -> LocalTableInContextMut<'_, CanonicalUserTypeAnnotation<'tcx>> {\n         LocalTableInContextMut {\n             local_id_root: self.local_id_root,\n-            data: &mut self.user_provided_tys\n+            data: &mut self.user_provided_types\n         }\n     }\n \n@@ -551,18 +549,6 @@ impl<'tcx> TypeckTables<'tcx> {\n         self.node_substs.get(&id.local_id).cloned()\n     }\n \n-    pub fn user_substs_mut(&mut self) -> LocalTableInContextMut<'_, CanonicalUserSubsts<'tcx>> {\n-        LocalTableInContextMut {\n-            local_id_root: self.local_id_root,\n-            data: &mut self.user_substs\n-        }\n-    }\n-\n-    pub fn user_substs(&self, id: hir::HirId) -> Option<CanonicalUserSubsts<'tcx>> {\n-        validate_hir_id_for_typeck_tables(self.local_id_root, id, false);\n-        self.user_substs.get(&id.local_id).cloned()\n-    }\n-\n     // Returns the type of a pattern as a monotype. Like @expr_ty, this function\n     // doesn't provide type parameter substitutions.\n     pub fn pat_ty(&self, pat: &hir::Pat) -> Ty<'tcx> {\n@@ -739,11 +725,10 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for TypeckTables<'gcx> {\n             local_id_root,\n             ref type_dependent_defs,\n             ref field_indices,\n-            ref user_provided_tys,\n+            ref user_provided_types,\n             ref user_provided_sigs,\n             ref node_types,\n             ref node_substs,\n-            ref user_substs,\n             ref adjustments,\n             ref pat_binding_modes,\n             ref pat_adjustments,\n@@ -763,11 +748,10 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for TypeckTables<'gcx> {\n         hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n             type_dependent_defs.hash_stable(hcx, hasher);\n             field_indices.hash_stable(hcx, hasher);\n-            user_provided_tys.hash_stable(hcx, hasher);\n+            user_provided_types.hash_stable(hcx, hasher);\n             user_provided_sigs.hash_stable(hcx, hasher);\n             node_types.hash_stable(hcx, hasher);\n             node_substs.hash_stable(hcx, hasher);\n-            user_substs.hash_stable(hcx, hasher);\n             adjustments.hash_stable(hcx, hasher);\n             pat_binding_modes.hash_stable(hcx, hasher);\n             pat_adjustments.hash_stable(hcx, hasher);\n@@ -805,6 +789,84 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for TypeckTables<'gcx> {\n     }\n }\n \n+newtype_index! {\n+    pub struct UserTypeAnnotationIndex {\n+        DEBUG_FORMAT = \"UserTypeAnnotation({})\",\n+        const START_INDEX = 0,\n+    }\n+}\n+\n+/// Mapping of type annotation indices to canonical user type annotations.\n+pub type CanonicalUserTypeAnnotations<'tcx> =\n+    IndexVec<UserTypeAnnotationIndex, (Span, CanonicalUserTypeAnnotation<'tcx>)>;\n+\n+/// Canonicalized user type annotation.\n+pub type CanonicalUserTypeAnnotation<'gcx> = Canonical<'gcx, UserTypeAnnotation<'gcx>>;\n+\n+impl CanonicalUserTypeAnnotation<'gcx> {\n+    /// Returns `true` if this represents a substitution of the form `[?0, ?1, ?2]`,\n+    /// i.e. each thing is mapped to a canonical variable with the same index.\n+    pub fn is_identity(&self) -> bool {\n+        match self.value {\n+            UserTypeAnnotation::Ty(_) => false,\n+            UserTypeAnnotation::TypeOf(_, user_substs) => {\n+                if user_substs.user_self_ty.is_some() {\n+                    return false;\n+                }\n+\n+                user_substs.substs.iter().zip(BoundVar::new(0)..).all(|(kind, cvar)| {\n+                    match kind.unpack() {\n+                        UnpackedKind::Type(ty) => match ty.sty {\n+                            ty::Bound(debruijn, b) => {\n+                                // We only allow a `ty::INNERMOST` index in substitutions.\n+                                assert_eq!(debruijn, ty::INNERMOST);\n+                                cvar == b.var\n+                            }\n+                            _ => false,\n+                        },\n+\n+                        UnpackedKind::Lifetime(r) => match r {\n+                            ty::ReLateBound(debruijn, br) => {\n+                                // We only allow a `ty::INNERMOST` index in substitutions.\n+                                assert_eq!(*debruijn, ty::INNERMOST);\n+                                cvar == br.assert_bound_var()\n+                            }\n+                            _ => false,\n+                        },\n+                    }\n+                })\n+            },\n+        }\n+    }\n+}\n+\n+/// A user-given type annotation attached to a constant.  These arise\n+/// from constants that are named via paths, like `Foo::<A>::new` and\n+/// so forth.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+pub enum UserTypeAnnotation<'tcx> {\n+    Ty(Ty<'tcx>),\n+\n+    /// The canonical type is the result of `type_of(def_id)` with the\n+    /// given substitutions applied.\n+    TypeOf(DefId, UserSubsts<'tcx>),\n+}\n+\n+EnumTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for UserTypeAnnotation<'tcx> {\n+        (UserTypeAnnotation::Ty)(ty),\n+        (UserTypeAnnotation::TypeOf)(def, substs),\n+    }\n+}\n+\n+EnumLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for UserTypeAnnotation<'a> {\n+        type Lifted = UserTypeAnnotation<'tcx>;\n+        (UserTypeAnnotation::Ty)(ty),\n+        (UserTypeAnnotation::TypeOf)(def, substs),\n+    }\n+}\n+\n impl<'tcx> CommonTypes<'tcx> {\n     fn new(interners: &CtxtInterners<'tcx>) -> CommonTypes<'tcx> {\n         let mk = |sty| CtxtInterners::intern_ty(interners, interners, sty);"}, {"sha": "d40dd830e9fb930f0182de08f52e668a454ded19", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -73,6 +73,10 @@ pub use self::binding::BindingMode::*;\n \n pub use self::context::{TyCtxt, FreeRegionInfo, GlobalArenas, AllArenas, tls, keep_local};\n pub use self::context::{Lift, TypeckTables, CtxtInterners};\n+pub use self::context::{\n+    UserTypeAnnotationIndex, UserTypeAnnotation, CanonicalUserTypeAnnotation,\n+    CanonicalUserTypeAnnotations,\n+};\n \n pub use self::instance::{Instance, InstanceDef};\n "}, {"sha": "842aea07614ddb0bc3d745e364cb50ba6ed55289", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -26,8 +26,8 @@ use session::config::OutputFilenames;\n use traits::{self, Vtable};\n use traits::query::{\n     CanonicalPredicateGoal, CanonicalProjectionGoal,\n-    CanonicalTyGoal, CanonicalTypeOpAscribeUserTypeGoal, CanonicalTypeOpEqGoal,\n-    CanonicalTypeOpSubtypeGoal, CanonicalTypeOpProvePredicateGoal,\n+    CanonicalTyGoal, CanonicalTypeOpAscribeUserTypeGoal,\n+    CanonicalTypeOpEqGoal, CanonicalTypeOpSubtypeGoal, CanonicalTypeOpProvePredicateGoal,\n     CanonicalTypeOpNormalizeGoal, NoSolution,\n };\n use traits::query::method_autoderef::MethodAutoderefStepsResult;"}, {"sha": "64e7af815b4bf93afc8da858cc5556effdec894e", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 1, "deletions": 39, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -2,12 +2,11 @@\n \n use hir::def_id::DefId;\n use infer::canonical::Canonical;\n-use ty::{self, BoundVar, Lift, List, Ty, TyCtxt};\n+use ty::{self, Lift, List, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n \n use serialize::{self, Encodable, Encoder, Decodable, Decoder};\n use syntax_pos::{Span, DUMMY_SP};\n-use rustc_data_structures::indexed_vec::Idx;\n use smallvec::SmallVec;\n \n use core::intrinsics;\n@@ -559,43 +558,6 @@ impl<'a, 'gcx, 'tcx> SubstFolder<'a, 'gcx, 'tcx> {\n \n pub type CanonicalUserSubsts<'tcx> = Canonical<'tcx, UserSubsts<'tcx>>;\n \n-impl CanonicalUserSubsts<'tcx> {\n-    /// True if this represents a substitution like\n-    ///\n-    /// ```text\n-    /// [?0, ?1, ?2]\n-    /// ```\n-    ///\n-    /// i.e., each thing is mapped to a canonical variable with the same index.\n-    pub fn is_identity(&self) -> bool {\n-        if self.value.user_self_ty.is_some() {\n-            return false;\n-        }\n-\n-        self.value.substs.iter().zip(BoundVar::new(0)..).all(|(kind, cvar)| {\n-            match kind.unpack() {\n-                UnpackedKind::Type(ty) => match ty.sty {\n-                    ty::Bound(debruijn, b) => {\n-                        // We only allow a `ty::INNERMOST` index in substitutions.\n-                        assert_eq!(debruijn, ty::INNERMOST);\n-                        cvar == b.var\n-                    }\n-                    _ => false,\n-                },\n-\n-                UnpackedKind::Lifetime(r) => match r {\n-                    ty::ReLateBound(debruijn, br) => {\n-                        // We only allow a `ty::INNERMOST` index in substitutions.\n-                        assert_eq!(*debruijn, ty::INNERMOST);\n-                        cvar == br.assert_bound_var()\n-                    }\n-                    _ => false,\n-                },\n-            }\n-        })\n-    }\n-}\n-\n /// Stores the user-given substs to reach some fully qualified path\n /// (e.g., `<T>::Item` or `<T as Trait>::Item`).\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]"}, {"sha": "aacc63c47de61fefd7d546eb0204e988e2508823", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -289,6 +289,11 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                     self.out.extend(obligations);\n                 }\n \n+                ty::FnDef(did, substs) => {\n+                    let obligations = self.nominal_obligations(did, substs);\n+                    self.out.extend(obligations);\n+                }\n+\n                 ty::Ref(r, rty, _) => {\n                     // WfReference\n                     if !r.has_escaping_bound_vars() && !rty.has_escaping_bound_vars() {\n@@ -349,7 +354,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                     }\n                 }\n \n-                ty::FnDef(..) | ty::FnPtr(_) => {\n+                ty::FnPtr(_) => {\n                     // let the loop iterate into the argument/return\n                     // types appearing in the fn signature\n                 }"}, {"sha": "318d7adb1901107f70a0fbf539968fc0908ad176", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -709,6 +709,9 @@ define_print! {\n \n define_print! {\n     ('tcx) ty::ExistentialTraitRef<'tcx>, (self, f, cx) {\n+        display {\n+            cx.parameterized(f, self.substs, self.def_id, &[])\n+        }\n         debug {\n             ty::tls::with(|tcx| {\n                 let dummy_self = tcx.mk_infer(ty::FreshTy(0));"}, {"sha": "a092c3b8ecde2c5671874d7ad4f67835a50f8eed", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -230,13 +230,14 @@ fn dump_mir_results<'a, 'gcx, 'tcx>(\n                 // Before the CFG, dump out the values for each region variable.\n                 PassWhere::BeforeCFG => {\n                     regioncx.dump_mir(out)?;\n+                    writeln!(out, \"|\")?;\n \n                     if let Some(closure_region_requirements) = closure_region_requirements {\n-                        writeln!(out, \"|\")?;\n                         writeln!(out, \"| Free Region Constraints\")?;\n                         for_each_region_constraint(closure_region_requirements, &mut |msg| {\n                             writeln!(out, \"| {}\", msg)\n                         })?;\n+                        writeln!(out, \"|\")?;\n                     }\n                 }\n "}, {"sha": "55af7399aab8f311a97a2e970c690f975a3e7f9e", "filename": "src/librustc_mir/borrow_check/nll/renumber.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -1,6 +1,10 @@\n+use rustc::infer::canonical::Canonical;\n use rustc::ty::subst::Substs;\n-use rustc::ty::{self, ClosureSubsts, GeneratorSubsts, Ty, TypeFoldable};\n-use rustc::mir::{Location, Mir, UserTypeAnnotation};\n+use rustc::ty::{\n+    self, ClosureSubsts, GeneratorSubsts, Ty, TypeFoldable, UserTypeAnnotation,\n+    UserTypeAnnotationIndex,\n+};\n+use rustc::mir::{Location, Mir};\n use rustc::mir::visit::{MutVisitor, TyContext};\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n \n@@ -55,7 +59,11 @@ impl<'a, 'gcx, 'tcx> MutVisitor<'tcx> for NLLVisitor<'a, 'gcx, 'tcx> {\n         debug!(\"visit_ty: ty={:?}\", ty);\n     }\n \n-    fn visit_user_type_annotation(&mut self, _ty: &mut UserTypeAnnotation<'tcx>) {\n+    fn visit_user_type_annotation(\n+        &mut self,\n+        _index: UserTypeAnnotationIndex,\n+        _ty: &mut Canonical<'tcx, UserTypeAnnotation<'tcx>>,\n+    ) {\n         // User type annotations represent the types that the user\n         // wrote in the progarm. We don't want to erase the regions\n         // from these types: rather, we want to add them as"}, {"sha": "796a2f79f7554ceb119d7d2b6ad7e77da2c8d804", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 75, "deletions": 28, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -36,7 +36,10 @@ use rustc::traits::query::{Fallible, NoSolution};\n use rustc::traits::{ObligationCause, PredicateObligations};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::subst::{Subst, Substs, UnpackedKind};\n-use rustc::ty::{self, RegionVid, ToPolyTraitRef, Ty, TyCtxt, TyKind};\n+use rustc::ty::{\n+    self, RegionVid, ToPolyTraitRef, Ty, TyCtxt, TyKind, UserTypeAnnotation,\n+    UserTypeAnnotationIndex,\n+};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc::ty::layout::VariantIdx;\n@@ -272,19 +275,20 @@ impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         self.sanitize_constant(constant, location);\n         self.sanitize_type(constant, constant.ty);\n \n-        if let Some(user_ty) = constant.user_ty {\n+        if let Some(annotation_index) = constant.user_ty {\n             if let Err(terr) = self.cx.relate_type_and_user_type(\n                 constant.ty,\n                 ty::Variance::Invariant,\n-                &UserTypeProjection { base: user_ty, projs: vec![], },\n+                &UserTypeProjection { base: annotation_index, projs: vec![], },\n                 location.to_locations(),\n                 ConstraintCategory::Boring,\n             ) {\n+                let annotation = self.cx.instantiated_type_annotations[&annotation_index];\n                 span_mirbug!(\n                     self,\n                     constant,\n                     \"bad constant user type {:?} vs {:?}: {:?}\",\n-                    user_ty,\n+                    annotation,\n                     constant.ty,\n                     terr,\n                 );\n@@ -303,8 +307,20 @@ impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         self.sanitize_type(local_decl, local_decl.ty);\n \n         for (user_ty, span) in local_decl.user_ty.projections_and_spans() {\n+            let ty = if !local_decl.is_nonref_binding() {\n+                // If we have a binding of the form `let ref x: T = ..` then remove the outermost\n+                // reference so we can check the type annotation for the remaining type.\n+                if let ty::Ref(_, rty, _) = local_decl.ty.sty {\n+                    rty\n+                } else {\n+                    bug!(\"{:?} with ref binding has wrong type {}\", local, local_decl.ty);\n+                }\n+            } else {\n+                local_decl.ty\n+            };\n+\n             if let Err(terr) = self.cx.relate_type_and_user_type(\n-                local_decl.ty,\n+                ty,\n                 ty::Variance::Invariant,\n                 user_ty,\n                 Locations::All(*span),\n@@ -715,6 +731,15 @@ struct TypeChecker<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     reported_errors: FxHashSet<(Ty<'tcx>, Span)>,\n     borrowck_context: Option<&'a mut BorrowCheckContext<'a, 'tcx>>,\n     universal_region_relations: Option<&'a UniversalRegionRelations<'tcx>>,\n+    /// For each user-type annotation (identified by a UserTypeAnnotationIndex), we create\n+    /// an \"instantiated\" version at the beginning of type check, which replaces each\n+    /// canonical variable with a fresh inference variable. These instantiated versions are\n+    /// stored either in this field or in user_substs, depending on the kind of user-type\n+    /// annotation. They are then referenced by the code which has the job of enforcing these\n+    /// annotations. Part of the reason for this setup is that it allows us to enforce basic\n+    /// WF criteria on the types even if the code that referenced them is dead\n+    /// code (see #54943).\n+    instantiated_type_annotations: FxHashMap<UserTypeAnnotationIndex, UserTypeAnnotation<'tcx>>,\n }\n \n struct BorrowCheckContext<'a, 'tcx: 'a> {\n@@ -860,7 +885,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         borrowck_context: Option<&'a mut BorrowCheckContext<'a, 'tcx>>,\n         universal_region_relations: Option<&'a UniversalRegionRelations<'tcx>>,\n     ) -> Self {\n-        TypeChecker {\n+        let mut checker = Self {\n             infcx,\n             last_span: DUMMY_SP,\n             mir,\n@@ -871,7 +896,36 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             borrowck_context,\n             reported_errors: Default::default(),\n             universal_region_relations,\n+            instantiated_type_annotations: Default::default(),\n+        };\n+        checker.instantiate_user_type_annotations();\n+        checker\n+    }\n+\n+    /// Instantiate canonical types from user type annotations in the `Mir` into the\n+    /// `TypeChecker`. Used when relating user type annotations and when checking if\n+    /// annotations are well-formed.\n+    fn instantiate_user_type_annotations(&mut self) {\n+        debug!(\n+            \"instantiate_user_type_annotations: user_type_annotations={:?}\",\n+             self.mir.user_type_annotations\n+        );\n+        for annotation_index in self.mir.user_type_annotations.indices() {\n+            let (span, canonical_annotation) = &self.mir.user_type_annotations[annotation_index];\n+            let (mut annotation, _) = self.infcx.instantiate_canonical_with_fresh_inference_vars(\n+                *span, &canonical_annotation\n+            );\n+            match annotation {\n+                UserTypeAnnotation::Ty(ref mut ty) =>\n+                    *ty = self.normalize(ty, Locations::All(*span)),\n+                _ => {},\n+            }\n+            self.instantiated_type_annotations.insert(annotation_index, annotation);\n         }\n+        debug!(\n+            \"instantiate_user_type_annotations: instantiated_type_annotations={:?}\",\n+            self.instantiated_type_annotations,\n+        );\n     }\n \n     /// Given some operation `op` that manipulates types, proves\n@@ -1003,18 +1057,14 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             a, v, user_ty, locations,\n         );\n \n-        match user_ty.base {\n-            UserTypeAnnotation::Ty(canonical_ty) => {\n-                let (ty, _) = self.infcx\n-                    .instantiate_canonical_with_fresh_inference_vars(DUMMY_SP, &canonical_ty);\n-\n+        let type_annotation = self.instantiated_type_annotations[&user_ty.base];\n+        match type_annotation {\n+            UserTypeAnnotation::Ty(ty) => {\n                 // The `TypeRelating` code assumes that \"unresolved inference\n                 // variables\" appear in the \"a\" side, so flip `Contravariant`\n                 // ambient variance to get the right relationship.\n                 let v1 = ty::Contravariant.xform(v);\n-\n                 let tcx = self.infcx.tcx;\n-                let ty = self.normalize(ty, locations);\n \n                 // We need to follow any provided projetions into the type.\n                 //\n@@ -1048,13 +1098,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     self.relate_types(ty, v1, a, locations, category)?;\n                 }\n             }\n-            UserTypeAnnotation::TypeOf(def_id, canonical_substs) => {\n-                let (\n-                    user_substs,\n-                    _,\n-                ) = self.infcx\n-                    .instantiate_canonical_with_fresh_inference_vars(DUMMY_SP, &canonical_substs);\n-\n+            UserTypeAnnotation::TypeOf(def_id, user_substs) => {\n                 let projs = self.infcx.tcx.intern_projs(&user_ty.projs);\n                 self.fully_perform_op(\n                     locations,\n@@ -1225,19 +1269,20 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     );\n                 }\n \n-                if let Some(user_ty) = self.rvalue_user_ty(rv) {\n+                if let Some(annotation_index) = self.rvalue_user_ty(rv) {\n                     if let Err(terr) = self.relate_type_and_user_type(\n                         rv_ty,\n                         ty::Variance::Invariant,\n-                        &UserTypeProjection { base: user_ty, projs: vec![], },\n+                        &UserTypeProjection { base: annotation_index, projs: vec![], },\n                         location.to_locations(),\n                         ConstraintCategory::Boring,\n                     ) {\n+                        let annotation = self.instantiated_type_annotations[&annotation_index];\n                         span_mirbug!(\n                             self,\n                             stmt,\n                             \"bad user type on rvalue ({:?} = {:?}): {:?}\",\n-                            user_ty,\n+                            annotation,\n                             rv_ty,\n                             terr\n                         );\n@@ -1282,21 +1327,23 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     );\n                 };\n             }\n-            StatementKind::AscribeUserType(ref place, variance, box ref c_ty) => {\n+            StatementKind::AscribeUserType(ref place, variance, box ref projection) => {\n                 let place_ty = place.ty(mir, tcx).to_ty(tcx);\n                 if let Err(terr) = self.relate_type_and_user_type(\n                     place_ty,\n                     variance,\n-                    c_ty,\n+                    projection,\n                     Locations::All(stmt.source_info.span),\n                     ConstraintCategory::TypeAnnotation,\n                 ) {\n+                    let annotation = self.instantiated_type_annotations[&projection.base];\n                     span_mirbug!(\n                         self,\n                         stmt,\n-                        \"bad type assert ({:?} <: {:?}): {:?}\",\n+                        \"bad type assert ({:?} <: {:?} with projections {:?}): {:?}\",\n                         place_ty,\n-                        c_ty,\n+                        annotation,\n+                        projection.projs,\n                         terr\n                     );\n                 }\n@@ -1955,7 +2002,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     /// If this rvalue supports a user-given type annotation, then\n     /// extract and return it. This represents the final type of the\n     /// rvalue and will be unified with the inferred type.\n-    fn rvalue_user_ty(&self, rvalue: &Rvalue<'tcx>) -> Option<UserTypeAnnotation<'tcx>> {\n+    fn rvalue_user_ty(&self, rvalue: &Rvalue<'tcx>) -> Option<UserTypeAnnotationIndex> {\n         match rvalue {\n             Rvalue::Use(_)\n             | Rvalue::Repeat(..)"}, {"sha": "f3d89a7a02515b3f17f00a95a44a71a67b3ba6d2", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -141,9 +141,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                             None, remainder_span, lint_level, slice::from_ref(&pattern),\n                             ArmHasGuard(false), None);\n \n+                        debug!(\"ast_block_stmts: pattern={:?}\", pattern);\n                         this.visit_bindings(\n                             &pattern,\n-                            &PatternTypeProjections::none(),\n+                            UserTypeProjections::none(),\n                             &mut |this, _, _, _, node, span, _, _| {\n                                 this.storage_live_binding(block, node, span, OutsideGuard);\n                                 this.schedule_drop_for_binding(node, span, OutsideGuard);"}, {"sha": "a431bfc61b37ae8c2aa2f9855d2c935b02bb492d", "filename": "src/librustc_mir/build/expr/as_constant.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -29,11 +29,16 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 lint_level: _,\n                 value,\n             } => this.as_constant(value),\n-            ExprKind::Literal { literal, user_ty } => Constant {\n-                span,\n-                ty,\n-                user_ty,\n-                literal,\n+            ExprKind::Literal { literal, user_ty } => {\n+                let user_ty = user_ty.map(|ty| {\n+                    this.canonical_user_type_annotations.push((span, ty))\n+                });\n+                Constant {\n+                    span,\n+                    ty,\n+                    user_ty,\n+                    literal,\n+                }\n             },\n             _ => span_bug!(span, \"expression is not a valid constant {:?}\", kind),\n         }"}, {"sha": "3ed00d5797907f638932cb4d51e097d6e94f724c", "filename": "src/librustc_mir/build/expr/as_place.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -133,14 +133,17 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             ExprKind::PlaceTypeAscription { source, user_ty } => {\n                 let place = unpack!(block = this.as_place(block, source));\n                 if let Some(user_ty) = user_ty {\n+                    let annotation_index = this.canonical_user_type_annotations.push(\n+                        (source_info.span, user_ty)\n+                    );\n                     this.cfg.push(\n                         block,\n                         Statement {\n                             source_info,\n                             kind: StatementKind::AscribeUserType(\n                                 place.clone(),\n                                 Variance::Invariant,\n-                                box UserTypeProjection { base: user_ty, projs: vec![], },\n+                                box UserTypeProjection { base: annotation_index, projs: vec![], },\n                             ),\n                         },\n                     );\n@@ -153,14 +156,17 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     block = this.as_temp(block, source.temp_lifetime, source, mutability)\n                 );\n                 if let Some(user_ty) = user_ty {\n+                    let annotation_index = this.canonical_user_type_annotations.push(\n+                        (source_info.span, user_ty)\n+                    );\n                     this.cfg.push(\n                         block,\n                         Statement {\n                             source_info,\n                             kind: StatementKind::AscribeUserType(\n                                 Place::Local(temp.clone()),\n                                 Variance::Invariant,\n-                                box UserTypeProjection { base: user_ty, projs: vec![], },\n+                                box UserTypeProjection { base: annotation_index, projs: vec![], },\n                             ),\n                         },\n                     );"}, {"sha": "7dcac05e702a3ad0b297b7fae4b8cc10e1fcdfa4", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -331,6 +331,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         .collect()\n                 };\n \n+                let user_ty = user_ty.map(|ty| {\n+                    this.canonical_user_type_annotations.push((expr_span, ty))\n+                });\n                 let adt = box AggregateKind::Adt(\n                     adt_def,\n                     variant_index,"}, {"sha": "fe5bc6e19db659bb4af1308d74ca7199298a7bc5", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 33, "deletions": 31, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -8,7 +8,6 @@ use build::ForGuard::{self, OutsideGuard, RefWithinGuard, ValWithinGuard};\n use build::{BlockAnd, BlockAndExtension, Builder};\n use build::{GuardFrame, GuardFrameLocal, LocalsForNode};\n use hair::*;\n-use hair::pattern::PatternTypeProjections;\n use rustc::mir::*;\n use rustc::ty::{self, Ty};\n use rustc::ty::layout::VariantIdx;\n@@ -302,14 +301,17 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 );\n \n                 let ty_source_info = self.source_info(user_ty_span);\n+                let user_ty = box pat_ascription_ty.user_ty(\n+                    &mut self.canonical_user_type_annotations, ty_source_info.span\n+                );\n                 self.cfg.push(\n                     block,\n                     Statement {\n                         source_info: ty_source_info,\n                         kind: StatementKind::AscribeUserType(\n                             place,\n                             ty::Variance::Invariant,\n-                            box pat_ascription_ty.user_ty(),\n+                            user_ty,\n                         ),\n                     },\n                 );\n@@ -406,9 +408,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         );\n         let mut scope = self.source_scope;\n         let num_patterns = patterns.len();\n+        debug!(\"declare_bindings: patterns={:?}\", patterns);\n         self.visit_bindings(\n             &patterns[0],\n-            &PatternTypeProjections::none(),\n+            UserTypeProjections::none(),\n             &mut |this, mutability, name, mode, var, span, ty, user_ty| {\n                 if visibility_scope.is_none() {\n                     visibility_scope =\n@@ -484,7 +487,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub(super) fn visit_bindings(\n         &mut self,\n         pattern: &Pattern<'tcx>,\n-        pattern_user_ty: &PatternTypeProjections<'tcx>,\n+        pattern_user_ty: UserTypeProjections<'tcx>,\n         f: &mut impl FnMut(\n             &mut Self,\n             Mutability,\n@@ -493,9 +496,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             NodeId,\n             Span,\n             Ty<'tcx>,\n-            &PatternTypeProjections<'tcx>,\n+            UserTypeProjections<'tcx>,\n         ),\n     ) {\n+        debug!(\"visit_bindings: pattern={:?} pattern_user_ty={:?}\", pattern, pattern_user_ty);\n         match *pattern.kind {\n             PatternKind::Binding {\n                 mutability,\n@@ -506,19 +510,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 ref subpattern,\n                 ..\n             } => {\n-                let pattern_ref_binding; // sidestep temp lifetime limitations.\n-                let binding_user_ty = match mode {\n-                    BindingMode::ByValue => { pattern_user_ty }\n-                    BindingMode::ByRef(..) => {\n-                        // If this is a `ref` binding (e.g., `let ref\n-                        // x: T = ..`), then the type of `x` is not\n-                        // `T` but rather `&T`.\n-                        pattern_ref_binding = pattern_user_ty.ref_binding();\n-                        &pattern_ref_binding\n-                    }\n-                };\n-\n-                f(self, mutability, name, mode, var, pattern.span, ty, binding_user_ty);\n+                f(self, mutability, name, mode, var, pattern.span, ty, pattern_user_ty.clone());\n                 if let Some(subpattern) = subpattern.as_ref() {\n                     self.visit_bindings(subpattern, pattern_user_ty, f);\n                 }\n@@ -536,41 +528,47 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 let from = u32::try_from(prefix.len()).unwrap();\n                 let to = u32::try_from(suffix.len()).unwrap();\n                 for subpattern in prefix {\n-                    self.visit_bindings(subpattern, &pattern_user_ty.index(), f);\n+                    self.visit_bindings(subpattern, pattern_user_ty.clone().index(), f);\n                 }\n                 for subpattern in slice {\n-                    self.visit_bindings(subpattern, &pattern_user_ty.subslice(from, to), f);\n+                    self.visit_bindings(subpattern, pattern_user_ty.clone().subslice(from, to), f);\n                 }\n                 for subpattern in suffix {\n-                    self.visit_bindings(subpattern, &pattern_user_ty.index(), f);\n+                    self.visit_bindings(subpattern, pattern_user_ty.clone().index(), f);\n                 }\n             }\n             PatternKind::Constant { .. } | PatternKind::Range { .. } | PatternKind::Wild => {}\n             PatternKind::Deref { ref subpattern } => {\n-                self.visit_bindings(subpattern, &pattern_user_ty.deref(), f);\n+                self.visit_bindings(subpattern, pattern_user_ty.deref(), f);\n             }\n             PatternKind::AscribeUserType { ref subpattern, ref user_ty, user_ty_span } => {\n                 // This corresponds to something like\n                 //\n                 // ```\n                 // let A::<'a>(_): A<'static> = ...;\n                 // ```\n-                let subpattern_user_ty = pattern_user_ty.add_user_type(user_ty, user_ty_span);\n-                self.visit_bindings(subpattern, &subpattern_user_ty, f)\n+                let annotation = (user_ty_span, user_ty.base);\n+                let projection = UserTypeProjection {\n+                    base: self.canonical_user_type_annotations.push(annotation),\n+                    projs: user_ty.projs.clone(),\n+                };\n+                let subpattern_user_ty = pattern_user_ty.push_projection(&projection, user_ty_span);\n+                self.visit_bindings(subpattern, subpattern_user_ty, f)\n             }\n \n             PatternKind::Leaf { ref subpatterns } => {\n                 for subpattern in subpatterns {\n-                    let subpattern_user_ty = pattern_user_ty.leaf(subpattern.field);\n-                    self.visit_bindings(&subpattern.pattern, &subpattern_user_ty, f);\n+                    let subpattern_user_ty = pattern_user_ty.clone().leaf(subpattern.field);\n+                    debug!(\"visit_bindings: subpattern_user_ty={:?}\", subpattern_user_ty);\n+                    self.visit_bindings(&subpattern.pattern, subpattern_user_ty, f);\n                 }\n             }\n \n             PatternKind::Variant { adt_def, substs: _, variant_index, ref subpatterns } => {\n                 for subpattern in subpatterns {\n-                    let subpattern_user_ty = pattern_user_ty.variant(\n+                    let subpattern_user_ty = pattern_user_ty.clone().variant(\n                         adt_def, variant_index, subpattern.field);\n-                    self.visit_bindings(&subpattern.pattern, &subpattern_user_ty, f);\n+                    self.visit_bindings(&subpattern.pattern, subpattern_user_ty, f);\n                 }\n             }\n         }\n@@ -1314,14 +1312,17 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 ascription.user_ty,\n             );\n \n+            let user_ty = box ascription.user_ty.clone().user_ty(\n+                &mut self.canonical_user_type_annotations, source_info.span\n+            );\n             self.cfg.push(\n                 block,\n                 Statement {\n                     source_info,\n                     kind: StatementKind::AscribeUserType(\n                         ascription.source.clone(),\n                         ty::Variance::Covariant,\n-                        box ascription.user_ty.clone().user_ty(),\n+                        user_ty,\n                     ),\n                 },\n             );\n@@ -1468,7 +1469,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         num_patterns: usize,\n         var_id: NodeId,\n         var_ty: Ty<'tcx>,\n-        user_var_ty: &PatternTypeProjections<'tcx>,\n+        user_ty: UserTypeProjections<'tcx>,\n         has_guard: ArmHasGuard,\n         opt_match_place: Option<(Option<Place<'tcx>>, Span)>,\n         pat_span: Span,\n@@ -1484,10 +1485,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             BindingMode::ByValue => ty::BindingMode::BindByValue(mutability.into()),\n             BindingMode::ByRef { .. } => ty::BindingMode::BindByReference(mutability.into()),\n         };\n+        debug!(\"declare_binding: user_ty={:?}\", user_ty);\n         let local = LocalDecl::<'tcx> {\n             mutability,\n             ty: var_ty,\n-            user_ty: user_var_ty.clone().user_ty(),\n+            user_ty,\n             name: Some(name),\n             source_info,\n             visibility_scope,"}, {"sha": "8acdecf6fa2489c9060c17ce0a59d4c8dc653710", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -379,6 +379,7 @@ struct Builder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     /// (A match binding can have two locals; the 2nd is for the arm's guard.)\n     var_indices: NodeMap<LocalsForNode>,\n     local_decls: IndexVec<Local, LocalDecl<'tcx>>,\n+    canonical_user_type_annotations: ty::CanonicalUserTypeAnnotations<'tcx>,\n     upvar_decls: Vec<UpvarDecl>,\n     unit_temp: Option<Place<'tcx>>,\n \n@@ -812,6 +813,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 LocalDecl::new_return_place(return_ty, return_span),\n                 1,\n             ),\n+            canonical_user_type_annotations: IndexVec::new(),\n             upvar_decls,\n             var_indices: Default::default(),\n             unit_temp: None,\n@@ -845,6 +847,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             IndexVec::new(),\n             yield_ty,\n             self.local_decls,\n+            self.canonical_user_type_annotations,\n             self.arg_count,\n             self.upvar_decls,\n             self.fn_span,"}, {"sha": "e73cc40c8c6e4ca19a84b14ed754281f6782d633", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -78,12 +78,13 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                         let mut pattern = cx.pattern_from_hir(&local.pat);\n \n                         if let Some(ty) = &local.ty {\n-                            if let Some(&user_ty) = cx.tables.user_provided_tys().get(ty.hir_id) {\n+                            if let Some(&user_ty) = cx.tables.user_provided_types().get(ty.hir_id) {\n+                                debug!(\"mirror_stmts: user_ty={:?}\", user_ty);\n                                 pattern = Pattern {\n                                     ty: pattern.ty,\n                                     span: pattern.span,\n                                     kind: Box::new(PatternKind::AscribeUserType {\n-                                        user_ty: PatternTypeProjection::from_canonical_ty(user_ty),\n+                                        user_ty: PatternTypeProjection::from_user_type(user_ty),\n                                         user_ty_span: ty.span,\n                                         subpattern: pattern\n                                     })"}, {"sha": "293058a0f26f53d359316eb42eae69361a1b19d3", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 44, "deletions": 19, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -11,7 +11,7 @@ use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow, AutoBorrowMutability\n use rustc::ty::cast::CastKind as TyCastKind;\n use rustc::hir;\n use rustc::hir::def_id::LocalDefId;\n-use rustc::mir::{BorrowKind};\n+use rustc::mir::BorrowKind;\n use syntax_pos::Span;\n \n impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n@@ -283,9 +283,16 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 };\n                 if let Some((adt_def, index)) = adt_data {\n                     let substs = cx.tables().node_substs(fun.hir_id);\n-\n-                    let user_ty = cx.tables().user_substs(fun.hir_id)\n-                        .map(|user_substs| UserTypeAnnotation::TypeOf(adt_def.did, user_substs));\n+                    let user_provided_types = cx.tables().user_provided_types();\n+                    let user_ty = user_provided_types.get(fun.hir_id)\n+                        .map(|u_ty| *u_ty)\n+                        .map(|mut u_ty| {\n+                            if let UserTypeAnnotation::TypeOf(ref mut did, _) = &mut u_ty.value {\n+                                *did = adt_def.did;\n+                            }\n+                            u_ty\n+                        });\n+                    debug!(\"make_mirror_unadjusted: (call) user_ty={:?}\", user_ty);\n \n                     let field_refs = args.iter()\n                         .enumerate()\n@@ -464,11 +471,14 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 ty::Adt(adt, substs) => {\n                     match adt.adt_kind() {\n                         AdtKind::Struct | AdtKind::Union => {\n+                            let user_provided_types = cx.tables().user_provided_types();\n+                            let user_ty = user_provided_types.get(expr.hir_id).map(|u_ty| *u_ty);\n+                            debug!(\"make_mirror_unadjusted: (struct/union) user_ty={:?}\", user_ty);\n                             ExprKind::Adt {\n                                 adt_def: adt,\n                                 variant_index: VariantIdx::new(0),\n                                 substs,\n-                                user_ty: cx.user_substs_applied_to_adt(expr.hir_id, adt),\n+                                user_ty,\n                                 fields: field_refs(cx, fields),\n                                 base: base.as_ref().map(|base| {\n                                     FruInfo {\n@@ -487,11 +497,18 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                     assert!(base.is_none());\n \n                                     let index = adt.variant_index_with_id(variant_id);\n+                                    let user_provided_types = cx.tables().user_provided_types();\n+                                    let user_ty = user_provided_types.get(expr.hir_id)\n+                                        .map(|u_ty| *u_ty);\n+                                    debug!(\n+                                        \"make_mirror_unadjusted: (variant) user_ty={:?}\",\n+                                        user_ty\n+                                    );\n                                     ExprKind::Adt {\n                                         adt_def: adt,\n                                         variant_index: index,\n                                         substs,\n-                                        user_ty: cx.user_substs_applied_to_adt(expr.hir_id, adt),\n+                                        user_ty,\n                                         fields: field_refs(cx, fields),\n                                         base: None,\n                                     }\n@@ -635,8 +652,8 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n         hir::ExprKind::Cast(ref source, ref cast_ty) => {\n             // Check for a user-given type annotation on this `cast`\n-            let user_ty = cx.tables.user_provided_tys().get(cast_ty.hir_id)\n-                .map(|&t| UserTypeAnnotation::Ty(t));\n+            let user_provided_types = cx.tables.user_provided_types();\n+            let user_ty = user_provided_types.get(cast_ty.hir_id);\n \n             debug!(\n                 \"cast({:?}) has ty w/ hir_id {:?} and user provided ty {:?}\",\n@@ -742,20 +759,20 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     span: expr.span,\n                     kind: cast,\n                 };\n+                debug!(\"make_mirror_unadjusted: (cast) user_ty={:?}\", user_ty);\n \n                 ExprKind::ValueTypeAscription {\n                     source: cast_expr.to_ref(),\n-                    user_ty: Some(user_ty),\n+                    user_ty: Some(*user_ty),\n                 }\n             } else {\n                 cast\n             }\n         }\n         hir::ExprKind::Type(ref source, ref ty) => {\n-            let user_provided_tys = cx.tables.user_provided_tys();\n-            let user_ty = user_provided_tys\n-                .get(ty.hir_id)\n-                .map(|&c_ty| UserTypeAnnotation::Ty(c_ty));\n+            let user_provided_types = cx.tables.user_provided_types();\n+            let user_ty = user_provided_types.get(ty.hir_id).map(|u_ty| *u_ty);\n+            debug!(\"make_mirror_unadjusted: (type) user_ty={:?}\", user_ty);\n             if source.is_place_expr() {\n                 ExprKind::PlaceTypeAscription {\n                     source: source.to_ref(),\n@@ -792,8 +809,9 @@ fn user_substs_applied_to_def(\n     cx: &mut Cx<'a, 'gcx, 'tcx>,\n     hir_id: hir::HirId,\n     def: &Def,\n-) -> Option<UserTypeAnnotation<'tcx>> {\n-    match def {\n+) -> Option<ty::CanonicalUserTypeAnnotation<'tcx>> {\n+    debug!(\"user_substs_applied_to_def: def={:?}\", def);\n+    let user_provided_type = match def {\n         // A reference to something callable -- e.g., a fn, method, or\n         // a tuple-struct or tuple-variant. This has the type of a\n         // `Fn` but with the user-given substitutions.\n@@ -802,8 +820,7 @@ fn user_substs_applied_to_def(\n         Def::StructCtor(_, CtorKind::Fn) |\n         Def::VariantCtor(_, CtorKind::Fn) |\n         Def::Const(_) |\n-        Def::AssociatedConst(_) =>\n-            Some(UserTypeAnnotation::TypeOf(def.def_id(), cx.tables().user_substs(hir_id)?)),\n+        Def::AssociatedConst(_) => cx.tables().user_provided_types().get(hir_id).map(|u_ty| *u_ty),\n \n         // A unit struct/variant which is used as a value (e.g.,\n         // `None`). This has the type of the enum/struct that defines\n@@ -819,7 +836,9 @@ fn user_substs_applied_to_def(\n \n         _ =>\n             bug!(\"user_substs_applied_to_def: unexpected def {:?} at {:?}\", def, hir_id)\n-    }\n+    };\n+    debug!(\"user_substs_applied_to_def: user_provided_type={:?}\", user_provided_type);\n+    user_provided_type\n }\n \n fn method_callee<'a, 'gcx, 'tcx>(\n@@ -839,6 +858,7 @@ fn method_callee<'a, 'gcx, 'tcx>(\n                     span_bug!(expr.span, \"no type-dependent def for method callee\")\n                 });\n             let user_ty = user_substs_applied_to_def(cx, expr.hir_id, def);\n+            debug!(\"method_callee: user_ty={:?}\", user_ty);\n             (def.def_id(), cx.tables().node_substs(expr.hir_id), user_ty)\n         }\n     };\n@@ -906,6 +926,7 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         Def::VariantCtor(_, CtorKind::Fn) |\n         Def::SelfCtor(..) => {\n             let user_ty = user_substs_applied_to_def(cx, expr.hir_id, &def);\n+            debug!(\"convert_path_expr: user_ty={:?}\", user_ty);\n             ExprKind::Literal {\n                 literal: ty::Const::zero_sized(\n                     cx.tcx,\n@@ -918,6 +939,7 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         Def::Const(def_id) |\n         Def::AssociatedConst(def_id) => {\n             let user_ty = user_substs_applied_to_def(cx, expr.hir_id, &def);\n+            debug!(\"convert_path_expr: (const) user_ty={:?}\", user_ty);\n             ExprKind::Literal {\n                 literal: ty::Const::unevaluated(\n                     cx.tcx,\n@@ -931,6 +953,9 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n         Def::StructCtor(def_id, CtorKind::Const) |\n         Def::VariantCtor(def_id, CtorKind::Const) => {\n+            let user_provided_types = cx.tables.user_provided_types();\n+            let user_provided_type = user_provided_types.get(expr.hir_id).map(|u_ty| *u_ty);\n+            debug!(\"convert_path_expr: user_provided_type={:?}\", user_provided_type);\n             match cx.tables().node_id_to_type(expr.hir_id).sty {\n                 // A unit struct/variant which is used as a value.\n                 // We return a completely different ExprKind here to account for this special case.\n@@ -939,7 +964,7 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                         adt_def,\n                         variant_index: adt_def.variant_index_with_id(def_id),\n                         substs,\n-                        user_ty: cx.user_substs_applied_to_adt(expr.hir_id, adt_def),\n+                        user_ty: user_provided_type,\n                         fields: vec![],\n                         base: None,\n                     }"}, {"sha": "b56e3d4e77395c49da800af726390bc10d1b553a", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -4,11 +4,12 @@\n //! unit-tested and separated from the Rust source and compiler data\n //! structures.\n \n-use rustc::mir::{BinOp, BorrowKind, UserTypeAnnotation, Field, UnOp};\n+use rustc::mir::{BinOp, BorrowKind, Field, UnOp};\n use rustc::hir::def_id::DefId;\n+use rustc::infer::canonical::Canonical;\n use rustc::middle::region;\n use rustc::ty::subst::Substs;\n-use rustc::ty::{AdtDef, UpvarSubsts, Region, Ty, Const};\n+use rustc::ty::{AdtDef, UpvarSubsts, Region, Ty, Const, UserTypeAnnotation};\n use rustc::ty::layout::VariantIdx;\n use rustc::hir;\n use syntax::ast;\n@@ -20,7 +21,7 @@ mod constant;\n \n pub mod pattern;\n pub use self::pattern::{BindingMode, Pattern, PatternKind, PatternRange, FieldPattern};\n-pub(crate) use self::pattern::{PatternTypeProjection, PatternTypeProjections};\n+pub(crate) use self::pattern::PatternTypeProjection;\n \n mod util;\n \n@@ -265,20 +266,20 @@ pub enum ExprKind<'tcx> {\n \n         /// Optional user-given substs: for something like `let x =\n         /// Bar::<T> { ... }`.\n-        user_ty: Option<UserTypeAnnotation<'tcx>>,\n+        user_ty: Option<Canonical<'tcx, UserTypeAnnotation<'tcx>>>,\n \n         fields: Vec<FieldExprRef<'tcx>>,\n         base: Option<FruInfo<'tcx>>\n     },\n     PlaceTypeAscription {\n         source: ExprRef<'tcx>,\n         /// Type that the user gave to this expression\n-        user_ty: Option<UserTypeAnnotation<'tcx>>,\n+        user_ty: Option<Canonical<'tcx, UserTypeAnnotation<'tcx>>>,\n     },\n     ValueTypeAscription {\n         source: ExprRef<'tcx>,\n         /// Type that the user gave to this expression\n-        user_ty: Option<UserTypeAnnotation<'tcx>>,\n+        user_ty: Option<Canonical<'tcx, UserTypeAnnotation<'tcx>>>,\n     },\n     Closure {\n         closure_id: DefId,\n@@ -288,7 +289,7 @@ pub enum ExprKind<'tcx> {\n     },\n     Literal {\n         literal: &'tcx Const<'tcx>,\n-        user_ty: Option<UserTypeAnnotation<'tcx>>,\n+        user_ty: Option<Canonical<'tcx, UserTypeAnnotation<'tcx>>>,\n     },\n     InlineAsm {\n         asm: &'tcx hir::InlineAsm,"}, {"sha": "10d2d7bc1b18b7cb63bc724e5447c51d76a937b5", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 50, "deletions": 115, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -12,9 +12,10 @@ use hair::util::UserAnnotatedTyHelpers;\n use hair::constant::*;\n \n use rustc::mir::{fmt_const_val, Field, BorrowKind, Mutability};\n-use rustc::mir::{ProjectionElem, UserTypeAnnotation, UserTypeProjection, UserTypeProjections};\n+use rustc::mir::{ProjectionElem, UserTypeProjection};\n use rustc::mir::interpret::{Scalar, GlobalId, ConstValue, sign_extend};\n use rustc::ty::{self, Region, TyCtxt, AdtDef, Ty, Lift};\n+use rustc::ty::{CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations, UserTypeAnnotation};\n use rustc::ty::subst::{Substs, Kind};\n use rustc::ty::layout::VariantIdx;\n use rustc::hir::{self, PatKind, RangeEnd};\n@@ -58,113 +59,29 @@ pub struct Pattern<'tcx> {\n \n \n #[derive(Clone, Debug)]\n-pub(crate) struct PatternTypeProjections<'tcx> {\n-    contents: Vec<(PatternTypeProjection<'tcx>, Span)>,\n+pub struct PatternTypeProjection<'tcx> {\n+    pub base: CanonicalUserTypeAnnotation<'tcx>,\n+    pub projs: Vec<ProjectionElem<'tcx, (), ()>>,\n }\n \n-impl<'tcx> PatternTypeProjections<'tcx> {\n-    pub(crate) fn user_ty(self) -> UserTypeProjections<'tcx> {\n-        UserTypeProjections::from_projections(\n-            self.contents.into_iter().map(|(pat_ty_proj, span)| (pat_ty_proj.user_ty(), span)))\n-    }\n-\n-    pub(crate) fn none() -> Self {\n-        PatternTypeProjections { contents: vec![] }\n-    }\n-\n-    pub(crate) fn ref_binding(&self) -> Self {\n-        // FIXME(#55401): ignore for now\n-        PatternTypeProjections { contents: vec![] }\n-    }\n-\n-    fn map_projs(&self,\n-                 mut f: impl FnMut(&PatternTypeProjection<'tcx>) -> PatternTypeProjection<'tcx>)\n-                 -> Self\n-    {\n-        PatternTypeProjections {\n-            contents: self.contents\n-                .iter()\n-                .map(|(proj, span)| (f(proj), *span))\n-                .collect(), }\n-    }\n-\n-    pub(crate) fn index(&self) -> Self { self.map_projs(|pat_ty_proj| pat_ty_proj.index()) }\n-\n-    pub(crate) fn subslice(&self, from: u32, to: u32) -> Self {\n-        self.map_projs(|pat_ty_proj| pat_ty_proj.subslice(from, to))\n-    }\n-\n-    pub(crate) fn deref(&self) -> Self { self.map_projs(|pat_ty_proj| pat_ty_proj.deref()) }\n-\n-    pub(crate) fn leaf(&self, field: Field) -> Self {\n-        self.map_projs(|pat_ty_proj| pat_ty_proj.leaf(field))\n-    }\n-\n-    pub(crate) fn variant(&self,\n-                          adt_def: &'tcx AdtDef,\n-                          variant_index: VariantIdx,\n-                          field: Field) -> Self {\n-        self.map_projs(|pat_ty_proj| pat_ty_proj.variant(adt_def, variant_index, field))\n-    }\n-\n-    pub(crate) fn add_user_type(&self, user_ty: &PatternTypeProjection<'tcx>, sp: Span) -> Self {\n-        let mut new = self.clone();\n-        new.contents.push((user_ty.clone(), sp));\n-        new\n-    }\n-}\n-\n-#[derive(Clone, Debug)]\n-pub struct PatternTypeProjection<'tcx>(UserTypeProjection<'tcx>);\n-\n impl<'tcx> PatternTypeProjection<'tcx> {\n-    pub(crate) fn index(&self) -> Self {\n-        let mut new = self.clone();\n-        new.0.projs.push(ProjectionElem::Index(()));\n-        new\n-    }\n-\n-    pub(crate) fn subslice(&self, from: u32, to: u32) -> Self {\n-        let mut new = self.clone();\n-        new.0.projs.push(ProjectionElem::Subslice { from, to });\n-        new\n-    }\n-\n-    pub(crate) fn deref(&self) -> Self {\n-        let mut new = self.clone();\n-        new.0.projs.push(ProjectionElem::Deref);\n-        new\n-    }\n-\n-    pub(crate) fn leaf(&self, field: Field) -> Self {\n-        let mut new = self.clone();\n-        new.0.projs.push(ProjectionElem::Field(field, ()));\n-        new\n-    }\n-\n-    pub(crate) fn variant(&self,\n-                          adt_def: &'tcx AdtDef,\n-                          variant_index: VariantIdx,\n-                          field: Field) -> Self {\n-        let mut new = self.clone();\n-        new.0.projs.push(ProjectionElem::Downcast(adt_def, variant_index));\n-        new.0.projs.push(ProjectionElem::Field(field, ()));\n-        new\n-    }\n-\n-    pub(crate) fn from_canonical_ty(c_ty: ty::CanonicalTy<'tcx>) -> Self {\n-        Self::from_user_type(UserTypeAnnotation::Ty(c_ty))\n-    }\n-\n-    pub(crate) fn from_user_type(u_ty: UserTypeAnnotation<'tcx>) -> Self {\n-        Self::from_user_type_proj(UserTypeProjection { base: u_ty, projs: vec![], })\n+    pub(crate) fn from_user_type(user_annotation: CanonicalUserTypeAnnotation<'tcx>) -> Self {\n+        Self {\n+            base: user_annotation,\n+            projs: Vec::new(),\n+        }\n     }\n \n-    pub(crate) fn from_user_type_proj(u_ty: UserTypeProjection<'tcx>) -> Self {\n-        PatternTypeProjection(u_ty)\n+    pub(crate) fn user_ty(\n+        self,\n+        annotations: &mut CanonicalUserTypeAnnotations<'tcx>,\n+        span: Span,\n+    ) -> UserTypeProjection<'tcx> {\n+        UserTypeProjection {\n+            base: annotations.push((span, self.base)),\n+            projs: self.projs\n+        }\n     }\n-\n-    pub(crate) fn user_ty(self) -> UserTypeProjection<'tcx> { self.0 }\n }\n \n #[derive(Clone, Debug)]\n@@ -788,18 +705,14 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n         };\n \n         if let Some(user_ty) = self.user_substs_applied_to_ty_of_hir_id(hir_id) {\n-            let subpattern = Pattern {\n-                span,\n-                ty,\n-                kind: Box::new(kind),\n-            };\n-\n-            debug!(\"pattern user_ty = {:?} for pattern at {:?}\", user_ty, span);\n-\n-            let pat_ty = PatternTypeProjection::from_user_type(user_ty);\n+            debug!(\"lower_variant_or_leaf: kind={:?} user_ty={:?} span={:?}\", kind, user_ty, span);\n             kind = PatternKind::AscribeUserType {\n-                subpattern,\n-                user_ty: pat_ty,\n+                subpattern: Pattern {\n+                    span,\n+                    ty,\n+                    kind: Box::new(kind),\n+                },\n+                user_ty: PatternTypeProjection::from_user_type(user_ty),\n                 user_ty_span: span,\n             };\n         }\n@@ -837,7 +750,28 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                         };\n                         match self.tcx.at(span).const_eval(self.param_env.and(cid)) {\n                             Ok(value) => {\n-                                return self.const_to_pat(instance, value, id, span)\n+                                let pattern = self.const_to_pat(instance, value, id, span);\n+                                if !is_associated_const {\n+                                    return pattern;\n+                                }\n+\n+                                let user_provided_types = self.tables().user_provided_types();\n+                                return if let Some(u_ty) = user_provided_types.get(id) {\n+                                    let user_ty = PatternTypeProjection::from_user_type(*u_ty);\n+                                    Pattern {\n+                                        span,\n+                                        kind: Box::new(\n+                                            PatternKind::AscribeUserType {\n+                                                subpattern: pattern,\n+                                                user_ty,\n+                                                user_ty_span: span,\n+                                            }\n+                                        ),\n+                                        ty: value.ty,\n+                                    }\n+                                } else {\n+                                    pattern\n+                                }\n                             },\n                             Err(_) => {\n                                 self.tcx.sess.span_err(\n@@ -927,7 +861,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n         id: hir::HirId,\n         span: Span,\n     ) -> Pattern<'tcx> {\n-        debug!(\"const_to_pat: cv={:#?}\", cv);\n+        debug!(\"const_to_pat: cv={:#?} id={:?}\", cv, id);\n         let adt_subpattern = |i, variant_opt| {\n             let field = Field::new(i);\n             let val = const_field(\n@@ -945,6 +879,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 }\n             }).collect::<Vec<_>>()\n         };\n+        debug!(\"const_to_pat: cv.ty={:?} span={:?}\", cv.ty, span);\n         let kind = match cv.ty.sty {\n             ty::Float(_) => {\n                 let id = self.tcx.hir().hir_to_node_id(id);"}, {"sha": "f0f8263b64de53f286e090e225f8060473897057", "filename": "src/librustc_mir/hair/util.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc_mir%2Fhair%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc_mir%2Fhair%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Futil.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -1,37 +1,31 @@\n use rustc::hir;\n-use rustc::mir::UserTypeAnnotation;\n-use rustc::ty::{self, AdtDef, TyCtxt};\n+use rustc::ty::{self, CanonicalUserTypeAnnotation, TyCtxt, UserTypeAnnotation};\n \n crate trait UserAnnotatedTyHelpers<'gcx: 'tcx, 'tcx> {\n     fn tcx(&self) -> TyCtxt<'_, 'gcx, 'tcx>;\n \n     fn tables(&self) -> &ty::TypeckTables<'tcx>;\n \n-    fn user_substs_applied_to_adt(\n-        &self,\n-        hir_id: hir::HirId,\n-        adt_def: &'tcx AdtDef,\n-    ) -> Option<UserTypeAnnotation<'tcx>> {\n-        let user_substs = self.tables().user_substs(hir_id)?;\n-        Some(UserTypeAnnotation::TypeOf(adt_def.did, user_substs))\n-    }\n-\n     /// Looks up the type associated with this hir-id and applies the\n     /// user-given substitutions; the hir-id must map to a suitable\n     /// type.\n     fn user_substs_applied_to_ty_of_hir_id(\n         &self,\n         hir_id: hir::HirId,\n-    ) -> Option<UserTypeAnnotation<'tcx>> {\n-        let user_substs = self.tables().user_substs(hir_id)?;\n+    ) -> Option<CanonicalUserTypeAnnotation<'tcx>> {\n+        let user_provided_types = self.tables().user_provided_types();\n+        let mut user_ty = *user_provided_types.get(hir_id)?;\n+        debug!(\"user_subts_applied_to_ty_of_hir_id: user_ty={:?}\", user_ty);\n         match &self.tables().node_id_to_type(hir_id).sty {\n-            ty::Adt(adt_def, _) => Some(UserTypeAnnotation::TypeOf(adt_def.did, user_substs)),\n-            ty::FnDef(def_id, _) => Some(UserTypeAnnotation::TypeOf(*def_id, user_substs)),\n-            sty => bug!(\n-                \"sty: {:?} should not have user-substs {:?} recorded \",\n-                sty,\n-                user_substs\n-            ),\n+            ty::Adt(adt_def, ..) => {\n+                if let UserTypeAnnotation::TypeOf(ref mut did, _) = &mut user_ty.value {\n+                    *did = adt_def.did;\n+                }\n+                Some(user_ty)\n+            }\n+            ty::FnDef(..) => Some(user_ty),\n+            sty =>\n+                bug!(\"sty: {:?} should not have user provided type {:?} recorded \", sty, user_ty),\n         }\n     }\n }"}, {"sha": "4c123d4a44b058857d3524b0d709a6992cc8fab3", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -207,6 +207,7 @@ fn build_drop_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         IndexVec::new(),\n         None,\n         local_decls_for_sig(&sig, span),\n+        IndexVec::new(),\n         sig.inputs().len(),\n         vec![],\n         span,\n@@ -376,6 +377,7 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n             IndexVec::new(),\n             None,\n             self.local_decls,\n+            IndexVec::new(),\n             self.sig.inputs().len(),\n             vec![],\n             self.span,\n@@ -825,6 +827,7 @@ fn build_call_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         IndexVec::new(),\n         None,\n         local_decls,\n+        IndexVec::new(),\n         sig.inputs().len(),\n         vec![],\n         span,\n@@ -903,6 +906,7 @@ pub fn build_adt_ctor<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n         IndexVec::new(),\n         None,\n         local_decls,\n+        IndexVec::new(),\n         sig.inputs().len(),\n         vec![],\n         span,"}, {"sha": "1602fc35a2c9585a54f44d13d052515a1310e72d", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -400,6 +400,7 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n                 IndexVec::new(),\n                 None,\n                 initial_locals,\n+                IndexVec::new(),\n                 0,\n                 vec![],\n                 mir.span,"}, {"sha": "6353eab6f6553770271e491549ce1c16cda7a1b7", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -142,6 +142,7 @@ fn dump_matched_mir_node<'a, 'gcx, 'tcx, F>(\n         }\n         writeln!(file, \"\")?;\n         extra_data(PassWhere::BeforeCFG, &mut file)?;\n+        write_user_type_annotations(mir, &mut file)?;\n         write_mir_fn(tcx, source, mir, &mut extra_data, &mut file)?;\n         extra_data(PassWhere::AfterCFG, &mut file)?;\n     };\n@@ -618,6 +619,19 @@ fn write_temp_decls(mir: &Mir, w: &mut dyn Write) -> io::Result<()> {\n     Ok(())\n }\n \n+fn write_user_type_annotations(mir: &Mir, w: &mut dyn Write) -> io::Result<()> {\n+    if !mir.user_type_annotations.is_empty() {\n+        writeln!(w, \"| User Type Annotations\")?;\n+    }\n+    for (index, (span, annotation)) in mir.user_type_annotations.iter_enumerated() {\n+        writeln!(w, \"| {:?}: {:?} at {:?}\", index.index(), annotation, span)?;\n+    }\n+    if !mir.user_type_annotations.is_empty() {\n+        writeln!(w, \"|\")?;\n+    }\n+    Ok(())\n+}\n+\n pub fn dump_mir_def_ids(tcx: TyCtxt, single: Option<DefId>) -> Vec<DefId> {\n     if let Some(i) = single {\n         vec![i]"}, {"sha": "c6626c1551f4a17e66faf7c2881b6e65cd60ae1d", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 446, "deletions": 514, "changes": 960, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -20,22 +20,279 @@ use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::itemlikevisit::DeepVisitor;\n use rustc::lint;\n use rustc::middle::privacy::{AccessLevel, AccessLevels};\n-use rustc::ty::{self, TyCtxt, Ty, TypeFoldable, GenericParamDefKind};\n+use rustc::ty::{self, TyCtxt, Ty, TraitRef, TypeFoldable, GenericParamDefKind};\n use rustc::ty::fold::TypeVisitor;\n use rustc::ty::query::Providers;\n-use rustc::ty::subst::UnpackedKind;\n+use rustc::ty::subst::Substs;\n use rustc::util::nodemap::NodeSet;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::Lrc;\n use syntax::ast::{self, CRATE_NODE_ID, Ident};\n+use syntax::attr;\n use syntax::symbol::keywords;\n use syntax_pos::Span;\n \n-use std::cmp;\n-use std::mem::replace;\n+use std::{cmp, fmt, mem};\n+use std::marker::PhantomData;\n \n mod diagnostics;\n \n+////////////////////////////////////////////////////////////////////////////////\n+/// Generic infrastructure used to implement specific visitors below.\n+////////////////////////////////////////////////////////////////////////////////\n+\n+/// Implemented to visit all `DefId`s in a type.\n+/// Visiting `DefId`s is useful because visibilities and reachabilities are attached to them.\n+/// The idea is to visit \"all components of a type\", as documented in\n+/// https://github.com/rust-lang/rfcs/blob/master/text/2145-type-privacy.md#how-to-determine-visibility-of-a-type\n+/// Default type visitor (`TypeVisitor`) does most of the job, but it has some shortcomings.\n+/// First, it doesn't have overridable `fn visit_trait_ref`, so we have to catch trait def-ids\n+/// manually. Second, it doesn't visit some type components like signatures of fn types, or traits\n+/// in `impl Trait`, see individual commits in `DefIdVisitorSkeleton::visit_ty`.\n+trait DefIdVisitor<'a, 'tcx: 'a> {\n+    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx>;\n+    fn recurse_into_assoc_tys(&self) -> bool { true }\n+    fn visit_def_id(&mut self, def_id: DefId, kind: &str, descr: &dyn fmt::Display) -> bool;\n+\n+    /// Not overridden, but used to actually visit types and traits.\n+    fn skeleton(&mut self) -> DefIdVisitorSkeleton<'_, 'a, 'tcx, Self> {\n+        DefIdVisitorSkeleton {\n+            def_id_visitor: self,\n+            visited_opaque_tys: Default::default(),\n+            dummy: Default::default(),\n+        }\n+    }\n+    fn visit(&mut self, ty_fragment: impl TypeFoldable<'tcx>) -> bool {\n+        ty_fragment.visit_with(&mut self.skeleton())\n+    }\n+    fn visit_trait(&mut self, trait_ref: TraitRef<'tcx>) -> bool {\n+        self.skeleton().visit_trait(trait_ref)\n+    }\n+    fn visit_predicates(&mut self, predicates: Lrc<ty::GenericPredicates<'tcx>>) -> bool {\n+        self.skeleton().visit_predicates(predicates)\n+    }\n+}\n+\n+struct DefIdVisitorSkeleton<'v, 'a, 'tcx, V>\n+    where V: DefIdVisitor<'a, 'tcx> + ?Sized\n+{\n+    def_id_visitor: &'v mut V,\n+    visited_opaque_tys: FxHashSet<DefId>,\n+    dummy: PhantomData<TyCtxt<'a, 'tcx, 'tcx>>,\n+}\n+\n+impl<'a, 'tcx, V> DefIdVisitorSkeleton<'_, 'a, 'tcx, V>\n+    where V: DefIdVisitor<'a, 'tcx> + ?Sized\n+{\n+    fn visit_trait(&mut self, trait_ref: TraitRef<'tcx>) -> bool {\n+        let TraitRef { def_id, substs } = trait_ref;\n+        self.def_id_visitor.visit_def_id(def_id, \"trait\", &trait_ref) || substs.visit_with(self)\n+    }\n+\n+    fn visit_predicates(&mut self, predicates: Lrc<ty::GenericPredicates<'tcx>>) -> bool {\n+        let ty::GenericPredicates { parent: _, predicates } = &*predicates;\n+        for (predicate, _span) in predicates {\n+            match predicate {\n+                ty::Predicate::Trait(poly_predicate) => {\n+                    let ty::TraitPredicate { trait_ref } = *poly_predicate.skip_binder();\n+                    if self.visit_trait(trait_ref) {\n+                        return true;\n+                    }\n+                }\n+                ty::Predicate::Projection(poly_predicate) => {\n+                    let ty::ProjectionPredicate { projection_ty, ty } =\n+                        *poly_predicate.skip_binder();\n+                    if ty.visit_with(self) {\n+                        return true;\n+                    }\n+                    if self.visit_trait(projection_ty.trait_ref(self.def_id_visitor.tcx())) {\n+                        return true;\n+                    }\n+                }\n+                ty::Predicate::TypeOutlives(poly_predicate) => {\n+                    let ty::OutlivesPredicate(ty, _region) = *poly_predicate.skip_binder();\n+                    if ty.visit_with(self) {\n+                        return true;\n+                    }\n+                }\n+                ty::Predicate::RegionOutlives(..) => {},\n+                _ => bug!(\"unexpected predicate: {:?}\", predicate),\n+            }\n+        }\n+        false\n+    }\n+}\n+\n+impl<'a, 'tcx, V> TypeVisitor<'tcx> for DefIdVisitorSkeleton<'_, 'a, 'tcx, V>\n+    where V: DefIdVisitor<'a, 'tcx> + ?Sized\n+{\n+    fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n+        let tcx = self.def_id_visitor.tcx();\n+        // Substs are not visited here because they are visited below in `super_visit_with`.\n+        match ty.sty {\n+            ty::Adt(&ty::AdtDef { did: def_id, .. }, ..) |\n+            ty::Foreign(def_id) |\n+            ty::FnDef(def_id, ..) |\n+            ty::Closure(def_id, ..) |\n+            ty::Generator(def_id, ..) => {\n+                if self.def_id_visitor.visit_def_id(def_id, \"type\", ty) {\n+                    return true;\n+                }\n+                // Default type visitor doesn't visit signatures of fn types.\n+                // Something like `fn() -> Priv {my_func}` is considered a private type even if\n+                // `my_func` is public, so we need to visit signatures.\n+                if let ty::FnDef(..) = ty.sty {\n+                    if tcx.fn_sig(def_id).visit_with(self) {\n+                        return true;\n+                    }\n+                }\n+                // Inherent static methods don't have self type in substs.\n+                // Something like `fn() {my_method}` type of the method\n+                // `impl Pub<Priv> { pub fn my_method() {} }` is considered a private type,\n+                // so we need to visit the self type additionally.\n+                if let Some(assoc_item) = tcx.opt_associated_item(def_id) {\n+                    if let ty::ImplContainer(impl_def_id) = assoc_item.container {\n+                        if tcx.type_of(impl_def_id).visit_with(self) {\n+                            return true;\n+                        }\n+                    }\n+                }\n+            }\n+            ty::Projection(proj) | ty::UnnormalizedProjection(proj) => {\n+                if !self.def_id_visitor.recurse_into_assoc_tys() {\n+                    // Visitors searching for minimal visibility/reachability want to\n+                    // conservatively approximate associated types like `<Type as Trait>::Alias`\n+                    // as visible/reachable even if both `Type` and `Trait` are private.\n+                    // Ideally, associated types should be substituted in the same way as\n+                    // free type aliases, but this isn't done yet.\n+                    return false;\n+                }\n+                // This will also visit substs, so we don't need to recurse.\n+                return self.visit_trait(proj.trait_ref(tcx));\n+            }\n+            ty::Dynamic(predicates, ..) => {\n+                for predicate in *predicates.skip_binder() {\n+                    let trait_ref = match *predicate {\n+                        ty::ExistentialPredicate::Trait(trait_ref) => trait_ref,\n+                        ty::ExistentialPredicate::Projection(proj) => proj.trait_ref(tcx),\n+                        ty::ExistentialPredicate::AutoTrait(def_id) =>\n+                            ty::ExistentialTraitRef { def_id, substs: Substs::empty() },\n+                    };\n+                    let ty::ExistentialTraitRef { def_id, substs: _ } = trait_ref;\n+                    if self.def_id_visitor.visit_def_id(def_id, \"trait\", &trait_ref) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            ty::Opaque(def_id, ..) => {\n+                // Skip repeated `Opaque`s to avoid infinite recursion.\n+                if self.visited_opaque_tys.insert(def_id) {\n+                    // Default type visitor doesn't visit traits in `impl Trait`.\n+                    // Something like `impl PrivTr` is considered a private type,\n+                    // so we need to visit the traits additionally.\n+                    if self.visit_predicates(tcx.predicates_of(def_id)) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            // These types don't have their own def-ids (but may have subcomponents\n+            // with def-ids that should be visited recursively).\n+            ty::Bool | ty::Char | ty::Int(..) | ty::Uint(..) |\n+            ty::Float(..) | ty::Str | ty::Never |\n+            ty::Array(..) | ty::Slice(..) | ty::Tuple(..) |\n+            ty::RawPtr(..) | ty::Ref(..) | ty::FnPtr(..) |\n+            ty::Param(..) | ty::Error | ty::GeneratorWitness(..) => {}\n+            ty::Bound(..) | ty::Placeholder(..) | ty::Infer(..) =>\n+                bug!(\"unexpected type: {:?}\", ty),\n+        }\n+\n+        ty.super_visit_with(self)\n+    }\n+}\n+\n+fn def_id_visibility<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n+                               -> (ty::Visibility, Span, &'static str) {\n+    match tcx.hir().as_local_node_id(def_id) {\n+        Some(node_id) => {\n+            let vis = match tcx.hir().get(node_id) {\n+                Node::Item(item) => &item.vis,\n+                Node::ForeignItem(foreign_item) => &foreign_item.vis,\n+                Node::TraitItem(..) | Node::Variant(..) => {\n+                    return def_id_visibility(tcx, tcx.hir().get_parent_did(node_id));\n+                }\n+                Node::ImplItem(impl_item) => {\n+                    match tcx.hir().get(tcx.hir().get_parent(node_id)) {\n+                        Node::Item(item) => match &item.node {\n+                            hir::ItemKind::Impl(.., None, _, _) => &impl_item.vis,\n+                            hir::ItemKind::Impl(.., Some(trait_ref), _, _)\n+                                => return def_id_visibility(tcx, trait_ref.path.def.def_id()),\n+                            kind => bug!(\"unexpected item kind: {:?}\", kind),\n+                        }\n+                        node => bug!(\"unexpected node kind: {:?}\", node),\n+                    }\n+                }\n+                Node::StructCtor(vdata) => {\n+                    let struct_node_id = tcx.hir().get_parent(node_id);\n+                    let item = match tcx.hir().get(struct_node_id) {\n+                        Node::Item(item) => item,\n+                        node => bug!(\"unexpected node kind: {:?}\", node),\n+                    };\n+                    let (mut ctor_vis, mut span, mut descr) =\n+                        (ty::Visibility::from_hir(&item.vis, struct_node_id, tcx),\n+                         item.vis.span, item.vis.node.descr());\n+                    for field in vdata.fields() {\n+                        let field_vis = ty::Visibility::from_hir(&field.vis, node_id, tcx);\n+                        if ctor_vis.is_at_least(field_vis, tcx) {\n+                            ctor_vis = field_vis;\n+                            span = field.vis.span;\n+                            descr = field.vis.node.descr();\n+                        }\n+                    }\n+\n+                    // If the structure is marked as non_exhaustive then lower the\n+                    // visibility to within the crate.\n+                    if ctor_vis == ty::Visibility::Public {\n+                        let adt_def = tcx.adt_def(tcx.hir().get_parent_did(node_id));\n+                        if adt_def.non_enum_variant().is_field_list_non_exhaustive() {\n+                            ctor_vis = ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n+                            span = attr::find_by_name(&item.attrs, \"non_exhaustive\").unwrap().span;\n+                            descr = \"crate-visible\";\n+                        }\n+                    }\n+\n+                    return (ctor_vis, span, descr);\n+                }\n+                Node::Expr(expr) => {\n+                    return (ty::Visibility::Restricted(tcx.hir().get_module_parent(expr.id)),\n+                            expr.span, \"private\")\n+                }\n+                node => bug!(\"unexpected node kind: {:?}\", node)\n+            };\n+            (ty::Visibility::from_hir(vis, node_id, tcx), vis.span, vis.node.descr())\n+        }\n+        None => {\n+            let vis = tcx.visibility(def_id);\n+            let descr = if vis == ty::Visibility::Public { \"public\" } else { \"private\" };\n+            (vis, tcx.def_span(def_id), descr)\n+        }\n+    }\n+}\n+\n+// Set the correct `TypeckTables` for the given `item_id` (or an empty table if\n+// there is no `TypeckTables` for the item).\n+fn item_tables<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                         node_id: ast::NodeId,\n+                         empty_tables: &'a ty::TypeckTables<'tcx>)\n+                         -> &'a ty::TypeckTables<'tcx> {\n+    let def_id = tcx.hir().local_def_id(node_id);\n+    if tcx.has_typeck_tables(def_id) { tcx.typeck_tables_of(def_id) } else { empty_tables }\n+}\n+\n+fn min<'a, 'tcx>(vis1: ty::Visibility, vis2: ty::Visibility, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                 -> ty::Visibility {\n+    if vis1.is_at_least(vis2, tcx) { vis2 } else { vis1 }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n /// Visitor used to determine if pub(restricted) is used anywhere in the crate.\n ///\n@@ -56,6 +313,59 @@ impl<'a, 'tcx> Visitor<'tcx> for PubRestrictedVisitor<'a, 'tcx> {\n     }\n }\n \n+////////////////////////////////////////////////////////////////////////////////\n+/// Visitor used to determine impl visibility and reachability.\n+////////////////////////////////////////////////////////////////////////////////\n+\n+struct FindMin<'a, 'tcx, VL: VisibilityLike> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    access_levels: &'a AccessLevels,\n+    min: VL,\n+}\n+\n+impl<'a, 'tcx, VL: VisibilityLike> DefIdVisitor<'a, 'tcx> for FindMin<'a, 'tcx, VL> {\n+    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> { self.tcx }\n+    fn recurse_into_assoc_tys(&self) -> bool { false }\n+    fn visit_def_id(&mut self, def_id: DefId, _kind: &str, _descr: &dyn fmt::Display) -> bool {\n+        self.min = VL::new_min(self, def_id);\n+        false\n+    }\n+}\n+\n+trait VisibilityLike: Sized {\n+    const MAX: Self;\n+    fn new_min<'a, 'tcx>(find: &FindMin<'a, 'tcx, Self>, def_id: DefId) -> Self;\n+\n+    // Returns an over-approximation (`recurse_into_assoc_tys` = false) of visibility due to\n+    // associated types for which we can't determine visibility precisely.\n+    fn of_impl<'a, 'tcx>(node_id: ast::NodeId, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                         access_levels: &'a AccessLevels) -> Self {\n+        let mut find = FindMin { tcx, access_levels, min: Self::MAX };\n+        let def_id = tcx.hir().local_def_id(node_id);\n+        find.visit(tcx.type_of(def_id));\n+        if let Some(trait_ref) = tcx.impl_trait_ref(def_id) {\n+            find.visit_trait(trait_ref);\n+        }\n+        find.min\n+    }\n+}\n+impl VisibilityLike for ty::Visibility {\n+    const MAX: Self = ty::Visibility::Public;\n+    fn new_min<'a, 'tcx>(find: &FindMin<'a, 'tcx, Self>, def_id: DefId) -> Self {\n+        min(def_id_visibility(find.tcx, def_id).0, find.min, find.tcx)\n+    }\n+}\n+impl VisibilityLike for Option<AccessLevel> {\n+    const MAX: Self = Some(AccessLevel::Public);\n+    fn new_min<'a, 'tcx>(find: &FindMin<'a, 'tcx, Self>, def_id: DefId) -> Self {\n+        cmp::min(if let Some(node_id) = find.tcx.hir().as_local_node_id(def_id) {\n+            find.access_levels.map.get(&node_id).cloned()\n+        } else {\n+            Self::MAX\n+        }, find.min)\n+    }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n /// The embargo visitor, used to determine the exports of the ast\n ////////////////////////////////////////////////////////////////////////////////\n@@ -78,30 +388,6 @@ struct ReachEverythingInTheInterfaceVisitor<'b, 'a: 'b, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n-    fn item_ty_level(&self, item_def_id: DefId) -> Option<AccessLevel> {\n-        let ty_def_id = match self.tcx.type_of(item_def_id).sty {\n-            ty::Adt(adt, _) => adt.did,\n-            ty::Foreign(did) => did,\n-            ty::Dynamic(ref obj, ..) => obj.principal().def_id(),\n-            ty::Projection(ref proj) => proj.trait_ref(self.tcx).def_id,\n-            _ => return Some(AccessLevel::Public)\n-        };\n-        if let Some(node_id) = self.tcx.hir().as_local_node_id(ty_def_id) {\n-            self.get(node_id)\n-        } else {\n-            Some(AccessLevel::Public)\n-        }\n-    }\n-\n-    fn impl_trait_level(&self, impl_def_id: DefId) -> Option<AccessLevel> {\n-        if let Some(trait_ref) = self.tcx.impl_trait_ref(impl_def_id) {\n-            if let Some(node_id) = self.tcx.hir().as_local_node_id(trait_ref.def_id) {\n-                return self.get(node_id);\n-            }\n-        }\n-        Some(AccessLevel::Public)\n-    }\n-\n     fn get(&self, id: ast::NodeId) -> Option<AccessLevel> {\n         self.access_levels.map.get(&id).cloned()\n     }\n@@ -119,10 +405,10 @@ impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn reach<'b>(&'b mut self, item_id: ast::NodeId)\n-                 -> ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n+    fn reach(&mut self, item_id: ast::NodeId, access_level: Option<AccessLevel>)\n+             -> ReachEverythingInTheInterfaceVisitor<'_, 'a, 'tcx> {\n         ReachEverythingInTheInterfaceVisitor {\n-            access_level: self.prev_level.map(|l| l.min(AccessLevel::Reachable)),\n+            access_level: cmp::min(access_level, Some(AccessLevel::Reachable)),\n             item_def_id: self.tcx.hir().local_def_id(item_id),\n             ev: self,\n         }\n@@ -138,15 +424,10 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         let inherited_item_level = match item.node {\n-            // Impls inherit level from their types and traits.\n-            hir::ItemKind::Impl(..) => {\n-                let def_id = self.tcx.hir().local_def_id(item.id);\n-                cmp::min(self.item_ty_level(def_id), self.impl_trait_level(def_id))\n-            }\n+            hir::ItemKind::Impl(..) =>\n+                Option::<AccessLevel>::of_impl(item.id, self.tcx, &self.access_levels),\n             // Foreign modules inherit level from parents.\n-            hir::ItemKind::ForeignMod(..) => {\n-                self.prev_level\n-            }\n+            hir::ItemKind::ForeignMod(..) => self.prev_level,\n             // Other `pub` items inherit levels from parents.\n             hir::ItemKind::Const(..) | hir::ItemKind::Enum(..) | hir::ItemKind::ExternCrate(..) |\n             hir::ItemKind::GlobalAsm(..) | hir::ItemKind::Fn(..) | hir::ItemKind::Mod(..) |\n@@ -171,18 +452,13 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n                     }\n                 }\n             }\n-            hir::ItemKind::Impl(.., None, _, ref impl_item_refs) => {\n+            hir::ItemKind::Impl(.., ref trait_ref, _, ref impl_item_refs) => {\n                 for impl_item_ref in impl_item_refs {\n-                    if impl_item_ref.vis.node.is_pub() {\n+                    if trait_ref.is_some() || impl_item_ref.vis.node.is_pub() {\n                         self.update(impl_item_ref.id.node_id, item_level);\n                     }\n                 }\n             }\n-            hir::ItemKind::Impl(.., Some(_), _, ref impl_item_refs) => {\n-                for impl_item_ref in impl_item_refs {\n-                    self.update(impl_item_ref.id.node_id, item_level);\n-                }\n-            }\n             hir::ItemKind::Trait(.., ref trait_item_refs) => {\n                 for trait_item_ref in trait_item_refs {\n                     self.update(trait_item_ref.id.node_id, item_level);\n@@ -205,15 +481,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n                     }\n                 }\n             }\n-            // Impl trait return types mark their parent function.\n-            // It (and its children) are revisited if the change applies.\n-            hir::ItemKind::Existential(ref ty_data) => {\n-                if let Some(impl_trait_fn) = ty_data.impl_trait_fn {\n-                    if let Some(node_id) = self.tcx.hir().as_local_node_id(impl_trait_fn) {\n-                        self.update(node_id, Some(AccessLevel::ReachableFromImplTrait));\n-                    }\n-                }\n-            }\n+            hir::ItemKind::Existential(..) |\n             hir::ItemKind::Use(..) |\n             hir::ItemKind::Static(..) |\n             hir::ItemKind::Const(..) |\n@@ -225,10 +493,6 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n             hir::ItemKind::ExternCrate(..) => {}\n         }\n \n-        // Store this node's access level here to propagate the correct\n-        // reachability level through interfaces and children.\n-        let orig_level = replace(&mut self.prev_level, item_level);\n-\n         // Mark all items in interfaces of reachable items as reachable.\n         match item.node {\n             // The interface is empty.\n@@ -239,26 +503,26 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n             hir::ItemKind::Use(..) => {}\n             // The interface is empty.\n             hir::ItemKind::GlobalAsm(..) => {}\n-            hir::ItemKind::Existential(hir::ExistTy { impl_trait_fn: Some(_), .. }) => {\n-                if item_level.is_some() {\n-                    // Reach the (potentially private) type and the API being exposed.\n-                    self.reach(item.id).ty().predicates();\n-                }\n+            hir::ItemKind::Existential(..) => {\n+                // FIXME: This is some serious pessimization intended to workaround deficiencies\n+                // in the reachability pass (`middle/reachable.rs`). Types are marked as link-time\n+                // reachable if they are returned via `impl Trait`, even from private functions.\n+                let exist_level = cmp::max(item_level, Some(AccessLevel::ReachableFromImplTrait));\n+                self.reach(item.id, exist_level).generics().predicates().ty();\n             }\n             // Visit everything.\n             hir::ItemKind::Const(..) | hir::ItemKind::Static(..) |\n-            hir::ItemKind::Existential(..) |\n             hir::ItemKind::Fn(..) | hir::ItemKind::Ty(..) => {\n                 if item_level.is_some() {\n-                    self.reach(item.id).generics().predicates().ty();\n+                    self.reach(item.id, item_level).generics().predicates().ty();\n                 }\n             }\n             hir::ItemKind::Trait(.., ref trait_item_refs) => {\n                 if item_level.is_some() {\n-                    self.reach(item.id).generics().predicates();\n+                    self.reach(item.id, item_level).generics().predicates();\n \n                     for trait_item_ref in trait_item_refs {\n-                        let mut reach = self.reach(trait_item_ref.id.node_id);\n+                        let mut reach = self.reach(trait_item_ref.id.node_id, item_level);\n                         reach.generics().predicates();\n \n                         if trait_item_ref.kind == hir::AssociatedItemKind::Type &&\n@@ -272,18 +536,19 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n             }\n             hir::ItemKind::TraitAlias(..) => {\n                 if item_level.is_some() {\n-                    self.reach(item.id).generics().predicates();\n+                    self.reach(item.id, item_level).generics().predicates();\n                 }\n             }\n             // Visit everything except for private impl items.\n-            hir::ItemKind::Impl(.., ref trait_ref, _, ref impl_item_refs) => {\n+            hir::ItemKind::Impl(.., ref impl_item_refs) => {\n                 if item_level.is_some() {\n-                    self.reach(item.id).generics().predicates().impl_trait_ref();\n+                    self.reach(item.id, item_level).generics().predicates();\n \n                     for impl_item_ref in impl_item_refs {\n-                        let id = impl_item_ref.id.node_id;\n-                        if trait_ref.is_some() || self.get(id).is_some() {\n-                            self.reach(id).generics().predicates().ty();\n+                        let impl_item_level = self.get(impl_item_ref.id.node_id);\n+                        if impl_item_level.is_some() {\n+                            self.reach(impl_item_ref.id.node_id, impl_item_level)\n+                                .generics().predicates().ty();\n                         }\n                     }\n                 }\n@@ -292,54 +557,56 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n             // Visit everything, but enum variants have their own levels.\n             hir::ItemKind::Enum(ref def, _) => {\n                 if item_level.is_some() {\n-                    self.reach(item.id).generics().predicates();\n+                    self.reach(item.id, item_level).generics().predicates();\n                 }\n                 for variant in &def.variants {\n-                    if self.get(variant.node.data.id()).is_some() {\n+                    let variant_level = self.get(variant.node.data.id());\n+                    if variant_level.is_some() {\n                         for field in variant.node.data.fields() {\n-                            self.reach(field.id).ty();\n+                            self.reach(field.id, variant_level).ty();\n                         }\n                         // Corner case: if the variant is reachable, but its\n                         // enum is not, make the enum reachable as well.\n-                        self.update(item.id, Some(AccessLevel::Reachable));\n+                        self.update(item.id, variant_level);\n                     }\n                 }\n             }\n             // Visit everything, but foreign items have their own levels.\n             hir::ItemKind::ForeignMod(ref foreign_mod) => {\n                 for foreign_item in &foreign_mod.items {\n-                    if self.get(foreign_item.id).is_some() {\n-                        self.reach(foreign_item.id).generics().predicates().ty();\n+                    let foreign_item_level = self.get(foreign_item.id);\n+                    if foreign_item_level.is_some() {\n+                        self.reach(foreign_item.id, foreign_item_level)\n+                            .generics().predicates().ty();\n                     }\n                 }\n             }\n             // Visit everything except for private fields.\n             hir::ItemKind::Struct(ref struct_def, _) |\n             hir::ItemKind::Union(ref struct_def, _) => {\n                 if item_level.is_some() {\n-                    self.reach(item.id).generics().predicates();\n+                    self.reach(item.id, item_level).generics().predicates();\n                     for field in struct_def.fields() {\n-                        if self.get(field.id).is_some() {\n-                            self.reach(field.id).ty();\n+                        let field_level = self.get(field.id);\n+                        if field_level.is_some() {\n+                            self.reach(field.id, field_level).ty();\n                         }\n                     }\n                 }\n             }\n         }\n \n+        let orig_level = mem::replace(&mut self.prev_level, item_level);\n         intravisit::walk_item(self, item);\n-\n         self.prev_level = orig_level;\n     }\n \n     fn visit_block(&mut self, b: &'tcx hir::Block) {\n-        let orig_level = replace(&mut self.prev_level, None);\n-\n         // Blocks can have public items, for example impls, but they always\n         // start as completely private regardless of publicity of a function,\n         // constant, type, field, etc., in which this block resides.\n+        let orig_level = mem::replace(&mut self.prev_level, None);\n         intravisit::walk_block(self, b);\n-\n         self.prev_level = orig_level;\n     }\n \n@@ -410,13 +677,13 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'b, 'a, 'tcx> ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n+impl<'a, 'tcx> ReachEverythingInTheInterfaceVisitor<'_, 'a, 'tcx> {\n     fn generics(&mut self) -> &mut Self {\n         for param in &self.ev.tcx.generics_of(self.item_def_id).params {\n             match param.kind {\n                 GenericParamDefKind::Type { has_default, .. } => {\n                     if has_default {\n-                        self.ev.tcx.type_of(param.def_id).visit_with(self);\n+                        self.visit(self.ev.tcx.type_of(param.def_id));\n                     }\n                 }\n                 GenericParamDefKind::Lifetime => {}\n@@ -426,73 +693,23 @@ impl<'b, 'a, 'tcx> ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n     }\n \n     fn predicates(&mut self) -> &mut Self {\n-        let predicates = self.ev.tcx.predicates_of(self.item_def_id);\n-        for (predicate, _) in &predicates.predicates {\n-            predicate.visit_with(self);\n-            match predicate {\n-                &ty::Predicate::Trait(poly_predicate) => {\n-                    self.check_trait_ref(poly_predicate.skip_binder().trait_ref);\n-                },\n-                &ty::Predicate::Projection(poly_predicate) => {\n-                    let tcx = self.ev.tcx;\n-                    self.check_trait_ref(\n-                        poly_predicate.skip_binder().projection_ty.trait_ref(tcx)\n-                    );\n-                },\n-                _ => (),\n-            };\n-        }\n+        self.visit_predicates(self.ev.tcx.predicates_of(self.item_def_id));\n         self\n     }\n \n     fn ty(&mut self) -> &mut Self {\n-        let ty = self.ev.tcx.type_of(self.item_def_id);\n-        ty.visit_with(self);\n-        if let ty::FnDef(def_id, _) = ty.sty {\n-            if def_id == self.item_def_id {\n-                self.ev.tcx.fn_sig(def_id).visit_with(self);\n-            }\n-        }\n-        self\n-    }\n-\n-    fn impl_trait_ref(&mut self) -> &mut Self {\n-        if let Some(impl_trait_ref) = self.ev.tcx.impl_trait_ref(self.item_def_id) {\n-            self.check_trait_ref(impl_trait_ref);\n-            impl_trait_ref.super_visit_with(self);\n-        }\n+        self.visit(self.ev.tcx.type_of(self.item_def_id));\n         self\n     }\n-\n-    fn check_trait_ref(&mut self, trait_ref: ty::TraitRef<'tcx>) {\n-        if let Some(node_id) = self.ev.tcx.hir().as_local_node_id(trait_ref.def_id) {\n-            let item = self.ev.tcx.hir().expect_item(node_id);\n-            self.ev.update(item.id, self.access_level);\n-        }\n-    }\n }\n \n-impl<'b, 'a, 'tcx> TypeVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n-    fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n-        let ty_def_id = match ty.sty {\n-            ty::Adt(adt, _) => Some(adt.did),\n-            ty::Foreign(did) => Some(did),\n-            ty::Dynamic(ref obj, ..) => Some(obj.principal().def_id()),\n-            ty::Projection(ref proj) => Some(proj.item_def_id),\n-            ty::FnDef(def_id, ..) |\n-            ty::Closure(def_id, ..) |\n-            ty::Generator(def_id, ..) |\n-            ty::Opaque(def_id, _) => Some(def_id),\n-            _ => None\n-        };\n-\n-        if let Some(def_id) = ty_def_id {\n-            if let Some(node_id) = self.ev.tcx.hir().as_local_node_id(def_id) {\n-                self.ev.update(node_id, self.access_level);\n-            }\n+impl<'a, 'tcx> DefIdVisitor<'a, 'tcx> for ReachEverythingInTheInterfaceVisitor<'_, 'a, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> { self.ev.tcx }\n+    fn visit_def_id(&mut self, def_id: DefId, _kind: &str, _descr: &dyn fmt::Display) -> bool {\n+        if let Some(node_id) = self.ev.tcx.hir().as_local_node_id(def_id) {\n+            self.ev.update(node_id, self.access_level);\n         }\n-\n-        ty.super_visit_with(self)\n+        false\n     }\n }\n \n@@ -528,22 +745,6 @@ impl<'a, 'tcx> NamePrivacyVisitor<'a, 'tcx> {\n     }\n }\n \n-// Set the correct `TypeckTables` for the given `item_id` (or an empty table if\n-// there is no `TypeckTables` for the item).\n-fn update_tables<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                           item_id: ast::NodeId,\n-                           tables: &mut &'a ty::TypeckTables<'tcx>,\n-                           empty_tables: &'a ty::TypeckTables<'tcx>)\n-                           -> &'a ty::TypeckTables<'tcx> {\n-    let def_id = tcx.hir().local_def_id(item_id);\n-\n-    if tcx.has_typeck_tables(def_id) {\n-        replace(tables, tcx.typeck_tables_of(def_id))\n-    } else {\n-        replace(tables, empty_tables)\n-    }\n-}\n-\n impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n     /// We want to visit items in the context of their containing\n     /// module and so forth, so supply a crate for doing a deep walk.\n@@ -552,28 +753,31 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n     }\n \n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n-        let orig_tables = replace(&mut self.tables, self.tcx.body_tables(body));\n+        let orig_tables = mem::replace(&mut self.tables, self.tcx.body_tables(body));\n         let body = self.tcx.hir().body(body);\n         self.visit_body(body);\n         self.tables = orig_tables;\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        let orig_current_item = replace(&mut self.current_item, item.id);\n-        let orig_tables = update_tables(self.tcx, item.id, &mut self.tables, self.empty_tables);\n+        let orig_current_item = mem::replace(&mut self.current_item, item.id);\n+        let orig_tables =\n+            mem::replace(&mut self.tables, item_tables(self.tcx, item.id, self.empty_tables));\n         intravisit::walk_item(self, item);\n         self.current_item = orig_current_item;\n         self.tables = orig_tables;\n     }\n \n     fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem) {\n-        let orig_tables = update_tables(self.tcx, ti.id, &mut self.tables, self.empty_tables);\n+        let orig_tables =\n+            mem::replace(&mut self.tables, item_tables(self.tcx, ti.id, self.empty_tables));\n         intravisit::walk_trait_item(self, ti);\n         self.tables = orig_tables;\n     }\n \n     fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem) {\n-        let orig_tables = update_tables(self.tcx, ii.id, &mut self.tables, self.empty_tables);\n+        let orig_tables =\n+            mem::replace(&mut self.tables, item_tables(self.tcx, ii.id, self.empty_tables));\n         intravisit::walk_impl_item(self, ii);\n         self.tables = orig_tables;\n     }\n@@ -644,88 +848,35 @@ struct TypePrivacyVisitor<'a, 'tcx: 'a> {\n     in_body: bool,\n     span: Span,\n     empty_tables: &'a ty::TypeckTables<'tcx>,\n-    visited_opaque_tys: FxHashSet<DefId>\n }\n \n impl<'a, 'tcx> TypePrivacyVisitor<'a, 'tcx> {\n-    fn def_id_visibility(&self, did: DefId) -> ty::Visibility {\n-        match self.tcx.hir().as_local_node_id(did) {\n-            Some(node_id) => {\n-                let vis = match self.tcx.hir().get(node_id) {\n-                    Node::Item(item) => &item.vis,\n-                    Node::ForeignItem(foreign_item) => &foreign_item.vis,\n-                    Node::ImplItem(impl_item) => &impl_item.vis,\n-                    Node::TraitItem(..) |\n-                    Node::Variant(..) => {\n-                        return self.def_id_visibility(self.tcx.hir().get_parent_did(node_id));\n-                    }\n-                    Node::StructCtor(vdata) => {\n-                        let struct_node_id = self.tcx.hir().get_parent(node_id);\n-                        let struct_vis = match self.tcx.hir().get(struct_node_id) {\n-                            Node::Item(item) => &item.vis,\n-                            node => bug!(\"unexpected node kind: {:?}\", node),\n-                        };\n-                        let mut ctor_vis\n-                            = ty::Visibility::from_hir(struct_vis, struct_node_id, self.tcx);\n-                        for field in vdata.fields() {\n-                            let field_vis = ty::Visibility::from_hir(&field.vis, node_id, self.tcx);\n-                            if ctor_vis.is_at_least(field_vis, self.tcx) {\n-                                ctor_vis = field_vis;\n-                            }\n-                        }\n-\n-                        // If the structure is marked as non_exhaustive then lower the\n-                        // visibility to within the crate.\n-                        let struct_def_id = self.tcx.hir().get_parent_did(node_id);\n-                        let adt_def = self.tcx.adt_def(struct_def_id);\n-                        if adt_def.non_enum_variant().is_field_list_non_exhaustive()\n-                            && ctor_vis == ty::Visibility::Public\n-                        {\n-                            ctor_vis = ty::Visibility::Restricted(\n-                                DefId::local(CRATE_DEF_INDEX));\n-                        }\n-\n-                        return ctor_vis;\n-                    }\n-                    node => bug!(\"unexpected node kind: {:?}\", node)\n-                };\n-                ty::Visibility::from_hir(vis, node_id, self.tcx)\n-            }\n-            None => self.tcx.visibility(did),\n-        }\n-    }\n-\n     fn item_is_accessible(&self, did: DefId) -> bool {\n-        self.def_id_visibility(did).is_accessible_from(self.current_item, self.tcx)\n+        def_id_visibility(self.tcx, did).0.is_accessible_from(self.current_item, self.tcx)\n     }\n \n     // Take node-id of an expression or pattern and check its type for privacy.\n     fn check_expr_pat_type(&mut self, id: hir::HirId, span: Span) -> bool {\n         self.span = span;\n-        if self.tables.node_id_to_type(id).visit_with(self) {\n-            return true;\n-        }\n-        if self.tables.node_substs(id).visit_with(self) {\n+        if self.visit(self.tables.node_id_to_type(id)) || self.visit(self.tables.node_substs(id)) {\n             return true;\n         }\n         if let Some(adjustments) = self.tables.adjustments().get(id) {\n             for adjustment in adjustments {\n-                if adjustment.target.visit_with(self) {\n+                if self.visit(adjustment.target) {\n                     return true;\n                 }\n             }\n         }\n         false\n     }\n \n-    fn check_trait_ref(&mut self, trait_ref: ty::TraitRef<'tcx>) -> bool {\n-        if !self.item_is_accessible(trait_ref.def_id) {\n-            let msg = format!(\"trait `{}` is private\", trait_ref);\n-            self.tcx.sess.span_err(self.span, &msg);\n-            return true;\n+    fn check_def_id(&mut self, def_id: DefId, kind: &str, descr: &dyn fmt::Display) -> bool {\n+        let is_error = !self.item_is_accessible(def_id);\n+        if is_error {\n+            self.tcx.sess.span_err(self.span, &format!(\"{} `{}` is private\", kind, descr));\n         }\n-\n-        trait_ref.super_visit_with(self)\n+        is_error\n     }\n }\n \n@@ -737,8 +888,8 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n     }\n \n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n-        let orig_tables = replace(&mut self.tables, self.tcx.body_tables(body));\n-        let orig_in_body = replace(&mut self.in_body, true);\n+        let orig_tables = mem::replace(&mut self.tables, self.tcx.body_tables(body));\n+        let orig_in_body = mem::replace(&mut self.in_body, true);\n         let body = self.tcx.hir().body(body);\n         self.visit_body(body);\n         self.tables = orig_tables;\n@@ -749,14 +900,14 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n         self.span = hir_ty.span;\n         if self.in_body {\n             // Types in bodies.\n-            if self.tables.node_id_to_type(hir_ty.hir_id).visit_with(self) {\n+            if self.visit(self.tables.node_id_to_type(hir_ty.hir_id)) {\n                 return;\n             }\n         } else {\n             // Types in signatures.\n             // FIXME: This is very ineffective. Ideally each HIR type should be converted\n             // into a semantic type only once and the result should be cached somehow.\n-            if rustc_typeck::hir_ty_to_ty(self.tcx, hir_ty).visit_with(self) {\n+            if self.visit(rustc_typeck::hir_ty_to_ty(self.tcx, hir_ty)) {\n                 return;\n             }\n         }\n@@ -771,12 +922,13 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n             // The traits' privacy in bodies is already checked as a part of trait object types.\n             let (principal, projections) =\n                 rustc_typeck::hir_trait_to_predicates(self.tcx, trait_ref);\n-            if self.check_trait_ref(*principal.skip_binder()) {\n+            if self.visit_trait(*principal.skip_binder()) {\n                 return;\n             }\n             for (poly_predicate, _) in projections {\n                 let tcx = self.tcx;\n-                if self.check_trait_ref(poly_predicate.skip_binder().projection_ty.trait_ref(tcx)) {\n+                if self.visit(poly_predicate.skip_binder().ty) ||\n+                   self.visit_trait(poly_predicate.skip_binder().projection_ty.trait_ref(tcx)) {\n                     return;\n                 }\n             }\n@@ -802,8 +954,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n                 // Method calls have to be checked specially.\n                 self.span = span;\n                 if let Some(def) = self.tables.type_dependent_defs().get(expr.hir_id) {\n-                    let def_id = def.def_id();\n-                    if self.tcx.type_of(def_id).visit_with(self) {\n+                    if self.visit(self.tcx.type_of(def.def_id())) {\n                         return;\n                     }\n                 } else {\n@@ -827,7 +978,8 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n         let def = match *qpath {\n             hir::QPath::Resolved(_, ref path) => match path.def {\n                 Def::Method(..) | Def::AssociatedConst(..) |\n-                Def::AssociatedTy(..) | Def::Static(..) => Some(path.def),\n+                Def::AssociatedTy(..) | Def::AssociatedExistential(..) |\n+                Def::Static(..) => Some(path.def),\n                 _ => None,\n             }\n             hir::QPath::TypeRelative(..) => {\n@@ -874,122 +1026,36 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n \n     // Check types in item interfaces.\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        let orig_current_item = self.current_item;\n-        let orig_tables = update_tables(self.tcx,\n-                                        item.id,\n-                                        &mut self.tables,\n-                                        self.empty_tables);\n-        let orig_in_body = replace(&mut self.in_body, false);\n-        self.current_item = self.tcx.hir().local_def_id(item.id);\n+        let orig_current_item =\n+            mem::replace(&mut self.current_item, self.tcx.hir().local_def_id(item.id));\n+        let orig_in_body = mem::replace(&mut self.in_body, false);\n+        let orig_tables =\n+            mem::replace(&mut self.tables, item_tables(self.tcx, item.id, self.empty_tables));\n         intravisit::walk_item(self, item);\n         self.tables = orig_tables;\n         self.in_body = orig_in_body;\n         self.current_item = orig_current_item;\n     }\n \n     fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem) {\n-        let orig_tables = update_tables(self.tcx, ti.id, &mut self.tables, self.empty_tables);\n+        let orig_tables =\n+            mem::replace(&mut self.tables, item_tables(self.tcx, ti.id, self.empty_tables));\n         intravisit::walk_trait_item(self, ti);\n         self.tables = orig_tables;\n     }\n \n     fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem) {\n-        let orig_tables = update_tables(self.tcx, ii.id, &mut self.tables, self.empty_tables);\n+        let orig_tables =\n+            mem::replace(&mut self.tables, item_tables(self.tcx, ii.id, self.empty_tables));\n         intravisit::walk_impl_item(self, ii);\n         self.tables = orig_tables;\n     }\n }\n \n-impl<'a, 'tcx> TypeVisitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n-    fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n-        match ty.sty {\n-            ty::Adt(&ty::AdtDef { did: def_id, .. }, ..) |\n-            ty::FnDef(def_id, ..) |\n-            ty::Foreign(def_id) => {\n-                if !self.item_is_accessible(def_id) {\n-                    let msg = format!(\"type `{}` is private\", ty);\n-                    self.tcx.sess.span_err(self.span, &msg);\n-                    return true;\n-                }\n-                if let ty::FnDef(..) = ty.sty {\n-                    if self.tcx.fn_sig(def_id).visit_with(self) {\n-                        return true;\n-                    }\n-                }\n-                // Inherent static methods don't have self type in substs,\n-                // we have to check it additionally.\n-                if let Some(assoc_item) = self.tcx.opt_associated_item(def_id) {\n-                    if let ty::ImplContainer(impl_def_id) = assoc_item.container {\n-                        if self.tcx.type_of(impl_def_id).visit_with(self) {\n-                            return true;\n-                        }\n-                    }\n-                }\n-            }\n-            ty::Dynamic(ref predicates, ..) => {\n-                let is_private = predicates.skip_binder().iter().any(|predicate| {\n-                    let def_id = match *predicate {\n-                        ty::ExistentialPredicate::Trait(trait_ref) => trait_ref.def_id,\n-                        ty::ExistentialPredicate::Projection(proj) =>\n-                            proj.trait_ref(self.tcx).def_id,\n-                        ty::ExistentialPredicate::AutoTrait(def_id) => def_id,\n-                    };\n-                    !self.item_is_accessible(def_id)\n-                });\n-                if is_private {\n-                    let msg = format!(\"type `{}` is private\", ty);\n-                    self.tcx.sess.span_err(self.span, &msg);\n-                    return true;\n-                }\n-            }\n-            ty::Projection(ref proj) => {\n-                let tcx = self.tcx;\n-                if self.check_trait_ref(proj.trait_ref(tcx)) {\n-                    return true;\n-                }\n-            }\n-            ty::Opaque(def_id, ..) => {\n-                for (predicate, _) in &self.tcx.predicates_of(def_id).predicates {\n-                    let trait_ref = match *predicate {\n-                        ty::Predicate::Trait(ref poly_trait_predicate) => {\n-                            Some(poly_trait_predicate.skip_binder().trait_ref)\n-                        }\n-                        ty::Predicate::Projection(ref poly_projection_predicate) => {\n-                            if poly_projection_predicate.skip_binder().ty.visit_with(self) {\n-                                return true;\n-                            }\n-                            Some(poly_projection_predicate.skip_binder()\n-                                                          .projection_ty.trait_ref(self.tcx))\n-                        }\n-                        ty::Predicate::TypeOutlives(..) | ty::Predicate::RegionOutlives(..) => None,\n-                        _ => bug!(\"unexpected predicate: {:?}\", predicate),\n-                    };\n-                    if let Some(trait_ref) = trait_ref {\n-                        if !self.item_is_accessible(trait_ref.def_id) {\n-                            let msg = format!(\"trait `{}` is private\", trait_ref);\n-                            self.tcx.sess.span_err(self.span, &msg);\n-                            return true;\n-                        }\n-                        for subst in trait_ref.substs.iter() {\n-                            // Skip repeated `Opaque`s to avoid infinite recursion.\n-                            if let UnpackedKind::Type(ty) = subst.unpack() {\n-                                if let ty::Opaque(def_id, ..) = ty.sty {\n-                                    if !self.visited_opaque_tys.insert(def_id) {\n-                                        continue;\n-                                    }\n-                                }\n-                            }\n-                            if subst.visit_with(self) {\n-                                return true;\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-            _ => {}\n-        }\n-\n-        ty.super_visit_with(self)\n+impl<'a, 'tcx> DefIdVisitor<'a, 'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> { self.tcx }\n+    fn visit_def_id(&mut self, def_id: DefId, kind: &str, descr: &dyn fmt::Display) -> bool {\n+        self.check_def_id(def_id, kind, descr)\n     }\n }\n \n@@ -1283,13 +1349,13 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n         }\n         for predicate in &generics.where_clause.predicates {\n             match predicate {\n-                &hir::WherePredicate::BoundPredicate(ref bound_pred) => {\n+                hir::WherePredicate::BoundPredicate(bound_pred) => {\n                     for bound in bound_pred.bounds.iter() {\n                         self.check_generic_bound(bound)\n                     }\n                 }\n-                &hir::WherePredicate::RegionPredicate(_) => {}\n-                &hir::WherePredicate::EqPredicate(ref eq_pred) => {\n+                hir::WherePredicate::RegionPredicate(_) => {}\n+                hir::WherePredicate::EqPredicate(eq_pred) => {\n                     self.visit_ty(&eq_pred.rhs_ty);\n                 }\n             }\n@@ -1349,8 +1415,6 @@ struct SearchInterfaceForPrivateItemsVisitor<'a, 'tcx: 'a> {\n     span: Span,\n     /// The visitor checks that each component type is at least this visible.\n     required_visibility: ty::Visibility,\n-    /// The visibility of the least visible component that has been visited.\n-    min_visibility: ty::Visibility,\n     has_pub_restricted: bool,\n     has_old_errors: bool,\n     in_assoc_ty: bool,\n@@ -1362,7 +1426,7 @@ impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n             match param.kind {\n                 GenericParamDefKind::Type { has_default, .. } => {\n                     if has_default {\n-                        self.tcx.type_of(param.def_id).visit_with(self);\n+                        self.visit(self.tcx.type_of(param.def_id));\n                     }\n                 }\n                 GenericParamDefKind::Lifetime => {}\n@@ -1378,140 +1442,54 @@ impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n         // consider the ones that the user wrote. This is important\n         // for the inferred outlives rules; see\n         // `src/test/ui/rfc-2093-infer-outlives/privacy.rs`.\n-        let predicates = self.tcx.explicit_predicates_of(self.item_def_id);\n-        for (predicate, _) in &predicates.predicates {\n-            predicate.visit_with(self);\n-            match predicate {\n-                &ty::Predicate::Trait(poly_predicate) => {\n-                    self.check_trait_ref(poly_predicate.skip_binder().trait_ref);\n-                },\n-                &ty::Predicate::Projection(poly_predicate) => {\n-                    let tcx = self.tcx;\n-                    self.check_trait_ref(\n-                        poly_predicate.skip_binder().projection_ty.trait_ref(tcx)\n-                    );\n-                },\n-                _ => (),\n-            };\n-        }\n+        self.visit_predicates(self.tcx.explicit_predicates_of(self.item_def_id));\n         self\n     }\n \n     fn ty(&mut self) -> &mut Self {\n-        let ty = self.tcx.type_of(self.item_def_id);\n-        ty.visit_with(self);\n-        if let ty::FnDef(def_id, _) = ty.sty {\n-            if def_id == self.item_def_id {\n-                self.tcx.fn_sig(def_id).visit_with(self);\n-            }\n-        }\n+        self.visit(self.tcx.type_of(self.item_def_id));\n         self\n     }\n \n-    fn impl_trait_ref(&mut self) -> &mut Self {\n-        if let Some(impl_trait_ref) = self.tcx.impl_trait_ref(self.item_def_id) {\n-            self.check_trait_ref(impl_trait_ref);\n-            impl_trait_ref.super_visit_with(self);\n-        }\n-        self\n-    }\n+    fn check_def_id(&mut self, def_id: DefId, kind: &str, descr: &dyn fmt::Display) -> bool {\n+        let node_id = match self.tcx.hir().as_local_node_id(def_id) {\n+            Some(node_id) => node_id,\n+            None => return false,\n+        };\n \n-    fn check_trait_ref(&mut self, trait_ref: ty::TraitRef<'tcx>) {\n-        // Non-local means public (private items can't leave their crate, modulo bugs).\n-        if let Some(node_id) = self.tcx.hir().as_local_node_id(trait_ref.def_id) {\n-            let item = self.tcx.hir().expect_item(node_id);\n-            let vis = ty::Visibility::from_hir(&item.vis, node_id, self.tcx);\n-            if !vis.is_at_least(self.min_visibility, self.tcx) {\n-                self.min_visibility = vis;\n-            }\n-            if !vis.is_at_least(self.required_visibility, self.tcx) {\n-                if self.has_pub_restricted || self.has_old_errors || self.in_assoc_ty {\n-                    struct_span_err!(self.tcx.sess, self.span, E0445,\n-                                     \"private trait `{}` in public interface\", trait_ref)\n-                        .span_label(self.span, format!(\n-                                    \"can't leak private trait\"))\n-                        .emit();\n+        let (vis, vis_span, vis_descr) = def_id_visibility(self.tcx, def_id);\n+        if !vis.is_at_least(self.required_visibility, self.tcx) {\n+            let msg = format!(\"{} {} `{}` in public interface\", vis_descr, kind, descr);\n+            if self.has_pub_restricted || self.has_old_errors || self.in_assoc_ty {\n+                let mut err = if kind == \"trait\" {\n+                    struct_span_err!(self.tcx.sess, self.span, E0445, \"{}\", msg)\n                 } else {\n-                    self.tcx.lint_node(lint::builtin::PRIVATE_IN_PUBLIC,\n-                                       node_id,\n-                                       self.span,\n-                                       &format!(\"private trait `{}` in public \\\n-                                                 interface (error E0445)\", trait_ref));\n-                }\n+                    struct_span_err!(self.tcx.sess, self.span, E0446, \"{}\", msg)\n+                };\n+                err.span_label(self.span, format!(\"can't leak {} {}\", vis_descr, kind));\n+                err.span_label(vis_span, format!(\"`{}` declared as {}\", descr, vis_descr));\n+                err.emit();\n+            } else {\n+                let err_code = if kind == \"trait\" { \"E0445\" } else { \"E0446\" };\n+                self.tcx.lint_node(lint::builtin::PRIVATE_IN_PUBLIC, node_id, self.span,\n+                                   &format!(\"{} (error {})\", msg, err_code));\n             }\n         }\n+        false\n     }\n }\n \n-impl<'a, 'tcx: 'a> TypeVisitor<'tcx> for SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n-    fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n-        let ty_def_id = match ty.sty {\n-            ty::Adt(adt, _) => Some(adt.did),\n-            ty::Foreign(did) => Some(did),\n-            ty::Dynamic(ref obj, ..) => Some(obj.principal().def_id()),\n-            ty::Projection(ref proj) => {\n-                if self.required_visibility == ty::Visibility::Invisible {\n-                    // Conservatively approximate the whole type alias as public without\n-                    // recursing into its components when determining impl publicity.\n-                    // For example, `impl <Type as Trait>::Alias {...}` may be a public impl\n-                    // even if both `Type` and `Trait` are private.\n-                    // Ideally, associated types should be substituted in the same way as\n-                    // free type aliases, but this isn't done yet.\n-                    return false;\n-                }\n-                let trait_ref = proj.trait_ref(self.tcx);\n-                Some(trait_ref.def_id)\n-            }\n-            _ => None\n-        };\n-\n-        if let Some(def_id) = ty_def_id {\n-            // Non-local means public (private items can't leave their crate, modulo bugs).\n-            if let Some(node_id) = self.tcx.hir().as_local_node_id(def_id) {\n-                let hir_vis = match self.tcx.hir().find(node_id) {\n-                    Some(Node::Item(item)) => &item.vis,\n-                    Some(Node::ForeignItem(item)) => &item.vis,\n-                    _ => bug!(\"expected item of foreign item\"),\n-                };\n-\n-                let vis = ty::Visibility::from_hir(hir_vis, node_id, self.tcx);\n-\n-                if !vis.is_at_least(self.min_visibility, self.tcx) {\n-                    self.min_visibility = vis;\n-                }\n-                if !vis.is_at_least(self.required_visibility, self.tcx) {\n-                    let vis_adj = match hir_vis.node {\n-                        hir::VisibilityKind::Crate(_) => \"crate-visible\",\n-                        hir::VisibilityKind::Restricted { .. } => \"restricted\",\n-                        _ => \"private\"\n-                    };\n-\n-                    if self.has_pub_restricted || self.has_old_errors || self.in_assoc_ty {\n-                        let mut err = struct_span_err!(self.tcx.sess, self.span, E0446,\n-                            \"{} type `{}` in public interface\", vis_adj, ty);\n-                        err.span_label(self.span, format!(\"can't leak {} type\", vis_adj));\n-                        err.span_label(hir_vis.span, format!(\"`{}` declared as {}\", ty, vis_adj));\n-                        err.emit();\n-                    } else {\n-                        self.tcx.lint_node(lint::builtin::PRIVATE_IN_PUBLIC,\n-                                           node_id,\n-                                           self.span,\n-                                           &format!(\"{} type `{}` in public \\\n-                                                     interface (error E0446)\", vis_adj, ty));\n-                    }\n-                }\n-            }\n-        }\n-\n-        ty.super_visit_with(self)\n+impl<'a, 'tcx> DefIdVisitor<'a, 'tcx> for SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> { self.tcx }\n+    fn visit_def_id(&mut self, def_id: DefId, kind: &str, descr: &dyn fmt::Display) -> bool {\n+        self.check_def_id(def_id, kind, descr)\n     }\n }\n \n struct PrivateItemsInPublicInterfacesVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     has_pub_restricted: bool,\n     old_error_set: &'a NodeSet,\n-    inner_visibility: ty::Visibility,\n }\n \n impl<'a, 'tcx> PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n@@ -1544,7 +1522,6 @@ impl<'a, 'tcx> PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n             tcx: self.tcx,\n             item_def_id: self.tcx.hir().local_def_id(item_id),\n             span: self.tcx.hir().span(item_id),\n-            min_visibility: ty::Visibility::Public,\n             required_visibility,\n             has_pub_restricted: self.has_pub_restricted,\n             has_old_errors,\n@@ -1560,10 +1537,6 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         let tcx = self.tcx;\n-        let min = |vis1: ty::Visibility, vis2| {\n-            if vis1.is_at_least(vis2, tcx) { vis2 } else { vis1 }\n-        };\n-\n         let item_visibility = ty::Visibility::from_hir(&item.vis, item.id, tcx);\n \n         match item.node {\n@@ -1575,23 +1548,10 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n             hir::ItemKind::Use(..) => {}\n             // No subitems.\n             hir::ItemKind::GlobalAsm(..) => {}\n-            hir::ItemKind::Existential(hir::ExistTy { impl_trait_fn: Some(_), .. }) => {\n-                // Check the traits being exposed, as they're separate,\n-                // e.g., `impl Iterator<Item=T>` has two predicates,\n-                // `X: Iterator` and `<X as Iterator>::Item == T`,\n-                // where `X` is the `impl Iterator<Item=T>` itself,\n-                // stored in `predicates_of`, not in the `Ty` itself.\n-                self.check(item.id, item_visibility).predicates();\n-            }\n             // Subitems of these items have inherited publicity.\n             hir::ItemKind::Const(..) | hir::ItemKind::Static(..) | hir::ItemKind::Fn(..) |\n-            hir::ItemKind::Existential(..) |\n-            hir::ItemKind::Ty(..) => {\n+            hir::ItemKind::Existential(..) | hir::ItemKind::Ty(..) => {\n                 self.check(item.id, item_visibility).generics().predicates().ty();\n-\n-                // Recurse for e.g., `impl Trait` (see `visit_ty`).\n-                self.inner_visibility = item_visibility;\n-                intravisit::walk_item(self, item);\n             }\n             hir::ItemKind::Trait(.., ref trait_item_refs) => {\n                 self.check(item.id, item_visibility).generics().predicates();\n@@ -1635,56 +1595,30 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n \n                 for field in struct_def.fields() {\n                     let field_visibility = ty::Visibility::from_hir(&field.vis, item.id, tcx);\n-                    self.check(field.id, min(item_visibility, field_visibility)).ty();\n+                    self.check(field.id, min(item_visibility, field_visibility, tcx)).ty();\n                 }\n             }\n             // An inherent impl is public when its type is public\n             // Subitems of inherent impls have their own publicity.\n-            hir::ItemKind::Impl(.., None, _, ref impl_item_refs) => {\n-                let ty_vis =\n-                    self.check(item.id, ty::Visibility::Invisible).ty().min_visibility;\n-                self.check(item.id, ty_vis).generics().predicates();\n-\n-                for impl_item_ref in impl_item_refs {\n-                    let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n-                    let impl_item_vis = ty::Visibility::from_hir(&impl_item.vis, item.id, tcx);\n-                    let mut check = self.check(impl_item.id, min(impl_item_vis, ty_vis));\n-                    check.in_assoc_ty = impl_item_ref.kind == hir::AssociatedItemKind::Type;\n-                    check.generics().predicates().ty();\n-\n-                    // Recurse for e.g., `impl Trait` (see `visit_ty`).\n-                    self.inner_visibility = impl_item_vis;\n-                    intravisit::walk_impl_item(self, impl_item);\n-                }\n-            }\n             // A trait impl is public when both its type and its trait are public\n             // Subitems of trait impls have inherited publicity.\n-            hir::ItemKind::Impl(.., Some(_), _, ref impl_item_refs) => {\n-                let vis = self.check(item.id, ty::Visibility::Invisible)\n-                              .ty().impl_trait_ref().min_visibility;\n-                self.check(item.id, vis).generics().predicates();\n+            hir::ItemKind::Impl(.., ref trait_ref, _, ref impl_item_refs) => {\n+                let impl_vis = ty::Visibility::of_impl(item.id, tcx, &Default::default());\n+                self.check(item.id, impl_vis).generics().predicates();\n                 for impl_item_ref in impl_item_refs {\n-                    let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n-                    let mut check = self.check(impl_item.id, vis);\n+                    let impl_item = tcx.hir().impl_item(impl_item_ref.id);\n+                    let impl_item_vis = if trait_ref.is_none() {\n+                        min(ty::Visibility::from_hir(&impl_item.vis, item.id, tcx), impl_vis, tcx)\n+                    } else {\n+                        impl_vis\n+                    };\n+                    let mut check = self.check(impl_item.id, impl_item_vis);\n                     check.in_assoc_ty = impl_item_ref.kind == hir::AssociatedItemKind::Type;\n                     check.generics().predicates().ty();\n-\n-                    // Recurse for e.g., `impl Trait` (see `visit_ty`).\n-                    self.inner_visibility = vis;\n-                    intravisit::walk_impl_item(self, impl_item);\n                 }\n             }\n         }\n     }\n-\n-    fn visit_impl_item(&mut self, _impl_item: &'tcx hir::ImplItem) {\n-        // Handled in `visit_item` above.\n-    }\n-\n-    // Don't recurse into expressions in array sizes or const initializers.\n-    fn visit_expr(&mut self, _: &'tcx hir::Expr) {}\n-    // Don't recurse into patterns in function arguments.\n-    fn visit_pat(&mut self, _: &'tcx hir::Pat) {}\n }\n \n pub fn provide(providers: &mut Providers) {\n@@ -1724,7 +1658,6 @@ fn privacy_access_levels<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         in_body: false,\n         span: krate.span,\n         empty_tables: &empty_tables,\n-        visited_opaque_tys: FxHashSet::default()\n     };\n     intravisit::walk_crate(&mut visitor, krate);\n \n@@ -1770,7 +1703,6 @@ fn privacy_access_levels<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             tcx,\n             has_pub_restricted,\n             old_error_set: &visitor.old_error_set,\n-            inner_visibility: ty::Visibility::Public,\n         };\n         krate.visit_all_item_likes(&mut DeepVisitor::new(&mut visitor));\n     }"}, {"sha": "a452bbf0c9d5409f53da9c508f9b7d536c4aa9ff", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -42,6 +42,7 @@ impl<'a> ToNameBinding<'a> for (Module<'a>, ty::Visibility, Span, Mark) {\n     fn to_name_binding(self, arenas: &'a ResolverArenas<'a>) -> &'a NameBinding<'a> {\n         arenas.alloc_name_binding(NameBinding {\n             kind: NameBindingKind::Module(self.0),\n+            ambiguity: None,\n             vis: self.1,\n             span: self.2,\n             expansion: self.3,\n@@ -53,6 +54,7 @@ impl<'a> ToNameBinding<'a> for (Def, ty::Visibility, Span, Mark) {\n     fn to_name_binding(self, arenas: &'a ResolverArenas<'a>) -> &'a NameBinding<'a> {\n         arenas.alloc_name_binding(NameBinding {\n             kind: NameBindingKind::Def(self.0, false),\n+            ambiguity: None,\n             vis: self.1,\n             span: self.2,\n             expansion: self.3,\n@@ -66,6 +68,7 @@ impl<'a> ToNameBinding<'a> for (Def, ty::Visibility, Span, Mark, IsMacroExport)\n     fn to_name_binding(self, arenas: &'a ResolverArenas<'a>) -> &'a NameBinding<'a> {\n         arenas.alloc_name_binding(NameBinding {\n             kind: NameBindingKind::Def(self.0, true),\n+            ambiguity: None,\n             vis: self.1,\n             span: self.2,\n             expansion: self.3,"}, {"sha": "cf949b62a634e3fb684e56052ef1f9b6c1644425", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 27, "deletions": 36, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -1191,6 +1191,7 @@ impl<'a> fmt::Debug for ModuleData<'a> {\n #[derive(Clone, Debug)]\n pub struct NameBinding<'a> {\n     kind: NameBindingKind<'a>,\n+    ambiguity: Option<(&'a NameBinding<'a>, AmbiguityKind)>,\n     expansion: Mark,\n     span: Span,\n     vis: ty::Visibility,\n@@ -1215,11 +1216,6 @@ enum NameBindingKind<'a> {\n         directive: &'a ImportDirective<'a>,\n         used: Cell<bool>,\n     },\n-    Ambiguity {\n-        kind: AmbiguityKind,\n-        b1: &'a NameBinding<'a>,\n-        b2: &'a NameBinding<'a>,\n-    }\n }\n \n struct PrivacyError<'a>(Span, Ident, &'a NameBinding<'a>);\n@@ -1309,15 +1305,13 @@ impl<'a> NameBinding<'a> {\n             NameBindingKind::Def(def, _) => def,\n             NameBindingKind::Module(module) => module.def().unwrap(),\n             NameBindingKind::Import { binding, .. } => binding.def(),\n-            NameBindingKind::Ambiguity { .. } => Def::Err,\n         }\n     }\n \n-    fn def_ignoring_ambiguity(&self) -> Def {\n-        match self.kind {\n-            NameBindingKind::Import { binding, .. } => binding.def_ignoring_ambiguity(),\n-            NameBindingKind::Ambiguity { b1, .. } => b1.def_ignoring_ambiguity(),\n-            _ => self.def(),\n+    fn is_ambiguity(&self) -> bool {\n+        self.ambiguity.is_some() || match self.kind {\n+            NameBindingKind::Import { binding, .. } => binding.is_ambiguity(),\n+            _ => false,\n         }\n     }\n \n@@ -1362,7 +1356,6 @@ impl<'a> NameBinding<'a> {\n     fn is_glob_import(&self) -> bool {\n         match self.kind {\n             NameBindingKind::Import { directive, .. } => directive.is_glob(),\n-            NameBindingKind::Ambiguity { b1, .. } => b1.is_glob_import(),\n             _ => false,\n         }\n     }\n@@ -1382,7 +1375,7 @@ impl<'a> NameBinding<'a> {\n     }\n \n     fn macro_kind(&self) -> Option<MacroKind> {\n-        match self.def_ignoring_ambiguity() {\n+        match self.def() {\n             Def::Macro(_, kind) => Some(kind),\n             Def::NonMacroAttr(..) => Some(MacroKind::Attr),\n             _ => None,\n@@ -1893,6 +1886,7 @@ impl<'a> Resolver<'a> {\n             arenas,\n             dummy_binding: arenas.alloc_name_binding(NameBinding {\n                 kind: NameBindingKind::Def(Def::Err, false),\n+                ambiguity: None,\n                 expansion: Mark::root(),\n                 span: DUMMY_SP,\n                 vis: ty::Visibility::Public,\n@@ -1963,33 +1957,30 @@ impl<'a> Resolver<'a> {\n \n     fn record_use(&mut self, ident: Ident, ns: Namespace,\n                   used_binding: &'a NameBinding<'a>, is_lexical_scope: bool) {\n-        match used_binding.kind {\n-            NameBindingKind::Import { directive, binding, ref used } if !used.get() => {\n-                // Avoid marking `extern crate` items that refer to a name from extern prelude,\n-                // but not introduce it, as used if they are accessed from lexical scope.\n-                if is_lexical_scope {\n-                    if let Some(entry) = self.extern_prelude.get(&ident.modern()) {\n-                        if let Some(crate_item) = entry.extern_crate_item {\n-                            if ptr::eq(used_binding, crate_item) && !entry.introduced_by_item {\n-                                return;\n-                            }\n+        if let Some((b2, kind)) = used_binding.ambiguity {\n+            self.ambiguity_errors.push(AmbiguityError {\n+                kind, ident, b1: used_binding, b2,\n+                misc1: AmbiguityErrorMisc::None,\n+                misc2: AmbiguityErrorMisc::None,\n+            });\n+        }\n+        if let NameBindingKind::Import { directive, binding, ref used } = used_binding.kind {\n+            // Avoid marking `extern crate` items that refer to a name from extern prelude,\n+            // but not introduce it, as used if they are accessed from lexical scope.\n+            if is_lexical_scope {\n+                if let Some(entry) = self.extern_prelude.get(&ident.modern()) {\n+                    if let Some(crate_item) = entry.extern_crate_item {\n+                        if ptr::eq(used_binding, crate_item) && !entry.introduced_by_item {\n+                            return;\n                         }\n                     }\n                 }\n-                used.set(true);\n-                directive.used.set(true);\n-                self.used_imports.insert((directive.id, ns));\n-                self.add_to_glob_map(directive.id, ident);\n-                self.record_use(ident, ns, binding, false);\n-            }\n-            NameBindingKind::Ambiguity { kind, b1, b2 } => {\n-                self.ambiguity_errors.push(AmbiguityError {\n-                    kind, ident, b1, b2,\n-                    misc1: AmbiguityErrorMisc::None,\n-                    misc2: AmbiguityErrorMisc::None,\n-                });\n             }\n-            _ => {}\n+            used.set(true);\n+            directive.used.set(true);\n+            self.used_imports.insert((directive.id, ns));\n+            self.add_to_glob_map(directive.id, ident);\n+            self.record_use(ident, ns, binding, false);\n         }\n     }\n "}, {"sha": "e5e6c7a994b7a02ad6dddaae4b2af30ab9ede69a", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -175,6 +175,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n         self.macro_map.insert(def_id, ext);\n         let binding = self.arenas.alloc_name_binding(NameBinding {\n             kind: NameBindingKind::Def(Def::Macro(def_id, kind), false),\n+            ambiguity: None,\n             span: DUMMY_SP,\n             vis: ty::Visibility::Public,\n             expansion: Mark::root(),\n@@ -389,7 +390,7 @@ impl<'a> Resolver<'a> {\n                     .push((path[0].ident, kind, parent_scope.clone(), binding.ok()));\n             }\n \n-            binding.map(|binding| binding.def_ignoring_ambiguity())\n+            binding.map(|binding| binding.def())\n         }\n     }\n \n@@ -950,9 +951,9 @@ impl<'a> Resolver<'a> {\n                 Ok(binding) => {\n                     let initial_def = initial_binding.map(|initial_binding| {\n                         self.record_use(ident, MacroNS, initial_binding, false);\n-                        initial_binding.def_ignoring_ambiguity()\n+                        initial_binding.def()\n                     });\n-                    let def = binding.def_ignoring_ambiguity();\n+                    let def = binding.def();\n                     let seg = Segment::from_ident(ident);\n                     check_consistency(self, &[seg], ident.span, kind, initial_def, def);\n                 }"}, {"sha": "c84dbd2974624976ac95ecab8bfab19a750cf3ea", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -445,6 +445,7 @@ impl<'a> Resolver<'a> {\n                 directive,\n                 used: Cell::new(false),\n             },\n+            ambiguity: None,\n             span: directive.span,\n             vis,\n             expansion: directive.parent_scope.expansion,\n@@ -498,8 +499,8 @@ impl<'a> Resolver<'a> {\n                                                                     nonglob_binding, glob_binding));\n                         } else {\n                             resolution.binding = Some(nonglob_binding);\n-                            resolution.shadowed_glob = Some(glob_binding);\n                         }\n+                        resolution.shadowed_glob = Some(glob_binding);\n                     }\n                     (false, false) => {\n                         if let (&NameBindingKind::Def(_, true), &NameBindingKind::Def(_, true)) =\n@@ -527,13 +528,15 @@ impl<'a> Resolver<'a> {\n         })\n     }\n \n-    fn ambiguity(&self, kind: AmbiguityKind, b1: &'a NameBinding<'a>, b2: &'a NameBinding<'a>)\n-                     -> &'a NameBinding<'a> {\n+    fn ambiguity(&self, kind: AmbiguityKind,\n+                 primary_binding: &'a NameBinding<'a>, secondary_binding: &'a NameBinding<'a>)\n+                 -> &'a NameBinding<'a> {\n         self.arenas.alloc_name_binding(NameBinding {\n-            kind: NameBindingKind::Ambiguity { kind, b1, b2 },\n-            vis: if b1.vis.is_at_least(b2.vis, self) { b1.vis } else { b2.vis },\n-            span: b1.span,\n-            expansion: Mark::root(),\n+            kind: primary_binding.kind.clone(),\n+            ambiguity: Some((secondary_binding, kind)),\n+            vis: primary_binding.vis,\n+            span: primary_binding.span,\n+            expansion: primary_binding.expansion,\n         })\n     }\n \n@@ -962,9 +965,9 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                                                 directive.module_path.is_empty());\n                             }\n                         }\n-                        initial_binding.def_ignoring_ambiguity()\n+                        initial_binding.def()\n                     });\n-                    let def = binding.def_ignoring_ambiguity();\n+                    let def = binding.def();\n                     if let Ok(initial_def) = initial_def {\n                         if def != initial_def && this.ambiguity_errors.is_empty() {\n                             span_bug!(directive.span, \"inconsistent resolution for an import\");\n@@ -1201,10 +1204,10 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 None => continue,\n             };\n \n-            // Filter away \"empty import canaries\".\n-            let is_non_canary_import =\n-                binding.is_import() && binding.vis != ty::Visibility::Invisible;\n-            if is_non_canary_import || binding.is_macro_def() {\n+            // Filter away \"empty import canaries\" and ambiguous imports.\n+            let is_good_import = binding.is_import() && !binding.is_ambiguity() &&\n+                                 binding.vis != ty::Visibility::Invisible;\n+            if is_good_import || binding.is_macro_def() {\n                 let def = binding.def();\n                 if def != Def::Err {\n                     if let Some(def_id) = def.opt_def_id() {"}, {"sha": "52fcb5b80f4ae9d4dec96886c8dd3b0cc02b31aa", "filename": "src/librustc_traits/type_op.rs", "status": "modified", "additions": 20, "deletions": 35, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc_traits%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc_traits%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Ftype_op.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -14,7 +14,7 @@ use rustc::traits::{\n     Normalized, Obligation, ObligationCause, TraitEngine, TraitEngineExt,\n };\n use rustc::ty::query::Providers;\n-use rustc::ty::subst::{Kind, Subst, UserSelfTy, UserSubsts};\n+use rustc::ty::subst::{Kind, Subst, UserSubsts, UserSelfTy};\n use rustc::ty::{\n     FnSig, Lift, ParamEnv, ParamEnvAnd, PolyFnSig, Predicate, Ty, TyCtxt, TypeFoldable, Variance,\n };\n@@ -44,28 +44,16 @@ fn type_op_ascribe_user_type<'tcx>(\n     tcx.infer_ctxt()\n         .enter_canonical_trait_query(&canonicalized, |infcx, fulfill_cx, key| {\n             let (\n-                param_env,\n-                AscribeUserType {\n-                    mir_ty,\n-                    variance,\n-                    def_id,\n-                    user_substs,\n-                    projs,\n-                },\n+                param_env, AscribeUserType { mir_ty, variance, def_id, user_substs, projs }\n             ) = key.into_parts();\n \n             debug!(\n-                \"type_op_ascribe_user_type(\\\n-                 mir_ty={:?}, variance={:?}, def_id={:?}, user_substs={:?}, projs={:?}\\\n-                 )\",\n-                mir_ty, variance, def_id, user_substs, projs,\n+                \"type_op_ascribe_user_type: mir_ty={:?} variance={:?} def_id={:?} \\\n+                 user_substs={:?} projs={:?}\",\n+                mir_ty, variance, def_id, user_substs, projs\n             );\n \n-            let mut cx = AscribeUserTypeCx {\n-                infcx,\n-                param_env,\n-                fulfill_cx,\n-            };\n+            let mut cx = AscribeUserTypeCx { infcx, param_env, fulfill_cx };\n             cx.relate_mir_and_user_ty(mir_ty, variance, def_id, user_substs, projs)?;\n \n             Ok(())\n@@ -130,10 +118,9 @@ impl AscribeUserTypeCx<'me, 'gcx, 'tcx> {\n         projs: &[ProjectionKind<'tcx>],\n     ) -> Result<(), NoSolution> {\n         let UserSubsts {\n-            substs,\n             user_self_ty,\n+            substs,\n         } = user_substs;\n-\n         let tcx = self.tcx();\n \n         let ty = tcx.type_of(def_id);\n@@ -171,20 +158,6 @@ impl AscribeUserTypeCx<'me, 'gcx, 'tcx> {\n             self.relate(mir_ty, variance, ty)?;\n         }\n \n-        if let Some(UserSelfTy {\n-            impl_def_id,\n-            self_ty,\n-        }) = user_self_ty\n-        {\n-            let impl_self_ty = self.tcx().type_of(impl_def_id);\n-            let impl_self_ty = self.subst(impl_self_ty, &substs);\n-            let impl_self_ty = self.normalize(impl_self_ty);\n-\n-            self.relate(self_ty, Variance::Invariant, impl_self_ty)?;\n-\n-            self.prove_predicate(Predicate::WellFormed(impl_self_ty));\n-        }\n-\n         // Prove the predicates coming along with `def_id`.\n         //\n         // Also, normalize the `instantiated_predicates`\n@@ -198,6 +171,19 @@ impl AscribeUserTypeCx<'me, 'gcx, 'tcx> {\n             self.prove_predicate(instantiated_predicate);\n         }\n \n+        if let Some(UserSelfTy {\n+            impl_def_id,\n+            self_ty,\n+        }) = user_self_ty {\n+            let impl_self_ty = self.tcx().type_of(impl_def_id);\n+            let impl_self_ty = self.subst(impl_self_ty, &substs);\n+            let impl_self_ty = self.normalize(impl_self_ty);\n+\n+            self.relate(self_ty, Variance::Invariant, impl_self_ty)?;\n+\n+            self.prove_predicate(Predicate::WellFormed(impl_self_ty));\n+        }\n+\n         // In addition to proving the predicates, we have to\n         // prove that `ty` is well-formed -- this is because\n         // the WF of `ty` is predicated on the substs being\n@@ -210,7 +196,6 @@ impl AscribeUserTypeCx<'me, 'gcx, 'tcx> {\n         // type were ill-formed but did not appear in `ty`,\n         // which...could happen with normalization...\n         self.prove_predicate(Predicate::WellFormed(ty));\n-\n         Ok(())\n     }\n }"}, {"sha": "1758f762524563623bfed05dec3c4d15ff327d65", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -357,16 +357,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         })\n     }\n \n-    pub fn resolve_ufcs(&self,\n-                        span: Span,\n-                        method_name: ast::Ident,\n-                        self_ty: Ty<'tcx>,\n-                        expr_id: ast::NodeId)\n-                        -> Result<Def, MethodError<'tcx>> {\n-        debug!(\"resolve_ufcs: method_name={:?} self_ty={:?} expr_id={:?}\",\n-            method_name,\n-            self_ty,\n-            expr_id\n+    pub fn resolve_ufcs(\n+        &self,\n+        span: Span,\n+        method_name: ast::Ident,\n+        self_ty: Ty<'tcx>,\n+        expr_id: ast::NodeId\n+    ) -> Result<Def, MethodError<'tcx>> {\n+        debug!(\n+            \"resolve_ufcs: method_name={:?} self_ty={:?} expr_id={:?}\",\n+            method_name, self_ty, expr_id,\n         );\n \n         let tcx = self.tcx;\n@@ -375,6 +375,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         match self.probe_for_name(span, mode, method_name, IsSuggestion(false),\n                                   self_ty, expr_id, ProbeScope::TraitsInScope) {\n             Ok(pick) => {\n+                debug!(\"resolve_ufcs: pick={:?}\", pick);\n                 if let Some(import_id) = pick.import_id {\n                     let import_def_id = tcx.hir().local_def_id(import_id);\n                     debug!(\"resolve_ufcs: used_trait_import: {:?}\", import_def_id);\n@@ -383,6 +384,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n \n                 let def = pick.item.def();\n+                debug!(\"resolve_ufcs: def={:?}\", def);\n                 tcx.check_stability(def.def_id(), Some(expr_id), span);\n \n                 Ok(def)"}, {"sha": "d78d7273a36e6193894cdeaca5fb72b62daf8165", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 77, "deletions": 52, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -102,13 +102,14 @@ use rustc::infer::type_variable::{TypeVariableOrigin};\n use rustc::middle::region;\n use rustc::mir::interpret::{ConstValue, GlobalId};\n use rustc::traits::{self, ObligationCause, ObligationCauseCode, TraitEngine};\n-use rustc::ty::{self, AdtKind, Ty, TyCtxt, GenericParamDefKind, RegionKind, Visibility,\n-                ToPolyTraitRef, ToPredicate};\n+use rustc::ty::{\n+    self, AdtKind, CanonicalUserTypeAnnotation, Ty, TyCtxt, GenericParamDefKind, Visibility,\n+    ToPolyTraitRef, ToPredicate, RegionKind, UserTypeAnnotation\n+};\n use rustc::ty::adjustment::{Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::query::Providers;\n-use rustc::ty::subst::{CanonicalUserSubsts, UnpackedKind, Subst, Substs,\n-                       UserSelfTy, UserSubsts};\n+use rustc::ty::subst::{UnpackedKind, Subst, Substs, UserSelfTy, UserSubsts};\n use rustc::ty::util::{Representability, IntTypeExt, Discr};\n use rustc::ty::layout::VariantIdx;\n use syntax_pos::{self, BytePos, Span, MultiSpan};\n@@ -974,10 +975,12 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for GatherLocalsVisitor<'a, 'gcx, 'tcx> {\n                     o_ty\n                 };\n \n-                let c_ty = self.fcx.inh.infcx.canonicalize_user_type_annotation(&revealed_ty);\n+                let c_ty = self.fcx.inh.infcx.canonicalize_user_type_annotation(\n+                    &UserTypeAnnotation::Ty(revealed_ty)\n+                );\n                 debug!(\"visit_local: ty.hir_id={:?} o_ty={:?} revealed_ty={:?} c_ty={:?}\",\n                        ty.hir_id, o_ty, revealed_ty, c_ty);\n-                self.fcx.tables.borrow_mut().user_provided_tys_mut().insert(ty.hir_id, c_ty);\n+                self.fcx.tables.borrow_mut().user_provided_types_mut().insert(ty.hir_id, c_ty);\n \n                 Some(LocalTy { decl_ty: o_ty, revealed_ty })\n             },\n@@ -2108,8 +2111,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.tables.borrow_mut().field_indices_mut().insert(hir_id, index);\n     }\n \n-    // The NodeId and the ItemLocalId must identify the same item. We just pass\n-    // both of them for consistency checking.\n     pub fn write_method_call(&self,\n                              hir_id: hir::HirId,\n                              method: MethodCallee<'tcx>) {\n@@ -2138,23 +2139,27 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         if !method.substs.is_noop() {\n             let method_generics = self.tcx.generics_of(method.def_id);\n             if !method_generics.params.is_empty() {\n-                let user_substs = self.infcx.probe(|_| {\n-                    let just_method_substs = Substs::for_item(self.tcx, method.def_id, |param, _| {\n-                        let i = param.index as usize;\n-                        if i < method_generics.parent_count {\n-                            self.infcx.var_for_def(DUMMY_SP, param)\n-                        } else {\n-                            method.substs[i]\n-                        }\n-                    });\n-                    self.infcx.canonicalize_user_type_annotation(&UserSubsts {\n-                        substs: just_method_substs,\n+                let user_type_annotation = self.infcx.probe(|_| {\n+                    let user_substs = UserSubsts {\n+                        substs: Substs::for_item(self.tcx, method.def_id, |param, _| {\n+                            let i = param.index as usize;\n+                            if i < method_generics.parent_count {\n+                                self.infcx.var_for_def(DUMMY_SP, param)\n+                            } else {\n+                                method.substs[i]\n+                            }\n+                        }),\n                         user_self_ty: None, // not relevant here\n-                    })\n+                    };\n+\n+                    self.infcx.canonicalize_user_type_annotation(&UserTypeAnnotation::TypeOf(\n+                        method.def_id,\n+                        user_substs,\n+                    ))\n                 });\n \n-                debug!(\"write_method_call: user_substs = {:?}\", user_substs);\n-                self.write_user_substs(hir_id, user_substs);\n+                debug!(\"write_method_call: user_type_annotation={:?}\", user_type_annotation);\n+                self.write_user_type_annotation(hir_id, user_type_annotation);\n             }\n         }\n     }\n@@ -2177,41 +2182,47 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// This should be invoked **before any unifications have\n     /// occurred**, so that annotations like `Vec<_>` are preserved\n     /// properly.\n-    pub fn write_user_substs_from_substs(\n+    pub fn write_user_type_annotation_from_substs(\n         &self,\n         hir_id: hir::HirId,\n+        def_id: DefId,\n         substs: &'tcx Substs<'tcx>,\n         user_self_ty: Option<UserSelfTy<'tcx>>,\n     ) {\n         debug!(\n-            \"write_user_substs_from_substs({:?}, {:?}) in fcx {}\",\n-            hir_id,\n-            substs,\n-            self.tag(),\n+            \"write_user_type_annotation_from_substs: hir_id={:?} def_id={:?} substs={:?} \\\n+             user_self_ty={:?} in fcx {}\",\n+            hir_id, def_id, substs, user_self_ty, self.tag(),\n         );\n \n         if !substs.is_noop() {\n-            let user_substs = self.infcx.canonicalize_user_type_annotation(&UserSubsts {\n-                substs,\n-                user_self_ty,\n-            });\n-            debug!(\"instantiate_value_path: user_substs = {:?}\", user_substs);\n-            self.write_user_substs(hir_id, user_substs);\n+            let canonicalized = self.infcx.canonicalize_user_type_annotation(\n+                &UserTypeAnnotation::TypeOf(def_id, UserSubsts {\n+                    substs,\n+                    user_self_ty,\n+                })\n+            );\n+            debug!(\"write_user_type_annotation_from_substs: canonicalized={:?}\", canonicalized);\n+            self.write_user_type_annotation(hir_id, canonicalized);\n         }\n     }\n \n-    pub fn write_user_substs(&self, hir_id: hir::HirId, substs: CanonicalUserSubsts<'tcx>) {\n+    pub fn write_user_type_annotation(\n+        &self,\n+        hir_id: hir::HirId,\n+        canonical_user_type_annotation: CanonicalUserTypeAnnotation<'tcx>,\n+    ) {\n         debug!(\n-            \"write_user_substs({:?}, {:?}) in fcx {}\",\n-            hir_id,\n-            substs,\n-            self.tag(),\n+            \"write_user_type_annotation: hir_id={:?} canonical_user_type_annotation={:?} tag={}\",\n+            hir_id, canonical_user_type_annotation, self.tag(),\n         );\n \n-        if !substs.is_identity() {\n-            self.tables.borrow_mut().user_substs_mut().insert(hir_id, substs);\n+        if !canonical_user_type_annotation.is_identity() {\n+            self.tables.borrow_mut().user_provided_types_mut().insert(\n+                hir_id, canonical_user_type_annotation\n+            );\n         } else {\n-            debug!(\"write_user_substs: skipping identity substs\");\n+            debug!(\"write_user_type_annotation: skipping identity substs\");\n         }\n     }\n \n@@ -2377,6 +2388,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn to_ty_saving_user_provided_ty(&self, ast_ty: &hir::Ty) -> Ty<'tcx> {\n         let ty = self.to_ty(ast_ty);\n+        debug!(\"to_ty_saving_user_provided_ty: ty={:?}\", ty);\n \n         // If the type given by the user has free regions, save it for\n         // later, since NLL would like to enforce those. Also pass in\n@@ -2386,8 +2398,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // although I have my doubts). Other sorts of things are\n         // already sufficiently enforced with erased regions. =)\n         if ty.has_free_regions() || ty.has_projections() {\n-            let c_ty = self.infcx.canonicalize_response(&ty);\n-            self.tables.borrow_mut().user_provided_tys_mut().insert(ast_ty.hir_id, c_ty);\n+            let c_ty = self.infcx.canonicalize_response(&UserTypeAnnotation::Ty(ty));\n+            debug!(\"to_ty_saving_user_provided_ty: c_ty={:?}\", c_ty);\n+            self.tables.borrow_mut().user_provided_types_mut().insert(ast_ty.hir_id, c_ty);\n         }\n \n         ty\n@@ -3422,8 +3435,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         if let Some(suggested_field_name) =\n                             Self::suggest_field_name(def.non_enum_variant(),\n                                                      &field.as_str(), vec![]) {\n-                                err.span_label(field.span,\n-                                               format!(\"did you mean `{}`?\", suggested_field_name));\n+                                err.span_suggestion_with_applicability(\n+                                    field.span,\n+                                    \"a field with a similar name exists\",\n+                                    suggested_field_name.to_string(),\n+                                    Applicability::MaybeIncorrect,\n+                                );\n                             } else {\n                                 err.span_label(field.span, \"unknown field\");\n                                 let struct_variant_def = def.non_enum_variant();\n@@ -3550,8 +3567,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         if let Some(field_name) = Self::suggest_field_name(variant,\n                                                            &field.ident.as_str(),\n                                                            skip_fields.collect()) {\n-            err.span_label(field.ident.span,\n-                           format!(\"field does not exist - did you mean `{}`?\", field_name));\n+            err.span_suggestion_with_applicability(\n+                    field.ident.span,\n+                    \"a field with a similar name exists\",\n+                    field_name.to_string(),\n+                    Applicability::MaybeIncorrect,\n+                );\n         } else {\n             match ty.sty {\n                 ty::Adt(adt, ..) => {\n@@ -3734,7 +3755,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         if let Some((variant, did, substs)) = variant {\n             debug!(\"check_struct_path: did={:?} substs={:?}\", did, substs);\n             let hir_id = self.tcx.hir().node_to_hir_id(node_id);\n-            self.write_user_substs_from_substs(hir_id, substs, None);\n+            self.write_user_type_annotation_from_substs(hir_id, did, substs, None);\n \n             // Check bounds on type arguments used in the path.\n             let bounds = self.instantiate_bounds(path_span, did, substs);\n@@ -4573,6 +4594,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                        span: Span)\n                                        -> (Def, Option<Ty<'tcx>>, &'b [hir::PathSegment])\n     {\n+        debug!(\"resolve_ty_and_def_ufcs: qpath={:?} node_id={:?} span={:?}\", qpath, node_id, span);\n         let (ty, qself, item_segment) = match *qpath {\n             QPath::Resolved(ref opt_qself, ref path) => {\n                 return (path.def,\n@@ -5093,6 +5115,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Def::Method(def_id) |\n             Def::AssociatedConst(def_id) => {\n                 let container = tcx.associated_item(def_id).container;\n+                debug!(\"instantiate_value_path: def={:?} container={:?}\", def, container);\n                 match container {\n                     ty::TraitContainer(trait_did) => {\n                         callee::check_legal_trait_for_method_call(tcx, span, trait_did)\n@@ -5195,13 +5218,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         if let Some(adt_def) = adt_def {\n                             match adt_def.adt_kind() {\n                                 AdtKind::Enum => {\n-                                    err.note(\"did you mean to use one of the enum's variants?\");\n+                                    err.help(\"did you mean to use one of the enum's variants?\");\n                                 },\n                                 AdtKind::Struct |\n                                 AdtKind::Union => {\n-                                    err.span_label(\n+                                    err.span_suggestion_with_applicability(\n                                         span,\n-                                        format!(\"did you mean `Self {{ /* fields */ }}`?\"),\n+                                        \"use curly brackets\",\n+                                        String::from(\"Self { /* fields */ }\"),\n+                                        Applicability::HasPlaceholders,\n                                     );\n                                 }\n                             }\n@@ -5290,7 +5315,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // First, store the \"user substs\" for later.\n         let hir_id = tcx.hir().node_to_hir_id(node_id);\n-        self.write_user_substs_from_substs(hir_id, substs, user_self_ty);\n+        self.write_user_type_annotation_from_substs(hir_id, def_id, substs, user_self_ty);\n \n         // Add all the obligations that are required, substituting and\n         // normalized appropriately."}, {"sha": "38de936a027ff6e2dd4e28ddb2d70812ea138744", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -3,6 +3,7 @@\n // substitutions.\n \n use check::FnCtxt;\n+use errors::DiagnosticBuilder;\n use rustc::hir;\n use rustc::hir::def_id::{DefId, DefIndex};\n use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n@@ -357,7 +358,8 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         debug_assert_eq!(fcx_tables.local_id_root, self.tables.local_id_root);\n         let common_local_id_root = fcx_tables.local_id_root.unwrap();\n \n-        for (&local_id, c_ty) in fcx_tables.user_provided_tys().iter() {\n+        let mut errors_buffer = Vec::new();\n+        for (&local_id, c_ty) in fcx_tables.user_provided_types().iter() {\n             let hir_id = hir::HirId {\n                 owner: common_local_id_root.index,\n                 local_id,\n@@ -374,8 +376,30 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n             };\n \n             self.tables\n-                .user_provided_tys_mut()\n+                .user_provided_types_mut()\n                 .insert(hir_id, c_ty.clone());\n+\n+            if let ty::UserTypeAnnotation::TypeOf(_, user_substs) = c_ty.value {\n+                if self.rustc_dump_user_substs {\n+                    // This is a unit-testing mechanism.\n+                    let node_id = self.tcx().hir().hir_to_node_id(hir_id);\n+                    let span = self.tcx().hir().span(node_id);\n+                    // We need to buffer the errors in order to guarantee a consistent\n+                    // order when emitting them.\n+                    let err = self.tcx().sess.struct_span_err(\n+                        span,\n+                        &format!(\"user substs: {:?}\", user_substs)\n+                    );\n+                    err.buffer(&mut errors_buffer);\n+                }\n+            }\n+        }\n+\n+        if !errors_buffer.is_empty() {\n+            errors_buffer.sort_by_key(|diag| diag.span.primary_span());\n+            for diag in errors_buffer.drain(..) {\n+                DiagnosticBuilder::new_diagnostic(self.tcx().sess.diagnostic(), diag).emit();\n+            }\n         }\n     }\n \n@@ -573,22 +597,6 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n             assert!(!substs.needs_infer() && !substs.has_placeholders());\n             self.tables.node_substs_mut().insert(hir_id, substs);\n         }\n-\n-        // Copy over any user-substs\n-        if let Some(user_substs) = self.fcx.tables.borrow().user_substs(hir_id) {\n-            let user_substs = self.tcx().lift_to_global(&user_substs).unwrap();\n-            self.tables.user_substs_mut().insert(hir_id, user_substs);\n-\n-            // Unit-testing mechanism:\n-            if self.rustc_dump_user_substs {\n-                let node_id = self.tcx().hir().hir_to_node_id(hir_id);\n-                let span = self.tcx().hir().span(node_id);\n-                self.tcx().sess.span_err(\n-                    span,\n-                    &format!(\"user substs: {:?}\", user_substs),\n-                );\n-            }\n-        }\n     }\n \n     fn visit_adjustments(&mut self, span: Span, hir_id: hir::HirId) {"}, {"sha": "ba6f9e622ad3532e61254232ab194fca38157458", "filename": "src/libstd/sys/sgx/ext/arch.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibstd%2Fsys%2Fsgx%2Fext%2Farch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibstd%2Fsys%2Fsgx%2Fext%2Farch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fext%2Farch.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -1,13 +1,3 @@\n-// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n //! SGX-specific access to architectural features.\n //!\n //! The functionality in this module is further documented in the Intel"}, {"sha": "1eb269783c5ab288c90470334832c3fed7c78464", "filename": "src/libstd/sys/sgx/ext/io.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibstd%2Fsys%2Fsgx%2Fext%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibstd%2Fsys%2Fsgx%2Fext%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fext%2Fio.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -1,13 +1,3 @@\n-// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n //! SGX-specific extensions to general I/O primitives\n //!\n //! SGX file descriptors behave differently from Unix file descriptors. See the"}, {"sha": "5489f6f56946e8a37f48312a423e8302bd06f9bc", "filename": "src/libstd/sys/sgx/ext/mod.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibstd%2Fsys%2Fsgx%2Fext%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibstd%2Fsys%2Fsgx%2Fext%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fext%2Fmod.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -1,13 +1,3 @@\n-// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n #![unstable(feature = \"sgx_platform\", issue = \"56975\")]\n \n pub mod arch;"}, {"sha": "855efbd3eb5d6261b62e5ee269770ad8dd697f8f", "filename": "src/libstd/sys/windows/handle.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -160,11 +160,6 @@ impl RawHandle {\n         }\n     }\n \n-    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> {\n-        let mut me = self;\n-        (&mut me).read_to_end(buf)\n-    }\n-\n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n         let mut amt = 0;\n         let len = cmp::min(buf.len(), <c::DWORD>::max_value() as usize) as c::DWORD;"}, {"sha": "a4f4bd22cd921ad259911b919c2fafe70c3a37ac", "filename": "src/libstd/sys/windows/stdio.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -128,11 +128,6 @@ impl Stdin {\n         // MemReader shouldn't error here since we just filled it\n         utf8.read(buf)\n     }\n-\n-    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> {\n-        let mut me = self;\n-        (&mut me).read_to_end(buf)\n-    }\n }\n \n #[unstable(reason = \"not public\", issue = \"0\", feature = \"fd_read\")]"}, {"sha": "ecb34e43c590cad2412415d4cb1638a19f88ebad", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 30, "deletions": 6, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -945,12 +945,36 @@ impl<'a> StringReader<'a> {\n                                     self.scan_unicode_escape(delim) && !ascii_only\n                                 } else {\n                                     let span = self.mk_sp(start, self.pos);\n-                                    self.sess.span_diagnostic\n-                                        .struct_span_err(span, \"incorrect unicode escape sequence\")\n-                                        .span_help(span,\n-                                                   \"format of unicode escape sequences is \\\n-                                                    `\\\\u{\u2026}`\")\n-                                        .emit();\n+                                    let mut suggestion = \"\\\\u{\".to_owned();\n+                                    let mut err = self.sess.span_diagnostic.struct_span_err(\n+                                        span,\n+                                        \"incorrect unicode escape sequence\",\n+                                    );\n+                                    let mut i = 0;\n+                                    while let (Some(ch), true) = (self.ch, i < 6) {\n+                                        if ch.is_digit(16) {\n+                                            suggestion.push(ch);\n+                                            self.bump();\n+                                            i += 1;\n+                                        } else {\n+                                            break;\n+                                        }\n+                                    }\n+                                    if i != 0 {\n+                                        suggestion.push('}');\n+                                        err.span_suggestion_with_applicability(\n+                                            self.mk_sp(start, self.pos),\n+                                            \"format of unicode escape sequences uses braces\",\n+                                            suggestion,\n+                                            Applicability::MaybeIncorrect,\n+                                        );\n+                                    } else {\n+                                        err.span_help(\n+                                            span,\n+                                            \"format of unicode escape sequences is `\\\\u{...}`\",\n+                                        );\n+                                    }\n+                                    err.emit();\n                                     false\n                                 };\n                                 if ascii_only {"}, {"sha": "c11f27f3ed589447874c58df12fb9ea22c3e72bb", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -808,12 +808,57 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n                 }\n                 ('\\\\', Some((next_pos, 'n'))) |\n                 ('\\\\', Some((next_pos, 't'))) |\n+                ('\\\\', Some((next_pos, '0'))) |\n                 ('\\\\', Some((next_pos, '\\\\'))) |\n                 ('\\\\', Some((next_pos, '\\''))) |\n                 ('\\\\', Some((next_pos, '\\\"'))) => {\n                     skips.push(*next_pos);\n                     let _ = s.next();\n                 }\n+                ('\\\\', Some((_, 'x'))) if !is_raw => {\n+                    for _ in 0..3 {  // consume `\\xAB` literal\n+                        if let Some((pos, _)) = s.next() {\n+                            skips.push(pos);\n+                        } else {\n+                            break;\n+                        }\n+                    }\n+                }\n+                ('\\\\', Some((_, 'u'))) if !is_raw => {\n+                    if let Some((pos, _)) = s.next() {\n+                        skips.push(pos);\n+                    }\n+                    if let Some((next_pos, next_c)) = s.next() {\n+                        if next_c == '{' {\n+                            skips.push(next_pos);\n+                            let mut i = 0;  // consume up to 6 hexanumeric chars + closing `}`\n+                            while let (Some((next_pos, c)), true) = (s.next(), i < 7) {\n+                                if c.is_digit(16) {\n+                                    skips.push(next_pos);\n+                                } else if c == '}' {\n+                                    skips.push(next_pos);\n+                                    break;\n+                                } else {\n+                                    break;\n+                                }\n+                                i += 1;\n+                            }\n+                        } else if next_c.is_digit(16) {\n+                            skips.push(next_pos);\n+                            // We suggest adding `{` and `}` when appropriate, accept it here as if\n+                            // it were correct\n+                            let mut i = 0;  // consume up to 6 hexanumeric chars\n+                            while let (Some((next_pos, c)), _) = (s.next(), i < 6) {\n+                                if c.is_digit(16) {\n+                                    skips.push(next_pos);\n+                                } else {\n+                                    break;\n+                                }\n+                                i += 1;\n+                            }\n+                        }\n+                    }\n+                }\n                 _ if eat_ws => {  // `take_while(|c| c.is_whitespace())`\n                     eat_ws = false;\n                 }"}, {"sha": "b6050f059c27bc6e5614bfa7a8ae544228b9aa1d", "filename": "src/test/incremental/hashes/let_expressions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fincremental%2Fhashes%2Flet_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fincremental%2Fhashes%2Flet_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Flet_expressions.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -70,7 +70,7 @@ pub fn change_mutability_of_reference_type() {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"HirBody,TypeckTables,MirValidated\")]\n+    except=\"HirBody,TypeckTables,MirValidated,MirOptimized\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_mutability_of_reference_type() {\n     let _x: &mut u64;"}, {"sha": "88fd53d4ba59d3feb878618276ba80d84ac67272", "filename": "src/test/mir-opt/basic_assignment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -37,7 +37,7 @@ fn main() {\n //        StorageLive(_4);\n //        _4 = std::option::Option<std::boxed::Box<u32>>::None;\n //        FakeRead(ForLet, _4);\n-//        AscribeUserType(_4, o, UserTypeProjection { base: Ty(Canonical { max_universe: U0, variables: [], value: std::option::Option<std::boxed::Box<u32>> }), projs: [] });\n+//        AscribeUserType(_4, o, UserTypeProjection { base: UserTypeAnnotation(1), projs: [] });\n //        StorageLive(_5);\n //        StorageLive(_6);\n //        _6 = move _4;"}, {"sha": "4801369cfd1a8a3ffeb0fba3aaaa17f829669c56", "filename": "src/test/run-pass/associated-consts/associated-const-range-match-patterns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-range-match-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-range-match-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-range-match-patterns.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -1,5 +1,5 @@\n // run-pass\n-#![allow(dead_code)]\n+#![allow(dead_code, unreachable_patterns)]\n \n struct Foo;\n "}, {"sha": "2d6cb1368d120ffa791212c56bdbad723281680c", "filename": "src/test/rustdoc/issue-56822.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Frustdoc%2Fissue-56822.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Frustdoc%2Fissue-56822.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-56822.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -1,13 +1,3 @@\n-// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n struct Wrapper<T>(T);\n \n trait MyTrait {"}, {"sha": "05bbc13d714fac81c2f05c131a0a0dd1d7b0cb75", "filename": "src/test/rustfix/closure-immutable-outer-variable.fixed", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Frustfix%2Fclosure-immutable-outer-variable.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Frustfix%2Fclosure-immutable-outer-variable.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustfix%2Fclosure-immutable-outer-variable.fixed?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -1,13 +1,3 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n // Point at the captured immutable outer variable\n \n fn foo(mut f: Box<FnMut()>) {"}, {"sha": "3724a00ce7ce09d157a982f40fb67ab51a9f59e7", "filename": "src/test/rustfix/empty-no-fixes.fixed", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Frustfix%2Fempty-no-fixes.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Frustfix%2Fempty-no-fixes.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustfix%2Fempty-no-fixes.fixed?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -1,11 +1 @@\n-// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n // compile-flags:--crate-type lib"}, {"sha": "e30d3ae0965ae3a3e541a579f3426012202621f7", "filename": "src/test/rustfix/empty-no-fixes.rs.fixed", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Frustfix%2Fempty-no-fixes.rs.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Frustfix%2Fempty-no-fixes.rs.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustfix%2Fempty-no-fixes.rs.fixed?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -1,12 +1,2 @@\n-// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n // compile-flags:--crate-type lib\n fn foo() {}"}, {"sha": "955b2cbf899ba68501d64b4e8347d728f287c71c", "filename": "src/test/rustfix/issue-45562.fixed", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Frustfix%2Fissue-45562.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Frustfix%2Fissue-45562.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustfix%2Fissue-45562.fixed?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -1,13 +1,3 @@\n-// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n #[no_mangle] pub static RAH: usize = 5;\n \n fn main() {}"}, {"sha": "b4ae4dc1ab2f8727646a01705f616443f093bb56", "filename": "src/test/rustfix/issue-45799-bad-extern-crate-rename-suggestion-formatting.fixed", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Frustfix%2Fissue-45799-bad-extern-crate-rename-suggestion-formatting.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Frustfix%2Fissue-45799-bad-extern-crate-rename-suggestion-formatting.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustfix%2Fissue-45799-bad-extern-crate-rename-suggestion-formatting.fixed?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -1,12 +1,2 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n extern crate std as other_std;\n fn main() {}"}, {"sha": "bedc8e15ace6ebd7d665b7b3ed21ba6c94a8d2ad", "filename": "src/test/rustfix/issue-46756-consider-borrowing-cast-or-binexpr.fixed", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Frustfix%2Fissue-46756-consider-borrowing-cast-or-binexpr.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Frustfix%2Fissue-46756-consider-borrowing-cast-or-binexpr.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustfix%2Fissue-46756-consider-borrowing-cast-or-binexpr.fixed?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -1,13 +1,3 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n #![allow(unused)]\n \n fn light_flows_our_war_of_mocking_words(and_yet: &usize) -> usize {"}, {"sha": "f328e4d9d04c31d0d70d16d21a07d1613be9d577", "filename": "src/test/rustfix/main-no-fixes.fixed", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Frustfix%2Fmain-no-fixes.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Frustfix%2Fmain-no-fixes.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustfix%2Fmain-no-fixes.fixed?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -1,11 +1 @@\n-// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n fn main() {}"}, {"sha": "f328e4d9d04c31d0d70d16d21a07d1613be9d577", "filename": "src/test/rustfix/main-no-fixes.rs.fixed", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Frustfix%2Fmain-no-fixes.rs.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Frustfix%2Fmain-no-fixes.rs.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustfix%2Fmain-no-fixes.rs.fixed?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -1,11 +1 @@\n-// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n fn main() {}"}, {"sha": "d4696ab9547a6a22828a92baed4bc36a381fc83f", "filename": "src/test/rustfix/missing-comma-in-match.fixed", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Frustfix%2Fmissing-comma-in-match.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Frustfix%2Fmissing-comma-in-match.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustfix%2Fmissing-comma-in-match.fixed?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -1,13 +1,3 @@\n-// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n fn main() {\n     match &Some(3) {\n         &None => 1,"}, {"sha": "900fee94653c1a4b70c908df06b4ba2fab26294c", "filename": "src/test/rustfix/str-as-char.fixed", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Frustfix%2Fstr-as-char.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Frustfix%2Fstr-as-char.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustfix%2Fstr-as-char.fixed?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -1,13 +1,3 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n fn main() {\n     println!(\"\u25cf\u25cf\");\n }"}, {"sha": "abb07962e894a9bf706db4e0d21df8aea3f58d41", "filename": "src/test/rustfix/tuple-float-index.fixed", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Frustfix%2Ftuple-float-index.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Frustfix%2Ftuple-float-index.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustfix%2Ftuple-float-index.fixed?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -1,13 +1,3 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n // compile-flags: -Z parse-only\n \n fn main () {"}, {"sha": "89ba26dfd6f4b1c109fcbd008bcfd3c035132275", "filename": "src/test/ui/attr-bad-crate-attr.rc", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fattr-bad-crate-attr.rc", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fattr-bad-crate-attr.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattr-bad-crate-attr.rc?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -1,13 +1,3 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n // error-pattern: expected item\n \n #![attr = \"val\"]"}, {"sha": "5c6358beb2487893755f1998ffd9eb596ae224b3", "filename": "src/test/ui/closures/closure-immutable-outer-variable.rs.fixed", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fclosures%2Fclosure-immutable-outer-variable.rs.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fclosures%2Fclosure-immutable-outer-variable.rs.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fclosure-immutable-outer-variable.rs.fixed?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -1,13 +1,3 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n // Point at the captured immutable outer variable\n \n fn foo(mut f: Box<FnMut()>) {"}, {"sha": "8273fad476462c764fd5791a07c66abf11dfbe41", "filename": "src/test/ui/did_you_mean/issue-36798.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-36798.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-36798.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-36798.stderr?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -2,7 +2,7 @@ error[E0609]: no field `baz` on type `Foo`\n   --> $DIR/issue-36798.rs:7:7\n    |\n LL |     f.baz; //~ ERROR no field\n-   |       ^^^ did you mean `bar`?\n+   |       ^^^ help: a field with a similar name exists: `bar`\n \n error: aborting due to previous error\n "}, {"sha": "e5dd61c45d6627b4e997ba17294377762a893a33", "filename": "src/test/ui/did_you_mean/issue-42599_available_fields_note.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-42599_available_fields_note.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-42599_available_fields_note.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-42599_available_fields_note.stderr?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -2,7 +2,7 @@ error[E0560]: struct `submodule::Demo` has no field named `inocently_mispellable\n   --> $DIR/issue-42599_available_fields_note.rs:16:39\n    |\n LL |             Self { secret_integer: 2, inocently_mispellable: () }\n-   |                                       ^^^^^^^^^^^^^^^^^^^^^ field does not exist - did you mean `innocently_misspellable`?\n+   |                                       ^^^^^^^^^^^^^^^^^^^^^ help: a field with a similar name exists: `innocently_misspellable`\n \n error[E0560]: struct `submodule::Demo` has no field named `egregiously_nonexistent_field`\n   --> $DIR/issue-42599_available_fields_note.rs:21:39\n@@ -16,7 +16,7 @@ error[E0609]: no field `inocently_mispellable` on type `submodule::Demo`\n   --> $DIR/issue-42599_available_fields_note.rs:32:41\n    |\n LL |     let innocent_field_misaccess = demo.inocently_mispellable;\n-   |                                         ^^^^^^^^^^^^^^^^^^^^^ did you mean `innocently_misspellable`?\n+   |                                         ^^^^^^^^^^^^^^^^^^^^^ help: a field with a similar name exists: `innocently_misspellable`\n \n error[E0609]: no field `egregiously_nonexistent_field` on type `submodule::Demo`\n   --> $DIR/issue-42599_available_fields_note.rs:35:42"}, {"sha": "a9a3aee2500fb5549c5f87aa57b345f5c7ca1069", "filename": "src/test/ui/error-codes/E0445.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Ferror-codes%2FE0445.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Ferror-codes%2FE0445.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0445.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -4,12 +4,9 @@ trait Foo {\n \n pub trait Bar : Foo {}\n //~^ ERROR private trait `Foo` in public interface [E0445]\n-//~| NOTE can't leak private trait\n pub struct Bar2<T: Foo>(pub T);\n //~^ ERROR private trait `Foo` in public interface [E0445]\n-//~| NOTE can't leak private trait\n pub fn foo<T: Foo> (t: T) {}\n //~^ ERROR private trait `Foo` in public interface [E0445]\n-//~| NOTE can't leak private trait\n \n fn main() {}"}, {"sha": "d0d6ebe16c7f7cbcf5325fae4d2f471a5c6de1ad", "filename": "src/test/ui/error-codes/E0445.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Ferror-codes%2FE0445.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Ferror-codes%2FE0445.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0445.stderr?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -5,13 +5,13 @@ LL | pub trait Bar : Foo {}\n    | ^^^^^^^^^^^^^^^^^^^^^^ can't leak private trait\n \n error[E0445]: private trait `Foo` in public interface\n-  --> $DIR/E0445.rs:8:1\n+  --> $DIR/E0445.rs:7:1\n    |\n LL | pub struct Bar2<T: Foo>(pub T);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private trait\n \n error[E0445]: private trait `Foo` in public interface\n-  --> $DIR/E0445.rs:11:1\n+  --> $DIR/E0445.rs:9:1\n    |\n LL | pub fn foo<T: Foo> (t: T) {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private trait"}, {"sha": "0f498d16439058061a46409ffcb543821f73dda4", "filename": "src/test/ui/error-codes/ex-E0612.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Ferror-codes%2Fex-E0612.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Ferror-codes%2Fex-E0612.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2Fex-E0612.stderr?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -2,7 +2,7 @@ error[E0609]: no field `1` on type `Foo`\n   --> $DIR/ex-E0612.rs:5:6\n    |\n LL |    y.1; //~ ERROR no field `1` on type `Foo`\n-   |      ^ did you mean `0`?\n+   |      ^ help: a field with a similar name exists: `0`\n \n error: aborting due to previous error\n "}, {"sha": "5c25ae502ff6d8f06d95c2456d84889978a7acd4", "filename": "src/test/ui/fmt/format-string-error-2.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Ffmt%2Fformat-string-error-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Ffmt%2Fformat-string-error-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffmt%2Fformat-string-error-2.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -69,4 +69,19 @@ raw  { \\n\n     //~^^ ERROR invalid format string\n     println!(\"\\t{}\");\n     //~^ ERROR 1 positional argument in format string\n+\n+    // note: `\\x7B` is `{`\n+    println!(\"\\x7B}\\u{8} {\", 1);\n+    //~^ ERROR invalid format string: expected `'}'` but string was terminated\n+\n+    println!(\"\\x7B}\\u8 {\", 1);\n+    //~^ ERROR incorrect unicode escape sequence\n+    //~| ERROR argument never used\n+\n+    // note: raw strings don't escape `\\xFF` and `\\u{FF}` sequences\n+    println!(r#\"\\x7B}\\u{8} {\"#, 1);\n+    //~^ ERROR invalid format string: unmatched `}` found\n+\n+    println!(r#\"\\x7B}\\u8 {\"#, 1);\n+    //~^ ERROR invalid format string: unmatched `}` found\n }"}, {"sha": "baab8529940c5ebe79e42d2dbde61dcf3a0c859d", "filename": "src/test/ui/fmt/format-string-error-2.stderr", "status": "modified", "additions": 43, "deletions": 1, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Ffmt%2Fformat-string-error-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Ffmt%2Fformat-string-error-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffmt%2Fformat-string-error-2.stderr?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -1,3 +1,11 @@\n+error: incorrect unicode escape sequence\n+  --> $DIR/format-string-error-2.rs:77:20\n+   |\n+LL |     println!(\"/x7B}/u8 {\", 1);\n+   |                    ^^-\n+   |                    |\n+   |                    help: format of unicode escape sequences uses braces: `/u{8}`\n+\n error: invalid format string: expected `'}'`, found `'a'`\n   --> $DIR/format-string-error-2.rs:5:5\n    |\n@@ -139,5 +147,39 @@ error: 1 positional argument in format string, but no arguments were given\n LL |     println!(\"/t{}\");\n    |                 ^^\n \n-error: aborting due to 14 previous errors\n+error: invalid format string: expected `'}'` but string was terminated\n+  --> $DIR/format-string-error-2.rs:74:27\n+   |\n+LL |     println!(\"/x7B}/u{8} {\", 1);\n+   |                          -^ expected `'}'` in format string\n+   |                          |\n+   |                          because of this opening brace\n+   |\n+   = note: if you intended to print `{`, you can escape it using `{{`\n+\n+error: argument never used\n+  --> $DIR/format-string-error-2.rs:77:28\n+   |\n+LL |     println!(\"/x7B}/u8 {\", 1);\n+   |              ------------  ^ argument never used\n+   |              |\n+   |              formatting specifier missing\n+\n+error: invalid format string: unmatched `}` found\n+  --> $DIR/format-string-error-2.rs:82:21\n+   |\n+LL |     println!(r#\"/x7B}/u{8} {\"#, 1);\n+   |                     ^ unmatched `}` in format string\n+   |\n+   = note: if you intended to print `}`, you can escape it using `}}`\n+\n+error: invalid format string: unmatched `}` found\n+  --> $DIR/format-string-error-2.rs:85:21\n+   |\n+LL |     println!(r#\"/x7B}/u8 {\"#, 1);\n+   |                     ^ unmatched `}` in format string\n+   |\n+   = note: if you intended to print `}`, you can escape it using `}}`\n+\n+error: aborting due to 19 previous errors\n "}, {"sha": "13671b8dbf448f2d4ef92d24fca8a987edf9f059", "filename": "src/test/ui/impl-trait/issue-49376.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-49376.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-49376.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-49376.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -9,9 +9,11 @@ fn gen() -> impl PartialOrd + PartialEq + Debug { }\n \n struct Bar {}\n trait Foo<T = Self> {}\n+trait FooNested<T = Option<Self>> {}\n impl Foo for Bar {}\n+impl FooNested for Bar {}\n \n-fn foo() -> impl Foo {\n+fn foo() -> impl Foo + FooNested {\n     Bar {}\n }\n "}, {"sha": "c83db64c6437c1953ceb9eb5a0d3383ee5c9fc1a", "filename": "src/test/ui/imports/auxiliary/glob-conflict.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fimports%2Fauxiliary%2Fglob-conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fimports%2Fauxiliary%2Fglob-conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fauxiliary%2Fglob-conflict.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -7,3 +7,7 @@ mod m2 {\n \n pub use m1::*;\n pub use m2::*;\n+\n+pub mod glob {\n+    pub use *;\n+}"}, {"sha": "db6538969ec71101d2d02390d1fd4623cdb83ec1", "filename": "src/test/ui/imports/duplicate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fimports%2Fduplicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fimports%2Fduplicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fduplicate.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -37,7 +37,7 @@ fn main() {\n }\n \n mod ambiguous_module_errors {\n-    pub mod m1 { pub use super::m1 as foo; }\n+    pub mod m1 { pub use super::m1 as foo; pub fn bar() {} }\n     pub mod m2 { pub use super::m2 as foo; }\n \n     use self::m1::*;"}, {"sha": "c8b18525d805980d460823db5d85f9f9fcad629e", "filename": "src/test/ui/imports/glob-conflict-cross-crate.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fimports%2Fglob-conflict-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fimports%2Fglob-conflict-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fglob-conflict-cross-crate.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -4,4 +4,5 @@ extern crate glob_conflict;\n \n fn main() {\n     glob_conflict::f(); //~ ERROR cannot find function `f` in module `glob_conflict`\n+    glob_conflict::glob::f(); //~ ERROR cannot find function `f` in module `glob_conflict::glob`\n }"}, {"sha": "f5a82ef1b3b0156c2410ecfe96e8e0b595759f92", "filename": "src/test/ui/imports/glob-conflict-cross-crate.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fimports%2Fglob-conflict-cross-crate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fimports%2Fglob-conflict-cross-crate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fglob-conflict-cross-crate.stderr?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -4,6 +4,12 @@ error[E0425]: cannot find function `f` in module `glob_conflict`\n LL |     glob_conflict::f(); //~ ERROR cannot find function `f` in module `glob_conflict`\n    |                    ^ not found in `glob_conflict`\n \n-error: aborting due to previous error\n+error[E0425]: cannot find function `f` in module `glob_conflict::glob`\n+  --> $DIR/glob-conflict-cross-crate.rs:7:26\n+   |\n+LL |     glob_conflict::glob::f(); //~ ERROR cannot find function `f` in module `glob_conflict::glob`\n+   |                          ^ not found in `glob_conflict::glob`\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0425`."}, {"sha": "7750e3403619288b0f44a332799ebc97c7e25c80", "filename": "src/test/ui/issue-54943-1.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fissue-54943-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fissue-54943-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-54943-1.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -0,0 +1,15 @@\n+#![feature(nll)]\n+\n+// This test is a minimal version of an ICE in the dropck-eyepatch tests\n+// found in the fix for #54943.\n+\n+// compile-pass\n+\n+fn foo<T>(_t: T) {\n+}\n+\n+fn main() {\n+    struct A<'a, B: 'a>(&'a B);\n+    let (a1, a2): (String, A<_>) = (String::from(\"auto\"), A(&\"this\"));\n+    foo((a1, a2));\n+}"}, {"sha": "f829c38c35d23638963114e4bc92fbe043512d9f", "filename": "src/test/ui/issue-54943-2.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fissue-54943-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fissue-54943-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-54943-2.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -0,0 +1,18 @@\n+#![feature(nll)]\n+\n+// This test is a minimal version of an ICE in the dropck-eyepatch tests\n+// found in the fix for #54943. In particular, this test is in unreachable\n+// code as the initial fix for this ICE only worked if the code was reachable.\n+\n+// compile-pass\n+\n+fn foo<T>(_t: T) {\n+}\n+\n+fn main() {\n+    return;\n+\n+    struct A<'a, B: 'a>(&'a B);\n+    let (a1, a2): (String, A<_>) = (String::from(\"auto\"), A(&\"this\"));\n+    foo((a1, a2));\n+}"}, {"sha": "185077bd684a87ecaac408212899eaeba80a8188", "filename": "src/test/ui/issue-54943-3.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fissue-54943-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fissue-54943-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-54943-3.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -0,0 +1,21 @@\n+// compile-pass\n+// FIXME(#54943) This test targets the scenario where proving the WF requirements requires\n+// knowing the value of the `_` type present in the user type annotation - unfortunately, figuring\n+// out the value of that `_` requires type-checking the surrounding code, but that code is dead,\n+// so our NLL region checker doesn't have access to it. This test should actually fail to compile.\n+\n+#![feature(nll)]\n+#![allow(warnings)]\n+\n+use std::fmt::Debug;\n+\n+fn foo<T: 'static + Debug>(_: T) { }\n+\n+fn bar<'a>() {\n+    return;\n+\n+    let _x = foo::<Vec<_>>(Vec::<&'a u32>::new());\n+    //~^ ERROR the type `&'a u32` does not fulfill the required lifetime [E0477]\n+}\n+\n+fn main() {}"}, {"sha": "c720f6279758068643488b9a43fcc873358840eb", "filename": "src/test/ui/issue-54943.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fissue-54943.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fissue-54943.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-54943.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -0,0 +1,17 @@\n+// compile-pass\n+// FIXME(#54943) This test targets the scenario where proving the WF requirements of a user\n+// type annotation requires checking dead code. This test should actually fail to compile.\n+\n+#![feature(nll)]\n+#![allow(warnings)]\n+\n+fn foo<T: 'static>() { }\n+\n+fn boo<'a>() {\n+    return;\n+\n+    let x = foo::<&'a u32>();\n+    //~^ ERROR the type `&'a u32` does not fulfill the required lifetime [E0477]\n+}\n+\n+fn main() {}"}, {"sha": "bf3e58e8cdb19b1c5cfea5247b1bba8e6cc4af73", "filename": "src/test/ui/issue-55511.nll.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fissue-55511.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fissue-55511.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-55511.nll.stderr?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -0,0 +1,15 @@\n+error[E0597]: `a` does not live long enough\n+  --> $DIR/issue-55511.rs:13:28\n+   |\n+LL |     let b = Some(Cell::new(&a));\n+   |                            ^^ borrowed value does not live long enough\n+...\n+LL |         <() as Foo<'static>>::C => { }\n+   |         ----------------------- type annotation requires that `a` is borrowed for `'static`\n+...\n+LL | }\n+   | - `a` dropped here while still borrowed\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "4b9475ba627183092b85f9a2d406018893c8c6ed", "filename": "src/test/ui/issue-55511.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fissue-55511.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fissue-55511.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-55511.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -0,0 +1,19 @@\n+use std::cell::Cell;\n+\n+trait Foo<'a> {\n+    const C: Option<Cell<&'a u32>>;\n+}\n+\n+impl<'a, T> Foo<'a> for T {\n+    const C: Option<Cell<&'a u32>> = None;\n+}\n+\n+fn main() {\n+    let a = 22;\n+    let b = Some(Cell::new(&a));\n+    //~^ ERROR `a` does not live long enough [E0597]\n+    match b {\n+        <() as Foo<'static>>::C => { }\n+        _ => { }\n+    }\n+}"}, {"sha": "24668f045517ac828cb16ae9a63e452a87a2a70b", "filename": "src/test/ui/issue-55511.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fissue-55511.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fissue-55511.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-55511.stderr?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -0,0 +1,14 @@\n+error[E0597]: `a` does not live long enough\n+  --> $DIR/issue-55511.rs:13:29\n+   |\n+LL |     let b = Some(Cell::new(&a));\n+   |                             ^ borrowed value does not live long enough\n+...\n+LL | }\n+   | - borrowed value only lives until here\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "02ff6b6d5bff4b3d426397def063d0a97dc5b629", "filename": "src/test/ui/issues/issue-18389.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fissues%2Fissue-18389.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fissues%2Fissue-18389.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-18389.stderr?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -1,6 +1,9 @@\n error[E0445]: private trait `Private<<Self as Public>::P, <Self as Public>::R>` in public interface\n   --> $DIR/issue-18389.rs:7:1\n    |\n+LL |   trait Private<P, R> {\n+   |   - `Private<<Self as Public>::P, <Self as Public>::R>` declared as private\n+...\n LL | / pub trait Public: Private<\n LL | | //~^ ERROR private trait `Private<<Self as Public>::P, <Self as Public>::R>` in public interface\n LL | |     <Self as Public>::P,"}, {"sha": "5e1b816defda37da049523183cc3f3267526254b", "filename": "src/test/ui/issues/issue-47073-zero-padded-tuple-struct-indices.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fissues%2Fissue-47073-zero-padded-tuple-struct-indices.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fissues%2Fissue-47073-zero-padded-tuple-struct-indices.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-47073-zero-padded-tuple-struct-indices.stderr?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -2,7 +2,7 @@ error[E0609]: no field `00` on type `Verdict`\n   --> $DIR/issue-47073-zero-padded-tuple-struct-indices.rs:8:30\n    |\n LL |     let _condemned = justice.00;\n-   |                              ^^ did you mean `0`?\n+   |                              ^^ help: a field with a similar name exists: `0`\n \n error[E0609]: no field `001` on type `Verdict`\n   --> $DIR/issue-47073-zero-padded-tuple-struct-indices.rs:10:31"}, {"sha": "39c649ba3e0e7cde0f3e7306a3735bcd16555727", "filename": "src/test/ui/issues/issue-4736.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fissues%2Fissue-4736.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fissues%2Fissue-4736.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-4736.stderr?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -2,7 +2,7 @@ error[E0560]: struct `NonCopyable` has no field named `p`\n   --> $DIR/issue-4736.rs:4:26\n    |\n LL |     let z = NonCopyable{ p: () }; //~ ERROR struct `NonCopyable` has no field named `p`\n-   |                          ^ field does not exist - did you mean `0`?\n+   |                          ^ help: a field with a similar name exists: `0`\n \n error: aborting due to previous error\n "}, {"sha": "7aaf8e4ac2f1408275a8f9cc671560c1353c581e", "filename": "src/test/ui/issues/issue-56199.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fissues%2Fissue-56199.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fissues%2Fissue-56199.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-56199.stderr?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -4,27 +4,27 @@ error: the `Self` constructor can only be used with tuple or unit structs\n LL |         let _ = Self;\n    |                 ^^^^\n    |\n-   = note: did you mean to use one of the enum's variants?\n+   = help: did you mean to use one of the enum's variants?\n \n error: the `Self` constructor can only be used with tuple or unit structs\n   --> $DIR/issue-56199.rs:8:17\n    |\n LL |         let _ = Self();\n    |                 ^^^^\n    |\n-   = note: did you mean to use one of the enum's variants?\n+   = help: did you mean to use one of the enum's variants?\n \n error: the `Self` constructor can only be used with tuple or unit structs\n   --> $DIR/issue-56199.rs:15:17\n    |\n LL |         let _ = Self;\n-   |                 ^^^^ did you mean `Self { /* fields */ }`?\n+   |                 ^^^^ help: use curly brackets: `Self { /* fields */ }`\n \n error: the `Self` constructor can only be used with tuple or unit structs\n   --> $DIR/issue-56199.rs:17:17\n    |\n LL |         let _ = Self();\n-   |                 ^^^^ did you mean `Self { /* fields */ }`?\n+   |                 ^^^^ help: use curly brackets: `Self { /* fields */ }`\n \n error: aborting due to 4 previous errors\n "}, {"sha": "f9fdf23af9715141ce9682ab1be5e7407a00b88d", "filename": "src/test/ui/issues/issue-56835.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fissues%2Fissue-56835.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fissues%2Fissue-56835.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-56835.stderr?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -2,7 +2,7 @@ error: the `Self` constructor can only be used with tuple or unit structs\n   --> $DIR/issue-56835.rs:4:12\n    |\n LL |     fn bar(Self(foo): Self) {}\n-   |            ^^^^^^^^^ did you mean `Self { /* fields */ }`?\n+   |            ^^^^^^^^^ help: use curly brackets: `Self { /* fields */ }`\n \n error[E0164]: expected tuple struct/variant, found self constructor `Self`\n   --> $DIR/issue-56835.rs:4:12"}, {"sha": "3f0444ec9c80777e08155259569ea70d5eb3a6ba", "filename": "src/test/ui/kindck/kindck-send-unsafe.rs~rust-lang_master", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fkindck%2Fkindck-send-unsafe.rs%7Erust-lang_master", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fkindck%2Fkindck-send-unsafe.rs%7Erust-lang_master", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fkindck%2Fkindck-send-unsafe.rs%7Erust-lang_master?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -1,13 +1,3 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n fn assert_send<T:Send>() { }\n \n // unsafe ptrs are ok unless they point at unsendable things"}, {"sha": "0386daaa59b072af1bae6925fcad7b05a98c991f", "filename": "src/test/ui/lint/lint-group-nonstandard-style.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Flint%2Flint-group-nonstandard-style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Flint%2Flint-group-nonstandard-style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-group-nonstandard-style.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -1,7 +1,3 @@\n-// Copyright 2014\u20132017 The Rust Project Developers. See the COPYRIGHT\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-\n #![deny(nonstandard_style)]\n #![allow(dead_code)]\n "}, {"sha": "d85ca7811d01e97e066f6cf228bb7126e8ed3150", "filename": "src/test/ui/lint/lint-group-nonstandard-style.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Flint%2Flint-group-nonstandard-style.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Flint%2Flint-group-nonstandard-style.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-group-nonstandard-style.stderr?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -1,63 +1,63 @@\n warning: type `snake_case` should have a camel case name such as `SnakeCase`\n-  --> $DIR/lint-group-nonstandard-style.rs:26:9\n+  --> $DIR/lint-group-nonstandard-style.rs:22:9\n    |\n LL |         struct snake_case; //~ WARN should have a camel\n    |         ^^^^^^^^^^^^^^^^^^\n    |\n note: lint level defined here\n-  --> $DIR/lint-group-nonstandard-style.rs:22:17\n+  --> $DIR/lint-group-nonstandard-style.rs:18:17\n    |\n LL |         #![warn(nonstandard_style)]\n    |                 ^^^^^^^^^^^^^^^^^\n    = note: #[warn(non_camel_case_types)] implied by #[warn(nonstandard_style)]\n \n error: function `CamelCase` should have a snake case name such as `camel_case`\n-  --> $DIR/lint-group-nonstandard-style.rs:8:1\n+  --> $DIR/lint-group-nonstandard-style.rs:4:1\n    |\n LL | fn CamelCase() {} //~ ERROR should have a snake\n    | ^^^^^^^^^^^^^^^^^\n    |\n note: lint level defined here\n-  --> $DIR/lint-group-nonstandard-style.rs:5:9\n+  --> $DIR/lint-group-nonstandard-style.rs:1:9\n    |\n LL | #![deny(nonstandard_style)]\n    |         ^^^^^^^^^^^^^^^^^\n    = note: #[deny(non_snake_case)] implied by #[deny(nonstandard_style)]\n \n error: function `CamelCase` should have a snake case name such as `camel_case`\n-  --> $DIR/lint-group-nonstandard-style.rs:16:9\n+  --> $DIR/lint-group-nonstandard-style.rs:12:9\n    |\n LL |         fn CamelCase() {} //~ ERROR should have a snake\n    |         ^^^^^^^^^^^^^^^^^\n    |\n note: lint level defined here\n-  --> $DIR/lint-group-nonstandard-style.rs:14:14\n+  --> $DIR/lint-group-nonstandard-style.rs:10:14\n    |\n LL |     #[forbid(nonstandard_style)]\n    |              ^^^^^^^^^^^^^^^^^\n    = note: #[forbid(non_snake_case)] implied by #[forbid(nonstandard_style)]\n \n error: static variable `bad` should have an upper case name such as `BAD`\n-  --> $DIR/lint-group-nonstandard-style.rs:18:9\n+  --> $DIR/lint-group-nonstandard-style.rs:14:9\n    |\n LL |         static bad: isize = 1; //~ ERROR should have an upper\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: lint level defined here\n-  --> $DIR/lint-group-nonstandard-style.rs:14:14\n+  --> $DIR/lint-group-nonstandard-style.rs:10:14\n    |\n LL |     #[forbid(nonstandard_style)]\n    |              ^^^^^^^^^^^^^^^^^\n    = note: #[forbid(non_upper_case_globals)] implied by #[forbid(nonstandard_style)]\n \n warning: function `CamelCase` should have a snake case name such as `camel_case`\n-  --> $DIR/lint-group-nonstandard-style.rs:24:9\n+  --> $DIR/lint-group-nonstandard-style.rs:20:9\n    |\n LL |         fn CamelCase() {} //~ WARN should have a snake\n    |         ^^^^^^^^^^^^^^^^^\n    |\n note: lint level defined here\n-  --> $DIR/lint-group-nonstandard-style.rs:22:17\n+  --> $DIR/lint-group-nonstandard-style.rs:18:17\n    |\n LL |         #![warn(nonstandard_style)]\n    |                 ^^^^^^^^^^^^^^^^^"}, {"sha": "0b5a4eb785195f8eebe8b3835888ca20064c8f2f", "filename": "src/test/ui/lint/not_found.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Flint%2Fnot_found.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Flint%2Fnot_found.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fnot_found.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -1,7 +1,3 @@\n-// Copyright 2014\u20132017 The Rust Project Developers. See the COPYRIGHT\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-\n // compile-pass\n \n // this tests the `unknown_lint` lint, especially the suggestions"}, {"sha": "266cf10af8285f9d36bf0c477d25dcaace578d5c", "filename": "src/test/ui/lint/not_found.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Flint%2Fnot_found.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Flint%2Fnot_found.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fnot_found.stderr?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -1,19 +1,19 @@\n warning: unknown lint: `FOO_BAR`\n-  --> $DIR/not_found.rs:10:9\n+  --> $DIR/not_found.rs:6:9\n    |\n LL | #[allow(FOO_BAR)]\n    |         ^^^^^^^\n    |\n    = note: #[warn(unknown_lints)] on by default\n \n warning: unknown lint: `DEAD_CODE`\n-  --> $DIR/not_found.rs:12:8\n+  --> $DIR/not_found.rs:8:8\n    |\n LL | #[warn(DEAD_CODE)]\n    |        ^^^^^^^^^ help: did you mean: `dead_code`\n \n warning: unknown lint: `Warnings`\n-  --> $DIR/not_found.rs:14:8\n+  --> $DIR/not_found.rs:10:8\n    |\n LL | #[deny(Warnings)]\n    |        ^^^^^^^^ help: did you mean: `warnings`"}, {"sha": "2fa234491087d679d10cfe68653575753d3ea00d", "filename": "src/test/ui/nll/issue-55401.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fnll%2Fissue-55401.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fnll%2Fissue-55401.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-55401.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -0,0 +1,8 @@\n+#![feature(nll)]\n+\n+fn static_to_a_to_static_through_ref_in_tuple<'a>(x: &'a u32) -> &'static u32 {\n+    let (ref y, _z): (&'a u32, u32) = (&22, 44);\n+    *y //~ ERROR\n+}\n+\n+fn main() {}"}, {"sha": "9e50db7b6045da374bd9591227b755edec3593cc", "filename": "src/test/ui/nll/issue-55401.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fnll%2Fissue-55401.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fnll%2Fissue-55401.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-55401.stderr?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -0,0 +1,11 @@\n+error: unsatisfied lifetime constraints\n+  --> $DIR/issue-55401.rs:5:5\n+   |\n+LL | fn static_to_a_to_static_through_ref_in_tuple<'a>(x: &'a u32) -> &'static u32 {\n+   |                                               -- lifetime `'a` defined here\n+LL |     let (ref y, _z): (&'a u32, u32) = (&22, 44);\n+LL |     *y //~ ERROR\n+   |     ^^ returning this value requires that `'a` must outlive `'static`\n+\n+error: aborting due to previous error\n+"}, {"sha": "123c26195d006aadda51d2ec790a201e0f905caf", "filename": "src/test/ui/nll/user-annotations/dump-adt-brace-struct.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-adt-brace-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-adt-brace-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-adt-brace-struct.stderr?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -1,4 +1,4 @@\n-error: user substs: Canonical { max_universe: U0, variables: [], value: UserSubsts { substs: [u32], user_self_ty: None } }\n+error: user substs: UserSubsts { substs: [u32], user_self_ty: None }\n   --> $DIR/dump-adt-brace-struct.rs:18:5\n    |\n LL |     SomeStruct::<u32> { t: 22 }; //~ ERROR [u32]"}, {"sha": "a1a4e43e8a3e9484fc08fab35368d9b2ad313b87", "filename": "src/test/ui/nll/user-annotations/dump-fn-method.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-fn-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-fn-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-fn-method.stderr?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -1,22 +1,22 @@\n-error: user substs: Canonical { max_universe: U0, variables: [], value: UserSubsts { substs: [u32], user_self_ty: None } }\n+error: user substs: UserSubsts { substs: [u32], user_self_ty: None }\n   --> $DIR/dump-fn-method.rs:26:13\n    |\n LL |     let x = foo::<u32>; //~ ERROR [u32]\n    |             ^^^^^^^^^^\n \n-error: user substs: Canonical { max_universe: U0, variables: [CanonicalVarInfo { kind: Ty(General(U0)) }, CanonicalVarInfo { kind: Ty(General(U0)) }], value: UserSubsts { substs: [^0, u32, ^1], user_self_ty: None } }\n+error: user substs: UserSubsts { substs: [^0, u32, ^1], user_self_ty: None }\n   --> $DIR/dump-fn-method.rs:32:13\n    |\n LL |     let x = <_ as Bazoom<u32>>::method::<_>; //~ ERROR [^0, u32, ^1]\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: user substs: Canonical { max_universe: U0, variables: [], value: UserSubsts { substs: [u8, u16, u32], user_self_ty: None } }\n+error: user substs: UserSubsts { substs: [u8, u16, u32], user_self_ty: None }\n   --> $DIR/dump-fn-method.rs:36:13\n    |\n LL |     let x = <u8 as Bazoom<u16>>::method::<u32>; //~ ERROR [u8, u16, u32]\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: user substs: Canonical { max_universe: U0, variables: [CanonicalVarInfo { kind: Ty(General(U0)) }, CanonicalVarInfo { kind: Ty(General(U0)) }], value: UserSubsts { substs: [^0, ^1, u32], user_self_ty: None } }\n+error: user substs: UserSubsts { substs: [^0, ^1, u32], user_self_ty: None }\n   --> $DIR/dump-fn-method.rs:44:5\n    |\n LL |     y.method::<u32>(44, 66); //~ ERROR [^0, ^1, u32]"}, {"sha": "f8a2f1cc7e6c9d2e6035f529dc831b875f5a1ef6", "filename": "src/test/ui/parser/issue-23620-invalid-escapes.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fparser%2Fissue-23620-invalid-escapes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fparser%2Fissue-23620-invalid-escapes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-23620-invalid-escapes.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -35,4 +35,7 @@ fn main() {\n     //~^ ERROR invalid character in numeric character escape:\n     //~^^ ERROR form of character escape may only be used with characters in the range [\\x00-\\x7f]\n     //~^^^ ERROR incorrect unicode escape sequence\n+\n+    let _ = \"\\u8f\";\n+    //~^ ERROR incorrect unicode escape sequence\n }"}, {"sha": "f6e476ab0cd1d12e62a49f169013cafa8587af85", "filename": "src/test/ui/parser/issue-23620-invalid-escapes.stderr", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fparser%2Fissue-23620-invalid-escapes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fparser%2Fissue-23620-invalid-escapes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-23620-invalid-escapes.stderr?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -16,7 +16,7 @@ error: incorrect unicode escape sequence\n LL |     let _ = b'/u';\n    |               ^^\n    |\n-help: format of unicode escape sequences is `/u{\u2026}`\n+help: format of unicode escape sequences is `/u{...}`\n   --> $DIR/issue-23620-invalid-escapes.rs:10:15\n    |\n LL |     let _ = b'/u';\n@@ -82,7 +82,7 @@ error: incorrect unicode escape sequence\n LL |     let _ = b\"/u{a4a4} /xf /u\";\n    |                            ^^\n    |\n-help: format of unicode escape sequences is `/u{\u2026}`\n+help: format of unicode escape sequences is `/u{...}`\n   --> $DIR/issue-23620-invalid-escapes.rs:28:28\n    |\n LL |     let _ = b\"/u{a4a4} /xf /u\";\n@@ -112,11 +112,19 @@ error: incorrect unicode escape sequence\n LL |     let _ = \"/xf /u\";\n    |                  ^^\n    |\n-help: format of unicode escape sequences is `/u{\u2026}`\n+help: format of unicode escape sequences is `/u{...}`\n   --> $DIR/issue-23620-invalid-escapes.rs:34:18\n    |\n LL |     let _ = \"/xf /u\";\n    |                  ^^\n \n-error: aborting due to 17 previous errors\n+error: incorrect unicode escape sequence\n+  --> $DIR/issue-23620-invalid-escapes.rs:39:14\n+   |\n+LL |     let _ = \"/u8f\";\n+   |              ^^--\n+   |              |\n+   |              help: format of unicode escape sequences uses braces: `/u{8f}`\n+\n+error: aborting due to 18 previous errors\n "}, {"sha": "591e9df81eb0b7ce8d1d6b58923bde60f26aa47d", "filename": "src/test/ui/privacy/associated-item-privacy-type-binding.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fprivacy%2Fassociated-item-privacy-type-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fprivacy%2Fassociated-item-privacy-type-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fassociated-item-privacy-type-binding.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -9,19 +9,19 @@ mod priv_trait {\n \n     pub macro mac1() {\n         let _: Box<PubTr<AssocTy = u8>>;\n-        //~^ ERROR type `(dyn priv_trait::PubTr<AssocTy=u8> + '<empty>)` is private\n-        //~| ERROR type `(dyn priv_trait::PubTr<AssocTy=u8> + '<empty>)` is private\n+        //~^ ERROR trait `priv_trait::PrivTr` is private\n+        //~| ERROR trait `priv_trait::PrivTr` is private\n         type InSignatureTy2 = Box<PubTr<AssocTy = u8>>;\n-        //~^ ERROR type `(dyn priv_trait::PubTr<AssocTy=u8> + 'static)` is private\n+        //~^ ERROR trait `priv_trait::PrivTr` is private\n         trait InSignatureTr2: PubTr<AssocTy = u8> {}\n         //~^ ERROR trait `priv_trait::PrivTr` is private\n     }\n     pub macro mac2() {\n         let _: Box<PrivTr<AssocTy = u8>>;\n-        //~^ ERROR type `(dyn priv_trait::PrivTr<AssocTy=u8> + '<empty>)` is private\n-        //~| ERROR type `(dyn priv_trait::PrivTr<AssocTy=u8> + '<empty>)` is private\n+        //~^ ERROR trait `priv_trait::PrivTr` is private\n+        //~| ERROR trait `priv_trait::PrivTr` is private\n         type InSignatureTy1 = Box<PrivTr<AssocTy = u8>>;\n-        //~^ ERROR type `(dyn priv_trait::PrivTr<AssocTy=u8> + 'static)` is private\n+        //~^ ERROR trait `priv_trait::PrivTr` is private\n         trait InSignatureTr1: PrivTr<AssocTy = u8> {}\n         //~^ ERROR trait `priv_trait::PrivTr` is private\n     }"}, {"sha": "7f6886d7f9ad446e17b6dbda3cf5e44a5ad0198b", "filename": "src/test/ui/privacy/associated-item-privacy-type-binding.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fprivacy%2Fassociated-item-privacy-type-binding.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fprivacy%2Fassociated-item-privacy-type-binding.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fassociated-item-privacy-type-binding.stderr?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -1,4 +1,4 @@\n-error: type `(dyn priv_trait::PubTr<AssocTy=u8> + '<empty>)` is private\n+error: trait `priv_trait::PrivTr` is private\n   --> $DIR/associated-item-privacy-type-binding.rs:11:13\n    |\n LL |         let _: Box<PubTr<AssocTy = u8>>;\n@@ -7,7 +7,7 @@ LL |         let _: Box<PubTr<AssocTy = u8>>;\n LL |     priv_trait::mac1!();\n    |     -------------------- in this macro invocation\n \n-error: type `(dyn priv_trait::PubTr<AssocTy=u8> + '<empty>)` is private\n+error: trait `priv_trait::PrivTr` is private\n   --> $DIR/associated-item-privacy-type-binding.rs:11:16\n    |\n LL |         let _: Box<PubTr<AssocTy = u8>>;\n@@ -16,7 +16,7 @@ LL |         let _: Box<PubTr<AssocTy = u8>>;\n LL |     priv_trait::mac1!();\n    |     -------------------- in this macro invocation\n \n-error: type `(dyn priv_trait::PubTr<AssocTy=u8> + 'static)` is private\n+error: trait `priv_trait::PrivTr` is private\n   --> $DIR/associated-item-privacy-type-binding.rs:14:31\n    |\n LL |         type InSignatureTy2 = Box<PubTr<AssocTy = u8>>;\n@@ -34,7 +34,7 @@ LL |         trait InSignatureTr2: PubTr<AssocTy = u8> {}\n LL |     priv_trait::mac1!();\n    |     -------------------- in this macro invocation\n \n-error: type `(dyn priv_trait::PrivTr<AssocTy=u8> + '<empty>)` is private\n+error: trait `priv_trait::PrivTr` is private\n   --> $DIR/associated-item-privacy-type-binding.rs:20:13\n    |\n LL |         let _: Box<PrivTr<AssocTy = u8>>;\n@@ -43,7 +43,7 @@ LL |         let _: Box<PrivTr<AssocTy = u8>>;\n LL |     priv_trait::mac2!();\n    |     -------------------- in this macro invocation\n \n-error: type `(dyn priv_trait::PrivTr<AssocTy=u8> + '<empty>)` is private\n+error: trait `priv_trait::PrivTr` is private\n   --> $DIR/associated-item-privacy-type-binding.rs:20:16\n    |\n LL |         let _: Box<PrivTr<AssocTy = u8>>;\n@@ -52,7 +52,7 @@ LL |         let _: Box<PrivTr<AssocTy = u8>>;\n LL |     priv_trait::mac2!();\n    |     -------------------- in this macro invocation\n \n-error: type `(dyn priv_trait::PrivTr<AssocTy=u8> + 'static)` is private\n+error: trait `priv_trait::PrivTr` is private\n   --> $DIR/associated-item-privacy-type-binding.rs:23:31\n    |\n LL |         type InSignatureTy1 = Box<PrivTr<AssocTy = u8>>;"}, {"sha": "a3e53bdf45de3f6a95540c1b625de4af2ce49bda", "filename": "src/test/ui/privacy/private-in-public-expr-pat.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-expr-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-expr-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-expr-pat.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -0,0 +1,13 @@\n+// Patterns and expressions are not interface parts and don't produce private-in-public errors.\n+\n+// compile-pass\n+\n+struct Priv1(usize);\n+struct Priv2;\n+\n+pub struct Pub(Priv2);\n+\n+pub fn public_expr(_: [u8; Priv1(0).0]) {} // OK\n+pub fn public_pat(Pub(Priv2): Pub) {} // OK\n+\n+fn main() {}"}, {"sha": "02fd92aa7a4ef95573d8ba68605b0bb030bbc644", "filename": "src/test/ui/privacy/private-in-public-non-principal-2.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-non-principal-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-non-principal-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-non-principal-2.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -0,0 +1,13 @@\n+#![feature(optin_builtin_traits)]\n+\n+#[allow(private_in_public)]\n+mod m {\n+    pub trait PubPrincipal {}\n+    auto trait PrivNonPrincipal {}\n+    pub fn leak_dyn_nonprincipal() -> Box<PubPrincipal + PrivNonPrincipal> { loop {} }\n+}\n+\n+fn main() {\n+    m::leak_dyn_nonprincipal();\n+    //~^ ERROR trait `m::PrivNonPrincipal` is private\n+}"}, {"sha": "2db49257226424fad138f7520313007411104320", "filename": "src/test/ui/privacy/private-in-public-non-principal-2.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-non-principal-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-non-principal-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-non-principal-2.stderr?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -0,0 +1,8 @@\n+error: trait `m::PrivNonPrincipal` is private\n+  --> $DIR/private-in-public-non-principal-2.rs:11:5\n+   |\n+LL |     m::leak_dyn_nonprincipal();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "5de5a685208cde885035827d35f66bf92231836a", "filename": "src/test/ui/privacy/private-in-public-non-principal.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-non-principal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-non-principal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-non-principal.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -0,0 +1,20 @@\n+#![feature(optin_builtin_traits)]\n+\n+pub trait PubPrincipal {}\n+auto trait PrivNonPrincipal {}\n+\n+pub fn leak_dyn_nonprincipal() -> Box<PubPrincipal + PrivNonPrincipal> { loop {} }\n+//~^ WARN private trait `PrivNonPrincipal` in public interface\n+//~| WARN this was previously accepted\n+\n+#[deny(missing_docs)]\n+fn container() {\n+    impl dyn PubPrincipal {\n+        pub fn check_doc_lint() {} //~ ERROR missing documentation for a method\n+    }\n+    impl dyn PubPrincipal + PrivNonPrincipal {\n+        pub fn check_doc_lint() {} // OK, no missing doc lint\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "996740558977709fb5c5f8402c337aa7e9c4845e", "filename": "src/test/ui/privacy/private-in-public-non-principal.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-non-principal.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-non-principal.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-non-principal.stderr?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -0,0 +1,24 @@\n+warning: private trait `PrivNonPrincipal` in public interface (error E0445)\n+  --> $DIR/private-in-public-non-principal.rs:6:1\n+   |\n+LL | pub fn leak_dyn_nonprincipal() -> Box<PubPrincipal + PrivNonPrincipal> { loop {} }\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: #[warn(private_in_public)] on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #34537 <https://github.com/rust-lang/rust/issues/34537>\n+\n+error: missing documentation for a method\n+  --> $DIR/private-in-public-non-principal.rs:13:9\n+   |\n+LL |         pub fn check_doc_lint() {} //~ ERROR missing documentation for a method\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: lint level defined here\n+  --> $DIR/private-in-public-non-principal.rs:10:8\n+   |\n+LL | #[deny(missing_docs)]\n+   |        ^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "29f365b69be4df85230ecca05fb7de164e10d540", "filename": "src/test/ui/privacy/private-in-public-warn.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-warn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-warn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-warn.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -213,6 +213,15 @@ mod aliases_pub {\n     impl PrivUseAliasTr for <Priv as PrivTr>::AssocAlias {\n         type Check = Priv; //~ ERROR private type `aliases_pub::Priv` in public interface\n     }\n+    impl PrivUseAliasTr for Option<<Priv as PrivTr>::AssocAlias> {\n+        type Check = Priv; //~ ERROR private type `aliases_pub::Priv` in public interface\n+    }\n+    impl PrivUseAliasTr for (<Priv as PrivTr>::AssocAlias, Priv) {\n+        type Check = Priv; // OK\n+    }\n+    impl PrivUseAliasTr for Option<(<Priv as PrivTr>::AssocAlias, Priv)> {\n+        type Check = Priv; // OK\n+    }\n }\n \n mod aliases_priv {"}, {"sha": "8f9e7cd74f9926008e8741e806a63e750efcbc34", "filename": "src/test/ui/privacy/private-in-public-warn.stderr", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-warn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-warn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-warn.stderr?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -297,33 +297,42 @@ LL |     struct Priv;\n LL |         type Check = Priv; //~ ERROR private type `aliases_pub::Priv` in public interface\n    |         ^^^^^^^^^^^^^^^^^^ can't leak private type\n \n+error[E0446]: private type `aliases_pub::Priv` in public interface\n+  --> $DIR/private-in-public-warn.rs:217:9\n+   |\n+LL |     struct Priv;\n+   |     - `aliases_pub::Priv` declared as private\n+...\n+LL |         type Check = Priv; //~ ERROR private type `aliases_pub::Priv` in public interface\n+   |         ^^^^^^^^^^^^^^^^^^ can't leak private type\n+\n error: private trait `aliases_priv::PrivTr1` in public interface (error E0445)\n-  --> $DIR/private-in-public-warn.rs:238:5\n+  --> $DIR/private-in-public-warn.rs:247:5\n    |\n LL |     pub trait Tr1: PrivUseAliasTr {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #34537 <https://github.com/rust-lang/rust/issues/34537>\n \n-error: private type `aliases_priv::Priv2` in public interface (error E0446)\n-  --> $DIR/private-in-public-warn.rs:241:5\n+error: private trait `aliases_priv::PrivTr1<aliases_priv::Priv2>` in public interface (error E0445)\n+  --> $DIR/private-in-public-warn.rs:250:5\n    |\n LL |     pub trait Tr2: PrivUseAliasTr<PrivAlias> {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #34537 <https://github.com/rust-lang/rust/issues/34537>\n \n-error: private trait `aliases_priv::PrivTr1<aliases_priv::Priv2>` in public interface (error E0445)\n-  --> $DIR/private-in-public-warn.rs:241:5\n+error: private type `aliases_priv::Priv2` in public interface (error E0446)\n+  --> $DIR/private-in-public-warn.rs:250:5\n    |\n LL |     pub trait Tr2: PrivUseAliasTr<PrivAlias> {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #34537 <https://github.com/rust-lang/rust/issues/34537>\n \n-error: aborting due to 35 previous errors\n+error: aborting due to 36 previous errors\n \n For more information about this error, try `rustc --explain E0446`."}, {"sha": "08c00f44f22690e8a1cade0344eb3c86867f7d89", "filename": "src/test/ui/privacy/private-in-public.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -102,7 +102,7 @@ mod aliases_pub {\n \n     // This should be OK, but associated type aliases are not substituted yet\n     pub fn f3(arg: <Priv as PrivTr>::Assoc) {}\n-    //~^ ERROR private type `<aliases_pub::Priv as aliases_pub::PrivTr>::Assoc` in public interface\n+    //~^ ERROR private trait `aliases_pub::PrivTr` in public interface\n     //~| ERROR private type `aliases_pub::Priv` in public interface\n \n     impl PrivUseAlias {\n@@ -131,7 +131,7 @@ mod aliases_priv {\n     pub fn f1(arg: PrivUseAlias) {} //~ ERROR private type `aliases_priv::Priv1` in public interface\n     pub fn f2(arg: PrivAlias) {} //~ ERROR private type `aliases_priv::Priv2` in public interface\n     pub fn f3(arg: <Priv as PrivTr>::Assoc) {}\n-    //~^ ERROR private type `<aliases_priv::Priv as aliases_priv::PrivTr>::Assoc` in public\n+    //~^ ERROR private trait `aliases_priv::PrivTr` in public interface\n     //~| ERROR private type `aliases_priv::Priv` in public interface\n }\n "}, {"sha": "bf88a83e633cc82227b36647f04d5b6baaddae61", "filename": "src/test/ui/privacy/private-in-public.stderr", "status": "modified", "additions": 36, "deletions": 6, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public.stderr?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -82,24 +82,36 @@ LL |         pub fn f2() -> Priv { panic!() } //~ ERROR private type `types::Pri\n error[E0445]: private trait `traits::PrivTr` in public interface\n   --> $DIR/private-in-public.rs:31:5\n    |\n+LL |     trait PrivTr {}\n+   |     - `traits::PrivTr` declared as private\n+...\n LL |     pub enum E<T: PrivTr> { V(T) } //~ ERROR private trait `traits::PrivTr` in public interface\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private trait\n \n error[E0445]: private trait `traits::PrivTr` in public interface\n   --> $DIR/private-in-public.rs:32:5\n    |\n+LL |     trait PrivTr {}\n+   |     - `traits::PrivTr` declared as private\n+...\n LL |     pub fn f<T: PrivTr>(arg: T) {} //~ ERROR private trait `traits::PrivTr` in public interface\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private trait\n \n error[E0445]: private trait `traits::PrivTr` in public interface\n   --> $DIR/private-in-public.rs:33:5\n    |\n+LL |     trait PrivTr {}\n+   |     - `traits::PrivTr` declared as private\n+...\n LL |     pub struct S1<T: PrivTr>(T); //~ ERROR private trait `traits::PrivTr` in public interface\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private trait\n \n error[E0445]: private trait `traits::PrivTr` in public interface\n   --> $DIR/private-in-public.rs:34:5\n    |\n+LL |       trait PrivTr {}\n+   |       - `traits::PrivTr` declared as private\n+...\n LL | /     impl<T: PrivTr> Pub<T> { //~ ERROR private trait `traits::PrivTr` in public interface\n LL | |         pub fn f<U: PrivTr>(arg: U) {} //~ ERROR private trait `traits::PrivTr` in public interface\n LL | |     }\n@@ -108,30 +120,45 @@ LL | |     }\n error[E0445]: private trait `traits::PrivTr` in public interface\n   --> $DIR/private-in-public.rs:35:9\n    |\n+LL |     trait PrivTr {}\n+   |     - `traits::PrivTr` declared as private\n+...\n LL |         pub fn f<U: PrivTr>(arg: U) {} //~ ERROR private trait `traits::PrivTr` in public interface\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private trait\n \n error[E0445]: private trait `traits_where::PrivTr` in public interface\n   --> $DIR/private-in-public.rs:44:5\n    |\n+LL |     trait PrivTr {}\n+   |     - `traits_where::PrivTr` declared as private\n+...\n LL |     pub enum E<T> where T: PrivTr { V(T) }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private trait\n \n error[E0445]: private trait `traits_where::PrivTr` in public interface\n   --> $DIR/private-in-public.rs:46:5\n    |\n+LL |     trait PrivTr {}\n+   |     - `traits_where::PrivTr` declared as private\n+...\n LL |     pub fn f<T>(arg: T) where T: PrivTr {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private trait\n \n error[E0445]: private trait `traits_where::PrivTr` in public interface\n   --> $DIR/private-in-public.rs:48:5\n    |\n+LL |     trait PrivTr {}\n+   |     - `traits_where::PrivTr` declared as private\n+...\n LL |     pub struct S1<T>(T) where T: PrivTr;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private trait\n \n error[E0445]: private trait `traits_where::PrivTr` in public interface\n   --> $DIR/private-in-public.rs:50:5\n    |\n+LL |       trait PrivTr {}\n+   |       - `traits_where::PrivTr` declared as private\n+...\n LL | /     impl<T> Pub<T> where T: PrivTr {\n LL | |     //~^ ERROR private trait `traits_where::PrivTr` in public interface\n LL | |         pub fn f<U>(arg: U) where U: PrivTr {}\n@@ -142,6 +169,9 @@ LL | |     }\n error[E0445]: private trait `traits_where::PrivTr` in public interface\n   --> $DIR/private-in-public.rs:52:9\n    |\n+LL |     trait PrivTr {}\n+   |     - `traits_where::PrivTr` declared as private\n+...\n LL |         pub fn f<U>(arg: U) where U: PrivTr {}\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private trait\n \n@@ -181,14 +211,14 @@ LL |     struct Priv;\n LL |         pub fn f(arg: Priv) {} //~ ERROR private type `impls::Priv` in public interface\n    |         ^^^^^^^^^^^^^^^^^^^^^^ can't leak private type\n \n-error[E0446]: private type `<aliases_pub::Priv as aliases_pub::PrivTr>::Assoc` in public interface\n+error[E0445]: private trait `aliases_pub::PrivTr` in public interface\n   --> $DIR/private-in-public.rs:104:5\n    |\n LL |     trait PrivTr {\n-   |     - `<aliases_pub::Priv as aliases_pub::PrivTr>::Assoc` declared as private\n+   |     - `aliases_pub::PrivTr` declared as private\n ...\n LL |     pub fn f3(arg: <Priv as PrivTr>::Assoc) {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private type\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private trait\n \n error[E0446]: private type `aliases_pub::Priv` in public interface\n   --> $DIR/private-in-public.rs:104:5\n@@ -226,14 +256,14 @@ LL |     struct Priv2;\n LL |     pub fn f2(arg: PrivAlias) {} //~ ERROR private type `aliases_priv::Priv2` in public interface\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private type\n \n-error[E0446]: private type `<aliases_priv::Priv as aliases_priv::PrivTr>::Assoc` in public interface\n+error[E0445]: private trait `aliases_priv::PrivTr` in public interface\n   --> $DIR/private-in-public.rs:133:5\n    |\n LL |     trait PrivTr {\n-   |     - `<aliases_priv::Priv as aliases_priv::PrivTr>::Assoc` declared as private\n+   |     - `aliases_priv::PrivTr` declared as private\n ...\n LL |     pub fn f3(arg: <Priv as PrivTr>::Assoc) {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private type\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private trait\n \n error[E0446]: private type `aliases_priv::Priv` in public interface\n   --> $DIR/private-in-public.rs:133:5"}, {"sha": "69b60a56c67f1c8313f02a896c3c3979c94c05b7", "filename": "src/test/ui/privacy/private-inferred-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -119,7 +119,7 @@ fn main() {\n     m::leak_anon2(); //~ ERROR type `m::Priv` is private\n     m::leak_anon3(); //~ ERROR type `m::Priv` is private\n \n-    m::leak_dyn1(); //~ ERROR type `(dyn m::Trait + 'static)` is private\n+    m::leak_dyn1(); //~ ERROR trait `m::Trait` is private\n     m::leak_dyn2(); //~ ERROR type `m::Priv` is private\n     m::leak_dyn3(); //~ ERROR type `m::Priv` is private\n "}, {"sha": "80a475f7dceea2266002e1897d0d930768aa09e0", "filename": "src/test/ui/privacy/private-inferred-type.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type.stderr?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -160,10 +160,10 @@ error: type `m::Priv` is private\n LL |     m::leak_anon3(); //~ ERROR type `m::Priv` is private\n    |     ^^^^^^^^^^^^^^^\n \n-error: type `(dyn m::Trait + 'static)` is private\n+error: trait `m::Trait` is private\n   --> $DIR/private-inferred-type.rs:122:5\n    |\n-LL |     m::leak_dyn1(); //~ ERROR type `(dyn m::Trait + 'static)` is private\n+LL |     m::leak_dyn1(); //~ ERROR trait `m::Trait` is private\n    |     ^^^^^^^^^^^^^^\n \n error: type `m::Priv` is private"}, {"sha": "91a0d8590ff341e92ff00efaeda65f9dc511f717", "filename": "src/test/ui/regions/regions-outlives-projection-container-wc.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -31,9 +31,7 @@ fn with_assoc<'a,'b>() {\n     // outlive 'a. In this case, that means TheType<'b>::TheAssocType,\n     // which is &'b (), must outlive 'a.\n \n-    // FIXME (#54943) NLL doesn't enforce WF condition in unreachable code if\n-    // `_x` is changed to `_`\n-    let _x: &'a WithAssoc<TheType<'b>> = loop { };\n+    let _: &'a WithAssoc<TheType<'b>> = loop { };\n     //~^ ERROR reference has a longer lifetime\n }\n "}, {"sha": "0d73d3d64322e0e69e0631d7cb7930819a4dac24", "filename": "src/test/ui/regions/regions-outlives-projection-container-wc.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.stderr?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -1,8 +1,8 @@\n error[E0491]: in type `&'a WithAssoc<TheType<'b>>`, reference has a longer lifetime than the data it references\n-  --> $DIR/regions-outlives-projection-container-wc.rs:36:13\n+  --> $DIR/regions-outlives-projection-container-wc.rs:34:12\n    |\n-LL |     let _x: &'a WithAssoc<TheType<'b>> = loop { };\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     let _: &'a WithAssoc<TheType<'b>> = loop { };\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: the pointer is valid for the lifetime 'a as defined on the function body at 28:15\n   --> $DIR/regions-outlives-projection-container-wc.rs:28:15"}, {"sha": "bed9076d84cbe9d0ed33f89678338cc3d452fde2", "filename": "src/test/ui/rmeta_meta_main.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Frmeta_meta_main.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Frmeta_meta_main.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frmeta_meta_main.stderr?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -2,7 +2,7 @@ error[E0560]: struct `rmeta_meta::Foo` has no field named `field2`\n   --> $DIR/rmeta_meta_main.rs:13:19\n    |\n LL |     let _ = Foo { field2: 42 }; //~ ERROR struct `rmeta_meta::Foo` has no field named `field2`\n-   |                   ^^^^^^ field does not exist - did you mean `field`?\n+   |                   ^^^^^^ help: a field with a similar name exists: `field`\n \n error: aborting due to previous error\n "}, {"sha": "1a88f269347c2daeacbe3e3f3700577b2e535327", "filename": "src/test/ui/structs/struct-fields-hints-no-dupe.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fstructs%2Fstruct-fields-hints-no-dupe.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fstructs%2Fstruct-fields-hints-no-dupe.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs%2Fstruct-fields-hints-no-dupe.stderr?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -2,7 +2,7 @@ error[E0560]: struct `A` has no field named `bar`\n   --> $DIR/struct-fields-hints-no-dupe.rs:10:9\n    |\n LL |         bar : 42,\n-   |         ^^^ field does not exist - did you mean `barr`?\n+   |         ^^^ help: a field with a similar name exists: `barr`\n \n error: aborting due to previous error\n "}, {"sha": "3b8a2b5c7bad01c7de8d95525d467b29dfc27bd3", "filename": "src/test/ui/structs/struct-fields-hints.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fstructs%2Fstruct-fields-hints.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fstructs%2Fstruct-fields-hints.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs%2Fstruct-fields-hints.stderr?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -2,7 +2,7 @@ error[E0560]: struct `A` has no field named `bar`\n   --> $DIR/struct-fields-hints.rs:10:9\n    |\n LL |         bar : 42,\n-   |         ^^^ field does not exist - did you mean `car`?\n+   |         ^^^ help: a field with a similar name exists: `car`\n \n error: aborting due to previous error\n "}, {"sha": "0e9b2ae5145d7233f3e44151283d48d0b651dc78", "filename": "src/test/ui/structs/struct-fields-typo.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fstructs%2Fstruct-fields-typo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fstructs%2Fstruct-fields-typo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs%2Fstruct-fields-typo.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -8,7 +8,8 @@ fn main() {\n         foo: 0,\n         bar: 0.5,\n     };\n-    let x = foo.baa;//~ no field `baa` on type `BuildData`\n-    //~^ did you mean `bar`?\n+    let x = foo.baa; //~ ERROR no field `baa` on type `BuildData`\n+                     //~| HELP a field with a similar name exists\n+                     //~| SUGGESTION bar\n     println!(\"{}\", x);\n }"}, {"sha": "c2fab714f7c156117db2ad0d45ca3be13ab9f398", "filename": "src/test/ui/structs/struct-fields-typo.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fstructs%2Fstruct-fields-typo.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fstructs%2Fstruct-fields-typo.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs%2Fstruct-fields-typo.stderr?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -1,8 +1,8 @@\n error[E0609]: no field `baa` on type `BuildData`\n   --> $DIR/struct-fields-typo.rs:11:17\n    |\n-LL |     let x = foo.baa;//~ no field `baa` on type `BuildData`\n-   |                 ^^^ did you mean `bar`?\n+LL |     let x = foo.baa; //~ ERROR no field `baa` on type `BuildData`\n+   |                 ^^^ help: a field with a similar name exists: `bar`\n \n error: aborting due to previous error\n "}, {"sha": "524558e0ec564233b8e9b24f06752b48fe023df4", "filename": "src/test/ui/suggestions/suggest-private-fields.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-private-fields.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-private-fields.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-private-fields.stderr?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -2,7 +2,7 @@ error[E0560]: struct `xc::B` has no field named `aa`\n   --> $DIR/suggest-private-fields.rs:15:9\n    |\n LL |         aa: 20,\n-   |         ^^ field does not exist - did you mean `a`?\n+   |         ^^ help: a field with a similar name exists: `a`\n \n error[E0560]: struct `xc::B` has no field named `bb`\n   --> $DIR/suggest-private-fields.rs:17:9\n@@ -16,13 +16,13 @@ error[E0560]: struct `A` has no field named `aa`\n   --> $DIR/suggest-private-fields.rs:22:9\n    |\n LL |         aa: 20,\n-   |         ^^ field does not exist - did you mean `a`?\n+   |         ^^ help: a field with a similar name exists: `a`\n \n error[E0560]: struct `A` has no field named `bb`\n   --> $DIR/suggest-private-fields.rs:24:9\n    |\n LL |         bb: 20,\n-   |         ^^ field does not exist - did you mean `b`?\n+   |         ^^ help: a field with a similar name exists: `b`\n \n error: aborting due to 4 previous errors\n "}, {"sha": "a1bcdfaedbc602bf04b6df4bda2c042ebd4cf057", "filename": "src/test/ui/tuple/tuple-index-not-tuple.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Ftuple%2Ftuple-index-not-tuple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Ftuple%2Ftuple-index-not-tuple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftuple%2Ftuple-index-not-tuple.stderr?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -2,7 +2,7 @@ error[E0609]: no field `0` on type `Point`\n   --> $DIR/tuple-index-not-tuple.rs:6:12\n    |\n LL |     origin.0;\n-   |            ^ did you mean `x`?\n+   |            ^ help: a field with a similar name exists: `x`\n \n error[E0609]: no field `0` on type `Empty`\n   --> $DIR/tuple-index-not-tuple.rs:8:11"}, {"sha": "7d7c5cd7892ea0b0147a1ac0eb0d26559846c86f", "filename": "src/test/ui/tuple/tuple-index-out-of-bounds.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Ftuple%2Ftuple-index-out-of-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Ftuple%2Ftuple-index-out-of-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftuple%2Ftuple-index-out-of-bounds.stderr?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -2,7 +2,7 @@ error[E0609]: no field `2` on type `Point`\n   --> $DIR/tuple-index-out-of-bounds.rs:7:12\n    |\n LL |     origin.2;\n-   |            ^ did you mean `0`?\n+   |            ^ help: a field with a similar name exists: `0`\n \n error[E0609]: no field `2` on type `({integer}, {integer})`\n   --> $DIR/tuple-index-out-of-bounds.rs:12:11"}, {"sha": "b2d8c0efea8fe8c9c4d0b40ef718cf6d686c1245", "filename": "src/test/ui/union/union-suggest-field.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Funion%2Funion-suggest-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Funion%2Funion-suggest-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-suggest-field.rs?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -9,8 +9,12 @@ impl U {\n fn main() {\n     let u = U { principle: 0 };\n     //~^ ERROR union `U` has no field named `principle`\n+    //~| HELP a field with a similar name exists\n+    //~| SUGGESTION principal\n     let w = u.principial; //~ ERROR no field `principial` on type `U`\n-                          //~^ did you mean `principal`?\n+                          //~| HELP a field with a similar name exists\n+                          //~| SUGGESTION principal\n \n     let y = u.calculate; //~ ERROR attempted to take value of method `calculate` on type `U`\n+                         //~| HELP maybe a `()` to call it is missing\n }"}, {"sha": "91d6b30ea026748b2e9266a5fb11d7e6cb35ee62", "filename": "src/test/ui/union/union-suggest-field.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Funion%2Funion-suggest-field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/20e0395e66557a1be055ec3f11c35082bf9a5882/src%2Ftest%2Fui%2Funion%2Funion-suggest-field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-suggest-field.stderr?ref=20e0395e66557a1be055ec3f11c35082bf9a5882", "patch": "@@ -2,16 +2,16 @@ error[E0560]: union `U` has no field named `principle`\n   --> $DIR/union-suggest-field.rs:10:17\n    |\n LL |     let u = U { principle: 0 };\n-   |                 ^^^^^^^^^ field does not exist - did you mean `principal`?\n+   |                 ^^^^^^^^^ help: a field with a similar name exists: `principal`\n \n error[E0609]: no field `principial` on type `U`\n-  --> $DIR/union-suggest-field.rs:12:15\n+  --> $DIR/union-suggest-field.rs:14:15\n    |\n LL |     let w = u.principial; //~ ERROR no field `principial` on type `U`\n-   |               ^^^^^^^^^^ did you mean `principal`?\n+   |               ^^^^^^^^^^ help: a field with a similar name exists: `principal`\n \n error[E0615]: attempted to take value of method `calculate` on type `U`\n-  --> $DIR/union-suggest-field.rs:15:15\n+  --> $DIR/union-suggest-field.rs:18:15\n    |\n LL |     let y = u.calculate; //~ ERROR attempted to take value of method `calculate` on type `U`\n    |               ^^^^^^^^^"}]}