{"sha": "db020ab63cd51dd4a25cba2d00117f016128762b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiMDIwYWI2M2NkNTFkZDRhMjVjYmEyZDAwMTE3ZjAxNjEyODc2MmI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-07-11T22:00:40Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-07-17T22:46:43Z"}, "message": "rustc: Implement and enforce instance coherence", "tree": {"sha": "2b6f1e99ba4356f3e3bf5338332c278d2a85109b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b6f1e99ba4356f3e3bf5338332c278d2a85109b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db020ab63cd51dd4a25cba2d00117f016128762b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db020ab63cd51dd4a25cba2d00117f016128762b", "html_url": "https://github.com/rust-lang/rust/commit/db020ab63cd51dd4a25cba2d00117f016128762b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db020ab63cd51dd4a25cba2d00117f016128762b/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5729bd60095fb5ca884936775e031cf19900760", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5729bd60095fb5ca884936775e031cf19900760", "html_url": "https://github.com/rust-lang/rust/commit/b5729bd60095fb5ca884936775e031cf19900760"}], "stats": {"total": 2260, "additions": 1740, "deletions": 520}, "files": [{"sha": "443d4dda020cd9087170217cf86252bdab3e12c5", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -11,7 +11,7 @@ import result::{ok, err};\n import io::writer_util;\n import std::{map, json, tempfile, term, sort, getopts};\n import map::hashmap;\n-import json::to_str;\n+import to_str::to_str;\n import getopts::{optflag, optopt, opt_present};\n \n type package = {\n@@ -535,7 +535,7 @@ fn load_one_source_package(src: source, p: map::hashmap<~str, json::json>) {\n         versions: ~[]\n     };\n \n-    alt src.packages.position(|pkg| pkg.uuid == uuid ) {\n+    alt vec::position(src.packages, |pkg| pkg.uuid == uuid) {\n       some(idx) {\n         src.packages[idx] = newpkg;\n         log(debug, ~\"  updated package: \" + src.name + ~\"/\" + name);"}, {"sha": "07dac5270b0c85944c9b6be0f4cdd0d1628601de", "filename": "src/libcore/core.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibcore%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibcore%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -5,12 +5,15 @@\n import option::{some, none};\n import option = option::option;\n import path = path::path;\n-import str::extensions;\n import tuple::extensions;\n+import str::{extensions, str_slice, unique_str};\n import vec::extensions;\n+import vec::{const_vector, copyable_vector, immutable_vector};\n+import vec::{immutable_copyable_vector, iter_trait_extensions, vec_concat};\n+import iter::{base_iter, extended_iter, copyable_iter, times};\n import option::extensions;\n import option_iter::extensions;\n-import ptr::extensions;\n+import ptr::{extensions, ptr};\n import rand::extensions;\n import result::extensions;\n import int::{num, times};\n@@ -26,11 +29,18 @@ import u64::{num, times};\n import float::num;\n import f32::num;\n import f64::num;\n+import num::num;\n \n export path, option, some, none, unreachable;\n export extensions;\n // The following exports are the extension impls for numeric types\n export num, times;\n+// The following exports are the common traits\n+export str_slice, unique_str;\n+export const_vector, copyable_vector, immutable_vector;\n+export immutable_copyable_vector, iter_trait_extensions, vec_concat;\n+export base_iter, copyable_iter, extended_iter;\n+export ptr;\n \n // Export the log levels as global constants. Higher levels mean\n // more-verbosity. Error is the bottom level, default logging level is"}, {"sha": "d9fb3dae846a7a5c16b336cfb729e7b1bccf0993", "filename": "src/libcore/int-template.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibcore%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibcore%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -233,6 +233,7 @@ fn test_ifaces() {\n \n #[test]\n fn test_times() {\n+    import iter::times;\n     let ten = 10 as T;\n     let mut accum = 0;\n     for ten.times { accum += 1; }\n@@ -243,5 +244,6 @@ fn test_times() {\n #[should_fail]\n #[ignore(cfg(windows))]\n fn test_times_negative() {\n+    import iter::times;\n     for (-10).times { log(error, ~\"nope!\"); }\n }"}, {"sha": "e31824d066dcc6424f941d883c12ce611aec4805", "filename": "src/libcore/iter-trait.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibcore%2Fiter-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibcore%2Fiter-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -8,6 +8,9 @@ export extensions;\n impl extensions<A> of iter::base_iter<A> for IMPL_T<A> {\n     fn each(blk: fn(A) -> bool) { EACH(self, blk) }\n     fn size_hint() -> option<uint> { SIZE_HINT(self) }\n+}\n+\n+impl extensions<A> of iter::extended_iter<A> for IMPL_T<A> {\n     fn eachi(blk: fn(uint, A) -> bool) { iter::eachi(self, blk) }\n     fn all(blk: fn(A) -> bool) -> bool { iter::all(self, blk) }\n     fn any(blk: fn(A) -> bool) -> bool { iter::any(self, blk) }"}, {"sha": "2e0c778cd5a41c2f541437adf929bf90972a0328", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -3,6 +3,16 @@ iface base_iter<A> {\n     fn size_hint() -> option<uint>;\n }\n \n+trait extended_iter<A> {\n+    fn eachi(blk: fn(uint, A) -> bool);\n+    fn all(blk: fn(A) -> bool) -> bool;\n+    fn any(blk: fn(A) -> bool) -> bool;\n+    fn foldl<B>(+b0: B, blk: fn(B, A) -> B) -> B;\n+    fn contains(x: A) -> bool;\n+    fn count(x: A) -> uint;\n+    fn position(f: fn(A) -> bool) -> option<uint>;\n+}\n+\n iface times {\n     fn times(it: fn() -> bool);\n }"}, {"sha": "2b9794987ee0187a60ff00c9aefc167947e641f3", "filename": "src/libcore/option.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -92,6 +92,7 @@ pure fn iter<T>(opt: option<T>, f: fn(T)) {\n     alt opt { none { } some(t) { f(t); } }\n }\n \n+#[inline(always)]\n pure fn unwrap<T>(-opt: option<T>) -> T {\n     /*!\n      * Moves a value out of an option type and returns it."}, {"sha": "33f5fe958a505f7c428577a1537e16980be72b15", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -578,7 +578,11 @@ impl<T: send> of selectable for pipes::port<T> {\n \n type shared_chan<T: send> = arc::exclusive<pipes::chan<T>>;\n \n-impl chan<T: send> for shared_chan<T> {\n+trait send_on_shared_chan<T> {\n+    fn send(+x: T);\n+}\n+\n+impl chan<T: send> of send_on_shared_chan<T> for shared_chan<T> {\n     fn send(+x: T) {\n         let mut xx = some(x);\n         do self.with |_c, chan| {"}, {"sha": "ba98fb3c119f75c294ca58a5fbb27c3bb772d8d4", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -14,6 +14,7 @@ export memset;\n export buf_len;\n export position;\n export extensions;\n+export ptr;\n \n import libc::{c_void, size_t};\n "}, {"sha": "7e83e7aa0ee70d008f3a57eb18ab9d7ad77356a4", "filename": "src/libcore/str.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -106,7 +106,9 @@ export\n    escape_unicode,\n \n    unsafe,\n-   extensions;\n+   extensions,\n+   str_slice,\n+   unique_str;\n \n #[abi = \"cdecl\"]\n extern mod rustrt {"}, {"sha": "4f35f1a8756eece426f9c5247ab6745a50219e15", "filename": "src/libcore/uint-template.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibcore%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibcore%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -278,6 +278,7 @@ fn to_str_radix17() {\n \n #[test]\n fn test_times() {\n+    import iter::times;\n     let ten = 10 as T;\n     let mut accum = 0;\n     for ten.times { accum += 1; }"}, {"sha": "1dd4ef5ae43e9e586ffe3124cfc98e1ca3f13387", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -85,6 +85,12 @@ export unpack_const_slice;\n export unsafe;\n export u8;\n export extensions;\n+export const_vector;\n+export copyable_vector;\n+export immutable_vector;\n+export immutable_copyable_vector;\n+export iter_trait_extensions;\n+export vec_concat;\n \n #[abi = \"cdecl\"]\n extern mod rustrt {\n@@ -179,11 +185,12 @@ pure fn len<T>(&&v: &[const T]) -> uint {\n  * Creates an immutable vector of size `n_elts` and initializes the elements\n  * to the value returned by the function `op`.\n  */\n-pure fn from_fn<T>(n_elts: uint, op: init_op<T>) -> ~[T] {\n+pure fn from_fn<T: copy>(n_elts: uint, op: init_op<T>) -> ~[T] {\n     let mut v = ~[];\n     unchecked{reserve(v, n_elts);}\n     let mut i: uint = 0u;\n-    while i < n_elts unsafe { push(v, op(i)); i += 1u; }\n+    while i < n_elts unsafe { ref_set(v, i, op(i)); i += 1u; }\n+    unsafe { unsafe::set_len(v, n_elts); }\n     ret v;\n }\n \n@@ -197,8 +204,9 @@ pure fn from_elem<T: copy>(n_elts: uint, t: T) -> ~[T] {\n     let mut v = ~[];\n     unchecked{reserve(v, n_elts)}\n     let mut i: uint = 0u;\n-    unsafe { // because push is impure\n-        while i < n_elts { push(v, t); i += 1u; }\n+    unsafe { // because ref_set is unsafe\n+        while i < n_elts { ref_set(v, i, t); i += 1u; }\n+        unsafe { unsafe::set_len(v, n_elts); }\n     }\n     ret v;\n }\n@@ -468,6 +476,16 @@ unsafe fn ref<T: copy>(v: &[const T], i: uint) -> T {\n     unpack_slice(v, |p, _len| *ptr::offset(p, i))\n }\n \n+#[inline(always)]\n+unsafe fn ref_set<T: copy>(v: &[mut T], i: uint, +val: T) {\n+    let mut box = some(val);\n+    do unpack_mut_slice(v) |p, _len| {\n+        let mut box2 = none;\n+        box2 <-> box;\n+        rusti::move_val_init(*ptr::mut_offset(p, i), option::unwrap(box2));\n+    }\n+}\n+\n #[inline(always)]\n fn push_all<T: copy>(&v: ~[const T], rhs: &[const T]) {\n     reserve(v, v.len() + rhs.len());\n@@ -1591,6 +1609,9 @@ mod u8 {\n impl extensions/&<A> of iter::base_iter<A> for &[const A] {\n     fn each(blk: fn(A) -> bool) { each(self, blk) }\n     fn size_hint() -> option<uint> { some(len(self)) }\n+}\n+\n+impl extensions/&<A> of iter::extended_iter<A> for &[const A] {\n     fn eachi(blk: fn(uint, A) -> bool) { iter::eachi(self, blk) }\n     fn all(blk: fn(A) -> bool) -> bool { iter::all(self, blk) }\n     fn any(blk: fn(A) -> bool) -> bool { iter::any(self, blk) }\n@@ -1599,6 +1620,7 @@ impl extensions/&<A> of iter::base_iter<A> for &[const A] {\n     }\n     fn contains(x: A) -> bool { iter::contains(self, x) }\n     fn count(x: A) -> uint { iter::count(self, x) }\n+    fn position(f: fn(A) -> bool) -> option<uint> { iter::position(self, f) }\n }\n \n trait iter_trait_extensions<A> {"}, {"sha": "2df720e6fe1b228b89b8004316a3904401f25e58", "filename": "src/libstd/arena.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibstd%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibstd%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farena.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -6,7 +6,12 @@ import list;\n import list::{list, cons, nil};\n \n type chunk = {data: ~[u8], mut fill: uint};\n-type arena = {mut chunks: @list<@chunk>};\n+\n+type arena_ = {mut chunks: @list<@chunk>};\n+\n+enum arena {\n+    arena_(arena_)\n+}\n \n fn chunk(size: uint) -> @chunk {\n     let mut v = ~[];\n@@ -15,7 +20,7 @@ fn chunk(size: uint) -> @chunk {\n }\n \n fn arena_with_size(initial_size: uint) -> arena {\n-    ret {mut chunks: @cons(chunk(initial_size), @nil)};\n+    ret arena_({mut chunks: @cons(chunk(initial_size), @nil)});\n }\n \n fn arena() -> arena {"}, {"sha": "07f578901fdbad0bc0f86769868e17bcfbdf1803", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -155,7 +155,11 @@ fn doc_as_i32(d: doc) -> i32 { doc_as_u32(d) as i32 }\n fn doc_as_i64(d: doc) -> i64 { doc_as_u64(d) as i64 }\n \n // ebml writing\n-type writer = {writer: io::writer, mut size_positions: ~[uint]};\n+type writer_ = {writer: io::writer, mut size_positions: ~[uint]};\n+\n+enum writer {\n+    writer_(writer_)\n+}\n \n fn write_sized_vuint(w: io::writer, n: uint, size: uint) {\n     alt size {\n@@ -187,7 +191,7 @@ fn write_vuint(w: io::writer, n: uint) {\n \n fn writer(w: io::writer) -> writer {\n     let size_positions: ~[uint] = ~[];\n-    ret {writer: w, mut size_positions: size_positions};\n+    ret writer_({writer: w, mut size_positions: size_positions});\n }\n \n // FIXME (#2741): Provide a function to write the standard ebml header.\n@@ -311,9 +315,12 @@ enum ebml_serializer_tag {\n     es_label // Used only when debugging\n }\n \n-impl serializer of serialization::serializer for ebml::writer {\n-    fn emit_nil() {}\n+trait serializer_priv {\n+    fn _emit_tagged_uint(t: ebml_serializer_tag, v: uint);\n+    fn _emit_label(label: ~str);\n+}\n \n+impl serializer of serializer_priv for ebml::writer {\n     // used internally to emit things like the vector length and so on\n     fn _emit_tagged_uint(t: ebml_serializer_tag, v: uint) {\n         assert v <= 0xFFFF_FFFF_u;\n@@ -329,6 +336,10 @@ impl serializer of serialization::serializer for ebml::writer {\n         // try and check failures more quickly.\n         if debug { self.wr_tagged_str(es_label as uint, label) }\n     }\n+}\n+\n+impl serializer of serialization::serializer for ebml::writer {\n+    fn emit_nil() {}\n \n     fn emit_uint(v: uint) { self.wr_tagged_u64(es_uint as uint, v as u64); }\n     fn emit_u64(v: u64) { self.wr_tagged_u64(es_u64 as uint, v); }\n@@ -383,14 +394,18 @@ impl serializer of serialization::serializer for ebml::writer {\n     fn emit_tup_elt(_idx: uint, f: fn()) { f() }\n }\n \n-type ebml_deserializer = {mut parent: ebml::doc,\n-                          mut pos: uint};\n+type ebml_deserializer_ = {mut parent: ebml::doc,\n+                           mut pos: uint};\n+\n+enum ebml_deserializer {\n+    ebml_deserializer_(ebml_deserializer_)\n+}\n \n fn ebml_deserializer(d: ebml::doc) -> ebml_deserializer {\n-    {mut parent: d, mut pos: d.start}\n+    ebml_deserializer_({mut parent: d, mut pos: d.start})\n }\n \n-impl deserializer of serialization::deserializer for ebml_deserializer {\n+impl deserializer_priv for ebml_deserializer {\n     fn _check_label(lbl: ~str) {\n         if self.pos < self.parent.end {\n             let {tag: r_tag, doc: r_doc} =\n@@ -443,7 +458,9 @@ impl deserializer of serialization::deserializer for ebml_deserializer {\n         #debug[\"_next_uint exp_tag=%? result=%?\", exp_tag, r];\n         ret r as uint;\n     }\n+}\n \n+impl deserializer of serialization::deserializer for ebml_deserializer {\n     fn read_nil() -> () { () }\n \n     fn read_u64() -> u64 { ebml::doc_as_u64(self.next_doc(es_u64)) }"}, {"sha": "74707e36a51afabe8f1c658e49d080f767943ad3", "filename": "src/libstd/json.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -8,6 +8,7 @@ import io;\n import io::{reader_util, writer_util};\n import map;\n import map::hashmap;\n+import map::map;\n import core::vec::extensions;\n \n export json;\n@@ -114,13 +115,17 @@ fn to_str(j: json) -> ~str {\n     io::with_str_writer(|wr| to_writer(wr, j))\n }\n \n-type parser = {\n+type parser_ = {\n     rdr: io::reader,\n     mut ch: char,\n     mut line: uint,\n     mut col: uint,\n };\n \n+enum parser {\n+    parser_(parser_)\n+}\n+\n impl parser for parser {\n     fn eof() -> bool { self.ch == -1 as char }\n \n@@ -463,12 +468,12 @@ impl parser for parser {\n \n /// Deserializes a json value from an io::reader\n fn from_reader(rdr: io::reader) -> result<json, error> {\n-    let parser = {\n+    let parser = parser_({\n         rdr: rdr,\n         mut ch: rdr.read_char(),\n         mut line: 1u,\n         mut col: 1u,\n-    };\n+    });\n \n     parser.parse()\n }"}, {"sha": "c285bc06629036537542bb2f9e728328073a1f3d", "filename": "src/libstd/map.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -92,13 +92,19 @@ mod chained {\n         absent\n     }\n \n-    type t<K, V> = @{\n+    type hashmap__<K, V> = {\n         mut count: uint,\n         mut chains: ~[mut chain<K,V>],\n         hasher: hashfn<K>,\n         eqer: eqfn<K>\n     };\n \n+    enum hashmap_<K, V> {\n+        hashmap_(@hashmap__<K, V>)\n+    }\n+\n+    type t<K, V> = hashmap_<K, V>;\n+\n     enum search_result<K, V> {\n         not_found,\n         found_first(uint, @entry<K,V>),\n@@ -284,10 +290,10 @@ mod chained {\n     }\n \n     fn mk<K, V: copy>(hasher: hashfn<K>, eqer: eqfn<K>) -> t<K,V> {\n-        let slf: t<K, V> = @{mut count: 0u,\n-                             mut chains: chains(initial_capacity),\n-                             hasher: hasher,\n-                             eqer: eqer};\n+        let slf: t<K, V> = hashmap_(@{mut count: 0u,\n+                                      mut chains: chains(initial_capacity),\n+                                      hasher: hasher,\n+                                      eqer: eqer});\n         slf\n     }\n }"}, {"sha": "f79a95d8ab50f47a18fc13126f862c50e327dd15", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -148,7 +148,12 @@ mod v4 {\n     // the simple, old style numberic representation of\n     // ipv4\n     type ipv4_rep = { a: u8, b: u8, c: u8, d:u8 };\n-    impl x for ipv4_rep {\n+\n+    trait as_unsafe_u32 {\n+        unsafe fn as_u32() -> u32;\n+    }\n+\n+    impl x of as_unsafe_u32 for ipv4_rep {\n         // this is pretty dastardly, i know\n         unsafe fn as_u32() -> u32 {\n             *((ptr::addr_of(self)) as *u32)"}, {"sha": "c7dc2d0cdab481a0f203ab352e4ed1cc244e1e46", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -11,6 +11,7 @@ import future::extensions;\n import result::*;\n import libc::size_t;\n import str::extensions;\n+import io::{reader, writer};\n \n // tcp interfaces\n export tcp_socket;"}, {"sha": "ed9cf5570ce96d0d81090d95d8df7fc7a16b3bb5", "filename": "src/libstd/serialization.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibstd%2Fserialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibstd%2Fserialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialization.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -101,13 +101,21 @@ fn read_to_vec<D: deserializer, T: copy>(d: D, f: fn() -> T) -> ~[T] {\n     }\n }\n \n-impl serializer_helpers<S: serializer> for S {\n+trait serializer_helpers {\n+    fn emit_from_vec<T>(v: ~[T], f: fn(T));\n+}\n+\n+impl serializer_helpers<S: serializer> of serializer_helpers for S {\n     fn emit_from_vec<T>(v: ~[T], f: fn(T)) {\n         emit_from_vec(self, v, f)\n     }\n }\n \n-impl deserializer_helpers<D: deserializer> for D {\n+trait deserializer_helpers {\n+    fn read_to_vec<T: copy>(f: fn() -> T) -> ~[T];\n+}\n+\n+impl deserializer_helpers<D: deserializer> of deserializer_helpers for D {\n     fn read_to_vec<T: copy>(f: fn() -> T) -> ~[T] {\n         read_to_vec(self, f)\n     }"}, {"sha": "112a55ab67d85e49576ffc977f21b1ad4c199cb1", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -5,14 +5,19 @@\n import core::option;\n import core::option::{some, none};\n import dvec::{dvec, extensions};\n+import map::map;\n \n // FIXME (#2347): Should not be @; there's a bug somewhere in rustc that\n // requires this to be.\n-type smallintmap<T: copy> = @{v: dvec<option<T>>};\n+type smallintmap_<T: copy> = {v: dvec<option<T>>};\n+\n+enum smallintmap<T:copy> {\n+    smallintmap_(@smallintmap_<T>)\n+}\n \n /// Create a smallintmap\n fn mk<T: copy>() -> smallintmap<T> {\n-    ret @{v: dvec()};\n+    ret smallintmap_(@{v: dvec()});\n }\n \n /**"}, {"sha": "8680719c9b9082afd69fa9a02604c2caa0df8348", "filename": "src/libstd/time.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -65,7 +65,7 @@ fn tzset() {\n     rustrt::rust_tzset();\n }\n \n-type tm = {\n+type tm_ = {\n     tm_sec: i32, // seconds after the minute ~[0-60]\n     tm_min: i32, // minutes after the hour ~[0-59]\n     tm_hour: i32, // hours after midnight ~[0-23]\n@@ -80,8 +80,12 @@ type tm = {\n     tm_nsec: i32, // nanoseconds\n };\n \n+enum tm {\n+    tm_(tm_)\n+}\n+\n fn empty_tm() -> tm {\n-    {\n+    tm_({\n         tm_sec: 0_i32,\n         tm_min: 0_i32,\n         tm_hour: 0_i32,\n@@ -94,7 +98,7 @@ fn empty_tm() -> tm {\n         tm_gmtoff: 0_i32,\n         tm_zone: ~\"\",\n         tm_nsec: 0_i32,\n-    }\n+    })\n }\n \n /// Returns the specified time in UTC\n@@ -563,7 +567,7 @@ fn strptime(s: ~str, format: ~str) -> result<tm, ~str> {\n         }\n \n         if pos == len && rdr.eof() {\n-            ok({\n+            ok(tm_({\n                 tm_sec: tm.tm_sec,\n                 tm_min: tm.tm_min,\n                 tm_hour: tm.tm_hour,\n@@ -576,7 +580,7 @@ fn strptime(s: ~str, format: ~str) -> result<tm, ~str> {\n                 tm_gmtoff: tm.tm_gmtoff,\n                 tm_zone: tm.tm_zone,\n                 tm_nsec: tm.tm_nsec,\n-            })\n+            }))\n         } else { result }\n     }\n }"}, {"sha": "37e8671facd329a05fae061221850614aad5ffde", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -306,7 +306,13 @@ pure fn class_member_visibility(ci: @class_member) -> visibility {\n   }\n }\n \n-impl inlined_item_methods for inlined_item {\n+trait inlined_item_utils {\n+    fn ident() -> ident;\n+    fn id() -> ast::node_id;\n+    fn accept<E>(e: E, v: visit::vt<E>);\n+}\n+\n+impl inlined_item_methods of inlined_item_utils for inlined_item {\n     fn ident() -> ident {\n         alt self {\n           ii_item(i) { /* FIXME (#2543) */ copy i.ident }"}, {"sha": "c52617c74bf4d8e49bb747443f1d380ab1b39c8e", "filename": "src/libsyntax/ext/auto_serialize.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -123,7 +123,34 @@ fn expand(cx: ext_ctxt,\n     }\n }\n \n-impl helpers for ext_ctxt {\n+trait ext_ctxt_helpers {\n+    fn helper_path(base_path: @ast::path, helper_name: ~str) -> @ast::path;\n+    fn path(span: span, strs: ~[ast::ident]) -> @ast::path;\n+    fn path_tps(span: span, strs: ~[ast::ident],\n+                tps: ~[@ast::ty]) -> @ast::path;\n+    fn ty_path(span: span, strs: ~[ast::ident], tps: ~[@ast::ty]) -> @ast::ty;\n+    fn ty_fn(span: span,\n+             -input_tys: ~[@ast::ty],\n+             -output: @ast::ty) -> @ast::ty;\n+    fn ty_nil(span: span) -> @ast::ty;\n+    fn expr(span: span, node: ast::expr_) -> @ast::expr;\n+    fn var_ref(span: span, name: ast::ident) -> @ast::expr;\n+    fn blk(span: span, stmts: ~[@ast::stmt]) -> ast::blk;\n+    fn expr_blk(expr: @ast::expr) -> ast::blk;\n+    fn binder_pat(span: span, nm: ast::ident) -> @ast::pat;\n+    fn stmt(expr: @ast::expr) -> @ast::stmt;\n+    fn alt_stmt(arms: ~[ast::arm], span: span, -v: @ast::expr) -> @ast::stmt;\n+    fn lit_str(span: span, s: @~str) -> @ast::expr;\n+    fn lit_uint(span: span, i: uint) -> @ast::expr;\n+    fn lambda(blk: ast::blk) -> @ast::expr;\n+    fn clone_folder() -> fold::ast_fold;\n+    fn clone(v: @ast::expr) -> @ast::expr;\n+    fn clone_ty(v: @ast::ty) -> @ast::ty;\n+    fn clone_ty_param(v: ast::ty_param) -> ast::ty_param;\n+    fn at(span: span, expr: @ast::expr) -> @ast::expr;\n+}\n+\n+impl helpers of ext_ctxt_helpers for ext_ctxt {\n     fn helper_path(base_path: @ast::path,\n                    helper_name: ~str) -> @ast::path {\n         let head = vec::init(base_path.idents);"}, {"sha": "58f421524373e3b783e75f69bffea67836f919f0", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 47, "deletions": 5, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -28,18 +28,29 @@ fn path(id: ident) -> @ast::path {\n       types: ~[]}\n }\n \n-impl methods for ident {\n+trait path_concat {\n+    fn +(id: ident) -> @ast::path;\n+}\n+\n+impl methods of path_concat for ident {\n     fn +(id: ident) -> @ast::path {\n         path(self) + id\n     }\n }\n \n-impl methods for @ast::path {\n+impl methods of path_concat for @ast::path {\n     fn +(id: ident) -> @ast::path {\n         @{idents: vec::append_one(self.idents, id)\n           with *self}\n     }\n+}\n+\n+trait append_types {\n+    fn add_ty(ty: @ast::ty) -> @ast::path;\n+    fn add_tys(+tys: ~[@ast::ty]) -> @ast::path;\n+}\n \n+impl methods of append_types for @ast::path {\n     fn add_ty(ty: @ast::ty) -> @ast::path {\n         @{types: vec::append_one(self.types, ty)\n           with *self}\n@@ -51,7 +62,38 @@ impl methods for @ast::path {\n     }\n }\n \n-impl ast_builder for ext_ctxt {\n+trait ext_ctxt_ast_builder {\n+    fn ty_param(id: ast::ident, +bounds: ~[ast::ty_param_bound])\n+        -> ast::ty_param;\n+    fn arg(name: ident, ty: @ast::ty) -> ast::arg;\n+    fn arg_mode(name: ident, ty: @ast::ty, mode: ast::rmode) -> ast::arg;\n+    fn expr_block(e: @ast::expr) -> ast::blk;\n+    fn fn_decl(+inputs: ~[ast::arg], output: @ast::ty) -> ast::fn_decl;\n+    fn item(name: ident, +node: ast::item_) -> @ast::item;\n+    fn item_fn_poly(name: ident,\n+                    +inputs: ~[ast::arg],\n+                    output: @ast::ty,\n+                    +ty_params: ~[ast::ty_param],\n+                    +body: ast::blk) -> @ast::item;\n+    fn item_fn(name: ident,\n+               +inputs: ~[ast::arg],\n+               output: @ast::ty,\n+               +body: ast::blk) -> @ast::item;\n+    fn item_enum_poly(name: ident,\n+                      +variants: ~[ast::variant],\n+                      +ty_params: ~[ast::ty_param]) -> @ast::item;\n+    fn item_enum(name: ident, +variants: ~[ast::variant]) -> @ast::item;\n+    fn variant(name: ident, +tys: ~[@ast::ty]) -> ast::variant;\n+    fn item_mod(name: ident, +items: ~[@ast::item]) -> @ast::item;\n+    fn ty_path_ast_builder(path: @ast::path) -> @ast::ty;\n+    fn item_ty_poly(name: ident,\n+                    ty: @ast::ty,\n+                    +params: ~[ast::ty_param]) -> @ast::item;\n+    fn item_ty(name: ident, ty: @ast::ty) -> @ast::item;\n+    fn ty_vars(+ty_params: ~[ast::ty_param]) -> ~[@ast::ty];\n+}\n+\n+impl ast_builder of ext_ctxt_ast_builder for ext_ctxt {\n     fn ty_param(id: ast::ident, +bounds: ~[ast::ty_param_bound])\n         -> ast::ty_param\n     {\n@@ -153,7 +195,7 @@ impl ast_builder for ext_ctxt {\n                       items: items}))\n     }\n \n-    fn ty_path(path: @ast::path) -> @ast::ty {\n+    fn ty_path_ast_builder(path: @ast::path) -> @ast::ty {\n         // FIXME #2886: make sure the node ids are legal.\n         @{id: self.next_id(),\n           node: ast::ty_path(path, self.next_id()),\n@@ -177,6 +219,6 @@ impl ast_builder for ext_ctxt {\n     }\n \n     fn ty_vars(+ty_params: ~[ast::ty_param]) -> ~[@ast::ty] {\n-        ty_params.map(|p| self.ty_path(path(p.ident)))\n+        ty_params.map(|p| self.ty_path_ast_builder(path(p.ident)))\n     }\n }"}, {"sha": "091eaf697bb4a83c51295b1bcc5df37c6392c668", "filename": "src/libsyntax/ext/pipes/parse_proto.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -6,7 +6,12 @@ import parse::token;\n \n import pipec::*;\n \n-impl proto_parser for parser {\n+trait proto_parser {\n+    fn parse_proto(id: ident) -> protocol;\n+    fn parse_state(proto: protocol);\n+}\n+\n+impl proto_parser of proto_parser for parser {\n     fn parse_proto(id: ident) -> protocol {\n         let proto = protocol(id);\n "}, {"sha": "eab2c58e50eaa8ec27f948b61b84d65e462d19cb", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 33, "deletions": 6, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -15,9 +15,9 @@ import pprust::{item_to_str, ty_to_str};\n import ext::base::{mk_ctxt, ext_ctxt};\n import parse;\n import parse::*;\n-\n import proto::*;\n \n+import ast_builder::append_types;\n import ast_builder::ast_builder;\n import ast_builder::methods;\n import ast_builder::path;\n@@ -38,7 +38,7 @@ impl compile for message {\n \n             let args_ast = vec::append(\n                 ~[cx.arg_mode(@~\"pipe\",\n-                              cx.ty_path(path(this.data_name())\n+                              cx.ty_path_ast_builder(path(this.data_name())\n                                         .add_tys(cx.ty_vars(this.ty_params))),\n                               ast::by_copy)],\n                 args_ast);\n@@ -64,7 +64,7 @@ impl compile for message {\n \n             cx.item_fn_poly(self.name(),\n                             args_ast,\n-                            cx.ty_path(path(next.data_name())\n+                            cx.ty_path_ast_builder(path(next.data_name())\n                                       .add_tys(next_tys)),\n                             self.get_params(),\n                             cx.expr_block(body))\n@@ -110,6 +110,11 @@ impl compile for message {\n           }\n         }\n     }\n+\n+    fn to_ty(cx: ext_ctxt) -> @ast::ty {\n+        cx.ty_path_ast_builder(path(self.name)\n+          .add_tys(cx.ty_vars(self.ty_params)))\n+    }\n }\n \n impl compile for state {\n@@ -169,9 +174,9 @@ impl compile for state {\n         vec::push(items,\n                   cx.item_ty_poly(\n                       self.data_name(),\n-                      cx.ty_path(\n+                      cx.ty_path_ast_builder(\n                           (@~\"pipes\" + @(dir.to_str() + ~\"_packet\"))\n-                          .add_ty(cx.ty_path(\n+                          .add_ty(cx.ty_path_ast_builder(\n                               (self.proto.name + self.data_name())\n                               .add_tys(cx.ty_vars(self.ty_params))))),\n                       self.ty_params));\n@@ -266,7 +271,12 @@ impl of to_source for @ast::expr {\n     }\n }\n \n-impl parse_utils for ext_ctxt {\n+trait ext_ctxt_parse_utils {\n+    fn parse_item(s: ~str) -> @ast::item;\n+    fn parse_expr(s: ~str) -> @ast::expr;\n+}\n+\n+impl parse_utils of ext_ctxt_parse_utils for ext_ctxt {\n     fn parse_item(s: ~str) -> @ast::item {\n         let res = parse::parse_item_from_source_str(\n             ~\"***protocol expansion***\",\n@@ -292,3 +302,20 @@ impl parse_utils for ext_ctxt {\n             self.parse_sess())\n     }\n }\n+\n+trait two_vector_utils<A, B> {\n+    fn zip() -> ~[(A, B)];\n+    fn map<C>(f: fn(A, B) -> C) -> ~[C];\n+}\n+\n+impl methods<A: copy, B: copy> of two_vector_utils<A, B> for (~[A], ~[B]) {\n+    fn zip() -> ~[(A, B)] {\n+        let (a, b) = self;\n+        vec::zip(a, b)\n+    }\n+\n+    fn map<C>(f: fn(A, B) -> C) -> ~[C] {\n+        let (a, b) = self;\n+        vec::map2(a, b, f)\n+    }\n+}"}, {"sha": "152b92a4b53b9948de1b8ae71483c60b1b430bf1", "filename": "src/libsyntax/ext/tt/earley_parser.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibsyntax%2Fext%2Ftt%2Fearley_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibsyntax%2Fext%2Ftt%2Fearley_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fearley_parser.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -60,6 +60,7 @@ fn count_names(ms: &[matcher]) -> uint {\n         }})\n }\n \n+#[warn(no_non_implicitly_copyable_typarams)]\n fn new_matcher_pos(ms: ~[matcher], sep: option<token>, lo: uint)\n     -> matcher_pos {\n     ~{elts: ms, sep: sep, mut idx: 0u, mut up: matcher_pos_up(none),"}, {"sha": "fb28f9526293054cac34b52bafb54ba2797b1632", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -9,7 +9,21 @@ export parser_attr;\n // extensions, which both begin with token.POUND\n type attr_or_ext = option<either<~[ast::attribute], @ast::expr>>;\n \n-impl parser_attr for parser {\n+trait parser_attr {\n+    fn parse_outer_attrs_or_ext(first_item_attrs: ~[ast::attribute])\n+        -> attr_or_ext;\n+    fn parse_outer_attributes() -> ~[ast::attribute];\n+    fn parse_attribute(style: ast::attr_style) -> ast::attribute;\n+    fn parse_attribute_naked(style: ast::attr_style, lo: uint) ->\n+        ast::attribute;\n+    fn parse_inner_attrs_and_next() ->\n+        {inner: ~[ast::attribute], next: ~[ast::attribute]};\n+    fn parse_meta_item() -> @ast::meta_item;\n+    fn parse_meta_seq() -> ~[@ast::meta_item];\n+    fn parse_optional_meta() -> ~[@ast::meta_item];\n+}\n+\n+impl parser_attr of parser_attr for parser {\n \n     fn parse_outer_attrs_or_ext(first_item_attrs: ~[ast::attribute])\n         -> attr_or_ext"}, {"sha": "9126bbb3be4d4ea3bfe491b3d38175e78ee723f6", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 37, "deletions": 2, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -22,9 +22,44 @@ fn token_to_str(reader: reader, ++token: token::token) -> ~str {\n     token::to_str(*reader.interner(), token)\n }\n \n-// This should be done with traits, once traits work\n-impl parser_common for parser {\n+trait parser_common {\n+    fn unexpected_last(t: token::token) -> !;\n+    fn unexpected() -> !;\n+    fn expect(t: token::token);\n+    fn parse_ident() -> ast::ident;\n+    fn parse_path_list_ident() -> ast::path_list_ident;\n+    fn parse_value_ident() -> ast::ident;\n+    fn eat(tok: token::token) -> bool;\n+    // A sanity check that the word we are asking for is a known keyword\n+    fn require_keyword(word: ~str);\n+    fn token_is_keyword(word: ~str, ++tok: token::token) -> bool;\n+    fn is_keyword(word: ~str) -> bool;\n+    fn is_any_keyword(tok: token::token) -> bool;\n+    fn eat_keyword(word: ~str) -> bool;\n+    fn expect_keyword(word: ~str);\n+    fn is_restricted_keyword(word: ~str) -> bool;\n+    fn check_restricted_keywords();\n+    fn check_restricted_keywords_(w: ~str);\n+    fn expect_gt();\n+    fn parse_seq_to_before_gt<T: copy>(sep: option<token::token>,\n+                                       f: fn(parser) -> T) -> ~[T];\n+    fn parse_seq_to_gt<T: copy>(sep: option<token::token>,\n+                                f: fn(parser) -> T) -> ~[T];\n+    fn parse_seq_lt_gt<T: copy>(sep: option<token::token>,\n+                                f: fn(parser) -> T) -> spanned<~[T]>;\n+    fn parse_seq_to_end<T: copy>(ket: token::token, sep: seq_sep,\n+                                 f: fn(parser) -> T) -> ~[T];\n+    fn parse_seq_to_before_end<T: copy>(ket: token::token, sep: seq_sep,\n+                                        f: fn(parser) -> T) -> ~[T];\n+    fn parse_unspanned_seq<T: copy>(bra: token::token,\n+                                    ket: token::token,\n+                                    sep: seq_sep,\n+                                    f: fn(parser) -> T) -> ~[T];\n+    fn parse_seq<T: copy>(bra: token::token, ket: token::token, sep: seq_sep,\n+                          f: fn(parser) -> T) -> spanned<~[T]>;\n+}\n \n+impl parser_common of parser_common for parser {\n     fn unexpected_last(t: token::token) -> ! {\n         self.span_fatal(\n             copy self.last_span,"}, {"sha": "c7687bf2b98cc4af96f5973fc586a691732d4ebf", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -2188,14 +2188,23 @@ class parser {\n         }\n     }\n \n+    fn token_is_pound_or_doc_comment(++tok: token::token) -> bool {\n+        alt tok {\n+            token::POUND | token::DOC_COMMENT(_) { true }\n+            _ { false }\n+        }\n+    }\n+\n     fn parse_single_class_item(vis: visibility)\n         -> @class_member {\n-        if self.eat_keyword(~\"let\") {\n+        if (self.eat_keyword(~\"let\") ||\n+                self.token_is_keyword(~\"mut\", copy self.token) ||\n+                !self.is_any_keyword(copy self.token)) &&\n+                !self.token_is_pound_or_doc_comment(self.token) {\n             let a_var = self.parse_instance_var(vis);\n             self.expect(token::SEMI);\n             ret a_var;\n-        }\n-        else {\n+        } else {\n             let m = self.parse_method(vis);\n             ret @{node: class_method(m), span: m.span};\n         }\n@@ -2510,7 +2519,7 @@ class parser {\n             self.parse_item_trait()\n         } else if self.eat_keyword(~\"impl\") {\n             self.parse_item_impl()\n-        } else if self.eat_keyword(~\"class\") {\n+        } else if self.eat_keyword(~\"class\") || self.eat_keyword(~\"struct\") {\n             self.parse_item_class()\n         } else if !self.is_any_keyword(copy self.token)\n             && self.look_ahead(1) == token::NOT"}, {"sha": "a39b74eaca37094e8c50048cfbc3d5c39bc5cdcf", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -313,8 +313,11 @@ fn restricted_keyword_table() -> hashmap<~str, ()> {\n         ~\"if\", ~\"iface\", ~\"impl\", ~\"import\",\n         ~\"let\", ~\"log\", ~\"loop\",\n         ~\"mod\", ~\"mut\",\n-        ~\"new\", ~\"owned\",\n-        ~\"pure\", ~\"ret\",\n+        ~\"new\",\n+        ~\"owned\",\n+        ~\"pure\",\n+        ~\"ret\",\n+        ~\"struct\",\n         ~\"true\", ~\"trait\", ~\"type\",\n         ~\"unchecked\", ~\"unsafe\",\n         ~\"while\""}, {"sha": "79679279f079147d74e58abb2fb9f180c7261e78", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -103,22 +103,22 @@ fn mk_printer(out: io::writer, linewidth: uint) -> printer {\n     let token: ~[mut token] = vec::to_mut(vec::from_elem(n, EOF));\n     let size: ~[mut int] = vec::to_mut(vec::from_elem(n, 0));\n     let scan_stack: ~[mut uint] = vec::to_mut(vec::from_elem(n, 0u));\n-    @{out: out,\n-      buf_len: n,\n-      mut margin: linewidth as int,\n-      mut space: linewidth as int,\n-      mut left: 0u,\n-      mut right: 0u,\n-      token: token,\n-      size: size,\n-      mut left_total: 0,\n-      mut right_total: 0,\n-      mut scan_stack: scan_stack,\n-      mut scan_stack_empty: true,\n-      mut top: 0u,\n-      mut bottom: 0u,\n-      print_stack: dvec(),\n-      mut pending_indentation: 0}\n+    printer_(@{out: out,\n+               buf_len: n,\n+               mut margin: linewidth as int,\n+               mut space: linewidth as int,\n+               mut left: 0u,\n+               mut right: 0u,\n+               token: token,\n+               size: size,\n+               mut left_total: 0,\n+               mut right_total: 0,\n+               mut scan_stack: scan_stack,\n+               mut scan_stack_empty: true,\n+               mut top: 0u,\n+               mut bottom: 0u,\n+               print_stack: dvec(),\n+               mut pending_indentation: 0})\n }\n \n \n@@ -199,7 +199,7 @@ fn mk_printer(out: io::writer, linewidth: uint) -> printer {\n  * the method called 'pretty_print', and the 'PRINT' process is the method\n  * called 'print'.\n  */\n-type printer = @{\n+type printer_ = {\n     out: io::writer,\n     buf_len: uint,\n     mut margin: int, // width of lines we're constrained to\n@@ -226,6 +226,10 @@ type printer = @{\n     mut pending_indentation: int\n };\n \n+enum printer {\n+    printer_(@printer_)\n+}\n+\n impl printer for printer {\n     fn last_token() -> token { self.token[self.right] }\n     // be very careful with this!"}, {"sha": "0b7b8402970f2259887a20ba9ef9110cbde6d1bc", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -1,6 +1,6 @@\n // -*- rust -*-\n import metadata::{creader, cstore, filesearch};\n-import session::session;\n+import session::{session, session_};\n import syntax::parse;\n import syntax::{ast, codemap};\n import syntax::attr;\n@@ -168,7 +168,10 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n                              session::sess_os_to_meta_os(sess.targ_cfg.os),\n                              sess.opts.static));\n \n-    let { def_map: def_map, exp_map: exp_map, impl_map: impl_map } =\n+    let { def_map: def_map,\n+          exp_map: exp_map,\n+          impl_map: impl_map,\n+          trait_map: trait_map } =\n         time(time_passes, ~\"resolution\", ||\n              middle::resolve3::resolve_crate(sess, ast_map, crate));\n \n@@ -187,6 +190,7 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n     let (method_map, vtable_map) = time(time_passes, ~\"typechecking\", ||\n                                         typeck::check_crate(ty_cx,\n                                                             impl_map,\n+                                                            trait_map,\n                                                             crate));\n \n     time(time_passes, ~\"const checking\", ||\n@@ -516,31 +520,32 @@ fn build_session(sopts: @session::options,\n     build_session_(sopts, codemap, demitter, span_diagnostic_handler)\n }\n \n-fn build_session_(\n-    sopts: @session::options, cm: codemap::codemap,\n-    demitter: diagnostic::emitter,\n-    span_diagnostic_handler: diagnostic::span_handler\n-) -> session {\n+fn build_session_(sopts: @session::options,\n+                  cm: codemap::codemap,\n+                  demitter: diagnostic::emitter,\n+                  span_diagnostic_handler: diagnostic::span_handler)\n+               -> session {\n+\n     let target_cfg = build_target_config(sopts, demitter);\n     let cstore = cstore::mk_cstore();\n     let filesearch = filesearch::mk_filesearch(\n         sopts.maybe_sysroot,\n         sopts.target_triple,\n         sopts.addl_lib_search_paths);\n     let warning_settings = lint::mk_warning_settings();\n-    @{targ_cfg: target_cfg,\n-      opts: sopts,\n-      cstore: cstore,\n-      parse_sess:\n+    session_(@{targ_cfg: target_cfg,\n+               opts: sopts,\n+               cstore: cstore,\n+               parse_sess:\n           parse::new_parse_sess_special_handler(span_diagnostic_handler, cm),\n-      codemap: cm,\n-      // For a library crate, this is always none\n-      mut main_fn: none,\n-      span_diagnostic: span_diagnostic_handler,\n-      filesearch: filesearch,\n-      mut building_library: false,\n-      working_dir: os::getcwd(),\n-      warning_settings: warning_settings}\n+               codemap: cm,\n+               // For a library crate, this is always none\n+               mut main_fn: none,\n+               span_diagnostic: span_diagnostic_handler,\n+               filesearch: filesearch,\n+               mut building_library: false,\n+               working_dir: os::getcwd(),\n+               warning_settings: warning_settings})\n }\n \n fn parse_pretty(sess: session, &&name: ~str) -> pp_mode {"}, {"sha": "c5643c90be36e9279c18e36b69606bbe650d17d9", "filename": "src/rustc/driver/session.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fsession.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -85,7 +85,7 @@ type options =\n \n type crate_metadata = {name: ~str, data: ~[u8]};\n \n-type session = @{targ_cfg: @config,\n+type session_ = {targ_cfg: @config,\n                  opts: @options,\n                  cstore: metadata::cstore::cstore,\n                  parse_sess: parse_sess,\n@@ -98,6 +98,10 @@ type session = @{targ_cfg: @config,\n                  working_dir: ~str,\n                  warning_settings: lint::warning_settings};\n \n+enum session {\n+    session_(@session_)\n+}\n+\n impl session for session {\n     fn span_fatal(sp: span, msg: ~str) -> ! {\n         self.span_diagnostic.span_fatal(sp, msg)"}, {"sha": "56d6dcab1063f937fa62af06e7598ec4baef91bc", "filename": "src/rustc/metadata/csearch.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcsearch.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -10,6 +10,7 @@ import syntax::diagnostic::span_handler;\n import syntax::diagnostic::expect;\n import common::*;\n import std::map::hashmap;\n+import dvec::{dvec, extensions};\n \n export class_dtor;\n export get_symbol;\n@@ -23,6 +24,7 @@ export lookup_method_purity;\n export get_enum_variants;\n export get_impls_for_mod;\n export get_trait_methods;\n+export get_method_names_if_trait;\n export each_path;\n export get_type;\n export get_impl_trait;\n@@ -140,6 +142,13 @@ fn get_trait_methods(tcx: ty::ctxt, def: ast::def_id) -> @~[ty::method] {\n     decoder::get_trait_methods(cdata, def.node, tcx)\n }\n \n+fn get_method_names_if_trait(cstore: cstore::cstore, def: ast::def_id)\n+                          -> option<@dvec<@~str>> {\n+\n+    let cdata = cstore::get_crate_data(cstore, def.crate);\n+    ret decoder::get_method_names_if_trait(cdata, def.node);\n+}\n+\n fn get_class_fields(tcx: ty::ctxt, def: ast::def_id) -> ~[ty::field_ty] {\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);"}, {"sha": "c9b214134a75151e75972d1989fd5c8cd5662dfb", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -2,6 +2,7 @@\n \n import std::{ebml, map};\n import std::map::{hashmap, str_hash};\n+import dvec::{dvec, extensions};\n import io::writer_util;\n import syntax::{ast, ast_util};\n import syntax::attr;\n@@ -37,6 +38,7 @@ export get_crate_hash;\n export get_crate_vers;\n export get_impls_for_mod;\n export get_trait_methods;\n+export get_method_names_if_trait;\n export get_crate_module_paths;\n export def_like;\n export dl_def;\n@@ -640,6 +642,23 @@ fn get_trait_methods(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n     @result\n }\n \n+// If the item in question is a trait, returns its set of methods. Otherwise,\n+// returns none.\n+fn get_method_names_if_trait(cdata: cmd, node_id: ast::node_id)\n+                          -> option<@dvec<@~str>> {\n+\n+    let item = lookup_item(node_id, cdata.data);\n+    if item_family(item) != 'I' {\n+        ret none;\n+    }\n+\n+    let resulting_method_names = @dvec();\n+    do ebml::tagged_docs(item, tag_item_trait_method) |method| {\n+        (*resulting_method_names).push(item_name(method));\n+    }\n+    ret some(resulting_method_names);\n+}\n+\n // Helper function that gets either fields or methods\n fn get_class_members(cdata: cmd, id: ast::node_id,\n                      p: fn(char) -> bool) -> ~[ty::field_ty] {"}, {"sha": "df0d8e97c0cc54c2220d74f90f124bfb4179c0c9", "filename": "src/rustc/middle/astencode.rs", "status": "modified", "additions": 78, "deletions": 15, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fastencode.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -65,12 +65,16 @@ type decode_ctxt = @{\n     maps: maps\n };\n \n-type extended_decode_ctxt = @{\n+type extended_decode_ctxt_ = {\n     dcx: decode_ctxt,\n     from_id_range: ast_util::id_range,\n     to_id_range: ast_util::id_range\n };\n \n+enum extended_decode_ctxt {\n+    extended_decode_ctxt_(@extended_decode_ctxt_)\n+}\n+\n iface tr {\n     fn tr(xcx: extended_decode_ctxt) -> self;\n }\n@@ -112,9 +116,9 @@ fn decode_inlined_item(cdata: cstore::crate_metadata,\n         let ast_dsr = ebml::ebml_deserializer(ast_doc);\n         let from_id_range = ast_util::deserialize_id_range(ast_dsr);\n         let to_id_range = reserve_id_range(dcx.tcx.sess, from_id_range);\n-        let xcx = @{dcx: dcx,\n-                    from_id_range: from_id_range,\n-                    to_id_range: to_id_range};\n+        let xcx = extended_decode_ctxt_(@{dcx: dcx,\n+                                          from_id_range: from_id_range,\n+                                          to_id_range: to_id_range});\n         let raw_ii = decode_ast(ast_doc);\n         let ii = renumber_ast(xcx, raw_ii);\n         ast_map::map_decoded_item(tcx.sess.diagnostic(),\n@@ -182,13 +186,23 @@ impl of tr for span {\n     }\n }\n \n-impl serializer_helpers<S: serializer> for S {\n+trait def_id_serializer_helpers {\n+    fn emit_def_id(did: ast::def_id);\n+}\n+\n+impl serializer_helpers<S: serializer> of def_id_serializer_helpers for S {\n     fn emit_def_id(did: ast::def_id) {\n         ast::serialize_def_id(self, did)\n     }\n }\n \n-impl deserializer_helpers<D: deserializer> for D {\n+trait def_id_deserializer_helpers {\n+    fn read_def_id(xcx: extended_decode_ctxt) -> ast::def_id;\n+}\n+\n+impl deserializer_helpers<D: deserializer> of def_id_deserializer_helpers\n+        for D {\n+\n     fn read_def_id(xcx: extended_decode_ctxt) -> ast::def_id {\n         let did = ast::deserialize_def_id(self);\n         did.tr(xcx)\n@@ -370,7 +384,11 @@ fn encode_freevar_entry(ebml_w: ebml::writer, fv: freevar_entry) {\n     serialize_freevar_entry(ebml_w, fv)\n }\n \n-impl helper for ebml::ebml_deserializer {\n+trait ebml_deserializer_helper {\n+    fn read_freevar_entry(xcx: extended_decode_ctxt) -> freevar_entry;\n+}\n+\n+impl helper of ebml_deserializer_helper for ebml::ebml_deserializer {\n     fn read_freevar_entry(xcx: extended_decode_ctxt) -> freevar_entry {\n         let fv = deserialize_freevar_entry(self);\n         fv.tr(xcx)\n@@ -386,7 +404,11 @@ impl of tr for freevar_entry {\n // ______________________________________________________________________\n // Encoding and decoding of method_map_entry\n \n-impl helper for ebml::ebml_deserializer {\n+trait read_method_map_entry_helper {\n+    fn read_method_map_entry(xcx: extended_decode_ctxt) -> method_map_entry;\n+}\n+\n+impl helper of read_method_map_entry_helper for ebml::ebml_deserializer {\n     fn read_method_map_entry(xcx: extended_decode_ctxt) -> method_map_entry {\n         let mme = deserialize_method_map_entry(self);\n         {derefs: mme.derefs, origin: mme.origin.tr(xcx)}\n@@ -412,7 +434,11 @@ impl of tr for method_origin {\n // ______________________________________________________________________\n // Encoding and decoding of borrow\n \n-impl helper for ebml::ebml_deserializer {\n+trait read_borrow_helper {\n+    fn read_borrow(xcx: extended_decode_ctxt) -> ty::borrow;\n+}\n+\n+impl helper of read_borrow_helper for ebml::ebml_deserializer {\n     fn read_borrow(xcx: extended_decode_ctxt) -> ty::borrow {\n         let borrow = ty::deserialize_borrow(self);\n         {scope_id: xcx.tr_id(borrow.scope_id),\n@@ -478,7 +504,12 @@ fn encode_vtable_origin(ecx: @e::encode_ctxt,\n \n }\n \n-impl helpers for ebml::ebml_deserializer {\n+trait vtable_deserialization_helpers {\n+    fn read_vtable_res(xcx: extended_decode_ctxt) -> typeck::vtable_res;\n+    fn read_vtable_origin(xcx: extended_decode_ctxt) -> typeck::vtable_origin;\n+}\n+\n+impl helpers of vtable_deserialization_helpers for ebml::ebml_deserializer {\n     fn read_vtable_res(xcx: extended_decode_ctxt) -> typeck::vtable_res {\n         @self.read_to_vec(|| self.read_vtable_origin(xcx) )\n     }\n@@ -530,7 +561,11 @@ impl helpers for ebml::ebml_deserializer {\n // ______________________________________________________________________\n // Encoding and decoding the side tables\n \n-impl helpers for @e::encode_ctxt {\n+trait get_ty_str_ctxt {\n+    fn ty_str_ctxt() -> @tyencode::ctxt;\n+}\n+\n+impl helpers of get_ty_str_ctxt for @e::encode_ctxt {\n     fn ty_str_ctxt() -> @tyencode::ctxt {\n         @{diag: self.tcx.sess.diagnostic(),\n           ds: e::def_to_str,\n@@ -540,7 +575,14 @@ impl helpers for @e::encode_ctxt {\n     }\n }\n \n-impl helpers for ebml::writer {\n+trait ebml_writer_helpers {\n+    fn emit_ty(ecx: @e::encode_ctxt, ty: ty::t);\n+    fn emit_tys(ecx: @e::encode_ctxt, tys: ~[ty::t]);\n+    fn emit_bounds(ecx: @e::encode_ctxt, bs: ty::param_bounds);\n+    fn emit_tpbt(ecx: @e::encode_ctxt, tpbt: ty::ty_param_bounds_and_ty);\n+}\n+\n+impl helpers of ebml_writer_helpers for ebml::writer {\n     fn emit_ty(ecx: @e::encode_ctxt, ty: ty::t) {\n         e::write_type(ecx, self, ty)\n     }\n@@ -572,7 +614,12 @@ impl helpers for ebml::writer {\n     }\n }\n \n-impl writer for ebml::writer {\n+trait write_tag_and_id {\n+    fn tag(tag_id: c::astencode_tag, f: fn());\n+    fn id(id: ast::node_id);\n+}\n+\n+impl writer of write_tag_and_id for ebml::writer {\n     fn tag(tag_id: c::astencode_tag, f: fn()) {\n         do self.wr_tag(tag_id as uint) { f() }\n     }\n@@ -724,7 +771,13 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n     }\n }\n \n-impl decoder for ebml::doc {\n+trait doc_decoder_helpers {\n+    fn as_int() -> int;\n+    fn [](tag: c::astencode_tag) -> ebml::doc;\n+    fn opt_child(tag: c::astencode_tag) -> option<ebml::doc>;\n+}\n+\n+impl decoder of doc_decoder_helpers for ebml::doc {\n     fn as_int() -> int { ebml::doc_as_u64(self) as int }\n     fn [](tag: c::astencode_tag) -> ebml::doc {\n         ebml::get_doc(self, tag as uint)\n@@ -734,7 +787,17 @@ impl decoder for ebml::doc {\n     }\n }\n \n-impl decoder for ebml::ebml_deserializer {\n+trait ebml_deserializer_decoder_helpers {\n+    fn read_ty(xcx: extended_decode_ctxt) -> ty::t;\n+    fn read_tys(xcx: extended_decode_ctxt) -> ~[ty::t];\n+    fn read_bounds(xcx: extended_decode_ctxt) -> @~[ty::param_bound];\n+    fn read_ty_param_bounds_and_ty(xcx: extended_decode_ctxt)\n+                                -> ty::ty_param_bounds_and_ty;\n+}\n+\n+impl decoder of ebml_deserializer_decoder_helpers\n+        for ebml::ebml_deserializer {\n+\n     fn read_ty(xcx: extended_decode_ctxt) -> ty::t {\n         // Note: regions types embed local node ids.  In principle, we\n         // should translate these node ids into the new decode"}, {"sha": "4bbbb2bcb6ce79bbf185b7a37d40d78b5024de95", "filename": "src/rustc/middle/borrowck.rs", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -169,17 +169,18 @@ fn check_crate(tcx: ty::ctxt,\n                method_map: typeck::method_map,\n                last_use_map: liveness::last_use_map,\n                crate: @ast::crate) -> (root_map, mutbl_map) {\n-    let bccx = @{tcx: tcx,\n-                 method_map: method_map,\n-                 last_use_map: last_use_map,\n-                 binding_map: int_hash(),\n-                 root_map: root_map(),\n-                 mutbl_map: int_hash(),\n-                 mut loaned_paths_same: 0,\n-                 mut loaned_paths_imm: 0,\n-                 mut stable_paths: 0,\n-                 mut req_pure_paths: 0,\n-                 mut guaranteed_paths: 0};\n+\n+    let bccx = borrowck_ctxt_(@{tcx: tcx,\n+                                method_map: method_map,\n+                                last_use_map: last_use_map,\n+                                binding_map: int_hash(),\n+                                root_map: root_map(),\n+                                mutbl_map: int_hash(),\n+                                mut loaned_paths_same: 0,\n+                                mut loaned_paths_imm: 0,\n+                                mut stable_paths: 0,\n+                                mut req_pure_paths: 0,\n+                                mut guaranteed_paths: 0});\n \n     let req_maps = gather_loans::gather_loans(bccx, crate);\n     check_loans::check_loans(bccx, req_maps, crate);\n@@ -210,7 +211,7 @@ fn check_crate(tcx: ty::ctxt,\n // ----------------------------------------------------------------------\n // Type definitions\n \n-type borrowck_ctxt = @{tcx: ty::ctxt,\n+type borrowck_ctxt_ = {tcx: ty::ctxt,\n                        method_map: typeck::method_map,\n                        last_use_map: liveness::last_use_map,\n                        binding_map: binding_map,\n@@ -224,6 +225,10 @@ type borrowck_ctxt = @{tcx: ty::ctxt,\n                        mut req_pure_paths: uint,\n                        mut guaranteed_paths: uint};\n \n+enum borrowck_ctxt {\n+    borrowck_ctxt_(@borrowck_ctxt_)\n+}\n+\n // a map mapping id's of expressions of gc'd type (@T, @[], etc) where\n // the box needs to be kept live to the id of the scope for which they\n // must stay live.\n@@ -365,7 +370,11 @@ impl of ast_node for @ast::pat {\n     fn span() -> span { self.span }\n }\n \n-impl methods for ty::ctxt {\n+trait get_type_for_node {\n+    fn ty<N: ast_node>(node: N) -> ty::t;\n+}\n+\n+impl methods of get_type_for_node for ty::ctxt {\n     fn ty<N: ast_node>(node: N) -> ty::t {\n         ty::node_id_to_type(self, node.id())\n     }"}, {"sha": "ee902885562e89abc6b4008d48111be74e81eecc", "filename": "src/rustc/middle/borrowck/loan.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -6,17 +6,21 @@ export public_methods;\n \n impl public_methods for borrowck_ctxt {\n     fn loan(cmt: cmt, mutbl: ast::mutability) -> @dvec<loan> {\n-        let lc = @{bccx: self, loans: @dvec()};\n+        let lc = loan_ctxt_(@{bccx: self, loans: @dvec()});\n         lc.loan(cmt, mutbl);\n         ret lc.loans;\n     }\n }\n \n-type loan_ctxt = @{\n+type loan_ctxt_ = {\n     bccx: borrowck_ctxt,\n     loans: @dvec<loan>\n };\n \n+enum loan_ctxt {\n+    loan_ctxt_(@loan_ctxt_)\n+}\n+\n impl loan_methods for loan_ctxt {\n     fn ok_with_loan_of(cmt: cmt,\n                        mutbl: ast::mutability) {"}, {"sha": "f5ca8cfd543711f4fa902d4e8b9a8ea05a149974", "filename": "src/rustc/middle/lint.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flint.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -162,14 +162,17 @@ fn get_warning_settings_level(settings: warning_settings,\n // This is kind of unfortunate. It should be somewhere else, or we should use\n // a persistent data structure...\n fn clone_lint_modes(modes: lint_modes) -> lint_modes {\n-    @{v: copy modes.v}\n+    std::smallintmap::smallintmap_(@{v: copy modes.v})\n }\n \n-type ctxt = {dict: lint_dict,\n-             curr: lint_modes,\n-             is_default: bool,\n-             sess: session};\n+type ctxt_ = {dict: lint_dict,\n+              curr: lint_modes,\n+              is_default: bool,\n+              sess: session};\n \n+enum ctxt {\n+    ctxt_(ctxt_)\n+}\n \n impl methods for ctxt {\n     fn get_level(lint: lint) -> level {\n@@ -216,9 +219,10 @@ impl methods for ctxt {\n                             // we do multiple unneeded copies of the map\n                             // if many attributes are set, but this shouldn't\n                             // actually be a problem...\n-                            new_ctxt = {is_default: false,\n-                                        curr: clone_lint_modes(new_ctxt.curr)\n-                                        with new_ctxt};\n+                            new_ctxt =\n+                                ctxt_({is_default: false,\n+                                       curr: clone_lint_modes(new_ctxt.curr)\n+                                      with *new_ctxt});\n                             new_ctxt.set_level(lint, new_level);\n                           }\n                         }\n@@ -271,10 +275,10 @@ fn build_settings_item(i: @ast::item, &&cx: ctxt, v: visit::vt<ctxt>) {\n \n fn build_settings_crate(sess: session::session, crate: @ast::crate) {\n \n-    let cx = {dict: get_lint_dict(),\n-              curr: std::smallintmap::mk(),\n-              is_default: true,\n-              sess: sess};\n+    let cx = ctxt_({dict: get_lint_dict(),\n+                    curr: std::smallintmap::mk(),\n+                    is_default: true,\n+                    sess: sess});\n \n     // Install defaults.\n     for cx.dict.each |_k, spec| { cx.set_level(spec.lint, spec.default); }\n@@ -291,7 +295,7 @@ fn build_settings_crate(sess: session::session, crate: @ast::crate) {\n             sess.warning_settings.default_settings.insert(k, v);\n         }\n \n-        let cx = {is_default: true with cx};\n+        let cx = ctxt_({is_default: true with *cx});\n \n         let visit = visit::mk_vt(@{\n             visit_item: build_settings_item"}, {"sha": "4168f2bbe89868fa3d799b347c3e4c17ffa4fcb4", "filename": "src/rustc/middle/region.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregion.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -426,7 +426,7 @@ fn resolve_crate(sess: session, def_map: resolve::def_map, crate: @ast::crate)\n type region_paramd_items = hashmap<ast::node_id, ()>;\n type dep_map = hashmap<ast::node_id, @dvec<ast::node_id>>;\n \n-type determine_rp_ctxt = @{\n+type determine_rp_ctxt_ = {\n     sess: session,\n     ast_map: ast_map::map,\n     def_map: resolve::def_map,\n@@ -442,6 +442,10 @@ type determine_rp_ctxt = @{\n     mut anon_implies_rp: bool\n };\n \n+enum determine_rp_ctxt {\n+    determine_rp_ctxt_(@determine_rp_ctxt_)\n+}\n+\n impl methods for determine_rp_ctxt {\n     fn add_rp(id: ast::node_id) {\n         assert id != 0;\n@@ -608,14 +612,14 @@ fn determine_rp_in_crate(sess: session,\n                          ast_map: ast_map::map,\n                          def_map: resolve::def_map,\n                          crate: @ast::crate) -> region_paramd_items {\n-    let cx = @{sess: sess,\n-               ast_map: ast_map,\n-               def_map: def_map,\n-               region_paramd_items: int_hash(),\n-               dep_map: int_hash(),\n-               worklist: dvec(),\n-               mut item_id: 0,\n-               mut anon_implies_rp: false};\n+    let cx = determine_rp_ctxt_(@{sess: sess,\n+                                  ast_map: ast_map,\n+                                  def_map: def_map,\n+                                  region_paramd_items: int_hash(),\n+                                  dep_map: int_hash(),\n+                                  worklist: dvec(),\n+                                  mut item_id: 0,\n+                                  mut anon_implies_rp: false});\n \n     // gather up the base set, worklist and dep_map:\n     let visitor = visit::mk_vt(@{"}, {"sha": "04a7448f7984d07ccc5f61cc4f96a54dc6d48b65", "filename": "src/rustc/middle/resolve3.rs", "status": "modified", "additions": 201, "deletions": 18, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustc%2Fmiddle%2Fresolve3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustc%2Fmiddle%2Fresolve3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve3.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -1,5 +1,6 @@\n import driver::session::session;\n-import metadata::csearch::{each_path, get_impls_for_mod, lookup_defs};\n+import metadata::csearch::{each_path, get_impls_for_mod};\n+import metadata::csearch::{get_method_names_if_trait, lookup_defs};\n import metadata::cstore::find_use_stmt_cnum;\n import metadata::decoder::{def_like, dl_def, dl_field, dl_impl};\n import middle::lint::{error, ignore, level, unused_imports, warn};\n@@ -59,6 +60,9 @@ type ImplScope = @~[@Impl];\n type ImplScopes = @list<ImplScope>;\n type ImplMap = hashmap<node_id,ImplScopes>;\n \n+// Trait method resolution\n+type TraitMap = @hashmap<node_id,@dvec<def_id>>;\n+\n // Export mapping\n type Export = { reexp: bool, id: def_id };\n type ExportMap = hashmap<node_id, ~[Export]>;\n@@ -599,6 +603,8 @@ class Resolver {\n \n     let unused_import_lint_level: level;\n \n+    let trait_info: hashmap<def_id,@hashmap<Atom,()>>;\n+\n     // The number of imports that are currently unresolved.\n     let mut unresolved_imports: uint;\n \n@@ -617,6 +623,9 @@ class Resolver {\n     // allowed to access private names of any module.\n     let mut xray_context: XrayFlag;\n \n+    // The trait that the current context can refer to.\n+    let mut current_trait_ref: option<def_id>;\n+\n     // The atom for the keyword \"self\".\n     let self_atom: Atom;\n \n@@ -629,6 +638,7 @@ class Resolver {\n     let def_map: DefMap;\n     let impl_map: ImplMap;\n     let export_map: ExportMap;\n+    let trait_map: TraitMap;\n \n     new(session: session, ast_map: ASTMap, crate: @crate) {\n         self.session = session;\n@@ -646,12 +656,16 @@ class Resolver {\n \n         self.unused_import_lint_level = unused_import_lint_level(session);\n \n+        self.trait_info = new_def_hash();\n+\n         self.unresolved_imports = 0u;\n \n         self.current_module = (*self.graph_root).get_module();\n         self.value_ribs = @dvec();\n         self.type_ribs = @dvec();\n+\n         self.xray_context = NoXray;\n+        self.current_trait_ref = none;\n \n         self.self_atom = (*self.atom_table).intern(@~\"self\");\n         self.primitive_type_table = @PrimitiveTypeTable(self.atom_table);\n@@ -661,6 +675,7 @@ class Resolver {\n         self.def_map = int_hash();\n         self.impl_map = int_hash();\n         self.export_map = int_hash();\n+        self.trait_map = @int_hash();\n     }\n \n     /// The main name resolution procedure.\n@@ -930,14 +945,34 @@ class Resolver {\n                 visit_item(item, new_parent, visitor);\n             }\n \n-            item_trait(*) {\n-                (*name_bindings).define_type(def_ty(local_def(item.id)));\n+            item_trait(_, methods) {\n+                // Add the names of all the methods to the trait info.\n+                let method_names = @atom_hashmap();\n+                for methods.each |method| {\n+                    let atom;\n+                    alt method {\n+                        required(required_method) {\n+                            atom = (*self.atom_table).intern\n+                                (required_method.ident);\n+                        }\n+                        provided(provided_method) {\n+                            atom = (*self.atom_table).intern\n+                                (provided_method.ident);\n+                        }\n+                    }\n+                    (*method_names).insert(atom, ());\n+                }\n+\n+                let def_id = local_def(item.id);\n+                self.trait_info.insert(def_id, method_names);\n+\n+                (*name_bindings).define_type(def_ty(def_id));\n                 visit_item(item, new_parent, visitor);\n             }\n \n-          item_mac(*) {\n-            fail ~\"item macros unimplemented\"\n-          }\n+            item_mac(*) {\n+                fail ~\"item macros unimplemented\"\n+            }\n         }\n     }\n \n@@ -1300,6 +1335,34 @@ class Resolver {\n                         def_ty(def_id) {\n                             #debug(\"(building reduced graph for external \\\n                                     crate) building type %s\", final_ident);\n+\n+                            // If this is a trait, add all the method names\n+                            // to the trait info.\n+\n+                            alt get_method_names_if_trait(self.session.cstore,\n+                                                          def_id) {\n+                                none {\n+                                    // Nothing to do.\n+                                }\n+                                some(method_names) {\n+                                    let interned_method_names =\n+                                        @atom_hashmap();\n+                                    for method_names.each |method_name| {\n+                                        #debug(\"(building reduced graph for \\\n+                                                 external crate) ... adding \\\n+                                                 trait method '%?'\",\n+                                               method_name);\n+                                        let atom =\n+                                            (*self.atom_table).intern\n+                                                (method_name);\n+                                        (*interned_method_names).insert(atom,\n+                                                                        ());\n+                                    }\n+                                    self.trait_info.insert\n+                                        (def_id, interned_method_names);\n+                                }\n+                            }\n+\n                             (*child_name_bindings).define_type(def);\n                         }\n                         def_class(def_id) {\n@@ -2724,7 +2787,9 @@ class Resolver {\n \n         // Move down in the graph.\n         alt name {\n-            none { /* Nothing to do. */ }\n+            none {\n+                // Nothing to do.\n+            }\n             some(name) {\n                 alt orig_module.children.find(name) {\n                     none {\n@@ -2903,6 +2968,7 @@ class Resolver {\n \n             item_impl(type_parameters, interface_reference, self_type,\n                       methods) {\n+\n                 self.resolve_implementation(item.id,\n                                             item.span,\n                                             type_parameters,\n@@ -2922,8 +2988,7 @@ class Resolver {\n                 // Create a new rib for the interface-wide type parameters.\n                 do self.with_type_parameter_rib\n                         (HasTypeParameters(&type_parameters, item.id, 0u,\n-                                           NormalRibKind))\n-                        || {\n+                                           NormalRibKind)) {\n \n                     self.resolve_type_parameters(type_parameters, visitor);\n \n@@ -2939,8 +3004,7 @@ class Resolver {\n                                 (HasTypeParameters(&ty_m.tps,\n                                                    item.id,\n                                                    type_parameters.len(),\n-                                                   NormalRibKind))\n-                            || {\n+                                                   NormalRibKind)) {\n \n                                 // Resolve the method-specific type\n                                 // parameters.\n@@ -3318,13 +3382,13 @@ class Resolver {\n         let borrowed_type_parameters: &~[ty_param] = &type_parameters;\n         do self.with_type_parameter_rib(HasTypeParameters\n                                         (borrowed_type_parameters, id, 0u,\n-                                         NormalRibKind))\n-                || {\n+                                         NormalRibKind)) {\n \n             // Resolve the type parameters.\n             self.resolve_type_parameters(type_parameters, visitor);\n \n             // Resolve the interface reference, if necessary.\n+            let original_trait_ref = self.current_trait_ref;\n             alt interface_reference {\n                 none {\n                     // Nothing to do.\n@@ -3339,6 +3403,9 @@ class Resolver {\n                         }\n                         some(def) {\n                             self.record_def(interface_reference.ref_id, def);\n+\n+                            // Record the current trait reference.\n+                            self.current_trait_ref = some(def_id_of_def(def));\n                         }\n                     }\n                 }\n@@ -3364,6 +3431,9 @@ class Resolver {\n                                       NoCaptureClause,\n                                       visitor);\n             }\n+\n+            // Restore the original trait reference.\n+            self.current_trait_ref = original_trait_ref;\n         }\n     }\n \n@@ -3828,9 +3898,10 @@ class Resolver {\n                                 ret ImportNameDefinition(def);\n                             }\n                             none {\n-                                fail ~\"target for namespace doesn't refer to \\\n-                                      bindings that contain a definition for \\\n-                                      that namespace!\";\n+                                // This can happen with external impls, due to\n+                                // the imperfect way we read the metadata.\n+\n+                                ret NoNameDefinition;\n                             }\n                         }\n                     }\n@@ -4040,6 +4111,11 @@ class Resolver {\n \n         self.record_impls_for_expr_if_necessary(expr);\n \n+        // Then record candidate traits for this expression if it could result\n+        // in the invocation of a method call.\n+\n+        self.record_candidate_traits_for_expr_if_necessary(expr);\n+\n         // Next, resolve the node.\n         alt expr.node {\n             // The interpretation of paths depends on whether the path has\n@@ -4101,6 +4177,109 @@ class Resolver {\n         }\n     }\n \n+    fn record_candidate_traits_for_expr_if_necessary(expr: @expr) {\n+        alt expr.node {\n+            expr_field(_, ident, _) {\n+                let atom = (*self.atom_table).intern(ident);\n+                let traits = self.search_for_traits_containing_method(atom);\n+                self.trait_map.insert(expr.id, traits);\n+            }\n+            _ {\n+                // Nothing to do.\n+                //\n+                // XXX: Handle more here... operator overloading, placement\n+                // new, etc.\n+            }\n+        }\n+    }\n+\n+    fn search_for_traits_containing_method(name: Atom) -> @dvec<def_id> {\n+        let found_traits = @dvec();\n+        let mut search_module = self.current_module;\n+        loop {\n+            // Look for the current trait.\n+            alt copy self.current_trait_ref {\n+                some(trait_def_id) {\n+                    self.add_trait_info_if_containing_method(found_traits,\n+                                                             trait_def_id,\n+                                                             name);\n+                }\n+                none {\n+                    // Nothing to do.\n+                }\n+            }\n+\n+            // Look for trait children.\n+            for search_module.children.each |_name, child_name_bindings| {\n+                alt child_name_bindings.def_for_namespace(TypeNS) {\n+                    some(def_ty(trait_def_id)) {\n+                        self.add_trait_info_if_containing_method(found_traits,\n+                                                                 trait_def_id,\n+                                                                 name);\n+                    }\n+                    some(_) | none {\n+                        // Continue.\n+                    }\n+                }\n+            }\n+\n+            // Look for imports.\n+            for search_module.import_resolutions.each\n+                    |_atom, import_resolution| {\n+\n+                alt import_resolution.target_for_namespace(TypeNS) {\n+                    none {\n+                        // Continue.\n+                    }\n+                    some(target) {\n+                        alt target.bindings.def_for_namespace(TypeNS) {\n+                            some(def_ty(trait_def_id)) {\n+                                self.add_trait_info_if_containing_method\n+                                    (found_traits, trait_def_id, name);\n+                            }\n+                            some(_) | none {\n+                                // Continue.\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Move to the next parent.\n+            alt search_module.parent_link {\n+                NoParentLink {\n+                    // Done.\n+                    break;\n+                }\n+                ModuleParentLink(parent_module, _) |\n+                BlockParentLink(parent_module, _) {\n+                    search_module = parent_module;\n+                }\n+            }\n+        }\n+\n+        ret found_traits;\n+    }\n+\n+    fn add_trait_info_if_containing_method(found_traits: @dvec<def_id>,\n+                                           trait_def_id: def_id,\n+                                           name: Atom) {\n+\n+        alt self.trait_info.find(trait_def_id) {\n+            some(trait_info) if trait_info.contains_key(name) {\n+                #debug(\"(adding trait info if containing method) found trait \\\n+                        %d:%d for method '%s'\",\n+                       trait_def_id.crate,\n+                       trait_def_id.node,\n+                       *(*self.atom_table).atom_to_str(name));\n+                (*found_traits).push(trait_def_id);\n+            }\n+            some(_) | none {\n+                // Continue.\n+            }\n+        }\n+    }\n+\n     fn record_def(node_id: node_id, def: def) {\n         #debug(\"(recording def) recording %? for %?\", def, node_id);\n         self.def_map.insert(node_id, def);\n@@ -4310,14 +4489,18 @@ class Resolver {\n \n /// Entry point to crate resolution.\n fn resolve_crate(session: session, ast_map: ASTMap, crate: @crate)\n-              -> { def_map: DefMap, exp_map: ExportMap, impl_map: ImplMap } {\n+              -> { def_map: DefMap,\n+                   exp_map: ExportMap,\n+                   impl_map: ImplMap,\n+                   trait_map: TraitMap } {\n \n     let resolver = @Resolver(session, ast_map, crate);\n     (*resolver).resolve(resolver);\n     ret {\n         def_map: resolver.def_map,\n         exp_map: resolver.export_map,\n-        impl_map: resolver.impl_map\n+        impl_map: resolver.impl_map,\n+        trait_map: resolver.trait_map\n     };\n }\n "}, {"sha": "24acfcecdf7d85dbfd53787ab78998c32bdeedc3", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -94,7 +94,11 @@ class icx_popper {\n     }\n }\n \n-impl ccx_icx for @crate_ctxt {\n+trait get_insn_ctxt {\n+    fn insn_ctxt(s: ~str) -> icx_popper;\n+}\n+\n+impl ccx_icx of get_insn_ctxt for @crate_ctxt {\n     fn insn_ctxt(s: ~str) -> icx_popper {\n         #debug(\"new insn_ctxt: %s\", s);\n         if self.sess.count_llvm_insns() {\n@@ -104,13 +108,13 @@ impl ccx_icx for @crate_ctxt {\n     }\n }\n \n-impl bcx_icx for block {\n+impl bcx_icx of get_insn_ctxt for block {\n     fn insn_ctxt(s: ~str) -> icx_popper {\n         self.ccx().insn_ctxt(s)\n     }\n }\n \n-impl fcx_icx for fn_ctxt {\n+impl fcx_icx of get_insn_ctxt for fn_ctxt {\n     fn insn_ctxt(s: ~str) -> icx_popper {\n         self.ccx.insn_ctxt(s)\n     }"}, {"sha": "2f460e2678e9ee8111366914ebd184bca583dba1", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -348,19 +348,23 @@ type scope_info = {\n     mut landing_pad: option<BasicBlockRef>,\n };\n \n-impl node_info for @ast::expr {\n+trait get_node_info {\n+    fn info() -> option<node_info>;\n+}\n+\n+impl node_info of get_node_info for @ast::expr {\n     fn info() -> option<node_info> {\n         some({id: self.id, span: self.span})\n     }\n }\n \n-impl node_info for ast::blk {\n+impl node_info of get_node_info for ast::blk {\n     fn info() -> option<node_info> {\n         some({id: self.node.id, span: self.span})\n     }\n }\n \n-impl node_info for option<@ast::expr> {\n+impl node_info of get_node_info for option<@ast::expr> {\n     fn info() -> option<node_info> {\n         self.chain(|s| s.info())\n     }"}, {"sha": "1cf46ba9b32e2dc79a6df9ecdf52b88862392d4d", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -165,6 +165,7 @@ export terr_sorts, terr_vec, terr_str, terr_record_size, terr_tuple_size;\n export terr_regions_differ, terr_mutability, terr_purity_mismatch;\n export terr_proto_mismatch;\n export terr_ret_style_mismatch;\n+export purity_to_str;\n \n // Data types\n \n@@ -441,7 +442,11 @@ impl of vid for region_vid {\n     fn to_str() -> ~str { #fmt[\"<R%u>\", self.to_uint()] }\n }\n \n-impl of to_str::to_str for purity {\n+trait purity_to_str {\n+    fn to_str() -> ~str;\n+}\n+\n+impl of purity_to_str for purity {\n     fn to_str() -> ~str {\n         purity_to_str(self)\n     }\n@@ -2359,7 +2364,8 @@ fn type_err_to_str(cx: ctxt, err: type_err) -> ~str {\n             ~\" function was expected\";\n       }\n       terr_purity_mismatch(f1, f2) {\n-        ret #fmt[\"expected %s fn but found %s fn\", f1.to_str(), f2.to_str()];\n+        ret #fmt[\"expected %s fn but found %s fn\",\n+                 purity_to_str(f1), purity_to_str(f2)];\n       }\n       terr_proto_mismatch(e, a) {\n         ret #fmt[\"closure protocol mismatch (%s vs %s)\","}, {"sha": "9d4968ef443fbce13daf9fdf563f172be3f58507", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -154,10 +154,16 @@ type ty_param_substs_and_ty = {substs: ty::substs, ty: ty::t};\n \n type ty_table = hashmap<ast::def_id, ty::t>;\n \n-type crate_ctxt = {impl_map: resolve::impl_map,\n-                   method_map: method_map,\n-                   vtable_map: vtable_map,\n-                   tcx: ty::ctxt};\n+type crate_ctxt_ = {impl_map: resolve::impl_map,\n+                    trait_map: resolve3::TraitMap,\n+                    method_map: method_map,\n+                    vtable_map: vtable_map,\n+                    coherence_info: @coherence::CoherenceInfo,\n+                    tcx: ty::ctxt};\n+\n+enum crate_ctxt {\n+    crate_ctxt_(crate_ctxt_)\n+}\n \n // Functions that write types into the node type table\n fn write_ty_to_tcx(tcx: ty::ctxt, node_id: ast::node_id, ty: ty::t) {\n@@ -284,17 +290,20 @@ fn check_for_main_fn(ccx: @crate_ctxt) {\n     }\n }\n \n-fn check_crate(tcx: ty::ctxt, impl_map: resolve::impl_map,\n-               crate: @ast::crate) -> (method_map, vtable_map) {\n-    let ccx = @{impl_map: impl_map,\n-                method_map: std::map::int_hash(),\n-                vtable_map: std::map::int_hash(),\n-                tcx: tcx};\n+fn check_crate(tcx: ty::ctxt,\n+               impl_map: resolve::impl_map,\n+               trait_map: resolve3::TraitMap,\n+               crate: @ast::crate)\n+            -> (method_map, vtable_map) {\n+\n+    let ccx = @crate_ctxt_({impl_map: impl_map,\n+                            trait_map: trait_map,\n+                            method_map: std::map::int_hash(),\n+                            vtable_map: std::map::int_hash(),\n+                            coherence_info: @coherence::CoherenceInfo(),\n+                            tcx: tcx});\n     collect::collect_item_types(ccx, crate);\n-\n-    if tcx.sess.coherence() {\n-        coherence::check_coherence(ccx, crate);\n-    }\n+    coherence::check_coherence(ccx, crate);\n \n     check::check_item_types(ccx, crate);\n     check_for_main_fn(ccx);"}, {"sha": "5a8d0b15619b0343c77566bf90eedaea186086ee", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 37, "deletions": 28, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -76,7 +76,7 @@ import syntax::ast::ty_i;\n import typeck::infer::{unify_methods}; // infcx.set()\n import typeck::infer::{resolve_type, force_tvar};\n \n-type fn_ctxt =\n+type fn_ctxt_ =\n     // var_bindings, locals and next_var_id are shared\n     // with any nested functions that capture the environment\n     // (and with any functions whose environment is being captured).\n@@ -111,30 +111,39 @@ type fn_ctxt =\n \n      ccx: @crate_ctxt};\n \n+enum fn_ctxt {\n+    fn_ctxt_(fn_ctxt_)\n+}\n+\n // Used by check_const and check_enum_variants\n fn blank_fn_ctxt(ccx: @crate_ctxt, rty: ty::t,\n                  region_bnd: ast::node_id) -> @fn_ctxt {\n // It's kind of a kludge to manufacture a fake function context\n // and statement context, but we might as well do write the code only once\n-    @{self_ty: none,\n-      ret_ty: rty,\n-      indirect_ret_ty: none,\n-      purity: ast::pure_fn,\n-      infcx: infer::new_infer_ctxt(ccx.tcx),\n-      locals: int_hash(),\n-      mut region_lb: region_bnd,\n-      mut region_ub: region_bnd,\n-      in_scope_regions: @nil,\n-      node_types: smallintmap::mk(),\n-      node_type_substs: map::int_hash(),\n-      ccx: ccx}\n+    @fn_ctxt_({self_ty: none,\n+               ret_ty: rty,\n+               indirect_ret_ty: none,\n+               purity: ast::pure_fn,\n+               infcx: infer::new_infer_ctxt(ccx.tcx),\n+               locals: int_hash(),\n+               mut region_lb: region_bnd,\n+               mut region_ub: region_bnd,\n+               in_scope_regions: @nil,\n+               node_types: smallintmap::mk(),\n+               node_type_substs: map::int_hash(),\n+               ccx: ccx})\n }\n \n // a list of mapping from in-scope-region-names (\"isr\") to the\n // corresponding ty::region\n type isr_alist = @list<(ty::bound_region, ty::region)>;\n \n-impl methods for isr_alist {\n+trait get_and_find_region {\n+    fn get(br: ty::bound_region) -> ty::region;\n+    fn find(br: ty::bound_region) -> option<ty::region>;\n+}\n+\n+impl methods of get_and_find_region for isr_alist {\n     fn get(br: ty::bound_region) -> ty::region {\n         option::get(self.find(br))\n     }\n@@ -227,18 +236,18 @@ fn check_fn(ccx: @crate_ctxt,\n             }\n         } else { none };\n \n-        @{self_ty: self_ty,\n-          ret_ty: ret_ty,\n-          indirect_ret_ty: indirect_ret_ty,\n-          purity: purity,\n-          infcx: infcx,\n-          locals: locals,\n-          mut region_lb: body.node.id,\n-          mut region_ub: body.node.id,\n-          in_scope_regions: isr,\n-          node_types: node_types,\n-          node_type_substs: node_type_substs,\n-          ccx: ccx}\n+        @fn_ctxt_({self_ty: self_ty,\n+                   ret_ty: ret_ty,\n+                   indirect_ret_ty: indirect_ret_ty,\n+                   purity: purity,\n+                   infcx: infcx,\n+                   locals: locals,\n+                   mut region_lb: body.node.id,\n+                   mut region_ub: body.node.id,\n+                   in_scope_regions: isr,\n+                   node_types: node_types,\n+                   node_type_substs: node_type_substs,\n+                   ccx: ccx})\n     };\n \n     gather_locals(fcx, decl, body, arg_tys);\n@@ -1787,8 +1796,8 @@ fn check_block_no_value(fcx: @fn_ctxt, blk: ast::blk) -> bool {\n \n fn check_block(fcx0: @fn_ctxt, blk: ast::blk) -> bool {\n     let fcx = alt blk.node.rules {\n-      ast::unchecked_blk { @{purity: ast::impure_fn with *fcx0} }\n-      ast::unsafe_blk { @{purity: ast::unsafe_fn with *fcx0} }\n+      ast::unchecked_blk { @fn_ctxt_({purity: ast::impure_fn with **fcx0}) }\n+      ast::unsafe_blk { @fn_ctxt_({purity: ast::unsafe_fn with **fcx0}) }\n       ast::default_blk { fcx0 }\n     };\n     do fcx.with_region_lb(blk.node.id) {"}, {"sha": "02045e3a2379b035b3fcccb66b6f09fff32b84ef", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 147, "deletions": 41, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -1,9 +1,12 @@\n /* Code to handle method lookups (which can be quite complex) */\n \n+import coherence::get_base_type_def_id;\n+import middle::resolve3::Impl;\n+import middle::typeck::infer::methods; // next_ty_vars\n import syntax::ast::def_id;\n import syntax::ast_map;\n+import syntax::ast_map::node_id_to_str;\n import syntax::ast_util::new_def_hash;\n-import middle::typeck::infer::methods; // next_ty_vars\n import dvec::{dvec, extensions};\n \n type candidate = {\n@@ -55,11 +58,34 @@ class lookup {\n \n     // Entrypoint:\n     fn method() -> option<method_map_entry> {\n-        #debug[\"method lookup(m_name=%s, self_ty=%s)\",\n-               *self.m_name, self.fcx.infcx.ty_to_str(self.self_ty)];\n+        #debug[\"method lookup(m_name=%s, self_ty=%s, %?)\",\n+               *self.m_name, self.fcx.infcx.ty_to_str(self.self_ty),\n+               ty::get(self.self_ty).struct];\n+\n+        // Determine if there are any inherent methods we can call.\n+        let optional_inherent_methods;\n+        alt get_base_type_def_id(self.fcx.infcx,\n+                                 self.self_expr.span,\n+                                 self.self_ty) {\n+            none {\n+                optional_inherent_methods = none;\n+            }\n+            some(base_type_def_id) {\n+                #debug(\"(checking method) found base type\");\n+                optional_inherent_methods =\n+                    self.fcx.ccx.coherence_info.inherent_methods.find\n+                        (base_type_def_id);\n+\n+                if optional_inherent_methods.is_none() {\n+                    #debug(\"(checking method) ... no inherent methods found\");\n+                } else {\n+                    #debug(\"(checking method) ... inherent methods found\");\n+                }\n+            }\n+        }\n \n         loop {\n-            // First, see whether this is an interface-bounded parameter\n+            // First, see whether this is an interface-bounded parameter.\n             alt ty::get(self.self_ty).struct {\n               ty::ty_param(n, did) {\n                 self.add_candidates_from_param(n, did);\n@@ -83,12 +109,20 @@ class lookup {\n             // would require doing an implicit borrow of the lhs.\n             self.add_candidates_from_scope(false);\n \n+            // Look for inherent methods.\n+            self.add_inherent_and_extension_candidates\n+                (optional_inherent_methods, false);\n+\n             // if we found anything, stop before trying borrows\n             if self.candidates.len() > 0u { break; }\n \n             // now look for impls in scope that might require a borrow\n             self.add_candidates_from_scope(true);\n \n+            // Again, look for inherent methods.\n+            self.add_inherent_and_extension_candidates\n+                (optional_inherent_methods, true);\n+\n             // if we found anything, stop before attempting auto-deref.\n             if self.candidates.len() > 0u { break; }\n \n@@ -296,50 +330,23 @@ class lookup {\n     }\n \n     fn add_candidates_from_scope(use_assignability: bool) {\n+        // If we're using coherence and this is one of the method invocation\n+        // forms it supports, don't use this method; it'll result in lots of\n+        // multiple-methods-in-scope errors.\n+\n+        if self.fcx.ccx.trait_map.contains_key(self.expr.id) {\n+            ret;\n+        }\n+\n         let impls_vecs = self.fcx.ccx.impl_map.get(self.expr.id);\n         let mut added_any = false;\n \n         #debug[\"method_from_scope\"];\n \n         for list::each(impls_vecs) |impls| {\n             for vec::each(*impls) |im| {\n-                // Check whether this impl has a method with the right name.\n-                for im.methods.find(|m| m.ident == self.m_name).each |m| {\n-\n-                    // determine the `self` of the impl with fresh\n-                    // variables for each parameter:\n-                    let {substs: impl_substs, ty: impl_ty} =\n-                        impl_self_ty(self.fcx, im.did);\n-\n-                    // Depending on our argument, we find potential\n-                    // matches either by checking subtypability or\n-                    // type assignability. Collect the matches.\n-                    let matches = if use_assignability {\n-                        self.fcx.can_mk_assignty(\n-                            self.self_expr, self.borrow_lb,\n-                            self.self_ty, impl_ty)\n-                    } else {\n-                        self.fcx.can_mk_subty(self.self_ty, impl_ty)\n-                    };\n-                    #debug[\"matches = %?\", matches];\n-                    alt matches {\n-                      result::err(_) { /* keep looking */ }\n-                      result::ok(_) {\n-                        if !self.candidate_impls.contains_key(im.did) {\n-                            let fty = self.ty_from_did(m.did);\n-                            self.candidates.push(\n-                                {self_ty: self.self_ty,\n-                                 self_substs: impl_substs,\n-                                 rcvr_ty: impl_ty,\n-                                 n_tps_m: m.n_tps,\n-                                 fty: fty,\n-                                 entry: {derefs: self.derefs,\n-                                         origin: method_static(m.did)}});\n-                            self.candidate_impls.insert(im.did, ());\n-                            added_any = true;\n-                        }\n-                      }\n-                    }\n+                if self.add_candidates_from_impl(im, use_assignability) {\n+                    added_any = true;\n                 }\n             }\n \n@@ -349,6 +356,53 @@ class lookup {\n         }\n     }\n \n+    // Returns true if any were added and false otherwise.\n+    fn add_candidates_from_impl(im: @resolve3::Impl,\n+                                use_assignability: bool) -> bool {\n+\n+        let mut added_any = false;\n+\n+        // Check whether this impl has a method with the right name.\n+        for im.methods.find(|m| m.ident == self.m_name).each |m| {\n+\n+            // determine the `self` of the impl with fresh\n+            // variables for each parameter:\n+            let {substs: impl_substs, ty: impl_ty} =\n+                impl_self_ty(self.fcx, im.did);\n+\n+            // Depending on our argument, we find potential\n+            // matches either by checking subtypability or\n+            // type assignability. Collect the matches.\n+            let matches = if use_assignability {\n+                self.fcx.can_mk_assignty(self.self_expr, self.borrow_lb,\n+                                         self.self_ty, impl_ty)\n+            } else {\n+                self.fcx.can_mk_subty(self.self_ty, impl_ty)\n+            };\n+            #debug[\"matches = %?\", matches];\n+            alt matches {\n+              result::err(_) { /* keep looking */ }\n+              result::ok(_) {\n+                if !self.candidate_impls.contains_key(im.did) {\n+                    let fty = self.ty_from_did(m.did);\n+                    self.candidates.push(\n+                        {self_ty: self.self_ty,\n+                         self_substs: impl_substs,\n+                         rcvr_ty: impl_ty,\n+                         n_tps_m: m.n_tps,\n+                         fty: fty,\n+                         entry: {derefs: self.derefs,\n+                                 origin: method_static(m.did)}});\n+                    self.candidate_impls.insert(im.did, ());\n+                    added_any = true;\n+                }\n+              }\n+            }\n+        }\n+\n+        ret added_any;\n+    }\n+\n     fn add_candidates_from_m(self_substs: ty::substs,\n                              m: ty::method,\n                              origin: method_origin) {\n@@ -367,6 +421,58 @@ class lookup {\n              entry: {derefs: self.derefs, origin: origin}});\n     }\n \n+    fn add_inherent_and_extension_candidates(optional_inherent_methods:\n+                                                option<@dvec<@Impl>>,\n+                                             use_assignability: bool) {\n+\n+        // Add inherent methods.\n+        alt optional_inherent_methods {\n+            none {\n+                // Continue.\n+            }\n+            some(inherent_methods) {\n+                #debug(\"(adding inherent and extension candidates) adding \\\n+                        inherent candidates\");\n+                for inherent_methods.each |implementation| {\n+                    #debug(\"(adding inherent and extension candidates) \\\n+                            adding candidates from impl: %s\",\n+                           node_id_to_str(self.tcx().items,\n+                                          implementation.did.node));\n+                    self.add_candidates_from_impl(implementation,\n+                                                  use_assignability);\n+                }\n+            }\n+        }\n+\n+        // Add trait methods.\n+        alt self.fcx.ccx.trait_map.find(self.expr.id) {\n+            none {\n+                // XXX: This particular operation is not yet trait-ified;\n+                // leave it alone for now.\n+            }\n+            some(trait_ids) {\n+                for (*trait_ids).each |trait_id| {\n+                    #debug(\"(adding inherent and extension candidates) \\\n+                            trying trait: %s\",\n+                           node_id_to_str(self.tcx().items, trait_id.node));\n+\n+                    let coherence_info = self.fcx.ccx.coherence_info;\n+                    alt coherence_info.extension_methods.find(trait_id) {\n+                        none {\n+                            // Do nothing.\n+                        }\n+                        some(extension_methods) {\n+                            for extension_methods.each |implementation| {\n+                                self.add_candidates_from_impl\n+                                    (implementation, use_assignability);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     fn write_mty_from_candidate(cand: candidate) -> method_map_entry {\n         let tcx = self.fcx.ccx.tcx;\n "}, {"sha": "19b4450bb62ca1f9257d48325eecd13325fda431", "filename": "src/rustc/middle/typeck/coherence.rs", "status": "modified", "additions": 343, "deletions": 124, "changes": 467, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -4,52 +4,132 @@\n // has at most one implementation for each type. Then we build a mapping from\n // each trait in the system to its implementations.\n \n-import middle::ty::{get, t, ty_box, ty_uniq, ty_ptr, ty_rptr, ty_enum};\n+import metadata::csearch::{each_path, get_impl_trait, get_impls_for_mod};\n+import metadata::cstore::{cstore, iter_crate_data};\n+import metadata::decoder::{dl_def, dl_field, dl_impl};\n+import middle::resolve3::Impl;\n+import middle::ty::{get, lookup_item_type, subst, t, ty_box};\n+import middle::ty::{ty_uniq, ty_ptr, ty_rptr, ty_enum};\n import middle::ty::{ty_class, ty_nil, ty_bot, ty_bool, ty_int, ty_uint};\n import middle::ty::{ty_float, ty_estr, ty_evec, ty_rec};\n import middle::ty::{ty_fn, ty_trait, ty_tup, ty_var, ty_var_integral};\n import middle::ty::{ty_param, ty_self, ty_type, ty_opaque_box};\n-import middle::ty::{ty_opaque_closure_ptr, ty_unboxed_vec, new_ty_hash};\n-import middle::ty::{subst};\n-import middle::typeck::infer::{infer_ctxt, mk_subty, new_infer_ctxt};\n-import syntax::ast::{crate, def_id, item, item_class, item_const, item_enum};\n-import syntax::ast::{item_fn, item_foreign_mod, item_impl, item_mac};\n-import syntax::ast::{item_mod, item_trait, item_ty, local_crate, method};\n-import syntax::ast::{node_id, trait_ref};\n-import syntax::ast_util::{def_id_of_def, new_def_hash};\n+import middle::ty::{ty_opaque_closure_ptr, ty_unboxed_vec, type_is_var};\n+import middle::typeck::infer::{infer_ctxt, mk_subty};\n+import middle::typeck::infer::{new_infer_ctxt, resolve_ivar, resolve_type};\n+import syntax::ast::{crate, def_id, def_mod, item, item_class, item_const};\n+import syntax::ast::{item_enum, item_fn, item_foreign_mod, item_impl};\n+import syntax::ast::{item_mac, item_mod, item_trait, item_ty, local_crate};\n+import syntax::ast::{method, node_id, region_param, rp_none, rp_self};\n+import syntax::ast::{trait_ref};\n+import syntax::ast_map::node_item;\n+import syntax::ast_util::{def_id_of_def, dummy_sp, new_def_hash};\n+import syntax::codemap::span;\n import syntax::visit::{default_simple_visitor, default_visitor};\n import syntax::visit::{mk_simple_visitor, mk_vt, visit_crate, visit_item};\n import syntax::visit::{visit_mod};\n import util::ppaux::ty_to_str;\n \n import dvec::{dvec, extensions};\n-import result::{extensions};\n+import result::{extensions, ok};\n import std::map::{hashmap, int_hash};\n import uint::range;\n+import vec::{len, push};\n+\n+fn get_base_type(inference_context: infer_ctxt, span: span, original_type: t)\n+              -> option<t> {\n+\n+    let resolved_type;\n+    alt resolve_type(inference_context,\n+                     original_type,\n+                     resolve_ivar) {\n+        ok(resulting_type) if !type_is_var(resulting_type) {\n+            resolved_type = resulting_type;\n+        }\n+        _ {\n+            inference_context.tcx.sess.span_fatal(span,\n+                                                  ~\"the type of this value \\\n+                                                    must be known in order \\\n+                                                    to determine the base \\\n+                                                    type\");\n+        }\n+    }\n+\n+    alt get(resolved_type).struct {\n+        ty_box(base_mutability_and_type) |\n+        ty_uniq(base_mutability_and_type) |\n+        ty_ptr(base_mutability_and_type) |\n+        ty_rptr(_, base_mutability_and_type) {\n+            #debug(\"(getting base type) recurring\");\n+            get_base_type(inference_context, span,\n+                          base_mutability_and_type.ty)\n+        }\n+\n+        ty_enum(*) | ty_trait(*) | ty_class(*) {\n+            #debug(\"(getting base type) found base type\");\n+            some(resolved_type)\n+        }\n+\n+        ty_nil | ty_bot | ty_bool | ty_int(*) | ty_uint(*) | ty_float(*) |\n+        ty_estr(*) | ty_evec(*) | ty_rec(*) |\n+        ty_fn(*) | ty_tup(*) | ty_var(*) | ty_var_integral(*) |\n+        ty_param(*) | ty_self | ty_type | ty_opaque_box |\n+        ty_opaque_closure_ptr(*) | ty_unboxed_vec(*) {\n+            #debug(\"(getting base type) no base type; found %?\",\n+                   get(original_type).struct);\n+            none\n+        }\n+    }\n+}\n+\n+// Returns the def ID of the base type, if there is one.\n+fn get_base_type_def_id(inference_context: infer_ctxt,\n+                        span: span,\n+                        original_type: t)\n+                     -> option<def_id> {\n+\n+    alt get_base_type(inference_context, span, original_type) {\n+        none {\n+            ret none;\n+        }\n+        some(base_type) {\n+            alt get(base_type).struct {\n+                ty_enum(def_id, _) |\n+                ty_class(def_id, _) |\n+                ty_trait(def_id, _) {\n+                    ret some(def_id);\n+                }\n+                _ {\n+                    fail ~\"get_base_type() returned a type that wasn't an \\\n+                           enum, class, or trait\";\n+                }\n+            }\n+        }\n+    }\n+}\n \n class CoherenceInfo {\n     // Contains implementations of methods that are inherent to a type.\n     // Methods in these implementations don't need to be exported.\n-    let inherent_methods: hashmap<t,@dvec<@item>>;\n+    let inherent_methods: hashmap<def_id,@dvec<@Impl>>;\n \n     // Contains implementations of methods associated with a trait. For these,\n     // the associated trait must be imported at the call site.\n-    let extension_methods: hashmap<def_id,@dvec<@item>>;\n+    let extension_methods: hashmap<def_id,@dvec<@Impl>>;\n \n     new() {\n-        self.inherent_methods = new_ty_hash();\n+        self.inherent_methods = new_def_hash();\n         self.extension_methods = new_def_hash();\n     }\n }\n \n class CoherenceChecker {\n     let crate_context: @crate_ctxt;\n     let inference_context: infer_ctxt;\n-    let info: @CoherenceInfo;\n \n     // A mapping from implementations to the corresponding base type\n     // definition ID.\n-    let base_type_def_ids: hashmap<node_id,def_id>;\n+    let base_type_def_ids: hashmap<def_id,def_id>;\n \n     // A set of implementations in privileged scopes; i.e. those\n     // implementations that are defined in the same scope as their base types.\n@@ -62,9 +142,8 @@ class CoherenceChecker {\n     new(crate_context: @crate_ctxt) {\n         self.crate_context = crate_context;\n         self.inference_context = new_infer_ctxt(crate_context.tcx);\n-        self.info = @CoherenceInfo();\n \n-        self.base_type_def_ids = int_hash();\n+        self.base_type_def_ids = new_def_hash();\n         self.privileged_implementations = int_hash();\n         self.privileged_types = new_def_hash();\n     }\n@@ -88,12 +167,20 @@ class CoherenceChecker {\n         }));\n \n         // Check trait coherence.\n-        for self.info.extension_methods.each |def_id, items| {\n+        for self.crate_context.coherence_info.extension_methods.each\n+                |def_id, items| {\n+\n             self.check_implementation_coherence(def_id, items);\n         }\n \n         // Check whether traits with base types are in privileged scopes.\n         self.check_privileged_scopes(crate);\n+\n+        // Bring in external crates. It's fine for this to happen after the\n+        // coherence checks, because we ensure by construction that no errors\n+        // can happen at link time.\n+\n+        self.add_external_crates();\n     }\n \n     fn check_implementation(item: @item,\n@@ -102,111 +189,89 @@ class CoherenceChecker {\n         let self_type = self.crate_context.tcx.tcache.get(local_def(item.id));\n         alt optional_associated_trait {\n             none {\n-                alt self.get_base_type(self_type.ty) {\n+                alt get_base_type_def_id(self.inference_context,\n+                                         item.span,\n+                                         self_type.ty) {\n                     none {\n                         let session = self.crate_context.tcx.sess;\n-                        session.span_warn(item.span,\n-                                          ~\"no base type found for inherent \\\n-                                           implementation; implement a trait \\\n-                                           instead\");\n+                        session.span_err(item.span,\n+                                         ~\"no base type found for inherent \\\n+                                           implementation; implement a \\\n+                                           trait instead\");\n                     }\n-                    some(base_type) {\n-                        let implementation_list;\n-                        alt self.info.inherent_methods.find(base_type) {\n-                            none {\n-                                implementation_list = @dvec();\n-                            }\n-                            some(existing_implementation_list) {\n-                                implementation_list =\n-                                    existing_implementation_list;\n-                            }\n-                        }\n-\n-                        implementation_list.push(item);\n+                    some(_) {\n+                        // Nothing to do.\n                     }\n                 }\n             }\n             some(associated_trait) {\n-                let def =\n-                  self.crate_context.tcx.def_map.get(associated_trait.ref_id);\n-                let def_id = def_id_of_def(def);\n-\n-                let implementation_list;\n-                alt self.info.extension_methods.find(def_id) {\n-                    none {\n-                        implementation_list = @dvec();\n-                    }\n-                    some(existing_implementation_list) {\n-                        implementation_list = existing_implementation_list;\n-                    }\n-                }\n-\n-                implementation_list.push(item);\n+                let def = self.crate_context.tcx.def_map.get\n+                    (associated_trait.ref_id);\n+                let implementation = self.create_impl_from_item(item);\n+                self.add_trait_method(def_id_of_def(def), implementation);\n             }\n         }\n \n         // Add the implementation to the mapping from implementation to base\n         // type def ID, if there is a base type for this implementation.\n-        alt self.get_base_type_def_id(self_type.ty) {\n+        alt get_base_type_def_id(self.inference_context,\n+                                 item.span,\n+                                 self_type.ty) {\n             none {\n                 // Nothing to do.\n             }\n             some(base_type_def_id) {\n-                self.base_type_def_ids.insert(item.id, base_type_def_id);\n+                let implementation = self.create_impl_from_item(item);\n+                self.add_inherent_method(base_type_def_id, implementation);\n+\n+                self.base_type_def_ids.insert(local_def(item.id),\n+                                              base_type_def_id);\n             }\n         }\n     }\n \n-    fn get_base_type(original_type: t) -> option<t> {\n-        alt get(original_type).struct {\n-            ty_box(base_mutability_and_type) |\n-            ty_uniq(base_mutability_and_type) |\n-            ty_ptr(base_mutability_and_type) |\n-            ty_rptr(_, base_mutability_and_type) {\n-                self.get_base_type(base_mutability_and_type.ty)\n-            }\n+    fn add_inherent_method(base_def_id: def_id, implementation: @Impl) {\n+        let implementation_list;\n+        alt self.crate_context.coherence_info.inherent_methods\n+            .find(base_def_id) {\n \n-            ty_enum(*) | ty_trait(*) | ty_class(*) {\n-                some(original_type)\n+            none {\n+                implementation_list = @dvec();\n+                self.crate_context.coherence_info.inherent_methods\n+                    .insert(base_def_id, implementation_list);\n             }\n-\n-            ty_nil | ty_bot | ty_bool | ty_int(*) | ty_uint(*) | ty_float(*) |\n-            ty_estr(*) | ty_evec(*) | ty_rec(*) |\n-            ty_fn(*) | ty_tup(*) | ty_var(*) | ty_var_integral(*) |\n-            ty_param(*) | ty_self | ty_type | ty_opaque_box |\n-            ty_opaque_closure_ptr(*) | ty_unboxed_vec(*) {\n-                none\n+            some(existing_implementation_list) {\n+                implementation_list = existing_implementation_list;\n             }\n         }\n+\n+        implementation_list.push(implementation);\n     }\n \n-    // Returns the def ID of the base type.\n-    fn get_base_type_def_id(original_type: t) -> option<def_id> {\n-        alt self.get_base_type(original_type) {\n+    fn add_trait_method(trait_id: def_id, implementation: @Impl) {\n+        let implementation_list;\n+        alt self.crate_context.coherence_info.extension_methods\n+                .find(trait_id) {\n+\n             none {\n-                ret none;\n+                implementation_list = @dvec();\n+                self.crate_context.coherence_info.extension_methods\n+                    .insert(trait_id, implementation_list);\n             }\n-            some(base_type) {\n-                alt get(base_type).struct {\n-                    ty_enum(def_id, _) |\n-                    ty_class(def_id, _) |\n-                    ty_trait(def_id, _) {\n-                        ret some(def_id);\n-                    }\n-                    _ {\n-                        fail ~\"get_base_type() returned a type that \\\n-                               wasn't an enum, class, or trait\";\n-                    }\n-                }\n+            some(existing_implementation_list) {\n+                implementation_list = existing_implementation_list;\n             }\n         }\n+\n+        implementation_list.push(implementation);\n     }\n \n     fn check_implementation_coherence(_trait_def_id: def_id,\n-                                      implementations: @dvec<@item>) {\n+                                      implementations: @dvec<@Impl>) {\n \n         // Unify pairs of polytypes.\n-        for implementations.eachi |i, implementation_a| {\n+        for range(0, implementations.len()) |i| {\n+            let implementation_a = implementations.get_elt(i);\n             let polytype_a =\n                 self.get_self_type_for_implementation(implementation_a);\n             for range(i + 1, implementations.len()) |j| {\n@@ -216,12 +281,12 @@ class CoherenceChecker {\n \n                 if self.polytypes_unify(polytype_a, polytype_b) {\n                     let session = self.crate_context.tcx.sess;\n-                    session.span_err(implementation_b.span,\n+                    session.span_err(self.span_of_impl(implementation_b),\n                                      ~\"conflicting implementations for a \\\n-                                      trait\");\n-                    session.span_note(\n-                        implementation_a.span,\n-                        ~\"note conflicting implementation here\");\n+                                       trait\");\n+                    session.span_note(self.span_of_impl(implementation_a),\n+                                      ~\"note conflicting implementation \\\n+                                        here\");\n                 }\n             }\n         }\n@@ -241,7 +306,7 @@ class CoherenceChecker {\n     // type variables.\n     fn universally_quantify_polytype(polytype: ty_param_bounds_and_ty) -> t {\n         let self_region =\n-            if polytype.rp {none}\n+            if !polytype.rp {none}\n             else {some(self.inference_context.next_region_var_nb())};\n \n         let bounds_count = polytype.bounds.len();\n@@ -257,25 +322,22 @@ class CoherenceChecker {\n         ret subst(self.crate_context.tcx, substitutions, polytype.ty);\n     }\n \n-    fn get_self_type_for_implementation(implementation: @item)\n+    fn get_self_type_for_implementation(implementation: @Impl)\n                                      -> ty_param_bounds_and_ty {\n \n-        alt implementation.node {\n-            item_impl(*) {\n-                let def = local_def(implementation.id);\n-                ret self.crate_context.tcx.tcache.get(def);\n-            }\n-            _ {\n-                self.crate_context.tcx.sess.span_bug(\n-                    implementation.span,\n-                    ~\"not an implementation\");\n-            }\n-        }\n+        ret self.crate_context.tcx.tcache.get(implementation.did);\n     }\n \n     // Privileged scope checking\n \n     fn check_privileged_scopes(crate: @crate) {\n+        // Gather up all privileged types.\n+        let privileged_types =\n+            self.gather_privileged_types(crate.node.module.items);\n+        for privileged_types.each |privileged_type| {\n+            self.privileged_types.insert(privileged_type, ());\n+        }\n+\n         visit_crate(*crate, (), mk_vt(@{\n             visit_item: |item, _context, visitor| {\n                 alt item.node {\n@@ -301,7 +363,7 @@ class CoherenceChecker {\n                         }\n                     }\n                     item_impl(_, optional_trait_ref, _, _) {\n-                        alt self.base_type_def_ids.find(item.id) {\n+                        alt self.base_type_def_ids.find(local_def(item.id)) {\n                             none {\n                                 // Nothing to do.\n                             }\n@@ -329,19 +391,18 @@ class CoherenceChecker {\n \n                                             let session =\n                                                 self.crate_context.tcx.sess;\n-                                            session.span_warn(item.span,\n-                                                              ~\"cannot \\\n-                                                               implement \\\n-                                                               inherent \\\n-                                                               methods for a \\\n-                                                               type outside \\\n-                                                               the scope the \\\n-                                                               type was \\\n-                                                               defined in; \\\n-                                                               define and \\\n-                                                               implement a \\\n-                                                               trait \\\n-                                                               instead\");\n+                                            session.span_err(item.span,\n+                                                             ~\"cannot \\\n+                                                              implement \\\n+                                                              inherent \\\n+                                                              methods for a \\\n+                                                              type outside \\\n+                                                              the scope the \\\n+                                                              type was \\\n+                                                              defined in; \\\n+                                                              define and \\\n+                                                              implement a \\\n+                                                              trait instead\");\n                                         }\n                                         some(trait_ref) {\n                                             // This is OK if and only if the\n@@ -357,13 +418,13 @@ class CoherenceChecker {\n                                             if trait_id.crate != local_crate {\n                                                 let session = self\n                                                     .crate_context.tcx.sess;\n-                                                session.span_warn(item.span,\n-                                                                  ~\"cannot \\\n+                                                session.span_err(item.span,\n+                                                                 ~\"cannot \\\n                                                                    provide \\\n                                                                    an \\\n                                                                    extension \\\n-                                                                   implement\\\n-                                                                      ation \\\n+                                                                   implementa\\\n+                                                                      tion \\\n                                                                    for a \\\n                                                                    trait not \\\n                                                                    defined \\\n@@ -405,6 +466,164 @@ class CoherenceChecker {\n \n         ret results;\n     }\n+\n+    // Converts an implementation in the AST to an Impl structure.\n+    fn create_impl_from_item(item: @item) -> @Impl {\n+        alt item.node {\n+            item_impl(ty_params, _, _, ast_methods) {\n+                let mut methods = ~[];\n+                for ast_methods.each |ast_method| {\n+                    push(methods, @{\n+                        did: local_def(ast_method.id),\n+                        n_tps: ast_method.tps.len(),\n+                        ident: ast_method.ident\n+                    });\n+                }\n+\n+                ret @{\n+                    did: local_def(item.id),\n+                    ident: item.ident,\n+                    methods: methods\n+                };\n+            }\n+            _ {\n+                self.crate_context.tcx.sess.span_bug(item.span,\n+                                                     ~\"can't convert a \\\n+                                                       non-impl to an impl\");\n+            }\n+        }\n+    }\n+\n+    fn span_of_impl(implementation: @Impl) -> span {\n+        assert implementation.did.crate == local_crate;\n+        alt self.crate_context.tcx.items.find(implementation.did.node) {\n+            some(node_item(item, _)) {\n+                ret item.span;\n+            }\n+            _ {\n+                self.crate_context.tcx.sess.bug(~\"span_of_impl() called on \\\n+                                                  something that wasn't an \\\n+                                                  impl!\");\n+            }\n+        }\n+    }\n+\n+    // External crate handling\n+\n+    fn add_impls_for_module(impls_seen: hashmap<def_id,()>,\n+                            crate_store: cstore,\n+                            module_def_id: def_id) {\n+\n+        let implementations = get_impls_for_mod(crate_store,\n+                                                module_def_id,\n+                                                none);\n+        for (*implementations).each |implementation| {\n+            // Make sure we don't visit the same implementation\n+            // multiple times.\n+            alt impls_seen.find(implementation.did) {\n+                none {\n+                    // Good. Continue.\n+                    impls_seen.insert(implementation.did, ());\n+                }\n+                some(_) {\n+                    // Skip this one.\n+                    again;\n+                }\n+            }\n+\n+            let self_type = lookup_item_type(self.crate_context.tcx,\n+                                             implementation.did);\n+            let optional_trait =\n+                get_impl_trait(self.crate_context.tcx,\n+                               implementation.did);\n+            alt optional_trait {\n+                none {\n+                    // This is an inherent method. There should be\n+                    // no problems here, but perform a sanity check\n+                    // anyway.\n+\n+                    alt get_base_type_def_id(self.inference_context,\n+                                             dummy_sp(),\n+                                             self_type.ty) {\n+                        none {\n+                            let session = self.crate_context.tcx.sess;\n+                            session.bug(#fmt(\"no base type for \\\n+                                              external impl with no \\\n+                                              trait: %s (type %s)!\",\n+                                             *implementation.ident,\n+                                             ty_to_str\n+                                             (self.crate_context.tcx,\n+                                              self_type.ty)));\n+                        }\n+                        some(_) {\n+                            // Nothing to do.\n+                        }\n+                    }\n+                }\n+\n+                some(trait_type) {\n+                    alt get(trait_type).struct {\n+                        ty_trait(trait_id, _) {\n+                            self.add_trait_method(trait_id,\n+                                                  implementation);\n+                        }\n+                        _ {\n+                            self.crate_context.tcx.sess\n+                                .bug(~\"trait type returned is not a \\\n+                                       trait\");\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Add the implementation to the mapping from\n+            // implementation to base type def ID, if there is a base\n+            // type for this implementation.\n+\n+            alt get_base_type_def_id(self.inference_context,\n+                                     dummy_sp(),\n+                                     self_type.ty) {\n+                none {\n+                    // Nothing to do.\n+                }\n+                some(base_type_def_id) {\n+                    self.add_inherent_method(base_type_def_id,\n+                                             implementation);\n+\n+                    self.base_type_def_ids.insert(implementation.did,\n+                                                  base_type_def_id);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn add_external_crates() {\n+        let impls_seen = new_def_hash();\n+\n+        let crate_store = self.crate_context.tcx.sess.cstore;\n+        do iter_crate_data(crate_store) |crate_number, _crate_metadata| {\n+            self.add_impls_for_module(impls_seen,\n+                                      crate_store,\n+                                      { crate: crate_number, node: 0 });\n+\n+            for each_path(crate_store, crate_number) |path_entry| {\n+                let module_def_id;\n+                alt path_entry.def_like {\n+                    dl_def(def_mod(def_id)) {\n+                        module_def_id = def_id;\n+                    }\n+                    dl_def(_) | dl_impl(_) | dl_field {\n+                        // Skip this.\n+                        again;\n+                    }\n+                }\n+\n+                self.add_impls_for_module(impls_seen,\n+                                          crate_store,\n+                                          module_def_id);\n+            }\n+        }\n+    }\n }\n \n fn check_coherence(crate_context: @crate_ctxt, crate: @crate) {"}, {"sha": "9334456b44ced84b8935daab73a4e4b5bef98ced", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -437,14 +437,24 @@ fn resolve_borrowings(cx: infer_ctxt) {\n     }\n }\n \n-impl methods for ures {\n+trait then {\n+    fn then<T:copy>(f: fn() -> result<T,ty::type_err>)\n+        -> result<T,ty::type_err>;\n+}\n+\n+impl methods of then for ures {\n     fn then<T:copy>(f: fn() -> result<T,ty::type_err>)\n         -> result<T,ty::type_err> {\n         self.chain(|_i| f())\n     }\n }\n \n-impl methods<T:copy> for cres<T> {\n+trait cres_helpers<T> {\n+    fn to_ures() -> ures;\n+    fn compare(t: T, f: fn() -> ty::type_err) -> cres<T>;\n+}\n+\n+impl methods<T:copy> of cres_helpers<T> for cres<T> {\n     fn to_ures() -> ures {\n         alt self {\n           ok(_v) { ok(()) }\n@@ -1097,19 +1107,22 @@ const force_rvar: uint          = 0b00100000;\n const force_ivar: uint          = 0b01000000;\n const force_all: uint           = 0b01110000;\n \n-type resolve_state = @{\n+type resolve_state_ = {\n     infcx: infer_ctxt,\n     modes: uint,\n     mut err: option<fixup_err>,\n     mut v_seen: ~[tv_vid]\n };\n \n-fn resolver(infcx: infer_ctxt, modes: uint)\n-    -> resolve_state {\n-    @{infcx: infcx,\n-      modes: modes,\n-      mut err: none,\n-      mut v_seen: ~[]}\n+enum resolve_state {\n+    resolve_state_(@resolve_state_)\n+}\n+\n+fn resolver(infcx: infer_ctxt, modes: uint) -> resolve_state {\n+    resolve_state_(@{infcx: infcx,\n+                     modes: modes,\n+                     mut err: none,\n+                     mut v_seen: ~[]})\n }\n \n impl methods for resolve_state {"}, {"sha": "8214e8ffc9844251cd350cdce012fd86c922ba25", "filename": "src/rustdoc/attr_pass.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_pass.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -6,6 +6,7 @@\n      of the natural-language documentation for a crate.\"\n )];\n \n+import doc::item_utils;\n import syntax::ast;\n import syntax::ast_map;\n import std::map::hashmap;\n@@ -48,13 +49,13 @@ fn fold_crate(\n     };\n \n     {\n-        topmod: {\n+        topmod: doc::moddoc_({\n             item: {\n                 name: option::get_default(attrs.name, doc.topmod.name())\n                 with doc.topmod.item\n             }\n-            with doc.topmod\n-        }\n+            with *doc.topmod\n+        })\n     }\n }\n "}, {"sha": "92078bb7d9a789b42840c20de98765df150e28a5", "filename": "src/rustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdesc_to_brief_pass.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -5,6 +5,8 @@\n  * is interpreted as the brief description.\n  */\n \n+import doc::item_utils;\n+\n export mk_pass;\n \n fn mk_pass() -> pass {"}, {"sha": "efbd9c7cd603837c37c5e8173593b8bc0207e6ac", "filename": "src/rustdoc/doc.rs", "status": "modified", "additions": 32, "deletions": 4, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustdoc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustdoc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdoc.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -2,10 +2,14 @@\n \n type ast_id = int;\n \n-type doc = {\n+type doc_ = {\n     pages: ~[page]\n };\n \n+enum doc {\n+    doc_(doc_)\n+}\n+\n enum page {\n     cratepage(cratedoc),\n     itempage(itemtag)\n@@ -59,12 +63,16 @@ type simpleitemdoc = {\n     sig: option<~str>\n };\n \n-type moddoc = {\n+type moddoc_ = {\n     item: itemdoc,\n     items: ~[itemtag],\n     index: option<index>\n };\n \n+enum moddoc {\n+    moddoc_(moddoc_)\n+}\n+\n type nmoddoc = {\n     item: itemdoc,\n     fns: ~[fndoc],\n@@ -221,7 +229,18 @@ impl util for moddoc {\n     }\n }\n \n-impl util for ~[page] {\n+trait page_utils {\n+    fn mods() -> ~[moddoc];\n+    fn nmods() -> ~[nmoddoc];\n+    fn fns() -> ~[fndoc];\n+    fn consts() -> ~[constdoc];\n+    fn enums() -> ~[enumdoc];\n+    fn traits() -> ~[traitdoc];\n+    fn impls() -> ~[impldoc];\n+    fn types() -> ~[tydoc];\n+}\n+\n+impl util of page_utils for ~[page] {\n \n     fn mods() -> ~[moddoc] {\n         do vec::filter_map(self) |page| {\n@@ -339,7 +358,16 @@ impl of item for impldoc {\n     fn item() -> itemdoc { self.item }\n }\n \n-impl util<A:item> for A {\n+trait item_utils {\n+    fn id() -> ast_id;\n+    fn name() -> ~str;\n+    fn path() -> ~[~str];\n+    fn brief() -> option<~str>;\n+    fn desc() -> option<~str>;\n+    fn sections() -> ~[section];\n+}\n+\n+impl util<A:item> of item_utils for A {\n     fn id() -> ast_id {\n         self.item().id\n     }"}, {"sha": "343c018a312d5212e5a9d23039a9c5496c6ab397", "filename": "src/rustdoc/extract.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fextract.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -1,6 +1,7 @@\n //! Converts the Rust AST to the rustdoc document model\n \n import syntax::ast;\n+import doc::item_utils;\n \n export from_srv, extract;\n \n@@ -20,13 +21,13 @@ fn extract(\n     crate: @ast::crate,\n     default_name: ~str\n ) -> doc::doc {\n-    {\n+    doc::doc_({\n         pages: ~[\n             doc::cratepage({\n                 topmod: top_moddoc_from_crate(crate, default_name),\n             })\n         ]\n-    }\n+    })\n }\n \n fn top_moddoc_from_crate(\n@@ -53,7 +54,7 @@ fn moddoc_from_mod(\n     itemdoc: doc::itemdoc,\n     module: ast::_mod\n ) -> doc::moddoc {\n-    {\n+    doc::moddoc_({\n         item: itemdoc,\n         items: do vec::filter_map(module.items) |item| {\n             let itemdoc = mk_itemdoc(item.id, item.ident);\n@@ -104,7 +105,7 @@ fn moddoc_from_mod(\n             }\n         },\n         index: none\n-    }\n+    })\n }\n \n fn nmoddoc_from_mod("}, {"sha": "11b90deecbd50b4f69cfb6e9d8c5a9209d74f9d9", "filename": "src/rustdoc/fold.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ffold.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -132,7 +132,7 @@ fn default_par_fold<T:send copy>(ctxt: T) -> fold<T> {\n }\n \n fn default_seq_fold_doc<T>(fold: fold<T>, doc: doc::doc) -> doc::doc {\n-    {\n+    doc::doc_({\n         pages: do vec::map(doc.pages) |page| {\n             alt page {\n               doc::cratepage(doc) {\n@@ -143,8 +143,8 @@ fn default_seq_fold_doc<T>(fold: fold<T>, doc: doc::doc) -> doc::doc {\n               }\n             }\n         }\n-        with doc\n-    }\n+        with *doc\n+    })\n }\n \n fn default_seq_fold_crate<T>(\n@@ -167,39 +167,39 @@ fn default_any_fold_mod<T:send copy>(\n     fold: fold<T>,\n     doc: doc::moddoc\n ) -> doc::moddoc {\n-    {\n+    doc::moddoc_({\n         item: fold.fold_item(fold, doc.item),\n         items: par::map(doc.items, |itemtag, copy fold| {\n             fold_itemtag(fold, itemtag)\n         })\n-        with doc\n-    }\n+        with *doc\n+    })\n }\n \n fn default_seq_fold_mod<T>(\n     fold: fold<T>,\n     doc: doc::moddoc\n ) -> doc::moddoc {\n-    {\n+    doc::moddoc_({\n         item: fold.fold_item(fold, doc.item),\n         items: vec::map(doc.items, |itemtag| {\n             fold_itemtag(fold, itemtag)\n         })\n-        with doc\n-    }\n+        with *doc\n+    })\n }\n \n fn default_par_fold_mod<T:send copy>(\n     fold: fold<T>,\n     doc: doc::moddoc\n ) -> doc::moddoc {\n-    {\n+    doc::moddoc_({\n         item: fold.fold_item(fold, doc.item),\n         items: par::map(doc.items, |itemtag, copy fold| {\n             fold_itemtag(fold, itemtag)\n         })\n-        with doc\n-    }\n+        with *doc\n+    })\n }\n \n fn default_any_fold_nmod<T:send copy>("}, {"sha": "2aa9afe03ada09eee1cfb1ae2adef042291d8d07", "filename": "src/rustdoc/markdown_index_pass.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustdoc%2Fmarkdown_index_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustdoc%2Fmarkdown_index_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_index_pass.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -1,5 +1,7 @@\n //! Build indexes as appropriate for the markdown pass\n \n+import doc::item_utils;\n+\n export mk_pass;\n \n fn mk_pass(config: config::config) -> pass {\n@@ -31,10 +33,10 @@ fn fold_mod(\n \n     let doc = fold::default_any_fold_mod(fold, doc);\n \n-    {\n+    doc::moddoc_({\n         index: some(build_mod_index(doc, fold.ctxt))\n-        with doc\n-    }\n+        with *doc\n+    })\n }\n \n fn fold_nmod("}, {"sha": "f3962f2a30e9bcbf2f4d2d5490d4426ad4803df4", "filename": "src/rustdoc/markdown_pass.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_pass.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -1,7 +1,9 @@\n //! Generate markdown from a document tree\n \n+import doc::item_utils;\n import markdown_writer::writer;\n import markdown_writer::writer_util;\n+import markdown_writer::writer_utils;\n import markdown_writer::writer_factory;\n \n export mk_pass;\n@@ -513,20 +515,20 @@ fn should_insert_blank_line_after_fn_signature() {\n #[test]\n fn should_correctly_indent_fn_signature() {\n     let doc = test::create_doc(~\"fn a() { }\");\n-    let doc = {\n+    let doc = doc::doc_({\n         pages: ~[\n             doc::cratepage({\n-                topmod: {\n+                topmod: doc::moddoc_({\n                     items: ~[doc::fntag({\n                         sig: some(~\"line 1\\nline 2\")\n                         with doc.cratemod().fns()[0]\n                     })]\n-                    with doc.cratemod()\n-                }\n+                    with *doc.cratemod()\n+                })\n                 with doc.cratedoc()\n             })\n         ]\n-    };\n+    });\n     let markdown = test::write_markdown_str(doc);\n     assert str::contains(markdown, ~\"    line 1\\n    line 2\");\n }"}, {"sha": "64c7ffd6ae8c8cc5314ba2d20fd0b87aaacd55e7", "filename": "src/rustdoc/markdown_writer.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_writer.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -1,7 +1,10 @@\n+import doc::item_utils;\n+\n export writeinstr;\n export writer;\n export writer_factory;\n export writer_util;\n+export writer_utils;\n export make_writer_factory;\n export future_writer_factory;\n export make_filename;\n@@ -14,7 +17,13 @@ enum writeinstr {\n type writer = fn~(+writeinstr);\n type writer_factory = fn~(page: doc::page) -> writer;\n \n-impl writer_util for writer {\n+trait writer_utils {\n+    fn write_str(str: ~str);\n+    fn write_line(str: ~str);\n+    fn write_done();\n+}\n+\n+impl writer_util of writer_utils for writer {\n     fn write_str(str: ~str) {\n         self(write(str));\n     }"}, {"sha": "e5e3866242de749b0f6c594900fae79832274caf", "filename": "src/rustdoc/page_pass.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustdoc%2Fpage_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustdoc%2Fpage_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fpage_pass.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -5,6 +5,7 @@\n  * individual modules, pages for the crate, indexes, etc.\n  */\n \n+import doc::{item_utils, page_utils};\n import syntax::ast;\n \n export mk_pass;\n@@ -51,9 +52,9 @@ fn make_doc_from_pages(page_port: page_port) -> doc::doc {\n             break;\n         }\n     }\n-    {\n+    doc::doc_({\n         pages: pages\n-    }\n+    })\n }\n \n fn find_pages(doc: doc::doc, page_chan: page_chan) {\n@@ -103,16 +104,16 @@ fn fold_mod(\n }\n \n fn strip_mod(doc: doc::moddoc) -> doc::moddoc {\n-    {\n+    doc::moddoc_({\n         items: do vec::filter(doc.items) |item| {\n             alt item {\n               doc::modtag(_) { false }\n               doc::nmodtag(_) { false }\n               _ { true }\n             }\n         }\n-        with doc\n-    }\n+        with *doc\n+    })\n }\n \n fn fold_nmod("}, {"sha": "ffef3ac7815bc2c085ae93cf1c480ed27dd99c10", "filename": "src/rustdoc/path_pass.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustdoc%2Fpath_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustdoc%2Fpath_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fpath_pass.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -1,5 +1,6 @@\n //! Records the full path to items\n \n+import doc::item_utils;\n import syntax::ast;\n \n export mk_pass;\n@@ -46,10 +47,10 @@ fn fold_mod(fold: fold::fold<ctxt>, doc: doc::moddoc) -> doc::moddoc {\n     let doc = fold::default_any_fold_mod(fold, doc);\n     if !is_topmod { vec::pop(fold.ctxt.path); }\n \n-    {\n+    doc::moddoc_({\n         item: fold.fold_item(fold, doc.item)\n-        with doc\n-    }\n+        with *doc\n+    })\n }\n \n fn fold_nmod(fold: fold::fold<ctxt>, doc: doc::nmoddoc) -> doc::nmoddoc {"}, {"sha": "dbb65f0e2d116ddc66e45bc156515c11875f1f8c", "filename": "src/rustdoc/prune_hidden_pass.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustdoc%2Fprune_hidden_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustdoc%2Fprune_hidden_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fprune_hidden_pass.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -1,5 +1,6 @@\n //! Prunes things with the #[doc(hidden)] attribute\n \n+import doc::item_utils;\n import std::map::hashmap;\n export mk_pass;\n \n@@ -24,12 +25,12 @@ fn fold_mod(\n ) -> doc::moddoc {\n     let doc = fold::default_any_fold_mod(fold, doc);\n \n-    {\n+    doc::moddoc_({\n         items: vec::filter(doc.items, |itemtag| {\n             !is_hidden(fold.ctxt, itemtag.item())\n         })\n-        with doc\n-    }\n+        with *doc\n+    })\n }\n \n fn is_hidden(srv: astsrv::srv, doc: doc::itemdoc) -> bool {"}, {"sha": "03d8a3de127ac7bf61272375cba97975054b2eb2", "filename": "src/rustdoc/prune_unexported_pass.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustdoc%2Fprune_unexported_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustdoc%2Fprune_unexported_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fprune_unexported_pass.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -1,5 +1,6 @@\n //! Prunes branches of the tree that are not exported\n \n+import doc::item_utils;\n import syntax::ast;\n import syntax::ast_util;\n import syntax::ast_map;\n@@ -24,10 +25,10 @@ fn run(srv: astsrv::srv, doc: doc::doc) -> doc::doc {\n \n fn fold_mod(fold: fold::fold<astsrv::srv>, doc: doc::moddoc) -> doc::moddoc {\n     let doc = fold::default_any_fold_mod(fold, doc);\n-    {\n+    doc::moddoc_({\n         items: exported_items(fold.ctxt, doc)\n-        with doc\n-    }\n+        with *doc\n+    })\n }\n \n fn exported_items(srv: astsrv::srv, doc: doc::moddoc) -> ~[doc::itemtag] {"}, {"sha": "29f76d162259875aaedb5efb87f891988e5c7e38", "filename": "src/rustdoc/reexport_pass.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustdoc%2Freexport_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustdoc%2Freexport_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Freexport_pass.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -1,5 +1,6 @@\n //! Finds docs for reexported items and duplicates them\n \n+import doc::item_utils;\n import std::map;\n import std::map::hashmap;\n import std::list;\n@@ -331,10 +332,10 @@ fn merge_reexports(\n         let new_items = get_new_items(path, fold.ctxt);\n         #debug(\"merging into %?: %?\", path, new_items);\n \n-        {\n+        doc::moddoc_({\n             items: (doc.items + new_items)\n-            with doc\n-        }\n+            with *doc\n+        })\n     }\n \n     fn get_new_items(path: ~[~str], path_map: path_map) -> ~[doc::itemtag] {\n@@ -352,11 +353,11 @@ fn merge_reexports(\n \n     fn reexport_doc(doc: doc::itemtag, name: ~str) -> doc::itemtag {\n         alt doc {\n-          doc::modtag(doc @ {item, _}) {\n-            doc::modtag({\n+          doc::modtag(doc @ doc::moddoc_({item, _})) {\n+            doc::modtag(doc::moddoc_({\n                 item: reexport(item, name)\n-                with doc\n-            })\n+                with *doc\n+            }))\n           }\n           doc::nmodtag(_) { fail }\n           doc::consttag(doc @ {item, _}) {"}, {"sha": "21db670f7814c6d45d455016051c3dd4f4bb3897", "filename": "src/rustdoc/rustdoc.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustdoc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustdoc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Frustdoc.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -1,4 +1,5 @@\n // Some utility interfaces\n+import doc::item_utils;\n import doc::item;\n import doc::util;\n \n@@ -47,39 +48,39 @@ fn test_run_passes() {\n         _srv: astsrv::srv,\n         doc: doc::doc\n     ) -> doc::doc {\n-        {\n+        doc::doc_({\n             pages: ~[\n                 doc::cratepage({\n-                    topmod: {\n+                    topmod: doc::moddoc_({\n                         item: {\n                             name: doc.cratemod().name() + ~\"two\"\n                             with doc.cratemod().item\n                         },\n                         items: ~[],\n                         index: none\n-                    }\n+                    })\n                 })\n             ]\n-        }\n+        })\n     }\n     fn pass2(\n         _srv: astsrv::srv,\n         doc: doc::doc\n     ) -> doc::doc {\n-        {\n+        doc::doc_({\n             pages: ~[\n                 doc::cratepage({\n-                    topmod: {\n+                    topmod: doc::moddoc_({\n                         item: {\n                             name: doc.cratemod().name() + ~\"three\"\n                             with doc.cratemod().item\n                         },\n                         items: ~[],\n                         index: none\n-                    }\n+                    })\n                 })\n             ]\n-        }\n+        })\n     }\n     let source = ~\"\";\n     do astsrv::from_str(source) |srv| {"}, {"sha": "a06ace654501550eb647990ae367dadd7e38944b", "filename": "src/rustdoc/sectionalize_pass.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fsectionalize_pass.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -1,5 +1,7 @@\n //! Breaks rustdocs into sections according to their headers\n \n+import doc::item_utils;\n+\n export mk_pass;\n \n fn mk_pass() -> pass {"}, {"sha": "6fe4a900699b74679fc6dd838da605ce8b559f93", "filename": "src/rustdoc/sort_item_name_pass.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustdoc%2Fsort_item_name_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustdoc%2Fsort_item_name_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fsort_item_name_pass.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -1,5 +1,6 @@\n //! Sorts items by name\n \n+import doc::item_utils;\n export mk_pass;\n \n fn mk_pass() -> pass {"}, {"sha": "43b197fb01585a6e94a6bf6b2cc7901d7515248b", "filename": "src/rustdoc/sort_item_type_pass.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustdoc%2Fsort_item_type_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustdoc%2Fsort_item_type_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fsort_item_type_pass.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -1,5 +1,7 @@\n //! Sorts items by type\n \n+import doc::item_utils;\n+\n export mk_pass;\n \n fn mk_pass() -> pass {"}, {"sha": "5501fb937cee6945f59564bd8655e2db7fb0b9e5", "filename": "src/rustdoc/sort_pass.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustdoc%2Fsort_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustdoc%2Fsort_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fsort_pass.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -1,5 +1,6 @@\n //! A general sorting pass\n \n+import doc::item_utils;\n import std::sort;\n \n export item_lteq, mk_pass;\n@@ -34,10 +35,10 @@ fn fold_mod(\n     doc: doc::moddoc\n ) -> doc::moddoc {\n     let doc = fold::default_any_fold_mod(fold, doc);\n-    {\n+    doc::moddoc_({\n         items: sort::merge_sort(fold.ctxt, doc.items)\n-        with doc\n-    }\n+        with *doc\n+    })\n }\n \n #[test]"}, {"sha": "c98b1fd7e84cd23a4088c83bfb5d756d83d5ce54", "filename": "src/rustdoc/text_pass.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustdoc%2Ftext_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustdoc%2Ftext_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftext_pass.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -1,5 +1,7 @@\n //! Generic pass for performing an operation on all descriptions\n \n+import doc::item_utils;\n+\n export mk_pass;\n \n fn mk_pass(name: ~str, +op: fn~(~str) -> ~str) -> pass {"}, {"sha": "3ce36f187d730a26393850ef4f5e7cc4a19a5b9c", "filename": "src/rustdoc/trim_pass.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustdoc%2Ftrim_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustdoc%2Ftrim_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftrim_pass.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -5,6 +5,8 @@\n  * is interpreted as the brief description.\n  */\n \n+import doc::item_utils;\n+\n export mk_pass;\n \n fn mk_pass() -> pass {"}, {"sha": "b22c7e121c7e469aea59543c6f9ccd1e3908344a", "filename": "src/rustdoc/tystr_pass.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Frustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftystr_pass.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -1,5 +1,6 @@\n //! Pulls type information out of the AST and attaches it to the document\n \n+import doc::item_utils;\n import syntax::ast;\n import syntax::print::pprust;\n import syntax::ast_map;"}, {"sha": "bf838a9d22c02563774b6f955aaa96c703285d24", "filename": "src/test/auxiliary/ambig_impl_2_lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Fauxiliary%2Fambig_impl_2_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Fauxiliary%2Fambig_impl_2_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fambig_impl_2_lib.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -1 +1,4 @@\n-impl methods1 for uint { fn me() -> uint { self } }\n+trait me {\n+    fn me() -> uint;\n+}\n+impl methods1 of me for uint { fn me() -> uint { self } }"}, {"sha": "af5fa814c6a560689d30f5df793bc3e71ccc19c8", "filename": "src/test/auxiliary/cci_impl_lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Fauxiliary%2Fcci_impl_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Fauxiliary%2Fcci_impl_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_impl_lib.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -1,6 +1,10 @@\n #[link(name=\"cci_impl_lib\", vers=\"0.0\")];\n \n-impl helpers for uint {\n+trait uint_helpers {\n+    fn to(v: uint, f: fn(uint));\n+}\n+\n+impl helpers of uint_helpers for uint {\n     #[inline]\n     fn to(v: uint, f: fn(uint)) {\n         let mut i = self;\n@@ -9,4 +13,4 @@ impl helpers for uint {\n             i += 1u;\n         }\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "3a7f3844019a756c4887a42a2d177040a51473dc", "filename": "src/test/auxiliary/crate-method-reexport-grrrrrrr2.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Fauxiliary%2Fcrate-method-reexport-grrrrrrr2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Fauxiliary%2Fcrate-method-reexport-grrrrrrr2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrate-method-reexport-grrrrrrr2.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -2,26 +2,38 @@\n \n export rust;\n \n+import name_pool::add;\n import name_pool::methods;\n \n mod name_pool {\n \n     type name_pool = ();\n \n-    impl methods for name_pool {\n+    trait add {\n+        fn add(s: ~str);\n+    }\n+\n+    impl methods of add for name_pool {\n         fn add(s: ~str) {\n         }\n     }\n }\n \n mod rust {\n \n+    import name_pool::add;\n+    export add;\n     export rt;\n     export methods;\n+    export cx;\n \n     type rt = @();\n \n-    impl methods for rt {\n+    trait cx {\n+        fn cx();\n+    }\n+\n+    impl methods of cx for rt {\n         fn cx() {\n         }\n     }"}, {"sha": "5eb25c4f44fbc149a5eb7a30aa4c493d89cc07cd", "filename": "src/test/auxiliary/issue-2414-a.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Fauxiliary%2Fissue-2414-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Fauxiliary%2Fissue-2414-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2414-a.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -2,4 +2,12 @@\n #[crate_type = \"lib\"];\n \n type t1 = uint;\n-impl t2 for ~str { }\n+\n+trait foo {\n+    fn foo();\n+}\n+\n+impl t2 of foo for ~str {\n+    fn foo() {}\n+}\n+"}, {"sha": "3fea95383d58df2f319524f5b58cfc0054969f4d", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -7,6 +7,7 @@ An implementation of the Graph500 Breadth First Search problem in Rust.\n use std;\n import std::time;\n import std::map;\n+import std::map::map;\n import std::map::hashmap;\n import std::deque;\n import std::deque::t;"}, {"sha": "7385313d53a9a147cc0d29cf10393e37a5504860", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -19,7 +19,12 @@ import std::map::hashmap;\n type cmplx = {re: f64, im: f64};\n type line = {i: uint, b: ~[u8]};\n \n-impl arith for cmplx {\n+trait times_and_plus {\n+    fn *(x: cmplx) -> cmplx;\n+    fn +(x: cmplx) -> cmplx;\n+}\n+\n+impl arith of times_and_plus for cmplx {\n     fn *(x: cmplx) -> cmplx {\n         {re: self.re*x.re - self.im*x.im, im: self.re*x.im + self.im*x.re}\n     }"}, {"sha": "51247c7e8e9ea0f7ac74cd359864f46aa731d350", "filename": "src/test/compile-fail/ambig_impl_1.rs", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b5729bd60095fb5ca884936775e031cf19900760/src%2Ftest%2Fcompile-fail%2Fambig_impl_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5729bd60095fb5ca884936775e031cf19900760/src%2Ftest%2Fcompile-fail%2Fambig_impl_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fambig_impl_1.rs?ref=b5729bd60095fb5ca884936775e031cf19900760", "patch": "@@ -1,3 +0,0 @@\n-impl methods1 for uint { fn me() -> uint { self } } //~ NOTE candidate #1 is `methods1::me`\n-impl methods2 for uint { fn me() -> uint { self } } //~ NOTE candidate #2 is `methods2::me`\n-fn main() { 1u.me(); } //~ ERROR multiple applicable methods in scope"}, {"sha": "fe6037384407f9c587e28ae21410c95fccfd9616", "filename": "src/test/compile-fail/ambig_impl_2_exe.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Fcompile-fail%2Fambig_impl_2_exe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Fcompile-fail%2Fambig_impl_2_exe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fambig_impl_2_exe.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -2,6 +2,10 @@\n // aux-build:ambig_impl_2_lib.rs\n use ambig_impl_2_lib;\n import ambig_impl_2_lib::methods1;\n-impl methods2 for uint { fn me() -> uint { self } } //~ NOTE is `methods2::me`\n+import ambig_impl_2_lib::me;\n+trait me {\n+    fn me() -> uint;\n+}\n+impl methods2 of me for uint { fn me() -> uint { self } } //~ NOTE is `methods2::me`\n fn main() { 1u.me(); } //~ ERROR multiple applicable methods in scope\n //~^ NOTE is `ambig_impl_2_lib::methods1::me`"}, {"sha": "f6994536a9939f3fbf69f2f9715dc3cd776e0c5b", "filename": "src/test/compile-fail/ambig_impl_unify.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Fcompile-fail%2Fambig_impl_unify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Fcompile-fail%2Fambig_impl_unify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fambig_impl_unify.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -1,12 +1,16 @@\n-impl methods for ~[uint] {\n+trait foo {\n+    fn foo() -> int;\n+}\n+\n+impl methods of foo for ~[uint] {\n     fn foo() -> int {1} //~ NOTE candidate #1 is `methods::foo`\n }\n \n-impl methods for ~[int] {\n+impl methods of foo for ~[int] {\n     fn foo() -> int {2} //~ NOTE candidate #2 is `methods::foo`\n }\n \n fn main() {\n     let x = ~[];\n     x.foo(); //~ ERROR multiple applicable methods in scope\n-}\n\\ No newline at end of file\n+}"}, {"sha": "18f160ce8e4d7a01de18488c7a4ef90a1f3da052", "filename": "src/test/compile-fail/bad-method-typaram-kind.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Fcompile-fail%2Fbad-method-typaram-kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Fcompile-fail%2Fbad-method-typaram-kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-method-typaram-kind.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -2,7 +2,11 @@ fn foo<T>() {\n     1u.bar::<T>(); //~ ERROR: missing `copy`\n }\n \n-impl methods for uint {\n+trait bar {\n+    fn bar<T:copy>();\n+}\n+\n+impl methods of bar for uint {\n     fn bar<T:copy>() {\n     }\n }"}, {"sha": "4e084ba35c3c4e2e9744665b95d9771caeca4547", "filename": "src/test/compile-fail/borrowck-loan-rcvr-overloaded-op.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr-overloaded-op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr-overloaded-op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr-overloaded-op.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -1,6 +1,11 @@\n type point = { x: int, y: int };\n \n-impl foo for point {\n+trait add_and_times {\n+    pure fn +(z: int) -> int;\n+    fn *(z: int) -> int;\n+}\n+\n+impl foo of add_and_times for point {\n     pure fn +(z: int) -> int { self.x + self.y + z }\n     fn *(z: int) -> int { self.x * self.y * z }\n }"}, {"sha": "77cec9c869ce8478da08c6ff37ee28b5a92cd491", "filename": "src/test/compile-fail/borrowck-loan-rcvr.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -1,6 +1,12 @@\n type point = { x: int, y: int };\n \n-impl foo for point {\n+trait methods {\n+    fn impurem();\n+    fn blockm(f: fn());\n+    pure fn purem();\n+}\n+\n+impl foo of methods for point {\n     fn impurem() {\n     }\n "}, {"sha": "dc1b9501df049d99e956a8068fe8507ed65a2d1a", "filename": "src/test/compile-fail/iface-test-2.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Fcompile-fail%2Fiface-test-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Fcompile-fail%2Fiface-test-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fiface-test-2.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -1,11 +1,9 @@\n iface bar { fn dup() -> self; fn blah<X>(); }\n impl of bar for int { fn dup() -> int { self } fn blah<X>() {} }\n impl of bar for uint { fn dup() -> uint { self } fn blah<X>() {} }\n-impl of bar for uint { fn dup() -> uint { self } fn blah<X>() {} }\n \n fn main() {\n     10.dup::<int>(); //~ ERROR does not take type parameters\n     10.blah::<int, int>(); //~ ERROR incorrect number of type parameters\n-    10u.dup(); //~ ERROR multiple applicable methods\n     (10 as bar).dup(); //~ ERROR contains a self type\n }"}, {"sha": "d2d8744e47925d0aad2e6e080e9dd813e9d1498c", "filename": "src/test/compile-fail/issue-2063.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Fcompile-fail%2Fissue-2063.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Fcompile-fail%2Fissue-2063.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2063.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -3,10 +3,14 @@\n // of such a type could ever be constructed.\n enum t = @t; //~ ERROR this type cannot be instantiated\n \n+trait to_str_2 {\n+    fn to_str() -> ~str;\n+}\n+\n // I use an impl here because it will cause\n // the compiler to attempt autoderef and then\n // try to resolve the method.\n-impl methods for t {\n+impl methods of to_str_2 for t {\n     fn to_str() -> ~str { ~\"t\" }\n }\n "}, {"sha": "344d151ae2b66ebafa63d33d6f6fa4ce3d14258b", "filename": "src/test/compile-fail/issue-2149.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -1,4 +1,8 @@\n-impl monad<A> for ~[A] {\n+trait vec_monad<A> {\n+    fn bind<B>(f: fn(A) -> ~[B]);\n+}\n+\n+impl monad<A> of vec_monad<A> for ~[A] {\n     fn bind<B>(f: fn(A) -> ~[B]) {\n         let mut r = fail;\n         for self.each |elt| { r += f(elt); }\n@@ -8,4 +12,4 @@ impl monad<A> for ~[A] {\n }\n fn main() {\n     [\"hi\"].bind({|x| [x] });\n-}\n\\ No newline at end of file\n+}"}, {"sha": "132ce4757e0c6176e4997d6a0be9fe3d3d54fc51", "filename": "src/test/compile-fail/issue-2590.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Fcompile-fail%2Fissue-2590.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Fcompile-fail%2Fissue-2590.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2590.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -4,7 +4,11 @@ type parser = {\n     tokens: dvec<int>,\n };\n \n-impl parser for parser {\n+trait parse {\n+    fn parse() -> ~[mut int];\n+}\n+\n+impl parser of parse for parser {\n     fn parse() -> ~[mut int] {\n         dvec::unwrap(self.tokens) //~ ERROR illegal move from self\n     }"}, {"sha": "2cbf91c8d2a3e68992031a695f2ce954fd57bdd7", "filename": "src/test/compile-fail/placement-new-bad-method-type.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Fcompile-fail%2Fplacement-new-bad-method-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Fcompile-fail%2Fplacement-new-bad-method-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fplacement-new-bad-method-type.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -2,7 +2,11 @@ import libc, unsafe;\n \n enum malloc_pool = ();\n \n-impl methods for malloc_pool {\n+trait alloc {\n+    fn alloc(sz: int, align: int) -> *();\n+}\n+\n+impl methods of alloc for malloc_pool {\n     fn alloc(sz: int, align: int) -> *() {\n         fail;\n     }"}, {"sha": "20cb1fa6b6b5bb98d917312c57e4d1fd107b6017", "filename": "src/test/compile-fail/pure-modifies-aliased.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Fcompile-fail%2Fpure-modifies-aliased.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Fcompile-fail%2Fpure-modifies-aliased.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpure-modifies-aliased.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -8,11 +8,15 @@ pure fn modify_in_box(sum: @mut {f: int}) {\n     sum.f = 3; //~ ERROR assigning to mutable field prohibited in pure context\n }\n \n-impl foo for int {\n+trait modify_in_box_rec {\n+    pure fn modify_in_box_rec(sum: @{mut f: int});\n+}\n+\n+impl foo of modify_in_box_rec for int {\n     pure fn modify_in_box_rec(sum: @{mut f: int}) {\n         sum.f = self; //~ ERROR assigning to mutable field prohibited in pure context\n     }\n }\n \n fn main() {\n-}\n\\ No newline at end of file\n+}"}, {"sha": "c07512e20f50e150e64334c60e9102cc38dbc254", "filename": "src/test/compile-fail/pure-overloaded-op.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Fcompile-fail%2Fpure-overloaded-op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Fcompile-fail%2Fpure-overloaded-op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpure-overloaded-op.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -1,6 +1,13 @@\n type point = { x: int, y: int };\n \n-impl foo for point {\n+trait operators {\n+    pure fn +(z: int) -> int;\n+    fn *(z: int) -> int;\n+    fn [](z: int) -> int;\n+    fn unary-() -> int;\n+}\n+\n+impl foo of operators for point {\n     // expr_binary\n     pure fn +(z: int) -> int { self.x + self.y + z }\n     fn *(z: int) -> int { self.x * self.y * z }"}, {"sha": "9a2329f849e7ef582ecd760fc828e1eb2c5bc926", "filename": "src/test/compile-fail/regions-infer-paramd-indirect.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-indirect.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -5,7 +5,12 @@ type a = &int;\n type b = @a;\n type c = {f: @b};\n \n-impl methods for c {\n+trait set_f {\n+    fn set_f_ok(b: @b/&self);\n+    fn set_f_bad(b: @b);\n+}\n+\n+impl methods of set_f for c {\n     fn set_f_ok(b: @b/&self) {\n         self.f = b;\n     }\n@@ -15,4 +20,4 @@ impl methods for c {\n     }\n }\n \n-fn main() {}\n\\ No newline at end of file\n+fn main() {}"}, {"sha": "33c699c0c86d0028d73a6db0d134e90215e71818", "filename": "src/test/compile-fail/regions-infer-paramd-method.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-method.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -9,7 +9,11 @@ iface foo {\n \n type with_foo = {mut f: foo};\n \n-impl methods for with_foo {\n+trait set_foo_foo {\n+    fn set_foo(f: foo);\n+}\n+\n+impl methods of set_foo_foo for with_foo {\n     fn set_foo(f: foo) {\n         self.f = f; //~ ERROR mismatched types: expected `foo/&self` but found `foo/&`\n     }\n@@ -23,10 +27,14 @@ iface bar {\n \n type with_bar = {mut f: bar};\n \n-impl methods for with_bar {\n+trait set_foo_bar {\n+    fn set_foo(f: bar);\n+}\n+\n+impl methods of set_foo_bar for with_bar {\n     fn set_foo(f: bar) {\n         self.f = f;\n     }\n }\n \n-fn main() {}\n\\ No newline at end of file\n+fn main() {}"}, {"sha": "3d67a5fd1f5ace6b7917f664857946c9376999fb", "filename": "src/test/run-pass/autoderef-method-newtype.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Frun-pass%2Fautoderef-method-newtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Frun-pass%2Fautoderef-method-newtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoderef-method-newtype.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -1,4 +1,8 @@\n-impl methods for uint {\n+trait double {\n+    fn double() -> uint;\n+}\n+\n+impl methods of double for uint {\n     fn double() -> uint { self * 2u }\n }\n "}, {"sha": "23f2a5e6b494f6ec980d81e40d50148e1faa4e08", "filename": "src/test/run-pass/autoderef-method-priority.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Frun-pass%2Fautoderef-method-priority.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Frun-pass%2Fautoderef-method-priority.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoderef-method-priority.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -1,8 +1,12 @@\n-impl methods for uint {\n+trait double {\n+    fn double() -> uint;\n+}\n+\n+impl methods of double for uint {\n     fn double() -> uint { self }\n }\n \n-impl methods for @uint {\n+impl methods of double for @uint {\n     fn double() -> uint { *self * 2u }\n }\n "}, {"sha": "45f8ffde6d89f3324ddb4ddf6ae0d93997e1cc0b", "filename": "src/test/run-pass/autoderef-method-twice-but-not-thrice.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Frun-pass%2Fautoderef-method-twice-but-not-thrice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Frun-pass%2Fautoderef-method-twice-but-not-thrice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoderef-method-twice-but-not-thrice.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -1,4 +1,8 @@\n-impl methods for @@uint {\n+trait double {\n+    fn double() -> uint;\n+}\n+\n+impl methods of double for @@uint {\n     fn double() -> uint { **self * 2u }\n }\n "}, {"sha": "899769352d66b61f6c0e4c9a0647867c38d2484a", "filename": "src/test/run-pass/autoderef-method-twice.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Frun-pass%2Fautoderef-method-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Frun-pass%2Fautoderef-method-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoderef-method-twice.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -1,4 +1,8 @@\n-impl methods for uint {\n+trait double {\n+    fn double() -> uint;\n+}\n+\n+impl methods of double for uint {\n     fn double() -> uint { self * 2u }\n }\n "}, {"sha": "5b66ce718f4adcd02b0c067e59d5e76a13695641", "filename": "src/test/run-pass/autoderef-method.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Frun-pass%2Fautoderef-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Frun-pass%2Fautoderef-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoderef-method.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -1,4 +1,8 @@\n-impl methods for uint {\n+trait double {\n+    fn double() -> uint;\n+}\n+\n+impl methods of double for uint {\n     fn double() -> uint { self * 2u }\n }\n "}, {"sha": "108613f54a2bf86f8cb5c4375c1a89561e58a702", "filename": "src/test/run-pass/borrowck-newtype-issue-2573.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Frun-pass%2Fborrowck-newtype-issue-2573.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Frun-pass%2Fborrowck-newtype-issue-2573.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-newtype-issue-2573.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -2,7 +2,11 @@ enum foo = {mut bar: baz};\n \n enum baz = @{mut baz: int};\n \n-impl quuux for foo {\n+trait frob {\n+    fn frob();\n+}\n+\n+impl quuux of frob for foo {\n     fn frob() {\n         really_impure(self.bar);\n     }\n@@ -13,4 +17,4 @@ fn really_impure(++bar: baz) {\n     bar.baz = 3;\n }\n \n-fn main() {}\n\\ No newline at end of file\n+fn main() {}"}, {"sha": "04dd607d76e8cff41b1382798d2f4116747b2b58", "filename": "src/test/run-pass/cci_impl_exe.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Frun-pass%2Fcci_impl_exe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Frun-pass%2Fcci_impl_exe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcci_impl_exe.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -3,6 +3,7 @@\n \n use cci_impl_lib;\n import cci_impl_lib::helpers;\n+import cci_impl_lib::uint_helpers;\n \n fn main() {\n     //let bt0 = sys::frame_address();"}, {"sha": "37da90be375cc7af6f8a2d6ff223bb1041451e3a", "filename": "src/test/run-pass/crate-method-reexport-grrrrrrr.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Frun-pass%2Fcrate-method-reexport-grrrrrrr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Frun-pass%2Fcrate-method-reexport-grrrrrrr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcrate-method-reexport-grrrrrrr.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -9,6 +9,8 @@ use crate_method_reexport_grrrrrrr2;\n \n fn main() {\n     import crate_method_reexport_grrrrrrr2::rust::methods;\n+    import crate_method_reexport_grrrrrrr2::rust::add;\n+    import crate_method_reexport_grrrrrrr2::rust::cx;\n     let x = @();\n     x.cx();\n     let y = ();"}, {"sha": "64459fbe91cf4f314236a4e28adc8ac3bf984472", "filename": "src/test/run-pass/fixed_length_vec_glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Frun-pass%2Ffixed_length_vec_glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Frun-pass%2Ffixed_length_vec_glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffixed_length_vec_glue.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -1,6 +1,6 @@\n fn main() {\n     let arr = [1,2,3]/3;\n-    let struct = {a: 13u8, b: arr, c: 42};\n-    let s = sys::log_str(struct);\n+    let struc = {a: 13u8, b: arr, c: 42};\n+    let s = sys::log_str(struc);\n     assert(s == ~\"(13, [1, 2, 3]/3, 42)\");\n }"}, {"sha": "1a913abbbf04cad660e24f89f3ed4b5747ec9a54", "filename": "src/test/run-pass/impl-variance.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Frun-pass%2Fimpl-variance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Frun-pass%2Fimpl-variance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimpl-variance.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -1,4 +1,8 @@\n-impl extensions<T> for ~[const T] {\n+trait foo {\n+    fn foo() -> uint;\n+}\n+\n+impl extensions<T> of foo for ~[const T] {\n     fn foo() -> uint { vec::len(self) }\n }\n \n@@ -9,4 +13,4 @@ fn main() {\n     assert v.foo() == 1u;\n     let v = ~[mut 0];\n     assert v.foo() == 1u;\n-}\n\\ No newline at end of file\n+}"}, {"sha": "ab75dd6b4e5b337b9bb0962394ff5ab0a3f7a5ce", "filename": "src/test/run-pass/int-conversion-coherence.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Frun-pass%2Fint-conversion-coherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Frun-pass%2Fint-conversion-coherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fint-conversion-coherence.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -0,0 +1,16 @@\n+// xfail-test\n+//\n+// Problem here is that transactions aren't implemented for integer literal\n+// inference.\n+\n+trait plus {\n+    fn plus() -> int;\n+}\n+\n+impl foo of plus for uint { fn plus() -> int { self as int + 20 } }\n+impl foo of plus for int { fn plus() -> int { self + 10 } }\n+\n+fn main() {\n+    assert 10.plus() == 20;\n+}\n+"}, {"sha": "0b711682b0a78d04c1aa4eb163a066b10eb66aed", "filename": "src/test/run-pass/method-attributes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Frun-pass%2Fmethod-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Frun-pass%2Fmethod-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmethod-attributes.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -9,7 +9,7 @@ iface frobable {\n }\n \n #[int_frobable]\n-impl frobable for int {\n+impl frobable of frobable for int {\n     #[frob_attr1]\n     fn frob() {\n         #[frob_attr2];"}, {"sha": "ec68d32ba9527c1d78384188719a7a619a542ad9", "filename": "src/test/run-pass/module-polymorphism4-files/trait.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Frun-pass%2Fmodule-polymorphism4-files%2Ftrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Frun-pass%2Fmodule-polymorphism4-files%2Ftrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmodule-polymorphism4-files%2Ftrait.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -1,4 +1,8 @@\n-impl talky for T {\n+trait says {\n+    fn says() -> ~str;\n+}\n+\n+impl talky of says for T {\n \n     // 'animal' and 'talk' functions are implemented by the module\n     // instantiating the talky trait. They are 'abstract'"}, {"sha": "3b0f6c1bbdf7c67f0c4b24baae38a1bc451a99bb", "filename": "src/test/run-pass/monad.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Frun-pass%2Fmonad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Frun-pass%2Fmonad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmonad.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -1,12 +1,20 @@\n-impl monad<A> for ~[A] {\n+trait vec_monad<A> {\n+    fn bind<B>(f: fn(A) -> ~[B]) -> ~[B];\n+}\n+\n+impl monad<A> of vec_monad<A> for ~[A] {\n     fn bind<B>(f: fn(A) -> ~[B]) -> ~[B] {\n         let mut r = ~[];\n         for self.each |elt| { r += f(elt); }\n         r\n     }\n }\n \n-impl monad<A> for option<A> {\n+trait option_monad<A> {\n+    fn bind<B>(f: fn(A) -> option<B>) -> option<B>;\n+}\n+\n+impl monad<A> of option_monad<A> for option<A> {\n     fn bind<B>(f: fn(A) -> option<B>) -> option<B> {\n         alt self {\n           some(a) { f(a) }"}, {"sha": "c3a0dcec7dfdf350207e2ecb0e46efaf60d82617", "filename": "src/test/run-pass/operator-overloading-leaks.rs", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Frun-pass%2Foperator-overloading-leaks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Frun-pass%2Foperator-overloading-leaks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foperator-overloading-leaks.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -1,6 +1,11 @@\n // The cases commented as \"Leaks\" need to not leak. Issue #2581\n \n-impl methods<T: copy> for ~[T] {\n+trait minus_and_foo<T> {\n+    fn -(x: &[T]) -> ~[T];\n+    fn foo(x: &[T]) -> ~[T];\n+}\n+\n+impl methods<T: copy> of minus_and_foo<T> for ~[T] {\n     fn -(x: &[T]) -> ~[T] {\n         ~[x[0], x[0], x[0]]\n     }\n@@ -10,19 +15,31 @@ impl methods<T: copy> for ~[T] {\n     }\n }\n \n-impl methods<T: copy> for ~T {\n+trait plus_uniq<T> {\n+    fn +(rhs: ~T) -> ~T;\n+}\n+\n+impl methods<T: copy> of plus_uniq<T> for ~T {\n     fn +(rhs: ~T) -> ~T {\n         rhs\n     }\n }\n \n-impl methods for ~int {\n+trait minus {\n+    fn -(rhs: ~int) -> ~int;\n+}\n+\n+impl methods of minus for ~int {\n     fn -(rhs: ~int) -> ~int {\n         ~(*self - *rhs)\n     }\n }\n \n-impl methods for @int {\n+trait plus_boxed {\n+    fn +(rhs: @int) -> @int;\n+}\n+\n+impl methods of plus_boxed for @int {\n     fn +(rhs: @int) -> @int {\n         @(*self + *rhs)\n     }"}, {"sha": "fb8cdd47f785008dacfe2c340064971a68ea1276", "filename": "src/test/run-pass/operator-overloading.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Frun-pass%2Foperator-overloading.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Frun-pass%2Foperator-overloading.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foperator-overloading.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -1,6 +1,13 @@\n type point = {x: int, y: int};\n \n-impl point_ops for point {\n+trait ops {\n+    fn +(other: point) -> point;\n+    fn -(other: point) -> point;\n+    fn unary-() -> point;\n+    fn [](x: bool) -> int;\n+}\n+\n+impl point_ops of ops for point {\n     fn +(other: point) -> point {\n         {x: self.x + other.x, y: self.y + other.y}\n     }"}, {"sha": "8624e5682a815aee8ff9ba266792671fbc56d60e", "filename": "src/test/run-pass/rcvr-borrowed-to-region.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-region.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -1,5 +1,9 @@\n+trait get {\n+    fn get() -> int;\n+}\n+\n // Note: impl on a slice\n-impl foo for &int {\n+impl foo of get for &int {\n     fn get() -> int {\n         ret *self;\n     }\n@@ -31,4 +35,4 @@ fn main() {\n     let y = x.get();\n     #debug[\"y=%d\", y];\n     assert y == 6;\n-}\n\\ No newline at end of file\n+}"}, {"sha": "10f91de86150d6cf96f6c021087181192950e6f0", "filename": "src/test/run-pass/rcvr-borrowed-to-slice.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-slice.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -1,5 +1,9 @@\n+trait sum {\n+    fn sum() -> int;\n+}\n+\n // Note: impl on a slice\n-impl foo for &[int] {\n+impl foo of sum for &[int] {\n     fn sum() -> int {\n         let mut sum = 0;\n         for vec::each(self) |e| { sum += e; }\n@@ -24,4 +28,4 @@ fn main() {\n     let y = x.sum();\n     #debug[\"y==%d\", y];\n     assert y == 6;\n-}\n\\ No newline at end of file\n+}"}, {"sha": "07457aa492bde17d68477a7c190fe7c3eaecf140", "filename": "src/test/run-pass/regions-self-impls.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Frun-pass%2Fregions-self-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Frun-pass%2Fregions-self-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-self-impls.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -1,6 +1,10 @@\n type clam = { chowder: &int };\n \n-impl clam for clam {\n+trait get_chowder {\n+    fn get_chowder() -> &self/int;\n+}\n+\n+impl clam of get_chowder for clam {\n     fn get_chowder() -> &self/int { ret self.chowder; }\n }\n "}, {"sha": "580713dab0f9d11af4b0171120e12fe5c59eb41c", "filename": "src/test/run-pass/static-impl.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Frun-pass%2Fstatic-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db020ab63cd51dd4a25cba2d00117f016128762b/src%2Ftest%2Frun-pass%2Fstatic-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-impl.rs?ref=db020ab63cd51dd4a25cba2d00117f016128762b", "patch": "@@ -1,23 +1,38 @@\n import a::*;\n import b::baz;\n \n+trait plus {\n+    fn plus() -> int;\n+}\n+\n mod a {\n-    impl foo for uint { fn plus() -> int { self as int + 20 } }\n+    impl foo of plus for uint { fn plus() -> int { self as int + 20 } }\n }\n \n mod b {\n-    impl baz for ~str { fn plus() -> int { 200 } }\n+    impl baz of plus for ~str { fn plus() -> int { 200 } }\n+}\n+\n+trait uint_utils {\n+    fn str() -> ~str;\n+    fn multi(f: fn(uint));\n }\n \n-impl util for uint {\n+impl util of uint_utils for uint {\n     fn str() -> ~str { uint::str(self) }\n     fn multi(f: fn(uint)) {\n         let mut c = 0u;\n         while c < self { f(c); c += 1u; }\n     }\n }\n \n-impl util<T> for ~[T] {\n+trait vec_utils<T> {\n+    fn length_() -> uint;\n+    fn iter_(f: fn(T));\n+    fn map_<U>(f: fn(T) -> U) -> ~[U];\n+}\n+\n+impl util<T> of vec_utils<T> for ~[T] {\n     fn length_() -> uint { vec::len(self) }\n     fn iter_(f: fn(T)) { for self.each |x| { f(x); } }\n     fn map_<U>(f: fn(T) -> U) -> ~[U] {\n@@ -28,8 +43,6 @@ impl util<T> for ~[T] {\n }\n \n fn main() {\n-    impl foo for int { fn plus() -> int { self + 10 } }\n-    assert 10.plus() == 20;\n     assert 10u.plus() == 30;\n     assert (~\"hi\").plus() == 200;\n "}]}