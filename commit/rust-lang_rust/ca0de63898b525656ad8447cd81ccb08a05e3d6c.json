{"sha": "ca0de63898b525656ad8447cd81ccb08a05e3d6c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhMGRlNjM4OThiNTI1NjU2YWQ4NDQ3Y2Q4MWNjYjA4YTA1ZTNkNmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-29T08:42:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-29T08:42:20Z"}, "message": "Auto merge of #53711 - arielb1:macro-table, r=michaelwoerister\n\ncreate a valid DefIdTable for proc macro crates\n\nAt least the incremental compilation code, and a few other places in the\ncompiler, require the CrateMetadata for a loaded target crate to contain a\nvalid DefIdTable for the DefIds in the target.\n\nPreviously, the CrateMetadata for a proc macro contained the crate's\n\"host\" DefIdTable, which is of course incompatible with the \"target\"\nDefIdTable, causing ICEs. This creates a DefIdTable that properly refers\nto the \"proc macro\" DefIds.\n\nFixes #49482.\n\nr? @michaelwoerister\n\nShould we beta-nominate this?", "tree": {"sha": "42c7f189214a54b9f35f3c0647ab87674b277cc5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/42c7f189214a54b9f35f3c0647ab87674b277cc5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ca0de63898b525656ad8447cd81ccb08a05e3d6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ca0de63898b525656ad8447cd81ccb08a05e3d6c", "html_url": "https://github.com/rust-lang/rust/commit/ca0de63898b525656ad8447cd81ccb08a05e3d6c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ca0de63898b525656ad8447cd81ccb08a05e3d6c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f4e981cfe474f598b34ca07df8c8f16f042e120f", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4e981cfe474f598b34ca07df8c8f16f042e120f", "html_url": "https://github.com/rust-lang/rust/commit/f4e981cfe474f598b34ca07df8c8f16f042e120f"}, {"sha": "025d01432fbdbefe24f7d3b4b487d040732f67fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/025d01432fbdbefe24f7d3b4b487d040732f67fa", "html_url": "https://github.com/rust-lang/rust/commit/025d01432fbdbefe24f7d3b4b487d040732f67fa"}], "stats": {"total": 226, "additions": 195, "deletions": 31}, "files": [{"sha": "be37ea18457f16a90cff2aeb4e222f3b06dbd9ca", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ca0de63898b525656ad8447cd81ccb08a05e3d6c/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca0de63898b525656ad8447cd81ccb08a05e3d6c/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=ca0de63898b525656ad8447cd81ccb08a05e3d6c", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use ty;\n-\n+use hir::map::definitions::FIRST_FREE_HIGH_DEF_INDEX;\n use rustc_data_structures::indexed_vec::Idx;\n use serialize;\n use std::fmt;\n@@ -125,15 +125,25 @@ impl DefIndex {\n     // index of the macro in the CrateMetadata::proc_macros array) to the\n     // corresponding DefIndex.\n     pub fn from_proc_macro_index(proc_macro_index: usize) -> DefIndex {\n-        let def_index = DefIndex::from_array_index(proc_macro_index,\n-                                                   DefIndexAddressSpace::High);\n+        // DefIndex for proc macros start from FIRST_FREE_HIGH_DEF_INDEX,\n+        // because the first FIRST_FREE_HIGH_DEF_INDEX indexes are reserved\n+        // for internal use.\n+        let def_index = DefIndex::from_array_index(\n+            proc_macro_index.checked_add(FIRST_FREE_HIGH_DEF_INDEX)\n+                .expect(\"integer overflow adding `proc_macro_index`\"),\n+            DefIndexAddressSpace::High);\n         assert!(def_index != CRATE_DEF_INDEX);\n         def_index\n     }\n \n     // This function is the reverse of from_proc_macro_index() above.\n     pub fn to_proc_macro_index(self: DefIndex) -> usize {\n-        self.as_array_index()\n+        assert_eq!(self.address_space(), DefIndexAddressSpace::High);\n+\n+        self.as_array_index().checked_sub(FIRST_FREE_HIGH_DEF_INDEX)\n+            .unwrap_or_else(|| {\n+                bug!(\"using local index {:?} as proc-macro index\", self)\n+            })\n     }\n \n     // Don't use this if you don't know about the DefIndex encoding.\n@@ -150,7 +160,7 @@ impl DefIndex {\n impl serialize::UseSpecializedEncodable for DefIndex {}\n impl serialize::UseSpecializedDecodable for DefIndex {}\n \n-#[derive(Copy, Clone, Hash)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n pub enum DefIndexAddressSpace {\n     Low = 0,\n     High = 1,"}, {"sha": "0b7fb5603cc40baf38a17236c025b1ae5ce265b7", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ca0de63898b525656ad8447cd81ccb08a05e3d6c/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca0de63898b525656ad8447cd81ccb08a05e3d6c/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=ca0de63898b525656ad8447cd81ccb08a05e3d6c", "patch": "@@ -380,6 +380,17 @@ impl Borrow<Fingerprint> for DefPathHash {\n \n impl Definitions {\n     /// Create new empty definition map.\n+    ///\n+    /// The DefIndex returned from a new Definitions are as follows:\n+    /// 1. At DefIndexAddressSpace::Low,\n+    ///     CRATE_ROOT has index 0:0, and then new indexes are allocated in\n+    ///     ascending order.\n+    /// 2. At DefIndexAddressSpace::High,\n+    ///     the first FIRST_FREE_HIGH_DEF_INDEX indexes are reserved for\n+    ///     internal use, then 1:FIRST_FREE_HIGH_DEF_INDEX are allocated in\n+    ///     ascending order.\n+    ///\n+    /// FIXME: there is probably a better place to put this comment.\n     pub fn new() -> Definitions {\n         Definitions {\n             table: DefPathTable {\n@@ -665,6 +676,11 @@ impl DefPathData {\n     }\n }\n \n+macro_rules! count {\n+    () => (0usize);\n+    ( $x:tt $($xs:tt)* ) => (1usize + count!($($xs)*));\n+}\n+\n // We define the GlobalMetaDataKind enum with this macro because we want to\n // make sure that we exhaustively iterate over all variants when registering\n // the corresponding DefIndices in the DefTable.\n@@ -678,6 +694,7 @@ macro_rules! define_global_metadata_kind {\n         }\n \n         const GLOBAL_MD_ADDRESS_SPACE: DefIndexAddressSpace = DefIndexAddressSpace::High;\n+        pub const FIRST_FREE_HIGH_DEF_INDEX: usize = count!($($variant)*);\n \n         impl GlobalMetaDataKind {\n             fn allocate_def_indices(definitions: &mut Definitions) {"}, {"sha": "5eb541952150f06cb3955f5089ea1f18a905657e", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ca0de63898b525656ad8447cd81ccb08a05e3d6c/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca0de63898b525656ad8447cd81ccb08a05e3d6c/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=ca0de63898b525656ad8447cd81ccb08a05e3d6c", "patch": "@@ -12,6 +12,7 @@\n \n use cstore::{self, CStore, CrateSource, MetadataBlob};\n use locator::{self, CratePaths};\n+use decoder::proc_macro_def_path_table;\n use schema::CrateRoot;\n use rustc_data_structures::sync::{Lrc, RwLock, Lock};\n \n@@ -219,8 +220,16 @@ impl<'a> CrateLoader<'a> {\n \n         let dependencies: Vec<CrateNum> = cnum_map.iter().cloned().collect();\n \n+        let proc_macros = crate_root.macro_derive_registrar.map(|_| {\n+            self.load_derive_macros(&crate_root, dylib.clone().map(|p| p.0), span)\n+        });\n+\n         let def_path_table = record_time(&self.sess.perf_stats.decode_def_path_tables_time, || {\n-            crate_root.def_path_table.decode((&metadata, self.sess))\n+            if let Some(proc_macros) = &proc_macros {\n+                proc_macro_def_path_table(&crate_root, proc_macros)\n+            } else {\n+                crate_root.def_path_table.decode((&metadata, self.sess))\n+            }\n         });\n \n         let interpret_alloc_index: Vec<u32> = crate_root.interpret_alloc_index\n@@ -237,9 +246,7 @@ impl<'a> CrateLoader<'a> {\n             extern_crate: Lock::new(None),\n             def_path_table: Lrc::new(def_path_table),\n             trait_impls,\n-            proc_macros: crate_root.macro_derive_registrar.map(|_| {\n-                self.load_derive_macros(&crate_root, dylib.clone().map(|p| p.0), span)\n-            }),\n+            proc_macros,\n             root: crate_root,\n             blob: metadata,\n             cnum_map,"}, {"sha": "f4456b96027aeba2c9e3685c5b241250fdccf46a", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 45, "deletions": 22, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/ca0de63898b525656ad8447cd81ccb08a05e3d6c/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca0de63898b525656ad8447cd81ccb08a05e3d6c/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=ca0de63898b525656ad8447cd81ccb08a05e3d6c", "patch": "@@ -14,14 +14,14 @@ use cstore::{self, CrateMetadata, MetadataBlob, NativeLibrary, ForeignModule};\n use schema::*;\n \n use rustc_data_structures::sync::{Lrc, ReadGuard};\n-use rustc::hir::map::{DefKey, DefPath, DefPathData, DefPathHash,\n-                      DisambiguatedDefPathData};\n+use rustc::hir::map::{DefKey, DefPath, DefPathData, DefPathHash, Definitions};\n use rustc::hir;\n use rustc::middle::cstore::LinkagePreference;\n use rustc::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel};\n use rustc::hir::def::{self, Def, CtorKind};\n-use rustc::hir::def_id::{CrateNum, DefId, DefIndex,\n+use rustc::hir::def_id::{CrateNum, DefId, DefIndex, DefIndexAddressSpace,\n                          CRATE_DEF_INDEX, LOCAL_CRATE, LocalDefId};\n+use rustc::hir::map::definitions::DefPathTable;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc::middle::lang_items;\n use rustc::mir::{self, interpret};\n@@ -41,7 +41,8 @@ use syntax::attr;\n use syntax::ast::{self, Ident};\n use syntax::source_map;\n use syntax::symbol::InternedString;\n-use syntax::ext::base::MacroKind;\n+use syntax::ext::base::{MacroKind, SyntaxExtension};\n+use syntax::ext::hygiene::Mark;\n use syntax_pos::{self, Span, BytePos, Pos, DUMMY_SP, NO_EXPANSION};\n \n pub struct DecodeContext<'a, 'tcx: 'a> {\n@@ -441,6 +442,40 @@ impl<'tcx> EntryKind<'tcx> {\n     }\n }\n \n+/// Create the \"fake\" DefPathTable for a given proc macro crate.\n+///\n+/// The DefPathTable is as follows:\n+///\n+/// CRATE_ROOT (DefIndex 0:0)\n+///  |- GlobalMetaDataKind data (DefIndex 1:0 .. DefIndex 1:N)\n+///  |- proc macro #0 (DefIndex 1:N)\n+///  |- proc macro #1 (DefIndex 1:N+1)\n+///  \\- ...\n+crate fn proc_macro_def_path_table(crate_root: &CrateRoot,\n+                                   proc_macros: &[(ast::Name, Lrc<SyntaxExtension>)])\n+                                   -> DefPathTable\n+{\n+    let mut definitions = Definitions::new();\n+\n+    let name = crate_root.name.as_str();\n+    let disambiguator = crate_root.disambiguator;\n+    debug!(\"creating proc macro def path table for {:?}/{:?}\", name, disambiguator);\n+    let crate_root = definitions.create_root_def(&name, disambiguator);\n+    for (index, (name, _)) in proc_macros.iter().enumerate() {\n+        let def_index = definitions.create_def_with_parent(\n+            crate_root,\n+            ast::DUMMY_NODE_ID,\n+            DefPathData::MacroDef(name.as_interned_str()),\n+            DefIndexAddressSpace::High,\n+            Mark::root(),\n+            DUMMY_SP);\n+        debug!(\"definition for {:?} is {:?}\", name, def_index);\n+        assert_eq!(def_index, DefIndex::from_proc_macro_index(index));\n+    }\n+\n+    definitions.def_path_table().clone()\n+}\n+\n impl<'a, 'tcx> CrateMetadata {\n     fn is_proc_macro(&self, id: DefIndex) -> bool {\n         self.proc_macros.is_some() && id != CRATE_DEF_INDEX\n@@ -669,6 +704,10 @@ impl<'a, 'tcx> CrateMetadata {\n         where F: FnMut(def::Export)\n     {\n         if let Some(ref proc_macros) = self.proc_macros {\n+            /* If we are loading as a proc macro, we want to return the view of this crate\n+             * as a proc macro crate, not as a Rust crate. See `proc_macro_def_path_table`\n+             * for the DefPathTable we are corresponding to.\n+             */\n             if id == CRATE_DEF_INDEX {\n                 for (id, &(name, ref ext)) in proc_macros.iter().enumerate() {\n                     let def = Def::Macro(\n@@ -1066,28 +1105,12 @@ impl<'a, 'tcx> CrateMetadata {\n \n     #[inline]\n     pub fn def_key(&self, index: DefIndex) -> DefKey {\n-        if !self.is_proc_macro(index) {\n-            self.def_path_table.def_key(index)\n-        } else {\n-            // FIXME(#49271) - It would be better if the DefIds were consistent\n-            //                 with the DefPathTable, but for proc-macro crates\n-            //                 they aren't.\n-            let name = self.proc_macros\n-                           .as_ref()\n-                           .unwrap()[index.to_proc_macro_index()].0;\n-            DefKey {\n-                parent: Some(CRATE_DEF_INDEX),\n-                disambiguated_data: DisambiguatedDefPathData {\n-                    data: DefPathData::MacroDef(name.as_interned_str()),\n-                    disambiguator: 0,\n-                }\n-            }\n-        }\n+        self.def_path_table.def_key(index)\n     }\n \n     // Returns the path leading to the thing with this `id`.\n     pub fn def_path(&self, id: DefIndex) -> DefPath {\n-        debug!(\"def_path(id={:?})\", id);\n+        debug!(\"def_path(cnum={:?}, id={:?})\", self.cnum, id);\n         DefPath::make(self.cnum, id, |parent| self.def_path_table.def_key(parent))\n     }\n "}, {"sha": "107245488acf322c30c58eb911cf2bafaa46315b", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca0de63898b525656ad8447cd81ccb08a05e3d6c/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca0de63898b525656ad8447cd81ccb08a05e3d6c/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=ca0de63898b525656ad8447cd81ccb08a05e3d6c", "patch": "@@ -22,6 +22,7 @@\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(slice_sort_by_cached_key)]\n+#![feature(crate_visibility_modifier)]\n #![feature(specialization)]\n #![feature(rustc_private)]\n "}, {"sha": "763c9eb138e74540922f2f7da79e9c0bed49a4f0", "filename": "src/test/incremental-fulldeps/auxiliary/issue_49482_macro_def.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/ca0de63898b525656ad8447cd81ccb08a05e3d6c/src%2Ftest%2Fincremental-fulldeps%2Fauxiliary%2Fissue_49482_macro_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca0de63898b525656ad8447cd81ccb08a05e3d6c/src%2Ftest%2Fincremental-fulldeps%2Fauxiliary%2Fissue_49482_macro_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental-fulldeps%2Fauxiliary%2Fissue_49482_macro_def.rs?ref=ca0de63898b525656ad8447cd81ccb08a05e3d6c", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![crate_type=\"proc-macro\"]\n+#![allow(non_snake_case)]\n+\n+extern crate proc_macro;\n+\n+macro_rules! proc_macro_expr_impl {\n+    ($(\n+        $( #[$attr:meta] )*\n+        pub fn $func:ident($input:ident: &str) -> String;\n+    )+) => {\n+        $(\n+            $( #[$attr] )*\n+            #[proc_macro_derive($func)]\n+            pub fn $func(_input: ::proc_macro::TokenStream) -> ::proc_macro::TokenStream {\n+                panic!()\n+            }\n+        )+\n+    };\n+}\n+\n+proc_macro_expr_impl! {\n+    pub fn f1(input: &str) -> String;\n+    pub fn f2(input: &str) -> String;\n+    pub fn f3(input: &str) -> String;\n+    pub fn f4(input: &str) -> String;\n+    pub fn f5(input: &str) -> String;\n+    pub fn f6(input: &str) -> String;\n+    pub fn f7(input: &str) -> String;\n+    pub fn f8(input: &str) -> String;\n+    pub fn f9(input: &str) -> String;\n+    pub fn fA(input: &str) -> String;\n+    pub fn fB(input: &str) -> String;\n+    pub fn fC(input: &str) -> String;\n+    pub fn fD(input: &str) -> String;\n+    pub fn fE(input: &str) -> String;\n+    pub fn fF(input: &str) -> String;\n+}"}, {"sha": "aa9aa3b58b90c277c9f211ab9ed7f925ed808727", "filename": "src/test/incremental-fulldeps/auxiliary/issue_49482_reexport.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ca0de63898b525656ad8447cd81ccb08a05e3d6c/src%2Ftest%2Fincremental-fulldeps%2Fauxiliary%2Fissue_49482_reexport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca0de63898b525656ad8447cd81ccb08a05e3d6c/src%2Ftest%2Fincremental-fulldeps%2Fauxiliary%2Fissue_49482_reexport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental-fulldeps%2Fauxiliary%2Fissue_49482_reexport.rs?ref=ca0de63898b525656ad8447cd81ccb08a05e3d6c", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[macro_use]\n+extern crate issue_49482_macro_def;\n+\n+pub use issue_49482_macro_def::*;\n+\n+pub fn foo() {}"}, {"sha": "3261b5ae09201070babaf9f1b231de1d2c7f669d", "filename": "src/test/incremental-fulldeps/issue-49482.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/ca0de63898b525656ad8447cd81ccb08a05e3d6c/src%2Ftest%2Fincremental-fulldeps%2Fissue-49482.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca0de63898b525656ad8447cd81ccb08a05e3d6c/src%2Ftest%2Fincremental-fulldeps%2Fissue-49482.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental-fulldeps%2Fissue-49482.rs?ref=ca0de63898b525656ad8447cd81ccb08a05e3d6c", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:issue_49482_macro_def.rs\n+// aux-build:issue_49482_reexport.rs\n+// ignore-stage1\n+// revisions: rpass1\n+\n+extern crate issue_49482_reexport;\n+\n+pub trait KvStorage\n+{\n+    fn get(&self);\n+}\n+\n+impl<K> KvStorage for Box<K>\n+where\n+    K: KvStorage + ?Sized,\n+{\n+    fn get(&self) {\n+        (**self).get()\n+    }\n+}\n+\n+impl KvStorage for u32 {\n+    fn get(&self) {}\n+}\n+\n+fn main() {\n+    /* force issue_49482_reexport to be loaded */\n+    issue_49482_reexport::foo();\n+\n+    Box::new(2).get();\n+}"}]}