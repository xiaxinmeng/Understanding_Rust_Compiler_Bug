{"sha": "0cb69dec57f9ad279d7ceefad26cb0d2e16107bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjYjY5ZGVjNTdmOWFkMjc5ZDdjZWVmYWQyNmNiMGQyZTE2MTA3YmM=", "commit": {"author": {"name": "Dan Gohman", "email": "dev@sunfishcode.online", "date": "2021-07-28T00:08:27Z"}, "committer": {"name": "Dan Gohman", "email": "dev@sunfishcode.online", "date": "2021-08-19T19:02:39Z"}, "message": "Rename `OwnedFd`'s private field to match it's debug output.", "tree": {"sha": "757494d77a16b17e5424f62611e15dd7de705dcf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/757494d77a16b17e5424f62611e15dd7de705dcf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0cb69dec57f9ad279d7ceefad26cb0d2e16107bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0cb69dec57f9ad279d7ceefad26cb0d2e16107bc", "html_url": "https://github.com/rust-lang/rust/commit/0cb69dec57f9ad279d7ceefad26cb0d2e16107bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0cb69dec57f9ad279d7ceefad26cb0d2e16107bc/comments", "author": {"login": "sunfishcode", "id": 4503403, "node_id": "MDQ6VXNlcjQ1MDM0MDM=", "avatar_url": "https://avatars.githubusercontent.com/u/4503403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sunfishcode", "html_url": "https://github.com/sunfishcode", "followers_url": "https://api.github.com/users/sunfishcode/followers", "following_url": "https://api.github.com/users/sunfishcode/following{/other_user}", "gists_url": "https://api.github.com/users/sunfishcode/gists{/gist_id}", "starred_url": "https://api.github.com/users/sunfishcode/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sunfishcode/subscriptions", "organizations_url": "https://api.github.com/users/sunfishcode/orgs", "repos_url": "https://api.github.com/users/sunfishcode/repos", "events_url": "https://api.github.com/users/sunfishcode/events{/privacy}", "received_events_url": "https://api.github.com/users/sunfishcode/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sunfishcode", "id": 4503403, "node_id": "MDQ6VXNlcjQ1MDM0MDM=", "avatar_url": "https://avatars.githubusercontent.com/u/4503403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sunfishcode", "html_url": "https://github.com/sunfishcode", "followers_url": "https://api.github.com/users/sunfishcode/followers", "following_url": "https://api.github.com/users/sunfishcode/following{/other_user}", "gists_url": "https://api.github.com/users/sunfishcode/gists{/gist_id}", "starred_url": "https://api.github.com/users/sunfishcode/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sunfishcode/subscriptions", "organizations_url": "https://api.github.com/users/sunfishcode/orgs", "repos_url": "https://api.github.com/users/sunfishcode/repos", "events_url": "https://api.github.com/users/sunfishcode/events{/privacy}", "received_events_url": "https://api.github.com/users/sunfishcode/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "45b5de3376bdfdd04222add3f42e39f933984993", "url": "https://api.github.com/repos/rust-lang/rust/commits/45b5de3376bdfdd04222add3f42e39f933984993", "html_url": "https://github.com/rust-lang/rust/commit/45b5de3376bdfdd04222add3f42e39f933984993"}], "stats": {"total": 171, "additions": 86, "deletions": 85}, "files": [{"sha": "2be6198092fcad6ba20cca5647fed8d782f10fbf", "filename": "library/std/src/os/unix/io/fd.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0cb69dec57f9ad279d7ceefad26cb0d2e16107bc/library%2Fstd%2Fsrc%2Fos%2Funix%2Fio%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cb69dec57f9ad279d7ceefad26cb0d2e16107bc/library%2Fstd%2Fsrc%2Fos%2Funix%2Fio%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fio%2Ffd.rs?ref=0cb69dec57f9ad279d7ceefad26cb0d2e16107bc", "patch": "@@ -32,7 +32,7 @@ use crate::sys_common::{AsInner, FromInner, IntoInner};\n #[rustc_layout_scalar_valid_range_end(0xFF_FF_FF_FE)]\n #[unstable(feature = \"io_safety\", issue = \"87074\")]\n pub struct BorrowedFd<'fd> {\n-    raw: RawFd,\n+    fd: RawFd,\n     _phantom: PhantomData<&'fd OwnedFd>,\n }\n \n@@ -52,47 +52,47 @@ pub struct BorrowedFd<'fd> {\n #[rustc_layout_scalar_valid_range_end(0xFF_FF_FF_FE)]\n #[unstable(feature = \"io_safety\", issue = \"87074\")]\n pub struct OwnedFd {\n-    raw: RawFd,\n+    fd: RawFd,\n }\n \n impl BorrowedFd<'_> {\n     /// Return a `BorrowedFd` holding the given raw file descriptor.\n     ///\n     /// # Safety\n     ///\n-    /// The resource pointed to by `raw` must remain open for the duration of\n+    /// The resource pointed to by `fd` must remain open for the duration of\n     /// the returned `BorrowedFd`, and it must not have the value `-1`.\n     #[inline]\n     #[unstable(feature = \"io_safety\", issue = \"87074\")]\n-    pub unsafe fn borrow_raw_fd(raw: RawFd) -> Self {\n-        assert_ne!(raw, -1_i32 as RawFd);\n-        Self { raw, _phantom: PhantomData }\n+    pub unsafe fn borrow_raw_fd(fd: RawFd) -> Self {\n+        assert_ne!(fd, -1_i32 as RawFd);\n+        Self { fd, _phantom: PhantomData }\n     }\n }\n \n #[unstable(feature = \"io_safety\", issue = \"87074\")]\n impl AsRawFd for BorrowedFd<'_> {\n     #[inline]\n     fn as_raw_fd(&self) -> RawFd {\n-        self.raw\n+        self.fd\n     }\n }\n \n #[unstable(feature = \"io_safety\", issue = \"87074\")]\n impl AsRawFd for OwnedFd {\n     #[inline]\n     fn as_raw_fd(&self) -> RawFd {\n-        self.raw\n+        self.fd\n     }\n }\n \n #[unstable(feature = \"io_safety\", issue = \"87074\")]\n impl IntoRawFd for OwnedFd {\n     #[inline]\n     fn into_raw_fd(self) -> RawFd {\n-        let raw = self.raw;\n+        let fd = self.fd;\n         forget(self);\n-        raw\n+        fd\n     }\n }\n \n@@ -102,13 +102,13 @@ impl FromRawFd for OwnedFd {\n     ///\n     /// # Safety\n     ///\n-    /// The resource pointed to by `raw` must be open and suitable for assuming\n+    /// The resource pointed to by `fd` must be open and suitable for assuming\n     /// ownership. The resource must not require any cleanup other than `close`.\n     #[inline]\n-    unsafe fn from_raw_fd(raw: RawFd) -> Self {\n-        assert_ne!(raw, -1i32);\n+    unsafe fn from_raw_fd(fd: RawFd) -> Self {\n+        assert_ne!(fd, -1i32);\n         // SAFETY: we just asserted that the value is in the valid range and isn't `-1` (the only value bigger than `0xFF_FF_FF_FE` unsigned)\n-        Self { raw }\n+        Self { fd }\n     }\n }\n \n@@ -122,22 +122,22 @@ impl Drop for OwnedFd {\n             // the file descriptor was closed or not, and if we retried (for\n             // something like EINTR), we might close another valid file descriptor\n             // opened after we closed ours.\n-            let _ = libc::close(self.raw as raw::c_int);\n+            let _ = libc::close(self.fd as raw::c_int);\n         }\n     }\n }\n \n #[unstable(feature = \"io_safety\", issue = \"87074\")]\n impl fmt::Debug for BorrowedFd<'_> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"BorrowedFd\").field(\"fd\", &self.raw).finish()\n+        f.debug_struct(\"BorrowedFd\").field(\"fd\", &self.fd).finish()\n     }\n }\n \n #[unstable(feature = \"io_safety\", issue = \"87074\")]\n impl fmt::Debug for OwnedFd {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"OwnedFd\").field(\"fd\", &self.raw).finish()\n+        f.debug_struct(\"OwnedFd\").field(\"fd\", &self.fd).finish()\n     }\n }\n "}, {"sha": "f77a73abb901f3d35ebf896273592c142bd75649", "filename": "library/std/src/os/wasi/io/fd.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0cb69dec57f9ad279d7ceefad26cb0d2e16107bc/library%2Fstd%2Fsrc%2Fos%2Fwasi%2Fio%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cb69dec57f9ad279d7ceefad26cb0d2e16107bc/library%2Fstd%2Fsrc%2Fos%2Fwasi%2Fio%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwasi%2Fio%2Ffd.rs?ref=0cb69dec57f9ad279d7ceefad26cb0d2e16107bc", "patch": "@@ -32,7 +32,7 @@ use crate::sys_common::{AsInner, FromInner, IntoInner};\n #[rustc_layout_scalar_valid_range_end(0xFF_FF_FF_FE)]\n #[unstable(feature = \"io_safety\", issue = \"87074\")]\n pub struct BorrowedFd<'fd> {\n-    raw: RawFd,\n+    fd: RawFd,\n     _phantom: PhantomData<&'fd OwnedFd>,\n }\n \n@@ -52,47 +52,47 @@ pub struct BorrowedFd<'fd> {\n #[rustc_layout_scalar_valid_range_end(0xFF_FF_FF_FE)]\n #[unstable(feature = \"io_safety\", issue = \"87074\")]\n pub struct OwnedFd {\n-    raw: RawFd,\n+    fd: RawFd,\n }\n \n impl BorrowedFd<'_> {\n     /// Return a `BorrowedFd` holding the given raw file descriptor.\n     ///\n     /// # Safety\n     ///\n-    /// The resource pointed to by `raw` must remain open for the duration of\n+    /// The resource pointed to by `fd` must remain open for the duration of\n     /// the returned `BorrowedFd`, and it must not have the value `-1`.\n     #[inline]\n     #[unstable(feature = \"io_safety\", issue = \"87074\")]\n-    pub unsafe fn borrow_raw_fd(raw: RawFd) -> Self {\n-        assert_ne!(raw, -1_i32 as RawFd);\n-        unsafe { Self { raw, _phantom: PhantomData } }\n+    pub unsafe fn borrow_raw_fd(fd: RawFd) -> Self {\n+        assert_ne!(fd, -1_i32 as RawFd);\n+        unsafe { Self { fd, _phantom: PhantomData } }\n     }\n }\n \n #[unstable(feature = \"io_safety\", issue = \"87074\")]\n impl AsRawFd for BorrowedFd<'_> {\n     #[inline]\n     fn as_raw_fd(&self) -> RawFd {\n-        self.raw\n+        self.fd\n     }\n }\n \n #[unstable(feature = \"io_safety\", issue = \"87074\")]\n impl AsRawFd for OwnedFd {\n     #[inline]\n     fn as_raw_fd(&self) -> RawFd {\n-        self.raw\n+        self.fd\n     }\n }\n \n #[unstable(feature = \"io_safety\", issue = \"87074\")]\n impl IntoRawFd for OwnedFd {\n     #[inline]\n     fn into_raw_fd(self) -> RawFd {\n-        let raw = self.raw;\n+        let fd = self.fd;\n         forget(self);\n-        raw\n+        fd\n     }\n }\n \n@@ -102,13 +102,13 @@ impl FromRawFd for OwnedFd {\n     ///\n     /// # Safety\n     ///\n-    /// The resource pointed to by `raw` must be open and suitable for assuming\n+    /// The resource pointed to by `fd` must be open and suitable for assuming\n     /// ownership.\n     #[inline]\n-    unsafe fn from_raw_fd(raw: RawFd) -> Self {\n-        assert_ne!(raw, RawFd::MAX);\n+    unsafe fn from_raw_fd(fd: RawFd) -> Self {\n+        assert_ne!(fd, RawFd::MAX);\n         // SAFETY: we just asserted that the value is in the valid range and isn't `-1` (the only value bigger than `0xFF_FF_FF_FE` unsigned)\n-        unsafe { Self { raw } }\n+        unsafe { Self { fd } }\n     }\n }\n \n@@ -122,22 +122,22 @@ impl Drop for OwnedFd {\n             // the file descriptor was closed or not, and if we retried (for\n             // something like EINTR), we might close another valid file descriptor\n             // opened after we closed ours.\n-            let _ = libc::close(self.raw as raw::c_int);\n+            let _ = libc::close(self.fd as raw::c_int);\n         }\n     }\n }\n \n #[unstable(feature = \"io_safety\", issue = \"87074\")]\n impl fmt::Debug for BorrowedFd<'_> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"BorrowedFd\").field(\"fd\", &self.raw).finish()\n+        f.debug_struct(\"BorrowedFd\").field(\"fd\", &self.fd).finish()\n     }\n }\n \n #[unstable(feature = \"io_safety\", issue = \"87074\")]\n impl fmt::Debug for OwnedFd {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"OwnedFd\").field(\"fd\", &self.raw).finish()\n+        f.debug_struct(\"OwnedFd\").field(\"fd\", &self.fd).finish()\n     }\n }\n "}, {"sha": "5d25052068579b48155ae618fd4053b41c62f13e", "filename": "library/std/src/os/windows/io/handle.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/0cb69dec57f9ad279d7ceefad26cb0d2e16107bc/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cb69dec57f9ad279d7ceefad26cb0d2e16107bc/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs?ref=0cb69dec57f9ad279d7ceefad26cb0d2e16107bc", "patch": "@@ -30,7 +30,7 @@ use crate::sys_common::{AsInner, FromInner, IntoInner};\n #[repr(transparent)]\n #[unstable(feature = \"io_safety\", issue = \"87074\")]\n pub struct BorrowedHandle<'handle> {\n-    raw: NonNull<c_void>,\n+    handle: NonNull<c_void>,\n     _phantom: PhantomData<&'handle OwnedHandle>,\n }\n \n@@ -58,7 +58,7 @@ pub struct BorrowedHandle<'handle> {\n #[repr(transparent)]\n #[unstable(feature = \"io_safety\", issue = \"87074\")]\n pub struct OwnedHandle {\n-    raw: NonNull<c_void>,\n+    handle: NonNull<c_void>,\n }\n \n /// Similar to `Option<OwnedHandle>`, but intended for use in FFI interfaces\n@@ -78,7 +78,7 @@ pub struct OwnedHandle {\n #[repr(transparent)]\n #[unstable(feature = \"io_safety\", issue = \"87074\")]\n pub struct OptionFileHandle {\n-    raw: RawHandle,\n+    handle: RawHandle,\n }\n \n // The Windows [`HANDLE`] type may be transferred across and shared between\n@@ -98,13 +98,13 @@ impl BorrowedHandle<'_> {\n     ///\n     /// # Safety\n     ///\n-    /// The resource pointed to by `raw` must remain open for the duration of\n-    /// the returned `BorrowedHandle`, and it must not be null.\n+    /// The resource pointed to by `handle` must remain open for the duration\n+    /// of the returned `BorrowedHandle`, and it must not be null.\n     #[inline]\n     #[unstable(feature = \"io_safety\", issue = \"87074\")]\n-    pub unsafe fn borrow_raw_handle(raw: RawHandle) -> Self {\n-        assert!(!raw.is_null());\n-        Self { raw: NonNull::new_unchecked(raw), _phantom: PhantomData }\n+    pub unsafe fn borrow_raw_handle(handle: RawHandle) -> Self {\n+        assert!(!handle.is_null());\n+        Self { handle: NonNull::new_unchecked(handle), _phantom: PhantomData }\n     }\n }\n \n@@ -113,7 +113,7 @@ impl OptionFileHandle {\n     #[inline]\n     #[unstable(feature = \"io_safety\", issue = \"87074\")]\n     pub const fn none() -> Self {\n-        Self { raw: c::INVALID_HANDLE_VALUE }\n+        Self { handle: c::INVALID_HANDLE_VALUE }\n     }\n }\n \n@@ -122,19 +122,19 @@ impl TryFrom<OptionFileHandle> for OwnedHandle {\n \n     #[inline]\n     fn try_from(option: OptionFileHandle) -> Result<Self, ()> {\n-        let raw = option.raw;\n+        let handle = option.handle;\n         forget(option);\n-        if let Some(non_null) = NonNull::new(raw) {\n+        if let Some(non_null) = NonNull::new(handle) {\n             if non_null.as_ptr() != c::INVALID_HANDLE_VALUE {\n-                Ok(Self { raw: non_null })\n+                Ok(Self { handle: non_null })\n             } else {\n                 Err(())\n             }\n         } else {\n             // In theory, we ought to be able to assume that the pointer here\n-            // is never null, change `option.raw` to `NonNull`, and obviate the\n-            // the panic path here. Unfortunately, Win32 documentation doesn't\n-            // explicitly guarantee this anywhere.\n+            // is never null, change `option.handle` to `NonNull`, and obviate\n+            // the the panic path here. Unfortunately, Win32 documentation\n+            // doesn't explicitly guarantee this anywhere.\n             //\n             // APIs like [`CreateFileW`] itself have `HANDLE` arguments where a\n             // null handle indicates an absent value, which wouldn't work if\n@@ -150,32 +150,32 @@ impl TryFrom<OptionFileHandle> for OwnedHandle {\n impl From<OwnedHandle> for OptionFileHandle {\n     #[inline]\n     fn from(owned: OwnedHandle) -> Self {\n-        let raw = owned.raw;\n+        let handle = owned.handle;\n         forget(owned);\n-        Self { raw: raw.as_ptr() }\n+        Self { handle: handle.as_ptr() }\n     }\n }\n \n impl AsRawHandle for BorrowedHandle<'_> {\n     #[inline]\n     fn as_raw_handle(&self) -> RawHandle {\n-        self.raw.as_ptr()\n+        self.handle.as_ptr()\n     }\n }\n \n impl AsRawHandle for OwnedHandle {\n     #[inline]\n     fn as_raw_handle(&self) -> RawHandle {\n-        self.raw.as_ptr()\n+        self.handle.as_ptr()\n     }\n }\n \n impl IntoRawHandle for OwnedHandle {\n     #[inline]\n     fn into_raw_handle(self) -> RawHandle {\n-        let raw = self.raw.as_ptr();\n+        let handle = self.handle.as_ptr();\n         forget(self);\n-        raw\n+        handle\n     }\n }\n \n@@ -184,7 +184,7 @@ impl FromRawHandle for OwnedHandle {\n     ///\n     /// # Safety\n     ///\n-    /// The resource pointed to by `raw` must be open and suitable for\n+    /// The resource pointed to by `handle` must be open and suitable for\n     /// assuming ownership. The resource must not require any cleanup other\n     /// than `CloseHandle`.\n     ///\n@@ -193,9 +193,9 @@ impl FromRawHandle for OwnedHandle {\n     ///\n     /// [`RegCloseKey`]: https://docs.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regclosekey\n     #[inline]\n-    unsafe fn from_raw_handle(raw: RawHandle) -> Self {\n-        assert!(!raw.is_null());\n-        Self { raw: NonNull::new_unchecked(raw) }\n+    unsafe fn from_raw_handle(handle: RawHandle) -> Self {\n+        assert!(!handle.is_null());\n+        Self { handle: NonNull::new_unchecked(handle) }\n     }\n }\n \n@@ -204,24 +204,24 @@ impl FromRawHandle for OptionFileHandle {\n     ///\n     /// # Safety\n     ///\n-    /// The resource pointed to by `raw` must be either open and otherwise\n+    /// The resource pointed to by `handle` must be either open and otherwise\n     /// unowned, or equal to `INVALID_HANDLE_VALUE``. Note that not all Windows\n     /// APIs use `INVALID_HANDLE_VALUE` for errors; see [here] for the full\n     /// story.\n     ///\n     /// [here]: https://devblogs.microsoft.com/oldnewthing/20040302-00/?p=40443\n     #[inline]\n-    unsafe fn from_raw_handle(raw: RawHandle) -> Self {\n-        assert!(!raw.is_null());\n-        Self { raw }\n+    unsafe fn from_raw_handle(handle: RawHandle) -> Self {\n+        assert!(!handle.is_null());\n+        Self { handle }\n     }\n }\n \n impl Drop for OwnedHandle {\n     #[inline]\n     fn drop(&mut self) {\n         unsafe {\n-            let _ = c::CloseHandle(self.raw.as_ptr());\n+            let _ = c::CloseHandle(self.handle.as_ptr());\n         }\n     }\n }\n@@ -230,26 +230,26 @@ impl Drop for OptionFileHandle {\n     #[inline]\n     fn drop(&mut self) {\n         unsafe {\n-            let _ = c::CloseHandle(self.raw);\n+            let _ = c::CloseHandle(self.handle);\n         }\n     }\n }\n \n impl fmt::Debug for BorrowedHandle<'_> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"BorrowedHandle\").field(\"handle\", &self.raw).finish()\n+        f.debug_struct(\"BorrowedHandle\").field(\"handle\", &self.handle).finish()\n     }\n }\n \n impl fmt::Debug for OwnedHandle {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"OwnedHandle\").field(\"handle\", &self.raw).finish()\n+        f.debug_struct(\"OwnedHandle\").field(\"handle\", &self.handle).finish()\n     }\n }\n \n impl fmt::Debug for OptionFileHandle {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"OptionFileHandle\").field(\"handle\", &self.raw).finish()\n+        f.debug_struct(\"OptionFileHandle\").field(\"handle\", &self.handle).finish()\n     }\n }\n "}, {"sha": "fd89f4cc60c785f37cab3d4fe2d14d2b4e04e523", "filename": "library/std/src/os/windows/io/socket.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0cb69dec57f9ad279d7ceefad26cb0d2e16107bc/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fsocket.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cb69dec57f9ad279d7ceefad26cb0d2e16107bc/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fsocket.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fsocket.rs?ref=0cb69dec57f9ad279d7ceefad26cb0d2e16107bc", "patch": "@@ -28,7 +28,7 @@ use crate::sys::c;\n )]\n #[unstable(feature = \"io_safety\", issue = \"87074\")]\n pub struct BorrowedSocket<'socket> {\n-    raw: RawSocket,\n+    socket: RawSocket,\n     _phantom: PhantomData<&'socket OwnedSocket>,\n }\n \n@@ -50,7 +50,7 @@ pub struct BorrowedSocket<'socket> {\n )]\n #[unstable(feature = \"io_safety\", issue = \"87074\")]\n pub struct OwnedSocket {\n-    raw: RawSocket,\n+    socket: RawSocket,\n }\n \n impl BorrowedSocket<'_> {\n@@ -63,32 +63,32 @@ impl BorrowedSocket<'_> {\n     /// `INVALID_SOCKET`.\n     #[inline]\n     #[unstable(feature = \"io_safety\", issue = \"87074\")]\n-    pub unsafe fn borrow_raw_socket(raw: RawSocket) -> Self {\n-        debug_assert_ne!(raw, c::INVALID_SOCKET as RawSocket);\n-        Self { raw, _phantom: PhantomData }\n+    pub unsafe fn borrow_raw_socket(socket: RawSocket) -> Self {\n+        debug_assert_ne!(socket, c::INVALID_SOCKET as RawSocket);\n+        Self { socket, _phantom: PhantomData }\n     }\n }\n \n impl AsRawSocket for BorrowedSocket<'_> {\n     #[inline]\n     fn as_raw_socket(&self) -> RawSocket {\n-        self.raw\n+        self.socket\n     }\n }\n \n impl AsRawSocket for OwnedSocket {\n     #[inline]\n     fn as_raw_socket(&self) -> RawSocket {\n-        self.raw\n+        self.socket\n     }\n }\n \n impl IntoRawSocket for OwnedSocket {\n     #[inline]\n     fn into_raw_socket(self) -> RawSocket {\n-        let raw = self.raw;\n+        let socket = self.socket;\n         forget(self);\n-        raw\n+        socket\n     }\n }\n \n@@ -97,33 +97,34 @@ impl FromRawSocket for OwnedSocket {\n     ///\n     /// # Safety\n     ///\n-    /// The resource pointed to by `raw` must be open and suitable for assuming\n-    /// ownership. The resource must not require cleanup other than `closesocket`.\n+    /// The resource pointed to by `socket` must be open and suitable for\n+    /// assuming ownership. The resource must not require cleanup other than\n+    /// `closesocket`.\n     #[inline]\n-    unsafe fn from_raw_socket(raw: RawSocket) -> Self {\n-        debug_assert_ne!(raw, c::INVALID_SOCKET as RawSocket);\n-        Self { raw }\n+    unsafe fn from_raw_socket(socket: RawSocket) -> Self {\n+        debug_assert_ne!(socket, c::INVALID_SOCKET as RawSocket);\n+        Self { socket }\n     }\n }\n \n impl Drop for OwnedSocket {\n     #[inline]\n     fn drop(&mut self) {\n         unsafe {\n-            let _ = c::closesocket(self.raw);\n+            let _ = c::closesocket(self.socket);\n         }\n     }\n }\n \n impl fmt::Debug for BorrowedSocket<'_> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"BorrowedSocket\").field(\"socket\", &self.raw).finish()\n+        f.debug_struct(\"BorrowedSocket\").field(\"socket\", &self.socket).finish()\n     }\n }\n \n impl fmt::Debug for OwnedSocket {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"OwnedSocket\").field(\"socket\", &self.raw).finish()\n+        f.debug_struct(\"OwnedSocket\").field(\"socket\", &self.socket).finish()\n     }\n }\n "}]}