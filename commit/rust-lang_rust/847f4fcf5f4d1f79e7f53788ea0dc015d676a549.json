{"sha": "847f4fcf5f4d1f79e7f53788ea0dc015d676a549", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0N2Y0ZmNmNWY0ZDFmNzllN2Y1Mzc4OGVhMGRjMDE1ZDY3NmE1NDk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-10-26T20:58:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-10-26T20:58:08Z"}, "message": "Auto merge of #45522 - michaelwoerister:fix-stable-hasher-cross, r=arielb1\n\nFix 32- vs 64-bit platform instability in StableHasher.\n\nThis might already be enough to fix issue https://github.com/rust-lang/rust/issues/45500.\n\nr? @alexcrichton", "tree": {"sha": "2d10b63358c2c59b214a70209b2e8b6740321b10", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d10b63358c2c59b214a70209b2e8b6740321b10"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/847f4fcf5f4d1f79e7f53788ea0dc015d676a549", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/847f4fcf5f4d1f79e7f53788ea0dc015d676a549", "html_url": "https://github.com/rust-lang/rust/commit/847f4fcf5f4d1f79e7f53788ea0dc015d676a549", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/847f4fcf5f4d1f79e7f53788ea0dc015d676a549/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b218a02ad8b8b79b30a847eadf3e9c739560fadf", "url": "https://api.github.com/repos/rust-lang/rust/commits/b218a02ad8b8b79b30a847eadf3e9c739560fadf", "html_url": "https://github.com/rust-lang/rust/commit/b218a02ad8b8b79b30a847eadf3e9c739560fadf"}, {"sha": "54818b3e99b57f69785c29ddfa8b74d8a611258d", "url": "https://api.github.com/repos/rust-lang/rust/commits/54818b3e99b57f69785c29ddfa8b74d8a611258d", "html_url": "https://github.com/rust-lang/rust/commit/54818b3e99b57f69785c29ddfa8b74d8a611258d"}], "stats": {"total": 40, "additions": 16, "deletions": 24}, "files": [{"sha": "d82b712b5b14b983403e49413a4f80f613073cc0", "filename": "src/librustc_data_structures/stable_hasher.rs", "status": "modified", "additions": 16, "deletions": 24, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/847f4fcf5f4d1f79e7f53788ea0dc015d676a549/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847f4fcf5f4d1f79e7f53788ea0dc015d676a549/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fstable_hasher.rs?ref=847f4fcf5f4d1f79e7f53788ea0dc015d676a549", "patch": "@@ -13,24 +13,13 @@ use std::marker::PhantomData;\n use std::mem;\n use sip128::SipHasher128;\n \n-/// When hashing something that ends up affecting properties like symbol names. We\n-/// want these symbol names to be calculated independent of other factors like\n-/// what architecture you're compiling *from*.\n+/// When hashing something that ends up affecting properties like symbol names,\n+/// we want these symbol names to be calculated independently of other factors\n+/// like what architecture you're compiling *from*.\n ///\n-/// The hashing just uses the standard `Hash` trait, but the implementations of\n-/// `Hash` for the `usize` and `isize` types are *not* architecture independent\n-/// (e.g. they has 4 or 8 bytes). As a result we want to avoid `usize` and\n-/// `isize` completely when hashing.\n-///\n-/// To do that, we encode all integers to be hashed with some\n-/// arch-independent encoding.\n-///\n-/// At the moment, we pass i8/u8 straight through and encode\n-/// all other integers using leb128.\n-///\n-/// This hasher currently always uses the stable Blake2b algorithm\n-/// and allows for variable output lengths through its type\n-/// parameter.\n+/// To that end we always convert integers to little-endian format before\n+/// hashing and the architecture dependent `isize` and `usize` types are\n+/// extended to 64 bits if needed.\n pub struct StableHasher<W> {\n     state: SipHasher128,\n     bytes_hashed: u64,\n@@ -86,9 +75,6 @@ impl<W> StableHasher<W> {\n     }\n }\n \n-// For the non-u8 integer cases we leb128 encode them first. Because small\n-// integers dominate, this significantly and cheaply reduces the number of\n-// bytes hashed, which is good because blake2b is expensive.\n impl<W> Hasher for StableHasher<W> {\n     fn finish(&self) -> u64 {\n         panic!(\"use StableHasher::finalize instead\");\n@@ -132,8 +118,11 @@ impl<W> Hasher for StableHasher<W> {\n \n     #[inline]\n     fn write_usize(&mut self, i: usize) {\n-        self.state.write_usize(i.to_le());\n-        self.bytes_hashed += ::std::mem::size_of::<usize>() as u64;\n+        // Always treat usize as u64 so we get the same results on 32 and 64 bit\n+        // platforms. This is important for symbol hashes when cross compiling,\n+        // for example.\n+        self.state.write_u64((i as u64).to_le());\n+        self.bytes_hashed += 8;\n     }\n \n     #[inline]\n@@ -168,8 +157,11 @@ impl<W> Hasher for StableHasher<W> {\n \n     #[inline]\n     fn write_isize(&mut self, i: isize) {\n-        self.state.write_isize(i.to_le());\n-        self.bytes_hashed += ::std::mem::size_of::<isize>() as u64;\n+        // Always treat isize as i64 so we get the same results on 32 and 64 bit\n+        // platforms. This is important for symbol hashes when cross compiling,\n+        // for example.\n+        self.state.write_i64((i as i64).to_le());\n+        self.bytes_hashed += 8;\n     }\n }\n "}]}