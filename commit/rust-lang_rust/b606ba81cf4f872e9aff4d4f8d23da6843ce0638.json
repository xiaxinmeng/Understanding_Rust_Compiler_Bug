{"sha": "b606ba81cf4f872e9aff4d4f8d23da6843ce0638", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2MDZiYTgxY2Y0Zjg3MmU5YWZmNGQ0ZjhkMjNkYTY4NDNjZTA2Mzg=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-12-14T23:32:13Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-12-14T23:32:13Z"}, "message": "Add obj items to AST and parser.", "tree": {"sha": "7ae26247cdcdcf97866ce3f18da5c46f88a341db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7ae26247cdcdcf97866ce3f18da5c46f88a341db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b606ba81cf4f872e9aff4d4f8d23da6843ce0638", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b606ba81cf4f872e9aff4d4f8d23da6843ce0638", "html_url": "https://github.com/rust-lang/rust/commit/b606ba81cf4f872e9aff4d4f8d23da6843ce0638", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b606ba81cf4f872e9aff4d4f8d23da6843ce0638/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f227c71b21c0a6962d8529b4ce8b725bde69a8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f227c71b21c0a6962d8529b4ce8b725bde69a8c", "html_url": "https://github.com/rust-lang/rust/commit/3f227c71b21c0a6962d8529b4ce8b725bde69a8c"}], "stats": {"total": 120, "additions": 94, "deletions": 26}, "files": [{"sha": "3b6ebd35f71dd0227e6230074aaf298ff3e2ff21", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b606ba81cf4f872e9aff4d4f8d23da6843ce0638/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b606ba81cf4f872e9aff4d4f8d23da6843ce0638/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=b606ba81cf4f872e9aff4d4f8d23da6843ce0638", "patch": "@@ -26,6 +26,7 @@ tag ann {\n \n tag def {\n     def_fn(def_id);\n+    def_obj(def_id);\n     def_mod(def_id);\n     def_const(def_id);\n     def_arg(def_id);\n@@ -194,6 +195,15 @@ type _fn = rec(effect effect,\n                @ty output,\n                block body);\n \n+\n+type method_ = rec(ident ident, _fn meth, def_id id);\n+type method = spanned[method_];\n+\n+type obj_field = rec(@ty ty, ident ident, def_id id);\n+type _obj = rec(vec[obj_field] fields,\n+                vec[@method] methods);\n+\n+\n tag mod_index_entry {\n     mie_item(uint);\n     mie_tag_variant(uint /* tag item index */, uint /* variant index */);\n@@ -212,6 +222,7 @@ tag item_ {\n     item_mod(ident, _mod, def_id);\n     item_ty(ident, @ty, vec[ty_param], def_id, ann);\n     item_tag(ident, vec[variant], vec[ty_param], def_id);\n+    item_obj(ident, _obj, vec[ty_param], def_id, ann);\n }\n \n "}, {"sha": "5fd90508aef08fcfe645442d869aee1dd6b38407", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 83, "deletions": 26, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/b606ba81cf4f872e9aff4d4f8d23da6843ce0638/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b606ba81cf4f872e9aff4d4f8d23da6843ce0638/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=b606ba81cf4f872e9aff4d4f8d23da6843ce0638", "patch": "@@ -141,6 +141,12 @@ impure fn parse_ty_fn(parser p) -> ast.ty_ {\n     ret ast.ty_fn(inputs.node, output);\n }\n \n+impure fn parse_ty_field(parser p) -> ast.ty_field {\n+    auto ty = parse_ty(p);\n+    auto id = parse_ident(p);\n+    ret rec(ident=id, ty=ty);\n+}\n+\n impure fn parse_ty(parser p) -> @ast.ty {\n     auto lo = p.get_span();\n     auto hi = lo;\n@@ -196,12 +202,7 @@ impure fn parse_ty(parser p) -> @ast.ty {\n \n         case (token.REC) {\n             p.bump();\n-            impure fn parse_field(parser p) -> ast.ty_field {\n-                auto ty = parse_ty(p);\n-                auto id = parse_ident(p);\n-                ret rec(ident=id, ty=ty);\n-            }\n-            auto f = parse_field; // FIXME: trans_const_lval bug\n+            auto f = parse_ty_field; // FIXME: trans_const_lval bug\n             auto elems =\n                 parse_seq[ast.ty_field](token.LPAREN,\n                                         token.RPAREN,\n@@ -367,6 +368,14 @@ impure fn parse_mutabliity(parser p) -> ast.mutability {\n     ret ast.imm;\n }\n \n+impure fn parse_field(parser p) -> ast.field {\n+    auto m = parse_mutabliity(p);\n+    auto i = parse_ident(p);\n+    expect(p, token.EQ);\n+    auto e = parse_expr(p);\n+    ret rec(mut=m, ident=i, expr=e);\n+}\n+\n impure fn parse_bottom_expr(parser p) -> @ast.expr {\n \n     auto lo = p.get_span();\n@@ -447,13 +456,6 @@ impure fn parse_bottom_expr(parser p) -> @ast.expr {\n \n         case (token.REC) {\n             p.bump();\n-            impure fn parse_field(parser p) -> ast.field {\n-                auto m = parse_mutabliity(p);\n-                auto i = parse_ident(p);\n-                expect(p, token.EQ);\n-                auto e = parse_expr(p);\n-                ret rec(mut=m, ident=i, expr=e);\n-            }\n             auto pf = parse_field;\n             auto fs =\n                 parse_seq[ast.field](token.LPAREN,\n@@ -1214,12 +1216,7 @@ impure fn parse_ty_params(parser p) -> vec[ast.ty_param] {\n     ret ty_params;\n }\n \n-impure fn parse_item_fn(parser p, ast.effect eff) -> @ast.item {\n-    auto lo = p.get_span();\n-    expect(p, token.FN);\n-    auto id = parse_ident(p);\n-    auto ty_params = parse_ty_params(p);\n-\n+impure fn parse_fn(parser p, ast.effect eff) -> ast._fn {\n     auto pf = parse_arg;\n     let util.common.spanned[vec[ast.arg]] inputs =\n         // FIXME: passing parse_arg as an lval doesn't work at the\n@@ -1235,18 +1232,72 @@ impure fn parse_item_fn(parser p, ast.effect eff) -> @ast.item {\n         p.bump();\n         output = parse_ty(p);\n     } else {\n-        output = @spanned(lo, inputs.span, ast.ty_nil);\n+        output = @spanned(inputs.span, inputs.span, ast.ty_nil);\n     }\n \n     auto body = parse_block(p);\n \n-    let ast._fn f = rec(effect = eff,\n-                        inputs = inputs.node,\n-                        output = output,\n-                        body = body);\n+    ret rec(effect = eff,\n+            inputs = inputs.node,\n+            output = output,\n+            body = body);\n+}\n \n+impure fn parse_item_fn(parser p, ast.effect eff) -> @ast.item {\n+    auto lo = p.get_span();\n+    expect(p, token.FN);\n+    auto id = parse_ident(p);\n+    auto ty_params = parse_ty_params(p);\n+    auto f = parse_fn(p, eff);\n     auto item = ast.item_fn(id, f, ty_params, p.next_def_id(), ast.ann_none);\n-    ret @spanned(lo, body.span, item);\n+    ret @spanned(lo, f.body.span, item);\n+}\n+\n+\n+impure fn parse_obj_field(parser p) -> ast.obj_field {\n+    auto ty = parse_ty(p);\n+    auto ident = parse_ident(p);\n+    ret rec(ty=ty, ident=ident, id=p.next_def_id());\n+}\n+\n+impure fn parse_method(parser p) -> @ast.method {\n+    auto lo = p.get_span();\n+    auto eff = parse_effect(p);\n+    expect(p, token.FN);\n+    auto ident = parse_ident(p);\n+    auto f = parse_fn(p, eff);\n+    auto meth = rec(ident = ident, meth = f, id = p.next_def_id());\n+    ret @spanned(lo, f.body.span, meth);\n+}\n+\n+impure fn parse_item_obj(parser p, ast.layer lyr) -> @ast.item {\n+    auto lo = p.get_span();\n+    expect(p, token.OBJ);\n+    auto ident = parse_ident(p);\n+    auto ty_params = parse_ty_params(p);\n+    auto pf = parse_obj_field;\n+    let util.common.spanned[vec[ast.obj_field]] fields =\n+        parse_seq[ast.obj_field]\n+        (token.LPAREN,\n+         token.RPAREN,\n+         some(token.COMMA),\n+         pf, p);\n+\n+    auto pm = parse_method;\n+    let util.common.spanned[vec[@ast.method]] meths =\n+        parse_seq[@ast.method]\n+        (token.LBRACE,\n+         token.RBRACE,\n+         none[token.token],\n+         pm, p);\n+\n+    let ast._obj ob = rec(fields=fields.node,\n+                          methods=meths.node);\n+\n+    auto item = ast.item_obj(ident, ob, ty_params,\n+                             p.next_def_id(), ast.ann_none);\n+\n+    ret @spanned(lo, meths.span, item);\n }\n \n impure fn parse_mod_items(parser p, token.token term) -> ast._mod {\n@@ -1271,7 +1322,6 @@ impure fn parse_mod_items(parser p, token.token term) -> ast._mod {\n             case (ast.item_ty(?id, _, _, _, _)) {\n                 index.insert(id, ast.mie_item(u));\n             }\n-\n             case (ast.item_tag(?id, ?variants, _, _)) {\n                 index.insert(id, ast.mie_item(u));\n                 let uint variant_idx = 0u;\n@@ -1280,6 +1330,9 @@ impure fn parse_mod_items(parser p, token.token term) -> ast._mod {\n                     variant_idx += 1u;\n                 }\n             }\n+            case (ast.item_obj(?id, _, _, _, _)) {\n+                index.insert(id, ast.mie_item(u));\n+            }\n         }\n \n         u += 1u;\n@@ -1438,6 +1491,10 @@ impure fn parse_item(parser p) -> @ast.item {\n             check (eff == ast.eff_pure);\n             ret parse_item_tag(p);\n         }\n+        case (token.OBJ) {\n+            check (eff == ast.eff_pure);\n+            ret parse_item_obj(p, lyr);\n+        }\n         case (?t) {\n             p.err(\"expected item but found \" + token.to_str(t));\n         }"}]}