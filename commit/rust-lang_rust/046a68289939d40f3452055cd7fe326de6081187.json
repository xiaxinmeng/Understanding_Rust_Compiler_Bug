{"sha": "046a68289939d40f3452055cd7fe326de6081187", "node_id": "C_kwDOAAsO6NoAKDA0NmE2ODI4OTkzOWQ0MGYzNDUyMDU1Y2Q3ZmUzMjZkZTYwODExODc", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2021-12-21T11:40:11Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2021-12-21T11:46:19Z"}, "message": "rustc_metadata: Switch crate data iteration from a callback to iterator\n\nThe iteration looks more conventional this way, and some allocations are avoided.", "tree": {"sha": "a18e65997ea4a48a1ef9c7899173eab2e752b87b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a18e65997ea4a48a1ef9c7899173eab2e752b87b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/046a68289939d40f3452055cd7fe326de6081187", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/046a68289939d40f3452055cd7fe326de6081187", "html_url": "https://github.com/rust-lang/rust/commit/046a68289939d40f3452055cd7fe326de6081187", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/046a68289939d40f3452055cd7fe326de6081187/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87e8639d8dd900ebdd79e9f0491ca4ae40944f02", "url": "https://api.github.com/repos/rust-lang/rust/commits/87e8639d8dd900ebdd79e9f0491ca4ae40944f02", "html_url": "https://github.com/rust-lang/rust/commit/87e8639d8dd900ebdd79e9f0491ca4ae40944f02"}], "stats": {"total": 169, "additions": 70, "deletions": 99}, "files": [{"sha": "36a1798cd6a8667cda5ca3740059994aee830687", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 67, "deletions": 94, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/046a68289939d40f3452055cd7fe326de6081187/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/046a68289939d40f3452055cd7fe326de6081187/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=046a68289939d40f3452055cd7fe326de6081187", "patch": "@@ -102,30 +102,23 @@ struct CrateDump<'a>(&'a CStore);\n impl<'a> std::fmt::Debug for CrateDump<'a> {\n     fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         writeln!(fmt, \"resolved crates:\")?;\n-        // `iter_crate_data` does not allow returning values. Thus we use a mutable variable here\n-        // that aggregates the value (and any errors that could happen).\n-        let mut res = Ok(());\n-        self.0.iter_crate_data(|cnum, data| {\n-            res = res.and(\n-                try {\n-                    writeln!(fmt, \"  name: {}\", data.name())?;\n-                    writeln!(fmt, \"  cnum: {}\", cnum)?;\n-                    writeln!(fmt, \"  hash: {}\", data.hash())?;\n-                    writeln!(fmt, \"  reqd: {:?}\", data.dep_kind())?;\n-                    let CrateSource { dylib, rlib, rmeta } = data.source();\n-                    if let Some(dylib) = dylib {\n-                        writeln!(fmt, \"  dylib: {}\", dylib.0.display())?;\n-                    }\n-                    if let Some(rlib) = rlib {\n-                        writeln!(fmt, \"   rlib: {}\", rlib.0.display())?;\n-                    }\n-                    if let Some(rmeta) = rmeta {\n-                        writeln!(fmt, \"   rmeta: {}\", rmeta.0.display())?;\n-                    }\n-                },\n-            );\n-        });\n-        res\n+        for (cnum, data) in self.0.iter_crate_data() {\n+            writeln!(fmt, \"  name: {}\", data.name())?;\n+            writeln!(fmt, \"  cnum: {}\", cnum)?;\n+            writeln!(fmt, \"  hash: {}\", data.hash())?;\n+            writeln!(fmt, \"  reqd: {:?}\", data.dep_kind())?;\n+            let CrateSource { dylib, rlib, rmeta } = data.source();\n+            if let Some(dylib) = dylib {\n+                writeln!(fmt, \"  dylib: {}\", dylib.0.display())?;\n+            }\n+            if let Some(rlib) = rlib {\n+                writeln!(fmt, \"   rlib: {}\", rlib.0.display())?;\n+            }\n+            if let Some(rmeta) = rmeta {\n+                writeln!(fmt, \"   rmeta: {}\", rmeta.0.display())?;\n+            }\n+        }\n+        Ok(())\n     }\n }\n \n@@ -154,12 +147,10 @@ impl CStore {\n         self.metas[cnum] = Some(Lrc::new(data));\n     }\n \n-    crate fn iter_crate_data(&self, mut f: impl FnMut(CrateNum, &CrateMetadata)) {\n-        for (cnum, data) in self.metas.iter_enumerated() {\n-            if let Some(data) = data {\n-                f(cnum, data);\n-            }\n-        }\n+    crate fn iter_crate_data(&self) -> impl Iterator<Item = (CrateNum, &CrateMetadata)> {\n+        self.metas\n+            .iter_enumerated()\n+            .filter_map(|(cnum, data)| data.as_ref().map(|data| (cnum, &**data)))\n     }\n \n     fn push_dependencies_in_postorder(&self, deps: &mut Vec<CrateNum>, cnum: CrateNum) {\n@@ -178,7 +169,9 @@ impl CStore {\n     crate fn crate_dependencies_in_postorder(&self, cnum: CrateNum) -> Vec<CrateNum> {\n         let mut deps = Vec::new();\n         if cnum == LOCAL_CRATE {\n-            self.iter_crate_data(|cnum, _| self.push_dependencies_in_postorder(&mut deps, cnum));\n+            for (cnum, _) in self.iter_crate_data() {\n+                self.push_dependencies_in_postorder(&mut deps, cnum);\n+            }\n         } else {\n             self.push_dependencies_in_postorder(&mut deps, cnum);\n         }\n@@ -263,21 +256,17 @@ impl<'a> CrateLoader<'a> {\n     }\n \n     fn existing_match(&self, name: Symbol, hash: Option<Svh>, kind: PathKind) -> Option<CrateNum> {\n-        let mut ret = None;\n-        self.cstore.iter_crate_data(|cnum, data| {\n+        for (cnum, data) in self.cstore.iter_crate_data() {\n             if data.name() != name {\n                 tracing::trace!(\"{} did not match {}\", data.name(), name);\n-                return;\n+                continue;\n             }\n \n             match hash {\n-                Some(hash) if hash == data.hash() => {\n-                    ret = Some(cnum);\n-                    return;\n-                }\n+                Some(hash) if hash == data.hash() => return Some(cnum),\n                 Some(hash) => {\n                     debug!(\"actual hash {} did not match expected {}\", hash, data.hash());\n-                    return;\n+                    continue;\n                 }\n                 None => {}\n             }\n@@ -301,10 +290,10 @@ impl<'a> CrateLoader<'a> {\n                             || source.rlib.as_ref().map(|(p, _)| p) == Some(l)\n                             || source.rmeta.as_ref().map(|(p, _)| p) == Some(l)\n                     }) {\n-                        ret = Some(cnum);\n+                        return Some(cnum);\n                     }\n                 }\n-                return;\n+                continue;\n             }\n \n             // Alright, so we've gotten this far which means that `data` has the\n@@ -321,15 +310,16 @@ impl<'a> CrateLoader<'a> {\n                 .expect(\"No sources for crate\")\n                 .1;\n             if kind.matches(prev_kind) {\n-                ret = Some(cnum);\n+                return Some(cnum);\n             } else {\n                 debug!(\n                     \"failed to load existing crate {}; kind {:?} did not match prev_kind {:?}\",\n                     name, kind, prev_kind\n                 );\n             }\n-        });\n-        ret\n+        }\n+\n+        None\n     }\n \n     fn verify_no_symbol_conflicts(&self, root: &CrateRoot<'_>) -> Result<(), CrateError> {\n@@ -339,17 +329,14 @@ impl<'a> CrateLoader<'a> {\n         }\n \n         // Check for conflicts with any crate loaded so far\n-        let mut res = Ok(());\n-        self.cstore.iter_crate_data(|_, other| {\n-            if other.stable_crate_id() == root.stable_crate_id() && // same stable crate id\n-               other.hash() != root.hash()\n-            {\n-                // but different SVH\n-                res = Err(CrateError::SymbolConflictsOthers(root.name()));\n+        for (_, other) in self.cstore.iter_crate_data() {\n+            // Same stable crate id but different SVH\n+            if other.stable_crate_id() == root.stable_crate_id() && other.hash() != root.hash() {\n+                return Err(CrateError::SymbolConflictsOthers(root.name()));\n             }\n-        });\n+        }\n \n-        res\n+        Ok(())\n     }\n \n     fn verify_no_stable_crate_id_hash_conflicts(\n@@ -607,13 +594,14 @@ impl<'a> CrateLoader<'a> {\n             locator.triple == self.sess.opts.target_triple || locator.is_proc_macro;\n         Ok(Some(if can_reuse_cratenum {\n             let mut result = LoadResult::Loaded(library);\n-            self.cstore.iter_crate_data(|cnum, data| {\n+            for (cnum, data) in self.cstore.iter_crate_data() {\n                 if data.name() == root.name() && root.hash() == data.hash() {\n                     assert!(locator.hash.is_none());\n                     info!(\"load success, going to previous cnum: {}\", cnum);\n                     result = LoadResult::Previous(cnum);\n+                    break;\n                 }\n-            });\n+            }\n             result\n         } else {\n             LoadResult::Loaded(library)\n@@ -711,7 +699,7 @@ impl<'a> CrateLoader<'a> {\n         let mut needs_panic_runtime =\n             self.sess.contains_name(&krate.attrs, sym::needs_panic_runtime);\n \n-        self.cstore.iter_crate_data(|cnum, data| {\n+        for (cnum, data) in self.cstore.iter_crate_data() {\n             needs_panic_runtime = needs_panic_runtime || data.needs_panic_runtime();\n             if data.is_panic_runtime() {\n                 // Inject a dependency from all #![needs_panic_runtime] to this\n@@ -721,7 +709,7 @@ impl<'a> CrateLoader<'a> {\n                 });\n                 runtime_found = runtime_found || data.dep_kind() == CrateDepKind::Explicit;\n             }\n-        });\n+        }\n \n         // If an explicitly linked and matching panic runtime was found, or if\n         // we just don't need one at all, then we're done here and there's\n@@ -813,11 +801,9 @@ impl<'a> CrateLoader<'a> {\n         // Check to see if we actually need an allocator. This desire comes\n         // about through the `#![needs_allocator]` attribute and is typically\n         // written down in liballoc.\n-        let mut needs_allocator = self.sess.contains_name(&krate.attrs, sym::needs_allocator);\n-        self.cstore.iter_crate_data(|_, data| {\n-            needs_allocator = needs_allocator || data.needs_allocator();\n-        });\n-        if !needs_allocator {\n+        if !self.sess.contains_name(&krate.attrs, sym::needs_allocator)\n+            && !self.cstore.iter_crate_data().any(|(_, data)| data.needs_allocator())\n+        {\n             return;\n         }\n \n@@ -838,23 +824,19 @@ impl<'a> CrateLoader<'a> {\n         // global allocator.\n         let mut global_allocator =\n             self.cstore.has_global_allocator.then(|| Symbol::intern(\"this crate\"));\n-        self.cstore.iter_crate_data(|_, data| {\n-            if !data.has_global_allocator() {\n-                return;\n-            }\n-            match global_allocator {\n-                Some(other_crate) => {\n-                    self.sess.err(&format!(\n-                        \"the `#[global_allocator]` in {} \\\n-                                            conflicts with global \\\n-                                            allocator in: {}\",\n+        for (_, data) in self.cstore.iter_crate_data() {\n+            if data.has_global_allocator() {\n+                match global_allocator {\n+                    Some(other_crate) => self.sess.err(&format!(\n+                        \"the `#[global_allocator]` in {} conflicts with global allocator in: {}\",\n                         other_crate,\n                         data.name()\n-                    ));\n+                    )),\n+                    None => global_allocator = Some(data.name()),\n                 }\n-                None => global_allocator = Some(data.name()),\n             }\n-        });\n+        }\n+\n         if global_allocator.is_some() {\n             self.cstore.allocator_kind = Some(AllocatorKind::Global);\n             return;\n@@ -864,19 +846,12 @@ impl<'a> CrateLoader<'a> {\n         // allocator. At this point our allocator request is typically fulfilled\n         // by the standard library, denoted by the `#![default_lib_allocator]`\n         // attribute.\n-        let mut has_default = self.sess.contains_name(&krate.attrs, sym::default_lib_allocator);\n-        self.cstore.iter_crate_data(|_, data| {\n-            if data.has_default_lib_allocator() {\n-                has_default = true;\n-            }\n-        });\n-\n-        if !has_default {\n+        if !self.sess.contains_name(&krate.attrs, sym::default_lib_allocator)\n+            && !self.cstore.iter_crate_data().any(|(_, data)| data.has_default_lib_allocator())\n+        {\n             self.sess.err(\n-                \"no global memory allocator found but one is \\\n-                           required; link to std or \\\n-                           add `#[global_allocator]` to a static item \\\n-                           that implements the GlobalAlloc trait\",\n+                \"no global memory allocator found but one is required; link to std or add \\\n+                 `#[global_allocator]` to a static item that implements the GlobalAlloc trait\",\n             );\n         }\n         self.cstore.allocator_kind = Some(AllocatorKind::Default);\n@@ -916,14 +891,12 @@ impl<'a> CrateLoader<'a> {\n         // crate provided for this compile, but in order for this compilation to\n         // be successfully linked we need to inject a dependency (to order the\n         // crates on the command line correctly).\n-        self.cstore.iter_crate_data(|cnum, data| {\n-            if !needs_dep(data) {\n-                return;\n+        for (cnum, data) in self.cstore.iter_crate_data() {\n+            if needs_dep(data) {\n+                info!(\"injecting a dep from {} to {}\", cnum, krate);\n+                data.add_dependency(krate);\n             }\n-\n-            info!(\"injecting a dep from {} to {}\", cnum, krate);\n-            data.add_dependency(krate);\n-        });\n+        }\n     }\n \n     fn report_unused_deps(&mut self, krate: &ast::Crate) {"}, {"sha": "8e7a525edb824a410660cb3bb923a1f2c444ca13", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/046a68289939d40f3452055cd7fe326de6081187/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/046a68289939d40f3452055cd7fe326de6081187/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=046a68289939d40f3452055cd7fe326de6081187", "patch": "@@ -357,7 +357,7 @@ pub fn provide(providers: &mut Providers) {\n             tcx.arena\n                 .alloc_slice(&CStore::from_tcx(tcx).crate_dependencies_in_postorder(LOCAL_CRATE))\n         },\n-        crates: |tcx, ()| tcx.arena.alloc_slice(&CStore::from_tcx(tcx).crates_untracked()),\n+        crates: |tcx, ()| tcx.arena.alloc_from_iter(CStore::from_tcx(tcx).crates_untracked()),\n \n         ..*providers\n     };\n@@ -440,10 +440,8 @@ impl CStore {\n         self.get_crate_data(def.krate).def_kind(def.index)\n     }\n \n-    pub fn crates_untracked(&self) -> Vec<CrateNum> {\n-        let mut result = vec![];\n-        self.iter_crate_data(|cnum, _| result.push(cnum));\n-        result\n+    pub fn crates_untracked(&self) -> impl Iterator<Item = CrateNum> + '_ {\n+        self.iter_crate_data().map(|(cnum, _)| cnum)\n     }\n \n     pub fn item_generics_num_lifetimes(&self, def_id: DefId, sess: &Session) -> usize {"}]}