{"sha": "a0e178db793d8d363d80430ab6e716600c4adcf7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwZTE3OGRiNzkzZDhkMzYzZDgwNDMwYWI2ZTcxNjYwMGM0YWRjZjc=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-09-22T05:10:16Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-09-23T04:26:56Z"}, "message": "Parse paths in statement and pattern macro invocations.", "tree": {"sha": "3e4515330a7d8510040c31366f5c5effe86abd79", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e4515330a7d8510040c31366f5c5effe86abd79"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a0e178db793d8d363d80430ab6e716600c4adcf7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a0e178db793d8d363d80430ab6e716600c4adcf7", "html_url": "https://github.com/rust-lang/rust/commit/a0e178db793d8d363d80430ab6e716600c4adcf7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a0e178db793d8d363d80430ab6e716600c4adcf7/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc7ed303f7093ada5c2fe39a755cad7bf8487544", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc7ed303f7093ada5c2fe39a755cad7bf8487544", "html_url": "https://github.com/rust-lang/rust/commit/dc7ed303f7093ada5c2fe39a755cad7bf8487544"}], "stats": {"total": 77, "additions": 46, "deletions": 31}, "files": [{"sha": "a092027313176f5006387eeb432b9398032a8ecc", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 46, "deletions": 31, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/a0e178db793d8d363d80430ab6e716600c4adcf7/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0e178db793d8d363d80430ab6e716600c4adcf7/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=a0e178db793d8d363d80430ab6e716600c4adcf7", "patch": "@@ -3625,29 +3625,16 @@ impl<'a> Parser<'a> {\n                 pat = PatKind::Box(subpat);\n             } else if self.token.is_path_start() {\n                 // Parse pattern starting with a path\n-                if self.token.is_ident() && self.look_ahead(1, |t| *t != token::DotDotDot &&\n-                        *t != token::OpenDelim(token::Brace) &&\n-                        *t != token::OpenDelim(token::Paren) &&\n-                        *t != token::ModSep) {\n-                    // Plain idents have some extra abilities here compared to general paths\n-                    if self.look_ahead(1, |t| *t == token::Not) {\n-                        // Parse macro invocation\n-                        let path = self.parse_ident_into_path()?;\n-                        self.bump();\n-                        let delim = self.expect_open_delim()?;\n-                        let tts = self.parse_seq_to_end(\n-                            &token::CloseDelim(delim),\n-                            SeqSep::none(), |p| p.parse_token_tree())?;\n-                        let mac = Mac_ { path: path, tts: tts };\n-                        pat = PatKind::Mac(codemap::Spanned {node: mac,\n-                                                               span: mk_sp(lo, self.last_span.hi)});\n-                    } else {\n-                        // Parse ident @ pat\n-                        // This can give false positives and parse nullary enums,\n-                        // they are dealt with later in resolve\n-                        let binding_mode = BindingMode::ByValue(Mutability::Immutable);\n-                        pat = self.parse_pat_ident(binding_mode)?;\n-                    }\n+                if self.token.is_ident() && self.look_ahead(1, |t| match *t {\n+                    token::OpenDelim(token::Paren) | token::OpenDelim(token::Brace) |\n+                    token::DotDotDot | token::ModSep | token::Not => false,\n+                    _ => true,\n+                }) {\n+                    // Parse ident @ pat\n+                    // This can give false positives and parse nullary enums,\n+                    // they are dealt with later in resolve\n+                    let binding_mode = BindingMode::ByValue(Mutability::Immutable);\n+                    pat = self.parse_pat_ident(binding_mode)?;\n                 } else {\n                     let (qself, path) = if self.eat_lt() {\n                         // Parse a qualified path\n@@ -3659,6 +3646,17 @@ impl<'a> Parser<'a> {\n                         (None, self.parse_path(PathStyle::Expr)?)\n                     };\n                     match self.token {\n+                      token::Not if qself.is_none() => {\n+                        // Parse macro invocation\n+                        self.bump();\n+                        let delim = self.expect_open_delim()?;\n+                        let tts = self.parse_seq_to_end(\n+                            &token::CloseDelim(delim),\n+                            SeqSep::none(), |p| p.parse_token_tree())?;\n+                        let mac = Mac_ { path: path, tts: tts };\n+                        pat = PatKind::Mac(codemap::Spanned {node: mac,\n+                                                               span: mk_sp(lo, self.last_span.hi)});\n+                      }\n                       token::DotDotDot => {\n                         // Parse range\n                         let hi = self.last_span.hi;\n@@ -3895,16 +3893,33 @@ impl<'a> Parser<'a> {\n                 node: StmtKind::Local(self.parse_local(attrs.into())?),\n                 span: mk_sp(lo, self.last_span.hi),\n             }\n-        } else if self.token.is_ident()\n-            && !self.token.is_any_keyword()\n-            && self.look_ahead(1, |t| *t == token::Not) {\n-            // it's a macro invocation:\n+        } else if self.token.is_path_start() && self.token != token::Lt && {\n+            !self.check_keyword(keywords::Union) ||\n+            self.look_ahead(1, |t| *t == token::Not || *t == token::ModSep)\n+        } {\n+            let pth = self.parse_path(PathStyle::Expr)?;\n \n-            // Potential trouble: if we allow macros with paths instead of\n-            // idents, we'd need to look ahead past the whole path here...\n-            let pth = self.parse_ident_into_path()?;\n-            self.bump();\n+            if !self.eat(&token::Not) {\n+                let expr = if self.check(&token::OpenDelim(token::Brace)) {\n+                    self.parse_struct_expr(lo, pth, ThinVec::new())?\n+                } else {\n+                    let hi = self.last_span.hi;\n+                    self.mk_expr(lo, hi, ExprKind::Path(None, pth), ThinVec::new())\n+                };\n+\n+                let expr = self.with_res(Restrictions::RESTRICTION_STMT_EXPR, |this| {\n+                    let expr = this.parse_dot_or_call_expr_with(expr, lo, attrs.into())?;\n+                    this.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(expr))\n+                })?;\n+\n+                return Ok(Some(Stmt {\n+                    id: ast::DUMMY_NODE_ID,\n+                    node: StmtKind::Expr(expr),\n+                    span: mk_sp(lo, self.last_span.hi),\n+                }));\n+            }\n \n+            // it's a macro invocation\n             let id = match self.token {\n                 token::OpenDelim(_) => keywords::Invalid.ident(), // no special identifier\n                 _ => self.parse_ident()?,"}]}