{"sha": "4220dcf1e9de2c2d2c329ecefa80108b63a69145", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyMjBkY2YxZTlkZTJjMmQyYzMyOWVjZWZhODAxMDhiNjNhNjkxNDU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-02-19T00:34:42Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-02-21T02:58:04Z"}, "message": "core: New task API", "tree": {"sha": "bd70397f064225f8d38b692f5f8120ed9e732d9e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bd70397f064225f8d38b692f5f8120ed9e732d9e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4220dcf1e9de2c2d2c329ecefa80108b63a69145", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4220dcf1e9de2c2d2c329ecefa80108b63a69145", "html_url": "https://github.com/rust-lang/rust/commit/4220dcf1e9de2c2d2c329ecefa80108b63a69145", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4220dcf1e9de2c2d2c329ecefa80108b63a69145/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fbc95ba0184a417ff6d8b2b417f210c960e142cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/fbc95ba0184a417ff6d8b2b417f210c960e142cc", "html_url": "https://github.com/rust-lang/rust/commit/fbc95ba0184a417ff6d8b2b417f210c960e142cc"}], "stats": {"total": 1724, "additions": 959, "deletions": 765}, "files": [{"sha": "1039f25df3f0ba143479342aa47146eb497588a2", "filename": "doc/tutorial.md", "status": "modified", "additions": 40, "deletions": 44, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/4220dcf1e9de2c2d2c329ecefa80108b63a69145/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/4220dcf1e9de2c2d2c329ecefa80108b63a69145/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=4220dcf1e9de2c2d2c329ecefa80108b63a69145", "patch": "@@ -2375,10 +2375,10 @@ module `task`.  Let's begin with the simplest one, `task::spawn()`:\n \n ~~~~\n let some_value = 22;\n-let child_task = task::spawn {||\n+task::spawn {||\n     std::io::println(\"This executes in the child task.\");\n     std::io::println(#fmt(\"%d\", some_value));\n-};\n+}\n ~~~~\n \n The argument to `task::spawn()` is a [unique\n@@ -2456,70 +2456,66 @@ let result = comm::recv(port);\n ## Creating a task with a bi-directional communication path\n \n A very common thing to do is to spawn a child task where the parent\n-and child both need to exchange messages with each other. The function\n-`task::spawn_connected()` supports this pattern. We'll look briefly at\n-how it is used.\n+and child both need to exchange messages with each\n+other. The function `task::spawn_listener()` supports this pattern. We'll look\n+briefly at how it is used.\n \n-To see how `spawn_connected()` works, we will create a child task\n+To see how `spawn_listener()` works, we will create a child task\n which receives `uint` messages, converts them to a string, and sends\n the string in response.  The child terminates when `0` is received.\n Here is the function which implements the child task:\n \n ~~~~\n-fn stringifier(from_par: comm::port<uint>,\n-               to_par: comm::chan<str>) {\n+fn stringifier(from_parent: comm::port<uint>,\n+               to_parent: comm::chan<str>) {\n     let value: uint;\n     do {\n-        value = comm::recv(from_par);\n-        comm::send(to_par, uint::to_str(value, 10u));\n+        value = comm::recv(from_parent);\n+        comm::send(to_parent, uint::to_str(value, 10u));\n     } while value != 0u;\n }\n \n ~~~~\n+\n You can see that the function takes two parameters.  The first is a\n port used to receive messages from the parent, and the second is a\n channel used to send messages to the parent.  The body itself simply\n loops, reading from the `from_par` port and then sending its response\n to the `to_par` channel.  The actual response itself is simply the\n strified version of the received value, `uint::to_str(value)`.\n-\n+ \n Here is the code for the parent task:\n+\n ~~~~\n-# fn stringifier(from_par: comm::port<uint>,\n-#                to_par: comm::chan<str>) {\n-#     comm::send(to_par, \"22\");\n-#     comm::send(to_par, \"23\");\n-#     comm::send(to_par, \"0\");\n+# fn stringifier(from_parent: comm::port<uint>,\n+#                to_parent: comm::chan<str>) {\n+#     comm::send(to_parent, \"22\");\n+#     comm::send(to_parent, \"23\");\n+#     comm::send(to_parent, \"0\");\n # }\n fn main() {\n-    let t = task::spawn_connected(stringifier);\n-    comm::send(t.to_child, 22u);\n-    assert comm::recv(t.from_child) == \"22\";\n-    comm::send(t.to_child, 23u);\n-    assert comm::recv(t.from_child) == \"23\";\n-    comm::send(t.to_child, 0u);\n-    assert comm::recv(t.from_child) == \"0\";\n-}\n-~~~~\n-\n-The call to `spawn_connected()` on the first line will instantiate the\n-various ports and channels and startup the child task.  The returned\n-value, `t`, is a record of type `task::connected_task<uint,str>`.  In\n-addition to the task id of the child, this record defines two fields,\n-`from_child` and `to_child`, which contain the port and channel\n-respectively for communicating with the child.  Those fields are used\n-here to send and receive three messages from the child task.\n-\n-## Joining a task\n-\n-The function `spawn_joinable()` is used to spawn a task that can later\n-be joined. This is implemented by having the child task send a message\n-when it has completed (either successfully or by failing). Therefore,\n-`spawn_joinable()` returns a structure containing both the task ID and\n-the port where this message will be sent---this structure type is\n-called `task::joinable_task`. The structure can be passed to\n-`task::join()`, which simply blocks on the port, waiting to receive\n-the message from the child task.\n+    let from_child = comm::port();\n+    let to_parent = comm::chan(from_child);\n+    let to_child = task::spawn_listener {|from_parent|\n+        stringifier(from_parent, to_parent);\n+    };\n+    comm::send(to_child, 22u);\n+    assert comm::recv(from_child) == \"22\";\n+    comm::send(to_child, 23u);\n+    assert comm::recv(from_child) == \"23\";\n+    comm::send(to_child, 0u);\n+    assert comm::recv(from_child) == \"0\";\n+}\n+~~~~\n+\n+The parent first sets up a port to receive data from and a channel\n+that the child can use to send data to that port. The call to\n+`spawn_listener()` will spawn the child task, providing it with a port\n+on which to receive data from its parent, and returning to the parent\n+the associated channel. Finally, the closure passed to\n+`spawn_listener()` that forms the body of the child task captures the\n+`to_parent` channel in its environment, so both parent and child\n+can send and receive data to and from the other.\n \n ## The supervisor relationship\n "}, {"sha": "5186290e4a4cb7c4d6ac1e101c373c041539e7ec", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=4220dcf1e9de2c2d2c329ecefa80108b63a69145", "patch": "@@ -143,8 +143,6 @@ fn monitor(f: fn~(diagnostic::emitter)) {\n \n     alt task::try  {||\n \n-        task::unsupervise();\n-\n         // The 'diagnostics emitter'. Every error, warning, etc. should\n         // go through this function.\n         let demitter = fn@(cmsp: option<(codemap::codemap, codemap::span)>,"}, {"sha": "abdd0fb9ab0674104d287a14b7f7b309d2a17ce0", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=4220dcf1e9de2c2d2c329ecefa80108b63a69145", "patch": "@@ -54,11 +54,11 @@ fn run(lib_path: str, prog: str, args: [str],\n     writeclose(pipe_in.out, input);\n     let p = comm::port();\n     let ch = comm::chan(p);\n-    task::spawn_sched(1u) {||\n+    task::spawn_sched(task::single_threaded) {||\n         let errput = readclose(pipe_err.in);\n         comm::send(ch, (2, errput));\n     };\n-    task::spawn_sched(1u) {||\n+    task::spawn_sched(task::single_threaded) {||\n         let output = readclose(pipe_out.in);\n         comm::send(ch, (1, output));\n     };"}, {"sha": "636fc702d35c083c0dd5b79adc75a8ef50742abe", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=4220dcf1e9de2c2d2c329ecefa80108b63a69145", "patch": "@@ -35,8 +35,9 @@ enum rust_port {}\n \n #[abi = \"cdecl\"]\n native mod rustrt {\n+    fn get_task_id() -> task_id;\n     fn chan_id_send<T: send>(t: *sys::type_desc,\n-                            target_task: task::task, target_port: port_id,\n+                            target_task: task_id, target_port: port_id,\n                             data: T) -> ctypes::uintptr_t;\n \n     fn new_port(unit_sz: ctypes::size_t) -> *rust_port;\n@@ -58,6 +59,7 @@ native mod rusti {\n     fn call_with_retptr<T: send>(&&f: fn@(*uint)) -> T;\n }\n \n+type task_id = int;\n type port_id = int;\n \n // It's critical that this only have one variant, so it has a record\n@@ -75,7 +77,7 @@ type port_id = int;\n           over other channels.\"\n )]\n enum chan<T: send> {\n-    chan_t(task::task, port_id)\n+    chan_t(task_id, port_id)\n }\n \n resource port_ptr<T: send>(po: *rust_port) {\n@@ -208,7 +210,7 @@ fn peek<T: send>(p: port<T>) -> bool {\n            port used to construct it.\"\n )]\n fn chan<T: send>(p: port<T>) -> chan<T> {\n-    chan_t(task::get_task(), rustrt::get_port_id(***p))\n+    chan_t(rustrt::get_task_id(), rustrt::get_port_id(***p))\n }\n \n #[test]"}, {"sha": "79316d5310d65ccc345906a1404cb80256c39697", "filename": "src/libcore/task.rs", "status": "modified", "additions": 767, "deletions": 416, "changes": 1183, "blob_url": "https://github.com/rust-lang/rust/blob/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=4220dcf1e9de2c2d2c329ecefa80108b63a69145", "patch": "@@ -1,5 +1,4 @@\n-/*\n-Module: task\n+#[doc = \"\n \n Task management.\n \n@@ -13,564 +12,916 @@ true: when a parent task fails its children will continue executing. When\n the root (main) task fails, all tasks fail, and then so does the entire\n process.\n \n-A task may remove itself from this failure propagation mechanism by\n-calling the <unsupervise> function, after which failure will only\n-result in the termination of that task.\n-\n Tasks may execute in parallel and are scheduled automatically by the runtime.\n \n Example:\n \n-> spawn {||\n->   log(debug, \"Hello, World!\");\n-> };\n+    spawn {||\n+        log(error, \\\"Hello, World!\\\");\n+    }\n \n-*/\n-import cast = unsafe::reinterpret_cast;\n-import comm;\n-import ptr;\n-import c = ctypes;\n+\"];\n \n export task;\n-export joinable_task;\n-export yield;\n-export task_notification;\n-export join;\n-export unsupervise;\n export task_result;\n-export tr_success;\n-export tr_failure;\n-export get_task;\n+export notification;\n+export sched_mode;\n+export sched_opts;\n+export task_opts;\n+export task_builder::{};\n+\n+export default_task_opts;\n+export mk_task_builder;\n+export get_opts;\n+export set_opts;\n+export add_wrapper;\n+export run;\n+\n+export future_result;\n+export future_task;\n+export unsupervise;\n+export run_listener;\n+\n export spawn;\n-export spawn_joinable;\n-export spawn_connected;\n+export spawn_listener;\n export spawn_sched;\n-export connected_fn;\n-export connected_task;\n-export currently_unwinding;\n export try;\n \n-#[abi = \"rust-intrinsic\"]\n-native mod rusti {\n-    // these must run on the Rust stack so that they can swap stacks etc:\n-    fn task_yield(task: *rust_task, &killed: bool);\n+export yield;\n+export failing;\n+export get_task;\n+\n+\n+/* Data types */\n+\n+#[doc = \"A handle to a task\"]\n+enum task = task_id;\n+\n+#[doc = \"\n+\n+Indicates the manner in which a task exited.\n+\n+A task that completes without failing and whose supervised children complete\n+without failing is considered to exit successfully.\n+\n+FIXME: This description does not indicate the current behavior for linked\n+failure.\n+\n+\"]\n+enum task_result {\n+    success,\n+    failure,\n }\n \n-type rust_closure = {\n-    fnptr: c::intptr_t, envptr: c::intptr_t\n+#[doc = \"\n+\n+A message type for notifying of task lifecycle events\n+\n+\"]\n+enum notification {\n+    #[doc = \"Sent when a task exits with the task handle and result\"]\n+    exit(task, task_result)\n+}\n+\n+#[doc = \"Scheduler modes\"]\n+enum sched_mode {\n+    #[doc = \"All tasks run in the same OS thread\"]\n+    single_threaded,\n+    #[doc = \"Tasks are distributed among available CPUs\"]\n+    thread_per_core,\n+    #[doc = \"Each task runs in its own OS thread\"]\n+    thread_per_task,\n+    #[doc = \"Tasks are distributed among a fixed number of OS threads\"]\n+    manual_threads(uint),\n+}\n+\n+#[doc = \"\n+\n+Scheduler configuration options\n+\n+Fields:\n+\n+* sched_mode - The operating mode of the scheduler\n+\n+* native_stack_size - The size of the native stack, in bytes\n+\n+    Rust code runs on Rust-specific stacks. When Rust code calls native code\n+    (via functions in native modules) it switches to a typical, large stack\n+    appropriate for running code written in languages like C. By default these\n+    native stacks have unspecified size, but with this option their size can\n+    be precisely specified.\n+\n+\"]\n+type sched_opts = {\n+    mode: sched_mode,\n+    native_stack_size: option<uint>,\n };\n \n-#[link_name = \"rustrt\"]\n-#[abi = \"cdecl\"]\n-native mod rustrt {\n-    fn rust_get_sched_id() -> sched_id;\n-    fn rust_new_sched(num_threads: c::uintptr_t) -> sched_id;\n+#[doc = \"\n \n-    fn get_task_id() -> task_id;\n-    fn rust_get_task() -> *rust_task;\n+Task configuration options\n \n-    fn new_task() -> task_id;\n-    fn rust_new_task_in_sched(id: sched_id) -> task_id;\n+Fields:\n \n-    fn rust_task_config_notify(\n-        id: task_id, &&chan: comm::chan<task_notification>);\n+* supervise - Do not propagate failure to the parent task\n \n-    fn start_task(id: task, closure: *rust_closure);\n+    All tasks are linked together via a tree, from parents to children. By\n+    default children are 'supervised' by their parent and when they fail\n+    so too will their parents. Settings this flag to false disables that\n+    behavior.\n \n-    fn rust_task_is_unwinding(rt: *rust_task) -> bool;\n-    fn unsupervise();\n-}\n+* notify_chan - Enable lifecycle notifications on the given channel\n \n-/* Section: Types */\n+* sched - Specify the configuration of a new scheduler to create the task in\n \n-type rust_task = *ctypes::void;\n+    By default, every task is created in the same scheduler as its\n+    parent, where it is scheduled cooperatively with all other tasks\n+    in that scheduler. Some specialized applications may want more\n+    control over their scheduling, in which case they can be spawned\n+    into a new scheduler with the specific properties required.\n \n-type sched_id = int;\n-type task_id = int;\n+    This is of particular importance for libraries which want to call\n+    into native code that blocks. Without doing so in a different\n+    scheduler other tasks will be impeded or even blocked indefinitely.\n \n-/*\n-Type: task\n+\"]\n+type task_opts = {\n+    supervise: bool,\n+    notify_chan: option<comm::chan<notification>>,\n+    sched: option<sched_opts>,\n+};\n+\n+#[doc = \"\n \n-A handle to a task\n-*/\n-type task = task_id;\n+The task builder type.\n \n-/*\n-Function: spawn\n+Provides detailed control over the properties and behavior of new tasks.\n \n-Creates and executes a new child task\n+\"]\n+// NB: Builders are designed to be single-use because they do stateful\n+// things that get weird when reusing - e.g. if you create a result future\n+// it only applies to a single task, so then you have to maintain some\n+// potentially tricky state to ensure that everything behaves correctly\n+// when you try to reuse the builder to spawn a new task. We'll just\n+// sidestep that whole issue by making builder's uncopyable and making\n+// the run function move them in.\n+enum task_builder = {\n+    mutable opts: task_opts,\n+    mutable gen_body: fn@(+fn~()) -> fn~(),\n+    can_not_copy: option<comm::port<()>>\n+};\n \n-Sets up a new task with its own call stack and schedules it to be\n-executed.  Upon execution, the closure `f()` will be invoked.\n \n-Parameters:\n+/* Task construction */\n \n-f - A function to execute in the new task\n+fn default_task_opts() -> task_opts {\n+    #[doc = \"\n \n-Returns:\n+    The default task options\n \n-A handle to the new task\n-*/\n-fn spawn(+f: fn~()) -> task {\n-    spawn_inner(f, none, new_task_in_this_sched)\n-}\n+    By default all tasks are supervised by their parent, are spawned\n+    into the same scheduler, and do not post lifecycle notifications.\n \n-fn spawn_inner(\n-    -f: fn~(),\n-    notify: option<comm::chan<task_notification>>,\n-    new_task: fn() -> task_id\n-) -> task unsafe {\n-    let closure: *rust_closure = unsafe::reinterpret_cast(ptr::addr_of(f));\n-    #debug(\"spawn: closure={%x,%x}\", (*closure).fnptr, (*closure).envptr);\n-    let id = new_task();\n+    \"];\n \n-    // set up notifications if they are enabled.\n-    option::may(notify) {|c|\n-        rustrt::rust_task_config_notify(id, c);\n+    {\n+        supervise: true,\n+        notify_chan: none,\n+        sched: none\n     }\n+}\n \n-    rustrt::start_task(id, closure);\n-    unsafe::leak(f);\n-    ret id;\n+fn mk_task_builder() -> task_builder {\n+    #[doc = \"Construct a task_builder\"];\n+\n+    let body_identity = fn@(+body: fn~()) -> fn~() { body };\n+\n+    task_builder({\n+        mutable opts: default_task_opts(),\n+        mutable gen_body: body_identity,\n+        can_not_copy: none\n+    })\n+}\n+\n+fn get_opts(builder: task_builder) -> task_opts {\n+    #[doc = \"Get the task_opts associated with a task_builder\"];\n+\n+    builder.opts\n+}\n+\n+fn set_opts(builder: task_builder, opts: task_opts) {\n+    #[doc = \"\n+\n+    Set the task_opts associated with a task_builder\n+\n+    To update a single option use a pattern like the following:\n+\n+        set_opts(builder, {\n+            supervise: false\n+            with get_opts(builder)\n+        });\n+\n+    \"];\n+\n+    builder.opts = opts;\n }\n \n-fn new_task_in_this_sched() -> task_id {\n-    rustrt::new_task()\n+fn add_wrapper(builder: task_builder, gen_body: fn@(+fn~()) -> fn~()) {\n+    #[doc = \"\n+\n+    Add a wrapper to the body of the spawned task.\n+\n+    Before the task is spawned it is passed through a 'body generator'\n+    function that may perform local setup operations as well as wrap\n+    the task body in remote setup operations. With this the behavior\n+    of tasks can be extended in simple ways.\n+\n+    This function augments the current body generator with a new body\n+    generator by applying the task body which results from the\n+    existing body generator to the new body generator.\n+\n+    \"];\n+\n+    let prev_gen_body = builder.gen_body;\n+    builder.gen_body = fn@(+body: fn~()) -> fn~() {\n+        gen_body(prev_gen_body(body))\n+    };\n }\n \n-fn new_task_in_new_sched(num_threads: uint) -> task_id {\n-    let sched_id = rustrt::rust_new_sched(num_threads);\n-    rustrt::rust_new_task_in_sched(sched_id)\n+fn run(-builder: task_builder, +f: fn~()) {\n+    #[doc(desc = \"\n+\n+    Creates and exucutes a new child task\n+\n+    Sets up a new task with its own call stack and schedules it to run\n+    the provided unique closure. The task has the properties and behavior\n+    specified by `builder`.\n+\n+    \", failure = \"\n+\n+    When spawning into a new scheduler, the number of threads requested\n+    must be greater than zero.\n+\n+    \")];\n+\n+    let body = builder.gen_body(f);\n+    spawn_raw(builder.opts, body);\n }\n \n-/*\n-Function: spawn_sched\n \n-Creates a new scheduler and executes a task on it. Tasks subsequently\n-spawned by that task will also execute on the new scheduler. When\n-there are no more tasks to execute the scheduler terminates.\n+/* Builder convenience functions */\n+\n+fn future_result(builder: task_builder) -> future::future<task_result> {\n+    #[doc = \"\n+\n+    Get a future representing the exit status of the task.\n+\n+    Taking the value of the future will block until the child task terminates.\n \n-Arguments:\n+    Note that the future returning by this function is only useful for\n+    obtaining the value of the next task to be spawning with the\n+    builder. If additional tasks are spawned with the same builder\n+    then a new result future must be obtained prior to spawning each\n+    task.\n \n-num_threads - The number of OS threads to dedicate schedule tasks on\n-f - A unique closure to execute as a task on the new scheduler\n+    \"];\n \n-Failure:\n+    // FIXME (1087, 1857): Once linked failure and notification are\n+    // handled in the library, I can imagine implementing this by just\n+    // registering an arbitrary number of task::on_exit handlers and\n+    // sending out messages.\n \n-The number of threads must be greater than 0\n+    let po = comm::port();\n+    let ch = comm::chan(po);\n \n-*/\n-fn spawn_sched(num_threads: uint, +f: fn~()) -> task {\n-    if num_threads < 1u {\n-        fail \"Can not create a scheduler with no threads\";\n+    set_opts(builder, {\n+        notify_chan: some(ch)\n+        with get_opts(builder)\n+    });\n+\n+    future::from_fn {||\n+        alt comm::recv(po) {\n+          exit(_, result) { result }\n+        }\n     }\n-    spawn_inner(f, none, bind new_task_in_new_sched(num_threads))\n-}\n-\n-/*\n-Type: joinable_task\n-\n-A task that sends notification upon termination\n-*/\n-type joinable_task = (task, comm::port<task_notification>);\n-\n-fn spawn_joinable(+f: fn~()) -> joinable_task {\n-    let notify_port = comm::port();\n-    let notify_chan = comm::chan(notify_port);\n-    let task = spawn_inner(f, some(notify_chan), new_task_in_this_sched);\n-    ret (task, notify_port);\n-    /*\n-    resource notify_rsrc(data: (comm::chan<task_notification>,\n-                                task,\n-                                @mutable task_result)) {\n-        let (chan, task, tr) = data;\n-        let msg = exit(task, *tr);\n-        comm::send(chan, msg);\n+}\n+\n+fn future_task(builder: task_builder) -> future::future<task> {\n+    #[doc = \"Get a future representing the handle to the new task\"];\n+\n+    let po = comm::port();\n+    let ch = comm::chan(po);\n+    add_wrapper(builder) {|body|\n+        fn~[move body]() {\n+            comm::send(ch, get_task());\n+            body();\n+        }\n     }\n+    future::from_port(po)\n+}\n \n-    let notify_port = comm::port();\n-    let notify_chan = comm::chan(notify_port);\n-    let g = fn~[copy notify_chan; move f]() {\n-        let this_task = rustrt::get_task_id();\n-        let result = @mutable tr_failure;\n-        let _rsrc = notify_rsrc((notify_chan, this_task, result));\n-        f();\n-        *result = tr_success; // rsrc will fire msg when fn returns\n-    };\n-    let task = spawn(g);\n-    ret (task, notify_port);\n-    */\n+fn unsupervise(builder: task_builder) {\n+    #[doc = \"Configures the new task to not propagate failure to its parent\"];\n+\n+    set_opts(builder, {\n+        supervise: false\n+        with get_opts(builder)\n+    });\n }\n \n-/*\n-Tag: task_result\n+fn run_listener<A:send>(-builder: task_builder,\n+                        +f: fn~(comm::port<A>)) -> comm::chan<A> {\n+    #[doc = \"\n \n-Indicates the manner in which a task exited\n-*/\n-enum task_result {\n-    /* Variant: tr_success */\n-    tr_success,\n-    /* Variant: tr_failure */\n-    tr_failure,\n+    Runs a new task while providing a channel from the parent to the child\n+\n+    Sets up a communication channel from the current task to the new\n+    child task, passes the port to child's body, and returns a channel\n+    linked to the port to the parent.\n+\n+    This encapsulates some boilerplate handshaking logic that would\n+    otherwise be required to establish communication from the parent\n+    to the child.\n+    \"];\n+\n+    let setup_po = comm::port();\n+    let setup_ch = comm::chan(setup_po);\n+\n+    run(builder, fn~[move f]() {\n+        let po = comm::port();\n+        let ch = comm::chan(po);\n+        comm::send(setup_ch, ch);\n+        f(po);\n+    });\n+\n+    comm::recv(setup_po)\n }\n \n-/*\n-Tag: task_notification\n \n-Message sent upon task exit to indicate normal or abnormal termination\n-*/\n-enum task_notification {\n-    /* Variant: exit */\n-    exit(task, task_result),\n+/* Spawn convenience functions */\n+\n+fn spawn(+f: fn~()) {\n+    #[doc = \"\n+\n+    Creates and exucutes a new child task\n+\n+    Sets up a new task with its own call stack and schedules it to run\n+    the provided unique closure.\n+\n+    This function is equivalent to `run(mk_task_builder(), f)`.\n+    \"];\n+\n+    run(mk_task_builder(), f);\n }\n \n-/*\n-Type: connected_fn\n+fn spawn_listener<A:send>(+f: fn~(comm::port<A>)) -> comm::chan<A> {\n+    #[doc = \"\n \n-The prototype for a connected child task function.  Such a function will be\n-supplied with a channel to send messages to the parent and a port to receive\n-messages from the parent. The type parameter `ToCh` is the type for messages\n-sent from the parent to the child and `FrCh` is the type for messages sent\n-from the child to the parent. */\n-type connected_fn<ToCh, FrCh> = fn~(comm::port<ToCh>, comm::chan<FrCh>);\n+    Runs a new task while providing a channel from the parent to the child\n \n-/*\n-Type: connected_fn\n+    Sets up a communication channel from the current task to the new\n+    child task, passes the port to child's body, and returns a channel\n+    linked to the port to the parent.\n \n-The result type of <spawn_connected>\n-*/\n-type connected_task<ToCh, FrCh> = {\n-    from_child: comm::port<FrCh>,\n-    to_child: comm::chan<ToCh>,\n-    task: task\n-};\n+    This encapsulates some boilerplate handshaking logic that would\n+    otherwise be required to establish communication from the parent\n+    to the child.\n \n-/*\n-Function: spawn_connected\n+    The simplest way to establish bidirectional communication between\n+    a parent in child is as follows:\n \n-Spawns a child task along with a port/channel for exchanging messages\n-with the parent task.  The type `ToCh` represents messages sent to the child\n-and `FrCh` messages received from the child.\n+        let po = comm::port();\n+        let ch = comm::chan(po);\n+        let ch = spawn_listener {|po|\n+            // Now the child has a port called 'po' to read from and\n+            // an environment-captured channel called 'ch'.\n+        };\n+        // Likewise, the parent has both a 'po' and 'ch'\n+\n+    This function is equivalent to `run_listener(mk_task_builder(), f)`.\n+\n+    \"];\n+\n+    run_listener(mk_task_builder(), f)\n+}\n \n-Parameters:\n+fn spawn_sched(mode: sched_mode, +f: fn~()) {\n+    #[doc(desc = \"\n \n-f - the child function to execute\n+    Creates a new scheduler and executes a task on it\n \n-Returns:\n+    Tasks subsequently spawned by that task will also execute on\n+    the new scheduler. When there are no more tasks to execute the\n+    scheduler terminates.\n \n-The new child task along with the port to receive messages and the channel\n-to send messages.\n-*/\n-fn spawn_connected<ToCh:send, FrCh:send>(+f: connected_fn<ToCh, FrCh>)\n-    -> connected_task<ToCh,FrCh> {\n-    let from_child_port = comm::port::<FrCh>();\n-    let from_child_chan = comm::chan(from_child_port);\n-    let get_to_child_port = comm::port::<comm::chan<ToCh>>();\n-    let get_to_child_chan = comm::chan(get_to_child_port);\n-    let child_task = spawn(fn~[move f]() {\n-        let to_child_port = comm::port::<ToCh>();\n-        comm::send(get_to_child_chan, comm::chan(to_child_port));\n-        f(to_child_port, from_child_chan);\n+    \", failure = \"\n+\n+    In manual threads mode the number of threads requested must be\n+    greater than zero.\n+\n+    \")];\n+\n+    let builder = mk_task_builder();\n+    set_opts(builder, {\n+        sched: some({\n+            mode: mode,\n+            native_stack_size: none\n+        })\n+        with get_opts(builder)\n     });\n-    let to_child_chan = comm::recv(get_to_child_port);\n-    ret {from_child: from_child_port,\n-         to_child: to_child_chan,\n-         task: child_task};\n+    run(builder, f);\n }\n \n-/* Section: Operations */\n+fn try<T:send>(+f: fn~() -> T) -> result::t<T,()> {\n+    #[doc(desc = \"\n \n-/*\n-Type: get_task\n+    Execute a function in another task and return either the return value\n+    of the function or result::err.\n \n-Retreives a handle to the currently executing task\n-*/\n-fn get_task() -> task { rustrt::get_task_id() }\n+    \", return = \"\n \n-/*\n-Function: yield\n+    If the function executed successfully then try returns result::ok\n+    containing the value returned by the function. If the function fails\n+    then try returns result::err containing nil.\n \n-Yield control to the task scheduler\n+    \")];\n+\n+    let po = comm::port();\n+    let ch = comm::chan(po);\n+    let builder = mk_task_builder();\n+    unsupervise(builder);\n+    let result = future_result(builder);\n+    run(builder, fn~[move f]() {\n+        comm::send(ch, f());\n+    });\n+    alt future::get(result) {\n+      success { result::ok(comm::recv(po)) }\n+      failure { result::err(()) }\n+    }\n+}\n+\n+\n+/* Lifecycle functions */\n \n-The scheduler may schedule another task to execute.\n-*/\n fn yield() {\n-    let task = rustrt::rust_get_task();\n+    #[doc = \"Yield control to the task scheduler\"];\n+\n+    let task_ = rustrt::rust_get_task();\n     let killed = false;\n-    rusti::task_yield(task, killed);\n-    if killed && !currently_unwinding() {\n+    rusti::task_yield(task_, killed);\n+    if killed && !failing() {\n         fail \"killed\";\n     }\n }\n \n-/*\n-Function: join\n+fn failing() -> bool {\n+    #[doc = \"True if the running task has failed\"];\n \n-Wait for a child task to exit\n+    rustrt::rust_task_is_unwinding(rustrt::rust_get_task())\n+}\n \n-The child task must have been spawned with <spawn_joinable>, which\n-produces a notification port that the child uses to communicate its\n-exit status.\n+fn get_task() -> task {\n+    #[doc = \"Get a handle to the running task\"];\n \n-Returns:\n+    task(rustrt::get_task_id())\n+}\n \n-A task_result indicating whether the task terminated normally or failed\n-*/\n-fn join(task_port: joinable_task) -> task_result {\n-    let (id, port) = task_port;\n-    alt comm::recv::<task_notification>(port) {\n-      exit(_id, res) {\n-        if _id == id {\n-            ret res\n-        } else {\n-            fail #fmt[\"join received id %d, expected %d\", _id, id]\n+\n+/* Internal */\n+\n+type sched_id = int;\n+type task_id = int;\n+\n+// These are both opaque runtime/compiler types that we don't know the\n+// structure of and should only deal with via unsafe pointer\n+type rust_task = ctypes::void;\n+type rust_closure = ctypes::void;\n+\n+fn spawn_raw(opts: task_opts, +f: fn~()) unsafe {\n+\n+    let f = if opts.supervise {\n+        f\n+    } else {\n+        // FIXME: The runtime supervision API is weird here because it\n+        // was designed to let the child unsupervise itself, when what\n+        // we actually want is for parents to unsupervise new\n+        // children.\n+        fn~[move f]() {\n+            rustrt::unsupervise();\n+            f();\n         }\n+    };\n+\n+    let fptr = ptr::addr_of(f);\n+    let closure: *rust_closure = unsafe::reinterpret_cast(fptr);\n+\n+    let task_id = alt opts.sched {\n+      none {\n+        rustrt::new_task()\n+      }\n+      some(sched_opts) {\n+        new_task_in_new_sched(sched_opts)\n       }\n+    };\n+\n+    option::may(opts.notify_chan) {|c|\n+        // FIXME (1087): Would like to do notification in Rust\n+        rustrt::rust_task_config_notify(task_id, c);\n     }\n-}\n \n-/*\n-Function: unsupervise\n+    rustrt::start_task(task_id, closure);\n+    unsafe::leak(f);\n \n-Detaches this task from its parent in the task tree\n+    fn new_task_in_new_sched(opts: sched_opts) -> task_id {\n+        if opts.native_stack_size != none {\n+            fail \"native_stack_size scheduler option unimplemented\";\n+        }\n \n-An unsupervised task will not propagate its failure up the task tree\n-*/\n-fn unsupervise() {\n-    rustrt::unsupervise();\n-}\n+        let num_threads = alt opts.mode {\n+          single_threaded { 1u }\n+          thread_per_core {\n+            fail \"thread_per_core scheduling mode unimplemented\"\n+          }\n+          thread_per_task {\n+            fail \"thread_per_task scheduling mode unimplemented\"\n+          }\n+          manual_threads(threads) {\n+            if threads == 0u {\n+                fail \"can not create a scheduler with no threads\";\n+            }\n+            threads\n+          }\n+        };\n \n-/*\n-Function: currently_unwinding()\n+        let sched_id = rustrt::rust_new_sched(num_threads);\n+        rustrt::rust_new_task_in_sched(sched_id)\n+    }\n \n-True if we are currently unwinding after a failure.\n-*/\n-fn currently_unwinding() -> bool {\n-    rustrt::rust_task_is_unwinding(rustrt::rust_get_task())\n }\n \n-/*\n-Function: try\n+#[abi = \"rust-intrinsic\"]\n+native mod rusti {\n+    fn task_yield(task: *rust_task, &killed: bool);\n+}\n \n-Execute a function in another task and return either the return value\n-of the function or result::err.\n+native mod rustrt {\n+    fn rust_get_sched_id() -> sched_id;\n+    fn rust_new_sched(num_threads: ctypes::uintptr_t) -> sched_id;\n \n-Returns:\n+    fn get_task_id() -> task_id;\n+    fn rust_get_task() -> *rust_task;\n \n-If the function executed successfully then try returns result::ok\n-containing the value returned by the function. If the function fails\n-then try returns result::err containing nil.\n-*/\n-fn try<T:send>(+f: fn~() -> T) -> result::t<T,()> {\n-    let p = comm::port();\n-    let ch = comm::chan(p);\n-    alt join(spawn_joinable {||\n-        unsupervise();\n-        comm::send(ch, f());\n-    }) {\n-      tr_success { result::ok(comm::recv(p)) }\n-      tr_failure { result::err(()) }\n+    fn new_task() -> task_id;\n+    fn rust_new_task_in_sched(id: sched_id) -> task_id;\n+\n+    fn rust_task_config_notify(\n+        id: task_id, &&chan: comm::chan<notification>);\n+\n+    fn start_task(id: task_id, closure: *rust_closure);\n+\n+    fn rust_task_is_unwinding(rt: *rust_task) -> bool;\n+    fn unsupervise();\n+}\n+\n+\n+#[test]\n+fn test_spawn_raw_simple() {\n+    let po = comm::port();\n+    let ch = comm::chan(po);\n+    spawn_raw(default_task_opts()) {||\n+        comm::send(ch, ());\n     }\n+    comm::recv(po);\n }\n \n-#[cfg(test)]\n-mod tests {\n-    // FIXME: Leaks on windows\n-    #[test]\n-    #[ignore(cfg(target_os = \"win32\"))]\n-    fn test_unsupervise() {\n-        fn f() { unsupervise(); fail; }\n-        spawn {|| f();};\n+#[test]\n+#[ignore(cfg(target_os = \"win32\"))]\n+fn test_spawn_raw_unsupervise() {\n+    let opts = {\n+        supervise: false\n+        with default_task_opts()\n+    };\n+    spawn_raw(opts) {||\n+        fail;\n     }\n+}\n \n-    #[test]\n-    fn test_lib_spawn() {\n-        fn foo() { #error(\"Hello, World!\"); }\n-        spawn {|| foo();};\n+#[test]\n+#[ignore(cfg(target_os = \"win32\"))]\n+fn test_spawn_raw_notify() {\n+    let task_po = comm::port();\n+    let task_ch = comm::chan(task_po);\n+    let notify_po = comm::port();\n+    let notify_ch = comm::chan(notify_po);\n+\n+    let opts = {\n+        notify_chan: some(notify_ch)\n+        with default_task_opts()\n+    };\n+    spawn_raw(opts) {||\n+        comm::send(task_ch, get_task());\n     }\n+    let task_ = comm::recv(task_po);\n+    assert comm::recv(notify_po) == exit(task_, success);\n \n-    #[test]\n-    fn test_lib_spawn2() {\n-        fn foo(x: int) { assert (x == 42); }\n-        spawn {|| foo(42);};\n+    let opts = {\n+        supervise: false,\n+        notify_chan: some(notify_ch)\n+        with default_task_opts()\n+    };\n+    spawn_raw(opts) {||\n+        comm::send(task_ch, get_task());\n+        fail;\n     }\n+    let task_ = comm::recv(task_po);\n+    assert comm::recv(notify_po) == exit(task_, failure);\n+}\n \n-    #[test]\n-    fn test_join_chan() {\n-        fn winner() { }\n+#[test]\n+fn test_run_basic() {\n+    let po = comm::port();\n+    let ch = comm::chan(po);\n+    let builder = mk_task_builder();\n+    run(builder) {||\n+        comm::send(ch, ());\n+    }\n+    comm::recv(po);\n+}\n \n-        let t = spawn_joinable {|| winner();};\n-        alt join(t) {\n-          tr_success {/* yay! */ }\n-          _ { fail \"invalid task status received\" }\n+#[test]\n+fn test_add_wrapper() {\n+    let po = comm::port();\n+    let ch = comm::chan(po);\n+    let builder = mk_task_builder();\n+    add_wrapper(builder) {|body|\n+        fn~() {\n+            body();\n+            comm::send(ch, ());\n         }\n     }\n+    run(builder) {||}\n+    comm::recv(po);\n+}\n \n-    // FIXME: Leaks on windows\n-    #[test]\n-    #[ignore(cfg(target_os = \"win32\"))]\n-    fn test_join_chan_fail() {\n-        fn failer() { unsupervise(); fail }\n+#[test]\n+#[ignore(cfg(target_os = \"win32\"))]\n+fn test_future_result() {\n+    let builder = mk_task_builder();\n+    let result = future_result(builder);\n+    run(builder) {||}\n+    assert future::get(result) == success;\n+\n+    let builder = mk_task_builder();\n+    let result = future_result(builder);\n+    unsupervise(builder);\n+    run(builder) {|| fail }\n+    assert future::get(result) == failure;\n+}\n \n-        let t = spawn_joinable {|| failer();};\n-        alt join(t) {\n-          tr_failure {/* yay! */ }\n-          _ { fail \"invalid task status received\" }\n-        }\n-    }\n+#[test]\n+fn test_future_task() {\n+    let po = comm::port();\n+    let ch = comm::chan(po);\n+    let builder = mk_task_builder();\n+    let task1 = future_task(builder);\n+    run(builder) {|| comm::send(ch, get_task()) }\n+    assert future::get(task1) == comm::recv(po);\n+}\n \n-    #[test]\n-    fn spawn_polymorphic() {\n-        fn foo<T:send>(x: T) { log(error, x); }\n-        spawn {|| foo(true);};\n-        spawn {|| foo(42);};\n-    }\n+#[test]\n+fn test_spawn_listiner_bidi() {\n+    let po = comm::port();\n+    let ch = comm::chan(po);\n+    let ch = spawn_listener {|po|\n+        // Now the child has a port called 'po' to read from and\n+        // an environment-captured channel called 'ch'.\n+        let res = comm::recv(po);\n+        assert res == \"ping\";\n+        comm::send(ch, \"pong\");\n+    };\n+    // Likewise, the parent has both a 'po' and 'ch'\n+    comm::send(ch, \"ping\");\n+    let res = comm::recv(po);\n+    assert res == \"pong\";\n+}\n \n-    #[test]\n-    fn try_success() {\n-        alt try {||\n-            \"Success!\"\n-        } {\n-            result::ok(\"Success!\") { }\n-            _ { fail; }\n-        }\n+#[test]\n+fn test_try_success() {\n+    alt try {||\n+        \"Success!\"\n+    } {\n+        result::ok(\"Success!\") { }\n+        _ { fail; }\n     }\n+}\n \n-    #[test]\n-    #[ignore(cfg(target_os = \"win32\"))]\n-    fn try_fail() {\n-        alt try {||\n-            fail\n-        } {\n-            result::err(()) { }\n-            _ { fail; }\n-        }\n+#[test]\n+#[ignore(cfg(target_os = \"win32\"))]\n+fn test_try_fail() {\n+    alt try {||\n+        fail\n+    } {\n+        result::err(()) { }\n+        _ { fail; }\n     }\n+}\n \n-    #[test]\n-    #[should_fail]\n-    #[ignore(cfg(target_os = \"win32\"))]\n-    fn spawn_sched_no_threads() {\n-        spawn_sched(0u) {|| };\n-    }\n+#[test]\n+#[should_fail]\n+#[ignore(cfg(target_os = \"win32\"))]\n+fn test_spawn_sched_no_threads() {\n+    spawn_sched(manual_threads(0u)) {|| };\n+}\n \n-    #[test]\n-    fn spawn_sched_1() {\n-        let po = comm::port();\n-        let ch = comm::chan(po);\n+#[test]\n+fn test_spawn_sched() {\n+    let po = comm::port();\n+    let ch = comm::chan(po);\n \n-        fn f(i: int, ch: comm::chan<()>) {\n-            let parent_sched_id = rustrt::rust_get_sched_id();\n+    fn f(i: int, ch: comm::chan<()>) {\n+        let parent_sched_id = rustrt::rust_get_sched_id();\n \n-            spawn_sched(1u) {||\n-                let child_sched_id = rustrt::rust_get_sched_id();\n-                assert parent_sched_id != child_sched_id;\n+        spawn_sched(single_threaded) {||\n+            let child_sched_id = rustrt::rust_get_sched_id();\n+            assert parent_sched_id != child_sched_id;\n \n-                if (i == 0) {\n-                    comm::send(ch, ());\n-                } else {\n-                    f(i - 1, ch);\n-                }\n-            };\n+            if (i == 0) {\n+                comm::send(ch, ());\n+            } else {\n+                f(i - 1, ch);\n+            }\n+        };\n \n-        }\n-        f(10, ch);\n-        comm::recv(po);\n     }\n+    f(10, ch);\n+    comm::recv(po);\n+}\n \n-    #[test]\n-    fn spawn_sched_childs_on_same_sched() {\n-        let po = comm::port();\n-        let ch = comm::chan(po);\n-\n-        spawn_sched(1u) {||\n-            let parent_sched_id = rustrt::rust_get_sched_id();\n-            spawn {||\n-                let child_sched_id = rustrt::rust_get_sched_id();\n-                // This should be on the same scheduler\n-                assert parent_sched_id == child_sched_id;\n-                comm::send(ch, ());\n-            };\n+#[test]\n+fn test_spawn_sched_childs_on_same_sched() {\n+    let po = comm::port();\n+    let ch = comm::chan(po);\n+\n+    spawn_sched(single_threaded) {||\n+        let parent_sched_id = rustrt::rust_get_sched_id();\n+        spawn {||\n+            let child_sched_id = rustrt::rust_get_sched_id();\n+            // This should be on the same scheduler\n+            assert parent_sched_id == child_sched_id;\n+            comm::send(ch, ());\n         };\n+    };\n \n-        comm::recv(po);\n-    }\n+    comm::recv(po);\n+}\n \n-    #[nolink]\n-    native mod rt {\n-        fn rust_dbg_lock_create() -> *ctypes::void;\n-        fn rust_dbg_lock_destroy(lock: *ctypes::void);\n-        fn rust_dbg_lock_lock(lock: *ctypes::void);\n-        fn rust_dbg_lock_unlock(lock: *ctypes::void);\n-        fn rust_dbg_lock_wait(lock: *ctypes::void);\n-        fn rust_dbg_lock_signal(lock: *ctypes::void);\n-    }\n+#[nolink]\n+#[cfg(test)]\n+native mod testrt {\n+    fn rust_dbg_lock_create() -> *ctypes::void;\n+    fn rust_dbg_lock_destroy(lock: *ctypes::void);\n+    fn rust_dbg_lock_lock(lock: *ctypes::void);\n+    fn rust_dbg_lock_unlock(lock: *ctypes::void);\n+    fn rust_dbg_lock_wait(lock: *ctypes::void);\n+    fn rust_dbg_lock_signal(lock: *ctypes::void);\n+}\n \n-    #[test]\n-    fn spawn_sched_blocking() {\n+#[test]\n+fn test_spawn_sched_blocking() {\n \n-        // Testing that a task in one scheduler can block natively\n-        // without affecting other schedulers\n-        iter::repeat(20u) {||\n+    // Testing that a task in one scheduler can block natively\n+    // without affecting other schedulers\n+    iter::repeat(20u) {||\n \n-            let start_po = comm::port();\n-            let start_ch = comm::chan(start_po);\n-            let fin_po = comm::port();\n-            let fin_ch = comm::chan(fin_po);\n+        let start_po = comm::port();\n+        let start_ch = comm::chan(start_po);\n+        let fin_po = comm::port();\n+        let fin_ch = comm::chan(fin_po);\n \n-            let lock = rt::rust_dbg_lock_create();\n+        let lock = testrt::rust_dbg_lock_create();\n \n-            spawn_sched(1u) {||\n-                rt::rust_dbg_lock_lock(lock);\n+        spawn_sched(single_threaded) {||\n+            testrt::rust_dbg_lock_lock(lock);\n \n-                comm::send(start_ch, ());\n+            comm::send(start_ch, ());\n \n-                // Block the scheduler thread\n-                rt::rust_dbg_lock_wait(lock);\n-                rt::rust_dbg_lock_unlock(lock);\n+            // Block the scheduler thread\n+            testrt::rust_dbg_lock_wait(lock);\n+            testrt::rust_dbg_lock_unlock(lock);\n \n-                comm::send(fin_ch, ());\n-            };\n+            comm::send(fin_ch, ());\n+        };\n \n-            // Wait until the other task has its lock\n-            comm::recv(start_po);\n+        // Wait until the other task has its lock\n+        comm::recv(start_po);\n \n-            fn pingpong(po: comm::port<int>, ch: comm::chan<int>) {\n-                let val = 20;\n-                while val > 0 {\n-                    val = comm::recv(po);\n-                    comm::send(ch, val - 1);\n-                }\n+        fn pingpong(po: comm::port<int>, ch: comm::chan<int>) {\n+            let val = 20;\n+            while val > 0 {\n+                val = comm::recv(po);\n+                comm::send(ch, val - 1);\n             }\n-\n-            let setup_po = comm::port();\n-            let setup_ch = comm::chan(setup_po);\n-            let parent_po = comm::port();\n-            let parent_ch = comm::chan(parent_po);\n-            spawn {||\n-                let child_po = comm::port();\n-                comm::send(setup_ch, comm::chan(child_po));\n-                pingpong(child_po, parent_ch);\n-            };\n-\n-            let child_ch = comm::recv(setup_po);\n-            comm::send(child_ch, 20);\n-            pingpong(parent_po, child_ch);\n-            rt::rust_dbg_lock_lock(lock);\n-            rt::rust_dbg_lock_signal(lock);\n-            rt::rust_dbg_lock_unlock(lock);\n-            comm::recv(fin_po);\n-            rt::rust_dbg_lock_destroy(lock);\n         }\n+\n+        let setup_po = comm::port();\n+        let setup_ch = comm::chan(setup_po);\n+        let parent_po = comm::port();\n+        let parent_ch = comm::chan(parent_po);\n+        spawn {||\n+            let child_po = comm::port();\n+            comm::send(setup_ch, comm::chan(child_po));\n+            pingpong(child_po, parent_ch);\n+        };\n+\n+        let child_ch = comm::recv(setup_po);\n+        comm::send(child_ch, 20);\n+        pingpong(parent_po, child_ch);\n+        testrt::rust_dbg_lock_lock(lock);\n+        testrt::rust_dbg_lock_signal(lock);\n+        testrt::rust_dbg_lock_unlock(lock);\n+        comm::recv(fin_po);\n+        testrt::rust_dbg_lock_destroy(lock);\n     }\n+}\n \n+#[cfg(test)]\n+fn avoid_copying_the_body(spawnfn: fn(+fn~())) {\n+    let p = comm::port::<uint>();\n+    let ch = comm::chan(p);\n+\n+    let x = ~1;\n+    let x_in_parent = ptr::addr_of(*x) as uint;\n+\n+    spawnfn(fn~[move x]() {\n+        let x_in_child = ptr::addr_of(*x) as uint;\n+        comm::send(ch, x_in_child);\n+    });\n+\n+    let x_in_child = comm::recv(p);\n+    assert x_in_parent == x_in_child;\n }\n \n+#[test]\n+fn test_avoid_copying_the_body_spawn() {\n+    avoid_copying_the_body(spawn);\n+}\n \n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n+#[test]\n+fn test_avoid_copying_the_body_spawn_listener() {\n+    avoid_copying_the_body {|f|\n+        spawn_listener(fn~[move f](_po: comm::port<int>) {\n+            f();\n+        });\n+    }\n+}\n+\n+#[test]\n+fn test_avoid_copying_the_body_run() {\n+    avoid_copying_the_body {|f|\n+        let builder = mk_task_builder();\n+        run(builder, fn~[move f]() {\n+            f();\n+        });\n+    }\n+}\n+\n+#[test]\n+fn test_avoid_copying_the_body_run_listener() {\n+    avoid_copying_the_body {|f|\n+        let builder = mk_task_builder();\n+        run_listener(builder,fn~[move f](_po: comm::port<int>) {\n+            f();\n+        });\n+    }\n+}\n+\n+#[test]\n+fn test_avoid_copying_the_body_try() {\n+    avoid_copying_the_body {|f|\n+        try(fn~[move f]() {\n+            f();\n+        });\n+    }\n+}\n+\n+#[test]\n+fn test_avoid_copying_the_body_future_task() {\n+    avoid_copying_the_body {|f|\n+        let builder = mk_task_builder();\n+        future_task(builder);\n+        run(builder, fn~[move f]() {\n+            f();\n+        });\n+    }\n+}\n+\n+#[test]\n+fn test_avoid_copying_the_body_unsupervise() {\n+    avoid_copying_the_body {|f|\n+        let builder = mk_task_builder();\n+        unsupervise(builder);\n+        run(builder, fn~[move f]() {\n+            f();\n+        });\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "1dc9ad9a5743545c8c569b6afd62a0e06d65865b", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=4220dcf1e9de2c2d2c329ecefa80108b63a69145", "patch": "@@ -1929,16 +1929,10 @@ mod tests {\n     }\n \n     #[test]\n-    // FIXME: Windows can't undwind\n+    #[should_fail]\n     #[ignore(cfg(target_os = \"win32\"))]\n     fn test_init_empty() {\n-\n-        let r = task::join(\n-            task::spawn_joinable {||\n-                task::unsupervise();\n-                init::<int>([]);\n-            });\n-        assert r == task::tr_failure\n+        init::<int>([]);\n     }\n \n     #[test]"}, {"sha": "9f25916778f9519e6f6ba47fbf0ebdf3a9ee0d82", "filename": "src/libstd/test.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=4220dcf1e9de2c2d2c329ecefa80108b63a69145", "patch": "@@ -316,13 +316,12 @@ fn run_test(+test: test_desc, monitor_ch: comm::chan<monitor_msg>) {\n     task::spawn {||\n \n         let testfn = test.fn;\n-        let test_task = task::spawn_joinable {||\n-            configure_test_task();\n-            testfn();\n-        };\n-\n-        let task_result = task::join(test_task);\n-        let test_result = calc_result(test, task_result == task::tr_success);\n+        let builder = task::mk_task_builder();\n+        let result_future = task::future_result(builder);\n+        task::unsupervise(builder);\n+        task::run(builder, testfn);\n+        let task_result = future::get(result_future);\n+        let test_result = calc_result(test, task_result == task::success);\n         comm::send(monitor_ch, (test, test_result));\n     };\n }\n@@ -337,13 +336,6 @@ fn calc_result(test: test_desc, task_succeeded: bool) -> test_result {\n     }\n }\n \n-// Call from within a test task to make sure it's set up correctly\n-fn configure_test_task() {\n-    // If this task fails we don't want that failure to propagate to the\n-    // test runner or else we couldn't keep running tests\n-    task::unsupervise();\n-}\n-\n #[cfg(test)]\n mod tests {\n "}, {"sha": "29940492f795a662735209b473b5f86a381466a7", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=4220dcf1e9de2c2d2c329ecefa80108b63a69145", "patch": "@@ -539,6 +539,11 @@ chan_id_send(type_desc *t, rust_task_id target_task_id,\n     // FIXME: make sure this is thread-safe\n     bool sent = false;\n     rust_task *task = rust_task_thread::get_task();\n+\n+    LOG(task, comm, \"chan_id_send task: 0x%\" PRIxPTR\n+        \" port: 0x%\" PRIxPTR, (uintptr_t) target_task_id,\n+        (uintptr_t) target_port_id);\n+\n     rust_task *target_task = task->kernel->get_task_by_id(target_task_id);\n     if(target_task) {\n         rust_port *port = target_task->get_port_by_id(target_port_id);\n@@ -547,8 +552,12 @@ chan_id_send(type_desc *t, rust_task_id target_task_id,\n             scoped_lock with(target_task->lock);\n             port->deref();\n             sent = true;\n+        } else {\n+            LOG(task, comm, \"didn't get the port\");\n         }\n         target_task->deref();\n+    } else {\n+        LOG(task, comm, \"didn't get the task\");\n     }\n     return (uintptr_t)sent;\n }"}, {"sha": "73db81c88a05319c15ce834778537095ec6c48b4", "filename": "src/test/bench/msgsend.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Fbench%2Fmsgsend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Fbench%2Fmsgsend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend.rs?ref=4220dcf1e9de2c2d2c329ecefa80108b63a69145", "patch": "@@ -28,22 +28,28 @@ fn server(requests: comm::port<request>, responses: comm::chan<uint>) {\n }\n \n fn run(args: [str]) {\n-    let server = task::spawn_connected(server);\n+    let from_child = comm::port();\n+    let to_parent = comm::chan(from_child);\n+    let to_child = task::spawn_listener {|po|\n+        server(po, to_parent);\n+    };\n     let size = uint::from_str(args[1]);\n     let workers = uint::from_str(args[2]);\n     let start = std::time::precise_time_s();\n-    let to_child = server.to_child;\n-    let worker_tasks = [];\n+    let to_child = to_child;\n+    let worker_results = [];\n     uint::range(0u, workers) {|_i|\n-        worker_tasks += [task::spawn_joinable {||\n+        let builder = task::mk_task_builder();\n+        worker_results += [task::future_result(builder)];\n+        task::run(builder) {||\n             uint::range(0u, size / workers) {|_i|\n                 comm::send(to_child, bytes(100u));\n             }\n-        }];\n+        };\n     }\n-    vec::iter(worker_tasks) {|t| task::join(t); }\n-    comm::send(server.to_child, stop);\n-    let result = comm::recv(server.from_child);\n+    vec::iter(worker_results) {|r| future::get(r); }\n+    comm::send(to_child, stop);\n+    let result = comm::recv(from_child);\n     let end = std::time::precise_time_s();\n     let elapsed = end - start;\n     std::io::stdout().write_str(#fmt(\"Count is %?\\n\", result));"}, {"sha": "edf9ed717544617a4dadfa42127ec6e823fc50c0", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=4220dcf1e9de2c2d2c329ecefa80108b63a69145", "patch": "@@ -69,11 +69,13 @@ fn stress_task(&&id: int) {\n }\n \n fn stress(num_tasks: int) {\n-    let tasks = [];\n+    let results = [];\n     range(0, num_tasks) {|i|\n-        tasks += [task::spawn_joinable {|| stress_task(i); }];\n+        let builder = task::mk_task_builder();\n+        results += [task::future_result(builder)];\n+        task::run(builder) {|| stress_task(i); }\n     }\n-    for t in tasks { task::join(t); }\n+    for r in results { future::get(r); }\n }\n \n fn main(argv: [str]) {"}, {"sha": "3e0150fc45c5659ac7b8fe472a03ad2c41ac3340", "filename": "src/test/bench/shootout-threadring.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-threadring.rs?ref=4220dcf1e9de2c2d2c329ecefa80108b63a69145", "patch": "@@ -10,7 +10,7 @@ fn start(+token: int) {\n     let ch = iter::foldl(bind int::range(2, n_threads + 1, _),\n                          comm::chan(p)) { |ch, i|\n         let id = n_threads + 2 - i;\n-        let {to_child, _} = task::spawn_connected::<int, int> {|p, _ch|\n+        let to_child = task::spawn_listener::<int> {|p|\n             roundtrip(id, p, ch)\n         };\n         to_child"}, {"sha": "3e38ff5ea22fcf33eda6bb7c13e13261eab1411b", "filename": "src/test/bench/task-perf-spawnalot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs?ref=4220dcf1e9de2c2d2c329ecefa80108b63a69145", "patch": "@@ -7,7 +7,7 @@ import str;\n fn f(&&n: uint) {\n     let i = 0u;\n     while i < n {\n-        task::join(task::spawn_joinable {|| g(); });\n+        task::try {|| g() };\n         i += 1u;\n     }\n }"}, {"sha": "9cf427f03002f4a936adf4324c6d0b5fa8b7d501", "filename": "src/test/bench/task-perf-word-count.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs?ref=4220dcf1e9de2c2d2c329ecefa80108b63a69145", "patch": "@@ -15,7 +15,6 @@ import option::{some, none};\n import std::{map, io, time};\n import io::reader_util;\n \n-import task::joinable_task;\n import comm::chan;\n import comm::port;\n import comm::recv;\n@@ -59,12 +58,14 @@ mod map_reduce {\n     enum reduce_proto { emit_val(int), done, ref, release, }\n \n     fn start_mappers(ctrl: chan<ctrl_proto>, -inputs: [str]) ->\n-       [joinable_task] {\n-        let tasks = [];\n+       [future::future<task::task_result>] {\n+        let results = [];\n         for i: str in inputs {\n-            tasks += [task::spawn_joinable {|| map_task(ctrl, i)}];\n+            let builder = task::mk_task_builder();\n+            results += [task::future_result(builder)];\n+            task::run(builder) {|| map_task(ctrl, i)}\n         }\n-        ret tasks;\n+        ret results;\n     }\n \n     fn map_task(ctrl: chan<ctrl_proto>, input: str) {\n@@ -137,7 +138,7 @@ mod map_reduce {\n         reducers = map::new_str_hash();\n \n         let num_mappers = vec::len(inputs) as int;\n-        let tasks = start_mappers(chan(ctrl), inputs);\n+        let results = start_mappers(chan(ctrl), inputs);\n \n         while num_mappers > 0 {\n             alt recv(ctrl) {\n@@ -158,8 +159,9 @@ mod map_reduce {\n                     // log(error, \"creating new reducer for \" + k);\n                     let p = port();\n                     let ch = chan(p);\n-                    tasks +=\n-                        [task::spawn_joinable{||reduce_task(k, ch)}];\n+                    let builder = task::mk_task_builder();\n+                    results += [task::future_result(builder)];\n+                    task::run(builder) {||reduce_task(k, ch)}\n                     c = recv(p);\n                     reducers.insert(k, c);\n                   }\n@@ -171,7 +173,7 @@ mod map_reduce {\n \n         reducers.values {|v| send(v, done); }\n \n-        for t in tasks { task::join(t); }\n+        for r in results { future::get(r); }\n     }\n }\n "}, {"sha": "e841345cba83653ef277385e54577d6856a4e5d1", "filename": "src/test/run-pass/binops.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Frun-pass%2Fbinops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Frun-pass%2Fbinops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbinops.rs?ref=4220dcf1e9de2c2d2c329ecefa80108b63a69145", "patch": "@@ -96,16 +96,6 @@ fn test_ptr() unsafe {\n     assert p1 >= p2;\n }\n \n-fn test_task() {\n-    fn f() { }\n-    let f1 = f, f2 = f;\n-    let t1 = task::spawn {|| f1(); };\n-    let t2 = task::spawn {|| f2(); };\n-\n-    assert (t1 == t1);\n-    assert (t1 != t2);\n-}\n-\n fn test_fn() {\n     fn f() { }\n     fn g() { }\n@@ -147,7 +137,6 @@ fn main() {\n     test_port();\n     test_chan();\n     test_ptr();\n-    test_task();\n     test_fn();\n     test_native_fn();\n }"}, {"sha": "7490f06d54803889d21841dbf4f23dc53da33c70", "filename": "src/test/run-pass/issue-507.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Frun-pass%2Fissue-507.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Frun-pass%2Fissue-507.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-507.rs?ref=4220dcf1e9de2c2d2c329ecefa80108b63a69145", "patch": "@@ -8,7 +8,6 @@\n use std;\n \n import task;\n-import task::join;\n import comm;\n import comm::chan;\n import comm::send;\n@@ -18,21 +17,18 @@ import comm::recv;\n fn grandchild(c: chan<int>) { send(c, 42); }\n \n fn child(c: chan<int>) {\n-    let _grandchild = task::spawn_joinable {|| grandchild(c); };\n-    join(_grandchild);\n+    task::spawn {|| grandchild(c); }\n }\n \n fn main() {\n     let p = comm::port();\n     let ch = chan(p);\n \n-    let _child = task::spawn_joinable {|| child(ch); };\n+    task::spawn {|| child(ch); }\n \n     let x: int = recv(p);\n \n     log(debug, x);\n \n     assert (x == 42);\n-\n-    join(_child);\n }"}, {"sha": "0dc78cbaec314e0b4d696e55d6064399d598e9ec", "filename": "src/test/run-pass/issue-783.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Frun-pass%2Fissue-783.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Frun-pass%2Fissue-783.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-783.rs?ref=4220dcf1e9de2c2d2c329ecefa80108b63a69145", "patch": "@@ -21,6 +21,7 @@ fn a() {\n }\n \n fn main() {\n-    let t = spawn_joinable {|| a(); };\n-    join(t);\n+    iter::repeat(100u) {||\n+        spawn {|| a(); }\n+    }\n }"}, {"sha": "ef4073406b4babaffb8128c2ee107649cf071f2f", "filename": "src/test/run-pass/join.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fbc95ba0184a417ff6d8b2b417f210c960e142cc/src%2Ftest%2Frun-pass%2Fjoin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbc95ba0184a417ff6d8b2b417f210c960e142cc/src%2Ftest%2Frun-pass%2Fjoin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fjoin.rs?ref=fbc95ba0184a417ff6d8b2b417f210c960e142cc", "patch": "@@ -1,15 +0,0 @@\n-// -*- rust -*-\n-\n-use std;\n-\n-import task::*;\n-\n-fn main() {\n-    let other = spawn_joinable {|| child(); };\n-    #error(\"1\");\n-    yield();\n-    join(other);\n-    #error(\"3\");\n-}\n-\n-fn child() { #error(\"2\"); }"}, {"sha": "b82aa7c2cb0a78c3b9242a3cb72e1c63bf1bb28e", "filename": "src/test/run-pass/linked-failure.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fbc95ba0184a417ff6d8b2b417f210c960e142cc/src%2Ftest%2Frun-pass%2Flinked-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbc95ba0184a417ff6d8b2b417f210c960e142cc/src%2Ftest%2Frun-pass%2Flinked-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flinked-failure.rs?ref=fbc95ba0184a417ff6d8b2b417f210c960e142cc", "patch": "@@ -1,21 +0,0 @@\n-// -*- rust -*-\n-// xfail-win32\n-use std;\n-import task;\n-import comm::port;\n-import comm::recv;\n-\n-fn child() { assert (1 == 2); }\n-\n-fn parent() {\n-    // Since this task isn't supervised it won't bring down the whole\n-    // process\n-    task::unsupervise();\n-    let p = port::<int>();\n-    task::spawn {|| child(); };\n-    let x = recv(p);\n-}\n-\n-fn main() {\n-    task::spawn {|| parent(); };\n-}\n\\ No newline at end of file"}, {"sha": "924c0ea8a7a49018869a98c5c6baa9f38c8c0164", "filename": "src/test/run-pass/lots-a-fail.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Frun-pass%2Flots-a-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Frun-pass%2Flots-a-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flots-a-fail.rs?ref=4220dcf1e9de2c2d2c329ecefa80108b63a69145", "patch": "@@ -9,12 +9,13 @@ fn die() {\n }\n \n fn iloop() {\n-    task::unsupervise();\n     task::spawn {|| die(); };\n }\n \n fn main() {\n     uint::range(0u, 100u) {|_i|\n-        task::spawn {|| iloop(); };\n+        let builder = task::mk_task_builder();\n+        task::unsupervise(builder);\n+        task::run(builder) {|| iloop(); };\n     }\n }\n\\ No newline at end of file"}, {"sha": "db67db86626addafa986d4070062aaceee988fd3", "filename": "src/test/run-pass/morestack5.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Frun-pass%2Fmorestack5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Frun-pass%2Fmorestack5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmorestack5.rs?ref=4220dcf1e9de2c2d2c329ecefa80108b63a69145", "patch": "@@ -12,7 +12,7 @@ fn getbig(&&i: int) {\n fn main() {\n     let sz = 400u;\n     while sz < 500u {\n-        task::join(task::spawn_joinable {|| getbig(200) });\n+        task::try {|| getbig(200) };\n         sz += 1u;\n     }\n }\n\\ No newline at end of file"}, {"sha": "6d8ac3c38f861b63c92eba76070c3cc5c400c716", "filename": "src/test/run-pass/morestack6.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Frun-pass%2Fmorestack6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Frun-pass%2Fmorestack6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmorestack6.rs?ref=4220dcf1e9de2c2d2c329ecefa80108b63a69145", "patch": "@@ -61,6 +61,6 @@ fn main() {\n     for f in fns {\n         let sz = rng.next() % 256u32 + 256u32;\n         let frame_backoff = rng.next() % 10u32 + 1u32;\n-        task::join(task::spawn_joinable {|| runtest(f, frame_backoff);});\n+        task::try {|| runtest(f, frame_backoff) };\n     }\n }\n\\ No newline at end of file"}, {"sha": "ece3dc4ce6444c317ce91af4f3d5ae469b0270f3", "filename": "src/test/run-pass/send-iloop.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Frun-pass%2Fsend-iloop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Frun-pass%2Fsend-iloop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend-iloop.rs?ref=4220dcf1e9de2c2d2c329ecefa80108b63a69145", "patch": "@@ -9,7 +9,6 @@ fn die() {\n }\n \n fn iloop() {\n-    task::unsupervise();\n     task::spawn {|| die(); };\n     let p = comm::port::<()>();\n     let c = comm::chan(p);\n@@ -23,6 +22,8 @@ fn iloop() {\n \n fn main() {\n     uint::range(0u, 16u) {|_i|\n-        task::spawn {|| iloop(); };\n+        let builder = task::mk_task_builder();\n+        task::unsupervise(builder);\n+        task::run(builder) {|| iloop(); }\n     }\n }\n\\ No newline at end of file"}, {"sha": "cbc3b8b2ea64b5c700a34f121c43fdbf8beff6ac", "filename": "src/test/run-pass/spawn-module-qualified.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fbc95ba0184a417ff6d8b2b417f210c960e142cc/src%2Ftest%2Frun-pass%2Fspawn-module-qualified.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbc95ba0184a417ff6d8b2b417f210c960e142cc/src%2Ftest%2Frun-pass%2Fspawn-module-qualified.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawn-module-qualified.rs?ref=fbc95ba0184a417ff6d8b2b417f210c960e142cc", "patch": "@@ -1,9 +0,0 @@\n-use std;\n-import task::join;\n-import task::spawn_joinable;\n-\n-fn main() { let x = spawn_joinable {|| m::child(10); }; join(x); }\n-\n-mod m {\n-    fn child(&&i: int) { log(debug, i); }\n-}"}, {"sha": "600cbdb06b8b0e912db70c74c15cb15374b095eb", "filename": "src/test/run-pass/spawn.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Frun-pass%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Frun-pass%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawn.rs?ref=4220dcf1e9de2c2d2c329ecefa80108b63a69145", "patch": "@@ -5,8 +5,7 @@ use std;\n import task;\n \n fn main() {\n-    let t = task::spawn_joinable {|| child(10); };\n-    task::join(t);\n+    task::spawn {|| child(10); };\n }\n \n fn child(&&i: int) { log(error, i); assert (i == 10); }"}, {"sha": "713d487f3d866933e32d46e35d14a44a19a56244", "filename": "src/test/run-pass/task-comm-1.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Frun-pass%2Ftask-comm-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Frun-pass%2Ftask-comm-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-1.rs?ref=4220dcf1e9de2c2d2c329ecefa80108b63a69145", "patch": "@@ -1,14 +1,8 @@\n-use std;\n-\n-import task::spawn_joinable;\n-import task::join;\n-\n fn main() { test00(); }\n \n fn start() { #debug(\"Started / Finished task.\"); }\n \n fn test00() {\n-    let t = spawn_joinable {|| start(); };\n-    join(t);\n+    task::try {|| start() };\n     #debug(\"Completing.\");\n }"}, {"sha": "4e690a034ce4c4433678234113e186e0d9f368e7", "filename": "src/test/run-pass/task-comm-12.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs?ref=4220dcf1e9de2c2d2c329ecefa80108b63a69145", "patch": "@@ -7,7 +7,9 @@ fn start(&&task_number: int) { #debug(\"Started / Finished task.\"); }\n \n fn test00() {\n     let i: int = 0;\n-    let t = task::spawn_joinable {|| start(i); };\n+    let builder = task::mk_task_builder();\n+    let r = task::future_result(builder);\n+    task::run(builder) {|| start(i); };\n \n     // Sleep long enough for the task to finish.\n     let i = 0;\n@@ -17,7 +19,7 @@ fn test00() {\n     }\n \n     // Try joining tasks that have already finished.\n-    task::join(t);\n+    future::get(r);\n \n     #debug(\"Joined task.\");\n }"}, {"sha": "5998dd15cf2010974647d44ffa8707efc8f78cff", "filename": "src/test/run-pass/task-comm-13.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs?ref=4220dcf1e9de2c2d2c329ecefa80108b63a69145", "patch": "@@ -12,7 +12,6 @@ fn main() {\n     #debug(\"Check that we don't deadlock.\");\n     let p = comm::port::<int>();\n     let ch = comm::chan(p);\n-    let a = task::spawn_joinable {|| start(ch, 0, 10); };\n-    task::join(a);\n+    task::try {|| start(ch, 0, 10) };\n     #debug(\"Joined task\");\n }"}, {"sha": "c17b1c8a11e61691bacfaaa7ecb202d2ac807caa", "filename": "src/test/run-pass/task-comm-2.rs", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/fbc95ba0184a417ff6d8b2b417f210c960e142cc/src%2Ftest%2Frun-pass%2Ftask-comm-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbc95ba0184a417ff6d8b2b417f210c960e142cc/src%2Ftest%2Frun-pass%2Ftask-comm-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-2.rs?ref=fbc95ba0184a417ff6d8b2b417f210c960e142cc", "patch": "@@ -1,31 +0,0 @@\n-// xfail-win32\n-use std;\n-\n-import task;\n-\n-fn main() {\n-    #debug(\"===== SPAWNING and JOINING THREAD TASKS =====\");\n-    test00();\n-}\n-\n-fn start(&&task_number: int) {\n-    #debug(\"Started task.\");\n-    let i: int = 0;\n-    while i < 10000 { i = i + 1; }\n-    #debug(\"Finished task.\");\n-}\n-\n-fn test00() {\n-    let number_of_tasks: int = 8;\n-\n-    let i: int = 0;\n-    let tasks = [];\n-    while i < number_of_tasks {\n-        i = i + 1;\n-        tasks += [task::spawn_joinable {|| start(i); }];\n-    }\n-\n-    for t in tasks { task::join(t); }\n-\n-    #debug(\"Joined all task.\");\n-}"}, {"sha": "bb1044d39e3755ec96c4408706cd79c82e7704bd", "filename": "src/test/run-pass/task-comm-3.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs?ref=4220dcf1e9de2c2d2c329ecefa80108b63a69145", "patch": "@@ -30,17 +30,19 @@ fn test00() {\n     let i: int = 0;\n \n     // Create and spawn tasks...\n-    let tasks = [];\n+    let results = [];\n     while i < number_of_tasks {\n-        tasks += [task::spawn_joinable {||\n+        let builder = task::mk_task_builder();\n+        results += [task::future_result(builder)];\n+        task::run(builder) {||\n             test00_start(ch, i, number_of_messages)\n-        }];\n+        }\n         i = i + 1;\n     }\n \n     // Read from spawned tasks...\n     let sum = 0;\n-    for t in tasks {\n+    for r in results {\n         i = 0;\n         while i < number_of_messages {\n             let value = recv(po);\n@@ -50,7 +52,7 @@ fn test00() {\n     }\n \n     // Join spawned tasks...\n-    for t in tasks { task::join(t); }\n+    for r in results { future::get(r); }\n \n     #debug(\"Completed: Final number is: \");\n     log(error, sum);"}, {"sha": "64649b85459714859444650bcab17a7c09486a7b", "filename": "src/test/run-pass/task-comm-7.rs", "status": "modified", "additions": 14, "deletions": 22, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs?ref=4220dcf1e9de2c2d2c329ecefa80108b63a69145", "patch": "@@ -1,9 +1,6 @@\n use std;\n import task;\n import comm;\n-import comm::chan;\n-import comm::recv;\n-import comm::port;\n \n fn main() { test00(); }\n \n@@ -15,40 +12,35 @@ fn test00_start(c: comm::chan<int>, start: int, number_of_messages: int) {\n fn test00() {\n     let r: int = 0;\n     let sum: int = 0;\n-    let p = port();\n+    let p = comm::port();\n     let number_of_messages: int = 10;\n-    let c = chan(p);\n+    let c = comm::chan(p);\n \n-    let t0 = task::spawn_joinable {||\n+    task::spawn {||\n         test00_start(c, number_of_messages * 0, number_of_messages);\n-    };\n-    let t1 = task::spawn_joinable {||\n+    }\n+    task::spawn {||\n         test00_start(c, number_of_messages * 1, number_of_messages);\n-    };\n-    let t2 = task::spawn_joinable {||\n+    }\n+    task::spawn {||\n         test00_start(c, number_of_messages * 2, number_of_messages);\n-    };\n-    let t3 = task::spawn_joinable {||\n+    }\n+    task::spawn {||\n         test00_start(c, number_of_messages * 3, number_of_messages);\n-    };\n+    }\n \n     let i: int = 0;\n     while i < number_of_messages {\n-        r = recv(p);\n+        r = comm::recv(p);\n         sum += r;\n-        r = recv(p);\n+        r = comm::recv(p);\n         sum += r;\n-        r = recv(p);\n+        r = comm::recv(p);\n         sum += r;\n-        r = recv(p);\n+        r = comm::recv(p);\n         sum += r;\n         i += 1;\n     }\n \n-    task::join(t0);\n-    task::join(t1);\n-    task::join(t2);\n-    task::join(t3);\n-\n     assert (sum == number_of_messages * 4 * (number_of_messages * 4 - 1) / 2);\n }"}, {"sha": "8259fde9fad13d984d0130c794cc1154bb2faa88", "filename": "src/test/run-pass/task-comm-8.rs", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/fbc95ba0184a417ff6d8b2b417f210c960e142cc/src%2Ftest%2Frun-pass%2Ftask-comm-8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbc95ba0184a417ff6d8b2b417f210c960e142cc/src%2Ftest%2Frun-pass%2Ftask-comm-8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-8.rs?ref=fbc95ba0184a417ff6d8b2b417f210c960e142cc", "patch": "@@ -1,51 +0,0 @@\n-use std;\n-import task;\n-import comm;\n-\n-fn main() { test00(); }\n-\n-fn test00_start(c: comm::chan<int>, start: int, number_of_messages: int) {\n-    let i: int = 0;\n-    while i < number_of_messages { comm::send(c, start + i); i += 1; }\n-}\n-\n-fn test00() {\n-    let r: int = 0;\n-    let sum: int = 0;\n-    let p = comm::port();\n-    let c = comm::chan(p);\n-    let number_of_messages: int = 10;\n-\n-    let t0 = task::spawn_joinable {||\n-        test00_start(c, number_of_messages * 0, number_of_messages);\n-    };\n-    let t1 = task::spawn_joinable {||\n-        test00_start(c, number_of_messages * 1, number_of_messages);\n-    };\n-    let t2 = task::spawn_joinable {||\n-        test00_start(c, number_of_messages * 2, number_of_messages);\n-    };\n-    let t3 = task::spawn_joinable {||\n-        test00_start(c, number_of_messages * 3, number_of_messages);\n-    };\n-\n-    let i: int = 0;\n-    while i < number_of_messages {\n-        r = comm::recv(p);\n-        sum += r;\n-        r = comm::recv(p);\n-        sum += r;\n-        r = comm::recv(p);\n-        sum += r;\n-        r = comm::recv(p);\n-        sum += r;\n-        i += 1;\n-    }\n-\n-    task::join(t0);\n-    task::join(t1);\n-    task::join(t2);\n-    task::join(t3);\n-\n-    assert (sum == number_of_messages * 4 * (number_of_messages * 4 - 1) / 2);\n-}"}, {"sha": "85d1e03c09c5ca6e320ae96dffda7ca2a204d29b", "filename": "src/test/run-pass/task-comm-9.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs?ref=4220dcf1e9de2c2d2c329ecefa80108b63a69145", "patch": "@@ -16,9 +16,11 @@ fn test00() {\n     let number_of_messages: int = 10;\n     let ch = comm::chan(p);\n \n-    let t0 = task::spawn_joinable {||\n+    let builder = task::mk_task_builder();\n+    let r = task::future_result(builder);\n+    task::run(builder) {||\n         test00_start(ch, number_of_messages);\n-    };\n+    }\n \n     let i: int = 0;\n     while i < number_of_messages {\n@@ -27,7 +29,7 @@ fn test00() {\n         i += 1;\n     }\n \n-    task::join(t0);\n+    future::get(r);\n \n     assert (sum == number_of_messages * (number_of_messages - 1) / 2);\n }"}, {"sha": "d710b50e2b0ea070a0fcb42fe0593390c1372a82", "filename": "src/test/run-pass/task-comm.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Frun-pass%2Ftask-comm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Frun-pass%2Ftask-comm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm.rs?ref=4220dcf1e9de2c2d2c329ecefa80108b63a69145", "patch": "@@ -38,20 +38,20 @@ fn test00() {\n \n     let i: int = 0;\n \n-    let tasks = [];\n+    let results = [];\n     while i < number_of_tasks {\n         i = i + 1;\n-        tasks += [\n-            task::spawn_joinable {|| test00_start(ch, i, number_of_messages);}\n-        ];\n+        let builder = task::mk_task_builder();\n+        results += [task::future_result(builder)];\n+        task::run(builder) {|| test00_start(ch, i, number_of_messages);}\n     }\n     let sum: int = 0;\n-    for t in tasks {\n+    for r in results {\n         i = 0;\n         while i < number_of_messages { sum += recv(po); i = i + 1; }\n     }\n \n-    for t in tasks { task::join(t); }\n+    for r in results { future::get(r); }\n \n     #debug(\"Completed: Final number is: \");\n     assert (sum ==\n@@ -123,14 +123,16 @@ fn test06() {\n \n     let i: int = 0;\n \n-    let tasks = [];\n+    let results = [];\n     while i < number_of_tasks {\n         i = i + 1;\n-        tasks += [task::spawn_joinable {|| test06_start(i);}];\n+        let builder = task::mk_task_builder();\n+        results += [task::future_result(builder)];\n+        task::run(builder) {|| test06_start(i);};\n     }\n \n \n-    for t in tasks { task::join(t); }\n+    for r in results { future::get(r); }\n }\n \n "}, {"sha": "872639bc8e70593d22ab6beed7b85264ad9e9af2", "filename": "src/test/run-pass/task-killjoin.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Frun-pass%2Ftask-killjoin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Frun-pass%2Ftask-killjoin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-killjoin.rs?ref=4220dcf1e9de2c2d2c329ecefa80108b63a69145", "patch": "@@ -1,34 +1,32 @@\n // xfail-win32\n-// Create a task that is supervised by another task,\n-// join the supervised task from the supervising task,\n-// then fail the supervised task. The supervised task\n-// will kill the supervising task, waking it up. The\n-// supervising task no longer needs to be wakened when\n-// the supervised task exits.\n+\n+// Create a task that is supervised by another task, join the supervised task\n+// from the supervising task, then fail the supervised task. The supervised\n+// task will kill the supervising task, waking it up. The supervising task no\n+// longer needs to be wakened when the supervised task exits.\n \n use std;\n import task;\n \n fn supervised() {\n-    // Yield to make sure the supervisor joins before we\n-    // fail. This is currently not needed because the supervisor\n-    // runs first, but I can imagine that changing.\n+    // Yield to make sure the supervisor joins before we fail. This is\n+    // currently not needed because the supervisor runs first, but I can\n+    // imagine that changing.\n     task::yield();\n     fail;\n }\n \n fn supervisor() {\n     // Unsupervise this task so the process doesn't return a failure status as\n     // a result of the main task being killed.\n-    task::unsupervise();\n     let f = supervised;\n-    let t = task::spawn_joinable {|| supervised(); };\n-    task::join(t);\n+    task::try {|| supervised() };\n }\n \n fn main() {\n-    let dom2 = task::spawn_joinable {|| supervisor(); };\n-    task::join(dom2);\n+    let builder = task::mk_task_builder();\n+    task::unsupervise(builder);\n+    task::run(builder) {|| supervisor(); }\n }\n \n // Local Variables:"}, {"sha": "053dab56a0558b14bc8471655370693d43f5549d", "filename": "src/test/run-pass/task-spawn-connected.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fbc95ba0184a417ff6d8b2b417f210c960e142cc/src%2Ftest%2Frun-pass%2Ftask-spawn-connected.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbc95ba0184a417ff6d8b2b417f210c960e142cc/src%2Ftest%2Frun-pass%2Ftask-spawn-connected.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-spawn-connected.rs?ref=fbc95ba0184a417ff6d8b2b417f210c960e142cc", "patch": "@@ -1,18 +0,0 @@\n-fn stringifier(from_par: comm::port<uint>,\n-               to_par: comm::chan<str>) {\n-    let value: uint;\n-    do {\n-        value = comm::recv(from_par);\n-        comm::send(to_par, uint::to_str(value, 10u));\n-    } while value != 0u;\n-}\n-\n-fn main() {\n-    let t = task::spawn_connected(stringifier);\n-    comm::send(t.to_child, 22u);\n-    assert comm::recv(t.from_child) == \"22\";\n-    comm::send(t.to_child, 23u);\n-    assert comm::recv(t.from_child) == \"23\";\n-    comm::send(t.to_child, 0u);\n-    assert comm::recv(t.from_child) == \"0\";\n-}\n\\ No newline at end of file"}, {"sha": "9b722a947c075f0eb43ca412e86de86b586fe332", "filename": "src/test/run-pass/terminate-in-initializer.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Frun-pass%2Fterminate-in-initializer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Frun-pass%2Fterminate-in-initializer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fterminate-in-initializer.rs?ref=4220dcf1e9de2c2d2c329ecefa80108b63a69145", "patch": "@@ -11,14 +11,14 @@ fn test_cont() { let i = 0; while i < 1 { i += 1; let x: @int = cont; } }\n fn test_ret() { let x: @int = ret; }\n \n fn test_fail() {\n-    fn f() { task::unsupervise(); let x: @int = fail; }\n-    task::spawn {|| f(); };\n+    fn f() { let x: @int = fail; }\n+    task::try {|| f() };\n }\n \n fn test_fail_indirect() {\n     fn f() -> ! { fail; }\n-    fn g() { task::unsupervise(); let x: @int = f(); }\n-    task::spawn {|| g(); };\n+    fn g() { let x: @int = f(); }\n+    task::try {|| g() };\n }\n \n fn main() {"}, {"sha": "04119e296cf83ad655414a55bdd83988d8e2a0fe", "filename": "src/test/run-pass/too-much-recursion.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Frun-pass%2Ftoo-much-recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Frun-pass%2Ftoo-much-recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftoo-much-recursion.rs?ref=4220dcf1e9de2c2d2c329ecefa80108b63a69145", "patch": "@@ -5,8 +5,9 @@\n // that it doesn't bring down the whole proc\n \n fn main() {\n-    task::spawn {||\n-        task::unsupervise();\n+    let builder = task::mk_task_builder();\n+    task::unsupervise(builder);\n+    task::run(builder) {||\n         fn f() { f() };\n         f();\n     };"}, {"sha": "5281ddb05c7dde91916ff161c3162b84ce35096d", "filename": "src/test/run-pass/unwind-box.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Frun-pass%2Funwind-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Frun-pass%2Funwind-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funwind-box.rs?ref=4220dcf1e9de2c2d2c329ecefa80108b63a69145", "patch": "@@ -3,11 +3,12 @@ use std;\n import task;\n \n fn f() {\n-    task::unsupervise();\n     let a = @0;\n     fail;\n }\n \n fn main() {\n-    task::spawn {|| f(); };\n+    let builder = task::mk_task_builder();\n+    task::unsupervise(builder);\n+    task::run(builder) {|| f(); }\n }\n\\ No newline at end of file"}, {"sha": "0c64af20b40a66b8ba7dc41d248860b9f711661c", "filename": "src/test/run-pass/unwind-resource.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Frun-pass%2Funwind-resource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Frun-pass%2Funwind-resource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funwind-resource.rs?ref=4220dcf1e9de2c2d2c329ecefa80108b63a69145", "patch": "@@ -8,14 +8,15 @@ resource complainer(c: comm::chan<bool>) {\n }\n \n fn f(c: comm::chan<bool>) {\n-    task::unsupervise();\n     let c <- complainer(c);\n     fail;\n }\n \n fn main() {\n     let p = comm::port();\n     let c = comm::chan(p);\n-    task::spawn {|| f(c); };\n+    let builder = task::mk_task_builder();\n+    task::unsupervise(builder);\n+    task::run(builder) {|| f(c); }\n     assert comm::recv(p);\n }\n\\ No newline at end of file"}, {"sha": "b4d2294fbfe0c7374128fdb792d8143a896ff9e4", "filename": "src/test/run-pass/unwind-resource2.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Frun-pass%2Funwind-resource2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Frun-pass%2Funwind-resource2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funwind-resource2.rs?ref=4220dcf1e9de2c2d2c329ecefa80108b63a69145", "patch": "@@ -7,11 +7,12 @@ resource complainer(c: @int) {\n }\n \n fn f() {\n-    task::unsupervise();\n     let c <- complainer(@0);\n     fail;\n }\n \n fn main() {\n-    task::spawn {|| f(); };\n+    let builder = task::mk_task_builder();\n+    task::unsupervise(builder);\n+    task::run(builder) {|| f(); }\n }\n\\ No newline at end of file"}, {"sha": "222343e1dc4cee6d61905ef2063f2b239d70b55e", "filename": "src/test/run-pass/unwind-unique.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Frun-pass%2Funwind-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Frun-pass%2Funwind-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funwind-unique.rs?ref=4220dcf1e9de2c2d2c329ecefa80108b63a69145", "patch": "@@ -3,11 +3,12 @@ use std;\n import task;\n \n fn f() {\n-    task::unsupervise();\n     let a = ~0;\n     fail;\n }\n \n fn main() {\n-    task::spawn {|| f(); };\n+    let builder = task::mk_task_builder();\n+    task::unsupervise(builder);\n+    task::run(builder) {|| f(); }\n }\n\\ No newline at end of file"}, {"sha": "3194676aae7625f84c8bd422d30409b868dac496", "filename": "src/test/run-pass/yield.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Frun-pass%2Fyield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Frun-pass%2Fyield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fyield.rs?ref=4220dcf1e9de2c2d2c329ecefa80108b63a69145", "patch": "@@ -4,13 +4,15 @@ import task;\n import task::*;\n \n fn main() {\n-    let other = task::spawn_joinable {|| child(); };\n+    let builder = task::mk_task_builder();\n+    let result = task::future_result(builder);\n+    task::run(builder) {|| child(); }\n     #error(\"1\");\n     yield();\n     #error(\"2\");\n     yield();\n     #error(\"3\");\n-    join(other);\n+    future::get(result);\n }\n \n fn child() {"}, {"sha": "c309e5b1b0c0464ac2f9ac06fa66a01c41af2784", "filename": "src/test/run-pass/yield1.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Frun-pass%2Fyield1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4220dcf1e9de2c2d2c329ecefa80108b63a69145/src%2Ftest%2Frun-pass%2Fyield1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fyield1.rs?ref=4220dcf1e9de2c2d2c329ecefa80108b63a69145", "patch": "@@ -4,10 +4,12 @@ import task;\n import task::*;\n \n fn main() {\n-    let other = task::spawn_joinable {|| child(); };\n+    let builder = task::mk_task_builder();\n+    let result = task::future_result(builder);\n+    task::run(builder) {|| child(); }\n     #error(\"1\");\n     yield();\n-    join(other);\n+    future::get(result);\n }\n \n fn child() { #error(\"2\"); }"}]}