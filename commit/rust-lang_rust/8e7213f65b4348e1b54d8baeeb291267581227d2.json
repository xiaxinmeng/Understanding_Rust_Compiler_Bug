{"sha": "8e7213f65b4348e1b54d8baeeb291267581227d2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlNzIxM2Y2NWI0MzQ4ZTFiNTRkOGJhZWViMjkxMjY3NTgxMjI3ZDI=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-06-11T05:18:57Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-06-17T22:30:33Z"}, "message": "Remove TraitStore from ty_trait\n\nUse ty_rptr/ty_uniq(ty_trait) rather than TraitStore to represent trait types.\nAlso addresses (but doesn't close) #12470.\nPart of the work towards DST (#12938).\n\n[breaking-change] lifetime parameters in `&mut trait` are now invariant. They used to be contravariant.", "tree": {"sha": "167d35131ffc76366c5a70909adbe82d1de7186a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/167d35131ffc76366c5a70909adbe82d1de7186a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e7213f65b4348e1b54d8baeeb291267581227d2", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e7213f65b4348e1b54d8baeeb291267581227d2", "html_url": "https://github.com/rust-lang/rust/commit/8e7213f65b4348e1b54d8baeeb291267581227d2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e7213f65b4348e1b54d8baeeb291267581227d2/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db298145c702c49e5f3cc17adeafe58c8b1bbd6a", "url": "https://api.github.com/repos/rust-lang/rust/commits/db298145c702c49e5f3cc17adeafe58c8b1bbd6a", "html_url": "https://github.com/rust-lang/rust/commit/db298145c702c49e5f3cc17adeafe58c8b1bbd6a"}], "stats": {"total": 815, "additions": 451, "deletions": 364}, "files": [{"sha": "4897117431bbdbc96ae13d9151e81013ac3c2632", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=8e7213f65b4348e1b54d8baeeb291267581227d2", "patch": "@@ -346,10 +346,9 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n         assert_eq!(next(st), '[');\n         let def = parse_def(st, NominalType, |x,y| conv(x,y));\n         let substs = parse_substs(st, |x,y| conv(x,y));\n-        let store = parse_trait_store(st, |x,y| conv(x,y));\n         let bounds = parse_bounds(st, |x,y| conv(x,y));\n         assert_eq!(next(st), ']');\n-        return ty::mk_trait(st.tcx, def, substs, store, bounds.builtin_bounds);\n+        return ty::mk_trait(st.tcx, def, substs, bounds.builtin_bounds);\n       }\n       'p' => {\n         let did = parse_def(st, TypeParameter, |x,y| conv(x,y));"}, {"sha": "e1fa4abefdd06512ac5af26b14320320998dc238", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=8e7213f65b4348e1b54d8baeeb291267581227d2", "patch": "@@ -232,12 +232,10 @@ fn enc_sty(w: &mut MemWriter, cx: &ctxt, st: &ty::sty) {\n         ty::ty_trait(box ty::TyTrait {\n                 def_id,\n                 ref substs,\n-                store,\n                 bounds\n             }) => {\n             mywrite!(w, \"x[{}|\", (cx.ds)(def_id));\n             enc_substs(w, cx, substs);\n-            enc_trait_store(w, cx, store);\n             let bounds = ty::ParamBounds {builtin_bounds: bounds,\n                                           trait_bounds: Vec::new()};\n             enc_bounds(w, cx, &bounds);"}, {"sha": "970ae36238bd6f915477818da8121bfe46e4a31d", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=8e7213f65b4348e1b54d8baeeb291267581227d2", "patch": "@@ -361,9 +361,12 @@ fn check_bounds_on_type_parameters(cx: &mut Context, e: &Expr) {\n fn check_trait_cast(cx: &mut Context, source_ty: ty::t, target_ty: ty::t, span: Span) {\n     check_cast_for_escaping_regions(cx, source_ty, target_ty, span);\n     match ty::get(target_ty).sty {\n-        ty::ty_trait(box ty::TyTrait { bounds, .. }) => {\n-            check_trait_cast_bounds(cx, span, source_ty, bounds);\n-        }\n+        ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ ty, .. }) => match ty::get(ty).sty {\n+            ty::ty_trait(box ty::TyTrait { bounds, .. }) => {\n+                check_trait_cast_bounds(cx, span, source_ty, bounds);\n+            }\n+            _ => {}\n+        },\n         _ => {}\n     }\n }\n@@ -530,9 +533,8 @@ pub fn check_cast_for_escaping_regions(\n {\n     // Determine what type we are casting to; if it is not a trait, then no\n     // worries.\n-    match ty::get(target_ty).sty {\n-        ty::ty_trait(..) => {}\n-        _ => { return; }\n+    if !ty::type_is_trait(target_ty) {\n+        return;\n     }\n \n     // Collect up the regions that appear in the target type.  We want to"}, {"sha": "ba05dc1b48a5e029317753eda0f0f9108cdce666", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=8e7213f65b4348e1b54d8baeeb291267581227d2", "patch": "@@ -980,9 +980,6 @@ fn check_heap_type(cx: &Context, span: Span, ty: ty::t) {\n                     n_box += 1;\n                 }\n                 ty::ty_uniq(_) |\n-                ty::ty_trait(box ty::TyTrait {\n-                    store: ty::UniqTraitStore, ..\n-                }) |\n                 ty::ty_closure(box ty::ClosureTy {\n                     store: ty::UniqTraitStore,\n                     .."}, {"sha": "8224557f860072a7685b9bcfb06c1991efdb1b0a", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=8e7213f65b4348e1b54d8baeeb291267581227d2", "patch": "@@ -174,7 +174,6 @@ pub enum deref_kind {\n pub fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n     match ty::get(t).sty {\n         ty::ty_uniq(_) |\n-        ty::ty_trait(box ty::TyTrait { store: ty::UniqTraitStore, .. }) |\n         ty::ty_closure(box ty::ClosureTy {store: ty::UniqTraitStore, ..}) => {\n             Some(deref_ptr(OwnedPtr))\n         }\n@@ -183,13 +182,6 @@ pub fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n             let kind = ty::BorrowKind::from_mutbl(mt.mutbl);\n             Some(deref_ptr(BorrowedPtr(kind, r)))\n         }\n-        ty::ty_trait(box ty::TyTrait {\n-                store: ty::RegionTraitStore(r, mutbl),\n-                ..\n-            }) => {\n-            let kind = ty::BorrowKind::from_mutbl(mutbl);\n-            Some(deref_ptr(BorrowedPtr(kind, r)))\n-        }\n \n         ty::ty_closure(box ty::ClosureTy {\n                 store: ty::RegionTraitStore(r, _),"}, {"sha": "9f4b11116dbb74717cbc27e984c576fada5e63c3", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=8e7213f65b4348e1b54d8baeeb291267581227d2", "patch": "@@ -292,12 +292,11 @@ impl Case {\n     fn find_ptr(&self) -> Option<uint> {\n         self.tys.iter().position(|&ty| {\n             match ty::get(ty).sty {\n-                ty::ty_rptr(_, mt) => match ty::get(mt.ty).sty {\n-                    ty::ty_vec(_, None) | ty::ty_str => false,\n+                ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) => match ty::get(ty).sty {\n+                    ty::ty_vec(_, None) | ty::ty_str| ty::ty_trait(..) => false,\n                     _ => true,\n                 },\n-                ty::ty_uniq(..) | ty::ty_box(..) |\n-                ty::ty_bare_fn(..) => true,\n+                ty::ty_box(..) | ty::ty_bare_fn(..) => true,\n                 // Is that everything?  Would closures or slices qualify?\n                 _ => false\n             }"}, {"sha": "7e4fec14f48e183e8da1f32a4b3e8ae0c2518f4b", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=8e7213f65b4348e1b54d8baeeb291267581227d2", "patch": "@@ -1794,6 +1794,9 @@ pub fn get_fn_llvm_attributes(ccx: &CrateContext, fn_ty: ty::t) -> Vec<(uint, u6\n         match ty::get(ret_ty).sty {\n             // `~` pointer return values never alias because ownership\n             // is transferred\n+            ty::ty_uniq(it)  if match ty::get(it).sty {\n+                ty::ty_str | ty::ty_vec(..) | ty::ty_trait(..) => true, _ => false\n+            } => {}\n             ty::ty_uniq(_) => {\n                 attrs.push((lib::llvm::ReturnIndex as uint, lib::llvm::NoAliasAttribute as u64));\n             }\n@@ -1803,9 +1806,9 @@ pub fn get_fn_llvm_attributes(ccx: &CrateContext, fn_ty: ty::t) -> Vec<(uint, u6\n         // We can also mark the return value as `nonnull` in certain cases\n         match ty::get(ret_ty).sty {\n             // These are not really pointers but pairs, (pointer, len)\n-            ty::ty_rptr(_, ty::mt { ty: it, .. }) |\n+            ty::ty_uniq(it) |\n             ty::ty_rptr(_, ty::mt { ty: it, .. }) if match ty::get(it).sty {\n-                ty::ty_str | ty::ty_vec(..) => true, _ => false\n+                ty::ty_str | ty::ty_vec(..) | ty::ty_trait(..) => true, _ => false\n             } => {}\n             ty::ty_uniq(_) | ty::ty_rptr(_, _) => {\n                 attrs.push((lib::llvm::ReturnIndex as uint, lib::llvm::NonNullAttribute as u64));"}, {"sha": "d7509866e08862687c60b03c0857edd44ba0aba6", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=8e7213f65b4348e1b54d8baeeb291267581227d2", "patch": "@@ -67,7 +67,7 @@ pub fn type_is_immediate(ccx: &CrateContext, ty: ty::t) -> bool {\n         ty::type_is_unique(ty) || ty::type_is_region_ptr(ty) ||\n         type_is_newtype_immediate(ccx, ty) || ty::type_is_bot(ty) ||\n         ty::type_is_simd(tcx, ty);\n-    if simple {\n+    if simple && !ty::type_is_trait(ty) {\n         return true;\n     }\n     match ty::get(ty).sty {"}, {"sha": "f0efd13377b78bd252b02a14ab74c99739f18374", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=8e7213f65b4348e1b54d8baeeb291267581227d2", "patch": "@@ -143,7 +143,9 @@ fn const_deref(cx: &CrateContext, v: ValueRef, t: ty::t, explicit: bool)\n             let dv = match ty::get(t).sty {\n                 ty::ty_ptr(mt) | ty::ty_rptr(_, mt) => {\n                     match ty::get(mt.ty).sty {\n-                        ty::ty_vec(_, None) | ty::ty_str => cx.sess().bug(\"unexpected slice\"),\n+                        ty::ty_vec(_, None) | ty::ty_str | ty::ty_trait(..) => {\n+                            cx.sess().bug(\"unexpected unsized type\")\n+                        }\n                         _ => const_deref_ptr(cx, v),\n                     }\n                 }"}, {"sha": "158a7d6cf7ab91a61a8026a27719e865cad3469d", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=8e7213f65b4348e1b54d8baeeb291267581227d2", "patch": "@@ -157,9 +157,7 @@ pub fn appropriate_rvalue_mode(ccx: &CrateContext, ty: ty::t) -> RvalueMode {\n      * on whether type is immediate or not.\n      */\n \n-    if type_is_zero_size(ccx, ty) {\n-        ByValue\n-    } else if type_is_immediate(ccx, ty) {\n+    if type_is_immediate(ccx, ty) {\n         ByValue\n     } else {\n         ByRef"}, {"sha": "d05e9954cf45793ac429668cd54ae46314925638", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=8e7213f65b4348e1b54d8baeeb291267581227d2", "patch": "@@ -285,8 +285,8 @@ impl TypeMap {\n         // unique ptr (~)       -> {~ :pointee-uid:}\n         // @-ptr (@)            -> {@ :pointee-uid:}\n         // sized vec ([T, ..x]) -> {[:size:] :element-uid:}\n-        // vec slice (&[T])     -> {&<mut> [] :element-uid:}\n-        // trait (~ | &[mut] T) -> {:sigil: trait_:svh: / :node-id:_<(:param-uid:),*> }\n+        // unsized vec ([T])    -> {[] :element-uid:}\n+        // trait (T)            -> {trait_:svh: / :node-id:_<(:param-uid:),*> }\n         // closure              -> {<unsafe_> <once_> :store-sigil: |(:param-uid:),* <,_...>| -> \\\n         //                             :return-type-uid: : (:bounds:)*}\n         // function             -> {<unsafe_> <abi_> fn( (:param-uid:)* <,_...> ) -> \\\n@@ -361,18 +361,12 @@ impl TypeMap {\n                 let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n                 unique_type_id.push_str(inner_type_id.as_slice());\n             },\n-            ty::ty_vec(ty::mt { ty: inner_type, mutbl }, optional_length) => {\n+            ty::ty_vec(ty::mt { ty: inner_type, .. }, optional_length) => {\n                 match optional_length {\n                     Some(len) => {\n                         unique_type_id.push_str(format!(\"[{}]\", len).as_slice());\n                     }\n                     None => {\n-                        unique_type_id.push_char('&');\n-\n-                        if mutbl == ast::MutMutable {\n-                           unique_type_id.push_str(\"mut\");\n-                        }\n-\n                         unique_type_id.push_str(\"[]\");\n                     }\n                 };\n@@ -382,12 +376,6 @@ impl TypeMap {\n                 unique_type_id.push_str(inner_type_id.as_slice());\n             },\n             ty::ty_trait(ref trait_data) => {\n-                match trait_data.store {\n-                    ty::UniqTraitStore => unique_type_id.push_char('~'),\n-                    ty::RegionTraitStore(_, ast::MutMutable) => unique_type_id.push_str(\"&mut\"),\n-                    ty::RegionTraitStore(_, ast::MutImmutable) => unique_type_id.push_char('&'),\n-                };\n-\n                 unique_type_id.push_str(\"trait \");\n \n                 from_def_id_and_substs(self,\n@@ -2901,6 +2889,16 @@ fn type_metadata(cx: &CrateContext,\n                     let i8_t = ty::mk_i8();\n                     heap_vec_metadata(cx, pointee_type, i8_t, unique_type_id, usage_site_span)\n                 }\n+                ty::ty_trait(box ty::TyTrait {\n+                        def_id,\n+                        ref substs,\n+                        ref bounds\n+                    }) => {\n+                    MetadataCreationResult::new(\n+                        trait_metadata(cx, def_id, t, substs, ty::UniqTraitStore,\n+                                       bounds, unique_type_id),\n+                    false)\n+                }\n                 _ => {\n                     let pointee_metadata = type_metadata(cx, pointee_type, usage_site_span);\n                     return_if_created_in_meantime!();\n@@ -2917,6 +2915,17 @@ fn type_metadata(cx: &CrateContext,\n                 ty::ty_str => {\n                     vec_slice_metadata(cx, t, ty::mk_i8(), unique_type_id, usage_site_span)\n                 }\n+                ty::ty_trait(box ty::TyTrait {\n+                        def_id,\n+                        ref substs,\n+                        ref bounds\n+                    }) => {\n+                    MetadataCreationResult::new(\n+                        trait_metadata(cx, def_id, t, substs,\n+                                       ty::RegionTraitStore(ty::ReStatic, mt.mutbl),\n+                                       bounds, unique_type_id),\n+                    false)\n+                }\n                 _ => {\n                     let pointee = type_metadata(cx, mt.ty, usage_site_span);\n                     return_if_created_in_meantime!();\n@@ -2930,16 +2939,6 @@ fn type_metadata(cx: &CrateContext,\n         ty::ty_closure(ref closurety) => {\n             subroutine_type_metadata(cx, unique_type_id, &closurety.sig, usage_site_span)\n         }\n-        ty::ty_trait(box ty::TyTrait {\n-                def_id,\n-                ref substs,\n-                store,\n-                ref bounds\n-            }) => {\n-            MetadataCreationResult::new(\n-                trait_metadata(cx, def_id, t, substs, store, bounds, unique_type_id),\n-                false)\n-        }\n         ty::ty_struct(def_id, ref substs) => {\n             prepare_struct_metadata(cx,\n                                     t,"}, {"sha": "42c7a71bab84dbda7bc4f9b3b454d9eeb3baf7c0", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=8e7213f65b4348e1b54d8baeeb291267581227d2", "patch": "@@ -769,15 +769,12 @@ fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n         }\n         ast::ExprCast(ref val, _) => {\n             // DPS output mode means this is a trait cast:\n-            match ty::get(node_id_type(bcx, expr.id)).sty {\n-                ty::ty_trait(..) => {\n-                    let datum = unpack_datum!(bcx, trans(bcx, &**val));\n-                    meth::trans_trait_cast(bcx, datum, expr.id, dest)\n-                }\n-                _ => {\n-                    bcx.tcx().sess.span_bug(expr.span,\n-                                            \"expr_cast of non-trait\");\n-                }\n+            if ty::type_is_trait(node_id_type(bcx, expr.id)) {\n+                let datum = unpack_datum!(bcx, trans(bcx, &**val));\n+                meth::trans_trait_cast(bcx, datum, expr.id, dest)\n+            } else {\n+                bcx.tcx().sess.span_bug(expr.span,\n+                                        \"expr_cast of non-trait\");\n             }\n         }\n         ast::ExprAssignOp(op, ref dst, ref src) => {\n@@ -1578,7 +1575,7 @@ pub fn cast_type_kind(t: ty::t) -> cast_kind {\n         ty::ty_float(..)   => cast_float,\n         ty::ty_ptr(..)     => cast_pointer,\n         ty::ty_rptr(_, mt) => match ty::get(mt.ty).sty{\n-            ty::ty_vec(_, None) | ty::ty_str => cast_other,\n+            ty::ty_vec(_, None) | ty::ty_str | ty::ty_trait(..) => cast_other,\n             _ => cast_pointer,\n         },\n         ty::ty_bare_fn(..) => cast_pointer,\n@@ -1794,8 +1791,8 @@ fn deref_once<'a>(bcx: &'a Block<'a>,\n     let r = match ty::get(datum.ty).sty {\n         ty::ty_uniq(content_ty) => {\n             match ty::get(content_ty).sty {\n-                ty::ty_vec(_, None) | ty::ty_str\n-                    => bcx.tcx().sess.span_bug(expr.span, \"unexpected ~[T]\"),\n+                ty::ty_vec(_, None) | ty::ty_str | ty::ty_trait(..)\n+                    => bcx.tcx().sess.span_bug(expr.span, \"unexpected unsized box\"),\n                 _ => deref_owned_pointer(bcx, expr, datum, content_ty),\n             }\n         }\n@@ -1812,8 +1809,8 @@ fn deref_once<'a>(bcx: &'a Block<'a>,\n         ty::ty_ptr(ty::mt { ty: content_ty, .. }) |\n         ty::ty_rptr(_, ty::mt { ty: content_ty, .. }) => {\n             match ty::get(content_ty).sty {\n-                ty::ty_vec(_, None) | ty::ty_str\n-                    => bcx.tcx().sess.span_bug(expr.span, \"unexpected &[T]\"),\n+                ty::ty_vec(_, None) | ty::ty_str | ty::ty_trait(..)\n+                    => bcx.tcx().sess.span_bug(expr.span, \"unexpected unsized reference\"),\n                 _ => {\n                     assert!(!ty::type_needs_drop(bcx.tcx(), datum.ty));\n "}, {"sha": "7024ea4b3756907b0af8a544311a928e9ad7540a", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=8e7213f65b4348e1b54d8baeeb291267581227d2", "patch": "@@ -100,7 +100,7 @@ pub fn get_drop_glue_type(ccx: &CrateContext, t: ty::t) -> ty::t {\n \n         ty::ty_uniq(typ) if !ty::type_needs_drop(tcx, typ) => {\n             match ty::get(typ).sty {\n-                ty::ty_vec(_, None) | ty::ty_str => t,\n+                ty::ty_vec(_, None) | ty::ty_str | ty::ty_trait(..) => t,\n                 _ => {\n                     let llty = sizing_type_of(ccx, typ);\n                     // `Box<ZeroSizeType>` does not allocate.\n@@ -295,25 +295,42 @@ fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t) -> &'a Block<'\n             decr_refcnt_maybe_free(bcx, v0, body_ty)\n         }\n         ty::ty_uniq(content_ty) => {\n-            let llbox = Load(bcx, v0);\n-            let not_null = IsNotNull(bcx, llbox);\n             match ty::get(content_ty).sty {\n                 ty::ty_vec(mt, None) => {\n+                    let llbox = Load(bcx, v0);\n+                    let not_null = IsNotNull(bcx, llbox);\n                     with_cond(bcx, not_null, |bcx| {\n                         let bcx = tvec::make_drop_glue_unboxed(bcx, llbox, mt.ty);\n                         // FIXME: #13994: the old `Box<[T]>` will not support sized deallocation\n                         trans_exchange_free(bcx, llbox, 0, 8)\n                     })\n                 }\n                 ty::ty_str => {\n+                    let llbox = Load(bcx, v0);\n+                    let not_null = IsNotNull(bcx, llbox);\n                     with_cond(bcx, not_null, |bcx| {\n                         let unit_ty = ty::sequence_element_type(bcx.tcx(), t);\n                         let bcx = tvec::make_drop_glue_unboxed(bcx, llbox, unit_ty);\n                         // FIXME: #13994: the old `Box<str>` will not support sized deallocation\n                         trans_exchange_free(bcx, llbox, 0, 8)\n                     })\n                 }\n+                ty::ty_trait(..) => {\n+                    let lluniquevalue = GEPi(bcx, v0, [0, abi::trt_field_box]);\n+                    // Only drop the value when it is non-null\n+                    with_cond(bcx, IsNotNull(bcx, Load(bcx, lluniquevalue)), |bcx| {\n+                        let dtor_ptr = Load(bcx, GEPi(bcx, v0, [0, abi::trt_field_vtable]));\n+                        let dtor = Load(bcx, dtor_ptr);\n+                        Call(bcx,\n+                             dtor,\n+                             [PointerCast(bcx, lluniquevalue, Type::i8p(bcx.ccx()))],\n+                             []);\n+                        bcx\n+                    })\n+                }\n                 _ => {\n+                    let llbox = Load(bcx, v0);\n+                    let not_null = IsNotNull(bcx, llbox);\n                     with_cond(bcx, not_null, |bcx| {\n                         let bcx = drop_ty(bcx, llbox, content_ty);\n                         trans_exchange_free_ty(bcx, llbox, content_ty)\n@@ -336,16 +353,6 @@ fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t) -> &'a Block<'\n                 }\n             }\n         }\n-        ty::ty_trait(box ty::TyTrait { store: ty::UniqTraitStore, .. }) => {\n-            let lluniquevalue = GEPi(bcx, v0, [0, abi::trt_field_box]);\n-            // Only drop the value when it is non-null\n-            with_cond(bcx, IsNotNull(bcx, Load(bcx, lluniquevalue)), |bcx| {\n-                let dtor_ptr = Load(bcx, GEPi(bcx, v0, [0, abi::trt_field_vtable]));\n-                let dtor = Load(bcx, dtor_ptr);\n-                Call(bcx, dtor, [PointerCast(bcx, lluniquevalue, Type::i8p(bcx.ccx()))], []);\n-                bcx\n-            })\n-        }\n         ty::ty_closure(ref f) if f.store == ty::UniqTraitStore => {\n             let box_cell_v = GEPi(bcx, v0, [0u, abi::fn_field_box]);\n             let env = Load(bcx, box_cell_v);"}, {"sha": "506817629565e37dc9dad7539219c4e350dfc8f1", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=8e7213f65b4348e1b54d8baeeb291267581227d2", "patch": "@@ -157,7 +157,7 @@ impl<'a, 'b> Reflector<'a, 'b> {\n               let extra = extra.append(self.c_mt(mt).as_slice());\n               self.visit(\"evec_fixed\", extra.as_slice())\n           }\n-          ty::ty_vec(..) | ty::ty_str => fail!(\"unexpected unsized type\"),\n+          ty::ty_vec(..) | ty::ty_str | ty::ty_trait(..) => fail!(\"unexpected unsized type\"),\n           // Should remove mt from box and uniq.\n           ty::ty_box(typ) => {\n               let extra = self.c_mt(&ty::mt {\n@@ -174,6 +174,13 @@ impl<'a, 'b> Reflector<'a, 'b> {\n                       self.visit(\"evec_uniq\", extra.as_slice())\n                   }\n                   ty::ty_str => self.visit(\"estr_uniq\", &[]),\n+                  ty::ty_trait(..) => {\n+                      let extra = [\n+                          self.c_slice(token::intern_and_get_ident(\n+                                  ty_to_str(tcx, t).as_slice()))\n+                      ];\n+                      self.visit(\"trait\", extra);\n+                  }\n                   _ => {\n                       let extra = self.c_mt(&ty::mt {\n                           ty: typ,\n@@ -196,6 +203,13 @@ impl<'a, 'b> Reflector<'a, 'b> {\n                                  extra.as_slice())\n                   }\n                   ty::ty_str => self.visit(\"estr_slice\", &[]),\n+                  ty::ty_trait(..) => {\n+                      let extra = [\n+                          self.c_slice(token::intern_and_get_ident(\n+                                  ty_to_str(tcx, t).as_slice()))\n+                      ];\n+                      self.visit(\"trait\", extra);\n+                  }\n                   _ => {\n                       let extra = self.c_mt(mt);\n                       self.visit(\"rptr\", extra.as_slice())\n@@ -351,14 +365,6 @@ impl<'a, 'b> Reflector<'a, 'b> {\n             })\n           }\n \n-          ty::ty_trait(..) => {\n-              let extra = [\n-                  self.c_slice(token::intern_and_get_ident(\n-                          ty_to_str(tcx, t).as_slice()))\n-              ];\n-              self.visit(\"trait\", extra);\n-          }\n-\n           // Miscellaneous extra types\n           ty::ty_infer(_) => self.leaf(\"infer\"),\n           ty::ty_err => self.leaf(\"err\"),"}, {"sha": "31bf6cb0110a489699e189359b86db04a765ded9", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=8e7213f65b4348e1b54d8baeeb291267581227d2", "patch": "@@ -116,20 +116,25 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n         ty::ty_float(t) => Type::float_from_ty(cx, t),\n \n         ty::ty_box(..) |\n-        ty::ty_uniq(..) |\n         ty::ty_ptr(..) => Type::i8p(cx),\n+        ty::ty_uniq(ty) => {\n+            match ty::get(ty).sty {\n+                ty::ty_trait(..) => Type::opaque_trait(cx),\n+                _ => Type::i8p(cx),\n+            }\n+        }\n         ty::ty_rptr(_, mt) => {\n             match ty::get(mt.ty).sty {\n                 ty::ty_vec(_, None) | ty::ty_str => {\n                     Type::struct_(cx, [Type::i8p(cx), Type::i8p(cx)], false)\n                 }\n+                ty::ty_trait(..) => Type::opaque_trait(cx),\n                 _ => Type::i8p(cx),\n             }\n         }\n \n         ty::ty_bare_fn(..) => Type::i8p(cx),\n         ty::ty_closure(..) => Type::struct_(cx, [Type::i8p(cx), Type::i8p(cx)], false),\n-        ty::ty_trait(..) => Type::opaque_trait(cx),\n \n         ty::ty_vec(mt, Some(size)) => {\n             Type::array(&sizing_type_of(cx, mt.ty), size as u64)\n@@ -152,7 +157,7 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n         }\n \n         ty::ty_infer(..) | ty::ty_param(..) |\n-        ty::ty_err(..) | ty::ty_vec(_, None) | ty::ty_str => {\n+        ty::ty_err(..) | ty::ty_vec(_, None) | ty::ty_str | ty::ty_trait(..) => {\n             cx.sess().bug(format!(\"fictitious type {:?} in sizing_type_of()\",\n                                   ty::get(t).sty).as_slice())\n         }\n@@ -215,6 +220,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n           match ty::get(typ).sty {\n               ty::ty_vec(mt, None) => Type::vec(cx, &type_of(cx, mt.ty)).ptr_to(),\n               ty::ty_str => Type::vec(cx, &Type::i8(cx)).ptr_to(),\n+              ty::ty_trait(..) => Type::opaque_trait(cx),\n               _ => type_of(cx, typ).ptr_to(),\n           }\n       }\n@@ -230,6 +236,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n                   // This means we get a nicer name in the output\n                   cx.tn.find_type(\"str_slice\").unwrap()\n               }\n+              ty::ty_trait(..) => Type::opaque_trait(cx),\n               _ => type_of(cx, mt.ty).ptr_to(),\n           }\n       }\n@@ -245,7 +252,6 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n           let fn_ty = type_of_fn_from_ty(cx, t).ptr_to();\n           Type::struct_(cx, [fn_ty, Type::i8p(cx)], false)\n       }\n-      ty::ty_trait(..) => Type::opaque_trait(cx),\n       ty::ty_tup(..) => {\n           let repr = adt::represent_type(cx, t);\n           adt::type_of(cx, &*repr)\n@@ -268,6 +274,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n \n       ty::ty_vec(_, None) => cx.sess().bug(\"type_of with unsized ty_vec\"),\n       ty::ty_str => cx.sess().bug(\"type_of with unsized (bare) ty_str\"),\n+      ty::ty_trait(..) => cx.sess().bug(\"type_of with unsized ty_trait\"),\n       ty::ty_infer(..) => cx.sess().bug(\"type_of with ty_infer\"),\n       ty::ty_param(..) => cx.sess().bug(\"type_of with ty_param\"),\n       ty::ty_err(..) => cx.sess().bug(\"type_of with ty_err\")"}, {"sha": "ac1b6ca591becaafdb65f5ec42cbe0ac2b4993a0", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 60, "deletions": 49, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=8e7213f65b4348e1b54d8baeeb291267581227d2", "patch": "@@ -742,7 +742,6 @@ pub enum sty {\n pub struct TyTrait {\n     pub def_id: DefId,\n     pub substs: Substs,\n-    pub store: TraitStore,\n     pub bounds: BuiltinBounds\n }\n \n@@ -1196,14 +1195,8 @@ pub fn mk_t(cx: &ctxt, st: sty) -> t {\n       &ty_enum(_, ref substs) | &ty_struct(_, ref substs) => {\n           flags |= sflags(substs);\n       }\n-      &ty_trait(box ty::TyTrait { ref substs, store, .. }) => {\n+      &ty_trait(box ty::TyTrait { ref substs, .. }) => {\n           flags |= sflags(substs);\n-          match store {\n-              RegionTraitStore(r, _) => {\n-                    flags |= rflags(r);\n-                }\n-              _ => {}\n-          }\n       }\n       &ty_box(tt) | &ty_uniq(tt) => {\n         flags |= get(tt).flags\n@@ -1434,14 +1427,12 @@ pub fn mk_ctor_fn(cx: &ctxt,\n pub fn mk_trait(cx: &ctxt,\n                 did: ast::DefId,\n                 substs: Substs,\n-                store: TraitStore,\n                 bounds: BuiltinBounds)\n              -> t {\n     // take a copy of substs so that we own the vectors inside\n     let inner = box TyTrait {\n         def_id: did,\n         substs: substs,\n-        store: store,\n         bounds: bounds\n     };\n     mk_t(cx, ty_trait(inner))\n@@ -1577,9 +1568,9 @@ fn type_is_slice(ty:t) -> bool {\n \n pub fn type_is_structural(ty: t) -> bool {\n     match get(ty).sty {\n-      ty_struct(..) | ty_tup(_) | ty_enum(..) | ty_closure(_) | ty_trait(..) |\n+      ty_struct(..) | ty_tup(_) | ty_enum(..) | ty_closure(_) |\n       ty_vec(_, Some(_)) => true,\n-      _ => type_is_slice(ty)\n+      _ => type_is_slice(ty) | type_is_trait(ty)\n     }\n }\n \n@@ -1635,7 +1626,7 @@ pub fn type_is_region_ptr(ty: t) -> bool {\n         ty_rptr(_, mt) => match get(mt.ty).sty {\n             // FIXME(nrc, DST) slices weren't regarded as rptrs, so we preserve this\n             // odd behaviour for now. (But ~[] were unique. I have no idea why).\n-            ty_vec(_, None) | ty_str => false,\n+            ty_vec(_, None) | ty_str | ty_trait(..) => false,\n             _ => true\n         },\n         _ => false\n@@ -1651,7 +1642,10 @@ pub fn type_is_unsafe_ptr(ty: t) -> bool {\n \n pub fn type_is_unique(ty: t) -> bool {\n     match get(ty).sty {\n-        ty_uniq(_) => true,\n+        ty_uniq(_) => match get(ty).sty {\n+            ty_trait(..) => false,\n+            _ => true\n+        },\n         _ => false\n     }\n }\n@@ -2060,8 +2054,8 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n                 }\n             }\n \n-            ty_trait(box ty::TyTrait { store, bounds, .. }) => {\n-                object_contents(cx, store, bounds)\n+            ty_trait(box ty::TyTrait { bounds, .. }) => {\n+                object_contents(cx, bounds)\n             }\n \n             ty_ptr(ref mt) => {\n@@ -2185,7 +2179,16 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n     fn closure_contents(cx: &ctxt, cty: &ClosureTy) -> TypeContents {\n         // Closure contents are just like trait contents, but with potentially\n         // even more stuff.\n-        let st = object_contents(cx, cty.store, cty.bounds);\n+        let st = object_contents(cx, cty.bounds);\n+\n+        let st = match cty.store {\n+            UniqTraitStore => {\n+                st.owned_pointer()\n+            }\n+            RegionTraitStore(r, mutbl) => {\n+                st.reference(borrowed_contents(r, mutbl))\n+            }\n+        };\n \n         // This also prohibits \"@once fn\" from being copied, which allows it to\n         // be called. Neither way really makes much sense.\n@@ -2198,20 +2201,10 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n     }\n \n     fn object_contents(cx: &ctxt,\n-                       store: TraitStore,\n                        bounds: BuiltinBounds)\n                        -> TypeContents {\n         // These are the type contents of the (opaque) interior\n-        let contents = kind_bounds_to_contents(cx, bounds, []);\n-\n-        match store {\n-            UniqTraitStore => {\n-                contents.owned_pointer()\n-            }\n-            RegionTraitStore(r, mutbl) => {\n-                contents.reference(borrowed_contents(r, mutbl))\n-            }\n-        }\n+        kind_bounds_to_contents(cx, bounds, [])\n     }\n \n     fn kind_bounds_to_contents(cx: &ctxt,\n@@ -2470,6 +2463,10 @@ pub fn is_type_representable(cx: &ctxt, sp: Span, ty: t) -> Representability {\n \n pub fn type_is_trait(ty: t) -> bool {\n     match get(ty).sty {\n+        ty_uniq(ty) | ty_rptr(_, mt { ty, ..}) => match get(ty).sty {\n+            ty_trait(..) => true,\n+            _ => false\n+        },\n         ty_trait(..) => true,\n         _ => false\n     }\n@@ -2559,15 +2556,15 @@ pub fn deref(t: t, explicit: bool) -> Option<mt> {\n     match get(t).sty {\n         ty_box(typ) | ty_uniq(typ) => match get(typ).sty {\n             // Don't deref ~[] etc., might need to generalise this to all DST.\n-            ty_vec(_, None) | ty_str => None,\n+            ty_vec(_, None) | ty_str | ty_trait(..) => None,\n             _ => Some(mt {\n                 ty: typ,\n                 mutbl: ast::MutImmutable,\n             }),\n         },\n         ty_rptr(_, mt) => match get(mt.ty).sty {\n             // Don't deref &[], might need to generalise this to all DST.\n-            ty_vec(_, None) | ty_str => None,\n+            ty_vec(_, None) | ty_str | ty_trait(..) => None,\n             _ => Some(mt),\n         },\n         ty_ptr(mt) if explicit => Some(mt),\n@@ -2888,7 +2885,19 @@ pub fn adjust_ty(cx: &ctxt,\n                 }\n \n                 AutoObject(store, bounds, def_id, ref substs) => {\n-                    mk_trait(cx, def_id, substs.clone(), store, bounds)\n+\n+                    let tr = mk_trait(cx, def_id, substs.clone(), bounds);\n+                    match store {\n+                        UniqTraitStore => {\n+                            mk_uniq(cx, tr)\n+                        }\n+                        RegionTraitStore(r, m) => {\n+                            mk_rptr(cx, r, mt {\n+                                ty: tr,\n+                                mutbl: m\n+                            })\n+                        }\n+                    }\n                 }\n             }\n         }\n@@ -2926,10 +2935,20 @@ pub fn adjust_ty(cx: &ctxt,\n     fn borrow_obj(cx: &ctxt, span: Span, r: Region,\n                   m: ast::Mutability, ty: ty::t) -> ty::t {\n         match get(ty).sty {\n-            ty_trait(box ty::TyTrait {def_id, ref substs, bounds, .. }) => {\n-                ty::mk_trait(cx, def_id, substs.clone(),\n-                             RegionTraitStore(r, m), bounds)\n-            }\n+            ty_uniq(t) | ty_rptr(_, mt{ty: t, ..}) => match get(t).sty {\n+                ty_trait(box ty::TyTrait {def_id, ref substs, bounds, .. }) => {\n+                    mk_rptr(cx, r, mt {\n+                        ty: ty::mk_trait(cx, def_id, substs.clone(), bounds),\n+                        mutbl: m\n+                    })\n+                }\n+                _ => {\n+                    cx.sess.span_bug(\n+                        span,\n+                        format!(\"borrow-trait-obj associated with bad sty: {:?}\",\n+                                get(ty).sty).as_slice());\n+                }\n+            },\n             ref s => {\n                 cx.sess.span_bug(\n                     span,\n@@ -4264,11 +4283,11 @@ pub fn visitor_object_ty(tcx: &ctxt,\n     let substs = Substs::empty();\n     let trait_ref = Rc::new(TraitRef { def_id: trait_lang_item, substs: substs });\n     Ok((trait_ref.clone(),\n-        mk_trait(tcx,\n-                 trait_ref.def_id,\n-                 trait_ref.substs.clone(),\n-                 RegionTraitStore(region, ast::MutMutable),\n-                 empty_builtin_bounds())))\n+        mk_rptr(tcx, region, mt {mutbl: ast::MutMutable,\n+                                 ty: mk_trait(tcx,\n+                                              trait_ref.def_id,\n+                                              trait_ref.substs.clone(),\n+                                              empty_builtin_bounds()) })))\n }\n \n pub fn item_variances(tcx: &ctxt, item_id: ast::DefId) -> Rc<ItemVariances> {\n@@ -4562,17 +4581,9 @@ pub fn hash_crate_independent(tcx: &ctxt, t: t, svh: &Svh) -> u64 {\n                     }\n                 }\n             }\n-            ty_trait(box ty::TyTrait { def_id: d, store, bounds, .. }) => {\n+            ty_trait(box ty::TyTrait { def_id: d, bounds, .. }) => {\n                 byte!(17);\n                 did(&mut state, d);\n-                match store {\n-                    UniqTraitStore => byte!(0),\n-                    RegionTraitStore(r, m) => {\n-                        byte!(1)\n-                        region(&mut state, r);\n-                        hash!(m);\n-                    }\n-                }\n                 hash!(bounds);\n             }\n             ty_struct(d, _) => {"}, {"sha": "2488d2da779b30c1b61cd8345d43c29fb11180bc", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=8e7213f65b4348e1b54d8baeeb291267581227d2", "patch": "@@ -364,13 +364,11 @@ pub fn super_fold_sty<T:TypeFolder>(this: &mut T,\n         ty::ty_trait(box ty::TyTrait {\n                 def_id,\n                 ref substs,\n-                store,\n                 bounds\n             }) => {\n             ty::ty_trait(box ty::TyTrait {\n                 def_id: def_id,\n                 substs: substs.fold_with(this),\n-                store: store.fold_with(this),\n                 bounds: bounds\n             })\n         }"}, {"sha": "7ca8a74ae636c4ef18bb27a959adb2e8ca5424dc", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 34, "deletions": 21, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=8e7213f65b4348e1b54d8baeeb291267581227d2", "patch": "@@ -584,10 +584,25 @@ fn mk_pointer<AC:AstConv,\n             return constr(ty::mk_vec(tcx, mt, None));\n         }\n         ast::TyUnboxedFn(ref unboxed_function) => {\n-            let trait_store = match ptr_ty {\n-                Uniq => ty::UniqTraitStore,\n+            let ty::TraitRef {\n+                def_id,\n+                substs\n+            } = trait_ref_for_unboxed_function(this,\n+                                               rscope,\n+                                               &**unboxed_function,\n+                                               None);\n+            let tr = ty::mk_trait(this.tcx(),\n+                                  def_id,\n+                                  substs,\n+                                  ty::empty_builtin_bounds());\n+            match ptr_ty {\n+                Uniq => {\n+                    return ty::mk_uniq(this.tcx(), tr);\n+                }\n                 RPtr(r) => {\n-                    ty::RegionTraitStore(r, a_seq_ty.mutbl)\n+                    return ty::mk_rptr(this.tcx(),\n+                                       r,\n+                                       ty::mt {mutbl: a_seq_ty.mutbl, ty: tr});\n                 }\n                 _ => {\n                     tcx.sess.span_err(\n@@ -596,19 +611,8 @@ fn mk_pointer<AC:AstConv,\n                          forms of casting-to-trait\");\n                     return ty::mk_err();\n                 }\n-            };\n-            let ty::TraitRef {\n-                def_id,\n-                substs\n-            } = trait_ref_for_unboxed_function(this,\n-                                               rscope,\n-                                               &**unboxed_function,\n-                                               None);\n-            return ty::mk_trait(this.tcx(),\n-                                def_id,\n-                                substs,\n-                                trait_store,\n-                                ty::empty_builtin_bounds());\n+\n+            }\n         }\n         ast::TyPath(ref path, ref bounds, id) => {\n             // Note that the \"bounds must be empty if path is not a trait\"\n@@ -651,11 +655,20 @@ fn mk_pointer<AC:AstConv,\n                                                      path.span,\n                                                      bounds,\n                                                      trait_store);\n-                    return ty::mk_trait(tcx,\n-                                        result.def_id,\n-                                        result.substs.clone(),\n-                                        trait_store,\n-                                        bounds);\n+                    let tr = ty::mk_trait(tcx,\n+                                          result.def_id,\n+                                          result.substs.clone(),\n+                                          bounds);\n+                    // We could just match on ptr_ty, but we need to pass a trait\n+                    // store to conv_builtin_bounds, so mathc twice for now.\n+                    return match trait_store {\n+                        ty::UniqTraitStore => {\n+                            return ty::mk_uniq(tcx, tr);\n+                        }\n+                        ty::RegionTraitStore(r, m) => {\n+                            return ty::mk_rptr(tcx, r, ty::mt{mutbl: m, ty: tr});\n+                        }\n+                    }\n                 }\n                 _ => {}\n             }"}, {"sha": "edb77e04b30786825ab507c5a5af0a9e58747cd2", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=8e7213f65b4348e1b54d8baeeb291267581227d2", "patch": "@@ -725,10 +725,10 @@ pub fn check_pointer_pat(pcx: &pat_ctxt,\n         fcx.write_ty(pat_id, expected);\n     };\n     match *structure_of(fcx, span, expected) {\n-        ty::ty_uniq(e_inner) if pointer_kind == Send => {\n+        ty::ty_uniq(e_inner) if pointer_kind == Send && !ty::type_is_trait(e_inner) => {\n             check_inner(e_inner);\n         }\n-        ty::ty_rptr(_, e_inner) if pointer_kind == Borrowed => {\n+        ty::ty_rptr(_, e_inner) if pointer_kind == Borrowed && !ty::type_is_trait(e_inner.ty) => {\n             check_inner(e_inner.ty);\n         }\n         _ => {"}, {"sha": "fafc84d2b10f08fce2b97a8559ef541d954551b9", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 44, "deletions": 52, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=8e7213f65b4348e1b54d8baeeb291267581227d2", "patch": "@@ -277,14 +277,14 @@ fn construct_transformed_self_ty_for_object(\n             match ty::get(transformed_self_ty).sty {\n                 ty::ty_rptr(r, mt) => { // must be SelfRegion\n                     let r = r.subst(tcx, rcvr_substs); // handle Early-Bound lifetime\n-                    ty::mk_trait(tcx, trait_def_id, obj_substs,\n-                                 RegionTraitStore(r, mt.mutbl),\n-                                 ty::empty_builtin_bounds())\n+                    let tr = ty::mk_trait(tcx, trait_def_id, obj_substs,\n+                                          ty::empty_builtin_bounds());\n+                    ty::mk_rptr(tcx, r, ty::mt{ ty: tr, mutbl: mt.mutbl })\n                 }\n                 ty::ty_uniq(_) => { // must be SelfUniq\n-                    ty::mk_trait(tcx, trait_def_id, obj_substs,\n-                                 UniqTraitStore,\n-                                 ty::empty_builtin_bounds())\n+                    let tr = ty::mk_trait(tcx, trait_def_id, obj_substs,\n+                                          ty::empty_builtin_bounds());\n+                    ty::mk_uniq(tcx, tr)\n                 }\n                 _ => {\n                     tcx.sess.span_bug(span,\n@@ -433,10 +433,13 @@ impl<'a> LookupContext<'a> {\n         let span = self.self_expr.map_or(self.span, |e| e.span);\n         check::autoderef(self.fcx, span, self_ty, None, PreferMutLvalue, |self_ty, _| {\n             match get(self_ty).sty {\n-                ty_trait(box TyTrait { def_id, ref substs, .. }) => {\n-                    self.push_inherent_candidates_from_object(def_id, substs);\n-                    self.push_inherent_impl_candidates_for_type(def_id);\n-                }\n+                ty_uniq(ty) | ty_rptr(_, mt {ty, ..}) => match get(ty).sty{\n+                    ty_trait(box TyTrait { def_id, ref substs, .. }) => {\n+                        self.push_inherent_candidates_from_object(def_id, substs);\n+                        self.push_inherent_impl_candidates_for_type(def_id);\n+                    }\n+                    _ => {}\n+                },\n                 ty_enum(did, _) | ty_struct(did, _) => {\n                     if self.check_traits == CheckTraitsAndInherentMethods {\n                         self.push_inherent_impl_candidates_for_type(did);\n@@ -774,25 +777,14 @@ impl<'a> LookupContext<'a> {\n                 let (extra_derefs, auto) = match ty::get(self_mt.ty).sty {\n                     ty::ty_vec(_, None) => (0, ty::AutoBorrowVec(region, self_mt.mutbl)),\n                     ty::ty_str => (0, ty::AutoBorrowVec(region, self_mt.mutbl)),\n+                    ty::ty_trait(..) => (0, ty::AutoBorrowObj(region, self_mt.mutbl)),\n                     _ => (1, ty::AutoPtr(region, self_mt.mutbl)),\n                 };\n                 (ty::mk_rptr(tcx, region, self_mt),\n                  ty::AutoDerefRef {\n                      autoderefs: autoderefs + extra_derefs,\n                      autoref: Some(auto)})\n             }\n-\n-            ty::ty_trait(box ty::TyTrait {\n-                def_id, ref substs, store: ty::RegionTraitStore(_, mutbl), bounds\n-            }) => {\n-                let region =\n-                    self.infcx().next_region_var(infer::Autoref(self.span));\n-                (ty::mk_trait(tcx, def_id, substs.clone(),\n-                              ty::RegionTraitStore(region, mutbl), bounds),\n-                 ty::AutoDerefRef {\n-                     autoderefs: autoderefs,\n-                     autoref: Some(ty::AutoBorrowObj(region, mutbl))})\n-            }\n             _ => {\n                 (self_ty,\n                  ty::AutoDerefRef {\n@@ -862,6 +854,26 @@ impl<'a> LookupContext<'a> {\n             })\n     }\n \n+    // Coerce Box/&Trait instances to &Trait.\n+    fn auto_slice_trait(&self, ty: ty::t, autoderefs: uint) -> Option<MethodCallee> {\n+        match ty::get(ty).sty {\n+            ty_trait(box ty::TyTrait {\n+                    def_id: trt_did,\n+                    substs: ref trt_substs,\n+                    bounds: b,\n+                    .. }) => {\n+                let tcx = self.tcx();\n+                self.search_for_some_kind_of_autorefd_method(\n+                    AutoBorrowObj, autoderefs, [MutImmutable, MutMutable],\n+                    |m, r| {\n+                        let tr = ty::mk_trait(tcx, trt_did, trt_substs.clone(), b);\n+                        ty::mk_rptr(tcx, r, ty::mt{ ty: tr, mutbl: m })\n+                    })\n+            }\n+            _ => fail!(\"Expected ty_trait in auto_slice_trait\")\n+        }\n+    }\n+\n     fn search_for_autosliced_method(&self,\n                                     self_ty: ty::t,\n                                     autoderefs: uint)\n@@ -871,38 +883,23 @@ impl<'a> LookupContext<'a> {\n          * `~[]` to `&[]`.\n          */\n \n-        let tcx = self.tcx();\n-        debug!(\"search_for_autosliced_method {}\", ppaux::ty_to_str(tcx, self_ty));\n+        debug!(\"search_for_autosliced_method {}\", ppaux::ty_to_str(self.tcx(), self_ty));\n \n         let sty = ty::get(self_ty).sty.clone();\n         match sty {\n             ty_rptr(_, mt) => match ty::get(mt.ty).sty {\n                 ty_vec(mt, None) => self.auto_slice_vec(mt, autoderefs),\n+                ty_trait(..) => self.auto_slice_trait(mt.ty, autoderefs),\n                 _ => None\n             },\n             ty_uniq(t) => match ty::get(t).sty {\n                 ty_vec(mt, None) => self.auto_slice_vec(mt, autoderefs),\n                 ty_str => self.auto_slice_str(autoderefs),\n+                ty_trait(..) => self.auto_slice_trait(t, autoderefs),\n                 _ => None\n             },\n             ty_vec(mt, Some(_)) => self.auto_slice_vec(mt, autoderefs),\n \n-            ty_trait(box ty::TyTrait {\n-                    def_id: trt_did,\n-                    substs: trt_substs,\n-                    bounds: b,\n-                    ..\n-                }) => {\n-                // Coerce Box/&Trait instances to &Trait.\n-\n-                self.search_for_some_kind_of_autorefd_method(\n-                    AutoBorrowObj, autoderefs, [MutImmutable, MutMutable],\n-                    |m, r| {\n-                        ty::mk_trait(tcx, trt_did, trt_substs.clone(),\n-                                     RegionTraitStore(r, m), b)\n-                    })\n-            }\n-\n             ty_closure(..) => {\n                 // This case should probably be handled similarly to\n                 // Trait instances.\n@@ -1313,17 +1310,15 @@ impl<'a> LookupContext<'a> {\n                     ty::ty_rptr(_, mt) => {\n                         match ty::get(mt.ty).sty {\n                             ty::ty_vec(_, None) | ty::ty_str => false,\n+                            ty::ty_trait(box ty::TyTrait { def_id: self_did, .. }) => {\n+                                mutability_matches(mt.mutbl, m) &&\n+                                rcvr_matches_object(self_did, candidate)\n+                            }\n                             _ => mutability_matches(mt.mutbl, m) &&\n                                  rcvr_matches_ty(self.fcx, mt.ty, candidate),\n                         }\n                     }\n \n-                    ty::ty_trait(box ty::TyTrait {\n-                        def_id: self_did, store: RegionTraitStore(_, self_m), ..\n-                    }) => {\n-                        mutability_matches(self_m, m) &&\n-                        rcvr_matches_object(self_did, candidate)\n-                    }\n \n                     _ => false\n                 }\n@@ -1335,16 +1330,13 @@ impl<'a> LookupContext<'a> {\n                     ty::ty_uniq(typ) => {\n                         match ty::get(typ).sty {\n                             ty::ty_vec(_, None) | ty::ty_str => false,\n+                            ty::ty_trait(box ty::TyTrait { def_id: self_did, .. }) => {\n+                                rcvr_matches_object(self_did, candidate)\n+                            }\n                             _ => rcvr_matches_ty(self.fcx, typ, candidate),\n                         }\n                     }\n \n-                    ty::ty_trait(box ty::TyTrait {\n-                        def_id: self_did, store: UniqTraitStore, ..\n-                    }) => {\n-                        rcvr_matches_object(self_did, candidate)\n-                    }\n-\n                     _ => false\n                 }\n             }"}, {"sha": "7d647dea3227861963754cb2212b6f9db562fde3", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=8e7213f65b4348e1b54d8baeeb291267581227d2", "patch": "@@ -3021,7 +3021,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         else {\n             match ty::get(t_1).sty {\n                 // This will be looked up later on\n-                ty::ty_trait(..) => (),\n+                _ if ty::type_is_trait(t_1) => {},\n \n                 _ => {\n                     if ty::type_is_nil(t_e) {"}, {"sha": "6706f8804a5c8f91b8cc73ec147cfef19169306c", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=8e7213f65b4348e1b54d8baeeb291267581227d2", "patch": "@@ -543,15 +543,18 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             // explaining how it goes about doing that.\n             let target_ty = rcx.resolve_node_type(expr.id);\n             match ty::get(target_ty).sty {\n-                ty::ty_trait(box ty::TyTrait {\n-                    store: ty::RegionTraitStore(trait_region, _), ..\n-                }) => {\n-                    let source_ty = rcx.resolve_expr_type_adjusted(&**source);\n-                    constrain_regions_in_type(\n-                        rcx,\n-                        trait_region,\n-                        infer::RelateObjectBound(expr.span),\n-                        source_ty);\n+                ty::ty_rptr(trait_region, ty::mt{ty, ..}) => {\n+                    match ty::get(ty).sty {\n+                        ty::ty_trait(..) => {\n+                            let source_ty = rcx.resolve_expr_type_adjusted(&**source);\n+                            constrain_regions_in_type(\n+                                rcx,\n+                                trait_region,\n+                                infer::RelateObjectBound(expr.span),\n+                                source_ty);\n+                        }\n+                        _ => {}\n+                    }\n                 }\n                 _ => ()\n             }"}, {"sha": "fe79dabc3f8de8e8c4877ae6548dbaa64a860322", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 66, "deletions": 40, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=8e7213f65b4348e1b54d8baeeb291267581227d2", "patch": "@@ -302,6 +302,7 @@ fn search_for_vtable(vcx: &VtableContext,\n                      trait_ref: Rc<ty::TraitRef>,\n                      is_early: bool)\n                      -> Option<vtable_origin> {\n+    debug!(\"nrc - search_for_vtable\");\n     let tcx = vcx.tcx();\n \n     let mut found = Vec::new();\n@@ -464,7 +465,6 @@ fn fixup_substs(vcx: &VtableContext,\n     // use a dummy type just to package up the substs that need fixing up\n     let t = ty::mk_trait(tcx,\n                          id, substs,\n-                         ty::RegionTraitStore(ty::ReStatic, ast::MutImmutable),\n                          ty::empty_builtin_bounds());\n     fixup_ty(vcx, span, t, is_early).map(|t_f| {\n         match ty::get(t_f).sty {\n@@ -518,43 +518,50 @@ fn insert_vtables(fcx: &FnCtxt, vtable_key: MethodCall, vtables: vtable_res) {\n }\n \n pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n+    fn mutability_allowed(a_mutbl: ast::Mutability,\n+                          b_mutbl: ast::Mutability) -> bool {\n+        a_mutbl == b_mutbl ||\n+        (a_mutbl == ast::MutMutable && b_mutbl == ast::MutImmutable)\n+    }\n+\n     debug!(\"vtable: early_resolve_expr() ex with id {:?} (early: {}): {}\",\n            ex.id, is_early, expr_to_str(ex));\n     let _indent = indenter();\n \n     let cx = fcx.ccx;\n     let resolve_object_cast = |src: &ast::Expr, target_ty: ty::t| {\n-      match ty::get(target_ty).sty {\n-          // Bounds of type's contents are not checked here, but in kind.rs.\n-          ty::ty_trait(box ty::TyTrait {\n-              def_id: target_def_id, substs: ref target_substs, store, ..\n-          }) => {\n-              fn mutability_allowed(a_mutbl: ast::Mutability,\n-                                    b_mutbl: ast::Mutability) -> bool {\n-                  a_mutbl == b_mutbl ||\n-                  (a_mutbl == ast::MutMutable && b_mutbl == ast::MutImmutable)\n-              }\n-              // Look up vtables for the type we're casting to,\n-              // passing in the source and target type.  The source\n-              // must be a pointer type suitable to the object sigil,\n-              // e.g.: `&x as &Trait` or `box x as Box<Trait>`\n-              let ty = structurally_resolved_type(fcx, ex.span,\n-                                                  fcx.expr_ty(src));\n-              match (&ty::get(ty).sty, store) {\n-                  (&ty::ty_rptr(_, mt), ty::RegionTraitStore(_, mutbl))\n-                    if !mutability_allowed(mt.mutbl, mutbl) => {\n+      // Look up vtables for the type we're casting to,\n+      // passing in the source and target type.  The source\n+      // must be a pointer type suitable to the object sigil,\n+      // e.g.: `&x as &Trait` or `box x as Box<Trait>`\n+      // Bounds of type's contents are not checked here, but in kind.rs.\n+      let src_ty = structurally_resolved_type(fcx, ex.span,\n+                                              fcx.expr_ty(src));\n+      match (&ty::get(target_ty).sty, &ty::get(src_ty).sty) {\n+          (&ty::ty_rptr(_, ty::mt{ty, mutbl}), &ty::ty_rptr(_, mt))\n+            if !mutability_allowed(mt.mutbl, mutbl) => {\n+              match ty::get(ty).sty {\n+                  ty::ty_trait(..) => {\n                       fcx.tcx()\n                          .sess\n                          .span_err(ex.span, \"types differ in mutability\");\n                   }\n+                  _ => {}\n+              }\n+          }\n \n-                  (&ty::ty_uniq(..), ty::UniqTraitStore) |\n-                  (&ty::ty_rptr(..), ty::RegionTraitStore(..)) => {\n-                    let typ = match &ty::get(ty).sty {\n-                        &ty::ty_box(typ) | &ty::ty_uniq(typ) => typ,\n-                        &ty::ty_rptr(_, mt) => mt.ty,\n-                        _ => fail!(\"shouldn't get here\"),\n-                    };\n+          (&ty::ty_uniq(ty), &ty::ty_uniq(..) ) |\n+          (&ty::ty_rptr(_, ty::mt{ty, ..}), &ty::ty_rptr(..)) => {\n+              match ty::get(ty).sty {\n+                  ty::ty_trait(box ty::TyTrait {\n+                      def_id: target_def_id, substs: ref target_substs, ..\n+                  }) => {\n+                      debug!(\"nrc correct path\");\n+                      let typ = match &ty::get(src_ty).sty {\n+                          &ty::ty_uniq(typ) => typ,\n+                          &ty::ty_rptr(_, mt) => mt.ty,\n+                          _ => fail!(\"shouldn't get here\"),\n+                      };\n \n                       let vcx = fcx.vtable_context();\n \n@@ -594,38 +601,49 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n \n                       // Now, if this is &trait, we need to link the\n                       // regions.\n-                      match (&ty::get(ty).sty, store) {\n-                          (&ty::ty_rptr(ra, _),\n-                           ty::RegionTraitStore(rb, _)) => {\n+                      match (&ty::get(src_ty).sty, &ty::get(target_ty).sty) {\n+                          (&ty::ty_rptr(ra, _), &ty::ty_rptr(rb, _)) => {\n+                              debug!(\"nrc - make subr\");\n                               infer::mk_subr(fcx.infcx(),\n                                              false,\n-                                             infer::RelateObjectBound(\n-                                                 ex.span),\n+                                             infer::RelateObjectBound(ex.span),\n                                              rb,\n                                              ra);\n                           }\n                           _ => {}\n                       }\n                   }\n+                  _ => {}\n+              }\n+          }\n \n-                  (_, ty::UniqTraitStore) => {\n+          (&ty::ty_uniq(ty), _) => {\n+              match ty::get(ty).sty {\n+                  ty::ty_trait(..) => {\n                       fcx.ccx.tcx.sess.span_err(\n                           ex.span,\n                           format!(\"can only cast an boxed pointer \\\n                                    to a boxed object, not a {}\",\n-                               ty::ty_sort_str(fcx.tcx(), ty)).as_slice());\n+                               ty::ty_sort_str(fcx.tcx(), src_ty)).as_slice());\n                   }\n+                  _ => {}\n+              }\n \n-                  (_, ty::RegionTraitStore(..)) => {\n+          }\n+          (&ty::ty_rptr(_, ty::mt{ty, ..}), _) => {\n+              match ty::get(ty).sty {\n+                  ty::ty_trait(..) => {\n                       fcx.ccx.tcx.sess.span_err(\n                           ex.span,\n                           format!(\"can only cast an &-pointer \\\n                                    to an &-object, not a {}\",\n-                                  ty::ty_sort_str(fcx.tcx(), ty)).as_slice());\n+                                  ty::ty_sort_str(fcx.tcx(), src_ty)).as_slice());\n                   }\n+                  _ => {}\n               }\n           }\n-          _ => { /* not a cast to a trait; ignore */ }\n+\n+          _ => {}\n       }\n     };\n     match ex.node {\n@@ -716,9 +734,17 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n                            ex.repr(fcx.tcx()),\n                            is_early);\n \n-                    let object_ty = ty::mk_trait(cx.tcx, def_id,\n-                                                 substs.clone(),\n-                                                 store, bounds);\n+                    let trait_ty = ty::mk_trait(cx.tcx,\n+                                                def_id,\n+                                                substs.clone(),\n+                                                bounds);\n+                    let object_ty = match store {\n+                        ty::UniqTraitStore => ty::mk_uniq(cx.tcx, trait_ty),\n+                        ty::RegionTraitStore(r, m) => {\n+                            ty::mk_rptr(cx.tcx, r, ty::mt {ty: trait_ty, mutbl: m})\n+                        }\n+                    };\n+\n                     resolve_object_cast(ex, object_ty);\n                 }\n                 AutoAddEnv(..) => {}"}, {"sha": "b12e3b614d1be1dd9da7aa0d1244600390b519d4", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=8e7213f65b4348e1b54d8baeeb291267581227d2", "patch": "@@ -74,10 +74,16 @@ fn get_base_type(inference_context: &InferCtxt,\n     }\n \n     match get(resolved_type).sty {\n-        ty_enum(..) | ty_trait(..) | ty_struct(..) => {\n+        ty_enum(..) | ty_struct(..) => {\n             debug!(\"(getting base type) found base type\");\n             Some(resolved_type)\n         }\n+        // FIXME(14865) I would prefere to use `_` here, but that causes a\n+        // compiler error.\n+        ty_uniq(_) | ty_rptr(_, _) | ty_trait(..) if ty::type_is_trait(resolved_type) => {\n+            debug!(\"(getting base type) found base type (trait)\");\n+            Some(resolved_type)\n+        }\n \n         ty_nil | ty_bot | ty_bool | ty_char | ty_int(..) | ty_uint(..) | ty_float(..) |\n         ty_str(..) | ty_vec(..) | ty_bare_fn(..) | ty_closure(..) | ty_tup(..) |\n@@ -87,6 +93,7 @@ fn get_base_type(inference_context: &InferCtxt,\n                    get(original_type).sty);\n             None\n         }\n+        ty_trait(..) => fail!(\"should have been caught\")\n     }\n }\n \n@@ -108,18 +115,10 @@ fn type_is_defined_in_local_crate(tcx: &ty::ctxt, original_type: t) -> bool {\n                     found_nominal = true;\n                 }\n             }\n-            ty_trait(box ty::TyTrait { def_id, ref store, .. }) => {\n+            ty_trait(box ty::TyTrait { def_id, .. }) => {\n                 if def_id.krate == ast::LOCAL_CRATE {\n                     found_nominal = true;\n                 }\n-                if *store == ty::UniqTraitStore {\n-                    match tcx.lang_items.owned_box() {\n-                        Some(did) if did.krate == ast::LOCAL_CRATE => {\n-                            found_nominal = true;\n-                        }\n-                        _ => {}\n-                    }\n-                }\n             }\n             ty_uniq(..) => {\n                 match tcx.lang_items.owned_box() {\n@@ -150,16 +149,22 @@ fn get_base_type_def_id(inference_context: &InferCtxt,\n                         original_type: t)\n                         -> Option<DefId> {\n     match get_base_type(inference_context, span, original_type) {\n-        None => {\n-            return None;\n-        }\n+        None => None,\n         Some(base_type) => {\n             match get(base_type).sty {\n                 ty_enum(def_id, _) |\n-                ty_struct(def_id, _) |\n-                ty_trait(box ty::TyTrait { def_id, .. }) => {\n-                    return Some(def_id);\n+                ty_struct(def_id, _) => {\n+                    Some(def_id)\n                 }\n+                ty_rptr(_, ty::mt {ty, ..}) | ty_uniq(ty) => match ty::get(ty).sty {\n+                    ty_trait(box ty::TyTrait { def_id, .. }) => {\n+                        Some(def_id)\n+                    }\n+                    _ => {\n+                        fail!(\"get_base_type() returned a type that wasn't an \\\n+                               enum, struct, or trait\");\n+                    }\n+                },\n                 _ => {\n                     fail!(\"get_base_type() returned a type that wasn't an \\\n                            enum, struct, or trait\");"}, {"sha": "0568542472b791c161b17a9761cf5e15dde2c4f1", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 62, "deletions": 48, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=8e7213f65b4348e1b54d8baeeb291267581227d2", "patch": "@@ -100,7 +100,7 @@ impl<'f> Coerce<'f> {\n         // Note: does not attempt to resolve type variables we encounter.\n         // See above for details.\n         match ty::get(b).sty {\n-            ty::ty_rptr(_, mt_b) => {\n+            ty::ty_rptr(r_b, mt_b) => {\n                 match ty::get(mt_b.ty).sty {\n                     ty::ty_vec(mt_b, None) => {\n                         return self.unpack_actual_value(a, |sty_a| {\n@@ -113,6 +113,28 @@ impl<'f> Coerce<'f> {\n                             self.coerce_borrowed_string(a, sty_a, b)\n                         });\n                     }\n+\n+                    ty::ty_trait(box ty::TyTrait { def_id, ref substs, bounds }) => {\n+                        let result = self.unpack_actual_value(a, |sty_a| {\n+                            match *sty_a {\n+                                ty::ty_rptr(_, mt_a) => match ty::get(mt_a.ty).sty {\n+                                    ty::ty_trait(..) => {\n+                                        self.coerce_borrowed_object(a, sty_a, b, mt_b.mutbl)\n+                                    }\n+                                    _ => self.coerce_object(a, sty_a, b, def_id, substs,\n+                                                            ty::RegionTraitStore(r_b, mt_b.mutbl),\n+                                                            bounds)\n+                                },\n+                                _ => self.coerce_borrowed_object(a, sty_a, b, mt_b.mutbl)\n+                            }\n+                        });\n+\n+                        match result {\n+                            Ok(t) => return Ok(t),\n+                            Err(..) => {}\n+                        }\n+                    }\n+\n                     _ => {\n                         return self.unpack_actual_value(a, |sty_a| {\n                             self.coerce_borrowed_pointer(a, sty_a, b, mt_b)\n@@ -121,6 +143,31 @@ impl<'f> Coerce<'f> {\n                 };\n             }\n \n+            ty::ty_uniq(t_b) => {\n+                match ty::get(t_b).sty {\n+                    ty::ty_trait(box ty::TyTrait { def_id, ref substs, bounds }) => {\n+                        let result = self.unpack_actual_value(a, |sty_a| {\n+                            match *sty_a {\n+                                ty::ty_uniq(t_a) => match ty::get(t_a).sty {\n+                                    ty::ty_trait(..) => {\n+                                        Err(ty::terr_mismatch)\n+                                    }\n+                                    _ => self.coerce_object(a, sty_a, b, def_id, substs,\n+                                                            ty::UniqTraitStore, bounds)\n+                                },\n+                                _ => Err(ty::terr_mismatch)\n+                            }\n+                        });\n+\n+                        match result {\n+                            Ok(t) => return Ok(t),\n+                            Err(..) => {}\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+\n             ty::ty_closure(box ty::ClosureTy {\n                     store: ty::RegionTraitStore(..),\n                     ..\n@@ -136,44 +183,6 @@ impl<'f> Coerce<'f> {\n                 });\n             }\n \n-            ty::ty_trait(box ty::TyTrait {\n-                def_id, ref substs, store: ty::UniqTraitStore, bounds\n-            }) => {\n-                let result = self.unpack_actual_value(a, |sty_a| {\n-                    match *sty_a {\n-                        ty::ty_uniq(..) => {\n-                            self.coerce_object(a, sty_a, b, def_id, substs,\n-                                               ty::UniqTraitStore, bounds)\n-                        }\n-                        _ => Err(ty::terr_mismatch)\n-                    }\n-                });\n-\n-                match result {\n-                    Ok(t) => return Ok(t),\n-                    Err(..) => {}\n-                }\n-            }\n-\n-            ty::ty_trait(box ty::TyTrait {\n-                def_id, ref substs, store: ty::RegionTraitStore(region, m), bounds\n-            }) => {\n-                let result = self.unpack_actual_value(a, |sty_a| {\n-                    match *sty_a {\n-                        ty::ty_rptr(..) => {\n-                            self.coerce_object(a, sty_a, b, def_id, substs,\n-                                               ty::RegionTraitStore(region, m), bounds)\n-                        }\n-                        _ => self.coerce_borrowed_object(a, sty_a, b, m)\n-                    }\n-                });\n-\n-                match result {\n-                    Ok(t) => return Ok(t),\n-                    Err(..) => {}\n-                }\n-            }\n-\n             _ => {}\n         }\n \n@@ -335,15 +344,20 @@ impl<'f> Coerce<'f> {\n         let r_a = self.get_ref().infcx.next_region_var(coercion);\n \n         let a_borrowed = match *sty_a {\n-            ty::ty_trait(box ty::TyTrait {\n-                    def_id,\n-                    ref substs,\n-                    bounds,\n-                    ..\n-                }) => {\n-                ty::mk_trait(tcx, def_id, substs.clone(),\n-                             ty::RegionTraitStore(r_a, b_mutbl), bounds)\n-            }\n+            ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) => match ty::get(ty).sty {\n+                ty::ty_trait(box ty::TyTrait {\n+                        def_id,\n+                        ref substs,\n+                        bounds,\n+                        ..\n+                    }) => {\n+                    let tr = ty::mk_trait(tcx, def_id, substs.clone(), bounds);\n+                    ty::mk_rptr(tcx, r_a, ty::mt{ mutbl: b_mutbl, ty: tr })\n+                }\n+                _ => {\n+                    return self.subtype(a, b);\n+                }\n+            },\n             _ => {\n                 return self.subtype(a, b);\n             }"}, {"sha": "cc898ab9c66926fef84d69a6e4ac594c2b45d666", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=8e7213f65b4348e1b54d8baeeb291267581227d2", "patch": "@@ -378,17 +378,19 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n     // so, for example, &T and &[U] should not unify. In fact the only thing\n     // &[U] should unify with is &[T]. We preserve that behaviour with this\n     // check.\n-    fn check_ptr_to_vec<C:Combine>(this: &C,\n-                                   a: ty::t,\n-                                   b: ty::t,\n-                                   a_inner: ty::t,\n-                                   b_inner: ty::t,\n-                                   result: ty::t) -> cres<ty::t> {\n+    fn check_ptr_to_unsized<C:Combine>(this: &C,\n+                                       a: ty::t,\n+                                       b: ty::t,\n+                                       a_inner: ty::t,\n+                                       b_inner: ty::t,\n+                                       result: ty::t) -> cres<ty::t> {\n         match (&ty::get(a_inner).sty, &ty::get(b_inner).sty) {\n             (&ty::ty_vec(_, None), &ty::ty_vec(_, None)) |\n-            (&ty::ty_str, &ty::ty_str) => Ok(result),\n+            (&ty::ty_str, &ty::ty_str) |\n+            (&ty::ty_trait(..), &ty::ty_trait(..)) => Ok(result),\n             (&ty::ty_vec(_, None), _) | (_, &ty::ty_vec(_, None)) |\n-            (&ty::ty_str, _) | (_, &ty::ty_str)\n+            (&ty::ty_str, _) | (_, &ty::ty_str) |\n+            (&ty::ty_trait(..), _) | (_, &ty::ty_trait(..))\n                 => Err(ty::terr_sorts(expected_found(this, a, b))),\n             _ => Ok(result),\n         }\n@@ -478,12 +480,10 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n       if a_.def_id == b_.def_id => {\n           debug!(\"Trying to match traits {:?} and {:?}\", a, b);\n           let substs = if_ok!(this.substs(a_.def_id, &a_.substs, &b_.substs));\n-          let s = if_ok!(this.trait_stores(ty::terr_trait, a_.store, b_.store));\n           let bounds = if_ok!(this.bounds(a_.bounds, b_.bounds));\n           Ok(ty::mk_trait(tcx,\n                           a_.def_id,\n                           substs.clone(),\n-                          s,\n                           bounds))\n       }\n \n@@ -499,18 +499,28 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n \n       (&ty::ty_uniq(a_inner), &ty::ty_uniq(b_inner)) => {\n             let typ = if_ok!(this.tys(a_inner, b_inner));\n-            check_ptr_to_vec(this, a, b, a_inner, b_inner, ty::mk_uniq(tcx, typ))\n+            check_ptr_to_unsized(this, a, b, a_inner, b_inner, ty::mk_uniq(tcx, typ))\n       }\n \n       (&ty::ty_ptr(ref a_mt), &ty::ty_ptr(ref b_mt)) => {\n             let mt = if_ok!(this.mts(a_mt, b_mt));\n-            check_ptr_to_vec(this, a, b, a_mt.ty, b_mt.ty, ty::mk_ptr(tcx, mt))\n+            check_ptr_to_unsized(this, a, b, a_mt.ty, b_mt.ty, ty::mk_ptr(tcx, mt))\n       }\n \n       (&ty::ty_rptr(a_r, ref a_mt), &ty::ty_rptr(b_r, ref b_mt)) => {\n             let r = if_ok!(this.contraregions(a_r, b_r));\n-            let mt = if_ok!(this.mts(a_mt, b_mt));\n-            check_ptr_to_vec(this, a, b, a_mt.ty, b_mt.ty, ty::mk_rptr(tcx, r, mt))\n+            // FIXME(14985)  If we have mutable references to trait objects, we\n+            // used to use covariant subtyping. I have preserved this behaviour,\n+            // even though it is probably incorrect. So don't go down the usual\n+            // path which would require invariance.\n+            let mt = match (&ty::get(a_mt.ty).sty, &ty::get(b_mt.ty).sty) {\n+                (&ty::ty_trait(..), &ty::ty_trait(..)) if a_mt.mutbl == b_mt.mutbl => {\n+                    let ty = if_ok!(this.tys(a_mt.ty, b_mt.ty));\n+                    ty::mt { ty: ty, mutbl: a_mt.mutbl }\n+                }\n+                _ => if_ok!(this.mts(a_mt, b_mt))\n+            };\n+            check_ptr_to_unsized(this, a, b, a_mt.ty, b_mt.ty, ty::mk_rptr(tcx, r, mt))\n       }\n \n       (&ty::ty_vec(ref a_mt, sz_a), &ty::ty_vec(ref b_mt, sz_b)) => {"}, {"sha": "7a7dbaa549a5cff0b515814be3b9a17925c8b1e5", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=8e7213f65b4348e1b54d8baeeb291267581227d2", "patch": "@@ -694,7 +694,6 @@ impl<'a> InferCtxt<'a> {\n         let dummy0 = ty::mk_trait(self.tcx,\n                                   trait_ref.def_id,\n                                   trait_ref.substs.clone(),\n-                                  ty::UniqTraitStore,\n                                   ty::empty_builtin_bounds());\n         let dummy1 = self.resolve_type_vars_if_possible(dummy0);\n         match ty::get(dummy1).sty {"}, {"sha": "6e9ee92c0a35e812b798eb9e18b96644ecfe0e6b", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=8e7213f65b4348e1b54d8baeeb291267581227d2", "patch": "@@ -390,16 +390,15 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> String {\n           parameterized(cx, base.as_slice(), substs, &generics)\n       }\n       ty_trait(box ty::TyTrait {\n-          def_id: did, ref substs, store, ref bounds\n+          def_id: did, ref substs, ref bounds\n       }) => {\n           let base = ty::item_path_str(cx, did);\n           let trait_def = ty::lookup_trait_def(cx, did);\n           let ty = parameterized(cx, base.as_slice(),\n                                  substs, &trait_def.generics);\n           let bound_sep = if bounds.is_empty() { \"\" } else { \":\" };\n           let bound_str = bounds.repr(cx);\n-          format!(\"{}{}{}{}\",\n-                  trait_store_to_str(cx, store),\n+          format!(\"{}{}{}\",\n                   ty,\n                   bound_sep,\n                   bound_str)"}, {"sha": "fa8d341e05de2b60174427a60be1fc7637016479", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=8e7213f65b4348e1b54d8baeeb291267581227d2", "patch": "@@ -233,7 +233,7 @@ use std::f64;\n use std::fmt;\n use std::io::MemWriter;\n use std::io;\n-use std::mem::swap;\n+use std::mem::{swap,transmute};\n use std::num;\n use std::str::ScalarValue;\n use std::str;\n@@ -369,10 +369,11 @@ impl<'a> Encoder<'a> {\n     pub fn buffer_encode<T:Encodable<Encoder<'a>, io::IoError>>(to_encode_object: &T) -> Vec<u8>  {\n        //Serialize the object in a string using a writer\n         let mut m = MemWriter::new();\n-        {\n+        // FIXME(14302) remove the transmute and unsafe block.\n+        unsafe {\n             let mut encoder = Encoder::new(&mut m as &mut io::Writer);\n             // MemWriter never Errs\n-            let _ = to_encode_object.encode(&mut encoder);\n+            let _ = to_encode_object.encode(transmute(&mut encoder));\n         }\n         m.unwrap()\n     }\n@@ -543,8 +544,11 @@ impl<'a> ::Encoder<io::IoError> for Encoder<'a> {\n         // ref #12967, make sure to wrap a key in double quotes,\n         // in the event that its of a type that omits them (eg numbers)\n         let mut buf = MemWriter::new();\n-        let mut check_encoder = Encoder::new(&mut buf);\n-        try!(f(&mut check_encoder));\n+        // FIXME(14302) remove the transmute and unsafe block.\n+        unsafe {\n+            let mut check_encoder = Encoder::new(&mut buf);\n+            try!(f(transmute(&mut check_encoder)));\n+        }\n         let buf = buf.unwrap();\n         let out = from_utf8(buf.as_slice()).unwrap();\n         let needs_wrapping = out.char_at(0) != '\"' &&\n@@ -778,8 +782,11 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n         // ref #12967, make sure to wrap a key in double quotes,\n         // in the event that its of a type that omits them (eg numbers)\n         let mut buf = MemWriter::new();\n-        let mut check_encoder = PrettyEncoder::new(&mut buf);\n-        try!(f(&mut check_encoder));\n+        // FIXME(14302) remove the transmute and unsafe block.\n+        unsafe {\n+            let mut check_encoder = PrettyEncoder::new(&mut buf);\n+            try!(f(transmute(&mut check_encoder)));\n+        }\n         let buf = buf.unwrap();\n         let out = from_utf8(buf.as_slice()).unwrap();\n         let needs_wrapping = out.char_at(0) != '\"' &&"}, {"sha": "eb0c6f2555aee1360754fec4442982ffbaa5a31f", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e7213f65b4348e1b54d8baeeb291267581227d2/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=8e7213f65b4348e1b54d8baeeb291267581227d2", "patch": "@@ -281,6 +281,7 @@ mod test {\n     use serialize::{json, Encodable};\n     use std::io;\n     use std::io::MemWriter;\n+    use std::mem::transmute;\n     use std::str;\n     use std::gc::GC;\n     use codemap::{Span, BytePos, Spanned};\n@@ -295,8 +296,11 @@ mod test {\n \n     fn to_json_str<'a, E: Encodable<json::Encoder<'a>, io::IoError>>(val: &E) -> String {\n         let mut writer = MemWriter::new();\n-        let mut encoder = json::Encoder::new(&mut writer as &mut io::Writer);\n-        let _ = val.encode(&mut encoder);\n+        // FIXME(14302) remove the transmute and unsafe block.\n+        unsafe {\n+            let mut encoder = json::Encoder::new(&mut writer as &mut io::Writer);\n+            let _ = val.encode(transmute(&mut encoder));\n+        }\n         str::from_utf8(writer.unwrap().as_slice()).unwrap().to_string()\n     }\n "}]}