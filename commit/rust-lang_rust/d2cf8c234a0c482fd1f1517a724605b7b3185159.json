{"sha": "d2cf8c234a0c482fd1f1517a724605b7b3185159", "node_id": "C_kwDOAAsO6NoAKGQyY2Y4YzIzNGEwYzQ4MmZkMWYxNTE3YTcyNDYwNWI3YjMxODUxNTk", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-02-12T09:49:57Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-02-12T09:49:57Z"}, "message": "Make else autocompletion work in more places", "tree": {"sha": "ca3446b559173373caee9a5b018f06f8824f6269", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca3446b559173373caee9a5b018f06f8824f6269"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d2cf8c234a0c482fd1f1517a724605b7b3185159", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d2cf8c234a0c482fd1f1517a724605b7b3185159", "html_url": "https://github.com/rust-lang/rust/commit/d2cf8c234a0c482fd1f1517a724605b7b3185159", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d2cf8c234a0c482fd1f1517a724605b7b3185159/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33cacde04b31d4fd71eae7432b92564aade43366", "url": "https://api.github.com/repos/rust-lang/rust/commits/33cacde04b31d4fd71eae7432b92564aade43366", "html_url": "https://github.com/rust-lang/rust/commit/33cacde04b31d4fd71eae7432b92564aade43366"}], "stats": {"total": 344, "additions": 305, "deletions": 39}, "files": [{"sha": "f696b273a4aa708782adaca7c69130a537f48076", "filename": "crates/ide-completion/src/context/analysis.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d2cf8c234a0c482fd1f1517a724605b7b3185159/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2cf8c234a0c482fd1f1517a724605b7b3185159/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs?ref=d2cf8c234a0c482fd1f1517a724605b7b3185159", "patch": "@@ -380,7 +380,7 @@ fn expected_type_and_name(\n                         sema,\n                        token.clone(),\n                     ).map(|ap| {\n-                        let name = dbg!(ap.ident().map(NameOrNameRef::Name));\n+                        let name = ap.ident().map(NameOrNameRef::Name);\n \n                         let ty = strip_refs(ap.ty);\n                         (Some(ty), name)\n@@ -656,8 +656,15 @@ fn classify_name_ref(\n     };\n     let after_if_expr = |node: SyntaxNode| {\n         let prev_expr = (|| {\n+            let node = match node.parent().and_then(ast::ExprStmt::cast) {\n+                Some(stmt) => stmt.syntax().clone(),\n+                None => node,\n+            };\n             let prev_sibling = non_trivia_sibling(node.into(), Direction::Prev)?.into_node()?;\n-            ast::ExprStmt::cast(prev_sibling)?.expr()\n+\n+            ast::ExprStmt::cast(prev_sibling.clone())\n+                .and_then(|it| it.expr())\n+                .or_else(|| ast::Expr::cast(prev_sibling))\n         })();\n         matches!(prev_expr, Some(ast::Expr::IfExpr(_)))\n     };"}, {"sha": "c1c6a689eb18a29a2e3e10e339dcb300ac0f99be", "filename": "crates/ide-completion/src/tests/expression.rs", "status": "modified", "additions": 252, "deletions": 0, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/d2cf8c234a0c482fd1f1517a724605b7b3185159/crates%2Fide-completion%2Fsrc%2Ftests%2Fexpression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2cf8c234a0c482fd1f1517a724605b7b3185159/crates%2Fide-completion%2Fsrc%2Ftests%2Fexpression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests%2Fexpression.rs?ref=d2cf8c234a0c482fd1f1517a724605b7b3185159", "patch": "@@ -745,3 +745,255 @@ fn return_value_no_block() {\n         r#\"fn f() -> i32 { match () { () => return $0 } }\"#,\n     );\n }\n+\n+#[test]\n+fn else_completion_after_if() {\n+    check_empty(\n+        r#\"\n+fn foo() { if foo {} $0 }\n+\"#,\n+        expect![[r#\"\n+            fn foo()       fn()\n+            bt u32\n+            kw const\n+            kw crate::\n+            kw else\n+            kw else if\n+            kw enum\n+            kw extern\n+            kw false\n+            kw fn\n+            kw for\n+            kw if\n+            kw if let\n+            kw impl\n+            kw let\n+            kw loop\n+            kw match\n+            kw mod\n+            kw return\n+            kw self::\n+            kw static\n+            kw struct\n+            kw trait\n+            kw true\n+            kw type\n+            kw union\n+            kw unsafe\n+            kw use\n+            kw while\n+            kw while let\n+            sn macro_rules\n+            sn pd\n+            sn ppd\n+        \"#]],\n+    );\n+    check_empty(\n+        r#\"\n+fn foo() { if foo {} el$0 }\n+\"#,\n+        expect![[r#\"\n+            fn foo()       fn()\n+            bt u32\n+            kw const\n+            kw crate::\n+            kw else\n+            kw else if\n+            kw enum\n+            kw extern\n+            kw false\n+            kw fn\n+            kw for\n+            kw if\n+            kw if let\n+            kw impl\n+            kw let\n+            kw loop\n+            kw match\n+            kw mod\n+            kw return\n+            kw self::\n+            kw static\n+            kw struct\n+            kw trait\n+            kw true\n+            kw type\n+            kw union\n+            kw unsafe\n+            kw use\n+            kw while\n+            kw while let\n+            sn macro_rules\n+            sn pd\n+            sn ppd\n+        \"#]],\n+    );\n+    check_empty(\n+        r#\"\n+fn foo() { bar(if foo {} $0) }\n+\"#,\n+        expect![[r#\"\n+            fn foo()     fn()\n+            bt u32\n+            kw crate::\n+            kw else\n+            kw else if\n+            kw false\n+            kw for\n+            kw if\n+            kw if let\n+            kw loop\n+            kw match\n+            kw return\n+            kw self::\n+            kw true\n+            kw unsafe\n+            kw while\n+            kw while let\n+        \"#]],\n+    );\n+    check_empty(\n+        r#\"\n+fn foo() { bar(if foo {} el$0) }\n+\"#,\n+        expect![[r#\"\n+            fn foo()     fn()\n+            bt u32\n+            kw crate::\n+            kw else\n+            kw else if\n+            kw false\n+            kw for\n+            kw if\n+            kw if let\n+            kw loop\n+            kw match\n+            kw return\n+            kw self::\n+            kw true\n+            kw unsafe\n+            kw while\n+            kw while let\n+        \"#]],\n+    );\n+    check_empty(\n+        r#\"\n+fn foo() { if foo {} $0 let x = 92; }\n+\"#,\n+        expect![[r#\"\n+            fn foo()       fn()\n+            bt u32\n+            kw const\n+            kw crate::\n+            kw else\n+            kw else if\n+            kw enum\n+            kw extern\n+            kw false\n+            kw fn\n+            kw for\n+            kw if\n+            kw if let\n+            kw impl\n+            kw let\n+            kw loop\n+            kw match\n+            kw mod\n+            kw return\n+            kw self::\n+            kw static\n+            kw struct\n+            kw trait\n+            kw true\n+            kw type\n+            kw union\n+            kw unsafe\n+            kw use\n+            kw while\n+            kw while let\n+            sn macro_rules\n+            sn pd\n+            sn ppd\n+        \"#]],\n+    );\n+    check_empty(\n+        r#\"\n+fn foo() { if foo {} el$0 let x = 92; }\n+\"#,\n+        expect![[r#\"\n+            fn foo()       fn()\n+            bt u32\n+            kw const\n+            kw crate::\n+            kw else\n+            kw else if\n+            kw enum\n+            kw extern\n+            kw false\n+            kw fn\n+            kw for\n+            kw if\n+            kw if let\n+            kw impl\n+            kw let\n+            kw loop\n+            kw match\n+            kw mod\n+            kw return\n+            kw self::\n+            kw static\n+            kw struct\n+            kw trait\n+            kw true\n+            kw type\n+            kw union\n+            kw unsafe\n+            kw use\n+            kw while\n+            kw while let\n+            sn macro_rules\n+            sn pd\n+            sn ppd\n+        \"#]],\n+    );\n+    check_empty(\n+        r#\"\n+fn foo() { if foo {} el$0 { let x = 92; } }\n+\"#,\n+        expect![[r#\"\n+            fn foo()       fn()\n+            bt u32\n+            kw const\n+            kw crate::\n+            kw else\n+            kw else if\n+            kw enum\n+            kw extern\n+            kw false\n+            kw fn\n+            kw for\n+            kw if\n+            kw if let\n+            kw impl\n+            kw let\n+            kw loop\n+            kw match\n+            kw mod\n+            kw return\n+            kw self::\n+            kw static\n+            kw struct\n+            kw trait\n+            kw true\n+            kw type\n+            kw union\n+            kw unsafe\n+            kw use\n+            kw while\n+            kw while let\n+            sn macro_rules\n+            sn pd\n+            sn ppd\n+        \"#]],\n+    );\n+}"}, {"sha": "cb71c7b2bdef3ff6a87e8c0d19afafff2de57a91", "filename": "crates/ide-completion/src/tests/special.rs", "status": "modified", "additions": 44, "deletions": 37, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/d2cf8c234a0c482fd1f1517a724605b7b3185159/crates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2cf8c234a0c482fd1f1517a724605b7b3185159/crates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs?ref=d2cf8c234a0c482fd1f1517a724605b7b3185159", "patch": "@@ -2,13 +2,20 @@\n \n use expect_test::{expect, Expect};\n \n-use crate::tests::{check_edit, completion_list_no_kw, completion_list_with_trigger_character};\n+use crate::tests::{\n+    check_edit, completion_list, completion_list_no_kw, completion_list_with_trigger_character,\n+};\n \n-fn check(ra_fixture: &str, expect: Expect) {\n+fn check_no_kw(ra_fixture: &str, expect: Expect) {\n     let actual = completion_list_no_kw(ra_fixture);\n     expect.assert_eq(&actual)\n }\n \n+fn check(ra_fixture: &str, expect: Expect) {\n+    let actual = completion_list(ra_fixture);\n+    expect.assert_eq(&actual)\n+}\n+\n pub(crate) fn check_with_trigger_character(\n     ra_fixture: &str,\n     trigger_character: Option<char>,\n@@ -59,7 +66,7 @@ fn _alpha() {}\n \n #[test]\n fn completes_prelude() {\n-    check(\n+    check_no_kw(\n         r#\"\n //- /main.rs edition:2018 crate:main deps:std\n fn foo() { let x: $0 }\n@@ -81,7 +88,7 @@ pub mod prelude {\n \n #[test]\n fn completes_prelude_macros() {\n-    check(\n+    check_no_kw(\n         r#\"\n //- /main.rs edition:2018 crate:main deps:std\n fn f() {$0}\n@@ -110,7 +117,7 @@ mod macros {\n \n #[test]\n fn completes_std_prelude_if_core_is_defined() {\n-    check(\n+    check_no_kw(\n         r#\"\n //- /main.rs crate:main deps:core,std\n fn foo() { let x: $0 }\n@@ -140,7 +147,7 @@ pub mod prelude {\n \n #[test]\n fn respects_doc_hidden() {\n-    check(\n+    check_no_kw(\n         r#\"\n //- /lib.rs crate:lib deps:std\n fn f() {\n@@ -168,7 +175,7 @@ pub mod prelude {\n \n #[test]\n fn respects_doc_hidden_in_assoc_item_list() {\n-    check(\n+    check_no_kw(\n         r#\"\n //- /lib.rs crate:lib deps:std\n struct S;\n@@ -195,7 +202,7 @@ pub mod prelude {\n \n #[test]\n fn associated_item_visibility() {\n-    check(\n+    check_no_kw(\n         r#\"\n //- /lib.rs crate:lib new_source_root:library\n pub struct S;\n@@ -222,7 +229,7 @@ fn foo() { let _ = lib::S::$0 }\n \n #[test]\n fn completes_union_associated_method() {\n-    check(\n+    check_no_kw(\n         r#\"\n union U {};\n impl U { fn m() { } }\n@@ -237,7 +244,7 @@ fn foo() { let _ = U::$0 }\n \n #[test]\n fn completes_trait_associated_method_1() {\n-    check(\n+    check_no_kw(\n         r#\"\n trait Trait { fn m(); }\n \n@@ -251,7 +258,7 @@ fn foo() { let _ = Trait::$0 }\n \n #[test]\n fn completes_trait_associated_method_2() {\n-    check(\n+    check_no_kw(\n         r#\"\n trait Trait { fn m(); }\n \n@@ -268,7 +275,7 @@ fn foo() { let _ = S::$0 }\n \n #[test]\n fn completes_trait_associated_method_3() {\n-    check(\n+    check_no_kw(\n         r#\"\n trait Trait { fn m(); }\n \n@@ -285,7 +292,7 @@ fn foo() { let _ = <S as Trait>::$0 }\n \n #[test]\n fn completes_ty_param_assoc_ty() {\n-    check(\n+    check_no_kw(\n         r#\"\n trait Super {\n     type Ty;\n@@ -318,7 +325,7 @@ fn foo<T: Sub>() { T::$0 }\n \n #[test]\n fn completes_self_param_assoc_ty() {\n-    check(\n+    check_no_kw(\n         r#\"\n trait Super {\n     type Ty;\n@@ -358,7 +365,7 @@ impl<T> Sub for Wrap<T> {\n \n #[test]\n fn completes_type_alias() {\n-    check(\n+    check_no_kw(\n         r#\"\n struct S;\n impl S { fn foo() {} }\n@@ -376,7 +383,7 @@ fn main() { T::$0; }\n \n #[test]\n fn completes_qualified_macros() {\n-    check(\n+    check_no_kw(\n         r#\"\n #[macro_export]\n macro_rules! foo { () => {} }\n@@ -392,7 +399,7 @@ fn main() { let _ = crate::$0 }\n \n #[test]\n fn does_not_complete_non_fn_macros() {\n-    check(\n+    check_no_kw(\n         r#\"\n mod m {\n     #[rustc_builtin_macro]\n@@ -403,7 +410,7 @@ fn f() {m::$0}\n \"#,\n         expect![[r#\"\"#]],\n     );\n-    check(\n+    check_no_kw(\n         r#\"\n mod m {\n     #[rustc_builtin_macro]\n@@ -418,7 +425,7 @@ fn f() {m::$0}\n \n #[test]\n fn completes_reexported_items_under_correct_name() {\n-    check(\n+    check_no_kw(\n         r#\"\n fn foo() { self::m::$0 }\n \n@@ -475,7 +482,7 @@ mod p {\n \n #[test]\n fn completes_in_simple_macro_call() {\n-    check(\n+    check_no_kw(\n         r#\"\n macro_rules! m { ($e:expr) => { $e } }\n fn main() { m!(self::f$0); }\n@@ -490,7 +497,7 @@ fn foo() {}\n \n #[test]\n fn function_mod_share_name() {\n-    check(\n+    check_no_kw(\n         r#\"\n fn foo() { self::m::$0 }\n \n@@ -508,7 +515,7 @@ mod m {\n \n #[test]\n fn completes_hashmap_new() {\n-    check(\n+    check_no_kw(\n         r#\"\n struct RandomState;\n struct HashMap<K, V, S = RandomState> {}\n@@ -529,7 +536,7 @@ fn foo() {\n #[test]\n fn completes_variant_through_self() {\n     cov_mark::check!(completes_variant_through_self);\n-    check(\n+    check_no_kw(\n         r#\"\n enum Foo {\n     Bar,\n@@ -552,7 +559,7 @@ impl Foo {\n \n #[test]\n fn completes_non_exhaustive_variant_within_the_defining_crate() {\n-    check(\n+    check_no_kw(\n         r#\"\n enum Foo {\n     #[non_exhaustive]\n@@ -570,7 +577,7 @@ fn foo(self) {\n             \"#]],\n     );\n \n-    check(\n+    check_no_kw(\n         r#\"\n //- /main.rs crate:main deps:e\n fn foo(self) {\n@@ -593,7 +600,7 @@ enum Foo {\n #[test]\n fn completes_primitive_assoc_const() {\n     cov_mark::check!(completes_primitive_assoc_const);\n-    check(\n+    check_no_kw(\n         r#\"\n //- /lib.rs crate:lib deps:core\n fn f() {\n@@ -618,7 +625,7 @@ impl u8 {\n #[test]\n fn completes_variant_through_alias() {\n     cov_mark::check!(completes_variant_through_alias);\n-    check(\n+    check_no_kw(\n         r#\"\n enum Foo {\n     Bar\n@@ -636,7 +643,7 @@ fn main() {\n \n #[test]\n fn respects_doc_hidden2() {\n-    check(\n+    check_no_kw(\n         r#\"\n //- /lib.rs crate:lib deps:dep\n fn f() {\n@@ -665,7 +672,7 @@ pub mod m {}\n \n #[test]\n fn type_anchor_empty() {\n-    check(\n+    check_no_kw(\n         r#\"\n trait Foo {\n     fn foo() -> Self;\n@@ -688,7 +695,7 @@ fn bar() -> Bar {\n \n #[test]\n fn type_anchor_type() {\n-    check(\n+    check_no_kw(\n         r#\"\n trait Foo {\n     fn foo() -> Self;\n@@ -715,7 +722,7 @@ fn bar() -> Bar {\n \n #[test]\n fn type_anchor_type_trait() {\n-    check(\n+    check_no_kw(\n         r#\"\n trait Foo {\n     fn foo() -> Self;\n@@ -741,7 +748,7 @@ fn bar() -> Bar {\n \n #[test]\n fn completes_fn_in_pub_trait_generated_by_macro() {\n-    check(\n+    check_no_kw(\n         r#\"\n mod other_mod {\n     macro_rules! make_method {\n@@ -775,7 +782,7 @@ fn main() {\n \n #[test]\n fn completes_fn_in_pub_trait_generated_by_recursive_macro() {\n-    check(\n+    check_no_kw(\n         r#\"\n mod other_mod {\n     macro_rules! make_method {\n@@ -815,7 +822,7 @@ fn main() {\n \n #[test]\n fn completes_const_in_pub_trait_generated_by_macro() {\n-    check(\n+    check_no_kw(\n         r#\"\n mod other_mod {\n     macro_rules! make_const {\n@@ -847,7 +854,7 @@ fn main() {\n \n #[test]\n fn completes_locals_from_macros() {\n-    check(\n+    check_no_kw(\n         r#\"\n \n macro_rules! x {\n@@ -875,7 +882,7 @@ fn main() {\n \n #[test]\n fn regression_12644() {\n-    check(\n+    check_no_kw(\n         r#\"\n macro_rules! __rust_force_expr {\n     ($e:expr) => {\n@@ -974,7 +981,7 @@ fn foo { crate:::$0 }\n \"#,\n         expect![\"\"],\n     );\n-    check(\n+    check_no_kw(\n         r#\"\n fn foo { crate::::$0 }\n \"#,"}]}