{"sha": "b5e73bfe90f7b4905829f1a6509b61ac5577ee07", "node_id": "C_kwDOAAsO6NoAKGI1ZTczYmZlOTBmN2I0OTA1ODI5ZjFhNjUwOWI2MWFjNTU3N2VlMDc", "commit": {"author": {"name": "Le\u00f3n Orell Valerian Liehr", "email": "me@fmease.dev", "date": "2023-02-17T16:06:27Z"}, "committer": {"name": "Le\u00f3n Orell Valerian Liehr", "email": "me@fmease.dev", "date": "2023-02-19T17:35:35Z"}, "message": "Groundwork for detecting ambiguous candidates\n\nNB: Since we are using the same InferCtxt in each iteration,\nwe essentially *spoil* the inference variables and we only\never get at most *one* applicable candidate (only the 1st candidate\nhas clean variables that can still unify correctly).", "tree": {"sha": "ac8880bf2099c4b08cd2aadba41264e776567de8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac8880bf2099c4b08cd2aadba41264e776567de8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b5e73bfe90f7b4905829f1a6509b61ac5577ee07", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEXSQFaHGAjVoD5I3F0XoHIV9o5xMFAmPyXecACgkQ0XoHIV9o\n5xPsJw//V+vLi/uKRVxLtLvqtgA8gn3hV6MPMQEdINDdwqumFSEl7v8nXDM4iaib\nMV2CKZ7u9dXRXVTJCgAgLMZ1MOZHuoK17wNH6TRbLwEcRTOO4mVJX91xQbTpHy6L\nRQCi0b6yecrnYfbuqjTOuia/5aiJAK8xYx4yCruowNvNm6NCJSsCy8WKn+60tXiO\njuMtTMu/WpmN0plkpFY6VgmHDoDdTTFATbDiI49tuyQCpjfA71abeYFs+Q9PIyQx\nGXM9Jy8WOEGo1ACxJRkABVs1fQpXA9p1Q0aI5QD3HljCI1E+vdZlu3S8smAYToBv\nkRqipsAblVsUS1W0r2UYiNutW5HW0bcEvm3Hfw8nwEW7lgABjcNYb5WVw+koHKsI\n97ys6yzXl7aGnDvw0vkJmAlnJ5E2DkmzZNHauWAJ40LcAShZDpLdhDwhNItMzaJK\ns1eVwRcqIEs6C61sWQzHnVsJBTolkc4b0croQioQfq0NXYdS86g+GU/qKZ210rDB\nmWHgpr6eXyikRatXZmMjv61uRlAsh3GdHr1wlc9rivowimT/2+J4Xz58LDS9nGKu\n2Lm+oriF+mPIJ9t2OMssLk9XUld1i8A7bKIZ0HYVPDSsMCKmirudq3haUpjXYAev\n1VkajgqvuAcHR9neTy0AfQEe33NvwVsr9ghsdFhQUEzLHrEExmQ=\n=596O\n-----END PGP SIGNATURE-----", "payload": "tree ac8880bf2099c4b08cd2aadba41264e776567de8\nparent cc65ebd0d29a79a2a1d3fd77e679c763837b33c4\nauthor Le\u00f3n Orell Valerian Liehr <me@fmease.dev> 1676649987 +0100\ncommitter Le\u00f3n Orell Valerian Liehr <me@fmease.dev> 1676828135 +0100\n\nGroundwork for detecting ambiguous candidates\n\nNB: Since we are using the same InferCtxt in each iteration,\nwe essentially *spoil* the inference variables and we only\never get at most *one* applicable candidate (only the 1st candidate\nhas clean variables that can still unify correctly).\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b5e73bfe90f7b4905829f1a6509b61ac5577ee07", "html_url": "https://github.com/rust-lang/rust/commit/b5e73bfe90f7b4905829f1a6509b61ac5577ee07", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b5e73bfe90f7b4905829f1a6509b61ac5577ee07/comments", "author": {"login": "fmease", "id": 14913065, "node_id": "MDQ6VXNlcjE0OTEzMDY1", "avatar_url": "https://avatars.githubusercontent.com/u/14913065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fmease", "html_url": "https://github.com/fmease", "followers_url": "https://api.github.com/users/fmease/followers", "following_url": "https://api.github.com/users/fmease/following{/other_user}", "gists_url": "https://api.github.com/users/fmease/gists{/gist_id}", "starred_url": "https://api.github.com/users/fmease/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fmease/subscriptions", "organizations_url": "https://api.github.com/users/fmease/orgs", "repos_url": "https://api.github.com/users/fmease/repos", "events_url": "https://api.github.com/users/fmease/events{/privacy}", "received_events_url": "https://api.github.com/users/fmease/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fmease", "id": 14913065, "node_id": "MDQ6VXNlcjE0OTEzMDY1", "avatar_url": "https://avatars.githubusercontent.com/u/14913065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fmease", "html_url": "https://github.com/fmease", "followers_url": "https://api.github.com/users/fmease/followers", "following_url": "https://api.github.com/users/fmease/following{/other_user}", "gists_url": "https://api.github.com/users/fmease/gists{/gist_id}", "starred_url": "https://api.github.com/users/fmease/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fmease/subscriptions", "organizations_url": "https://api.github.com/users/fmease/orgs", "repos_url": "https://api.github.com/users/fmease/repos", "events_url": "https://api.github.com/users/fmease/events{/privacy}", "received_events_url": "https://api.github.com/users/fmease/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc65ebd0d29a79a2a1d3fd77e679c763837b33c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc65ebd0d29a79a2a1d3fd77e679c763837b33c4", "html_url": "https://github.com/rust-lang/rust/commit/cc65ebd0d29a79a2a1d3fd77e679c763837b33c4"}], "stats": {"total": 87, "additions": 85, "deletions": 2}, "files": [{"sha": "f3a03805a4469c0890360648d6d5b0052fbc2a48", "filename": "compiler/rustc_hir_analysis/src/astconv/errors.rs", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/b5e73bfe90f7b4905829f1a6509b61ac5577ee07/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5e73bfe90f7b4905829f1a6509b61ac5577ee07/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Ferrors.rs?ref=b5e73bfe90f7b4905829f1a6509b61ac5577ee07", "patch": "@@ -222,6 +222,66 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         err.emit()\n     }\n \n+    pub(crate) fn complain_about_ambiguous_inherent_assoc_type(\n+        &self,\n+        name: Ident,\n+        candidates: Vec<(DefId, DefId)>,\n+        span: Span,\n+    ) -> ErrorGuaranteed {\n+        let mut err = struct_span_err!(\n+            self.tcx().sess,\n+            name.span,\n+            E0034,\n+            \"multiple applicable items in scope\"\n+        );\n+        err.span_label(name.span, format!(\"multiple `{name}` found\"));\n+        self.note_ambiguous_inherent_assoc_type(&mut err, candidates, span);\n+        err.emit()\n+    }\n+\n+    // FIXME(fmease): Heavily adapted from `rustc_hir_typeck::method::suggest`. Deduplicate.\n+    fn note_ambiguous_inherent_assoc_type(\n+        &self,\n+        err: &mut Diagnostic,\n+        candidates: Vec<(DefId, DefId)>,\n+        span: Span,\n+    ) {\n+        let tcx = self.tcx();\n+\n+        // Dynamic limit to avoid hiding just one candidate, which is silly.\n+        let limit = if candidates.len() == 5 { 5 } else { 4 };\n+\n+        for (index, &(assoc_item, _)) in candidates.iter().take(limit).enumerate() {\n+            let impl_ = tcx.impl_of_method(assoc_item).unwrap();\n+\n+            let note_span = if assoc_item.is_local() {\n+                Some(tcx.def_span(assoc_item))\n+            } else if impl_.is_local() {\n+                Some(tcx.def_span(impl_))\n+            } else {\n+                None\n+            };\n+\n+            let title = if candidates.len() > 1 {\n+                format!(\"candidate #{}\", index + 1)\n+            } else {\n+                \"the candidate\".into()\n+            };\n+\n+            let impl_ty = tcx.at(span).type_of(impl_).subst_identity();\n+            let note = format!(\"{title} is defined in an impl for the type `{impl_ty}`\");\n+\n+            if let Some(span) = note_span {\n+                err.span_note(span, &note);\n+            } else {\n+                err.note(&note);\n+            }\n+        }\n+        if candidates.len() > limit {\n+            err.note(&format!(\"and {} others\", candidates.len() - limit));\n+        }\n+    }\n+\n     // FIXME(inherent_associated_types): Find similarly named associated types and suggest them.\n     pub(crate) fn complain_about_inherent_assoc_type_not_found(\n         &self,"}, {"sha": "43db8af7bac81e4c758f183c10fc8e9e8a5a62b0", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b5e73bfe90f7b4905829f1a6509b61ac5577ee07/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5e73bfe90f7b4905829f1a6509b61ac5577ee07/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=b5e73bfe90f7b4905829f1a6509b61ac5577ee07", "patch": "@@ -2217,12 +2217,24 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             return Ok(None);\n         }\n \n+        // In contexts that have no inference context, just make a new one.\n+        // We do need a local variable to store it, though.\n+        let infcx_;\n+        let infcx = match self.infcx() {\n+            Some(infcx) => infcx,\n+            None => {\n+                assert!(!self_ty.needs_infer());\n+                infcx_ = tcx.infer_ctxt().ignoring_regions().build();\n+                &infcx_\n+            }\n+        };\n+\n         let param_env = tcx.param_env(block.owner.to_def_id());\n         let cause = ObligationCause::misc(span, block.owner.def_id);\n         let mut fulfillment_errors = Vec::new();\n+        let mut applicable_candidates = Vec::new();\n \n         for &(impl_, (assoc_item, def_scope)) in &candidates {\n-            let infcx = tcx.infer_ctxt().ignoring_regions().build();\n             let ocx = ObligationCtxt::new(&infcx);\n \n             let impl_ty = tcx.type_of(impl_);\n@@ -2253,6 +2265,18 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 continue;\n             }\n \n+            applicable_candidates.push((assoc_item, def_scope));\n+        }\n+\n+        if applicable_candidates.len() > 1 {\n+            return Err(self.complain_about_ambiguous_inherent_assoc_type(\n+                name,\n+                applicable_candidates,\n+                span,\n+            ));\n+        }\n+\n+        if let Some((assoc_item, def_scope)) = applicable_candidates.pop() {\n             self.check_assoc_ty(assoc_item, name, def_scope, block, span);\n \n             let ty::Adt(_, adt_substs) = self_ty.kind() else {\n@@ -2269,7 +2293,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             // associated type hold, if any.\n             let ty = tcx.type_of(assoc_item).subst(tcx, item_substs);\n \n-            // FIXME(fmease): Don't return early here! There might be multiple applicable candidates.\n             return Ok(Some((ty, assoc_item)));\n         }\n "}]}