{"sha": "7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhYzExY2FkM2ZlODUxNjNkZDhiMGNhMWY2M2FmNDkyNTA5ZjliZmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-08-17T16:49:34Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-08-17T16:49:34Z"}, "message": "Auto merge of #35747 - jonathandturner:rollup, r=jonathandturner\n\nRollup of 23 pull requests\n\n- Successful merges: #34370, #35415, #35595, #35610, #35613, #35614, #35621, #35660, #35663, #35670, #35671, #35672, #35681, #35686, #35690, #35695, #35707, #35708, #35713, #35722, #35725, #35726, #35731\n- Failed merges: #35395", "tree": {"sha": "32c7c9b5a810739c688044cca3c06512e5b6d4ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/32c7c9b5a810739c688044cca3c06512e5b6d4ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "html_url": "https://github.com/rust-lang/rust/commit/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76fa5875c68246384c5057179927cbfdea0cc822", "url": "https://api.github.com/repos/rust-lang/rust/commits/76fa5875c68246384c5057179927cbfdea0cc822", "html_url": "https://github.com/rust-lang/rust/commit/76fa5875c68246384c5057179927cbfdea0cc822"}, {"sha": "c216617cf291a577fc0309ff81e8a58598c11a1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/c216617cf291a577fc0309ff81e8a58598c11a1e", "html_url": "https://github.com/rust-lang/rust/commit/c216617cf291a577fc0309ff81e8a58598c11a1e"}], "stats": {"total": 887, "additions": 511, "deletions": 376}, "files": [{"sha": "1725143325c61207ad54d1becf2a11521d2f8243", "filename": "mk/main.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/mk%2Fmain.mk", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/mk%2Fmain.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fmain.mk?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -13,7 +13,7 @@\n ######################################################################\n \n # The version number\n-CFG_RELEASE_NUM=1.12.0\n+CFG_RELEASE_NUM=1.13.0\n \n # An optional number to put after the label, e.g. '.2' -> '-beta.2'\n # NB Make sure it starts with a dot to conform to semver pre-release"}, {"sha": "0998a88c4d24145314b09df88a228f05e0caf72a", "filename": "src/doc/book/associated-types.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Fdoc%2Fbook%2Fassociated-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Fdoc%2Fbook%2Fassociated-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fassociated-types.md?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -67,7 +67,7 @@ trait Graph {\n Simple enough. Associated types use the `type` keyword, and go inside the body\n of the trait, with the functions.\n \n-These `type` declarations can have all the same thing as functions do. For example,\n+These type declarations work the same way as those for functions. For example,\n if we wanted our `N` type to implement `Display`, so we can print the nodes out,\n we could do this:\n "}, {"sha": "d332cac7d8d16c76bed6b7bad805c1c389239feb", "filename": "src/doc/book/closures.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Fdoc%2Fbook%2Fclosures.md", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Fdoc%2Fbook%2Fclosures.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fclosures.md?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -262,7 +262,7 @@ the result:\n \n ```rust\n fn call_with_one<F>(some_closure: F) -> i32\n-    where F : Fn(i32) -> i32 {\n+    where F: Fn(i32) -> i32 {\n \n     some_closure(1)\n }\n@@ -279,7 +279,7 @@ Let\u2019s examine the signature of `call_with_one` in more depth:\n \n ```rust\n fn call_with_one<F>(some_closure: F) -> i32\n-#    where F : Fn(i32) -> i32 {\n+#    where F: Fn(i32) -> i32 {\n #    some_closure(1) }\n ```\n \n@@ -288,7 +288,7 @@ isn\u2019t interesting. The next part is:\n \n ```rust\n # fn call_with_one<F>(some_closure: F) -> i32\n-    where F : Fn(i32) -> i32 {\n+    where F: Fn(i32) -> i32 {\n #   some_closure(1) }\n ```\n "}, {"sha": "de7dbab3f12ea665ffc2fbb5fad5bb038b0a77b1", "filename": "src/doc/book/lang-items.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Fdoc%2Fbook%2Flang-items.md", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Fdoc%2Fbook%2Flang-items.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Flang-items.md?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -57,8 +57,8 @@ fn main(argc: isize, argv: *const *const u8) -> isize {\n     0\n }\n \n-#[lang = \"eh_personality\"] extern fn eh_personality() {}\n-#[lang = \"panic_fmt\"] fn panic_fmt() -> ! { loop {} }\n+#[lang = \"eh_personality\"] extern fn rust_eh_personality() {}\n+#[lang = \"panic_fmt\"] extern fn rust_begin_panic() -> ! { loop {} }\n # #[lang = \"eh_unwind_resume\"] extern fn rust_eh_unwind_resume() {}\n # #[no_mangle] pub extern fn rust_eh_register_frames () {}\n # #[no_mangle] pub extern fn rust_eh_unregister_frames () {}\n@@ -73,8 +73,8 @@ Other features provided by lang items include:\n   `==`, `<`, dereferencing (`*`) and `+` (etc.) operators are all\n   marked with lang items; those specific four are `eq`, `ord`,\n   `deref`, and `add` respectively.\n-- stack unwinding and general failure; the `eh_personality`, `fail`\n-  and `fail_bounds_checks` lang items.\n+- stack unwinding and general failure; the `eh_personality`,\n+  `eh_unwind_resume`, `fail` and `fail_bounds_checks` lang items.\n - the traits in `std::marker` used to indicate types of\n   various kinds; lang items `send`, `sync` and `copy`.\n - the marker types and variance indicators found in"}, {"sha": "2604ca8d4cab7a269ed4eeacca2ea9b4f6f0e7e5", "filename": "src/doc/book/no-stdlib.md", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Fdoc%2Fbook%2Fno-stdlib.md", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Fdoc%2Fbook%2Fno-stdlib.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fno-stdlib.md?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -55,7 +55,13 @@ fn start(_argc: isize, _argv: *const *const u8) -> isize {\n // provided by libstd.\n #[lang = \"eh_personality\"]\n #[no_mangle]\n-pub extern fn eh_personality() {\n+pub extern fn rust_eh_personality() {\n+}\n+\n+// This function may be needed based on the compilation target.\n+#[lang = \"eh_unwind_resume\"]\n+#[no_mangle]\n+pub extern fn rust_eh_unwind_resume() {\n }\n \n #[lang = \"panic_fmt\"]\n@@ -87,12 +93,18 @@ pub extern fn main(_argc: i32, _argv: *const *const u8) -> i32 {\n     0\n }\n \n-// These functions and traits are used by the compiler, but not\n+// These functions are used by the compiler, but not\n // for a bare-bones hello world. These are normally\n // provided by libstd.\n #[lang = \"eh_personality\"]\n #[no_mangle]\n-pub extern fn eh_personality() {\n+pub extern fn rust_eh_personality() {\n+}\n+\n+// This function may be needed based on the compilation target.\n+#[lang = \"eh_unwind_resume\"]\n+#[no_mangle]\n+pub extern fn rust_eh_unwind_resume() {\n }\n \n #[lang = \"panic_fmt\"]\n@@ -104,23 +116,28 @@ pub extern fn rust_begin_panic(_msg: core::fmt::Arguments,\n }\n ```\n \n-## More about the langauge items\n+## More about the language items\n \n The compiler currently makes a few assumptions about symbols which are\n available in the executable to call. Normally these functions are provided by\n the standard library, but without it you must define your own. These symbols\n are called \"language items\", and they each have an internal name, and then a\n signature that an implementation must conform to.\n \n-The first of these two functions, `eh_personality`, is used by the failure\n+The first of these functions, `rust_eh_personality`, is used by the failure\n mechanisms of the compiler. This is often mapped to GCC's personality function\n (see the [libstd implementation][unwind] for more information), but crates\n which do not trigger a panic can be assured that this function is never\n-called. Both the language item and the symbol name are `eh_personality`.\n- \n+called. The language item's name is `eh_personality`.\n+\n [unwind]: https://github.com/rust-lang/rust/blob/master/src/libpanic_unwind/gcc.rs\n \n-The second function, `panic_fmt`, is also used by the failure mechanisms of the\n+The second function, `rust_begin_panic`, is also used by the failure mechanisms of the\n compiler. When a panic happens, this controls the message that's displayed on\n the screen. While the language item's name is `panic_fmt`, the symbol name is\n `rust_begin_panic`.\n+\n+A third function, `rust_eh_unwind_resume`, is also needed if the `custom_unwind_resume`\n+flag is set in the options of the compilation target. It allows customizing the\n+process of resuming unwind at the end of the landing pads. The language item's name\n+is `eh_unwind_resume`."}, {"sha": "be64379b516e797a69272868254692b940586f66", "filename": "src/doc/grammar.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Fdoc%2Fgrammar.md", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Fdoc%2Fgrammar.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fgrammar.md?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -172,6 +172,11 @@ token : simple_token | ident | literal | symbol | whitespace token ;\n Each of these keywords has special meaning in its grammar, and all of them are\n excluded from the `ident` rule.\n \n+Not all of these keywords are used by the language. Some of them were used\n+before Rust 1.0, and were left reserved once their implementations were\n+removed. Some of them were reserved before 1.0 to make space for possible\n+future features.\n+\n ### Literals\n \n ```antlr"}, {"sha": "522890a2e2682820f912022e424574ceaa3dc5c9", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -1715,6 +1715,15 @@ pub struct IntoIter<T> {\n     end: *const T,\n }\n \n+#[stable(feature = \"vec_intoiter_debug\", since = \"\")]\n+impl<T: fmt::Debug> fmt::Debug for IntoIter<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_tuple(\"IntoIter\")\n+            .field(&self.as_slice())\n+            .finish()\n+    }\n+}\n+\n impl<T> IntoIter<T> {\n     /// Returns the remaining items of this iterator as a slice.\n     ///"}, {"sha": "ee2b898d5c2c2a7698a5dfbba39fd468d532a05a", "filename": "src/libcollectionstest/vec.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Flibcollectionstest%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Flibcollectionstest%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fvec.rs?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -501,6 +501,14 @@ fn test_into_iter_as_mut_slice() {\n     assert_eq!(into_iter.as_slice(), &['y', 'c']);\n }\n \n+#[test]\n+fn test_into_iter_debug() {\n+    let vec = vec!['a', 'b', 'c'];\n+    let into_iter = vec.into_iter();\n+    let debug = format!(\"{:?}\", into_iter);\n+    assert_eq!(debug, \"IntoIter(['a', 'b', 'c'])\");\n+}\n+\n #[test]\n fn test_into_iter_count() {\n     assert_eq!(vec![1, 2, 3].into_iter().count(), 3);"}, {"sha": "079dfe2a81f8090aa8001a590438205d598140da", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -295,20 +295,8 @@ impl<A: Step> ops::Range<A> {\n     ///\n     /// ```\n     /// #![feature(step_by)]\n-    ///\n-    /// for i in (0..10).step_by(2) {\n-    ///     println!(\"{}\", i);\n-    /// }\n-    /// ```\n-    ///\n-    /// This prints:\n-    ///\n-    /// ```text\n-    /// 0\n-    /// 2\n-    /// 4\n-    /// 6\n-    /// 8\n+    /// let result: Vec<_> = (0..10).step_by(2).collect();\n+    /// assert_eq!(result, vec![0, 2, 4, 6, 8]);\n     /// ```\n     #[unstable(feature = \"step_by\", reason = \"recent addition\",\n                issue = \"27741\")]\n@@ -650,4 +638,3 @@ impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> where\n         n\n     }\n }\n-"}, {"sha": "2a9678203e17805004d88aa07e4b1773810bda01", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -42,6 +42,11 @@\n //!   line. It is up to consumers of this core library to define this panic\n //!   function; it is only required to never return. This requires a `lang`\n //!   attribute named `panic_fmt`.\n+//!\n+//! * `rust_eh_personality` - is used by the failure mechanisms of the\n+//!    compiler. This is often mapped to GCC's personality function, but crates\n+//!    which do not trigger a panic can be assured that this function is never\n+//!    called. The `lang` attribute is called `eh_personality`.\n \n // Since libcore defines many fundamental lang items, all tests live in a\n // separate crate, libcoretest, to avoid bizarre issues."}, {"sha": "4ac1b8394f4508cd26016e37945b2bd347c71736", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -10,11 +10,16 @@\n \n //! Overloadable operators.\n //!\n-//! Implementing these traits allows you to get an effect similar to\n-//! overloading operators.\n+//! Implementing these traits allows you to overload certain operators.\n //!\n //! Some of these traits are imported by the prelude, so they are available in\n-//! every Rust program.\n+//! every Rust program. Only operators backed by traits can be overloaded. For\n+//! example, the addition operator (`+`) can be overloaded through the `Add`\n+//! trait, but since the assignment operator (`=`) has no backing trait, there\n+//! is no way of overloading its semantics. Additionally, this module does not\n+//! provide any mechanism to create new operators. If traitless overloading or\n+//! custom operators are required, you should look toward macros or compiler\n+//! plugins to extend Rust's syntax.\n //!\n //! Many of the operators take their operands by value. In non-generic\n //! contexts involving built-in types, this is usually not a problem."}, {"sha": "5db293f5bb016786ad409920e5d8545829bd0fde", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -1073,11 +1073,12 @@ fn check_irrefutable(cx: &MatchCheckCtxt, pat: &Pat, is_fn_arg: bool) {\n     };\n \n     is_refutable(cx, pat, |uncovered_pat| {\n-        span_err!(cx.tcx.sess, pat.span, E0005,\n+        let pattern_string = pat_to_string(uncovered_pat);\n+        struct_span_err!(cx.tcx.sess, pat.span, E0005,\n             \"refutable pattern in {}: `{}` not covered\",\n             origin,\n-            pat_to_string(uncovered_pat),\n-        );\n+            pattern_string,\n+        ).span_label(pat.span, &format!(\"pattern `{}` not covered\", pattern_string)).emit();\n     });\n }\n "}, {"sha": "1de67922b1b3a19e9ab3523885baa424946eaf03", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -277,7 +277,10 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n             } else {\n                 \"cannot refer to statics by value, use a constant instead\"\n             };\n-            span_err!(self.tcx.sess, self.span, E0394, \"{}\", msg);\n+            struct_span_err!(self.tcx.sess, self.span, E0394, \"{}\", msg)\n+                .span_label(self.span, &format!(\"referring to another static by value\"))\n+                .note(&format!(\"use the address-of operator or a constant instead\"))\n+                .emit();\n \n             // Replace STATIC with NOT_CONST to avoid further errors.\n             self.qualif = self.qualif - Qualif::STATIC;"}, {"sha": "b116ab7b3161abf628712357973b2d0b023a45b2", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -283,10 +283,10 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                     Ok(Ordering::Less) |\n                     Ok(Ordering::Equal) => {}\n                     Ok(Ordering::Greater) => {\n-                        span_err!(self.tcx.sess,\n-                                  start.span,\n-                                  E0030,\n-                                  \"lower range bound must be less than or equal to upper\");\n+                        struct_span_err!(self.tcx.sess, start.span, E0030,\n+                            \"lower range bound must be less than or equal to upper\")\n+                            .span_label(start.span, &format!(\"lower bound larger than upper bound\"))\n+                            .emit();\n                     }\n                     Err(ErrorReported) => {}\n                 }"}, {"sha": "d90a932a63d86081ae540569329326eb1ffe9902", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -116,7 +116,7 @@ enum ResolutionError<'a> {\n     /// error E0408: variable `{}` from pattern #{} is not bound in pattern #{}\n     VariableNotBoundInPattern(Name, usize, usize),\n     /// error E0409: variable is bound with different mode in pattern #{} than in pattern #1\n-    VariableBoundWithDifferentMode(Name, usize),\n+    VariableBoundWithDifferentMode(Name, usize, Span),\n     /// error E0411: use of `Self` outside of an impl or trait\n     SelfUsedOutsideImplOrTrait,\n     /// error E0412: use of undeclared\n@@ -269,14 +269,19 @@ fn resolve_struct_error<'b, 'a: 'b, 'c>(resolver: &'b Resolver<'a>,\n                              from,\n                              to)\n         }\n-        ResolutionError::VariableBoundWithDifferentMode(variable_name, pattern_number) => {\n-            struct_span_err!(resolver.session,\n+        ResolutionError::VariableBoundWithDifferentMode(variable_name,\n+                                                        pattern_number,\n+                                                        first_binding_span) => {\n+            let mut err = struct_span_err!(resolver.session,\n                              span,\n                              E0409,\n                              \"variable `{}` is bound with different mode in pattern #{} than in \\\n                               pattern #1\",\n                              variable_name,\n-                             pattern_number)\n+                             pattern_number);\n+            err.span_label(span, &format!(\"bound in different ways\"));\n+            err.span_label(first_binding_span, &format!(\"first binding\"));\n+            err\n         }\n         ResolutionError::SelfUsedOutsideImplOrTrait => {\n             let mut err = struct_span_err!(resolver.session,\n@@ -316,11 +321,13 @@ fn resolve_struct_error<'b, 'a: 'b, 'c>(resolver: &'b Resolver<'a>,\n             err\n         }\n         ResolutionError::DoesNotNameAStruct(name) => {\n-            struct_span_err!(resolver.session,\n+            let mut err = struct_span_err!(resolver.session,\n                              span,\n                              E0422,\n                              \"`{}` does not name a structure\",\n-                             name)\n+                             name);\n+            err.span_label(span, &format!(\"not a structure\"));\n+            err\n         }\n         ResolutionError::StructVariantUsedAsFunction(path_name) => {\n             struct_span_err!(resolver.session,\n@@ -2028,8 +2035,10 @@ impl<'a> Resolver<'a> {\n                         if binding_0.binding_mode != binding_i.binding_mode {\n                             resolve_error(self,\n                                           binding_i.span,\n-                                          ResolutionError::VariableBoundWithDifferentMode(key.name,\n-                                                                                          i + 1));\n+                                          ResolutionError::VariableBoundWithDifferentMode(\n+                                              key.name,\n+                                              i + 1,\n+                                              binding_0.span));\n                         }\n                     }\n                 }"}, {"sha": "e08a30e40d354fb0db482f545fbc0dce56c95834", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -584,12 +584,12 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                                        source);\n                     self.session.add_lint(PRIVATE_IN_PUBLIC, directive.id, directive.span, msg);\n                 } else {\n-                    let msg = format!(\"`{}` is private, and cannot be reexported\", source);\n-                    let note_msg =\n-                        format!(\"consider declaring type or module `{}` with `pub`\", source);\n-                    struct_span_err!(self.session, directive.span, E0365, \"{}\", &msg)\n-                        .span_note(directive.span, &note_msg)\n-                        .emit();\n+                    let mut err = struct_span_err!(self.session, directive.span, E0365,\n+                                                     \"`{}` is private, and cannot be reexported\",\n+                                                     source);\n+                    err.span_label(directive.span, &format!(\"reexport of private `{}`\", source));\n+                    err.note(&format!(\"consider declaring type or module `{}` with `pub`\", source));\n+                    err.emit();\n                 }\n             }\n "}, {"sha": "bcad7dd3bd0fa78ef03e7a729b3c95f1fdfc7ee1", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -624,8 +624,10 @@ fn error_380(ccx: &CrateCtxt, span: Span) {\n \n fn error_392<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, span: Span, param_name: ast::Name)\n                        -> DiagnosticBuilder<'tcx> {\n-    struct_span_err!(ccx.tcx.sess, span, E0392,\n-                     \"parameter `{}` is never used\", param_name)\n+    let mut err = struct_span_err!(ccx.tcx.sess, span, E0392,\n+                  \"parameter `{}` is never used\", param_name);\n+    err.span_label(span, &format!(\"unused type parameter\"));\n+    err\n }\n \n fn error_194(tcx: TyCtxt, span: Span, name: ast::Name) {"}, {"sha": "d00cbf0221e0e76dbc53c8e0606c71f74f65ecfa", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -458,13 +458,25 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n                                        being coerced, none found\");\n                             return;\n                         } else if diff_fields.len() > 1 {\n-                            span_err!(tcx.sess, span, E0375,\n-                                      \"the trait `CoerceUnsized` may only be implemented \\\n-                                       for a coercion between structures with one field \\\n-                                       being coerced, but {} fields need coercions: {}\",\n-                                       diff_fields.len(), diff_fields.iter().map(|&(i, a, b)| {\n-                                            format!(\"{} ({} to {})\", fields[i].name, a, b)\n-                                       }).collect::<Vec<_>>().join(\", \"));\n+                            let item = tcx.map.expect_item(impl_node_id);\n+                            let span = if let ItemImpl(_, _, _, Some(ref t), _, _) = item.node {\n+                                t.path.span\n+                            } else {\n+                                tcx.map.span(impl_node_id)\n+                            };\n+\n+                            let mut err = struct_span_err!(tcx.sess, span, E0375,\n+                                      \"implementing the trait `CoerceUnsized` \\\n+                                       requires multiple coercions\");\n+                            err.note(\"`CoerceUnsized` may only be implemented for \\\n+                                      a coercion between structures with one field being coerced\");\n+                            err.note(&format!(\"currently, {} fields need coercions: {}\",\n+                                             diff_fields.len(),\n+                                             diff_fields.iter().map(|&(i, a, b)| {\n+                                                format!(\"{} ({} to {})\", fields[i].name, a, b)\n+                                             }).collect::<Vec<_>>().join(\", \") ));\n+                            err.span_label(span, &format!(\"requires multiple coercions\"));\n+                            err.emit();\n                             return;\n                         }\n "}, {"sha": "7578ec3d813c16bc98ae7c980efe4731048a542f", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -335,8 +335,10 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n \n                 // Disallow *all* explicit impls of `Sized` and `Unsize` for now.\n                 if Some(trait_def_id) == self.tcx.lang_items.sized_trait() {\n-                    span_err!(self.tcx.sess, item.span, E0322,\n-                              \"explicit impls for the `Sized` trait are not permitted\");\n+                    struct_span_err!(self.tcx.sess, item.span, E0322,\n+                              \"explicit impls for the `Sized` trait are not permitted\")\n+                        .span_label(item.span, &format!(\"impl of 'Sized' not allowed\"))\n+                        .emit();\n                     return;\n                 }\n                 if Some(trait_def_id) == self.tcx.lang_items.unsize_trait() {"}, {"sha": "7e1fb32881d6fa203e8568e1b00bff76499ec8f1", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -2236,7 +2236,6 @@ fn report_unused_parameter(ccx: &CrateCtxt,\n         \"the {} parameter `{}` is not constrained by the \\\n         impl trait, self type, or predicates\",\n         kind, name)\n-        .span_label(span, &format!(\"unconstrained lifetime parameter\"))\n+        .span_label(span, &format!(\"unconstrained {} parameter\", kind))\n         .emit();\n-\n }"}, {"sha": "18a7c7c8457043de80004199a7f45f90322b6573", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -211,6 +211,17 @@ impl CString {\n     /// This method is equivalent to `new` except that no runtime assertion\n     /// is made that `v` contains no 0 bytes, and it requires an actual\n     /// byte vector, not anything that can be converted to one with Into.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::ffi::CString;\n+    ///\n+    /// let raw = b\"foo\".to_vec();\n+    /// unsafe {\n+    ///     let c_string = CString::from_vec_unchecked(raw);\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub unsafe fn from_vec_unchecked(mut v: Vec<u8>) -> CString {\n         v.push(0);"}, {"sha": "d31a593037622f7c6ad8692f94f9402b5413c2d6", "filename": "src/libstd/primitive_docs.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Flibstd%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Flibstd%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprimitive_docs.rs?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -269,13 +269,18 @@ mod prim_pointer { }\n /// - `Borrow`, `BorrowMut`\n /// - `Default`\n ///\n+/// This limitation to `N in 0..33` exists because Rust does not yet support\n+/// generics over the size of an array type. `[Foo; 3]` and `[Bar; 3]` are\n+/// instances of same generic type `[T; 3]`, but `[Foo; 3]` and `[Foo; 5]` are\n+/// entirely different types. As a stopgap, trait implementations are\n+/// statically generated for `N in 0..33`.\n+///\n /// Arrays coerce to [slices (`[T]`)][slice], so their methods can be called on\n-/// arrays.\n+/// arrays. Slices are dynamic and do not coerce to arrays; consequently more\n+/// methods are defined on `slice` where they support both types.\n ///\n /// [slice]: primitive.slice.html\n ///\n-/// Rust does not currently support generics over the size of an array type.\n-///\n /// # Examples\n ///\n /// ```\n@@ -385,6 +390,10 @@ mod prim_slice { }\n ///\n /// [`.as_ptr()`]: #method.as_ptr\n /// [`len()`]: #method.len\n+///\n+/// Note: This example shows the internals of `&str`. `unsafe` should not be\n+/// used to get a string slice under normal circumstances. Use `.as_slice()`\n+/// instead.\n mod prim_str { }\n \n #[doc(primitive = \"tuple\")]"}, {"sha": "6f368e1bc6f06ea28cc22fe9e217812acc022d48", "filename": "src/libsyntax_ext/asm.rs", "status": "modified", "additions": 38, "deletions": 40, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Flibsyntax_ext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Flibsyntax_ext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fasm.rs?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -8,9 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*\n- * Inline assembly support.\n- */\n+// Inline assembly support.\n+//\n use self::State::*;\n \n use syntax::ast;\n@@ -31,43 +30,48 @@ enum State {\n     Inputs,\n     Clobbers,\n     Options,\n-    StateNone\n+    StateNone,\n }\n \n impl State {\n     fn next(&self) -> State {\n         match *self {\n-            Asm       => Outputs,\n-            Outputs   => Inputs,\n-            Inputs    => Clobbers,\n-            Clobbers  => Options,\n-            Options   => StateNone,\n-            StateNone => StateNone\n+            Asm => Outputs,\n+            Outputs => Inputs,\n+            Inputs => Clobbers,\n+            Clobbers => Options,\n+            Options => StateNone,\n+            StateNone => StateNone,\n         }\n     }\n }\n \n const OPTIONS: &'static [&'static str] = &[\"volatile\", \"alignstack\", \"intel\"];\n \n-pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n-                       -> Box<base::MacResult+'cx> {\n+pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt,\n+                       sp: Span,\n+                       tts: &[tokenstream::TokenTree])\n+                       -> Box<base::MacResult + 'cx> {\n     if !cx.ecfg.enable_asm() {\n-        feature_gate::emit_feature_err(\n-            &cx.parse_sess.span_diagnostic, \"asm\", sp,\n-            feature_gate::GateIssue::Language,\n-            feature_gate::EXPLAIN_ASM);\n+        feature_gate::emit_feature_err(&cx.parse_sess.span_diagnostic,\n+                                       \"asm\",\n+                                       sp,\n+                                       feature_gate::GateIssue::Language,\n+                                       feature_gate::EXPLAIN_ASM);\n         return DummyResult::expr(sp);\n     }\n \n     // Split the tts before the first colon, to avoid `asm!(\"x\": y)`  being\n     // parsed as `asm!(z)` with `z = \"x\": y` which is type ascription.\n-    let first_colon = tts.iter().position(|tt| {\n-        match *tt {\n-            tokenstream::TokenTree::Token(_, token::Colon) |\n-            tokenstream::TokenTree::Token(_, token::ModSep) => true,\n-            _ => false\n-        }\n-    }).unwrap_or(tts.len());\n+    let first_colon = tts.iter()\n+        .position(|tt| {\n+            match *tt {\n+                tokenstream::TokenTree::Token(_, token::Colon) |\n+                tokenstream::TokenTree::Token(_, token::ModSep) => true,\n+                _ => false,\n+            }\n+        })\n+        .unwrap_or(tts.len());\n     let mut p = cx.new_parser_from_tts(&tts[first_colon..]);\n     let mut asm = token::InternedString::new(\"\");\n     let mut asm_str_style = None;\n@@ -91,8 +95,9 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[tokenstream::Token\n                 }\n                 // Nested parser, stop before the first colon (see above).\n                 let mut p2 = cx.new_parser_from_tts(&tts[..first_colon]);\n-                let (s, style) = match expr_to_string(cx, panictry!(p2.parse_expr()),\n-                                                   \"inline assembly must be a string literal\") {\n+                let (s, style) = match expr_to_string(cx,\n+                                                      panictry!(p2.parse_expr()),\n+                                                      \"inline assembly must be a string literal\") {\n                     Some((s, st)) => (s, st),\n                     // let compilation continue\n                     None => return DummyResult::expr(sp),\n@@ -109,9 +114,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[tokenstream::Token\n                 asm_str_style = Some(style);\n             }\n             Outputs => {\n-                while p.token != token::Eof &&\n-                      p.token != token::Colon &&\n-                      p.token != token::ModSep {\n+                while p.token != token::Eof && p.token != token::Colon && p.token != token::ModSep {\n \n                     if !outputs.is_empty() {\n                         p.eat(&token::Comma);\n@@ -136,8 +139,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[tokenstream::Token\n                     let output = match ch.next() {\n                         Some('=') => None,\n                         Some('+') => {\n-                            Some(token::intern_and_get_ident(&format!(\n-                                        \"={}\", ch.as_str())))\n+                            Some(token::intern_and_get_ident(&format!(\"={}\", ch.as_str())))\n                         }\n                         _ => {\n                             cx.span_err(span, \"output operand constraint lacks '=' or '+'\");\n@@ -156,9 +158,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[tokenstream::Token\n                 }\n             }\n             Inputs => {\n-                while p.token != token::Eof &&\n-                      p.token != token::Colon &&\n-                      p.token != token::ModSep {\n+                while p.token != token::Eof && p.token != token::Colon && p.token != token::ModSep {\n \n                     if !inputs.is_empty() {\n                         p.eat(&token::Comma);\n@@ -180,9 +180,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[tokenstream::Token\n                 }\n             }\n             Clobbers => {\n-                while p.token != token::Eof &&\n-                      p.token != token::Colon &&\n-                      p.token != token::ModSep {\n+                while p.token != token::Eof && p.token != token::Colon && p.token != token::ModSep {\n \n                     if !clobs.is_empty() {\n                         p.eat(&token::Comma);\n@@ -218,25 +216,25 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[tokenstream::Token\n                     p.eat(&token::Comma);\n                 }\n             }\n-            StateNone => ()\n+            StateNone => (),\n         }\n \n         loop {\n             // MOD_SEP is a double colon '::' without space in between.\n             // When encountered, the state must be advanced twice.\n             match (&p.token, state.next(), state.next().next()) {\n-                (&token::Colon, StateNone, _)   |\n+                (&token::Colon, StateNone, _) |\n                 (&token::ModSep, _, StateNone) => {\n                     p.bump();\n                     break 'statement;\n                 }\n-                (&token::Colon, st, _)   |\n+                (&token::Colon, st, _) |\n                 (&token::ModSep, _, st) => {\n                     p.bump();\n                     state = st;\n                 }\n                 (&token::Eof, _, _) => break 'statement,\n-                _ => break\n+                _ => break,\n             }\n         }\n     }"}, {"sha": "169ef9ab7d6359f40c53ec3d54526e573df2fad2", "filename": "src/libsyntax_ext/cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Flibsyntax_ext%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Flibsyntax_ext%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fcfg.rs?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -23,7 +23,7 @@ use syntax_pos::Span;\n pub fn expand_cfg<'cx>(cx: &mut ExtCtxt,\n                        sp: Span,\n                        tts: &[tokenstream::TokenTree])\n-                       -> Box<base::MacResult+'static> {\n+                       -> Box<base::MacResult + 'static> {\n     let mut p = cx.new_parser_from_tts(tts);\n     let cfg = panictry!(p.parse_meta_item());\n "}, {"sha": "02b44f2d012ea101f224d69969ba2a401a45e1b7", "filename": "src/libsyntax_ext/concat.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Flibsyntax_ext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Flibsyntax_ext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat.rs?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -20,10 +20,10 @@ use std::string::String;\n pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n                          sp: syntax_pos::Span,\n                          tts: &[tokenstream::TokenTree])\n-                         -> Box<base::MacResult+'static> {\n+                         -> Box<base::MacResult + 'static> {\n     let es = match base::get_exprs_from_tts(cx, sp, tts) {\n         Some(e) => e,\n-        None => return base::DummyResult::expr(sp)\n+        None => return base::DummyResult::expr(sp),\n     };\n     let mut accumulator = String::new();\n     for e in es {\n@@ -57,7 +57,5 @@ pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n             }\n         }\n     }\n-    base::MacEager::expr(cx.expr_str(\n-            sp,\n-            token::intern_and_get_ident(&accumulator[..])))\n+    base::MacEager::expr(cx.expr_str(sp, token::intern_and_get_ident(&accumulator[..])))\n }"}, {"sha": "15aaf3c78237f2410f3760df07afca52f9e9c396", "filename": "src/libsyntax_ext/concat_idents.rs", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Flibsyntax_ext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Flibsyntax_ext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat_idents.rs?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -18,8 +18,10 @@ use syntax::ptr::P;\n use syntax_pos::Span;\n use syntax::tokenstream::TokenTree;\n \n-pub fn expand_syntax_ext<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[TokenTree])\n-                              -> Box<base::MacResult+'cx> {\n+pub fn expand_syntax_ext<'cx>(cx: &'cx mut ExtCtxt,\n+                              sp: Span,\n+                              tts: &[TokenTree])\n+                              -> Box<base::MacResult + 'cx> {\n     if !cx.ecfg.enable_concat_idents() {\n         feature_gate::emit_feature_err(&cx.parse_sess.span_diagnostic,\n                                        \"concat_idents\",\n@@ -33,35 +35,40 @@ pub fn expand_syntax_ext<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[TokenTree])\n     for (i, e) in tts.iter().enumerate() {\n         if i & 1 == 1 {\n             match *e {\n-                TokenTree::Token(_, token::Comma) => {},\n+                TokenTree::Token(_, token::Comma) => {}\n                 _ => {\n                     cx.span_err(sp, \"concat_idents! expecting comma.\");\n                     return DummyResult::expr(sp);\n-                },\n+                }\n             }\n         } else {\n             match *e {\n-                TokenTree::Token(_, token::Ident(ident)) => {\n-                    res_str.push_str(&ident.name.as_str())\n-                },\n+                TokenTree::Token(_, token::Ident(ident)) => res_str.push_str(&ident.name.as_str()),\n                 _ => {\n                     cx.span_err(sp, \"concat_idents! requires ident args.\");\n                     return DummyResult::expr(sp);\n-                },\n+                }\n             }\n         }\n     }\n     let res = str_to_ident(&res_str);\n \n-    struct Result { ident: ast::Ident, span: Span };\n+    struct Result {\n+        ident: ast::Ident,\n+        span: Span,\n+    };\n \n     impl Result {\n         fn path(&self) -> ast::Path {\n             let segment = ast::PathSegment {\n                 identifier: self.ident,\n-                parameters: ast::PathParameters::none()\n+                parameters: ast::PathParameters::none(),\n             };\n-            ast::Path { span: self.span, global: false, segments: vec![segment] }\n+            ast::Path {\n+                span: self.span,\n+                global: false,\n+                segments: vec![segment],\n+            }\n         }\n     }\n \n@@ -84,5 +91,8 @@ pub fn expand_syntax_ext<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[TokenTree])\n         }\n     }\n \n-    Box::new(Result { ident: res, span: sp })\n+    Box::new(Result {\n+        ident: res,\n+        span: sp,\n+    })\n }"}, {"sha": "356c54fcf31202299bac568cee529e21d418f536", "filename": "src/libsyntax_ext/deriving/generic/ty.rs", "status": "modified", "additions": 70, "deletions": 63, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -36,20 +36,20 @@ pub enum PtrTy<'a> {\n /// for type parameters and a lifetime.\n #[derive(Clone, Eq, PartialEq)]\n pub struct Path<'a> {\n-    pub path: Vec<&'a str> ,\n+    pub path: Vec<&'a str>,\n     pub lifetime: Option<&'a str>,\n     pub params: Vec<Box<Ty<'a>>>,\n     pub global: bool,\n }\n \n impl<'a> Path<'a> {\n-    pub fn new<'r>(path: Vec<&'r str> ) -> Path<'r> {\n+    pub fn new<'r>(path: Vec<&'r str>) -> Path<'r> {\n         Path::new_(path, None, Vec::new(), true)\n     }\n     pub fn new_local<'r>(path: &'r str) -> Path<'r> {\n-        Path::new_(vec!( path ), None, Vec::new(), false)\n+        Path::new_(vec![path], None, Vec::new(), false)\n     }\n-    pub fn new_<'r>(path: Vec<&'r str> ,\n+    pub fn new_<'r>(path: Vec<&'r str>,\n                     lifetime: Option<&'r str>,\n                     params: Vec<Box<Ty<'r>>>,\n                     global: bool)\n@@ -58,7 +58,7 @@ impl<'a> Path<'a> {\n             path: path,\n             lifetime: lifetime,\n             params: params,\n-            global: global\n+            global: global,\n         }\n     }\n \n@@ -94,7 +94,7 @@ pub enum Ty<'a> {\n     /// parameter, and things like `i32`\n     Literal(Path<'a>),\n     /// includes unit\n-    Tuple(Vec<Ty<'a>> )\n+    Tuple(Vec<Ty<'a>>),\n }\n \n pub fn borrowed_ptrty<'r>() -> PtrTy<'r> {\n@@ -119,14 +119,14 @@ pub fn nil_ty<'r>() -> Ty<'r> {\n fn mk_lifetime(cx: &ExtCtxt, span: Span, lt: &Option<&str>) -> Option<ast::Lifetime> {\n     match *lt {\n         Some(ref s) => Some(cx.lifetime(span, cx.ident_of(*s).name)),\n-        None => None\n+        None => None,\n     }\n }\n \n fn mk_lifetimes(cx: &ExtCtxt, span: Span, lt: &Option<&str>) -> Vec<ast::Lifetime> {\n     match *lt {\n-        Some(ref s) => vec!(cx.lifetime(span, cx.ident_of(*s).name)),\n-        None => vec!()\n+        Some(ref s) => vec![cx.lifetime(span, cx.ident_of(*s).name)],\n+        None => vec![],\n     }\n }\n \n@@ -145,13 +145,11 @@ impl<'a> Ty<'a> {\n                         let lt = mk_lifetime(cx, span, lt);\n                         cx.ty_rptr(span, raw_ty, lt, mutbl)\n                     }\n-                    Raw(mutbl) => cx.ty_ptr(span, raw_ty, mutbl)\n+                    Raw(mutbl) => cx.ty_ptr(span, raw_ty, mutbl),\n                 }\n             }\n-            Literal(ref p) => { p.to_ty(cx, span, self_ty, self_generics) }\n-            Self_  => {\n-                cx.ty_path(self.to_path(cx, span, self_ty, self_generics))\n-            }\n+            Literal(ref p) => p.to_ty(cx, span, self_ty, self_generics),\n+            Self_ => cx.ty_path(self.to_path(cx, span, self_ty, self_generics)),\n             Tuple(ref fields) => {\n                 let ty = ast::TyKind::Tup(fields.iter()\n                     .map(|f| f.to_ty(cx, span, self_ty, self_generics))\n@@ -169,20 +167,25 @@ impl<'a> Ty<'a> {\n                    -> ast::Path {\n         match *self {\n             Self_ => {\n-                let self_params = self_generics.ty_params.iter().map(|ty_param| {\n-                    cx.ty_ident(span, ty_param.ident)\n-                }).collect();\n-                let lifetimes = self_generics.lifetimes.iter()\n-                                                       .map(|d| d.lifetime)\n-                                                       .collect();\n+                let self_params = self_generics.ty_params\n+                    .iter()\n+                    .map(|ty_param| cx.ty_ident(span, ty_param.ident))\n+                    .collect();\n+                let lifetimes = self_generics.lifetimes\n+                    .iter()\n+                    .map(|d| d.lifetime)\n+                    .collect();\n \n-                cx.path_all(span, false, vec![self_ty], lifetimes, self_params, Vec::new())\n-            }\n-            Literal(ref p) => {\n-                p.to_path(cx, span, self_ty, self_generics)\n+                cx.path_all(span,\n+                            false,\n+                            vec![self_ty],\n+                            lifetimes,\n+                            self_params,\n+                            Vec::new())\n             }\n-            Ptr(..) => { cx.span_bug(span, \"pointer in a path in generic `derive`\") }\n-            Tuple(..) => { cx.span_bug(span, \"tuple in a path in generic `derive`\") }\n+            Literal(ref p) => p.to_path(cx, span, self_ty, self_generics),\n+            Ptr(..) => cx.span_bug(span, \"pointer in a path in generic `derive`\"),\n+            Tuple(..) => cx.span_bug(span, \"tuple in a path in generic `derive`\"),\n         }\n     }\n }\n@@ -195,16 +198,16 @@ fn mk_ty_param(cx: &ExtCtxt,\n                self_ident: Ident,\n                self_generics: &Generics)\n                -> ast::TyParam {\n-    let bounds =\n-        bounds.iter().map(|b| {\n+    let bounds = bounds.iter()\n+        .map(|b| {\n             let path = b.to_path(cx, span, self_ident, self_generics);\n             cx.typarambound(path)\n-        }).collect();\n+        })\n+        .collect();\n     cx.typaram(span, cx.ident_of(name), bounds, None)\n }\n \n-fn mk_generics(lifetimes: Vec<ast::LifetimeDef>, ty_params: Vec<ast::TyParam>)\n-               -> Generics {\n+fn mk_generics(lifetimes: Vec<ast::LifetimeDef>, ty_params: Vec<ast::TyParam>) -> Generics {\n     Generics {\n         lifetimes: lifetimes,\n         ty_params: P::from_vec(ty_params),\n@@ -225,7 +228,8 @@ pub struct LifetimeBounds<'a> {\n impl<'a> LifetimeBounds<'a> {\n     pub fn empty() -> LifetimeBounds<'a> {\n         LifetimeBounds {\n-            lifetimes: Vec::new(), bounds: Vec::new()\n+            lifetimes: Vec::new(),\n+            bounds: Vec::new(),\n         }\n     }\n     pub fn to_generics(&self,\n@@ -234,46 +238,49 @@ impl<'a> LifetimeBounds<'a> {\n                        self_ty: Ident,\n                        self_generics: &Generics)\n                        -> Generics {\n-        let lifetimes = self.lifetimes.iter().map(|&(ref lt, ref bounds)| {\n-            let bounds =\n-                bounds.iter().map(\n-                    |b| cx.lifetime(span, cx.ident_of(*b).name)).collect();\n-            cx.lifetime_def(span, cx.ident_of(*lt).name, bounds)\n-        }).collect();\n-        let ty_params = self.bounds.iter().map(|t| {\n-            match *t {\n-                (ref name, ref bounds) => {\n-                    mk_ty_param(cx,\n-                                span,\n-                                *name,\n-                                bounds,\n-                                self_ty,\n-                                self_generics)\n+        let lifetimes = self.lifetimes\n+            .iter()\n+            .map(|&(ref lt, ref bounds)| {\n+                let bounds = bounds.iter()\n+                    .map(|b| cx.lifetime(span, cx.ident_of(*b).name))\n+                    .collect();\n+                cx.lifetime_def(span, cx.ident_of(*lt).name, bounds)\n+            })\n+            .collect();\n+        let ty_params = self.bounds\n+            .iter()\n+            .map(|t| {\n+                match *t {\n+                    (ref name, ref bounds) => {\n+                        mk_ty_param(cx, span, *name, bounds, self_ty, self_generics)\n+                    }\n                 }\n-            }\n-        }).collect();\n+            })\n+            .collect();\n         mk_generics(lifetimes, ty_params)\n     }\n }\n \n-pub fn get_explicit_self(cx: &ExtCtxt, span: Span, self_ptr: &Option<PtrTy>)\n-    -> (P<Expr>, ast::ExplicitSelf) {\n+pub fn get_explicit_self(cx: &ExtCtxt,\n+                         span: Span,\n+                         self_ptr: &Option<PtrTy>)\n+                         -> (P<Expr>, ast::ExplicitSelf) {\n     // this constructs a fresh `self` path\n     let self_path = cx.expr_self(span);\n     match *self_ptr {\n-        None => {\n-            (self_path, respan(span, SelfKind::Value(ast::Mutability::Immutable)))\n-        }\n+        None => (self_path, respan(span, SelfKind::Value(ast::Mutability::Immutable))),\n         Some(ref ptr) => {\n-            let self_ty = respan(\n-                span,\n-                match *ptr {\n-                    Borrowed(ref lt, mutbl) => {\n-                        let lt = lt.map(|s| cx.lifetime(span, cx.ident_of(s).name));\n-                        SelfKind::Region(lt, mutbl)\n-                    }\n-                    Raw(_) => cx.span_bug(span, \"attempted to use *self in deriving definition\")\n-                });\n+            let self_ty =\n+                respan(span,\n+                       match *ptr {\n+                           Borrowed(ref lt, mutbl) => {\n+                               let lt = lt.map(|s| cx.lifetime(span, cx.ident_of(s).name));\n+                               SelfKind::Region(lt, mutbl)\n+                           }\n+                           Raw(_) => {\n+                               cx.span_bug(span, \"attempted to use *self in deriving definition\")\n+                           }\n+                       });\n             let self_expr = cx.expr_deref(span, self_path);\n             (self_expr, self_ty)\n         }"}, {"sha": "aee86b246b9852dd61f10337428ea07164a5012e", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -10,7 +10,7 @@\n \n //! The compiler code necessary to implement the `#[derive]` extensions.\n \n-use syntax::ast::{MetaItem, self};\n+use syntax::ast::{self, MetaItem};\n use syntax::attr::AttrMetaMethods;\n use syntax::ext::base::{Annotatable, ExtCtxt, SyntaxEnv};\n use syntax::ext::base::{MultiDecorator, MultiItemDecorator, MultiModifier};\n@@ -99,11 +99,11 @@ fn expand_derive(cx: &mut ExtCtxt,\n \n             for titem in traits.iter().rev() {\n                 let tname = if titem.is_word() {\n-                                titem.name() }\n-                            else {\n-                                cx.span_err(titem.span, \"malformed `derive` entry\");\n-                                continue;\n-                            };\n+                    titem.name()\n+                } else {\n+                    cx.span_err(titem.span, \"malformed `derive` entry\");\n+                    continue;\n+                };\n \n                 if !(is_builtin_trait(&tname) || cx.ecfg.enable_custom_derive()) {\n                     feature_gate::emit_feature_err(&cx.parse_sess.span_diagnostic,"}, {"sha": "5c081b98962e310345110f2b5efe7561a97d2c70", "filename": "src/libsyntax_ext/env.rs", "status": "modified", "additions": 37, "deletions": 43, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Flibsyntax_ext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Flibsyntax_ext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fenv.rs?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -8,11 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*\n- * The compiler code necessary to support the env! extension.  Eventually this\n- * should all get sucked into either the compiler syntax extension plugin\n- * interface.\n- */\n+// The compiler code necessary to support the env! extension.  Eventually this\n+// should all get sucked into either the compiler syntax extension plugin\n+// interface.\n+//\n \n use syntax::ast;\n use syntax::ext::base::*;\n@@ -24,66 +23,61 @@ use syntax::tokenstream;\n \n use std::env;\n \n-pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n-                              -> Box<base::MacResult+'cx> {\n+pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt,\n+                              sp: Span,\n+                              tts: &[tokenstream::TokenTree])\n+                              -> Box<base::MacResult + 'cx> {\n     let var = match get_single_str_from_tts(cx, sp, tts, \"option_env!\") {\n         None => return DummyResult::expr(sp),\n-        Some(v) => v\n+        Some(v) => v,\n     };\n \n     let e = match env::var(&var[..]) {\n-      Err(..) => {\n-          cx.expr_path(cx.path_all(sp,\n-                                   true,\n-                                   cx.std_path(&[\"option\", \"Option\", \"None\"]),\n-                                   Vec::new(),\n-                                   vec!(cx.ty_rptr(sp,\n-                                                   cx.ty_ident(sp,\n-                                                        cx.ident_of(\"str\")),\n-                                                   Some(cx.lifetime(sp,\n-                                                        cx.ident_of(\n-                                                            \"'static\").name)),\n-                                                   ast::Mutability::Immutable)),\n-                                   Vec::new()))\n-      }\n-      Ok(s) => {\n-          cx.expr_call_global(sp,\n-                              cx.std_path(&[\"option\", \"Option\", \"Some\"]),\n-                              vec!(cx.expr_str(sp,\n-                                               token::intern_and_get_ident(\n-                                          &s[..]))))\n-      }\n+        Err(..) => {\n+            cx.expr_path(cx.path_all(sp,\n+                                     true,\n+                                     cx.std_path(&[\"option\", \"Option\", \"None\"]),\n+                                     Vec::new(),\n+                                     vec![cx.ty_rptr(sp,\n+                                                     cx.ty_ident(sp, cx.ident_of(\"str\")),\n+                                                     Some(cx.lifetime(sp,\n+                                                                      cx.ident_of(\"'static\")\n+                                                                          .name)),\n+                                                     ast::Mutability::Immutable)],\n+                                     Vec::new()))\n+        }\n+        Ok(s) => {\n+            cx.expr_call_global(sp,\n+                                cx.std_path(&[\"option\", \"Option\", \"Some\"]),\n+                                vec![cx.expr_str(sp, token::intern_and_get_ident(&s[..]))])\n+        }\n     };\n     MacEager::expr(e)\n }\n \n-pub fn expand_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n-                       -> Box<base::MacResult+'cx> {\n+pub fn expand_env<'cx>(cx: &'cx mut ExtCtxt,\n+                       sp: Span,\n+                       tts: &[tokenstream::TokenTree])\n+                       -> Box<base::MacResult + 'cx> {\n     let mut exprs = match get_exprs_from_tts(cx, sp, tts) {\n         Some(ref exprs) if exprs.is_empty() => {\n             cx.span_err(sp, \"env! takes 1 or 2 arguments\");\n             return DummyResult::expr(sp);\n         }\n         None => return DummyResult::expr(sp),\n-        Some(exprs) => exprs.into_iter()\n+        Some(exprs) => exprs.into_iter(),\n     };\n \n-    let var = match expr_to_string(cx,\n-                                exprs.next().unwrap(),\n-                                \"expected string literal\") {\n+    let var = match expr_to_string(cx, exprs.next().unwrap(), \"expected string literal\") {\n         None => return DummyResult::expr(sp),\n-        Some((v, _style)) => v\n+        Some((v, _style)) => v,\n     };\n     let msg = match exprs.next() {\n-        None => {\n-            token::intern_and_get_ident(&format!(\"environment variable `{}` \\\n-                                                 not defined\",\n-                                                var))\n-        }\n+        None => token::intern_and_get_ident(&format!(\"environment variable `{}` not defined\", var)),\n         Some(second) => {\n             match expr_to_string(cx, second, \"expected string literal\") {\n                 None => return DummyResult::expr(sp),\n-                Some((s, _style)) => s\n+                Some((s, _style)) => s,\n             }\n         }\n     };\n@@ -98,7 +92,7 @@ pub fn expand_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[tokenstream::Token\n             cx.span_err(sp, &msg);\n             cx.expr_usize(sp, 0)\n         }\n-        Ok(s) => cx.expr_str(sp, token::intern_and_get_ident(&s))\n+        Ok(s) => cx.expr_str(sp, token::intern_and_get_ident(&s)),\n     };\n     MacEager::expr(e)\n }"}, {"sha": "06b16095d1963bff451224a30393abc37753aa55", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 89, "deletions": 68, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -37,7 +37,7 @@ enum Position {\n     Named(String),\n }\n \n-struct Context<'a, 'b:'a> {\n+struct Context<'a, 'b: 'a> {\n     ecx: &'a mut ExtCtxt<'b>,\n     /// The macro's call site. References to unstable formatting internals must\n     /// use this span to pass the stability checker.\n@@ -120,7 +120,9 @@ struct Context<'a, 'b:'a> {\n /// ```ignore\n /// Some((fmtstr, parsed arguments, index map for named arguments))\n /// ```\n-fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n+fn parse_args(ecx: &mut ExtCtxt,\n+              sp: Span,\n+              tts: &[tokenstream::TokenTree])\n               -> Option<(P<ast::Expr>, Vec<P<ast::Expr>>, HashMap<String, usize>)> {\n     let mut args = Vec::<P<ast::Expr>>::new();\n     let mut names = HashMap::<String, usize>::new();\n@@ -138,7 +140,9 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n             ecx.span_err(sp, \"expected token: `,`\");\n             return None;\n         }\n-        if p.token == token::Eof { break } // accept trailing commas\n+        if p.token == token::Eof {\n+            break;\n+        } // accept trailing commas\n         if named || (p.token.is_ident() && p.look_ahead(1, |t| *t == token::Eq)) {\n             named = true;\n             let ident = match p.token {\n@@ -155,7 +159,7 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n                 _ => {\n                     ecx.span_err(p.span,\n                                  &format!(\"expected ident for named argument, found `{}`\",\n-                                         p.this_token_to_string()));\n+                                          p.this_token_to_string()));\n                     return None;\n                 }\n             };\n@@ -164,9 +168,7 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n             panictry!(p.expect(&token::Eq));\n             let e = panictry!(p.parse_expr());\n             if let Some(prev) = names.get(name) {\n-                ecx.struct_span_err(e.span,\n-                                    &format!(\"duplicate argument named `{}`\",\n-                                             name))\n+                ecx.struct_span_err(e.span, &format!(\"duplicate argument named `{}`\", name))\n                     .span_note(args[*prev].span, \"previously here\")\n                     .emit();\n                 continue;\n@@ -235,7 +237,8 @@ impl<'a, 'b> Context<'a, 'b> {\n \n     fn verify_count(&mut self, c: parse::Count) {\n         match c {\n-            parse::CountImplied | parse::CountIs(..) => {}\n+            parse::CountImplied |\n+            parse::CountIs(..) => {}\n             parse::CountIsParam(i) => {\n                 self.verify_arg_type(Exact(i), Count);\n             }\n@@ -260,7 +263,8 @@ impl<'a, 'b> Context<'a, 'b> {\n             Exact(arg) => {\n                 if self.args.len() <= arg {\n                     let msg = format!(\"invalid reference to argument `{}` ({})\",\n-                                      arg, self.describe_num_args());\n+                                      arg,\n+                                      self.describe_num_args());\n \n                     self.ecx.span_err(self.fmtsp, &msg[..]);\n                     return;\n@@ -394,9 +398,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                                 let arg = self.ecx.expr_usize(sp, i);\n                                 self.ecx.expr_call_global(sp, path, vec![arg])\n                             }\n-                            None => {\n-                                self.ecx.expr_path(self.ecx.path_global(sp, path))\n-                            }\n+                            None => self.ecx.expr_path(self.ecx.path_global(sp, path)),\n                         }\n                     };\n                     match arg.position {\n@@ -436,11 +438,14 @@ impl<'a, 'b> Context<'a, 'b> {\n                         flags: 0,\n                         precision: parse::CountImplied,\n                         width: parse::CountImplied,\n-                        ty: arg.format.ty\n-                    }\n+                        ty: arg.format.ty,\n+                    },\n                 };\n \n-                let fill = match arg.format.fill { Some(c) => c, None => ' ' };\n+                let fill = match arg.format.fill {\n+                    Some(c) => c,\n+                    None => ' ',\n+                };\n \n                 if *arg != simple_arg || fill != ' ' {\n                     self.all_pieces_simple = false;\n@@ -464,17 +469,33 @@ impl<'a, 'b> Context<'a, 'b> {\n                 let prec = self.trans_count(arg.format.precision);\n                 let width = self.trans_count(arg.format.width);\n                 let path = self.ecx.path_global(sp, Context::rtpath(self.ecx, \"FormatSpec\"));\n-                let fmt = self.ecx.expr_struct(sp, path, vec!(\n-                    self.ecx.field_imm(sp, self.ecx.ident_of(\"fill\"), fill),\n-                    self.ecx.field_imm(sp, self.ecx.ident_of(\"align\"), align),\n-                    self.ecx.field_imm(sp, self.ecx.ident_of(\"flags\"), flags),\n-                    self.ecx.field_imm(sp, self.ecx.ident_of(\"precision\"), prec),\n-                    self.ecx.field_imm(sp, self.ecx.ident_of(\"width\"), width)));\n+                let fmt =\n+                    self.ecx.expr_struct(sp,\n+                                         path,\n+                                         vec![self.ecx\n+                                                  .field_imm(sp, self.ecx.ident_of(\"fill\"), fill),\n+                                              self.ecx.field_imm(sp,\n+                                                                 self.ecx.ident_of(\"align\"),\n+                                                                 align),\n+                                              self.ecx.field_imm(sp,\n+                                                                 self.ecx.ident_of(\"flags\"),\n+                                                                 flags),\n+                                              self.ecx.field_imm(sp,\n+                                                                 self.ecx.ident_of(\"precision\"),\n+                                                                 prec),\n+                                              self.ecx.field_imm(sp,\n+                                                                 self.ecx.ident_of(\"width\"),\n+                                                                 width)]);\n \n                 let path = self.ecx.path_global(sp, Context::rtpath(self.ecx, \"Argument\"));\n-                Some(self.ecx.expr_struct(sp, path, vec!(\n-                    self.ecx.field_imm(sp, self.ecx.ident_of(\"position\"), pos),\n-                    self.ecx.field_imm(sp, self.ecx.ident_of(\"format\"), fmt))))\n+                Some(self.ecx.expr_struct(sp,\n+                                          path,\n+                                          vec![self.ecx.field_imm(sp,\n+                                                                  self.ecx.ident_of(\"position\"),\n+                                                                  pos),\n+                                               self.ecx.field_imm(sp,\n+                                                                  self.ecx.ident_of(\"format\"),\n+                                                                  fmt)]))\n             }\n         }\n     }\n@@ -486,9 +507,9 @@ impl<'a, 'b> Context<'a, 'b> {\n                     -> P<ast::Expr> {\n         let sp = piece_ty.span;\n         let ty = ecx.ty_rptr(sp,\n-            ecx.ty(sp, ast::TyKind::Vec(piece_ty)),\n-            Some(ecx.lifetime(sp, keywords::StaticLifetime.name())),\n-            ast::Mutability::Immutable);\n+                             ecx.ty(sp, ast::TyKind::Vec(piece_ty)),\n+                             Some(ecx.lifetime(sp, keywords::StaticLifetime.name())),\n+                             ast::Mutability::Immutable);\n         let slice = ecx.expr_vec_slice(sp, pieces);\n         // static instead of const to speed up codegen by not requiring this to be inlined\n         let st = ast::ItemKind::Static(ty, ast::Mutability::Immutable, slice);\n@@ -516,15 +537,11 @@ impl<'a, 'b> Context<'a, 'b> {\n         // First, build up the static array which will become our precompiled\n         // format \"string\"\n         let static_lifetime = self.ecx.lifetime(self.fmtsp, keywords::StaticLifetime.name());\n-        let piece_ty = self.ecx.ty_rptr(\n-                self.fmtsp,\n-                self.ecx.ty_ident(self.fmtsp, self.ecx.ident_of(\"str\")),\n-                Some(static_lifetime),\n-                ast::Mutability::Immutable);\n-        let pieces = Context::static_array(self.ecx,\n-                                           \"__STATIC_FMTSTR\",\n-                                           piece_ty,\n-                                           self.str_pieces);\n+        let piece_ty = self.ecx.ty_rptr(self.fmtsp,\n+                                        self.ecx.ty_ident(self.fmtsp, self.ecx.ident_of(\"str\")),\n+                                        Some(static_lifetime),\n+                                        ast::Mutability::Immutable);\n+        let pieces = Context::static_array(self.ecx, \"__STATIC_FMTSTR\", piece_ty, self.str_pieces);\n \n         // Before consuming the expressions, we have to remember spans for\n         // count arguments as they are now generated separate from other\n@@ -542,7 +559,10 @@ impl<'a, 'b> Context<'a, 'b> {\n             let name = self.ecx.ident_of(&format!(\"__arg{}\", i));\n             pats.push(self.ecx.pat_ident(DUMMY_SP, name));\n             for ref arg_ty in self.arg_unique_types[i].iter() {\n-                locals.push(Context::format_arg(self.ecx, self.macsp, e.span, arg_ty,\n+                locals.push(Context::format_arg(self.ecx,\n+                                                self.macsp,\n+                                                e.span,\n+                                                arg_ty,\n                                                 self.ecx.expr_ident(e.span, name)));\n             }\n             heads.push(self.ecx.expr_addr_of(e.span, e));\n@@ -556,7 +576,10 @@ impl<'a, 'b> Context<'a, 'b> {\n                 Exact(i) => spans_pos[i],\n                 _ => panic!(\"should never happen\"),\n             };\n-            counts.push(Context::format_arg(self.ecx, self.macsp, span, &Count,\n+            counts.push(Context::format_arg(self.ecx,\n+                                            self.macsp,\n+                                            span,\n+                                            &Count,\n                                             self.ecx.expr_ident(span, name)));\n         }\n \n@@ -593,9 +616,9 @@ impl<'a, 'b> Context<'a, 'b> {\n         // But the nested match expression is proved to perform not as well\n         // as series of let's; the first approach does.\n         let pat = self.ecx.pat_tuple(self.fmtsp, pats);\n-        let arm = self.ecx.arm(self.fmtsp, vec!(pat), args_array);\n+        let arm = self.ecx.arm(self.fmtsp, vec![pat], args_array);\n         let head = self.ecx.expr(self.fmtsp, ast::ExprKind::Tup(heads));\n-        let result = self.ecx.expr_match(self.fmtsp, head, vec!(arm));\n+        let result = self.ecx.expr_match(self.fmtsp, head, vec![arm]);\n \n         let args_slice = self.ecx.expr_addr_of(self.fmtsp, result);\n \n@@ -605,13 +628,9 @@ impl<'a, 'b> Context<'a, 'b> {\n         } else {\n             // Build up the static array which will store our precompiled\n             // nonstandard placeholders, if there are any.\n-            let piece_ty = self.ecx.ty_path(self.ecx.path_global(\n-                    self.macsp,\n-                    Context::rtpath(self.ecx, \"Argument\")));\n-            let fmt = Context::static_array(self.ecx,\n-                                            \"__STATIC_FMTARGS\",\n-                                            piece_ty,\n-                                            self.pieces);\n+            let piece_ty = self.ecx\n+                .ty_path(self.ecx.path_global(self.macsp, Context::rtpath(self.ecx, \"Argument\")));\n+            let fmt = Context::static_array(self.ecx, \"__STATIC_FMTARGS\", piece_ty, self.pieces);\n \n             (\"new_v1_formatted\", vec![pieces, args_slice, fmt])\n         };\n@@ -620,13 +639,16 @@ impl<'a, 'b> Context<'a, 'b> {\n         self.ecx.expr_call_global(self.macsp, path, fn_args)\n     }\n \n-    fn format_arg(ecx: &ExtCtxt, macsp: Span, sp: Span,\n-                  ty: &ArgumentType, arg: P<ast::Expr>)\n+    fn format_arg(ecx: &ExtCtxt,\n+                  macsp: Span,\n+                  sp: Span,\n+                  ty: &ArgumentType,\n+                  arg: P<ast::Expr>)\n                   -> P<ast::Expr> {\n         let trait_ = match *ty {\n             Placeholder(ref tyname) => {\n                 match &tyname[..] {\n-                    \"\"  => \"Display\",\n+                    \"\" => \"Display\",\n                     \"?\" => \"Debug\",\n                     \"e\" => \"LowerExp\",\n                     \"E\" => \"UpperExp\",\n@@ -636,16 +658,14 @@ impl<'a, 'b> Context<'a, 'b> {\n                     \"x\" => \"LowerHex\",\n                     \"X\" => \"UpperHex\",\n                     _ => {\n-                        ecx.span_err(sp,\n-                                     &format!(\"unknown format trait `{}`\",\n-                                             *tyname));\n+                        ecx.span_err(sp, &format!(\"unknown format trait `{}`\", *tyname));\n                         \"Dummy\"\n                     }\n                 }\n             }\n             Count => {\n                 let path = ecx.std_path(&[\"fmt\", \"ArgumentV1\", \"from_usize\"]);\n-                return ecx.expr_call_global(macsp, path, vec![arg])\n+                return ecx.expr_call_global(macsp, path, vec![arg]);\n             }\n         };\n \n@@ -656,22 +676,23 @@ impl<'a, 'b> Context<'a, 'b> {\n     }\n }\n \n-pub fn expand_format_args<'cx>(ecx: &'cx mut ExtCtxt, sp: Span,\n+pub fn expand_format_args<'cx>(ecx: &'cx mut ExtCtxt,\n+                               sp: Span,\n                                tts: &[tokenstream::TokenTree])\n-                               -> Box<base::MacResult+'cx> {\n+                               -> Box<base::MacResult + 'cx> {\n \n     match parse_args(ecx, sp, tts) {\n         Some((efmt, args, names)) => {\n-            MacEager::expr(expand_preparsed_format_args(ecx, sp, efmt,\n-                                                      args, names))\n+            MacEager::expr(expand_preparsed_format_args(ecx, sp, efmt, args, names))\n         }\n-        None => DummyResult::expr(sp)\n+        None => DummyResult::expr(sp),\n     }\n }\n \n /// Take the various parts of `format_args!(efmt, args..., name=names...)`\n /// and construct the appropriate formatting expression.\n-pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n+pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n+                                    sp: Span,\n                                     efmt: P<ast::Expr>,\n                                     args: Vec<P<ast::Expr>>,\n                                     names: HashMap<String, usize>)\n@@ -704,11 +725,9 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n         macsp: macsp,\n         fmtsp: efmt.span,\n     };\n-    let fmt = match expr_to_string(cx.ecx,\n-                                   efmt,\n-                                   \"format argument must be a string literal.\") {\n+    let fmt = match expr_to_string(cx.ecx, efmt, \"format argument must be a string literal.\") {\n         Some((fmt, _)) => fmt,\n-        None => return DummyResult::raw_expr(sp)\n+        None => return DummyResult::raw_expr(sp),\n     };\n \n     let mut parser = parse::Parser::new(&fmt);\n@@ -717,12 +736,14 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n     loop {\n         match parser.next() {\n             Some(mut piece) => {\n-                if !parser.errors.is_empty() { break }\n+                if !parser.errors.is_empty() {\n+                    break;\n+                }\n                 cx.verify_piece(&piece);\n                 cx.resolve_name_inplace(&mut piece);\n                 pieces.push(piece);\n             }\n-            None => break\n+            None => break,\n         }\n     }\n \n@@ -738,8 +759,8 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n     }\n \n     if !parser.errors.is_empty() {\n-        cx.ecx.span_err(cx.fmtsp, &format!(\"invalid format string: {}\",\n-                                          parser.errors.remove(0)));\n+        cx.ecx.span_err(cx.fmtsp,\n+                        &format!(\"invalid format string: {}\", parser.errors.remove(0)));\n         return DummyResult::raw_expr(sp);\n     }\n     if !cx.literal.is_empty() {"}, {"sha": "3aa62339b477efac75e4313fa5fa2b9ce54eb0f7", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -23,7 +23,8 @@\n #![feature(staged_api)]\n \n extern crate fmt_macros;\n-#[macro_use] extern crate log;\n+#[macro_use]\n+extern crate log;\n #[macro_use]\n extern crate syntax;\n extern crate syntax_pos;\n@@ -52,16 +53,13 @@ pub fn register_builtins(env: &mut SyntaxEnv) {\n         NormalTT(Box::new(f), None, false)\n     }\n \n-    env.insert(intern(\"asm\"),\n-               builtin_normal_expander(asm::expand_asm));\n-    env.insert(intern(\"cfg\"),\n-               builtin_normal_expander(cfg::expand_cfg));\n+    env.insert(intern(\"asm\"), builtin_normal_expander(asm::expand_asm));\n+    env.insert(intern(\"cfg\"), builtin_normal_expander(cfg::expand_cfg));\n     env.insert(intern(\"concat\"),\n                builtin_normal_expander(concat::expand_syntax_ext));\n     env.insert(intern(\"concat_idents\"),\n                builtin_normal_expander(concat_idents::expand_syntax_ext));\n-    env.insert(intern(\"env\"),\n-               builtin_normal_expander(env::expand_env));\n+    env.insert(intern(\"env\"), builtin_normal_expander(env::expand_env));\n     env.insert(intern(\"option_env\"),\n                builtin_normal_expander(env::expand_option_env));\n     env.insert(intern(\"format_args\"),"}, {"sha": "7242b9865a92c73e4b634e0090689d6feb856cb1", "filename": "src/libsyntax_ext/log_syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Flibsyntax_ext%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Flibsyntax_ext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flog_syntax.rs?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -17,7 +17,7 @@ use syntax_pos;\n pub fn expand_syntax_ext<'cx>(cx: &'cx mut base::ExtCtxt,\n                               sp: syntax_pos::Span,\n                               tts: &[tokenstream::TokenTree])\n-                              -> Box<base::MacResult+'cx> {\n+                              -> Box<base::MacResult + 'cx> {\n     if !cx.ecfg.enable_log_syntax() {\n         feature_gate::emit_feature_err(&cx.parse_sess.span_diagnostic,\n                                        \"log_syntax\","}, {"sha": "794169ae3429cd9d19c01928fe413dee00af944b", "filename": "src/libsyntax_ext/trace_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Flibsyntax_ext%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Flibsyntax_ext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftrace_macros.rs?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -18,7 +18,7 @@ use syntax::tokenstream::TokenTree;\n pub fn expand_trace_macros(cx: &mut ExtCtxt,\n                            sp: Span,\n                            tt: &[TokenTree])\n-                           -> Box<base::MacResult+'static> {\n+                           -> Box<base::MacResult + 'static> {\n     if !cx.ecfg.enable_trace_macros() {\n         feature_gate::emit_feature_err(&cx.parse_sess.span_diagnostic,\n                                        \"trace_macros\","}, {"sha": "809b3af3bea2a3e3306e52bd8e39d809c398f1b9", "filename": "src/test/compile-fail/E0005.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fcompile-fail%2FE0005.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fcompile-fail%2FE0005.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0005.rs?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -11,4 +11,5 @@\n fn main() {\n     let x = Some(1);\n     let Some(y) = x; //~ ERROR E0005\n+    //~| NOTE pattern `None` not covered\n }"}, {"sha": "74e827b3379a71a085996207cdd0c283479ad686", "filename": "src/test/compile-fail/E0030.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fcompile-fail%2FE0030.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fcompile-fail%2FE0030.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0030.rs?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -11,6 +11,8 @@\n \n fn main() {\n     match 5u32 {\n-        1000 ... 5 => {} //~ ERROR E0030\n+        1000 ... 5 => {}\n+        //~^ ERROR lower range bound must be less than or equal to upper\n+        //~| NOTE lower bound larger than upper bound\n     }\n }"}, {"sha": "fbddb81d7c70be18bbdd6dc437d796b620802f46", "filename": "src/test/compile-fail/E0207.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fcompile-fail%2FE0207.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fcompile-fail%2FE0207.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0207.rs?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -11,7 +11,7 @@\n struct Foo;\n \n impl<T: Default> Foo { //~ ERROR E0207\n-                       //~| NOTE unconstrained lifetime parameter\n+                       //~| NOTE unconstrained type parameter\n     fn get(&self) -> T {\n         <T as Default>::default()\n     }"}, {"sha": "ea5fd6ed4772f044e7603b5e01c41dc239885670", "filename": "src/test/compile-fail/E0365.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fcompile-fail%2FE0365.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fcompile-fail%2FE0365.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0365.rs?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -12,6 +12,9 @@ mod foo {\n     pub const X: u32 = 1;\n }\n \n-pub use foo as foo2; //~ ERROR E0365\n+pub use foo as foo2;\n+//~^ ERROR `foo` is private, and cannot be reexported [E0365]\n+//~| NOTE reexport of private `foo`\n+//~| NOTE consider declaring type or module `foo` with `pub`\n \n fn main() {}"}, {"sha": "29d8e920c4ce767ef0ce81642cc208c14212444b", "filename": "src/test/compile-fail/E0375.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fcompile-fail%2FE0375.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fcompile-fail%2FE0375.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0375.rs?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-tidy-linelength\n+\n #![feature(coerce_unsized)]\n use std::ops::CoerceUnsized;\n \n@@ -17,6 +19,10 @@ struct Foo<T: ?Sized, U: ?Sized> {\n     c: U,\n }\n \n-impl<T, U> CoerceUnsized<Foo<U, T>> for Foo<T, U> {} //~ ERROR E0375\n+impl<T, U> CoerceUnsized<Foo<U, T>> for Foo<T, U> {}\n+//~^ ERROR E0375\n+//~| NOTE requires multiple coercions\n+//~| NOTE `CoerceUnsized` may only be implemented for a coercion between structures with one field being coerced\n+//~| NOTE currently, 2 fields need coercions: b (T to U), c (U to T)\n \n fn main() {}"}, {"sha": "a21e500e519bb4cfb7ded1d34c50b8c5ca26e6f9", "filename": "src/test/compile-fail/E0392.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fcompile-fail%2FE0392.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fcompile-fail%2FE0392.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0392.rs?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n enum Foo<T> { Bar } //~ ERROR E0392\n+                    //~| NOTE unused type parameter\n \n fn main() {\n }"}, {"sha": "e35d038248c8148f39b1a377be151a7fe258f8c5", "filename": "src/test/compile-fail/E0394.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fcompile-fail%2FE0394.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fcompile-fail%2FE0394.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0394.rs?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -9,7 +9,10 @@\n // except according to those terms.\n \n static A: u32 = 0;\n-static B: u32 = A; //~ ERROR E0394\n+static B: u32 = A;\n+//~^ ERROR E0394\n+//~| NOTE referring to another static by value\n+//~| NOTE use the address-of operator or a constant instead\n \n fn main() {\n }"}, {"sha": "e89cc9ea5cbf26b19a7df4503d1a9f318ced1980", "filename": "src/test/compile-fail/E0409.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fcompile-fail%2FE0409.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fcompile-fail%2FE0409.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0409.rs?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -13,7 +13,12 @@ fn main() {\n \n     match x {\n         (0, ref y) | (y, 0) => {} //~ ERROR E0409\n-                                  //~^ ERROR E0308\n+                                  //~^ NOTE bound in different ways\n+                                  //~| NOTE first binding\n+                                  //~| ERROR E0308\n+                                  //~| NOTE expected &{integer}, found integral variable\n+                                  //~| NOTE expected type `&{integer}`\n+                                  //~| NOTE    found type `{integer}`\n         _ => ()\n     }\n }"}, {"sha": "61e96b896a66a58e011222fdd21e06a2353337ad", "filename": "src/test/compile-fail/E0422.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fcompile-fail%2FE0422.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fcompile-fail%2FE0422.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0422.rs?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -9,5 +9,7 @@\n // except according to those terms.\n \n fn main () {\n-    let x = Foo { x: 1, y: 2 }; //~ ERROR E0422\n+    let x = Foo { x: 1, y: 2 };\n+    //~^ ERROR E0422\n+    //~| NOTE not a structure\n }"}, {"sha": "79767e5157b14b34e65a7d341de5c87fa068fb7d", "filename": "src/test/compile-fail/coherence-impls-sized.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-sized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-sized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-sized.rs?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -22,12 +22,15 @@ struct NotSync;\n impl !Sync for NotSync {}\n \n impl Sized for TestE {} //~ ERROR E0322\n+//~^ impl of 'Sized' not allowed\n \n impl Sized for MyType {} //~ ERROR E0322\n+//~^ impl of 'Sized' not allowed\n \n impl Sized for (MyType, MyType) {} //~ ERROR E0117\n \n impl Sized for &'static NotSync {} //~ ERROR E0322\n+//~^ impl of 'Sized' not allowed\n \n impl Sized for [MyType] {} //~ ERROR E0117\n "}, {"sha": "2cf3b66dd77c81ea4930c019da850a6885d914c5", "filename": "src/test/ui/codemap_tests/empty_span.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fui%2Fcodemap_tests%2Fempty_span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fui%2Fcodemap_tests%2Fempty_span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Fempty_span.rs?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// rustc-env:RUST_NEW_ERROR_FORMAT\n #![feature(optin_builtin_traits)]\n fn main() {\n     struct Foo;"}, {"sha": "b33dee6b4a472ed04086888a61d93accf8f11e91", "filename": "src/test/ui/codemap_tests/empty_span.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fui%2Fcodemap_tests%2Fempty_span.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fui%2Fcodemap_tests%2Fempty_span.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Fempty_span.stderr?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -1,7 +1,7 @@\n error[E0321]: cross-crate traits with a default impl, like `std::marker::Send`, can only be implemented for a struct/enum type, not `&'static main::Foo`\n-  --> $DIR/empty_span.rs:18:5\n+  --> $DIR/empty_span.rs:17:5\n    |\n-18 |     unsafe impl Send for &'static Foo { }\n+17 |     unsafe impl Send for &'static Foo { }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error"}, {"sha": "5a058d483915a5f8e28714b75f90f65508ce67ed", "filename": "src/test/ui/codemap_tests/huge_multispan_highlight.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fui%2Fcodemap_tests%2Fhuge_multispan_highlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fui%2Fcodemap_tests%2Fhuge_multispan_highlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Fhuge_multispan_highlight.rs?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// rustc-env:RUST_NEW_ERROR_FORMAT\n-\n fn main() {\n     let x = \"foo\";\n \n@@ -96,9 +94,8 @@ fn main() {\n \n \n \n-\n-    let y = &mut x;\n-}\n \n \n \n+    let y = &mut x;\n+}"}, {"sha": "edbfd72df615fd49723fa6fd6715f38a3a64419c", "filename": "src/test/ui/codemap_tests/huge_multispan_highlight.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fui%2Fcodemap_tests%2Fhuge_multispan_highlight.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fui%2Fcodemap_tests%2Fhuge_multispan_highlight.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Fhuge_multispan_highlight.stderr?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -1,7 +1,7 @@\n error: cannot borrow immutable local variable `x` as mutable\n    --> $DIR/huge_multispan_highlight.rs:100:18\n     |\n-14  |     let x = \"foo\";\n+12  |     let x = \"foo\";\n     |         - use `mut x` here to make mutable\n ...\n 100 |     let y = &mut x;"}, {"sha": "ba1ce6abcd3d4804bdfd160a4a59dcf6b8952078", "filename": "src/test/ui/codemap_tests/issue-11715.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fui%2Fcodemap_tests%2Fissue-11715.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fui%2Fcodemap_tests%2Fissue-11715.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Fissue-11715.rs?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// rustc-env:RUST_NEW_ERROR_FORMAT\n+\n \n \n \n@@ -99,6 +99,3 @@ fn main() {\n     let y = &mut x;\n     let z = &mut x;\n }\n-\n-\n-"}, {"sha": "e50091d56062258fda1fed1da5a8c725196fdcef", "filename": "src/test/ui/codemap_tests/one_line.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fui%2Fcodemap_tests%2Fone_line.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fui%2Fcodemap_tests%2Fone_line.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Fone_line.rs?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// rustc-env:RUST_NEW_ERROR_FORMAT\n-\n fn main() {\n     let mut v = vec![Some(\"foo\"), Some(\"bar\")];\n     v.push(v.pop().unwrap());"}, {"sha": "a73575a8d57f1ae65783eec6492c758db02c3c5c", "filename": "src/test/ui/codemap_tests/one_line.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fui%2Fcodemap_tests%2Fone_line.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fui%2Fcodemap_tests%2Fone_line.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Fone_line.stderr?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -1,7 +1,7 @@\n error[E0499]: cannot borrow `v` as mutable more than once at a time\n-  --> $DIR/one_line.rs:15:12\n+  --> $DIR/one_line.rs:13:12\n    |\n-15 |     v.push(v.pop().unwrap());\n+13 |     v.push(v.pop().unwrap());\n    |     -      ^               - first borrow ends here\n    |     |      |\n    |     |      second mutable borrow occurs here"}, {"sha": "7c1f0db16dd0920e87da2e7a18cbfe10d97decbb", "filename": "src/test/ui/codemap_tests/overlapping_spans.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fui%2Fcodemap_tests%2Foverlapping_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fui%2Fcodemap_tests%2Foverlapping_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Foverlapping_spans.rs?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// rustc-env:RUST_NEW_ERROR_FORMAT\n #[derive(Debug)]\n struct Foo { }\n "}, {"sha": "d32b18d670308c4379da0ed8060db3694a1f1bdd", "filename": "src/test/ui/codemap_tests/overlapping_spans.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fui%2Fcodemap_tests%2Foverlapping_spans.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fui%2Fcodemap_tests%2Foverlapping_spans.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Foverlapping_spans.stderr?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -1,7 +1,7 @@\n error[E0509]: cannot move out of type `S`, which implements the `Drop` trait\n-  --> $DIR/overlapping_spans.rs:22:9\n+  --> $DIR/overlapping_spans.rs:21:9\n    |\n-22 |         S {f:_s} => {}\n+21 |         S {f:_s} => {}\n    |         ^^^^^--^\n    |         |    |\n    |         |    hint: to prevent move, use `ref _s` or `ref mut _s`"}, {"sha": "0672b5508b607f838242eff2ee226481e381d52e", "filename": "src/test/ui/codemap_tests/tab.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fui%2Fcodemap_tests%2Ftab.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fui%2Fcodemap_tests%2Ftab.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Ftab.rs?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -8,9 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// rustc-env:RUST_NEW_ERROR_FORMAT\n // ignore-tidy-tab\n+\n fn main() {\n \tbar;\n }\n-"}, {"sha": "fe5eba93b233115860e6ecb7a65d7104bd44f46d", "filename": "src/test/ui/codemap_tests/two_files.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files.rs?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// rustc-env:RUST_NEW_ERROR_FORMAT\n include!(\"two_files_data.rs\");\n \n struct Baz { }"}, {"sha": "d58e7148f6104025a40004e386bb4f72c77c90d9", "filename": "src/test/ui/codemap_tests/two_files.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files.stderr?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -1,7 +1,7 @@\n error[E0404]: `Bar` is not a trait\n-  --> $DIR/two_files.rs:16:6\n+  --> $DIR/two_files.rs:15:6\n    |\n-16 | impl Bar for Baz { }\n+15 | impl Bar for Baz { }\n    |      ^^^ not a trait\n    |\n    = note: type aliases cannot be used for traits"}, {"sha": "a3dcea0546d388a6b258b1b3b3018b934fa47afd", "filename": "src/test/ui/codemap_tests/two_files_data.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files_data.rs?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -8,9 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// rustc-env:RUST_NEW_ERROR_FORMAT\n // ignore-test\n+\n trait Foo { }\n \n type Bar = Foo;\n-"}, {"sha": "b206722d4f36887c6f94f937b2a5256e1bf27851", "filename": "src/test/ui/codemap_tests/unicode.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fui%2Fcodemap_tests%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fui%2Fcodemap_tests%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Funicode.rs?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// rustc-env:RUST_NEW_ERROR_FORMAT\n extern \"\u8def\u6feb\u72fc\u00e1\u0301\u0301\" fn foo() {}\n \n fn main() { }"}, {"sha": "aa42ae341c54542e20508839e372ce1690b5ff29", "filename": "src/test/ui/codemap_tests/unicode.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fui%2Fcodemap_tests%2Funicode.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fui%2Fcodemap_tests%2Funicode.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Funicode.stderr?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -1,7 +1,7 @@\n error: invalid ABI: expected one of [cdecl, stdcall, fastcall, vectorcall, aapcs, win64, Rust, C, system, rust-intrinsic, rust-call, platform-intrinsic], found `\u8def\u6feb\u72fc\u00e1\u0301\u0301`\n-  --> $DIR/unicode.rs:12:8\n+  --> $DIR/unicode.rs:11:8\n    |\n-12 | extern \"\u8def\u6feb\u72fc\u00e1\u0301\u0301\" fn foo() {}\n+11 | extern \"\u8def\u6feb\u72fc\u00e1\u0301\u0301\" fn foo() {}\n    |        ^^^^^^^^\n \n error: aborting due to previous error"}, {"sha": "f842627e76fee1fbe5ceff7249204cf3d063e9f5", "filename": "src/test/ui/mismatched_types/issue-26480.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-26480.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-26480.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-26480.rs?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// rustc-env:RUST_NEW_ERROR_FORMAT\n extern {\n     fn write(fildes: i32, buf: *const i8, nbyte: u64) -> i64;\n }"}, {"sha": "13f23a5d01ac1aea63c45eddc76abd776f139b2b", "filename": "src/test/ui/mismatched_types/issue-26480.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-26480.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-26480.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-26480.stderr?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -1,16 +1,16 @@\n error[E0308]: mismatched types\n-  --> $DIR/issue-26480.rs:27:19\n+  --> $DIR/issue-26480.rs:26:19\n    |\n-27 |                   $arr.len() * size_of($arr[0]));\n+26 |                   $arr.len() * size_of($arr[0]));\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected u64, found usize\n-$DIR/issue-26480.rs:38:5: 38:19 note: in this expansion of write! (defined in $DIR/issue-26480.rs)\n+$DIR/issue-26480.rs:37:5: 37:19 note: in this expansion of write! (defined in $DIR/issue-26480.rs)\n \n error: non-scalar cast: `{integer}` as `()`\n-  --> $DIR/issue-26480.rs:33:19\n+  --> $DIR/issue-26480.rs:32:19\n    |\n-33 |     ($x:expr) => ($x as ())\n+32 |     ($x:expr) => ($x as ())\n    |                   ^^^^^^^^\n-$DIR/issue-26480.rs:39:5: 39:14 note: in this expansion of cast! (defined in $DIR/issue-26480.rs)\n+$DIR/issue-26480.rs:38:5: 38:14 note: in this expansion of cast! (defined in $DIR/issue-26480.rs)\n \n error: aborting due to 2 previous errors\n "}, {"sha": "f7f1c78c3ba0d47365091484147002d916989a60", "filename": "src/test/ui/mismatched_types/main.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fui%2Fmismatched_types%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fui%2Fmismatched_types%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fmain.rs?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// rustc-env:RUST_NEW_ERROR_FORMAT\n-\n fn main() {\n     let x: u32 = (\n     );"}, {"sha": "9e26be6fdddeb1021d9d5979a88326753b3f3daf", "filename": "src/test/ui/mismatched_types/main.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fui%2Fmismatched_types%2Fmain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fui%2Fmismatched_types%2Fmain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fmain.stderr?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -1,7 +1,7 @@\n error[E0308]: mismatched types\n-  --> $DIR/main.rs:14:18\n+  --> $DIR/main.rs:12:18\n    |\n-14 |     let x: u32 = (\n+12 |     let x: u32 = (\n    |                  ^ expected u32, found ()\n    |\n    = note: expected type `u32`"}, {"sha": "e11ef0dddaa94bf761f9f9a7b57906733836d02d", "filename": "src/test/ui/span/move-closure.rs", "status": "renamed", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fui%2Fspan%2Fmove-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fui%2Fspan%2Fmove-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmove-closure.rs?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -8,10 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// Regression test for issue #24986\n // Make sure that the span of a closure marked `move` begins at the `move` keyword.\n \n fn main() {\n-    let x: () =\n-    move //~ ERROR mismatched types\n-    || ();\n+    let x: () = move || ();\n }", "previous_filename": "src/test/compile-fail/move-closure-span.rs"}, {"sha": "251feded167d84cd8c82ab60d189c7bbefa88fdf", "filename": "src/test/ui/span/move-closure.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fui%2Fspan%2Fmove-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fui%2Fspan%2Fmove-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmove-closure.stderr?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -0,0 +1,11 @@\n+error[E0308]: mismatched types\n+  --> $DIR/move-closure.rs:15:17\n+   |\n+15 |     let x: () = move || ();\n+   |                 ^^^^^^^^^^ expected (), found closure\n+   |\n+   = note: expected type `()`\n+   = note:    found type `[closure@$DIR/move-closure.rs:15:17: 15:27]`\n+\n+error: aborting due to previous error\n+"}, {"sha": "05285c732f41430436a2a406a3c3889d8f2d0d55", "filename": "src/test/ui/span/type-binding.rs", "status": "renamed", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fui%2Fspan%2Ftype-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fui%2Fspan%2Ftype-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Ftype-binding.rs?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -8,13 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// Regression test for issue #28158\n // Test the type binding span doesn't include >>\n \n use std::ops::Deref;\n \n-fn homura<T: Deref<Trget=i32 //~ ERROR associated type\n->>(_: T) { }\n+fn homura<T: Deref<Trget = i32>>(_: T) {}\n \n-\n-fn main() {\n-}\n+fn main() {}", "previous_filename": "src/test/compile-fail/ty_binding_span.rs"}, {"sha": "3cd1791a34ff7233cf05d598bfede1f5d3b29d6d", "filename": "src/test/ui/span/type-binding.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fui%2Fspan%2Ftype-binding.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ac11cad3fe85163dd8b0ca1f63af492509f9bfe/src%2Ftest%2Fui%2Fspan%2Ftype-binding.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Ftype-binding.stderr?ref=7ac11cad3fe85163dd8b0ca1f63af492509f9bfe", "patch": "@@ -0,0 +1,8 @@\n+error[E0220]: associated type `Trget` not found for `std::ops::Deref`\n+  --> $DIR/type-binding.rs:16:20\n+   |\n+16 | fn homura<T: Deref<Trget = i32>>(_: T) {}\n+   |                    ^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}]}