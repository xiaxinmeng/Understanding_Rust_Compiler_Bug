{"sha": "dd4112bf7924767a6074b54ffe297c877f8b042d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkNDExMmJmNzkyNDc2N2E2MDc0YjU0ZmZlMjk3Yzg3N2Y4YjA0MmQ=", "commit": {"author": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2014-07-05T19:47:14Z"}, "committer": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2014-07-06T20:12:10Z"}, "message": "Store booleans as i8 in memory to improve optimizations by LLVM\n\nLLVM doesn't really like types with a bit-width that isn't a multiple of\n8 and disable various optimizations if it encounters such types used\nwith loads/stores. OTOH, booleans must be represented as i1 when used as\nSSA values. To get the best results, we must use i1 for SSA values, and\ni8 when storing the value to memory.\n\nBy using range asserts on loads, LLVM can eliminate the required\nzero-extend and truncate operations.\n\nFixes #15203", "tree": {"sha": "1ee8151258b14b8549e74eec275bf88bab446ae7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ee8151258b14b8549e74eec275bf88bab446ae7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dd4112bf7924767a6074b54ffe297c877f8b042d", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dd4112bf7924767a6074b54ffe297c877f8b042d", "html_url": "https://github.com/rust-lang/rust/commit/dd4112bf7924767a6074b54ffe297c877f8b042d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dd4112bf7924767a6074b54ffe297c877f8b042d/comments", "author": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d2a22f520c73d26730f9159e1ce1b6058c2287dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2a22f520c73d26730f9159e1ce1b6058c2287dd", "html_url": "https://github.com/rust-lang/rust/commit/d2a22f520c73d26730f9159e1ce1b6058c2287dd"}], "stats": {"total": 180, "additions": 115, "deletions": 65}, "files": [{"sha": "f7fb6646938fdd706b38ead1ec2f9f9cac7b5fb4", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd4112bf7924767a6074b54ffe297c877f8b042d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd4112bf7924767a6074b54ffe297c877f8b042d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=dd4112bf7924767a6074b54ffe297c877f8b042d", "patch": "@@ -641,7 +641,7 @@ pub fn trans_start_init(bcx: &Block, r: &Repr, val: ValueRef, discr: Disr) {\n         }\n         Univariant(ref st, true) => {\n             assert_eq!(discr, 0);\n-            Store(bcx, C_bool(bcx.ccx(), true),\n+            Store(bcx, C_u8(bcx.ccx(), 1),\n                   GEPi(bcx, val, [0, st.fields.len() - 1]))\n         }\n         Univariant(..) => {"}, {"sha": "3eaa17a05712f1547fb70ae16eb544998c727b78", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 49, "deletions": 9, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/dd4112bf7924767a6074b54ffe297c877f8b042d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd4112bf7924767a6074b54ffe297c877f8b042d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=dd4112bf7924767a6074b54ffe297c877f8b042d", "patch": "@@ -959,10 +959,42 @@ pub fn need_invoke(bcx: &Block) -> bool {\n \n pub fn load_if_immediate(cx: &Block, v: ValueRef, t: ty::t) -> ValueRef {\n     let _icx = push_ctxt(\"load_if_immediate\");\n-    if type_is_immediate(cx.ccx(), t) { return Load(cx, v); }\n+    if type_is_immediate(cx.ccx(), t) { return load_ty(cx, v, t); }\n     return v;\n }\n \n+pub fn load_ty(cx: &Block, ptr: ValueRef, t: ty::t) -> ValueRef {\n+    /*!\n+     * Helper for loading values from memory. Does the necessary conversion if\n+     * the in-memory type differs from the type used for SSA values. Also\n+     * handles various special cases where the type gives us better information\n+     * about what we are loading.\n+     */\n+    if type_is_zero_size(cx.ccx(), t) {\n+        C_undef(type_of::type_of(cx.ccx(), t))\n+    } else if ty::type_is_bool(t) {\n+        Trunc(cx, LoadRangeAssert(cx, ptr, 0, 2, lib::llvm::False), Type::i1(cx.ccx()))\n+    } else if ty::type_is_char(t) {\n+        // a char is a unicode codepoint, and so takes values from 0\n+        // to 0x10FFFF inclusive only.\n+        LoadRangeAssert(cx, ptr, 0, 0x10FFFF + 1, lib::llvm::False)\n+    } else {\n+        Load(cx, ptr)\n+    }\n+}\n+\n+pub fn store_ty(cx: &Block, v: ValueRef, dst: ValueRef, t: ty::t) {\n+    /*!\n+     * Helper for storing values in memory. Does the necessary conversion if\n+     * the in-memory type differs from the type used for SSA values.\n+     */\n+    if ty::type_is_bool(t) {\n+        Store(cx, ZExt(cx, v, Type::i8(cx.ccx())), dst);\n+    } else {\n+        Store(cx, v, dst);\n+    };\n+}\n+\n pub fn ignore_lhs(_bcx: &Block, local: &ast::Local) -> bool {\n     match local.pat.node {\n         ast::PatWild => true, _ => false\n@@ -1285,9 +1317,14 @@ fn copy_args_to_allocas<'a>(fcx: &FunctionContext<'a>,\n // Ties up the llstaticallocas -> llloadenv -> lltop edges,\n // and builds the return block.\n pub fn finish_fn<'a>(fcx: &'a FunctionContext<'a>,\n-                     last_bcx: &'a Block<'a>) {\n+                     last_bcx: &'a Block<'a>,\n+                     retty: ty::t) {\n     let _icx = push_ctxt(\"finish_fn\");\n \n+    // This shouldn't need to recompute the return type,\n+    // as new_fn_ctxt did it already.\n+    let substd_retty = retty.substp(fcx.ccx.tcx(), fcx.param_substs);\n+\n     let ret_cx = match fcx.llreturn.get() {\n         Some(llreturn) => {\n             if !last_bcx.terminated.get() {\n@@ -1297,13 +1334,13 @@ pub fn finish_fn<'a>(fcx: &'a FunctionContext<'a>,\n         }\n         None => last_bcx\n     };\n-    build_return_block(fcx, ret_cx);\n+    build_return_block(fcx, ret_cx, substd_retty);\n     debuginfo::clear_source_location(fcx);\n     fcx.cleanup();\n }\n \n // Builds the return block for a function.\n-pub fn build_return_block(fcx: &FunctionContext, ret_cx: &Block) {\n+pub fn build_return_block(fcx: &FunctionContext, ret_cx: &Block, retty: ty::t) {\n     // Return the value if this function immediate; otherwise, return void.\n     if fcx.llretptr.get().is_none() || fcx.caller_expects_out_pointer {\n         return RetVoid(ret_cx);\n@@ -1321,13 +1358,16 @@ pub fn build_return_block(fcx: &FunctionContext, ret_cx: &Block) {\n                 retptr.erase_from_parent();\n             }\n \n-            retval\n+            if ty::type_is_bool(retty) {\n+                Trunc(ret_cx, retval, Type::i1(fcx.ccx))\n+            } else {\n+                retval\n+            }\n         }\n         // Otherwise, load the return value from the ret slot\n-        None => Load(ret_cx, fcx.llretptr.get().unwrap())\n+        None => load_ty(ret_cx, fcx.llretptr.get().unwrap(), retty)\n     };\n \n-\n     Ret(ret_cx, retval);\n }\n \n@@ -1429,7 +1469,7 @@ pub fn trans_closure(ccx: &CrateContext,\n     }\n \n     // Insert the mandatory first few basic blocks before lltop.\n-    finish_fn(&fcx, bcx);\n+    finish_fn(&fcx, bcx, output_type);\n }\n \n // trans_fn: creates an LLVM function corresponding to a source language\n@@ -1521,7 +1561,7 @@ fn trans_enum_variant_or_tuple_like_struct(ccx: &CrateContext,\n         }\n     }\n \n-    finish_fn(&fcx, bcx);\n+    finish_fn(&fcx, bcx, result_ty);\n }\n \n fn trans_enum_def(ccx: &CrateContext, enum_definition: &ast::EnumDef,"}, {"sha": "c44a4e02ad462a5be8ef51d67934634776880a49", "filename": "src/librustc/middle/trans/cabi_arm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dd4112bf7924767a6074b54ffe297c877f8b042d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd4112bf7924767a6074b54ffe297c877f8b042d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs?ref=dd4112bf7924767a6074b54ffe297c877f8b042d", "patch": "@@ -85,7 +85,7 @@ fn ty_size(ty: Type) -> uint {\n \n fn classify_ret_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n     if is_reg_ty(ty) {\n-        let attr = if ty == Type::bool(ccx) { Some(ZExtAttribute) } else { None };\n+        let attr = if ty == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n         return ArgType::direct(ty, None, None, attr);\n     }\n     let size = ty_size(ty);\n@@ -104,7 +104,7 @@ fn classify_ret_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n \n fn classify_arg_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n     if is_reg_ty(ty) {\n-        let attr = if ty == Type::bool(ccx) { Some(ZExtAttribute) } else { None };\n+        let attr = if ty == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n         return ArgType::direct(ty, None, None, attr);\n     }\n     let align = ty_align(ty);"}, {"sha": "9e5b38d2f7ddb4b468505c78b676bc73d5e9bb67", "filename": "src/librustc/middle/trans/cabi_mips.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dd4112bf7924767a6074b54ffe297c877f8b042d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd4112bf7924767a6074b54ffe297c877f8b042d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs?ref=dd4112bf7924767a6074b54ffe297c877f8b042d", "patch": "@@ -85,7 +85,7 @@ fn ty_size(ty: Type) -> uint {\n \n fn classify_ret_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n     if is_reg_ty(ty) {\n-        let attr = if ty == Type::bool(ccx) { Some(ZExtAttribute) } else { None };\n+        let attr = if ty == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n         ArgType::direct(ty, None, None, attr)\n     } else {\n         ArgType::indirect(ty, Some(StructRetAttribute))\n@@ -102,7 +102,7 @@ fn classify_arg_ty(ccx: &CrateContext, ty: Type, offset: &mut uint) -> ArgType {\n     *offset += align_up_to(size, align * 8) / 8;\n \n     if is_reg_ty(ty) {\n-        let attr = if ty == Type::bool(ccx) { Some(ZExtAttribute) } else { None };\n+        let attr = if ty == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n         ArgType::direct(ty, None, None, attr)\n     } else {\n         ArgType::direct("}, {"sha": "0d88c611cbaede78a0a996f6eee4d6f34bc78573", "filename": "src/librustc/middle/trans/cabi_x86.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dd4112bf7924767a6074b54ffe297c877f8b042d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd4112bf7924767a6074b54ffe297c877f8b042d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs?ref=dd4112bf7924767a6074b54ffe297c877f8b042d", "patch": "@@ -59,7 +59,7 @@ pub fn compute_abi_info(ccx: &CrateContext,\n             }\n         }\n     } else {\n-        let attr = if rty == Type::bool(ccx) { Some(ZExtAttribute) } else { None };\n+        let attr = if rty == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n         ret_ty = ArgType::direct(rty, None, None, attr);\n     }\n \n@@ -74,7 +74,7 @@ pub fn compute_abi_info(ccx: &CrateContext,\n                 }\n             }\n             _ => {\n-                let attr = if t == Type::bool(ccx) { Some(ZExtAttribute) } else { None };\n+                let attr = if t == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n                 ArgType::direct(t, None, None, attr)\n             }\n         };"}, {"sha": "5b8ddfe1be7bf707d09dcdd1e9736cc53d40bc57", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd4112bf7924767a6074b54ffe297c877f8b042d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd4112bf7924767a6074b54ffe297c877f8b042d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=dd4112bf7924767a6074b54ffe297c877f8b042d", "patch": "@@ -350,7 +350,7 @@ pub fn compute_abi_info(ccx: &CrateContext,\n                                 None)\n             }\n         } else {\n-            let attr = if ty == Type::bool(ccx) { Some(ZExtAttribute) } else { None };\n+            let attr = if ty == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n             ArgType::direct(ty, None, None, attr)\n         }\n     }"}, {"sha": "37b9da738e158ed2d9b27e18ecad3eca7d10542f", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dd4112bf7924767a6074b54ffe297c877f8b042d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd4112bf7924767a6074b54ffe297c877f8b042d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=dd4112bf7924767a6074b54ffe297c877f8b042d", "patch": "@@ -346,7 +346,7 @@ pub fn trans_unboxing_shim(bcx: &Block,\n                            }).bcx;\n \n     bcx = fcx.pop_and_trans_custom_cleanup_scope(bcx, arg_scope);\n-    finish_fn(&fcx, bcx);\n+    finish_fn(&fcx, bcx, return_type);\n \n     llfn\n }\n@@ -758,7 +758,7 @@ pub fn trans_call_inner<'a>(\n                 if !type_of::return_uses_outptr(bcx.ccx(), ret_ty) &&\n                     !type_is_zero_size(bcx.ccx(), ret_ty)\n                 {\n-                    Store(bcx, llret, llretslot);\n+                    store_ty(bcx, llret, llretslot, ret_ty)\n                 }\n             }\n             None => {}"}, {"sha": "b93469ad2fba330a9315f428641a9ab383d47407", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 4, "deletions": 24, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/dd4112bf7924767a6074b54ffe297c877f8b042d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd4112bf7924767a6074b54ffe297c877f8b042d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=dd4112bf7924767a6074b54ffe297c877f8b042d", "patch": "@@ -13,10 +13,8 @@\n  * Datums are and how they are intended to be used.\n  */\n \n-use lib;\n use lib::llvm::ValueRef;\n use middle::trans::base::*;\n-use middle::trans::build::*;\n use middle::trans::common::*;\n use middle::trans::cleanup;\n use middle::trans::cleanup::CleanupMethods;\n@@ -344,7 +342,7 @@ impl Datum<Rvalue> {\n                 match self.kind.mode {\n                     ByValue => DatumBlock::new(bcx, self),\n                     ByRef => {\n-                        let llval = load(bcx, self.val, self.ty);\n+                        let llval = load_ty(bcx, self.val, self.ty);\n                         DatumBlock::new(bcx, Datum::new(llval, self.ty, Rvalue::new(ByValue)))\n                     }\n                 }\n@@ -471,7 +469,7 @@ impl Datum<Expr> {\n                         DatumBlock::new(bcx, scratch)\n                     }\n                     ByValue => {\n-                        let v = load(bcx, l.val, l.ty);\n+                        let v = load_ty(bcx, l.val, l.ty);\n                         bcx = l.kind.post_store(bcx, l.val, l.ty);\n                         DatumBlock::new(bcx, Datum::new(v, l.ty, Rvalue::new(ByValue)))\n                     }\n@@ -516,24 +514,6 @@ impl Datum<Lvalue> {\n     }\n }\n \n-fn load<'a>(bcx: &'a Block<'a>, llptr: ValueRef, ty: ty::t) -> ValueRef {\n-    /*!\n-     * Private helper for loading from a by-ref datum. Handles various\n-     * special cases where the type gives us better information about\n-     * what we are loading.\n-     */\n-\n-    if type_is_zero_size(bcx.ccx(), ty) {\n-        C_undef(type_of::type_of(bcx.ccx(), ty))\n-    } else if ty::type_is_char(ty) {\n-        // a char is a unicode codepoint, and so takes values from 0\n-        // to 0x10FFFF inclusive only.\n-        LoadRangeAssert(bcx, llptr, 0, 0x10FFFF + 1, lib::llvm::False)\n-    } else {\n-        Load(bcx, llptr)\n-    }\n-}\n-\n /**\n  * Generic methods applicable to any sort of datum.\n  */\n@@ -591,7 +571,7 @@ impl<K:KindOps> Datum<K> {\n         if self.kind.is_by_ref() {\n             memcpy_ty(bcx, dst, self.val, self.ty);\n         } else {\n-            Store(bcx, self.val, dst);\n+            store_ty(bcx, self.val, dst, self.ty);\n         }\n \n         return bcx;\n@@ -642,7 +622,7 @@ impl<K:KindOps> Datum<K> {\n         assert!(!ty::type_needs_drop(bcx.tcx(), self.ty));\n         assert!(self.appropriate_rvalue_mode(bcx.ccx()) == ByValue);\n         if self.kind.is_by_ref() {\n-            load(bcx, self.val, self.ty)\n+            load_ty(bcx, self.val, self.ty)\n         } else {\n             self.val\n         }"}, {"sha": "ac33f9bd1a87d44938c41dba00b424570e6dd910", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dd4112bf7924767a6074b54ffe297c877f8b042d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd4112bf7924767a6074b54ffe297c877f8b042d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=dd4112bf7924767a6074b54ffe297c877f8b042d", "patch": "@@ -1374,7 +1374,7 @@ fn trans_lazy_binop<'a>(\n     }\n \n     Br(past_rhs, join.llbb);\n-    let phi = Phi(join, Type::bool(bcx.ccx()), [lhs, rhs],\n+    let phi = Phi(join, Type::i1(bcx.ccx()), [lhs, rhs],\n                   [past_lhs.llbb, past_rhs.llbb]);\n \n     return immediate_rvalue_bcx(join, phi, binop_ty).to_expr_datumblock();\n@@ -1591,8 +1591,8 @@ fn trans_imm_cast<'a>(bcx: &'a Block<'a>,\n     let k_in = cast_type_kind(t_in);\n     let k_out = cast_type_kind(t_out);\n     let s_in = k_in == cast_integral && ty::type_is_signed(t_in);\n-    let ll_t_in = type_of::type_of(ccx, t_in);\n-    let ll_t_out = type_of::type_of(ccx, t_out);\n+    let ll_t_in = type_of::arg_type_of(ccx, t_in);\n+    let ll_t_out = type_of::arg_type_of(ccx, t_out);\n \n     // Convert the value to be cast into a ValueRef, either by-ref or\n     // by-value as appropriate given its type:\n@@ -1683,7 +1683,7 @@ fn trans_assign_op<'a>(\n     let dst_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, dst, \"assign_op\"));\n     assert!(!ty::type_needs_drop(bcx.tcx(), dst_datum.ty));\n     let dst_ty = dst_datum.ty;\n-    let dst = Load(bcx, dst_datum.val);\n+    let dst = load_ty(bcx, dst_datum.val, dst_datum.ty);\n \n     // Evaluate RHS\n     let rhs_datum = unpack_datum!(bcx, trans(bcx, &*src));"}, {"sha": "4e009622b0eb2c532c346b75bbb09725693e9b9a", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/dd4112bf7924767a6074b54ffe297c877f8b042d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd4112bf7924767a6074b54ffe297c877f8b042d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=dd4112bf7924767a6074b54ffe297c877f8b042d", "patch": "@@ -325,7 +325,7 @@ pub fn trans_native_call<'a>(\n                 base::alloca(bcx,\n                              type_of::type_of(ccx, *passed_arg_tys.get(i)),\n                              \"__arg\");\n-            Store(bcx, llarg_rust, scratch);\n+            base::store_ty(bcx, llarg_rust, scratch, *passed_arg_tys.get(i));\n             llarg_rust = scratch;\n         }\n \n@@ -346,7 +346,12 @@ pub fn trans_native_call<'a>(\n         let llarg_foreign = if foreign_indirect {\n             llarg_rust\n         } else {\n-            Load(bcx, llarg_rust)\n+            if ty::type_is_bool(*passed_arg_tys.get(i)) {\n+                let val = LoadRangeAssert(bcx, llarg_rust, 0, 2, lib::llvm::False);\n+                Trunc(bcx, val, Type::i1(bcx.ccx()))\n+            } else {\n+                Load(bcx, llarg_rust)\n+            }\n         };\n \n         debug!(\"argument {}, llarg_foreign={}\",\n@@ -431,7 +436,7 @@ pub fn trans_native_call<'a>(\n         debug!(\"llforeign_ret_ty={}\", ccx.tn.type_to_str(llforeign_ret_ty));\n \n         if llrust_ret_ty == llforeign_ret_ty {\n-            Store(bcx, llforeign_retval, llretptr);\n+            base::store_ty(bcx, llforeign_retval, llretptr, fn_sig.output)\n         } else {\n             // The actual return type is a struct, but the ABI\n             // adaptation code has cast it into some scalar type.  The\n@@ -715,9 +720,15 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n             // pointer).  It makes adapting types easier, since we can\n             // always just bitcast pointers.\n             if !foreign_indirect {\n-                let lltemp = builder.alloca(val_ty(llforeign_arg), \"\");\n-                builder.store(llforeign_arg, lltemp);\n-                llforeign_arg = lltemp;\n+                llforeign_arg = if ty::type_is_bool(rust_ty) {\n+                    let lltemp = builder.alloca(Type::bool(ccx), \"\");\n+                    builder.store(builder.zext(llforeign_arg, Type::bool(ccx)), lltemp);\n+                    lltemp\n+                } else {\n+                    let lltemp = builder.alloca(val_ty(llforeign_arg), \"\");\n+                    builder.store(llforeign_arg, lltemp);\n+                    lltemp\n+                }\n             }\n \n             // If the types in the ABI and the Rust types don't match,\n@@ -731,7 +742,12 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n             let llrust_arg = if rust_indirect {\n                 llforeign_arg\n             } else {\n-                builder.load(llforeign_arg)\n+                if ty::type_is_bool(rust_ty) {\n+                    let tmp = builder.load_range_assert(llforeign_arg, 0, 2, lib::llvm::False);\n+                    builder.trunc(tmp, Type::i1(ccx))\n+                } else {\n+                    builder.load(llforeign_arg)\n+                }\n             };\n \n             debug!(\"llrust_arg {}{}: {}\", \"#\",\n@@ -828,8 +844,8 @@ fn foreign_signature(ccx: &CrateContext, fn_sig: &ty::FnSig, arg_tys: &[ty::t])\n      * values by pointer like we do.\n      */\n \n-    let llarg_tys = arg_tys.iter().map(|&arg| type_of(ccx, arg)).collect();\n-    let llret_ty = type_of::type_of(ccx, fn_sig.output);\n+    let llarg_tys = arg_tys.iter().map(|&arg| arg_type_of(ccx, arg)).collect();\n+    let llret_ty = type_of::arg_type_of(ccx, fn_sig.output);\n     LlvmSignature {\n         llarg_tys: llarg_tys,\n         llret_ty: llret_ty"}, {"sha": "d3552baa7925d24e44675db4fad0b5e08e6b7489", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dd4112bf7924767a6074b54ffe297c877f8b042d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd4112bf7924767a6074b54ffe297c877f8b042d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=dd4112bf7924767a6074b54ffe297c877f8b042d", "patch": "@@ -234,7 +234,7 @@ fn trans_struct_drop_flag<'a>(bcx: &'a Block<'a>,\n                               -> &'a Block<'a> {\n     let repr = adt::represent_type(bcx.ccx(), t);\n     let drop_flag = adt::trans_drop_flag_ptr(bcx, &*repr, v0);\n-    with_cond(bcx, Load(bcx, drop_flag), |cx| {\n+    with_cond(bcx, load_ty(bcx, drop_flag, ty::mk_bool()), |cx| {\n         trans_struct_drop(cx, t, v0, dtor_did, class_did, substs)\n     })\n }\n@@ -505,7 +505,7 @@ fn make_generic_glue(ccx: &CrateContext,\n     let bcx = fcx.entry_bcx.borrow().clone().unwrap();\n     let llrawptr0 = unsafe { llvm::LLVMGetParam(llfn, fcx.arg_pos(0) as c_uint) };\n     let bcx = helper(bcx, llrawptr0, t);\n-    finish_fn(&fcx, bcx);\n+    finish_fn(&fcx, bcx, ty::mk_nil());\n \n     llfn\n }"}, {"sha": "c5ce61ed122ba8436f4f7194a2f215f48370b721", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dd4112bf7924767a6074b54ffe297c877f8b042d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd4112bf7924767a6074b54ffe297c877f8b042d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=dd4112bf7924767a6074b54ffe297c877f8b042d", "patch": "@@ -96,13 +96,19 @@ pub fn trans_intrinsic(ccx: &CrateContext,\n         let b = get_param(bcx.fcx.llfn, first_real_arg + 1);\n         let llfn = bcx.ccx().get_intrinsic(&name);\n \n+        // convert `i1` to a `bool`, and write to the out parameter\n         let val = Call(bcx, llfn, [a, b], []);\n+        let result = ExtractValue(bcx, val, 0);\n+        let overflow = ZExt(bcx, ExtractValue(bcx, val, 1), Type::bool(bcx.ccx()));\n+        let ret = C_undef(type_of::type_of(bcx.ccx(), t));\n+        let ret = InsertValue(bcx, ret, result, 0);\n+        let ret = InsertValue(bcx, ret, overflow, 1);\n \n         if type_is_immediate(bcx.ccx(), t) {\n-            Ret(bcx, val);\n+            Ret(bcx, ret);\n         } else {\n             let retptr = get_param(bcx.fcx.llfn, bcx.fcx.out_arg_pos());\n-            Store(bcx, val, retptr);\n+            Store(bcx, ret, retptr);\n             RetVoid(bcx);\n         }\n     }\n@@ -367,7 +373,7 @@ pub fn trans_intrinsic(ccx: &CrateContext,\n             let retty = *substs.substs.types.get(FnSpace, 0);\n             if type_is_immediate(ccx, retty) && !return_type_is_void(ccx, retty) {\n                 unsafe {\n-                    Ret(bcx, lib::llvm::llvm::LLVMGetUndef(type_of(ccx, retty).to_ref()));\n+                    Ret(bcx, lib::llvm::llvm::LLVMGetUndef(arg_type_of(ccx, retty).to_ref()));\n                 }\n             } else {\n                 RetVoid(bcx)"}, {"sha": "87a730dbc790fc6bb8ebd1db23063cb873db7a58", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd4112bf7924767a6074b54ffe297c877f8b042d/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd4112bf7924767a6074b54ffe297c877f8b042d/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=dd4112bf7924767a6074b54ffe297c877f8b042d", "patch": "@@ -331,7 +331,7 @@ impl<'a, 'b> Reflector<'a, 'b> {\n                     Some(llreturn) => Br(bcx, llreturn),\n                     None => {}\n                 };\n-                finish_fn(&fcx, bcx);\n+                finish_fn(&fcx, bcx, ty::mk_u64());\n                 llfdecl\n             };\n "}, {"sha": "b10f6eda8805321359042c817fdbd9ecc2f0da25", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd4112bf7924767a6074b54ffe297c877f8b042d/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd4112bf7924767a6074b54ffe297c877f8b042d/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=dd4112bf7924767a6074b54ffe297c877f8b042d", "patch": "@@ -89,7 +89,7 @@ impl Type {\n     }\n \n     pub fn bool(ccx: &CrateContext) -> Type {\n-        Type::i1(ccx)\n+        Type::i8(ccx)\n     }\n \n     pub fn char(ccx: &CrateContext) -> Type {"}, {"sha": "028722071a6999a3bfadc25fc6d32ed5d33fbd97", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dd4112bf7924767a6074b54ffe297c877f8b042d/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd4112bf7924767a6074b54ffe297c877f8b042d/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=dd4112bf7924767a6074b54ffe297c877f8b042d", "patch": "@@ -31,7 +31,7 @@ pub fn return_uses_outptr(ccx: &CrateContext, ty: ty::t) -> bool {\n }\n \n pub fn type_of_explicit_arg(ccx: &CrateContext, arg_ty: ty::t) -> Type {\n-    let llty = type_of(ccx, arg_ty);\n+    let llty = arg_type_of(ccx, arg_ty);\n     if arg_is_indirect(ccx, arg_ty) {\n         llty.ptr_to()\n     } else {\n@@ -46,7 +46,7 @@ pub fn type_of_rust_fn(cx: &CrateContext, has_env: bool,\n     // Arg 0: Output pointer.\n     // (if the output type is non-immediate)\n     let use_out_pointer = return_uses_outptr(cx, output);\n-    let lloutputtype = type_of(cx, output);\n+    let lloutputtype = arg_type_of(cx, output);\n     if use_out_pointer {\n         atys.push(lloutputtype.ptr_to());\n     }\n@@ -167,6 +167,14 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n     llsizingty\n }\n \n+pub fn arg_type_of(cx: &CrateContext, t: ty::t) -> Type {\n+    if ty::type_is_bool(t) {\n+        Type::i1(cx)\n+    } else {\n+        type_of(cx, t)\n+    }\n+}\n+\n // NB: If you update this, be sure to update `sizing_type_of()` as well.\n pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n     // Check the cache."}]}