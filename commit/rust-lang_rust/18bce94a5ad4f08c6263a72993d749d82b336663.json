{"sha": "18bce94a5ad4f08c6263a72993d749d82b336663", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4YmNlOTRhNWFkNGYwOGM2MjYzYTcyOTkzZDc0OWQ4MmIzMzY2NjM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-09-26T23:01:40Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-09-26T23:04:23Z"}, "message": "libcore: De-export dvec, rand, run, and sys", "tree": {"sha": "216e17174c707760eb6af1d6911e1bda9c672fd2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/216e17174c707760eb6af1d6911e1bda9c672fd2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18bce94a5ad4f08c6263a72993d749d82b336663", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18bce94a5ad4f08c6263a72993d749d82b336663", "html_url": "https://github.com/rust-lang/rust/commit/18bce94a5ad4f08c6263a72993d749d82b336663", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18bce94a5ad4f08c6263a72993d749d82b336663/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f15b0d97528d57d3dd8b4fa8dc27fad41a9ebf6", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f15b0d97528d57d3dd8b4fa8dc27fad41a9ebf6", "html_url": "https://github.com/rust-lang/rust/commit/4f15b0d97528d57d3dd8b4fa8dc27fad41a9ebf6"}], "stats": {"total": 150, "additions": 59, "deletions": 91}, "files": [{"sha": "9d3d2e97f9a71992cd6e3103adc8f6e5b893e3f2", "filename": "src/libcore/dvec.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/18bce94a5ad4f08c6263a72993d749d82b336663/src%2Flibcore%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18bce94a5ad4f08c6263a72993d749d82b336663/src%2Flibcore%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdvec.rs?ref=18bce94a5ad4f08c6263a72993d749d82b336663", "patch": "@@ -16,12 +16,6 @@ Note that recursive use is not permitted.\n use cast::reinterpret_cast;\n use ptr::null;\n \n-export DVec;\n-export from_elem;\n-export from_vec;\n-export extensions;\n-export unwrap;\n-\n /**\n  * A growable, modifiable vector type that accumulates elements into a\n  * unique vector.\n@@ -57,27 +51,27 @@ type DVec_<A> = {\n     mut data: ~[A]\n };\n \n-enum DVec<A> {\n+pub enum DVec<A> {\n     DVec_(DVec_<A>)\n }\n \n /// Creates a new, empty dvec\n-fn DVec<A>() -> DVec<A> {\n+pub fn DVec<A>() -> DVec<A> {\n     DVec_({mut data: ~[]})\n }\n \n /// Creates a new dvec with a single element\n-fn from_elem<A>(+e: A) -> DVec<A> {\n+pub fn from_elem<A>(+e: A) -> DVec<A> {\n     DVec_({mut data: ~[move e]})\n }\n \n /// Creates a new dvec with the contents of a vector\n-fn from_vec<A>(+v: ~[A]) -> DVec<A> {\n+pub fn from_vec<A>(+v: ~[A]) -> DVec<A> {\n     DVec_({mut data: move v})\n }\n \n /// Consumes the vector and returns its contents\n-fn unwrap<A>(+d: DVec<A>) -> ~[A] {\n+pub fn unwrap<A>(+d: DVec<A>) -> ~[A] {\n     let DVec_({data: v}) <- d;\n     move v\n }"}, {"sha": "02aa8530072ec1eb07bd33637c9c4b1a8a77fc42", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 25, "deletions": 30, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/18bce94a5ad4f08c6263a72993d749d82b336663/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18bce94a5ad4f08c6263a72993d749d82b336663/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=18bce94a5ad4f08c6263a72993d749d82b336663", "patch": "@@ -1,8 +1,5 @@\n //! Random number generation\n \n-export Rng, seed, seeded_rng, Weighted, extensions;\n-export xorshift, seeded_xorshift;\n-\n #[allow(non_camel_case_types)] // runtime type\n enum rctx {}\n \n@@ -17,13 +14,13 @@ extern mod rustrt {\n }\n \n /// A random number generator\n-trait Rng {\n+pub trait Rng {\n     /// Return the next random integer\n     fn next() -> u32;\n }\n \n /// A value with a particular weight compared to other values\n-type Weighted<T> = { weight: uint, item: T };\n+pub type Weighted<T> = { weight: uint, item: T };\n \n /// Extension methods for random number generators\n impl Rng {\n@@ -260,12 +257,12 @@ impl @RandRes: Rng {\n }\n \n /// Create a new random seed for seeded_rng\n-fn seed() -> ~[u8] {\n+pub fn seed() -> ~[u8] {\n     rustrt::rand_seed()\n }\n \n /// Create a random number generator with a system specified seed\n-fn Rng() -> Rng {\n+pub fn Rng() -> Rng {\n     @RandRes(rustrt::rand_new()) as Rng\n }\n \n@@ -275,7 +272,7 @@ fn Rng() -> Rng {\n  * all other generators constructed with the same seed. The seed may be any\n  * length.\n  */\n-fn seeded_rng(seed: ~[u8]) -> Rng {\n+pub fn seeded_rng(seed: ~[u8]) -> Rng {\n     @RandRes(rustrt::rand_new_seeded(seed)) as Rng\n }\n \n@@ -299,29 +296,27 @@ impl XorShiftState: Rng {\n     }\n }\n \n-fn xorshift() -> Rng {\n+pub fn xorshift() -> Rng {\n     // constants taken from http://en.wikipedia.org/wiki/Xorshift\n     seeded_xorshift(123456789u32, 362436069u32, 521288629u32, 88675123u32)\n }\n \n-fn seeded_xorshift(x: u32, y: u32, z: u32, w: u32) -> Rng {\n+pub fn seeded_xorshift(x: u32, y: u32, z: u32, w: u32) -> Rng {\n     {mut x: x, mut y: y, mut z: z, mut w: w} as Rng\n }\n \n #[cfg(test)]\n-mod tests {\n-    #[legacy_exports];\n-\n+pub mod tests {\n     #[test]\n-    fn rng_seeded() {\n+    pub fn rng_seeded() {\n         let seed = rand::seed();\n         let ra = rand::seeded_rng(seed);\n         let rb = rand::seeded_rng(seed);\n         assert ra.gen_str(100u) == rb.gen_str(100u);\n     }\n \n     #[test]\n-    fn rng_seeded_custom_seed() {\n+    pub fn rng_seeded_custom_seed() {\n         // much shorter than generated seeds which are 1024 bytes\n         let seed = ~[2u8, 32u8, 4u8, 32u8, 51u8];\n         let ra = rand::seeded_rng(seed);\n@@ -330,7 +325,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn rng_seeded_custom_seed2() {\n+    pub fn rng_seeded_custom_seed2() {\n         let seed = ~[2u8, 32u8, 4u8, 32u8, 51u8];\n         let ra = rand::seeded_rng(seed);\n         // Regression test that isaac is actually using the above vector\n@@ -341,7 +336,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn gen_int_range() {\n+    pub fn gen_int_range() {\n         let r = rand::Rng();\n         let a = r.gen_int_range(-3, 42);\n         assert a >= -3 && a < 42;\n@@ -352,12 +347,12 @@ mod tests {\n     #[test]\n     #[should_fail]\n     #[ignore(cfg(windows))]\n-    fn gen_int_from_fail() {\n+    pub fn gen_int_from_fail() {\n         rand::Rng().gen_int_range(5, -2);\n     }\n \n     #[test]\n-    fn gen_uint_range() {\n+    pub fn gen_uint_range() {\n         let r = rand::Rng();\n         let a = r.gen_uint_range(3u, 42u);\n         assert a >= 3u && a < 42u;\n@@ -368,27 +363,27 @@ mod tests {\n     #[test]\n     #[should_fail]\n     #[ignore(cfg(windows))]\n-    fn gen_uint_range_fail() {\n+    pub fn gen_uint_range_fail() {\n         rand::Rng().gen_uint_range(5u, 2u);\n     }\n \n     #[test]\n-    fn gen_float() {\n+    pub fn gen_float() {\n         let r = rand::Rng();\n         let a = r.gen_float();\n         let b = r.gen_float();\n         log(debug, (a, b));\n     }\n \n     #[test]\n-    fn gen_weighted_bool() {\n+    pub fn gen_weighted_bool() {\n         let r = rand::Rng();\n         assert r.gen_weighted_bool(0u) == true;\n         assert r.gen_weighted_bool(1u) == true;\n     }\n \n     #[test]\n-    fn gen_str() {\n+    pub fn gen_str() {\n         let r = rand::Rng();\n         log(debug, r.gen_str(10u));\n         log(debug, r.gen_str(10u));\n@@ -399,29 +394,29 @@ mod tests {\n     }\n \n     #[test]\n-    fn gen_bytes() {\n+    pub fn gen_bytes() {\n         let r = rand::Rng();\n         assert r.gen_bytes(0u).len() == 0u;\n         assert r.gen_bytes(10u).len() == 10u;\n         assert r.gen_bytes(16u).len() == 16u;\n     }\n \n     #[test]\n-    fn choose() {\n+    pub fn choose() {\n         let r = rand::Rng();\n         assert r.choose([1, 1, 1]) == 1;\n     }\n \n     #[test]\n-    fn choose_option() {\n+    pub fn choose_option() {\n         let r = rand::Rng();\n         let x: Option<int> = r.choose_option([]);\n         assert x.is_none();\n         assert r.choose_option([1, 1, 1]) == Some(1);\n     }\n \n     #[test]\n-    fn choose_weighted() {\n+    pub fn choose_weighted() {\n         let r = rand::Rng();\n         assert r.choose_weighted(~[{weight: 1u, item: 42}]) == 42;\n         assert r.choose_weighted(~[\n@@ -431,7 +426,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn choose_weighted_option() {\n+    pub fn choose_weighted_option() {\n         let r = rand::Rng();\n         assert r.choose_weighted_option(~[{weight: 1u, item: 42}]) ==\n                Some(42);\n@@ -444,7 +439,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn weighted_vec() {\n+    pub fn weighted_vec() {\n         let r = rand::Rng();\n         let empty: ~[int] = ~[];\n         assert r.weighted_vec(~[]) == empty;\n@@ -456,7 +451,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn shuffle() {\n+    pub fn shuffle() {\n         let r = rand::Rng();\n         let empty: ~[int] = ~[];\n         assert r.shuffle(~[]) == empty;"}, {"sha": "e3e8491e15ad60987097711603cc7e174208faae", "filename": "src/libcore/run.rs", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/18bce94a5ad4f08c6263a72993d749d82b336663/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18bce94a5ad4f08c6263a72993d749d82b336663/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=18bce94a5ad4f08c6263a72993d749d82b336663", "patch": "@@ -7,13 +7,6 @@ use option::{Some, None};\n use libc::{pid_t, c_void, c_int};\n use io::ReaderUtil;\n \n-export Program;\n-export run_program;\n-export start_program;\n-export program_output;\n-export spawn_process;\n-export waitpid;\n-\n #[abi = \"cdecl\"]\n extern mod rustrt {\n     #[legacy_exports];\n@@ -24,7 +17,7 @@ extern mod rustrt {\n }\n \n /// A value representing a child process\n-trait Program {\n+pub trait Program {\n     /// Returns the process id of the program\n     fn get_id() -> pid_t;\n \n@@ -68,7 +61,7 @@ trait Program {\n  *\n  * The process id of the spawned process\n  */\n-fn spawn_process(prog: &str, args: &[~str],\n+pub fn spawn_process(prog: &str, args: &[~str],\n                  env: &Option<~[(~str,~str)]>,\n                  dir: &Option<~str>,\n                  in_fd: c_int, out_fd: c_int, err_fd: c_int)\n@@ -166,7 +159,7 @@ fn with_dirp<T>(d: &Option<~str>,\n  *\n  * The process id\n  */\n-fn run_program(prog: &str, args: &[~str]) -> int {\n+pub fn run_program(prog: &str, args: &[~str]) -> int {\n     let pid = spawn_process(prog, args, &None, &None,\n                             0i32, 0i32, 0i32);\n     if pid == -1 as pid_t { fail; }\n@@ -189,7 +182,7 @@ fn run_program(prog: &str, args: &[~str]) -> int {\n  *\n  * A class with a <program> field\n  */\n-fn start_program(prog: &str, args: &[~str]) -> Program {\n+pub fn start_program(prog: &str, args: &[~str]) -> Program {\n     let pipe_input = os::pipe();\n     let pipe_output = os::pipe();\n     let pipe_err = os::pipe();\n@@ -278,7 +271,7 @@ fn read_all(rd: io::Reader) -> ~str {\n  * A record, {status: int, out: str, err: str} containing the exit code,\n  * the contents of stdout and the contents of stderr.\n  */\n-fn program_output(prog: &str, args: &[~str]) ->\n+pub fn program_output(prog: &str, args: &[~str]) ->\n    {status: int, out: ~str, err: ~str} {\n \n     let pipe_in = os::pipe();\n@@ -359,7 +352,7 @@ fn readclose(fd: c_int) -> ~str {\n }\n \n /// Waits for a process to exit and returns the exit code\n-fn waitpid(pid: pid_t) -> int {\n+pub fn waitpid(pid: pid_t) -> int {\n     return waitpid_os(pid);\n \n     #[cfg(windows)]\n@@ -402,20 +395,18 @@ fn waitpid(pid: pid_t) -> int {\n \n #[cfg(test)]\n mod tests {\n-    #[legacy_exports];\n-\n     use io::WriterUtil;\n \n     // Regression test for memory leaks\n     #[ignore(cfg(windows))] // FIXME (#2626)\n-    fn test_leaks() {\n+    pub fn test_leaks() {\n         run::run_program(\"echo\", []);\n         run::start_program(\"echo\", []);\n         run::program_output(\"echo\", []);\n     }\n \n     #[test]\n-    fn test_pipes() {\n+    pub fn test_pipes() {\n         let pipe_in = os::pipe();\n         let pipe_out = os::pipe();\n         let pipe_err = os::pipe();\n@@ -441,7 +432,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn waitpid() {\n+    pub fn waitpid() {\n         let pid = run::spawn_process(\"false\", [],\n                                      &None, &None,\n                                      0i32, 0i32, 0i32);"}, {"sha": "d89691aba5b7fee8310d680552b85590fcefe12a", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 20, "deletions": 32, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/18bce94a5ad4f08c6263a72993d749d82b336663/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18bce94a5ad4f08c6263a72993d749d82b336663/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=18bce94a5ad4f08c6263a72993d749d82b336663", "patch": "@@ -7,21 +7,10 @@\n use cmp::{Eq, Ord};\n use libc::c_void;\n \n-export FreeGlue;\n-export TypeDesc;\n-export Closure;\n-export get_type_desc;\n-export size_of;\n-export min_align_of;\n-export pref_align_of;\n-export refcount;\n-export log_str;\n-export shape_eq, shape_lt, shape_le;\n-\n-type FreeGlue = fn(*TypeDesc, *c_void);\n+pub type FreeGlue = fn(*TypeDesc, *c_void);\n \n // Corresponds to runtime type_desc type\n-enum TypeDesc = {\n+pub enum TypeDesc = {\n     size: uint,\n     align: uint,\n     take_glue: uint,\n@@ -31,7 +20,7 @@ enum TypeDesc = {\n };\n \n /// The representation of a Rust closure\n-struct Closure {\n+pub struct Closure {\n     code: *(),\n     env: *(),\n }\n@@ -47,15 +36,15 @@ extern mod rusti {\n \n /// Compares contents of two pointers using the default method.\n /// Equivalent to `*x1 == *x2`.  Useful for hashtables.\n-pure fn shape_eq<T:Eq>(x1: &T, x2: &T) -> bool {\n+pub pure fn shape_eq<T:Eq>(x1: &T, x2: &T) -> bool {\n     *x1 == *x2\n }\n \n-pure fn shape_lt<T:Ord>(x1: &T, x2: &T) -> bool {\n+pub pure fn shape_lt<T:Ord>(x1: &T, x2: &T) -> bool {\n     *x1 < *x2\n }\n \n-pure fn shape_le<T:Ord>(x1: &T, x2: &T) -> bool {\n+pub pure fn shape_le<T:Ord>(x1: &T, x2: &T) -> bool {\n     *x1 <= *x2\n }\n \n@@ -66,13 +55,13 @@ pure fn shape_le<T:Ord>(x1: &T, x2: &T) -> bool {\n  * performing dark magick.\n  */\n #[inline(always)]\n-pure fn get_type_desc<T>() -> *TypeDesc {\n+pub pure fn get_type_desc<T>() -> *TypeDesc {\n     unsafe { rusti::get_tydesc::<T>() as *TypeDesc }\n }\n \n /// Returns the size of a type\n #[inline(always)]\n-pure fn size_of<T>() -> uint {\n+pub pure fn size_of<T>() -> uint {\n     unsafe { rusti::size_of::<T>() }\n }\n \n@@ -83,26 +72,26 @@ pure fn size_of<T>() -> uint {\n  * than the preferred alignment.\n  */\n #[inline(always)]\n-pure fn min_align_of<T>() -> uint {\n+pub pure fn min_align_of<T>() -> uint {\n     unsafe { rusti::min_align_of::<T>() }\n }\n \n /// Returns the preferred alignment of a type\n #[inline(always)]\n-pure fn pref_align_of<T>() -> uint {\n+pub pure fn pref_align_of<T>() -> uint {\n     unsafe { rusti::pref_align_of::<T>() }\n }\n \n /// Returns the refcount of a shared box (as just before calling this)\n #[inline(always)]\n-pure fn refcount<T>(+t: @T) -> uint {\n+pub pure fn refcount<T>(+t: @T) -> uint {\n     unsafe {\n         let ref_ptr: *uint = cast::reinterpret_cast(&t);\n         *ref_ptr - 1\n     }\n }\n \n-pure fn log_str<T>(t: &T) -> ~str {\n+pub pure fn log_str<T>(t: &T) -> ~str {\n     unsafe {\n         do io::with_str_writer |wr| {\n             repr::write_repr(wr, t)\n@@ -111,11 +100,10 @@ pure fn log_str<T>(t: &T) -> ~str {\n }\n \n #[cfg(test)]\n-mod tests {\n-    #[legacy_exports];\n+pub mod tests {\n \n     #[test]\n-    fn size_of_basic() {\n+    pub fn size_of_basic() {\n         assert size_of::<u8>() == 1u;\n         assert size_of::<u16>() == 2u;\n         assert size_of::<u32>() == 4u;\n@@ -125,20 +113,20 @@ mod tests {\n     #[test]\n     #[cfg(target_arch = \"x86\")]\n     #[cfg(target_arch = \"arm\")]\n-    fn size_of_32() {\n+    pub fn size_of_32() {\n         assert size_of::<uint>() == 4u;\n         assert size_of::<*uint>() == 4u;\n     }\n \n     #[test]\n     #[cfg(target_arch = \"x86_64\")]\n-    fn size_of_64() {\n+    pub fn size_of_64() {\n         assert size_of::<uint>() == 8u;\n         assert size_of::<*uint>() == 8u;\n     }\n \n     #[test]\n-    fn align_of_basic() {\n+    pub fn align_of_basic() {\n         assert pref_align_of::<u8>() == 1u;\n         assert pref_align_of::<u16>() == 2u;\n         assert pref_align_of::<u32>() == 4u;\n@@ -147,20 +135,20 @@ mod tests {\n     #[test]\n     #[cfg(target_arch = \"x86\")]\n     #[cfg(target_arch = \"arm\")]\n-    fn align_of_32() {\n+    pub fn align_of_32() {\n         assert pref_align_of::<uint>() == 4u;\n         assert pref_align_of::<*uint>() == 4u;\n     }\n \n     #[test]\n     #[cfg(target_arch = \"x86_64\")]\n-    fn align_of_64() {\n+    pub fn align_of_64() {\n         assert pref_align_of::<uint>() == 8u;\n         assert pref_align_of::<*uint>() == 8u;\n     }\n \n     #[test]\n-    fn synthesize_closure() unsafe {\n+    pub fn synthesize_closure() unsafe {\n         let x = 10;\n         let f: fn(int) -> int = |y| x + y;\n "}]}