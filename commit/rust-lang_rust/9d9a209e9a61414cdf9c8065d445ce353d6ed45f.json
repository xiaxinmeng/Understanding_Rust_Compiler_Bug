{"sha": "9d9a209e9a61414cdf9c8065d445ce353d6ed45f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkOWEyMDllOWE2MTQxNGNkZjljODA2NWQ0NDVjZTM1M2Q2ZWQ0NWY=", "commit": {"author": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2013-03-21T11:36:21Z"}, "committer": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2013-03-21T13:05:57Z"}, "message": "back-renamed slice_DBG_BRWD, slice_V_DBG_BRWD -> slice, slice_DBG_UNIQ -> slice_unique", "tree": {"sha": "11ec8b9926019a8864066990c5bf34860620c1a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/11ec8b9926019a8864066990c5bf34860620c1a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d9a209e9a61414cdf9c8065d445ce353d6ed45f", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d9a209e9a61414cdf9c8065d445ce353d6ed45f", "html_url": "https://github.com/rust-lang/rust/commit/9d9a209e9a61414cdf9c8065d445ce353d6ed45f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/comments", "author": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f4448837b09fe644524ba28d59dee08950ef6b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f4448837b09fe644524ba28d59dee08950ef6b5", "html_url": "https://github.com/rust-lang/rust/commit/8f4448837b09fe644524ba28d59dee08950ef6b5"}], "stats": {"total": 248, "additions": 124, "deletions": 124}, "files": [{"sha": "6be428ef27908a94f420f01664e48e8a17ebfe94", "filename": "doc/rust.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=9d9a209e9a61414cdf9c8065d445ce353d6ed45f", "patch": "@@ -806,7 +806,7 @@ An example of `use` declarations:\n \n ~~~~\n use core::float::sin;\n-use core::str::{slice_DBG_BRWD, to_upper};\n+use core::str::{slice, to_upper};\n use core::option::Some;\n \n fn main() {\n@@ -817,8 +817,8 @@ fn main() {\n     info!(Some(1.0));\n \n     // Equivalent to\n-    // 'info!(core::str::to_upper(core::str::slice_DBG_BRWD(\"foo\", 0, 1)));'\n-    info!(to_upper(slice_DBG_BRWD(\"foo\", 0, 1)));\n+    // 'info!(core::str::to_upper(core::str::slice(\"foo\", 0, 1)));'\n+    info!(to_upper(slice(\"foo\", 0, 1)));\n }\n ~~~~\n \n@@ -2668,7 +2668,7 @@ Within the body of an item that has type parameter declarations, the names of it\n fn map<A: Copy, B: Copy>(f: &fn(A) -> B, xs: &[A]) -> ~[B] {\n    if xs.len() == 0 { return ~[]; }\n    let first: B = f(xs[0]);\n-   let rest: ~[B] = map(f, xs.slice_V_DBG_BRWD(1, xs.len()));\n+   let rest: ~[B] = map(f, xs.slice(1, xs.len()));\n    return ~[first] + rest;\n }\n ~~~~~~~"}, {"sha": "63b5c64c6d4a62dda6608c5107d76795162cb56e", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=9d9a209e9a61414cdf9c8065d445ce353d6ed45f", "patch": "@@ -51,11 +51,11 @@ fn parse_expected(line_num: uint, line: ~str) -> ~[ExpectedError] {\n         while idx < len && line[idx] == (' ' as u8) { idx += 1u; }\n         let start_kind = idx;\n         while idx < len && line[idx] != (' ' as u8) { idx += 1u; }\n-        let kind = str::to_lower(str::slice_DBG_BRWD(line, start_kind, idx).to_owned());\n+        let kind = str::to_lower(str::slice(line, start_kind, idx).to_owned());\n \n         // Extract msg:\n         while idx < len && line[idx] == (' ' as u8) { idx += 1u; }\n-        let msg = str::slice_DBG_BRWD(line, idx, len).to_owned();\n+        let msg = str::slice(line, idx, len).to_owned();\n \n         debug!(\"line=%u kind=%s msg=%s\", line_num - adjust_line, kind, msg);\n "}, {"sha": "a039aaf56835a9511805dbe28983f56c6d2e1105", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=9d9a209e9a61414cdf9c8065d445ce353d6ed45f", "patch": "@@ -174,7 +174,7 @@ fn parse_name_value_directive(line: ~str,\n         let keycolon = directive + ~\":\";\n         match str::find_str(line, keycolon) {\n             Some(colon) => {\n-                let value = str::slice_DBG_BRWD(line, colon + str::len(keycolon),\n+                let value = str::slice(line, colon + str::len(keycolon),\n                                        str::len(line)).to_owned();\n                 debug!(\"%s: %s\", directive,  value);\n                 Some(value)"}, {"sha": "28e57a354c8beb9b98e8831c7ec6174044420f6c", "filename": "src/libcore/num/strconv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibcore%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibcore%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fstrconv.rs?ref=9d9a209e9a61414cdf9c8065d445ce353d6ed45f", "patch": "@@ -364,14 +364,14 @@ pub pure fn to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Copy+\n \n             // only resize buf if we actually remove digits\n             if i < buf_max_i {\n-                buf = buf.slice_V_DBG_BRWD(0, i + 1).to_owned();\n+                buf = buf.slice(0, i + 1).to_owned();\n             }\n         }\n     } // If exact and trailing '.', just cut that\n     else {\n         let max_i = buf.len() - 1;\n         if buf[max_i] == '.' as u8 {\n-            buf = buf.slice_V_DBG_BRWD(0, max_i).to_owned();\n+            buf = buf.slice(0, max_i).to_owned();\n         }\n     }\n \n@@ -606,7 +606,7 @@ pub pure fn from_str_bytes_common<T:NumCast+Zero+One+Ord+Copy+Div<T,T>+\n         // parse remaining bytes as decimal integer,\n         // skipping the exponent char\n         let exp: Option<int> = from_str_bytes_common(\n-            buf.slice_V_DBG_BRWD(i+1, len), 10, true, false, false, ExpNone, false);\n+            buf.slice(i+1, len), 10, true, false, false, ExpNone, false);\n \n         match exp {\n             Some(exp_pow) => {"}, {"sha": "bc6d6b507b202b64095457a57e9d18187b309bd4", "filename": "src/libcore/path.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=9d9a209e9a61414cdf9c8065d445ce353d6ed45f", "patch": "@@ -410,7 +410,7 @@ impl GenericPath for PosixPath {\n           None => None,\n           Some(ref f) => {\n             match str::rfind_char(*f, '.') {\n-              Some(p) => Some(f.slice_DBG_BRWD(0, p).to_owned()),\n+              Some(p) => Some(f.slice(0, p).to_owned()),\n               None => Some(copy *f)\n             }\n           }\n@@ -422,7 +422,7 @@ impl GenericPath for PosixPath {\n           None => None,\n           Some(ref f) => {\n             match str::rfind_char(*f, '.') {\n-              Some(p) if p < f.len() => Some(f.slice_DBG_BRWD(p, f.len()).to_owned()),\n+              Some(p) if p < f.len() => Some(f.slice(p, f.len()).to_owned()),\n               _ => None\n             }\n           }\n@@ -622,7 +622,7 @@ impl GenericPath for WindowsPath {\n           None => None,\n           Some(ref f) => {\n             match str::rfind_char(*f, '.') {\n-              Some(p) => Some(f.slice_DBG_BRWD(0, p).to_owned()),\n+              Some(p) => Some(f.slice(0, p).to_owned()),\n               None => Some(copy *f)\n             }\n           }\n@@ -634,7 +634,7 @@ impl GenericPath for WindowsPath {\n           None => None,\n           Some(ref f) => {\n             match str::rfind_char(*f, '.') {\n-              Some(p) if p < f.len() => Some(f.slice_DBG_BRWD(p, f.len()).to_owned()),\n+              Some(p) if p < f.len() => Some(f.slice(p, f.len()).to_owned()),\n               _ => None\n             }\n           }\n@@ -842,8 +842,8 @@ pub mod windows {\n             let mut i = 2;\n             while i < s.len() {\n                 if is_sep(s[i]) {\n-                    let pre = s.slice_DBG_BRWD(2, i).to_owned();\n-                    let mut rest = s.slice_DBG_BRWD(i, s.len()).to_owned();\n+                    let pre = s.slice(2, i).to_owned();\n+                    let mut rest = s.slice(i, s.len()).to_owned();\n                     return Some((pre, rest));\n                 }\n                 i += 1;\n@@ -860,9 +860,9 @@ pub mod windows {\n                 let rest = if s.len() == 2 {\n                     ~\"\"\n                 } else {\n-                    s.slice_DBG_BRWD(2, s.len()).to_owned()\n+                    s.slice(2, s.len()).to_owned()\n                 };\n-                return Some((s.slice_DBG_BRWD(0,1).to_owned(), rest));\n+                return Some((s.slice(0,1).to_owned(), rest));\n             }\n             None\n         }"}, {"sha": "e57d0f51870efe3b6854f72e25168fb69f561984", "filename": "src/libcore/rt/uv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibcore%2Frt%2Fuv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibcore%2Frt%2Fuv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv.rs?ref=9d9a209e9a61414cdf9c8065d445ce353d6ed45f", "patch": "@@ -878,7 +878,7 @@ fn listen() {\n                 if status.is_none() {\n                     rtdebug!(\"got %d bytes\", nread);\n                     let buf = buf.unwrap();\n-                    for buf.slice_V_DBG_BRWD(0, nread as uint).each |byte| {\n+                    for buf.slice(0, nread as uint).each |byte| {\n                         fail_unless!(*byte == count as u8);\n                         rtdebug!(\"%u\", *byte as uint);\n                         count += 1;"}, {"sha": "5fbb5e3c2236126faf0d73993f49fb1adbdf5977", "filename": "src/libcore/run.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=9d9a209e9a61414cdf9c8065d445ce353d6ed45f", "patch": "@@ -303,7 +303,7 @@ fn read_all(rd: io::Reader) -> ~str {\n         let mut bytes = [0, ..4096];\n         while !rd.eof() {\n             let nread = rd.read(bytes, bytes.len());\n-            wr.write(bytes.slice_V_DBG_BRWD(0, nread));\n+            wr.write(bytes.slice(0, nread));\n         }\n     });\n     str::from_bytes(buf)\n@@ -404,7 +404,7 @@ pub fn readclose(fd: c_int) -> ~str {\n             let mut bytes = [0, ..4096];\n             while !reader.eof() {\n                 let nread = reader.read(bytes, bytes.len());\n-                writer.write(bytes.slice_V_DBG_BRWD(0, nread));\n+                writer.write(bytes.slice(0, nread));\n             }\n         });\n         os::fclose(file);"}, {"sha": "3d704b42a0e07eb55565caf99986f5e82975ab72", "filename": "src/libcore/str.rs", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=9d9a209e9a61414cdf9c8065d445ce353d6ed45f", "patch": "@@ -50,7 +50,7 @@ pub pure fn from_bytes(vv: &[const u8]) -> ~str {\n \n /// Copy a slice into a new unique str\n pub pure fn from_slice(s: &str) -> ~str {\n-    unsafe { raw::slice_DBG_UNIQ_bytes(s, 0, len(s)) }\n+    unsafe { raw::slice_bytes_unique(s, 0, len(s)) }\n }\n \n /**\n@@ -265,7 +265,7 @@ pub fn pop_char(s: &mut ~str) -> char {\n  */\n pub fn shift_char(s: &mut ~str) -> char {\n     let CharRange {ch, next} = char_range_at(*s, 0u);\n-    *s = unsafe { raw::slice_DBG_UNIQ_bytes(*s, next, len(*s)) };\n+    *s = unsafe { raw::slice_bytes_unique(*s, next, len(*s)) };\n     return ch;\n }\n \n@@ -281,7 +281,7 @@ pub fn shift_char(s: &mut ~str) -> char {\n #[inline]\n pub fn slice_shift_char(s: &'a str) -> (char, &'a str) {\n     let CharRange {ch, next} = char_range_at(s, 0u);\n-    let next_s = unsafe { raw::slice_DBG_BRWD_bytes(s, next, len(s)) };\n+    let next_s = unsafe { raw::slice_bytes(s, next, len(s)) };\n     return (ch, next_s);\n }\n \n@@ -304,7 +304,7 @@ pub pure fn trim_left_chars(s: &str, chars_to_trim: &[char]) -> ~str {\n \n     match find(s, |c| !chars_to_trim.contains(&c)) {\n       None => ~\"\",\n-      Some(first) => unsafe { raw::slice_DBG_UNIQ_bytes(s, first, s.len()) }\n+      Some(first) => unsafe { raw::slice_bytes_unique(s, first, s.len()) }\n     }\n }\n \n@@ -324,7 +324,7 @@ pub pure fn trim_right_chars(s: &str, chars_to_trim: &[char]) -> ~str {\n       None => ~\"\",\n       Some(last) => {\n         let next = char_range_at(s, last).next;\n-        unsafe { raw::slice_DBG_UNIQ_bytes(s, 0u, next) }\n+        unsafe { raw::slice_bytes_unique(s, 0u, next) }\n       }\n     }\n }\n@@ -346,7 +346,7 @@ pub pure fn trim_chars(s: &str, chars_to_trim: &[char]) -> ~str {\n pub pure fn trim_left(s: &str) -> ~str {\n     match find(s, |c| !char::is_whitespace(c)) {\n       None => ~\"\",\n-      Some(first) => unsafe { raw::slice_DBG_UNIQ_bytes(s, first, len(s)) }\n+      Some(first) => unsafe { raw::slice_bytes_unique(s, first, len(s)) }\n     }\n }\n \n@@ -356,7 +356,7 @@ pub pure fn trim_right(s: &str) -> ~str {\n       None => ~\"\",\n       Some(last) => {\n         let next = char_range_at(s, last).next;\n-        unsafe { raw::slice_DBG_UNIQ_bytes(s, 0u, next) }\n+        unsafe { raw::slice_bytes_unique(s, 0u, next) }\n       }\n     }\n }\n@@ -408,7 +408,7 @@ pub pure fn chars(s: &str) -> ~[char] {\n  * `begin`.\n  */\n pub pure fn substr(s: &str, begin: uint, n: uint) -> ~str {\n-    slice_DBG_BRWD(s, begin, begin + count_bytes(s, begin, n)).to_owned()\n+    slice(s, begin, begin + count_bytes(s, begin, n)).to_owned()\n }\n \n /**\n@@ -417,10 +417,10 @@ pub pure fn substr(s: &str, begin: uint, n: uint) -> ~str {\n  * Fails when `begin` and `end` do not point to valid characters or beyond\n  * the last character of the string\n  */\n-pub pure fn slice_DBG_BRWD(s: &'a str, begin: uint, end: uint) -> &'a str {\n+pub pure fn slice(s: &'a str, begin: uint, end: uint) -> &'a str {\n     fail_unless!(is_char_boundary(s, begin));\n     fail_unless!(is_char_boundary(s, end));\n-    unsafe { raw::slice_DBG_BRWD_bytes(s, begin, end) }\n+    unsafe { raw::slice_bytes(s, begin, end) }\n }\n \n /// Splits a string into substrings at each occurrence of a given character\n@@ -453,7 +453,7 @@ pure fn split_char_inner(s: &str, sep: char, count: uint, allow_empty: bool)\n             if s[i] == b {\n                 if allow_empty || start < i {\n                     unsafe {\n-                        result.push(raw::slice_DBG_UNIQ_bytes(s, start, i));\n+                        result.push(raw::slice_bytes_unique(s, start, i));\n                     }\n                 }\n                 start = i + 1u;\n@@ -462,7 +462,7 @@ pure fn split_char_inner(s: &str, sep: char, count: uint, allow_empty: bool)\n             i += 1u;\n         }\n         if allow_empty || start < l {\n-            unsafe { result.push(raw::slice_DBG_UNIQ_bytes(s, start, l) ) };\n+            unsafe { result.push(raw::slice_bytes_unique(s, start, l) ) };\n         }\n         result\n     } else {\n@@ -501,7 +501,7 @@ pure fn split_inner(s: &str, sepfn: &fn(cc: char) -> bool, count: uint,\n         if sepfn(ch) {\n             if allow_empty || start < i {\n                 unsafe {\n-                    result.push(raw::slice_DBG_UNIQ_bytes(s, start, i));\n+                    result.push(raw::slice_bytes_unique(s, start, i));\n                 }\n             }\n             start = next;\n@@ -511,7 +511,7 @@ pure fn split_inner(s: &str, sepfn: &fn(cc: char) -> bool, count: uint,\n     }\n     if allow_empty || start < l {\n         unsafe {\n-            result.push(raw::slice_DBG_UNIQ_bytes(s, start, l));\n+            result.push(raw::slice_bytes_unique(s, start, l));\n         }\n     }\n     result\n@@ -566,7 +566,7 @@ pure fn iter_between_matches(s: &'a str, sep: &'b str, f: &fn(uint, uint)) {\n pub pure fn split_str(s: &'a str, sep: &'b str) -> ~[~str] {\n     let mut result = ~[];\n     do iter_between_matches(s, sep) |from, to| {\n-        unsafe { result.push(raw::slice_DBG_UNIQ_bytes(s, from, to)); }\n+        unsafe { result.push(raw::slice_bytes_unique(s, from, to)); }\n     }\n     result\n }\n@@ -575,7 +575,7 @@ pub pure fn split_str_nonempty(s: &'a str, sep: &'b str) -> ~[~str] {\n     let mut result = ~[];\n     do iter_between_matches(s, sep) |from, to| {\n         if to > from {\n-            unsafe { result.push(raw::slice_DBG_UNIQ_bytes(s, from, to)); }\n+            unsafe { result.push(raw::slice_bytes_unique(s, from, to)); }\n         }\n     }\n     result\n@@ -709,7 +709,7 @@ pub pure fn replace(s: &str, from: &str, to: &str) -> ~str {\n         } else {\n             unsafe { push_str(&mut result, to); }\n         }\n-        unsafe { push_str(&mut result, raw::slice_DBG_UNIQ_bytes(s, start, end)); }\n+        unsafe { push_str(&mut result, raw::slice_bytes_unique(s, start, end)); }\n     }\n     result\n }\n@@ -2123,7 +2123,7 @@ pub mod raw {\n      * If begin is greater than end.\n      * If end is greater than the length of the string.\n      */\n-    pub unsafe fn slice_DBG_UNIQ_bytes(s: &str, begin: uint, end: uint) -> ~str {\n+    pub unsafe fn slice_bytes_unique(s: &str, begin: uint, end: uint) -> ~str {\n         do as_buf(s) |sbuf, n| {\n             fail_unless!((begin <= end));\n             fail_unless!((end <= n));\n@@ -2153,7 +2153,7 @@ pub mod raw {\n      * If end is greater than the length of the string.\n      */\n     #[inline]\n-    pub unsafe fn slice_DBG_BRWD_bytes(s: &str, begin: uint, end: uint) -> &str {\n+    pub unsafe fn slice_bytes(s: &str, begin: uint, end: uint) -> &str {\n         do as_buf(s) |sbuf, n| {\n              fail_unless!((begin <= end));\n              fail_unless!((end <= n));\n@@ -2195,7 +2195,7 @@ pub mod raw {\n         let len = len(*s);\n         fail_unless!((len > 0u));\n         let b = s[0];\n-        *s = unsafe { raw::slice_DBG_UNIQ_bytes(*s, 1u, len) };\n+        *s = unsafe { raw::slice_bytes_unique(*s, 1u, len) };\n         return b;\n     }\n \n@@ -2275,7 +2275,7 @@ pub trait StrSlice {\n     pure fn is_alphanumeric(&self) -> bool;\n     pure fn len(&self) -> uint;\n     pure fn char_len(&self) -> uint;\n-    pure fn slice_DBG_BRWD(&self, begin: uint, end: uint) -> &'self str;\n+    pure fn slice(&self, begin: uint, end: uint) -> &'self str;\n     pure fn split(&self, sepfn: &fn(char) -> bool) -> ~[~str];\n     pure fn split_char(&self, sep: char) -> ~[~str];\n     pure fn split_str(&self, sep: &'a str) -> ~[~str];\n@@ -2390,8 +2390,8 @@ impl StrSlice for &'self str {\n      * beyond the last character of the string\n      */\n     #[inline]\n-    pure fn slice_DBG_BRWD(&self, begin: uint, end: uint) -> &'self str {\n-        slice_DBG_BRWD(*self, begin, end)\n+    pure fn slice(&self, begin: uint, end: uint) -> &'self str {\n+        slice(*self, begin, end)\n     }\n     /// Splits a string into substrings using a character function\n     #[inline]\n@@ -2511,8 +2511,8 @@ mod tests {\n \n     #[test]\n     fn test_eq_slice() {\n-        fail_unless!((eq_slice(slice_DBG_BRWD(\"foobar\", 0, 3), \"foo\")));\n-        fail_unless!((eq_slice(slice_DBG_BRWD(\"barfoo\", 3, 6), \"foo\")));\n+        fail_unless!((eq_slice(slice(\"foobar\", 0, 3), \"foo\")));\n+        fail_unless!((eq_slice(slice(\"barfoo\", 3, 6), \"foo\")));\n         fail_unless!((!eq_slice(\"foo1\", \"foo2\")));\n     }\n \n@@ -2879,9 +2879,9 @@ mod tests {\n \n     #[test]\n     fn test_unsafe_slice() {\n-        fail_unless!(\"ab\" == unsafe {raw::slice_DBG_BRWD_bytes(\"abc\", 0, 2)});\n-        fail_unless!(\"bc\" == unsafe {raw::slice_DBG_BRWD_bytes(\"abc\", 1, 3)});\n-        fail_unless!(\"\" == unsafe {raw::slice_DBG_BRWD_bytes(\"abc\", 1, 1)});\n+        fail_unless!(\"ab\" == unsafe {raw::slice_bytes(\"abc\", 0, 2)});\n+        fail_unless!(\"bc\" == unsafe {raw::slice_bytes(\"abc\", 1, 3)});\n+        fail_unless!(\"\" == unsafe {raw::slice_bytes(\"abc\", 1, 1)});\n         fn a_million_letter_a() -> ~str {\n             let mut i = 0;\n             let mut rs = ~\"\";\n@@ -2896,7 +2896,7 @@ mod tests {\n         }\n         let letters = a_million_letter_a();\n         fail_unless!(half_a_million_letter_a() ==\n-            unsafe {raw::slice_DBG_BRWD_bytes(letters, 0u, 500000)}.to_owned());\n+            unsafe {raw::slice_bytes(letters, 0u, 500000)}.to_owned());\n     }\n \n     #[test]\n@@ -2976,16 +2976,16 @@ mod tests {\n \n     #[test]\n     fn test_slice() {\n-        fail_unless!(\"ab\" == slice_DBG_BRWD(\"abc\", 0, 2));\n-        fail_unless!(\"bc\" == slice_DBG_BRWD(\"abc\", 1, 3));\n-        fail_unless!(\"\" == slice_DBG_BRWD(\"abc\", 1, 1));\n-        fail_unless!(\"\\u65e5\" == slice_DBG_BRWD(\"\\u65e5\\u672c\", 0, 3));\n+        fail_unless!(\"ab\" == slice(\"abc\", 0, 2));\n+        fail_unless!(\"bc\" == slice(\"abc\", 1, 3));\n+        fail_unless!(\"\" == slice(\"abc\", 1, 1));\n+        fail_unless!(\"\\u65e5\" == slice(\"\\u65e5\\u672c\", 0, 3));\n \n         let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-        fail_unless!(\"\u0e1b\" == slice_DBG_BRWD(data, 0, 3));\n-        fail_unless!(\"\u0e23\" == slice_DBG_BRWD(data, 3, 6));\n-        fail_unless!(\"\" == slice_DBG_BRWD(data, 3, 3));\n-        fail_unless!(\"\u534e\" == slice_DBG_BRWD(data, 30, 33));\n+        fail_unless!(\"\u0e1b\" == slice(data, 0, 3));\n+        fail_unless!(\"\u0e23\" == slice(data, 3, 6));\n+        fail_unless!(\"\" == slice(data, 3, 3));\n+        fail_unless!(\"\u534e\" == slice(data, 30, 33));\n \n         fn a_million_letter_X() -> ~str {\n             let mut i = 0;\n@@ -3004,23 +3004,23 @@ mod tests {\n         }\n         let letters = a_million_letter_X();\n         fail_unless!(half_a_million_letter_X() ==\n-            slice_DBG_BRWD(letters, 0u, 3u * 500000u).to_owned());\n+            slice(letters, 0u, 3u * 500000u).to_owned());\n     }\n \n     #[test]\n     fn test_slice_2() {\n         let ss = \"\u4e2d\u534eVi\u1ec7t Nam\";\n \n-        fail_unless!(\"\u534e\" == slice_DBG_BRWD(ss, 3u, 6u));\n-        fail_unless!(\"Vi\u1ec7t Nam\" == slice_DBG_BRWD(ss, 6u, 16u));\n+        fail_unless!(\"\u534e\" == slice(ss, 3u, 6u));\n+        fail_unless!(\"Vi\u1ec7t Nam\" == slice(ss, 6u, 16u));\n \n-        fail_unless!(\"ab\" == slice_DBG_BRWD(\"abc\", 0u, 2u));\n-        fail_unless!(\"bc\" == slice_DBG_BRWD(\"abc\", 1u, 3u));\n-        fail_unless!(\"\" == slice_DBG_BRWD(\"abc\", 1u, 1u));\n+        fail_unless!(\"ab\" == slice(\"abc\", 0u, 2u));\n+        fail_unless!(\"bc\" == slice(\"abc\", 1u, 3u));\n+        fail_unless!(\"\" == slice(\"abc\", 1u, 1u));\n \n-        fail_unless!(\"\u4e2d\" == slice_DBG_BRWD(ss, 0u, 3u));\n-        fail_unless!(\"\u534eV\" == slice_DBG_BRWD(ss, 3u, 7u));\n-        fail_unless!(\"\" == slice_DBG_BRWD(ss, 3u, 3u));\n+        fail_unless!(\"\u4e2d\" == slice(ss, 0u, 3u));\n+        fail_unless!(\"\u534eV\" == slice(ss, 3u, 7u));\n+        fail_unless!(\"\" == slice(ss, 3u, 3u));\n         /*0: \u4e2d\n           3: \u534e\n           6: V\n@@ -3037,7 +3037,7 @@ mod tests {\n     #[should_fail]\n     #[ignore(cfg(windows))]\n     fn test_slice_fail() {\n-        slice_DBG_BRWD(\"\u4e2d\u534eVi\u1ec7t Nam\", 0u, 2u);\n+        slice(\"\u4e2d\u534eVi\u1ec7t Nam\", 0u, 2u);\n     }\n \n     #[test]\n@@ -3633,7 +3633,7 @@ mod tests {\n     #[test]\n     fn test_to_managed() {\n         fail_unless!((~\"abc\").to_managed() == @\"abc\");\n-        fail_unless!(slice_DBG_BRWD(\"abcdef\", 1, 5).to_managed() == @\"bcde\");\n+        fail_unless!(slice(\"abcdef\", 1, 5).to_managed() == @\"bcde\");\n     }\n \n     #[test]"}, {"sha": "0f41ca8c41afdea32bcd2dfbd8843cb7fdef579c", "filename": "src/libcore/unstable/extfmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibcore%2Funstable%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibcore%2Funstable%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fextfmt.rs?ref=9d9a209e9a61414cdf9c8065d445ce353d6ed45f", "patch": "@@ -164,7 +164,7 @@ pub mod ct {\n     pub fn parse_fmt_string(s: &str, err: ErrorFn) -> ~[Piece] {\n         fn push_slice(ps: &mut ~[Piece], s: &str, from: uint, to: uint) {\n             if to > from {\n-                ps.push(PieceString(s.slice_DBG_BRWD(from, to).to_owned()));\n+                ps.push(PieceString(s.slice(from, to).to_owned()));\n             }\n         }\n "}, {"sha": "2e20e859d5562044a70bec66a4399f789c6428d4", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=9d9a209e9a61414cdf9c8065d445ce353d6ed45f", "patch": "@@ -1729,7 +1729,7 @@ impl<T: Copy> CopyableVector<T> for &'self [const T] {\n }\n \n pub trait ImmutableVector<T> {\n-    pure fn slice_V_DBG_BRWD(&self, start: uint, end: uint) -> &'self [T];\n+    pure fn slice(&self, start: uint, end: uint) -> &'self [T];\n     pure fn head(&self) -> &'self T;\n     pure fn head_opt(&self) -> Option<&'self T>;\n     pure fn tail(&self) -> &'self [T];\n@@ -1753,7 +1753,7 @@ pub trait ImmutableVector<T> {\n impl<T> ImmutableVector<T> for &'self [T] {\n     /// Return a slice that points into another slice.\n     #[inline]\n-    pure fn slice_V_DBG_BRWD(&self, start: uint, end: uint) -> &'self [T] {\n+    pure fn slice(&self, start: uint, end: uint) -> &'self [T] {\n         slice(*self, start, end)\n     }\n \n@@ -3615,9 +3615,9 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_slice_V_DBG_BRWD() {\n+    fn test_slice_2() {\n         let v = ~[1, 2, 3, 4, 5];\n-        let v = v.slice_V_DBG_BRWD(1u, 3u);\n+        let v = v.slice(1u, 3u);\n         fail_unless!(v.len() == 2u);\n         fail_unless!(v[0] == 2);\n         fail_unless!(v[1] == 3);"}, {"sha": "3a2bbcee4b0a606327ec1b16564aee35f8c7f376", "filename": "src/libfuzzer/fuzzer.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibfuzzer%2Ffuzzer.rc", "raw_url": "https://github.com/rust-lang/rust/raw/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibfuzzer%2Ffuzzer.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Ffuzzer.rc?ref=9d9a209e9a61414cdf9c8065d445ce353d6ed45f", "patch": "@@ -336,7 +336,7 @@ pub fn check_variants_T<T: Copy>(\n \n pub fn last_part(filename: ~str) -> ~str {\n   let ix = option::get(str::rfind_char(filename, '/'));\n-  str::slice_DBG_BRWD(filename, ix + 1u, str::len(filename) - 3u).to_owned()\n+  str::slice(filename, ix + 1u, str::len(filename) - 3u).to_owned()\n }\n \n pub enum happiness {"}, {"sha": "4c8f27167816e49e88006014e232c3bd2c291a1b", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=9d9a209e9a61414cdf9c8065d445ce353d6ed45f", "patch": "@@ -771,7 +771,7 @@ pub fn link_binary(sess: Session,\n     fn unlib(config: @session::config, +stem: ~str) -> ~str {\n         if stem.starts_with(\"lib\") &&\n             config.os != session::os_win32 {\n-            stem.slice_DBG_BRWD(3, stem.len()).to_owned()\n+            stem.slice(3, stem.len()).to_owned()\n         } else {\n             stem\n         }"}, {"sha": "6bb10a42f3e457fa5db5e579f4e89cbaff192d8d", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=9d9a209e9a61414cdf9c8065d445ce353d6ed45f", "patch": "@@ -1239,7 +1239,7 @@ fn encode_crate_deps(ecx: @EncodeContext,\n         }\n \n         // mut -> immutable hack for vec::map\n-        deps.slice_V_DBG_BRWD(0, deps.len()).to_owned()\n+        deps.slice(0, deps.len()).to_owned()\n     }\n \n     // We're just going to write a list of crate 'name-hash-version's, with"}, {"sha": "3edceebba0cc021568d3eb5bcc87cb07370e1b6f", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=9d9a209e9a61414cdf9c8065d445ce353d6ed45f", "patch": "@@ -888,14 +888,14 @@ fn check_item_non_camel_case_types(cx: ty::ctxt, it: @ast::item) {\n \n     fn ident_without_trailing_underscores(ident: &'r str) -> &'r str {\n         match str::rfind(ident, |c| c != '_') {\n-            Some(idx) => str::slice_DBG_BRWD(ident, 0, idx + 1),\n+            Some(idx) => str::slice(ident, 0, idx + 1),\n             None => ident, // all underscores\n         }\n     }\n \n     fn ident_without_leading_underscores(ident: &'r str) -> &'r str {\n         match str::find(ident, |c| c != '_') {\n-            Some(idx) => str::slice_DBG_BRWD(ident, idx, ident.len()),\n+            Some(idx) => str::slice(ident, idx, ident.len()),\n             None => ident // all underscores\n         }\n     }"}, {"sha": "8ffccff54b8d81136cc16ddfbfe8551e67f10713", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=9d9a209e9a61414cdf9c8065d445ce353d6ed45f", "patch": "@@ -1430,7 +1430,7 @@ pub fn find_vtable(tcx: ty::ctxt, ps: &param_substs,\n \n     // Vtables are stored in a flat array, finding the right one is\n     // somewhat awkward\n-    let first_n_bounds = ps.bounds.slice_V_DBG_BRWD(0, n_param);\n+    let first_n_bounds = ps.bounds.slice(0, n_param);\n     let vtables_to_skip =\n         ty::count_traits_and_supertraits(tcx, first_n_bounds);\n     let vtable_off = vtables_to_skip + n_bound;"}, {"sha": "c575465ddf7846d72aef8d23523deb807cbde0b5", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=9d9a209e9a61414cdf9c8065d445ce353d6ed45f", "patch": "@@ -250,7 +250,7 @@ fn get_cache(cx: @CrateContext) -> metadata_cache {\n \n fn get_file_path_and_dir(work_dir: &str, full_path: &str) -> (~str, ~str) {\n     (if str::starts_with(full_path, work_dir) {\n-        str::slice_DBG_BRWD(full_path, str::len(work_dir) + 1u,\n+        str::slice(full_path, str::len(work_dir) + 1u,\n                    str::len(full_path)).to_owned()\n     } else {\n         full_path.to_owned()"}, {"sha": "eb63d675d80af440c9397c097c915ac9bc00356e", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=9d9a209e9a61414cdf9c8065d445ce353d6ed45f", "patch": "@@ -488,7 +488,7 @@ pub fn parameterized(cx: ctxt,\n \n pub fn ty_to_short_str(cx: ctxt, typ: t) -> ~str {\n     let mut s = encoder::encoded_ty(cx, typ);\n-    if str::len(s) >= 32u { s = str::slice_DBG_BRWD(s, 0u, 32u).to_owned(); }\n+    if str::len(s) >= 32u { s = str::slice(s, 0u, 32u).to_owned(); }\n     return s;\n }\n "}, {"sha": "281c318eb152cc8b5a0aeb931d31a1c930b8a8ef", "filename": "src/librustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs?ref=9d9a209e9a61414cdf9c8065d445ce353d6ed45f", "patch": "@@ -171,7 +171,7 @@ fn first_sentence_(s: &str) -> ~str {\n     };\n     match idx {\n         Some(idx) if idx > 2u => {\n-            str::from_slice(str::slice_DBG_BRWD(s, 0, idx - 1))\n+            str::from_slice(str::slice(s, 0, idx - 1))\n         }\n         _ => {\n             if str::ends_with(s, ~\".\") {"}, {"sha": "58e84d727d5a2e2ad342977409cb525e4284172e", "filename": "src/librustdoc/markdown_writer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibrustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibrustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_writer.rs?ref=9d9a209e9a61414cdf9c8065d445ce353d6ed45f", "patch": "@@ -157,7 +157,7 @@ fn readclose(fd: libc::c_int) -> ~str {\n             let mut bytes = [0, ..4096];\n             while !reader.eof() {\n                 let nread = reader.read(bytes, bytes.len());\n-                writer.write(bytes.slice_V_DBG_BRWD(0, nread).to_owned());\n+                writer.write(bytes.slice(0, nread).to_owned());\n             }\n         });\n         os::fclose(file);"}, {"sha": "8b058048ff4ac6dd5dd5dcd2d8334aab569e387b", "filename": "src/librustdoc/sectionalize_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibrustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibrustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsectionalize_pass.rs?ref=9d9a209e9a61414cdf9c8065d445ce353d6ed45f", "patch": "@@ -154,7 +154,7 @@ fn sectionalize(desc: Option<~str>) -> (Option<~str>, ~[doc::Section]) {\n \n fn parse_header(line: ~str) -> Option<~str> {\n     if str::starts_with(line, ~\"# \") {\n-        Some(str::slice_DBG_BRWD(line, 2u, str::len(line)).to_owned())\n+        Some(str::slice(line, 2u, str::len(line)).to_owned())\n     } else {\n         None\n     }"}, {"sha": "506dfafa24715fc58d229e2766cee5017a96ee63", "filename": "src/librustdoc/unindent_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibrustdoc%2Funindent_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibrustdoc%2Funindent_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Funindent_pass.rs?ref=9d9a209e9a61414cdf9c8065d445ce353d6ed45f", "patch": "@@ -84,7 +84,7 @@ fn unindent(s: &str) -> ~str {\n                 copy *line\n             } else {\n                 fail_unless!(str::len(*line) >= min_indent);\n-                str::slice_DBG_BRWD(*line, min_indent, str::len(*line)).to_owned()\n+                str::slice(*line, min_indent, str::len(*line)).to_owned()\n             }\n         };\n         str::connect(unindented, ~\"\\n\")"}, {"sha": "d4b4c7b097c1c4fa5c5c4cb2079cdf6bb99b1ffa", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=9d9a209e9a61414cdf9c8065d445ce353d6ed45f", "patch": "@@ -831,7 +831,7 @@ priv impl BitvSet {\n                         f: &fn(uint, uint, uint) -> bool) {\n         let min = uint::min(self.bitv.storage.len(),\n                             other.bitv.storage.len());\n-        for self.bitv.storage.slice_V_DBG_BRWD(0, min).eachi |i, &w| {\n+        for self.bitv.storage.slice(0, min).eachi |i, &w| {\n             if !f(i * uint::bits, w, other.bitv.storage[i]) {\n                 return;\n             }\n@@ -852,12 +852,12 @@ priv impl BitvSet {\n         let min = uint::min(len1, len2);\n \n         /* only one of these loops will execute and that's the point */\n-        for self.bitv.storage.slice_V_DBG_BRWD(min, len1).eachi |i, &w| {\n+        for self.bitv.storage.slice(min, len1).eachi |i, &w| {\n             if !f(true, (i + min) * uint::bits, w) {\n                 return;\n             }\n         }\n-        for other.bitv.storage.slice_V_DBG_BRWD(min, len2).eachi |i, &w| {\n+        for other.bitv.storage.slice(min, len2).eachi |i, &w| {\n             if !f(false, (i + min) * uint::bits, w) {\n                 return;\n             }"}, {"sha": "105e34761a8edec73f047248a7c047fac1717db1", "filename": "src/libstd/flatpipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibstd%2Fflatpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibstd%2Fflatpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fflatpipes.rs?ref=9d9a209e9a61414cdf9c8065d445ce353d6ed45f", "patch": "@@ -571,7 +571,7 @@ pub mod bytepipes {\n         fn try_recv(&self, count: uint) -> Option<~[u8]> {\n             if vec::uniq_len(&const self.buf) >= count {\n                 let mut bytes = ::core::util::replace(&mut self.buf, ~[]);\n-                self.buf = bytes.slice_V_DBG_BRWD(count, bytes.len()).to_owned();\n+                self.buf = bytes.slice(count, bytes.len()).to_owned();\n                 bytes.truncate(count);\n                 return Some(bytes);\n             } else if vec::uniq_len(&const self.buf) > 0 {"}, {"sha": "e2702b7d566c55fec503d570d3507e7c1059776c", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=9d9a209e9a61414cdf9c8065d445ce353d6ed45f", "patch": "@@ -243,7 +243,7 @@ pub fn getopts(args: &[~str], opts: &[Opt]) -> Result {\n                 let mut names;\n                 let mut i_arg = None;\n                 if cur[1] == '-' as u8 {\n-                    let tail = str::slice_DBG_BRWD(cur, 2, curlen).to_owned();\n+                    let tail = str::slice(cur, 2, curlen).to_owned();\n                     let tail_eq = str::splitn_char(tail, '=', 1);\n                     if tail_eq.len() <= 1 {\n                         names = ~[Long(tail)];\n@@ -279,7 +279,7 @@ pub fn getopts(args: &[~str], opts: &[Opt]) -> Result {\n                                   No => false\n                                 };\n                             if arg_follows && j < curlen {\n-                                i_arg = Some(cur.slice_DBG_BRWD(j, curlen).to_owned());\n+                                i_arg = Some(cur.slice(j, curlen).to_owned());\n                                 break;\n                             } else {\n                                 last_valid_opt_id = None;"}, {"sha": "4943b374980a9d6f6e1ab88b85ead7cfd06c802a", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=9d9a209e9a61414cdf9c8065d445ce353d6ed45f", "patch": "@@ -317,10 +317,10 @@ pure fn split_char_first(s: &str, c: char) -> (~str, ~str) {\n         }\n     }\n     if index+mat == len {\n-        return (str::slice_DBG_BRWD(s, 0, index).to_owned(), ~\"\");\n+        return (str::slice(s, 0, index).to_owned(), ~\"\");\n     } else {\n-        return (str::slice_DBG_BRWD(s, 0, index).to_owned(),\n-             str::slice_DBG_BRWD(s, index + mat, str::len(s)).to_owned());\n+        return (str::slice(s, 0, index).to_owned(),\n+             str::slice(s, index + mat, str::len(s)).to_owned());\n     }\n }\n \n@@ -386,8 +386,8 @@ pub pure fn get_scheme(rawurl: &str) -> Result<(~str, ~str), ~str> {\n             if i == 0 {\n                 return Err(~\"url: Scheme cannot be empty.\");\n             } else {\n-                return Ok((rawurl.slice_DBG_BRWD(0,i).to_owned(),\n-                                rawurl.slice_DBG_BRWD(i+1,str::len(rawurl)).to_owned()));\n+                return Ok((rawurl.slice(0,i).to_owned(),\n+                                rawurl.slice(i+1,str::len(rawurl)).to_owned()));\n             }\n           }\n           _ => {\n@@ -489,7 +489,7 @@ pure fn get_authority(rawurl: &str) ->\n               }\n               Ip6Host => {\n                 if colon_count > 7 {\n-                    host = str::slice_DBG_BRWD(rawurl, begin, i).to_owned();\n+                    host = str::slice(rawurl, begin, i).to_owned();\n                     pos = i;\n                     st = InPort;\n                 }\n@@ -506,13 +506,13 @@ pure fn get_authority(rawurl: &str) ->\n             colon_count = 0; // reset count\n             match st {\n               Start => {\n-                let user = str::slice_DBG_BRWD(rawurl, begin, i).to_owned();\n+                let user = str::slice(rawurl, begin, i).to_owned();\n                 userinfo = Some(UserInfo::new(user, None));\n                 st = InHost;\n               }\n               PassHostPort => {\n-                let user = str::slice_DBG_BRWD(rawurl, begin, pos).to_owned();\n-                let pass = str::slice_DBG_BRWD(rawurl, pos+1, i).to_owned();\n+                let user = str::slice(rawurl, begin, pos).to_owned();\n+                let pass = str::slice(rawurl, pos+1, i).to_owned();\n                 userinfo = Some(UserInfo::new(user, Some(pass)));\n                 st = InHost;\n               }\n@@ -543,31 +543,31 @@ pure fn get_authority(rawurl: &str) ->\n     match st {\n       Start => {\n         if host_is_end_plus_one() {\n-            host = str::slice_DBG_BRWD(rawurl, begin, end+1).to_owned();\n+            host = str::slice(rawurl, begin, end+1).to_owned();\n         } else {\n-            host = str::slice_DBG_BRWD(rawurl, begin, end).to_owned();\n+            host = str::slice(rawurl, begin, end).to_owned();\n         }\n       }\n       PassHostPort | Ip6Port => {\n         if in != Digit {\n             return Err(~\"Non-digit characters in port.\");\n         }\n-        host = str::slice_DBG_BRWD(rawurl, begin, pos).to_owned();\n-        port = Some(str::slice_DBG_BRWD(rawurl, pos+1, end).to_owned());\n+        host = str::slice(rawurl, begin, pos).to_owned();\n+        port = Some(str::slice(rawurl, pos+1, end).to_owned());\n       }\n       Ip6Host | InHost => {\n-        host = str::slice_DBG_BRWD(rawurl, begin, end).to_owned();\n+        host = str::slice(rawurl, begin, end).to_owned();\n       }\n       InPort => {\n         if in != Digit {\n             return Err(~\"Non-digit characters in port.\");\n         }\n-        port = Some(str::slice_DBG_BRWD(rawurl, pos+1, end).to_owned());\n+        port = Some(str::slice(rawurl, pos+1, end).to_owned());\n       }\n     }\n \n     let rest = if host_is_end_plus_one() { ~\"\" }\n-    else { str::slice_DBG_BRWD(rawurl, end, len).to_owned() };\n+    else { str::slice(rawurl, end, len).to_owned() };\n     return Ok((userinfo, host, port, rest));\n }\n \n@@ -599,24 +599,24 @@ pure fn get_path(rawurl: &str, authority: bool) ->\n         }\n     }\n \n-    return Ok((decode_component(str::slice_DBG_BRWD(rawurl, 0, end).to_owned()),\n-                    str::slice_DBG_BRWD(rawurl, end, len).to_owned()));\n+    return Ok((decode_component(str::slice(rawurl, 0, end).to_owned()),\n+                    str::slice(rawurl, end, len).to_owned()));\n }\n \n // returns the parsed query and the fragment, if present\n pure fn get_query_fragment(rawurl: &str) ->\n     Result<(Query, Option<~str>), ~str> {\n     if !str::starts_with(rawurl, ~\"?\") {\n         if str::starts_with(rawurl, ~\"#\") {\n-            let f = decode_component(str::slice_DBG_BRWD(rawurl,\n+            let f = decode_component(str::slice(rawurl,\n                                                 1,\n                                                 str::len(rawurl)).to_owned());\n             return Ok((~[], Some(f)));\n         } else {\n             return Ok((~[], None));\n         }\n     }\n-    let (q, r) = split_char_first(str::slice_DBG_BRWD(rawurl, 1,\n+    let (q, r) = split_char_first(str::slice(rawurl, 1,\n                                              str::len(rawurl)).to_owned(), '#');\n     let f = if str::len(r) != 0 {\n         Some(decode_component(r)) } else { None };"}, {"sha": "ff7d4ec3b1cfac336b9aaeab308fd2922285a74c", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=9d9a209e9a61414cdf9c8065d445ce353d6ed45f", "patch": "@@ -1293,7 +1293,7 @@ mod tests {\n                 unsafe {\n                     match (*node) {\n                       node::Leaf(x) => {\n-                        *str += str::slice_DBG_BRWD(\n+                        *str += str::slice(\n                             *x.content, x.byte_offset,\n                             x.byte_offset + x.byte_len).to_owned();\n                       }"}, {"sha": "077ab191e69e3708b00cf053791f84cc14e0a363", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=9d9a209e9a61414cdf9c8065d445ce353d6ed45f", "patch": "@@ -398,7 +398,7 @@ mod tests {\n                 let mut left = len;\n                 while left > 0u {\n                     let take = (left + 1u) / 2u;\n-                    sh.input_str(str::slice_DBG_BRWD(t.input, len - left,\n+                    sh.input_str(str::slice(t.input, len - left,\n                                  take + len - left).to_owned());\n                     left = left - take;\n                 }"}, {"sha": "727d386f277f92046b14c204b5f319ccb3f48535", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=9d9a209e9a61414cdf9c8065d445ce353d6ed45f", "patch": "@@ -266,7 +266,7 @@ pub impl FileMap {\n                 Some(e) => e,\n                 None => str::len(*self.src)\n             };\n-            str::slice_DBG_BRWD(*self.src, begin, end).to_owned()\n+            str::slice(*self.src, begin, end).to_owned()\n         }\n     }\n \n@@ -395,7 +395,7 @@ pub impl CodeMap {\n         let begin = self.lookup_byte_offset(sp.lo);\n         let end = self.lookup_byte_offset(sp.hi);\n         fail_unless!(begin.fm.start_pos == end.fm.start_pos);\n-        return str::slice_DBG_BRWD(*begin.fm.src,\n+        return str::slice(*begin.fm.src,\n                           begin.pos.to_uint(), end.pos.to_uint()).to_owned();\n     }\n "}, {"sha": "5a6fd6fec5894f914adf55cf6953bd12cc4b14cd", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=9d9a209e9a61414cdf9c8065d445ce353d6ed45f", "patch": "@@ -112,7 +112,7 @@ pub fn add_new_extension(cx: @ext_ctxt,\n                             match (*tt) {\n                                 // cut off delimiters; don't parse 'em\n                                 tt_delim(ref tts) => {\n-                                    (*tts).slice_V_DBG_BRWD(1u,(*tts).len()-1u).to_owned()\n+                                    (*tts).slice(1u,(*tts).len()-1u).to_owned()\n                                 }\n                                 _ => cx.span_fatal(\n                                     sp, ~\"macro rhs must be delimited\")"}, {"sha": "b5072e8c2b54d18dcf4da6e67a4ddd1e18cf2b1a", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=9d9a209e9a61414cdf9c8065d445ce353d6ed45f", "patch": "@@ -76,7 +76,7 @@ pub fn strip_doc_comment_decoration(comment: &str) -> ~str {\n         while j > i && lines[j - 1u].trim().is_empty() {\n             j -= 1u;\n         }\n-        return lines.slice_V_DBG_BRWD(i, j).to_owned();\n+        return lines.slice(i, j).to_owned();\n     }\n \n     // drop leftmost columns that contain only values in chars\n@@ -103,17 +103,17 @@ pub fn strip_doc_comment_decoration(comment: &str) -> ~str {\n             if i > chars.len() {\n                 ~\"\"\n             } else {\n-                str::from_chars(chars.slice_V_DBG_BRWD(i, chars.len()).to_owned())\n+                str::from_chars(chars.slice(i, chars.len()).to_owned())\n             }\n         };\n     }\n \n     if comment.starts_with(~\"//\") {\n-        return comment.slice_DBG_BRWD(3u, comment.len()).trim();\n+        return comment.slice(3u, comment.len()).trim();\n     }\n \n     if comment.starts_with(~\"/*\") {\n-        let lines = str::lines_any(comment.slice_DBG_BRWD(3u, comment.len() - 2u).to_owned());\n+        let lines = str::lines_any(comment.slice(3u, comment.len() - 2u).to_owned());\n         let lines = vertical_trim(lines);\n         let lines = block_trim(lines, ~\"\\t \", None);\n         let lines = block_trim(lines, ~\"*\", Some(1u));\n@@ -218,7 +218,7 @@ fn trim_whitespace_prefix_and_push_line(lines: &mut ~[~str],\n     let col = col.to_uint();\n     if all_whitespace(s, 0u, uint::min(len, col)) {\n         if col < len {\n-            s1 = str::slice_DBG_BRWD(s, col, len).to_owned();\n+            s1 = str::slice(s, col, len).to_owned();\n         } else { s1 = ~\"\"; }\n     } else { s1 = s; }\n     debug!(\"pushing line: %s\", s1);"}, {"sha": "6cb4065935c6e52e2cd18e8abcfd307a258546a1", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=9d9a209e9a61414cdf9c8065d445ce353d6ed45f", "patch": "@@ -176,7 +176,7 @@ pub fn get_str_from(rdr: @mut StringReader, start: BytePos) -> ~str {\n     unsafe {\n         // I'm pretty skeptical about this subtraction. What if there's a\n         // multi-byte character before the mark?\n-        return str::slice_DBG_BRWD(*rdr.src, start.to_uint() - 1u,\n+        return str::slice(*rdr.src, start.to_uint() - 1u,\n                           byte_offset(rdr).to_uint() - 1u).to_owned();\n     }\n }"}, {"sha": "c9a5507f8de0fb5a0f7bf9de92143ced1ec775af", "filename": "src/test/compile-fail/issue-3888.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Ftest%2Fcompile-fail%2Fissue-3888.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d9a209e9a61414cdf9c8065d445ce353d6ed45f/src%2Ftest%2Fcompile-fail%2Fissue-3888.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3888.rs?ref=9d9a209e9a61414cdf9c8065d445ce353d6ed45f", "patch": "@@ -17,7 +17,7 @@ fn vec_peek<T>(v: &'r [T]) -> Option< (&'r T, &'r [T]) > {\n         let vec_len = v.len();\n         let head = &v[0];\n         // note: this *shouldn't* be an illegal borrow! See #3888\n-        let tail = v.slice_V_DBG_BRWD(1, vec_len); //~ ERROR illegal borrow: borrowed value does not live long enough\n+        let tail = v.slice(1, vec_len); //~ ERROR illegal borrow: borrowed value does not live long enough\n         Some( (head, tail) )\n     }\n }"}]}