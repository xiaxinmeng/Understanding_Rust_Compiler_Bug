{"sha": "66c1ca857bf8e7c27b61d02c4e2127a724551ba8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2YzFjYTg1N2JmOGU3YzI3YjYxZDAyYzRlMjEyN2E3MjQ1NTFiYTg=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-07-27T07:13:00Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-07-27T13:19:31Z"}, "message": "Update the parser to accept the new syntax", "tree": {"sha": "a32e8f493db000c730568548b1873951dcb11379", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a32e8f493db000c730568548b1873951dcb11379"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66c1ca857bf8e7c27b61d02c4e2127a724551ba8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66c1ca857bf8e7c27b61d02c4e2127a724551ba8", "html_url": "https://github.com/rust-lang/rust/commit/66c1ca857bf8e7c27b61d02c4e2127a724551ba8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66c1ca857bf8e7c27b61d02c4e2127a724551ba8/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "300eb3011355d81f95b79de4ca85e6190f1935a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/300eb3011355d81f95b79de4ca85e6190f1935a4", "html_url": "https://github.com/rust-lang/rust/commit/300eb3011355d81f95b79de4ca85e6190f1935a4"}], "stats": {"total": 214, "additions": 59, "deletions": 155}, "files": [{"sha": "e0ca20a4f1dd3ccc8d6ac44b613357df577c214e", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 59, "deletions": 155, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/66c1ca857bf8e7c27b61d02c4e2127a724551ba8/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66c1ca857bf8e7c27b61d02c4e2127a724551ba8/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=66c1ca857bf8e7c27b61d02c4e2127a724551ba8", "patch": "@@ -155,6 +155,7 @@ fn bad_expr_word_table() -> hashmap[str, ()] {\n     words.insert(\"do\", ());\n     words.insert(\"alt\", ());\n     words.insert(\"for\", ());\n+    words.insert(\"each\", ());\n     words.insert(\"break\", ());\n     words.insert(\"cont\", ());\n     words.insert(\"put\", ());\n@@ -221,6 +222,11 @@ fn parse_value_ident(&parser p) -> ast::ident {\n     ret parse_ident(p);\n }\n \n+fn eat(&parser p, &token::token tok) -> bool {\n+    ret if p.peek() == tok { p.bump(); true }\n+        else { false };\n+}\n+\n fn is_word(&parser p, &str word) -> bool {\n     ret alt (p.peek()) {\n             case (token::IDENT(?sid, false)) { str::eq(word, p.get_str(sid)) }\n@@ -262,16 +268,16 @@ fn check_bad_word(&parser p) {\n fn parse_ty_fn(ast::proto proto, &parser p, uint lo) -> ast::ty_ {\n     fn parse_fn_input_ty(&parser p) -> ast::ty_arg {\n         auto lo = p.get_lo_pos();\n+        // Ignore arg name, if present\n+        if is_plain_ident(p) && p.look_ahead(1u) == token::COLON {\n+            p.bump(); p.bump();\n+        }\n         auto mode = ast::val;\n         if (p.peek() == token::BINOP(token::AND)) {\n             p.bump();\n             mode = ast::alias(eat_word(p, \"mutable\"));\n         }\n         auto t = parse_ty(p);\n-        alt (p.peek()) {\n-            case (token::IDENT(_, _)) { p.bump();/* ignore param name */ }\n-            case (_) {/* no param name present */ }\n-        }\n         ret spanned(lo, t.span.hi, rec(mode=mode, ty=t));\n     }\n     auto lo = p.get_lo_pos();\n@@ -342,14 +348,6 @@ fn parse_mt(&parser p) -> ast::mt {\n }\n \n fn parse_ty_field(&parser p) -> ast::ty_field {\n-    auto lo = p.get_lo_pos();\n-    auto mt = parse_mt(p);\n-    auto id = parse_ident(p);\n-    ret spanned(lo, mt.ty.span.hi, rec(ident=id, mt=mt));\n-}\n-\n-// FIXME rename to parse_ty_field once the other one is dropped\n-fn parse_ty_field_modern(&parser p) -> ast::ty_field {\n     auto lo = p.get_lo_pos();\n     auto mut = parse_mutability(p);\n     auto id = parse_ident(p);\n@@ -555,7 +553,7 @@ fn parse_ty(&parser p) -> @ast::ty {\n         t = ast::ty_ptr(mt);\n     } else if (p.peek() == token::LBRACE) {\n         auto elems = parse_seq(token::LBRACE, token::RBRACE,\n-                               some(token::COMMA), parse_ty_field_modern, p);\n+                               some(token::COMMA), parse_ty_field, p);\n         hi = elems.span.hi;\n         t = ast::ty_rec(elems.node);\n         if (p.peek() == token::COLON) {\n@@ -568,20 +566,6 @@ fn parse_ty(&parser p) -> @ast::ty {\n         t = ast::ty_vec(parse_mt(p));\n         hi = p.get_hi_pos();\n         expect(p, token::RBRACKET);\n-    } else if (eat_word(p, \"rec\")) {\n-        auto elems =\n-            parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n-                           parse_ty_field, p);\n-        hi = elems.span.hi;\n-        // possible constrs\n-        // FIXME: something seems dodgy or at least repetitive\n-        // about how constrained types get parsed\n-        t = ast::ty_rec(elems.node);\n-        if (p.peek() == token::COLON) {\n-            p.bump();\n-            t = ast::ty_constr(@spanned(lo, hi, t),\n-                               parse_type_constraints(p));\n-        }\n     } else if (eat_word(p, \"fn\")) {\n         auto flo = p.get_last_lo_pos();\n         t = parse_ty_fn(ast::proto_fn, p, flo);\n@@ -621,12 +605,12 @@ fn parse_ty(&parser p) -> @ast::ty {\n \n fn parse_arg(&parser p) -> ast::arg {\n     let ast::mode m = ast::val;\n-    if (p.peek() == token::BINOP(token::AND)) {\n-        p.bump();\n+    let ast::ident i = parse_value_ident(p);\n+    expect(p, token::COLON);\n+    if eat(p, token::BINOP(token::AND)) {\n         m = ast::alias(eat_word(p, \"mutable\"));\n     }\n     let @ast::ty t = parse_ty(p);\n-    let ast::ident i = parse_value_ident(p);\n     ret rec(mode=m, ty=t, ident=i, id=p.get_id());\n }\n \n@@ -710,6 +694,10 @@ fn is_ident(token::token t) -> bool {\n     ret false;\n }\n \n+fn is_plain_ident(&parser p) -> bool {\n+    ret alt p.peek() { token::IDENT(_, false) { true } _ { false } };\n+}\n+\n fn parse_path(&parser p) -> ast::path {\n     auto lo = p.get_lo_pos();\n     auto hi = lo;\n@@ -806,8 +794,7 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n     } else if (p.peek() == token::LBRACE) {\n         p.bump();\n         if (is_word(p, \"mutable\") ||\n-            alt p.peek() { token::IDENT(_, false) { true } _ { false } } &&\n-            p.look_ahead(1u) == token::COLON) {\n+            is_plain_ident(p) && p.look_ahead(1u) == token::COLON) {\n             auto fields = ~[parse_field(p, token::COLON)];\n             auto base = none;\n             while p.peek() != token::RBRACE {\n@@ -915,27 +902,6 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n         let ast::anon_obj ob =\n             rec(fields=fields, methods=meths, with_obj=with_obj);\n         ex = ast::expr_anon_obj(ob);\n-    } else if (eat_word(p, \"rec\")) {\n-        expect(p, token::LPAREN);\n-        auto fields = ~[parse_field(p, token::EQ)];\n-        auto more = true;\n-        auto base = none;\n-        while (more) {\n-            if (p.peek() == token::RPAREN) {\n-                hi = p.get_hi_pos();\n-                p.bump();\n-                more = false;\n-            } else if (eat_word(p, \"with\")) {\n-                base = some(parse_expr(p));\n-                hi = p.get_hi_pos();\n-                expect(p, token::RPAREN);\n-                more = false;\n-            } else if (p.peek() == token::COMMA) {\n-                p.bump();\n-                fields += ~[parse_field(p, token::EQ)];\n-            } else { unexpected(p, p.peek()); }\n-        }\n-        ex = ast::expr_rec(fields, base);\n     } else if (eat_word(p, \"bind\")) {\n         auto e = parse_expr_res(p, RESTRICT_NO_CALL_EXPRS);\n         fn parse_expr_opt(&parser p) -> option::t[@ast::expr] {\n@@ -1349,25 +1315,15 @@ fn parse_else_expr(&parser p) -> @ast::expr {\n     }\n }\n \n-fn parse_head_local(&parser p) -> @ast::local {\n-    if (eat_word(p, \"auto\")) {\n-        ret parse_auto_local(p);\n-    } else {\n-        ret parse_typed_local(p);\n-    }\n-}\n-\n fn parse_for_expr(&parser p) -> @ast::expr {\n     auto lo = p.get_last_lo_pos();\n     auto is_each = eat_word(p, \"each\");\n-    expect(p, token::LPAREN);\n-    auto decl = parse_head_local(p);\n+    auto decl = parse_local(p, false);\n     expect_word(p, \"in\");\n     auto seq = parse_expr(p);\n-    expect(p, token::RPAREN);\n     auto body = parse_block(p);\n     auto hi = body.span.hi;\n-    if (is_each) {\n+    if is_each {\n         ret mk_expr(p, lo, hi, ast::expr_for_each(decl, seq, body));\n     } else {\n         ret mk_expr(p, lo, hi, ast::expr_for(decl, seq, body));\n@@ -1483,21 +1439,6 @@ fn parse_pat(&parser p) -> @ast::pat {\n             p.bump();\n             pat = ast::pat_wild;\n         }\n-        case (token::QUES) {\n-            p.bump();\n-            alt (p.peek()) {\n-                case (token::IDENT(?id, _)) {\n-                    hi = p.get_hi_pos();\n-                    p.bump();\n-                    pat = ast::pat_bind(p.get_str(id));\n-                }\n-                case (?tok) {\n-                    p.fatal(\"expected identifier after '?' in pattern but \" +\n-                              \"found \" + token::to_str(p.get_reader(), tok));\n-                    fail;\n-                }\n-            }\n-        }\n         case (token::AT) {\n             p.bump();\n             auto sub = parse_pat(p);\n@@ -1548,6 +1489,15 @@ fn parse_pat(&parser p) -> @ast::pat {\n                 auto lit = parse_lit(p);\n                 hi = lit.span.hi;\n                 pat = ast::pat_lit(@lit);\n+            } else if (is_plain_ident(p) &&\n+                       alt p.look_ahead(1u) {\n+                         token::DOT | token::LPAREN | token::LBRACKET {\n+                           false\n+                         }\n+                         _ { true }\n+                       }) {\n+                hi = p.get_hi_pos();\n+                pat = ast::pat_bind(parse_ident(p));\n             } else {\n                 auto tag_path = parse_path_and_ty_param_substs(p);\n                 hi = tag_path.span.hi;\n@@ -1559,7 +1509,11 @@ fn parse_pat(&parser p) -> @ast::pat {\n                         args = a.node;\n                         hi = a.span.hi;\n                     }\n-                    case (_) { args = ~[]; }\n+                    case (token::DOT) {\n+                        args = ~[];\n+                        p.bump();\n+                    }\n+                    case (_) { expect(p, token::LPAREN); fail; }\n                 }\n                 pat = ast::pat_tag(tag_path, args);\n             }\n@@ -1568,81 +1522,30 @@ fn parse_pat(&parser p) -> @ast::pat {\n     ret @rec(id=p.get_id(), node=pat, span=rec(lo=lo, hi=hi));\n }\n \n-fn parse_local_full(&option::t[@ast::ty] tyopt, &parser p)\n-    -> @ast::local {\n+fn parse_local(&parser p, bool allow_init) -> @ast::local {\n     auto lo = p.get_lo_pos();\n     auto ident = parse_value_ident(p);\n-    auto init = parse_initializer(p);\n-    ret @spanned(lo, p.get_hi_pos(),\n-                 rec(ty=tyopt,\n-                     infer=false,\n-                     ident=ident,\n-                     init=init,\n-                     id=p.get_id()));\n-}\n-\n-fn parse_typed_local(&parser p) -> @ast::local {\n-    auto ty = parse_ty(p);\n-    ret parse_local_full(some(ty), p);\n-}\n-\n-fn parse_auto_local(&parser p) -> @ast::local {\n-    ret parse_local_full(none, p);\n-}\n-\n-// FIXME simplify when old syntax is no longer supported\n-fn parse_let(&parser p) -> @ast::decl {\n-    if alt p.peek() { token::IDENT(_, false) { true } _ { false } } {\n-        alt p.look_ahead(1u) {\n-          token::COLON | token::SEMI | token::COMMA | token::EQ |\n-          token::LARROW {\n-            ret parse_let_modern(p);\n-          }\n-          _ {}\n-        }\n+    auto ty = none;\n+    if eat(p, token::COLON) {\n+        ty = some(parse_ty(p));\n     }\n-    auto lo = p.get_last_lo_pos();\n-    auto locals = ~[parse_typed_local(p)];\n-    while p.peek() == token::COMMA {\n-        p.bump();\n-        locals += ~[parse_typed_local(p)];\n-    }\n-    ret @spanned(lo, p.get_hi_pos(), ast::decl_local(locals));\n+    auto init = if allow_init { parse_initializer(p) }\n+                else { none };\n+    ret @spanned(lo, p.get_last_hi_pos(),\n+                 rec(ty=ty, infer=false, ident=ident,\n+                     init=init, id=p.get_id()));\n }\n \n-fn parse_let_modern(&parser p) -> @ast::decl {\n-    fn parse_local(&parser p) -> @ast::local {\n-        auto lo = p.get_lo_pos();\n-        auto ident = parse_value_ident(p);\n-        auto ty = none;\n-        if p.peek() == token::COLON {\n-            p.bump();\n-            ty = some(parse_ty(p));\n-        }\n-        auto init = parse_initializer(p);\n-        ret @spanned(lo, p.get_last_hi_pos(),\n-                     rec(ty=ty, infer=false, ident=ident,\n-                         init=init, id=p.get_id()));\n-    }\n+fn parse_let(&parser p) -> @ast::decl {\n     auto lo = p.get_lo_pos();\n-    auto locals = ~[parse_local(p)];\n+    auto locals = ~[parse_local(p, true)];\n     while p.peek() == token::COMMA {\n         p.bump();\n-        locals += ~[parse_local(p)];\n+        locals += ~[parse_local(p, true)];\n     }\n     ret @spanned(lo, p.get_last_hi_pos(), ast::decl_local(locals));\n }\n \n-fn parse_auto(&parser p) -> @ast::decl {\n-    auto lo = p.get_last_lo_pos();\n-    auto locals = ~[parse_auto_local(p)];\n-    while p.peek() == token::COMMA {\n-        p.bump();\n-        locals += ~[parse_auto_local(p)];\n-    }\n-    ret @spanned(lo, p.get_hi_pos(), ast::decl_local(locals));\n-}\n-\n fn parse_stmt(&parser p) -> @ast::stmt {\n     if (p.get_file_type() == SOURCE_FILE) {\n         ret parse_source_stmt(p);\n@@ -1660,9 +1563,6 @@ fn parse_source_stmt(&parser p) -> @ast::stmt {\n     if (eat_word(p, \"let\")) {\n         auto decl = parse_let(p);\n         ret @spanned(lo, decl.span.hi, ast::stmt_decl(decl, p.get_id()));\n-    } else if (eat_word(p, \"auto\")) {\n-        auto decl = parse_auto(p);\n-        ret @spanned(lo, decl.span.hi, ast::stmt_decl(decl, p.get_id()));\n     } else {\n \n         auto item_attrs;\n@@ -1850,11 +1750,11 @@ fn parse_ty_params(&parser p) -> ast::ty_param[] {\n fn parse_fn_decl(&parser p, ast::purity purity) -> ast::fn_decl {\n     let ast::spanned[ast::arg[]] inputs =\n         parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n-                       parse_arg, p);\n+                  parse_arg, p);\n     let ty_or_bang rslt;\n-// Use the args list to translate each bound variable\n-// mentioned in a constraint to an arg index.\n-// Seems weird to do this in the parser, but I'm not sure how else to.\n+    // Use the args list to translate each bound variable\n+    // mentioned in a constraint to an arg index.\n+    // Seems weird to do this in the parser, but I'm not sure how else to.\n     auto constrs = ~[];\n     if (p.peek() == token::COLON) {\n         p.bump();\n@@ -1917,15 +1817,17 @@ fn parse_item_fn_or_iter(&parser p, ast::purity purity, ast::proto proto,\n \n fn parse_obj_field(&parser p) -> ast::obj_field {\n     auto mut = parse_mutability(p);\n-    auto ty = parse_ty(p);\n     auto ident = parse_value_ident(p);\n+    expect(p, token::COLON);\n+    auto ty = parse_ty(p);\n     ret rec(mut=mut, ty=ty, ident=ident, id=p.get_id());\n }\n \n fn parse_anon_obj_field(&parser p) -> ast::anon_obj_field {\n     auto mut = parse_mutability(p);\n-    auto ty = parse_ty(p);\n     auto ident = parse_value_ident(p);\n+    expect(p, token::COLON);\n+    auto ty = parse_ty(p);\n     expect(p, token::EQ);\n     auto expr = parse_expr(p);\n     ret rec(mut=mut, ty=ty, expr=expr, ident=ident, id=p.get_id());\n@@ -1988,8 +1890,9 @@ fn parse_item_res(&parser p, ast::layer lyr, &ast::attribute[] attrs) ->\n     auto ident = parse_value_ident(p);\n     auto ty_params = parse_ty_params(p);\n     expect(p, token::LPAREN);\n-    auto t = parse_ty(p);\n     auto arg_ident = parse_value_ident(p);\n+    expect(p, token::COLON);\n+    auto t = parse_ty(p);\n     expect(p, token::RPAREN);\n     auto dtor = parse_block(p);\n     auto decl = rec(inputs=~[rec(mode=ast::alias(false), ty=t,\n@@ -2029,8 +1932,9 @@ fn parse_mod_items(&parser p, token::token term,\n \n fn parse_item_const(&parser p, &ast::attribute[] attrs) -> @ast::item {\n     auto lo = p.get_last_lo_pos();\n-    auto ty = parse_ty(p);\n     auto id = parse_value_ident(p);\n+    expect(p, token::COLON);\n+    auto ty = parse_ty(p);\n     expect(p, token::EQ);\n     auto e = parse_expr(p);\n     auto hi = p.get_hi_pos();"}]}