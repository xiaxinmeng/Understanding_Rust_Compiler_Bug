{"sha": "ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491", "node_id": "C_kwDOAAsO6NoAKGVkNzZiNzczYjU3Y2YwYWE0OGVjNGUyZmM2ZDZhM2Y3YTkwNzk0OTE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-28T04:04:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-28T04:04:29Z"}, "message": "Auto merge of #97284 - b-naber:constraint-dyn-impl-suggestion, r=estebank\n\nAdd suggestion for relaxing static lifetime bounds on dyn trait impls in NLL\n\nThis PR introduces suggestions for relaxing static lifetime bounds on impls of dyn trait items for NLL similar to what is already available in lexical region diagnostics.\n\nFixes https://github.com/rust-lang/rust/issues/95701\n\nr? `@estebank`", "tree": {"sha": "3ec0e6ff4813c0970206a5ef9b3b86bcb4f65d06", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3ec0e6ff4813c0970206a5ef9b3b86bcb4f65d06"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491", "html_url": "https://github.com/rust-lang/rust/commit/ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "764b8615e9149431d8790e3c07cb663642fe393d", "url": "https://api.github.com/repos/rust-lang/rust/commits/764b8615e9149431d8790e3c07cb663642fe393d", "html_url": "https://github.com/rust-lang/rust/commit/764b8615e9149431d8790e3c07cb663642fe393d"}, {"sha": "3c6c8d5a8dbf4db20450ed5793ef35f29c13466c", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c6c8d5a8dbf4db20450ed5793ef35f29c13466c", "html_url": "https://github.com/rust-lang/rust/commit/3c6c8d5a8dbf4db20450ed5793ef35f29c13466c"}], "stats": {"total": 472, "additions": 368, "deletions": 104}, "files": [{"sha": "a504d0c91222e39b1a419b3b59db80ac778d94ef", "filename": "compiler/rustc_borrowck/src/constraints/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs?ref=ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491", "patch": "@@ -95,7 +95,7 @@ pub struct OutlivesConstraint<'tcx> {\n     pub span: Span,\n \n     /// What caused this constraint?\n-    pub category: ConstraintCategory,\n+    pub category: ConstraintCategory<'tcx>,\n \n     /// Variance diagnostic information\n     pub variance_info: VarianceDiagInfo<'tcx>,"}, {"sha": "191574d7a8fb986a764bfa3fee12e1c8bfc07479", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491", "patch": "@@ -788,7 +788,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         err: &mut Diagnostic,\n         location: Location,\n         issued_borrow: &BorrowData<'tcx>,\n-        explanation: BorrowExplanation,\n+        explanation: BorrowExplanation<'tcx>,\n     ) {\n         let used_in_call = matches!(\n             explanation,\n@@ -1088,7 +1088,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 BorrowExplanation::MustBeValidFor {\n                     category:\n                         category @ (ConstraintCategory::Return(_)\n-                        | ConstraintCategory::CallArgument\n+                        | ConstraintCategory::CallArgument(_)\n                         | ConstraintCategory::OpaqueType),\n                     from_closure: false,\n                     ref region_name,\n@@ -1147,7 +1147,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         borrow: &BorrowData<'tcx>,\n         drop_span: Span,\n         borrow_spans: UseSpans<'tcx>,\n-        explanation: BorrowExplanation,\n+        explanation: BorrowExplanation<'tcx>,\n     ) -> DiagnosticBuilder<'cx, ErrorGuaranteed> {\n         debug!(\n             \"report_local_value_does_not_live_long_enough(\\\n@@ -1352,7 +1352,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         drop_span: Span,\n         borrow_spans: UseSpans<'tcx>,\n         proper_span: Span,\n-        explanation: BorrowExplanation,\n+        explanation: BorrowExplanation<'tcx>,\n     ) -> DiagnosticBuilder<'cx, ErrorGuaranteed> {\n         debug!(\n             \"report_temporary_value_does_not_live_long_enough(\\\n@@ -1410,7 +1410,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         borrow: &BorrowData<'tcx>,\n         borrow_span: Span,\n         return_span: Span,\n-        category: ConstraintCategory,\n+        category: ConstraintCategory<'tcx>,\n         opt_place_desc: Option<&String>,\n     ) -> Option<DiagnosticBuilder<'cx, ErrorGuaranteed>> {\n         let return_kind = match category {\n@@ -1508,7 +1508,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         use_span: UseSpans<'tcx>,\n         var_span: Span,\n         fr_name: &RegionName,\n-        category: ConstraintCategory,\n+        category: ConstraintCategory<'tcx>,\n         constraint_span: Span,\n         captured_var: &str,\n     ) -> DiagnosticBuilder<'cx, ErrorGuaranteed> {\n@@ -1559,7 +1559,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 let msg = format!(\"{} is returned here\", kind);\n                 err.span_note(constraint_span, &msg);\n             }\n-            ConstraintCategory::CallArgument => {\n+            ConstraintCategory::CallArgument(_) => {\n                 fr_name.highlight_region_name(&mut err);\n                 if matches!(use_span.generator_kind(), Some(GeneratorKind::Async(_))) {\n                     err.note("}, {"sha": "5d9e5907dffb0de57fb9e5ae58c5a27bf66f0a49", "filename": "compiler/rustc_borrowck/src/diagnostics/explain_borrow.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs?ref=ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491", "patch": "@@ -24,7 +24,7 @@ use crate::{\n use super::{find_use, RegionName, UseSpans};\n \n #[derive(Debug)]\n-pub(crate) enum BorrowExplanation {\n+pub(crate) enum BorrowExplanation<'tcx> {\n     UsedLater(LaterUseKind, Span, Option<Span>),\n     UsedLaterInLoop(LaterUseKind, Span, Option<Span>),\n     UsedLaterWhenDropped {\n@@ -33,7 +33,7 @@ pub(crate) enum BorrowExplanation {\n         should_note_order: bool,\n     },\n     MustBeValidFor {\n-        category: ConstraintCategory,\n+        category: ConstraintCategory<'tcx>,\n         from_closure: bool,\n         span: Span,\n         region_name: RegionName,\n@@ -51,11 +51,11 @@ pub(crate) enum LaterUseKind {\n     Other,\n }\n \n-impl BorrowExplanation {\n+impl<'tcx> BorrowExplanation<'tcx> {\n     pub(crate) fn is_explained(&self) -> bool {\n         !matches!(self, BorrowExplanation::Unexplained)\n     }\n-    pub(crate) fn add_explanation_to_diagnostic<'tcx>(\n+    pub(crate) fn add_explanation_to_diagnostic(\n         &self,\n         tcx: TyCtxt<'tcx>,\n         body: &Body<'tcx>,\n@@ -276,7 +276,7 @@ impl BorrowExplanation {\n     pub(crate) fn add_lifetime_bound_suggestion_to_diagnostic(\n         &self,\n         err: &mut Diagnostic,\n-        category: &ConstraintCategory,\n+        category: &ConstraintCategory<'tcx>,\n         span: Span,\n         region_name: &RegionName,\n     ) {\n@@ -305,7 +305,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         &self,\n         borrow_region: RegionVid,\n         outlived_region: RegionVid,\n-    ) -> (ConstraintCategory, bool, Span, Option<RegionName>) {\n+    ) -> (ConstraintCategory<'tcx>, bool, Span, Option<RegionName>) {\n         let BlameConstraint { category, from_closure, cause, variance_info: _ } =\n             self.regioncx.best_blame_constraint(\n                 &self.body,\n@@ -337,7 +337,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         location: Location,\n         borrow: &BorrowData<'tcx>,\n         kind_place: Option<(WriteKind, Place<'tcx>)>,\n-    ) -> BorrowExplanation {\n+    ) -> BorrowExplanation<'tcx> {\n         debug!(\n             \"explain_why_borrow_contains_point(location={:?}, borrow={:?}, kind_place={:?})\",\n             location, borrow, kind_place"}, {"sha": "9d81330745fe2a15ab3c93832321cc05d0575e5b", "filename": "compiler/rustc_borrowck/src/diagnostics/outlives_suggestion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs?ref=ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491", "patch": "@@ -161,7 +161,7 @@ impl OutlivesSuggestionBuilder {\n     pub(crate) fn intermediate_suggestion(\n         &mut self,\n         mbcx: &MirBorrowckCtxt<'_, '_>,\n-        errci: &ErrorConstraintInfo,\n+        errci: &ErrorConstraintInfo<'_>,\n         diag: &mut Diagnostic,\n     ) {\n         // Emit an intermediate note."}, {"sha": "35f805ce76e1c612c61d8b99e4f2b5139e169d19", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 196, "deletions": 26, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491", "patch": "@@ -1,19 +1,26 @@\n //! Error reporting machinery for lifetime errors.\n \n-use rustc_errors::{Diagnostic, DiagnosticBuilder, ErrorGuaranteed};\n+use rustc_data_structures::stable_set::FxHashSet;\n+use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, MultiSpan};\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::intravisit::Visitor;\n+use rustc_hir::{self as hir, Item, ItemKind, Node};\n use rustc_infer::infer::{\n     error_reporting::nice_region_error::{\n         self, find_anon_type, find_param_with_region, suggest_adding_lifetime_params,\n-        NiceRegionError,\n+        HirTraitObjectVisitor, NiceRegionError, TraitObjectVisitor,\n     },\n     error_reporting::unexpected_hidden_region_diagnostic,\n     NllRegionVariableOrigin, RelateParamBound,\n };\n use rustc_middle::hir::place::PlaceBase;\n use rustc_middle::mir::{ConstraintCategory, ReturnConstraint};\n use rustc_middle::ty::subst::InternalSubsts;\n+use rustc_middle::ty::Region;\n+use rustc_middle::ty::TypeVisitor;\n use rustc_middle::ty::{self, RegionVid, Ty};\n use rustc_span::symbol::sym;\n+use rustc_span::symbol::Ident;\n use rustc_span::Span;\n \n use crate::borrowck_errors;\n@@ -27,7 +34,7 @@ use crate::{\n     MirBorrowckCtxt,\n };\n \n-impl ConstraintDescription for ConstraintCategory {\n+impl<'tcx> ConstraintDescription for ConstraintCategory<'tcx> {\n     fn description(&self) -> &'static str {\n         // Must end with a space. Allows for empty names to be provided.\n         match self {\n@@ -37,7 +44,7 @@ impl ConstraintDescription for ConstraintCategory {\n             ConstraintCategory::UseAsConst => \"using this value as a constant \",\n             ConstraintCategory::UseAsStatic => \"using this value as a static \",\n             ConstraintCategory::Cast => \"cast \",\n-            ConstraintCategory::CallArgument => \"argument \",\n+            ConstraintCategory::CallArgument(_) => \"argument \",\n             ConstraintCategory::TypeAnnotation => \"type annotation \",\n             ConstraintCategory::ClosureBounds => \"closure body \",\n             ConstraintCategory::SizedBound => \"proving this value is `Sized` \",\n@@ -101,15 +108,15 @@ pub(crate) enum RegionErrorKind<'tcx> {\n \n /// Information about the various region constraints involved in a borrow checker error.\n #[derive(Clone, Debug)]\n-pub struct ErrorConstraintInfo {\n+pub struct ErrorConstraintInfo<'tcx> {\n     // fr: outlived_fr\n     pub(super) fr: RegionVid,\n     pub(super) fr_is_local: bool,\n     pub(super) outlived_fr: RegionVid,\n     pub(super) outlived_fr_is_local: bool,\n \n     // Category and span for best blame constraint\n-    pub(super) category: ConstraintCategory,\n+    pub(super) category: ConstraintCategory<'tcx>,\n     pub(super) span: Span,\n }\n \n@@ -256,6 +263,70 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         outlives_suggestion.add_suggestion(self);\n     }\n \n+    fn get_impl_ident_and_self_ty_from_trait(\n+        &self,\n+        def_id: DefId,\n+        trait_objects: &FxHashSet<DefId>,\n+    ) -> Option<(Ident, &'tcx hir::Ty<'tcx>)> {\n+        let tcx = self.infcx.tcx;\n+        match tcx.hir().get_if_local(def_id) {\n+            Some(Node::ImplItem(impl_item)) => {\n+                match tcx.hir().find_by_def_id(tcx.hir().get_parent_item(impl_item.hir_id())) {\n+                    Some(Node::Item(Item {\n+                        kind: ItemKind::Impl(hir::Impl { self_ty, .. }),\n+                        ..\n+                    })) => Some((impl_item.ident, self_ty)),\n+                    _ => None,\n+                }\n+            }\n+            Some(Node::TraitItem(trait_item)) => {\n+                let trait_did = tcx.hir().get_parent_item(trait_item.hir_id());\n+                match tcx.hir().find_by_def_id(trait_did) {\n+                    Some(Node::Item(Item { kind: ItemKind::Trait(..), .. })) => {\n+                        // The method being called is defined in the `trait`, but the `'static`\n+                        // obligation comes from the `impl`. Find that `impl` so that we can point\n+                        // at it in the suggestion.\n+                        let trait_did = trait_did.to_def_id();\n+                        match tcx\n+                            .hir()\n+                            .trait_impls(trait_did)\n+                            .iter()\n+                            .filter_map(|&impl_did| {\n+                                match tcx.hir().get_if_local(impl_did.to_def_id()) {\n+                                    Some(Node::Item(Item {\n+                                        kind: ItemKind::Impl(hir::Impl { self_ty, .. }),\n+                                        ..\n+                                    })) if trait_objects.iter().all(|did| {\n+                                        // FIXME: we should check `self_ty` against the receiver\n+                                        // type in the `UnifyReceiver` context, but for now, use\n+                                        // this imperfect proxy. This will fail if there are\n+                                        // multiple `impl`s for the same trait like\n+                                        // `impl Foo for Box<dyn Bar>` and `impl Foo for dyn Bar`.\n+                                        // In that case, only the first one will get suggestions.\n+                                        let mut traits = vec![];\n+                                        let mut hir_v = HirTraitObjectVisitor(&mut traits, *did);\n+                                        hir_v.visit_ty(self_ty);\n+                                        !traits.is_empty()\n+                                    }) =>\n+                                    {\n+                                        Some(self_ty)\n+                                    }\n+                                    _ => None,\n+                                }\n+                            })\n+                            .next()\n+                        {\n+                            Some(self_ty) => Some((trait_item.ident, self_ty)),\n+                            _ => None,\n+                        }\n+                    }\n+                    _ => None,\n+                }\n+            }\n+            _ => None,\n+        }\n+    }\n+\n     /// Report an error because the universal region `fr` was required to outlive\n     /// `outlived_fr` but it is not known to do so. For example:\n     ///\n@@ -279,6 +350,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             });\n \n         debug!(\"report_region_error: category={:?} {:?} {:?}\", category, cause, variance_info);\n+\n         // Check if we can use one of the \"nice region errors\".\n         if let (Some(f), Some(o)) = (self.to_error_region(fr), self.to_error_region(outlived_fr)) {\n             let nice = NiceRegionError::new_from_span(self.infcx, cause.span, o, f);\n@@ -312,7 +384,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 self.report_fnmut_error(&errci, kind)\n             }\n             (ConstraintCategory::Assignment, true, false)\n-            | (ConstraintCategory::CallArgument, true, false) => {\n+            | (ConstraintCategory::CallArgument(_), true, false) => {\n                 let mut db = self.report_escaping_data_error(&errci);\n \n                 outlives_suggestion.intermediate_suggestion(self, &errci, &mut db);\n@@ -405,7 +477,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     /// ```\n     fn report_fnmut_error(\n         &self,\n-        errci: &ErrorConstraintInfo,\n+        errci: &ErrorConstraintInfo<'tcx>,\n         kind: ReturnConstraint,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         let ErrorConstraintInfo { outlived_fr, span, .. } = errci;\n@@ -486,7 +558,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     /// ```\n     fn report_escaping_data_error(\n         &self,\n-        errci: &ErrorConstraintInfo,\n+        errci: &ErrorConstraintInfo<'tcx>,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         let ErrorConstraintInfo { span, category, .. } = errci;\n \n@@ -548,24 +620,28 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         // Only show an extra note if we can find an 'error region' for both of the region\n         // variables. This avoids showing a noisy note that just mentions 'synthetic' regions\n         // that don't help the user understand the error.\n-        if self.to_error_region(errci.fr).is_some()\n-            && self.to_error_region(errci.outlived_fr).is_some()\n-        {\n-            let fr_region_name = self.give_region_a_name(errci.fr).unwrap();\n-            fr_region_name.highlight_region_name(&mut diag);\n-            let outlived_fr_region_name = self.give_region_a_name(errci.outlived_fr).unwrap();\n-            outlived_fr_region_name.highlight_region_name(&mut diag);\n+        match (self.to_error_region(errci.fr), self.to_error_region(errci.outlived_fr)) {\n+            (Some(f), Some(o)) => {\n+                self.maybe_suggest_constrain_dyn_trait_impl(&mut diag, f, o, category);\n \n-            diag.span_label(\n-                *span,\n-                format!(\n-                    \"{}requires that `{}` must outlive `{}`\",\n-                    category.description(),\n-                    fr_region_name,\n-                    outlived_fr_region_name,\n-                ),\n-            );\n+                let fr_region_name = self.give_region_a_name(errci.fr).unwrap();\n+                fr_region_name.highlight_region_name(&mut diag);\n+                let outlived_fr_region_name = self.give_region_a_name(errci.outlived_fr).unwrap();\n+                outlived_fr_region_name.highlight_region_name(&mut diag);\n+\n+                diag.span_label(\n+                    *span,\n+                    format!(\n+                        \"{}requires that `{}` must outlive `{}`\",\n+                        category.description(),\n+                        fr_region_name,\n+                        outlived_fr_region_name,\n+                    ),\n+                );\n+            }\n+            _ => {}\n         }\n+\n         diag\n     }\n \n@@ -586,7 +662,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     /// ```\n     fn report_general_error(\n         &self,\n-        errci: &ErrorConstraintInfo,\n+        errci: &ErrorConstraintInfo<'tcx>,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         let ErrorConstraintInfo {\n             fr,\n@@ -699,6 +775,100 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         }\n     }\n \n+    fn maybe_suggest_constrain_dyn_trait_impl(\n+        &self,\n+        diag: &mut DiagnosticBuilder<'tcx, ErrorGuaranteed>,\n+        f: Region<'tcx>,\n+        o: Region<'tcx>,\n+        category: &ConstraintCategory<'tcx>,\n+    ) {\n+        if !o.is_static() {\n+            return;\n+        }\n+\n+        let tcx = self.infcx.tcx;\n+\n+        let instance = if let ConstraintCategory::CallArgument(Some(func_ty)) = category {\n+            let (fn_did, substs) = match func_ty.kind() {\n+                ty::FnDef(fn_did, substs) => (fn_did, substs),\n+                _ => return,\n+            };\n+            debug!(?fn_did, ?substs);\n+\n+            // Only suggest this on function calls, not closures\n+            let ty = tcx.type_of(fn_did);\n+            debug!(\"ty: {:?}, ty.kind: {:?}\", ty, ty.kind());\n+            if let ty::Closure(_, _) = ty.kind() {\n+                return;\n+            }\n+\n+            if let Ok(Some(instance)) = ty::Instance::resolve(\n+                tcx,\n+                self.param_env,\n+                *fn_did,\n+                self.infcx.resolve_vars_if_possible(substs),\n+            ) {\n+                instance\n+            } else {\n+                return;\n+            }\n+        } else {\n+            return;\n+        };\n+\n+        let param = match find_param_with_region(tcx, f, o) {\n+            Some(param) => param,\n+            None => return,\n+        };\n+        debug!(?param);\n+\n+        let mut visitor = TraitObjectVisitor(FxHashSet::default());\n+        visitor.visit_ty(param.param_ty);\n+\n+        let Some((ident, self_ty)) =\n+            self.get_impl_ident_and_self_ty_from_trait(instance.def_id(), &visitor.0) else {return};\n+\n+        self.suggest_constrain_dyn_trait_in_impl(diag, &visitor.0, ident, self_ty);\n+    }\n+\n+    #[instrument(skip(self, err), level = \"debug\")]\n+    fn suggest_constrain_dyn_trait_in_impl(\n+        &self,\n+        err: &mut Diagnostic,\n+        found_dids: &FxHashSet<DefId>,\n+        ident: Ident,\n+        self_ty: &hir::Ty<'_>,\n+    ) -> bool {\n+        debug!(\"err: {:#?}\", err);\n+        let mut suggested = false;\n+        for found_did in found_dids {\n+            let mut traits = vec![];\n+            let mut hir_v = HirTraitObjectVisitor(&mut traits, *found_did);\n+            hir_v.visit_ty(&self_ty);\n+            debug!(\"trait spans found: {:?}\", traits);\n+            for span in &traits {\n+                let mut multi_span: MultiSpan = vec![*span].into();\n+                multi_span.push_span_label(\n+                    *span,\n+                    \"this has an implicit `'static` lifetime requirement\".to_string(),\n+                );\n+                multi_span.push_span_label(\n+                    ident.span,\n+                    \"calling this method introduces the `impl`'s 'static` requirement\".to_string(),\n+                );\n+                err.span_note(multi_span, \"the used `impl` has a `'static` requirement\");\n+                err.span_suggestion_verbose(\n+                    span.shrink_to_hi(),\n+                    \"consider relaxing the implicit `'static` requirement\",\n+                    \" + '_\".to_string(),\n+                    Applicability::MaybeIncorrect,\n+                );\n+                suggested = true;\n+            }\n+        }\n+        suggested\n+    }\n+\n     fn suggest_adding_lifetime_params(\n         &self,\n         diag: &mut Diagnostic,"}, {"sha": "2c460bcb72d8b619c5babc3b204de5357d33b6cf", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491", "patch": "@@ -87,7 +87,7 @@ pub struct RegionInferenceContext<'tcx> {\n \n     /// Map closure bounds to a `Span` that should be used for error reporting.\n     closure_bounds_mapping:\n-        FxHashMap<Location, FxHashMap<(RegionVid, RegionVid), (ConstraintCategory, Span)>>,\n+        FxHashMap<Location, FxHashMap<(RegionVid, RegionVid), (ConstraintCategory<'tcx>, Span)>>,\n \n     /// Map universe indexes to information on why we created it.\n     universe_causes: FxHashMap<ty::UniverseIndex, UniverseInfo<'tcx>>,\n@@ -259,7 +259,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         member_constraints_in: MemberConstraintSet<'tcx, RegionVid>,\n         closure_bounds_mapping: FxHashMap<\n             Location,\n-            FxHashMap<(RegionVid, RegionVid), (ConstraintCategory, Span)>,\n+            FxHashMap<(RegionVid, RegionVid), (ConstraintCategory<'tcx>, Span)>,\n         >,\n         universe_causes: FxHashMap<ty::UniverseIndex, UniverseInfo<'tcx>>,\n         type_tests: Vec<TypeTest<'tcx>>,\n@@ -1772,7 +1772,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         fr1: RegionVid,\n         fr1_origin: NllRegionVariableOrigin,\n         fr2: RegionVid,\n-    ) -> (ConstraintCategory, ObligationCause<'tcx>) {\n+    ) -> (ConstraintCategory<'tcx>, ObligationCause<'tcx>) {\n         let BlameConstraint { category, cause, .. } =\n             self.best_blame_constraint(body, fr1, fr1_origin, |r| {\n                 self.provides_universal_region(r, fr1, fr2)\n@@ -2270,7 +2270,7 @@ impl<'tcx> ClosureRegionRequirementsExt<'tcx> for ClosureRegionRequirements<'tcx\n \n #[derive(Clone, Debug)]\n pub struct BlameConstraint<'tcx> {\n-    pub category: ConstraintCategory,\n+    pub category: ConstraintCategory<'tcx>,\n     pub from_closure: bool,\n     pub cause: ObligationCause<'tcx>,\n     pub variance_info: ty::VarianceDiagInfo<'tcx>,"}, {"sha": "55c0bf05b487317753d3725959a81433a943165a", "filename": "compiler/rustc_borrowck/src/type_check/canonical.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs?ref=ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491", "patch": "@@ -28,7 +28,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     pub(super) fn fully_perform_op<R, Op>(\n         &mut self,\n         locations: Locations,\n-        category: ConstraintCategory,\n+        category: ConstraintCategory<'tcx>,\n         op: Op,\n     ) -> Fallible<R>\n     where\n@@ -83,11 +83,12 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         instantiated\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     pub(super) fn prove_trait_ref(\n         &mut self,\n         trait_ref: ty::TraitRef<'tcx>,\n         locations: Locations,\n-        category: ConstraintCategory,\n+        category: ConstraintCategory<'tcx>,\n     ) {\n         self.prove_predicates(\n             Some(ty::Binder::dummy(ty::PredicateKind::Trait(ty::TraitPredicate {\n@@ -113,6 +114,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             .into_iter()\n             .zip(instantiated_predicates.spans.into_iter())\n         {\n+            debug!(?predicate);\n             let predicate = self.normalize(predicate, locations);\n             self.prove_predicate(predicate, locations, ConstraintCategory::Predicate(span));\n         }\n@@ -122,7 +124,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         &mut self,\n         predicates: impl IntoIterator<Item = impl ToPredicate<'tcx>>,\n         locations: Locations,\n-        category: ConstraintCategory,\n+        category: ConstraintCategory<'tcx>,\n     ) {\n         for predicate in predicates {\n             let predicate = predicate.to_predicate(self.tcx());\n@@ -137,7 +139,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         &mut self,\n         predicate: ty::Predicate<'tcx>,\n         locations: Locations,\n-        category: ConstraintCategory,\n+        category: ConstraintCategory<'tcx>,\n     ) {\n         let param_env = self.param_env;\n         self.fully_perform_op("}, {"sha": "3c9e3870aeac419e68dcbf907be23863c2088770", "filename": "compiler/rustc_borrowck/src/type_check/constraint_conversion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs?ref=ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491", "patch": "@@ -27,7 +27,7 @@ pub(crate) struct ConstraintConversion<'a, 'tcx> {\n     param_env: ty::ParamEnv<'tcx>,\n     locations: Locations,\n     span: Span,\n-    category: ConstraintCategory,\n+    category: ConstraintCategory<'tcx>,\n     constraints: &'a mut MirTypeckRegionConstraints<'tcx>,\n }\n \n@@ -40,7 +40,7 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         locations: Locations,\n         span: Span,\n-        category: ConstraintCategory,\n+        category: ConstraintCategory<'tcx>,\n         constraints: &'a mut MirTypeckRegionConstraints<'tcx>,\n     ) -> Self {\n         Self {"}, {"sha": "4a2b2942008b874266d3c70d616a22b4b5244dc5", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 36, "deletions": 9, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491", "patch": "@@ -162,6 +162,8 @@ pub(crate) fn type_check<'mir, 'tcx>(\n         &mut constraints,\n     );\n \n+    debug!(?normalized_inputs_and_output);\n+\n     for u in ty::UniverseIndex::ROOT..infcx.universe() {\n         let info = UniverseInfo::other();\n         constraints.universe_causes.insert(u, info);\n@@ -185,6 +187,7 @@ pub(crate) fn type_check<'mir, 'tcx>(\n         implicit_region_bound,\n         &mut borrowck_context,\n         |mut cx| {\n+            debug!(\"inside extra closure of type_check_internal\");\n             cx.equate_inputs_and_outputs(&body, universal_regions, &normalized_inputs_and_output);\n             liveness::generate(\n                 &mut cx,\n@@ -257,6 +260,7 @@ fn type_check_internal<'a, 'tcx, R>(\n     borrowck_context: &'a mut BorrowCheckContext<'a, 'tcx>,\n     extra: impl FnOnce(TypeChecker<'a, 'tcx>) -> R,\n ) -> R {\n+    debug!(\"body: {:#?}\", body);\n     let mut checker = TypeChecker::new(\n         infcx,\n         body,\n@@ -935,7 +939,7 @@ pub(crate) struct MirTypeckRegionConstraints<'tcx> {\n     pub(crate) member_constraints: MemberConstraintSet<'tcx, RegionVid>,\n \n     pub(crate) closure_bounds_mapping:\n-        FxHashMap<Location, FxHashMap<(RegionVid, RegionVid), (ConstraintCategory, Span)>>,\n+        FxHashMap<Location, FxHashMap<(RegionVid, RegionVid), (ConstraintCategory<'tcx>, Span)>>,\n \n     pub(crate) universe_causes: FxHashMap<ty::UniverseIndex, UniverseInfo<'tcx>>,\n \n@@ -1125,7 +1129,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     fn push_region_constraints(\n         &mut self,\n         locations: Locations,\n-        category: ConstraintCategory,\n+        category: ConstraintCategory<'tcx>,\n         data: &QueryRegionConstraints<'tcx>,\n     ) {\n         debug!(\"constraints generated: {:#?}\", data);\n@@ -1150,7 +1154,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         sub: Ty<'tcx>,\n         sup: Ty<'tcx>,\n         locations: Locations,\n-        category: ConstraintCategory,\n+        category: ConstraintCategory<'tcx>,\n     ) -> Fallible<()> {\n         // Use this order of parameters because the sup type is usually the\n         // \"expected\" type in diagnostics.\n@@ -1163,7 +1167,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n         locations: Locations,\n-        category: ConstraintCategory,\n+        category: ConstraintCategory<'tcx>,\n     ) -> Fallible<()> {\n         self.relate_types(expected, ty::Variance::Invariant, found, locations, category)\n     }\n@@ -1175,7 +1179,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         v: ty::Variance,\n         user_ty: &UserTypeProjection,\n         locations: Locations,\n-        category: ConstraintCategory,\n+        category: ConstraintCategory<'tcx>,\n     ) -> Fallible<()> {\n         let annotated_type = self.user_type_annotations[user_ty.base].inferred_ty;\n         let mut curr_projected_ty = PlaceTy::from_ty(annotated_type);\n@@ -1212,6 +1216,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     #[instrument(skip(self, body, location), level = \"debug\")]\n     fn check_stmt(&mut self, body: &Body<'tcx>, stmt: &Statement<'tcx>, location: Location) {\n         let tcx = self.tcx();\n+        debug!(\"stmt kind: {:?}\", stmt.kind);\n         match stmt.kind {\n             StatementKind::Assign(box (ref place, ref rv)) => {\n                 // Assignments to temporaries are not \"interesting\";\n@@ -1251,9 +1256,13 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 );\n \n                 let place_ty = place.ty(body, tcx).ty;\n+                debug!(?place_ty);\n                 let place_ty = self.normalize(place_ty, location);\n+                debug!(\"place_ty normalized: {:?}\", place_ty);\n                 let rv_ty = rv.ty(body, tcx);\n+                debug!(?rv_ty);\n                 let rv_ty = self.normalize(rv_ty, location);\n+                debug!(\"normalized rv_ty: {:?}\", rv_ty);\n                 if let Err(terr) =\n                     self.sub_types(rv_ty, place_ty, location.to_locations(), category)\n                 {\n@@ -1347,6 +1356,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         term_location: Location,\n     ) {\n         let tcx = self.tcx();\n+        debug!(\"terminator kind: {:?}\", term.kind);\n         match term.kind {\n             TerminatorKind::Goto { .. }\n             | TerminatorKind::Resume\n@@ -1404,15 +1414,21 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 // FIXME: check the values\n             }\n             TerminatorKind::Call {\n-                ref func, ref args, destination, target, from_hir_call, ..\n+                ref func,\n+                ref args,\n+                ref destination,\n+                from_hir_call,\n+                target,\n+                ..\n             } => {\n                 self.check_operand(func, term_location);\n                 for arg in args {\n                     self.check_operand(arg, term_location);\n                 }\n \n                 let func_ty = func.ty(body, tcx);\n-                debug!(\"check_terminator: call, func_ty={:?}\", func_ty);\n+                debug!(\"func_ty.kind: {:?}\", func_ty.kind());\n+\n                 let sig = match func_ty.kind() {\n                     ty::FnDef(..) | ty::FnPtr(_) => func_ty.fn_sig(tcx),\n                     _ => {\n@@ -1425,8 +1441,9 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     LateBoundRegionConversionTime::FnCall,\n                     sig,\n                 );\n+                debug!(?sig);\n                 let sig = self.normalize(sig, term_location);\n-                self.check_call_dest(body, term, &sig, destination, target, term_location);\n+                self.check_call_dest(body, term, &sig, *destination, target, term_location);\n \n                 self.prove_predicates(\n                     sig.inputs_and_output\n@@ -1585,11 +1602,20 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         if args.len() < sig.inputs().len() || (args.len() > sig.inputs().len() && !sig.c_variadic) {\n             span_mirbug!(self, term, \"call to {:?} with wrong # of args\", sig);\n         }\n+\n+        let func_ty = if let TerminatorKind::Call { func, .. } = &term.kind {\n+            Some(func.ty(body, self.infcx.tcx))\n+        } else {\n+            None\n+        };\n+        debug!(?func_ty);\n+\n         for (n, (fn_arg, op_arg)) in iter::zip(sig.inputs(), args).enumerate() {\n             let op_arg_ty = op_arg.ty(body, self.tcx());\n+\n             let op_arg_ty = self.normalize(op_arg_ty, term_location);\n             let category = if from_hir_call {\n-                ConstraintCategory::CallArgument\n+                ConstraintCategory::CallArgument(func_ty)\n             } else {\n                 ConstraintCategory::Boring\n             };\n@@ -1841,6 +1867,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         }\n     }\n \n+    #[instrument(skip(self, body), level = \"debug\")]\n     fn check_rvalue(&mut self, body: &Body<'tcx>, rvalue: &Rvalue<'tcx>, location: Location) {\n         let tcx = self.tcx();\n "}, {"sha": "c45850c6d840f8752998e9bb741f0eacfbd69930", "filename": "compiler/rustc_borrowck/src/type_check/relate_tys.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs?ref=ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491", "patch": "@@ -28,7 +28,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         v: ty::Variance,\n         b: Ty<'tcx>,\n         locations: Locations,\n-        category: ConstraintCategory,\n+        category: ConstraintCategory<'tcx>,\n     ) -> Fallible<()> {\n         TypeRelating::new(\n             self.infcx,\n@@ -47,7 +47,7 @@ struct NllTypeRelatingDelegate<'me, 'bccx, 'tcx> {\n     locations: Locations,\n \n     /// What category do we assign the resulting `'a: 'b` relationships?\n-    category: ConstraintCategory,\n+    category: ConstraintCategory<'tcx>,\n \n     /// Information so that error reporting knows what types we are relating\n     /// when reporting a bound region error.\n@@ -58,7 +58,7 @@ impl<'me, 'bccx, 'tcx> NllTypeRelatingDelegate<'me, 'bccx, 'tcx> {\n     fn new(\n         type_checker: &'me mut TypeChecker<'bccx, 'tcx>,\n         locations: Locations,\n-        category: ConstraintCategory,\n+        category: ConstraintCategory<'tcx>,\n         universe_info: UniverseInfo<'tcx>,\n     ) -> Self {\n         Self { type_checker, locations, category, universe_info }"}, {"sha": "53d9acf7d290851c20661c93d0690d64d72dfec1", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs?ref=ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491", "patch": "@@ -16,7 +16,7 @@ mod util;\n \n pub use different_lifetimes::suggest_adding_lifetime_params;\n pub use find_anon_type::find_anon_type;\n-pub use static_impl_trait::suggest_new_region_bound;\n+pub use static_impl_trait::{suggest_new_region_bound, HirTraitObjectVisitor, TraitObjectVisitor};\n pub use util::find_param_with_region;\n \n impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {"}, {"sha": "1081f888f7ff3fb05e2e7fbdb3d13d09f9f09d80", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491", "patch": "@@ -546,7 +546,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n }\n \n /// Collect all the trait objects in a type that could have received an implicit `'static` lifetime.\n-pub(super) struct TraitObjectVisitor(pub(super) FxHashSet<DefId>);\n+pub struct TraitObjectVisitor(pub FxHashSet<DefId>);\n \n impl<'tcx> TypeVisitor<'tcx> for TraitObjectVisitor {\n     fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n@@ -563,7 +563,7 @@ impl<'tcx> TypeVisitor<'tcx> for TraitObjectVisitor {\n }\n \n /// Collect all `hir::Ty<'_>` `Span`s for trait objects with an implicit lifetime.\n-pub(super) struct HirTraitObjectVisitor<'a>(pub(super) &'a mut Vec<Span>, pub(super) DefId);\n+pub struct HirTraitObjectVisitor<'a>(pub &'a mut Vec<Span>, pub DefId);\n \n impl<'a, 'tcx> Visitor<'tcx> for HirTraitObjectVisitor<'a> {\n     fn visit_ty(&mut self, t: &'tcx hir::Ty<'tcx>) {"}, {"sha": "96b57b6cd2055e33d646e077fc51ace1c76d5063", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491", "patch": "@@ -34,6 +34,7 @@ pub struct AnonymousParamInfo<'tcx> {\n // i32, which is the type of y but with the anonymous region replaced\n // with 'a, the corresponding bound region and is_first which is true if\n // the hir::Param is the first parameter in the function declaration.\n+#[instrument(skip(tcx), level = \"debug\")]\n pub fn find_param_with_region<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     anon_region: Region<'tcx>,\n@@ -51,9 +52,19 @@ pub fn find_param_with_region<'tcx>(\n     let hir_id = hir.local_def_id_to_hir_id(id.as_local()?);\n     let body_id = hir.maybe_body_owned_by(hir_id)?;\n     let body = hir.body(body_id);\n+\n+    // Don't perform this on closures\n+    match hir.get(hir_id) {\n+        hir::Node::Expr(&hir::Expr { kind: hir::ExprKind::Closure(..), .. }) => {\n+            return None;\n+        }\n+        _ => {}\n+    }\n+\n     let owner_id = hir.body_owner(body_id);\n     let fn_decl = hir.fn_decl_by_hir_id(owner_id).unwrap();\n     let poly_fn_sig = tcx.fn_sig(id);\n+\n     let fn_sig = tcx.liberate_late_bound_regions(id, poly_fn_sig);\n     body.params\n         .iter()"}, {"sha": "01945b543b14bf6a585428bccc445cce3401b372", "filename": "compiler/rustc_middle/src/mir/query.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs?ref=ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491", "patch": "@@ -338,11 +338,12 @@ pub struct ClosureOutlivesRequirement<'tcx> {\n     pub blame_span: Span,\n \n     // ... due to this reason.\n-    pub category: ConstraintCategory,\n+    pub category: ConstraintCategory<'tcx>,\n }\n \n // Make sure this enum doesn't unintentionally grow\n-rustc_data_structures::static_assert_size!(ConstraintCategory, 12);\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+rustc_data_structures::static_assert_size!(ConstraintCategory<'_>, 16);\n \n /// Outlives-constraints can be categorized to determine whether and why they\n /// are interesting (for error reporting). Order of variants indicates sort\n@@ -351,7 +352,7 @@ rustc_data_structures::static_assert_size!(ConstraintCategory, 12);\n /// See also `rustc_const_eval::borrow_check::constraints`.\n #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash)]\n #[derive(TyEncodable, TyDecodable, HashStable)]\n-pub enum ConstraintCategory {\n+pub enum ConstraintCategory<'tcx> {\n     Return(ReturnConstraint),\n     Yield,\n     UseAsConst,\n@@ -363,7 +364,9 @@ pub enum ConstraintCategory {\n     ///\n     /// We try to get the category that the closure used when reporting this.\n     ClosureBounds,\n-    CallArgument,\n+\n+    /// Contains the function type if available.\n+    CallArgument(Option<Ty<'tcx>>),\n     CopyBound,\n     SizedBound,\n     Assignment,"}, {"sha": "42e5a05d63b7670058590290c63a4146a0c3488e", "filename": "compiler/rustc_middle/src/ty/impls_ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491/compiler%2Frustc_middle%2Fsrc%2Fty%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491/compiler%2Frustc_middle%2Fsrc%2Fty%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fimpls_ty.rs?ref=ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491", "patch": "@@ -135,8 +135,8 @@ impl<'a> HashStable<StableHashingContext<'a>> for ty::RegionKind {\n             ty::RePlaceholder(p) => {\n                 p.hash_stable(hcx, hasher);\n             }\n-            ty::ReVar(..) => {\n-                bug!(\"StableHasher: unexpected region {:?}\", *self)\n+            ty::ReVar(reg) => {\n+                reg.hash_stable(hcx, hasher);\n             }\n         }\n     }"}, {"sha": "09119ea2bb5f9338c34733e8f11d96b2def2d4f5", "filename": "src/test/ui/associated-types/cache/project-fn-ret-invariant-nll.krisskross.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant-nll.krisskross.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant-nll.krisskross.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant-nll.krisskross.stderr?ref=ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491", "patch": "@@ -1,5 +1,5 @@\n error: lifetime may not live long enough\n-  --> $DIR/project-fn-ret-invariant-nll.rs:63:5\n+  --> $DIR/project-fn-ret-invariant-nll.rs:64:5\n    |\n LL | fn transmute<'a, 'b>(x: Type<'a>, y: Type<'b>) -> (Type<'a>, Type<'b>) {\n    |              --  -- lifetime `'b` defined here\n@@ -15,7 +15,7 @@ LL |     (a, b)\n    = help: see <https://doc.rust-lang.org/nomicon/subtyping.html> for more information about variance\n \n error: lifetime may not live long enough\n-  --> $DIR/project-fn-ret-invariant-nll.rs:63:5\n+  --> $DIR/project-fn-ret-invariant-nll.rs:64:5\n    |\n LL | fn transmute<'a, 'b>(x: Type<'a>, y: Type<'b>) -> (Type<'a>, Type<'b>) {\n    |              --  -- lifetime `'b` defined here"}, {"sha": "266f3b99f9f30a7f2bb436a493c2c884df19709e", "filename": "src/test/ui/associated-types/cache/project-fn-ret-invariant-nll.oneuse.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant-nll.oneuse.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant-nll.oneuse.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant-nll.oneuse.stderr?ref=ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491", "patch": "@@ -15,19 +15,19 @@ LL |     let a = bar(f, x);\n    = help: see <https://doc.rust-lang.org/nomicon/subtyping.html> for more information about variance\n \n error: lifetime may not live long enough\n-  --> $DIR/project-fn-ret-invariant-nll.rs:47:13\n+  --> $DIR/project-fn-ret-invariant-nll.rs:46:13\n    |\n LL | fn baz<'a, 'b>(x: Type<'a>, y: Type<'b>) -> (Type<'a>, Type<'b>) {\n    |        --  -- lifetime `'b` defined here\n    |        |\n    |        lifetime `'a` defined here\n-...\n-LL |     let b = bar(f, y);\n+LL |     let f = foo; // <-- No consistent type can be inferred for `f` here.\n+LL |     let a = bar(f, x);\n    |             ^^^^^^^^^ argument requires that `'b` must outlive `'a`\n    |\n    = help: consider adding the following bound: `'b: 'a`\n-   = note: requirement occurs because of the type `Type<'_>`, which makes the generic argument `'_` invariant\n-   = note: the struct `Type<'a>` is invariant over the parameter `'a`\n+   = note: requirement occurs because of a function pointer to `foo`\n+   = note: the function `foo` is invariant over the parameter `'a`\n    = help: see <https://doc.rust-lang.org/nomicon/subtyping.html> for more information about variance\n \n help: `'a` and `'b` must be the same: replace one with the other"}, {"sha": "15bf38dabc0601b71e1319e3f205956ce29b2282", "filename": "src/test/ui/associated-types/cache/project-fn-ret-invariant-nll.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant-nll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant-nll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant-nll.rs?ref=ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491", "patch": "@@ -44,7 +44,8 @@ fn baz<'a, 'b>(x: Type<'a>, y: Type<'b>) -> (Type<'a>, Type<'b>) {\n fn baz<'a, 'b>(x: Type<'a>, y: Type<'b>) -> (Type<'a>, Type<'b>) {\n     let f = foo; // <-- No consistent type can be inferred for `f` here.\n     let a = bar(f, x); //[oneuse]~ ERROR lifetime may not live long enough\n-    let b = bar(f, y); //[oneuse]~ ERROR lifetime may not live long enough\n+    //[oneuse]~^ ERROR lifetime may not live long enough\n+    let b = bar(f, y);\n     (a, b)\n }\n "}, {"sha": "56f081529997febdce48b1d3566323d5ed14acdf", "filename": "src/test/ui/associated-types/cache/project-fn-ret-invariant-nll.transmute.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant-nll.transmute.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant-nll.transmute.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant-nll.transmute.stderr?ref=ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491", "patch": "@@ -1,5 +1,5 @@\n error: lifetime may not live long enough\n-  --> $DIR/project-fn-ret-invariant-nll.rs:56:5\n+  --> $DIR/project-fn-ret-invariant-nll.rs:57:5\n    |\n LL | fn baz<'a, 'b>(x: Type<'a>) -> Type<'static> {\n    |        -- lifetime `'a` defined here"}, {"sha": "02e47721e0cf928bc511c9da78cea5ffeeb39c95", "filename": "src/test/ui/async-await/issues/issue-72312.nll.stderr", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-72312.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-72312.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-72312.nll.stderr?ref=ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491", "patch": "@@ -1,24 +1,23 @@\n error[E0521]: borrowed data escapes outside of associated function\n-  --> $DIR/issue-72312.rs:20:24\n+  --> $DIR/issue-72312.rs:20:9\n    |\n LL |       pub async fn start(&self) {\n    |                          -----\n    |                          |\n    |                          `self` is a reference that is only valid in the associated function body\n    |                          let's call the lifetime of this reference `'1`\n ...\n-LL |           require_static(async move {\n-   |  ________________________^\n+LL | /         require_static(async move {\n LL | |\n LL | |\n LL | |\n LL | |\n LL | |             &self;\n LL | |         });\n-   | |         ^\n-   | |         |\n-   | |_________`self` escapes the associated function body here\n-   |           argument requires that `'1` must outlive `'static`\n+   | |          ^\n+   | |          |\n+   | |__________`self` escapes the associated function body here\n+   |            argument requires that `'1` must outlive `'static`\n \n error: aborting due to previous error\n "}, {"sha": "3ab55b370c2318e7b3f991f5f97996d245698e87", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-comparing-against-free.stderr", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr?ref=ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491", "patch": "@@ -72,14 +72,15 @@ LL | | }\n error[E0597]: `a` does not live long enough\n   --> $DIR/propagate-approximated-shorter-to-static-comparing-against-free.rs:30:26\n    |\n-LL |     let cell = Cell::new(&a);\n-   |                ----------^^-\n-   |                |         |\n-   |                |         borrowed value does not live long enough\n-   |                argument requires that `a` is borrowed for `'static`\n+LL |       let cell = Cell::new(&a);\n+   |                            ^^ borrowed value does not live long enough\n ...\n-LL | }\n-   | - `a` dropped here while still borrowed\n+LL | /     foo(cell, |cell_a, cell_x| {\n+LL | |         cell_x.set(cell_a.get()); // forces 'a: 'x, implies 'a = 'static -> borrow error\n+LL | |     })\n+   | |______- argument requires that `a` is borrowed for `'static`\n+LL |   }\n+   |   - `a` dropped here while still borrowed\n \n error: aborting due to 2 previous errors\n "}, {"sha": "3326fa521fc9cea4efc8e4d26b039fb90f1c7663", "filename": "src/test/ui/nll/user-annotations/adt-nullary-enums.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fadt-nullary-enums.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fadt-nullary-enums.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fadt-nullary-enums.stderr?ref=ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491", "patch": "@@ -1,14 +1,14 @@\n error[E0597]: `c` does not live long enough\n   --> $DIR/adt-nullary-enums.rs:33:41\n    |\n-LL |         SomeEnum::SomeVariant(Cell::new(&c)),\n-   |                               ----------^^-\n-   |                               |         |\n-   |                               |         borrowed value does not live long enough\n-   |                               argument requires that `c` is borrowed for `'static`\n-...\n-LL | }\n-   | - `c` dropped here while still borrowed\n+LL | /     combine(\n+LL | |         SomeEnum::SomeVariant(Cell::new(&c)),\n+   | |                                         ^^ borrowed value does not live long enough\n+LL | |         SomeEnum::SomeOtherVariant::<Cell<&'static u32>>,\n+LL | |     );\n+   | |_____- argument requires that `c` is borrowed for `'static`\n+LL |   }\n+   |   - `c` dropped here while still borrowed\n \n error[E0597]: `c` does not live long enough\n   --> $DIR/adt-nullary-enums.rs:41:41"}, {"sha": "5d9c7077fa109b6b18d7ed6f4f86a3c0baf43584", "filename": "src/test/ui/suggestions/impl-on-dyn-trait-with-implicit-static-bound-nll.stderr", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound-nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound-nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound-nll.stderr?ref=ed76b773b57cf0aa48ec4e2fc6d6a3f7a9079491", "patch": "@@ -10,6 +10,18 @@ LL |         val.use_self::<T>()\n    |         |\n    |         `val` escapes the function body here\n    |         argument requires that `'a` must outlive `'static`\n+   |\n+note: the used `impl` has a `'static` requirement\n+  --> $DIR/impl-on-dyn-trait-with-implicit-static-bound-nll.rs:19:32\n+   |\n+LL |     impl<T> MyTrait<T> for dyn ObjectTrait<T> {\n+   |                                ^^^^^^^^^^^^^^ this has an implicit `'static` lifetime requirement\n+LL |         fn use_self<K>(&self) -> &() { panic!() }\n+   |            -------- calling this method introduces the `impl`'s 'static` requirement\n+help: consider relaxing the implicit `'static` requirement\n+   |\n+LL |     impl<T> MyTrait<T> for dyn ObjectTrait<T> + '_ {\n+   |                                               ++++\n \n error[E0521]: borrowed data escapes outside of function\n   --> $DIR/impl-on-dyn-trait-with-implicit-static-bound-nll.rs:74:9\n@@ -23,6 +35,18 @@ LL |         val.use_self()\n    |         |\n    |         `val` escapes the function body here\n    |         argument requires that `'a` must outlive `'static`\n+   |\n+note: the used `impl` has a `'static` requirement\n+  --> $DIR/impl-on-dyn-trait-with-implicit-static-bound-nll.rs:69:14\n+   |\n+LL |     impl dyn ObjectTrait {\n+   |              ^^^^^^^^^^^ this has an implicit `'static` lifetime requirement\n+LL |         fn use_self(&self) -> &() { panic!() }\n+   |            -------- calling this method introduces the `impl`'s 'static` requirement\n+help: consider relaxing the implicit `'static` requirement\n+   |\n+LL |     impl dyn ObjectTrait + '_ {\n+   |                          ++++\n \n error[E0521]: borrowed data escapes outside of function\n   --> $DIR/impl-on-dyn-trait-with-implicit-static-bound-nll.rs:94:9\n@@ -36,6 +60,19 @@ LL |         val.use_self()\n    |         |\n    |         `val` escapes the function body here\n    |         argument requires that `'a` must outlive `'static`\n+   |\n+note: the used `impl` has a `'static` requirement\n+  --> $DIR/impl-on-dyn-trait-with-implicit-static-bound-nll.rs:91:26\n+   |\n+LL |         fn use_self(&self) -> &() { panic!() }\n+   |            -------- calling this method introduces the `impl`'s 'static` requirement\n+...\n+LL |     impl MyTrait for dyn ObjectTrait {}\n+   |                          ^^^^^^^^^^^ this has an implicit `'static` lifetime requirement\n+help: consider relaxing the implicit `'static` requirement\n+   |\n+LL |     impl MyTrait for dyn ObjectTrait + '_ {}\n+   |                                      ++++\n \n error[E0521]: borrowed data escapes outside of function\n   --> $DIR/impl-on-dyn-trait-with-implicit-static-bound-nll.rs:114:9\n@@ -49,6 +86,19 @@ LL |         MyTrait::use_self(val)\n    |         |\n    |         `val` escapes the function body here\n    |         argument requires that `'a` must outlive `'static`\n+   |\n+note: the used `impl` has a `'static` requirement\n+  --> $DIR/impl-on-dyn-trait-with-implicit-static-bound-nll.rs:110:26\n+   |\n+LL |         fn use_self(&self) -> &() { panic!() }\n+   |            -------- calling this method introduces the `impl`'s 'static` requirement\n+...\n+LL |     impl MyTrait for dyn ObjectTrait {}\n+   |                          ^^^^^^^^^^^ this has an implicit `'static` lifetime requirement\n+help: consider relaxing the implicit `'static` requirement\n+   |\n+LL |     impl MyTrait for dyn ObjectTrait + '_ {}\n+   |                                      ++++\n \n error: aborting due to 4 previous errors\n "}]}