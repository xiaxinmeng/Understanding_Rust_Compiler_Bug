{"sha": "744fea1a4f1b826def484aa4584e939fa272a8c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0NGZlYTFhNGYxYjgyNmRlZjQ4NGFhNDU4NGU5MzlmYTI3MmE4YzM=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-08-22T20:18:29Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-08-22T20:18:29Z"}, "message": "Track the type of self properly. Closes #3247.", "tree": {"sha": "52e455ddd7906717bcd8319fe5e876592545b35b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/52e455ddd7906717bcd8319fe5e876592545b35b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/744fea1a4f1b826def484aa4584e939fa272a8c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/744fea1a4f1b826def484aa4584e939fa272a8c3", "html_url": "https://github.com/rust-lang/rust/commit/744fea1a4f1b826def484aa4584e939fa272a8c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/744fea1a4f1b826def484aa4584e939fa272a8c3/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "728496929292c692aaad005bdbf4376bb1d78c4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/728496929292c692aaad005bdbf4376bb1d78c4f", "html_url": "https://github.com/rust-lang/rust/commit/728496929292c692aaad005bdbf4376bb1d78c4f"}], "stats": {"total": 203, "additions": 107, "deletions": 96}, "files": [{"sha": "bc0822bec8238ae765aad4f659ec3c279f29a8ac", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 17, "deletions": 21, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/744fea1a4f1b826def484aa4584e939fa272a8c3/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/744fea1a4f1b826def484aa4584e939fa272a8c3/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=744fea1a4f1b826def484aa4584e939fa272a8c3", "patch": "@@ -54,32 +54,28 @@ fn trans_method(ccx: @crate_ctxt,\n                 method: &ast::method,\n                 param_substs: option<param_substs>,\n                 llfn: ValueRef) {\n-    // determine the (monomorphized) type that `self` maps to for this method\n-    let self_ty = ty::node_id_to_type(ccx.tcx, method.self_id);\n-    let self_ty = match param_substs {\n-      none => self_ty,\n-      some({tys: ref tys, _}) => ty::subst_tps(ccx.tcx, *tys, self_ty)\n-    };\n \n-    // apply any transformations from the explicit self declaration\n+    // figure out how self is being passed\n     let self_arg = match method.self_ty.node {\n       ast::sty_static => {\n         no_self\n       }\n-      ast::sty_box(_) => {\n-        impl_self(ty::mk_imm_box(ccx.tcx, self_ty))\n-      }\n-      ast::sty_uniq(_) => {\n-        impl_self(ty::mk_imm_uniq(ccx.tcx, self_ty))\n-      }\n-      ast::sty_region(*) => {\n-        impl_self(ty::mk_imm_ptr(ccx.tcx, self_ty))\n-      }\n-      ast::sty_value => {\n-        impl_owned_self(self_ty)\n-      }\n-      ast::sty_by_ref => {\n-        impl_self(self_ty)\n+      _ => {\n+        // determine the (monomorphized) type that `self` maps to for\n+        // this method\n+        let self_ty = ty::node_id_to_type(ccx.tcx, method.self_id);\n+        let self_ty = match param_substs {\n+          none => self_ty,\n+          some({tys: ref tys, _}) => ty::subst_tps(ccx.tcx, *tys, self_ty)\n+        };\n+        match method.self_ty.node {\n+          ast::sty_value => {\n+            impl_owned_self(self_ty)\n+          }\n+          _ => {\n+            impl_self(self_ty)\n+          }\n+        }\n       }\n     };\n "}, {"sha": "ff9bd009498df70626f0cf3ed0b0568793a0e3ef", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 57, "deletions": 58, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/744fea1a4f1b826def484aa4584e939fa272a8c3/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/744fea1a4f1b826def484aa4584e939fa272a8c3/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=744fea1a4f1b826def484aa4584e939fa272a8c3", "patch": "@@ -79,15 +79,16 @@ import std::map::str_hash;\n \n type self_info = {\n     self_ty: ty::t,\n+    self_id: ast::node_id,\n     def_id: ast::def_id,\n-    explicit_self: ast::self_ty_\n+    explicit_self: ast::self_ty\n };\n \n type fn_ctxt_ =\n     // var_bindings, locals and next_var_id are shared\n     // with any nested functions that capture the environment\n     // (and with any functions whose environment is being captured).\n-    {self_info: option<self_info>,\n+    {self_impl_def_id: option<ast::def_id>,\n      ret_ty: ty::t,\n      // Used by loop bodies that return from the outer function\n      indirect_ret_ty: option<ty::t>,\n@@ -126,7 +127,7 @@ fn blank_fn_ctxt(ccx: @crate_ctxt, rty: ty::t,\n                  region_bnd: ast::node_id) -> @fn_ctxt {\n // It's kind of a kludge to manufacture a fake function context\n // and statement context, but we might as well do write the code only once\n-    @fn_ctxt_({self_info: none,\n+    @fn_ctxt_({self_impl_def_id: none,\n                ret_ty: rty,\n                indirect_ret_ty: none,\n                purity: ast::pure_fn,\n@@ -244,7 +245,7 @@ fn check_fn(ccx: @crate_ctxt,\n             }\n         } else { none };\n \n-        @fn_ctxt_({self_info: self_info,\n+        @fn_ctxt_({self_impl_def_id: self_info.map(|info| info.def_id),\n                    ret_ty: ret_ty,\n                    indirect_ret_ty: indirect_ret_ty,\n                    purity: purity,\n@@ -257,7 +258,22 @@ fn check_fn(ccx: @crate_ctxt,\n                    ccx: ccx})\n     };\n \n-    gather_locals(fcx, decl, body, arg_tys);\n+    // Update the self_info to contain an accurate self type (taking\n+    // into account explicit self).\n+    let self_info = do self_info.chain |info| {\n+        // If the self type is sty_static, we don't have a self ty.\n+        if info.explicit_self.node == ast::sty_static {\n+            none\n+        } else  {\n+            let self_region = fcx.in_scope_regions.find(ty::br_self);\n+            let ty = method::transform_self_type_for_method(\n+                fcx.tcx(), self_region,\n+                info.self_ty, info.explicit_self.node);\n+            some({self_ty: ty with info})\n+        }\n+    };\n+\n+    gather_locals(fcx, decl, body, arg_tys, self_info);\n     check_block(fcx, body);\n \n     // We unify the tail expr's type with the\n@@ -270,10 +286,11 @@ fn check_fn(ccx: @crate_ctxt,\n       none => ()\n     }\n \n-    let mut i = 0u;\n-    do vec::iter(arg_tys) |arg| {\n-        fcx.write_ty(decl.inputs[i].id, arg);\n-        i += 1u;\n+    for self_info.each |info| {\n+        fcx.write_ty(info.self_id, info.self_ty);\n+    }\n+    do vec::iter2(decl.inputs, arg_tys) |input, arg| {\n+        fcx.write_ty(input.id, arg);\n     }\n \n     // If we don't have any enclosing function scope, it is time to\n@@ -283,13 +300,14 @@ fn check_fn(ccx: @crate_ctxt,\n     if option::is_none(old_fcx) {\n         vtable::resolve_in_block(fcx, body);\n         regionck::regionck_fn(fcx, decl, body);\n-        writeback::resolve_type_vars_in_fn(fcx, decl, body);\n+        writeback::resolve_type_vars_in_fn(fcx, decl, body, self_info);\n     }\n \n     fn gather_locals(fcx: @fn_ctxt,\n                      decl: ast::fn_decl,\n                      body: ast::blk,\n-                     arg_tys: ~[ty::t]) {\n+                     arg_tys: ~[ty::t],\n+                     self_info: option<self_info>) {\n         let tcx = fcx.ccx.tcx;\n \n         let assign = fn@(span: span, nid: ast::node_id,\n@@ -305,6 +323,14 @@ fn check_fn(ccx: @crate_ctxt,\n             }\n         };\n \n+        // Add the self parameter\n+        for self_info.each |info| {\n+            assign(info.explicit_self.span,\n+                   info.self_id, some(info.self_ty));\n+            debug!{\"self is assigned to %s\",\n+                   fcx.locals.get(info.self_id).to_str()};\n+        }\n+\n         // Add formal parameters.\n         do vec::iter2(arg_tys, decl.inputs) |arg_ty, input| {\n             assign(input.ty.span, input.id, some(arg_ty));\n@@ -369,8 +395,11 @@ fn check_fn(ccx: @crate_ctxt,\n }\n \n fn check_method(ccx: @crate_ctxt, method: @ast::method,\n-                self_info: self_info) {\n-\n+                self_ty: ty::t, self_impl_def_id: ast::def_id) {\n+    let self_info = {self_ty: self_ty,\n+                     self_id: method.self_id,\n+                     def_id: self_impl_def_id,\n+                     explicit_self: method.self_ty };\n     check_bare_fn(ccx, method.decl, method.body, method.id, some(self_info));\n }\n \n@@ -404,33 +433,31 @@ fn check_struct(ccx: @crate_ctxt, struct_def: @ast::struct_def,\n \n     do option::iter(struct_def.ctor) |ctor| {\n         let class_t = {self_ty: self_ty,\n+                       self_id: ctor.node.self_id,\n                        def_id: local_def(id),\n-                       explicit_self: ast::sty_by_ref};\n+                       explicit_self: {node: ast::sty_by_ref,\n+                                       span: ast_util::dummy_sp()}};\n         // typecheck the ctor\n         check_bare_fn(ccx, ctor.node.dec,\n                       ctor.node.body, ctor.node.id,\n                       some(class_t));\n-        // Write the ctor's self's type\n-        write_ty_to_tcx(tcx, ctor.node.self_id, class_t.self_ty);\n     }\n \n     do option::iter(struct_def.dtor) |dtor| {\n         let class_t = {self_ty: self_ty,\n+                       self_id: dtor.node.self_id,\n                        def_id: local_def(id),\n-                       explicit_self: ast::sty_by_ref};\n+                       explicit_self: {node: ast::sty_by_ref,\n+                                       span: ast_util::dummy_sp()}};\n         // typecheck the dtor\n         check_bare_fn(ccx, ast_util::dtor_dec(),\n                       dtor.node.body, dtor.node.id,\n                       some(class_t));\n-        // Write the dtor's self's type\n-        write_ty_to_tcx(tcx, dtor.node.self_id, class_t.self_ty);\n     };\n \n     // typecheck the methods\n     for struct_def.methods.each |m| {\n-        check_method(ccx, m, {self_ty: self_ty,\n-                              def_id: local_def(id),\n-                              explicit_self: m.self_ty.node});\n+        check_method(ccx, m, self_ty, local_def(id));\n     }\n     // Check that there's at least one field\n     if struct_def.fields.len() < 1u {\n@@ -455,10 +482,7 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n                *it.ident, it.id, rp};\n         let self_ty = ccx.to_ty(rscope::type_rscope(rp), ty);\n         for ms.each |m| {\n-            let self_info = {self_ty: self_ty,\n-                             def_id: local_def(it.id),\n-                             explicit_self: m.self_ty.node };\n-            check_method(ccx, m, self_info)\n+            check_method(ccx, m, self_ty, local_def(it.id));\n         }\n       }\n       ast::item_trait(_, _, trait_methods) => {\n@@ -469,10 +493,7 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n                 // bodies to check.\n               }\n               provided(m) => {\n-                let self_info = {self_ty: ty::mk_self(ccx.tcx),\n-                                 def_id: local_def(it.id),\n-                                 explicit_self: m.self_ty.node};\n-                check_method(ccx, m, self_info);\n+                check_method(ccx, m, ty::mk_self(ccx.tcx), local_def(it.id));\n               }\n             }\n         }\n@@ -1204,7 +1225,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n \n         fcx.write_ty(expr.id, fty);\n \n-        check_fn(fcx.ccx, fcx.self_info, &fn_ty, decl, body,\n+        check_fn(fcx.ccx, none, &fn_ty, decl, body,\n                  is_loop_body, some(fcx));\n     }\n \n@@ -2247,29 +2268,12 @@ fn ty_param_bounds_and_ty_for_def(fcx: @fn_ctxt, sp: span, defn: ast::def) ->\n     ty_param_bounds_and_ty {\n \n     match defn {\n-      ast::def_arg(nid, _) => {\n+      ast::def_arg(nid, _) | ast::def_local(nid, _) |\n+      ast::def_self(nid) | ast::def_binding(nid, _) => {\n         assert (fcx.locals.contains_key(nid));\n         let typ = ty::mk_var(fcx.ccx.tcx, lookup_local(fcx, sp, nid));\n         return no_params(typ);\n       }\n-      ast::def_local(nid, _) => {\n-        assert (fcx.locals.contains_key(nid));\n-        let typ = ty::mk_var(fcx.ccx.tcx, lookup_local(fcx, sp, nid));\n-        return no_params(typ);\n-      }\n-      ast::def_self(_) => {\n-        match fcx.self_info {\n-          some(self_info) => {\n-            let self_region = fcx.in_scope_regions.find(ty::br_self);\n-            return no_params(method::transform_self_type_for_method(\n-                fcx.tcx(), self_region,\n-                self_info.self_ty, self_info.explicit_self));\n-          }\n-          none => {\n-              fcx.ccx.tcx.sess.span_bug(sp, ~\"def_self with no self_info\");\n-          }\n-        }\n-      }\n       ast::def_fn(id, ast::extern_fn) => {\n         // extern functions are just u8 pointers\n         return {\n@@ -2296,20 +2300,15 @@ fn ty_param_bounds_and_ty_for_def(fcx: @fn_ctxt, sp: span, defn: ast::def) ->\n       ast::def_class(id, _) => {\n         return ty::lookup_item_type(fcx.ccx.tcx, id);\n       }\n-      ast::def_binding(nid, _) => {\n-        assert (fcx.locals.contains_key(nid));\n-        let typ = ty::mk_var(fcx.ccx.tcx, lookup_local(fcx, sp, nid));\n-        return no_params(typ);\n-      }\n-      ast::def_ty(_) | ast::def_prim_ty(_) => {\n-        fcx.ccx.tcx.sess.span_fatal(sp, ~\"expected value but found type\");\n-      }\n       ast::def_upvar(_, inner, _, _) => {\n         return ty_param_bounds_and_ty_for_def(fcx, sp, *inner);\n       }\n       ast::def_ty_param(did, n) => {\n         return no_params(ty::mk_param(fcx.ccx.tcx, n, did));\n       }\n+      ast::def_ty(_) | ast::def_prim_ty(_) => {\n+        fcx.ccx.tcx.sess.span_fatal(sp, ~\"expected value but found type\");\n+      }\n       ast::def_mod(*) | ast::def_foreign_mod(*) => {\n         fcx.ccx.tcx.sess.span_fatal(sp, ~\"expected value but found module\");\n       }"}, {"sha": "a711e2280b41c70d299a94cad2afa36a706534ef", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/744fea1a4f1b826def484aa4584e939fa272a8c3/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/744fea1a4f1b826def484aa4584e939fa272a8c3/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=744fea1a4f1b826def484aa4584e939fa272a8c3", "patch": "@@ -150,14 +150,8 @@ struct lookup {\n               ty::ty_self => {\n                 // Call is of the form \"self.foo()\" and appears in one\n                 // of a trait's provided methods.\n-                let self_def_id = match self.fcx.self_info {\n-                  some(self_info) => self_info.def_id,\n-                  none => {\n-                    // Shouldn't happen; there should always be a\n-                    // self_info in this case.\n-                    self.tcx().sess.bug(~\"unexpected `none` for self_info\")\n-                  }\n-                };\n+                let self_def_id = self.fcx.self_impl_def_id.expect(\n+                    ~\"unexpected `none` for self_impl_def_id\");\n \n                 let substs = {\n                     self_r: none,"}, {"sha": "7eb88a397dfb5f771fb29185d25b558edcfc5bdd", "filename": "src/rustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/744fea1a4f1b826def484aa4584e939fa272a8c3/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/744fea1a4f1b826def484aa4584e939fa272a8c3/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=744fea1a4f1b826def484aa4584e939fa272a8c3", "patch": "@@ -23,7 +23,7 @@ fn replace_bound_regions_in_fn_ty(\n     let mut all_tys = ty::tys_in_fn_ty(fn_ty);\n \n     match self_info {\n-      some({explicit_self: ast::sty_region(m), _}) => {\n+      some({explicit_self: {node: ast::sty_region(m), _}, _}) => {\n         let region = ty::re_bound(ty::br_self);\n         let ty = ty::mk_rptr(tcx, region,\n                              { ty: ty::mk_self(tcx), mutbl: m });"}, {"sha": "4f9bc928860e6b827dc7bdd18b94d1322ce3bbc8", "filename": "src/rustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/744fea1a4f1b826def484aa4584e939fa272a8c3/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/744fea1a4f1b826def484aa4584e939fa272a8c3/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=744fea1a4f1b826def484aa4584e939fa272a8c3", "patch": "@@ -171,10 +171,16 @@ fn resolve_type_vars_in_expr(fcx: @fn_ctxt, e: @ast::expr) -> bool {\n \n fn resolve_type_vars_in_fn(fcx: @fn_ctxt,\n                            decl: ast::fn_decl,\n-                           blk: ast::blk) -> bool {\n+                           blk: ast::blk,\n+                           self_info: option<self_info>) -> bool {\n     let wbcx = {fcx: fcx, mut success: true};\n     let visit = mk_visitor();\n     visit.visit_block(blk, wbcx, visit);\n+    for self_info.each |self_info| {\n+        if self_info.explicit_self.node == ast::sty_static { break; }\n+        resolve_type_vars_for_node(wbcx, self_info.explicit_self.span,\n+                                   self_info.self_id);\n+    }\n     for decl.inputs.each |arg| {\n         resolve_type_vars_for_node(wbcx, arg.ty.span, arg.id);\n     }"}, {"sha": "250f431a1c7bad69f83fce4fcbe5575b66fda3d8", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/744fea1a4f1b826def484aa4584e939fa272a8c3/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/744fea1a4f1b826def484aa4584e939fa272a8c3/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=744fea1a4f1b826def484aa4584e939fa272a8c3", "patch": "@@ -381,12 +381,10 @@ type converted_method = {mty: ty::method, id: ast::node_id, span: span};\n fn convert_methods(ccx: @crate_ctxt,\n                    ms: ~[@ast::method],\n                    rp: bool,\n-                   rcvr_bounds: @~[ty::param_bounds],\n-                   self_ty: ty::t) -> ~[converted_method] {\n+                   rcvr_bounds: @~[ty::param_bounds]) -> ~[converted_method] {\n \n     let tcx = ccx.tcx;\n     do vec::map(ms) |m| {\n-        write_ty_to_tcx(tcx, m.self_id, self_ty);\n         let bounds = ty_param_bounds(ccx, m.tps);\n         let mty = ty_of_method(ccx, m, rp);\n         let fty = ty::mk_fn(tcx, mty.fty);\n@@ -423,7 +421,7 @@ fn convert(ccx: @crate_ctxt, it: @ast::item) {\n                            rp: rp,\n                            ty: selfty});\n \n-        let cms = convert_methods(ccx, ms, rp, i_bounds, selfty);\n+        let cms = convert_methods(ccx, ms, rp, i_bounds);\n         for trait_ref.each |t| {\n             check_methods_against_trait(ccx, tps, rp, selfty, t, cms);\n         }\n@@ -436,9 +434,8 @@ fn convert(ccx: @crate_ctxt, it: @ast::item) {\n         ensure_trait_methods(ccx, it.id, tpt.ty);\n \n         let (_, provided_methods) = split_trait_methods(trait_methods);\n-        let selfty = ty::mk_self(tcx);\n         let {bounds, _} = mk_substs(ccx, tps, rp);\n-        let _cms = convert_methods(ccx, provided_methods, rp, bounds, selfty);\n+        let _cms = convert_methods(ccx, provided_methods, rp, bounds);\n         // FIXME (#2616): something like this, when we start having\n         // trait inheritance?\n         // for trait_ref.each |t| {\n@@ -510,7 +507,7 @@ fn convert_struct(ccx: @crate_ctxt, rp: bool, struct_def: @ast::struct_def,\n     }\n     let {bounds, substs} = mk_substs(ccx, tps, rp);\n     let selfty = ty::mk_class(tcx, local_def(id), substs);\n-    let cms = convert_methods(ccx, struct_def.methods, rp, bounds, selfty);\n+    let cms = convert_methods(ccx, struct_def.methods, rp, bounds);\n     for struct_def.traits.each |trait_ref| {\n         check_methods_against_trait(ccx, tps, rp, selfty, trait_ref, cms);\n         // trait_ref.impl_id represents (class, trait) pair"}, {"sha": "b1f447d66489243f89a399656bd0eee6751a414c", "filename": "src/test/run-pass/explicit-self-closures.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/744fea1a4f1b826def484aa4584e939fa272a8c3/src%2Ftest%2Frun-pass%2Fexplicit-self-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/744fea1a4f1b826def484aa4584e939fa272a8c3/src%2Ftest%2Frun-pass%2Fexplicit-self-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit-self-closures.rs?ref=744fea1a4f1b826def484aa4584e939fa272a8c3", "patch": "@@ -0,0 +1,19 @@\n+// Test to make sure that explicit self params work inside closures\n+\n+struct Box {\n+    x: uint;\n+}\n+\n+impl Box {\n+    fn set_many(&mut self, xs: &[uint]) {\n+        for xs.each |x| { self.x = x; }\n+    }\n+    fn set_many2(@mut self, xs: &[uint]) {\n+        for xs.each |x| { self.x = x; }\n+    }\n+    fn set_many3(~mut self, xs: &[uint]) {\n+        for xs.each |x| { self.x = x; }\n+    }\n+}\n+\n+fn main() {}"}]}