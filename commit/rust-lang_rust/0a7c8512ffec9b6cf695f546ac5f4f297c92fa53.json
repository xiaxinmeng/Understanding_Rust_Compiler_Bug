{"sha": "0a7c8512ffec9b6cf695f546ac5f4f297c92fa53", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhN2M4NTEyZmZlYzliNmNmNjk1ZjU0NmFjNWY0ZjI5N2M5MmZhNTM=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2020-11-06T01:13:29Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2020-11-06T01:15:13Z"}, "message": "Support closures in infer_function_return_type assist", "tree": {"sha": "6a0bd8941356a8160896ffa463298f44e9a0acde", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a0bd8941356a8160896ffa463298f44e9a0acde"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a7c8512ffec9b6cf695f546ac5f4f297c92fa53", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a7c8512ffec9b6cf695f546ac5f4f297c92fa53", "html_url": "https://github.com/rust-lang/rust/commit/0a7c8512ffec9b6cf695f546ac5f4f297c92fa53", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a7c8512ffec9b6cf695f546ac5f4f297c92fa53/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a14df19d825152aff823fae3344f9e4c2d31937b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a14df19d825152aff823fae3344f9e4c2d31937b", "html_url": "https://github.com/rust-lang/rust/commit/a14df19d825152aff823fae3344f9e4c2d31937b"}], "stats": {"total": 133, "additions": 114, "deletions": 19}, "files": [{"sha": "f363a56f3220b47445e7b3eb2323286efe967807", "filename": "crates/assists/src/handlers/infer_function_return_type.rs", "status": "modified", "additions": 114, "deletions": 19, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/0a7c8512ffec9b6cf695f546ac5f4f297c92fa53/crates%2Fassists%2Fsrc%2Fhandlers%2Finfer_function_return_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a7c8512ffec9b6cf695f546ac5f4f297c92fa53/crates%2Fassists%2Fsrc%2Fhandlers%2Finfer_function_return_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Finfer_function_return_type.rs?ref=0a7c8512ffec9b6cf695f546ac5f4f297c92fa53", "patch": "@@ -1,12 +1,12 @@\n use hir::HirDisplay;\n-use syntax::{ast, AstNode, TextSize};\n+use syntax::{ast, AstNode, SyntaxToken, TextSize};\n use test_utils::mark;\n \n use crate::{AssistContext, AssistId, AssistKind, Assists};\n \n // Assist: infer_function_return_type\n //\n-// Adds the return type to a function inferred from its tail expression if it doesn't have a return\n+// Adds the return type to a function or closure inferred from its tail expression if it doesn't have a return\n // type specified.\n //\n // ```\n@@ -18,36 +18,52 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n // ```\n pub(crate) fn infer_function_return_type(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let expr = ctx.find_node_at_offset::<ast::Expr>()?;\n-    let func = expr.syntax().ancestors().find_map(ast::Fn::cast)?;\n-\n-    if func.ret_type().is_some() {\n-        mark::hit!(existing_ret_type);\n-        return None;\n-    }\n-    let body = func.body()?;\n-    let tail_expr = body.expr()?;\n-    // check whether the expr we were at is indeed the tail expression\n-    if !tail_expr.syntax().text_range().contains_range(expr.syntax().text_range()) {\n-        mark::hit!(not_tail_expr);\n-        return None;\n-    }\n-    let module = ctx.sema.scope(func.syntax()).module()?;\n+    let (tail_expr, insert_pos) = extract(expr)?;\n+    let module = ctx.sema.scope(tail_expr.syntax()).module()?;\n     let ty = ctx.sema.type_of_expr(&tail_expr)?;\n     let ty = ty.display_source_code(ctx.db(), module.into()).ok()?;\n-    let rparen = func.param_list()?.r_paren_token()?;\n \n     acc.add(\n         AssistId(\"change_return_type_to_result\", AssistKind::RefactorRewrite),\n         \"Wrap return type in Result\",\n         tail_expr.syntax().text_range(),\n         |builder| {\n-            let insert_pos = rparen.text_range().end() + TextSize::from(1);\n-\n+            let insert_pos = insert_pos.text_range().end() + TextSize::from(1);\n             builder.insert(insert_pos, &format!(\"-> {} \", ty));\n         },\n     )\n }\n \n+fn extract(expr: ast::Expr) -> Option<(ast::Expr, SyntaxToken)> {\n+    let (ret_ty, tail_expr, insert_pos) =\n+        if let Some(closure) = expr.syntax().ancestors().find_map(ast::ClosureExpr::cast) {\n+            let tail_expr = match closure.body()? {\n+                ast::Expr::BlockExpr(block) => block.expr()?,\n+                body => body,\n+            };\n+            let ret_ty = closure.ret_type();\n+            let rpipe = closure.param_list()?.syntax().last_token()?;\n+            (ret_ty, tail_expr, rpipe)\n+        } else {\n+            let func = expr.syntax().ancestors().find_map(ast::Fn::cast)?;\n+            let tail_expr = func.body()?.expr()?;\n+            let ret_ty = func.ret_type();\n+            let rparen = func.param_list()?.r_paren_token()?;\n+            (ret_ty, tail_expr, rparen)\n+        };\n+    if ret_ty.is_some() {\n+        mark::hit!(existing_ret_type);\n+        mark::hit!(existing_ret_type_closure);\n+        return None;\n+    }\n+    // check whether the expr we were at is indeed the tail expression\n+    if !tail_expr.syntax().text_range().contains_range(expr.syntax().text_range()) {\n+        mark::hit!(not_tail_expr);\n+        return None;\n+    }\n+    Some((tail_expr, insert_pos))\n+}\n+\n #[cfg(test)]\n mod tests {\n     use crate::tests::{check_assist, check_assist_not_applicable};\n@@ -110,4 +126,83 @@ mod tests {\n             }\"#,\n         );\n     }\n+\n+    #[test]\n+    fn infer_return_type_closure_block() {\n+        check_assist(\n+            infer_function_return_type,\n+            r#\"fn foo() {\n+                |x: i32| {\n+                    x<|>\n+                };\n+            }\"#,\n+            r#\"fn foo() {\n+                |x: i32| -> i32 {\n+                    x\n+                };\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn infer_return_type_closure() {\n+        check_assist(\n+            infer_function_return_type,\n+            r#\"fn foo() {\n+                |x: i32| x<|>;\n+            }\"#,\n+            r#\"fn foo() {\n+                |x: i32| -> i32 x;\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn infer_return_type_nested_closure() {\n+        check_assist(\n+            infer_function_return_type,\n+            r#\"fn foo() {\n+                || {\n+                    if true {\n+                        3<|>\n+                    } else {\n+                        5\n+                    }\n+                }\n+            }\"#,\n+            r#\"fn foo() {\n+                || -> i32 {\n+                    if true {\n+                        3\n+                    } else {\n+                        5\n+                    }\n+                }\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_ret_type_specified_closure() {\n+        mark::check!(existing_ret_type_closure);\n+        check_assist_not_applicable(\n+            infer_function_return_type,\n+            r#\"fn foo() {\n+                || -> i32 { 3<|> }\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_non_tail_expr_closure() {\n+        check_assist_not_applicable(\n+            infer_function_return_type,\n+            r#\"fn foo() {\n+                || -> i32 {\n+                    let x = 3<|>;\n+                    6\n+                }\n+            }\"#,\n+        );\n+    }\n }"}]}