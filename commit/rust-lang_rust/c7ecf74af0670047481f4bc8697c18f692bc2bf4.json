{"sha": "c7ecf74af0670047481f4bc8697c18f692bc2bf4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3ZWNmNzRhZjA2NzAwNDc0ODFmNGJjODY5N2MxOGY2OTJiYzJiZjQ=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2015-06-15T08:32:12Z"}, "committer": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2015-06-15T08:32:12Z"}, "message": "Merge pull request #106 from marcusklaas/issue-number-check-2\n\nImplement checks for unnumbered TODOs and FIXMEs", "tree": {"sha": "1c40ff0a93617e02d4a2dfd5f1842d76362a1633", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c40ff0a93617e02d4a2dfd5f1842d76362a1633"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c7ecf74af0670047481f4bc8697c18f692bc2bf4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c7ecf74af0670047481f4bc8697c18f692bc2bf4", "html_url": "https://github.com/rust-lang/rust/commit/c7ecf74af0670047481f4bc8697c18f692bc2bf4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c7ecf74af0670047481f4bc8697c18f692bc2bf4/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9da7be929f2b048b9f062a04b0a85e2c4e455966", "url": "https://api.github.com/repos/rust-lang/rust/commits/9da7be929f2b048b9f062a04b0a85e2c4e455966", "html_url": "https://github.com/rust-lang/rust/commit/9da7be929f2b048b9f062a04b0a85e2c4e455966"}, {"sha": "d335d0457536d985f5f4ff406ccf8a7a8c933133", "url": "https://api.github.com/repos/rust-lang/rust/commits/d335d0457536d985f5f4ff406ccf8a7a8c933133", "html_url": "https://github.com/rust-lang/rust/commit/d335d0457536d985f5f4ff406ccf8a7a8c933133"}], "stats": {"total": 457, "additions": 435, "deletions": 22}, "files": [{"sha": "97133ab67fbdd688fb6d2e22d1e2b4a651bf2800", "filename": "src/changes.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c7ecf74af0670047481f4bc8697c18f692bc2bf4/src%2Fchanges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ecf74af0670047481f4bc8697c18f692bc2bf4/src%2Fchanges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchanges.rs?ref=c7ecf74af0670047481f4bc8697c18f692bc2bf4", "patch": "@@ -21,6 +21,7 @@ use std::fs::File;\n use std::io::{Write, stdout};\n use WriteMode;\n use NewlineStyle;\n+use utils::round_up_to_power_of_two;\n \n // This is basically a wrapper around a bunch of Ropes which makes it convenient\n // to work with libsyntax. It is badly named.\n@@ -41,11 +42,10 @@ impl<'a> ChangeSet<'a> {\n \n         for f in codemap.files.borrow().iter() {\n             // Use the length of the file as a heuristic for how much space we\n-            // need. I hope that at some stage someone rounds this up to the next\n-            // power of two. TODO check that or do it here.\n-            result.file_map.insert(f.name.clone(),\n-                                   StringBuffer::with_capacity(f.src.as_ref().unwrap().len()));\n+            // need. Round to the next power of two.\n+            let buffer_cap = round_up_to_power_of_two(f.src.as_ref().unwrap().len());\n \n+            result.file_map.insert(f.name.clone(), StringBuffer::with_capacity(buffer_cap));\n             result.file_spans.push((f.start_pos.0, f.end_pos.0));\n         }\n "}, {"sha": "c803a07d9d0ed9c44616ced038500caf1aa9d64f", "filename": "src/config.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c7ecf74af0670047481f4bc8697c18f692bc2bf4/src%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ecf74af0670047481f4bc8697c18f692bc2bf4/src%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig.rs?ref=c7ecf74af0670047481f4bc8697c18f692bc2bf4", "patch": "@@ -10,19 +10,25 @@\n \n extern crate toml;\n \n+use {NewlineStyle, BraceStyle, ReturnIndent};\n+use lists::SeparatorTactic;\n+use issues::ReportTactic;\n+\n #[derive(RustcDecodable)]\n pub struct Config {\n     pub max_width: usize,\n     pub ideal_width: usize,\n     pub leeway: usize,\n     pub tab_spaces: usize,\n-    pub newline_style: ::NewlineStyle,\n-    pub fn_brace_style: ::BraceStyle,\n-    pub fn_return_indent: ::ReturnIndent,\n+    pub newline_style: NewlineStyle,\n+    pub fn_brace_style: BraceStyle,\n+    pub fn_return_indent: ReturnIndent,\n     pub fn_args_paren_newline: bool,\n     pub struct_trailing_comma: bool,\n-    pub struct_lit_trailing_comma: ::lists::SeparatorTactic,\n+    pub struct_lit_trailing_comma: SeparatorTactic,\n     pub enum_trailing_comma: bool,\n+    pub report_todo: ReportTactic,\n+    pub report_fixme: ReportTactic,\n }\n \n impl Config {"}, {"sha": "75ab3a60164489a575eceed77c734647e080a80f", "filename": "src/default.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7ecf74af0670047481f4bc8697c18f692bc2bf4/src%2Fdefault.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c7ecf74af0670047481f4bc8697c18f692bc2bf4/src%2Fdefault.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdefault.toml?ref=c7ecf74af0670047481f4bc8697c18f692bc2bf4", "patch": "@@ -9,3 +9,5 @@ fn_args_paren_newline = true\n struct_trailing_comma = true\n struct_lit_trailing_comma = \"Vertical\"\n enum_trailing_comma = true\n+report_todo = \"Always\"\n+report_fixme = \"Never\""}, {"sha": "9ee70e1aadca596a0215f0ae04877634826aef9c", "filename": "src/issues.rs", "status": "added", "additions": 298, "deletions": 0, "changes": 298, "blob_url": "https://github.com/rust-lang/rust/blob/c7ecf74af0670047481f4bc8697c18f692bc2bf4/src%2Fissues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ecf74af0670047481f4bc8697c18f692bc2bf4/src%2Fissues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fissues.rs?ref=c7ecf74af0670047481f4bc8697c18f692bc2bf4", "patch": "@@ -0,0 +1,298 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Objects for seeking through a char stream for occurences of TODO and FIXME.\n+// Depending on the loaded configuration, may also check that these have an\n+// associated issue number.\n+\n+use std::fmt;\n+\n+static TO_DO_CHARS: &'static [char] = &['T', 'O', 'D', 'O'];\n+static FIX_ME_CHARS: &'static [char] = &['F', 'I', 'X', 'M', 'E'];\n+\n+#[derive(Clone, Copy)]\n+pub enum ReportTactic {\n+    Always,\n+    Unnumbered,\n+    Never\n+}\n+\n+impl ReportTactic {\n+    fn is_enabled(&self) -> bool {\n+        match *self {\n+            ReportTactic::Always => true,\n+            ReportTactic::Unnumbered => true,\n+            ReportTactic::Never => false\n+        }\n+    }\n+}\n+\n+impl_enum_decodable!(ReportTactic, Always, Unnumbered, Never);\n+\n+#[derive(Clone, Copy)]\n+enum Seeking {\n+    Issue {\n+        todo_idx: usize,\n+        fixme_idx: usize\n+    },\n+    Number {\n+        issue: Issue,\n+        part: NumberPart\n+    }\n+}\n+\n+#[derive(Clone, Copy)]\n+enum NumberPart {\n+    OpenParen,\n+    Pound,\n+    Number,\n+    CloseParen\n+}\n+\n+#[derive(PartialEq, Eq, Debug, Clone, Copy)]\n+pub struct Issue {\n+    issue_type: IssueType,\n+    // Indicates whether we're looking for issues with missing numbers, or\n+    // all issues of this type.\n+    missing_number: bool,\n+}\n+\n+impl fmt::Display for Issue {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        let msg = match self.issue_type {\n+            IssueType::Todo => \"TODO\",\n+            IssueType::Fixme => \"FIXME\",\n+        };\n+        let details = if self.missing_number { \" without issue number\" } else { \"\" };\n+\n+        write!(fmt, \"{}{}\", msg, details)\n+    }\n+}\n+\n+#[derive(PartialEq, Eq, Debug, Clone, Copy)]\n+enum IssueType {\n+    Todo,\n+    Fixme\n+}\n+\n+enum IssueClassification {\n+    Good,\n+    Bad(Issue),\n+    None\n+}\n+\n+pub struct BadIssueSeeker {\n+    state: Seeking,\n+    report_todo: ReportTactic,\n+    report_fixme: ReportTactic,\n+}\n+\n+impl BadIssueSeeker {\n+    pub fn new(report_todo: ReportTactic, report_fixme: ReportTactic) -> BadIssueSeeker {\n+        BadIssueSeeker {\n+            state: Seeking::Issue { todo_idx: 0, fixme_idx: 0 },\n+            report_todo: report_todo,\n+            report_fixme: report_fixme,\n+        }\n+    }\n+\n+    // Check whether or not the current char is conclusive evidence for an\n+    // unnumbered TO-DO or FIX-ME.\n+    pub fn inspect(&mut self, c: char) -> Option<Issue> {\n+        match self.state {\n+            Seeking::Issue { todo_idx, fixme_idx } => {\n+                self.state = self.inspect_issue(c, todo_idx, fixme_idx);\n+            },\n+            Seeking::Number { issue, part } => {\n+                let result = self.inspect_number(c, issue, part);\n+\n+                if let IssueClassification::None = result {\n+                    return None;\n+                }\n+\n+                self.state = Seeking::Issue { todo_idx: 0, fixme_idx: 0 };\n+\n+                if let IssueClassification::Bad(issue) = result {\n+                    return Some(issue);\n+                }\n+            }\n+        }\n+\n+        None\n+    }\n+\n+    fn inspect_issue(&mut self, c: char, mut todo_idx: usize, mut fixme_idx: usize) -> Seeking {\n+        // FIXME: Should we also check for lower case characters?\n+        if self.report_todo.is_enabled() && c == TO_DO_CHARS[todo_idx] {\n+            todo_idx += 1;\n+            if todo_idx == TO_DO_CHARS.len() {\n+                return Seeking::Number {\n+                    issue: Issue {\n+                        issue_type: IssueType::Todo,\n+                        missing_number: if let ReportTactic::Unnumbered = self.report_todo {\n+                            true\n+                        } else {\n+                            false\n+                        }\n+                    },\n+                    part: NumberPart::OpenParen\n+                };\n+            }\n+            fixme_idx = 0;\n+        } else if self.report_fixme.is_enabled() && c == FIX_ME_CHARS[fixme_idx] {\n+            // Exploit the fact that the character sets of todo and fixme\n+            // are disjoint by adding else.\n+            fixme_idx += 1;\n+            if fixme_idx == FIX_ME_CHARS.len() {\n+                return Seeking::Number {\n+                    issue: Issue {\n+                        issue_type: IssueType::Fixme,\n+                        missing_number: if let ReportTactic::Unnumbered = self.report_fixme {\n+                            true\n+                        } else {\n+                            false\n+                        }\n+                    },\n+                    part: NumberPart::OpenParen\n+                };\n+            }\n+            todo_idx = 0;\n+        } else {\n+            todo_idx = 0;\n+            fixme_idx = 0;\n+        }\n+\n+        Seeking::Issue { todo_idx: todo_idx, fixme_idx: fixme_idx }\n+    }\n+\n+    fn inspect_number(&mut self,\n+                      c: char,\n+                      issue: Issue,\n+                      mut part: NumberPart)\n+        -> IssueClassification\n+    {\n+        if ! issue.missing_number || c == '\\n' {\n+            return IssueClassification::Bad(issue);\n+        } else if c == ')' {\n+            return if let NumberPart::CloseParen = part {\n+                IssueClassification::Good\n+            } else {\n+                IssueClassification::Bad(issue)\n+            };\n+        }\n+\n+        match part {\n+            NumberPart::OpenParen => {\n+                if c != '(' {\n+                    return IssueClassification::Bad(issue);\n+                } else {\n+                    part = NumberPart::Pound;\n+                }\n+            },\n+            NumberPart::Pound => {\n+                if c == '#' {\n+                    part = NumberPart::Number;\n+                }\n+            },\n+            NumberPart::Number => {\n+                if c >= '0' && c <= '9' {\n+                    part = NumberPart::CloseParen;\n+                } else {\n+                    return IssueClassification::Bad(issue);\n+                }\n+            },\n+            NumberPart::CloseParen => {}\n+        }\n+\n+        self.state = Seeking::Number {\n+            part: part,\n+            issue: issue\n+        };\n+\n+        IssueClassification::None\n+    }\n+}\n+\n+#[test]\n+fn find_unnumbered_issue() {\n+    fn check_fail(text: &str, failing_pos: usize) {\n+        println!(\"{:?}\", text);\n+        let mut seeker = BadIssueSeeker::new(ReportTactic::Unnumbered, ReportTactic::Unnumbered);\n+        assert_eq!(Some(failing_pos), text.chars().position(|c| seeker.inspect(c).is_some()));\n+    }\n+\n+    fn check_pass(text: &str) {\n+        let mut seeker = BadIssueSeeker::new(ReportTactic::Unnumbered, ReportTactic::Unnumbered);\n+        assert_eq!(None, text.chars().position(|c| seeker.inspect(c).is_some()));\n+    }\n+\n+    check_fail(\"TODO\\n\", 4);\n+    check_pass(\" TO FIX DOME\\n\");\n+    check_fail(\" \\n FIXME\\n\", 8);\n+    check_fail(\"FIXME(\\n\", 6);\n+    check_fail(\"FIXME(#\\n\", 7);\n+    check_fail(\"FIXME(#1\\n\", 8);\n+    check_fail(\"FIXME(#)1\\n\", 7);\n+    check_pass(\"FIXME(#1222)\\n\");\n+    check_fail(\"FIXME(#12\\n22)\\n\", 9);\n+    check_pass(\"FIXME(@maintainer, #1222, hello)\\n\");\n+    check_fail(\"TODO(#22) FIXME\\n\", 15);\n+}\n+\n+#[test]\n+fn find_issue() {\n+    fn is_bad_issue(text: &str, report_todo: ReportTactic, report_fixme: ReportTactic) -> bool {\n+        let mut seeker = BadIssueSeeker::new(report_todo, report_fixme);\n+        text.chars().any(|c| seeker.inspect(c).is_some())\n+    }\n+\n+    assert!(is_bad_issue(\"TODO(@maintainer, #1222, hello)\\n\",\n+                         ReportTactic::Always,\n+                         ReportTactic::Never));\n+\n+    assert!(! is_bad_issue(\"TODO: no number\\n\",\n+                           ReportTactic::Never,\n+                           ReportTactic::Always));\n+\n+    assert!(is_bad_issue(\"This is a FIXME(#1)\\n\",\n+                         ReportTactic::Never,\n+                         ReportTactic::Always));\n+\n+    assert!(! is_bad_issue(\"bad FIXME\\n\",\n+                           ReportTactic::Always,\n+                           ReportTactic::Never));\n+}\n+\n+#[test]\n+fn issue_type() {\n+    let mut seeker = BadIssueSeeker::new(ReportTactic::Always, ReportTactic::Never);\n+    let expected = Some(Issue {\n+        issue_type: IssueType::Todo,\n+        missing_number: false\n+    });\n+\n+    assert_eq!(expected,\n+               \"TODO(#100): more awesomeness\".chars()\n+                                       .map(|c| seeker.inspect(c))\n+                                       .find(Option::is_some)\n+                                       .unwrap());\n+\n+    let mut seeker = BadIssueSeeker::new(ReportTactic::Never, ReportTactic::Unnumbered);\n+    let expected = Some(Issue {\n+        issue_type: IssueType::Fixme,\n+        missing_number: true\n+    });\n+\n+    assert_eq!(expected,\n+               \"Test. FIXME: bad, bad, not good\".chars()\n+                                                .map(|c| seeker.inspect(c))\n+                                                .find(Option::is_some)\n+                                                .unwrap());\n+}"}, {"sha": "c8fdc2eab96f03a720d1f5f26d1078c19ab4950e", "filename": "src/lib.rs", "status": "modified", "additions": 84, "deletions": 11, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/c7ecf74af0670047481f4bc8697c18f692bc2bf4/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ecf74af0670047481f4bc8697c18f692bc2bf4/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=c7ecf74af0670047481f4bc8697c18f692bc2bf4", "patch": "@@ -33,16 +33,16 @@ use rustc::session::config as rustc_config;\n use rustc::session::config::Input;\n use rustc_driver::{driver, CompilerCalls, Compilation};\n \n-use rustc_serialize::{Decodable, Decoder};\n-\n use syntax::ast;\n use syntax::codemap::CodeMap;\n use syntax::diagnostics;\n use syntax::visit;\n \n use std::path::PathBuf;\n use std::collections::HashMap;\n+use std::fmt;\n \n+use issues::{BadIssueSeeker, Issue};\n use changes::ChangeSet;\n use visitor::FmtVisitor;\n \n@@ -58,6 +58,7 @@ mod lists;\n mod types;\n mod expr;\n mod imports;\n+mod issues;\n \n const MIN_STRING: usize = 10;\n // When we get scoped annotations, we should have rustfmt::skip.\n@@ -106,6 +107,58 @@ pub enum ReturnIndent {\n \n impl_enum_decodable!(ReturnIndent, WithArgs, WithWhereClause);\n \n+enum ErrorKind {\n+    // Line has more than config!(max_width) characters\n+    LineOverflow,\n+    // Line ends in whitespace\n+    TrailingWhitespace,\n+    // TO-DO or FIX-ME item without an issue number\n+    BadIssue(Issue),\n+}\n+\n+impl fmt::Display for ErrorKind {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        match *self {\n+            ErrorKind::LineOverflow => {\n+                write!(fmt, \"line exceeded maximum length\")\n+            },\n+            ErrorKind::TrailingWhitespace => {\n+                write!(fmt, \"left behind trailing whitespace\")\n+            },\n+            ErrorKind::BadIssue(issue) => {\n+                write!(fmt, \"found {}\", issue)\n+            },\n+        }\n+    }\n+}\n+\n+// Formatting errors that are identified *after* rustfmt has run\n+struct FormattingError {\n+    line: u32,\n+    kind: ErrorKind,\n+}\n+\n+struct FormatReport {\n+    // Maps stringified file paths to their associated formatting errors\n+    file_error_map: HashMap<String, Vec<FormattingError>>,\n+}\n+\n+impl fmt::Display for FormatReport {\n+    // Prints all the formatting errors.\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        for (file, errors) in self.file_error_map.iter() {\n+            for error in errors {\n+                try!(write!(fmt,\n+                            \"Rustfmt failed at {}:{}: {} (sorry)\\n\",\n+                            file,\n+                            error.line,\n+                            error.kind));\n+            }\n+        }\n+        Ok(())\n+    }\n+}\n+\n // Formatting which depends on the AST.\n fn fmt_ast<'a>(krate: &ast::Crate, codemap: &'a CodeMap) -> ChangeSet<'a> {\n     let mut visitor = FmtVisitor::from_codemap(codemap);\n@@ -119,11 +172,11 @@ fn fmt_ast<'a>(krate: &ast::Crate, codemap: &'a CodeMap) -> ChangeSet<'a> {\n }\n \n // Formatting done on a char by char or line by line basis.\n-// TODO warn on TODOs and FIXMEs without an issue number\n // TODO warn on bad license\n // TODO other stuff for parity with make tidy\n-fn fmt_lines(changes: &mut ChangeSet) {\n+fn fmt_lines(changes: &mut ChangeSet) -> FormatReport {\n     let mut truncate_todo = Vec::new();\n+    let mut report = FormatReport { file_error_map: HashMap::new() };\n \n     // Iterate over the chars in the change set.\n     for (f, text) in changes.text() {\n@@ -132,8 +185,21 @@ fn fmt_lines(changes: &mut ChangeSet) {\n         let mut line_len = 0;\n         let mut cur_line = 1;\n         let mut newline_count = 0;\n+        let mut errors = vec![];\n+        let mut issue_seeker = BadIssueSeeker::new(config!(report_todo),\n+                                                   config!(report_fixme));\n+\n         for (c, b) in text.chars() {\n             if c == '\\r' { continue; }\n+\n+            // Add warnings for bad todos/ fixmes\n+            if let Some(issue) = issue_seeker.inspect(c) {\n+                errors.push(FormattingError {\n+                    line: cur_line,\n+                    kind: ErrorKind::BadIssue(issue)\n+                });\n+            }\n+\n             if c == '\\n' {\n                 // Check for (and record) trailing whitespace.\n                 if let Some(lw) = last_wspace {\n@@ -142,9 +208,10 @@ fn fmt_lines(changes: &mut ChangeSet) {\n                 }\n                 // Check for any line width errors we couldn't correct.\n                 if line_len > config!(max_width) {\n-                    // TODO store the error rather than reporting immediately.\n-                    println!(\"Rustfmt couldn't fix (sorry). {}:{}: line longer than {} characters\",\n-                             f, cur_line, config!(max_width));\n+                    errors.push(FormattingError {\n+                        line: cur_line,\n+                        kind: ErrorKind::LineOverflow\n+                    });\n                 }\n                 line_len = 0;\n                 cur_line += 1;\n@@ -165,18 +232,24 @@ fn fmt_lines(changes: &mut ChangeSet) {\n \n         if newline_count > 1 {\n             debug!(\"track truncate: {} {} {}\", f, text.len, newline_count);\n-            truncate_todo.push((f.to_string(), text.len - newline_count + 1))\n+            truncate_todo.push((f.to_owned(), text.len - newline_count + 1))\n         }\n \n         for &(l, _, _) in trims.iter() {\n-            // TODO store the error rather than reporting immediately.\n-            println!(\"Rustfmt left trailing whitespace at {}:{} (sorry)\", f, l);\n+            errors.push(FormattingError {\n+                line: l,\n+                kind: ErrorKind::TrailingWhitespace\n+            });\n         }\n+\n+        report.file_error_map.insert(f.to_owned(), errors);\n     }\n \n     for (f, l) in truncate_todo {\n         changes.get_mut(&f).truncate(l);\n     }\n+\n+    report\n }\n \n struct RustFmtCalls {\n@@ -237,7 +310,7 @@ impl<'a> CompilerCalls<'a> for RustFmtCalls {\n             // For some reason, the codemap does not include terminating newlines\n             // so we must add one on for each file. This is sad.\n             changes.append_newlines();\n-            fmt_lines(&mut changes);\n+            println!(\"{}\", fmt_lines(&mut changes));\n \n             let result = changes.write_all_files(write_mode);\n "}, {"sha": "9f1006c39f0bc9711a4515317789fc0c00e6eb23", "filename": "src/lists.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c7ecf74af0670047481f4bc8697c18f692bc2bf4/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ecf74af0670047481f4bc8697c18f692bc2bf4/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=c7ecf74af0670047481f4bc8697c18f692bc2bf4", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use utils::make_indent;\n-use rustc_serialize::{Decodable, Decoder};\n \n #[derive(Eq, PartialEq, Debug, Copy, Clone)]\n pub enum ListTactic {"}, {"sha": "c32a929332635b6923e5f30c314d6dc2fd22ac95", "filename": "src/utils.rs", "status": "modified", "additions": 35, "deletions": 2, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c7ecf74af0670047481f4bc8697c18f692bc2bf4/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ecf74af0670047481f4bc8697c18f692bc2bf4/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=c7ecf74af0670047481f4bc8697c18f692bc2bf4", "patch": "@@ -48,12 +48,38 @@ pub fn format_visibility(vis: Visibility) -> &'static str {\n     }\n }\n \n+#[inline]\n+#[cfg(target_pointer_width=\"64\")]\n+// Based on the trick layed out at\n+// http://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2\n+pub fn round_up_to_power_of_two(mut x: usize) -> usize {\n+    x -= 1;\n+    x |= x >> 1;\n+    x |= x >> 2;\n+    x |= x >> 4;\n+    x |= x >> 8;\n+    x |= x >> 16;\n+    x |= x >> 32;\n+    x + 1\n+}\n+\n+#[cfg(target_pointer_width=\"32\")]\n+pub fn round_up_to_power_of_two(mut x: usize) -> usize {\n+    x -= 1;\n+    x |= x >> 1;\n+    x |= x >> 2;\n+    x |= x >> 4;\n+    x |= x >> 8;\n+    x |= x >> 16;\n+    x + 1\n+}\n+\n // Macro for deriving implementations of Decodable for enums\n #[macro_export]\n macro_rules! impl_enum_decodable {\n     ( $e:ident, $( $x:ident ),* ) => {\n-        impl Decodable for $e {\n-            fn decode<D: Decoder>(d: &mut D) -> Result<Self, D::Error> {\n+        impl ::rustc_serialize::Decodable for $e {\n+            fn decode<D: ::rustc_serialize::Decoder>(d: &mut D) -> Result<Self, D::Error> {\n                 let s = try!(d.read_str());\n                 match &*s {\n                     $(\n@@ -65,3 +91,10 @@ macro_rules! impl_enum_decodable {\n         }\n     };\n }\n+\n+#[test]\n+fn power_rounding() {\n+    assert_eq!(1, round_up_to_power_of_two(1));\n+    assert_eq!(64, round_up_to_power_of_two(33));\n+    assert_eq!(256, round_up_to_power_of_two(256));\n+}"}, {"sha": "688248386445ff3a458d3235b4907959915dc2d7", "filename": "tests/config/small_tabs.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7ecf74af0670047481f4bc8697c18f692bc2bf4/tests%2Fconfig%2Fsmall_tabs.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c7ecf74af0670047481f4bc8697c18f692bc2bf4/tests%2Fconfig%2Fsmall_tabs.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fconfig%2Fsmall_tabs.toml?ref=c7ecf74af0670047481f4bc8697c18f692bc2bf4", "patch": "@@ -9,3 +9,5 @@ fn_args_paren_newline = true\n struct_trailing_comma = true\n struct_lit_trailing_comma = \"Vertical\"\n enum_trailing_comma = true\n+report_todo = \"Always\"\n+report_fixme = \"Never\""}]}