{"sha": "318a38e2ea76554c7ff9b8117519a8920a556854", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxOGEzOGUyZWE3NjU1NGM3ZmY5YjgxMTc1MTlhODkyMGE1NTY4NTQ=", "commit": {"author": {"name": "Pietro Albini", "email": "pietro@pietroalbini.org", "date": "2018-11-18T22:24:51Z"}, "committer": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-11-19T14:06:24Z"}, "message": "Rollup merge of #55963 - stepancheg:mpsc-take-2, r=alexcrichton\n\nStress test for MPSC\n\n`concurrent_recv_timeout_and_upgrade` reproduces a problem 100%\ntimes on my MacBook with command:\n\n```\n./x.py test --stage 0 ./src/test/run-pass/mpsc_stress.rs\n```\n\nThus it is commented out.\n\nOther tests cases were useful for catching another test cases\nwhich may arise during the fix.\n\nThis diff is a part of my previous rewrite attempt: #42883\n\nCC #39364", "tree": {"sha": "967d1ce2b50df706cedcfccb2d47ef7578e0b02b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/967d1ce2b50df706cedcfccb2d47ef7578e0b02b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/318a38e2ea76554c7ff9b8117519a8920a556854", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIyBAABCAAdFiEEZ1R8CLMp8f2GxWoQ/vbIBR0OATwFAlvyw2EACgkQ/vbIBR0O\nATyccA/2JWlCCAc0DA5Qs/xsb/h3wmUiJuClvZC8VOE/nwxHLse8JKWk4TDTjlOQ\nL12TStNdic4qXEdAerErbCyyeXwhKWWjhGOSb+lqA+xGtXs8Gt2Nw9mZDyQuiKLg\nE6JsqoR0Vn+aGBbCgJk4zRjDqBg7dY8ne13S1L7jrGMn3gVtYZo4Sm+sAmMWMe7/\n1k1Dz6PcOIACMwLrPKD6fSul0y3ERvyd2QWh2W0dCzb6OqpjB+QyM+lYdkOocKGy\nDJHlpTDAMyLQaL2L65vCznzzi6c7/Dmn/T7AErmK1djE74K9FUmEtKjpAc7OLOdl\nhNUyWxfwCmyvZO7eP+RpRg5kUbC083iuAIb6A9XELNjPR4jJACbfge+DDUPt4y+7\nhzUldC9YnjDYz6i68D+ONhEGC5CFu9+r8rEFZxX/fZbNKU7Wr7aDz7WJn8JqxMPr\nKlUp5kCvGRoTcr3qZOuEnn0WLsieZHU8kAnIoCSCgG4J3OyDchWqH0OReCjq5vSf\nPzfqHAZmxKu+AlyiD0jEzei7wtiLQQuysMZmv5hg9Eu24kiluc2vu9IC/CfiFNhs\n0X6ZG2BKNhRL9UBFc0uP3up3WdBheXJSBFK/k6JKVz3aaWbI3P2DwjZvTkwAcrf8\nxYN9hYhC7TdccLRILvaIuKb5lD/vaSTEjmSo/JPURfXWeIVMnw==\n=XJCn\n-----END PGP SIGNATURE-----", "payload": "tree 967d1ce2b50df706cedcfccb2d47ef7578e0b02b\nparent f13d16621eafc54e806367ea24e191cce8af66d4\nparent a1f83e75afefad37b1eed868c0aefba99563969d\nauthor Pietro Albini <pietro@pietroalbini.org> 1542579891 +0100\ncommitter kennytm <kennytm@gmail.com> 1542636384 +0800\n\nRollup merge of #55963 - stepancheg:mpsc-take-2, r=alexcrichton\n\nStress test for MPSC\n\n`concurrent_recv_timeout_and_upgrade` reproduces a problem 100%\ntimes on my MacBook with command:\n\n```\n./x.py test --stage 0 ./src/test/run-pass/mpsc_stress.rs\n```\n\nThus it is commented out.\n\nOther tests cases were useful for catching another test cases\nwhich may arise during the fix.\n\nThis diff is a part of my previous rewrite attempt: #42883\n\nCC #39364\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/318a38e2ea76554c7ff9b8117519a8920a556854", "html_url": "https://github.com/rust-lang/rust/commit/318a38e2ea76554c7ff9b8117519a8920a556854", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/318a38e2ea76554c7ff9b8117519a8920a556854/comments", "author": {"login": "pietroalbini", "id": 2299951, "node_id": "MDQ6VXNlcjIyOTk5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2299951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietroalbini", "html_url": "https://github.com/pietroalbini", "followers_url": "https://api.github.com/users/pietroalbini/followers", "following_url": "https://api.github.com/users/pietroalbini/following{/other_user}", "gists_url": "https://api.github.com/users/pietroalbini/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietroalbini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietroalbini/subscriptions", "organizations_url": "https://api.github.com/users/pietroalbini/orgs", "repos_url": "https://api.github.com/users/pietroalbini/repos", "events_url": "https://api.github.com/users/pietroalbini/events{/privacy}", "received_events_url": "https://api.github.com/users/pietroalbini/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f13d16621eafc54e806367ea24e191cce8af66d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/f13d16621eafc54e806367ea24e191cce8af66d4", "html_url": "https://github.com/rust-lang/rust/commit/f13d16621eafc54e806367ea24e191cce8af66d4"}, {"sha": "a1f83e75afefad37b1eed868c0aefba99563969d", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1f83e75afefad37b1eed868c0aefba99563969d", "html_url": "https://github.com/rust-lang/rust/commit/a1f83e75afefad37b1eed868c0aefba99563969d"}], "stats": {"total": 172, "additions": 172, "deletions": 0}, "files": [{"sha": "aa369bb17fead69364876919953e98598f570846", "filename": "src/test/run-pass/mpsc_stress.rs", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/318a38e2ea76554c7ff9b8117519a8920a556854/src%2Ftest%2Frun-pass%2Fmpsc_stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318a38e2ea76554c7ff9b8117519a8920a556854/src%2Ftest%2Frun-pass%2Fmpsc_stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmpsc_stress.rs?ref=318a38e2ea76554c7ff9b8117519a8920a556854", "patch": "@@ -0,0 +1,172 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:--test\n+// ignore-emscripten\n+\n+use std::sync::mpsc::channel;\n+use std::sync::mpsc::TryRecvError;\n+use std::sync::mpsc::RecvError;\n+use std::sync::mpsc::RecvTimeoutError;\n+use std::sync::Arc;\n+use std::sync::atomic::AtomicUsize;\n+use std::sync::atomic::Ordering;\n+\n+use std::thread;\n+use std::time::Duration;\n+\n+\n+/// Simple thread synchronization utility\n+struct Barrier {\n+    // Not using mutex/condvar for precision\n+    shared: Arc<AtomicUsize>,\n+    count: usize,\n+}\n+\n+impl Barrier {\n+    fn new(count: usize) -> Vec<Barrier> {\n+        let shared = Arc::new(AtomicUsize::new(0));\n+        (0..count).map(|_| Barrier { shared: shared.clone(), count: count }).collect()\n+    }\n+\n+    fn new2() -> (Barrier, Barrier) {\n+        let mut v = Barrier::new(2);\n+        (v.pop().unwrap(), v.pop().unwrap())\n+    }\n+\n+    /// Returns when `count` threads enter `wait`\n+    fn wait(self) {\n+        self.shared.fetch_add(1, Ordering::SeqCst);\n+        while self.shared.load(Ordering::SeqCst) != self.count {\n+        }\n+    }\n+}\n+\n+\n+fn shared_close_sender_does_not_lose_messages_iter() {\n+    let (tb, rb) = Barrier::new2();\n+\n+    let (tx, rx) = channel();\n+    let _ = tx.clone(); // convert to shared\n+\n+    thread::spawn(move || {\n+        tb.wait();\n+        thread::sleep(Duration::from_micros(1));\n+        tx.send(17).expect(\"send\");\n+        drop(tx);\n+    });\n+\n+    let i = rx.into_iter();\n+    rb.wait();\n+    // Make sure it doesn't return disconnected before returning an element\n+    assert_eq!(vec![17], i.collect::<Vec<_>>());\n+}\n+\n+#[test]\n+fn shared_close_sender_does_not_lose_messages() {\n+    for _ in 0..10000 {\n+        shared_close_sender_does_not_lose_messages_iter();\n+    }\n+}\n+\n+\n+// https://github.com/rust-lang/rust/issues/39364\n+fn concurrent_recv_timeout_and_upgrade_iter() {\n+    // 1 us\n+    let sleep = Duration::new(0, 1_000);\n+\n+    let (a, b) = Barrier::new2();\n+    let (tx, rx) = channel();\n+    let th = thread::spawn(move || {\n+        a.wait();\n+        loop {\n+            match rx.recv_timeout(sleep) {\n+                Ok(_) => {\n+                    break;\n+                },\n+                Err(_) => {},\n+            }\n+        }\n+    });\n+    b.wait();\n+    thread::sleep(sleep);\n+    tx.clone().send(()).expect(\"send\");\n+    th.join().unwrap();\n+}\n+\n+#[test]\n+fn concurrent_recv_timeout_and_upgrade() {\n+    // FIXME: fix and enable\n+    if true { return }\n+\n+    // at the moment of writing this test fails like this:\n+    // thread '<unnamed>' panicked at 'assertion failed: `(left == right)`\n+    //  left: `4561387584`,\n+    // right: `0`', libstd/sync/mpsc/shared.rs:253:13\n+\n+    for _ in 0..10000 {\n+        concurrent_recv_timeout_and_upgrade_iter();\n+    }\n+}\n+\n+\n+fn concurrent_writes_iter() {\n+    const THREADS: usize = 4;\n+    const PER_THR: usize = 100;\n+\n+    let mut bs = Barrier::new(THREADS + 1);\n+    let (tx, rx) = channel();\n+\n+    let mut threads = Vec::new();\n+    for j in 0..THREADS {\n+        let tx = tx.clone();\n+        let b = bs.pop().unwrap();\n+        threads.push(thread::spawn(move || {\n+            b.wait();\n+            for i in 0..PER_THR {\n+                tx.send(j * 1000 + i).expect(\"send\");\n+            }\n+        }));\n+    }\n+\n+    let b = bs.pop().unwrap();\n+    b.wait();\n+\n+    let mut v: Vec<_> = rx.iter().take(THREADS * PER_THR).collect();\n+    v.sort();\n+\n+    for j in 0..THREADS {\n+        for i in 0..PER_THR {\n+            assert_eq!(j * 1000 + i, v[j * PER_THR + i]);\n+        }\n+    }\n+\n+    for t in threads {\n+        t.join().unwrap();\n+    }\n+\n+    let one_us = Duration::new(0, 1000);\n+\n+    assert_eq!(TryRecvError::Empty, rx.try_recv().unwrap_err());\n+    assert_eq!(RecvTimeoutError::Timeout, rx.recv_timeout(one_us).unwrap_err());\n+\n+    drop(tx);\n+\n+    assert_eq!(RecvError, rx.recv().unwrap_err());\n+    assert_eq!(RecvTimeoutError::Disconnected, rx.recv_timeout(one_us).unwrap_err());\n+    assert_eq!(TryRecvError::Disconnected, rx.try_recv().unwrap_err());\n+}\n+\n+#[test]\n+fn concurrent_writes() {\n+    for _ in 0..100 {\n+        concurrent_writes_iter();\n+    }\n+}"}]}