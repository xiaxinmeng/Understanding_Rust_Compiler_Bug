{"sha": "a9bbe31519b250fb331347351b47345fcbfe7932", "node_id": "C_kwDOAAsO6NoAKGE5YmJlMzE1MTliMjUwZmIzMzEzNDczNTFiNDczNDVmY2JmZTc5MzI", "commit": {"author": {"name": "Rejyr", "email": "jerrylwang123@gmail.com", "date": "2022-09-05T17:37:57Z"}, "committer": {"name": "Rejyr", "email": "jerrylwang123@gmail.com", "date": "2023-01-09T22:07:25Z"}, "message": "migrate: `nonstandard_style.rs`", "tree": {"sha": "36effba3b6e13ef6098777302efe53a92ab18781", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36effba3b6e13ef6098777302efe53a92ab18781"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9bbe31519b250fb331347351b47345fcbfe7932", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9bbe31519b250fb331347351b47345fcbfe7932", "html_url": "https://github.com/rust-lang/rust/commit/a9bbe31519b250fb331347351b47345fcbfe7932", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9bbe31519b250fb331347351b47345fcbfe7932/comments", "author": {"login": "Rejyr", "id": 88239847, "node_id": "MDQ6VXNlcjg4MjM5ODQ3", "avatar_url": "https://avatars.githubusercontent.com/u/88239847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Rejyr", "html_url": "https://github.com/Rejyr", "followers_url": "https://api.github.com/users/Rejyr/followers", "following_url": "https://api.github.com/users/Rejyr/following{/other_user}", "gists_url": "https://api.github.com/users/Rejyr/gists{/gist_id}", "starred_url": "https://api.github.com/users/Rejyr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Rejyr/subscriptions", "organizations_url": "https://api.github.com/users/Rejyr/orgs", "repos_url": "https://api.github.com/users/Rejyr/repos", "events_url": "https://api.github.com/users/Rejyr/events{/privacy}", "received_events_url": "https://api.github.com/users/Rejyr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Rejyr", "id": 88239847, "node_id": "MDQ6VXNlcjg4MjM5ODQ3", "avatar_url": "https://avatars.githubusercontent.com/u/88239847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Rejyr", "html_url": "https://github.com/Rejyr", "followers_url": "https://api.github.com/users/Rejyr/followers", "following_url": "https://api.github.com/users/Rejyr/following{/other_user}", "gists_url": "https://api.github.com/users/Rejyr/gists{/gist_id}", "starred_url": "https://api.github.com/users/Rejyr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Rejyr/subscriptions", "organizations_url": "https://api.github.com/users/Rejyr/orgs", "repos_url": "https://api.github.com/users/Rejyr/repos", "events_url": "https://api.github.com/users/Rejyr/events{/privacy}", "received_events_url": "https://api.github.com/users/Rejyr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "56fc66d196378a1af26631cbedabdcd07883bf3f", "url": "https://api.github.com/repos/rust-lang/rust/commits/56fc66d196378a1af26631cbedabdcd07883bf3f", "html_url": "https://github.com/rust-lang/rust/commit/56fc66d196378a1af26631cbedabdcd07883bf3f"}], "stats": {"total": 237, "additions": 156, "deletions": 81}, "files": [{"sha": "7e92b2d6b3d514ea501bb0946be06d58508c1a85", "filename": "compiler/rustc_lint/src/lints.rs", "status": "modified", "additions": 105, "deletions": 1, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/a9bbe31519b250fb331347351b47345fcbfe7932/compiler%2Frustc_lint%2Fsrc%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9bbe31519b250fb331347351b47345fcbfe7932/compiler%2Frustc_lint%2Fsrc%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flints.rs?ref=a9bbe31519b250fb331347351b47345fcbfe7932", "patch": "@@ -2,10 +2,114 @@ use rustc_errors::{fluent, AddSubdiagnostic, Applicability, DecorateLint, Emissi\n use rustc_hir::def_id::DefId;\n use rustc_macros::{LintDiagnostic, SessionSubdiagnostic};\n use rustc_middle::ty::{Predicate, Ty, TyCtxt};\n-use rustc_span::{Span, Symbol};\n+use rustc_span::{symbol::Ident, Span, Symbol};\n \n use crate::LateContext;\n \n+#[derive(LintDiagnostic)]\n+#[diag(lint_non_camel_case_type)]\n+pub struct NonCamelCaseType<'a> {\n+    pub sort: &'a str,\n+    pub name: &'a str,\n+    #[subdiagnostic]\n+    pub sub: NonCamelCaseTypeSub,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+pub enum NonCamelCaseTypeSub {\n+    #[label(label)]\n+    Label {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[suggestion(suggestion, code = \"{replace}\", applicability = \"maybe-incorrect\")]\n+    Suggestion {\n+        #[primary_span]\n+        span: Span,\n+        replace: String,\n+    },\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_non_snake_case)]\n+pub struct NonSnakeCaseDiag<'a> {\n+    pub sort: &'a str,\n+    pub name: &'a str,\n+    pub sc: String,\n+    #[subdiagnostic]\n+    pub sub: NonSnakeCaseDiagSub,\n+}\n+\n+pub enum NonSnakeCaseDiagSub {\n+    Label { span: Span },\n+    Help,\n+    RenameOrConvertSuggestion { span: Span, suggestion: Ident },\n+    ConvertSuggestion { span: Span, suggestion: String },\n+    SuggestionAndNote { span: Span },\n+}\n+\n+impl AddSubdiagnostic for NonSnakeCaseDiagSub {\n+    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n+        match self {\n+            NonSnakeCaseDiagSub::Label { span } => {\n+                diag.span_label(span, fluent::label);\n+            }\n+            NonSnakeCaseDiagSub::Help => {\n+                diag.help(fluent::help);\n+            }\n+            NonSnakeCaseDiagSub::ConvertSuggestion { span, suggestion } => {\n+                diag.span_suggestion(\n+                    span,\n+                    fluent::convert_suggestion,\n+                    suggestion,\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+            NonSnakeCaseDiagSub::RenameOrConvertSuggestion { span, suggestion } => {\n+                diag.span_suggestion(\n+                    span,\n+                    fluent::rename_or_convert_suggestion,\n+                    suggestion,\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+            NonSnakeCaseDiagSub::SuggestionAndNote { span } => {\n+                diag.note(fluent::cannot_convert_note);\n+                diag.span_suggestion(\n+                    span,\n+                    fluent::rename_suggestion,\n+                    \"\",\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+        };\n+    }\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_non_upper_case_global)]\n+pub struct NonUpperCaseGlobal<'a> {\n+    pub sort: &'a str,\n+    pub name: &'a str,\n+    #[subdiagnostic]\n+    pub sub: NonUpperCaseGlobalSub,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+pub enum NonUpperCaseGlobalSub {\n+    #[label(label)]\n+    Label {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[suggestion(suggestion, code = \"{replace}\", applicability = \"maybe-incorrect\")]\n+    Suggestion {\n+        #[primary_span]\n+        span: Span,\n+        replace: String,\n+    },\n+}\n+\n #[derive(LintDiagnostic)]\n #[diag(lint_noop_method_call)]\n #[note]"}, {"sha": "34e3751c061f113b571f5ad19b0c38a4b0e63b8b", "filename": "compiler/rustc_lint/src/nonstandard_style.rs", "status": "modified", "additions": 51, "deletions": 80, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/a9bbe31519b250fb331347351b47345fcbfe7932/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9bbe31519b250fb331347351b47345fcbfe7932/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs?ref=a9bbe31519b250fb331347351b47345fcbfe7932", "patch": "@@ -1,7 +1,12 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n+use crate::lints::{\n+    NonCamelCaseType, NonCamelCaseTypeSub, NonSnakeCaseDiag, NonSnakeCaseDiagSub,\n+    NonUpperCaseGlobal, NonUpperCaseGlobalSub,\n+};\n use crate::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n use rustc_ast as ast;\n use rustc_attr as attr;\n-use rustc_errors::{fluent, Applicability};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::intravisit::FnKind;\n@@ -136,30 +141,17 @@ impl NonCamelCaseTypes {\n         let name = ident.name.as_str();\n \n         if !is_camel_case(name) {\n-            cx.struct_span_lint(\n+            let cc = to_camel_case(name);\n+            let sub = if *name != cc {\n+                NonCamelCaseTypeSub::Suggestion { span: ident.span, replace: cc }\n+            } else {\n+                NonCamelCaseTypeSub::Label { span: ident.span }\n+            };\n+            cx.emit_spanned_lint(\n                 NON_CAMEL_CASE_TYPES,\n                 ident.span,\n-                fluent::lint_non_camel_case_type,\n-                |lint| {\n-                    let cc = to_camel_case(name);\n-                    // We cannot provide meaningful suggestions\n-                    // if the characters are in the category of \"Lowercase Letter\".\n-                    if *name != cc {\n-                        lint.span_suggestion(\n-                            ident.span,\n-                            fluent::suggestion,\n-                            to_camel_case(name),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    } else {\n-                        lint.span_label(ident.span, fluent::label);\n-                    }\n-\n-                    lint.set_arg(\"sort\", sort);\n-                    lint.set_arg(\"name\", name);\n-                    lint\n-                },\n-            )\n+                NonCamelCaseType { sort, name, sub },\n+            );\n         }\n     }\n }\n@@ -294,47 +286,37 @@ impl NonSnakeCase {\n         let name = ident.name.as_str();\n \n         if !is_snake_case(name) {\n-            cx.struct_span_lint(NON_SNAKE_CASE, ident.span, fluent::lint_non_snake_case, |lint| {\n-                let sc = NonSnakeCase::to_snake_case(name);\n-                // We cannot provide meaningful suggestions\n-                // if the characters are in the category of \"Uppercase Letter\".\n-                if name != sc {\n-                    // We have a valid span in almost all cases, but we don't have one when linting a crate\n-                    // name provided via the command line.\n-                    if !ident.span.is_dummy() {\n-                        let sc_ident = Ident::from_str_and_span(&sc, ident.span);\n-                        let (message, suggestion) = if sc_ident.is_reserved() {\n-                            // We shouldn't suggest a reserved identifier to fix non-snake-case identifiers.\n-                            // Instead, recommend renaming the identifier entirely or, if permitted,\n-                            // escaping it to create a raw identifier.\n-                            if sc_ident.name.can_be_raw() {\n-                                (fluent::rename_or_convert_suggestion, sc_ident.to_string())\n-                            } else {\n-                                lint.note(fluent::cannot_convert_note);\n-                                (fluent::rename_suggestion, String::new())\n+            let span = ident.span;\n+            let sc = NonSnakeCase::to_snake_case(name);\n+            // We cannot provide meaningful suggestions\n+            // if the characters are in the category of \"Uppercase Letter\".\n+            let sub = if name != sc {\n+                // We have a valid span in almost all cases, but we don't have one when linting a crate\n+                // name provided via the command line.\n+                if !span.is_dummy() {\n+                    let sc_ident = Ident::from_str_and_span(&sc, span);\n+                    if sc_ident.is_reserved() {\n+                        // We shouldn't suggest a reserved identifier to fix non-snake-case identifiers.\n+                        // Instead, recommend renaming the identifier entirely or, if permitted,\n+                        // escaping it to create a raw identifier.\n+                        if sc_ident.name.can_be_raw() {\n+                            NonSnakeCaseDiagSub::RenameOrConvertSuggestion {\n+                                span,\n+                                suggestion: sc_ident,\n                             }\n                         } else {\n-                            (fluent::convert_suggestion, sc.clone())\n-                        };\n-\n-                        lint.span_suggestion(\n-                            ident.span,\n-                            message,\n-                            suggestion,\n-                            Applicability::MaybeIncorrect,\n-                        );\n+                            NonSnakeCaseDiagSub::SuggestionAndNote { span }\n+                        }\n                     } else {\n-                        lint.help(fluent::help);\n+                        NonSnakeCaseDiagSub::ConvertSuggestion { span, suggestion: sc.clone() }\n                     }\n                 } else {\n-                    lint.span_label(ident.span, fluent::label);\n+                    NonSnakeCaseDiagSub::Help\n                 }\n-\n-                lint.set_arg(\"sort\", sort);\n-                lint.set_arg(\"name\", name);\n-                lint.set_arg(\"sc\", sc);\n-                lint\n-            });\n+            } else {\n+                NonSnakeCaseDiagSub::Label { span }\n+            };\n+            cx.emit_spanned_lint(NON_SNAKE_CASE, span, NonSnakeCaseDiag { sort, name, sc, sub });\n         }\n     }\n }\n@@ -490,30 +472,19 @@ impl NonUpperCaseGlobals {\n     fn check_upper_case(cx: &LateContext<'_>, sort: &str, ident: &Ident) {\n         let name = ident.name.as_str();\n         if name.chars().any(|c| c.is_lowercase()) {\n-            cx.struct_span_lint(\n+            let uc = NonSnakeCase::to_snake_case(&name).to_uppercase();\n+            // We cannot provide meaningful suggestions\n+            // if the characters are in the category of \"Lowercase Letter\".\n+            let sub = if *name != uc {\n+                NonUpperCaseGlobalSub::Suggestion { span: ident.span, replace: uc }\n+            } else {\n+                NonUpperCaseGlobalSub::Label { span: ident.span }\n+            };\n+            cx.emit_spanned_lint(\n                 NON_UPPER_CASE_GLOBALS,\n                 ident.span,\n-                fluent::lint_non_upper_case_global,\n-                |lint| {\n-                    let uc = NonSnakeCase::to_snake_case(&name).to_uppercase();\n-                    // We cannot provide meaningful suggestions\n-                    // if the characters are in the category of \"Lowercase Letter\".\n-                    if *name != uc {\n-                        lint.span_suggestion(\n-                            ident.span,\n-                            fluent::suggestion,\n-                            uc,\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    } else {\n-                        lint.span_label(ident.span, fluent::label);\n-                    }\n-\n-                    lint.set_arg(\"sort\", sort);\n-                    lint.set_arg(\"name\", name);\n-                    lint\n-                },\n-            )\n+                NonUpperCaseGlobal { sort, name, sub },\n+            );\n         }\n     }\n }"}]}