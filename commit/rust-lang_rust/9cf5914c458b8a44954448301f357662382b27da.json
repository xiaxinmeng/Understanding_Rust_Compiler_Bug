{"sha": "9cf5914c458b8a44954448301f357662382b27da", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljZjU5MTRjNDU4YjhhNDQ5NTQ0NDgzMDFmMzU3NjYyMzgyYjI3ZGE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-08-10T09:49:55Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-08-10T09:49:55Z"}, "message": "internal: unify subcommand handling between ra and xtask", "tree": {"sha": "bf3985535b636fe62098cb4d14519997925c7bde", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf3985535b636fe62098cb4d14519997925c7bde"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9cf5914c458b8a44954448301f357662382b27da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9cf5914c458b8a44954448301f357662382b27da", "html_url": "https://github.com/rust-lang/rust/commit/9cf5914c458b8a44954448301f357662382b27da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9cf5914c458b8a44954448301f357662382b27da/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8a67b67bf87eb3119303e1e49f8c19b69d11461", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8a67b67bf87eb3119303e1e49f8c19b69d11461", "html_url": "https://github.com/rust-lang/rust/commit/e8a67b67bf87eb3119303e1e49f8c19b69d11461"}], "stats": {"total": 400, "additions": 197, "deletions": 203}, "files": [{"sha": "ace07cc50d97a690507eee54b7a9d25133ba8d38", "filename": "crates/rust-analyzer/src/bin/main.rs", "status": "modified", "additions": 9, "deletions": 30, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/9cf5914c458b8a44954448301f357662382b27da/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf5914c458b8a44954448301f357662382b27da/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs?ref=9cf5914c458b8a44954448301f357662382b27da", "patch": "@@ -8,13 +8,7 @@ use std::{convert::TryFrom, env, fs, path::Path, process};\n \n use lsp_server::Connection;\n use project_model::ProjectManifest;\n-use rust_analyzer::{\n-    cli::{self, flags, AnalysisStatsCmd},\n-    config::Config,\n-    from_json,\n-    lsp_ext::supports_utf8,\n-    Result,\n-};\n+use rust_analyzer::{cli::flags, config::Config, from_json, lsp_ext::supports_utf8, Result};\n use vfs::AbsPathBuf;\n \n #[cfg(all(feature = \"mimalloc\"))]\n@@ -85,29 +79,14 @@ fn try_main() -> Result<()> {\n             }\n             run_server()?\n         }\n-        flags::RustAnalyzerCmd::ProcMacro(_) => proc_macro_srv::cli::run()?,\n-        flags::RustAnalyzerCmd::Parse(cmd) => cli::parse(cmd.no_dump)?,\n-        flags::RustAnalyzerCmd::Symbols(_) => cli::symbols()?,\n-        flags::RustAnalyzerCmd::Highlight(cmd) => cli::highlight(cmd.rainbow)?,\n-        flags::RustAnalyzerCmd::AnalysisStats(cmd) => AnalysisStatsCmd {\n-            randomize: cmd.randomize,\n-            parallel: cmd.parallel,\n-            memory_usage: cmd.memory_usage,\n-            only: cmd.only,\n-            with_deps: cmd.with_deps,\n-            no_sysroot: cmd.no_sysroot,\n-            path: cmd.path,\n-            enable_build_scripts: !cmd.disable_build_scripts,\n-            enable_proc_macros: !cmd.disable_proc_macros,\n-            skip_inference: cmd.skip_inference,\n-        }\n-        .run(verbosity)?,\n-\n-        flags::RustAnalyzerCmd::Diagnostics(cmd) => {\n-            cli::diagnostics(&cmd.path, !cmd.disable_build_scripts, !cmd.disable_proc_macros)?\n-        }\n-        flags::RustAnalyzerCmd::Ssr(cmd) => cli::apply_ssr_rules(cmd.rule)?,\n-        flags::RustAnalyzerCmd::Search(cmd) => cli::search_for_patterns(cmd.pattern, cmd.debug)?,\n+        flags::RustAnalyzerCmd::ProcMacro(flags::ProcMacro) => proc_macro_srv::cli::run()?,\n+        flags::RustAnalyzerCmd::Parse(cmd) => cmd.run()?,\n+        flags::RustAnalyzerCmd::Symbols(cmd) => cmd.run()?,\n+        flags::RustAnalyzerCmd::Highlight(cmd) => cmd.run()?,\n+        flags::RustAnalyzerCmd::AnalysisStats(cmd) => cmd.run(verbosity)?,\n+        flags::RustAnalyzerCmd::Diagnostics(cmd) => cmd.run()?,\n+        flags::RustAnalyzerCmd::Ssr(cmd) => cmd.run()?,\n+        flags::RustAnalyzerCmd::Search(cmd) => cmd.run()?,\n     }\n     Ok(())\n }"}, {"sha": "efd8a2aa9fc00917c8dbb3774fb94933bef0021c", "filename": "crates/rust-analyzer/src/cli.rs", "status": "modified", "additions": 6, "deletions": 41, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/9cf5914c458b8a44954448301f357662382b27da/crates%2Frust-analyzer%2Fsrc%2Fcli.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf5914c458b8a44954448301f357662382b27da/crates%2Frust-analyzer%2Fsrc%2Fcli.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli.rs?ref=9cf5914c458b8a44954448301f357662382b27da", "patch": "@@ -2,24 +2,21 @@\n \n pub mod flags;\n pub mod load_cargo;\n+mod parse;\n+mod symbols;\n+mod highlight;\n mod analysis_stats;\n mod diagnostics;\n-mod progress_report;\n mod ssr;\n \n+mod progress_report;\n+\n use std::io::Read;\n \n use anyhow::Result;\n-use ide::{Analysis, AnalysisHost};\n-use syntax::{AstNode, SourceFile};\n+use ide::AnalysisHost;\n use vfs::Vfs;\n \n-pub use self::{\n-    analysis_stats::AnalysisStatsCmd,\n-    diagnostics::diagnostics,\n-    ssr::{apply_ssr_rules, search_for_patterns},\n-};\n-\n #[derive(Clone, Copy)]\n pub enum Verbosity {\n     Spammy,\n@@ -37,38 +34,6 @@ impl Verbosity {\n     }\n }\n \n-pub fn parse(no_dump: bool) -> Result<()> {\n-    let _p = profile::span(\"parsing\");\n-    let file = file()?;\n-    if !no_dump {\n-        println!(\"{:#?}\", file.syntax());\n-    }\n-    std::mem::forget(file);\n-    Ok(())\n-}\n-\n-pub fn symbols() -> Result<()> {\n-    let text = read_stdin()?;\n-    let (analysis, file_id) = Analysis::from_single_file(text);\n-    let structure = analysis.file_structure(file_id).unwrap();\n-    for s in structure {\n-        println!(\"{:?}\", s);\n-    }\n-    Ok(())\n-}\n-\n-pub fn highlight(rainbow: bool) -> Result<()> {\n-    let (analysis, file_id) = Analysis::from_single_file(read_stdin()?);\n-    let html = analysis.highlight_as_html(file_id, rainbow).unwrap();\n-    println!(\"{}\", html);\n-    Ok(())\n-}\n-\n-fn file() -> Result<SourceFile> {\n-    let text = read_stdin()?;\n-    Ok(SourceFile::parse(&text).tree())\n-}\n-\n fn read_stdin() -> Result<String> {\n     let mut buff = String::new();\n     std::io::stdin().read_to_string(&mut buff)?;"}, {"sha": "454510177e84295f4f884f81ba928214ed6c92dd", "filename": "crates/rust-analyzer/src/cli/analysis_stats.rs", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9cf5914c458b8a44954448301f357662382b27da/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf5914c458b8a44954448301f357662382b27da/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs?ref=9cf5914c458b8a44954448301f357662382b27da", "patch": "@@ -3,7 +3,6 @@\n \n use std::{\n     env,\n-    path::PathBuf,\n     time::{SystemTime, UNIX_EPOCH},\n };\n \n@@ -28,6 +27,7 @@ use syntax::AstNode;\n use vfs::{Vfs, VfsPath};\n \n use crate::cli::{\n+    flags,\n     load_cargo::{load_workspace_at, LoadCargoConfig},\n     print_memory_usage,\n     progress_report::ProgressReport,\n@@ -43,20 +43,7 @@ impl<DB: ParallelDatabase> Clone for Snap<salsa::Snapshot<DB>> {\n     }\n }\n \n-pub struct AnalysisStatsCmd {\n-    pub randomize: bool,\n-    pub parallel: bool,\n-    pub memory_usage: bool,\n-    pub only: Option<String>,\n-    pub with_deps: bool,\n-    pub no_sysroot: bool,\n-    pub path: PathBuf,\n-    pub enable_build_scripts: bool,\n-    pub enable_proc_macros: bool,\n-    pub skip_inference: bool,\n-}\n-\n-impl AnalysisStatsCmd {\n+impl flags::AnalysisStats {\n     pub fn run(self, verbosity: Verbosity) -> Result<()> {\n         let mut rng = {\n             let seed = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_millis() as u64;\n@@ -67,8 +54,8 @@ impl AnalysisStatsCmd {\n         let mut cargo_config = CargoConfig::default();\n         cargo_config.no_sysroot = self.no_sysroot;\n         let load_cargo_config = LoadCargoConfig {\n-            load_out_dirs_from_check: self.enable_build_scripts,\n-            with_proc_macro: self.enable_proc_macros,\n+            load_out_dirs_from_check: !self.disable_build_scripts,\n+            with_proc_macro: !self.disable_proc_macros,\n             prefill_caches: false,\n         };\n         let (host, vfs, _proc_macro) ="}, {"sha": "52511ceb5805dcb91cea5d1017ce1f57d9f9bda6", "filename": "crates/rust-analyzer/src/cli/diagnostics.rs", "status": "modified", "additions": 61, "deletions": 59, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/9cf5914c458b8a44954448301f357662382b27da/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf5914c458b8a44954448301f357662382b27da/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fdiagnostics.rs?ref=9cf5914c458b8a44954448301f357662382b27da", "patch": "@@ -1,84 +1,86 @@\n-//! Analyze all modules in a project for diagnostics. Exits with a non-zero status\n-//! code if any errors are found.\n+//! Analyze all modules in a project for diagnostics. Exits with a non-zero\n+//! status code if any errors are found.\n \n-use std::path::Path;\n-\n-use anyhow::anyhow;\n use rustc_hash::FxHashSet;\n \n use hir::{db::HirDatabase, Crate, Module};\n use ide::{AssistResolveStrategy, DiagnosticsConfig, Severity};\n use ide_db::base_db::SourceDatabaseExt;\n \n use crate::cli::{\n+    flags,\n     load_cargo::{load_workspace_at, LoadCargoConfig},\n-    Result,\n };\n \n-fn all_modules(db: &dyn HirDatabase) -> Vec<Module> {\n-    let mut worklist: Vec<_> =\n-        Crate::all(db).into_iter().map(|krate| krate.root_module(db)).collect();\n-    let mut modules = Vec::new();\n+impl flags::Diagnostics {\n+    pub fn run(self) -> anyhow::Result<()> {\n+        let cargo_config = Default::default();\n+        let load_cargo_config = LoadCargoConfig {\n+            load_out_dirs_from_check: !self.disable_build_scripts,\n+            with_proc_macro: !self.disable_proc_macros,\n+            prefill_caches: false,\n+        };\n+        let (host, _vfs, _proc_macro) =\n+            load_workspace_at(&self.path, &cargo_config, &load_cargo_config, &|_| {})?;\n+        let db = host.raw_database();\n+        let analysis = host.analysis();\n \n-    while let Some(module) = worklist.pop() {\n-        modules.push(module);\n-        worklist.extend(module.children(db));\n-    }\n-\n-    modules\n-}\n+        let mut found_error = false;\n+        let mut visited_files = FxHashSet::default();\n \n-pub fn diagnostics(\n-    path: &Path,\n-    load_out_dirs_from_check: bool,\n-    with_proc_macro: bool,\n-) -> Result<()> {\n-    let cargo_config = Default::default();\n-    let load_cargo_config =\n-        LoadCargoConfig { load_out_dirs_from_check, with_proc_macro, prefill_caches: false };\n-    let (host, _vfs, _proc_macro) =\n-        load_workspace_at(path, &cargo_config, &load_cargo_config, &|_| {})?;\n-    let db = host.raw_database();\n-    let analysis = host.analysis();\n+        let work = all_modules(db).into_iter().filter(|module| {\n+            let file_id = module.definition_source(db).file_id.original_file(db);\n+            let source_root = db.file_source_root(file_id);\n+            let source_root = db.source_root(source_root);\n+            !source_root.is_library\n+        });\n \n-    let mut found_error = false;\n-    let mut visited_files = FxHashSet::default();\n+        for module in work {\n+            let file_id = module.definition_source(db).file_id.original_file(db);\n+            if !visited_files.contains(&file_id) {\n+                let crate_name =\n+                    module.krate().display_name(db).as_deref().unwrap_or(\"unknown\").to_string();\n+                println!(\"processing crate: {}, module: {}\", crate_name, _vfs.file_path(file_id));\n+                for diagnostic in analysis\n+                    .diagnostics(\n+                        &DiagnosticsConfig::default(),\n+                        AssistResolveStrategy::None,\n+                        file_id,\n+                    )\n+                    .unwrap()\n+                {\n+                    if matches!(diagnostic.severity, Severity::Error) {\n+                        found_error = true;\n+                    }\n \n-    let work = all_modules(db).into_iter().filter(|module| {\n-        let file_id = module.definition_source(db).file_id.original_file(db);\n-        let source_root = db.file_source_root(file_id);\n-        let source_root = db.source_root(source_root);\n-        !source_root.is_library\n-    });\n-\n-    for module in work {\n-        let file_id = module.definition_source(db).file_id.original_file(db);\n-        if !visited_files.contains(&file_id) {\n-            let crate_name =\n-                module.krate().display_name(db).as_deref().unwrap_or(\"unknown\").to_string();\n-            println!(\"processing crate: {}, module: {}\", crate_name, _vfs.file_path(file_id));\n-            for diagnostic in analysis\n-                .diagnostics(&DiagnosticsConfig::default(), AssistResolveStrategy::None, file_id)\n-                .unwrap()\n-            {\n-                if matches!(diagnostic.severity, Severity::Error) {\n-                    found_error = true;\n+                    println!(\"{:?}\", diagnostic);\n                 }\n \n-                println!(\"{:?}\", diagnostic);\n+                visited_files.insert(file_id);\n             }\n+        }\n+\n+        println!();\n+        println!(\"diagnostic scan complete\");\n \n-            visited_files.insert(file_id);\n+        if found_error {\n+            println!();\n+            anyhow::bail!(\"diagnostic error detected\")\n         }\n+\n+        Ok(())\n     }\n+}\n \n-    println!();\n-    println!(\"diagnostic scan complete\");\n+fn all_modules(db: &dyn HirDatabase) -> Vec<Module> {\n+    let mut worklist: Vec<_> =\n+        Crate::all(db).into_iter().map(|krate| krate.root_module(db)).collect();\n+    let mut modules = Vec::new();\n \n-    if found_error {\n-        println!();\n-        Err(anyhow!(\"diagnostic error detected\"))\n-    } else {\n-        Ok(())\n+    while let Some(module) = worklist.pop() {\n+        modules.push(module);\n+        worklist.extend(module.children(db));\n     }\n+\n+    modules\n }"}, {"sha": "4f9b362f1bec47b430f4781a83a7b545ef0df86d", "filename": "crates/rust-analyzer/src/cli/highlight.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9cf5914c458b8a44954448301f357662382b27da/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf5914c458b8a44954448301f357662382b27da/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fhighlight.rs?ref=9cf5914c458b8a44954448301f357662382b27da", "patch": "@@ -0,0 +1,14 @@\n+//! Read Rust code on stdin, print HTML highlighted version to stdout.\n+\n+use ide::Analysis;\n+\n+use crate::cli::{flags, read_stdin};\n+\n+impl flags::Highlight {\n+    pub fn run(self) -> anyhow::Result<()> {\n+        let (analysis, file_id) = Analysis::from_single_file(read_stdin()?);\n+        let html = analysis.highlight_as_html(file_id, self.rainbow).unwrap();\n+        println!(\"{}\", html);\n+        Ok(())\n+    }\n+}"}, {"sha": "5ef8cdff4cf25173dea29ce4395cd289b1cb5df3", "filename": "crates/rust-analyzer/src/cli/parse.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9cf5914c458b8a44954448301f357662382b27da/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf5914c458b8a44954448301f357662382b27da/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fparse.rs?ref=9cf5914c458b8a44954448301f357662382b27da", "patch": "@@ -0,0 +1,17 @@\n+//! Read Rust code on stdin, print syntax tree on stdout.\n+use syntax::{AstNode, SourceFile};\n+\n+use crate::cli::{flags, read_stdin};\n+\n+impl flags::Parse {\n+    pub fn run(self) -> anyhow::Result<()> {\n+        let _p = profile::span(\"parsing\");\n+        let text = read_stdin()?;\n+        let file = SourceFile::parse(&text).tree();\n+        if !self.no_dump {\n+            println!(\"{:#?}\", file.syntax());\n+        }\n+        std::mem::forget(file);\n+        Ok(())\n+    }\n+}"}, {"sha": "e8291782b7ac15499ed60d7655e73e59a324954d", "filename": "crates/rust-analyzer/src/cli/ssr.rs", "status": "modified", "additions": 70, "deletions": 56, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/9cf5914c458b8a44954448301f357662382b27da/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fssr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf5914c458b8a44954448301f357662382b27da/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fssr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fssr.rs?ref=9cf5914c458b8a44954448301f357662382b27da", "patch": "@@ -1,72 +1,86 @@\n //! Applies structured search replace rules from the command line.\n \n+use ide_ssr::MatchFinder;\n+use project_model::CargoConfig;\n+\n use crate::cli::{\n+    flags,\n     load_cargo::{load_workspace_at, LoadCargoConfig},\n     Result,\n };\n-use ide_ssr::{MatchFinder, SsrPattern, SsrRule};\n-use project_model::CargoConfig;\n \n-pub fn apply_ssr_rules(rules: Vec<SsrRule>) -> Result<()> {\n-    use ide_db::base_db::SourceDatabaseExt;\n-    let cargo_config = CargoConfig::default();\n-    let load_cargo_config = LoadCargoConfig {\n-        load_out_dirs_from_check: true,\n-        with_proc_macro: true,\n-        prefill_caches: false,\n-    };\n-    let (host, vfs, _proc_macro) =\n-        load_workspace_at(&std::env::current_dir()?, &cargo_config, &load_cargo_config, &|_| {})?;\n-    let db = host.raw_database();\n-    let mut match_finder = MatchFinder::at_first_file(db)?;\n-    for rule in rules {\n-        match_finder.add_rule(rule)?;\n-    }\n-    let edits = match_finder.edits();\n-    for (file_id, edit) in edits {\n-        if let Some(path) = vfs.file_path(file_id).as_path() {\n-            let mut contents = db.file_text(file_id).to_string();\n-            edit.apply(&mut contents);\n-            std::fs::write(path, contents)?;\n+impl flags::Ssr {\n+    pub fn run(self) -> Result<()> {\n+        use ide_db::base_db::SourceDatabaseExt;\n+        let cargo_config = CargoConfig::default();\n+        let load_cargo_config = LoadCargoConfig {\n+            load_out_dirs_from_check: true,\n+            with_proc_macro: true,\n+            prefill_caches: false,\n+        };\n+        let (host, vfs, _proc_macro) = load_workspace_at(\n+            &std::env::current_dir()?,\n+            &cargo_config,\n+            &load_cargo_config,\n+            &|_| {},\n+        )?;\n+        let db = host.raw_database();\n+        let mut match_finder = MatchFinder::at_first_file(db)?;\n+        for rule in self.rule {\n+            match_finder.add_rule(rule)?;\n+        }\n+        let edits = match_finder.edits();\n+        for (file_id, edit) in edits {\n+            if let Some(path) = vfs.file_path(file_id).as_path() {\n+                let mut contents = db.file_text(file_id).to_string();\n+                edit.apply(&mut contents);\n+                std::fs::write(path, contents)?;\n+            }\n         }\n+        Ok(())\n     }\n-    Ok(())\n }\n \n-/// Searches for `patterns`, printing debug information for any nodes whose text exactly matches\n-/// `debug_snippet`. This is intended for debugging and probably isn't in it's current form useful\n-/// for much else.\n-pub fn search_for_patterns(patterns: Vec<SsrPattern>, debug_snippet: Option<String>) -> Result<()> {\n-    use ide_db::base_db::SourceDatabaseExt;\n-    use ide_db::symbol_index::SymbolsDatabase;\n-    let cargo_config = CargoConfig::default();\n-    let load_cargo_config = LoadCargoConfig {\n-        load_out_dirs_from_check: true,\n-        with_proc_macro: true,\n-        prefill_caches: false,\n-    };\n-    let (host, _vfs, _proc_macro) =\n-        load_workspace_at(&std::env::current_dir()?, &cargo_config, &load_cargo_config, &|_| {})?;\n-    let db = host.raw_database();\n-    let mut match_finder = MatchFinder::at_first_file(db)?;\n-    for pattern in patterns {\n-        match_finder.add_search_pattern(pattern)?;\n-    }\n-    if let Some(debug_snippet) = &debug_snippet {\n-        for &root in db.local_roots().iter() {\n-            let sr = db.source_root(root);\n-            for file_id in sr.iter() {\n-                for debug_info in match_finder.debug_where_text_equal(file_id, debug_snippet) {\n-                    println!(\"{:#?}\", debug_info);\n+impl flags::Search {\n+    /// Searches for `patterns`, printing debug information for any nodes whose text exactly matches\n+    /// `debug_snippet`. This is intended for debugging and probably isn't in it's current form useful\n+    /// for much else.\n+    pub fn run(self) -> Result<()> {\n+        use ide_db::base_db::SourceDatabaseExt;\n+        use ide_db::symbol_index::SymbolsDatabase;\n+        let cargo_config = CargoConfig::default();\n+        let load_cargo_config = LoadCargoConfig {\n+            load_out_dirs_from_check: true,\n+            with_proc_macro: true,\n+            prefill_caches: false,\n+        };\n+        let (host, _vfs, _proc_macro) = load_workspace_at(\n+            &std::env::current_dir()?,\n+            &cargo_config,\n+            &load_cargo_config,\n+            &|_| {},\n+        )?;\n+        let db = host.raw_database();\n+        let mut match_finder = MatchFinder::at_first_file(db)?;\n+        for pattern in self.pattern {\n+            match_finder.add_search_pattern(pattern)?;\n+        }\n+        if let Some(debug_snippet) = &self.debug {\n+            for &root in db.local_roots().iter() {\n+                let sr = db.source_root(root);\n+                for file_id in sr.iter() {\n+                    for debug_info in match_finder.debug_where_text_equal(file_id, debug_snippet) {\n+                        println!(\"{:#?}\", debug_info);\n+                    }\n                 }\n             }\n+        } else {\n+            for m in match_finder.matches().flattened().matches {\n+                // We could possibly at some point do something more useful than just printing\n+                // the matched text. For now though, that's the easiest thing to do.\n+                println!(\"{}\", m.matched_text());\n+            }\n         }\n-    } else {\n-        for m in match_finder.matches().flattened().matches {\n-            // We could possibly at some point do something more useful than just printing\n-            // the matched text. For now though, that's the easiest thing to do.\n-            println!(\"{}\", m.matched_text());\n-        }\n+        Ok(())\n     }\n-    Ok(())\n }"}, {"sha": "84659b5ea9cd5a471bbc99ba67ece3ccdd7cad8a", "filename": "crates/rust-analyzer/src/cli/symbols.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9cf5914c458b8a44954448301f357662382b27da/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fsymbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf5914c458b8a44954448301f357662382b27da/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fsymbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fsymbols.rs?ref=9cf5914c458b8a44954448301f357662382b27da", "patch": "@@ -0,0 +1,16 @@\n+//! Read Rust code on stdin, print syntax tree on stdout.\n+use ide::Analysis;\n+\n+use crate::cli::{flags, read_stdin};\n+\n+impl flags::Symbols {\n+    pub fn run(self) -> anyhow::Result<()> {\n+        let text = read_stdin()?;\n+        let (analysis, file_id) = Analysis::from_single_file(text);\n+        let structure = analysis.file_structure(file_id).unwrap();\n+        for s in structure {\n+            println!(\"{:?}\", s);\n+        }\n+        Ok(())\n+    }\n+}"}]}