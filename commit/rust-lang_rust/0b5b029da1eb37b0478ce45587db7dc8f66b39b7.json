{"sha": "0b5b029da1eb37b0478ce45587db7dc8f66b39b7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiNWIwMjlkYTFlYjM3YjA0NzhjZTQ1NTg3ZGI3ZGM4ZjY2YjM5Yjc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-19T14:23:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-19T14:23:46Z"}, "message": "Auto merge of #28494 - bluss:vecdeque-zst, r=eddyb\n\nVecDeque: Use power of two capacity even for zero sized types\r\n\r\nVecDeque depends on using a power of two capacity. Use the largest\r\npossible power of two capacity for ZSTs.\r\n\r\nFixes #28488", "tree": {"sha": "fd72eb52aedb6cb32afa50dd62d70475ba6fad4b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd72eb52aedb6cb32afa50dd62d70475ba6fad4b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b5b029da1eb37b0478ce45587db7dc8f66b39b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b5b029da1eb37b0478ce45587db7dc8f66b39b7", "html_url": "https://github.com/rust-lang/rust/commit/0b5b029da1eb37b0478ce45587db7dc8f66b39b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b5b029da1eb37b0478ce45587db7dc8f66b39b7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "655b2ef45fb87925fcdd4ceb44eb36e0c62dad24", "url": "https://api.github.com/repos/rust-lang/rust/commits/655b2ef45fb87925fcdd4ceb44eb36e0c62dad24", "html_url": "https://github.com/rust-lang/rust/commit/655b2ef45fb87925fcdd4ceb44eb36e0c62dad24"}, {"sha": "66f5dc13476d05b425a34071c75fd2e0b4275019", "url": "https://api.github.com/repos/rust-lang/rust/commits/66f5dc13476d05b425a34071c75fd2e0b4275019", "html_url": "https://github.com/rust-lang/rust/commit/66f5dc13476d05b425a34071c75fd2e0b4275019"}], "stats": {"total": 41, "additions": 40, "deletions": 1}, "files": [{"sha": "4ee9787c9ec8a5c727bf93d2059e04436d79e7d3", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 40, "deletions": 1, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/0b5b029da1eb37b0478ce45587db7dc8f66b39b7/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b5b029da1eb37b0478ce45587db7dc8f66b39b7/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=0b5b029da1eb37b0478ce45587db7dc8f66b39b7", "patch": "@@ -21,9 +21,11 @@\n use core::cmp::Ordering;\n use core::fmt;\n use core::iter::{repeat, FromIterator};\n+use core::mem;\n use core::ops::{Index, IndexMut};\n use core::ptr;\n use core::slice;\n+use core::usize;\n \n use core::hash::{Hash, Hasher};\n use core::cmp;\n@@ -32,6 +34,7 @@ use alloc::raw_vec::RawVec;\n \n const INITIAL_CAPACITY: usize = 7; // 2^3 - 1\n const MINIMUM_CAPACITY: usize = 1; // 2 - 1\n+const MAXIMUM_ZST_CAPACITY: usize = 1 << (usize::BITS - 1); // Largest possible power of two\n \n /// `VecDeque` is a growable ring buffer, which can be used as a\n /// double-ended queue efficiently.\n@@ -83,7 +86,12 @@ impl<T> VecDeque<T> {\n     /// Marginally more convenient\n     #[inline]\n     fn cap(&self) -> usize {\n-        self.buf.cap()\n+        if mem::size_of::<T>() == 0 {\n+            // For zero sized types, we are always at maximum capacity\n+            MAXIMUM_ZST_CAPACITY\n+        } else {\n+            self.buf.cap()\n+        }\n     }\n \n     /// Turn ptr into a slice\n@@ -1465,6 +1473,7 @@ impl<T: Clone> VecDeque<T> {\n #[inline]\n fn wrap_index(index: usize, size: usize) -> usize {\n     // size is always a power of 2\n+    debug_assert!(size.is_power_of_two());\n     index & (size - 1)\n }\n \n@@ -2032,4 +2041,34 @@ mod tests {\n             }\n         }\n     }\n+\n+    #[test]\n+    fn test_zst_push() {\n+        const N: usize = 8;\n+\n+        // Zero sized type\n+        struct Zst;\n+\n+        // Test that for all possible sequences of push_front / push_back,\n+        // we end up with a deque of the correct size\n+\n+        for len in 0..N {\n+            let mut tester = VecDeque::with_capacity(len);\n+            assert_eq!(tester.len(), 0);\n+            assert!(tester.capacity() >= len);\n+            for case in 0..(1 << len) {\n+                assert_eq!(tester.len(), 0);\n+                for bit in 0..len {\n+                    if case & (1 << bit) != 0 {\n+                        tester.push_front(Zst);\n+                    } else {\n+                        tester.push_back(Zst);\n+                    }\n+                }\n+                assert_eq!(tester.len(), len);\n+                assert_eq!(tester.iter().count(), len);\n+                tester.clear();\n+            }\n+        }\n+    }\n }"}]}