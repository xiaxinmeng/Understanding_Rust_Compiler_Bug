{"sha": "9dd6f5246cf59c1d04bf6f23f86998ae08689168", "node_id": "C_kwDOAAsO6NoAKDlkZDZmNTI0NmNmNTljMWQwNGJmNmYyM2Y4Njk5OGFlMDg2ODkxNjg", "commit": {"author": {"name": "R\u00e9my Rakic", "email": "remy.rakic+github@gmail.com", "date": "2022-05-16T01:40:52Z"}, "committer": {"name": "R\u00e9my Rakic", "email": "remy.rakic+github@gmail.com", "date": "2022-07-11T13:43:28Z"}, "message": "extend bootstrap for PGO on windows\n\nWhen building LLVM/LLD as part of a build that asks LLVM to generate profiles, e.g. when\ndoing PGO, cmake or clang-cl don't automatically link clang's profiler runtime in,\ncausing undefined reference errors at link-time.\n\nWe do that manually, by adding clang's resource library folder to the library search path:\n- for LLVM itself, by extending the linker args that `rustc_llvm`'s build script\n  uses, to avoid the linker errors when linking `rustc_driver`.\n- for LLD, by extending cmake's linker flags during the LLD build step.", "tree": {"sha": "b5b9107a845637a1871fd0ffd0f20d9e2dd3ebe1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b5b9107a845637a1871fd0ffd0f20d9e2dd3ebe1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9dd6f5246cf59c1d04bf6f23f86998ae08689168", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9dd6f5246cf59c1d04bf6f23f86998ae08689168", "html_url": "https://github.com/rust-lang/rust/commit/9dd6f5246cf59c1d04bf6f23f86998ae08689168", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9dd6f5246cf59c1d04bf6f23f86998ae08689168/comments", "author": {"login": "lqd", "id": 247183, "node_id": "MDQ6VXNlcjI0NzE4Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/247183?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lqd", "html_url": "https://github.com/lqd", "followers_url": "https://api.github.com/users/lqd/followers", "following_url": "https://api.github.com/users/lqd/following{/other_user}", "gists_url": "https://api.github.com/users/lqd/gists{/gist_id}", "starred_url": "https://api.github.com/users/lqd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lqd/subscriptions", "organizations_url": "https://api.github.com/users/lqd/orgs", "repos_url": "https://api.github.com/users/lqd/repos", "events_url": "https://api.github.com/users/lqd/events{/privacy}", "received_events_url": "https://api.github.com/users/lqd/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lqd", "id": 247183, "node_id": "MDQ6VXNlcjI0NzE4Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/247183?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lqd", "html_url": "https://github.com/lqd", "followers_url": "https://api.github.com/users/lqd/followers", "following_url": "https://api.github.com/users/lqd/following{/other_user}", "gists_url": "https://api.github.com/users/lqd/gists{/gist_id}", "starred_url": "https://api.github.com/users/lqd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lqd/subscriptions", "organizations_url": "https://api.github.com/users/lqd/orgs", "repos_url": "https://api.github.com/users/lqd/repos", "events_url": "https://api.github.com/users/lqd/events{/privacy}", "received_events_url": "https://api.github.com/users/lqd/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "94f8ee1f7c27b749f84ce9dbea0762975aaa7770", "url": "https://api.github.com/repos/rust-lang/rust/commits/94f8ee1f7c27b749f84ce9dbea0762975aaa7770", "html_url": "https://github.com/rust-lang/rust/commit/94f8ee1f7c27b749f84ce9dbea0762975aaa7770"}], "stats": {"total": 75, "additions": 72, "deletions": 3}, "files": [{"sha": "ef258747927364c4491fe8e7bd312fae92a8850a", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9dd6f5246cf59c1d04bf6f23f86998ae08689168/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dd6f5246cf59c1d04bf6f23f86998ae08689168/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=9dd6f5246cf59c1d04bf6f23f86998ae08689168", "patch": "@@ -25,6 +25,7 @@ use crate::config::{LlvmLibunwind, TargetSelection};\n use crate::dist;\n use crate::native;\n use crate::tool::SourceType;\n+use crate::util::get_clang_cl_resource_dir;\n use crate::util::{exe, is_debug_info, is_dylib, output, symlink_dir, t, up_to_date};\n use crate::LLVM_TOOLS;\n use crate::{CLang, Compiler, DependencyType, GitRepo, Mode};\n@@ -769,10 +770,38 @@ pub fn rustc_cargo_env(builder: &Builder<'_>, cargo: &mut Cargo, target: TargetS\n         if let Some(s) = target_config.and_then(|c| c.llvm_config.as_ref()) {\n             cargo.env(\"CFG_LLVM_ROOT\", s);\n         }\n-        // Some LLVM linker flags (-L and -l) may be needed to link rustc_llvm.\n+\n+        // Some LLVM linker flags (-L and -l) may be needed to link `rustc_llvm`. Its build script\n+        // expects these to be passed via the `LLVM_LINKER_FLAGS` env variable, separated by\n+        // whitespace.\n+        //\n+        // For example:\n+        // - on windows, when `clang-cl` is used with instrumentation, we need to manually add\n+        // clang's runtime library resource directory so that the profiler runtime library can be\n+        // found. This is to avoid the linker errors about undefined references to\n+        // `__llvm_profile_instrument_memop` when linking `rustc_driver`.\n+        let mut llvm_linker_flags = String::new();\n+        if builder.config.llvm_profile_generate && target.contains(\"msvc\") {\n+            if let Some(ref clang_cl_path) = builder.config.llvm_clang_cl {\n+                // Add clang's runtime library directory to the search path\n+                let clang_rt_dir = get_clang_cl_resource_dir(clang_cl_path);\n+                llvm_linker_flags.push_str(&format!(\"-L{}\", clang_rt_dir.display()));\n+            }\n+        }\n+\n+        // The config can also specify its own llvm linker flags.\n         if let Some(ref s) = builder.config.llvm_ldflags {\n-            cargo.env(\"LLVM_LINKER_FLAGS\", s);\n+            if !llvm_linker_flags.is_empty() {\n+                llvm_linker_flags.push_str(\" \");\n+            }\n+            llvm_linker_flags.push_str(s);\n+        }\n+\n+        // Set the linker flags via the env var that `rustc_llvm`'s build script will read.\n+        if !llvm_linker_flags.is_empty() {\n+            cargo.env(\"LLVM_LINKER_FLAGS\", llvm_linker_flags);\n         }\n+\n         // Building with a static libstdc++ is only supported on linux right now,\n         // not for MSVC or macOS\n         if builder.config.llvm_static_stdcpp"}, {"sha": "2e7b2fa0d4ccd88b10f80a849d9258e3c6361ed3", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9dd6f5246cf59c1d04bf6f23f86998ae08689168/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dd6f5246cf59c1d04bf6f23f86998ae08689168/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=9dd6f5246cf59c1d04bf6f23f86998ae08689168", "patch": "@@ -18,6 +18,7 @@ use std::process::Command;\n \n use crate::builder::{Builder, RunConfig, ShouldRun, Step};\n use crate::config::TargetSelection;\n+use crate::util::get_clang_cl_resource_dir;\n use crate::util::{self, exe, output, program_out_of_date, t, up_to_date};\n use crate::{CLang, GitRepo};\n \n@@ -755,7 +756,22 @@ impl Step for Lld {\n         t!(fs::create_dir_all(&out_dir));\n \n         let mut cfg = cmake::Config::new(builder.src.join(\"src/llvm-project/lld\"));\n-        configure_cmake(builder, target, &mut cfg, true, LdFlags::default());\n+        let mut ldflags = LdFlags::default();\n+\n+        // When building LLD as part of a build with instrumentation on windows, for example\n+        // when doing PGO on CI, cmake or clang-cl don't automatically link clang's\n+        // profiler runtime in. In that case, we need to manually ask cmake to do it, to avoid\n+        // linking errors, much like LLVM's cmake setup does in that situation.\n+        if builder.config.llvm_profile_generate && target.contains(\"msvc\") {\n+            if let Some(clang_cl_path) = builder.config.llvm_clang_cl.as_ref() {\n+                // Find clang's runtime library directory and push that as a search path to the\n+                // cmake linker flags.\n+                let clang_rt_dir = get_clang_cl_resource_dir(clang_cl_path);\n+                ldflags.push_all(&format!(\"/libpath:{}\", clang_rt_dir.display()));\n+            }\n+        }\n+\n+        configure_cmake(builder, target, &mut cfg, true, ldflags);\n \n         // This is an awful, awful hack. Discovered when we migrated to using\n         // clang-cl to compile LLVM/LLD it turns out that LLD, when built out of"}, {"sha": "77e6ce6b79e00147f232958a78b3e51a73a9e847", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9dd6f5246cf59c1d04bf6f23f86998ae08689168/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dd6f5246cf59c1d04bf6f23f86998ae08689168/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=9dd6f5246cf59c1d04bf6f23f86998ae08689168", "patch": "@@ -576,3 +576,27 @@ fn absolute_windows(path: &std::path::Path) -> std::io::Result<std::path::PathBu\n         }\n     }\n }\n+\n+/// Adapted from https://github.com/llvm/llvm-project/blob/782e91224601e461c019e0a4573bbccc6094fbcd/llvm/cmake/modules/HandleLLVMOptions.cmake#L1058-L1079\n+///\n+/// When `clang-cl` is used with instrumentation, we need to add clang's runtime library resource\n+/// directory to the linker flags, otherwise there will be linker errors about the profiler runtime\n+/// missing. This function returns the path to that directory.\n+pub fn get_clang_cl_resource_dir(clang_cl_path: &str) -> PathBuf {\n+    // Similar to how LLVM does it, to find clang's library runtime directory:\n+    // - we ask `clang-cl` to locate the `clang_rt.builtins` lib.\n+    let mut builtins_locator = Command::new(clang_cl_path);\n+    builtins_locator.args(&[\"/clang:-print-libgcc-file-name\", \"/clang:--rtlib=compiler-rt\"]);\n+\n+    let clang_rt_builtins = output(&mut builtins_locator);\n+    let clang_rt_builtins = Path::new(clang_rt_builtins.trim());\n+    assert!(\n+        clang_rt_builtins.exists(),\n+        \"`clang-cl` must correctly locate the library runtime directory\"\n+    );\n+\n+    // - the profiler runtime will be located in the same directory as the builtins lib, like\n+    // `$LLVM_DISTRO_ROOT/lib/clang/$LLVM_VERSION/lib/windows`.\n+    let clang_rt_dir = clang_rt_builtins.parent().expect(\"The clang lib folder should exist\");\n+    clang_rt_dir.to_path_buf()\n+}"}]}