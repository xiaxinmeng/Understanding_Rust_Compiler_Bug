{"sha": "a375799f7a4793adc92b76df59dc0be0bb2a90b8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzNzU3OTlmN2E0NzkzYWRjOTJiNzZkZjU5ZGMwYmUwYmIyYTkwYjg=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2016-08-28T02:33:38Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2016-08-28T02:44:12Z"}, "message": "rustbuild: smarter `git submodule`-ing\n\nWith this commit, if one bootstraps rust against system llvm then the\nsrc/llvm submodule is not updated/checked-out. This saves considerable\nnetwork bandwith when starting from a fresh clone of rust-lang/rust as\nthe llvm submodule is never cloned.\n\ncc #30107", "tree": {"sha": "91f2c2a73b59c43c8d2c7f68adb42805b017710d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/91f2c2a73b59c43c8d2c7f68adb42805b017710d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a375799f7a4793adc92b76df59dc0be0bb2a90b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a375799f7a4793adc92b76df59dc0be0bb2a90b8", "html_url": "https://github.com/rust-lang/rust/commit/a375799f7a4793adc92b76df59dc0be0bb2a90b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a375799f7a4793adc92b76df59dc0be0bb2a90b8/comments", "author": null, "committer": null, "parents": [{"sha": "11946956a6352f49c6aadc1c13c39757a046e0c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/11946956a6352f49c6aadc1c13c39757a046e0c2", "html_url": "https://github.com/rust-lang/rust/commit/11946956a6352f49c6aadc1c13c39757a046e0c2"}], "stats": {"total": 83, "additions": 72, "deletions": 11}, "files": [{"sha": "b1a609aac5c2bca6ef5858e986d46e62b31e5179", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 72, "deletions": 11, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/a375799f7a4793adc92b76df59dc0be0bb2a90b8/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a375799f7a4793adc92b76df59dc0be0bb2a90b8/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=a375799f7a4793adc92b76df59dc0be0bb2a90b8", "patch": "@@ -32,7 +32,7 @@ use std::cell::RefCell;\n use std::collections::HashMap;\n use std::env;\n use std::fs::{self, File};\n-use std::path::{PathBuf, Path};\n+use std::path::{Component, PathBuf, Path};\n use std::process::Command;\n \n use build_helper::{run_silent, output};\n@@ -475,12 +475,32 @@ impl Build {\n     /// This will detect if any submodules are out of date an run the necessary\n     /// commands to sync them all with upstream.\n     fn update_submodules(&self) {\n+        struct Submodule<'a> {\n+            path: &'a Path,\n+            state: State,\n+        }\n+\n+        enum State {\n+            // The submodule may have staged/unstaged changes\n+            MaybeDirty,\n+            // Or could be initialized but never updated\n+            NotInitialized,\n+            // The submodule, itself, has extra commits but those changes haven't been commited to\n+            // the (outer) git repository\n+            OutOfSync,\n+        }\n+\n         if !self.config.submodules {\n             return\n         }\n         if fs::metadata(self.src.join(\".git\")).is_err() {\n             return\n         }\n+        let git = || {\n+            let mut cmd = Command::new(\"git\");\n+            cmd.current_dir(&self.src);\n+            return cmd\n+        };\n         let git_submodule = || {\n             let mut cmd = Command::new(\"git\");\n             cmd.current_dir(&self.src).arg(\"submodule\");\n@@ -492,19 +512,60 @@ impl Build {\n         //        of detecting whether we need to run all the submodule commands\n         //        below.\n         let out = output(git_submodule().arg(\"status\"));\n-        if !out.lines().any(|l| l.starts_with(\"+\") || l.starts_with(\"-\")) {\n-            return\n+        let mut submodules = vec![];\n+        for line in out.lines() {\n+            // NOTE `git submodule status` output looks like this:\n+            //\n+            // -5066b7dcab7e700844b0e2ba71b8af9dc627a59b src/liblibc\n+            // +b37ef24aa82d2be3a3cc0fe89bf82292f4ca181c src/compiler-rt (remotes/origin/rust-llvm-2016-07-18-1-gb37ef24)\n+            //  e058ca661692a8d01f8cf9d35939dfe3105ce968 src/jemalloc (3.6.0-533-ge058ca6)\n+            //\n+            // The first character can be '-', '+' or ' ' and denotes the `State` of the submodule\n+            // Right next to this character is the SHA-1 of the submodule HEAD\n+            // And after that comes the path to the submodule\n+            let path = Path::new(line[1..].split(' ').skip(1).next().unwrap());\n+            let state = if line.starts_with('-') {\n+                State::NotInitialized\n+            } else if line.starts_with('*') {\n+                State::OutOfSync\n+            } else if line.starts_with(' ') {\n+                State::MaybeDirty\n+            } else {\n+                panic!(\"unexpected git submodule state: {:?}\", line.chars().next());\n+            };\n+\n+            submodules.push(Submodule { path: path, state: state })\n         }\n \n         self.run(git_submodule().arg(\"sync\"));\n-        self.run(git_submodule().arg(\"init\"));\n-        self.run(git_submodule().arg(\"update\"));\n-        self.run(git_submodule().arg(\"update\").arg(\"--recursive\"));\n-        self.run(git_submodule().arg(\"status\").arg(\"--recursive\"));\n-        self.run(git_submodule().arg(\"foreach\").arg(\"--recursive\")\n-                                .arg(\"git\").arg(\"clean\").arg(\"-fdx\"));\n-        self.run(git_submodule().arg(\"foreach\").arg(\"--recursive\")\n-                                .arg(\"git\").arg(\"checkout\").arg(\".\"));\n+\n+        for submodule in submodules {\n+            // If using llvm-root then don't touch the llvm submodule.\n+            if submodule.path.components().any(|c| c == Component::Normal(\"llvm\".as_ref())) &&\n+                self.config.target_config.get(&self.config.build).and_then(|c| c.llvm_config.as_ref()).is_some()\n+            {\n+                continue\n+            }\n+\n+            match submodule.state {\n+                State::MaybeDirty => {\n+                    // drop staged changes\n+                    self.run(git().arg(\"-C\").arg(submodule.path).args(&[\"reset\", \"--hard\"]));\n+                    // drops unstaged changes\n+                    self.run(git().arg(\"-C\").arg(submodule.path).args(&[\"clean\", \"-fdx\"]));\n+                },\n+                State::NotInitialized => {\n+                    self.run(git_submodule().arg(\"init\").arg(submodule.path));\n+                    self.run(git_submodule().arg(\"update\").arg(submodule.path));\n+                },\n+                State::OutOfSync => {\n+                    // drops submodule commits that weren't reported to the (outer) git repository\n+                    self.run(git_submodule().arg(\"update\").arg(submodule.path));\n+                    self.run(git().arg(\"-C\").arg(submodule.path).args(&[\"reset\", \"--hard\"]));\n+                    self.run(git().arg(\"-C\").arg(submodule.path).args(&[\"clean\", \"-fdx\"]));\n+                },\n+            }\n+        }\n     }\n \n     /// Clear out `dir` if `input` is newer."}]}