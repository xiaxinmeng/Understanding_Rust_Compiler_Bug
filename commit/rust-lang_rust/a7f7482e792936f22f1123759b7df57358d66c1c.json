{"sha": "a7f7482e792936f22f1123759b7df57358d66c1c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3Zjc0ODJlNzkyOTM2ZjIyZjExMjM3NTliN2RmNTczNThkNjZjMWM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-27T23:09:27Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-01-03T22:01:58Z"}, "message": "libsyntax: De-`@mut` `TtFrame::idx`", "tree": {"sha": "73665925a807043aab2d01cf1d979934381230aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/73665925a807043aab2d01cf1d979934381230aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a7f7482e792936f22f1123759b7df57358d66c1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a7f7482e792936f22f1123759b7df57358d66c1c", "html_url": "https://github.com/rust-lang/rust/commit/a7f7482e792936f22f1123759b7df57358d66c1c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a7f7482e792936f22f1123759b7df57358d66c1c/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "497b63ddf044e43173f83110a4ffb4c61413c524", "url": "https://api.github.com/repos/rust-lang/rust/commits/497b63ddf044e43173f83110a4ffb4c61413c524", "html_url": "https://github.com/rust-lang/rust/commit/497b63ddf044e43173f83110a4ffb4c61413c524"}], "stats": {"total": 28, "additions": 14, "deletions": 14}, "files": [{"sha": "f32a0162192a28285a93582451fb44ed8b8f51ac", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a7f7482e792936f22f1123759b7df57358d66c1c/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7f7482e792936f22f1123759b7df57358d66c1c/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=a7f7482e792936f22f1123759b7df57358d66c1c", "patch": "@@ -17,14 +17,14 @@ use parse::token::{EOF, INTERPOLATED, IDENT, Token, nt_ident};\n use parse::token::{ident_to_str};\n use parse::lexer::TokenAndSpan;\n \n-use std::cell::RefCell;\n+use std::cell::{Cell, RefCell};\n use std::hashmap::HashMap;\n use std::option;\n \n ///an unzipping of `token_tree`s\n struct TtFrame {\n     forest: @~[ast::token_tree],\n-    idx: uint,\n+    idx: Cell<uint>,\n     dotdotdoted: bool,\n     sep: Option<Token>,\n     up: Option<@mut TtFrame>,\n@@ -54,7 +54,7 @@ pub fn new_tt_reader(sp_diag: @SpanHandler,\n         sp_diag: sp_diag,\n         stack: RefCell::new(@mut TtFrame {\n             forest: @src,\n-            idx: 0u,\n+            idx: Cell::new(0u),\n             dotdotdoted: false,\n             sep: None,\n             up: option::None\n@@ -76,7 +76,7 @@ pub fn new_tt_reader(sp_diag: @SpanHandler,\n fn dup_tt_frame(f: @mut TtFrame) -> @mut TtFrame {\n     @mut TtFrame {\n         forest: @(*f.forest).clone(),\n-        idx: f.idx,\n+        idx: f.idx.clone(),\n         dotdotdoted: f.dotdotdoted,\n         sep: f.sep.clone(),\n         up: match f.up {\n@@ -181,7 +181,7 @@ pub fn tt_next_token(r: &TtReader) -> TokenAndSpan {\n     loop {\n         {\n             let mut stack = r.stack.borrow_mut();\n-            if stack.get().idx < stack.get().forest.len() {\n+            if stack.get().idx.get() < stack.get().forest.len() {\n                 break;\n             }\n         }\n@@ -209,12 +209,12 @@ pub fn tt_next_token(r: &TtReader) -> TokenAndSpan {\n                 }\n \n                 r.stack.set(tt_f);\n-                r.stack.get().idx += 1u;\n+                r.stack.get().idx.set(r.stack.get().idx.get() + 1u);\n               }\n             }\n \n         } else { /* repeat */\n-            r.stack.get().idx = 0u;\n+            r.stack.get().idx.set(0u);\n             {\n                 let mut repeat_idx = r.repeat_idx.borrow_mut();\n                 repeat_idx.get()[repeat_idx.get().len() - 1u] += 1u;\n@@ -231,11 +231,11 @@ pub fn tt_next_token(r: &TtReader) -> TokenAndSpan {\n     loop { /* because it's easiest, this handles `tt_delim` not starting\n     with a `tt_tok`, even though it won't happen */\n         // XXX(pcwalton): Bad copy.\n-        match r.stack.get().forest[r.stack.get().idx].clone() {\n+        match r.stack.get().forest[r.stack.get().idx.get()].clone() {\n           tt_delim(tts) => {\n             r.stack.set(@mut TtFrame {\n                 forest: tts,\n-                idx: 0u,\n+                idx: Cell::new(0u),\n                 dotdotdoted: false,\n                 sep: None,\n                 up: option::Some(r.stack.get())\n@@ -245,7 +245,7 @@ pub fn tt_next_token(r: &TtReader) -> TokenAndSpan {\n           tt_tok(sp, tok) => {\n             r.cur_span.set(sp);\n             r.cur_tok.set(tok);\n-            r.stack.get().idx += 1u;\n+            r.stack.get().idx.set(r.stack.get().idx.get() + 1u);\n             return ret_val;\n           }\n           tt_seq(sp, tts, sep, zerok) => {\n@@ -272,7 +272,7 @@ pub fn tt_next_token(r: &TtReader) -> TokenAndSpan {\n                                               once\");\n                           }\n \n-                    r.stack.get().idx += 1u;\n+                    r.stack.get().idx.set(r.stack.get().idx.get() + 1u);\n                     return tt_next_token(r);\n                 } else {\n                     {\n@@ -282,7 +282,7 @@ pub fn tt_next_token(r: &TtReader) -> TokenAndSpan {\n                         repeat_idx.get().push(0u);\n                         r.stack.set(@mut TtFrame {\n                             forest: tts,\n-                            idx: 0u,\n+                            idx: Cell::new(0u),\n                             dotdotdoted: true,\n                             sep: sep,\n                             up: Some(r.stack.get())\n@@ -301,14 +301,14 @@ pub fn tt_next_token(r: &TtReader) -> TokenAndSpan {\n               matched_nonterminal(nt_ident(~sn,b)) => {\n                 r.cur_span.set(sp);\n                 r.cur_tok.set(IDENT(sn,b));\n-                r.stack.get().idx += 1u;\n+                r.stack.get().idx.set(r.stack.get().idx.get() + 1u);\n                 return ret_val;\n               }\n               matched_nonterminal(ref other_whole_nt) => {\n                 // XXX(pcwalton): Bad copy.\n                 r.cur_span.set(sp);\n                 r.cur_tok.set(INTERPOLATED((*other_whole_nt).clone()));\n-                r.stack.get().idx += 1u;\n+                r.stack.get().idx.set(r.stack.get().idx.get() + 1u);\n                 return ret_val;\n               }\n               matched_seq(..) => {"}]}