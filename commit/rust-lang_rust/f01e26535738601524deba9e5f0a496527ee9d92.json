{"sha": "f01e26535738601524deba9e5f0a496527ee9d92", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwMWUyNjUzNTczODYwMTUyNGRlYmE5ZTVmMGE0OTY1MjdlZTlkOTI=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2013-08-22T16:07:54Z"}, "committer": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2013-08-22T23:31:58Z"}, "message": "std: moved static file actions (open,unlink) to FsRequest", "tree": {"sha": "0c5457404000976cea42b103c97c0526cf4665f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c5457404000976cea42b103c97c0526cf4665f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f01e26535738601524deba9e5f0a496527ee9d92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f01e26535738601524deba9e5f0a496527ee9d92", "html_url": "https://github.com/rust-lang/rust/commit/f01e26535738601524deba9e5f0a496527ee9d92", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f01e26535738601524deba9e5f0a496527ee9d92/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f85d3b3ec1c8c06a6929a960b3d544fb810e1c70", "url": "https://api.github.com/repos/rust-lang/rust/commits/f85d3b3ec1c8c06a6929a960b3d544fb810e1c70", "html_url": "https://github.com/rust-lang/rust/commit/f85d3b3ec1c8c06a6929a960b3d544fb810e1c70"}], "stats": {"total": 126, "additions": 63, "deletions": 63}, "files": [{"sha": "637b5a754587f333c9b9b299e029e9ca5a238601", "filename": "src/libstd/rt/uv/file.rs", "status": "modified", "additions": 61, "deletions": 61, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/f01e26535738601524deba9e5f0a496527ee9d92/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f01e26535738601524deba9e5f0a496527ee9d92/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Ffile.rs?ref=f01e26535738601524deba9e5f0a496527ee9d92", "patch": "@@ -37,6 +37,58 @@ impl FsRequest {\n         fs_req\n     }\n \n+    fn open_common<P: PathLike>(loop_: Loop, path: &P, flags: int, mode: int,\n+               cb: Option<FsCallback>) -> int {\n+        let complete_cb_ptr = match cb {\n+            Some(_) => compl_cb as *u8,\n+            None => 0 as *u8\n+        };\n+        let is_sync = cb.is_none();\n+        let req = FsRequest::new(cb);\n+        let result = path.path_as_str(|p| {\n+            p.to_c_str().with_ref(|p| unsafe {\n+            uvll::fs_open(loop_.native_handle(),\n+                          req.native_handle(), p, flags, mode, complete_cb_ptr) as int\n+            })\n+        });\n+        if is_sync { req.cleanup_and_delete(); }\n+        result\n+    }\n+    pub fn open<P: PathLike>(loop_: Loop, path: &P, flags: int, mode: int,\n+               cb: FsCallback) {\n+        FsRequest::open_common(loop_, path, flags, mode, Some(cb));\n+    }\n+\n+    pub fn open_sync<P: PathLike>(loop_: Loop, path: &P, flags: int, mode: int) -> Result<int, UvError> {\n+        let result = FsRequest::open_common(loop_, path, flags, mode, None);\n+        sync_cleanup(&loop_, result)\n+    }\n+\n+    fn unlink_common<P: PathLike>(loop_: Loop, path: &P, cb: Option<FsCallback>) -> int {\n+        let complete_cb_ptr = match cb {\n+            Some(_) => compl_cb as *u8,\n+            None => 0 as *u8\n+        };\n+        let is_sync = cb.is_none();\n+        let req = FsRequest::new(cb);\n+        let result = path.path_as_str(|p| {\n+            p.to_c_str().with_ref(|p| unsafe {\n+                uvll::fs_unlink(loop_.native_handle(),\n+                              req.native_handle(), p, complete_cb_ptr) as int\n+            })\n+        });\n+        if is_sync { req.cleanup_and_delete(); }\n+        result\n+    }\n+    pub fn unlink<P: PathLike>(loop_: Loop, path: &P, cb: FsCallback) {\n+        let result = FsRequest::unlink_common(loop_, path, Some(cb));\n+        sync_cleanup(&loop_, result);\n+    }\n+    pub fn unlink_sync<P: PathLike>(loop_: Loop, path: &P) -> Result<int, UvError> {\n+        let result = FsRequest::unlink_common(loop_, path, None);\n+        sync_cleanup(&loop_, result)\n+    }\n+\n     pub fn install_req_data(&self, cb: Option<FsCallback>) {\n         let fs_req = (self.native_handle()) as *uvll::uv_write_t;\n         let data = ~RequestData {\n@@ -105,63 +157,11 @@ impl FileDescriptor {\n         FileDescriptor::new(req.get_result())\n     }\n \n-    fn open_common<P: PathLike>(loop_: Loop, path: &P, flags: int, mode: int,\n-               cb: Option<FsCallback>) -> int {\n-        let complete_cb_ptr = match cb {\n-            Some(_) => compl_cb,\n-            None => 0 as *u8\n-        };\n-        let is_sync = cb.is_none();\n-        let req = FsRequest::new(cb);\n-        let result = path.path_as_str(|p| {\n-            p.to_c_str().with_ref(|p| unsafe {\n-            uvll::fs_open(loop_.native_handle(),\n-                          req.native_handle(), p, flags, mode, complete_cb_ptr) as int\n-            })\n-        });\n-        if is_sync { req.cleanup_and_delete(); }\n-        result\n-    }\n-    pub fn open<P: PathLike>(loop_: Loop, path: &P, flags: int, mode: int,\n-               cb: FsCallback) {\n-        FileDescriptor::open_common(loop_, path, flags, mode, Some(cb));\n-    }\n-\n-    pub fn open_sync<P: PathLike>(loop_: Loop, path: &P, flags: int, mode: int) -> Result<int, UvError> {\n-        let result = FileDescriptor::open_common(loop_, path, flags, mode, None);\n-        sync_cleanup(&loop_, result)\n-    }\n-\n-    fn unlink_common<P: PathLike>(loop_: Loop, path: &P, cb: Option<FsCallback>) -> int {\n-        let complete_cb_ptr = match cb {\n-            Some(_) => compl_cb,\n-            None => 0 as *u8\n-        };\n-        let is_sync = cb.is_none();\n-        let req = FsRequest::new(cb);\n-        let result = path.path_as_str(|p| {\n-            p.to_c_str().with_ref(|p| unsafe {\n-                uvll::fs_unlink(loop_.native_handle(),\n-                              req.native_handle(), p, complete_cb_ptr) as int\n-            })\n-        });\n-        if is_sync { req.cleanup_and_delete(); }\n-        result\n-    }\n-    pub fn unlink<P: PathLike>(loop_: Loop, path: &P, cb: FsCallback) {\n-        let result = FileDescriptor::unlink_common(loop_, path, Some(cb));\n-        sync_cleanup(&loop_, result);\n-    }\n-    pub fn unlink_sync<P: PathLike>(loop_: Loop, path: &P) -> Result<int, UvError> {\n-        let result = FileDescriptor::unlink_common(loop_, path, None);\n-        sync_cleanup(&loop_, result)\n-    }\n-\n     // as per bnoordhuis in #libuv: offset >= 0 uses prwrite instead of write\n     fn write_common(&mut self, loop_: Loop, buf: Buf, offset: i64, cb: Option<FsCallback>)\n           -> int {\n         let complete_cb_ptr = match cb {\n-            Some(_) => compl_cb,\n+            Some(_) => compl_cb as *u8,\n             None => 0 as *u8\n         };\n         let is_sync = cb.is_none();\n@@ -190,7 +190,7 @@ impl FileDescriptor {\n                    offset: i64, cb: Option<FsCallback>)\n           -> int {\n         let complete_cb_ptr = match cb {\n-            Some(_) => compl_cb,\n+            Some(_) => compl_cb as *u8,\n             None => 0 as *u8\n         };\n         let is_sync = cb.is_none();\n@@ -216,7 +216,7 @@ impl FileDescriptor {\n \n     fn close_common(self, loop_: Loop, cb: Option<FsCallback>) -> int {\n         let complete_cb_ptr = match cb {\n-            Some(_) => compl_cb,\n+            Some(_) => compl_cb as *u8,\n             None => 0 as *u8\n         };\n         let is_sync = cb.is_none();\n@@ -301,7 +301,7 @@ mod test {\n             let read_buf = slice_to_uv_buf(read_mem);\n             let read_buf_ptr: *Buf = &read_buf;\n             let p = Path(path_str);\n-            do FileDescriptor::open(loop_, &p, create_flags as int, mode as int)\n+            do FsRequest::open(loop_, &p, create_flags as int, mode as int)\n             |req, uverr| {\n                 let loop_ = req.get_loop();\n                 assert!(uverr.is_none());\n@@ -313,7 +313,7 @@ mod test {\n                     do fd.close(loop_) |req, _| {\n                         let loop_ = req.get_loop();\n                         assert!(uverr.is_none());\n-                        do FileDescriptor::open(loop_, &Path(path_str), read_flags as int,0)\n+                        do FsRequest::open(loop_, &Path(path_str), read_flags as int,0)\n                             |req, uverr| {\n                             assert!(uverr.is_none());\n                             let loop_ = req.get_loop();\n@@ -336,7 +336,7 @@ mod test {\n                                     assert!(read_str == ~\"hello\");\n                                     do FileDescriptor(raw_fd).close(loop_) |_,uverr| {\n                                         assert!(uverr.is_none());\n-                                        do FileDescriptor::unlink(loop_, &Path(path_str))\n+                                        do FsRequest::unlink(loop_, &Path(path_str))\n                                         |_,uverr| {\n                                             assert!(uverr.is_none());\n                                         };\n@@ -367,7 +367,7 @@ mod test {\n             let write_val = \"hello\".as_bytes().to_owned();\n             let write_buf = slice_to_uv_buf(write_val);\n             // open/create\n-            let result = FileDescriptor::open_sync(loop_, &Path(path_str),\n+            let result = FsRequest::open_sync(loop_, &Path(path_str),\n                                                    create_flags as int, mode as int);\n             assert!(result.is_ok());\n             let mut fd = FileDescriptor(result.unwrap() as i32);\n@@ -378,7 +378,7 @@ mod test {\n             let result = fd.close_sync(loop_);\n             assert!(result.is_ok());\n             // re-open\n-            let result = FileDescriptor::open_sync(loop_, &Path(path_str),\n+            let result = FsRequest::open_sync(loop_, &Path(path_str),\n                                                    read_flags as int,0);\n             assert!(result.is_ok());\n             let len = 1028;\n@@ -399,7 +399,7 @@ mod test {\n                 let result = fd.close_sync(loop_);\n                 assert!(result.is_ok());\n                 // unlink\n-                let result = FileDescriptor::unlink_sync(loop_, &Path(path_str));\n+                let result = FsRequest::unlink_sync(loop_, &Path(path_str));\n                 assert!(result.is_ok());\n             } else { fail!(\"nread was 0.. wudn't expectin' that.\"); }\n             loop_.close();"}, {"sha": "acdd8b2dabf9fada7aff635052f609757340e1f5", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f01e26535738601524deba9e5f0a496527ee9d92/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f01e26535738601524deba9e5f0a496527ee9d92/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=f01e26535738601524deba9e5f0a496527ee9d92", "patch": "@@ -477,7 +477,7 @@ impl IoFactory for UvIoFactory {\n         do scheduler.deschedule_running_task_and_then |_, task| {\n             let task_cell = Cell::new(task);\n             let path = path_cell.take();\n-            do file::FileDescriptor::open(loop_, path, flags, mode) |req,err| {\n+            do file::FsRequest::open(loop_, path, flags, mode) |req,err| {\n                 if err.is_none() {\n                     let home = get_handle_to_current_scheduler!();\n                     let fd = file::FileDescriptor(req.get_result());\n@@ -508,7 +508,7 @@ impl IoFactory for UvIoFactory {\n         do scheduler.deschedule_running_task_and_then |_, task| {\n             let task_cell = Cell::new(task);\n             let path = path_cell.take();\n-            do file::FileDescriptor::unlink(loop_, path) |_, err| {\n+            do file::FsRequest::unlink(loop_, path) |_, err| {\n                 let res = match err {\n                     None => Ok(()),\n                     Some(err) => Err(uv_error_to_io_error(err))"}]}