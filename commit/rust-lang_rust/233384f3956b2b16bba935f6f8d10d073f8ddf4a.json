{"sha": "233384f3956b2b16bba935f6f8d10d073f8ddf4a", "node_id": "C_kwDOAAsO6NoAKDIzMzM4NGYzOTU2YjJiMTZiYmE5MzVmNmY4ZDEwZDA3M2Y4ZGRmNGE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-06T23:11:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-06T23:11:18Z"}, "message": "Auto merge of #102729 - flip1995:clippyup, r=Manishearth\n\nUpdate Clippy\n\nr? `@Manishearth`", "tree": {"sha": "2c71b020004b163b2dd220a2782ebe236cd740aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2c71b020004b163b2dd220a2782ebe236cd740aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/233384f3956b2b16bba935f6f8d10d073f8ddf4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/233384f3956b2b16bba935f6f8d10d073f8ddf4a", "html_url": "https://github.com/rust-lang/rust/commit/233384f3956b2b16bba935f6f8d10d073f8ddf4a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/233384f3956b2b16bba935f6f8d10d073f8ddf4a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ca356586fed56002b10920fd21ddf6fb12de797", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ca356586fed56002b10920fd21ddf6fb12de797", "html_url": "https://github.com/rust-lang/rust/commit/0ca356586fed56002b10920fd21ddf6fb12de797"}, {"sha": "2b30ce04ac23aaea8d35502aa67079f1072cad2d", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b30ce04ac23aaea8d35502aa67079f1072cad2d", "html_url": "https://github.com/rust-lang/rust/commit/2b30ce04ac23aaea8d35502aa67079f1072cad2d"}], "stats": {"total": 14524, "additions": 10165, "deletions": 4359}, "files": [{"sha": "027121774d4eca618a47425bed45b59ee28a824b", "filename": "Cargo.lock", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -387,7 +387,7 @@ dependencies = [\n  \"directories\",\n  \"rustc-build-sysroot\",\n  \"rustc-workspace-hack\",\n- \"rustc_tools_util 0.2.1\",\n+ \"rustc_tools_util\",\n  \"rustc_version\",\n  \"serde\",\n  \"serde_json\",\n@@ -655,7 +655,7 @@ dependencies = [\n \n [[package]]\n name = \"clippy\"\n-version = \"0.1.65\"\n+version = \"0.1.66\"\n dependencies = [\n  \"clippy_lints\",\n  \"clippy_utils\",\n@@ -670,7 +670,7 @@ dependencies = [\n  \"regex\",\n  \"rustc-semver\",\n  \"rustc-workspace-hack\",\n- \"rustc_tools_util 0.2.0\",\n+ \"rustc_tools_util\",\n  \"semver\",\n  \"serde\",\n  \"syn\",\n@@ -698,7 +698,7 @@ dependencies = [\n \n [[package]]\n name = \"clippy_lints\"\n-version = \"0.1.65\"\n+version = \"0.1.66\"\n dependencies = [\n  \"cargo_metadata 0.14.0\",\n  \"clippy_utils\",\n@@ -720,7 +720,7 @@ dependencies = [\n \n [[package]]\n name = \"clippy_utils\"\n-version = \"0.1.65\"\n+version = \"0.1.66\"\n dependencies = [\n  \"arrayvec\",\n  \"if_chain\",\n@@ -829,9 +829,9 @@ dependencies = [\n \n [[package]]\n name = \"compiletest_rs\"\n-version = \"0.8.0\"\n+version = \"0.9.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"262134ef87408da1ddfe45e33daa0ca43b75286d6b1076446e602d264cf9847e\"\n+checksum = \"70489bbb718aea4f92e5f48f2e3b5be670c2051de30e57cb6e5377b4aa08b372\"\n dependencies = [\n  \"diff\",\n  \"filetime\",\n@@ -4162,10 +4162,6 @@ dependencies = [\n  \"tracing\",\n ]\n \n-[[package]]\n-name = \"rustc_tools_util\"\n-version = \"0.2.0\"\n-\n [[package]]\n name = \"rustc_tools_util\"\n version = \"0.2.1\""}, {"sha": "42615179f7053073fce07a19319a24216b159865", "filename": "src/tools/clippy/CHANGELOG.md", "status": "modified", "additions": 157, "deletions": 2, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2FCHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2FCHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FCHANGELOG.md?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -6,11 +6,161 @@ document.\n \n ## Unreleased / In Rust Nightly\n \n-[d7b5cbf0...master](https://github.com/rust-lang/rust-clippy/compare/d7b5cbf0...master)\n+[3c7e7dbc...master](https://github.com/rust-lang/rust-clippy/compare/3c7e7dbc...master)\n+\n+## Rust 1.64\n+\n+Current stable, released 2022-09-22\n+\n+[d7b5cbf0...3c7e7dbc](https://github.com/rust-lang/rust-clippy/compare/d7b5cbf0...3c7e7dbc)\n+\n+### New Lints\n+\n+* [`arithmetic_side_effects`]\n+  [#9130](https://github.com/rust-lang/rust-clippy/pull/9130)\n+* [`invalid_utf8_in_unchecked`]\n+  [#9105](https://github.com/rust-lang/rust-clippy/pull/9105)\n+* [`assertions_on_result_states`]\n+  [#9225](https://github.com/rust-lang/rust-clippy/pull/9225)\n+* [`manual_find`]\n+  [#8649](https://github.com/rust-lang/rust-clippy/pull/8649)\n+* [`manual_retain`]\n+  [#8972](https://github.com/rust-lang/rust-clippy/pull/8972)\n+* [`default_instead_of_iter_empty`]\n+  [#8989](https://github.com/rust-lang/rust-clippy/pull/8989)\n+* [`manual_rem_euclid`]\n+  [#9031](https://github.com/rust-lang/rust-clippy/pull/9031)\n+* [`obfuscated_if_else`]\n+  [#9148](https://github.com/rust-lang/rust-clippy/pull/9148)\n+* [`std_instead_of_core`]\n+  [#9103](https://github.com/rust-lang/rust-clippy/pull/9103)\n+* [`std_instead_of_alloc`]\n+  [#9103](https://github.com/rust-lang/rust-clippy/pull/9103)\n+* [`alloc_instead_of_core`]\n+  [#9103](https://github.com/rust-lang/rust-clippy/pull/9103)\n+* [`explicit_auto_deref`]\n+  [#8355](https://github.com/rust-lang/rust-clippy/pull/8355)\n+\n+\n+### Moves and Deprecations\n+\n+* Moved [`format_push_string`] to `restriction` (now allow-by-default)\n+  [#9161](https://github.com/rust-lang/rust-clippy/pull/9161)\n+\n+### Enhancements\n+\n+* [`significant_drop_in_scrutinee`]: Now gives more context in the lint message\n+  [#8981](https://github.com/rust-lang/rust-clippy/pull/8981)\n+* [`single_match`], [`single_match_else`]: Now catches more `Option` cases\n+  [#8985](https://github.com/rust-lang/rust-clippy/pull/8985)\n+* [`unused_async`]: Now works for async methods\n+  [#9025](https://github.com/rust-lang/rust-clippy/pull/9025)\n+* [`manual_filter_map`], [`manual_find_map`]: Now lint more expressions\n+  [#8958](https://github.com/rust-lang/rust-clippy/pull/8958)\n+* [`question_mark`]: Now works for simple `if let` expressions\n+  [#8356](https://github.com/rust-lang/rust-clippy/pull/8356)\n+* [`undocumented_unsafe_blocks`]: Now finds comments before the start of closures\n+  [#9117](https://github.com/rust-lang/rust-clippy/pull/9117)\n+* [`trait_duplication_in_bounds`]: Now catches duplicate bounds in where clauses\n+  [#8703](https://github.com/rust-lang/rust-clippy/pull/8703)\n+* [`shadow_reuse`], [`shadow_same`], [`shadow_unrelated`]: Now lint in const blocks\n+  [#9124](https://github.com/rust-lang/rust-clippy/pull/9124)\n+* [`slow_vector_initialization`]: Now detects cases with `vec.capacity()`\n+  [#8953](https://github.com/rust-lang/rust-clippy/pull/8953)\n+* [`unused_self`]: Now respects the `avoid-breaking-exported-api` config option\n+  [#9199](https://github.com/rust-lang/rust-clippy/pull/9199)\n+* [`box_collection`]: Now supports all std collections\n+  [#9170](https://github.com/rust-lang/rust-clippy/pull/9170)\n+\n+### False Positive Fixes\n+\n+* [`significant_drop_in_scrutinee`]: Now ignores calls to `IntoIterator::into_iter`\n+  [#9140](https://github.com/rust-lang/rust-clippy/pull/9140)\n+* [`while_let_loop`]: Now ignores cases when the significant drop order would change\n+  [#8981](https://github.com/rust-lang/rust-clippy/pull/8981)\n+* [`branches_sharing_code`]: Now ignores cases where moved variables have a significant\n+  drop or variable modifications can affect the conditions\n+  [#9138](https://github.com/rust-lang/rust-clippy/pull/9138)\n+* [`let_underscore_lock`]: Now ignores bindings that aren't locked\n+  [#8990](https://github.com/rust-lang/rust-clippy/pull/8990)\n+* [`trivially_copy_pass_by_ref`]: Now tracks lifetimes and ignores cases where unsafe\n+  pointers are used\n+  [#8639](https://github.com/rust-lang/rust-clippy/pull/8639)\n+* [`let_unit_value`]: No longer ignores `#[allow]` attributes on the value\n+  [#9082](https://github.com/rust-lang/rust-clippy/pull/9082)\n+* [`declare_interior_mutable_const`]: Now ignores the `thread_local!` macro\n+  [#9015](https://github.com/rust-lang/rust-clippy/pull/9015)\n+* [`if_same_then_else`]: Now ignores branches with `todo!` and `unimplemented!`\n+  [#9006](https://github.com/rust-lang/rust-clippy/pull/9006)\n+* [`enum_variant_names`]: Now ignores names with `_` prefixes\n+  [#9032](https://github.com/rust-lang/rust-clippy/pull/9032)\n+* [`let_unit_value`]: Now ignores cases, where the unit type is manually specified\n+  [#9056](https://github.com/rust-lang/rust-clippy/pull/9056)\n+* [`match_same_arms`]: Now ignores branches with `todo!`\n+  [#9207](https://github.com/rust-lang/rust-clippy/pull/9207)\n+* [`assign_op_pattern`]: Ignores cases that break borrowing rules\n+  [#9214](https://github.com/rust-lang/rust-clippy/pull/9214)\n+* [`extra_unused_lifetimes`]: No longer triggers in derive macros\n+  [#9037](https://github.com/rust-lang/rust-clippy/pull/9037)\n+* [`mismatching_type_param_order`]: Now ignores complicated generic parameters\n+  [#9146](https://github.com/rust-lang/rust-clippy/pull/9146)\n+* [`equatable_if_let`]: No longer lints in macros\n+  [#9074](https://github.com/rust-lang/rust-clippy/pull/9074)\n+* [`new_without_default`]: Now ignores generics and lifetime parameters on `fn new`\n+  [#9115](https://github.com/rust-lang/rust-clippy/pull/9115)\n+* [`needless_borrow`]: Now ignores cases that result in the execution of different traits\n+  [#9096](https://github.com/rust-lang/rust-clippy/pull/9096)\n+* [`declare_interior_mutable_const`]: No longer triggers in thread-local initializers\n+  [#9246](https://github.com/rust-lang/rust-clippy/pull/9246)\n+\n+### Suggestion Fixes/Improvements\n+\n+* [`type_repetition_in_bounds`]: The suggestion now works with maybe bounds\n+  [#9132](https://github.com/rust-lang/rust-clippy/pull/9132)\n+* [`transmute_ptr_to_ref`]: Now suggests `pointer::cast` when possible\n+  [#8939](https://github.com/rust-lang/rust-clippy/pull/8939)\n+* [`useless_format`]: Now suggests the correct variable name\n+  [#9237](https://github.com/rust-lang/rust-clippy/pull/9237)\n+* [`or_fun_call`]: The lint emission will now only span over the `unwrap_or` call\n+  [#9144](https://github.com/rust-lang/rust-clippy/pull/9144)\n+* [`neg_multiply`]: Now suggests adding parentheses around suggestion if needed\n+  [#9026](https://github.com/rust-lang/rust-clippy/pull/9026)\n+* [`unnecessary_lazy_evaluations`]: Now suggest for `bool::then_some` for lazy evaluation\n+  [#9099](https://github.com/rust-lang/rust-clippy/pull/9099)\n+* [`manual_flatten`]: Improved message for long code snippets\n+  [#9156](https://github.com/rust-lang/rust-clippy/pull/9156)\n+* [`explicit_counter_loop`]: The suggestion is now machine applicable\n+  [#9149](https://github.com/rust-lang/rust-clippy/pull/9149)\n+* [`needless_borrow`]: Now keeps parentheses around fields, when needed\n+  [#9210](https://github.com/rust-lang/rust-clippy/pull/9210)\n+* [`while_let_on_iterator`]: The suggestion now works in `FnOnce` closures\n+  [#9134](https://github.com/rust-lang/rust-clippy/pull/9134)\n+\n+### ICE Fixes\n+\n+* Fix ICEs related to `#![feature(generic_const_exprs)]` usage\n+  [#9241](https://github.com/rust-lang/rust-clippy/pull/9241)\n+* Fix ICEs related to reference lints\n+  [#9093](https://github.com/rust-lang/rust-clippy/pull/9093)\n+* [`question_mark`]: Fix ICE on zero field tuple structs\n+  [#9244](https://github.com/rust-lang/rust-clippy/pull/9244)\n+\n+### Documentation Improvements\n+\n+* [`needless_option_take`]: Now includes a \"What it does\" and \"Why is this bad?\" section.\n+  [#9022](https://github.com/rust-lang/rust-clippy/pull/9022)\n+\n+### Others\n+\n+* Using `--cap-lints=allow` and only `--force-warn`ing some will now work with Clippy's driver\n+  [#9036](https://github.com/rust-lang/rust-clippy/pull/9036)\n+* Clippy now tries to read the `rust-version` from `Cargo.toml` to identify the\n+  minimum supported rust version\n+  [#8774](https://github.com/rust-lang/rust-clippy/pull/8774)\n \n ## Rust 1.63\n \n-Current stable, released 2022-08-11\n+Released 2022-08-11\n \n [7c21f91b...d7b5cbf0](https://github.com/rust-lang/rust-clippy/compare/7c21f91b...d7b5cbf0)\n \n@@ -3609,6 +3759,7 @@ Released 2018-09-13\n [`borrow_interior_mutable_const`]: https://rust-lang.github.io/rust-clippy/master/index.html#borrow_interior_mutable_const\n [`borrowed_box`]: https://rust-lang.github.io/rust-clippy/master/index.html#borrowed_box\n [`box_collection`]: https://rust-lang.github.io/rust-clippy/master/index.html#box_collection\n+[`box_default`]: https://rust-lang.github.io/rust-clippy/master/index.html#box_default\n [`box_vec`]: https://rust-lang.github.io/rust-clippy/master/index.html#box_vec\n [`boxed_local`]: https://rust-lang.github.io/rust-clippy/master/index.html#boxed_local\n [`branches_sharing_code`]: https://rust-lang.github.io/rust-clippy/master/index.html#branches_sharing_code\n@@ -3669,6 +3820,7 @@ Released 2018-09-13\n [`derive_hash_xor_eq`]: https://rust-lang.github.io/rust-clippy/master/index.html#derive_hash_xor_eq\n [`derive_ord_xor_partial_ord`]: https://rust-lang.github.io/rust-clippy/master/index.html#derive_ord_xor_partial_ord\n [`derive_partial_eq_without_eq`]: https://rust-lang.github.io/rust-clippy/master/index.html#derive_partial_eq_without_eq\n+[`disallowed_macros`]: https://rust-lang.github.io/rust-clippy/master/index.html#disallowed_macros\n [`disallowed_method`]: https://rust-lang.github.io/rust-clippy/master/index.html#disallowed_method\n [`disallowed_methods`]: https://rust-lang.github.io/rust-clippy/master/index.html#disallowed_methods\n [`disallowed_names`]: https://rust-lang.github.io/rust-clippy/master/index.html#disallowed_names\n@@ -3766,6 +3918,7 @@ Released 2018-09-13\n [`implicit_clone`]: https://rust-lang.github.io/rust-clippy/master/index.html#implicit_clone\n [`implicit_hasher`]: https://rust-lang.github.io/rust-clippy/master/index.html#implicit_hasher\n [`implicit_return`]: https://rust-lang.github.io/rust-clippy/master/index.html#implicit_return\n+[`implicit_saturating_add`]: https://rust-lang.github.io/rust-clippy/master/index.html#implicit_saturating_add\n [`implicit_saturating_sub`]: https://rust-lang.github.io/rust-clippy/master/index.html#implicit_saturating_sub\n [`imprecise_flops`]: https://rust-lang.github.io/rust-clippy/master/index.html#imprecise_flops\n [`inconsistent_digit_grouping`]: https://rust-lang.github.io/rust-clippy/master/index.html#inconsistent_digit_grouping\n@@ -3834,6 +3987,7 @@ Released 2018-09-13\n [`manual_assert`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_assert\n [`manual_async_fn`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_async_fn\n [`manual_bits`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_bits\n+[`manual_clamp`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_clamp\n [`manual_filter_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_filter_map\n [`manual_find`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_find\n [`manual_find_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_find_map\n@@ -4124,6 +4278,7 @@ Released 2018-09-13\n [`unimplemented`]: https://rust-lang.github.io/rust-clippy/master/index.html#unimplemented\n [`uninit_assumed_init`]: https://rust-lang.github.io/rust-clippy/master/index.html#uninit_assumed_init\n [`uninit_vec`]: https://rust-lang.github.io/rust-clippy/master/index.html#uninit_vec\n+[`uninlined_format_args`]: https://rust-lang.github.io/rust-clippy/master/index.html#uninlined_format_args\n [`unit_arg`]: https://rust-lang.github.io/rust-clippy/master/index.html#unit_arg\n [`unit_cmp`]: https://rust-lang.github.io/rust-clippy/master/index.html#unit_cmp\n [`unit_hash`]: https://rust-lang.github.io/rust-clippy/master/index.html#unit_hash"}, {"sha": "60200a88b85829b6b7cf883829791d7ebc626ed2", "filename": "src/tools/clippy/Cargo.toml", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FCargo.toml?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy\"\n-version = \"0.1.65\"\n+version = \"0.1.66\"\n description = \"A bunch of helpful lints to avoid common pitfalls in Rust\"\n repository = \"https://github.com/rust-lang/rust-clippy\"\n readme = \"README.md\"\n@@ -23,12 +23,12 @@ path = \"src/driver.rs\"\n [dependencies]\n clippy_lints = { path = \"clippy_lints\" }\n semver = \"1.0\"\n-rustc_tools_util = { path = \"rustc_tools_util\" }\n+rustc_tools_util = \"0.2.1\"\n tempfile = { version = \"3.2\", optional = true }\n termize = \"0.1\"\n \n [dev-dependencies]\n-compiletest_rs = { version = \"0.8\", features = [\"tmp\"] }\n+compiletest_rs = { version = \"0.9\", features = [\"tmp\"] }\n tester = \"0.9\"\n regex = \"1.5\"\n toml = \"0.5\"\n@@ -55,7 +55,7 @@ tokio = { version = \"1\", features = [\"io-util\"] }\n rustc-semver = \"1.1\"\n \n [build-dependencies]\n-rustc_tools_util = { version = \"0.2\", path = \"rustc_tools_util\" }\n+rustc_tools_util = \"0.2.1\"\n \n [features]\n deny-warnings = [\"clippy_lints/deny-warnings\"]"}, {"sha": "a8a6b86d2a15b73da47061a1eb20810aa9aa3268", "filename": "src/tools/clippy/README.md", "status": "modified", "additions": 27, "deletions": 19, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FREADME.md?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -139,25 +139,6 @@ line. (You can swap `clippy::all` with the specific lint category you are target\n \n ## Configuration\n \n-Some lints can be configured in a TOML file named `clippy.toml` or `.clippy.toml`. It contains a basic `variable =\n-value` mapping e.g.\n-\n-```toml\n-avoid-breaking-exported-api = false\n-disallowed-names = [\"toto\", \"tata\", \"titi\"]\n-cognitive-complexity-threshold = 30\n-```\n-\n-See the [list of lints](https://rust-lang.github.io/rust-clippy/master/index.html) for more information about which\n-lints can be configured and the meaning of the variables.\n-\n-Note that configuration changes will not apply for code that has already been compiled and cached under `./target/`;\n-for example, adding a new string to `doc-valid-idents` may still result in Clippy flagging that string. To be sure that\n-any configuration changes are applied, you may want to run `cargo clean` and re-compile your crate from scratch.\n-\n-To deactivate the \u201cfor further information visit *lint-link*\u201d message you can\n-define the `CLIPPY_DISABLE_DOCS_LINKS` environment variable.\n-\n ### Allowing/denying lints\n \n You can add options to your code to `allow`/`warn`/`deny` Clippy lints:\n@@ -205,6 +186,33 @@ the lint(s) you are interested in:\n cargo clippy -- -A clippy::all -W clippy::useless_format -W clippy::...\n ```\n \n+### Configure the behavior of some lints\n+\n+Some lints can be configured in a TOML file named `clippy.toml` or `.clippy.toml`. It contains a basic `variable =\n+value` mapping e.g.\n+\n+```toml\n+avoid-breaking-exported-api = false\n+disallowed-names = [\"toto\", \"tata\", \"titi\"]\n+cognitive-complexity-threshold = 30\n+```\n+\n+See the [list of lints](https://rust-lang.github.io/rust-clippy/master/index.html) for more information about which\n+lints can be configured and the meaning of the variables.\n+\n+> **Note**\n+>\n+> `clippy.toml` or `.clippy.toml` cannot be used to allow/deny lints.\n+\n+> **Note**\n+>\n+> Configuration changes will not apply for code that has already been compiled and cached under `./target/`;\n+> for example, adding a new string to `doc-valid-idents` may still result in Clippy flagging that string. To be sure\n+> that any configuration changes are applied, you may want to run `cargo clean` and re-compile your crate from scratch.\n+\n+To deactivate the \u201cfor further information visit *lint-link*\u201d message you can\n+define the `CLIPPY_DISABLE_DOCS_LINKS` environment variable.\n+\n ### Specifying the minimum supported Rust version\n \n Projects that intend to support old versions of Rust can disable lints pertaining to newer features by"}, {"sha": "2562314418172b67b8d8aaf1cc5ba68d281d1f4d", "filename": "src/tools/clippy/clippy_dev/src/fmt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Ffmt.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -82,16 +82,16 @@ pub fn run(check: bool, verbose: bool) {\n     fn output_err(err: CliError) {\n         match err {\n             CliError::CommandFailed(command, stderr) => {\n-                eprintln!(\"error: A command failed! `{}`\\nstderr: {}\", command, stderr);\n+                eprintln!(\"error: A command failed! `{command}`\\nstderr: {stderr}\");\n             },\n             CliError::IoError(err) => {\n-                eprintln!(\"error: {}\", err);\n+                eprintln!(\"error: {err}\");\n             },\n             CliError::RustfmtNotInstalled => {\n                 eprintln!(\"error: rustfmt nightly is not installed.\");\n             },\n             CliError::WalkDirError(err) => {\n-                eprintln!(\"error: {}\", err);\n+                eprintln!(\"error: {err}\");\n             },\n             CliError::IntellijSetupActive => {\n                 eprintln!("}, {"sha": "d3e036692040f6f03294892956ef1de9cd3e812f", "filename": "src/tools/clippy/clippy_dev/src/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fmain.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -41,7 +41,7 @@ fn main() {\n                 matches.contains_id(\"msrv\"),\n             ) {\n                 Ok(_) => update_lints::update(update_lints::UpdateMode::Change),\n-                Err(e) => eprintln!(\"Unable to create lint: {}\", e),\n+                Err(e) => eprintln!(\"Unable to create lint: {e}\"),\n             }\n         },\n         Some((\"setup\", sub_command)) => match sub_command.subcommand() {"}, {"sha": "9e15f1504fa91f6e6f2c883380f52d5355862c7a", "filename": "src/tools/clippy/clippy_dev/src/new_lint.rs", "status": "modified", "additions": 74, "deletions": 93, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fnew_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fnew_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fnew_lint.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -1,5 +1,5 @@\n use crate::clippy_project_root;\n-use indoc::{indoc, writedoc};\n+use indoc::{formatdoc, writedoc};\n use std::fmt::Write as _;\n use std::fs::{self, OpenOptions};\n use std::io::prelude::*;\n@@ -23,7 +23,7 @@ impl<T> Context for io::Result<T> {\n         match self {\n             Ok(t) => Ok(t),\n             Err(e) => {\n-                let message = format!(\"{}: {}\", text.as_ref(), e);\n+                let message = format!(\"{}: {e}\", text.as_ref());\n                 Err(io::Error::new(ErrorKind::Other, message))\n             },\n         }\n@@ -72,7 +72,7 @@ fn create_lint(lint: &LintData<'_>, enable_msrv: bool) -> io::Result<()> {\n         let lint_contents = get_lint_file_contents(lint, enable_msrv);\n         let lint_path = format!(\"clippy_lints/src/{}.rs\", lint.name);\n         write_file(lint.project_root.join(&lint_path), lint_contents.as_bytes())?;\n-        println!(\"Generated lint file: `{}`\", lint_path);\n+        println!(\"Generated lint file: `{lint_path}`\");\n \n         Ok(())\n     }\n@@ -86,7 +86,7 @@ fn create_test(lint: &LintData<'_>) -> io::Result<()> {\n \n         path.push(\"src\");\n         fs::create_dir(&path)?;\n-        let header = format!(\"// compile-flags: --crate-name={}\", lint_name);\n+        let header = format!(\"// compile-flags: --crate-name={lint_name}\");\n         write_file(path.join(\"main.rs\"), get_test_file_contents(lint_name, Some(&header)))?;\n \n         Ok(())\n@@ -106,7 +106,7 @@ fn create_test(lint: &LintData<'_>) -> io::Result<()> {\n         let test_contents = get_test_file_contents(lint.name, None);\n         write_file(lint.project_root.join(&test_path), test_contents)?;\n \n-        println!(\"Generated test file: `{}`\", test_path);\n+        println!(\"Generated test file: `{test_path}`\");\n     }\n \n     Ok(())\n@@ -186,38 +186,36 @@ pub(crate) fn get_stabilization_version() -> String {\n }\n \n fn get_test_file_contents(lint_name: &str, header_commands: Option<&str>) -> String {\n-    let mut contents = format!(\n-        indoc! {\"\n-            #![allow(unused)]\n-            #![warn(clippy::{})]\n-\n-            fn main() {{\n-                // test code goes here\n-            }}\n-        \"},\n-        lint_name\n+    let mut contents = formatdoc!(\n+        r#\"\n+        #![allow(unused)]\n+        #![warn(clippy::{lint_name})]\n+\n+        fn main() {{\n+            // test code goes here\n+        }}\n+    \"#\n     );\n \n     if let Some(header) = header_commands {\n-        contents = format!(\"{}\\n{}\", header, contents);\n+        contents = format!(\"{header}\\n{contents}\");\n     }\n \n     contents\n }\n \n fn get_manifest_contents(lint_name: &str, hint: &str) -> String {\n-    format!(\n-        indoc! {r#\"\n-            # {}\n-\n-            [package]\n-            name = \"{}\"\n-            version = \"0.1.0\"\n-            publish = false\n-\n-            [workspace]\n-        \"#},\n-        hint, lint_name\n+    formatdoc!(\n+        r#\"\n+        # {hint}\n+\n+        [package]\n+        name = \"{lint_name}\"\n+        version = \"0.1.0\"\n+        publish = false\n+\n+        [workspace]\n+    \"#\n     )\n }\n \n@@ -238,85 +236,70 @@ fn get_lint_file_contents(lint: &LintData<'_>, enable_msrv: bool) -> String {\n     let name_upper = lint_name.to_uppercase();\n \n     result.push_str(&if enable_msrv {\n-        format!(\n-            indoc! {\"\n-                use clippy_utils::msrvs;\n-                {pass_import}\n-                use rustc_lint::{{{context_import}, {pass_type}, LintContext}};\n-                use rustc_semver::RustcVersion;\n-                use rustc_session::{{declare_tool_lint, impl_lint_pass}};\n+        formatdoc!(\n+            r#\"\n+            use clippy_utils::msrvs;\n+            {pass_import}\n+            use rustc_lint::{{{context_import}, {pass_type}, LintContext}};\n+            use rustc_semver::RustcVersion;\n+            use rustc_session::{{declare_tool_lint, impl_lint_pass}};\n \n-            \"},\n-            pass_type = pass_type,\n-            pass_import = pass_import,\n-            context_import = context_import,\n+        \"#\n         )\n     } else {\n-        format!(\n-            indoc! {\"\n-                {pass_import}\n-                use rustc_lint::{{{context_import}, {pass_type}}};\n-                use rustc_session::{{declare_lint_pass, declare_tool_lint}};\n-\n-            \"},\n-            pass_import = pass_import,\n-            pass_type = pass_type,\n-            context_import = context_import\n+        formatdoc!(\n+            r#\"\n+            {pass_import}\n+            use rustc_lint::{{{context_import}, {pass_type}}};\n+            use rustc_session::{{declare_lint_pass, declare_tool_lint}};\n+\n+        \"#\n         )\n     });\n \n     let _ = write!(result, \"{}\", get_lint_declaration(&name_upper, category));\n \n     result.push_str(&if enable_msrv {\n-        format!(\n-            indoc! {\"\n-                pub struct {name_camel} {{\n-                    msrv: Option<RustcVersion>,\n-                }}\n+        formatdoc!(\n+            r#\"\n+            pub struct {name_camel} {{\n+                msrv: Option<RustcVersion>,\n+            }}\n \n-                impl {name_camel} {{\n-                    #[must_use]\n-                    pub fn new(msrv: Option<RustcVersion>) -> Self {{\n-                        Self {{ msrv }}\n-                    }}\n+            impl {name_camel} {{\n+                #[must_use]\n+                pub fn new(msrv: Option<RustcVersion>) -> Self {{\n+                    Self {{ msrv }}\n                 }}\n+            }}\n \n-                impl_lint_pass!({name_camel} => [{name_upper}]);\n+            impl_lint_pass!({name_camel} => [{name_upper}]);\n \n-                impl {pass_type}{pass_lifetimes} for {name_camel} {{\n-                    extract_msrv_attr!({context_import});\n-                }}\n+            impl {pass_type}{pass_lifetimes} for {name_camel} {{\n+                extract_msrv_attr!({context_import});\n+            }}\n \n-                // TODO: Add MSRV level to `clippy_utils/src/msrvs.rs` if needed.\n-                // TODO: Add MSRV test to `tests/ui/min_rust_version_attr.rs`.\n-                // TODO: Update msrv config comment in `clippy_lints/src/utils/conf.rs`\n-            \"},\n-            pass_type = pass_type,\n-            pass_lifetimes = pass_lifetimes,\n-            name_upper = name_upper,\n-            name_camel = name_camel,\n-            context_import = context_import,\n+            // TODO: Add MSRV level to `clippy_utils/src/msrvs.rs` if needed.\n+            // TODO: Add MSRV test to `tests/ui/min_rust_version_attr.rs`.\n+            // TODO: Update msrv config comment in `clippy_lints/src/utils/conf.rs`\n+        \"#\n         )\n     } else {\n-        format!(\n-            indoc! {\"\n-                declare_lint_pass!({name_camel} => [{name_upper}]);\n+        formatdoc!(\n+            r#\"\n+            declare_lint_pass!({name_camel} => [{name_upper}]);\n \n-                impl {pass_type}{pass_lifetimes} for {name_camel} {{}}\n-            \"},\n-            pass_type = pass_type,\n-            pass_lifetimes = pass_lifetimes,\n-            name_upper = name_upper,\n-            name_camel = name_camel,\n+            impl {pass_type}{pass_lifetimes} for {name_camel} {{}}\n+        \"#\n         )\n     });\n \n     result\n }\n \n fn get_lint_declaration(name_upper: &str, category: &str) -> String {\n-    format!(\n-        indoc! {r#\"\n+    formatdoc!(\n+        r#\"\n             declare_clippy_lint! {{\n                 /// ### What it does\n                 ///\n@@ -330,15 +313,13 @@ fn get_lint_declaration(name_upper: &str, category: &str) -> String {\n                 /// ```rust\n                 /// // example code which does not raise clippy warning\n                 /// ```\n-                #[clippy::version = \"{version}\"]\n+                #[clippy::version = \"{}\"]\n                 pub {name_upper},\n                 {category},\n                 \"default lint description\"\n             }}\n-        \"#},\n-        version = get_stabilization_version(),\n-        name_upper = name_upper,\n-        category = category,\n+        \"#,\n+        get_stabilization_version(),\n     )\n }\n \n@@ -352,7 +333,7 @@ fn create_lint_for_ty(lint: &LintData<'_>, enable_msrv: bool, ty: &str) -> io::R\n         _ => {},\n     }\n \n-    let ty_dir = lint.project_root.join(format!(\"clippy_lints/src/{}\", ty));\n+    let ty_dir = lint.project_root.join(format!(\"clippy_lints/src/{ty}\"));\n     assert!(\n         ty_dir.exists() && ty_dir.is_dir(),\n         \"Directory `{}` does not exist!\",\n@@ -412,10 +393,10 @@ fn create_lint_for_ty(lint: &LintData<'_>, enable_msrv: bool, ty: &str) -> io::R\n     }\n \n     write_file(lint_file_path.as_path(), lint_file_contents)?;\n-    println!(\"Generated lint file: `clippy_lints/src/{}/{}.rs`\", ty, lint.name);\n+    println!(\"Generated lint file: `clippy_lints/src/{ty}/{}.rs`\", lint.name);\n     println!(\n-        \"Be sure to add a call to `{}::check` in `clippy_lints/src/{}/mod.rs`!\",\n-        lint.name, ty\n+        \"Be sure to add a call to `{}::check` in `clippy_lints/src/{ty}/mod.rs`!\",\n+        lint.name\n     );\n \n     Ok(())\n@@ -542,7 +523,7 @@ fn setup_mod_file(path: &Path, lint: &LintData<'_>) -> io::Result<&'static str>\n         .chain(std::iter::once(&*lint_name_upper))\n         .filter(|s| !s.is_empty())\n     {\n-        let _ = write!(new_arr_content, \"\\n    {},\", ident);\n+        let _ = write!(new_arr_content, \"\\n    {ident},\");\n     }\n     new_arr_content.push('\\n');\n "}, {"sha": "2e0794f12fa19c2eab6c7f1463ed8e0c9530637c", "filename": "src/tools/clippy/clippy_dev/src/serve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fserve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fserve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fserve.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -10,8 +10,8 @@ use std::time::{Duration, SystemTime};\n /// Panics if the python commands could not be spawned\n pub fn run(port: u16, lint: Option<&String>) -> ! {\n     let mut url = Some(match lint {\n-        None => format!(\"http://localhost:{}\", port),\n-        Some(lint) => format!(\"http://localhost:{}/#{}\", port, lint),\n+        None => format!(\"http://localhost:{port}\"),\n+        Some(lint) => format!(\"http://localhost:{port}/#{lint}\"),\n     });\n \n     loop {"}, {"sha": "1de5b1940bae1a7e1595490f4411afb3347a45b7", "filename": "src/tools/clippy/clippy_dev/src/setup/git_hook.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fsetup%2Fgit_hook.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fsetup%2Fgit_hook.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fsetup%2Fgit_hook.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -30,10 +30,7 @@ pub fn install_hook(force_override: bool) {\n             println!(\"info: the hook can be removed with `cargo dev remove git-hook`\");\n             println!(\"git hook successfully installed\");\n         },\n-        Err(err) => eprintln!(\n-            \"error: unable to copy `{}` to `{}` ({})\",\n-            HOOK_SOURCE_FILE, HOOK_TARGET_FILE, err\n-        ),\n+        Err(err) => eprintln!(\"error: unable to copy `{HOOK_SOURCE_FILE}` to `{HOOK_TARGET_FILE}` ({err})\"),\n     }\n }\n \n@@ -77,7 +74,7 @@ pub fn remove_hook() {\n \n fn delete_git_hook_file(path: &Path) -> bool {\n     if let Err(err) = fs::remove_file(path) {\n-        eprintln!(\"error: unable to delete existing pre-commit git hook ({})\", err);\n+        eprintln!(\"error: unable to delete existing pre-commit git hook ({err})\");\n         false\n     } else {\n         true"}, {"sha": "b64e79733eb2453ecc1c1741b71eb6d12a7e858a", "filename": "src/tools/clippy/clippy_dev/src/setup/intellij.rs", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fsetup%2Fintellij.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fsetup%2Fintellij.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fsetup%2Fintellij.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -60,7 +60,7 @@ fn check_and_get_rustc_dir(rustc_path: &str) -> Result<PathBuf, ()> {\n                 path = absolute_path;\n             },\n             Err(err) => {\n-                eprintln!(\"error: unable to get the absolute path of rustc ({})\", err);\n+                eprintln!(\"error: unable to get the absolute path of rustc ({err})\");\n                 return Err(());\n             },\n         };\n@@ -103,14 +103,14 @@ fn inject_deps_into_project(rustc_source_dir: &Path, project: &ClippyProjectInfo\n fn read_project_file(file_path: &str) -> Result<String, ()> {\n     let path = Path::new(file_path);\n     if !path.exists() {\n-        eprintln!(\"error: unable to find the file `{}`\", file_path);\n+        eprintln!(\"error: unable to find the file `{file_path}`\");\n         return Err(());\n     }\n \n     match fs::read_to_string(path) {\n         Ok(content) => Ok(content),\n         Err(err) => {\n-            eprintln!(\"error: the file `{}` could not be read ({})\", file_path, err);\n+            eprintln!(\"error: the file `{file_path}` could not be read ({err})\");\n             Err(())\n         },\n     }\n@@ -124,10 +124,7 @@ fn inject_deps_into_manifest(\n ) -> std::io::Result<()> {\n     // do not inject deps if we have already done so\n     if cargo_toml.contains(RUSTC_PATH_SECTION) {\n-        eprintln!(\n-            \"warn: dependencies are already setup inside {}, skipping file\",\n-            manifest_path\n-        );\n+        eprintln!(\"warn: dependencies are already setup inside {manifest_path}, skipping file\");\n         return Ok(());\n     }\n \n@@ -142,11 +139,7 @@ fn inject_deps_into_manifest(\n \n     let new_deps = extern_crates.map(|dep| {\n         // format the dependencies that are going to be put inside the Cargo.toml\n-        format!(\n-            \"{dep} = {{ path = \\\"{source_path}/{dep}\\\" }}\\n\",\n-            dep = dep,\n-            source_path = rustc_source_dir.display()\n-        )\n+        format!(\"{dep} = {{ path = \\\"{}/{dep}\\\" }}\\n\", rustc_source_dir.display())\n     });\n \n     // format a new [dependencies]-block with the new deps we need to inject\n@@ -163,11 +156,11 @@ fn inject_deps_into_manifest(\n     // etc\n     let new_manifest = cargo_toml.replacen(\"[dependencies]\\n\", &all_deps, 1);\n \n-    // println!(\"{}\", new_manifest);\n+    // println!(\"{new_manifest}\");\n     let mut file = File::create(manifest_path)?;\n     file.write_all(new_manifest.as_bytes())?;\n \n-    println!(\"info: successfully setup dependencies inside {}\", manifest_path);\n+    println!(\"info: successfully setup dependencies inside {manifest_path}\");\n \n     Ok(())\n }\n@@ -214,8 +207,8 @@ fn remove_rustc_src_from_project(project: &ClippyProjectInfo) -> bool {\n         },\n         Err(err) => {\n             eprintln!(\n-                \"error: unable to open file `{}` to remove rustc dependencies for {} ({})\",\n-                project.cargo_file, project.name, err\n+                \"error: unable to open file `{}` to remove rustc dependencies for {} ({err})\",\n+                project.cargo_file, project.name\n             );\n             false\n         },"}, {"sha": "dbcdc9b59e529cedc693e813bb40adeea591b549", "filename": "src/tools/clippy/clippy_dev/src/setup/vscode.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fsetup%2Fvscode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fsetup%2Fvscode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fsetup%2Fvscode.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -17,10 +17,7 @@ pub fn install_tasks(force_override: bool) {\n             println!(\"info: the task file can be removed with `cargo dev remove vscode-tasks`\");\n             println!(\"vscode tasks successfully installed\");\n         },\n-        Err(err) => eprintln!(\n-            \"error: unable to copy `{}` to `{}` ({})\",\n-            TASK_SOURCE_FILE, TASK_TARGET_FILE, err\n-        ),\n+        Err(err) => eprintln!(\"error: unable to copy `{TASK_SOURCE_FILE}` to `{TASK_TARGET_FILE}` ({err})\"),\n     }\n }\n \n@@ -44,23 +41,17 @@ fn check_install_precondition(force_override: bool) -> bool {\n                 return delete_vs_task_file(path);\n             }\n \n-            eprintln!(\n-                \"error: there is already a `task.json` file inside the `{}` directory\",\n-                VSCODE_DIR\n-            );\n+            eprintln!(\"error: there is already a `task.json` file inside the `{VSCODE_DIR}` directory\");\n             println!(\"info: use the `--force-override` flag to override the existing `task.json` file\");\n             return false;\n         }\n     } else {\n         match fs::create_dir(vs_dir_path) {\n             Ok(_) => {\n-                println!(\"info: created `{}` directory for clippy\", VSCODE_DIR);\n+                println!(\"info: created `{VSCODE_DIR}` directory for clippy\");\n             },\n             Err(err) => {\n-                eprintln!(\n-                    \"error: the task target directory `{}` could not be created ({})\",\n-                    VSCODE_DIR, err\n-                );\n+                eprintln!(\"error: the task target directory `{VSCODE_DIR}` could not be created ({err})\");\n             },\n         }\n     }\n@@ -82,7 +73,7 @@ pub fn remove_tasks() {\n \n fn delete_vs_task_file(path: &Path) -> bool {\n     if let Err(err) = fs::remove_file(path) {\n-        eprintln!(\"error: unable to delete the existing `tasks.json` file ({})\", err);\n+        eprintln!(\"error: unable to delete the existing `tasks.json` file ({err})\");\n         return false;\n     }\n "}, {"sha": "0eb443167ecf3ffcb4f26d8f1f42007cffe55b43", "filename": "src/tools/clippy/clippy_dev/src/update_lints.rs", "status": "modified", "additions": 48, "deletions": 55, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fupdate_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fupdate_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fupdate_lints.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -45,9 +45,8 @@ fn generate_lint_files(\n     renamed_lints: &[RenamedLint],\n ) {\n     let internal_lints = Lint::internal_lints(lints);\n-    let usable_lints = Lint::usable_lints(lints);\n-    let mut sorted_usable_lints = usable_lints.clone();\n-    sorted_usable_lints.sort_by_key(|lint| lint.name.clone());\n+    let mut usable_lints = Lint::usable_lints(lints);\n+    usable_lints.sort_by_key(|lint| lint.name.clone());\n \n     replace_region_in_file(\n         update_mode,\n@@ -86,7 +85,7 @@ fn generate_lint_files(\n                 )\n                 .sorted()\n             {\n-                writeln!(res, \"[`{}`]: {}#{}\", lint, DOCS_LINK, lint).unwrap();\n+                writeln!(res, \"[`{lint}`]: {DOCS_LINK}#{lint}\").unwrap();\n             }\n         },\n     );\n@@ -99,7 +98,7 @@ fn generate_lint_files(\n         \"// end lints modules, do not remove this comment, it\u2019s used in `update_lints`\",\n         |res| {\n             for lint_mod in usable_lints.iter().map(|l| &l.module).unique().sorted() {\n-                writeln!(res, \"mod {};\", lint_mod).unwrap();\n+                writeln!(res, \"mod {lint_mod};\").unwrap();\n             }\n         },\n     );\n@@ -129,7 +128,7 @@ fn generate_lint_files(\n     for (lint_group, lints) in Lint::by_lint_group(usable_lints.into_iter().chain(internal_lints)) {\n         let content = gen_lint_group_list(&lint_group, lints.iter());\n         process_file(\n-            &format!(\"clippy_lints/src/lib.register_{}.rs\", lint_group),\n+            &format!(\"clippy_lints/src/lib.register_{lint_group}.rs\"),\n             update_mode,\n             &content,\n         );\n@@ -190,9 +189,9 @@ fn print_lint_names(header: &str, lints: &BTreeSet<String>) -> bool {\n     if lints.is_empty() {\n         return false;\n     }\n-    println!(\"{}\", header);\n+    println!(\"{header}\");\n     for lint in lints.iter().sorted() {\n-        println!(\"    {}\", lint);\n+        println!(\"    {lint}\");\n     }\n     println!();\n     true\n@@ -205,16 +204,16 @@ pub fn print_lints() {\n     let grouped_by_lint_group = Lint::by_lint_group(usable_lints.into_iter());\n \n     for (lint_group, mut lints) in grouped_by_lint_group {\n-        println!(\"\\n## {}\", lint_group);\n+        println!(\"\\n## {lint_group}\");\n \n         lints.sort_by_key(|l| l.name.clone());\n \n         for lint in lints {\n-            println!(\"* [{}]({}#{}) ({})\", lint.name, DOCS_LINK, lint.name, lint.desc);\n+            println!(\"* [{}]({DOCS_LINK}#{}) ({})\", lint.name, lint.name, lint.desc);\n         }\n     }\n \n-    println!(\"there are {} lints\", usable_lint_count);\n+    println!(\"there are {usable_lint_count} lints\");\n }\n \n /// Runs the `rename_lint` command.\n@@ -235,10 +234,10 @@ pub fn print_lints() {\n #[allow(clippy::too_many_lines)]\n pub fn rename(old_name: &str, new_name: &str, uplift: bool) {\n     if let Some((prefix, _)) = old_name.split_once(\"::\") {\n-        panic!(\"`{}` should not contain the `{}` prefix\", old_name, prefix);\n+        panic!(\"`{old_name}` should not contain the `{prefix}` prefix\");\n     }\n     if let Some((prefix, _)) = new_name.split_once(\"::\") {\n-        panic!(\"`{}` should not contain the `{}` prefix\", new_name, prefix);\n+        panic!(\"`{new_name}` should not contain the `{prefix}` prefix\");\n     }\n \n     let (mut lints, deprecated_lints, mut renamed_lints) = gather_all();\n@@ -251,28 +250,26 @@ pub fn rename(old_name: &str, new_name: &str, uplift: bool) {\n             found_new_name = true;\n         }\n     }\n-    let old_lint_index = old_lint_index.unwrap_or_else(|| panic!(\"could not find lint `{}`\", old_name));\n+    let old_lint_index = old_lint_index.unwrap_or_else(|| panic!(\"could not find lint `{old_name}`\"));\n \n     let lint = RenamedLint {\n-        old_name: format!(\"clippy::{}\", old_name),\n+        old_name: format!(\"clippy::{old_name}\"),\n         new_name: if uplift {\n             new_name.into()\n         } else {\n-            format!(\"clippy::{}\", new_name)\n+            format!(\"clippy::{new_name}\")\n         },\n     };\n \n     // Renamed lints and deprecated lints shouldn't have been found in the lint list, but check just in\n     // case.\n     assert!(\n         !renamed_lints.iter().any(|l| lint.old_name == l.old_name),\n-        \"`{}` has already been renamed\",\n-        old_name\n+        \"`{old_name}` has already been renamed\"\n     );\n     assert!(\n         !deprecated_lints.iter().any(|l| lint.old_name == l.name),\n-        \"`{}` has already been deprecated\",\n-        old_name\n+        \"`{old_name}` has already been deprecated\"\n     );\n \n     // Update all lint level attributes. (`clippy::lint_name`)\n@@ -309,14 +306,12 @@ pub fn rename(old_name: &str, new_name: &str, uplift: bool) {\n     if uplift {\n         write_file(Path::new(\"tests/ui/rename.rs\"), &gen_renamed_lints_test(&renamed_lints));\n         println!(\n-            \"`{}` has be uplifted. All the code inside `clippy_lints` related to it needs to be removed manually.\",\n-            old_name\n+            \"`{old_name}` has be uplifted. All the code inside `clippy_lints` related to it needs to be removed manually.\"\n         );\n     } else if found_new_name {\n         write_file(Path::new(\"tests/ui/rename.rs\"), &gen_renamed_lints_test(&renamed_lints));\n         println!(\n-            \"`{}` is already defined. The old linting code inside `clippy_lints` needs to be updated/removed manually.\",\n-            new_name\n+            \"`{new_name}` is already defined. The old linting code inside `clippy_lints` needs to be updated/removed manually.\"\n         );\n     } else {\n         // Rename the lint struct and source files sharing a name with the lint.\n@@ -327,25 +322,25 @@ pub fn rename(old_name: &str, new_name: &str, uplift: bool) {\n \n         // Rename test files. only rename `.stderr` and `.fixed` files if the new test name doesn't exist.\n         if try_rename_file(\n-            Path::new(&format!(\"tests/ui/{}.rs\", old_name)),\n-            Path::new(&format!(\"tests/ui/{}.rs\", new_name)),\n+            Path::new(&format!(\"tests/ui/{old_name}.rs\")),\n+            Path::new(&format!(\"tests/ui/{new_name}.rs\")),\n         ) {\n             try_rename_file(\n-                Path::new(&format!(\"tests/ui/{}.stderr\", old_name)),\n-                Path::new(&format!(\"tests/ui/{}.stderr\", new_name)),\n+                Path::new(&format!(\"tests/ui/{old_name}.stderr\")),\n+                Path::new(&format!(\"tests/ui/{new_name}.stderr\")),\n             );\n             try_rename_file(\n-                Path::new(&format!(\"tests/ui/{}.fixed\", old_name)),\n-                Path::new(&format!(\"tests/ui/{}.fixed\", new_name)),\n+                Path::new(&format!(\"tests/ui/{old_name}.fixed\")),\n+                Path::new(&format!(\"tests/ui/{new_name}.fixed\")),\n             );\n         }\n \n         // Try to rename the file containing the lint if the file name matches the lint's name.\n         let replacements;\n         let replacements = if lint.module == old_name\n             && try_rename_file(\n-                Path::new(&format!(\"clippy_lints/src/{}.rs\", old_name)),\n-                Path::new(&format!(\"clippy_lints/src/{}.rs\", new_name)),\n+                Path::new(&format!(\"clippy_lints/src/{old_name}.rs\")),\n+                Path::new(&format!(\"clippy_lints/src/{new_name}.rs\")),\n             ) {\n             // Edit the module name in the lint list. Note there could be multiple lints.\n             for lint in lints.iter_mut().filter(|l| l.module == old_name) {\n@@ -356,14 +351,14 @@ pub fn rename(old_name: &str, new_name: &str, uplift: bool) {\n         } else if !lint.module.contains(\"::\")\n             // Catch cases like `methods/lint_name.rs` where the lint is stored in `methods/mod.rs`\n             && try_rename_file(\n-                Path::new(&format!(\"clippy_lints/src/{}/{}.rs\", lint.module, old_name)),\n-                Path::new(&format!(\"clippy_lints/src/{}/{}.rs\", lint.module, new_name)),\n+                Path::new(&format!(\"clippy_lints/src/{}/{old_name}.rs\", lint.module)),\n+                Path::new(&format!(\"clippy_lints/src/{}/{new_name}.rs\", lint.module)),\n             )\n         {\n             // Edit the module name in the lint list. Note there could be multiple lints, or none.\n-            let renamed_mod = format!(\"{}::{}\", lint.module, old_name);\n+            let renamed_mod = format!(\"{}::{old_name}\", lint.module);\n             for lint in lints.iter_mut().filter(|l| l.module == renamed_mod) {\n-                lint.module = format!(\"{}::{}\", lint.module, new_name);\n+                lint.module = format!(\"{}::{new_name}\", lint.module);\n             }\n             replacements = [(&*old_name_upper, &*new_name_upper), (old_name, new_name)];\n             replacements.as_slice()\n@@ -379,7 +374,7 @@ pub fn rename(old_name: &str, new_name: &str, uplift: bool) {\n         }\n \n         generate_lint_files(UpdateMode::Change, &lints, &deprecated_lints, &renamed_lints);\n-        println!(\"{} has been successfully renamed\", old_name);\n+        println!(\"{old_name} has been successfully renamed\");\n     }\n \n     println!(\"note: `cargo uitest` still needs to be run to update the test results\");\n@@ -408,7 +403,7 @@ pub fn deprecate(name: &str, reason: Option<&String>) {\n         });\n \n         generate_lint_files(UpdateMode::Change, &lints, &deprecated_lints, &renamed_lints);\n-        println!(\"info: `{}` has successfully been deprecated\", name);\n+        println!(\"info: `{name}` has successfully been deprecated\");\n \n         if reason == DEFAULT_DEPRECATION_REASON {\n             println!(\"note: the deprecation reason must be updated in `clippy_lints/src/deprecated_lints.rs`\");\n@@ -421,7 +416,7 @@ pub fn deprecate(name: &str, reason: Option<&String>) {\n     let name_upper = name.to_uppercase();\n \n     let (mut lints, deprecated_lints, renamed_lints) = gather_all();\n-    let Some(lint) = lints.iter().find(|l| l.name == name_lower) else { eprintln!(\"error: failed to find lint `{}`\", name); return; };\n+    let Some(lint) = lints.iter().find(|l| l.name == name_lower) else { eprintln!(\"error: failed to find lint `{name}`\"); return; };\n \n     let mod_path = {\n         let mut mod_path = PathBuf::from(format!(\"clippy_lints/src/{}\", lint.module));\n@@ -450,7 +445,7 @@ fn remove_lint_declaration(name: &str, path: &Path, lints: &mut Vec<Lint>) -> io\n     }\n \n     fn remove_test_assets(name: &str) {\n-        let test_file_stem = format!(\"tests/ui/{}\", name);\n+        let test_file_stem = format!(\"tests/ui/{name}\");\n         let path = Path::new(&test_file_stem);\n \n         // Some lints have their own directories, delete them\n@@ -512,8 +507,7 @@ fn remove_lint_declaration(name: &str, path: &Path, lints: &mut Vec<Lint>) -> io\n                     fs::read_to_string(path).unwrap_or_else(|_| panic!(\"failed to read `{}`\", path.to_string_lossy()));\n \n                 eprintln!(\n-                    \"warn: you will have to manually remove any code related to `{}` from `{}`\",\n-                    name,\n+                    \"warn: you will have to manually remove any code related to `{name}` from `{}`\",\n                     path.display()\n                 );\n \n@@ -528,7 +522,7 @@ fn remove_lint_declaration(name: &str, path: &Path, lints: &mut Vec<Lint>) -> io\n                 content.replace_range(lint.declaration_range.clone(), \"\");\n \n                 // Remove the module declaration (mod xyz;)\n-                let mod_decl = format!(\"\\nmod {};\", name);\n+                let mod_decl = format!(\"\\nmod {name};\");\n                 content = content.replacen(&mod_decl, \"\", 1);\n \n                 remove_impl_lint_pass(&lint.name.to_uppercase(), &mut content);\n@@ -621,13 +615,13 @@ fn round_to_fifty(count: usize) -> usize {\n fn process_file(path: impl AsRef<Path>, update_mode: UpdateMode, content: &str) {\n     if update_mode == UpdateMode::Check {\n         let old_content =\n-            fs::read_to_string(&path).unwrap_or_else(|e| panic!(\"Cannot read from {}: {}\", path.as_ref().display(), e));\n+            fs::read_to_string(&path).unwrap_or_else(|e| panic!(\"Cannot read from {}: {e}\", path.as_ref().display()));\n         if content != old_content {\n             exit_with_failure();\n         }\n     } else {\n         fs::write(&path, content.as_bytes())\n-            .unwrap_or_else(|e| panic!(\"Cannot write to {}: {}\", path.as_ref().display(), e));\n+            .unwrap_or_else(|e| panic!(\"Cannot write to {}: {e}\", path.as_ref().display()));\n     }\n }\n \n@@ -731,11 +725,10 @@ fn gen_lint_group_list<'a>(group_name: &str, lints: impl Iterator<Item = &'a Lin\n \n     let _ = writeln!(\n         output,\n-        \"store.register_group(true, \\\"clippy::{0}\\\", Some(\\\"clippy_{0}\\\"), vec![\",\n-        group_name\n+        \"store.register_group(true, \\\"clippy::{group_name}\\\", Some(\\\"clippy_{group_name}\\\"), vec![\",\n     );\n     for (module, name) in details {\n-        let _ = writeln!(output, \"    LintId::of({}::{}),\", module, name);\n+        let _ = writeln!(output, \"    LintId::of({module}::{name}),\");\n     }\n     output.push_str(\"])\\n\");\n \n@@ -783,7 +776,7 @@ fn gen_register_lint_list<'a>(\n         if !is_public {\n             output.push_str(\"    #[cfg(feature = \\\"internal\\\")]\\n\");\n         }\n-        let _ = writeln!(output, \"    {}::{},\", module_name, lint_name);\n+        let _ = writeln!(output, \"    {module_name}::{lint_name},\");\n     }\n     output.push_str(\"])\\n\");\n \n@@ -841,7 +834,7 @@ fn gather_all() -> (Vec<Lint>, Vec<DeprecatedLint>, Vec<RenamedLint>) {\n     for (rel_path, file) in clippy_lints_src_files() {\n         let path = file.path();\n         let contents =\n-            fs::read_to_string(path).unwrap_or_else(|e| panic!(\"Cannot read from `{}`: {}\", path.display(), e));\n+            fs::read_to_string(path).unwrap_or_else(|e| panic!(\"Cannot read from `{}`: {e}\", path.display()));\n         let module = rel_path\n             .components()\n             .map(|c| c.as_os_str().to_str().unwrap())\n@@ -1050,7 +1043,7 @@ fn remove_line_splices(s: &str) -> String {\n         .trim_matches('#')\n         .strip_prefix('\"')\n         .and_then(|s| s.strip_suffix('\"'))\n-        .unwrap_or_else(|| panic!(\"expected quoted string, found `{}`\", s));\n+        .unwrap_or_else(|| panic!(\"expected quoted string, found `{s}`\"));\n     let mut res = String::with_capacity(s.len());\n     unescape::unescape_literal(s, unescape::Mode::Str, &mut |range, ch| {\n         if ch.is_ok() {\n@@ -1076,18 +1069,18 @@ fn replace_region_in_file(\n     end: &str,\n     write_replacement: impl FnMut(&mut String),\n ) {\n-    let contents = fs::read_to_string(path).unwrap_or_else(|e| panic!(\"Cannot read from `{}`: {}\", path.display(), e));\n+    let contents = fs::read_to_string(path).unwrap_or_else(|e| panic!(\"Cannot read from `{}`: {e}\", path.display()));\n     let new_contents = match replace_region_in_text(&contents, start, end, write_replacement) {\n         Ok(x) => x,\n-        Err(delim) => panic!(\"Couldn't find `{}` in file `{}`\", delim, path.display()),\n+        Err(delim) => panic!(\"Couldn't find `{delim}` in file `{}`\", path.display()),\n     };\n \n     match update_mode {\n         UpdateMode::Check if contents != new_contents => exit_with_failure(),\n         UpdateMode::Check => (),\n         UpdateMode::Change => {\n             if let Err(e) = fs::write(path, new_contents.as_bytes()) {\n-                panic!(\"Cannot write to `{}`: {}\", path.display(), e);\n+                panic!(\"Cannot write to `{}`: {e}\", path.display());\n             }\n         },\n     }\n@@ -1135,7 +1128,7 @@ fn try_rename_file(old_name: &Path, new_name: &Path) -> bool {\n \n #[allow(clippy::needless_pass_by_value)]\n fn panic_file(error: io::Error, name: &Path, action: &str) -> ! {\n-    panic!(\"failed to {} file `{}`: {}\", action, name.display(), error)\n+    panic!(\"failed to {action} file `{}`: {error}\", name.display())\n }\n \n fn rewrite_file(path: &Path, f: impl FnOnce(&str) -> Option<String>) {"}, {"sha": "6fbd6401ef3ebe00ba8a516912325564c7cc8589", "filename": "src/tools/clippy/clippy_lints/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2FCargo.toml?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy_lints\"\n-version = \"0.1.65\"\n+version = \"0.1.66\"\n description = \"A bunch of helpful lints to avoid common pitfalls in Rust\"\n repository = \"https://github.com/rust-lang/rust-clippy\"\n readme = \"README.md\""}, {"sha": "724490fb49592f64c5b770de45124e741dcb08c0", "filename": "src/tools/clippy/clippy_lints/src/approx_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fapprox_const.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -92,7 +92,7 @@ impl ApproxConstant {\n                         cx,\n                         APPROX_CONSTANT,\n                         e.span,\n-                        &format!(\"approximate value of `{}::consts::{}` found\", module, &name),\n+                        &format!(\"approximate value of `{module}::consts::{}` found\", &name),\n                         None,\n                         \"consider using the constant directly\",\n                     );\n@@ -126,7 +126,7 @@ fn is_approx_const(constant: f64, value: &str, min_digits: usize) -> bool {\n         // The value is a truncated constant\n         true\n     } else {\n-        let round_const = format!(\"{:.*}\", value.len() - 2, constant);\n+        let round_const = format!(\"{constant:.*}\", value.len() - 2);\n         value == round_const\n     }\n }"}, {"sha": "9717aa9e981fbf41f30c4864f3ee19cd8ff6747d", "filename": "src/tools/clippy/clippy_lints/src/asm_syntax.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fasm_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fasm_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fasm_syntax.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -44,7 +44,7 @@ fn check_expr_asm_syntax(lint: &'static Lint, cx: &EarlyContext<'_>, expr: &Expr\n                 cx,\n                 lint,\n                 expr.span,\n-                &format!(\"{} x86 assembly syntax used\", style),\n+                &format!(\"{style} x86 assembly syntax used\"),\n                 None,\n                 &format!(\"use {} x86 assembly syntax\", !style),\n             );\n@@ -64,6 +64,7 @@ declare_clippy_lint! {\n     ///\n     /// ```rust,no_run\n     /// # #![feature(asm)]\n+    /// # #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n     /// # unsafe { let ptr = \"\".as_ptr();\n     /// # use std::arch::asm;\n     /// asm!(\"lea {}, [{}]\", lateout(reg) _, in(reg) ptr);\n@@ -72,6 +73,7 @@ declare_clippy_lint! {\n     /// Use instead:\n     /// ```rust,no_run\n     /// # #![feature(asm)]\n+    /// # #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n     /// # unsafe { let ptr = \"\".as_ptr();\n     /// # use std::arch::asm;\n     /// asm!(\"lea ({}), {}\", in(reg) ptr, lateout(reg) _, options(att_syntax));\n@@ -103,6 +105,7 @@ declare_clippy_lint! {\n     ///\n     /// ```rust,no_run\n     /// # #![feature(asm)]\n+    /// # #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n     /// # unsafe { let ptr = \"\".as_ptr();\n     /// # use std::arch::asm;\n     /// asm!(\"lea ({}), {}\", in(reg) ptr, lateout(reg) _, options(att_syntax));\n@@ -111,6 +114,7 @@ declare_clippy_lint! {\n     /// Use instead:\n     /// ```rust,no_run\n     /// # #![feature(asm)]\n+    /// # #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n     /// # unsafe { let ptr = \"\".as_ptr();\n     /// # use std::arch::asm;\n     /// asm!(\"lea {}, [{}]\", lateout(reg) _, in(reg) ptr);"}, {"sha": "a36df55d0bdafe5891baf90b8ece12041b5edc21", "filename": "src/tools/clippy/clippy_lints/src/assertions_on_constants.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassertions_on_constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassertions_on_constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassertions_on_constants.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -60,9 +60,9 @@ impl<'tcx> LateLintPass<'tcx> for AssertionsOnConstants {\n                 cx,\n                 ASSERTIONS_ON_CONSTANTS,\n                 macro_call.span,\n-                &format!(\"`assert!(false{})` should probably be replaced\", assert_arg),\n+                &format!(\"`assert!(false{assert_arg})` should probably be replaced\"),\n                 None,\n-                &format!(\"use `panic!({})` or `unreachable!({0})`\", panic_arg),\n+                &format!(\"use `panic!({panic_arg})` or `unreachable!({panic_arg})`\"),\n             );\n         }\n     }"}, {"sha": "f6d6c23bb6ed2a29803c4dad4313f906225cfd67", "filename": "src/tools/clippy/clippy_lints/src/assertions_on_result_states.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassertions_on_result_states.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassertions_on_result_states.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassertions_on_result_states.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -69,9 +69,8 @@ impl<'tcx> LateLintPass<'tcx> for AssertionsOnResultStates {\n                         \"called `assert!` with `Result::is_ok`\",\n                         \"replace with\",\n                         format!(\n-                            \"{}.unwrap(){}\",\n-                            snippet_with_context(cx, recv.span, condition.span.ctxt(), \"..\", &mut app).0,\n-                            semicolon\n+                            \"{}.unwrap(){semicolon}\",\n+                            snippet_with_context(cx, recv.span, condition.span.ctxt(), \"..\", &mut app).0\n                         ),\n                         app,\n                     );\n@@ -84,9 +83,8 @@ impl<'tcx> LateLintPass<'tcx> for AssertionsOnResultStates {\n                         \"called `assert!` with `Result::is_err`\",\n                         \"replace with\",\n                         format!(\n-                            \"{}.unwrap_err(){}\",\n-                            snippet_with_context(cx, recv.span, condition.span.ctxt(), \"..\", &mut app).0,\n-                            semicolon\n+                            \"{}.unwrap_err(){semicolon}\",\n+                            snippet_with_context(cx, recv.span, condition.span.ctxt(), \"..\", &mut app).0\n                         ),\n                         app,\n                     );"}, {"sha": "0bd1f8b784e8f3f5552c79c2af82a4c23a5c46fa", "filename": "src/tools/clippy/clippy_lints/src/attrs.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -357,7 +357,8 @@ impl<'tcx> LateLintPass<'tcx> for Attributes {\n                                                     \"wildcard_imports\"\n                                                         | \"enum_glob_use\"\n                                                         | \"redundant_pub_crate\"\n-                                                        | \"macro_use_imports\",\n+                                                        | \"macro_use_imports\"\n+                                                        | \"unsafe_removed_from_name\",\n                                                 )\n                                             })\n                                         {\n@@ -541,10 +542,7 @@ fn check_attrs(cx: &LateContext<'_>, span: Span, name: Symbol, attrs: &[Attribut\n                     cx,\n                     INLINE_ALWAYS,\n                     attr.span,\n-                    &format!(\n-                        \"you have declared `#[inline(always)]` on `{}`. This is usually a bad idea\",\n-                        name\n-                    ),\n+                    &format!(\"you have declared `#[inline(always)]` on `{name}`. This is usually a bad idea\"),\n                 );\n             }\n         }\n@@ -720,7 +718,7 @@ fn check_mismatched_target_os(cx: &EarlyContext<'_>, attr: &Attribute) {\n                 let mut unix_suggested = false;\n \n                 for (os, span) in mismatched {\n-                    let sugg = format!(\"target_os = \\\"{}\\\"\", os);\n+                    let sugg = format!(\"target_os = \\\"{os}\\\"\");\n                     diag.span_suggestion(span, \"try\", sugg, Applicability::MaybeIncorrect);\n \n                     if !unix_suggested && is_unix(os) {"}, {"sha": "34717811866d87fc0cb68922dc838d3548ccd3db", "filename": "src/tools/clippy/clippy_lints/src/await_holding_invalid.rs", "status": "modified", "additions": 19, "deletions": 23, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fawait_holding_invalid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fawait_holding_invalid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fawait_holding_invalid.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -1,14 +1,15 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::{match_def_path, paths};\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir::def::{Namespace, Res};\n use rustc_hir::def_id::DefId;\n-use rustc_hir::{def::Res, AsyncGeneratorKind, Body, BodyId, GeneratorKind};\n+use rustc_hir::{AsyncGeneratorKind, Body, BodyId, GeneratorKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::GeneratorInteriorTypeCause;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::Span;\n+use rustc_span::{sym, Span};\n \n-use crate::utils::conf::DisallowedType;\n+use crate::utils::conf::DisallowedPath;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -171,12 +172,12 @@ impl_lint_pass!(AwaitHolding => [AWAIT_HOLDING_LOCK, AWAIT_HOLDING_REFCELL_REF,\n \n #[derive(Debug)]\n pub struct AwaitHolding {\n-    conf_invalid_types: Vec<DisallowedType>,\n-    def_ids: FxHashMap<DefId, DisallowedType>,\n+    conf_invalid_types: Vec<DisallowedPath>,\n+    def_ids: FxHashMap<DefId, DisallowedPath>,\n }\n \n impl AwaitHolding {\n-    pub(crate) fn new(conf_invalid_types: Vec<DisallowedType>) -> Self {\n+    pub(crate) fn new(conf_invalid_types: Vec<DisallowedPath>) -> Self {\n         Self {\n             conf_invalid_types,\n             def_ids: FxHashMap::default(),\n@@ -187,11 +188,8 @@ impl AwaitHolding {\n impl LateLintPass<'_> for AwaitHolding {\n     fn check_crate(&mut self, cx: &LateContext<'_>) {\n         for conf in &self.conf_invalid_types {\n-            let path = match conf {\n-                DisallowedType::Simple(path) | DisallowedType::WithReason { path, .. } => path,\n-            };\n-            let segs: Vec<_> = path.split(\"::\").collect();\n-            if let Res::Def(_, id) = clippy_utils::def_path_res(cx, &segs) {\n+            let segs: Vec<_> = conf.path().split(\"::\").collect();\n+            if let Res::Def(_, id) = clippy_utils::def_path_res(cx, &segs, Some(Namespace::TypeNS)) {\n                 self.def_ids.insert(id, conf.clone());\n             }\n         }\n@@ -256,29 +254,27 @@ impl AwaitHolding {\n     }\n }\n \n-fn emit_invalid_type(cx: &LateContext<'_>, span: Span, disallowed: &DisallowedType) {\n-    let (type_name, reason) = match disallowed {\n-        DisallowedType::Simple(path) => (path, &None),\n-        DisallowedType::WithReason { path, reason } => (path, reason),\n-    };\n-\n+fn emit_invalid_type(cx: &LateContext<'_>, span: Span, disallowed: &DisallowedPath) {\n     span_lint_and_then(\n         cx,\n         AWAIT_HOLDING_INVALID_TYPE,\n         span,\n-        &format!(\"`{type_name}` may not be held across an `await` point per `clippy.toml`\",),\n+        &format!(\n+            \"`{}` may not be held across an `await` point per `clippy.toml`\",\n+            disallowed.path()\n+        ),\n         |diag| {\n-            if let Some(reason) = reason {\n-                diag.note(reason.clone());\n+            if let Some(reason) = disallowed.reason() {\n+                diag.note(reason);\n             }\n         },\n     );\n }\n \n fn is_mutex_guard(cx: &LateContext<'_>, def_id: DefId) -> bool {\n-    match_def_path(cx, def_id, &paths::MUTEX_GUARD)\n-        || match_def_path(cx, def_id, &paths::RWLOCK_READ_GUARD)\n-        || match_def_path(cx, def_id, &paths::RWLOCK_WRITE_GUARD)\n+    cx.tcx.is_diagnostic_item(sym::MutexGuard, def_id)\n+        || cx.tcx.is_diagnostic_item(sym::RwLockReadGuard, def_id)\n+        || cx.tcx.is_diagnostic_item(sym::RwLockWriteGuard, def_id)\n         || match_def_path(cx, def_id, &paths::PARKING_LOT_MUTEX_GUARD)\n         || match_def_path(cx, def_id, &paths::PARKING_LOT_RWLOCK_READ_GUARD)\n         || match_def_path(cx, def_id, &paths::PARKING_LOT_RWLOCK_WRITE_GUARD)"}, {"sha": "9c05324740247dfd774b6251f229b2ef902acdf3", "filename": "src/tools/clippy/clippy_lints/src/blocks_in_if_conditions.rs", "status": "modified", "additions": 28, "deletions": 40, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -3,10 +3,11 @@ use clippy_utils::get_parent_expr;\n use clippy_utils::higher;\n use clippy_utils::source::snippet_block_with_applicability;\n use clippy_utils::ty::implements_trait;\n+use clippy_utils::visitors::{for_each_expr, Descend};\n+use core::ops::ControlFlow;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::intravisit::{walk_expr, Visitor};\n-use rustc_hir::{BlockCheckMode, Closure, Expr, ExprKind};\n+use rustc_hir::{BlockCheckMode, Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -44,39 +45,6 @@ declare_clippy_lint! {\n \n declare_lint_pass!(BlocksInIfConditions => [BLOCKS_IN_IF_CONDITIONS]);\n \n-struct ExVisitor<'a, 'tcx> {\n-    found_block: Option<&'tcx Expr<'tcx>>,\n-    cx: &'a LateContext<'tcx>,\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for ExVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n-        if let ExprKind::Closure(&Closure { body, .. }) = expr.kind {\n-            // do not lint if the closure is called using an iterator (see #1141)\n-            if_chain! {\n-                if let Some(parent) = get_parent_expr(self.cx, expr);\n-                if let ExprKind::MethodCall(_, self_arg, ..) = &parent.kind;\n-                let caller = self.cx.typeck_results().expr_ty(self_arg);\n-                if let Some(iter_id) = self.cx.tcx.get_diagnostic_item(sym::Iterator);\n-                if implements_trait(self.cx, caller, iter_id, &[]);\n-                then {\n-                    return;\n-                }\n-            }\n-\n-            let body = self.cx.tcx.hir().body(body);\n-            let ex = &body.value;\n-            if let ExprKind::Block(block, _) = ex.kind {\n-                if !body.value.span.from_expansion() && !block.stmts.is_empty() {\n-                    self.found_block = Some(ex);\n-                    return;\n-                }\n-            }\n-        }\n-        walk_expr(self, expr);\n-    }\n-}\n-\n const BRACED_EXPR_MESSAGE: &str = \"omit braces around single expression condition\";\n const COMPLEX_BLOCK_MESSAGE: &str = \"in an `if` condition, avoid complex blocks or closures with blocks; \\\n                                     instead, move the block or closure higher and bind it with a `let`\";\n@@ -145,11 +113,31 @@ impl<'tcx> LateLintPass<'tcx> for BlocksInIfConditions {\n                     }\n                 }\n             } else {\n-                let mut visitor = ExVisitor { found_block: None, cx };\n-                walk_expr(&mut visitor, cond);\n-                if let Some(block) = visitor.found_block {\n-                    span_lint(cx, BLOCKS_IN_IF_CONDITIONS, block.span, COMPLEX_BLOCK_MESSAGE);\n-                }\n+                let _: Option<!> = for_each_expr(cond, |e| {\n+                    if let ExprKind::Closure(closure) = e.kind {\n+                        // do not lint if the closure is called using an iterator (see #1141)\n+                        if_chain! {\n+                            if let Some(parent) = get_parent_expr(cx, e);\n+                            if let ExprKind::MethodCall(_, self_arg, _, _) = &parent.kind;\n+                            let caller = cx.typeck_results().expr_ty(self_arg);\n+                            if let Some(iter_id) = cx.tcx.get_diagnostic_item(sym::Iterator);\n+                            if implements_trait(cx, caller, iter_id, &[]);\n+                            then {\n+                                return ControlFlow::Continue(Descend::No);\n+                            }\n+                        }\n+\n+                        let body = cx.tcx.hir().body(closure.body);\n+                        let ex = &body.value;\n+                        if let ExprKind::Block(block, _) = ex.kind {\n+                            if !body.value.span.from_expansion() && !block.stmts.is_empty() {\n+                                span_lint(cx, BLOCKS_IN_IF_CONDITIONS, ex.span, COMPLEX_BLOCK_MESSAGE);\n+                                return ControlFlow::Continue(Descend::No);\n+                            }\n+                        }\n+                    }\n+                    ControlFlow::Continue(Descend::Yes)\n+                });\n             }\n         }\n     }"}, {"sha": "4bd55c1429c3b452dfe6aada32088ed771abdfb9", "filename": "src/tools/clippy/clippy_lints/src/bool_assert_comparison.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbool_assert_comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbool_assert_comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbool_assert_comparison.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -98,9 +98,9 @@ impl<'tcx> LateLintPass<'tcx> for BoolAssertComparison {\n             cx,\n             BOOL_ASSERT_COMPARISON,\n             macro_call.span,\n-            &format!(\"used `{}!` with a literal bool\", macro_name),\n+            &format!(\"used `{macro_name}!` with a literal bool\"),\n             \"replace it with\",\n-            format!(\"{}!(..)\", non_eq_mac),\n+            format!(\"{non_eq_mac}!(..)\"),\n             Applicability::MaybeIncorrect,\n         );\n     }"}, {"sha": "001d74c2605453e02988103b8f785aab7ce7fc64", "filename": "src/tools/clippy/clippy_lints/src/bool_to_int_with_if.rs", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbool_to_int_with_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbool_to_int_with_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbool_to_int_with_if.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -3,7 +3,7 @@ use rustc_hir::{Block, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n-use clippy_utils::{diagnostics::span_lint_and_then, is_else_clause, sugg::Sugg};\n+use clippy_utils::{diagnostics::span_lint_and_then, is_else_clause, is_integer_literal, sugg::Sugg};\n use rustc_errors::Applicability;\n \n declare_clippy_lint! {\n@@ -56,13 +56,9 @@ fn check_if_else<'tcx>(ctx: &LateContext<'tcx>, expr: &'tcx rustc_hir::Expr<'tcx\n         && let Some(then_lit) = int_literal(then)\n         && let Some(else_lit) = int_literal(else_)\n     {\n-        let inverted = if\n-            check_int_literal_equals_val(then_lit, 1)\n-            && check_int_literal_equals_val(else_lit, 0) {\n+        let inverted = if is_integer_literal(then_lit, 1) && is_integer_literal(else_lit, 0) {\n             false\n-        } else if\n-            check_int_literal_equals_val(then_lit, 0)\n-            && check_int_literal_equals_val(else_lit, 1) {\n+        } else if is_integer_literal(then_lit, 0) && is_integer_literal(else_lit, 1) {\n             true\n         } else {\n             // Expression isn't boolean, exit\n@@ -123,14 +119,3 @@ fn int_literal<'tcx>(expr: &'tcx rustc_hir::Expr<'tcx>) -> Option<&'tcx rustc_hi\n         None\n     }\n }\n-\n-fn check_int_literal_equals_val<'tcx>(expr: &'tcx rustc_hir::Expr<'tcx>, expected_value: u128) -> bool {\n-    if let ExprKind::Lit(lit) = &expr.kind\n-        && let LitKind::Int(val, _) = lit.node\n-        && val == expected_value\n-    {\n-        true\n-    } else {\n-        false\n-    }\n-}"}, {"sha": "2a15cbc7a3c3b0a981eb29511b505bd36f063000", "filename": "src/tools/clippy/clippy_lints/src/booleans.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbooleans.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -263,9 +263,8 @@ fn simplify_not(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<String> {\n             }\n             .and_then(|op| {\n                 Some(format!(\n-                    \"{}{}{}\",\n+                    \"{}{op}{}\",\n                     snippet_opt(cx, lhs.span)?,\n-                    op,\n                     snippet_opt(cx, rhs.span)?\n                 ))\n             })\n@@ -285,7 +284,7 @@ fn simplify_not(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<String> {\n                     let path: &str = path.ident.name.as_str();\n                     a == path\n                 })\n-                .and_then(|(_, neg_method)| Some(format!(\"{}.{}()\", snippet_opt(cx, receiver.span)?, neg_method)))\n+                .and_then(|(_, neg_method)| Some(format!(\"{}.{neg_method}()\", snippet_opt(cx, receiver.span)?)))\n         },\n         _ => None,\n     }"}, {"sha": "792183ac40814ef90355cd13e94a3bd72ce3cfbf", "filename": "src/tools/clippy/clippy_lints/src/box_default.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbox_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbox_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbox_default.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -0,0 +1,61 @@\n+use clippy_utils::{diagnostics::span_lint_and_help, is_default_equivalent, path_def_id};\n+use rustc_hir::{Expr, ExprKind, QPath};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_middle::lint::in_external_macro;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// checks for `Box::new(T::default())`, which is better written as\n+    /// `Box::<T>::default()`.\n+    ///\n+    /// ### Why is this bad?\n+    /// First, it's more complex, involving two calls instead of one.\n+    /// Second, `Box::default()` can be faster\n+    /// [in certain cases](https://nnethercote.github.io/perf-book/standard-library-types.html#box).\n+    ///\n+    /// ### Known problems\n+    /// The lint may miss some cases (e.g. Box::new(String::from(\"\"))).\n+    /// On the other hand, it will trigger on cases where the `default`\n+    /// code comes from a macro that does something different based on\n+    /// e.g. target operating system.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let x: Box<String> = Box::new(Default::default());\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let x: Box<String> = Box::default();\n+    /// ```\n+    #[clippy::version = \"1.65.0\"]\n+    pub BOX_DEFAULT,\n+    perf,\n+    \"Using Box::new(T::default()) instead of Box::default()\"\n+}\n+\n+declare_lint_pass!(BoxDefault => [BOX_DEFAULT]);\n+\n+impl LateLintPass<'_> for BoxDefault {\n+    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n+        if let ExprKind::Call(box_new, [arg]) = expr.kind\n+            && let ExprKind::Path(QPath::TypeRelative(ty, seg)) = box_new.kind\n+            && let ExprKind::Call(..) = arg.kind\n+            && !in_external_macro(cx.sess(), expr.span)\n+            && expr.span.eq_ctxt(arg.span)\n+            && seg.ident.name == sym::new\n+            && path_def_id(cx, ty) == cx.tcx.lang_items().owned_box()\n+            && is_default_equivalent(cx, arg)\n+        {\n+            span_lint_and_help(\n+                cx,\n+                BOX_DEFAULT,\n+                expr.span,\n+                \"`Box::new(_)` of default value\",\n+                None,\n+                \"use `Box::default()` instead\",\n+            );\n+        }\n+    }\n+}"}, {"sha": "805121bcced3b562393279e500a4b3823b50b94e", "filename": "src/tools/clippy/clippy_lints/src/cargo/common_metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcargo%2Fcommon_metadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcargo%2Fcommon_metadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcargo%2Fcommon_metadata.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -40,7 +40,7 @@ pub(super) fn check(cx: &LateContext<'_>, metadata: &Metadata, ignore_publish: b\n }\n \n fn missing_warning(cx: &LateContext<'_>, package: &cargo_metadata::Package, field: &str) {\n-    let message = format!(\"package `{}` is missing `{}` metadata\", package.name, field);\n+    let message = format!(\"package `{}` is missing `{field}` metadata\", package.name);\n     span_lint(cx, CARGO_COMMON_METADATA, DUMMY_SP, &message);\n }\n "}, {"sha": "37c169dbd95e3807599248b01c6366a6854303b7", "filename": "src/tools/clippy/clippy_lints/src/cargo/feature_name.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcargo%2Ffeature_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcargo%2Ffeature_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcargo%2Ffeature_name.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -57,10 +57,8 @@ fn lint(cx: &LateContext<'_>, feature: &str, substring: &str, is_prefix: bool) {\n         },\n         DUMMY_SP,\n         &format!(\n-            \"the \\\"{}\\\" {} in the feature name \\\"{}\\\" is {}\",\n-            substring,\n+            \"the \\\"{substring}\\\" {} in the feature name \\\"{feature}\\\" is {}\",\n             if is_prefix { \"prefix\" } else { \"suffix\" },\n-            feature,\n             if is_negative { \"negative\" } else { \"redundant\" }\n         ),\n         None,"}, {"sha": "3a872e54c9a2b2134dc6861e66823c716792c93d", "filename": "src/tools/clippy/clippy_lints/src/cargo/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcargo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcargo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcargo%2Fmod.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -196,7 +196,7 @@ impl LateLintPass<'_> for Cargo {\n                 },\n                 Err(e) => {\n                     for lint in NO_DEPS_LINTS {\n-                        span_lint(cx, lint, DUMMY_SP, &format!(\"could not read cargo metadata: {}\", e));\n+                        span_lint(cx, lint, DUMMY_SP, &format!(\"could not read cargo metadata: {e}\"));\n                     }\n                 },\n             }\n@@ -212,7 +212,7 @@ impl LateLintPass<'_> for Cargo {\n                 },\n                 Err(e) => {\n                     for lint in WITH_DEPS_LINTS {\n-                        span_lint(cx, lint, DUMMY_SP, &format!(\"could not read cargo metadata: {}\", e));\n+                        span_lint(cx, lint, DUMMY_SP, &format!(\"could not read cargo metadata: {e}\"));\n                     }\n                 },\n             }"}, {"sha": "f9b17d45e9fbab74a837fad8048cfe2358fbb246", "filename": "src/tools/clippy/clippy_lints/src/cargo/multiple_crate_versions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcargo%2Fmultiple_crate_versions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcargo%2Fmultiple_crate_versions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcargo%2Fmultiple_crate_versions.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -37,7 +37,7 @@ pub(super) fn check(cx: &LateContext<'_>, metadata: &Metadata) {\n                         cx,\n                         MULTIPLE_CRATE_VERSIONS,\n                         DUMMY_SP,\n-                        &format!(\"multiple versions for dependency `{}`: {}\", name, versions),\n+                        &format!(\"multiple versions for dependency `{name}`: {versions}\"),\n                     );\n                 }\n             }"}, {"sha": "294d22d34de953994576fd8beca4b6c52f691934", "filename": "src/tools/clippy/clippy_lints/src/casts/borrow_as_ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fborrow_as_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fborrow_as_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fborrow_as_ptr.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -30,7 +30,7 @@ pub(super) fn check<'tcx>(\n             expr.span,\n             \"borrow as raw pointer\",\n             \"try\",\n-            format!(\"{}::ptr::{}!({})\", core_or_std, macro_name, snip),\n+            format!(\"{core_or_std}::ptr::{macro_name}!({snip})\"),\n             Applicability::MachineApplicable,\n         );\n     }"}, {"sha": "13c403234dad5e8b44a41dfe87b99a5f24d25b4b", "filename": "src/tools/clippy/clippy_lints/src/casts/cast_lossless.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_lossless.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_lossless.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_lossless.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -41,15 +41,9 @@ pub(super) fn check(\n     );\n \n     let message = if cast_from.is_bool() {\n-        format!(\n-            \"casting `{0:}` to `{1:}` is more cleanly stated with `{1:}::from(_)`\",\n-            cast_from, cast_to\n-        )\n+        format!(\"casting `{cast_from:}` to `{cast_to:}` is more cleanly stated with `{cast_to:}::from(_)`\")\n     } else {\n-        format!(\n-            \"casting `{}` to `{}` may become silently lossy if you later change the type\",\n-            cast_from, cast_to\n-        )\n+        format!(\"casting `{cast_from}` to `{cast_to}` may become silently lossy if you later change the type\")\n     };\n \n     span_lint_and_sugg(\n@@ -58,7 +52,7 @@ pub(super) fn check(\n         expr.span,\n         &message,\n         \"try\",\n-        format!(\"{}::from({})\", cast_to, sugg),\n+        format!(\"{cast_to}::from({sugg})\"),\n         applicability,\n     );\n }"}, {"sha": "88deb4565eb216cb801b49e659418ffd42b74131", "filename": "src/tools/clippy/clippy_lints/src/casts/cast_possible_truncation.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_possible_truncation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_possible_truncation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_possible_truncation.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -103,10 +103,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, cast_expr: &Expr<'_>,\n                 return;\n             }\n \n-            format!(\n-                \"casting `{}` to `{}` may truncate the value{}\",\n-                cast_from, cast_to, suffix,\n-            )\n+            format!(\"casting `{cast_from}` to `{cast_to}` may truncate the value{suffix}\",)\n         },\n \n         (ty::Adt(def, _), true) if def.is_enum() => {\n@@ -142,20 +139,17 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, cast_expr: &Expr<'_>,\n                     CAST_ENUM_TRUNCATION,\n                     expr.span,\n                     &format!(\n-                        \"casting `{}::{}` to `{}` will truncate the value{}\",\n-                        cast_from, variant.name, cast_to, suffix,\n+                        \"casting `{cast_from}::{}` to `{cast_to}` will truncate the value{suffix}\",\n+                        variant.name,\n                     ),\n                 );\n                 return;\n             }\n-            format!(\n-                \"casting `{}` to `{}` may truncate the value{}\",\n-                cast_from, cast_to, suffix,\n-            )\n+            format!(\"casting `{cast_from}` to `{cast_to}` may truncate the value{suffix}\",)\n         },\n \n         (ty::Float(_), true) => {\n-            format!(\"casting `{}` to `{}` may truncate the value\", cast_from, cast_to)\n+            format!(\"casting `{cast_from}` to `{cast_to}` may truncate the value\")\n         },\n \n         (ty::Float(FloatTy::F64), false) if matches!(cast_to.kind(), &ty::Float(FloatTy::F32)) => {"}, {"sha": "28ecdea7ea06c3d4e238adf9f54c2342e4d06f30", "filename": "src/tools/clippy/clippy_lints/src/casts/cast_possible_wrap.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_possible_wrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_possible_wrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_possible_wrap.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -35,10 +35,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, cast_from: Ty<'_>, ca\n             cx,\n             CAST_POSSIBLE_WRAP,\n             expr.span,\n-            &format!(\n-                \"casting `{}` to `{}` may wrap around the value{}\",\n-                cast_from, cast_to, suffix,\n-            ),\n+            &format!(\"casting `{cast_from}` to `{cast_to}` may wrap around the value{suffix}\",),\n         );\n     }\n }"}, {"sha": "97054a0d10154682178d0fd28023502ca00528e6", "filename": "src/tools/clippy/clippy_lints/src/casts/cast_ptr_alignment.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_ptr_alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_ptr_alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_ptr_alignment.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -49,9 +49,7 @@ fn lint_cast_ptr_alignment<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>, cast_f\n             CAST_PTR_ALIGNMENT,\n             expr.span,\n             &format!(\n-                \"casting from `{}` to a more-strictly-aligned pointer (`{}`) ({} < {} bytes)\",\n-                cast_from,\n-                cast_to,\n+                \"casting from `{cast_from}` to a more-strictly-aligned pointer (`{cast_to}`) ({} < {} bytes)\",\n                 from_layout.align.abi.bytes(),\n                 to_layout.align.abi.bytes(),\n             ),"}, {"sha": "a20a97d4e56daccaaf0d739537c240216d2fd545", "filename": "src/tools/clippy/clippy_lints/src/casts/cast_sign_loss.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_sign_loss.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_sign_loss.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_sign_loss.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -14,10 +14,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, cast_op: &Expr<'_>, c\n             cx,\n             CAST_SIGN_LOSS,\n             expr.span,\n-            &format!(\n-                \"casting `{}` to `{}` may lose the sign of the value\",\n-                cast_from, cast_to\n-            ),\n+            &format!(\"casting `{cast_from}` to `{cast_to}` may lose the sign of the value\"),\n         );\n     }\n }"}, {"sha": "d31d10d22b92b8997a77631d71d86ddc21dcdd38", "filename": "src/tools/clippy/clippy_lints/src/casts/cast_slice_different_sizes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_slice_different_sizes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_slice_different_sizes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_slice_different_sizes.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -35,8 +35,8 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>, msrv: Optio\n                     CAST_SLICE_DIFFERENT_SIZES,\n                     expr.span,\n                     &format!(\n-                        \"casting between raw pointers to `[{}]` (element size {}) and `[{}]` (element size {}) does not adjust the count\",\n-                        start_ty.ty, from_size, end_ty.ty, to_size,\n+                        \"casting between raw pointers to `[{}]` (element size {from_size}) and `[{}]` (element size {to_size}) does not adjust the count\",\n+                        start_ty.ty, end_ty.ty,\n                     ),\n                     |diag| {\n                         let ptr_snippet = source::snippet(cx, left_cast.span, \"..\");"}, {"sha": "82e07c98a7e0179da0a9b721ae2f540b3eec7f03", "filename": "src/tools/clippy/clippy_lints/src/casts/char_lit_as_u8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fchar_lit_as_u8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fchar_lit_as_u8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fchar_lit_as_u8.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -31,7 +31,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>) {\n                         diag.span_suggestion(\n                             expr.span,\n                             \"use a byte literal instead\",\n-                            format!(\"b{}\", snippet),\n+                            format!(\"b{snippet}\"),\n                             applicability,\n                         );\n                     }"}, {"sha": "a26bfab4e7c1568d22b62eae3780169dd0bf79e5", "filename": "src/tools/clippy/clippy_lints/src/casts/fn_to_numeric_cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Ffn_to_numeric_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Ffn_to_numeric_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Ffn_to_numeric_cast.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -25,9 +25,9 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, cast_expr: &Expr<'_>,\n                     cx,\n                     FN_TO_NUMERIC_CAST,\n                     expr.span,\n-                    &format!(\"casting function pointer `{}` to `{}`\", from_snippet, cast_to),\n+                    &format!(\"casting function pointer `{from_snippet}` to `{cast_to}`\"),\n                     \"try\",\n-                    format!(\"{} as usize\", from_snippet),\n+                    format!(\"{from_snippet} as usize\"),\n                     applicability,\n                 );\n             }"}, {"sha": "75654129408e68ef0ccbd3b3b300f91185874313", "filename": "src/tools/clippy/clippy_lints/src/casts/fn_to_numeric_cast_any.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Ffn_to_numeric_cast_any.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Ffn_to_numeric_cast_any.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Ffn_to_numeric_cast_any.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -23,9 +23,9 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, cast_expr: &Expr<'_>,\n                 cx,\n                 FN_TO_NUMERIC_CAST_ANY,\n                 expr.span,\n-                &format!(\"casting function pointer `{}` to `{}`\", from_snippet, cast_to),\n+                &format!(\"casting function pointer `{from_snippet}` to `{cast_to}`\"),\n                 \"did you mean to invoke the function?\",\n-                format!(\"{}() as {}\", from_snippet, cast_to),\n+                format!(\"{from_snippet}() as {cast_to}\"),\n                 applicability,\n             );\n         },"}, {"sha": "556be1d1506657a4f8d80bd6ce563f770c508155", "filename": "src/tools/clippy/clippy_lints/src/casts/fn_to_numeric_cast_with_truncation.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Ffn_to_numeric_cast_with_truncation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Ffn_to_numeric_cast_with_truncation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Ffn_to_numeric_cast_with_truncation.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -24,12 +24,9 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, cast_expr: &Expr<'_>,\n                     cx,\n                     FN_TO_NUMERIC_CAST_WITH_TRUNCATION,\n                     expr.span,\n-                    &format!(\n-                        \"casting function pointer `{}` to `{}`, which truncates the value\",\n-                        from_snippet, cast_to\n-                    ),\n+                    &format!(\"casting function pointer `{from_snippet}` to `{cast_to}`, which truncates the value\"),\n                     \"try\",\n-                    format!(\"{} as usize\", from_snippet),\n+                    format!(\"{from_snippet} as usize\"),\n                     applicability,\n                 );\n             }"}, {"sha": "c2b9253ec35dc8bccd9efc5ce3269b7965338ea5", "filename": "src/tools/clippy/clippy_lints/src/casts/ptr_as_ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fptr_as_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fptr_as_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fptr_as_ptr.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -33,15 +33,15 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, msrv: Option<RustcVer\n             let turbofish = match &cast_to_hir_ty.kind {\n                     TyKind::Infer => Cow::Borrowed(\"\"),\n                     TyKind::Ptr(mut_ty) if matches!(mut_ty.ty.kind, TyKind::Infer) => Cow::Borrowed(\"\"),\n-                    _ => Cow::Owned(format!(\"::<{}>\", to_pointee_ty)),\n+                    _ => Cow::Owned(format!(\"::<{to_pointee_ty}>\")),\n                 };\n             span_lint_and_sugg(\n                 cx,\n                 PTR_AS_PTR,\n                 expr.span,\n                 \"`as` casting between raw pointers without changing its mutability\",\n                 \"try `pointer::cast`, a safer alternative\",\n-                format!(\"{}.cast{}()\", cast_expr_sugg.maybe_par(), turbofish),\n+                format!(\"{}.cast{turbofish}()\", cast_expr_sugg.maybe_par()),\n                 applicability,\n             );\n         }"}, {"sha": "21ed7f4844cc593948bbb21bc6a69c1c37ca126c", "filename": "src/tools/clippy/clippy_lints/src/casts/unnecessary_cast.rs", "status": "modified", "additions": 51, "deletions": 30, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Funnecessary_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Funnecessary_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Funnecessary_cast.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -1,4 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::get_parent_expr;\n use clippy_utils::numeric_literal::NumericLiteral;\n use clippy_utils::source::snippet_opt;\n use if_chain::if_chain;\n@@ -30,8 +31,10 @@ pub(super) fn check<'tcx>(\n         }\n     }\n \n+    let cast_str = snippet_opt(cx, cast_expr.span).unwrap_or_default();\n+\n     if let Some(lit) = get_numeric_literal(cast_expr) {\n-        let literal_str = snippet_opt(cx, cast_expr.span).unwrap_or_default();\n+        let literal_str = &cast_str;\n \n         if_chain! {\n             if let LitKind::Int(n, _) = lit.node;\n@@ -49,61 +52,79 @@ pub(super) fn check<'tcx>(\n \n         match lit.node {\n             LitKind::Int(_, LitIntType::Unsuffixed) if cast_to.is_integral() => {\n-                lint_unnecessary_cast(cx, expr, &literal_str, cast_from, cast_to);\n+                lint_unnecessary_cast(cx, expr, literal_str, cast_from, cast_to);\n+                return false;\n             },\n             LitKind::Float(_, LitFloatType::Unsuffixed) if cast_to.is_floating_point() => {\n-                lint_unnecessary_cast(cx, expr, &literal_str, cast_from, cast_to);\n+                lint_unnecessary_cast(cx, expr, literal_str, cast_from, cast_to);\n+                return false;\n+            },\n+            LitKind::Int(_, LitIntType::Unsuffixed) | LitKind::Float(_, LitFloatType::Unsuffixed) => {\n+                return false;\n             },\n-            LitKind::Int(_, LitIntType::Unsuffixed) | LitKind::Float(_, LitFloatType::Unsuffixed) => {},\n             LitKind::Int(_, LitIntType::Signed(_) | LitIntType::Unsigned(_))\n             | LitKind::Float(_, LitFloatType::Suffixed(_))\n                 if cast_from.kind() == cast_to.kind() =>\n             {\n                 if let Some(src) = snippet_opt(cx, cast_expr.span) {\n                     if let Some(num_lit) = NumericLiteral::from_lit_kind(&src, &lit.node) {\n                         lint_unnecessary_cast(cx, expr, num_lit.integer, cast_from, cast_to);\n+                        return true;\n                     }\n                 }\n             },\n-            _ => {\n-                if cast_from.kind() == cast_to.kind() && !in_external_macro(cx.sess(), expr.span) {\n-                    span_lint_and_sugg(\n-                        cx,\n-                        UNNECESSARY_CAST,\n-                        expr.span,\n-                        &format!(\n-                            \"casting to the same type is unnecessary (`{}` -> `{}`)\",\n-                            cast_from, cast_to\n-                        ),\n-                        \"try\",\n-                        literal_str,\n-                        Applicability::MachineApplicable,\n-                    );\n-                    return true;\n-                }\n-            },\n+            _ => {},\n         }\n     }\n \n+    if cast_from.kind() == cast_to.kind() && !in_external_macro(cx.sess(), expr.span) {\n+        span_lint_and_sugg(\n+            cx,\n+            UNNECESSARY_CAST,\n+            expr.span,\n+            &format!(\"casting to the same type is unnecessary (`{cast_from}` -> `{cast_to}`)\"),\n+            \"try\",\n+            cast_str,\n+            Applicability::MachineApplicable,\n+        );\n+        return true;\n+    }\n+\n     false\n }\n \n-fn lint_unnecessary_cast(cx: &LateContext<'_>, expr: &Expr<'_>, literal_str: &str, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n+fn lint_unnecessary_cast(\n+    cx: &LateContext<'_>,\n+    expr: &Expr<'_>,\n+    raw_literal_str: &str,\n+    cast_from: Ty<'_>,\n+    cast_to: Ty<'_>,\n+) {\n     let literal_kind_name = if cast_from.is_integral() { \"integer\" } else { \"float\" };\n-    let replaced_literal;\n-    let matchless = if literal_str.contains(['(', ')']) {\n-        replaced_literal = literal_str.replace(['(', ')'], \"\");\n-        &replaced_literal\n-    } else {\n-        literal_str\n+    // first we remove all matches so `-(1)` become `-1`, and remove trailing dots, so `1.` become `1`\n+    let literal_str = raw_literal_str\n+        .replace(['(', ')'], \"\")\n+        .trim_end_matches('.')\n+        .to_string();\n+    // we know need to check if the parent is a method call, to add parenthesis accordingly (eg:\n+    // (-1).foo() instead of -1.foo())\n+    let sugg = if let Some(parent_expr) = get_parent_expr(cx, expr)\n+        && let ExprKind::MethodCall(..) = parent_expr.kind\n+        && literal_str.starts_with('-')\n+        {\n+            format!(\"({literal_str}_{cast_to})\")\n+\n+        } else {\n+            format!(\"{literal_str}_{cast_to}\")\n     };\n+\n     span_lint_and_sugg(\n         cx,\n         UNNECESSARY_CAST,\n         expr.span,\n-        &format!(\"casting {} literal to `{}` is unnecessary\", literal_kind_name, cast_to),\n+        &format!(\"casting {literal_kind_name} literal to `{cast_to}` is unnecessary\"),\n         \"try\",\n-        format!(\"{}_{}\", matchless.trim_end_matches('.'), cast_to),\n+        sugg,\n         Applicability::MachineApplicable,\n     );\n }"}, {"sha": "78e9921f036f3369bd3f5768bb96227c01430fcd", "filename": "src/tools/clippy/clippy_lints/src/checked_conversions.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fchecked_conversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fchecked_conversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fchecked_conversions.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -2,9 +2,8 @@\n \n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::{in_constant, meets_msrv, msrvs, SpanlessEq};\n+use clippy_utils::{in_constant, is_integer_literal, meets_msrv, msrvs, SpanlessEq};\n use if_chain::if_chain;\n-use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::{BinOp, BinOpKind, Expr, ExprKind, QPath, TyKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n@@ -82,7 +81,7 @@ impl<'tcx> LateLintPass<'tcx> for CheckedConversions {\n                     item.span,\n                     \"checked cast can be simplified\",\n                     \"try\",\n-                    format!(\"{}::try_from({}).is_ok()\", to_type, snippet),\n+                    format!(\"{to_type}::try_from({snippet}).is_ok()\"),\n                     applicability,\n                 );\n             }\n@@ -223,16 +222,7 @@ fn check_lower_bound<'tcx>(expr: &'tcx Expr<'tcx>) -> Option<Conversion<'tcx>> {\n \n /// Check for `expr >= 0`\n fn check_lower_bound_zero<'a>(candidate: &'a Expr<'_>, check: &'a Expr<'_>) -> Option<Conversion<'a>> {\n-    if_chain! {\n-        if let ExprKind::Lit(ref lit) = &check.kind;\n-        if let LitKind::Int(0, _) = &lit.node;\n-\n-        then {\n-            Some(Conversion::new_any(candidate))\n-        } else {\n-            None\n-        }\n-    }\n+    is_integer_literal(check, 0).then(|| Conversion::new_any(candidate))\n }\n \n /// Check for `expr >= (to_type::MIN as from_type)`"}, {"sha": "77af3b53d63338ad735d7a46f351975af3343927", "filename": "src/tools/clippy/clippy_lints/src/cognitive_complexity.rs", "status": "modified", "additions": 28, "deletions": 36, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcognitive_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcognitive_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcognitive_complexity.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -3,10 +3,12 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::visitors::for_each_expr;\n use clippy_utils::LimitStack;\n+use core::ops::ControlFlow;\n use rustc_ast::ast::Attribute;\n-use rustc_hir::intravisit::{walk_expr, FnKind, Visitor};\n-use rustc_hir::{Body, Expr, ExprKind, FnDecl, HirId};\n+use rustc_hir::intravisit::FnKind;\n+use rustc_hir::{Body, ExprKind, FnDecl, HirId};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Span;\n@@ -61,11 +63,27 @@ impl CognitiveComplexity {\n             return;\n         }\n \n-        let expr = &body.value;\n+        let expr = body.value;\n+\n+        let mut cc = 1u64;\n+        let mut returns = 0u64;\n+        let _: Option<!> = for_each_expr(expr, |e| {\n+            match e.kind {\n+                ExprKind::If(_, _, _) => {\n+                    cc += 1;\n+                },\n+                ExprKind::Match(_, arms, _) => {\n+                    if arms.len() > 1 {\n+                        cc += 1;\n+                    }\n+                    cc += arms.iter().filter(|arm| arm.guard.is_some()).count() as u64;\n+                },\n+                ExprKind::Ret(_) => returns += 1,\n+                _ => {},\n+            }\n+            ControlFlow::Continue(())\n+        });\n \n-        let mut helper = CcHelper { cc: 1, returns: 0 };\n-        helper.visit_expr(expr);\n-        let CcHelper { cc, returns } = helper;\n         let ret_ty = cx.typeck_results().node_type(expr.hir_id);\n         let ret_adjust = if is_type_diagnostic_item(cx, ret_ty, sym::Result) {\n             returns\n@@ -74,13 +92,12 @@ impl CognitiveComplexity {\n             (returns / 2)\n         };\n \n-        let mut rust_cc = cc;\n         // prevent degenerate cases where unreachable code contains `return` statements\n-        if rust_cc >= ret_adjust {\n-            rust_cc -= ret_adjust;\n+        if cc >= ret_adjust {\n+            cc -= ret_adjust;\n         }\n \n-        if rust_cc > self.limit.limit() {\n+        if cc > self.limit.limit() {\n             let fn_span = match kind {\n                 FnKind::ItemFn(ident, _, _) | FnKind::Method(ident, _) => ident.span,\n                 FnKind::Closure => {\n@@ -107,8 +124,7 @@ impl CognitiveComplexity {\n                 COGNITIVE_COMPLEXITY,\n                 fn_span,\n                 &format!(\n-                    \"the function has a cognitive complexity of ({}/{})\",\n-                    rust_cc,\n+                    \"the function has a cognitive complexity of ({cc}/{})\",\n                     self.limit.limit()\n                 ),\n                 None,\n@@ -141,27 +157,3 @@ impl<'tcx> LateLintPass<'tcx> for CognitiveComplexity {\n         self.limit.pop_attrs(cx.sess(), attrs, \"cognitive_complexity\");\n     }\n }\n-\n-struct CcHelper {\n-    cc: u64,\n-    returns: u64,\n-}\n-\n-impl<'tcx> Visitor<'tcx> for CcHelper {\n-    fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n-        walk_expr(self, e);\n-        match e.kind {\n-            ExprKind::If(_, _, _) => {\n-                self.cc += 1;\n-            },\n-            ExprKind::Match(_, arms, _) => {\n-                if arms.len() > 1 {\n-                    self.cc += 1;\n-                }\n-                self.cc += arms.iter().filter(|arm| arm.guard.is_some()).count() as u64;\n-            },\n-            ExprKind::Ret(_) => self.returns += 1,\n-            _ => {},\n-        }\n-    }\n-}"}, {"sha": "7f937de1dd3120f594436fc8facb97be30e72316", "filename": "src/tools/clippy/clippy_lints/src/default.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -105,7 +105,7 @@ impl<'tcx> LateLintPass<'tcx> for Default {\n                     cx,\n                     DEFAULT_TRAIT_ACCESS,\n                     expr.span,\n-                    &format!(\"calling `{}` is more clear than this expression\", replacement),\n+                    &format!(\"calling `{replacement}` is more clear than this expression\"),\n                     \"try\",\n                     replacement,\n                     Applicability::Unspecified, // First resolve the TODO above\n@@ -210,7 +210,7 @@ impl<'tcx> LateLintPass<'tcx> for Default {\n                     .map(|(field, rhs)| {\n                         // extract and store the assigned value for help message\n                         let value_snippet = snippet_with_macro_callsite(cx, rhs.span, \"..\");\n-                        format!(\"{}: {}\", field, value_snippet)\n+                        format!(\"{field}: {value_snippet}\")\n                     })\n                     .collect::<Vec<String>>()\n                     .join(\", \");\n@@ -227,20 +227,20 @@ impl<'tcx> LateLintPass<'tcx> for Default {\n                             .map(ToString::to_string)\n                             .collect::<Vec<_>>()\n                             .join(\", \");\n-                        format!(\"{}::<{}>\", adt_def_ty_name, &tys_str)\n+                        format!(\"{adt_def_ty_name}::<{}>\", &tys_str)\n                     } else {\n                         binding_type.to_string()\n                     }\n                 };\n \n                 let sugg = if ext_with_default {\n                     if field_list.is_empty() {\n-                        format!(\"{}::default()\", binding_type)\n+                        format!(\"{binding_type}::default()\")\n                     } else {\n-                        format!(\"{} {{ {}, ..Default::default() }}\", binding_type, field_list)\n+                        format!(\"{binding_type} {{ {field_list}, ..Default::default() }}\")\n                     }\n                 } else {\n-                    format!(\"{} {{ {} }}\", binding_type, field_list)\n+                    format!(\"{binding_type} {{ {field_list} }}\")\n                 };\n \n                 // span lint once per statement that binds default\n@@ -250,10 +250,7 @@ impl<'tcx> LateLintPass<'tcx> for Default {\n                     first_assign.unwrap().span,\n                     \"field assignment outside of initializer for an instance created with Default::default()\",\n                     Some(local.span),\n-                    &format!(\n-                        \"consider initializing the variable with `{}` and removing relevant reassignments\",\n-                        sugg\n-                    ),\n+                    &format!(\"consider initializing the variable with `{sugg}` and removing relevant reassignments\"),\n                 );\n                 self.reassigned_linted.insert(span);\n             }"}, {"sha": "1ad929864b2a0061bcbb413afce05ec4e171fdf7", "filename": "src/tools/clippy/clippy_lints/src/default_instead_of_iter_empty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_instead_of_iter_empty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_instead_of_iter_empty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_instead_of_iter_empty.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -23,7 +23,7 @@ declare_clippy_lint! {\n     /// let _ = std::iter::empty::<usize>();\n     /// let iter: std::iter::Empty<usize> = std::iter::empty();\n     /// ```\n-    #[clippy::version = \"1.63.0\"]\n+    #[clippy::version = \"1.64.0\"]\n     pub DEFAULT_INSTEAD_OF_ITER_EMPTY,\n     style,\n     \"check `std::iter::Empty::default()` and replace with `std::iter::empty()`\""}, {"sha": "3ed9cd36a2292a171e0ff63e7e2574ef5c8e7aea", "filename": "src/tools/clippy/clippy_lints/src/default_numeric_fallback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -95,8 +95,8 @@ impl<'a, 'tcx> NumericFallbackVisitor<'a, 'tcx> {\n                         src\n                     } else {\n                         match lit.node {\n-                            LitKind::Int(src, _) => format!(\"{}\", src),\n-                            LitKind::Float(src, _) => format!(\"{}\", src),\n+                            LitKind::Int(src, _) => format!(\"{src}\"),\n+                            LitKind::Float(src, _) => format!(\"{src}\"),\n                             _ => return,\n                         }\n                     };"}, {"sha": "741edc1319609004c4e9ed087025aae0f70c5856", "filename": "src/tools/clippy/clippy_lints/src/default_union_representation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_union_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_union_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_union_representation.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -1,10 +1,10 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n use rustc_hir::{self as hir, HirId, Item, ItemKind};\n+use rustc_hir_analysis::hir_ty_to_ty;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::layout::LayoutOf;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::sym;\n-use rustc_hir_analysis::hir_ty_to_ty;\n \n declare_clippy_lint! {\n     /// ### What it does"}, {"sha": "3cd8f236e7a5fdc6fe061eccc1f8a9fe796779e4", "filename": "src/tools/clippy/clippy_lints/src/dereference.rs", "status": "modified", "additions": 37, "deletions": 16, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -135,7 +135,7 @@ declare_clippy_lint! {\n     /// let x = String::new();\n     /// let y: &str = &x;\n     /// ```\n-    #[clippy::version = \"1.60.0\"]\n+    #[clippy::version = \"1.64.0\"]\n     pub EXPLICIT_AUTO_DEREF,\n     complexity,\n     \"dereferencing when the compiler would automatically dereference\"\n@@ -184,19 +184,22 @@ impl Dereferencing {\n     }\n }\n \n+#[derive(Debug)]\n struct StateData {\n     /// Span of the top level expression\n     span: Span,\n     hir_id: HirId,\n     position: Position,\n }\n \n+#[derive(Debug)]\n struct DerefedBorrow {\n     count: usize,\n     msg: &'static str,\n     snip_expr: Option<HirId>,\n }\n \n+#[derive(Debug)]\n enum State {\n     // Any number of deref method calls.\n     DerefMethod {\n@@ -276,10 +279,12 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n             (None, kind) => {\n                 let expr_ty = typeck.expr_ty(expr);\n                 let (position, adjustments) = walk_parents(cx, expr, self.msrv);\n-\n                 match kind {\n                     RefOp::Deref => {\n-                        if let Position::FieldAccess(name) = position\n+                        if let Position::FieldAccess {\n+                            name,\n+                            of_union: false,\n+                        } = position\n                             && !ty_contains_field(typeck.expr_ty(sub_expr), name)\n                         {\n                             self.state = Some((\n@@ -451,7 +456,7 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n             (Some((State::DerefedBorrow(state), data)), RefOp::Deref) => {\n                 let position = data.position;\n                 report(cx, expr, State::DerefedBorrow(state), data);\n-                if let Position::FieldAccess(name) = position\n+                if let Position::FieldAccess{name, ..} = position\n                     && !ty_contains_field(typeck.expr_ty(sub_expr), name)\n                 {\n                     self.state = Some((\n@@ -616,14 +621,17 @@ fn deref_method_same_type<'tcx>(result_ty: Ty<'tcx>, arg_ty: Ty<'tcx>) -> bool {\n }\n \n /// The position of an expression relative to it's parent.\n-#[derive(Clone, Copy)]\n+#[derive(Clone, Copy, Debug)]\n enum Position {\n     MethodReceiver,\n     /// The method is defined on a reference type. e.g. `impl Foo for &T`\n     MethodReceiverRefImpl,\n     Callee,\n     ImplArg(HirId),\n-    FieldAccess(Symbol),\n+    FieldAccess {\n+        name: Symbol,\n+        of_union: bool,\n+    }, // union fields cannot be auto borrowed\n     Postfix,\n     Deref,\n     /// Any other location which will trigger auto-deref to a specific time.\n@@ -645,7 +653,10 @@ impl Position {\n     }\n \n     fn can_auto_borrow(self) -> bool {\n-        matches!(self, Self::MethodReceiver | Self::FieldAccess(_) | Self::Callee)\n+        matches!(\n+            self,\n+            Self::MethodReceiver | Self::FieldAccess { of_union: false, .. } | Self::Callee\n+        )\n     }\n \n     fn lint_explicit_deref(self) -> bool {\n@@ -657,7 +668,7 @@ impl Position {\n             Self::MethodReceiver\n             | Self::MethodReceiverRefImpl\n             | Self::Callee\n-            | Self::FieldAccess(_)\n+            | Self::FieldAccess { .. }\n             | Self::Postfix => PREC_POSTFIX,\n             Self::ImplArg(_) | Self::Deref => PREC_PREFIX,\n             Self::DerefStable(p, _) | Self::ReborrowStable(p) | Self::Other(p) => p,\n@@ -844,7 +855,10 @@ fn walk_parents<'tcx>(\n                         }\n                     })\n                 },\n-                ExprKind::Field(child, name) if child.hir_id == e.hir_id => Some(Position::FieldAccess(name.name)),\n+                ExprKind::Field(child, name) if child.hir_id == e.hir_id => Some(Position::FieldAccess {\n+                    name: name.name,\n+                    of_union: is_union(cx.typeck_results(), child),\n+                }),\n                 ExprKind::Unary(UnOp::Deref, child) if child.hir_id == e.hir_id => Some(Position::Deref),\n                 ExprKind::Match(child, _, MatchSource::TryDesugar | MatchSource::AwaitDesugar)\n                 | ExprKind::Index(child, _)\n@@ -865,6 +879,13 @@ fn walk_parents<'tcx>(\n     (position, adjustments)\n }\n \n+fn is_union<'tcx>(typeck: &'tcx TypeckResults<'_>, path_expr: &'tcx Expr<'_>) -> bool {\n+    typeck\n+        .expr_ty_adjusted(path_expr)\n+        .ty_adt_def()\n+        .map_or(false, rustc_middle::ty::AdtDef::is_union)\n+}\n+\n fn closure_result_position<'tcx>(\n     cx: &LateContext<'tcx>,\n     closure: &'tcx Closure<'_>,\n@@ -1308,7 +1329,7 @@ fn report<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, state: State, data\n             };\n \n             let expr_str = if !expr_is_macro_call && is_final_ufcs && expr.precedence().order() < PREC_PREFIX {\n-                format!(\"({})\", expr_str)\n+                format!(\"({expr_str})\")\n             } else {\n                 expr_str.into_owned()\n             };\n@@ -1322,7 +1343,7 @@ fn report<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, state: State, data\n                     Mutability::Mut => \"explicit `deref_mut` method call\",\n                 },\n                 \"try this\",\n-                format!(\"{}{}{}\", addr_of_str, deref_str, expr_str),\n+                format!(\"{addr_of_str}{deref_str}{expr_str}\"),\n                 app,\n             );\n         },\n@@ -1336,7 +1357,7 @@ fn report<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, state: State, data\n                     && !has_enclosing_paren(&snip)\n                     && (expr.precedence().order() < data.position.precedence() || calls_field)\n                 {\n-                    format!(\"({})\", snip)\n+                    format!(\"({snip})\")\n                 } else {\n                     snip.into()\n                 };\n@@ -1379,9 +1400,9 @@ fn report<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, state: State, data\n                     let (snip, snip_is_macro) = snippet_with_context(cx, expr.span, data.span.ctxt(), \"..\", &mut app);\n                     let sugg =\n                         if !snip_is_macro && expr.precedence().order() < precedence && !has_enclosing_paren(&snip) {\n-                            format!(\"{}({})\", prefix, snip)\n+                            format!(\"{prefix}({snip})\")\n                         } else {\n-                            format!(\"{}{}\", prefix, snip)\n+                            format!(\"{prefix}{snip}\")\n                         };\n                     diag.span_suggestion(data.span, \"try this\", sugg, app);\n                 },\n@@ -1460,14 +1481,14 @@ impl Dereferencing {\n                             } else {\n                                 pat.always_deref = false;\n                                 let snip = snippet_with_context(cx, e.span, parent.span.ctxt(), \"..\", &mut pat.app).0;\n-                                pat.replacements.push((e.span, format!(\"&{}\", snip)));\n+                                pat.replacements.push((e.span, format!(\"&{snip}\")));\n                             }\n                         },\n                         _ if !e.span.from_expansion() => {\n                             // Double reference might be needed at this point.\n                             pat.always_deref = false;\n                             let snip = snippet_with_applicability(cx, e.span, \"..\", &mut pat.app);\n-                            pat.replacements.push((e.span, format!(\"&{}\", snip)));\n+                            pat.replacements.push((e.span, format!(\"&{snip}\")));\n                         },\n                         // Edge case for macros. The span of the identifier will usually match the context of the\n                         // binding, but not if the identifier was created in a macro. e.g. `concat_idents` and proc"}, {"sha": "3fac93dcc90c504f2f26dc9df219a1688b4f9ac9", "filename": "src/tools/clippy/clippy_lints/src/derive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -191,7 +191,7 @@ declare_clippy_lint! {\n     /// ```\n     #[clippy::version = \"1.63.0\"]\n     pub DERIVE_PARTIAL_EQ_WITHOUT_EQ,\n-    style,\n+    nursery,\n     \"deriving `PartialEq` on a type that can implement `Eq`, without implementing `Eq`\"\n }\n "}, {"sha": "5ab7144e29098b7d4a877804d8dab723943f65c5", "filename": "src/tools/clippy/clippy_lints/src/disallowed_macros.rs", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdisallowed_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdisallowed_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdisallowed_macros.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -0,0 +1,151 @@\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::macros::macro_backtrace;\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_hir::def::{Namespace, Res};\n+use rustc_hir::def_id::DefIdMap;\n+use rustc_hir::{Expr, ForeignItem, HirId, ImplItem, Item, Pat, Path, Stmt, TraitItem, Ty};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::{ExpnId, Span};\n+\n+use crate::utils::conf;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Denies the configured macros in clippy.toml\n+    ///\n+    /// Note: Even though this lint is warn-by-default, it will only trigger if\n+    /// macros are defined in the clippy.toml file.\n+    ///\n+    /// ### Why is this bad?\n+    /// Some macros are undesirable in certain contexts, and it's beneficial to\n+    /// lint for them as needed.\n+    ///\n+    /// ### Example\n+    /// An example clippy.toml configuration:\n+    /// ```toml\n+    /// # clippy.toml\n+    /// disallowed-macros = [\n+    ///     # Can use a string as the path of the disallowed macro.\n+    ///     \"std::print\",\n+    ///     # Can also use an inline table with a `path` key.\n+    ///     { path = \"std::println\" },\n+    ///     # When using an inline table, can add a `reason` for why the macro\n+    ///     # is disallowed.\n+    ///     { path = \"serde::Serialize\", reason = \"no serializing\" },\n+    /// ]\n+    /// ```\n+    /// ```\n+    /// use serde::Serialize;\n+    ///\n+    /// // Example code where clippy issues a warning\n+    /// println!(\"warns\");\n+    ///\n+    /// // The diagnostic will contain the message \"no serializing\"\n+    /// #[derive(Serialize)]\n+    /// struct Data {\n+    ///     name: String,\n+    ///     value: usize,\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.65.0\"]\n+    pub DISALLOWED_MACROS,\n+    style,\n+    \"use of a disallowed macro\"\n+}\n+\n+pub struct DisallowedMacros {\n+    conf_disallowed: Vec<conf::DisallowedPath>,\n+    disallowed: DefIdMap<usize>,\n+    seen: FxHashSet<ExpnId>,\n+}\n+\n+impl DisallowedMacros {\n+    pub fn new(conf_disallowed: Vec<conf::DisallowedPath>) -> Self {\n+        Self {\n+            conf_disallowed,\n+            disallowed: DefIdMap::default(),\n+            seen: FxHashSet::default(),\n+        }\n+    }\n+\n+    fn check(&mut self, cx: &LateContext<'_>, span: Span) {\n+        if self.conf_disallowed.is_empty() {\n+            return;\n+        }\n+\n+        for mac in macro_backtrace(span) {\n+            if !self.seen.insert(mac.expn) {\n+                return;\n+            }\n+\n+            if let Some(&index) = self.disallowed.get(&mac.def_id) {\n+                let conf = &self.conf_disallowed[index];\n+\n+                span_lint_and_then(\n+                    cx,\n+                    DISALLOWED_MACROS,\n+                    mac.span,\n+                    &format!(\"use of a disallowed macro `{}`\", conf.path()),\n+                    |diag| {\n+                        if let Some(reason) = conf.reason() {\n+                            diag.note(&format!(\"{reason} (from clippy.toml)\"));\n+                        }\n+                    },\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+impl_lint_pass!(DisallowedMacros => [DISALLOWED_MACROS]);\n+\n+impl LateLintPass<'_> for DisallowedMacros {\n+    fn check_crate(&mut self, cx: &LateContext<'_>) {\n+        for (index, conf) in self.conf_disallowed.iter().enumerate() {\n+            let segs: Vec<_> = conf.path().split(\"::\").collect();\n+            if let Res::Def(_, id) = clippy_utils::def_path_res(cx, &segs, Some(Namespace::MacroNS)) {\n+                self.disallowed.insert(id, index);\n+            }\n+        }\n+    }\n+\n+    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n+        self.check(cx, expr.span);\n+    }\n+\n+    fn check_stmt(&mut self, cx: &LateContext<'_>, stmt: &Stmt<'_>) {\n+        self.check(cx, stmt.span);\n+    }\n+\n+    fn check_ty(&mut self, cx: &LateContext<'_>, ty: &Ty<'_>) {\n+        self.check(cx, ty.span);\n+    }\n+\n+    fn check_pat(&mut self, cx: &LateContext<'_>, pat: &Pat<'_>) {\n+        self.check(cx, pat.span);\n+    }\n+\n+    fn check_item(&mut self, cx: &LateContext<'_>, item: &Item<'_>) {\n+        self.check(cx, item.span);\n+        self.check(cx, item.vis_span);\n+    }\n+\n+    fn check_foreign_item(&mut self, cx: &LateContext<'_>, item: &ForeignItem<'_>) {\n+        self.check(cx, item.span);\n+        self.check(cx, item.vis_span);\n+    }\n+\n+    fn check_impl_item(&mut self, cx: &LateContext<'_>, item: &ImplItem<'_>) {\n+        self.check(cx, item.span);\n+        self.check(cx, item.vis_span);\n+    }\n+\n+    fn check_trait_item(&mut self, cx: &LateContext<'_>, item: &TraitItem<'_>) {\n+        self.check(cx, item.span);\n+    }\n+\n+    fn check_path(&mut self, cx: &LateContext<'_>, path: &Path<'_>, _: HirId) {\n+        self.check(cx, path.span);\n+    }\n+}"}, {"sha": "1a381f92c0314f7c06048682e984665c213f4aeb", "filename": "src/tools/clippy/clippy_lints/src/disallowed_methods.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdisallowed_methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdisallowed_methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdisallowed_methods.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -1,7 +1,9 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::{fn_def_id, get_parent_expr, path_def_id};\n \n-use rustc_hir::{def::Res, def_id::DefIdMap, Expr, ExprKind};\n+use rustc_hir::def::{Namespace, Res};\n+use rustc_hir::def_id::DefIdMap;\n+use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n \n@@ -58,12 +60,12 @@ declare_clippy_lint! {\n \n #[derive(Clone, Debug)]\n pub struct DisallowedMethods {\n-    conf_disallowed: Vec<conf::DisallowedMethod>,\n+    conf_disallowed: Vec<conf::DisallowedPath>,\n     disallowed: DefIdMap<usize>,\n }\n \n impl DisallowedMethods {\n-    pub fn new(conf_disallowed: Vec<conf::DisallowedMethod>) -> Self {\n+    pub fn new(conf_disallowed: Vec<conf::DisallowedPath>) -> Self {\n         Self {\n             conf_disallowed,\n             disallowed: DefIdMap::default(),\n@@ -77,7 +79,7 @@ impl<'tcx> LateLintPass<'tcx> for DisallowedMethods {\n     fn check_crate(&mut self, cx: &LateContext<'_>) {\n         for (index, conf) in self.conf_disallowed.iter().enumerate() {\n             let segs: Vec<_> = conf.path().split(\"::\").collect();\n-            if let Res::Def(_, id) = clippy_utils::def_path_res(cx, &segs) {\n+            if let Res::Def(_, id) = clippy_utils::def_path_res(cx, &segs, Some(Namespace::ValueNS)) {\n                 self.disallowed.insert(id, index);\n             }\n         }\n@@ -102,11 +104,8 @@ impl<'tcx> LateLintPass<'tcx> for DisallowedMethods {\n         };\n         let msg = format!(\"use of a disallowed method `{}`\", conf.path());\n         span_lint_and_then(cx, DISALLOWED_METHODS, expr.span, &msg, |diag| {\n-            if let conf::DisallowedMethod::WithReason {\n-                reason: Some(reason), ..\n-            } = conf\n-            {\n-                diag.note(&format!(\"{} (from clippy.toml)\", reason));\n+            if let Some(reason) = conf.reason() {\n+                diag.note(&format!(\"{reason} (from clippy.toml)\"));\n             }\n         });\n     }"}, {"sha": "084190f00132ce04e9b0ffb600165cc320b8ff16", "filename": "src/tools/clippy/clippy_lints/src/disallowed_script_idents.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdisallowed_script_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdisallowed_script_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdisallowed_script_idents.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -99,8 +99,7 @@ impl EarlyLintPass for DisallowedScriptIdents {\n                         DISALLOWED_SCRIPT_IDENTS,\n                         span,\n                         &format!(\n-                            \"identifier `{}` has a Unicode script that is not allowed by configuration: {}\",\n-                            symbol_str,\n+                            \"identifier `{symbol_str}` has a Unicode script that is not allowed by configuration: {}\",\n                             script.full_name()\n                         ),\n                     );"}, {"sha": "c7131fc164d3e47d08feb845f720245d9e94e829", "filename": "src/tools/clippy/clippy_lints/src/disallowed_types.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdisallowed_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdisallowed_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdisallowed_types.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -1,9 +1,9 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n \n use rustc_data_structures::fx::FxHashMap;\n-use rustc_hir::{\n-    def::Res, def_id::DefId, Item, ItemKind, PolyTraitRef, PrimTy, Ty, TyKind, UseKind,\n-};\n+use rustc_hir::def::{Namespace, Res};\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::{Item, ItemKind, PolyTraitRef, PrimTy, Ty, TyKind, UseKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::Span;\n@@ -52,13 +52,13 @@ declare_clippy_lint! {\n }\n #[derive(Clone, Debug)]\n pub struct DisallowedTypes {\n-    conf_disallowed: Vec<conf::DisallowedType>,\n+    conf_disallowed: Vec<conf::DisallowedPath>,\n     def_ids: FxHashMap<DefId, Option<String>>,\n     prim_tys: FxHashMap<PrimTy, Option<String>>,\n }\n \n impl DisallowedTypes {\n-    pub fn new(conf_disallowed: Vec<conf::DisallowedType>) -> Self {\n+    pub fn new(conf_disallowed: Vec<conf::DisallowedPath>) -> Self {\n         Self {\n             conf_disallowed,\n             def_ids: FxHashMap::default(),\n@@ -88,15 +88,9 @@ impl_lint_pass!(DisallowedTypes => [DISALLOWED_TYPES]);\n impl<'tcx> LateLintPass<'tcx> for DisallowedTypes {\n     fn check_crate(&mut self, cx: &LateContext<'_>) {\n         for conf in &self.conf_disallowed {\n-            let (path, reason) = match conf {\n-                conf::DisallowedType::Simple(path) => (path, None),\n-                conf::DisallowedType::WithReason { path, reason } => (\n-                    path,\n-                    reason.as_ref().map(|reason| format!(\"{} (from clippy.toml)\", reason)),\n-                ),\n-            };\n-            let segs: Vec<_> = path.split(\"::\").collect();\n-            match clippy_utils::def_path_res(cx, &segs) {\n+            let segs: Vec<_> = conf.path().split(\"::\").collect();\n+            let reason = conf.reason().map(|reason| format!(\"{reason} (from clippy.toml)\"));\n+            match clippy_utils::def_path_res(cx, &segs, Some(Namespace::TypeNS)) {\n                 Res::Def(_, id) => {\n                     self.def_ids.insert(id, reason);\n                 },\n@@ -130,7 +124,7 @@ fn emit(cx: &LateContext<'_>, name: &str, span: Span, reason: Option<&str>) {\n         cx,\n         DISALLOWED_TYPES,\n         span,\n-        &format!(\"`{}` is not allowed according to config\", name),\n+        &format!(\"`{name}` is not allowed according to config\"),\n         |diag| {\n             if let Some(reason) = reason {\n                 diag.note(reason);"}, {"sha": "36dc7e3396b824205791f1303124cd7e074fdf07", "filename": "src/tools/clippy/clippy_lints/src/doc.rs", "status": "modified", "additions": 75, "deletions": 17, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -198,6 +198,29 @@ declare_clippy_lint! {\n     \"presence of `fn main() {` in code examples\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Detects the syntax `['foo']` in documentation comments (notice quotes instead of backticks)\n+    /// outside of code blocks\n+    /// ### Why is this bad?\n+    /// It is likely a typo when defining an intra-doc link\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// /// See also: ['foo']\n+    /// fn bar() {}\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// /// See also: [`foo`]\n+    /// fn bar() {}\n+    /// ```\n+    #[clippy::version = \"1.63.0\"]\n+    pub DOC_LINK_WITH_QUOTES,\n+    pedantic,\n+    \"possible typo for an intra-doc link\"\n+}\n+\n #[expect(clippy::module_name_repetitions)]\n #[derive(Clone)]\n pub struct DocMarkdown {\n@@ -214,9 +237,14 @@ impl DocMarkdown {\n     }\n }\n \n-impl_lint_pass!(DocMarkdown =>\n-    [DOC_MARKDOWN, MISSING_SAFETY_DOC, MISSING_ERRORS_DOC, MISSING_PANICS_DOC, NEEDLESS_DOCTEST_MAIN]\n-);\n+impl_lint_pass!(DocMarkdown => [\n+    DOC_LINK_WITH_QUOTES,\n+    DOC_MARKDOWN,\n+    MISSING_SAFETY_DOC,\n+    MISSING_ERRORS_DOC,\n+    MISSING_PANICS_DOC,\n+    NEEDLESS_DOCTEST_MAIN\n+]);\n \n impl<'tcx> LateLintPass<'tcx> for DocMarkdown {\n     fn check_crate(&mut self, cx: &LateContext<'tcx>) {\n@@ -237,7 +265,15 @@ impl<'tcx> LateLintPass<'tcx> for DocMarkdown {\n                         panic_span: None,\n                     };\n                     fpu.visit_expr(body.value);\n-                    lint_for_missing_headers(cx, item.def_id.def_id, item.span, sig, headers, Some(body_id), fpu.panic_span);\n+                    lint_for_missing_headers(\n+                        cx,\n+                        item.def_id.def_id,\n+                        item.span,\n+                        sig,\n+                        headers,\n+                        Some(body_id),\n+                        fpu.panic_span,\n+                    );\n                 }\n             },\n             hir::ItemKind::Impl(impl_) => {\n@@ -287,7 +323,15 @@ impl<'tcx> LateLintPass<'tcx> for DocMarkdown {\n                 panic_span: None,\n             };\n             fpu.visit_expr(body.value);\n-            lint_for_missing_headers(cx, item.def_id.def_id, item.span, sig, headers, Some(body_id), fpu.panic_span);\n+            lint_for_missing_headers(\n+                cx,\n+                item.def_id.def_id,\n+                item.span,\n+                sig,\n+                headers,\n+                Some(body_id),\n+                fpu.panic_span,\n+            );\n         }\n     }\n }\n@@ -416,7 +460,7 @@ pub fn strip_doc_comment_decoration(doc: &str, comment_kind: CommentKind, span:\n     (no_stars, sizes)\n }\n \n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Default)]\n struct DocHeaders {\n     safety: bool,\n     errors: bool,\n@@ -460,11 +504,7 @@ fn check_attrs<'a>(cx: &LateContext<'_>, valid_idents: &FxHashSet<String>, attrs\n     }\n \n     if doc.is_empty() {\n-        return DocHeaders {\n-            safety: false,\n-            errors: false,\n-            panics: false,\n-        };\n+        return DocHeaders::default();\n     }\n \n     let mut cb = fake_broken_link_callback;\n@@ -505,11 +545,7 @@ fn check_doc<'a, Events: Iterator<Item = (pulldown_cmark::Event<'a>, Range<usize\n     use pulldown_cmark::Tag::{CodeBlock, Heading, Item, Link, Paragraph};\n     use pulldown_cmark::{CodeBlockKind, CowStr};\n \n-    let mut headers = DocHeaders {\n-        safety: false,\n-        errors: false,\n-        panics: false,\n-    };\n+    let mut headers = DocHeaders::default();\n     let mut in_code = false;\n     let mut in_link = None;\n     let mut in_heading = false;\n@@ -596,6 +632,7 @@ fn check_doc<'a, Events: Iterator<Item = (pulldown_cmark::Event<'a>, Range<usize\n                         check_code(cx, &text, edition, span);\n                     }\n                 } else {\n+                    check_link_quotes(cx, in_link.is_some(), trimmed_text, span, &range, begin, text.len());\n                     // Adjust for the beginning of the current `Event`\n                     let span = span.with_lo(span.lo() + BytePos::from_usize(range.start - begin));\n                     text_to_check.push((text, span));\n@@ -606,6 +643,27 @@ fn check_doc<'a, Events: Iterator<Item = (pulldown_cmark::Event<'a>, Range<usize\n     headers\n }\n \n+fn check_link_quotes(\n+    cx: &LateContext<'_>,\n+    in_link: bool,\n+    trimmed_text: &str,\n+    span: Span,\n+    range: &Range<usize>,\n+    begin: usize,\n+    text_len: usize,\n+) {\n+    if in_link && trimmed_text.starts_with('\\'') && trimmed_text.ends_with('\\'') {\n+        // fix the span to only point at the text within the link\n+        let lo = span.lo() + BytePos::from_usize(range.start - begin);\n+        span_lint(\n+            cx,\n+            DOC_LINK_WITH_QUOTES,\n+            span.with_lo(lo).with_hi(lo + BytePos::from_usize(text_len)),\n+            \"possible intra-doc link using quotes instead of backticks\",\n+        );\n+    }\n+}\n+\n fn get_current_span(spans: &[(usize, Span)], idx: usize) -> (usize, Span) {\n     let index = match spans.binary_search_by(|c| c.0.cmp(&idx)) {\n         Ok(o) => o,\n@@ -790,7 +848,7 @@ fn check_word(cx: &LateContext<'_>, word: &str, span: Span) {\n                 diag.span_suggestion_with_style(\n                     span,\n                     \"try\",\n-                    format!(\"`{}`\", snippet),\n+                    format!(\"`{snippet}`\"),\n                     applicability,\n                     // always show the suggestion in a separate line, since the\n                     // inline presentation adds another pair of backticks"}, {"sha": "0ff1d2755daf6284c5babcdc77a6989e05497f61", "filename": "src/tools/clippy/clippy_lints/src/doc_link_with_quotes.rs", "status": "removed", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/0ca356586fed56002b10920fd21ddf6fb12de797/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc_link_with_quotes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca356586fed56002b10920fd21ddf6fb12de797/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc_link_with_quotes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc_link_with_quotes.rs?ref=0ca356586fed56002b10920fd21ddf6fb12de797", "patch": "@@ -1,60 +0,0 @@\n-use clippy_utils::diagnostics::span_lint;\n-use itertools::Itertools;\n-use rustc_ast::{AttrKind, Attribute};\n-use rustc_lint::{EarlyContext, EarlyLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Detects the syntax `['foo']` in documentation comments (notice quotes instead of backticks)\n-    /// outside of code blocks\n-    /// ### Why is this bad?\n-    /// It is likely a typo when defining an intra-doc link\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// /// See also: ['foo']\n-    /// fn bar() {}\n-    /// ```\n-    /// Use instead:\n-    /// ```rust\n-    /// /// See also: [`foo`]\n-    /// fn bar() {}\n-    /// ```\n-    #[clippy::version = \"1.63.0\"]\n-    pub DOC_LINK_WITH_QUOTES,\n-    pedantic,\n-    \"possible typo for an intra-doc link\"\n-}\n-declare_lint_pass!(DocLinkWithQuotes => [DOC_LINK_WITH_QUOTES]);\n-\n-impl EarlyLintPass for DocLinkWithQuotes {\n-    fn check_attribute(&mut self, ctx: &EarlyContext<'_>, attr: &Attribute) {\n-        if let AttrKind::DocComment(_, symbol) = attr.kind {\n-            if contains_quote_link(symbol.as_str()) {\n-                span_lint(\n-                    ctx,\n-                    DOC_LINK_WITH_QUOTES,\n-                    attr.span,\n-                    \"possible intra-doc link using quotes instead of backticks\",\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-fn contains_quote_link(s: &str) -> bool {\n-    let mut in_backticks = false;\n-    let mut found_opening = false;\n-\n-    for c in s.chars().tuple_windows::<(char, char)>() {\n-        match c {\n-            ('`', _) => in_backticks = !in_backticks,\n-            ('[', '\\'') if !in_backticks => found_opening = true,\n-            ('\\'', ']') if !in_backticks && found_opening => return true,\n-            _ => {},\n-        }\n-    }\n-\n-    false\n-}"}, {"sha": "4721a7b370567c5ebb3a23275de952275d3a2912", "filename": "src/tools/clippy/clippy_lints/src/drop_forget_ref.rs", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdrop_forget_ref.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -1,7 +1,8 @@\n use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_note};\n+use clippy_utils::get_parent_node;\n use clippy_utils::is_must_use_func_call;\n use clippy_utils::ty::{is_copy, is_must_use_ty, is_type_lang_item};\n-use rustc_hir::{Expr, ExprKind, LangItem};\n+use rustc_hir::{Arm, Expr, ExprKind, LangItem, Node};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::sym;\n@@ -202,11 +203,13 @@ impl<'tcx> LateLintPass<'tcx> for DropForgetRef {\n             && let Some(fn_name) = cx.tcx.get_diagnostic_name(def_id)\n         {\n             let arg_ty = cx.typeck_results().expr_ty(arg);\n+            let is_copy = is_copy(cx, arg_ty);\n+            let drop_is_single_call_in_arm = is_single_call_in_arm(cx, arg, expr);\n             let (lint, msg) = match fn_name {\n                 sym::mem_drop if arg_ty.is_ref() => (DROP_REF, DROP_REF_SUMMARY),\n                 sym::mem_forget if arg_ty.is_ref() => (FORGET_REF, FORGET_REF_SUMMARY),\n-                sym::mem_drop if is_copy(cx, arg_ty) => (DROP_COPY, DROP_COPY_SUMMARY),\n-                sym::mem_forget if is_copy(cx, arg_ty) => (FORGET_COPY, FORGET_COPY_SUMMARY),\n+                sym::mem_drop if is_copy && !drop_is_single_call_in_arm => (DROP_COPY, DROP_COPY_SUMMARY),\n+                sym::mem_forget if is_copy => (FORGET_COPY, FORGET_COPY_SUMMARY),\n                 sym::mem_drop if is_type_lang_item(cx, arg_ty, LangItem::ManuallyDrop) => {\n                     span_lint_and_help(\n                         cx,\n@@ -221,7 +224,9 @@ impl<'tcx> LateLintPass<'tcx> for DropForgetRef {\n                 sym::mem_drop\n                     if !(arg_ty.needs_drop(cx.tcx, cx.param_env)\n                         || is_must_use_func_call(cx, arg)\n-                        || is_must_use_ty(cx, arg_ty)) =>\n+                        || is_must_use_ty(cx, arg_ty)\n+                        || drop_is_single_call_in_arm\n+                        ) =>\n                 {\n                     (DROP_NON_DROP, DROP_NON_DROP_SUMMARY)\n                 },\n@@ -236,8 +241,23 @@ impl<'tcx> LateLintPass<'tcx> for DropForgetRef {\n                 expr.span,\n                 msg,\n                 Some(arg.span),\n-                &format!(\"argument has type `{}`\", arg_ty),\n+                &format!(\"argument has type `{arg_ty}`\"),\n             );\n         }\n     }\n }\n+\n+// dropping returned value of a function like in the following snippet is considered idiomatic, see\n+// #9482 for examples match <var> {\n+//     <pat> => drop(fn_with_side_effect_and_returning_some_value()),\n+//     ..\n+// }\n+fn is_single_call_in_arm<'tcx>(cx: &LateContext<'tcx>, arg: &'tcx Expr<'_>, drop_expr: &'tcx Expr<'_>) -> bool {\n+    if matches!(arg.kind, ExprKind::Call(..) | ExprKind::MethodCall(..)) {\n+        let parent_node = get_parent_node(cx.tcx, drop_expr.hir_id);\n+        if let Some(Node::Arm(Arm { body, .. })) = &parent_node {\n+            return body.hir_id == drop_expr.hir_id;\n+        }\n+    }\n+    false\n+}"}, {"sha": "9c834cf014485e824ee47e27593a91a19381ea49", "filename": "src/tools/clippy/clippy_lints/src/entry.rs", "status": "modified", "additions": 7, "deletions": 21, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fentry.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -113,13 +113,8 @@ impl<'tcx> LateLintPass<'tcx> for HashMapPass {\n                     ),\n                 };\n                 format!(\n-                    \"if let {}::{} = {}.entry({}) {} else {}\",\n+                    \"if let {}::{entry_kind} = {map_str}.entry({key_str}) {then_str} else {else_str}\",\n                     map_ty.entry_path(),\n-                    entry_kind,\n-                    map_str,\n-                    key_str,\n-                    then_str,\n-                    else_str,\n                 )\n             } else {\n                 // if .. { insert } else { insert }\n@@ -137,16 +132,11 @@ impl<'tcx> LateLintPass<'tcx> for HashMapPass {\n                 let indent_str = snippet_indent(cx, expr.span);\n                 let indent_str = indent_str.as_deref().unwrap_or(\"\");\n                 format!(\n-                    \"match {}.entry({}) {{\\n{indent}    {entry}::{} => {}\\n\\\n-                        {indent}    {entry}::{} => {}\\n{indent}}}\",\n-                    map_str,\n-                    key_str,\n-                    then_entry,\n+                    \"match {map_str}.entry({key_str}) {{\\n{indent_str}    {entry}::{then_entry} => {}\\n\\\n+                        {indent_str}    {entry}::{else_entry} => {}\\n{indent_str}}}\",\n                     reindent_multiline(then_str.into(), true, Some(4 + indent_str.len())),\n-                    else_entry,\n                     reindent_multiline(else_str.into(), true, Some(4 + indent_str.len())),\n                     entry = map_ty.entry_path(),\n-                    indent = indent_str,\n                 )\n             }\n         } else {\n@@ -163,20 +153,16 @@ impl<'tcx> LateLintPass<'tcx> for HashMapPass {\n                     then_search.snippet_occupied(cx, then_expr.span, &mut app)\n                 };\n                 format!(\n-                    \"if let {}::{} = {}.entry({}) {}\",\n+                    \"if let {}::{entry_kind} = {map_str}.entry({key_str}) {body_str}\",\n                     map_ty.entry_path(),\n-                    entry_kind,\n-                    map_str,\n-                    key_str,\n-                    body_str,\n                 )\n             } else if let Some(insertion) = then_search.as_single_insertion() {\n                 let value_str = snippet_with_context(cx, insertion.value.span, then_expr.span.ctxt(), \"..\", &mut app).0;\n                 if contains_expr.negated {\n                     if insertion.value.can_have_side_effects() {\n-                        format!(\"{}.entry({}).or_insert_with(|| {});\", map_str, key_str, value_str)\n+                        format!(\"{map_str}.entry({key_str}).or_insert_with(|| {value_str});\")\n                     } else {\n-                        format!(\"{}.entry({}).or_insert({});\", map_str, key_str, value_str)\n+                        format!(\"{map_str}.entry({key_str}).or_insert({value_str});\")\n                     }\n                 } else {\n                     // TODO: suggest using `if let Some(v) = map.get_mut(k) { .. }` here.\n@@ -186,7 +172,7 @@ impl<'tcx> LateLintPass<'tcx> for HashMapPass {\n             } else {\n                 let block_str = then_search.snippet_closure(cx, then_expr.span, &mut app);\n                 if contains_expr.negated {\n-                    format!(\"{}.entry({}).or_insert_with(|| {});\", map_str, key_str, block_str)\n+                    format!(\"{map_str}.entry({key_str}).or_insert_with(|| {block_str});\")\n                 } else {\n                     // TODO: suggest using `if let Some(v) = map.get_mut(k) { .. }` here.\n                     // This would need to be a different lint."}, {"sha": "b019d07d53d11fb1318d1be1f082f8493e699a9b", "filename": "src/tools/clippy/clippy_lints/src/enum_variants.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_variants.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -202,12 +202,11 @@ fn check_variant(cx: &LateContext<'_>, threshold: u64, def: &EnumDef<'_>, item_n\n         cx,\n         ENUM_VARIANT_NAMES,\n         span,\n-        &format!(\"all variants have the same {}fix: `{}`\", what, value),\n+        &format!(\"all variants have the same {what}fix: `{value}`\"),\n         None,\n         &format!(\n-            \"remove the {}fixes and use full paths to \\\n-             the variants instead of glob imports\",\n-            what\n+            \"remove the {what}fixes and use full paths to \\\n+             the variants instead of glob imports\"\n         ),\n     );\n }"}, {"sha": "b40cb7cddaf178155a41bb54f4459cf5b9895ddb", "filename": "src/tools/clippy/clippy_lints/src/equatable_if_let.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fequatable_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fequatable_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fequatable_if_let.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -51,9 +51,7 @@ fn unary_pattern(pat: &Pat<'_>) -> bool {\n             false\n         },\n         PatKind::Struct(_, a, etc) => !etc && a.iter().all(|x| unary_pattern(x.pat)),\n-        PatKind::Tuple(a, etc) | PatKind::TupleStruct(_, a, etc) => {\n-            !etc.as_opt_usize().is_some() && array_rec(a)\n-        }\n+        PatKind::Tuple(a, etc) | PatKind::TupleStruct(_, a, etc) => etc.as_opt_usize().is_none() && array_rec(a),\n         PatKind::Ref(x, _) | PatKind::Box(x) => unary_pattern(x),\n         PatKind::Path(_) | PatKind::Lit(_) => true,\n     }\n@@ -93,9 +91,8 @@ impl<'tcx> LateLintPass<'tcx> for PatternEquality {\n                     \"this pattern matching can be expressed using equality\",\n                     \"try\",\n                     format!(\n-                        \"{} == {}\",\n+                        \"{} == {pat_str}\",\n                         snippet_with_context(cx, let_expr.init.span, expr.span.ctxt(), \"..\", &mut applicability).0,\n-                        pat_str,\n                     ),\n                     applicability,\n                 );"}, {"sha": "2e608fe527fdceee413e19f8b30da78b85f49a43", "filename": "src/tools/clippy/clippy_lints/src/escape.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -1,6 +1,7 @@\n use clippy_utils::diagnostics::span_lint_hir;\n use rustc_hir::intravisit;\n use rustc_hir::{self, AssocItemKind, Body, FnDecl, HirId, HirIdSet, Impl, ItemKind, Node, Pat, PatKind};\n+use rustc_hir_analysis::expr_use_visitor::{Delegate, ExprUseVisitor, PlaceBase, PlaceWithHirId};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::mir::FakeReadCause;\n@@ -10,7 +11,6 @@ use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Span;\n use rustc_span::symbol::kw;\n use rustc_target::spec::abi::Abi;\n-use rustc_hir_analysis::expr_use_visitor::{Delegate, ExprUseVisitor, PlaceBase, PlaceWithHirId};\n \n #[derive(Copy, Clone)]\n pub struct BoxedLocal {\n@@ -177,7 +177,13 @@ impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n         }\n     }\n \n-    fn fake_read(&mut self, _: &rustc_hir_analysis::expr_use_visitor::PlaceWithHirId<'tcx>, _: FakeReadCause, _: HirId) {}\n+    fn fake_read(\n+        &mut self,\n+        _: &rustc_hir_analysis::expr_use_visitor::PlaceWithHirId<'tcx>,\n+        _: FakeReadCause,\n+        _: HirId,\n+    ) {\n+    }\n }\n \n impl<'a, 'tcx> EscapeDelegate<'a, 'tcx> {"}, {"sha": "3732410e71e57a9338ef71b6ab3a9e3f562c3789", "filename": "src/tools/clippy/clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feta_reduction.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::higher::VecArgs;\n use clippy_utils::source::snippet_opt;\n-use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::ty::{implements_trait, is_type_diagnostic_item};\n use clippy_utils::usage::local_used_after_expr;\n use clippy_utils::{higher, is_adjusted, path_to_local, path_to_local_id};\n use if_chain::if_chain;\n@@ -11,7 +11,7 @@ use rustc_hir::{Closure, Expr, ExprKind, Param, PatKind, Unsafety};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow};\n use rustc_middle::ty::binding::BindingMode;\n-use rustc_middle::ty::{self, ClosureKind, Ty, TypeVisitable};\n+use rustc_middle::ty::{self, Ty, TypeVisitable};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::symbol::sym;\n \n@@ -122,15 +122,12 @@ impl<'tcx> LateLintPass<'tcx> for EtaReduction {\n             then {\n                 span_lint_and_then(cx, REDUNDANT_CLOSURE, expr.span, \"redundant closure\", |diag| {\n                     if let Some(mut snippet) = snippet_opt(cx, callee.span) {\n-                        if_chain! {\n-                            if let ty::Closure(_, substs) = callee_ty.peel_refs().kind();\n-                            if substs.as_closure().kind() == ClosureKind::FnMut;\n-                            if path_to_local(callee).map_or(false, |l| local_used_after_expr(cx, l, expr));\n-\n-                            then {\n+                        if let Some(fn_mut_id) = cx.tcx.lang_items().fn_mut_trait()\n+                            && implements_trait(cx, callee_ty.peel_refs(), fn_mut_id, &[])\n+                            && path_to_local(callee).map_or(false, |l| local_used_after_expr(cx, l, expr))\n+                        {\n                                 // Mutable closure is used after current expr; we cannot consume it.\n-                                snippet = format!(\"&mut {}\", snippet);\n-                            }\n+                                snippet = format!(\"&mut {snippet}\");\n                         }\n                         diag.span_suggestion(\n                             expr.span,\n@@ -157,7 +154,7 @@ impl<'tcx> LateLintPass<'tcx> for EtaReduction {\n                     diag.span_suggestion(\n                         expr.span,\n                         \"replace the closure with the method itself\",\n-                        format!(\"{}::{}\", name, path.ident.name),\n+                        format!(\"{name}::{}\", path.ident.name),\n                         Applicability::MachineApplicable,\n                     );\n                 })"}, {"sha": "be6242bd20b8464fc84f16b81e44d8aeed3e3c0f", "filename": "src/tools/clippy/clippy_lints/src/exhaustive_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexhaustive_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexhaustive_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexhaustive_items.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -97,7 +97,7 @@ impl LateLintPass<'_> for ExhaustiveItems {\n                     item.span,\n                     msg,\n                     |diag| {\n-                        let sugg = format!(\"#[non_exhaustive]\\n{}\", indent);\n+                        let sugg = format!(\"#[non_exhaustive]\\n{indent}\");\n                         diag.span_suggestion(suggestion_span,\n                                              \"try adding #[non_exhaustive]\",\n                                              sugg,"}, {"sha": "c0ea6f338a230b51d9864dc2dcc8e89a56558ed3", "filename": "src/tools/clippy/clippy_lints/src/explicit_write.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexplicit_write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexplicit_write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexplicit_write.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -80,12 +80,12 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitWrite {\n                 // used.\n                 let (used, sugg_mac) = if let Some(macro_name) = calling_macro {\n                     (\n-                        format!(\"{}!({}(), ...)\", macro_name, dest_name),\n+                        format!(\"{macro_name}!({dest_name}(), ...)\"),\n                         macro_name.replace(\"write\", \"print\"),\n                     )\n                 } else {\n                     (\n-                        format!(\"{}().write_fmt(...)\", dest_name),\n+                        format!(\"{dest_name}().write_fmt(...)\"),\n                         \"print\".into(),\n                     )\n                 };\n@@ -100,9 +100,9 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitWrite {\n                     cx,\n                     EXPLICIT_WRITE,\n                     expr.span,\n-                    &format!(\"use of `{}.unwrap()`\", used),\n+                    &format!(\"use of `{used}.unwrap()`\"),\n                     \"try this\",\n-                    format!(\"{}{}!({})\", prefix, sugg_mac, inputs_snippet),\n+                    format!(\"{prefix}{sugg_mac}!({inputs_snippet})\"),\n                     applicability,\n                 )\n             }"}, {"sha": "6fee7fb308ce7f9905a8d505dbffa5f7f4f758ad", "filename": "src/tools/clippy/clippy_lints/src/float_literal.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloat_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloat_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloat_literal.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -173,9 +173,9 @@ impl FloatFormat {\n         T: fmt::UpperExp + fmt::LowerExp + fmt::Display,\n     {\n         match self {\n-            Self::LowerExp => format!(\"{:e}\", f),\n-            Self::UpperExp => format!(\"{:E}\", f),\n-            Self::Normal => format!(\"{}\", f),\n+            Self::LowerExp => format!(\"{f:e}\"),\n+            Self::UpperExp => format!(\"{f:E}\"),\n+            Self::Normal => format!(\"{f}\"),\n         }\n     }\n }"}, {"sha": "0ed301964758e643243ba19cb09f1f1ab37d2cbf", "filename": "src/tools/clippy/clippy_lints/src/floating_point_arithmetic.rs", "status": "modified", "additions": 39, "deletions": 16, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -142,8 +142,7 @@ fn prepare_receiver_sugg<'a>(cx: &LateContext<'_>, mut expr: &'a Expr<'a>) -> Su\n         if let ast::LitKind::Float(sym, ast::LitFloatType::Unsuffixed) = lit.node;\n         then {\n             let op = format!(\n-                \"{}{}{}\",\n-                suggestion,\n+                \"{suggestion}{}{}\",\n                 // Check for float literals without numbers following the decimal\n                 // separator such as `2.` and adds a trailing zero\n                 if sym.as_str().ends_with('.') {\n@@ -172,7 +171,7 @@ fn check_log_base(cx: &LateContext<'_>, expr: &Expr<'_>, receiver: &Expr<'_>, ar\n             expr.span,\n             \"logarithm for bases 2, 10 and e can be computed more accurately\",\n             \"consider using\",\n-            format!(\"{}.{}()\", Sugg::hir(cx, receiver, \"..\").maybe_par(), method),\n+            format!(\"{}.{method}()\", Sugg::hir(cx, receiver, \"..\").maybe_par()),\n             Applicability::MachineApplicable,\n         );\n     }\n@@ -251,7 +250,7 @@ fn check_powf(cx: &LateContext<'_>, expr: &Expr<'_>, receiver: &Expr<'_>, args:\n                 expr.span,\n                 \"exponent for bases 2 and e can be computed more accurately\",\n                 \"consider using\",\n-                format!(\"{}.{}()\", prepare_receiver_sugg(cx, &args[0]), method),\n+                format!(\"{}.{method}()\", prepare_receiver_sugg(cx, &args[0])),\n                 Applicability::MachineApplicable,\n             );\n         }\n@@ -312,14 +311,25 @@ fn check_powi(cx: &LateContext<'_>, expr: &Expr<'_>, receiver: &Expr<'_>, args:\n \n                 if let ExprKind::Binary(\n                     Spanned {\n-                        node: BinOpKind::Add, ..\n+                        node: op @ (BinOpKind::Add | BinOpKind::Sub),\n+                        ..\n                     },\n                     lhs,\n                     rhs,\n                 ) = parent.kind\n                 {\n                     let other_addend = if lhs.hir_id == expr.hir_id { rhs } else { lhs };\n \n+                    // Negate expr if original code has subtraction and expr is on the right side\n+                    let maybe_neg_sugg = |expr, hir_id| {\n+                        let sugg = Sugg::hir(cx, expr, \"..\");\n+                        if matches!(op, BinOpKind::Sub) && hir_id == rhs.hir_id {\n+                            format!(\"-{sugg}\")\n+                        } else {\n+                            sugg.to_string()\n+                        }\n+                    };\n+\n                     span_lint_and_sugg(\n                         cx,\n                         SUBOPTIMAL_FLOPS,\n@@ -329,8 +339,8 @@ fn check_powi(cx: &LateContext<'_>, expr: &Expr<'_>, receiver: &Expr<'_>, args:\n                         format!(\n                             \"{}.mul_add({}, {})\",\n                             Sugg::hir(cx, receiver, \"..\").maybe_par(),\n-                            Sugg::hir(cx, receiver, \"..\"),\n-                            Sugg::hir(cx, other_addend, \"..\"),\n+                            maybe_neg_sugg(receiver, expr.hir_id),\n+                            maybe_neg_sugg(other_addend, other_addend.hir_id),\n                         ),\n                         Applicability::MachineApplicable,\n                     );\n@@ -444,7 +454,8 @@ fn is_float_mul_expr<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<(&'\n fn check_mul_add(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if let ExprKind::Binary(\n         Spanned {\n-            node: BinOpKind::Add, ..\n+            node: op @ (BinOpKind::Add | BinOpKind::Sub),\n+            ..\n         },\n         lhs,\n         rhs,\n@@ -458,10 +469,27 @@ fn check_mul_add(cx: &LateContext<'_>, expr: &Expr<'_>) {\n             }\n         }\n \n+        let maybe_neg_sugg = |expr| {\n+            let sugg = Sugg::hir(cx, expr, \"..\");\n+            if let BinOpKind::Sub = op {\n+                format!(\"-{sugg}\")\n+            } else {\n+                sugg.to_string()\n+            }\n+        };\n+\n         let (recv, arg1, arg2) = if let Some((inner_lhs, inner_rhs)) = is_float_mul_expr(cx, lhs) {\n-            (inner_lhs, inner_rhs, rhs)\n+            (\n+                inner_lhs,\n+                Sugg::hir(cx, inner_rhs, \"..\").to_string(),\n+                maybe_neg_sugg(rhs),\n+            )\n         } else if let Some((inner_lhs, inner_rhs)) = is_float_mul_expr(cx, rhs) {\n-            (inner_lhs, inner_rhs, lhs)\n+            (\n+                inner_lhs,\n+                maybe_neg_sugg(inner_rhs),\n+                Sugg::hir(cx, lhs, \"..\").to_string(),\n+            )\n         } else {\n             return;\n         };\n@@ -472,12 +500,7 @@ fn check_mul_add(cx: &LateContext<'_>, expr: &Expr<'_>) {\n             expr.span,\n             \"multiply and add expressions can be calculated more efficiently and accurately\",\n             \"consider using\",\n-            format!(\n-                \"{}.mul_add({}, {})\",\n-                prepare_receiver_sugg(cx, recv),\n-                Sugg::hir(cx, arg1, \"..\"),\n-                Sugg::hir(cx, arg2, \"..\"),\n-            ),\n+            format!(\"{}.mul_add({arg1}, {arg2})\", prepare_receiver_sugg(cx, recv)),\n             Applicability::MachineApplicable,\n         );\n     }"}, {"sha": "bc0c68f535a96f23e1cfd0d9b75ef55665b7d875", "filename": "src/tools/clippy/clippy_lints/src/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -62,7 +62,7 @@ impl<'tcx> LateLintPass<'tcx> for UselessFormat {\n                 [_] => {\n                     // Simulate macro expansion, converting {{ and }} to { and }.\n                     let s_expand = format_args.format_string.snippet.replace(\"{{\", \"{\").replace(\"}}\", \"}\");\n-                    let sugg = format!(\"{}.to_string()\", s_expand);\n+                    let sugg = format!(\"{s_expand}.to_string()\");\n                     span_useless_format(cx, call_site, sugg, applicability);\n                 },\n                 [..] => {},"}, {"sha": "99bef62f81436d48343eee7a921585b0664270de", "filename": "src/tools/clippy/clippy_lints/src/format_args.rs", "status": "modified", "additions": 131, "deletions": 18, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat_args.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -1,16 +1,18 @@\n use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};\n-use clippy_utils::is_diag_trait_item;\n-use clippy_utils::macros::{is_format_macro, FormatArgsExpn};\n+use clippy_utils::macros::FormatParamKind::{Implicit, Named, Numbered, Starred};\n+use clippy_utils::macros::{is_format_macro, FormatArgsExpn, FormatParam, FormatParamUsage};\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::implements_trait;\n+use clippy_utils::{is_diag_trait_item, meets_msrv, msrvs};\n use if_chain::if_chain;\n use itertools::Itertools;\n use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind, HirId};\n-use rustc_lint::{LateContext, LateLintPass};\n+use rustc_hir::{Expr, ExprKind, HirId, QPath};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::ty::adjustment::{Adjust, Adjustment};\n use rustc_middle::ty::Ty;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_semver::RustcVersion;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::{sym, ExpnData, ExpnKind, Span, Symbol};\n \n declare_clippy_lint! {\n@@ -64,7 +66,67 @@ declare_clippy_lint! {\n     \"`to_string` applied to a type that implements `Display` in format args\"\n }\n \n-declare_lint_pass!(FormatArgs => [FORMAT_IN_FORMAT_ARGS, TO_STRING_IN_FORMAT_ARGS]);\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Detect when a variable is not inlined in a format string,\n+    /// and suggests to inline it.\n+    ///\n+    /// ### Why is this bad?\n+    /// Non-inlined code is slightly more difficult to read and understand,\n+    /// as it requires arguments to be matched against the format string.\n+    /// The inlined syntax, where allowed, is simpler.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # let var = 42;\n+    /// # let width = 1;\n+    /// # let prec = 2;\n+    /// format!(\"{}\", var);\n+    /// format!(\"{v:?}\", v = var);\n+    /// format!(\"{0} {0}\", var);\n+    /// format!(\"{0:1$}\", var, width);\n+    /// format!(\"{:.*}\", prec, var);\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// # let var = 42;\n+    /// # let width = 1;\n+    /// # let prec = 2;\n+    /// format!(\"{var}\");\n+    /// format!(\"{var:?}\");\n+    /// format!(\"{var} {var}\");\n+    /// format!(\"{var:width$}\");\n+    /// format!(\"{var:.prec$}\");\n+    /// ```\n+    ///\n+    /// ### Known Problems\n+    ///\n+    /// There may be a false positive if the format string is expanded from certain proc macros:\n+    ///\n+    /// ```ignore\n+    /// println!(indoc!(\"{}\"), var);\n+    /// ```\n+    ///\n+    /// If a format string contains a numbered argument that cannot be inlined\n+    /// nothing will be suggested, e.g. `println!(\"{0}={1}\", var, 1+2)`.\n+    #[clippy::version = \"1.65.0\"]\n+    pub UNINLINED_FORMAT_ARGS,\n+    pedantic,\n+    \"using non-inlined variables in `format!` calls\"\n+}\n+\n+impl_lint_pass!(FormatArgs => [FORMAT_IN_FORMAT_ARGS, UNINLINED_FORMAT_ARGS, TO_STRING_IN_FORMAT_ARGS]);\n+\n+pub struct FormatArgs {\n+    msrv: Option<RustcVersion>,\n+}\n+\n+impl FormatArgs {\n+    #[must_use]\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n+        Self { msrv }\n+    }\n+}\n \n impl<'tcx> LateLintPass<'tcx> for FormatArgs {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n@@ -86,9 +148,65 @@ impl<'tcx> LateLintPass<'tcx> for FormatArgs {\n                     check_format_in_format_args(cx, outermost_expn_data.call_site, name, arg.param.value);\n                     check_to_string_in_format_args(cx, name, arg.param.value);\n                 }\n+                if meets_msrv(self.msrv, msrvs::FORMAT_ARGS_CAPTURE) {\n+                    check_uninlined_args(cx, &format_args, outermost_expn_data.call_site);\n+                }\n             }\n         }\n     }\n+\n+    extract_msrv_attr!(LateContext);\n+}\n+\n+fn check_uninlined_args(cx: &LateContext<'_>, args: &FormatArgsExpn<'_>, call_site: Span) {\n+    if args.format_string.span.from_expansion() {\n+        return;\n+    }\n+\n+    let mut fixes = Vec::new();\n+    // If any of the arguments are referenced by an index number,\n+    // and that argument is not a simple variable and cannot be inlined,\n+    // we cannot remove any other arguments in the format string,\n+    // because the index numbers might be wrong after inlining.\n+    // Example of an un-inlinable format:  print!(\"{}{1}\", foo, 2)\n+    if !args.params().all(|p| check_one_arg(args, &p, &mut fixes)) || fixes.is_empty() {\n+        return;\n+    }\n+\n+    // Temporarily ignore multiline spans: https://github.com/rust-lang/rust/pull/102729#discussion_r988704308\n+    if fixes.iter().any(|(span, _)| cx.sess().source_map().is_multiline(*span)) {\n+        return;\n+    }\n+\n+    span_lint_and_then(\n+        cx,\n+        UNINLINED_FORMAT_ARGS,\n+        call_site,\n+        \"variables can be used directly in the `format!` string\",\n+        |diag| {\n+            diag.multipart_suggestion(\"change this to\", fixes, Applicability::MachineApplicable);\n+        },\n+    );\n+}\n+\n+fn check_one_arg(args: &FormatArgsExpn<'_>, param: &FormatParam<'_>, fixes: &mut Vec<(Span, String)>) -> bool {\n+    if matches!(param.kind, Implicit | Starred | Named(_) | Numbered)\n+        && let ExprKind::Path(QPath::Resolved(None, path)) = param.value.kind\n+        && let [segment] = path.segments\n+        && let Some(arg_span) = args.value_with_prev_comma_span(param.value.hir_id)\n+    {\n+        let replacement = match param.usage {\n+            FormatParamUsage::Argument => segment.ident.name.to_string(),\n+            FormatParamUsage::Width => format!(\"{}$\", segment.ident.name),\n+            FormatParamUsage::Precision => format!(\".{}$\", segment.ident.name),\n+        };\n+        fixes.push((param.span, replacement));\n+        fixes.push((arg_span, String::new()));\n+        true  // successful inlining, continue checking\n+    } else {\n+        // if we can't inline a numbered argument, we can't continue\n+        param.kind != Numbered\n+    }\n }\n \n fn outermost_expn_data(expn_data: ExpnData) -> ExpnData {\n@@ -117,11 +235,10 @@ fn check_format_in_format_args(\n         cx,\n         FORMAT_IN_FORMAT_ARGS,\n         call_site,\n-        &format!(\"`format!` in `{}!` args\", name),\n+        &format!(\"`format!` in `{name}!` args\"),\n         |diag| {\n             diag.help(&format!(\n-                \"combine the `format!(..)` arguments with the outer `{}!(..)` call\",\n-                name\n+                \"combine the `format!(..)` arguments with the outer `{name}!(..)` call\"\n             ));\n             diag.help(\"or consider changing `format!` to `format_args!`\");\n         },\n@@ -149,8 +266,7 @@ fn check_to_string_in_format_args(cx: &LateContext<'_>, name: Symbol, value: &Ex\n                     TO_STRING_IN_FORMAT_ARGS,\n                     value.span.with_lo(receiver.span.hi()),\n                     &format!(\n-                        \"`to_string` applied to a type that implements `Display` in `{}!` args\",\n-                        name\n+                        \"`to_string` applied to a type that implements `Display` in `{name}!` args\"\n                     ),\n                     \"remove this\",\n                     String::new(),\n@@ -162,16 +278,13 @@ fn check_to_string_in_format_args(cx: &LateContext<'_>, name: Symbol, value: &Ex\n                     TO_STRING_IN_FORMAT_ARGS,\n                     value.span,\n                     &format!(\n-                        \"`to_string` applied to a type that implements `Display` in `{}!` args\",\n-                        name\n+                        \"`to_string` applied to a type that implements `Display` in `{name}!` args\"\n                     ),\n                     \"use this\",\n                     format!(\n-                        \"{}{:*>width$}{}\",\n+                        \"{}{:*>n_needed_derefs$}{receiver_snippet}\",\n                         if needs_ref { \"&\" } else { \"\" },\n-                        \"\",\n-                        receiver_snippet,\n-                        width = n_needed_derefs\n+                        \"\"\n                     ),\n                     Applicability::MachineApplicable,\n                 );\n@@ -180,7 +293,7 @@ fn check_to_string_in_format_args(cx: &LateContext<'_>, name: Symbol, value: &Ex\n     }\n }\n \n-// Returns true if `hir_id` is referred to by multiple format params\n+/// Returns true if `hir_id` is referred to by multiple format params\n fn is_aliased(args: &FormatArgsExpn<'_>, hir_id: HirId) -> bool {\n     args.params().filter(|param| param.value.hir_id == hir_id).at_most_one().is_err()\n }"}, {"sha": "ed1342a54654301fe24541e0f9dc25b5d7b4a989", "filename": "src/tools/clippy/clippy_lints/src/format_impl.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat_impl.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -214,12 +214,12 @@ fn check_print_in_format_impl(cx: &LateContext<'_>, expr: &Expr<'_>, impl_trait:\n                 cx,\n                 PRINT_IN_FORMAT_IMPL,\n                 macro_call.span,\n-                &format!(\"use of `{}!` in `{}` impl\", name, impl_trait.name),\n+                &format!(\"use of `{name}!` in `{}` impl\", impl_trait.name),\n                 \"replace with\",\n                 if let Some(formatter_name) = impl_trait.formatter_name {\n-                    format!(\"{}!({}, ..)\", replacement, formatter_name)\n+                    format!(\"{replacement}!({formatter_name}, ..)\")\n                 } else {\n-                    format!(\"{}!(..)\", replacement)\n+                    format!(\"{replacement}!(..)\")\n                 },\n                 Applicability::HasPlaceholders,\n             );"}, {"sha": "a866a68987d02c04d8f5c44f8d7ee83210d59295", "filename": "src/tools/clippy/clippy_lints/src/formatting.rs", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformatting.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -154,11 +154,10 @@ fn check_assign(cx: &EarlyContext<'_>, expr: &Expr) {\n                             eqop_span,\n                             &format!(\n                                 \"this looks like you are trying to use `.. {op}= ..`, but you \\\n-                                 really are doing `.. = ({op} ..)`\",\n-                                op = op\n+                                 really are doing `.. = ({op} ..)`\"\n                             ),\n                             None,\n-                            &format!(\"to remove this lint, use either `{op}=` or `= {op}`\", op = op),\n+                            &format!(\"to remove this lint, use either `{op}=` or `= {op}`\"),\n                         );\n                     }\n                 }\n@@ -191,16 +190,12 @@ fn check_unop(cx: &EarlyContext<'_>, expr: &Expr) {\n                 SUSPICIOUS_UNARY_OP_FORMATTING,\n                 eqop_span,\n                 &format!(\n-                    \"by not having a space between `{binop}` and `{unop}` it looks like \\\n-                     `{binop}{unop}` is a single operator\",\n-                    binop = binop_str,\n-                    unop = unop_str\n+                    \"by not having a space between `{binop_str}` and `{unop_str}` it looks like \\\n+                     `{binop_str}{unop_str}` is a single operator\"\n                 ),\n                 None,\n                 &format!(\n-                    \"put a space between `{binop}` and `{unop}` and remove the space after `{unop}`\",\n-                    binop = binop_str,\n-                    unop = unop_str\n+                    \"put a space between `{binop_str}` and `{unop_str}` and remove the space after `{unop_str}`\"\n                 ),\n             );\n         }\n@@ -246,12 +241,11 @@ fn check_else(cx: &EarlyContext<'_>, expr: &Expr) {\n                 cx,\n                 SUSPICIOUS_ELSE_FORMATTING,\n                 else_span,\n-                &format!(\"this is an `else {}` but the formatting might hide it\", else_desc),\n+                &format!(\"this is an `else {else_desc}` but the formatting might hide it\"),\n                 None,\n                 &format!(\n                     \"to remove this lint, remove the `else` or remove the new line between \\\n-                     `else` and `{}`\",\n-                    else_desc,\n+                     `else` and `{else_desc}`\",\n                 ),\n             );\n         }\n@@ -320,11 +314,10 @@ fn check_missing_else(cx: &EarlyContext<'_>, first: &Expr, second: &Expr) {\n                 cx,\n                 SUSPICIOUS_ELSE_FORMATTING,\n                 else_span,\n-                &format!(\"this looks like {} but the `else` is missing\", looks_like),\n+                &format!(\"this looks like {looks_like} but the `else` is missing\"),\n                 None,\n                 &format!(\n-                    \"to remove this lint, add the missing `else` or add a new line before {}\",\n-                    next_thing,\n+                    \"to remove this lint, add the missing `else` or add a new line before {next_thing}\",\n                 ),\n             );\n         }"}, {"sha": "cf8b7acd66d22ab4d9e627e95d0a4117573d4df0", "filename": "src/tools/clippy/clippy_lints/src/from_str_radix_10.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffrom_str_radix_10.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffrom_str_radix_10.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffrom_str_radix_10.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -1,4 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::is_integer_literal;\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n use if_chain::if_chain;\n@@ -60,8 +61,7 @@ impl<'tcx> LateLintPass<'tcx> for FromStrRadix10 {\n             if pathseg.ident.name.as_str() == \"from_str_radix\";\n \n             // check if the second argument is a primitive `10`\n-            if let ExprKind::Lit(lit) = &radix.kind;\n-            if let rustc_ast::ast::LitKind::Int(10, _) = lit.node;\n+            if is_integer_literal(radix, 10);\n \n             then {\n                 let expr = if let ExprKind::AddrOf(_, _, expr) = &src.kind {\n@@ -88,7 +88,7 @@ impl<'tcx> LateLintPass<'tcx> for FromStrRadix10 {\n                     exp.span,\n                     \"this call to `from_str_radix` can be replaced with a call to `str::parse`\",\n                     \"try\",\n-                    format!(\"{}.parse::<{}>()\", sugg, prim_ty.name_str()),\n+                    format!(\"{sugg}.parse::<{}>()\", prim_ty.name_str()),\n                     Applicability::MaybeIncorrect\n                 );\n             }"}, {"sha": "d263804f32cf48538be82cad8e979d6543d490f8", "filename": "src/tools/clippy/clippy_lints/src/functions/must_use.rs", "status": "modified", "additions": 36, "deletions": 46, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -1,7 +1,7 @@\n use rustc_ast::ast::Attribute;\n use rustc_errors::Applicability;\n use rustc_hir::def_id::{DefIdSet, LocalDefId};\n-use rustc_hir::{self as hir, def::Res, intravisit, QPath};\n+use rustc_hir::{self as hir, def::Res, QPath};\n use rustc_lint::{LateContext, LintContext};\n use rustc_middle::{\n     lint::in_external_macro,\n@@ -13,8 +13,11 @@ use clippy_utils::attrs::is_proc_macro;\n use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_then};\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::is_must_use_ty;\n+use clippy_utils::visitors::for_each_expr;\n use clippy_utils::{match_def_path, return_ty, trait_ref_of_method};\n \n+use core::ops::ControlFlow;\n+\n use super::{DOUBLE_MUST_USE, MUST_USE_CANDIDATE, MUST_USE_UNIT};\n \n pub(super) fn check_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n@@ -47,7 +50,8 @@ pub(super) fn check_impl_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::Imp\n         let attr = cx.tcx.get_attr(item.def_id.to_def_id(), sym::must_use);\n         if let Some(attr) = attr {\n             check_needless_must_use(cx, sig.decl, item.hir_id(), item.span, fn_header_span, attr);\n-        } else if is_public && !is_proc_macro(cx.sess(), attrs) && trait_ref_of_method(cx, item.def_id.def_id).is_none() {\n+        } else if is_public && !is_proc_macro(cx.sess(), attrs) && trait_ref_of_method(cx, item.def_id.def_id).is_none()\n+        {\n             check_must_use_candidate(\n                 cx,\n                 sig.decl,\n@@ -143,7 +147,7 @@ fn check_must_use_candidate<'tcx>(\n             diag.span_suggestion(\n                 fn_span,\n                 \"add the attribute\",\n-                format!(\"#[must_use] {}\", snippet),\n+                format!(\"#[must_use] {snippet}\"),\n                 Applicability::MachineApplicable,\n             );\n         }\n@@ -199,79 +203,65 @@ fn is_mutable_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, span: Span, tys: &m\n     }\n }\n \n-struct StaticMutVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,\n-    mutates_static: bool,\n+fn is_mutated_static(e: &hir::Expr<'_>) -> bool {\n+    use hir::ExprKind::{Field, Index, Path};\n+\n+    match e.kind {\n+        Path(QPath::Resolved(_, path)) => !matches!(path.res, Res::Local(_)),\n+        Path(_) => true,\n+        Field(inner, _) | Index(inner, _) => is_mutated_static(inner),\n+        _ => false,\n+    }\n }\n \n-impl<'a, 'tcx> intravisit::Visitor<'tcx> for StaticMutVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n+fn mutates_static<'tcx>(cx: &LateContext<'tcx>, body: &'tcx hir::Body<'_>) -> bool {\n+    for_each_expr(body.value, |e| {\n         use hir::ExprKind::{AddrOf, Assign, AssignOp, Call, MethodCall};\n \n-        if self.mutates_static {\n-            return;\n-        }\n-        match expr.kind {\n+        match e.kind {\n             Call(_, args) => {\n                 let mut tys = DefIdSet::default();\n                 for arg in args {\n-                    if self.cx.tcx.has_typeck_results(arg.hir_id.owner.to_def_id())\n+                    if cx.tcx.has_typeck_results(arg.hir_id.owner.to_def_id())\n                         && is_mutable_ty(\n-                            self.cx,\n-                            self.cx.tcx.typeck(arg.hir_id.owner.def_id).expr_ty(arg),\n+                            cx,\n+                            cx.tcx.typeck(arg.hir_id.owner.def_id).expr_ty(arg),\n                             arg.span,\n                             &mut tys,\n                         )\n                         && is_mutated_static(arg)\n                     {\n-                        self.mutates_static = true;\n-                        return;\n+                        return ControlFlow::Break(());\n                     }\n                     tys.clear();\n                 }\n+                ControlFlow::Continue(())\n             },\n             MethodCall(_, receiver, args, _) => {\n                 let mut tys = DefIdSet::default();\n                 for arg in std::iter::once(receiver).chain(args.iter()) {\n-                    if self.cx.tcx.has_typeck_results(arg.hir_id.owner.to_def_id())\n+                    if cx.tcx.has_typeck_results(arg.hir_id.owner.to_def_id())\n                         && is_mutable_ty(\n-                            self.cx,\n-                            self.cx.tcx.typeck(arg.hir_id.owner.def_id).expr_ty(arg),\n+                            cx,\n+                            cx.tcx.typeck(arg.hir_id.owner.def_id).expr_ty(arg),\n                             arg.span,\n                             &mut tys,\n                         )\n                         && is_mutated_static(arg)\n                     {\n-                        self.mutates_static = true;\n-                        return;\n+                        return ControlFlow::Break(());\n                     }\n                     tys.clear();\n                 }\n+                ControlFlow::Continue(())\n             },\n-            Assign(target, ..) | AssignOp(_, target, _) | AddrOf(_, hir::Mutability::Mut, target) => {\n-                self.mutates_static |= is_mutated_static(target);\n+            Assign(target, ..) | AssignOp(_, target, _) | AddrOf(_, hir::Mutability::Mut, target)\n+                if is_mutated_static(target) =>\n+            {\n+                ControlFlow::Break(())\n             },\n-            _ => {},\n+            _ => ControlFlow::Continue(()),\n         }\n-    }\n-}\n-\n-fn is_mutated_static(e: &hir::Expr<'_>) -> bool {\n-    use hir::ExprKind::{Field, Index, Path};\n-\n-    match e.kind {\n-        Path(QPath::Resolved(_, path)) => !matches!(path.res, Res::Local(_)),\n-        Path(_) => true,\n-        Field(inner, _) | Index(inner, _) => is_mutated_static(inner),\n-        _ => false,\n-    }\n-}\n-\n-fn mutates_static<'tcx>(cx: &LateContext<'tcx>, body: &'tcx hir::Body<'_>) -> bool {\n-    let mut v = StaticMutVisitor {\n-        cx,\n-        mutates_static: false,\n-    };\n-    intravisit::walk_expr(&mut v, body.value);\n-    v.mutates_static\n+    })\n+    .is_some()\n }"}, {"sha": "b7595d101e0fa9f04893f52eb75c8f44f4c98e96", "filename": "src/tools/clippy/clippy_lints/src/functions/not_unsafe_ptr_arg_deref.rs", "status": "modified", "additions": 33, "deletions": 58, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -5,8 +5,11 @@ use rustc_span::def_id::LocalDefId;\n \n use clippy_utils::diagnostics::span_lint;\n use clippy_utils::ty::type_is_unsafe_function;\n+use clippy_utils::visitors::for_each_expr_with_closures;\n use clippy_utils::{iter_input_pats, path_to_local};\n \n+use core::ops::ControlFlow;\n+\n use super::NOT_UNSAFE_PTR_ARG_DEREF;\n \n pub(super) fn check_fn<'tcx>(\n@@ -39,21 +42,34 @@ fn check_raw_ptr<'tcx>(\n     body: &'tcx hir::Body<'tcx>,\n     def_id: LocalDefId,\n ) {\n-    let expr = &body.value;\n     if unsafety == hir::Unsafety::Normal && cx.access_levels.is_exported(def_id) {\n         let raw_ptrs = iter_input_pats(decl, body)\n             .filter_map(|arg| raw_ptr_arg(cx, arg))\n             .collect::<HirIdSet>();\n \n         if !raw_ptrs.is_empty() {\n-            let typeck_results = cx.tcx.typeck_body(body.id());\n-            let mut v = DerefVisitor {\n-                cx,\n-                ptrs: raw_ptrs,\n-                typeck_results,\n-            };\n-\n-            intravisit::walk_expr(&mut v, expr);\n+            let typeck = cx.tcx.typeck_body(body.id());\n+            let _: Option<!> = for_each_expr_with_closures(cx, body.value, |e| {\n+                match e.kind {\n+                    hir::ExprKind::Call(f, args) if type_is_unsafe_function(cx, typeck.expr_ty(f)) => {\n+                        for arg in args {\n+                            check_arg(cx, &raw_ptrs, arg);\n+                        }\n+                    },\n+                    hir::ExprKind::MethodCall(_, recv, args, _) => {\n+                        let def_id = typeck.type_dependent_def_id(e.hir_id).unwrap();\n+                        if cx.tcx.fn_sig(def_id).skip_binder().unsafety == hir::Unsafety::Unsafe {\n+                            check_arg(cx, &raw_ptrs, recv);\n+                            for arg in args {\n+                                check_arg(cx, &raw_ptrs, arg);\n+                            }\n+                        }\n+                    },\n+                    hir::ExprKind::Unary(hir::UnOp::Deref, ptr) => check_arg(cx, &raw_ptrs, ptr),\n+                    _ => (),\n+                }\n+                ControlFlow::Continue(())\n+            });\n         }\n     }\n }\n@@ -70,54 +86,13 @@ fn raw_ptr_arg(cx: &LateContext<'_>, arg: &hir::Param<'_>) -> Option<hir::HirId>\n     }\n }\n \n-struct DerefVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,\n-    ptrs: HirIdSet,\n-    typeck_results: &'a ty::TypeckResults<'tcx>,\n-}\n-\n-impl<'a, 'tcx> intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n-        match expr.kind {\n-            hir::ExprKind::Call(f, args) => {\n-                let ty = self.typeck_results.expr_ty(f);\n-\n-                if type_is_unsafe_function(self.cx, ty) {\n-                    for arg in args {\n-                        self.check_arg(arg);\n-                    }\n-                }\n-            },\n-            hir::ExprKind::MethodCall(_, receiver, args, _) => {\n-                let def_id = self.typeck_results.type_dependent_def_id(expr.hir_id).unwrap();\n-                let base_type = self.cx.tcx.type_of(def_id);\n-\n-                if type_is_unsafe_function(self.cx, base_type) {\n-                    self.check_arg(receiver);\n-                    for arg in args {\n-                        self.check_arg(arg);\n-                    }\n-                }\n-            },\n-            hir::ExprKind::Unary(hir::UnOp::Deref, ptr) => self.check_arg(ptr),\n-            _ => (),\n-        }\n-\n-        intravisit::walk_expr(self, expr);\n-    }\n-}\n-\n-impl<'a, 'tcx> DerefVisitor<'a, 'tcx> {\n-    fn check_arg(&self, ptr: &hir::Expr<'_>) {\n-        if let Some(id) = path_to_local(ptr) {\n-            if self.ptrs.contains(&id) {\n-                span_lint(\n-                    self.cx,\n-                    NOT_UNSAFE_PTR_ARG_DEREF,\n-                    ptr.span,\n-                    \"this public function might dereference a raw pointer but is not marked `unsafe`\",\n-                );\n-            }\n-        }\n+fn check_arg(cx: &LateContext<'_>, raw_ptrs: &HirIdSet, arg: &hir::Expr<'_>) {\n+    if path_to_local(arg).map_or(false, |id| raw_ptrs.contains(&id)) {\n+        span_lint(\n+            cx,\n+            NOT_UNSAFE_PTR_ARG_DEREF,\n+            arg.span,\n+            \"this public function might dereference a raw pointer but is not marked `unsafe`\",\n+        );\n     }\n }"}, {"sha": "1e08922a616645395f649004a7cf121daf0ff793", "filename": "src/tools/clippy/clippy_lints/src/functions/too_many_arguments.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Ftoo_many_arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Ftoo_many_arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Ftoo_many_arguments.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -59,10 +59,7 @@ fn check_arg_number(cx: &LateContext<'_>, decl: &hir::FnDecl<'_>, fn_span: Span,\n             cx,\n             TOO_MANY_ARGUMENTS,\n             fn_span,\n-            &format!(\n-                \"this function has too many arguments ({}/{})\",\n-                args, too_many_arguments_threshold\n-            ),\n+            &format!(\"this function has too many arguments ({args}/{too_many_arguments_threshold})\"),\n         );\n     }\n }"}, {"sha": "f83f8b40f94b75eff950f62fa8e3f25936a97c42", "filename": "src/tools/clippy/clippy_lints/src/functions/too_many_lines.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Ftoo_many_lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Ftoo_many_lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Ftoo_many_lines.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -78,10 +78,7 @@ pub(super) fn check_fn(\n             cx,\n             TOO_MANY_LINES,\n             span,\n-            &format!(\n-                \"this function has too many lines ({}/{})\",\n-                line_count, too_many_lines_threshold\n-            ),\n+            &format!(\"this function has too many lines ({line_count}/{too_many_lines_threshold})\"),\n         );\n     }\n }"}, {"sha": "0d6718c168a5c9da12865ee7633dc5078ad7e33a", "filename": "src/tools/clippy/clippy_lints/src/if_then_some_else_none.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_then_some_else_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_then_some_else_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_then_some_else_none.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -1,7 +1,9 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::eager_or_lazy::switch_to_eager_eval;\n use clippy_utils::source::snippet_with_macro_callsite;\n-use clippy_utils::{contains_return, higher, is_else_clause, is_lang_ctor, meets_msrv, msrvs, peel_blocks};\n+use clippy_utils::{\n+    contains_return, higher, is_else_clause, is_res_lang_ctor, meets_msrv, msrvs, path_res, peel_blocks,\n+};\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n use rustc_hir::{Expr, ExprKind, Stmt, StmtKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n@@ -76,23 +78,21 @@ impl<'tcx> LateLintPass<'tcx> for IfThenSomeElseNone {\n             && let ExprKind::Block(then_block, _) = then.kind\n             && let Some(then_expr) = then_block.expr\n             && let ExprKind::Call(then_call, [then_arg]) = then_expr.kind\n-            && let ExprKind::Path(ref then_call_qpath) = then_call.kind\n-            && is_lang_ctor(cx, then_call_qpath, OptionSome)\n-            && let ExprKind::Path(ref qpath) = peel_blocks(els).kind\n-            && is_lang_ctor(cx, qpath, OptionNone)\n+            && is_res_lang_ctor(cx, path_res(cx, then_call), OptionSome)\n+            && is_res_lang_ctor(cx, path_res(cx, peel_blocks(els)), OptionNone)\n             && !stmts_contains_early_return(then_block.stmts)\n         {\n             let cond_snip = snippet_with_macro_callsite(cx, cond.span, \"[condition]\");\n             let cond_snip = if matches!(cond.kind, ExprKind::Unary(_, _) | ExprKind::Binary(_, _, _)) {\n-                format!(\"({})\", cond_snip)\n+                format!(\"({cond_snip})\")\n             } else {\n                 cond_snip.into_owned()\n             };\n             let arg_snip = snippet_with_macro_callsite(cx, then_arg.span, \"\");\n             let mut method_body = if then_block.stmts.is_empty() {\n                 arg_snip.into_owned()\n             } else {\n-                format!(\"{{ /* snippet */ {} }}\", arg_snip)\n+                format!(\"{{ /* snippet */ {arg_snip} }}\")\n             };\n             let method_name = if switch_to_eager_eval(cx, expr) && meets_msrv(self.msrv, msrvs::BOOL_THEN_SOME) {\n                 \"then_some\"\n@@ -102,14 +102,13 @@ impl<'tcx> LateLintPass<'tcx> for IfThenSomeElseNone {\n             };\n \n             let help = format!(\n-                \"consider using `bool::{}` like: `{}.{}({})`\",\n-                method_name, cond_snip, method_name, method_body,\n+                \"consider using `bool::{method_name}` like: `{cond_snip}.{method_name}({method_body})`\",\n             );\n             span_lint_and_help(\n                 cx,\n                 IF_THEN_SOME_ELSE_NONE,\n                 expr.span,\n-                &format!(\"this could be simplified with `bool::{}`\", method_name),\n+                &format!(\"this could be simplified with `bool::{method_name}`\"),\n                 None,\n                 &help,\n             );"}, {"sha": "93efe957b1dc27bf2f9d7c43594f1408b2cf73a6", "filename": "src/tools/clippy/clippy_lints/src/implicit_hasher.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_hasher.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -5,14 +5,14 @@ use rustc_errors::Diagnostic;\n use rustc_hir as hir;\n use rustc_hir::intravisit::{walk_body, walk_expr, walk_inf, walk_ty, Visitor};\n use rustc_hir::{Body, Expr, ExprKind, GenericArg, Item, ItemKind, QPath, TyKind};\n+use rustc_hir_analysis::hir_ty_to_ty;\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::nested_filter;\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::{Ty, TypeckResults};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n use rustc_span::symbol::sym;\n-use rustc_hir_analysis::hir_ty_to_ty;\n \n use if_chain::if_chain;\n \n@@ -89,8 +89,7 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitHasher {\n                     (\n                         generics_suggestion_span,\n                         format!(\n-                            \"<{}{}S: ::std::hash::BuildHasher{}>\",\n-                            generics_snip,\n+                            \"<{generics_snip}{}S: ::std::hash::BuildHasher{}>\",\n                             if generics_snip.is_empty() { \"\" } else { \", \" },\n                             if vis.suggestions.is_empty() {\n                                 \"\"\n@@ -263,8 +262,8 @@ impl<'tcx> ImplicitHasherType<'tcx> {\n \n     fn type_arguments(&self) -> String {\n         match *self {\n-            ImplicitHasherType::HashMap(.., ref k, ref v) => format!(\"{}, {}\", k, v),\n-            ImplicitHasherType::HashSet(.., ref t) => format!(\"{}\", t),\n+            ImplicitHasherType::HashMap(.., ref k, ref v) => format!(\"{k}, {v}\"),\n+            ImplicitHasherType::HashSet(.., ref t) => format!(\"{t}\"),\n         }\n     }\n "}, {"sha": "946d04eff6f9850f6c81dce875bca890f0b9d76f", "filename": "src/tools/clippy/clippy_lints/src/implicit_return.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_return.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -2,10 +2,11 @@ use clippy_utils::{\n     diagnostics::span_lint_hir_and_then,\n     get_async_fn_body, is_async_fn,\n     source::{snippet_with_applicability, snippet_with_context, walk_span_to_context},\n-    visitors::expr_visitor_no_bodies,\n+    visitors::for_each_expr,\n };\n+use core::ops::ControlFlow;\n use rustc_errors::Applicability;\n-use rustc_hir::intravisit::{FnKind, Visitor};\n+use rustc_hir::intravisit::FnKind;\n use rustc_hir::{Block, Body, Expr, ExprKind, FnDecl, FnRetTy, HirId};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n@@ -53,7 +54,7 @@ fn lint_return(cx: &LateContext<'_>, emission_place: HirId, span: Span) {\n         span,\n         \"missing `return` statement\",\n         |diag| {\n-            diag.span_suggestion(span, \"add `return` as shown\", format!(\"return {}\", snip), app);\n+            diag.span_suggestion(span, \"add `return` as shown\", format!(\"return {snip}\"), app);\n         },\n     );\n }\n@@ -71,7 +72,7 @@ fn lint_break(cx: &LateContext<'_>, emission_place: HirId, break_span: Span, exp\n             diag.span_suggestion(\n                 break_span,\n                 \"change `break` to `return` as shown\",\n-                format!(\"return {}\", snip),\n+                format!(\"return {snip}\"),\n                 app,\n             );\n         },\n@@ -152,7 +153,7 @@ fn lint_implicit_returns(\n \n         ExprKind::Loop(block, ..) => {\n             let mut add_return = false;\n-            expr_visitor_no_bodies(|e| {\n+            let _: Option<!> = for_each_expr(block, |e| {\n                 if let ExprKind::Break(dest, sub_expr) = e.kind {\n                     if dest.target_id.ok() == Some(expr.hir_id) {\n                         if call_site_span.is_none() && e.span.ctxt() == ctxt {\n@@ -167,9 +168,8 @@ fn lint_implicit_returns(\n                         }\n                     }\n                 }\n-                true\n-            })\n-            .visit_block(block);\n+                ControlFlow::Continue(())\n+            });\n             if add_return {\n                 #[expect(clippy::option_if_let_else)]\n                 if let Some(span) = call_site_span {"}, {"sha": "bf1351829c6a5e2e61755dc873df6494e5009ab5", "filename": "src/tools/clippy/clippy_lints/src/implicit_saturating_add.rs", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_saturating_add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_saturating_add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_saturating_add.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -0,0 +1,114 @@\n+use clippy_utils::consts::{constant, Constant};\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::get_parent_expr;\n+use clippy_utils::source::snippet_with_applicability;\n+use if_chain::if_chain;\n+use rustc_ast::ast::{LitIntType, LitKind};\n+use rustc_errors::Applicability;\n+use rustc_hir::{BinOpKind, Block, Expr, ExprKind, Stmt, StmtKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::{Int, IntTy, Ty, Uint, UintTy};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for implicit saturating addition.\n+    ///\n+    /// ### Why is this bad?\n+    /// The built-in function is more readable and may be faster.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    ///let mut u:u32 = 7000;\n+    ///\n+    /// if u != u32::MAX {\n+    ///     u += 1;\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    ///let mut u:u32 = 7000;\n+    ///\n+    /// u = u.saturating_add(1);\n+    /// ```\n+    #[clippy::version = \"1.65.0\"]\n+    pub IMPLICIT_SATURATING_ADD,\n+    style,\n+    \"Perform saturating addition instead of implicitly checking max bound of data type\"\n+}\n+declare_lint_pass!(ImplicitSaturatingAdd => [IMPLICIT_SATURATING_ADD]);\n+\n+impl<'tcx> LateLintPass<'tcx> for ImplicitSaturatingAdd {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n+        if_chain! {\n+            if let ExprKind::If(cond, then, None) = expr.kind;\n+            if let ExprKind::DropTemps(expr1) = cond.kind;\n+            if let Some((c, op_node, l)) = get_const(cx, expr1);\n+            if let BinOpKind::Ne | BinOpKind::Lt = op_node;\n+            if let ExprKind::Block(block, None) = then.kind;\n+            if let Block {\n+                stmts:\n+                    [Stmt\n+                        { kind: StmtKind::Expr(ex) | StmtKind::Semi(ex), .. }],\n+                        expr: None, ..} |\n+                        Block { stmts: [], expr: Some(ex), ..} = block;\n+            if let ExprKind::AssignOp(op1, target, value) = ex.kind;\n+            let ty = cx.typeck_results().expr_ty(target);\n+            if Some(c) == get_int_max(ty);\n+            if clippy_utils::SpanlessEq::new(cx).eq_expr(l, target);\n+            if BinOpKind::Add == op1.node;\n+            if let ExprKind::Lit(ref lit) = value.kind;\n+            if let LitKind::Int(1, LitIntType::Unsuffixed) = lit.node;\n+            if block.expr.is_none();\n+            then {\n+                let mut app = Applicability::MachineApplicable;\n+                let code = snippet_with_applicability(cx, target.span, \"_\", &mut app);\n+                let sugg = if let Some(parent) = get_parent_expr(cx, expr) && let ExprKind::If(_cond, _then, Some(else_)) = parent.kind && else_.hir_id == expr.hir_id {format!(\"{{{code} = {code}.saturating_add(1); }}\")} else {format!(\"{code} = {code}.saturating_add(1);\")};\n+                span_lint_and_sugg(cx, IMPLICIT_SATURATING_ADD, expr.span, \"manual saturating add detected\", \"use instead\", sugg, app);\n+            }\n+        }\n+    }\n+}\n+\n+fn get_int_max(ty: Ty<'_>) -> Option<u128> {\n+    match ty.peel_refs().kind() {\n+        Int(IntTy::I8) => i8::max_value().try_into().ok(),\n+        Int(IntTy::I16) => i16::max_value().try_into().ok(),\n+        Int(IntTy::I32) => i32::max_value().try_into().ok(),\n+        Int(IntTy::I64) => i64::max_value().try_into().ok(),\n+        Int(IntTy::I128) => i128::max_value().try_into().ok(),\n+        Int(IntTy::Isize) => isize::max_value().try_into().ok(),\n+        Uint(UintTy::U8) => u8::max_value().try_into().ok(),\n+        Uint(UintTy::U16) => u16::max_value().try_into().ok(),\n+        Uint(UintTy::U32) => u32::max_value().try_into().ok(),\n+        Uint(UintTy::U64) => u64::max_value().try_into().ok(),\n+        Uint(UintTy::U128) => Some(u128::max_value()),\n+        Uint(UintTy::Usize) => usize::max_value().try_into().ok(),\n+        _ => None,\n+    }\n+}\n+\n+fn get_const<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>) -> Option<(u128, BinOpKind, &'tcx Expr<'tcx>)> {\n+    if let ExprKind::Binary(op, l, r) = expr.kind {\n+        let tr = cx.typeck_results();\n+        if let Some((Constant::Int(c), _)) = constant(cx, tr, r) {\n+            return Some((c, op.node, l));\n+        };\n+        if let Some((Constant::Int(c), _)) = constant(cx, tr, l) {\n+            return Some((c, invert_op(op.node)?, r));\n+        }\n+    }\n+    None\n+}\n+\n+fn invert_op(op: BinOpKind) -> Option<BinOpKind> {\n+    use rustc_hir::BinOpKind::{Ge, Gt, Le, Lt, Ne};\n+    match op {\n+        Lt => Some(Gt),\n+        Le => Some(Ge),\n+        Ne => Some(Ne),\n+        Ge => Some(Le),\n+        Gt => Some(Lt),\n+        _ => None,\n+    }\n+}"}, {"sha": "48edbf6ae576cc66cfe717a11a9eb5de8ec5f57a", "filename": "src/tools/clippy/clippy_lints/src/implicit_saturating_sub.rs", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::{higher, peel_blocks_with_stmt, SpanlessEq};\n+use clippy_utils::{higher, is_integer_literal, peel_blocks_with_stmt, SpanlessEq};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n@@ -131,17 +131,8 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitSaturatingSub {\n fn subtracts_one<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<&'a Expr<'a>> {\n     match peel_blocks_with_stmt(expr).kind {\n         ExprKind::AssignOp(ref op1, target, value) => {\n-            if_chain! {\n-                if BinOpKind::Sub == op1.node;\n-                // Check if literal being subtracted is one\n-                if let ExprKind::Lit(ref lit1) = value.kind;\n-                if let LitKind::Int(1, _) = lit1.node;\n-                then {\n-                    Some(target)\n-                } else {\n-                    None\n-                }\n-            }\n+            // Check if literal being subtracted is one\n+            (BinOpKind::Sub == op1.node && is_integer_literal(value, 1)).then_some(target)\n         },\n         ExprKind::Assign(target, value, _) => {\n             if_chain! {\n@@ -150,8 +141,7 @@ fn subtracts_one<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<&'a Exp\n \n                 if SpanlessEq::new(cx).eq_expr(left1, target);\n \n-                if let ExprKind::Lit(ref lit1) = right1.kind;\n-                if let LitKind::Int(1, _) = lit1.node;\n+                if is_integer_literal(right1, 1);\n                 then {\n                     Some(target)\n                 } else {\n@@ -170,7 +160,7 @@ fn print_lint_and_sugg(cx: &LateContext<'_>, var_name: &str, expr: &Expr<'_>) {\n         expr.span,\n         \"implicitly performing saturating subtraction\",\n         \"try\",\n-        format!(\"{} = {}.saturating_sub({});\", var_name, var_name, '1'),\n+        format!(\"{var_name} = {var_name}.saturating_sub({});\", '1'),\n         Applicability::MachineApplicable,\n     );\n }"}, {"sha": "e2f2d3d42e6953bef10b31fbd370d661444ece5a", "filename": "src/tools/clippy/clippy_lints/src/inconsistent_struct_constructor.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finconsistent_struct_constructor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finconsistent_struct_constructor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finconsistent_struct_constructor.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -90,7 +90,7 @@ impl<'tcx> LateLintPass<'tcx> for InconsistentStructConstructor {\n                 let mut fields_snippet = String::new();\n                 let (last_ident, idents) = ordered_fields.split_last().unwrap();\n                 for ident in idents {\n-                    let _ = write!(fields_snippet, \"{}, \", ident);\n+                    let _ = write!(fields_snippet, \"{ident}, \");\n                 }\n                 fields_snippet.push_str(&last_ident.to_string());\n \n@@ -100,10 +100,8 @@ impl<'tcx> LateLintPass<'tcx> for InconsistentStructConstructor {\n                         String::new()\n                     };\n \n-                let sugg = format!(\"{} {{ {}{} }}\",\n+                let sugg = format!(\"{} {{ {fields_snippet}{base_snippet} }}\",\n                     snippet(cx, qpath.span(), \"..\"),\n-                    fields_snippet,\n-                    base_snippet,\n                     );\n \n                 span_lint_and_sugg("}, {"sha": "c7b5badaae51b0c21a392cc9762a65be80c63016", "filename": "src/tools/clippy/clippy_lints/src/index_refutable_slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findex_refutable_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findex_refutable_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findex_refutable_slice.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -139,14 +139,14 @@ fn lint_slice(cx: &LateContext<'_>, slice: &SliceLintInformation) {\n         .map(|(index, _)| *index)\n         .collect::<FxHashSet<_>>();\n \n-    let value_name = |index| format!(\"{}_{}\", slice.ident.name, index);\n+    let value_name = |index| format!(\"{}_{index}\", slice.ident.name);\n \n     if let Some(max_index) = used_indices.iter().max() {\n         let opt_ref = if slice.needs_ref { \"ref \" } else { \"\" };\n         let pat_sugg_idents = (0..=*max_index)\n             .map(|index| {\n                 if used_indices.contains(&index) {\n-                    format!(\"{}{}\", opt_ref, value_name(index))\n+                    format!(\"{opt_ref}{}\", value_name(index))\n                 } else {\n                     \"_\".to_string()\n                 }"}, {"sha": "d1d2db27c6fc0acd6efa477769d5840722056f1b", "filename": "src/tools/clippy/clippy_lints/src/infinite_iter.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finfinite_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finfinite_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finfinite_iter.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::higher;\n use clippy_utils::ty::{implements_trait, is_type_diagnostic_item};\n-use clippy_utils::{higher, match_def_path, path_def_id, paths};\n use rustc_hir::{BorrowKind, Closure, Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -168,9 +168,16 @@ fn is_infinite(cx: &LateContext<'_>, expr: &Expr<'_>) -> Finiteness {\n         },\n         ExprKind::Block(block, _) => block.expr.as_ref().map_or(Finite, |e| is_infinite(cx, e)),\n         ExprKind::Box(e) | ExprKind::AddrOf(BorrowKind::Ref, _, e) => is_infinite(cx, e),\n-        ExprKind::Call(path, _) => path_def_id(cx, path)\n-            .map_or(false, |id| match_def_path(cx, id, &paths::ITER_REPEAT))\n-            .into(),\n+        ExprKind::Call(path, _) => {\n+            if let ExprKind::Path(ref qpath) = path.kind {\n+                cx.qpath_res(qpath, path.hir_id)\n+                    .opt_def_id()\n+                    .map_or(false, |id| cx.tcx.is_diagnostic_item(sym::iter_repeat, id))\n+                    .into()\n+            } else {\n+                Finite\n+            }\n+        },\n         ExprKind::Struct(..) => higher::Range::hir(expr).map_or(false, |r| r.end.is_none()).into(),\n         _ => Finite,\n     }"}, {"sha": "676136df572bd0dd7cff51bc4cc1d74945a3dd2c", "filename": "src/tools/clippy/clippy_lints/src/inherent_to_string.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_to_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_to_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_to_string.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::ty::{implements_trait, is_type_diagnostic_item};\n-use clippy_utils::{get_trait_def_id, paths, return_ty, trait_ref_of_method};\n+use clippy_utils::{return_ty, trait_ref_of_method};\n use if_chain::if_chain;\n use rustc_hir::{GenericParamKind, ImplItem, ImplItemKind};\n use rustc_lint::{LateContext, LateLintPass};\n@@ -118,7 +118,10 @@ impl<'tcx> LateLintPass<'tcx> for InherentToString {\n }\n \n fn show_lint(cx: &LateContext<'_>, item: &ImplItem<'_>) {\n-    let display_trait_id = get_trait_def_id(cx, &paths::DISPLAY_TRAIT).expect(\"Failed to get trait ID of `Display`!\");\n+    let display_trait_id = cx\n+        .tcx\n+        .get_diagnostic_item(sym::Display)\n+        .expect(\"Failed to get trait ID of `Display`!\");\n \n     // Get the real type of 'self'\n     let self_type = cx.tcx.fn_sig(item.def_id).input(0);\n@@ -131,23 +134,19 @@ fn show_lint(cx: &LateContext<'_>, item: &ImplItem<'_>) {\n             INHERENT_TO_STRING_SHADOW_DISPLAY,\n             item.span,\n             &format!(\n-                \"type `{}` implements inherent method `to_string(&self) -> String` which shadows the implementation of `Display`\",\n-                self_type\n+                \"type `{self_type}` implements inherent method `to_string(&self) -> String` which shadows the implementation of `Display`\"\n             ),\n             None,\n-            &format!(\"remove the inherent method from type `{}`\", self_type),\n+            &format!(\"remove the inherent method from type `{self_type}`\"),\n         );\n     } else {\n         span_lint_and_help(\n             cx,\n             INHERENT_TO_STRING,\n             item.span,\n-            &format!(\n-                \"implementation of inherent method `to_string(&self) -> String` for type `{}`\",\n-                self_type\n-            ),\n+            &format!(\"implementation of inherent method `to_string(&self) -> String` for type `{self_type}`\"),\n             None,\n-            &format!(\"implement trait `Display` for type `{}` instead\", self_type),\n+            &format!(\"implement trait `Display` for type `{self_type}` instead\"),\n         );\n     }\n }"}, {"sha": "d609a5ca4d4653fcadcdd476ec1a181cbd349235", "filename": "src/tools/clippy/clippy_lints/src/inline_fn_without_body.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finline_fn_without_body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finline_fn_without_body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finline_fn_without_body.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -51,7 +51,7 @@ fn check_attrs(cx: &LateContext<'_>, name: Symbol, attrs: &[Attribute]) {\n             cx,\n             INLINE_FN_WITHOUT_BODY,\n             attr.span,\n-            &format!(\"use of `#[inline]` on trait method `{}` which has no body\", name),\n+            &format!(\"use of `#[inline]` on trait method `{name}` which has no body\"),\n             |diag| {\n                 diag.suggest_remove_item(cx, attr.span, \"remove\", Applicability::MachineApplicable);\n             },"}, {"sha": "33491da3fc5aff094bc504c462bbd8281a5596a0", "filename": "src/tools/clippy/clippy_lints/src/int_plus_one.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fint_plus_one.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fint_plus_one.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fint_plus_one.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -138,8 +138,8 @@ impl IntPlusOne {\n         if let Some(snippet) = snippet_opt(cx, node.span) {\n             if let Some(other_side_snippet) = snippet_opt(cx, other_side.span) {\n                 let rec = match side {\n-                    Side::Lhs => Some(format!(\"{} {} {}\", snippet, binop_string, other_side_snippet)),\n-                    Side::Rhs => Some(format!(\"{} {} {}\", other_side_snippet, binop_string, snippet)),\n+                    Side::Lhs => Some(format!(\"{snippet} {binop_string} {other_side_snippet}\")),\n+                    Side::Rhs => Some(format!(\"{other_side_snippet} {binop_string} {snippet}\")),\n                 };\n                 return rec;\n             }"}, {"sha": "ea9f046fb973645f0c3573e56303c0bdf873a100", "filename": "src/tools/clippy/clippy_lints/src/iter_not_returning_iterator.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fiter_not_returning_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fiter_not_returning_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fiter_not_returning_iterator.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -80,10 +80,7 @@ fn check_sig(cx: &LateContext<'_>, name: &str, sig: &FnSig<'_>, fn_id: LocalDefI\n                 cx,\n                 ITER_NOT_RETURNING_ITERATOR,\n                 sig.span,\n-                &format!(\n-                    \"this method is named `{}` but its return type does not implement `Iterator`\",\n-                    name\n-                ),\n+                &format!(\"this method is named `{name}` but its return type does not implement `Iterator`\"),\n             );\n         }\n     }"}, {"sha": "76c83ab47d09561a9caf4ec22e161db2ce04ee18", "filename": "src/tools/clippy/clippy_lints/src/large_const_arrays.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_const_arrays.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_const_arrays.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_const_arrays.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -2,12 +2,12 @@ use clippy_utils::diagnostics::span_lint_and_then;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{Item, ItemKind};\n+use rustc_hir_analysis::hir_ty_to_ty;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::layout::LayoutOf;\n use rustc_middle::ty::{self, ConstKind};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::{BytePos, Pos, Span};\n-use rustc_hir_analysis::hir_ty_to_ty;\n \n declare_clippy_lint! {\n     /// ### What it does"}, {"sha": "3a563736fb077b7ae51d3016ff63c9c0c4434182", "filename": "src/tools/clippy/clippy_lints/src/len_zero.rs", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -210,7 +210,8 @@ fn check_trait_items(cx: &LateContext<'_>, visited_trait: &Item<'_>, trait_items\n         }\n     }\n \n-    if cx.access_levels.is_exported(visited_trait.def_id.def_id) && trait_items.iter().any(|i| is_named_self(cx, i, sym::len))\n+    if cx.access_levels.is_exported(visited_trait.def_id.def_id)\n+        && trait_items.iter().any(|i| is_named_self(cx, i, sym::len))\n     {\n         let mut current_and_super_traits = DefIdSet::default();\n         fill_trait_set(visited_trait.def_id.to_def_id(), &mut current_and_super_traits, cx);\n@@ -278,15 +279,13 @@ impl<'tcx> LenOutput<'tcx> {\n             _ => \"\",\n         };\n         match self {\n-            Self::Integral => format!(\"expected signature: `({}self) -> bool`\", self_ref),\n-            Self::Option(_) => format!(\n-                \"expected signature: `({}self) -> bool` or `({}self) -> Option<bool>\",\n-                self_ref, self_ref\n-            ),\n-            Self::Result(..) => format!(\n-                \"expected signature: `({}self) -> bool` or `({}self) -> Result<bool>\",\n-                self_ref, self_ref\n-            ),\n+            Self::Integral => format!(\"expected signature: `({self_ref}self) -> bool`\"),\n+            Self::Option(_) => {\n+                format!(\"expected signature: `({self_ref}self) -> bool` or `({self_ref}self) -> Option<bool>\")\n+            },\n+            Self::Result(..) => {\n+                format!(\"expected signature: `({self_ref}self) -> bool` or `({self_ref}self) -> Result<bool>\")\n+            },\n         }\n     }\n }\n@@ -326,17 +325,15 @@ fn check_for_is_empty<'tcx>(\n     let (msg, is_empty_span, self_kind) = match is_empty {\n         None => (\n             format!(\n-                \"{} `{}` has a public `len` method, but no `is_empty` method\",\n-                item_kind,\n+                \"{item_kind} `{}` has a public `len` method, but no `is_empty` method\",\n                 item_name.as_str(),\n             ),\n             None,\n             None,\n         ),\n         Some(is_empty) if !cx.access_levels.is_exported(is_empty.def_id.expect_local()) => (\n             format!(\n-                \"{} `{}` has a public `len` method, but a private `is_empty` method\",\n-                item_kind,\n+                \"{item_kind} `{}` has a public `len` method, but a private `is_empty` method\",\n                 item_name.as_str(),\n             ),\n             Some(cx.tcx.def_span(is_empty.def_id)),\n@@ -348,8 +345,7 @@ fn check_for_is_empty<'tcx>(\n         {\n             (\n                 format!(\n-                    \"{} `{}` has a public `len` method, but the `is_empty` method has an unexpected signature\",\n-                    item_kind,\n+                    \"{item_kind} `{}` has a public `len` method, but the `is_empty` method has an unexpected signature\",\n                     item_name.as_str(),\n                 ),\n                 Some(cx.tcx.def_span(is_empty.def_id)),\n@@ -419,10 +415,9 @@ fn check_len(\n                 LEN_ZERO,\n                 span,\n                 &format!(\"length comparison to {}\", if compare_to == 0 { \"zero\" } else { \"one\" }),\n-                &format!(\"using `{}is_empty` is clearer and more explicit\", op),\n+                &format!(\"using `{op}is_empty` is clearer and more explicit\"),\n                 format!(\n-                    \"{}{}.is_empty()\",\n-                    op,\n+                    \"{op}{}.is_empty()\",\n                     snippet_with_applicability(cx, receiver.span, \"_\", &mut applicability)\n                 ),\n                 applicability,\n@@ -439,10 +434,9 @@ fn check_empty_expr(cx: &LateContext<'_>, span: Span, lit1: &Expr<'_>, lit2: &Ex\n             COMPARISON_TO_EMPTY,\n             span,\n             \"comparison to empty slice\",\n-            &format!(\"using `{}is_empty` is clearer and more explicit\", op),\n+            &format!(\"using `{op}is_empty` is clearer and more explicit\"),\n             format!(\n-                \"{}{}.is_empty()\",\n-                op,\n+                \"{op}{}.is_empty()\",\n                 snippet_with_applicability(cx, lit1.span, \"_\", &mut applicability)\n             ),\n             applicability,"}, {"sha": "13071d64441a081d416fdc5782db70f195e32e51", "filename": "src/tools/clippy/clippy_lints/src/let_if_seq.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_if_seq.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -106,8 +106,7 @@ impl<'tcx> LateLintPass<'tcx> for LetIfSeq {\n                     // use mutably after the `if`\n \n                     let sug = format!(\n-                        \"let {mut}{name} = if {cond} {{{then} {value} }} else {{{else} {default} }};\",\n-                        mut=mutability,\n+                        \"let {mutability}{name} = if {cond} {{{then} {value} }} else {{{else} {default} }};\",\n                         name=ident.name,\n                         cond=snippet(cx, cond.span, \"_\"),\n                         then=if then.stmts.len() > 1 { \" ..;\" } else { \"\" },"}, {"sha": "5d26e4b336012d91f59d6859ae42a89c3204d644", "filename": "src/tools/clippy/clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_all.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -21,6 +21,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(booleans::NONMINIMAL_BOOL),\n     LintId::of(booleans::OVERLY_COMPLEX_BOOL_EXPR),\n     LintId::of(borrow_deref_ref::BORROW_DEREF_REF),\n+    LintId::of(box_default::BOX_DEFAULT),\n     LintId::of(casts::CAST_ABS_TO_UNSIGNED),\n     LintId::of(casts::CAST_ENUM_CONSTRUCTOR),\n     LintId::of(casts::CAST_ENUM_TRUNCATION),\n@@ -44,7 +45,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(derivable_impls::DERIVABLE_IMPLS),\n     LintId::of(derive::DERIVE_HASH_XOR_EQ),\n     LintId::of(derive::DERIVE_ORD_XOR_PARTIAL_ORD),\n-    LintId::of(derive::DERIVE_PARTIAL_EQ_WITHOUT_EQ),\n+    LintId::of(disallowed_macros::DISALLOWED_MACROS),\n     LintId::of(disallowed_methods::DISALLOWED_METHODS),\n     LintId::of(disallowed_names::DISALLOWED_NAMES),\n     LintId::of(disallowed_types::DISALLOWED_TYPES),\n@@ -85,6 +86,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(functions::RESULT_UNIT_ERR),\n     LintId::of(functions::TOO_MANY_ARGUMENTS),\n     LintId::of(if_let_mutex::IF_LET_MUTEX),\n+    LintId::of(implicit_saturating_add::IMPLICIT_SATURATING_ADD),\n     LintId::of(indexing_slicing::OUT_OF_BOUNDS_INDEXING),\n     LintId::of(infinite_iter::INFINITE_ITER),\n     LintId::of(inherent_to_string::INHERENT_TO_STRING),\n@@ -125,6 +127,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(main_recursion::MAIN_RECURSION),\n     LintId::of(manual_async_fn::MANUAL_ASYNC_FN),\n     LintId::of(manual_bits::MANUAL_BITS),\n+    LintId::of(manual_clamp::MANUAL_CLAMP),\n     LintId::of(manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE),\n     LintId::of(manual_rem_euclid::MANUAL_REM_EUCLID),\n     LintId::of(manual_retain::MANUAL_RETAIN),"}, {"sha": "a58d066fa6b6737bd58e69b9bf7294513490cf60", "filename": "src/tools/clippy/clippy_lints/src/lib.register_complexity.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_complexity.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -22,6 +22,7 @@ store.register_group(true, \"clippy::complexity\", Some(\"clippy_complexity\"), vec!\n     LintId::of(loops::MANUAL_FLATTEN),\n     LintId::of(loops::SINGLE_ELEMENT_LOOP),\n     LintId::of(loops::WHILE_LET_LOOP),\n+    LintId::of(manual_clamp::MANUAL_CLAMP),\n     LintId::of(manual_rem_euclid::MANUAL_REM_EUCLID),\n     LintId::of(manual_strip::MANUAL_STRIP),\n     LintId::of(map_unit_fn::OPTION_MAP_UNIT_FN),"}, {"sha": "71dfdab369b97e93228a82f1de68ea331b89639d", "filename": "src/tools/clippy/clippy_lints/src/lib.register_internal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_internal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_internal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_internal.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -13,10 +13,10 @@ store.register_group(true, \"clippy::internal\", Some(\"clippy_internal\"), vec![\n     LintId::of(utils::internal_lints::INVALID_CLIPPY_VERSION_ATTRIBUTE),\n     LintId::of(utils::internal_lints::INVALID_PATHS),\n     LintId::of(utils::internal_lints::LINT_WITHOUT_LINT_PASS),\n-    LintId::of(utils::internal_lints::MATCH_TYPE_ON_DIAGNOSTIC_ITEM),\n     LintId::of(utils::internal_lints::MISSING_CLIPPY_VERSION_ATTRIBUTE),\n     LintId::of(utils::internal_lints::MISSING_MSRV_ATTR_IMPL),\n     LintId::of(utils::internal_lints::OUTER_EXPN_EXPN_DATA),\n     LintId::of(utils::internal_lints::PRODUCE_ICE),\n+    LintId::of(utils::internal_lints::UNNECESSARY_DEF_PATH),\n     LintId::of(utils::internal_lints::UNNECESSARY_SYMBOL_STR),\n ])"}, {"sha": "05d927dbea7942448898c45ee8cda13db461490c", "filename": "src/tools/clippy/clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_lints.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -24,8 +24,6 @@ store.register_lints(&[\n     #[cfg(feature = \"internal\")]\n     utils::internal_lints::LINT_WITHOUT_LINT_PASS,\n     #[cfg(feature = \"internal\")]\n-    utils::internal_lints::MATCH_TYPE_ON_DIAGNOSTIC_ITEM,\n-    #[cfg(feature = \"internal\")]\n     utils::internal_lints::MISSING_CLIPPY_VERSION_ATTRIBUTE,\n     #[cfg(feature = \"internal\")]\n     utils::internal_lints::MISSING_MSRV_ATTR_IMPL,\n@@ -34,6 +32,8 @@ store.register_lints(&[\n     #[cfg(feature = \"internal\")]\n     utils::internal_lints::PRODUCE_ICE,\n     #[cfg(feature = \"internal\")]\n+    utils::internal_lints::UNNECESSARY_DEF_PATH,\n+    #[cfg(feature = \"internal\")]\n     utils::internal_lints::UNNECESSARY_SYMBOL_STR,\n     almost_complete_letter_range::ALMOST_COMPLETE_LETTER_RANGE,\n     approx_const::APPROX_CONSTANT,\n@@ -60,6 +60,7 @@ store.register_lints(&[\n     booleans::NONMINIMAL_BOOL,\n     booleans::OVERLY_COMPLEX_BOOL_EXPR,\n     borrow_deref_ref::BORROW_DEREF_REF,\n+    box_default::BOX_DEFAULT,\n     cargo::CARGO_COMMON_METADATA,\n     cargo::MULTIPLE_CRATE_VERSIONS,\n     cargo::NEGATIVE_FEATURE_NAMES,\n@@ -113,16 +114,17 @@ store.register_lints(&[\n     derive::DERIVE_PARTIAL_EQ_WITHOUT_EQ,\n     derive::EXPL_IMPL_CLONE_ON_COPY,\n     derive::UNSAFE_DERIVE_DESERIALIZE,\n+    disallowed_macros::DISALLOWED_MACROS,\n     disallowed_methods::DISALLOWED_METHODS,\n     disallowed_names::DISALLOWED_NAMES,\n     disallowed_script_idents::DISALLOWED_SCRIPT_IDENTS,\n     disallowed_types::DISALLOWED_TYPES,\n+    doc::DOC_LINK_WITH_QUOTES,\n     doc::DOC_MARKDOWN,\n     doc::MISSING_ERRORS_DOC,\n     doc::MISSING_PANICS_DOC,\n     doc::MISSING_SAFETY_DOC,\n     doc::NEEDLESS_DOCTEST_MAIN,\n-    doc_link_with_quotes::DOC_LINK_WITH_QUOTES,\n     double_parens::DOUBLE_PARENS,\n     drop_forget_ref::DROP_COPY,\n     drop_forget_ref::DROP_NON_DROP,\n@@ -159,6 +161,7 @@ store.register_lints(&[\n     format::USELESS_FORMAT,\n     format_args::FORMAT_IN_FORMAT_ARGS,\n     format_args::TO_STRING_IN_FORMAT_ARGS,\n+    format_args::UNINLINED_FORMAT_ARGS,\n     format_impl::PRINT_IN_FORMAT_IMPL,\n     format_impl::RECURSIVE_FORMAT_IMPL,\n     format_push_string::FORMAT_PUSH_STRING,\n@@ -182,6 +185,7 @@ store.register_lints(&[\n     if_then_some_else_none::IF_THEN_SOME_ELSE_NONE,\n     implicit_hasher::IMPLICIT_HASHER,\n     implicit_return::IMPLICIT_RETURN,\n+    implicit_saturating_add::IMPLICIT_SATURATING_ADD,\n     implicit_saturating_sub::IMPLICIT_SATURATING_SUB,\n     inconsistent_struct_constructor::INCONSISTENT_STRUCT_CONSTRUCTOR,\n     index_refutable_slice::INDEX_REFUTABLE_SLICE,\n@@ -243,6 +247,7 @@ store.register_lints(&[\n     manual_assert::MANUAL_ASSERT,\n     manual_async_fn::MANUAL_ASYNC_FN,\n     manual_bits::MANUAL_BITS,\n+    manual_clamp::MANUAL_CLAMP,\n     manual_instant_elapsed::MANUAL_INSTANT_ELAPSED,\n     manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE,\n     manual_rem_euclid::MANUAL_REM_EUCLID,"}, {"sha": "e0b4639af53e631ba4250bdfb5f88f3fc5ed061d", "filename": "src/tools/clippy/clippy_lints/src/lib.register_nursery.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_nursery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_nursery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_nursery.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -6,6 +6,7 @@ store.register_group(true, \"clippy::nursery\", Some(\"clippy_nursery\"), vec![\n     LintId::of(attrs::EMPTY_LINE_AFTER_OUTER_ATTR),\n     LintId::of(cognitive_complexity::COGNITIVE_COMPLEXITY),\n     LintId::of(copies::BRANCHES_SHARING_CODE),\n+    LintId::of(derive::DERIVE_PARTIAL_EQ_WITHOUT_EQ),\n     LintId::of(equatable_if_let::EQUATABLE_IF_LET),\n     LintId::of(fallible_impl_from::FALLIBLE_IMPL_FROM),\n     LintId::of(floating_point_arithmetic::IMPRECISE_FLOPS),"}, {"sha": "bc2f0beb358a50f0d8c7981d3e49e7c8dd435b4c", "filename": "src/tools/clippy/clippy_lints/src/lib.register_pedantic.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_pedantic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_pedantic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_pedantic.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -20,15 +20,16 @@ store.register_group(true, \"clippy::pedantic\", Some(\"clippy_pedantic\"), vec![\n     LintId::of(dereference::REF_BINDING_TO_REFERENCE),\n     LintId::of(derive::EXPL_IMPL_CLONE_ON_COPY),\n     LintId::of(derive::UNSAFE_DERIVE_DESERIALIZE),\n+    LintId::of(doc::DOC_LINK_WITH_QUOTES),\n     LintId::of(doc::DOC_MARKDOWN),\n     LintId::of(doc::MISSING_ERRORS_DOC),\n     LintId::of(doc::MISSING_PANICS_DOC),\n-    LintId::of(doc_link_with_quotes::DOC_LINK_WITH_QUOTES),\n     LintId::of(empty_enum::EMPTY_ENUM),\n     LintId::of(enum_variants::MODULE_NAME_REPETITIONS),\n     LintId::of(eta_reduction::REDUNDANT_CLOSURE_FOR_METHOD_CALLS),\n     LintId::of(excessive_bools::FN_PARAMS_EXCESSIVE_BOOLS),\n     LintId::of(excessive_bools::STRUCT_EXCESSIVE_BOOLS),\n+    LintId::of(format_args::UNINLINED_FORMAT_ARGS),\n     LintId::of(functions::MUST_USE_CANDIDATE),\n     LintId::of(functions::TOO_MANY_LINES),\n     LintId::of(if_not_else::IF_NOT_ELSE),"}, {"sha": "8e927470e02ffea36f947a6133ba0dacb98f4226", "filename": "src/tools/clippy/clippy_lints/src/lib.register_perf.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_perf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_perf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_perf.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -3,6 +3,7 @@\n // Manual edits will be overwritten.\n \n store.register_group(true, \"clippy::perf\", Some(\"clippy_perf\"), vec![\n+    LintId::of(box_default::BOX_DEFAULT),\n     LintId::of(entry::MAP_ENTRY),\n     LintId::of(escape::BOXED_LOCAL),\n     LintId::of(format_args::FORMAT_IN_FORMAT_ARGS),"}, {"sha": "8e1390167dc81fd1e7bfd856ee63d6fea4b19577", "filename": "src/tools/clippy/clippy_lints/src/lib.register_style.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_style.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -15,7 +15,7 @@ store.register_group(true, \"clippy::style\", Some(\"clippy_style\"), vec![\n     LintId::of(default::FIELD_REASSIGN_WITH_DEFAULT),\n     LintId::of(default_instead_of_iter_empty::DEFAULT_INSTEAD_OF_ITER_EMPTY),\n     LintId::of(dereference::NEEDLESS_BORROW),\n-    LintId::of(derive::DERIVE_PARTIAL_EQ_WITHOUT_EQ),\n+    LintId::of(disallowed_macros::DISALLOWED_MACROS),\n     LintId::of(disallowed_methods::DISALLOWED_METHODS),\n     LintId::of(disallowed_names::DISALLOWED_NAMES),\n     LintId::of(disallowed_types::DISALLOWED_TYPES),\n@@ -30,6 +30,7 @@ store.register_group(true, \"clippy::style\", Some(\"clippy_style\"), vec![\n     LintId::of(functions::DOUBLE_MUST_USE),\n     LintId::of(functions::MUST_USE_UNIT),\n     LintId::of(functions::RESULT_UNIT_ERR),\n+    LintId::of(implicit_saturating_add::IMPLICIT_SATURATING_ADD),\n     LintId::of(inherent_to_string::INHERENT_TO_STRING),\n     LintId::of(init_numbered_fields::INIT_NUMBERED_FIELDS),\n     LintId::of(len_zero::COMPARISON_TO_EMPTY),"}, {"sha": "2dcefd78763b7f24013f2cd2b6d59cdb628d2cb2", "filename": "src/tools/clippy/clippy_lints/src/lib.rs", "status": "modified", "additions": 30, "deletions": 26, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -31,6 +31,7 @@ extern crate rustc_data_structures;\n extern crate rustc_driver;\n extern crate rustc_errors;\n extern crate rustc_hir;\n+extern crate rustc_hir_analysis;\n extern crate rustc_hir_pretty;\n extern crate rustc_index;\n extern crate rustc_infer;\n@@ -43,7 +44,6 @@ extern crate rustc_session;\n extern crate rustc_span;\n extern crate rustc_target;\n extern crate rustc_trait_selection;\n-extern crate rustc_hir_analysis;\n \n #[macro_use]\n extern crate clippy_utils;\n@@ -180,6 +180,7 @@ mod bool_assert_comparison;\n mod bool_to_int_with_if;\n mod booleans;\n mod borrow_deref_ref;\n+mod box_default;\n mod cargo;\n mod casts;\n mod checked_conversions;\n@@ -198,12 +199,12 @@ mod default_union_representation;\n mod dereference;\n mod derivable_impls;\n mod derive;\n+mod disallowed_macros;\n mod disallowed_methods;\n mod disallowed_names;\n mod disallowed_script_idents;\n mod disallowed_types;\n mod doc;\n-mod doc_link_with_quotes;\n mod double_parens;\n mod drop_forget_ref;\n mod duplicate_mod;\n@@ -238,6 +239,7 @@ mod if_not_else;\n mod if_then_some_else_none;\n mod implicit_hasher;\n mod implicit_return;\n+mod implicit_saturating_add;\n mod implicit_saturating_sub;\n mod inconsistent_struct_constructor;\n mod index_refutable_slice;\n@@ -267,6 +269,7 @@ mod main_recursion;\n mod manual_assert;\n mod manual_async_fn;\n mod manual_bits;\n+mod manual_clamp;\n mod manual_instant_elapsed;\n mod manual_non_exhaustive;\n mod manual_rem_euclid;\n@@ -416,8 +419,7 @@ pub fn register_pre_expansion_lints(store: &mut rustc_lint::LintStore, sess: &Se\n     let msrv = conf.msrv.as_ref().and_then(|s| {\n         parse_msrv(s, None, None).or_else(|| {\n             sess.err(&format!(\n-                \"error reading Clippy's configuration file. `{}` is not a valid Rust version\",\n-                s\n+                \"error reading Clippy's configuration file. `{s}` is not a valid Rust version\"\n             ));\n             None\n         })\n@@ -433,8 +435,7 @@ fn read_msrv(conf: &Conf, sess: &Session) -> Option<RustcVersion> {\n     let clippy_msrv = conf.msrv.as_ref().and_then(|s| {\n         parse_msrv(s, None, None).or_else(|| {\n             sess.err(&format!(\n-                \"error reading Clippy's configuration file. `{}` is not a valid Rust version\",\n-                s\n+                \"error reading Clippy's configuration file. `{s}` is not a valid Rust version\"\n             ));\n             None\n         })\n@@ -445,8 +446,7 @@ fn read_msrv(conf: &Conf, sess: &Session) -> Option<RustcVersion> {\n             // if both files have an msrv, let's compare them and emit a warning if they differ\n             if clippy_msrv != cargo_msrv {\n                 sess.warn(&format!(\n-                    \"the MSRV in `clippy.toml` and `Cargo.toml` differ; using `{}` from `clippy.toml`\",\n-                    clippy_msrv\n+                    \"the MSRV in `clippy.toml` and `Cargo.toml` differ; using `{clippy_msrv}` from `clippy.toml`\"\n                 ));\n             }\n \n@@ -465,7 +465,7 @@ pub fn read_conf(sess: &Session) -> Conf {\n         Ok(Some(path)) => path,\n         Ok(None) => return Conf::default(),\n         Err(error) => {\n-            sess.struct_err(&format!(\"error finding Clippy's configuration file: {}\", error))\n+            sess.struct_err(&format!(\"error finding Clippy's configuration file: {error}\"))\n                 .emit();\n             return Conf::default();\n         },\n@@ -535,9 +535,9 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         store.register_late_pass(|_| Box::new(utils::internal_lints::CompilerLintFunctions::new()));\n         store.register_late_pass(|_| Box::new(utils::internal_lints::IfChainStyle));\n         store.register_late_pass(|_| Box::new(utils::internal_lints::InvalidPaths));\n-        store.register_late_pass(|_| Box::new(utils::internal_lints::InterningDefinedSymbol::default()));\n-        store.register_late_pass(|_| Box::new(utils::internal_lints::LintWithoutLintPass::default()));\n-        store.register_late_pass(|_| Box::new(utils::internal_lints::MatchTypeOnDiagItem));\n+        store.register_late_pass(|_| Box::<utils::internal_lints::InterningDefinedSymbol>::default());\n+        store.register_late_pass(|_| Box::<utils::internal_lints::LintWithoutLintPass>::default());\n+        store.register_late_pass(|_| Box::new(utils::internal_lints::UnnecessaryDefPath));\n         store.register_late_pass(|_| Box::new(utils::internal_lints::OuterExpnDataPass));\n         store.register_late_pass(|_| Box::new(utils::internal_lints::MsrvAttrImpl));\n     }\n@@ -629,10 +629,10 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n             msrv,\n         ))\n     });\n-    store.register_late_pass(|_| Box::new(shadow::Shadow::default()));\n+    store.register_late_pass(|_| Box::<shadow::Shadow>::default());\n     store.register_late_pass(|_| Box::new(unit_types::UnitTypes));\n     store.register_late_pass(|_| Box::new(loops::Loops));\n-    store.register_late_pass(|_| Box::new(main_recursion::MainRecursion::default()));\n+    store.register_late_pass(|_| Box::<main_recursion::MainRecursion>::default());\n     store.register_late_pass(|_| Box::new(lifetimes::Lifetimes));\n     store.register_late_pass(|_| Box::new(entry::HashMapPass));\n     store.register_late_pass(|_| Box::new(minmax::MinMaxPass));\n@@ -666,7 +666,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|_| Box::new(format::UselessFormat));\n     store.register_late_pass(|_| Box::new(swap::Swap));\n     store.register_late_pass(|_| Box::new(overflow_check_conditional::OverflowCheckConditional));\n-    store.register_late_pass(|_| Box::new(new_without_default::NewWithoutDefault::default()));\n+    store.register_late_pass(|_| Box::<new_without_default::NewWithoutDefault>::default());\n     let disallowed_names = conf.disallowed_names.iter().cloned().collect::<FxHashSet<_>>();\n     store.register_late_pass(move |_| Box::new(disallowed_names::DisallowedNames::new(disallowed_names.clone())));\n     let too_many_arguments_threshold = conf.too_many_arguments_threshold;\n@@ -705,7 +705,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|_| Box::new(ref_option_ref::RefOptionRef));\n     store.register_late_pass(|_| Box::new(infinite_iter::InfiniteIter));\n     store.register_late_pass(|_| Box::new(inline_fn_without_body::InlineFnWithoutBody));\n-    store.register_late_pass(|_| Box::new(useless_conversion::UselessConversion::default()));\n+    store.register_late_pass(|_| Box::<useless_conversion::UselessConversion>::default());\n     store.register_late_pass(|_| Box::new(implicit_hasher::ImplicitHasher));\n     store.register_late_pass(|_| Box::new(fallible_impl_from::FallibleImplFrom));\n     store.register_late_pass(|_| Box::new(question_mark::QuestionMark));\n@@ -775,7 +775,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n             upper_case_acronyms_aggressive,\n         ))\n     });\n-    store.register_late_pass(|_| Box::new(default::Default::default()));\n+    store.register_late_pass(|_| Box::<default::Default>::default());\n     store.register_late_pass(move |_| Box::new(unused_self::UnusedSelf::new(avoid_breaking_exported_api)));\n     store.register_late_pass(|_| Box::new(mutable_debug_assertion::DebugAssertWithMutCall));\n     store.register_late_pass(|_| Box::new(exit::Exit));\n@@ -798,7 +798,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_early_pass(|| Box::new(option_env_unwrap::OptionEnvUnwrap));\n     let warn_on_all_wildcard_imports = conf.warn_on_all_wildcard_imports;\n     store.register_late_pass(move |_| Box::new(wildcard_imports::WildcardImports::new(warn_on_all_wildcard_imports)));\n-    store.register_late_pass(|_| Box::new(redundant_pub_crate::RedundantPubCrate::default()));\n+    store.register_late_pass(|_| Box::<redundant_pub_crate::RedundantPubCrate>::default());\n     store.register_late_pass(|_| Box::new(unnamed_address::UnnamedAddress));\n     store.register_late_pass(move |_| Box::new(dereference::Dereferencing::new(msrv)));\n     store.register_late_pass(|_| Box::new(option_if_let_else::OptionIfLetElse));\n@@ -816,11 +816,13 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     });\n     let macro_matcher = conf.standard_macro_braces.iter().cloned().collect::<FxHashSet<_>>();\n     store.register_early_pass(move || Box::new(nonstandard_macro_braces::MacroBraces::new(&macro_matcher)));\n-    store.register_late_pass(|_| Box::new(macro_use::MacroUseImports::default()));\n+    store.register_late_pass(|_| Box::<macro_use::MacroUseImports>::default());\n     store.register_late_pass(|_| Box::new(pattern_type_mismatch::PatternTypeMismatch));\n     store.register_late_pass(|_| Box::new(unwrap_in_result::UnwrapInResult));\n     store.register_late_pass(|_| Box::new(semicolon_if_nothing_returned::SemicolonIfNothingReturned));\n     store.register_late_pass(|_| Box::new(async_yields_async::AsyncYieldsAsync));\n+    let disallowed_macros = conf.disallowed_macros.clone();\n+    store.register_late_pass(move |_| Box::new(disallowed_macros::DisallowedMacros::new(disallowed_macros.clone())));\n     let disallowed_methods = conf.disallowed_methods.clone();\n     store.register_late_pass(move |_| Box::new(disallowed_methods::DisallowedMethods::new(disallowed_methods.clone())));\n     store.register_early_pass(|| Box::new(asm_syntax::InlineAsmX86AttSyntax));\n@@ -829,7 +831,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|_| Box::new(strings::StrToString));\n     store.register_late_pass(|_| Box::new(strings::StringToString));\n     store.register_late_pass(|_| Box::new(zero_sized_map_values::ZeroSizedMapValues));\n-    store.register_late_pass(|_| Box::new(vec_init_then_push::VecInitThenPush::default()));\n+    store.register_late_pass(|_| Box::<vec_init_then_push::VecInitThenPush>::default());\n     store.register_late_pass(|_| Box::new(redundant_slicing::RedundantSlicing));\n     store.register_late_pass(|_| Box::new(from_str_radix_10::FromStrRadix10));\n     store.register_late_pass(move |_| Box::new(if_then_some_else_none::IfThenSomeElseNone::new(msrv)));\n@@ -857,7 +859,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         ))\n     });\n     store.register_late_pass(move |_| Box::new(undocumented_unsafe_blocks::UndocumentedUnsafeBlocks));\n-    store.register_late_pass(move |_| Box::new(format_args::FormatArgs));\n+    store.register_late_pass(move |_| Box::new(format_args::FormatArgs::new(msrv)));\n     store.register_late_pass(|_| Box::new(trailing_empty_array::TrailingEmptyArray));\n     store.register_early_pass(|| Box::new(octal_escapes::OctalEscapes));\n     store.register_late_pass(|_| Box::new(needless_late_init::NeedlessLateInit));\n@@ -866,8 +868,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_early_pass(|| Box::new(single_char_lifetime_names::SingleCharLifetimeNames));\n     store.register_late_pass(move |_| Box::new(manual_bits::ManualBits::new(msrv)));\n     store.register_late_pass(|_| Box::new(default_union_representation::DefaultUnionRepresentation));\n-    store.register_early_pass(|| Box::new(doc_link_with_quotes::DocLinkWithQuotes));\n-    store.register_late_pass(|_| Box::new(only_used_in_recursion::OnlyUsedInRecursion::default()));\n+    store.register_late_pass(|_| Box::<only_used_in_recursion::OnlyUsedInRecursion>::default());\n     let allow_dbg_in_tests = conf.allow_dbg_in_tests;\n     store.register_late_pass(move |_| Box::new(dbg_macro::DbgMacro::new(allow_dbg_in_tests)));\n     let cargo_ignore_publish = conf.cargo_ignore_publish;\n@@ -876,7 +877,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n             ignore_publish: cargo_ignore_publish,\n         })\n     });\n-    store.register_late_pass(|_| Box::new(write::Write::default()));\n+    store.register_late_pass(|_| Box::<write::Write>::default());\n     store.register_early_pass(|| Box::new(crate_in_macro_def::CrateInMacroDef));\n     store.register_early_pass(|| Box::new(empty_structs_with_brackets::EmptyStructsWithBrackets));\n     store.register_late_pass(|_| Box::new(unnecessary_owned_empty_strings::UnnecessaryOwnedEmptyStrings));\n@@ -886,7 +887,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(move |_| Box::new(large_include_file::LargeIncludeFile::new(max_include_file_size)));\n     store.register_late_pass(|_| Box::new(strings::TrimSplitWhitespace));\n     store.register_late_pass(|_| Box::new(rc_clone_in_vec_init::RcCloneInVecInit));\n-    store.register_early_pass(|| Box::new(duplicate_mod::DuplicateMod::default()));\n+    store.register_early_pass(|| Box::<duplicate_mod::DuplicateMod>::default());\n     store.register_early_pass(|| Box::new(unused_rounding::UnusedRounding));\n     store.register_early_pass(move || Box::new(almost_complete_letter_range::AlmostCompleteLetterRange::new(msrv)));\n     store.register_late_pass(|_| Box::new(swap_ptr_to_ref::SwapPtrToRef));\n@@ -898,13 +899,16 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     let verbose_bit_mask_threshold = conf.verbose_bit_mask_threshold;\n     store.register_late_pass(move |_| Box::new(operators::Operators::new(verbose_bit_mask_threshold)));\n     store.register_late_pass(|_| Box::new(invalid_utf8_in_unchecked::InvalidUtf8InUnchecked));\n-    store.register_late_pass(|_| Box::new(std_instead_of_core::StdReexports::default()));\n+    store.register_late_pass(|_| Box::<std_instead_of_core::StdReexports>::default());\n     store.register_late_pass(|_| Box::new(manual_instant_elapsed::ManualInstantElapsed));\n     store.register_late_pass(|_| Box::new(partialeq_to_none::PartialeqToNone));\n+    store.register_late_pass(move |_| Box::new(manual_clamp::ManualClamp::new(msrv)));\n     store.register_late_pass(|_| Box::new(manual_string_new::ManualStringNew));\n     store.register_late_pass(|_| Box::new(unused_peekable::UnusedPeekable));\n     store.register_early_pass(|| Box::new(multi_assignments::MultiAssignments));\n     store.register_late_pass(|_| Box::new(bool_to_int_with_if::BoolToIntWithIf));\n+    store.register_late_pass(|_| Box::new(box_default::BoxDefault));\n+    store.register_late_pass(|_| Box::new(implicit_saturating_add::ImplicitSaturatingAdd));\n     // add lints here, do not remove this comment, it's used in `new_lint`\n }\n "}, {"sha": "aef253303a8f490c913afb282d710d0967bd4b3e", "filename": "src/tools/clippy/clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -9,8 +9,8 @@ use rustc_hir::intravisit::{\n use rustc_hir::FnRetTy::Return;\n use rustc_hir::{\n     BareFnTy, BodyId, FnDecl, GenericArg, GenericBound, GenericParam, GenericParamKind, Generics, Impl, ImplItem,\n-    ImplItemKind, Item, ItemKind, LangItem, Lifetime, LifetimeName, ParamName, PolyTraitRef, PredicateOrigin,\n-    TraitFn, TraitItem, TraitItemKind, Ty, TyKind, WherePredicate,\n+    ImplItemKind, Item, ItemKind, LangItem, Lifetime, LifetimeName, ParamName, PolyTraitRef, PredicateOrigin, TraitFn,\n+    TraitItem, TraitItemKind, Ty, TyKind, WherePredicate,\n };\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::nested_filter as middle_nested_filter;\n@@ -276,7 +276,7 @@ fn could_use_elision<'tcx>(\n         let mut checker = BodyLifetimeChecker {\n             lifetimes_used_in_body: false,\n         };\n-        checker.visit_expr(&body.value);\n+        checker.visit_expr(body.value);\n         if checker.lifetimes_used_in_body {\n             return false;\n         }"}, {"sha": "25f19b9c6e6c771281a212748b21487ed9b8cf50", "filename": "src/tools/clippy/clippy_lints/src/literal_representation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fliteral_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fliteral_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fliteral_representation.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -478,7 +478,7 @@ impl DecimalLiteralRepresentation {\n             if num_lit.radix == Radix::Decimal;\n             if val >= u128::from(self.threshold);\n             then {\n-                let hex = format!(\"{:#X}\", val);\n+                let hex = format!(\"{val:#X}\");\n                 let num_lit = NumericLiteral::new(&hex, num_lit.suffix, false);\n                 let _ = Self::do_lint(num_lit.integer).map_err(|warning_type| {\n                     warning_type.display(num_lit.format(), cx, lit.span);"}, {"sha": "14f2234813277c7c5ae4226278798c26548aa012", "filename": "src/tools/clippy/clippy_lints/src/loops/explicit_counter_loop.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fexplicit_counter_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fexplicit_counter_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fexplicit_counter_loop.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -44,11 +44,10 @@ pub(super) fn check<'tcx>(\n                                 cx,\n                                 EXPLICIT_COUNTER_LOOP,\n                                 span,\n-                                &format!(\"the variable `{}` is used as a loop counter\", name),\n+                                &format!(\"the variable `{name}` is used as a loop counter\"),\n                                 \"consider using\",\n                                 format!(\n-                                    \"for ({}, {}) in {}.enumerate()\",\n-                                    name,\n+                                    \"for ({name}, {}) in {}.enumerate()\",\n                                     snippet_with_applicability(cx, pat.span, \"item\", &mut applicability),\n                                     make_iterator_snippet(cx, arg, &mut applicability),\n                                 ),\n@@ -65,24 +64,21 @@ pub(super) fn check<'tcx>(\n                         cx,\n                         EXPLICIT_COUNTER_LOOP,\n                         span,\n-                        &format!(\"the variable `{}` is used as a loop counter\", name),\n+                        &format!(\"the variable `{name}` is used as a loop counter\"),\n                         |diag| {\n                             diag.span_suggestion(\n                                 span,\n                                 \"consider using\",\n                                 format!(\n-                                    \"for ({}, {}) in (0_{}..).zip({})\",\n-                                    name,\n+                                    \"for ({name}, {}) in (0_{int_name}..).zip({})\",\n                                     snippet_with_applicability(cx, pat.span, \"item\", &mut applicability),\n-                                    int_name,\n                                     make_iterator_snippet(cx, arg, &mut applicability),\n                                 ),\n                                 applicability,\n                             );\n \n                             diag.note(&format!(\n-                                \"`{}` is of type `{}`, making it ineligible for `Iterator::enumerate`\",\n-                                name, int_name\n+                                \"`{name}` is of type `{int_name}`, making it ineligible for `Iterator::enumerate`\"\n                             ));\n                         },\n                     );"}, {"sha": "b1f2941622abbc0af06154094d30a18aeca34a7c", "filename": "src/tools/clippy/clippy_lints/src/loops/explicit_iter_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fexplicit_iter_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fexplicit_iter_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fexplicit_iter_loop.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -41,7 +41,7 @@ pub(super) fn check(cx: &LateContext<'_>, self_arg: &Expr<'_>, arg: &Expr<'_>, m\n         \"it is more concise to loop over references to containers instead of using explicit \\\n          iteration methods\",\n         \"to write this more concisely, try\",\n-        format!(\"&{}{}\", muta, object),\n+        format!(\"&{muta}{object}\"),\n         applicability,\n     );\n }"}, {"sha": "ed620460dbe660f95fc1cb5fcd46a17cc2f16365", "filename": "src/tools/clippy/clippy_lints/src/loops/for_kv_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Ffor_kv_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Ffor_kv_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Ffor_kv_map.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -38,15 +38,15 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>, arg: &'tcx\n                     cx,\n                     FOR_KV_MAP,\n                     arg_span,\n-                    &format!(\"you seem to want to iterate on a map's {}s\", kind),\n+                    &format!(\"you seem to want to iterate on a map's {kind}s\"),\n                     |diag| {\n                         let map = sugg::Sugg::hir(cx, arg, \"map\");\n                         multispan_sugg(\n                             diag,\n                             \"use the corresponding method\",\n                             vec![\n                                 (pat_span, snippet(cx, new_pat_span, kind).into_owned()),\n-                                (arg_span, format!(\"{}.{}s{}()\", map.maybe_par(), kind, mutbl)),\n+                                (arg_span, format!(\"{}.{kind}s{mutbl}()\", map.maybe_par())),\n                             ],\n                         );\n                     },"}, {"sha": "4bb9936e9cde7a235f674ba7483f531b8f3dc1de", "filename": "src/tools/clippy/clippy_lints/src/loops/manual_find.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_find.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_find.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_find.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -1,7 +1,7 @@\n use super::utils::make_iterator_snippet;\n use super::MANUAL_FIND;\n use clippy_utils::{\n-    diagnostics::span_lint_and_then, higher, is_lang_ctor, path_res, peel_blocks_with_stmt,\n+    diagnostics::span_lint_and_then, higher, is_res_lang_ctor, path_res, peel_blocks_with_stmt,\n     source::snippet_with_applicability, ty::implements_trait,\n };\n use if_chain::if_chain;\n@@ -30,8 +30,8 @@ pub(super) fn check<'tcx>(\n         if let [stmt] = block.stmts;\n         if let StmtKind::Semi(semi) = stmt.kind;\n         if let ExprKind::Ret(Some(ret_value)) = semi.kind;\n-        if let ExprKind::Call(Expr { kind: ExprKind::Path(ctor), .. }, [inner_ret]) = ret_value.kind;\n-        if is_lang_ctor(cx, ctor, LangItem::OptionSome);\n+        if let ExprKind::Call(ctor, [inner_ret]) = ret_value.kind;\n+        if is_res_lang_ctor(cx, path_res(cx, ctor), LangItem::OptionSome);\n         if path_res(cx, inner_ret) == Res::Local(binding_id);\n         if let Some((last_stmt, last_ret)) = last_stmt_and_ret(cx, expr);\n         then {\n@@ -143,8 +143,7 @@ fn last_stmt_and_ret<'tcx>(\n         if let Some((_, Node::Block(block))) = parent_iter.next();\n         if let Some((last_stmt, last_ret)) = extract(block);\n         if last_stmt.hir_id == node_hir;\n-        if let ExprKind::Path(path) = &last_ret.kind;\n-        if is_lang_ctor(cx, path, LangItem::OptionNone);\n+        if is_res_lang_ctor(cx, path_res(cx, last_ret), LangItem::OptionNone);\n         if let Some((_, Node::Expr(_block))) = parent_iter.next();\n         // This includes the function header\n         if let Some((_, func)) = parent_iter.next();"}, {"sha": "8c27c09404b1b28e77fb13a62b97bea0a5a6fd7b", "filename": "src/tools/clippy/clippy_lints/src/loops/manual_flatten.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -3,13 +3,13 @@ use super::MANUAL_FLATTEN;\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::higher;\n use clippy_utils::visitors::is_local_used;\n-use clippy_utils::{is_lang_ctor, path_to_local_id, peel_blocks_with_stmt};\n+use clippy_utils::{path_to_local_id, peel_blocks_with_stmt};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::LangItem::{OptionSome, ResultOk};\n+use rustc_hir::def::{DefKind, Res};\n use rustc_hir::{Expr, Pat, PatKind};\n use rustc_lint::LateContext;\n-use rustc_middle::ty;\n+use rustc_middle::ty::{self, DefIdTree};\n use rustc_span::source_map::Span;\n \n /// Check for unnecessary `if let` usage in a for loop where only the `Some` or `Ok` variant of the\n@@ -30,15 +30,17 @@ pub(super) fn check<'tcx>(\n         if path_to_local_id(let_expr, pat_hir_id);\n         // Ensure the `if let` statement is for the `Some` variant of `Option` or the `Ok` variant of `Result`\n         if let PatKind::TupleStruct(ref qpath, _, _) = let_pat.kind;\n-        let some_ctor = is_lang_ctor(cx, qpath, OptionSome);\n-        let ok_ctor = is_lang_ctor(cx, qpath, ResultOk);\n+        if let Res::Def(DefKind::Ctor(..), ctor_id) = cx.qpath_res(qpath, let_pat.hir_id);\n+        if let Some(variant_id) = cx.tcx.opt_parent(ctor_id);\n+        let some_ctor = cx.tcx.lang_items().option_some_variant() == Some(variant_id);\n+        let ok_ctor = cx.tcx.lang_items().result_ok_variant() == Some(variant_id);\n         if some_ctor || ok_ctor;\n         // Ensure expr in `if let` is not used afterwards\n         if !is_local_used(cx, if_then, pat_hir_id);\n         then {\n             let if_let_type = if some_ctor { \"Some\" } else { \"Ok\" };\n             // Prepare the error message\n-            let msg = format!(\"unnecessary `if let` since only the `{}` variant of the iterator element is used\", if_let_type);\n+            let msg = format!(\"unnecessary `if let` since only the `{if_let_type}` variant of the iterator element is used\");\n \n             // Prepare the help message\n             let mut applicability = Applicability::MaybeIncorrect;"}, {"sha": "c87fc4f90e21659fcfd9b8e4a22cb9db6e8d7be9", "filename": "src/tools/clippy/clippy_lints/src/loops/manual_memcpy.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -177,13 +177,7 @@ fn build_manual_memcpy_suggestion<'tcx>(\n     let dst = if dst_offset == sugg::EMPTY && dst_limit == sugg::EMPTY {\n         dst_base_str\n     } else {\n-        format!(\n-            \"{}[{}..{}]\",\n-            dst_base_str,\n-            dst_offset.maybe_par(),\n-            dst_limit.maybe_par()\n-        )\n-        .into()\n+        format!(\"{dst_base_str}[{}..{}]\", dst_offset.maybe_par(), dst_limit.maybe_par()).into()\n     };\n \n     let method_str = if is_copy(cx, elem_ty) {\n@@ -193,10 +187,7 @@ fn build_manual_memcpy_suggestion<'tcx>(\n     };\n \n     format!(\n-        \"{}.{}(&{}[{}..{}]);\",\n-        dst,\n-        method_str,\n-        src_base_str,\n+        \"{dst}.{method_str}(&{src_base_str}[{}..{}]);\",\n         src_offset.maybe_par(),\n         src_limit.maybe_par()\n     )"}, {"sha": "c0a0444485e3b8b8a2b3ce4a26169e57d9a0489d", "filename": "src/tools/clippy/clippy_lints/src/loops/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmod.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -635,7 +635,7 @@ declare_clippy_lint! {\n     ///     arr.into_iter().find(|&el| el == 1)\n     /// }\n     /// ```\n-    #[clippy::version = \"1.61.0\"]\n+    #[clippy::version = \"1.64.0\"]\n     pub MANUAL_FIND,\n     complexity,\n     \"manual implementation of `Iterator::find`\""}, {"sha": "0ee42b61c9a509f7197c4d6f2d63a7b2d41e4a34", "filename": "src/tools/clippy/clippy_lints/src/loops/mut_range_bound.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmut_range_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmut_range_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmut_range_bound.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -4,11 +4,11 @@ use clippy_utils::{get_enclosing_block, higher, path_to_local};\n use if_chain::if_chain;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{BindingAnnotation, Expr, ExprKind, HirId, Node, PatKind};\n+use rustc_hir_analysis::expr_use_visitor::{Delegate, ExprUseVisitor, PlaceBase, PlaceWithHirId};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::LateContext;\n use rustc_middle::{mir::FakeReadCause, ty};\n use rustc_span::source_map::Span;\n-use rustc_hir_analysis::expr_use_visitor::{Delegate, ExprUseVisitor, PlaceBase, PlaceWithHirId};\n \n pub(super) fn check(cx: &LateContext<'_>, arg: &Expr<'_>, body: &Expr<'_>) {\n     if_chain! {\n@@ -114,7 +114,13 @@ impl<'tcx> Delegate<'tcx> for MutatePairDelegate<'_, 'tcx> {\n         }\n     }\n \n-    fn fake_read(&mut self, _: &rustc_hir_analysis::expr_use_visitor::PlaceWithHirId<'tcx>, _: FakeReadCause, _: HirId) {}\n+    fn fake_read(\n+        &mut self,\n+        _: &rustc_hir_analysis::expr_use_visitor::PlaceWithHirId<'tcx>,\n+        _: FakeReadCause,\n+        _: HirId,\n+    ) {\n+    }\n }\n \n impl MutatePairDelegate<'_, '_> {"}, {"sha": "66f9e28596e87cedda9ae44c8508a19523be8341", "filename": "src/tools/clippy/clippy_lints/src/loops/needless_collect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -45,7 +45,7 @@ fn check_needless_collect_direct_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateCont\n                         let (arg, pred) = contains_arg\n                             .strip_prefix('&')\n                             .map_or((\"&x\", &*contains_arg), |s| (\"x\", s));\n-                        format!(\"any(|{}| x == {})\", arg, pred)\n+                        format!(\"any(|{arg}| x == {pred})\")\n                     }\n                     _ => return,\n                 }\n@@ -141,9 +141,9 @@ impl IterFunction {\n             IterFunctionKind::Contains(span) => {\n                 let s = snippet(cx, *span, \"..\");\n                 if let Some(stripped) = s.strip_prefix('&') {\n-                    format!(\".any(|x| x == {})\", stripped)\n+                    format!(\".any(|x| x == {stripped})\")\n                 } else {\n-                    format!(\".any(|x| x == *{})\", s)\n+                    format!(\".any(|x| x == *{s})\")\n                 }\n             },\n         }"}, {"sha": "00cfc6d49f19a7f3043a70ff8d1f7760471466cd", "filename": "src/tools/clippy/clippy_lints/src/loops/needless_range_loop.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -145,7 +145,7 @@ pub(super) fn check<'tcx>(\n                         cx,\n                         NEEDLESS_RANGE_LOOP,\n                         arg.span,\n-                        &format!(\"the loop variable `{}` is used to index `{}`\", ident.name, indexed),\n+                        &format!(\"the loop variable `{}` is used to index `{indexed}`\", ident.name),\n                         |diag| {\n                             multispan_sugg(\n                                 diag,\n@@ -154,24 +154,24 @@ pub(super) fn check<'tcx>(\n                                     (pat.span, format!(\"({}, <item>)\", ident.name)),\n                                     (\n                                         arg.span,\n-                                        format!(\"{}.{}().enumerate(){}{}\", indexed, method, method_1, method_2),\n+                                        format!(\"{indexed}.{method}().enumerate(){method_1}{method_2}\"),\n                                     ),\n                                 ],\n                             );\n                         },\n                     );\n                 } else {\n                     let repl = if starts_at_zero && take_is_empty {\n-                        format!(\"&{}{}\", ref_mut, indexed)\n+                        format!(\"&{ref_mut}{indexed}\")\n                     } else {\n-                        format!(\"{}.{}(){}{}\", indexed, method, method_1, method_2)\n+                        format!(\"{indexed}.{method}(){method_1}{method_2}\")\n                     };\n \n                     span_lint_and_then(\n                         cx,\n                         NEEDLESS_RANGE_LOOP,\n                         arg.span,\n-                        &format!(\"the loop variable `{}` is only used to index `{}`\", ident.name, indexed),\n+                        &format!(\"the loop variable `{}` is only used to index `{indexed}`\", ident.name),\n                         |diag| {\n                             multispan_sugg(\n                                 diag,"}, {"sha": "16b00ad663787cd4c495d5acc9b48917b41be5a9", "filename": "src/tools/clippy/clippy_lints/src/loops/never_loop.rs", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fnever_loop.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -42,6 +42,7 @@ pub(super) fn check(\n     }\n }\n \n+#[derive(Copy, Clone)]\n enum NeverLoopResult {\n     // A break/return always get triggered but not necessarily for the main loop.\n     AlwaysBreak,\n@@ -51,8 +52,8 @@ enum NeverLoopResult {\n }\n \n #[must_use]\n-fn absorb_break(arg: &NeverLoopResult) -> NeverLoopResult {\n-    match *arg {\n+fn absorb_break(arg: NeverLoopResult) -> NeverLoopResult {\n+    match arg {\n         NeverLoopResult::AlwaysBreak | NeverLoopResult::Otherwise => NeverLoopResult::Otherwise,\n         NeverLoopResult::MayContinueMainLoop => NeverLoopResult::MayContinueMainLoop,\n     }\n@@ -92,19 +93,29 @@ fn combine_branches(b1: NeverLoopResult, b2: NeverLoopResult) -> NeverLoopResult\n }\n \n fn never_loop_block(block: &Block<'_>, main_loop_id: HirId) -> NeverLoopResult {\n-    let mut iter = block.stmts.iter().filter_map(stmt_to_expr).chain(block.expr);\n+    let mut iter = block\n+        .stmts\n+        .iter()\n+        .filter_map(stmt_to_expr)\n+        .chain(block.expr.map(|expr| (expr, None)));\n     never_loop_expr_seq(&mut iter, main_loop_id)\n }\n \n-fn never_loop_expr_seq<'a, T: Iterator<Item = &'a Expr<'a>>>(es: &mut T, main_loop_id: HirId) -> NeverLoopResult {\n-    es.map(|e| never_loop_expr(e, main_loop_id))\n-        .fold(NeverLoopResult::Otherwise, combine_seq)\n+fn never_loop_expr_seq<'a, T: Iterator<Item = (&'a Expr<'a>, Option<&'a Block<'a>>)>>(\n+    es: &mut T,\n+    main_loop_id: HirId,\n+) -> NeverLoopResult {\n+    es.map(|(e, els)| {\n+        let e = never_loop_expr(e, main_loop_id);\n+        els.map_or(e, |els| combine_branches(e, never_loop_block(els, main_loop_id)))\n+    })\n+    .fold(NeverLoopResult::Otherwise, combine_seq)\n }\n \n-fn stmt_to_expr<'tcx>(stmt: &Stmt<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n+fn stmt_to_expr<'tcx>(stmt: &Stmt<'tcx>) -> Option<(&'tcx Expr<'tcx>, Option<&'tcx Block<'tcx>>)> {\n     match stmt.kind {\n-        StmtKind::Semi(e, ..) | StmtKind::Expr(e, ..) => Some(e),\n-        StmtKind::Local(local) => local.init,\n+        StmtKind::Semi(e, ..) | StmtKind::Expr(e, ..) => Some((e, None)),\n+        StmtKind::Local(local) => local.init.map(|init| (init, local.els)),\n         StmtKind::Item(..) => None,\n     }\n }\n@@ -139,7 +150,7 @@ fn never_loop_expr(expr: &Expr<'_>, main_loop_id: HirId) -> NeverLoopResult {\n         | ExprKind::Index(e1, e2) => never_loop_expr_all(&mut [e1, e2].iter().copied(), main_loop_id),\n         ExprKind::Loop(b, _, _, _) => {\n             // Break can come from the inner loop so remove them.\n-            absorb_break(&never_loop_block(b, main_loop_id))\n+            absorb_break(never_loop_block(b, main_loop_id))\n         },\n         ExprKind::If(e, e2, e3) => {\n             let e1 = never_loop_expr(e, main_loop_id);\n@@ -211,9 +222,5 @@ fn for_to_if_let_sugg(cx: &LateContext<'_>, iterator: &Expr<'_>, pat: &Pat<'_>)\n     let pat_snippet = snippet(cx, pat.span, \"_\");\n     let iter_snippet = make_iterator_snippet(cx, iterator, &mut Applicability::Unspecified);\n \n-    format!(\n-        \"if let Some({pat}) = {iter}.next()\",\n-        pat = pat_snippet,\n-        iter = iter_snippet\n-    )\n+    format!(\"if let Some({pat_snippet}) = {iter_snippet}.next()\")\n }"}, {"sha": "07edee46fa657639fb29f0ddada7e638ff34cf1d", "filename": "src/tools/clippy/clippy_lints/src/loops/same_item_push.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fsame_item_push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fsame_item_push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fsame_item_push.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -30,10 +30,7 @@ pub(super) fn check<'tcx>(\n             vec.span,\n             \"it looks like the same item is being pushed into this Vec\",\n             None,\n-            &format!(\n-                \"try using vec![{};SIZE] or {}.resize(NEW_SIZE, {})\",\n-                item_str, vec_str, item_str\n-            ),\n+            &format!(\"try using vec![{item_str};SIZE] or {vec_str}.resize(NEW_SIZE, {item_str})\"),\n         );\n     }\n "}, {"sha": "b6f4cf7bbb37f149eccda55bbc0ef40b2f08def9", "filename": "src/tools/clippy/clippy_lints/src/loops/utils.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Futils.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -5,12 +5,12 @@ use rustc_ast::ast::{LitIntType, LitKind};\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_expr, walk_local, walk_pat, walk_stmt, Visitor};\n use rustc_hir::{BinOpKind, BorrowKind, Expr, ExprKind, HirId, HirIdMap, Local, Mutability, Pat, PatKind, Stmt};\n+use rustc_hir_analysis::hir_ty_to_ty;\n use rustc_lint::LateContext;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::ty::{self, Ty};\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{sym, Symbol};\n-use rustc_hir_analysis::hir_ty_to_ty;\n use std::iter::Iterator;\n \n #[derive(Debug, PartialEq, Eq)]\n@@ -344,9 +344,8 @@ pub(super) fn make_iterator_snippet(cx: &LateContext<'_>, arg: &Expr<'_>, applic\n                     _ => arg,\n                 };\n                 format!(\n-                    \"{}.{}()\",\n+                    \"{}.{method_name}()\",\n                     sugg::Sugg::hir_with_applicability(cx, caller, \"_\", applic_ref).maybe_par(),\n-                    method_name,\n                 )\n             },\n             _ => format!("}, {"sha": "153f97e4e66c88ffe334d220c0d8425cf6589796", "filename": "src/tools/clippy/clippy_lints/src/loops/while_let_on_iterator.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -3,13 +3,12 @@ use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::higher;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::{\n-    get_enclosing_loop_or_multi_call_closure, is_refutable, is_trait_method, match_def_path, paths,\n-    visitors::is_res_used,\n+    get_enclosing_loop_or_multi_call_closure, is_refutable, is_res_lang_ctor, is_trait_method, visitors::is_res_used,\n };\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_expr, Visitor};\n-use rustc_hir::{def::Res, Closure, Expr, ExprKind, HirId, Local, Mutability, PatKind, QPath, UnOp};\n+use rustc_hir::{def::Res, Closure, Expr, ExprKind, HirId, LangItem, Local, Mutability, PatKind, UnOp};\n use rustc_lint::LateContext;\n use rustc_middle::hir::nested_filter::OnlyBodies;\n use rustc_middle::ty::adjustment::Adjust;\n@@ -19,9 +18,8 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n     let (scrutinee_expr, iter_expr_struct, iter_expr, some_pat, loop_expr) = if_chain! {\n         if let Some(higher::WhileLet { if_then, let_pat, let_expr }) = higher::WhileLet::hir(expr);\n         // check for `Some(..)` pattern\n-        if let PatKind::TupleStruct(QPath::Resolved(None, pat_path), some_pat, _) = let_pat.kind;\n-        if let Res::Def(_, pat_did) = pat_path.res;\n-        if match_def_path(cx, pat_did, &paths::OPTION_SOME);\n+        if let PatKind::TupleStruct(ref pat_path, some_pat, _) = let_pat.kind;\n+        if is_res_lang_ctor(cx, cx.qpath_res(pat_path, let_pat.hir_id), LangItem::OptionSome);\n         // check for call to `Iterator::next`\n         if let ExprKind::MethodCall(method_name, iter_expr, [], _) = let_expr.kind;\n         if method_name.ident.name == sym::next;\n@@ -67,7 +65,7 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         expr.span.with_hi(scrutinee_expr.span.hi()),\n         \"this loop could be written as a `for` loop\",\n         \"try\",\n-        format!(\"for {} in {}{}\", loop_var, iterator, by_ref),\n+        format!(\"for {loop_var} in {iterator}{by_ref}\"),\n         applicability,\n     );\n }"}, {"sha": "594f6af76b3d874f339203d06ce5c066e9bab9e8", "filename": "src/tools/clippy/clippy_lints/src/macro_use.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmacro_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmacro_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmacro_use.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -189,17 +189,17 @@ impl<'tcx> LateLintPass<'tcx> for MacroUseImports {\n         let mut suggestions = vec![];\n         for ((root, span, hir_id), path) in used {\n             if path.len() == 1 {\n-                suggestions.push((span, format!(\"{}::{}\", root, path[0]), hir_id));\n+                suggestions.push((span, format!(\"{root}::{}\", path[0]), hir_id));\n             } else {\n-                suggestions.push((span, format!(\"{}::{{{}}}\", root, path.join(\", \")), hir_id));\n+                suggestions.push((span, format!(\"{root}::{{{}}}\", path.join(\", \")), hir_id));\n             }\n         }\n \n         // If mac_refs is not empty we have encountered an import we could not handle\n         // such as `std::prelude::v1::foo` or some other macro that expands to an import.\n         if self.mac_refs.is_empty() {\n             for (span, import, hir_id) in suggestions {\n-                let help = format!(\"use {};\", import);\n+                let help = format!(\"use {import};\");\n                 span_lint_hir_and_then(\n                     cx,\n                     MACRO_USE_IMPORTS,"}, {"sha": "825ec84b4a81241be619e8d8b5c4e64689b09ed5", "filename": "src/tools/clippy/clippy_lints/src/manual_assert.rs", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_assert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_assert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_assert.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -1,7 +1,8 @@\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n+use crate::rustc_lint::LintContext;\n+use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::macros::{root_macro_call, FormatArgsExpn};\n use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::{peel_blocks_with_stmt, sugg};\n+use clippy_utils::{peel_blocks_with_stmt, span_extract_comment, sugg};\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind, UnOp};\n use rustc_lint::{LateContext, LateLintPass};\n@@ -50,20 +51,36 @@ impl<'tcx> LateLintPass<'tcx> for ManualAssert {\n                 let mut applicability = Applicability::MachineApplicable;\n                 let format_args_snip = snippet_with_applicability(cx, format_args.inputs_span(), \"..\", &mut applicability);\n                 let cond = cond.peel_drop_temps();\n+                let mut comments = span_extract_comment(cx.sess().source_map(), expr.span);\n+                if !comments.is_empty() {\n+                    comments += \"\\n\";\n+                }\n                 let (cond, not) = match cond.kind {\n                     ExprKind::Unary(UnOp::Not, e) => (e, \"\"),\n                     _ => (cond, \"!\"),\n                 };\n                 let cond_sugg = sugg::Sugg::hir_with_applicability(cx, cond, \"..\", &mut applicability).maybe_par();\n                 let sugg = format!(\"assert!({not}{cond_sugg}, {format_args_snip});\");\n-                span_lint_and_sugg(\n+                // we show to the user the suggestion without the comments, but when applicating the fix, include the comments in the block\n+                span_lint_and_then(\n                     cx,\n                     MANUAL_ASSERT,\n                     expr.span,\n                     \"only a `panic!` in `if`-then statement\",\n-                    \"try\",\n-                    sugg,\n-                    Applicability::MachineApplicable,\n+                    |diag| {\n+                        // comments can be noisy, do not show them to the user\n+                        diag.tool_only_span_suggestion(\n+                                    expr.span.shrink_to_lo(),\n+                                    \"add comments back\",\n+                                    comments,\n+                                    applicability);\n+                        diag.span_suggestion(\n+                                    expr.span,\n+                                    \"try instead\",\n+                                    sugg,\n+                                    applicability);\n+                                     }\n+\n                 );\n             }\n         }"}, {"sha": "9a0a26c0991b3eb59dd9a50caf98308f2ca217d1", "filename": "src/tools/clippy/clippy_lints/src/manual_async_fn.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_async_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_async_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_async_fn.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -74,11 +74,11 @@ impl<'tcx> LateLintPass<'tcx> for ManualAsyncFn {\n                             if let Some(ret_pos) = position_before_rarrow(&header_snip);\n                             if let Some((ret_sugg, ret_snip)) = suggested_ret(cx, output);\n                             then {\n-                                let help = format!(\"make the function `async` and {}\", ret_sugg);\n+                                let help = format!(\"make the function `async` and {ret_sugg}\");\n                                 diag.span_suggestion(\n                                     header_span,\n                                     &help,\n-                                    format!(\"async {}{}\", &header_snip[..ret_pos], ret_snip),\n+                                    format!(\"async {}{ret_snip}\", &header_snip[..ret_pos]),\n                                     Applicability::MachineApplicable\n                                 );\n \n@@ -196,7 +196,7 @@ fn suggested_ret(cx: &LateContext<'_>, output: &Ty<'_>) -> Option<(&'static str,\n         },\n         _ => {\n             let sugg = \"return the output of the future directly\";\n-            snippet_opt(cx, output.span).map(|snip| (sugg, format!(\" -> {}\", snip)))\n+            snippet_opt(cx, output.span).map(|snip| (sugg, format!(\" -> {snip}\")))\n         },\n     }\n }"}, {"sha": "ece4df95505ceb2de65d5bb5ba0e03f7cdc4d7cc", "filename": "src/tools/clippy/clippy_lints/src/manual_clamp.rs", "status": "added", "additions": 713, "deletions": 0, "changes": 713, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_clamp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_clamp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_clamp.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -0,0 +1,713 @@\n+use itertools::Itertools;\n+use rustc_errors::Diagnostic;\n+use rustc_hir::{\n+    def::Res, Arm, BinOpKind, Block, Expr, ExprKind, Guard, HirId, PatKind, PathSegment, PrimTy, QPath, StmtKind,\n+};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::Ty;\n+use rustc_semver::RustcVersion;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::{symbol::sym, Span};\n+use std::ops::Deref;\n+\n+use clippy_utils::{\n+    diagnostics::{span_lint_and_then, span_lint_hir_and_then},\n+    eq_expr_value, get_trait_def_id,\n+    higher::If,\n+    is_diag_trait_item, is_trait_method, meets_msrv, msrvs, path_res, path_to_local_id, paths, peel_blocks,\n+    peel_blocks_with_stmt,\n+    sugg::Sugg,\n+    ty::implements_trait,\n+    visitors::is_const_evaluatable,\n+    MaybePath,\n+};\n+use rustc_errors::Applicability;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Identifies good opportunities for a clamp function from std or core, and suggests using it.\n+    ///\n+    /// ### Why is this bad?\n+    /// clamp is much shorter, easier to read, and doesn't use any control flow.\n+    ///\n+    /// ### Known issue(s)\n+    /// If the clamped variable is NaN this suggestion will cause the code to propagate NaN\n+    /// rather than returning either `max` or `min`.\n+    ///\n+    /// `clamp` functions will panic if `max < min`, `max.is_nan()`, or `min.is_nan()`.\n+    /// Some may consider panicking in these situations to be desirable, but it also may\n+    /// introduce panicking where there wasn't any before.\n+    ///\n+    /// ### Examples\n+    /// ```rust\n+    /// # let (input, min, max) = (0, -2, 1);\n+    /// if input > max {\n+    ///     max\n+    /// } else if input < min {\n+    ///     min\n+    /// } else {\n+    ///     input\n+    /// }\n+    /// # ;\n+    /// ```\n+    ///\n+    /// ```rust\n+    /// # let (input, min, max) = (0, -2, 1);\n+    /// input.max(min).min(max)\n+    /// # ;\n+    /// ```\n+    ///\n+    /// ```rust\n+    /// # let (input, min, max) = (0, -2, 1);\n+    /// match input {\n+    ///     x if x > max => max,\n+    ///     x if x < min => min,\n+    ///     x => x,\n+    /// }\n+    /// # ;\n+    /// ```\n+    ///\n+    /// ```rust\n+    /// # let (input, min, max) = (0, -2, 1);\n+    /// let mut x = input;\n+    /// if x < min { x = min; }\n+    /// if x > max { x = max; }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// # let (input, min, max) = (0, -2, 1);\n+    /// input.clamp(min, max)\n+    /// # ;\n+    /// ```\n+    #[clippy::version = \"1.66.0\"]\n+    pub MANUAL_CLAMP,\n+    complexity,\n+    \"using a clamp pattern instead of the clamp function\"\n+}\n+impl_lint_pass!(ManualClamp => [MANUAL_CLAMP]);\n+\n+pub struct ManualClamp {\n+    msrv: Option<RustcVersion>,\n+}\n+\n+impl ManualClamp {\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n+        Self { msrv }\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct ClampSuggestion<'tcx> {\n+    params: InputMinMax<'tcx>,\n+    span: Span,\n+    make_assignment: Option<&'tcx Expr<'tcx>>,\n+    hir_with_ignore_attr: Option<HirId>,\n+}\n+\n+#[derive(Debug)]\n+struct InputMinMax<'tcx> {\n+    input: &'tcx Expr<'tcx>,\n+    min: &'tcx Expr<'tcx>,\n+    max: &'tcx Expr<'tcx>,\n+    is_float: bool,\n+}\n+\n+impl<'tcx> LateLintPass<'tcx> for ManualClamp {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n+        if !meets_msrv(self.msrv, msrvs::CLAMP) {\n+            return;\n+        }\n+        if !expr.span.from_expansion() {\n+            let suggestion = is_if_elseif_else_pattern(cx, expr)\n+                .or_else(|| is_max_min_pattern(cx, expr))\n+                .or_else(|| is_call_max_min_pattern(cx, expr))\n+                .or_else(|| is_match_pattern(cx, expr))\n+                .or_else(|| is_if_elseif_pattern(cx, expr));\n+            if let Some(suggestion) = suggestion {\n+                emit_suggestion(cx, &suggestion);\n+            }\n+        }\n+    }\n+\n+    fn check_block(&mut self, cx: &LateContext<'tcx>, block: &'tcx Block<'tcx>) {\n+        if !meets_msrv(self.msrv, msrvs::CLAMP) {\n+            return;\n+        }\n+        for suggestion in is_two_if_pattern(cx, block) {\n+            emit_suggestion(cx, &suggestion);\n+        }\n+    }\n+    extract_msrv_attr!(LateContext);\n+}\n+\n+fn emit_suggestion<'tcx>(cx: &LateContext<'tcx>, suggestion: &ClampSuggestion<'tcx>) {\n+    let ClampSuggestion {\n+        params: InputMinMax {\n+            input,\n+            min,\n+            max,\n+            is_float,\n+        },\n+        span,\n+        make_assignment,\n+        hir_with_ignore_attr,\n+    } = suggestion;\n+    let input = Sugg::hir(cx, input, \"..\").maybe_par();\n+    let min = Sugg::hir(cx, min, \"..\");\n+    let max = Sugg::hir(cx, max, \"..\");\n+    let semicolon = if make_assignment.is_some() { \";\" } else { \"\" };\n+    let assignment = if let Some(assignment) = make_assignment {\n+        let assignment = Sugg::hir(cx, assignment, \"..\");\n+        format!(\"{assignment} = \")\n+    } else {\n+        String::new()\n+    };\n+    let suggestion = format!(\"{assignment}{input}.clamp({min}, {max}){semicolon}\");\n+    let msg = \"clamp-like pattern without using clamp function\";\n+    let lint_builder = |d: &mut Diagnostic| {\n+        d.span_suggestion(*span, \"replace with clamp\", suggestion, Applicability::MaybeIncorrect);\n+        if *is_float {\n+            d.note(\"clamp will panic if max < min, min.is_nan(), or max.is_nan()\")\n+                .note(\"clamp returns NaN if the input is NaN\");\n+        } else {\n+            d.note(\"clamp will panic if max < min\");\n+        }\n+    };\n+    if let Some(hir_id) = hir_with_ignore_attr {\n+        span_lint_hir_and_then(cx, MANUAL_CLAMP, *hir_id, *span, msg, lint_builder);\n+    } else {\n+        span_lint_and_then(cx, MANUAL_CLAMP, *span, msg, lint_builder);\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, Eq, PartialEq)]\n+enum TypeClampability {\n+    Float,\n+    Ord,\n+}\n+\n+impl TypeClampability {\n+    fn is_clampable<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<TypeClampability> {\n+        if ty.is_floating_point() {\n+            Some(TypeClampability::Float)\n+        } else if get_trait_def_id(cx, &paths::ORD).map_or(false, |id| implements_trait(cx, ty, id, &[])) {\n+            Some(TypeClampability::Ord)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn is_float(self) -> bool {\n+        matches!(self, TypeClampability::Float)\n+    }\n+}\n+\n+/// Targets patterns like\n+///\n+/// ```\n+/// # let (input, min, max) = (0, -3, 12);\n+///\n+/// if input < min {\n+///     min\n+/// } else if input > max {\n+///     max\n+/// } else {\n+///     input\n+/// }\n+/// # ;\n+/// ```\n+fn is_if_elseif_else_pattern<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> Option<ClampSuggestion<'tcx>> {\n+    if let Some(If {\n+        cond,\n+        then,\n+        r#else: Some(else_if),\n+    }) = If::hir(expr)\n+    && let Some(If {\n+        cond: else_if_cond,\n+        then: else_if_then,\n+        r#else: Some(else_body),\n+    }) = If::hir(peel_blocks(else_if))\n+    {\n+        let params = is_clamp_meta_pattern(\n+            cx,\n+            &BinaryOp::new(peel_blocks(cond))?,\n+            &BinaryOp::new(peel_blocks(else_if_cond))?,\n+            peel_blocks(then),\n+            peel_blocks(else_if_then),\n+            None,\n+        )?;\n+        // Contents of the else should be the resolved input.\n+        if !eq_expr_value(cx, params.input, peel_blocks(else_body)) {\n+            return None;\n+        }\n+        Some(ClampSuggestion {\n+            params,\n+            span: expr.span,\n+            make_assignment: None,\n+            hir_with_ignore_attr: None,\n+        })\n+    } else {\n+        None\n+    }\n+}\n+\n+/// Targets patterns like\n+///\n+/// ```\n+/// # let (input, min_value, max_value) = (0, -3, 12);\n+///\n+/// input.max(min_value).min(max_value)\n+/// # ;\n+/// ```\n+fn is_max_min_pattern<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> Option<ClampSuggestion<'tcx>> {\n+    if let ExprKind::MethodCall(seg_second, receiver, [arg_second], _) = &expr.kind\n+        && (cx.typeck_results().expr_ty_adjusted(receiver).is_floating_point() || is_trait_method(cx, expr, sym::Ord))\n+        && let ExprKind::MethodCall(seg_first, input, [arg_first], _) = &receiver.kind\n+        && (cx.typeck_results().expr_ty_adjusted(input).is_floating_point() || is_trait_method(cx, receiver, sym::Ord))\n+    {\n+        let is_float = cx.typeck_results().expr_ty_adjusted(input).is_floating_point();\n+        let (min, max) = match (seg_first.ident.as_str(), seg_second.ident.as_str()) {\n+            (\"min\", \"max\") => (arg_second, arg_first),\n+            (\"max\", \"min\") => (arg_first, arg_second),\n+            _ => return None,\n+        };\n+        Some(ClampSuggestion {\n+            params: InputMinMax { input, min, max, is_float },\n+            span: expr.span,\n+            make_assignment: None,\n+            hir_with_ignore_attr: None,\n+        })\n+    } else {\n+        None\n+    }\n+}\n+\n+/// Targets patterns like\n+///\n+/// ```\n+/// # let (input, min_value, max_value) = (0, -3, 12);\n+/// # use std::cmp::{max, min};\n+/// min(max(input, min_value), max_value)\n+/// # ;\n+/// ```\n+fn is_call_max_min_pattern<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> Option<ClampSuggestion<'tcx>> {\n+    fn segment<'tcx>(cx: &LateContext<'_>, func: &Expr<'tcx>) -> Option<FunctionType<'tcx>> {\n+        match func.kind {\n+            ExprKind::Path(QPath::Resolved(None, path)) => {\n+                let id = path.res.opt_def_id()?;\n+                match cx.tcx.get_diagnostic_name(id) {\n+                    Some(sym::cmp_min) => Some(FunctionType::CmpMin),\n+                    Some(sym::cmp_max) => Some(FunctionType::CmpMax),\n+                    _ if is_diag_trait_item(cx, id, sym::Ord) => {\n+                        Some(FunctionType::OrdOrFloat(path.segments.last().expect(\"infallible\")))\n+                    },\n+                    _ => None,\n+                }\n+            },\n+            ExprKind::Path(QPath::TypeRelative(ty, seg)) => {\n+                matches!(path_res(cx, ty), Res::PrimTy(PrimTy::Float(_))).then(|| FunctionType::OrdOrFloat(seg))\n+            },\n+            _ => None,\n+        }\n+    }\n+\n+    enum FunctionType<'tcx> {\n+        CmpMin,\n+        CmpMax,\n+        OrdOrFloat(&'tcx PathSegment<'tcx>),\n+    }\n+\n+    fn check<'tcx>(\n+        cx: &LateContext<'tcx>,\n+        outer_fn: &'tcx Expr<'tcx>,\n+        inner_call: &'tcx Expr<'tcx>,\n+        outer_arg: &'tcx Expr<'tcx>,\n+        span: Span,\n+    ) -> Option<ClampSuggestion<'tcx>> {\n+        if let ExprKind::Call(inner_fn, [first, second]) = &inner_call.kind\n+            && let Some(inner_seg) = segment(cx, inner_fn)\n+            && let Some(outer_seg) = segment(cx, outer_fn)\n+        {\n+            let (input, inner_arg) = match (is_const_evaluatable(cx, first), is_const_evaluatable(cx, second)) {\n+                (true, false) => (second, first),\n+                (false, true) => (first, second),\n+                _ => return None,\n+            };\n+            let is_float = cx.typeck_results().expr_ty_adjusted(input).is_floating_point();\n+            let (min, max) = match (inner_seg, outer_seg) {\n+                (FunctionType::CmpMin, FunctionType::CmpMax) => (outer_arg, inner_arg),\n+                (FunctionType::CmpMax, FunctionType::CmpMin) => (inner_arg, outer_arg),\n+                (FunctionType::OrdOrFloat(first_segment), FunctionType::OrdOrFloat(second_segment)) => {\n+                    match (first_segment.ident.as_str(), second_segment.ident.as_str()) {\n+                        (\"min\", \"max\") => (outer_arg, inner_arg),\n+                        (\"max\", \"min\") => (inner_arg, outer_arg),\n+                        _ => return None,\n+                    }\n+                }\n+                _ => return None,\n+            };\n+            Some(ClampSuggestion {\n+                params: InputMinMax { input, min, max, is_float },\n+                span,\n+                make_assignment: None,\n+                hir_with_ignore_attr: None,\n+            })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    if let ExprKind::Call(outer_fn, [first, second]) = &expr.kind {\n+        check(cx, outer_fn, first, second, expr.span).or_else(|| check(cx, outer_fn, second, first, expr.span))\n+    } else {\n+        None\n+    }\n+}\n+\n+/// Targets patterns like\n+///\n+/// ```\n+/// # let (input, min, max) = (0, -3, 12);\n+///\n+/// match input {\n+///     input if input > max => max,\n+///     input if input < min => min,\n+///     input => input,\n+/// }\n+/// # ;\n+/// ```\n+fn is_match_pattern<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> Option<ClampSuggestion<'tcx>> {\n+    if let ExprKind::Match(value, [first_arm, second_arm, last_arm], rustc_hir::MatchSource::Normal) = &expr.kind {\n+        // Find possible min/max branches\n+        let minmax_values = |a: &'tcx Arm<'tcx>| {\n+            if let PatKind::Binding(_, var_hir_id, _, None) = &a.pat.kind\n+            && let Some(Guard::If(e)) = a.guard {\n+                Some((e, var_hir_id, a.body))\n+            } else {\n+                None\n+            }\n+        };\n+        let (first, first_hir_id, first_expr) = minmax_values(first_arm)?;\n+        let (second, second_hir_id, second_expr) = minmax_values(second_arm)?;\n+        let first = BinaryOp::new(first)?;\n+        let second = BinaryOp::new(second)?;\n+        if let PatKind::Binding(_, binding, _, None) = &last_arm.pat.kind\n+            && path_to_local_id(peel_blocks_with_stmt(last_arm.body), *binding)\n+            && last_arm.guard.is_none()\n+        {\n+            // Proceed as normal\n+        } else {\n+            return None;\n+        }\n+        if let Some(params) = is_clamp_meta_pattern(\n+            cx,\n+            &first,\n+            &second,\n+            first_expr,\n+            second_expr,\n+            Some((*first_hir_id, *second_hir_id)),\n+        ) {\n+            return Some(ClampSuggestion {\n+                params: InputMinMax {\n+                    input: value,\n+                    min: params.min,\n+                    max: params.max,\n+                    is_float: params.is_float,\n+                },\n+                span: expr.span,\n+                make_assignment: None,\n+                hir_with_ignore_attr: None,\n+            });\n+        }\n+    }\n+    None\n+}\n+\n+/// Targets patterns like\n+///\n+/// ```\n+/// # let (input, min, max) = (0, -3, 12);\n+///\n+/// let mut x = input;\n+/// if x < min { x = min; }\n+/// if x > max { x = max; }\n+/// ```\n+fn is_two_if_pattern<'tcx>(cx: &LateContext<'tcx>, block: &'tcx Block<'tcx>) -> Vec<ClampSuggestion<'tcx>> {\n+    block_stmt_with_last(block)\n+        .tuple_windows()\n+        .filter_map(|(maybe_set_first, maybe_set_second)| {\n+            if let StmtKind::Expr(first_expr) = *maybe_set_first\n+                && let StmtKind::Expr(second_expr) = *maybe_set_second\n+                && let Some(If { cond: first_cond, then: first_then, r#else: None }) = If::hir(first_expr)\n+                && let Some(If { cond: second_cond, then: second_then, r#else: None }) = If::hir(second_expr)\n+                && let ExprKind::Assign(\n+                    maybe_input_first_path,\n+                    maybe_min_max_first,\n+                    _\n+                ) = peel_blocks_with_stmt(first_then).kind\n+                && let ExprKind::Assign(\n+                    maybe_input_second_path,\n+                    maybe_min_max_second,\n+                    _\n+                ) = peel_blocks_with_stmt(second_then).kind\n+                && eq_expr_value(cx, maybe_input_first_path, maybe_input_second_path)\n+                && let Some(first_bin) = BinaryOp::new(first_cond)\n+                && let Some(second_bin) = BinaryOp::new(second_cond)\n+                && let Some(input_min_max) = is_clamp_meta_pattern(\n+                    cx,\n+                    &first_bin,\n+                    &second_bin,\n+                    maybe_min_max_first,\n+                    maybe_min_max_second,\n+                    None\n+                )\n+            {\n+                Some(ClampSuggestion {\n+                    params: InputMinMax {\n+                        input: maybe_input_first_path,\n+                        min: input_min_max.min,\n+                        max: input_min_max.max,\n+                        is_float: input_min_max.is_float,\n+                    },\n+                    span: first_expr.span.to(second_expr.span),\n+                    make_assignment: Some(maybe_input_first_path),\n+                    hir_with_ignore_attr: Some(first_expr.hir_id()),\n+                })\n+            } else {\n+                None\n+            }\n+        })\n+        .collect()\n+}\n+\n+/// Targets patterns like\n+///\n+/// ```\n+/// # let (mut input, min, max) = (0, -3, 12);\n+///\n+/// if input < min {\n+///     input = min;\n+/// } else if input > max {\n+///     input = max;\n+/// }\n+/// ```\n+fn is_if_elseif_pattern<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> Option<ClampSuggestion<'tcx>> {\n+    if let Some(If {\n+        cond,\n+        then,\n+        r#else: Some(else_if),\n+    }) = If::hir(expr)\n+        && let Some(If {\n+            cond: else_if_cond,\n+            then: else_if_then,\n+            r#else: None,\n+        }) = If::hir(peel_blocks(else_if))\n+        && let ExprKind::Assign(\n+            maybe_input_first_path,\n+            maybe_min_max_first,\n+            _\n+        ) = peel_blocks_with_stmt(then).kind\n+        && let ExprKind::Assign(\n+            maybe_input_second_path,\n+            maybe_min_max_second,\n+            _\n+        ) = peel_blocks_with_stmt(else_if_then).kind\n+    {\n+        let params = is_clamp_meta_pattern(\n+            cx,\n+            &BinaryOp::new(peel_blocks(cond))?,\n+            &BinaryOp::new(peel_blocks(else_if_cond))?,\n+            peel_blocks(maybe_min_max_first),\n+            peel_blocks(maybe_min_max_second),\n+            None,\n+        )?;\n+        if !eq_expr_value(cx, maybe_input_first_path, maybe_input_second_path) {\n+            return None;\n+        }\n+        Some(ClampSuggestion {\n+            params,\n+            span: expr.span,\n+            make_assignment: Some(maybe_input_first_path),\n+            hir_with_ignore_attr: None,\n+        })\n+    } else {\n+        None\n+    }\n+}\n+\n+/// `ExprKind::Binary` but more narrowly typed\n+#[derive(Debug, Clone, Copy)]\n+struct BinaryOp<'tcx> {\n+    op: BinOpKind,\n+    left: &'tcx Expr<'tcx>,\n+    right: &'tcx Expr<'tcx>,\n+}\n+\n+impl<'tcx> BinaryOp<'tcx> {\n+    fn new(e: &'tcx Expr<'tcx>) -> Option<BinaryOp<'tcx>> {\n+        match &e.kind {\n+            ExprKind::Binary(op, left, right) => Some(BinaryOp {\n+                op: op.node,\n+                left,\n+                right,\n+            }),\n+            _ => None,\n+        }\n+    }\n+\n+    fn flip(&self) -> Self {\n+        Self {\n+            op: match self.op {\n+                BinOpKind::Le => BinOpKind::Ge,\n+                BinOpKind::Lt => BinOpKind::Gt,\n+                BinOpKind::Ge => BinOpKind::Le,\n+                BinOpKind::Gt => BinOpKind::Lt,\n+                other => other,\n+            },\n+            left: self.right,\n+            right: self.left,\n+        }\n+    }\n+}\n+\n+/// The clamp meta pattern is a pattern shared between many (but not all) patterns.\n+/// In summary, this pattern consists of two if statements that meet many criteria,\n+/// - binary operators that are one of [`>`, `<`, `>=`, `<=`].\n+/// - Both binary statements must have a shared argument\n+///     - Which can appear on the left or right side of either statement\n+///     - The binary operators must define a finite range for the shared argument. To put this in\n+///       the terms of Rust `std` library, the following ranges are acceptable\n+///         - `Range`\n+///         - `RangeInclusive`\n+///       And all other range types are not accepted. For the purposes of `clamp` it's irrelevant\n+///       whether the range is inclusive or not, the output is the same.\n+/// - The result of each if statement must be equal to the argument unique to that if statement. The\n+///   result can not be the shared argument in either case.\n+fn is_clamp_meta_pattern<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    first_bin: &BinaryOp<'tcx>,\n+    second_bin: &BinaryOp<'tcx>,\n+    first_expr: &'tcx Expr<'tcx>,\n+    second_expr: &'tcx Expr<'tcx>,\n+    // This parameters is exclusively for the match pattern.\n+    // It exists because the variable bindings used in that pattern\n+    // refer to the variable bound in the match arm, not the variable\n+    // bound outside of it. Fortunately due to context we know this has to\n+    // be the input variable, not the min or max.\n+    input_hir_ids: Option<(HirId, HirId)>,\n+) -> Option<InputMinMax<'tcx>> {\n+    fn check<'tcx>(\n+        cx: &LateContext<'tcx>,\n+        first_bin: &BinaryOp<'tcx>,\n+        second_bin: &BinaryOp<'tcx>,\n+        first_expr: &'tcx Expr<'tcx>,\n+        second_expr: &'tcx Expr<'tcx>,\n+        input_hir_ids: Option<(HirId, HirId)>,\n+        is_float: bool,\n+    ) -> Option<InputMinMax<'tcx>> {\n+        match (&first_bin.op, &second_bin.op) {\n+            (BinOpKind::Ge | BinOpKind::Gt, BinOpKind::Le | BinOpKind::Lt) => {\n+                let (min, max) = (second_expr, first_expr);\n+                let refers_to_input = match input_hir_ids {\n+                    Some((first_hir_id, second_hir_id)) => {\n+                        path_to_local_id(peel_blocks(first_bin.left), first_hir_id)\n+                            && path_to_local_id(peel_blocks(second_bin.left), second_hir_id)\n+                    },\n+                    None => eq_expr_value(cx, first_bin.left, second_bin.left),\n+                };\n+                (refers_to_input\n+                    && eq_expr_value(cx, first_bin.right, first_expr)\n+                    && eq_expr_value(cx, second_bin.right, second_expr))\n+                .then_some(InputMinMax {\n+                    input: first_bin.left,\n+                    min,\n+                    max,\n+                    is_float,\n+                })\n+            },\n+            _ => None,\n+        }\n+    }\n+    // First filter out any expressions with side effects\n+    let exprs = [\n+        first_bin.left,\n+        first_bin.right,\n+        second_bin.left,\n+        second_bin.right,\n+        first_expr,\n+        second_expr,\n+    ];\n+    let clampability = TypeClampability::is_clampable(cx, cx.typeck_results().expr_ty(first_expr))?;\n+    let is_float = clampability.is_float();\n+    if exprs.iter().any(|e| peel_blocks(e).can_have_side_effects()) {\n+        return None;\n+    }\n+    if !(is_ord_op(first_bin.op) && is_ord_op(second_bin.op)) {\n+        return None;\n+    }\n+    let cases = [\n+        (*first_bin, *second_bin),\n+        (first_bin.flip(), second_bin.flip()),\n+        (first_bin.flip(), *second_bin),\n+        (*first_bin, second_bin.flip()),\n+    ];\n+\n+    cases.into_iter().find_map(|(first, second)| {\n+        check(cx, &first, &second, first_expr, second_expr, input_hir_ids, is_float).or_else(|| {\n+            check(\n+                cx,\n+                &second,\n+                &first,\n+                second_expr,\n+                first_expr,\n+                input_hir_ids.map(|(l, r)| (r, l)),\n+                is_float,\n+            )\n+        })\n+    })\n+}\n+\n+fn block_stmt_with_last<'tcx>(block: &'tcx Block<'tcx>) -> impl Iterator<Item = MaybeBorrowedStmtKind<'tcx>> {\n+    block\n+        .stmts\n+        .iter()\n+        .map(|s| MaybeBorrowedStmtKind::Borrowed(&s.kind))\n+        .chain(\n+            block\n+                .expr\n+                .as_ref()\n+                .map(|e| MaybeBorrowedStmtKind::Owned(StmtKind::Expr(e))),\n+        )\n+}\n+\n+fn is_ord_op(op: BinOpKind) -> bool {\n+    matches!(op, BinOpKind::Ge | BinOpKind::Gt | BinOpKind::Le | BinOpKind::Lt)\n+}\n+\n+/// Really similar to Cow, but doesn't have a `Clone` requirement.\n+#[derive(Debug)]\n+enum MaybeBorrowedStmtKind<'a> {\n+    Borrowed(&'a StmtKind<'a>),\n+    Owned(StmtKind<'a>),\n+}\n+\n+impl<'a> Clone for MaybeBorrowedStmtKind<'a> {\n+    fn clone(&self) -> Self {\n+        match self {\n+            Self::Borrowed(t) => Self::Borrowed(t),\n+            Self::Owned(StmtKind::Expr(e)) => Self::Owned(StmtKind::Expr(e)),\n+            Self::Owned(_) => unreachable!(\"Owned should only ever contain a StmtKind::Expr.\"),\n+        }\n+    }\n+}\n+\n+impl<'a> Deref for MaybeBorrowedStmtKind<'a> {\n+    type Target = StmtKind<'a>;\n+\n+    fn deref(&self) -> &Self::Target {\n+        match self {\n+            Self::Borrowed(t) => t,\n+            Self::Owned(t) => t,\n+        }\n+    }\n+}"}, {"sha": "6a42275322b4399218b58239de3d5b38187f8e74", "filename": "src/tools/clippy/clippy_lints/src/manual_non_exhaustive.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -133,7 +133,7 @@ impl EarlyLintPass for ManualNonExhaustiveStruct {\n                             diag.span_suggestion(\n                                 header_span,\n                                 \"add the attribute\",\n-                                format!(\"#[non_exhaustive] {}\", snippet),\n+                                format!(\"#[non_exhaustive] {snippet}\"),\n                                 Applicability::Unspecified,\n                             );\n                         }\n@@ -207,7 +207,7 @@ impl<'tcx> LateLintPass<'tcx> for ManualNonExhaustiveEnum {\n                             diag.span_suggestion(\n                                 header_span,\n                                 \"add the attribute\",\n-                                format!(\"#[non_exhaustive] {}\", snippet),\n+                                format!(\"#[non_exhaustive] {snippet}\"),\n                                 Applicability::Unspecified,\n                             );\n                     }"}, {"sha": "6f25a2ed8e434f60b11025d4943f6127a9848f1c", "filename": "src/tools/clippy/clippy_lints/src/manual_rem_euclid.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_rem_euclid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_rem_euclid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_rem_euclid.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -27,7 +27,7 @@ declare_clippy_lint! {\n     /// let x: i32 = 24;\n     /// let rem = x.rem_euclid(4);\n     /// ```\n-    #[clippy::version = \"1.63.0\"]\n+    #[clippy::version = \"1.64.0\"]\n     pub MANUAL_REM_EUCLID,\n     complexity,\n     \"manually reimplementing `rem_euclid`\""}, {"sha": "3181bc86d179362e0ed6d075837ef569c7094478", "filename": "src/tools/clippy/clippy_lints/src/manual_retain.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_retain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_retain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_retain.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -43,7 +43,7 @@ declare_clippy_lint! {\n     /// let mut vec = vec![0, 1, 2];\n     /// vec.retain(|x| x % 2 == 0);\n     /// ```\n-    #[clippy::version = \"1.63.0\"]\n+    #[clippy::version = \"1.64.0\"]\n     pub MANUAL_RETAIN,\n     perf,\n     \"`retain()` is simpler and the same functionalitys\"\n@@ -92,7 +92,7 @@ fn check_into_iter(\n         && match_def_path(cx, filter_def_id, &paths::CORE_ITER_FILTER)\n         && let hir::ExprKind::MethodCall(_, struct_expr, [], _) = &into_iter_expr.kind\n         && let Some(into_iter_def_id) = cx.typeck_results().type_dependent_def_id(into_iter_expr.hir_id)\n-        && match_def_path(cx, into_iter_def_id, &paths::CORE_ITER_INTO_ITER)\n+        && cx.tcx.lang_items().require(hir::LangItem::IntoIterIntoIter).ok() == Some(into_iter_def_id)\n         && match_acceptable_type(cx, left_expr, msrv)\n         && SpanlessEq::new(cx).eq_expr(left_expr, struct_expr) {\n         suggest(cx, parent_expr, left_expr, target_expr);\n@@ -153,15 +153,15 @@ fn suggest(cx: &LateContext<'_>, parent_expr: &hir::Expr<'_>, left_expr: &hir::E\n         && let [filter_params] = filter_body.params\n         && let Some(sugg) = match filter_params.pat.kind {\n             hir::PatKind::Binding(_, _, filter_param_ident, None) => {\n-                Some(format!(\"{}.retain(|{}| {})\", snippet(cx, left_expr.span, \"..\"), filter_param_ident, snippet(cx, filter_body.value.span, \"..\")))\n+                Some(format!(\"{}.retain(|{filter_param_ident}| {})\", snippet(cx, left_expr.span, \"..\"), snippet(cx, filter_body.value.span, \"..\")))\n             },\n             hir::PatKind::Tuple([key_pat, value_pat], _) => {\n                 make_sugg(cx, key_pat, value_pat, left_expr, filter_body)\n             },\n             hir::PatKind::Ref(pat, _) => {\n                 match pat.kind {\n                     hir::PatKind::Binding(_, _, filter_param_ident, None) => {\n-                        Some(format!(\"{}.retain(|{}| {})\", snippet(cx, left_expr.span, \"..\"), filter_param_ident, snippet(cx, filter_body.value.span, \"..\")))\n+                        Some(format!(\"{}.retain(|{filter_param_ident}| {})\", snippet(cx, left_expr.span, \"..\"), snippet(cx, filter_body.value.span, \"..\")))\n                     },\n                     _ => None\n                 }\n@@ -190,23 +190,19 @@ fn make_sugg(\n     match (&key_pat.kind, &value_pat.kind) {\n         (hir::PatKind::Binding(_, _, key_param_ident, None), hir::PatKind::Binding(_, _, value_param_ident, None)) => {\n             Some(format!(\n-                \"{}.retain(|{}, &mut {}| {})\",\n+                \"{}.retain(|{key_param_ident}, &mut {value_param_ident}| {})\",\n                 snippet(cx, left_expr.span, \"..\"),\n-                key_param_ident,\n-                value_param_ident,\n                 snippet(cx, filter_body.value.span, \"..\")\n             ))\n         },\n         (hir::PatKind::Binding(_, _, key_param_ident, None), hir::PatKind::Wild) => Some(format!(\n-            \"{}.retain(|{}, _| {})\",\n+            \"{}.retain(|{key_param_ident}, _| {})\",\n             snippet(cx, left_expr.span, \"..\"),\n-            key_param_ident,\n             snippet(cx, filter_body.value.span, \"..\")\n         )),\n         (hir::PatKind::Wild, hir::PatKind::Binding(_, _, value_param_ident, None)) => Some(format!(\n-            \"{}.retain(|_, &mut {}| {})\",\n+            \"{}.retain(|_, &mut {value_param_ident}| {})\",\n             snippet(cx, left_expr.span, \"..\"),\n-            value_param_ident,\n             snippet(cx, filter_body.value.span, \"..\")\n         )),\n         _ => None,"}, {"sha": "0976940afac355fcc9f9b02f9796cf4262023018", "filename": "src/tools/clippy/clippy_lints/src/manual_strip.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_strip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_strip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_strip.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -108,15 +108,14 @@ impl<'tcx> LateLintPass<'tcx> for ManualStrip {\n                     };\n \n                     let test_span = expr.span.until(then.span);\n-                    span_lint_and_then(cx, MANUAL_STRIP, strippings[0], &format!(\"stripping a {} manually\", kind_word), |diag| {\n-                        diag.span_note(test_span, &format!(\"the {} was tested here\", kind_word));\n+                    span_lint_and_then(cx, MANUAL_STRIP, strippings[0], &format!(\"stripping a {kind_word} manually\"), |diag| {\n+                        diag.span_note(test_span, &format!(\"the {kind_word} was tested here\"));\n                         multispan_sugg(\n                             diag,\n-                            &format!(\"try using the `strip_{}` method\", kind_word),\n+                            &format!(\"try using the `strip_{kind_word}` method\"),\n                             vec![(test_span,\n-                                  format!(\"if let Some(<stripped>) = {}.strip_{}({}) \",\n+                                  format!(\"if let Some(<stripped>) = {}.strip_{kind_word}({}) \",\n                                           snippet(cx, target_arg.span, \"..\"),\n-                                          kind_word,\n                                           snippet(cx, pattern.span, \"..\")))]\n                             .into_iter().chain(strippings.into_iter().map(|span| (span, \"<stripped>\".into()))),\n                         );"}, {"sha": "32da37a862d8ca02f30001805b013a8fc2f89a0d", "filename": "src/tools/clippy/clippy_lints/src/map_unit_fn.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_unit_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_unit_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_unit_fn.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -131,12 +131,12 @@ fn reduce_unit_expression<'a>(cx: &LateContext<'_>, expr: &'a hir::Expr<'_>) ->\n         },\n         hir::ExprKind::Block(block, _) => {\n             match (block.stmts, block.expr.as_ref()) {\n-                (&[], Some(inner_expr)) => {\n+                ([], Some(inner_expr)) => {\n                     // If block only contains an expression,\n                     // reduce `{ X }` to `X`\n                     reduce_unit_expression(cx, inner_expr)\n                 },\n-                (&[ref inner_stmt], None) => {\n+                ([inner_stmt], None) => {\n                     // If block only contains statements,\n                     // reduce `{ X; }` to `X` or `X;`\n                     match inner_stmt.kind {\n@@ -194,10 +194,7 @@ fn let_binding_name(cx: &LateContext<'_>, var_arg: &hir::Expr<'_>) -> String {\n \n #[must_use]\n fn suggestion_msg(function_type: &str, map_type: &str) -> String {\n-    format!(\n-        \"called `map(f)` on an `{0}` value where `f` is a {1} that returns the unit type `()`\",\n-        map_type, function_type\n-    )\n+    format!(\"called `map(f)` on an `{map_type}` value where `f` is a {function_type} that returns the unit type `()`\")\n }\n \n fn lint_map_unit_fn("}, {"sha": "a020282d234f9bba5625d435b574314d4055e6ba", "filename": "src/tools/clippy/clippy_lints/src/match_result_ok.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_result_ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_result_ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_result_ok.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -70,17 +70,15 @@ impl<'tcx> LateLintPass<'tcx> for MatchResultOk {\n                 let some_expr_string = snippet_with_applicability(cx, y[0].span, \"\", &mut applicability);\n                 let trimmed_ok = snippet_with_applicability(cx, let_expr.span.until(ok_path.ident.span), \"\", &mut applicability);\n                 let sugg = format!(\n-                    \"{} let Ok({}) = {}\",\n-                    ifwhile,\n-                    some_expr_string,\n+                    \"{ifwhile} let Ok({some_expr_string}) = {}\",\n                     trimmed_ok.trim().trim_end_matches('.'),\n                 );\n                 span_lint_and_sugg(\n                     cx,\n                     MATCH_RESULT_OK,\n                     expr.span.with_hi(let_expr.span.hi()),\n                     \"matching on `Some` with `ok()` is redundant\",\n-                    &format!(\"consider matching on `Ok({})` and removing the call to `ok` instead\", some_expr_string),\n+                    &format!(\"consider matching on `Ok({some_expr_string})` and removing the call to `ok` instead\"),\n                     sugg,\n                     applicability,\n                 );"}, {"sha": "fd14d868df348e7e856c08e8b59bf2f4c9ee58d8", "filename": "src/tools/clippy/clippy_lints/src/matches/collapsible_match.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fcollapsible_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fcollapsible_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fcollapsible_match.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -1,7 +1,9 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::higher::IfLetOrMatch;\n use clippy_utils::visitors::is_local_used;\n-use clippy_utils::{is_lang_ctor, is_unit_expr, path_to_local, peel_blocks_with_stmt, peel_ref_operators, SpanlessEq};\n+use clippy_utils::{\n+    is_res_lang_ctor, is_unit_expr, path_to_local, peel_blocks_with_stmt, peel_ref_operators, SpanlessEq,\n+};\n use if_chain::if_chain;\n use rustc_errors::MultiSpan;\n use rustc_hir::LangItem::OptionNone;\n@@ -110,7 +112,7 @@ fn arm_is_wild_like(cx: &LateContext<'_>, arm: &Arm<'_>) -> bool {\n     }\n     match arm.pat.kind {\n         PatKind::Binding(..) | PatKind::Wild => true,\n-        PatKind::Path(ref qpath) => is_lang_ctor(cx, qpath, OptionNone),\n+        PatKind::Path(ref qpath) => is_res_lang_ctor(cx, cx.qpath_res(qpath, arm.pat.hir_id), OptionNone),\n         _ => false,\n     }\n }"}, {"sha": "76f5e1c941c7a270e37f0647455c8db60550588c", "filename": "src/tools/clippy/clippy_lints/src/matches/manual_map.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmanual_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmanual_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmanual_map.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -3,8 +3,8 @@ use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n use clippy_utils::ty::{is_type_diagnostic_item, peel_mid_ty_refs_is_mutable, type_is_unsafe_function};\n use clippy_utils::{\n-    can_move_expr_to_closure, is_else_clause, is_lang_ctor, is_lint_allowed, path_to_local_id, peel_blocks,\n-    peel_hir_expr_refs, peel_hir_expr_while, CaptureKind,\n+    can_move_expr_to_closure, is_else_clause, is_lint_allowed, is_res_lang_ctor, path_res, path_to_local_id,\n+    peel_blocks, peel_hir_expr_refs, peel_hir_expr_while, CaptureKind,\n };\n use rustc_ast::util::parser::PREC_POSTFIX;\n use rustc_errors::Applicability;\n@@ -144,7 +144,7 @@ fn check<'tcx>(\n     let scrutinee = peel_hir_expr_refs(scrutinee).0;\n     let (scrutinee_str, _) = snippet_with_context(cx, scrutinee.span, expr_ctxt, \"..\", &mut app);\n     let scrutinee_str = if scrutinee.span.ctxt() == expr.span.ctxt() && scrutinee.precedence().order() < PREC_POSTFIX {\n-        format!(\"({})\", scrutinee_str)\n+        format!(\"({scrutinee_str})\")\n     } else {\n         scrutinee_str.into()\n     };\n@@ -172,9 +172,9 @@ fn check<'tcx>(\n                 };\n                 let expr_snip = snippet_with_context(cx, some_expr.expr.span, expr_ctxt, \"..\", &mut app).0;\n                 if some_expr.needs_unsafe_block {\n-                    format!(\"|{}{}| unsafe {{ {} }}\", annotation, some_binding, expr_snip)\n+                    format!(\"|{annotation}{some_binding}| unsafe {{ {expr_snip} }}\")\n                 } else {\n-                    format!(\"|{}{}| {}\", annotation, some_binding, expr_snip)\n+                    format!(\"|{annotation}{some_binding}| {expr_snip}\")\n                 }\n             }\n         }\n@@ -183,9 +183,9 @@ fn check<'tcx>(\n         let pat_snip = snippet_with_context(cx, some_pat.span, expr_ctxt, \"..\", &mut app).0;\n         let expr_snip = snippet_with_context(cx, some_expr.expr.span, expr_ctxt, \"..\", &mut app).0;\n         if some_expr.needs_unsafe_block {\n-            format!(\"|{}| unsafe {{ {} }}\", pat_snip, expr_snip)\n+            format!(\"|{pat_snip}| unsafe {{ {expr_snip} }}\")\n         } else {\n-            format!(\"|{}| {}\", pat_snip, expr_snip)\n+            format!(\"|{pat_snip}| {expr_snip}\")\n         }\n     } else {\n         // Refutable bindings and mixed reference annotations can't be handled by `map`.\n@@ -199,9 +199,9 @@ fn check<'tcx>(\n         \"manual implementation of `Option::map`\",\n         \"try this\",\n         if else_pat.is_none() && is_else_clause(cx.tcx, expr) {\n-            format!(\"{{ {}{}.map({}) }}\", scrutinee_str, as_ref_str, body_str)\n+            format!(\"{{ {scrutinee_str}{as_ref_str}.map({body_str}) }}\")\n         } else {\n-            format!(\"{}{}.map({})\", scrutinee_str, as_ref_str, body_str)\n+            format!(\"{scrutinee_str}{as_ref_str}.map({body_str})\")\n         },\n         app,\n     );\n@@ -251,9 +251,11 @@ fn try_parse_pattern<'tcx>(cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>, ctxt: Syn\n         match pat.kind {\n             PatKind::Wild => Some(OptionPat::Wild),\n             PatKind::Ref(pat, _) => f(cx, pat, ref_count + 1, ctxt),\n-            PatKind::Path(ref qpath) if is_lang_ctor(cx, qpath, OptionNone) => Some(OptionPat::None),\n+            PatKind::Path(ref qpath) if is_res_lang_ctor(cx, cx.qpath_res(qpath, pat.hir_id), OptionNone) => {\n+                Some(OptionPat::None)\n+            },\n             PatKind::TupleStruct(ref qpath, [pattern], _)\n-                if is_lang_ctor(cx, qpath, OptionSome) && pat.span.ctxt() == ctxt =>\n+                if is_res_lang_ctor(cx, cx.qpath_res(qpath, pat.hir_id), OptionSome) && pat.span.ctxt() == ctxt =>\n             {\n                 Some(OptionPat::Some { pattern, ref_count })\n             },\n@@ -272,16 +274,14 @@ fn get_some_expr<'tcx>(\n ) -> Option<SomeExpr<'tcx>> {\n     // TODO: Allow more complex expressions.\n     match expr.kind {\n-        ExprKind::Call(\n-            Expr {\n-                kind: ExprKind::Path(ref qpath),\n-                ..\n-            },\n-            [arg],\n-        ) if ctxt == expr.span.ctxt() && is_lang_ctor(cx, qpath, OptionSome) => Some(SomeExpr {\n-            expr: arg,\n-            needs_unsafe_block,\n-        }),\n+        ExprKind::Call(callee, [arg])\n+            if ctxt == expr.span.ctxt() && is_res_lang_ctor(cx, path_res(cx, callee), OptionSome) =>\n+        {\n+            Some(SomeExpr {\n+                expr: arg,\n+                needs_unsafe_block,\n+            })\n+        },\n         ExprKind::Block(\n             Block {\n                 stmts: [],\n@@ -302,5 +302,5 @@ fn get_some_expr<'tcx>(\n \n // Checks for the `None` value.\n fn is_none_expr(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    matches!(peel_blocks(expr).kind, ExprKind::Path(ref qpath) if is_lang_ctor(cx, qpath, OptionNone))\n+    is_res_lang_ctor(cx, path_res(cx, peel_blocks(expr)), OptionNone)\n }"}, {"sha": "587c926dc01c3f02d790653c72dcbc3d8eded3e8", "filename": "src/tools/clippy/clippy_lints/src/matches/manual_unwrap_or.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmanual_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmanual_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmanual_unwrap_or.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -3,12 +3,14 @@ use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::{indent_of, reindent_multiline, snippet_opt};\n use clippy_utils::ty::is_type_diagnostic_item;\n use clippy_utils::usage::contains_return_break_continue_macro;\n-use clippy_utils::{is_lang_ctor, path_to_local_id, sugg};\n+use clippy_utils::{is_res_lang_ctor, path_to_local_id, sugg};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::LangItem::{OptionNone, OptionSome, ResultErr, ResultOk};\n+use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::LangItem::{OptionNone, ResultErr};\n use rustc_hir::{Arm, Expr, PatKind};\n use rustc_lint::LateContext;\n+use rustc_middle::ty::DefIdTree;\n use rustc_span::sym;\n \n use super::MANUAL_UNWRAP_OR;\n@@ -42,12 +44,10 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>, scrutinee:\n             span_lint_and_sugg(\n                 cx,\n                 MANUAL_UNWRAP_OR, expr.span,\n-                &format!(\"this pattern reimplements `{}::unwrap_or`\", ty_name),\n+                &format!(\"this pattern reimplements `{ty_name}::unwrap_or`\"),\n                 \"replace with\",\n                 format!(\n-                    \"{}.unwrap_or({})\",\n-                    suggestion,\n-                    reindented_or_body,\n+                    \"{suggestion}.unwrap_or({reindented_or_body})\",\n                 ),\n                 Applicability::MachineApplicable,\n             );\n@@ -61,15 +61,19 @@ fn applicable_or_arm<'a>(cx: &LateContext<'_>, arms: &'a [Arm<'a>]) -> Option<&'\n         if arms.iter().all(|arm| arm.guard.is_none());\n         if let Some((idx, or_arm)) = arms.iter().enumerate().find(|(_, arm)| {\n             match arm.pat.kind {\n-                PatKind::Path(ref qpath) => is_lang_ctor(cx, qpath, OptionNone),\n+                PatKind::Path(ref qpath) => is_res_lang_ctor(cx, cx.qpath_res(qpath, arm.pat.hir_id), OptionNone),\n                 PatKind::TupleStruct(ref qpath, [pat], _) =>\n-                    matches!(pat.kind, PatKind::Wild) && is_lang_ctor(cx, qpath, ResultErr),\n+                    matches!(pat.kind, PatKind::Wild)\n+                        && is_res_lang_ctor(cx, cx.qpath_res(qpath, arm.pat.hir_id), ResultErr),\n                 _ => false,\n             }\n         });\n         let unwrap_arm = &arms[1 - idx];\n         if let PatKind::TupleStruct(ref qpath, [unwrap_pat], _) = unwrap_arm.pat.kind;\n-        if is_lang_ctor(cx, qpath, OptionSome) || is_lang_ctor(cx, qpath, ResultOk);\n+        if let Res::Def(DefKind::Ctor(..), ctor_id) = cx.qpath_res(qpath, unwrap_arm.pat.hir_id);\n+        if let Some(variant_id) = cx.tcx.opt_parent(ctor_id);\n+        if cx.tcx.lang_items().option_some_variant() == Some(variant_id)\n+            || cx.tcx.lang_items().result_ok_variant() == Some(variant_id);\n         if let PatKind::Binding(_, binding_hir_id, ..) = unwrap_pat.kind;\n         if path_to_local_id(unwrap_arm.body, binding_hir_id);\n         if cx.typeck_results().expr_adjustments(unwrap_arm.body).is_empty();"}, {"sha": "2818f030b7a6388fc85b4ca52fe99da681b75aca", "filename": "src/tools/clippy/clippy_lints/src/matches/match_as_ref.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_as_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_as_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_as_ref.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::{is_lang_ctor, peel_blocks};\n+use clippy_utils::{is_res_lang_ctor, path_res, peel_blocks};\n use rustc_errors::Applicability;\n use rustc_hir::{Arm, BindingAnnotation, ByRef, Expr, ExprKind, LangItem, Mutability, PatKind, QPath};\n use rustc_lint::LateContext;\n@@ -45,13 +45,11 @@ pub(crate) fn check(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr:\n                 cx,\n                 MATCH_AS_REF,\n                 expr.span,\n-                &format!(\"use `{}()` instead\", suggestion),\n+                &format!(\"use `{suggestion}()` instead\"),\n                 \"try this\",\n                 format!(\n-                    \"{}.{}(){}\",\n+                    \"{}.{suggestion}(){cast}\",\n                     snippet_with_applicability(cx, ex.span, \"_\", &mut applicability),\n-                    suggestion,\n-                    cast,\n                 ),\n                 applicability,\n             );\n@@ -61,18 +59,20 @@ pub(crate) fn check(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr:\n \n // Checks if arm has the form `None => None`\n fn is_none_arm(cx: &LateContext<'_>, arm: &Arm<'_>) -> bool {\n-    matches!(arm.pat.kind, PatKind::Path(ref qpath) if is_lang_ctor(cx, qpath, LangItem::OptionNone))\n+    matches!(\n+        arm.pat.kind,\n+        PatKind::Path(ref qpath) if is_res_lang_ctor(cx, cx.qpath_res(qpath, arm.pat.hir_id), LangItem::OptionNone)\n+    )\n }\n \n // Checks if arm has the form `Some(ref v) => Some(v)` (checks for `ref` and `ref mut`)\n fn is_ref_some_arm(cx: &LateContext<'_>, arm: &Arm<'_>) -> Option<Mutability> {\n     if_chain! {\n         if let PatKind::TupleStruct(ref qpath, [first_pat, ..], _) = arm.pat.kind;\n-        if is_lang_ctor(cx, qpath, LangItem::OptionSome);\n+        if is_res_lang_ctor(cx, cx.qpath_res(qpath, arm.pat.hir_id), LangItem::OptionSome);\n         if let PatKind::Binding(BindingAnnotation(ByRef::Yes, mutabl), .., ident, _) = first_pat.kind;\n         if let ExprKind::Call(e, [arg]) = peel_blocks(arm.body).kind;\n-        if let ExprKind::Path(ref some_path) = e.kind;\n-        if is_lang_ctor(cx, some_path, LangItem::OptionSome);\n+        if is_res_lang_ctor(cx, path_res(cx, e), LangItem::OptionSome);\n         if let ExprKind::Path(QPath::Resolved(_, path2)) = arg.kind;\n         if path2.segments.len() == 1 && ident.name == path2.segments[0].ident.name;\n         then {"}, {"sha": "107fad32393cff30de3f84055901358f70685798", "filename": "src/tools/clippy/clippy_lints/src/matches/match_like_matches.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_like_matches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_like_matches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_like_matches.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -112,7 +112,7 @@ where\n                     .join(\" | \")\n             };\n             let pat_and_guard = if let Some(Guard::If(g)) = first_guard {\n-                format!(\"{} if {}\", pat, snippet_with_applicability(cx, g.span, \"..\", &mut applicability))\n+                format!(\"{pat} if {}\", snippet_with_applicability(cx, g.span, \"..\", &mut applicability))\n             } else {\n                 pat\n             };\n@@ -131,10 +131,9 @@ where\n                 &format!(\"{} expression looks like `matches!` macro\", if is_if_let { \"if let .. else\" } else { \"match\" }),\n                 \"try this\",\n                 format!(\n-                    \"{}matches!({}, {})\",\n+                    \"{}matches!({}, {pat_and_guard})\",\n                     if b0 { \"\" } else { \"!\" },\n                     snippet_with_applicability(cx, ex_new.span, \"..\", &mut applicability),\n-                    pat_and_guard,\n                 ),\n                 applicability,\n             );"}, {"sha": "37049f83577513605c6ea63000e4662101898138", "filename": "src/tools/clippy/clippy_lints/src/matches/match_same_arms.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -134,7 +134,7 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>]) {\n                     diag.span_suggestion(\n                         keep_arm.pat.span,\n                         \"try merging the arm patterns\",\n-                        format!(\"{} | {}\", keep_pat_snip, move_pat_snip),\n+                        format!(\"{keep_pat_snip} | {move_pat_snip}\"),\n                         Applicability::MaybeIncorrect,\n                     )\n                     .help(\"or try changing either arm body\")"}, {"sha": "68682cedf1de434bcce702c5c5abb13e4f97a53f", "filename": "src/tools/clippy/clippy_lints/src/matches/match_single_binding.rs", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_single_binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_single_binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_single_binding.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -75,12 +75,11 @@ pub(crate) fn check<'a>(cx: &LateContext<'a>, ex: &Expr<'a>, arms: &[Arm<'_>], e\n                 Some(AssignmentExpr::Local { span, pat_span }) => (\n                     span,\n                     format!(\n-                        \"let {} = {};\\n{}let {} = {};\",\n+                        \"let {} = {};\\n{}let {} = {snippet_body};\",\n                         snippet_with_applicability(cx, bind_names, \"..\", &mut applicability),\n                         snippet_with_applicability(cx, matched_vars, \"..\", &mut applicability),\n                         \" \".repeat(indent_of(cx, expr.span).unwrap_or(0)),\n-                        snippet_with_applicability(cx, pat_span, \"..\", &mut applicability),\n-                        snippet_body\n+                        snippet_with_applicability(cx, pat_span, \"..\", &mut applicability)\n                     ),\n                 ),\n                 None => {\n@@ -110,10 +109,8 @@ pub(crate) fn check<'a>(cx: &LateContext<'a>, ex: &Expr<'a>, arms: &[Arm<'_>], e\n             if ex.can_have_side_effects() {\n                 let indent = \" \".repeat(indent_of(cx, expr.span).unwrap_or(0));\n                 let sugg = format!(\n-                    \"{};\\n{}{}\",\n-                    snippet_with_applicability(cx, ex.span, \"..\", &mut applicability),\n-                    indent,\n-                    snippet_body\n+                    \"{};\\n{indent}{snippet_body}\",\n+                    snippet_with_applicability(cx, ex.span, \"..\", &mut applicability)\n                 );\n \n                 span_lint_and_sugg(\n@@ -178,10 +175,10 @@ fn sugg_with_curlies<'a>(\n     let (mut cbrace_start, mut cbrace_end) = (String::new(), String::new());\n     if let Some(parent_expr) = get_parent_expr(cx, match_expr) {\n         if let ExprKind::Closure { .. } = parent_expr.kind {\n-            cbrace_end = format!(\"\\n{}}}\", indent);\n+            cbrace_end = format!(\"\\n{indent}}}\");\n             // Fix body indent due to the closure\n             indent = \" \".repeat(indent_of(cx, bind_names).unwrap_or(0));\n-            cbrace_start = format!(\"{{\\n{}\", indent);\n+            cbrace_start = format!(\"{{\\n{indent}\");\n         }\n     }\n \n@@ -190,10 +187,10 @@ fn sugg_with_curlies<'a>(\n     let parent_node_id = cx.tcx.hir().get_parent_node(match_expr.hir_id);\n     if let Node::Arm(arm) = &cx.tcx.hir().get(parent_node_id) {\n         if let ExprKind::Match(..) = arm.body.kind {\n-            cbrace_end = format!(\"\\n{}}}\", indent);\n+            cbrace_end = format!(\"\\n{indent}}}\");\n             // Fix body indent due to the match\n             indent = \" \".repeat(indent_of(cx, bind_names).unwrap_or(0));\n-            cbrace_start = format!(\"{{\\n{}\", indent);\n+            cbrace_start = format!(\"{{\\n{indent}\");\n         }\n     }\n \n@@ -204,13 +201,8 @@ fn sugg_with_curlies<'a>(\n     });\n \n     format!(\n-        \"{}let {} = {};\\n{}{}{}{}\",\n-        cbrace_start,\n+        \"{cbrace_start}let {} = {};\\n{indent}{assignment_str}{snippet_body}{cbrace_end}\",\n         snippet_with_applicability(cx, bind_names, \"..\", applicability),\n-        snippet_with_applicability(cx, matched_vars, \"..\", applicability),\n-        indent,\n-        assignment_str,\n-        snippet_body,\n-        cbrace_end\n+        snippet_with_applicability(cx, matched_vars, \"..\", applicability)\n     )\n }"}, {"sha": "6647322caa37a846520edfc81251261d9e312c6c", "filename": "src/tools/clippy/clippy_lints/src/matches/match_str_case_mismatch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_str_case_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_str_case_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_str_case_mismatch.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -118,8 +118,8 @@ fn lint(cx: &LateContext<'_>, case_method: &CaseMethod, bad_case_span: Span, bad\n         MATCH_STR_CASE_MISMATCH,\n         bad_case_span,\n         \"this `match` arm has a differing case than its expression\",\n-        &format!(\"consider changing the case of this arm to respect `{}`\", method_str),\n-        format!(\"\\\"{}\\\"\", suggestion),\n+        &format!(\"consider changing the case of this arm to respect `{method_str}`\"),\n+        format!(\"\\\"{suggestion}\\\"\"),\n         Applicability::MachineApplicable,\n     );\n }"}, {"sha": "42f1e2629d41a79ee766973a2e32635afffc6942", "filename": "src/tools/clippy/clippy_lints/src/matches/match_wild_err_arm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_wild_err_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_wild_err_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_wild_err_arm.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -38,7 +38,7 @@ pub(crate) fn check<'tcx>(cx: &LateContext<'tcx>, ex: &Expr<'tcx>, arms: &[Arm<'\n                             span_lint_and_note(cx,\n                                 MATCH_WILD_ERR_ARM,\n                                 arm.pat.span,\n-                                &format!(\"`Err({})` matches all errors\", ident_bind_name),\n+                                &format!(\"`Err({ident_bind_name})` matches all errors\"),\n                                 None,\n                                 \"match each error separately or use the error output, or use `.expect(msg)` if the error case is unreachable\",\n                             );"}, {"sha": "c4f6852aedc3d541785111161099fba809ff86b4", "filename": "src/tools/clippy/clippy_lints/src/matches/needless_match.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fneedless_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fneedless_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fneedless_match.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -3,15 +3,15 @@ use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::{is_type_diagnostic_item, same_type_and_consts};\n use clippy_utils::{\n-    eq_expr_value, get_parent_expr_for_hir, get_parent_node, higher, is_else_clause, is_lang_ctor, over,\n+    eq_expr_value, get_parent_expr_for_hir, get_parent_node, higher, is_else_clause, is_res_lang_ctor, over, path_res,\n     peel_blocks_with_stmt,\n };\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::OptionNone;\n use rustc_hir::{Arm, BindingAnnotation, ByRef, Expr, ExprKind, FnRetTy, Guard, Node, Pat, PatKind, Path, QPath};\n+use rustc_hir_analysis::hir_ty_to_ty;\n use rustc_lint::LateContext;\n use rustc_span::sym;\n-use rustc_hir_analysis::hir_ty_to_ty;\n \n pub(crate) fn check_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n     if arms.len() > 1 && expr_ty_matches_p_ty(cx, ex, expr) && check_all_arms(cx, ex, arms) {\n@@ -112,10 +112,7 @@ fn check_if_let_inner(cx: &LateContext<'_>, if_let: &higher::IfLet<'_>) -> bool\n             let ret = strip_return(else_expr);\n             let let_expr_ty = cx.typeck_results().expr_ty(if_let.let_expr);\n             if is_type_diagnostic_item(cx, let_expr_ty, sym::Option) {\n-                if let ExprKind::Path(ref qpath) = ret.kind {\n-                    return is_lang_ctor(cx, qpath, OptionNone) || eq_expr_value(cx, if_let.let_expr, ret);\n-                }\n-                return false;\n+                return is_res_lang_ctor(cx, path_res(cx, ret), OptionNone) || eq_expr_value(cx, if_let.let_expr, ret);\n             }\n             return eq_expr_value(cx, if_let.let_expr, ret);\n         }"}, {"sha": "81bebff34c82c78644adfbf5ba37d34f46f7ba54", "filename": "src/tools/clippy/clippy_lints/src/matches/redundant_pattern_match.rs", "status": "modified", "additions": 34, "deletions": 31, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -4,11 +4,12 @@ use clippy_utils::source::snippet;\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::{is_type_diagnostic_item, needs_ordered_drop};\n use clippy_utils::visitors::any_temporaries_need_ordered_drop;\n-use clippy_utils::{higher, is_lang_ctor, is_trait_method};\n+use clippy_utils::{higher, is_trait_method};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n-use rustc_hir::LangItem::{self, OptionSome, OptionNone, PollPending, PollReady, ResultOk, ResultErr};\n+use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::LangItem::{self, OptionNone, OptionSome, PollPending, PollReady, ResultErr, ResultOk};\n use rustc_hir::{Arm, Expr, ExprKind, Node, Pat, PatKind, QPath, UnOp};\n use rustc_lint::LateContext;\n use rustc_middle::ty::{self, subst::GenericArgKind, DefIdTree, Ty};\n@@ -87,15 +88,21 @@ fn find_sugg_for_if_let<'tcx>(\n             }\n         },\n         PatKind::Path(ref path) => {\n-            let method = if is_lang_ctor(cx, path, OptionNone) {\n-                \"is_none()\"\n-            } else if is_lang_ctor(cx, path, PollPending) {\n-                \"is_pending()\"\n+            if let Res::Def(DefKind::Ctor(..), ctor_id) = cx.qpath_res(path, check_pat.hir_id)\n+                && let Some(variant_id) = cx.tcx.opt_parent(ctor_id)\n+            {\n+                let method = if cx.tcx.lang_items().option_none_variant() == Some(variant_id) {\n+                    \"is_none()\"\n+                } else if cx.tcx.lang_items().poll_pending_variant() == Some(variant_id) {\n+                    \"is_pending()\"\n+                } else {\n+                    return;\n+                };\n+                // `None` and `Pending` don't have an inner type.\n+                (method, cx.tcx.types.unit)\n             } else {\n                 return;\n-            };\n-            // `None` and `Pending` don't have an inner type.\n-            (method, cx.tcx.types.unit)\n+            }\n         },\n         _ => return,\n     };\n@@ -138,7 +145,7 @@ fn find_sugg_for_if_let<'tcx>(\n         cx,\n         REDUNDANT_PATTERN_MATCHING,\n         let_pat.span,\n-        &format!(\"redundant pattern matching, consider using `{}`\", good_method),\n+        &format!(\"redundant pattern matching, consider using `{good_method}`\"),\n         |diag| {\n             // if/while let ... = ... { ... }\n             // ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -162,7 +169,7 @@ fn find_sugg_for_if_let<'tcx>(\n                 .maybe_par()\n                 .to_string();\n \n-            diag.span_suggestion(span, \"try this\", format!(\"{} {}.{}\", keyword, sugg, good_method), app);\n+            diag.span_suggestion(span, \"try this\", format!(\"{keyword} {sugg}.{good_method}\"), app);\n \n             if needs_drop {\n                 diag.note(\"this will change drop order of the result, as well as all temporaries\");\n@@ -213,7 +220,6 @@ pub(super) fn check_match<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, op\n                 if patterns.len() == 1 =>\n             {\n                 if let PatKind::Wild = patterns[0].kind {\n-\n                     find_good_method_for_match(\n                         cx,\n                         arms,\n@@ -253,12 +259,12 @@ pub(super) fn check_match<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, op\n                 cx,\n                 REDUNDANT_PATTERN_MATCHING,\n                 expr.span,\n-                &format!(\"redundant pattern matching, consider using `{}`\", good_method),\n+                &format!(\"redundant pattern matching, consider using `{good_method}`\"),\n                 |diag| {\n                     diag.span_suggestion(\n                         span,\n                         \"try this\",\n-                        format!(\"{}.{}\", snippet(cx, result_expr.span, \"_\"), good_method),\n+                        format!(\"{}.{good_method}\", snippet(cx, result_expr.span, \"_\")),\n                         Applicability::MaybeIncorrect, // snippet\n                     );\n                 },\n@@ -269,8 +275,8 @@ pub(super) fn check_match<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, op\n \n #[derive(Clone, Copy)]\n enum Item {\n-  Lang(LangItem),\n-  Diag(Symbol, Symbol),\n+    Lang(LangItem),\n+    Diag(Symbol, Symbol),\n }\n \n fn is_pat_variant(cx: &LateContext<'_>, pat: &Pat<'_>, path: &QPath<'_>, expected_item: Item) -> bool {\n@@ -285,15 +291,16 @@ fn is_pat_variant(cx: &LateContext<'_>, pat: &Pat<'_>, path: &QPath<'_>, expecte\n             let ty = cx.typeck_results().pat_ty(pat);\n \n             if is_type_diagnostic_item(cx, ty, expected_ty) {\n-                let variant = ty.ty_adt_def()\n+                let variant = ty\n+                    .ty_adt_def()\n                     .expect(\"struct pattern type is not an ADT\")\n                     .variant_of_res(cx.qpath_res(path, pat.hir_id));\n \n-                return variant.name == expected_variant\n+                return variant.name == expected_variant;\n             }\n \n             false\n-        }\n+        },\n     }\n }\n \n@@ -308,20 +315,16 @@ fn find_good_method_for_match<'a>(\n     should_be_left: &'a str,\n     should_be_right: &'a str,\n ) -> Option<&'a str> {\n-    let pat_left = arms[0].pat;\n-    let pat_right = arms[1].pat;\n+    let first_pat = arms[0].pat;\n+    let second_pat = arms[1].pat;\n \n-    let body_node_pair = if (\n-        is_pat_variant(cx, pat_left, path_left, expected_item_left)\n-    ) && (\n-        is_pat_variant(cx, pat_right, path_right, expected_item_right)\n-    ) {\n+    let body_node_pair = if (is_pat_variant(cx, first_pat, path_left, expected_item_left))\n+        && (is_pat_variant(cx, second_pat, path_right, expected_item_right))\n+    {\n         (&arms[0].body.kind, &arms[1].body.kind)\n-    } else if (\n-        is_pat_variant(cx, pat_left, path_left, expected_item_right)\n-    ) && (\n-        is_pat_variant(cx, pat_right, path_right, expected_item_left)\n-    ) {\n+    } else if (is_pat_variant(cx, first_pat, path_left, expected_item_right))\n+        && (is_pat_variant(cx, second_pat, path_right, expected_item_left))\n+    {\n         (&arms[1].body.kind, &arms[0].body.kind)\n     } else {\n         return None;"}, {"sha": "85269e533a066861ad3454d82d0a67185ee3277c", "filename": "src/tools/clippy/clippy_lints/src/matches/significant_drop_in_scrutinee.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fsignificant_drop_in_scrutinee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fsignificant_drop_in_scrutinee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fsignificant_drop_in_scrutinee.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -50,13 +50,13 @@ fn set_diagnostic<'tcx>(diag: &mut Diagnostic, cx: &LateContext<'tcx>, expr: &'t\n     let trailing_indent = \" \".repeat(indent_of(cx, found.found_span).unwrap_or(0));\n \n     let replacement = if found.lint_suggestion == LintSuggestion::MoveAndDerefToCopy {\n-        format!(\"let value = *{};\\n{}\", original, trailing_indent)\n+        format!(\"let value = *{original};\\n{trailing_indent}\")\n     } else if found.is_unit_return_val {\n         // If the return value of the expression to be moved is unit, then we don't need to\n         // capture the result in a temporary -- we can just replace it completely with `()`.\n-        format!(\"{};\\n{}\", original, trailing_indent)\n+        format!(\"{original};\\n{trailing_indent}\")\n     } else {\n-        format!(\"let value = {};\\n{}\", original, trailing_indent)\n+        format!(\"let value = {original};\\n{trailing_indent}\")\n     };\n \n     let suggestion_message = if found.lint_suggestion == LintSuggestion::MoveOnly {"}, {"sha": "d496107ffd6b85a76a903cf912663ca1fd62369b", "filename": "src/tools/clippy/clippy_lints/src/matches/single_match.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fsingle_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fsingle_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fsingle_match.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -99,23 +99,21 @@ fn report_single_pattern(\n \n             let msg = \"you seem to be trying to use `match` for an equality check. Consider using `if`\";\n             let sugg = format!(\n-                \"if {} == {}{} {}{}\",\n+                \"if {} == {}{} {}{els_str}\",\n                 snippet(cx, ex.span, \"..\"),\n                 // PartialEq for different reference counts may not exist.\n                 \"&\".repeat(ref_count_diff),\n                 snippet(cx, arms[0].pat.span, \"..\"),\n                 expr_block(cx, arms[0].body, None, \"..\", Some(expr.span)),\n-                els_str,\n             );\n             (msg, sugg)\n         } else {\n             let msg = \"you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\";\n             let sugg = format!(\n-                \"if let {} = {} {}{}\",\n+                \"if let {} = {} {}{els_str}\",\n                 snippet(cx, arms[0].pat.span, \"..\"),\n                 snippet(cx, ex.span, \"..\"),\n                 expr_block(cx, arms[0].body, None, \"..\", Some(expr.span)),\n-                els_str,\n             );\n             (msg, sugg)\n         }"}, {"sha": "c6cba81d8718972e89d436f83a3b4ef2facd37e2", "filename": "src/tools/clippy/clippy_lints/src/matches/try_err.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Ftry_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Ftry_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Ftry_err.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{get_parent_expr, is_lang_ctor, match_def_path, paths};\n+use clippy_utils::{get_parent_expr, is_res_lang_ctor, match_def_path, path_res, paths};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::ResultErr;\n@@ -27,8 +27,7 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, scrutine\n         if let ExprKind::Path(ref match_fun_path) = match_fun.kind;\n         if matches!(match_fun_path, QPath::LangItem(LangItem::TryTraitBranch, ..));\n         if let ExprKind::Call(err_fun, [err_arg, ..]) = try_arg.kind;\n-        if let ExprKind::Path(ref err_fun_path) = err_fun.kind;\n-        if is_lang_ctor(cx, err_fun_path, ResultErr);\n+        if is_res_lang_ctor(cx, path_res(cx, err_fun), ResultErr);\n         if let Some(return_ty) = find_return_type(cx, &expr.kind);\n         then {\n             let prefix;\n@@ -61,9 +60,9 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, scrutine\n                 \"return \"\n             };\n             let suggestion = if err_ty == expr_err_ty {\n-                format!(\"{}{}{}{}\", ret_prefix, prefix, origin_snippet, suffix)\n+                format!(\"{ret_prefix}{prefix}{origin_snippet}{suffix}\")\n             } else {\n-                format!(\"{}{}{}.into(){}\", ret_prefix, prefix, origin_snippet, suffix)\n+                format!(\"{ret_prefix}{prefix}{origin_snippet}.into(){suffix}\")\n             };\n \n             span_lint_and_sugg("}, {"sha": "0c4d9f100f7a966f7c3bade76f7e3843b3518f70", "filename": "src/tools/clippy/clippy_lints/src/mem_replace.rs", "status": "modified", "additions": 34, "deletions": 38, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_replace.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::source::{snippet, snippet_with_applicability};\n use clippy_utils::ty::is_non_aggregate_primitive_type;\n-use clippy_utils::{is_default_equivalent, is_lang_ctor, meets_msrv, msrvs};\n+use clippy_utils::{is_default_equivalent, is_res_lang_ctor, meets_msrv, msrvs, path_res};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::OptionNone;\n@@ -102,40 +102,38 @@ impl_lint_pass!(MemReplace =>\n     [MEM_REPLACE_OPTION_WITH_NONE, MEM_REPLACE_WITH_UNINIT, MEM_REPLACE_WITH_DEFAULT]);\n \n fn check_replace_option_with_none(cx: &LateContext<'_>, src: &Expr<'_>, dest: &Expr<'_>, expr_span: Span) {\n-    if let ExprKind::Path(ref replacement_qpath) = src.kind {\n-        // Check that second argument is `Option::None`\n-        if is_lang_ctor(cx, replacement_qpath, OptionNone) {\n-            // Since this is a late pass (already type-checked),\n-            // and we already know that the second argument is an\n-            // `Option`, we do not need to check the first\n-            // argument's type. All that's left is to get\n-            // replacee's path.\n-            let replaced_path = match dest.kind {\n-                ExprKind::AddrOf(BorrowKind::Ref, Mutability::Mut, replaced) => {\n-                    if let ExprKind::Path(QPath::Resolved(None, replaced_path)) = replaced.kind {\n-                        replaced_path\n-                    } else {\n-                        return;\n-                    }\n-                },\n-                ExprKind::Path(QPath::Resolved(None, replaced_path)) => replaced_path,\n-                _ => return,\n-            };\n+    // Check that second argument is `Option::None`\n+    if is_res_lang_ctor(cx, path_res(cx, src), OptionNone) {\n+        // Since this is a late pass (already type-checked),\n+        // and we already know that the second argument is an\n+        // `Option`, we do not need to check the first\n+        // argument's type. All that's left is to get\n+        // replacee's path.\n+        let replaced_path = match dest.kind {\n+            ExprKind::AddrOf(BorrowKind::Ref, Mutability::Mut, replaced) => {\n+                if let ExprKind::Path(QPath::Resolved(None, replaced_path)) = replaced.kind {\n+                    replaced_path\n+                } else {\n+                    return;\n+                }\n+            },\n+            ExprKind::Path(QPath::Resolved(None, replaced_path)) => replaced_path,\n+            _ => return,\n+        };\n \n-            let mut applicability = Applicability::MachineApplicable;\n-            span_lint_and_sugg(\n-                cx,\n-                MEM_REPLACE_OPTION_WITH_NONE,\n-                expr_span,\n-                \"replacing an `Option` with `None`\",\n-                \"consider `Option::take()` instead\",\n-                format!(\n-                    \"{}.take()\",\n-                    snippet_with_applicability(cx, replaced_path.span, \"\", &mut applicability)\n-                ),\n-                applicability,\n-            );\n-        }\n+        let mut applicability = Applicability::MachineApplicable;\n+        span_lint_and_sugg(\n+            cx,\n+            MEM_REPLACE_OPTION_WITH_NONE,\n+            expr_span,\n+            \"replacing an `Option` with `None`\",\n+            \"consider `Option::take()` instead\",\n+            format!(\n+                \"{}.take()\",\n+                snippet_with_applicability(cx, replaced_path.span, \"\", &mut applicability)\n+            ),\n+            applicability,\n+        );\n     }\n }\n \n@@ -203,10 +201,8 @@ fn check_replace_with_default(cx: &LateContext<'_>, src: &Expr<'_>, dest: &Expr<\n         return;\n     }\n     // disable lint for Option since it is covered in another lint\n-    if let ExprKind::Path(q) = &src.kind {\n-        if is_lang_ctor(cx, q, OptionNone) {\n-            return;\n-        }\n+    if is_res_lang_ctor(cx, path_res(cx, src), OptionNone) {\n+        return;\n     }\n     if is_default_equivalent(cx, src) && !in_external_macro(cx.tcx.sess, expr_span) {\n         span_lint_and_then("}, {"sha": "cc26b0f7fa82d38a5b2af682db29f3265a77d0c2", "filename": "src/tools/clippy/clippy_lints/src/methods/bind_instead_of_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -85,7 +85,7 @@ pub(crate) trait BindInsteadOfMap {\n \n                 let closure_args_snip = snippet(cx, closure_args_span, \"..\");\n                 let option_snip = snippet(cx, recv.span, \"..\");\n-                let note = format!(\"{}.{}({} {})\", option_snip, Self::GOOD_METHOD_NAME, closure_args_snip, some_inner_snip);\n+                let note = format!(\"{option_snip}.{}({closure_args_snip} {some_inner_snip})\", Self::GOOD_METHOD_NAME);\n                 span_lint_and_sugg(\n                     cx,\n                     BIND_INSTEAD_OF_MAP,"}, {"sha": "2e96346be977e839716708929bfeede60207d612", "filename": "src/tools/clippy/clippy_lints/src/methods/bytes_nth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fbytes_nth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fbytes_nth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fbytes_nth.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -22,7 +22,7 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>, recv: &'tcx E\n         cx,\n         BYTES_NTH,\n         expr.span,\n-        &format!(\"called `.bytes().nth()` on a `{}`\", caller_type),\n+        &format!(\"called `.bytes().nth()` on a `{caller_type}`\"),\n         \"try\",\n         format!(\n             \"{}.as_bytes().get({})\","}, {"sha": "56b7fbb9d4bc88243d597b975cbde2159885a8aa", "filename": "src/tools/clippy/clippy_lints/src/methods/chars_cmp.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fchars_cmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fchars_cmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fchars_cmp.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -33,12 +33,11 @@ pub(super) fn check(\n                 cx,\n                 lint,\n                 info.expr.span,\n-                &format!(\"you should use the `{}` method\", suggest),\n+                &format!(\"you should use the `{suggest}` method\"),\n                 \"like this\",\n-                format!(\"{}{}.{}({})\",\n+                format!(\"{}{}.{suggest}({})\",\n                         if info.eq { \"\" } else { \"!\" },\n                         snippet_with_applicability(cx, args[0].0.span, \"..\", &mut applicability),\n-                        suggest,\n                         snippet_with_applicability(cx, arg_char.span, \"..\", &mut applicability)),\n                 applicability,\n             );"}, {"sha": "7e808760663a1a4b370bd33daeebedca134fc1f9", "filename": "src/tools/clippy/clippy_lints/src/methods/chars_cmp_with_unwrap.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fchars_cmp_with_unwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fchars_cmp_with_unwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fchars_cmp_with_unwrap.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -26,12 +26,11 @@ pub(super) fn check<'tcx>(\n                 cx,\n                 lint,\n                 info.expr.span,\n-                &format!(\"you should use the `{}` method\", suggest),\n+                &format!(\"you should use the `{suggest}` method\"),\n                 \"like this\",\n-                format!(\"{}{}.{}('{}')\",\n+                format!(\"{}{}.{suggest}('{}')\",\n                         if info.eq { \"\" } else { \"!\" },\n                         snippet_with_applicability(cx, args[0].0.span, \"..\", &mut applicability),\n-                        suggest,\n                         c.escape_default()),\n                 applicability,\n             );"}, {"sha": "7c7938dd2e8b04f5e76fc1f10c4eb654bbcf2f93", "filename": "src/tools/clippy/clippy_lints/src/methods/clone_on_copy.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fclone_on_copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fclone_on_copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fclone_on_copy.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -49,8 +49,7 @@ pub(super) fn check(\n                 expr.span,\n                 &format!(\n                     \"using `clone` on a double-reference; \\\n-                    this will copy the reference of type `{}` instead of cloning the inner type\",\n-                    ty\n+                    this will copy the reference of type `{ty}` instead of cloning the inner type\"\n                 ),\n                 |diag| {\n                     if let Some(snip) = sugg::Sugg::hir_opt(cx, arg) {\n@@ -62,11 +61,11 @@ pub(super) fn check(\n                         }\n                         let refs = \"&\".repeat(n + 1);\n                         let derefs = \"*\".repeat(n);\n-                        let explicit = format!(\"<{}{}>::clone({})\", refs, ty, snip);\n+                        let explicit = format!(\"<{refs}{ty}>::clone({snip})\");\n                         diag.span_suggestion(\n                             expr.span,\n                             \"try dereferencing it\",\n-                            format!(\"{}({}{}).clone()\", refs, derefs, snip.deref()),\n+                            format!(\"{refs}({derefs}{}).clone()\", snip.deref()),\n                             Applicability::MaybeIncorrect,\n                         );\n                         diag.span_suggestion(\n@@ -121,16 +120,16 @@ pub(super) fn check(\n         let (help, sugg) = if deref_count == 0 {\n             (\"try removing the `clone` call\", snip.into())\n         } else if parent_is_suffix_expr {\n-            (\"try dereferencing it\", format!(\"({}{})\", \"*\".repeat(deref_count), snip))\n+            (\"try dereferencing it\", format!(\"({}{snip})\", \"*\".repeat(deref_count)))\n         } else {\n-            (\"try dereferencing it\", format!(\"{}{}\", \"*\".repeat(deref_count), snip))\n+            (\"try dereferencing it\", format!(\"{}{snip}\", \"*\".repeat(deref_count)))\n         };\n \n         span_lint_and_sugg(\n             cx,\n             CLONE_ON_COPY,\n             expr.span,\n-            &format!(\"using `clone` on type `{}` which implements the `Copy` trait\", ty),\n+            &format!(\"using `clone` on type `{ty}` which implements the `Copy` trait\"),\n             help,\n             sugg,\n             app,"}, {"sha": "355f53532e2689beeda54d174fcaa50d82aab670", "filename": "src/tools/clippy/clippy_lints/src/methods/clone_on_ref_ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fclone_on_ref_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fclone_on_ref_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fclone_on_ref_ptr.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -41,7 +41,7 @@ pub(super) fn check(\n             expr.span,\n             \"using `.clone()` on a ref-counted pointer\",\n             \"try this\",\n-            format!(\"{}::<{}>::clone(&{})\", caller_type, subst.type_at(0), snippet),\n+            format!(\"{caller_type}::<{}>::clone(&{snippet})\", subst.type_at(0)),\n             Applicability::Unspecified, // Sometimes unnecessary ::<_> after Rc/Arc/Weak\n         );\n     }"}, {"sha": "d0cf411dfd34caca494b9675d518fe742a1c4653", "filename": "src/tools/clippy/clippy_lints/src/methods/expect_fun_call.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -143,9 +143,9 @@ pub(super) fn check<'tcx>(\n             cx,\n             EXPECT_FUN_CALL,\n             span_replace_word,\n-            &format!(\"use of `{}` followed by a function call\", name),\n+            &format!(\"use of `{name}` followed by a function call\"),\n             \"try this\",\n-            format!(\"unwrap_or_else({} panic!({}))\", closure_args, sugg),\n+            format!(\"unwrap_or_else({closure_args} panic!({sugg}))\"),\n             applicability,\n         );\n         return;\n@@ -160,12 +160,9 @@ pub(super) fn check<'tcx>(\n         cx,\n         EXPECT_FUN_CALL,\n         span_replace_word,\n-        &format!(\"use of `{}` followed by a function call\", name),\n+        &format!(\"use of `{name}` followed by a function call\"),\n         \"try this\",\n-        format!(\n-            \"unwrap_or_else({} {{ panic!(\\\"{{}}\\\", {}) }})\",\n-            closure_args, arg_root_snippet\n-        ),\n+        format!(\"unwrap_or_else({closure_args} {{ panic!(\\\"{{}}\\\", {arg_root_snippet}) }})\"),\n         applicability,\n     );\n }"}, {"sha": "3fef53739fbde876c7114f2967c7ffc7231b730b", "filename": "src/tools/clippy/clippy_lints/src/methods/filetype_is_file.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Ffiletype_is_file.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Ffiletype_is_file.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Ffiletype_is_file.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -1,17 +1,18 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n-use clippy_utils::ty::match_type;\n-use clippy_utils::{get_parent_expr, paths};\n+use clippy_utils::get_parent_expr;\n+use clippy_utils::ty::is_type_diagnostic_item;\n use if_chain::if_chain;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n use rustc_span::source_map::Span;\n+use rustc_span::sym;\n \n use super::FILETYPE_IS_FILE;\n \n pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr<'_>) {\n     let ty = cx.typeck_results().expr_ty(recv);\n \n-    if !match_type(cx, ty, &paths::FILE_TYPE) {\n+    if !is_type_diagnostic_item(cx, ty, sym::FileType) {\n         return;\n     }\n \n@@ -35,7 +36,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr\n             span = expr.span;\n         }\n     }\n-    let lint_msg = format!(\"`{}FileType::is_file()` only {} regular files\", lint_unary, verb);\n-    let help_msg = format!(\"use `{}FileType::is_dir()` instead\", help_unary);\n+    let lint_msg = format!(\"`{lint_unary}FileType::is_file()` only {verb} regular files\");\n+    let help_msg = format!(\"use `{help_unary}FileType::is_dir()` instead\");\n     span_lint_and_help(cx, FILETYPE_IS_FILE, span, &lint_msg, None, &help_msg);\n }"}, {"sha": "ddf8a1f09b87d4b21b21704bc4bd1209a10600ad", "filename": "src/tools/clippy/clippy_lints/src/methods/filter_map_next.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Ffilter_map_next.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Ffilter_map_next.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Ffilter_map_next.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -32,7 +32,7 @@ pub(super) fn check<'tcx>(\n                 expr.span,\n                 msg,\n                 \"try this\",\n-                format!(\"{}.find_map({})\", iter_snippet, filter_snippet),\n+                format!(\"{iter_snippet}.find_map({filter_snippet})\"),\n                 Applicability::MachineApplicable,\n             );\n         } else {"}, {"sha": "edcec0fc1015ea7c52cb358ac30c8dabb2fe67fa", "filename": "src/tools/clippy/clippy_lints/src/methods/filter_next.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Ffilter_next.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Ffilter_next.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Ffilter_next.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -32,7 +32,7 @@ pub(super) fn check<'tcx>(\n                 expr.span,\n                 msg,\n                 \"try this\",\n-                format!(\"{}.find({})\", iter_snippet, filter_snippet),\n+                format!(\"{iter_snippet}.find({filter_snippet})\"),\n                 Applicability::MachineApplicable,\n             );\n         } else {"}, {"sha": "66dfce3682b59b59d885427234be5741db401e99", "filename": "src/tools/clippy/clippy_lints/src/methods/from_iter_instead_of_collect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Ffrom_iter_instead_of_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Ffrom_iter_instead_of_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Ffrom_iter_instead_of_collect.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -23,7 +23,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Exp\n             // `expr` implements `FromIterator` trait\n             let iter_expr = sugg::Sugg::hir(cx, &args[0], \"..\").maybe_par();\n             let turbofish = extract_turbofish(cx, expr, ty);\n-            let sugg = format!(\"{}.collect::<{}>()\", iter_expr, turbofish);\n+            let sugg = format!(\"{iter_expr}.collect::<{turbofish}>()\");\n             span_lint_and_sugg(\n                 cx,\n                 FROM_ITER_INSTEAD_OF_COLLECT,\n@@ -63,7 +63,7 @@ fn extract_turbofish(cx: &LateContext<'_>, expr: &hir::Expr<'_>, ty: Ty<'_>) ->\n                             if e == type_specifier { None } else { Some((*e).to_string()) }\n                         }).collect::<Vec<_>>();\n                         // join and add the type specifier at the end (i.e.: `collections::BTreeSet<u32>`)\n-                        format!(\"{}{}\", without_ts.join(\"::\"), type_specifier)\n+                        format!(\"{}{type_specifier}\", without_ts.join(\"::\"))\n                     } else {\n                         // type is not explicitly specified so wildcards are needed\n                         // i.e.: 2 wildcards in `std::collections::BTreeMap<&i32, &char>`\n@@ -72,7 +72,7 @@ fn extract_turbofish(cx: &LateContext<'_>, expr: &hir::Expr<'_>, ty: Ty<'_>) ->\n                         let end = ty_str.find('>').unwrap_or(ty_str.len());\n                         let nb_wildcard = ty_str[start..end].split(',').count();\n                         let wildcards = format!(\"_{}\", \", _\".repeat(nb_wildcard - 1));\n-                        format!(\"{}<{}>\", elements.join(\"::\"), wildcards)\n+                        format!(\"{}<{wildcards}>\", elements.join(\"::\"))\n                     }\n                 }\n             }"}, {"sha": "cb17af608a3f06f74505ab5769a0108412470810", "filename": "src/tools/clippy/clippy_lints/src/methods/get_first.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fget_first.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fget_first.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fget_first.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -29,9 +29,9 @@ pub(super) fn check<'tcx>(\n                 cx,\n                 GET_FIRST,\n                 expr.span,\n-                &format!(\"accessing first element with `{0}.get(0)`\", slice_name),\n+                &format!(\"accessing first element with `{slice_name}.get(0)`\"),\n                 \"try\",\n-                format!(\"{}.first()\", slice_name),\n+                format!(\"{slice_name}.first()\"),\n                 app,\n             );\n         }"}, {"sha": "3bdc154df04958a67dd050f306ac1f22d01897bd", "filename": "src/tools/clippy/clippy_lints/src/methods/get_last_with_len.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fget_last_with_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fget_last_with_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fget_last_with_len.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -1,7 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::SpanlessEq;\n-use rustc_ast::LitKind;\n+use clippy_utils::{is_integer_literal, SpanlessEq};\n use rustc_errors::Applicability;\n use rustc_hir::{BinOpKind, Expr, ExprKind};\n use rustc_lint::LateContext;\n@@ -26,8 +25,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, arg:\n         && lhs_path.ident.name == sym::len\n \n         // RHS of subtraction is 1\n-        && let ExprKind::Lit(rhs_lit) = &rhs.kind\n-        && let LitKind::Int(1, ..) = rhs_lit.node\n+        && is_integer_literal(rhs, 1)\n \n         // check that recv == lhs_recv `recv.get(lhs_recv.len() - 1)`\n         && SpanlessEq::new(cx).eq_expr(recv, lhs_recv)"}, {"sha": "ffc3a4d780e5d324be025959b3a2d90dd0b6c6ab", "filename": "src/tools/clippy/clippy_lints/src/methods/get_unwrap.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fget_unwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fget_unwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fget_unwrap.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -71,16 +71,11 @@ pub(super) fn check<'tcx>(\n         cx,\n         GET_UNWRAP,\n         span,\n-        &format!(\n-            \"called `.get{0}().unwrap()` on a {1}. Using `[]` is more clear and more concise\",\n-            mut_str, caller_type\n-        ),\n+        &format!(\"called `.get{mut_str}().unwrap()` on a {caller_type}. Using `[]` is more clear and more concise\"),\n         \"try this\",\n         format!(\n-            \"{}{}[{}]\",\n-            borrow_str,\n-            snippet_with_applicability(cx, recv.span, \"..\", &mut applicability),\n-            get_args_str\n+            \"{borrow_str}{}[{get_args_str}]\",\n+            snippet_with_applicability(cx, recv.span, \"..\", &mut applicability)\n         ),\n         applicability,\n     );"}, {"sha": "429cdc1918d79d7c03d1d5b24fe1bff04c8e7afb", "filename": "src/tools/clippy/clippy_lints/src/methods/implicit_clone.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fimplicit_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fimplicit_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fimplicit_clone.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -26,12 +26,12 @@ pub fn check(cx: &LateContext<'_>, method_name: &str, expr: &hir::Expr<'_>, recv\n                 cx,\n                 IMPLICIT_CLONE,\n                 expr.span,\n-                &format!(\"implicitly cloning a `{}` by calling `{}` on its dereferenced type\", ty_name, method_name),\n+                &format!(\"implicitly cloning a `{ty_name}` by calling `{method_name}` on its dereferenced type\"),\n                 \"consider using\",\n                 if ref_count > 1 {\n-                    format!(\"({}{}).clone()\", \"*\".repeat(ref_count - 1), recv_snip)\n+                    format!(\"({}{recv_snip}).clone()\", \"*\".repeat(ref_count - 1))\n                 } else {\n-                    format!(\"{}.clone()\", recv_snip)\n+                    format!(\"{recv_snip}.clone()\")\n                 },\n                 app,\n             );"}, {"sha": "ede3b8bb74e97c7353dcef5154a167057bceb612", "filename": "src/tools/clippy/clippy_lints/src/methods/inefficient_to_string.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -34,18 +34,17 @@ pub fn check<'tcx>(\n                 cx,\n                 INEFFICIENT_TO_STRING,\n                 expr.span,\n-                &format!(\"calling `to_string` on `{}`\", arg_ty),\n+                &format!(\"calling `to_string` on `{arg_ty}`\"),\n                 |diag| {\n                     diag.help(&format!(\n-                        \"`{}` implements `ToString` through a slower blanket impl, but `{}` has a fast specialization of `ToString`\",\n-                        self_ty, deref_self_ty\n+                        \"`{self_ty}` implements `ToString` through a slower blanket impl, but `{deref_self_ty}` has a fast specialization of `ToString`\"\n                     ));\n                     let mut applicability = Applicability::MachineApplicable;\n                     let arg_snippet = snippet_with_applicability(cx, receiver.span, \"..\", &mut applicability);\n                     diag.span_suggestion(\n                         expr.span,\n                         \"try dereferencing the receiver\",\n-                        format!(\"({}{}).to_string()\", \"*\".repeat(deref_count), arg_snippet),\n+                        format!(\"({}{arg_snippet}).to_string()\", \"*\".repeat(deref_count)),\n                         applicability,\n                     );\n                 },\n@@ -66,7 +65,7 @@ fn specializes_tostring(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n     }\n \n     if let ty::Adt(adt, substs) = ty.kind() {\n-        match_def_path(cx, adt.did(), &paths::COW) && substs.type_at(1).is_str()\n+        cx.tcx.is_diagnostic_item(sym::Cow, adt.did()) && substs.type_at(1).is_str()\n     } else {\n         false\n     }"}, {"sha": "be56b63506a4be475be73426c827852b1241c455", "filename": "src/tools/clippy/clippy_lints/src/methods/into_iter_on_ref.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Finto_iter_on_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Finto_iter_on_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Finto_iter_on_ref.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -30,8 +30,7 @@ pub(super) fn check(\n                 INTO_ITER_ON_REF,\n                 method_span,\n                 &format!(\n-                    \"this `.into_iter()` call is equivalent to `.{}()` and will not consume the `{}`\",\n-                    method_name, kind,\n+                    \"this `.into_iter()` call is equivalent to `.{method_name}()` and will not consume the `{kind}`\",\n                 ),\n                 \"call directly\",\n                 method_name.to_string(),"}, {"sha": "304024e80666f882e7eaff6bce448c734e1d3348", "filename": "src/tools/clippy/clippy_lints/src/methods/is_digit_ascii_radix.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fis_digit_ascii_radix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fis_digit_ascii_radix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fis_digit_ascii_radix.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -37,12 +37,11 @@ pub(super) fn check<'tcx>(\n             cx,\n             IS_DIGIT_ASCII_RADIX,\n             expr.span,\n-            &format!(\"use of `char::is_digit` with literal radix of {}\", num),\n+            &format!(\"use of `char::is_digit` with literal radix of {num}\"),\n             \"try\",\n             format!(\n-                \"{}.{}()\",\n-                snippet_with_applicability(cx, self_arg.span, \"..\", &mut applicability),\n-                replacement\n+                \"{}.{replacement}()\",\n+                snippet_with_applicability(cx, self_arg.span, \"..\", &mut applicability)\n             ),\n             applicability,\n         );"}, {"sha": "bde6f92b076ebae374c76d47eab0820c34fd86e4", "filename": "src/tools/clippy/clippy_lints/src/methods/iter_cloned_collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_cloned_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_cloned_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_cloned_collect.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -20,8 +20,8 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, method_name: &str, expr: &hir:\n                 cx,\n                 ITER_CLONED_COLLECT,\n                 to_replace,\n-                &format!(\"called `iter().{}().collect()` on a slice to create a `Vec`. Calling `to_vec()` is both faster and \\\n-                more readable\", method_name),\n+                &format!(\"called `iter().{method_name}().collect()` on a slice to create a `Vec`. Calling `to_vec()` is both faster and \\\n+                more readable\"),\n                 \"try\",\n                 \".to_vec()\".to_string(),\n                 Applicability::MachineApplicable,"}, {"sha": "bcddc7c786a50d3750163531d0ba6bc15b6802a5", "filename": "src/tools/clippy/clippy_lints/src/methods/iter_count.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_count.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -37,7 +37,7 @@ pub(crate) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>, recv: &'tcx E\n         cx,\n         ITER_COUNT,\n         expr.span,\n-        &format!(\"called `.{}().count()` on a `{}`\", iter_method, caller_type),\n+        &format!(\"called `.{iter_method}().count()` on a `{caller_type}`\"),\n         \"try\",\n         format!(\n             \"{}.len()\","}, {"sha": "2244ebfb129277036c95e95013d0a39d8f213a60", "filename": "src/tools/clippy/clippy_lints/src/methods/iter_kv_map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_kv_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_kv_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_kv_map.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -54,19 +54,19 @@ pub(super) fn check<'tcx>(\n                         cx,\n                         ITER_KV_MAP,\n                         expr.span,\n-                        &format!(\"iterating on a map's {}s\", replacement_kind),\n+                        &format!(\"iterating on a map's {replacement_kind}s\"),\n                         \"try\",\n-                        format!(\"{}.{}{}s()\", recv_snippet, into_prefix, replacement_kind),\n+                        format!(\"{recv_snippet}.{into_prefix}{replacement_kind}s()\"),\n                         applicability,\n                     );\n                 } else {\n                     span_lint_and_sugg(\n                         cx,\n                         ITER_KV_MAP,\n                         expr.span,\n-                        &format!(\"iterating on a map's {}s\", replacement_kind),\n+                        &format!(\"iterating on a map's {replacement_kind}s\"),\n                         \"try\",\n-                        format!(\"{}.{}{}s().map(|{}| {})\", recv_snippet, into_prefix, replacement_kind, binded_ident,\n+                        format!(\"{recv_snippet}.{into_prefix}{replacement_kind}s().map(|{binded_ident}| {})\",\n                             snippet_with_applicability(cx, body_expr.span, \"/* body */\", &mut applicability)),\n                         applicability,\n                     );"}, {"sha": "83c1bf203467a447aca66f9e0f2692d555dd246a", "filename": "src/tools/clippy/clippy_lints/src/methods/iter_next_slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_next_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_next_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_next_slice.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -37,7 +37,7 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, cal\n                 let suggest = if start_idx == 0 {\n                     format!(\"{}.first()\", snippet_with_applicability(cx, caller_var.span, \"..\", &mut applicability))\n                 } else {\n-                    format!(\"{}.get({})\", snippet_with_applicability(cx, caller_var.span, \"..\", &mut applicability), start_idx)\n+                    format!(\"{}.get({start_idx})\", snippet_with_applicability(cx, caller_var.span, \"..\", &mut applicability))\n                 };\n                 span_lint_and_sugg(\n                     cx,"}, {"sha": "ceee12784cbb789e46785d44a51569c892654229", "filename": "src/tools/clippy/clippy_lints/src/methods/iter_nth.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_nth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_nth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_nth.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -32,8 +32,8 @@ pub(super) fn check<'tcx>(\n         cx,\n         ITER_NTH,\n         expr.span,\n-        &format!(\"called `.iter{0}().nth()` on a {1}\", mut_str, caller_type),\n+        &format!(\"called `.iter{mut_str}().nth()` on a {caller_type}\"),\n         None,\n-        &format!(\"calling `.get{}()` is both faster and more readable\", mut_str),\n+        &format!(\"calling `.get{mut_str}()` is both faster and more readable\"),\n     );\n }"}, {"sha": "4f73b3ec42247e56bacf4f6d9df9a1506095c6e7", "filename": "src/tools/clippy/clippy_lints/src/methods/iter_on_single_or_empty_collections.rs", "status": "modified", "additions": 6, "deletions": 21, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_on_single_or_empty_collections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_on_single_or_empty_collections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_on_single_or_empty_collections.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet;\n-use clippy_utils::{get_expr_use_or_unification_node, is_lang_ctor, is_no_std_crate};\n+use clippy_utils::{get_expr_use_or_unification_node, is_no_std_crate, is_res_lang_ctor, path_res};\n \n use rustc_errors::Applicability;\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n@@ -26,26 +26,11 @@ impl IterType {\n }\n \n pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>, method_name: &str, recv: &Expr<'_>) {\n-    let item = match &recv.kind {\n-        ExprKind::Array(v) if v.len() <= 1 => v.first(),\n-        ExprKind::Path(p) => {\n-            if is_lang_ctor(cx, p, OptionNone) {\n-                None\n-            } else {\n-                return;\n-            }\n-        },\n-        ExprKind::Call(f, some_args) if some_args.len() == 1 => {\n-            if let ExprKind::Path(p) = &f.kind {\n-                if is_lang_ctor(cx, p, OptionSome) {\n-                    Some(&some_args[0])\n-                } else {\n-                    return;\n-                }\n-            } else {\n-                return;\n-            }\n-        },\n+    let item = match recv.kind {\n+        ExprKind::Array([]) => None,\n+        ExprKind::Array([e]) => Some(e),\n+        ExprKind::Path(ref p) if is_res_lang_ctor(cx, cx.qpath_res(p, recv.hir_id), OptionNone) => None,\n+        ExprKind::Call(f, [arg]) if is_res_lang_ctor(cx, path_res(cx, f), OptionSome) => Some(arg),\n         _ => return,\n     };\n     let iter_type = match method_name {"}, {"sha": "3da230e12d7fe017867fe9dee9abaa6c56842811", "filename": "src/tools/clippy/clippy_lints/src/methods/iter_with_drain.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_with_drain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_with_drain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_with_drain.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -22,7 +22,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, span\n             cx,\n             ITER_WITH_DRAIN,\n             span.with_hi(expr.span.hi()),\n-            &format!(\"`drain(..)` used on a `{}`\", ty_name),\n+            &format!(\"`drain(..)` used on a `{ty_name}`\"),\n             \"try this\",\n             \"into_iter()\".to_string(),\n             Applicability::MaybeIncorrect,"}, {"sha": "5b758f1e6547c676ea7dca16710969e9df4834ec", "filename": "src/tools/clippy/clippy_lints/src/methods/manual_ok_or.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmanual_ok_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmanual_ok_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmanual_ok_or.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -1,11 +1,11 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::{indent_of, reindent_multiline, snippet_opt};\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{is_lang_ctor, path_to_local_id};\n+use clippy_utils::{is_res_lang_ctor, path_res, path_to_local_id};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::{ResultErr, ResultOk};\n-use rustc_hir::{Closure, Expr, ExprKind, PatKind};\n+use rustc_hir::{Expr, ExprKind, PatKind};\n use rustc_lint::LateContext;\n use rustc_span::symbol::sym;\n \n@@ -22,8 +22,8 @@ pub(super) fn check<'tcx>(\n         if let Some(method_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n         if let Some(impl_id) = cx.tcx.impl_of_method(method_id);\n         if is_type_diagnostic_item(cx, cx.tcx.type_of(impl_id), sym::Option);\n-        if let ExprKind::Call(Expr { kind: ExprKind::Path(err_path), .. }, [err_arg]) = or_expr.kind;\n-        if is_lang_ctor(cx, err_path, ResultErr);\n+        if let ExprKind::Call(err_path, [err_arg]) = or_expr.kind;\n+        if is_res_lang_ctor(cx, path_res(cx, err_path), ResultErr);\n         if is_ok_wrapping(cx, map_expr);\n         if let Some(recv_snippet) = snippet_opt(cx, recv.span);\n         if let Some(err_arg_snippet) = snippet_opt(cx, err_arg.span);\n@@ -37,9 +37,7 @@ pub(super) fn check<'tcx>(\n                 \"this pattern reimplements `Option::ok_or`\",\n                 \"replace with\",\n                 format!(\n-                    \"{}.ok_or({})\",\n-                    recv_snippet,\n-                    reindented_err_arg_snippet\n+                    \"{recv_snippet}.ok_or({reindented_err_arg_snippet})\"\n                 ),\n                 Applicability::MachineApplicable,\n             );\n@@ -48,17 +46,19 @@ pub(super) fn check<'tcx>(\n }\n \n fn is_ok_wrapping(cx: &LateContext<'_>, map_expr: &Expr<'_>) -> bool {\n-    if let ExprKind::Path(ref qpath) = map_expr.kind {\n-        if is_lang_ctor(cx, qpath, ResultOk) {\n-            return true;\n-        }\n-    }\n-    if_chain! {\n-        if let ExprKind::Closure(&Closure { body, .. }) = map_expr.kind;\n-        let body = cx.tcx.hir().body(body);\n-        if let PatKind::Binding(_, param_id, ..) = body.params[0].pat.kind;\n-        if let ExprKind::Call(Expr { kind: ExprKind::Path(ok_path), .. }, &[ref ok_arg]) = body.value.kind;\n-        if is_lang_ctor(cx, ok_path, ResultOk);\n-        then { path_to_local_id(ok_arg, param_id) } else { false }\n+    match map_expr.kind {\n+        ExprKind::Path(ref qpath) if is_res_lang_ctor(cx, cx.qpath_res(qpath, map_expr.hir_id), ResultOk) => true,\n+        ExprKind::Closure(closure) => {\n+            let body = cx.tcx.hir().body(closure.body);\n+            if let PatKind::Binding(_, param_id, ..) = body.params[0].pat.kind\n+                && let ExprKind::Call(callee, [ok_arg]) = body.value.kind\n+                && is_res_lang_ctor(cx, path_res(cx, callee), ResultOk)\n+            {\n+                path_to_local_id(ok_arg, param_id)\n+            } else {\n+                false\n+            }\n+        },\n+        _ => false,\n     }\n }"}, {"sha": "ec694cf6882e5c28a5ad490dee73401fccdb5da7", "filename": "src/tools/clippy/clippy_lints/src/methods/manual_saturating_arithmetic.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -57,11 +57,10 @@ pub fn check(\n         super::MANUAL_SATURATING_ARITHMETIC,\n         expr.span,\n         \"manual saturating arithmetic\",\n-        &format!(\"try using `saturating_{}`\", arith),\n+        &format!(\"try using `saturating_{arith}`\"),\n         format!(\n-            \"{}.saturating_{}({})\",\n+            \"{}.saturating_{arith}({})\",\n             snippet_with_applicability(cx, arith_lhs.span, \"..\", &mut applicability),\n-            arith,\n             snippet_with_applicability(cx, arith_rhs.span, \"..\", &mut applicability),\n         ),\n         applicability,"}, {"sha": "8b6b8f1bf16cbbfcf6952c4dac6fd684448d85e3", "filename": "src/tools/clippy/clippy_lints/src/methods/manual_str_repeat.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmanual_str_repeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmanual_str_repeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmanual_str_repeat.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -1,8 +1,8 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::is_path_diagnostic_item;\n use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n use clippy_utils::sugg::Sugg;\n-use clippy_utils::ty::{is_type_diagnostic_item, is_type_lang_item, match_type};\n-use clippy_utils::{is_expr_path_def_path, paths};\n+use clippy_utils::ty::{is_type_diagnostic_item, is_type_lang_item};\n use if_chain::if_chain;\n use rustc_ast::LitKind;\n use rustc_errors::Applicability;\n@@ -38,7 +38,7 @@ fn parse_repeat_arg(cx: &LateContext<'_>, e: &Expr<'_>) -> Option<RepeatKind> {\n         let ty = cx.typeck_results().expr_ty(e);\n         if is_type_diagnostic_item(cx, ty, sym::String)\n             || (is_type_lang_item(cx, ty, LangItem::OwnedBox) && get_ty_param(ty).map_or(false, Ty::is_str))\n-            || (match_type(cx, ty, &paths::COW) && get_ty_param(ty).map_or(false, Ty::is_str))\n+            || (is_type_diagnostic_item(cx, ty, sym::Cow) && get_ty_param(ty).map_or(false, Ty::is_str))\n         {\n             Some(RepeatKind::String)\n         } else {\n@@ -57,7 +57,7 @@ pub(super) fn check(\n ) {\n     if_chain! {\n         if let ExprKind::Call(repeat_fn, [repeat_arg]) = take_self_arg.kind;\n-        if is_expr_path_def_path(cx, repeat_fn, &paths::ITER_REPEAT);\n+        if is_path_diagnostic_item(cx, repeat_fn, sym::iter_repeat);\n         if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(collect_expr), sym::String);\n         if let Some(collect_id) = cx.typeck_results().type_dependent_def_id(collect_expr.hir_id);\n         if let Some(take_id) = cx.typeck_results().type_dependent_def_id(take_expr.hir_id);\n@@ -91,7 +91,7 @@ pub(super) fn check(\n                 collect_expr.span,\n                 \"manual implementation of `str::repeat` using iterators\",\n                 \"try this\",\n-                format!(\"{}.repeat({})\", val_str, count_snip),\n+                format!(\"{val_str}.repeat({count_snip})\"),\n                 app\n             )\n         }"}, {"sha": "7ce14ec080b15fa42177d583cb2802526a414adf", "filename": "src/tools/clippy/clippy_lints/src/methods/map_clone.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmap_clone.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -111,11 +111,10 @@ fn lint_explicit_closure(cx: &LateContext<'_>, replace: Span, root: Span, is_cop\n         MAP_CLONE,\n         replace,\n         message,\n-        &format!(\"consider calling the dedicated `{}` method\", sugg_method),\n+        &format!(\"consider calling the dedicated `{sugg_method}` method\"),\n         format!(\n-            \"{}.{}()\",\n+            \"{}.{sugg_method}()\",\n             snippet_with_applicability(cx, root, \"..\", &mut applicability),\n-            sugg_method,\n         ),\n         applicability,\n     );"}, {"sha": "361ffcb5ef3fb2e9f93af8110ad60be7298b4d1c", "filename": "src/tools/clippy/clippy_lints/src/methods/map_flatten.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmap_flatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmap_flatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmap_flatten.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -20,12 +20,9 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, map_\n             cx,\n             MAP_FLATTEN,\n             expr.span.with_lo(map_span.lo()),\n-            &format!(\"called `map(..).flatten()` on `{}`\", caller_ty_name),\n-            &format!(\n-                \"try replacing `map` with `{}` and remove the `.flatten()`\",\n-                method_to_use\n-            ),\n-            format!(\"{}({})\", method_to_use, closure_snippet),\n+            &format!(\"called `map(..).flatten()` on `{caller_ty_name}`\"),\n+            &format!(\"try replacing `map` with `{method_to_use}` and remove the `.flatten()`\"),\n+            format!(\"{method_to_use}({closure_snippet})\"),\n             applicability,\n         );\n     }"}, {"sha": "0f25ef82ed42a642d424f51260e3f49d3db74399", "filename": "src/tools/clippy/clippy_lints/src/methods/map_identity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmap_identity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmap_identity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmap_identity.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -30,7 +30,7 @@ pub(super) fn check(\n                 MAP_IDENTITY,\n                 sugg_span,\n                 \"unnecessary map of the identity function\",\n-                &format!(\"remove the call to `{}`\", name),\n+                &format!(\"remove the call to `{name}`\"),\n                 String::new(),\n                 Applicability::MachineApplicable,\n             )"}, {"sha": "74fdead216b0a5f7c3df156b51c21cf83a1a59ac", "filename": "src/tools/clippy/clippy_lints/src/methods/map_unwrap_or.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmap_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmap_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmap_unwrap_or.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -65,7 +65,7 @@ pub(super) fn check<'tcx>(\n                 expr.span,\n                 msg,\n                 \"try this\",\n-                format!(\"{}.map_or_else({}, {})\", var_snippet, unwrap_snippet, map_snippet),\n+                format!(\"{var_snippet}.map_or_else({unwrap_snippet}, {map_snippet})\"),\n                 Applicability::MachineApplicable,\n             );\n             return true;"}, {"sha": "cfcf9596c50d3f32638475a2f06277916257195e", "filename": "src/tools/clippy/clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 40, "deletions": 47, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -109,13 +109,13 @@ use if_chain::if_chain;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_hir::{Expr, ExprKind, PrimTy, QPath, TraitItem, TraitItemKind};\n+use rustc_hir_analysis::hir_ty_to_ty;\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::{self, TraitRef, Ty};\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::{sym, Span};\n-use rustc_hir_analysis::hir_ty_to_ty;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -3255,65 +3255,59 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n         let self_ty = cx.tcx.type_of(item.def_id);\n \n         let implements_trait = matches!(item.kind, hir::ItemKind::Impl(hir::Impl { of_trait: Some(_), .. }));\n-        if_chain! {\n-            if let hir::ImplItemKind::Fn(ref sig, id) = impl_item.kind;\n-            if let Some(first_arg) = iter_input_pats(sig.decl, cx.tcx.hir().body(id)).next();\n-\n-            let method_sig = cx.tcx.fn_sig(impl_item.def_id.def_id);\n+        if let hir::ImplItemKind::Fn(ref sig, id) = impl_item.kind {\n+            let method_sig = cx.tcx.fn_sig(impl_item.def_id);\n             let method_sig = cx.tcx.erase_late_bound_regions(method_sig);\n-\n-            let first_arg_ty = method_sig.inputs().iter().next();\n-\n-            // check conventions w.r.t. conversion method names and predicates\n-            if let Some(first_arg_ty) = first_arg_ty;\n-\n-            then {\n-                // if this impl block implements a trait, lint in trait definition instead\n-                if !implements_trait && cx.access_levels.is_exported(impl_item.def_id.def_id) {\n-                    // check missing trait implementations\n-                    for method_config in &TRAIT_METHODS {\n-                        if name == method_config.method_name &&\n-                            sig.decl.inputs.len() == method_config.param_count &&\n-                            method_config.output_type.matches(&sig.decl.output) &&\n-                            method_config.self_kind.matches(cx, self_ty, *first_arg_ty) &&\n-                            fn_header_equals(method_config.fn_header, sig.header) &&\n-                            method_config.lifetime_param_cond(impl_item)\n-                        {\n-                            span_lint_and_help(\n-                                cx,\n-                                SHOULD_IMPLEMENT_TRAIT,\n-                                impl_item.span,\n-                                &format!(\n-                                    \"method `{}` can be confused for the standard trait method `{}::{}`\",\n-                                    method_config.method_name,\n-                                    method_config.trait_name,\n-                                    method_config.method_name\n-                                ),\n-                                None,\n-                                &format!(\n-                                    \"consider implementing the trait `{}` or choosing a less ambiguous method name\",\n-                                    method_config.trait_name\n-                                )\n-                            );\n-                        }\n+            let first_arg_ty_opt = method_sig.inputs().iter().next().copied();\n+            // if this impl block implements a trait, lint in trait definition instead\n+            if !implements_trait && cx.access_levels.is_exported(impl_item.def_id.def_id) {\n+                // check missing trait implementations\n+                for method_config in &TRAIT_METHODS {\n+                    if name == method_config.method_name\n+                        && sig.decl.inputs.len() == method_config.param_count\n+                        && method_config.output_type.matches(&sig.decl.output)\n+                        // in case there is no first arg, since we already have checked the number of arguments\n+                        // it's should be always true\n+                        && first_arg_ty_opt.map_or(true, |first_arg_ty| method_config\n+                            .self_kind.matches(cx, self_ty, first_arg_ty)\n+                            )\n+                        && fn_header_equals(method_config.fn_header, sig.header)\n+                        && method_config.lifetime_param_cond(impl_item)\n+                    {\n+                        span_lint_and_help(\n+                            cx,\n+                            SHOULD_IMPLEMENT_TRAIT,\n+                            impl_item.span,\n+                            &format!(\n+                                \"method `{}` can be confused for the standard trait method `{}::{}`\",\n+                                method_config.method_name, method_config.trait_name, method_config.method_name\n+                            ),\n+                            None,\n+                            &format!(\n+                                \"consider implementing the trait `{}` or choosing a less ambiguous method name\",\n+                                method_config.trait_name\n+                            ),\n+                        );\n                     }\n                 }\n+            }\n \n-                if sig.decl.implicit_self.has_implicit_self()\n+            if sig.decl.implicit_self.has_implicit_self()\n                     && !(self.avoid_breaking_exported_api\n-                        && cx.access_levels.is_exported(impl_item.def_id.def_id))\n+                    && cx.access_levels.is_exported(impl_item.def_id.def_id))\n+                    && let Some(first_arg) = iter_input_pats(sig.decl, cx.tcx.hir().body(id)).next()\n+                    && let Some(first_arg_ty) = first_arg_ty_opt\n                 {\n                     wrong_self_convention::check(\n                         cx,\n                         name,\n                         self_ty,\n-                        *first_arg_ty,\n+                        first_arg_ty,\n                         first_arg.pat.span,\n                         implements_trait,\n                         false\n                     );\n                 }\n-            }\n         }\n \n         // if this impl block implements a trait, lint in trait definition instead\n@@ -3799,7 +3793,6 @@ const TRAIT_METHODS: [ShouldImplTraitCase; 30] = [\n     ShouldImplTraitCase::new(\"std::borrow::BorrowMut\", \"borrow_mut\",  1,  FN_HEADER,  SelfKind::RefMut,  OutType::Ref, true),\n     ShouldImplTraitCase::new(\"std::clone::Clone\", \"clone\",  1,  FN_HEADER,  SelfKind::Ref,  OutType::Any, true),\n     ShouldImplTraitCase::new(\"std::cmp::Ord\", \"cmp\",  2,  FN_HEADER,  SelfKind::Ref,  OutType::Any, true),\n-    // FIXME: default doesn't work\n     ShouldImplTraitCase::new(\"std::default::Default\", \"default\",  0,  FN_HEADER,  SelfKind::No,  OutType::Any, true),\n     ShouldImplTraitCase::new(\"std::ops::Deref\", \"deref\",  1,  FN_HEADER,  SelfKind::Ref,  OutType::Ref, true),\n     ShouldImplTraitCase::new(\"std::ops::DerefMut\", \"deref_mut\",  1,  FN_HEADER,  SelfKind::RefMut,  OutType::Ref, true),\n@@ -3827,7 +3820,7 @@ enum SelfKind {\n     Value,\n     Ref,\n     RefMut,\n-    No,\n+    No, // When we want the first argument type to be different than `Self`\n }\n \n impl SelfKind {"}, {"sha": "6fb92d1c663cf6de9ee7a7421656186fad5d7908", "filename": "src/tools/clippy/clippy_lints/src/methods/option_as_ref_deref.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Foption_as_ref_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Foption_as_ref_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Foption_as_ref_deref.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -98,13 +98,12 @@ pub(super) fn check<'tcx>(\n             format!(\".as_ref().map({})\", snippet(cx, map_arg.span, \"..\"))\n         };\n         let method_hint = if is_mut { \"as_deref_mut\" } else { \"as_deref\" };\n-        let hint = format!(\"{}.{}()\", snippet(cx, as_ref_recv.span, \"..\"), method_hint);\n-        let suggestion = format!(\"try using {} instead\", method_hint);\n+        let hint = format!(\"{}.{method_hint}()\", snippet(cx, as_ref_recv.span, \"..\"));\n+        let suggestion = format!(\"try using {method_hint} instead\");\n \n         let msg = format!(\n-            \"called `{0}` on an Option value. This can be done more directly \\\n-            by calling `{1}` instead\",\n-            current_method, hint\n+            \"called `{current_method}` on an Option value. This can be done more directly \\\n+            by calling `{hint}` instead\"\n         );\n         span_lint_and_sugg(\n             cx,"}, {"sha": "3a23ecc50dc1d4dc76b90fd721220eed395b40dc", "filename": "src/tools/clippy/clippy_lints/src/methods/option_map_or_none.rs", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{is_lang_ctor, path_def_id};\n+use clippy_utils::{is_res_lang_ctor, path_def_id, path_res};\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n@@ -51,22 +51,12 @@ pub(super) fn check<'tcx>(\n         return;\n     }\n \n-    let default_arg_is_none = if let hir::ExprKind::Path(ref qpath) = def_arg.kind {\n-        is_lang_ctor(cx, qpath, OptionNone)\n-    } else {\n-        return;\n-    };\n-\n-    if !default_arg_is_none {\n+    if !is_res_lang_ctor(cx, path_res(cx, def_arg), OptionNone) {\n         // nothing to lint!\n         return;\n     }\n \n-    let f_arg_is_some = if let hir::ExprKind::Path(ref qpath) = map_arg.kind {\n-        is_lang_ctor(cx, qpath, OptionSome)\n-    } else {\n-        false\n-    };\n+    let f_arg_is_some = is_res_lang_ctor(cx, path_res(cx, map_arg), OptionSome);\n \n     if is_option {\n         let self_snippet = snippet(cx, recv.span, \"..\");\n@@ -87,7 +77,7 @@ pub(super) fn check<'tcx>(\n                     expr.span,\n                     msg,\n                     \"try using `map` instead\",\n-                    format!(\"{0}.map({1} {2})\", self_snippet, arg_snippet,func_snippet),\n+                    format!(\"{self_snippet}.map({arg_snippet} {func_snippet})\"),\n                     Applicability::MachineApplicable,\n                 );\n             }\n@@ -102,7 +92,7 @@ pub(super) fn check<'tcx>(\n             expr.span,\n             msg,\n             \"try using `and_then` instead\",\n-            format!(\"{0}.and_then({1})\", self_snippet, func_snippet),\n+            format!(\"{self_snippet}.and_then({func_snippet})\"),\n             Applicability::MachineApplicable,\n         );\n     } else if f_arg_is_some {\n@@ -115,7 +105,7 @@ pub(super) fn check<'tcx>(\n             expr.span,\n             msg,\n             \"try using `ok` instead\",\n-            format!(\"{0}.ok()\", self_snippet),\n+            format!(\"{self_snippet}.ok()\"),\n             Applicability::MachineApplicable,\n         );\n     }"}, {"sha": "30421a6dd5afb458261b436cfc4d23dcce6ba57c", "filename": "src/tools/clippy/clippy_lints/src/methods/option_map_unwrap_or.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -65,9 +65,8 @@ pub(super) fn check<'tcx>(\n             \"map_or(<a>, <f>)\"\n         };\n         let msg = &format!(\n-            \"called `map(<f>).unwrap_or({})` on an `Option` value. \\\n-            This can be done more directly by calling `{}` instead\",\n-            arg, suggest\n+            \"called `map(<f>).unwrap_or({arg})` on an `Option` value. \\\n+            This can be done more directly by calling `{suggest}` instead\"\n         );\n \n         span_lint_and_then(cx, MAP_UNWRAP_OR, expr.span, msg, |diag| {\n@@ -82,10 +81,10 @@ pub(super) fn check<'tcx>(\n             ];\n \n             if !unwrap_snippet_none {\n-                suggestion.push((map_arg_span.with_hi(map_arg_span.lo()), format!(\"{}, \", unwrap_snippet)));\n+                suggestion.push((map_arg_span.with_hi(map_arg_span.lo()), format!(\"{unwrap_snippet}, \")));\n             }\n \n-            diag.multipart_suggestion(&format!(\"use `{}` instead\", suggest), suggestion, applicability);\n+            diag.multipart_suggestion(&format!(\"use `{suggest}` instead\"), suggestion, applicability);\n         });\n     }\n }"}, {"sha": "6a35024d0361240596283a3e116b9e5b39eceb8d", "filename": "src/tools/clippy/clippy_lints/src/methods/or_fun_call.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -62,9 +62,9 @@ pub(super) fn check<'tcx>(\n                     cx,\n                     OR_FUN_CALL,\n                     method_span.with_hi(span.hi()),\n-                    &format!(\"use of `{}` followed by a call to `{}`\", name, path),\n+                    &format!(\"use of `{name}` followed by a call to `{path}`\"),\n                     \"try this\",\n-                    format!(\"{}()\", sugg),\n+                    format!(\"{sugg}()\"),\n                     Applicability::MachineApplicable,\n                 );\n \n@@ -131,7 +131,7 @@ pub(super) fn check<'tcx>(\n \n                     if use_lambda {\n                         let l_arg = if fn_has_arguments { \"_\" } else { \"\" };\n-                        format!(\"|{}| {}\", l_arg, snippet).into()\n+                        format!(\"|{l_arg}| {snippet}\").into()\n                     } else {\n                         snippet\n                     }\n@@ -141,9 +141,9 @@ pub(super) fn check<'tcx>(\n                     cx,\n                     OR_FUN_CALL,\n                     span_replace_word,\n-                    &format!(\"use of `{}` followed by a function call\", name),\n+                    &format!(\"use of `{name}` followed by a function call\"),\n                     \"try this\",\n-                    format!(\"{}_{}({})\", name, suffix, sugg),\n+                    format!(\"{name}_{suffix}({sugg})\"),\n                     Applicability::HasPlaceholders,\n                 );\n             }"}, {"sha": "55ba6e262df7e1d44b2f3555eddec6f4b26f9d26", "filename": "src/tools/clippy/clippy_lints/src/methods/or_then_unwrap.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2For_then_unwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2For_then_unwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2For_then_unwrap.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{diagnostics::span_lint_and_sugg, is_lang_ctor};\n+use clippy_utils::{diagnostics::span_lint_and_sugg, is_res_lang_ctor, path_res};\n use rustc_errors::Applicability;\n use rustc_hir::{lang_items::LangItem, Expr, ExprKind};\n use rustc_lint::LateContext;\n@@ -58,8 +58,7 @@ pub(super) fn check<'tcx>(\n \n fn get_content_if_ctor_matches(cx: &LateContext<'_>, expr: &Expr<'_>, item: LangItem) -> Option<Span> {\n     if let ExprKind::Call(some_expr, [arg]) = expr.kind\n-        && let ExprKind::Path(qpath) = &some_expr.kind\n-        && is_lang_ctor(cx, qpath, item)\n+        && is_res_lang_ctor(cx, path_res(cx, some_expr), item)\n     {\n         Some(arg.span)\n     } else {"}, {"sha": "324c9c17b5a9a36a7ad6a8fdf82fc16e18fca695", "filename": "src/tools/clippy/clippy_lints/src/methods/search_is_some.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fsearch_is_some.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fsearch_is_some.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fsearch_is_some.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -30,10 +30,7 @@ pub(super) fn check<'tcx>(\n     let option_check_method = if is_some { \"is_some\" } else { \"is_none\" };\n     // lint if caller of search is an Iterator\n     if is_trait_method(cx, is_some_recv, sym::Iterator) {\n-        let msg = format!(\n-            \"called `{}()` after searching an `Iterator` with `{}`\",\n-            option_check_method, search_method\n-        );\n+        let msg = format!(\"called `{option_check_method}()` after searching an `Iterator` with `{search_method}`\");\n         let search_snippet = snippet(cx, search_arg.span, \"..\");\n         if search_snippet.lines().count() <= 1 {\n             // suggest `any(|x| ..)` instead of `any(|&x| ..)` for `find(|&x| ..).is_some()`\n@@ -86,8 +83,7 @@ pub(super) fn check<'tcx>(\n                     &msg,\n                     \"use `!_.any()` instead\",\n                     format!(\n-                        \"!{}.any({})\",\n-                        iter,\n+                        \"!{iter}.any({})\",\n                         any_search_snippet.as_ref().map_or(&*search_snippet, String::as_str)\n                     ),\n                     applicability,\n@@ -119,7 +115,7 @@ pub(super) fn check<'tcx>(\n             if is_string_or_str_slice(search_recv);\n             if is_string_or_str_slice(search_arg);\n             then {\n-                let msg = format!(\"called `{}()` after calling `find()` on a string\", option_check_method);\n+                let msg = format!(\"called `{option_check_method}()` after calling `find()` on a string\");\n                 match option_check_method {\n                     \"is_some\" => {\n                         let mut applicability = Applicability::MachineApplicable;\n@@ -130,7 +126,7 @@ pub(super) fn check<'tcx>(\n                             method_span.with_hi(expr.span.hi()),\n                             &msg,\n                             \"use `contains()` instead\",\n-                            format!(\"contains({})\", find_arg),\n+                            format!(\"contains({find_arg})\"),\n                             applicability,\n                         );\n                     },\n@@ -144,7 +140,7 @@ pub(super) fn check<'tcx>(\n                             expr.span,\n                             &msg,\n                             \"use `!_.contains()` instead\",\n-                            format!(\"!{}.contains({})\", string, find_arg),\n+                            format!(\"!{string}.contains({find_arg})\"),\n                             applicability,\n                         );\n                     },"}, {"sha": "44a7ad394fa0c45b4e7b1ad4b96a1f2e5b5206b2", "filename": "src/tools/clippy/clippy_lints/src/methods/single_char_insert_string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fsingle_char_insert_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fsingle_char_insert_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fsingle_char_insert_string.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -14,7 +14,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, receiver: &hir::\n         let base_string_snippet =\n             snippet_with_applicability(cx, receiver.span.source_callsite(), \"_\", &mut applicability);\n         let pos_arg = snippet_with_applicability(cx, args[0].span, \"..\", &mut applicability);\n-        let sugg = format!(\"{}.insert({}, {})\", base_string_snippet, pos_arg, extension_string);\n+        let sugg = format!(\"{base_string_snippet}.insert({pos_arg}, {extension_string})\");\n         span_lint_and_sugg(\n             cx,\n             SINGLE_CHAR_ADD_STR,"}, {"sha": "0698bd6a0c5237b0942877943b57803eeb98885c", "filename": "src/tools/clippy/clippy_lints/src/methods/single_char_push_string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fsingle_char_push_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fsingle_char_push_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fsingle_char_push_string.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -13,7 +13,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, receiver: &hir::\n     if let Some(extension_string) = get_hint_if_single_char_arg(cx, &args[0], &mut applicability) {\n         let base_string_snippet =\n             snippet_with_applicability(cx, receiver.span.source_callsite(), \"..\", &mut applicability);\n-        let sugg = format!(\"{}.push({})\", base_string_snippet, extension_string);\n+        let sugg = format!(\"{base_string_snippet}.push({extension_string})\");\n         span_lint_and_sugg(\n             cx,\n             SINGLE_CHAR_ADD_STR,"}, {"sha": "09c8ca4cbe44ccfd7358540ee07a50a7cd602998", "filename": "src/tools/clippy/clippy_lints/src/methods/stable_sort_primitive.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fstable_sort_primitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fstable_sort_primitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fstable_sort_primitive.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -17,11 +17,11 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, recv: &'tcx\n             cx,\n             STABLE_SORT_PRIMITIVE,\n             e.span,\n-            &format!(\"used `sort` on primitive type `{}`\", slice_type),\n+            &format!(\"used `sort` on primitive type `{slice_type}`\"),\n             |diag| {\n                 let mut app = Applicability::MachineApplicable;\n                 let recv_snip = snippet_with_context(cx, recv.span, e.span.ctxt(), \"..\", &mut app).0;\n-                diag.span_suggestion(e.span, \"try\", format!(\"{}.sort_unstable()\", recv_snip), app);\n+                diag.span_suggestion(e.span, \"try\", format!(\"{recv_snip}.sort_unstable()\"), app);\n                 diag.note(\n                     \"an unstable sort typically performs faster without any observable difference for this data type\",\n                 );"}, {"sha": "ae3594bd36c3ab1ecfb3a1e6022666aa900b7001", "filename": "src/tools/clippy/clippy_lints/src/methods/str_splitn.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -2,11 +2,11 @@ use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::source::snippet_with_context;\n use clippy_utils::usage::local_used_after_expr;\n-use clippy_utils::visitors::expr_visitor;\n+use clippy_utils::visitors::{for_each_expr_with_closures, Descend};\n use clippy_utils::{is_diag_item_method, match_def_path, meets_msrv, msrvs, path_to_local_id, paths};\n+use core::ops::ControlFlow;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::intravisit::Visitor;\n use rustc_hir::{\n     BindingAnnotation, Expr, ExprKind, HirId, LangItem, Local, MatchSource, Node, Pat, PatKind, QPath, Stmt, StmtKind,\n };\n@@ -211,7 +211,7 @@ fn indirect_usage<'tcx>(\n     binding: HirId,\n     ctxt: SyntaxContext,\n ) -> Option<IndirectUsage<'tcx>> {\n-    if let StmtKind::Local(Local {\n+    if let StmtKind::Local(&Local {\n         pat: Pat {\n             kind: PatKind::Binding(BindingAnnotation::NONE, _, ident, None),\n             ..\n@@ -222,14 +222,12 @@ fn indirect_usage<'tcx>(\n     }) = stmt.kind\n     {\n         let mut path_to_binding = None;\n-        expr_visitor(cx, |expr| {\n-            if path_to_local_id(expr, binding) {\n-                path_to_binding = Some(expr);\n+        let _: Option<!> = for_each_expr_with_closures(cx, init_expr, |e| {\n+            if path_to_local_id(e, binding) {\n+                path_to_binding = Some(e);\n             }\n-\n-            path_to_binding.is_none()\n-        })\n-        .visit_expr(init_expr);\n+            ControlFlow::Continue(Descend::from(path_to_binding.is_none()))\n+        });\n \n         let mut parents = cx.tcx.hir().parent_iter(path_to_binding?.hir_id);\n         let iter_usage = parse_iter_usage(cx, ctxt, &mut parents)?;\n@@ -250,7 +248,7 @@ fn indirect_usage<'tcx>(\n             ..\n         } = iter_usage\n         {\n-            if parent_id == *local_hir_id {\n+            if parent_id == local_hir_id {\n                 return Some(IndirectUsage {\n                     name: ident.name,\n                     span: stmt.span,"}, {"sha": "6974260f70dbd4f4da082253a3ed0e16fbaeb1e0", "filename": "src/tools/clippy/clippy_lints/src/methods/string_extend_chars.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fstring_extend_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fstring_extend_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fstring_extend_chars.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -34,9 +34,8 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr\n             \"calling `.extend(_.chars())`\",\n             \"try this\",\n             format!(\n-                \"{}.push_str({}{})\",\n+                \"{}.push_str({ref_str}{})\",\n                 snippet_with_applicability(cx, recv.span, \"..\", &mut applicability),\n-                ref_str,\n                 snippet_with_applicability(cx, target.span, \"..\", &mut applicability)\n             ),\n             applicability,"}, {"sha": "219a9edd65768eeb3124f3c174375e5fce335058", "filename": "src/tools/clippy/clippy_lints/src/methods/suspicious_splitn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fsuspicious_splitn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fsuspicious_splitn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fsuspicious_splitn.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -24,10 +24,10 @@ pub(super) fn check(cx: &LateContext<'_>, method_name: &str, expr: &Expr<'_>, se\n             }\n \n             let (msg, note_msg) = if count == 0 {\n-                (format!(\"`{}` called with `0` splits\", method_name),\n+                (format!(\"`{method_name}` called with `0` splits\"),\n                 \"the resulting iterator will always return `None`\")\n             } else {\n-                (format!(\"`{}` called with `1` split\", method_name),\n+                (format!(\"`{method_name}` called with `1` split\"),\n                 if self_ty.is_slice() {\n                     \"the resulting iterator will always return the entire slice followed by `None`\"\n                 } else {"}, {"sha": "15c1c618c5137e76069e3b0e3b02008b1e5bb8fa", "filename": "src/tools/clippy/clippy_lints/src/methods/suspicious_to_owned.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fsuspicious_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fsuspicious_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fsuspicious_to_owned.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -24,9 +24,9 @@ pub fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr<'_>) -\n                 cx,\n                 SUSPICIOUS_TO_OWNED,\n                 expr.span,\n-                &format!(\"this `to_owned` call clones the {0} itself and does not cause the {0} contents to become owned\", input_type),\n+                &format!(\"this `to_owned` call clones the {input_type} itself and does not cause the {input_type} contents to become owned\"),\n                 \"consider using, depending on intent\",\n-                format!(\"{0}.clone()` or `{0}.into_owned()\", recv_snip),\n+                format!(\"{recv_snip}.clone()` or `{recv_snip}.into_owned()\"),\n                 app,\n             );\n             return true;"}, {"sha": "1cef6226ad4ff40925445616a8bd93c986cef96e", "filename": "src/tools/clippy/clippy_lints/src/methods/unnecessary_filter_map.rs", "status": "modified", "additions": 24, "deletions": 49, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -2,9 +2,10 @@ use super::utils::clone_or_copy_needed;\n use clippy_utils::diagnostics::span_lint;\n use clippy_utils::ty::is_copy;\n use clippy_utils::usage::mutated_variables;\n-use clippy_utils::{is_lang_ctor, is_trait_method, path_to_local_id};\n+use clippy_utils::visitors::{for_each_expr, Descend};\n+use clippy_utils::{is_res_lang_ctor, is_trait_method, path_res, path_to_local_id};\n+use core::ops::ControlFlow;\n use rustc_hir as hir;\n-use rustc_hir::intravisit::{walk_expr, Visitor};\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n use rustc_lint::LateContext;\n use rustc_middle::ty;\n@@ -13,7 +14,7 @@ use rustc_span::sym;\n use super::UNNECESSARY_FILTER_MAP;\n use super::UNNECESSARY_FIND_MAP;\n \n-pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<'_>, name: &str) {\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'tcx>, arg: &'tcx hir::Expr<'tcx>, name: &str) {\n     if !is_trait_method(cx, expr, sym::Iterator) {\n         return;\n     }\n@@ -26,10 +27,16 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<\n \n         let (mut found_mapping, mut found_filtering) = check_expression(cx, arg_id, body.value);\n \n-        let mut return_visitor = ReturnVisitor::new(cx, arg_id);\n-        return_visitor.visit_expr(body.value);\n-        found_mapping |= return_visitor.found_mapping;\n-        found_filtering |= return_visitor.found_filtering;\n+        let _: Option<!> = for_each_expr(body.value, |e| {\n+            if let hir::ExprKind::Ret(Some(e)) = &e.kind {\n+                let (found_mapping_res, found_filtering_res) = check_expression(cx, arg_id, e);\n+                found_mapping |= found_mapping_res;\n+                found_filtering |= found_filtering_res;\n+                ControlFlow::Continue(Descend::No)\n+            } else {\n+                ControlFlow::Continue(Descend::Yes)\n+            }\n+        });\n \n         let in_ty = cx.typeck_results().node_type(body.params[0].hir_id);\n         let sugg = if !found_filtering {\n@@ -54,22 +61,20 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<\n                 UNNECESSARY_FIND_MAP\n             },\n             expr.span,\n-            &format!(\"this `.{}` can be written more simply using `.{}`\", name, sugg),\n+            &format!(\"this `.{name}` can be written more simply using `.{sugg}`\"),\n         );\n     }\n }\n \n // returns (found_mapping, found_filtering)\n fn check_expression<'tcx>(cx: &LateContext<'tcx>, arg_id: hir::HirId, expr: &'tcx hir::Expr<'_>) -> (bool, bool) {\n-    match &expr.kind {\n+    match expr.kind {\n         hir::ExprKind::Call(func, args) => {\n-            if let hir::ExprKind::Path(ref path) = func.kind {\n-                if is_lang_ctor(cx, path, OptionSome) {\n-                    if path_to_local_id(&args[0], arg_id) {\n-                        return (false, false);\n-                    }\n-                    return (true, false);\n+            if is_res_lang_ctor(cx, path_res(cx, func), OptionSome) {\n+                if path_to_local_id(&args[0], arg_id) {\n+                    return (false, false);\n                 }\n+                return (true, false);\n             }\n             (true, true)\n         },\n@@ -80,7 +85,7 @@ fn check_expression<'tcx>(cx: &LateContext<'tcx>, arg_id: hir::HirId, expr: &'tc\n         hir::ExprKind::Match(_, arms, _) => {\n             let mut found_mapping = false;\n             let mut found_filtering = false;\n-            for arm in *arms {\n+            for arm in arms {\n                 let (m, f) = check_expression(cx, arg_id, arm.body);\n                 found_mapping |= m;\n                 found_filtering |= f;\n@@ -93,39 +98,9 @@ fn check_expression<'tcx>(cx: &LateContext<'tcx>, arg_id: hir::HirId, expr: &'tc\n             let else_check = check_expression(cx, arg_id, else_arm);\n             (if_check.0 | else_check.0, if_check.1 | else_check.1)\n         },\n-        hir::ExprKind::Path(path) if is_lang_ctor(cx, path, OptionNone) => (false, true),\n+        hir::ExprKind::Path(ref path) if is_res_lang_ctor(cx, cx.qpath_res(path, expr.hir_id), OptionNone) => {\n+            (false, true)\n+        },\n         _ => (true, true),\n     }\n }\n-\n-struct ReturnVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,\n-    arg_id: hir::HirId,\n-    // Found a non-None return that isn't Some(input)\n-    found_mapping: bool,\n-    // Found a return that isn't Some\n-    found_filtering: bool,\n-}\n-\n-impl<'a, 'tcx> ReturnVisitor<'a, 'tcx> {\n-    fn new(cx: &'a LateContext<'tcx>, arg_id: hir::HirId) -> ReturnVisitor<'a, 'tcx> {\n-        ReturnVisitor {\n-            cx,\n-            arg_id,\n-            found_mapping: false,\n-            found_filtering: false,\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for ReturnVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n-        if let hir::ExprKind::Ret(Some(expr)) = &expr.kind {\n-            let (found_mapping, found_filtering) = check_expression(self.cx, self.arg_id, expr);\n-            self.found_mapping |= found_mapping;\n-            self.found_filtering |= found_filtering;\n-        } else {\n-            walk_expr(self, expr);\n-        }\n-    }\n-}"}, {"sha": "aa87dead38f01ce4a4f97732c507fee973d18917", "filename": "src/tools/clippy/clippy_lints/src/methods/unnecessary_fold.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_fold.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -49,15 +49,12 @@ pub(super) fn check(\n                 let mut applicability = Applicability::MachineApplicable;\n                 let sugg = if replacement_has_args {\n                     format!(\n-                        \"{replacement}(|{s}| {r})\",\n-                        replacement = replacement_method_name,\n-                        s = second_arg_ident,\n+                        \"{replacement_method_name}(|{second_arg_ident}| {r})\",\n                         r = snippet_with_applicability(cx, right_expr.span, \"EXPR\", &mut applicability),\n                     )\n                 } else {\n                     format!(\n-                        \"{replacement}()\",\n-                        replacement = replacement_method_name,\n+                        \"{replacement_method_name}()\",\n                     )\n                 };\n "}, {"sha": "1966a85f7a7356de70229800e36e5eed18905b2b", "filename": "src/tools/clippy/clippy_lints/src/methods/unnecessary_iter_cloned.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_iter_cloned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_iter_cloned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_iter_cloned.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -68,7 +68,7 @@ pub fn check_for_loop_iter(\n                 cx,\n                 UNNECESSARY_TO_OWNED,\n                 expr.span,\n-                &format!(\"unnecessary use of `{}`\", method_name),\n+                &format!(\"unnecessary use of `{method_name}`\"),\n                 |diag| {\n                     // If `check_into_iter_call_arg` called `check_for_loop_iter` because a call to\n                     // a `to_owned`-like function was removed, then the next suggestion may be"}, {"sha": "0e73459ad65f7a258e91b6ee8ccd5ff50d7d4ded", "filename": "src/tools/clippy/clippy_lints/src/methods/unnecessary_lazy_eval.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::source::snippet;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{eager_or_lazy, usage};\n+use clippy_utils::{eager_or_lazy, is_from_proc_macro, usage};\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n@@ -18,6 +18,10 @@ pub(super) fn check<'tcx>(\n     arg: &'tcx hir::Expr<'_>,\n     simplify_using: &str,\n ) {\n+    if is_from_proc_macro(cx, expr) {\n+        return;\n+    }\n+\n     let is_option = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(recv), sym::Option);\n     let is_result = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(recv), sym::Result);\n     let is_bool = cx.typeck_results().expr_ty(recv).is_bool();\n@@ -58,8 +62,8 @@ pub(super) fn check<'tcx>(\n                     span_lint_and_then(cx, UNNECESSARY_LAZY_EVALUATIONS, expr.span, msg, |diag| {\n                         diag.span_suggestion(\n                             span,\n-                            &format!(\"use `{}(..)` instead\", simplify_using),\n-                            format!(\"{}({})\", simplify_using, snippet(cx, body_expr.span, \"..\")),\n+                            &format!(\"use `{simplify_using}(..)` instead\"),\n+                            format!(\"{simplify_using}({})\", snippet(cx, body_expr.span, \"..\")),\n                             applicability,\n                         );\n                     });"}, {"sha": "9ab0d614114699400375b7073a5dde46c326327c", "filename": "src/tools/clippy/clippy_lints/src/methods/unnecessary_to_owned.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -8,6 +8,7 @@ use clippy_utils::{fn_def_id, get_parent_expr, is_diag_item_method, is_diag_trai\n use clippy_utils::{meets_msrv, msrvs};\n use rustc_errors::Applicability;\n use rustc_hir::{def_id::DefId, BorrowKind, Expr, ExprKind, ItemKind, LangItem, Node};\n+use rustc_hir_analysis::check::{FnCtxt, Inherited};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::LateContext;\n use rustc_middle::mir::Mutability;\n@@ -18,7 +19,6 @@ use rustc_middle::ty::{self, ParamTy, PredicateKind, ProjectionPredicate, TraitP\n use rustc_semver::RustcVersion;\n use rustc_span::{sym, Symbol};\n use rustc_trait_selection::traits::{query::evaluate_obligation::InferCtxtExt as _, Obligation, ObligationCause};\n-use rustc_hir_analysis::check::{FnCtxt, Inherited};\n use std::cmp::max;\n \n use super::UNNECESSARY_TO_OWNED;\n@@ -132,12 +132,11 @@ fn check_addr_of_expr(\n                     cx,\n                     UNNECESSARY_TO_OWNED,\n                     parent.span,\n-                    &format!(\"unnecessary use of `{}`\", method_name),\n+                    &format!(\"unnecessary use of `{method_name}`\"),\n                     \"use\",\n                     format!(\n-                        \"{:&>width$}{}\",\n+                        \"{:&>width$}{receiver_snippet}\",\n                         \"\",\n-                        receiver_snippet,\n                         width = n_target_refs - n_receiver_refs\n                     ),\n                     Applicability::MachineApplicable,\n@@ -154,7 +153,7 @@ fn check_addr_of_expr(\n                             cx,\n                             UNNECESSARY_TO_OWNED,\n                             parent.span,\n-                            &format!(\"unnecessary use of `{}`\", method_name),\n+                            &format!(\"unnecessary use of `{method_name}`\"),\n                             \"use\",\n                             receiver_snippet,\n                             Applicability::MachineApplicable,\n@@ -164,7 +163,7 @@ fn check_addr_of_expr(\n                             cx,\n                             UNNECESSARY_TO_OWNED,\n                             expr.span.with_lo(receiver.span.hi()),\n-                            &format!(\"unnecessary use of `{}`\", method_name),\n+                            &format!(\"unnecessary use of `{method_name}`\"),\n                             \"remove this\",\n                             String::new(),\n                             Applicability::MachineApplicable,\n@@ -181,9 +180,9 @@ fn check_addr_of_expr(\n                         cx,\n                         UNNECESSARY_TO_OWNED,\n                         parent.span,\n-                        &format!(\"unnecessary use of `{}`\", method_name),\n+                        &format!(\"unnecessary use of `{method_name}`\"),\n                         \"use\",\n-                        format!(\"{}.as_ref()\", receiver_snippet),\n+                        format!(\"{receiver_snippet}.as_ref()\"),\n                         Applicability::MachineApplicable,\n                     );\n                     return true;\n@@ -228,9 +227,9 @@ fn check_into_iter_call_arg(\n                 cx,\n                 UNNECESSARY_TO_OWNED,\n                 parent.span,\n-                &format!(\"unnecessary use of `{}`\", method_name),\n+                &format!(\"unnecessary use of `{method_name}`\"),\n                 \"use\",\n-                format!(\"{}.iter().{}()\", receiver_snippet, cloned_or_copied),\n+                format!(\"{receiver_snippet}.iter().{cloned_or_copied}()\"),\n                 Applicability::MaybeIncorrect,\n             );\n             return true;\n@@ -275,9 +274,9 @@ fn check_other_call_arg<'tcx>(\n                 cx,\n                 UNNECESSARY_TO_OWNED,\n                 maybe_arg.span,\n-                &format!(\"unnecessary use of `{}`\", method_name),\n+                &format!(\"unnecessary use of `{method_name}`\"),\n                 \"use\",\n-                format!(\"{:&>width$}{}\", \"\", receiver_snippet, width = n_refs),\n+                format!(\"{:&>n_refs$}{receiver_snippet}\", \"\"),\n                 Applicability::MachineApplicable,\n             );\n             return true;"}, {"sha": "c1139d84e2f47eb1138e475a859b320db610dff2", "filename": "src/tools/clippy/clippy_lints/src/methods/useless_asref.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fuseless_asref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fuseless_asref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fuseless_asref.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -1,19 +1,20 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::walk_ptrs_ty_depth;\n-use clippy_utils::{get_parent_expr, match_trait_method, paths};\n+use clippy_utils::{get_parent_expr, is_trait_method};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n+use rustc_span::sym;\n \n use super::USELESS_ASREF;\n \n /// Checks for the `USELESS_ASREF` lint.\n pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, call_name: &str, recvr: &hir::Expr<'_>) {\n     // when we get here, we've already checked that the call name is \"as_ref\" or \"as_mut\"\n     // check if the call is to the actual `AsRef` or `AsMut` trait\n-    if match_trait_method(cx, expr, &paths::ASREF_TRAIT) || match_trait_method(cx, expr, &paths::ASMUT_TRAIT) {\n+    if is_trait_method(cx, expr, sym::AsRef) || is_trait_method(cx, expr, sym::AsMut) {\n         // check if the type after `as_ref` or `as_mut` is the same as before\n         let rcv_ty = cx.typeck_results().expr_ty(recvr);\n         let res_ty = cx.typeck_results().expr_ty(expr);\n@@ -35,7 +36,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, call_name: &str,\n                 cx,\n                 USELESS_ASREF,\n                 expr.span,\n-                &format!(\"this call to `{}` does nothing\", call_name),\n+                &format!(\"this call to `{call_name}` does nothing\"),\n                 \"try this\",\n                 snippet_with_applicability(cx, recvr.span, \"..\", &mut applicability).to_string(),\n                 applicability,"}, {"sha": "1fbf783b8860e1d701f1801cf9ddf272bad3b288", "filename": "src/tools/clippy/clippy_lints/src/methods/wrong_self_convention.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fwrong_self_convention.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fwrong_self_convention.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fwrong_self_convention.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -61,20 +61,20 @@ impl Convention {\n impl fmt::Display for Convention {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n         match *self {\n-            Self::Eq(this) => format!(\"`{}`\", this).fmt(f),\n-            Self::StartsWith(this) => format!(\"`{}*`\", this).fmt(f),\n-            Self::EndsWith(this) => format!(\"`*{}`\", this).fmt(f),\n-            Self::NotEndsWith(this) => format!(\"`~{}`\", this).fmt(f),\n+            Self::Eq(this) => format!(\"`{this}`\").fmt(f),\n+            Self::StartsWith(this) => format!(\"`{this}*`\").fmt(f),\n+            Self::EndsWith(this) => format!(\"`*{this}`\").fmt(f),\n+            Self::NotEndsWith(this) => format!(\"`~{this}`\").fmt(f),\n             Self::IsSelfTypeCopy(is_true) => {\n                 format!(\"`self` type is{} `Copy`\", if is_true { \"\" } else { \" not\" }).fmt(f)\n             },\n             Self::ImplementsTrait(is_true) => {\n                 let (negation, s_suffix) = if is_true { (\"\", \"s\") } else { (\" does not\", \"\") };\n-                format!(\"method{} implement{} a trait\", negation, s_suffix).fmt(f)\n+                format!(\"method{negation} implement{s_suffix} a trait\").fmt(f)\n             },\n             Self::IsTraitItem(is_true) => {\n                 let suffix = if is_true { \" is\" } else { \" is not\" };\n-                format!(\"method{} a trait item\", suffix).fmt(f)\n+                format!(\"method{suffix} a trait item\").fmt(f)\n             },\n         }\n     }\n@@ -138,8 +138,7 @@ pub(super) fn check<'tcx>(\n                 WRONG_SELF_CONVENTION,\n                 first_arg_span,\n                 &format!(\n-                    \"{} usually take {}\",\n-                    suggestion,\n+                    \"{suggestion} usually take {}\",\n                     &self_kinds\n                         .iter()\n                         .map(|k| k.description())"}, {"sha": "4f967755bfa1975d5781547dd1eaa89569dd1bec", "filename": "src/tools/clippy/clippy_lints/src/minmax.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fminmax.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::consts::{constant_simple, Constant};\n use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::{match_trait_method, paths};\n+use clippy_utils::is_trait_method;\n use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -83,7 +83,7 @@ fn min_max<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<(MinMax, Cons\n             }\n         },\n         ExprKind::MethodCall(path, receiver, args @ [_], _) => {\n-            if cx.typeck_results().expr_ty(receiver).is_floating_point() || match_trait_method(cx, expr, &paths::ORD) {\n+            if cx.typeck_results().expr_ty(receiver).is_floating_point() || is_trait_method(cx, expr, sym::Ord) {\n                 if path.ident.name == sym!(max) {\n                     fetch_const(cx, Some(receiver), args, MinMax::Max)\n                 } else if path.ident.name == sym!(min) {"}, {"sha": "516dee20f8b15f17266ca589927a2631361f7072", "filename": "src/tools/clippy/clippy_lints/src/misc.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -1,7 +1,6 @@\n use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg, span_lint_hir_and_then};\n use clippy_utils::source::{snippet, snippet_opt};\n use if_chain::if_chain;\n-use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::FnKind;\n use rustc_hir::{\n@@ -15,7 +14,7 @@ use rustc_span::hygiene::DesugaringKind;\n use rustc_span::source_map::{ExpnKind, Span};\n \n use clippy_utils::sugg::Sugg;\n-use clippy_utils::{get_parent_expr, in_constant, iter_input_pats, last_path_segment, SpanlessEq};\n+use clippy_utils::{get_parent_expr, in_constant, is_integer_literal, iter_input_pats, last_path_segment, SpanlessEq};\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -178,7 +177,7 @@ impl<'tcx> LateLintPass<'tcx> for MiscLints {\n                     (\"\", sugg_init.addr())\n                 };\n                 let tyopt = if let Some(ty) = local.ty {\n-                    format!(\": &{mutopt}{ty}\", mutopt=mutopt, ty=snippet(cx, ty.span, \"..\"))\n+                    format!(\": &{mutopt}{ty}\", ty=snippet(cx, ty.span, \"..\"))\n                 } else {\n                     String::new()\n                 };\n@@ -195,8 +194,6 @@ impl<'tcx> LateLintPass<'tcx> for MiscLints {\n                             format!(\n                                 \"let {name}{tyopt} = {initref};\",\n                                 name=snippet(cx, name.span, \"..\"),\n-                                tyopt=tyopt,\n-                                initref=initref,\n                             ),\n                             Applicability::MachineApplicable,\n                         );\n@@ -222,8 +219,7 @@ impl<'tcx> LateLintPass<'tcx> for MiscLints {\n                             stmt.span,\n                             \"replace it with\",\n                             format!(\n-                                \"if {} {{ {}; }}\",\n-                                sugg,\n+                                \"if {sugg} {{ {}; }}\",\n                                 &snippet(cx, b.span, \"..\"),\n                             ),\n                             Applicability::MachineApplicable, // snippet\n@@ -275,9 +271,8 @@ impl<'tcx> LateLintPass<'tcx> for MiscLints {\n                 USED_UNDERSCORE_BINDING,\n                 expr.span,\n                 &format!(\n-                    \"used binding `{}` which is prefixed with an underscore. A leading \\\n-                     underscore signals that a binding will not be used\",\n-                    binding\n+                    \"used binding `{binding}` which is prefixed with an underscore. A leading \\\n+                     underscore signals that a binding will not be used\"\n                 ),\n             );\n         }\n@@ -318,8 +313,7 @@ fn non_macro_local(cx: &LateContext<'_>, res: def::Res) -> bool {\n fn check_cast(cx: &LateContext<'_>, span: Span, e: &Expr<'_>, ty: &hir::Ty<'_>) {\n     if_chain! {\n         if let TyKind::Ptr(ref mut_ty) = ty.kind;\n-        if let ExprKind::Lit(ref lit) = e.kind;\n-        if let LitKind::Int(0, _) = lit.node;\n+        if is_integer_literal(e, 0);\n         if !in_constant(cx, e.hir_id);\n         then {\n             let (msg, sugg_fn) = match mut_ty.mutbl {\n@@ -328,12 +322,12 @@ fn check_cast(cx: &LateContext<'_>, span: Span, e: &Expr<'_>, ty: &hir::Ty<'_>)\n             };\n \n             let (sugg, appl) = if let TyKind::Infer = mut_ty.ty.kind {\n-                (format!(\"{}()\", sugg_fn), Applicability::MachineApplicable)\n+                (format!(\"{sugg_fn}()\"), Applicability::MachineApplicable)\n             } else if let Some(mut_ty_snip) = snippet_opt(cx, mut_ty.ty.span) {\n-                (format!(\"{}::<{}>()\", sugg_fn, mut_ty_snip), Applicability::MachineApplicable)\n+                (format!(\"{sugg_fn}::<{mut_ty_snip}>()\"), Applicability::MachineApplicable)\n             } else {\n                 // `MaybeIncorrect` as type inference may not work with the suggested code\n-                (format!(\"{}()\", sugg_fn), Applicability::MaybeIncorrect)\n+                (format!(\"{sugg_fn}()\"), Applicability::MaybeIncorrect)\n             };\n             span_lint_and_sugg(cx, ZERO_PTR, span, msg, \"try\", sugg, appl);\n         }"}, {"sha": "62c6ca32d31a9da1012cb2fc51a73d976273050e", "filename": "src/tools/clippy/clippy_lints/src/misc_early/literal_suffix.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early%2Fliteral_suffix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early%2Fliteral_suffix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early%2Fliteral_suffix.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -18,19 +18,19 @@ pub(super) fn check(cx: &EarlyContext<'_>, lit: &Lit, lit_snip: &str, suffix: &s\n                 cx,\n                 SEPARATED_LITERAL_SUFFIX,\n                 lit.span,\n-                &format!(\"{} type suffix should not be separated by an underscore\", sugg_type),\n+                &format!(\"{sugg_type} type suffix should not be separated by an underscore\"),\n                 \"remove the underscore\",\n-                format!(\"{}{}\", &lit_snip[..maybe_last_sep_idx], suffix),\n+                format!(\"{}{suffix}\", &lit_snip[..maybe_last_sep_idx]),\n                 Applicability::MachineApplicable,\n             );\n         } else {\n             span_lint_and_sugg(\n                 cx,\n                 UNSEPARATED_LITERAL_SUFFIX,\n                 lit.span,\n-                &format!(\"{} type suffix should be separated by an underscore\", sugg_type),\n+                &format!(\"{sugg_type} type suffix should be separated by an underscore\"),\n                 \"add an underscore\",\n-                format!(\"{}_{}\", &lit_snip[..=maybe_last_sep_idx], suffix),\n+                format!(\"{}_{suffix}\", &lit_snip[..=maybe_last_sep_idx]),\n                 Applicability::MachineApplicable,\n             );\n         }"}, {"sha": "c8227ca44505723ea05d174266c2321734d68b3f", "filename": "src/tools/clippy/clippy_lints/src/misc_early/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early%2Fmod.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -357,9 +357,8 @@ impl EarlyLintPass for MiscEarlyLints {\n                             DUPLICATE_UNDERSCORE_ARGUMENT,\n                             *correspondence,\n                             &format!(\n-                                \"`{}` already exists, having another argument having almost the same \\\n-                                 name makes code comprehension and documentation more difficult\",\n-                                arg_name\n+                                \"`{arg_name}` already exists, having another argument having almost the same \\\n+                                 name makes code comprehension and documentation more difficult\"\n                             ),\n                         );\n                     }"}, {"sha": "676e5d40bb776c4723a34b5aaecdbba77422f709", "filename": "src/tools/clippy/clippy_lints/src/misc_early/unneeded_field_pattern.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early%2Funneeded_field_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early%2Funneeded_field_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early%2Funneeded_field_pattern.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -27,7 +27,7 @@ pub(super) fn check(cx: &EarlyContext<'_>, pat: &Pat) {\n                 pat.span,\n                 \"all the struct fields are matched to a wildcard pattern, consider using `..`\",\n                 None,\n-                &format!(\"try with `{} {{ .. }}` instead\", type_name),\n+                &format!(\"try with `{type_name} {{ .. }}` instead\"),\n             );\n             return;\n         }\n@@ -63,7 +63,7 @@ pub(super) fn check(cx: &EarlyContext<'_>, pat: &Pat) {\n                             \"you matched a field with a wildcard pattern, consider using `..` \\\n                              instead\",\n                             None,\n-                            &format!(\"try with `{} {{ {}, .. }}`\", type_name, normal[..].join(\", \")),\n+                            &format!(\"try with `{type_name} {{ {}, .. }}`\", normal[..].join(\", \")),\n                         );\n                     }\n                 }"}, {"sha": "6dd76a6531e496e497cff2f30bf6e0457bfed11c", "filename": "src/tools/clippy/clippy_lints/src/mismatching_type_param_order.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmismatching_type_param_order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmismatching_type_param_order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmismatching_type_param_order.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -91,10 +91,9 @@ impl<'tcx> LateLintPass<'tcx> for TypeParamMismatch {\n                 let type_name = segment.ident;\n                 for (i, (impl_param_name, impl_param_span)) in impl_params.iter().enumerate() {\n                     if mismatch_param_name(i, impl_param_name, &type_param_names_hashmap) {\n-                        let msg = format!(\"`{}` has a similarly named generic type parameter `{}` in its declaration, but in a different order\",\n-                                          type_name, impl_param_name);\n-                        let help = format!(\"try `{}`, or a name that does not conflict with `{}`'s generic params\",\n-                                           type_param_names[i], type_name);\n+                        let msg = format!(\"`{type_name}` has a similarly named generic type parameter `{impl_param_name}` in its declaration, but in a different order\");\n+                        let help = format!(\"try `{}`, or a name that does not conflict with `{type_name}`'s generic params\",\n+                                           type_param_names[i]);\n                         span_lint_and_help(\n                             cx,\n                             MISMATCHING_TYPE_PARAM_ORDER,"}, {"sha": "71cc0d0a81cd2dd8bc909dd8780c79f857b919a0", "filename": "src/tools/clippy/clippy_lints/src/missing_const_for_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_const_for_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_const_for_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_const_for_fn.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -8,12 +8,12 @@ use rustc_hir as hir;\n use rustc_hir::def_id::CRATE_DEF_ID;\n use rustc_hir::intravisit::FnKind;\n use rustc_hir::{Body, Constness, FnDecl, GenericParamKind, HirId};\n+use rustc_hir_analysis::hir_ty_to_ty;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::lint::in_external_macro;\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::Span;\n-use rustc_hir_analysis::hir_ty_to_ty;\n \n declare_clippy_lint! {\n     /// ### What it does"}, {"sha": "b3f1553cfea99c95b436a96d983ebfb8fdeb006d", "filename": "src/tools/clippy/clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_doc.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -103,7 +103,7 @@ impl MissingDoc {\n                 cx,\n                 MISSING_DOCS_IN_PRIVATE_ITEMS,\n                 sp,\n-                &format!(\"missing documentation for {} {}\", article, desc),\n+                &format!(\"missing documentation for {article} {desc}\"),\n             );\n         }\n     }"}, {"sha": "872679f25ab5a777364c7c3ee8a1dfbe1a4d015d", "filename": "src/tools/clippy/clippy_lints/src/missing_enforced_import_rename.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_enforced_import_rename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_enforced_import_rename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_enforced_import_rename.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -58,7 +58,8 @@ impl_lint_pass!(ImportRename => [MISSING_ENFORCED_IMPORT_RENAMES]);\n impl LateLintPass<'_> for ImportRename {\n     fn check_crate(&mut self, cx: &LateContext<'_>) {\n         for Rename { path, rename } in &self.conf_renames {\n-            if let Res::Def(_, id) = clippy_utils::def_path_res(cx, &path.split(\"::\").collect::<Vec<_>>()) {\n+            let segs = path.split(\"::\").collect::<Vec<_>>();\n+            if let Res::Def(_, id) = clippy_utils::def_path_res(cx, &segs, None) {\n                 self.renames.insert(id, Symbol::intern(rename));\n             }\n         }\n@@ -90,9 +91,7 @@ impl LateLintPass<'_> for ImportRename {\n                     \"this import should be renamed\",\n                     \"try\",\n                     format!(\n-                        \"{} as {}\",\n-                        import,\n-                        name,\n+                        \"{import} as {name}\",\n                     ),\n                     Applicability::MachineApplicable,\n                 );"}, {"sha": "655df5419ac640b87897c0fccf3b10787250c4d3", "filename": "src/tools/clippy/clippy_lints/src/missing_inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -65,7 +65,7 @@ fn check_missing_inline_attrs(cx: &LateContext<'_>, attrs: &[ast::Attribute], sp\n             cx,\n             MISSING_INLINE_IN_PUBLIC_ITEMS,\n             sp,\n-            &format!(\"missing `#[inline]` for {}\", desc),\n+            &format!(\"missing `#[inline]` for {desc}\"),\n         );\n     }\n }"}, {"sha": "0742943dff2b90cd2576ffde21239e7ec9ea1500", "filename": "src/tools/clippy/clippy_lints/src/module_style.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmodule_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmodule_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmodule_style.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -118,13 +118,7 @@ impl EarlyLintPass for ModStyle {\n                         SELF_NAMED_MODULE_FILES,\n                         Span::new(file.start_pos, file.start_pos, SyntaxContext::root(), None),\n                         format!(\"`mod.rs` files are required, found `{}`\", path.display()),\n-                        |lint| {\n-                            lint.help(format!(\n-                                \"move `{}` to `{}`\",\n-                                path.display(),\n-                                correct.display(),\n-                            ))\n-                        },\n+                        |lint| lint.help(format!(\"move `{}` to `{}`\", path.display(), correct.display(),)),\n                     );\n                 }\n             }"}, {"sha": "4547ed7eafc861925fb142320d3624a62c99dbc3", "filename": "src/tools/clippy/clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_reference.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -87,7 +87,7 @@ fn check_arguments<'tcx>(\n                                 cx,\n                                 UNNECESSARY_MUT_PASSED,\n                                 argument.span,\n-                                &format!(\"the {} `{}` doesn't need a mutable reference\", fn_kind, name),\n+                                &format!(\"the {fn_kind} `{name}` doesn't need a mutable reference\"),\n                             );\n                         }\n                     },"}, {"sha": "d8647a9910585a1c69aeb1503f5878cd331f7f31", "filename": "src/tools/clippy/clippy_lints/src/mutable_debug_assertion.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmutable_debug_assertion.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -56,10 +56,7 @@ impl<'tcx> LateLintPass<'tcx> for DebugAssertWithMutCall {\n                     cx,\n                     DEBUG_ASSERT_WITH_MUT_CALL,\n                     span,\n-                    &format!(\n-                        \"do not call a function with mutable arguments inside of `{}!`\",\n-                        macro_name\n-                    ),\n+                    &format!(\"do not call a function with mutable arguments inside of `{macro_name}!`\"),\n                 );\n             }\n         }"}, {"sha": "09cb53331763d04f5188d36089dee85f1e360b77", "filename": "src/tools/clippy/clippy_lints/src/mutex_atomic.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmutex_atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmutex_atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmutex_atomic.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -84,9 +84,8 @@ impl<'tcx> LateLintPass<'tcx> for Mutex {\n                 let mutex_param = subst.type_at(0);\n                 if let Some(atomic_name) = get_atomic_name(mutex_param) {\n                     let msg = format!(\n-                        \"consider using an `{}` instead of a `Mutex` here; if you just want the locking \\\n-                         behavior and not the internal type, consider using `Mutex<()>`\",\n-                        atomic_name\n+                        \"consider using an `{atomic_name}` instead of a `Mutex` here; if you just want the locking \\\n+                         behavior and not the internal type, consider using `Mutex<()>`\"\n                     );\n                     match *mutex_param.kind() {\n                         ty::Uint(t) if t != ty::UintTy::Usize => span_lint(cx, MUTEX_INTEGER, expr.span, &msg),"}, {"sha": "10c3ff026b6d66100b3bee5a9b27d7c25799c184", "filename": "src/tools/clippy/clippy_lints/src/needless_borrowed_ref.rs", "status": "modified", "additions": 79, "deletions": 42, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -1,43 +1,31 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::source::snippet_with_applicability;\n-use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{BindingAnnotation, Mutability, Node, Pat, PatKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n declare_clippy_lint! {\n     /// ### What it does\n-    /// Checks for bindings that destructure a reference and borrow the inner\n+    /// Checks for bindings that needlessly destructure a reference and borrow the inner\n     /// value with `&ref`.\n     ///\n     /// ### Why is this bad?\n     /// This pattern has no effect in almost all cases.\n     ///\n-    /// ### Known problems\n-    /// In some cases, `&ref` is needed to avoid a lifetime mismatch error.\n-    /// Example:\n-    /// ```rust\n-    /// fn foo(a: &Option<String>, b: &Option<String>) {\n-    ///     match (a, b) {\n-    ///         (None, &ref c) | (&ref c, None) => (),\n-    ///         (&Some(ref c), _) => (),\n-    ///     };\n-    /// }\n-    /// ```\n-    ///\n     /// ### Example\n     /// ```rust\n     /// let mut v = Vec::<String>::new();\n-    /// # #[allow(unused)]\n     /// v.iter_mut().filter(|&ref a| a.is_empty());\n+    ///\n+    /// if let &[ref first, ref second] = v.as_slice() {}\n     /// ```\n     ///\n     /// Use instead:\n     /// ```rust\n     /// let mut v = Vec::<String>::new();\n-    /// # #[allow(unused)]\n     /// v.iter_mut().filter(|a| a.is_empty());\n+    ///\n+    /// if let [first, second] = v.as_slice() {}\n     /// ```\n     #[clippy::version = \"pre 1.29.0\"]\n     pub NEEDLESS_BORROWED_REFERENCE,\n@@ -54,34 +42,83 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBorrowedRef {\n             return;\n         }\n \n-        if_chain! {\n-            // Only lint immutable refs, because `&mut ref T` may be useful.\n-            if let PatKind::Ref(sub_pat, Mutability::Not) = pat.kind;\n+        // Do not lint patterns that are part of an OR `|` pattern, the binding mode must match in all arms\n+        for (_, node) in cx.tcx.hir().parent_iter(pat.hir_id) {\n+            let Node::Pat(pat) = node else { break };\n+\n+            if matches!(pat.kind, PatKind::Or(_)) {\n+                return;\n+            }\n+        }\n+\n+        // Only lint immutable refs, because `&mut ref T` may be useful.\n+        let PatKind::Ref(sub_pat, Mutability::Not) = pat.kind else { return };\n \n+        match sub_pat.kind {\n             // Check sub_pat got a `ref` keyword (excluding `ref mut`).\n-            if let PatKind::Binding(BindingAnnotation::REF, .., spanned_name, _) = sub_pat.kind;\n-            let parent_id = cx.tcx.hir().get_parent_node(pat.hir_id);\n-            if let Some(parent_node) = cx.tcx.hir().find(parent_id);\n-            then {\n-                // do not recurse within patterns, as they may have other references\n-                // XXXManishearth we can relax this constraint if we only check patterns\n-                // with a single ref pattern inside them\n-                if let Node::Pat(_) = parent_node {\n-                    return;\n+            PatKind::Binding(BindingAnnotation::REF, _, ident, None) => {\n+                span_lint_and_then(\n+                    cx,\n+                    NEEDLESS_BORROWED_REFERENCE,\n+                    pat.span,\n+                    \"this pattern takes a reference on something that is being dereferenced\",\n+                    |diag| {\n+                        // `&ref ident`\n+                        //  ^^^^^\n+                        let span = pat.span.until(ident.span);\n+                        diag.span_suggestion_verbose(\n+                            span,\n+                            \"try removing the `&ref` part\",\n+                            String::new(),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    },\n+                );\n+            },\n+            // Slices where each element is `ref`: `&[ref a, ref b, ..., ref z]`\n+            PatKind::Slice(\n+                before,\n+                None\n+                | Some(Pat {\n+                    kind: PatKind::Wild, ..\n+                }),\n+                after,\n+            ) => {\n+                let mut suggestions = Vec::new();\n+\n+                for element_pat in itertools::chain(before, after) {\n+                    if let PatKind::Binding(BindingAnnotation::REF, _, ident, None) = element_pat.kind {\n+                        // `&[..., ref ident, ...]`\n+                        //         ^^^^\n+                        let span = element_pat.span.until(ident.span);\n+                        suggestions.push((span, String::new()));\n+                    } else {\n+                        return;\n+                    }\n                 }\n-                let mut applicability = Applicability::MachineApplicable;\n-                span_lint_and_then(cx, NEEDLESS_BORROWED_REFERENCE, pat.span,\n-                                   \"this pattern takes a reference on something that is being de-referenced\",\n-                                   |diag| {\n-                                       let hint = snippet_with_applicability(cx, spanned_name.span, \"..\", &mut applicability).into_owned();\n-                                       diag.span_suggestion(\n-                                           pat.span,\n-                                           \"try removing the `&ref` part and just keep\",\n-                                           hint,\n-                                           applicability,\n-                                       );\n-                                   });\n-            }\n+\n+                if !suggestions.is_empty() {\n+                    span_lint_and_then(\n+                        cx,\n+                        NEEDLESS_BORROWED_REFERENCE,\n+                        pat.span,\n+                        \"dereferencing a slice pattern where every element takes a reference\",\n+                        |diag| {\n+                            // `&[...]`\n+                            //  ^\n+                            let span = pat.span.until(sub_pat.span);\n+                            suggestions.push((span, String::new()));\n+\n+                            diag.multipart_suggestion(\n+                                \"try removing the `&` and `ref` parts\",\n+                                suggestions,\n+                                Applicability::MachineApplicable,\n+                            );\n+                        },\n+                    );\n+                }\n+            },\n+            _ => {},\n         }\n     }\n }"}, {"sha": "6f0e755466e5a4524099df8f37f6954fddbd8ab3", "filename": "src/tools/clippy/clippy_lints/src/needless_continue.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_continue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_continue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_continue.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -309,7 +309,7 @@ fn emit_warning<'a>(cx: &EarlyContext<'_>, data: &'a LintData<'_>, header: &str,\n         expr.span,\n         message,\n         None,\n-        &format!(\"{}\\n{}\", header, snip),\n+        &format!(\"{header}\\n{snip}\"),\n     );\n }\n \n@@ -322,10 +322,7 @@ fn suggestion_snippet_for_continue_inside_if<'a>(cx: &EarlyContext<'_>, data: &'\n \n     let indent_if = indent_of(cx, data.if_expr.span).unwrap_or(0);\n     format!(\n-        \"{indent}if {} {}\\n{indent}{}\",\n-        cond_code,\n-        continue_code,\n-        else_code,\n+        \"{indent}if {cond_code} {continue_code}\\n{indent}{else_code}\",\n         indent = \" \".repeat(indent_if),\n     )\n }\n@@ -349,7 +346,7 @@ fn suggestion_snippet_for_continue_inside_else<'a>(cx: &EarlyContext<'_>, data:\n             let span = cx.sess().source_map().stmt_span(stmt.span, data.loop_block.span);\n             let snip = snippet_block(cx, span, \"..\", None).into_owned();\n             snip.lines()\n-                .map(|line| format!(\"{}{}\", \" \".repeat(indent), line))\n+                .map(|line| format!(\"{}{line}\", \" \".repeat(indent)))\n                 .collect::<Vec<_>>()\n                 .join(\"\\n\")\n         })\n@@ -358,10 +355,7 @@ fn suggestion_snippet_for_continue_inside_else<'a>(cx: &EarlyContext<'_>, data:\n \n     let indent_if = indent_of(cx, data.if_expr.span).unwrap_or(0);\n     format!(\n-        \"{indent_if}if {} {}\\n{indent}// merged code follows:\\n{}\\n{indent_if}}}\",\n-        cond_code,\n-        block_code,\n-        to_annex,\n+        \"{indent_if}if {cond_code} {block_code}\\n{indent}// merged code follows:\\n{to_annex}\\n{indent_if}}}\",\n         indent = \" \".repeat(indent),\n         indent_if = \" \".repeat(indent_if),\n     )"}, {"sha": "9d26e5900866c85ef55e1b0bad608ca8272177a3", "filename": "src/tools/clippy/clippy_lints/src/needless_late_init.rs", "status": "modified", "additions": 19, "deletions": 25, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_late_init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_late_init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_late_init.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -2,9 +2,9 @@ use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::path_to_local;\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::needs_ordered_drop;\n-use clippy_utils::visitors::{expr_visitor, expr_visitor_no_bodies, is_local_used};\n+use clippy_utils::visitors::{for_each_expr, for_each_expr_with_closures, is_local_used};\n+use core::ops::ControlFlow;\n use rustc_errors::{Applicability, MultiSpan};\n-use rustc_hir::intravisit::Visitor;\n use rustc_hir::{\n     BindingAnnotation, Block, Expr, ExprKind, HirId, Local, LocalSource, MatchSource, Node, Pat, PatKind, Stmt,\n     StmtKind,\n@@ -64,31 +64,25 @@ declare_clippy_lint! {\n declare_lint_pass!(NeedlessLateInit => [NEEDLESS_LATE_INIT]);\n \n fn contains_assign_expr<'tcx>(cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'tcx>) -> bool {\n-    let mut seen = false;\n-    expr_visitor(cx, |expr| {\n-        if let ExprKind::Assign(..) = expr.kind {\n-            seen = true;\n+    for_each_expr_with_closures(cx, stmt, |e| {\n+        if matches!(e.kind, ExprKind::Assign(..)) {\n+            ControlFlow::Break(())\n+        } else {\n+            ControlFlow::Continue(())\n         }\n-\n-        !seen\n     })\n-    .visit_stmt(stmt);\n-\n-    seen\n+    .is_some()\n }\n \n fn contains_let(cond: &Expr<'_>) -> bool {\n-    let mut seen = false;\n-    expr_visitor_no_bodies(|expr| {\n-        if let ExprKind::Let(_) = expr.kind {\n-            seen = true;\n+    for_each_expr(cond, |e| {\n+        if matches!(e.kind, ExprKind::Let(_)) {\n+            ControlFlow::Break(())\n+        } else {\n+            ControlFlow::Continue(())\n         }\n-\n-        !seen\n     })\n-    .visit_expr(cond);\n-\n-    seen\n+    .is_some()\n }\n \n fn stmt_needs_ordered_drop(cx: &LateContext<'_>, stmt: &Stmt<'_>) -> bool {\n@@ -287,7 +281,7 @@ fn check<'tcx>(\n \n                     diag.span_suggestion(\n                         assign.lhs_span,\n-                        &format!(\"declare `{}` here\", binding_name),\n+                        &format!(\"declare `{binding_name}` here\"),\n                         let_snippet,\n                         Applicability::MachineApplicable,\n                     );\n@@ -307,8 +301,8 @@ fn check<'tcx>(\n \n                     diag.span_suggestion_verbose(\n                         usage.stmt.span.shrink_to_lo(),\n-                        &format!(\"declare `{}` here\", binding_name),\n-                        format!(\"{} = \", let_snippet),\n+                        &format!(\"declare `{binding_name}` here\"),\n+                        format!(\"{let_snippet} = \"),\n                         applicability,\n                     );\n \n@@ -338,8 +332,8 @@ fn check<'tcx>(\n \n                     diag.span_suggestion_verbose(\n                         usage.stmt.span.shrink_to_lo(),\n-                        &format!(\"declare `{}` here\", binding_name),\n-                        format!(\"{} = \", let_snippet),\n+                        &format!(\"declare `{binding_name}` here\"),\n+                        format!(\"{let_snippet} = \"),\n                         applicability,\n                     );\n "}, {"sha": "178c973981b1b5da2f4e15e198cad7c9c6c1f075", "filename": "src/tools/clippy/clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -12,17 +12,17 @@ use rustc_hir::{\n     BindingAnnotation, Body, FnDecl, GenericArg, HirId, Impl, ItemKind, Mutability, Node, PatKind, QPath, TyKind,\n };\n use rustc_hir::{HirIdMap, HirIdSet};\n+use rustc_hir_analysis::expr_use_visitor as euv;\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::mir::FakeReadCause;\n use rustc_middle::ty::{self, TypeVisitable};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::symbol::kw;\n-use rustc_span::{sym, Span};\n+use rustc_span::{sym, Span, DUMMY_SP};\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits;\n use rustc_trait_selection::traits::misc::can_type_implement_copy;\n-use rustc_hir_analysis::expr_use_visitor as euv;\n use std::borrow::Cow;\n \n declare_clippy_lint! {\n@@ -186,6 +186,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n                 if !is_self(arg);\n                 if !ty.is_mutable_ptr();\n                 if !is_copy(cx, ty);\n+                if ty.is_sized(cx.tcx.at(DUMMY_SP), cx.param_env);\n                 if !allowed_traits.iter().any(|&t| implements_trait(cx, ty, t, &[]));\n                 if !implements_borrow_trait;\n                 if !all_borrowable_trait;\n@@ -236,7 +237,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n                                         snippet_opt(cx, span)\n                                             .map_or(\n                                                 \"change the call to\".into(),\n-                                                |x| Cow::from(format!(\"change `{}` to\", x)),\n+                                                |x| Cow::from(format!(\"change `{x}` to\")),\n                                             )\n                                             .as_ref(),\n                                         suggestion,\n@@ -266,7 +267,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n                                         snippet_opt(cx, span)\n                                             .map_or(\n                                                 \"change the call to\".into(),\n-                                                |x| Cow::from(format!(\"change `{}` to\", x))\n+                                                |x| Cow::from(format!(\"change `{x}` to\"))\n                                             )\n                                             .as_ref(),\n                                         suggestion,\n@@ -341,5 +342,11 @@ impl<'tcx> euv::Delegate<'tcx> for MovedVariablesCtxt {\n \n     fn mutate(&mut self, _: &euv::PlaceWithHirId<'tcx>, _: HirId) {}\n \n-    fn fake_read(&mut self, _: &rustc_hir_analysis::expr_use_visitor::PlaceWithHirId<'tcx>, _: FakeReadCause, _: HirId) {}\n+    fn fake_read(\n+        &mut self,\n+        _: &rustc_hir_analysis::expr_use_visitor::PlaceWithHirId<'tcx>,\n+        _: FakeReadCause,\n+        _: HirId,\n+    ) {\n+    }\n }"}, {"sha": "97c8cfbd3eb7a195cda0aa3b4a1caa7ffdfcde40", "filename": "src/tools/clippy/clippy_lints/src/needless_question_mark.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_question_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_question_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_question_mark.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -1,11 +1,12 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::is_lang_ctor;\n+use clippy_utils::path_res;\n use clippy_utils::source::snippet;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::LangItem::{OptionSome, ResultOk};\n+use rustc_hir::def::{DefKind, Res};\n use rustc_hir::{AsyncGeneratorKind, Block, Body, Expr, ExprKind, GeneratorKind, LangItem, MatchSource, QPath};\n use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::DefIdTree;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n declare_clippy_lint! {\n@@ -112,11 +113,12 @@ impl LateLintPass<'_> for NeedlessQuestionMark {\n \n fn check(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if_chain! {\n-        if let ExprKind::Call(path, [arg]) = &expr.kind;\n-        if let ExprKind::Path(ref qpath) = &path.kind;\n-        let sugg_remove = if is_lang_ctor(cx, qpath, OptionSome) {\n+        if let ExprKind::Call(path, [arg]) = expr.kind;\n+        if let Res::Def(DefKind::Ctor(..), ctor_id) = path_res(cx, path);\n+        if let Some(variant_id) = cx.tcx.opt_parent(ctor_id);\n+        let sugg_remove = if cx.tcx.lang_items().option_some_variant() == Some(variant_id) {\n             \"Some()\"\n-        } else if is_lang_ctor(cx, qpath, ResultOk) {\n+        } else if cx.tcx.lang_items().result_ok_variant() == Some(variant_id) {\n             \"Ok()\"\n         } else {\n             return;\n@@ -134,7 +136,7 @@ fn check(cx: &LateContext<'_>, expr: &Expr<'_>) {\n                 NEEDLESS_QUESTION_MARK,\n                 expr.span,\n                 \"question mark operator is useless here\",\n-                &format!(\"try removing question mark and `{}`\", sugg_remove),\n+                &format!(\"try removing question mark and `{sugg_remove}`\"),\n                 format!(\"{}\", snippet(cx, inner_expr.span, r#\"\"...\"\"#)),\n                 Applicability::MachineApplicable,\n             );"}, {"sha": "fb9a4abd0b4b03e4128c08107a57333b9949c044", "filename": "src/tools/clippy/clippy_lints/src/neg_multiply.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneg_multiply.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneg_multiply.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneg_multiply.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -62,9 +62,9 @@ fn check_mul(cx: &LateContext<'_>, span: Span, lit: &Expr<'_>, exp: &Expr<'_>) {\n             let mut applicability = Applicability::MachineApplicable;\n             let snip = snippet_with_applicability(cx, exp.span, \"..\", &mut applicability);\n             let suggestion = if exp.precedence().order() < PREC_PREFIX && !has_enclosing_paren(&snip) {\n-                format!(\"-({})\", snip)\n+                format!(\"-({snip})\")\n             } else {\n-                format!(\"-{}\", snip)\n+                format!(\"-{snip}\")\n             };\n             span_lint_and_sugg(\n                     cx,"}, {"sha": "6017117e1eccf7c15a7773aea4e999d5e536635c", "filename": "src/tools/clippy/clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -136,8 +136,7 @@ impl<'tcx> LateLintPass<'tcx> for NewWithoutDefault {\n                                     id,\n                                     impl_item.span,\n                                     &format!(\n-                                        \"you should consider adding a `Default` implementation for `{}`\",\n-                                        self_type_snip\n+                                        \"you should consider adding a `Default` implementation for `{self_type_snip}`\"\n                                     ),\n                                     |diag| {\n                                         diag.suggest_prepend_item(\n@@ -161,9 +160,9 @@ impl<'tcx> LateLintPass<'tcx> for NewWithoutDefault {\n fn create_new_without_default_suggest_msg(self_type_snip: &str, generics_sugg: &str) -> String {\n     #[rustfmt::skip]\n     format!(\n-\"impl{} Default for {} {{\n+\"impl{generics_sugg} Default for {self_type_snip} {{\n     fn default() -> Self {{\n         Self::new()\n     }}\n-}}\", generics_sugg, self_type_snip)\n+}}\")\n }"}, {"sha": "2c839d029c6f7a5bd482145e1cc5257af862e76b", "filename": "src/tools/clippy/clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -13,14 +13,14 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::{\n     BodyId, Expr, ExprKind, HirId, Impl, ImplItem, ImplItemKind, Item, ItemKind, Node, TraitItem, TraitItemKind, UnOp,\n };\n+use rustc_hir_analysis::hir_ty_to_ty;\n use rustc_lint::{LateContext, LateLintPass, Lint};\n use rustc_middle::mir;\n use rustc_middle::mir::interpret::{ConstValue, ErrorHandled};\n use rustc_middle::ty::adjustment::Adjust;\n use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{sym, InnerSpan, Span, DUMMY_SP};\n-use rustc_hir_analysis::hir_ty_to_ty;\n \n // FIXME: this is a correctness problem but there's no suitable\n // warn-by-default category.\n@@ -149,6 +149,9 @@ fn is_value_unfrozen_raw<'tcx>(\n             // the fact that we have to dig into every structs to search enums\n             // leads us to the point checking `UnsafeCell` directly is the only option.\n             ty::Adt(ty_def, ..) if ty_def.is_unsafe_cell() => true,\n+            // As of 2022-09-08 miri doesn't track which union field is active so there's no safe way to check the\n+            // contained value.\n+            ty::Adt(def, ..) if def.is_union() => false,\n             ty::Array(..) | ty::Adt(..) | ty::Tuple(..) => {\n                 let val = cx.tcx.destructure_mir_constant(cx.param_env, val);\n                 val.fields.iter().any(|field| inner(cx, *field))"}, {"sha": "9f6917c146f633d6fb58279644ee7e626fe624f0", "filename": "src/tools/clippy/clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -112,10 +112,7 @@ impl<'a, 'tcx> SimilarNamesLocalVisitor<'a, 'tcx> {\n                 self.cx,\n                 MANY_SINGLE_CHAR_NAMES,\n                 span,\n-                &format!(\n-                    \"{} bindings with single-character names in scope\",\n-                    num_single_char_names\n-                ),\n+                &format!(\"{num_single_char_names} bindings with single-character names in scope\"),\n             );\n         }\n     }"}, {"sha": "1a765b14892f6fccba6e1f6b4a2c0ca52435e6f2", "filename": "src/tools/clippy/clippy_lints/src/non_octal_unix_permissions.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_octal_unix_permissions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_octal_unix_permissions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_octal_unix_permissions.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -1,12 +1,13 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::{snippet_opt, snippet_with_applicability};\n-use clippy_utils::ty::match_type;\n+use clippy_utils::ty::{is_type_diagnostic_item, match_type};\n use clippy_utils::{match_def_path, paths};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -49,7 +50,7 @@ impl<'tcx> LateLintPass<'tcx> for NonOctalUnixPermissions {\n                 if_chain! {\n                     if (path.ident.name == sym!(mode)\n                         && (match_type(cx, obj_ty, &paths::OPEN_OPTIONS)\n-                            || match_type(cx, obj_ty, &paths::DIR_BUILDER)))\n+                            || is_type_diagnostic_item(cx, obj_ty, sym::DirBuilder)))\n                         || (path.ident.name == sym!(set_mode) && match_type(cx, obj_ty, &paths::PERMISSIONS));\n                     if let ExprKind::Lit(_) = param.kind;\n "}, {"sha": "0ca0befc13515e92f16c59e871215ce4c815ff90", "filename": "src/tools/clippy/clippy_lints/src/nonstandard_macro_braces.rs", "status": "modified", "additions": 35, "deletions": 44, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnonstandard_macro_braces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnonstandard_macro_braces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnonstandard_macro_braces.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -3,16 +3,17 @@ use std::{\n     hash::{Hash, Hasher},\n };\n \n-use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_opt;\n use if_chain::if_chain;\n use rustc_ast::ast;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_errors::Applicability;\n use rustc_hir::def_id::DefId;\n use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::hygiene::{ExpnKind, MacroKind};\n-use rustc_span::{Span, Symbol};\n+use rustc_span::Span;\n use serde::{de, Deserialize};\n \n declare_clippy_lint! {\n@@ -39,8 +40,8 @@ declare_clippy_lint! {\n \n const BRACES: &[(&str, &str)] = &[(\"(\", \")\"), (\"{\", \"}\"), (\"[\", \"]\")];\n \n-/// The (name, (open brace, close brace), source snippet)\n-type MacroInfo<'a> = (Symbol, &'a (String, String), String);\n+/// The (callsite span, (open brace, close brace), source snippet)\n+type MacroInfo<'a> = (Span, &'a (String, String), String);\n \n #[derive(Clone, Debug, Default)]\n pub struct MacroBraces {\n@@ -62,33 +63,29 @@ impl_lint_pass!(MacroBraces => [NONSTANDARD_MACRO_BRACES]);\n \n impl EarlyLintPass for MacroBraces {\n     fn check_item(&mut self, cx: &EarlyContext<'_>, item: &ast::Item) {\n-        if let Some((name, braces, snip)) = is_offending_macro(cx, item.span, self) {\n-            let span = item.span.ctxt().outer_expn_data().call_site;\n-            emit_help(cx, snip, braces, name, span);\n+        if let Some((span, braces, snip)) = is_offending_macro(cx, item.span, self) {\n+            emit_help(cx, &snip, braces, span);\n             self.done.insert(span);\n         }\n     }\n \n     fn check_stmt(&mut self, cx: &EarlyContext<'_>, stmt: &ast::Stmt) {\n-        if let Some((name, braces, snip)) = is_offending_macro(cx, stmt.span, self) {\n-            let span = stmt.span.ctxt().outer_expn_data().call_site;\n-            emit_help(cx, snip, braces, name, span);\n+        if let Some((span, braces, snip)) = is_offending_macro(cx, stmt.span, self) {\n+            emit_help(cx, &snip, braces, span);\n             self.done.insert(span);\n         }\n     }\n \n     fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &ast::Expr) {\n-        if let Some((name, braces, snip)) = is_offending_macro(cx, expr.span, self) {\n-            let span = expr.span.ctxt().outer_expn_data().call_site;\n-            emit_help(cx, snip, braces, name, span);\n+        if let Some((span, braces, snip)) = is_offending_macro(cx, expr.span, self) {\n+            emit_help(cx, &snip, braces, span);\n             self.done.insert(span);\n         }\n     }\n \n     fn check_ty(&mut self, cx: &EarlyContext<'_>, ty: &ast::Ty) {\n-        if let Some((name, braces, snip)) = is_offending_macro(cx, ty.span, self) {\n-            let span = ty.span.ctxt().outer_expn_data().call_site;\n-            emit_help(cx, snip, braces, name, span);\n+        if let Some((span, braces, snip)) = is_offending_macro(cx, ty.span, self) {\n+            emit_help(cx, &snip, braces, span);\n             self.done.insert(span);\n         }\n     }\n@@ -102,48 +99,44 @@ fn is_offending_macro<'a>(cx: &EarlyContext<'_>, span: Span, mac_braces: &'a Mac\n                 .last()\n                 .map_or(false, |e| e.macro_def_id.map_or(false, DefId::is_local))\n     };\n+    let span_call_site = span.ctxt().outer_expn_data().call_site;\n     if_chain! {\n         if let ExpnKind::Macro(MacroKind::Bang, mac_name) = span.ctxt().outer_expn_data().kind;\n         let name = mac_name.as_str();\n         if let Some(braces) = mac_braces.macro_braces.get(name);\n-        if let Some(snip) = snippet_opt(cx, span.ctxt().outer_expn_data().call_site);\n+        if let Some(snip) = snippet_opt(cx, span_call_site);\n         // we must check only invocation sites\n         // https://github.com/rust-lang/rust-clippy/issues/7422\n-        if snip.starts_with(&format!(\"{}!\", name));\n+        if snip.starts_with(&format!(\"{name}!\"));\n         if unnested_or_local();\n         // make formatting consistent\n         let c = snip.replace(' ', \"\");\n-        if !c.starts_with(&format!(\"{}!{}\", name, braces.0));\n-        if !mac_braces.done.contains(&span.ctxt().outer_expn_data().call_site);\n+        if !c.starts_with(&format!(\"{name}!{}\", braces.0));\n+        if !mac_braces.done.contains(&span_call_site);\n         then {\n-            Some((mac_name, braces, snip))\n+            Some((span_call_site, braces, snip))\n         } else {\n             None\n         }\n     }\n }\n \n-fn emit_help(cx: &EarlyContext<'_>, snip: String, braces: &(String, String), name: Symbol, span: Span) {\n-    let with_space = &format!(\"! {}\", braces.0);\n-    let without_space = &format!(\"!{}\", braces.0);\n-    let mut help = snip;\n-    for b in BRACES.iter().filter(|b| b.0 != braces.0) {\n-        help = help.replace(b.0, &braces.0).replace(b.1, &braces.1);\n-        // Only `{` traditionally has space before the brace\n-        if braces.0 != \"{\" && help.contains(with_space) {\n-            help = help.replace(with_space, without_space);\n-        } else if braces.0 == \"{\" && help.contains(without_space) {\n-            help = help.replace(without_space, with_space);\n-        }\n+fn emit_help(cx: &EarlyContext<'_>, snip: &str, braces: &(String, String), span: Span) {\n+    if let Some((macro_name, macro_args_str)) = snip.split_once('!') {\n+        let mut macro_args = macro_args_str.trim().to_string();\n+        // now remove the wrong braces\n+        macro_args.remove(0);\n+        macro_args.pop();\n+        span_lint_and_sugg(\n+            cx,\n+            NONSTANDARD_MACRO_BRACES,\n+            span,\n+            &format!(\"use of irregular braces for `{macro_name}!` macro\"),\n+            \"consider writing\",\n+            format!(\"{macro_name}!{}{macro_args}{}\", braces.0, braces.1),\n+            Applicability::MachineApplicable,\n+        );\n     }\n-    span_lint_and_help(\n-        cx,\n-        NONSTANDARD_MACRO_BRACES,\n-        span,\n-        &format!(\"use of irregular braces for `{}!` macro\", name),\n-        Some(span),\n-        &format!(\"consider writing `{}`\", help),\n-    );\n }\n \n fn macro_braces(conf: FxHashSet<MacroMatcher>) -> FxHashMap<String, (String, String)> {\n@@ -273,9 +266,7 @@ impl<'de> Deserialize<'de> for MacroMatcher {\n                         .iter()\n                         .find(|b| b.0 == brace)\n                         .map(|(o, c)| ((*o).to_owned(), (*c).to_owned()))\n-                        .ok_or_else(|| {\n-                            de::Error::custom(&format!(\"expected one of `(`, `{{`, `[` found `{}`\", brace))\n-                        })?,\n+                        .ok_or_else(|| de::Error::custom(&format!(\"expected one of `(`, `{{`, `[` found `{brace}`\")))?,\n                 })\n             }\n         }"}, {"sha": "f380a5065827d04e2730f62b6398cef13c756d09", "filename": "src/tools/clippy/clippy_lints/src/octal_escapes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foctal_escapes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foctal_escapes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foctal_escapes.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -102,7 +102,7 @@ fn check_lit(cx: &EarlyContext<'_>, lit: &Lit, span: Span, is_string: bool) {\n         // construct a replacement escape\n         // the maximum value is \\077, or \\x3f, so u8 is sufficient here\n         if let Ok(n) = u8::from_str_radix(&contents[from + 1..to], 8) {\n-            write!(suggest_1, \"\\\\x{:02x}\", n).unwrap();\n+            write!(suggest_1, \"\\\\x{n:02x}\").unwrap();\n         }\n \n         // append the null byte as \\x00 and the following digits literally"}, {"sha": "d29ca37eaeb809a2c27ec9aadfd9714966d96cba", "filename": "src/tools/clippy/clippy_lints/src/operators/absurd_extreme_comparisons.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fabsurd_extreme_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fabsurd_extreme_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fabsurd_extreme_comparisons.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -34,13 +34,12 @@ pub(super) fn check<'tcx>(\n         };\n \n         let help = format!(\n-            \"because `{}` is the {} value for this type, {}\",\n+            \"because `{}` is the {} value for this type, {conclusion}\",\n             snippet(cx, culprit.expr.span, \"x\"),\n             match culprit.which {\n                 ExtremeType::Minimum => \"minimum\",\n                 ExtremeType::Maximum => \"maximum\",\n-            },\n-            conclusion\n+            }\n         );\n \n         span_lint_and_help(cx, ABSURD_EXTREME_COMPARISONS, expr.span, msg, None, &help);"}, {"sha": "8827daaa3ee7c37760d54ad43ada2dc2d369c83d", "filename": "src/tools/clippy/clippy_lints/src/operators/arithmetic_side_effects.rs", "status": "modified", "additions": 68, "deletions": 52, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Farithmetic_side_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Farithmetic_side_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Farithmetic_side_effects.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -1,8 +1,3 @@\n-#![allow(\n-    // False positive\n-    clippy::match_same_arms\n-)]\n-\n use super::ARITHMETIC_SIDE_EFFECTS;\n use clippy_utils::{consts::constant_simple, diagnostics::span_lint};\n use rustc_ast as ast;\n@@ -14,11 +9,12 @@ use rustc_session::impl_lint_pass;\n use rustc_span::source_map::{Span, Spanned};\n \n const HARD_CODED_ALLOWED: &[&str] = &[\n+    \"&str\",\n     \"f32\",\n     \"f64\",\n     \"std::num::Saturating\",\n-    \"std::string::String\",\n     \"std::num::Wrapping\",\n+    \"std::string::String\",\n ];\n \n #[derive(Debug)]\n@@ -45,61 +41,59 @@ impl ArithmeticSideEffects {\n     /// Assuming that `expr` is a literal integer, checks operators (+=, -=, *, /) in a\n     /// non-constant environment that won't overflow.\n     fn has_valid_op(op: &Spanned<hir::BinOpKind>, expr: &hir::Expr<'_>) -> bool {\n-        if let hir::BinOpKind::Add | hir::BinOpKind::Sub = op.node\n-            && let hir::ExprKind::Lit(ref lit) = expr.kind\n-            && let ast::LitKind::Int(0, _) = lit.node\n-        {\n-            return true;\n-        }\n-        if let hir::BinOpKind::Div | hir::BinOpKind::Rem = op.node\n-            && let hir::ExprKind::Lit(ref lit) = expr.kind\n-            && !matches!(lit.node, ast::LitKind::Int(0, _))\n+        if let hir::ExprKind::Lit(ref lit) = expr.kind &&\n+            let ast::LitKind::Int(value, _) = lit.node\n         {\n-            return true;\n-        }\n-        if let hir::BinOpKind::Mul = op.node\n-            && let hir::ExprKind::Lit(ref lit) = expr.kind\n-            && let ast::LitKind::Int(0 | 1, _) = lit.node\n-        {\n-            return true;\n+            match (&op.node, value) {\n+                (hir::BinOpKind::Div | hir::BinOpKind::Rem, 0) => false,\n+                (hir::BinOpKind::Add | hir::BinOpKind::Sub, 0)\n+                    | (hir::BinOpKind::Div | hir::BinOpKind::Rem, _)\n+                    | (hir::BinOpKind::Mul, 0 | 1) => true,\n+                _ => false,\n+            }\n+        } else {\n+            false\n         }\n-        false\n     }\n \n     /// Checks if the given `expr` has any of the inner `allowed` elements.\n-    fn is_allowed_ty(&self, cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> bool {\n-        self.allowed.contains(\n-            cx.typeck_results()\n-                .expr_ty(expr)\n-                .to_string()\n-                .split('<')\n-                .next()\n-                .unwrap_or_default(),\n-        )\n+    fn is_allowed_ty(&self, ty: Ty<'_>) -> bool {\n+        self.allowed\n+            .contains(ty.to_string().split('<').next().unwrap_or_default())\n     }\n \n-    /// Explicit integers like `1` or `i32::MAX`. Does not take into consideration references.\n-    fn is_literal_integer(expr: &hir::Expr<'_>, expr_refs: Ty<'_>) -> bool {\n-        let is_integral = expr_refs.is_integral();\n-        let is_literal = matches!(expr.kind, hir::ExprKind::Lit(_));\n-        is_integral && is_literal\n+    // For example, 8i32 or &i64::MAX.\n+    fn is_integral(ty: Ty<'_>) -> bool {\n+        ty.peel_refs().is_integral()\n     }\n \n+    // Common entry-point to avoid code duplication.\n     fn issue_lint(&mut self, cx: &LateContext<'_>, expr: &hir::Expr<'_>) {\n         let msg = \"arithmetic operation that can potentially result in unexpected side-effects\";\n         span_lint(cx, ARITHMETIC_SIDE_EFFECTS, expr.span, msg);\n         self.expr_span = Some(expr.span);\n     }\n \n+    /// If `expr` does not match any variant of `LiteralIntegerTy`, returns `None`.\n+    fn literal_integer<'expr, 'tcx>(expr: &'expr hir::Expr<'tcx>) -> Option<LiteralIntegerTy<'expr, 'tcx>> {\n+        if matches!(expr.kind, hir::ExprKind::Lit(_)) {\n+            return Some(LiteralIntegerTy::Value(expr));\n+        }\n+        if let hir::ExprKind::AddrOf(.., inn) = expr.kind && let hir::ExprKind::Lit(_) = inn.kind {\n+            return Some(LiteralIntegerTy::Ref(inn));\n+        }\n+        None\n+    }\n+\n     /// Manages when the lint should be triggered. Operations in constant environments, hard coded\n     /// types, custom allowed types and non-constant operations that won't overflow are ignored.\n-    fn manage_bin_ops(\n+    fn manage_bin_ops<'tcx>(\n         &mut self,\n-        cx: &LateContext<'_>,\n-        expr: &hir::Expr<'_>,\n+        cx: &LateContext<'tcx>,\n+        expr: &hir::Expr<'tcx>,\n         op: &Spanned<hir::BinOpKind>,\n-        lhs: &hir::Expr<'_>,\n-        rhs: &hir::Expr<'_>,\n+        lhs: &hir::Expr<'tcx>,\n+        rhs: &hir::Expr<'tcx>,\n     ) {\n         if constant_simple(cx, cx.typeck_results(), expr).is_some() {\n             return;\n@@ -116,17 +110,20 @@ impl ArithmeticSideEffects {\n         ) {\n             return;\n         };\n-        if self.is_allowed_ty(cx, lhs) || self.is_allowed_ty(cx, rhs) {\n+        let lhs_ty = cx.typeck_results().expr_ty(lhs);\n+        let rhs_ty = cx.typeck_results().expr_ty(rhs);\n+        let lhs_and_rhs_have_the_same_ty = lhs_ty == rhs_ty;\n+        if lhs_and_rhs_have_the_same_ty && self.is_allowed_ty(lhs_ty) && self.is_allowed_ty(rhs_ty) {\n             return;\n         }\n-        let has_valid_op = match (\n-            Self::is_literal_integer(lhs, cx.typeck_results().expr_ty(lhs).peel_refs()),\n-            Self::is_literal_integer(rhs, cx.typeck_results().expr_ty(rhs).peel_refs()),\n-        ) {\n-            (true, true) => true,\n-            (true, false) => Self::has_valid_op(op, lhs),\n-            (false, true) => Self::has_valid_op(op, rhs),\n-            (false, false) => false,\n+        let has_valid_op = if Self::is_integral(lhs_ty) && Self::is_integral(rhs_ty) {\n+            match (Self::literal_integer(lhs), Self::literal_integer(rhs)) {\n+                (None, Some(lit_int_ty)) | (Some(lit_int_ty), None) => Self::has_valid_op(op, lit_int_ty.into()),\n+                (Some(LiteralIntegerTy::Value(_)), Some(LiteralIntegerTy::Value(_))) => true,\n+                (None, None) | (Some(_), Some(_)) => false,\n+            }\n+        } else {\n+            false\n         };\n         if !has_valid_op {\n             self.issue_lint(cx, expr);\n@@ -135,7 +132,7 @@ impl ArithmeticSideEffects {\n }\n \n impl<'tcx> LateLintPass<'tcx> for ArithmeticSideEffects {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &hir::Expr<'tcx>) {\n         if self.expr_span.is_some() || self.const_span.map_or(false, |sp| sp.contains(expr.span)) {\n             return;\n         }\n@@ -180,3 +177,22 @@ impl<'tcx> LateLintPass<'tcx> for ArithmeticSideEffects {\n         }\n     }\n }\n+\n+/// Tells if an expression is a integer declared by value or by reference.\n+///\n+/// If `LiteralIntegerTy::Ref`, then the contained value will be `hir::ExprKind::Lit` rather\n+/// than `hirExprKind::Addr`.\n+enum LiteralIntegerTy<'expr, 'tcx> {\n+    /// For example, `&199`\n+    Ref(&'expr hir::Expr<'tcx>),\n+    /// For example, `1` or `i32::MAX`\n+    Value(&'expr hir::Expr<'tcx>),\n+}\n+\n+impl<'expr, 'tcx> From<LiteralIntegerTy<'expr, 'tcx>> for &'expr hir::Expr<'tcx> {\n+    fn from(from: LiteralIntegerTy<'expr, 'tcx>) -> Self {\n+        match from {\n+            LiteralIntegerTy::Ref(elem) | LiteralIntegerTy::Value(elem) => elem,\n+        }\n+    }\n+}"}, {"sha": "26bca7c306a84e99d7e81f8370ed53696b62c11b", "filename": "src/tools/clippy/clippy_lints/src/operators/assign_op_pattern.rs", "status": "modified", "additions": 16, "deletions": 27, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fassign_op_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fassign_op_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fassign_op_pattern.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -2,16 +2,17 @@ use clippy_utils::binop_traits;\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::implements_trait;\n+use clippy_utils::visitors::for_each_expr;\n use clippy_utils::{eq_expr_value, trait_ref_of_method};\n+use core::ops::ControlFlow;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n-use rustc_hir::intravisit::{walk_expr, Visitor};\n+use rustc_hir_analysis::expr_use_visitor::{Delegate, ExprUseVisitor, PlaceBase, PlaceWithHirId};\n use rustc_lint::LateContext;\n use rustc_middle::mir::FakeReadCause;\n use rustc_middle::ty::BorrowKind;\n use rustc_trait_selection::infer::TyCtxtInferExt;\n-use rustc_hir_analysis::expr_use_visitor::{Delegate, ExprUseVisitor, PlaceBase, PlaceWithHirId};\n \n use super::ASSIGN_OP_PATTERN;\n \n@@ -55,7 +56,7 @@ pub(super) fn check<'tcx>(\n                                 diag.span_suggestion(\n                                     expr.span,\n                                     \"replace it with\",\n-                                    format!(\"{} {}= {}\", snip_a, op.node.as_str(), snip_r),\n+                                    format!(\"{snip_a} {}= {snip_r}\", op.node.as_str()),\n                                     Applicability::MachineApplicable,\n                                 );\n                             }\n@@ -65,15 +66,19 @@ pub(super) fn check<'tcx>(\n             }\n         };\n \n-        let mut visitor = ExprVisitor {\n-            assignee,\n-            counter: 0,\n-            cx,\n-        };\n-\n-        walk_expr(&mut visitor, e);\n+        let mut found = false;\n+        let found_multiple = for_each_expr(e, |e| {\n+            if eq_expr_value(cx, assignee, e) {\n+                if found {\n+                    return ControlFlow::Break(());\n+                }\n+                found = true;\n+            }\n+            ControlFlow::Continue(())\n+        })\n+        .is_some();\n \n-        if visitor.counter == 1 {\n+        if found && !found_multiple {\n             // a = a op b\n             if eq_expr_value(cx, assignee, l) {\n                 lint(assignee, r);\n@@ -98,22 +103,6 @@ pub(super) fn check<'tcx>(\n     }\n }\n \n-struct ExprVisitor<'a, 'tcx> {\n-    assignee: &'a hir::Expr<'a>,\n-    counter: u8,\n-    cx: &'a LateContext<'tcx>,\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for ExprVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n-        if eq_expr_value(self.cx, self.assignee, expr) {\n-            self.counter += 1;\n-        }\n-\n-        walk_expr(self, expr);\n-    }\n-}\n-\n fn imm_borrows_in_expr(cx: &LateContext<'_>, e: &hir::Expr<'_>) -> hir::HirIdSet {\n     struct S(hir::HirIdSet);\n     impl Delegate<'_> for S {"}, {"sha": "1369b3e74625cacdb849ad510ff2e930f0de943a", "filename": "src/tools/clippy/clippy_lints/src/operators/bit_mask.rs", "status": "modified", "additions": 8, "deletions": 32, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fbit_mask.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -64,10 +64,7 @@ fn check_bit_mask(\n                             cx,\n                             BAD_BIT_MASK,\n                             span,\n-                            &format!(\n-                                \"incompatible bit mask: `_ & {}` can never be equal to `{}`\",\n-                                mask_value, cmp_value\n-                            ),\n+                            &format!(\"incompatible bit mask: `_ & {mask_value}` can never be equal to `{cmp_value}`\"),\n                         );\n                     }\n                 } else if mask_value == 0 {\n@@ -80,10 +77,7 @@ fn check_bit_mask(\n                         cx,\n                         BAD_BIT_MASK,\n                         span,\n-                        &format!(\n-                            \"incompatible bit mask: `_ | {}` can never be equal to `{}`\",\n-                            mask_value, cmp_value\n-                        ),\n+                        &format!(\"incompatible bit mask: `_ | {mask_value}` can never be equal to `{cmp_value}`\"),\n                     );\n                 }\n             },\n@@ -96,10 +90,7 @@ fn check_bit_mask(\n                         cx,\n                         BAD_BIT_MASK,\n                         span,\n-                        &format!(\n-                            \"incompatible bit mask: `_ & {}` will always be lower than `{}`\",\n-                            mask_value, cmp_value\n-                        ),\n+                        &format!(\"incompatible bit mask: `_ & {mask_value}` will always be lower than `{cmp_value}`\"),\n                     );\n                 } else if mask_value == 0 {\n                     span_lint(cx, BAD_BIT_MASK, span, \"&-masking with zero\");\n@@ -111,10 +102,7 @@ fn check_bit_mask(\n                         cx,\n                         BAD_BIT_MASK,\n                         span,\n-                        &format!(\n-                            \"incompatible bit mask: `_ | {}` will never be lower than `{}`\",\n-                            mask_value, cmp_value\n-                        ),\n+                        &format!(\"incompatible bit mask: `_ | {mask_value}` will never be lower than `{cmp_value}`\"),\n                     );\n                 } else {\n                     check_ineffective_lt(cx, span, mask_value, cmp_value, \"|\");\n@@ -130,10 +118,7 @@ fn check_bit_mask(\n                         cx,\n                         BAD_BIT_MASK,\n                         span,\n-                        &format!(\n-                            \"incompatible bit mask: `_ & {}` will never be higher than `{}`\",\n-                            mask_value, cmp_value\n-                        ),\n+                        &format!(\"incompatible bit mask: `_ & {mask_value}` will never be higher than `{cmp_value}`\"),\n                     );\n                 } else if mask_value == 0 {\n                     span_lint(cx, BAD_BIT_MASK, span, \"&-masking with zero\");\n@@ -145,10 +130,7 @@ fn check_bit_mask(\n                         cx,\n                         BAD_BIT_MASK,\n                         span,\n-                        &format!(\n-                            \"incompatible bit mask: `_ | {}` will always be higher than `{}`\",\n-                            mask_value, cmp_value\n-                        ),\n+                        &format!(\"incompatible bit mask: `_ | {mask_value}` will always be higher than `{cmp_value}`\"),\n                     );\n                 } else {\n                     check_ineffective_gt(cx, span, mask_value, cmp_value, \"|\");\n@@ -167,10 +149,7 @@ fn check_ineffective_lt(cx: &LateContext<'_>, span: Span, m: u128, c: u128, op:\n             cx,\n             INEFFECTIVE_BIT_MASK,\n             span,\n-            &format!(\n-                \"ineffective bit mask: `x {} {}` compared to `{}`, is the same as x compared directly\",\n-                op, m, c\n-            ),\n+            &format!(\"ineffective bit mask: `x {op} {m}` compared to `{c}`, is the same as x compared directly\"),\n         );\n     }\n }\n@@ -181,10 +160,7 @@ fn check_ineffective_gt(cx: &LateContext<'_>, span: Span, m: u128, c: u128, op:\n             cx,\n             INEFFECTIVE_BIT_MASK,\n             span,\n-            &format!(\n-                \"ineffective bit mask: `x {} {}` compared to `{}`, is the same as x compared directly\",\n-                op, m, c\n-            ),\n+            &format!(\"ineffective bit mask: `x {op} {m}` compared to `{c}`, is the same as x compared directly\"),\n         );\n     }\n }"}, {"sha": "c9c777f1bd8d8854e66e19f4c0fa77b17a3bc059", "filename": "src/tools/clippy/clippy_lints/src/operators/cmp_owned.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fcmp_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fcmp_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fcmp_owned.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -99,7 +99,7 @@ fn check_op(cx: &LateContext<'_>, expr: &Expr<'_>, other: &Expr<'_>, left: bool)\n             let expr_snip;\n             let eq_impl;\n             if with_deref.is_implemented() {\n-                expr_snip = format!(\"*{}\", arg_snip);\n+                expr_snip = format!(\"*{arg_snip}\");\n                 eq_impl = with_deref;\n             } else {\n                 expr_snip = arg_snip.to_string();\n@@ -121,17 +121,15 @@ fn check_op(cx: &LateContext<'_>, expr: &Expr<'_>, other: &Expr<'_>, left: bool)\n                 };\n                 if eq_impl.ty_eq_other {\n                     hint = format!(\n-                        \"{}{}{}\",\n-                        expr_snip,\n+                        \"{expr_snip}{}{}\",\n                         snippet(cx, cmp_span, \"..\"),\n                         snippet(cx, other.span, \"..\")\n                     );\n                 } else {\n                     hint = format!(\n-                        \"{}{}{}\",\n+                        \"{}{}{expr_snip}\",\n                         snippet(cx, other.span, \"..\"),\n-                        snippet(cx, cmp_span, \"..\"),\n-                        expr_snip\n+                        snippet(cx, cmp_span, \"..\")\n                     );\n                 }\n             }"}, {"sha": "49e662cacb0c374720d1a8d404f5856b48852acf", "filename": "src/tools/clippy/clippy_lints/src/operators/duration_subsec.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fduration_subsec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fduration_subsec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fduration_subsec.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -31,12 +31,11 @@ pub(crate) fn check<'tcx>(\n             cx,\n             DURATION_SUBSEC,\n             expr.span,\n-            &format!(\"calling `{}()` is more concise than this calculation\", suggested_fn),\n+            &format!(\"calling `{suggested_fn}()` is more concise than this calculation\"),\n             \"try\",\n             format!(\n-                \"{}.{}()\",\n-                snippet_with_applicability(cx, self_arg.span, \"_\", &mut applicability),\n-                suggested_fn\n+                \"{}.{suggested_fn}()\",\n+                snippet_with_applicability(cx, self_arg.span, \"_\", &mut applicability)\n             ),\n             applicability,\n         );"}, {"sha": "67913f7392c0490d05a26213809d04051ed9d5ac", "filename": "src/tools/clippy/clippy_lints/src/operators/eq_op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Feq_op.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -22,7 +22,7 @@ pub(crate) fn check_assert<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n             cx,\n             EQ_OP,\n             lhs.span.to(rhs.span),\n-            &format!(\"identical args used in this `{}!` macro call\", macro_name),\n+            &format!(\"identical args used in this `{macro_name}!` macro call\"),\n         );\n     }\n }"}, {"sha": "ae805147f07a20155444857085a60eb120f604fe", "filename": "src/tools/clippy/clippy_lints/src/operators/misrefactored_assign_op.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fmisrefactored_assign_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fmisrefactored_assign_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fmisrefactored_assign_op.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -47,18 +47,14 @@ fn lint_misrefactored_assign_op(\n             if let (Some(snip_a), Some(snip_r)) = (snippet_opt(cx, assignee.span), snippet_opt(cx, rhs_other.span)) {\n                 let a = &sugg::Sugg::hir(cx, assignee, \"..\");\n                 let r = &sugg::Sugg::hir(cx, rhs, \"..\");\n-                let long = format!(\"{} = {}\", snip_a, sugg::make_binop(op.into(), a, r));\n+                let long = format!(\"{snip_a} = {}\", sugg::make_binop(op.into(), a, r));\n                 diag.span_suggestion(\n                     expr.span,\n                     &format!(\n-                        \"did you mean `{} = {} {} {}` or `{}`? Consider replacing it with\",\n-                        snip_a,\n-                        snip_a,\n-                        op.as_str(),\n-                        snip_r,\n-                        long\n+                        \"did you mean `{snip_a} = {snip_a} {} {snip_r}` or `{long}`? Consider replacing it with\",\n+                        op.as_str()\n                     ),\n-                    format!(\"{} {}= {}\", snip_a, op.as_str(), snip_r),\n+                    format!(\"{snip_a} {}= {snip_r}\", op.as_str()),\n                     Applicability::MaybeIncorrect,\n                 );\n                 diag.span_suggestion("}, {"sha": "b8a20d5ebe9bd689e7d996fea0dff6e86d9dcdd4", "filename": "src/tools/clippy/clippy_lints/src/operators/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fmod.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -67,7 +67,7 @@ declare_clippy_lint! {\n     /// Reference](https://doc.rust-lang.org/reference/expressions/operator-expr.html#overflow),\n     /// or can panic (`/`, `%`).\n     ///\n-    /// Known safe built-in types like `Wrapping` or `Saturing`, floats, operations in constant\n+    /// Known safe built-in types like `Wrapping` or `Saturating`, floats, operations in constant\n     /// environments, allowed types and non-constant operations that won't overflow are ignored.\n     ///\n     /// ### Why is this bad?"}, {"sha": "ab5fb1787004e79f8ef198802f90705b608e7ec9", "filename": "src/tools/clippy/clippy_lints/src/operators/needless_bitwise_bool.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fneedless_bitwise_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fneedless_bitwise_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fneedless_bitwise_bool.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -27,7 +27,7 @@ pub(super) fn check(cx: &LateContext<'_>, e: &Expr<'_>, op: BinOpKind, lhs: &Exp\n                 if let Some(lhs_snip) = snippet_opt(cx, lhs.span)\n                     && let Some(rhs_snip) = snippet_opt(cx, rhs.span)\n                 {\n-                    let sugg = format!(\"{} {} {}\", lhs_snip, op_str, rhs_snip);\n+                    let sugg = format!(\"{lhs_snip} {op_str} {rhs_snip}\");\n                     diag.span_suggestion(e.span, \"try\", sugg, Applicability::MachineApplicable);\n                 }\n             },"}, {"sha": "0830a106f55685014b50e19476296bddf8397519", "filename": "src/tools/clippy/clippy_lints/src/operators/numeric_arithmetic.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fnumeric_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fnumeric_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fnumeric_arithmetic.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -1,5 +1,6 @@\n use clippy_utils::consts::constant_simple;\n use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::is_integer_literal;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n use rustc_span::source_map::Span;\n@@ -50,11 +51,9 @@ impl Context {\n                 hir::BinOpKind::Div | hir::BinOpKind::Rem => match &r.kind {\n                     hir::ExprKind::Lit(_lit) => (),\n                     hir::ExprKind::Unary(hir::UnOp::Neg, expr) => {\n-                        if let hir::ExprKind::Lit(lit) = &expr.kind {\n-                            if let rustc_ast::ast::LitKind::Int(1, _) = lit.node {\n-                                span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");\n-                                self.expr_id = Some(expr.hir_id);\n-                            }\n+                        if is_integer_literal(expr, 1) {\n+                            span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");\n+                            self.expr_id = Some(expr.hir_id);\n                         }\n                     },\n                     _ => {"}, {"sha": "1229c202f5a0993dbecf0a9e76eff8d25936ea63", "filename": "src/tools/clippy/clippy_lints/src/operators/ptr_eq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fptr_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fptr_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fptr_eq.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -34,7 +34,7 @@ pub(super) fn check<'tcx>(\n                     expr.span,\n                     LINT_MSG,\n                     \"try\",\n-                    format!(\"std::ptr::eq({}, {})\", left_snip, right_snip),\n+                    format!(\"std::ptr::eq({left_snip}, {right_snip})\"),\n                     Applicability::MachineApplicable,\n                     );\n             }"}, {"sha": "7c9d5320a3a8b0e30f5706fd39447d33c026e40a", "filename": "src/tools/clippy/clippy_lints/src/operators/self_assignment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fself_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fself_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fself_assignment.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -14,7 +14,7 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, lhs: &'tcx\n             cx,\n             SELF_ASSIGNMENT,\n             e.span,\n-            &format!(\"self-assignment of `{}` to `{}`\", rhs, lhs),\n+            &format!(\"self-assignment of `{rhs}` to `{lhs}`\"),\n         );\n     }\n }"}, {"sha": "fbf65e92b322a7c8e92cbe67614d69a1ebe5c2f0", "filename": "src/tools/clippy/clippy_lints/src/operators/verbose_bit_mask.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fverbose_bit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fverbose_bit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fverbose_bit_mask.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -35,7 +35,7 @@ pub(super) fn check<'tcx>(\n                 diag.span_suggestion(\n                     e.span,\n                     \"try\",\n-                    format!(\"{}.trailing_zeros() >= {}\", sugg, n.count_ones()),\n+                    format!(\"{sugg}.trailing_zeros() >= {}\", n.count_ones()),\n                     Applicability::MaybeIncorrect,\n                 );\n             },"}, {"sha": "4eb42da1fed02a1bdabb2dab559c36498e31b310", "filename": "src/tools/clippy/clippy_lints/src/option_if_let_else.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foption_if_let_else.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::sugg::Sugg;\n use clippy_utils::{\n-    can_move_expr_to_closure, eager_or_lazy, higher, in_constant, is_else_clause, is_lang_ctor, peel_blocks,\n+    can_move_expr_to_closure, eager_or_lazy, higher, in_constant, is_else_clause, is_res_lang_ctor, peel_blocks,\n     peel_hir_expr_while, CaptureKind,\n };\n use if_chain::if_chain;\n@@ -88,7 +88,7 @@ declare_lint_pass!(OptionIfLetElse => [OPTION_IF_LET_ELSE]);\n ///     None/_ => {..}\n /// }\n /// ```\n-struct OptionOccurence {\n+struct OptionOccurrence {\n     option: String,\n     method_sugg: String,\n     some_expr: String,\n@@ -109,13 +109,13 @@ fn format_option_in_sugg(cx: &LateContext<'_>, cond_expr: &Expr<'_>, as_ref: boo\n     )\n }\n \n-fn try_get_option_occurence<'tcx>(\n+fn try_get_option_occurrence<'tcx>(\n     cx: &LateContext<'tcx>,\n     pat: &Pat<'tcx>,\n     expr: &Expr<'_>,\n     if_then: &'tcx Expr<'_>,\n     if_else: &'tcx Expr<'_>,\n-) -> Option<OptionOccurence> {\n+) -> Option<OptionOccurrence> {\n     let cond_expr = match expr.kind {\n         ExprKind::Unary(UnOp::Deref, inner_expr) | ExprKind::AddrOf(_, _, inner_expr) => inner_expr,\n         _ => expr,\n@@ -160,10 +160,10 @@ fn try_get_option_occurence<'tcx>(\n                 }\n             }\n \n-            return Some(OptionOccurence {\n+            return Some(OptionOccurrence {\n                 option: format_option_in_sugg(cx, cond_expr, as_ref, as_mut),\n                 method_sugg: method_sugg.to_string(),\n-                some_expr: format!(\"|{}{}| {}\", capture_mut, capture_name, Sugg::hir_with_macro_callsite(cx, some_body, \"..\")),\n+                some_expr: format!(\"|{capture_mut}{capture_name}| {}\", Sugg::hir_with_macro_callsite(cx, some_body, \"..\")),\n                 none_expr: format!(\"{}{}\", if method_sugg == \"map_or\" { \"\" } else { \"|| \" }, Sugg::hir_with_macro_callsite(cx, none_body, \"..\")),\n             });\n         }\n@@ -174,17 +174,18 @@ fn try_get_option_occurence<'tcx>(\n \n fn try_get_inner_pat<'tcx>(cx: &LateContext<'tcx>, pat: &Pat<'tcx>) -> Option<&'tcx Pat<'tcx>> {\n     if let PatKind::TupleStruct(ref qpath, [inner_pat], ..) = pat.kind {\n-        if is_lang_ctor(cx, qpath, OptionSome) || is_lang_ctor(cx, qpath, ResultOk) {\n+        let res = cx.qpath_res(qpath, pat.hir_id);\n+        if is_res_lang_ctor(cx, res, OptionSome) || is_res_lang_ctor(cx, res, ResultOk) {\n             return Some(inner_pat);\n         }\n     }\n     None\n }\n \n /// If this expression is the option if let/else construct we're detecting, then\n-/// this function returns an `OptionOccurence` struct with details if\n+/// this function returns an `OptionOccurrence` struct with details if\n /// this construct is found, or None if this construct is not found.\n-fn detect_option_if_let_else<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>) -> Option<OptionOccurence> {\n+fn detect_option_if_let_else<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>) -> Option<OptionOccurrence> {\n     if let Some(higher::IfLet {\n         let_pat,\n         let_expr,\n@@ -193,16 +194,16 @@ fn detect_option_if_let_else<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>) ->\n     }) = higher::IfLet::hir(cx, expr)\n     {\n         if !is_else_clause(cx.tcx, expr) {\n-            return try_get_option_occurence(cx, let_pat, let_expr, if_then, if_else);\n+            return try_get_option_occurrence(cx, let_pat, let_expr, if_then, if_else);\n         }\n     }\n     None\n }\n \n-fn detect_option_match<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>) -> Option<OptionOccurence> {\n+fn detect_option_match<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>) -> Option<OptionOccurrence> {\n     if let ExprKind::Match(ex, arms, MatchSource::Normal) = expr.kind {\n         if let Some((let_pat, if_then, if_else)) = try_convert_match(cx, arms) {\n-            return try_get_option_occurence(cx, let_pat, ex, if_then, if_else);\n+            return try_get_option_occurrence(cx, let_pat, ex, if_then, if_else);\n         }\n     }\n     None\n@@ -226,9 +227,10 @@ fn try_convert_match<'tcx>(\n \n fn is_none_or_err_arm(cx: &LateContext<'_>, arm: &Arm<'_>) -> bool {\n     match arm.pat.kind {\n-        PatKind::Path(ref qpath) => is_lang_ctor(cx, qpath, OptionNone),\n+        PatKind::Path(ref qpath) => is_res_lang_ctor(cx, cx.qpath_res(qpath, arm.pat.hir_id), OptionNone),\n         PatKind::TupleStruct(ref qpath, [first_pat], _) => {\n-            is_lang_ctor(cx, qpath, ResultErr) && matches!(first_pat.kind, PatKind::Wild)\n+            is_res_lang_ctor(cx, cx.qpath_res(qpath, arm.pat.hir_id), ResultErr)\n+                && matches!(first_pat.kind, PatKind::Wild)\n         },\n         PatKind::Wild => true,\n         _ => false,"}, {"sha": "efec12489a9bad42708568988843610ddfb172b9", "filename": "src/tools/clippy/clippy_lints/src/panic_in_result_fn.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpanic_in_result_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpanic_in_result_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpanic_in_result_fn.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -2,9 +2,10 @@ use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::macros::root_macro_call_first_node;\n use clippy_utils::return_ty;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::visitors::expr_visitor_no_bodies;\n+use clippy_utils::visitors::{for_each_expr, Descend};\n+use core::ops::ControlFlow;\n use rustc_hir as hir;\n-use rustc_hir::intravisit::{FnKind, Visitor};\n+use rustc_hir::intravisit::FnKind;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{sym, Span};\n@@ -58,18 +59,20 @@ impl<'tcx> LateLintPass<'tcx> for PanicInResultFn {\n \n fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, body: &'tcx hir::Body<'tcx>) {\n     let mut panics = Vec::new();\n-    expr_visitor_no_bodies(|expr| {\n-        let Some(macro_call) = root_macro_call_first_node(cx, expr) else { return true };\n+    let _: Option<!> = for_each_expr(body.value, |e| {\n+        let Some(macro_call) = root_macro_call_first_node(cx, e) else {\n+            return ControlFlow::Continue(Descend::Yes);\n+        };\n         if matches!(\n             cx.tcx.item_name(macro_call.def_id).as_str(),\n             \"unimplemented\" | \"unreachable\" | \"panic\" | \"todo\" | \"assert\" | \"assert_eq\" | \"assert_ne\"\n         ) {\n             panics.push(macro_call.span);\n-            return false;\n+            ControlFlow::Continue(Descend::No)\n+        } else {\n+            ControlFlow::Continue(Descend::Yes)\n         }\n-        true\n-    })\n-    .visit_expr(body.value);\n+    });\n     if !panics.is_empty() {\n         span_lint_and_then(\n             cx,"}, {"sha": "6810a2431758910ab3a62bf5ac25286882ac5e97", "filename": "src/tools/clippy/clippy_lints/src/partialeq_to_none.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpartialeq_to_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpartialeq_to_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpartialeq_to_none.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::{\n-    diagnostics::span_lint_and_sugg, is_lang_ctor, peel_hir_expr_refs, peel_ref_operators, sugg,\n+    diagnostics::span_lint_and_sugg, is_res_lang_ctor, path_res, peel_hir_expr_refs, peel_ref_operators, sugg,\n     ty::is_type_diagnostic_item,\n };\n use rustc_errors::Applicability;\n@@ -54,8 +54,7 @@ impl<'tcx> LateLintPass<'tcx> for PartialeqToNone {\n         // If the expression is a literal `Option::None`\n         let is_none_ctor = |expr: &Expr<'_>| {\n             !expr.span.from_expansion()\n-                && matches!(&peel_hir_expr_refs(expr).0.kind,\n-            ExprKind::Path(p) if is_lang_ctor(cx, p, LangItem::OptionNone))\n+                && is_res_lang_ctor(cx, path_res(cx, peel_hir_expr_refs(expr).0), LangItem::OptionNone)\n         };\n \n         let mut applicability = Applicability::MachineApplicable;"}, {"sha": "45e98de10ace4985308194b806b8f3645fc01a8d", "filename": "src/tools/clippy/clippy_lints/src/pass_by_ref_or_value.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -209,7 +209,7 @@ impl<'tcx> PassByRefOrValue {\n                             cx,\n                             TRIVIALLY_COPY_PASS_BY_REF,\n                             input.span,\n-                            &format!(\"this argument ({} byte) is passed by reference, but would be more efficient if passed by value (limit: {} byte)\", size, self.ref_min_size),\n+                            &format!(\"this argument ({size} byte) is passed by reference, but would be more efficient if passed by value (limit: {} byte)\", self.ref_min_size),\n                             \"consider passing by value instead\",\n                             value_type,\n                             Applicability::Unspecified,\n@@ -237,7 +237,7 @@ impl<'tcx> PassByRefOrValue {\n                                 cx,\n                                 LARGE_TYPES_PASSED_BY_VALUE,\n                                 input.span,\n-                                &format!(\"this argument ({} byte) is passed by value, but might be more efficient if passed by reference (limit: {} byte)\", size, self.value_max_size),\n+                                &format!(\"this argument ({size} byte) is passed by value, but might be more efficient if passed by reference (limit: {} byte)\", self.value_max_size),\n                                 \"consider passing by reference instead\",\n                                 format!(\"&{}\", snippet(cx, input.span, \"_\")),\n                                 Applicability::MaybeIncorrect,"}, {"sha": "d296a150b46d085cec600152a3c2a05abac8af49", "filename": "src/tools/clippy/clippy_lints/src/ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -463,7 +463,7 @@ fn check_fn_args<'cx, 'tcx: 'cx>(\n                                     diag.span_suggestion(\n                                         hir_ty.span,\n                                         \"change this to\",\n-                                        format!(\"&{}{}\", mutability.prefix_str(), ty_name),\n+                                        format!(\"&{}{ty_name}\", mutability.prefix_str()),\n                                         Applicability::Unspecified,\n                                     );\n                                 }\n@@ -669,7 +669,7 @@ fn check_ptr_arg_usage<'tcx>(cx: &LateContext<'tcx>, body: &'tcx Body<'_>, args:\n }\n \n fn get_rptr_lm<'tcx>(ty: &'tcx hir::Ty<'tcx>) -> Option<(&'tcx Lifetime, Mutability, Span)> {\n-    if let TyKind::Rptr(ref lt, ref m) = ty.kind {\n+    if let TyKind::Rptr(lt, ref m) = ty.kind {\n         Some((lt, m.mutbl, ty.span))\n     } else {\n         None"}, {"sha": "b0a5d1a6758285d268071ffbc1e2a586dfa2da45", "filename": "src/tools/clippy/clippy_lints/src/ptr_offset_with_cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr_offset_with_cast.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -60,7 +60,7 @@ impl<'tcx> LateLintPass<'tcx> for PtrOffsetWithCast {\n             None => return,\n         };\n \n-        let msg = format!(\"use of `{}` with a `usize` casted to an `isize`\", method);\n+        let msg = format!(\"use of `{method}` with a `usize` casted to an `isize`\");\n         if let Some(sugg) = build_suggestion(cx, method, receiver_expr, cast_lhs_expr) {\n             span_lint_and_sugg(\n                 cx,\n@@ -124,7 +124,7 @@ fn build_suggestion<'tcx>(\n ) -> Option<String> {\n     let receiver = snippet_opt(cx, receiver_expr.span)?;\n     let cast_lhs = snippet_opt(cx, cast_lhs_expr.span)?;\n-    Some(format!(\"{}.{}({})\", receiver, method.suggestion(), cast_lhs))\n+    Some(format!(\"{receiver}.{}({cast_lhs})\", method.suggestion()))\n }\n \n #[derive(Copy, Clone)]"}, {"sha": "328371fd602f0c517c9c48a6ff2a6585535e90ba", "filename": "src/tools/clippy/clippy_lints/src/question_mark.rs", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -3,11 +3,12 @@ use clippy_utils::higher;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::is_type_diagnostic_item;\n use clippy_utils::{\n-    eq_expr_value, get_parent_node, is_else_clause, is_lang_ctor, path_to_local, path_to_local_id, peel_blocks,\n-    peel_blocks_with_stmt,\n+    eq_expr_value, get_parent_node, in_constant, is_else_clause, is_res_lang_ctor, path_to_local, path_to_local_id,\n+    peel_blocks, peel_blocks_with_stmt,\n };\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n+use rustc_hir::def::Res;\n use rustc_hir::LangItem::{OptionNone, OptionSome, ResultErr, ResultOk};\n use rustc_hir::{BindingAnnotation, ByRef, Expr, ExprKind, Node, PatKind, PathSegment, QPath};\n use rustc_lint::{LateContext, LateLintPass};\n@@ -58,7 +59,7 @@ enum IfBlockType<'hir> {\n     /// Contains: let_pat_qpath (Xxx), let_pat_type, let_pat_sym (a), let_expr (b), if_then (c),\n     /// if_else (d)\n     IfLet(\n-        &'hir QPath<'hir>,\n+        Res,\n         Ty<'hir>,\n         Symbol,\n         &'hir Expr<'hir>,\n@@ -97,12 +98,12 @@ fn check_is_none_or_err_and_early_return<'tcx>(cx: &LateContext<'tcx>, expr: &Ex\n                 !matches!(caller.kind, ExprKind::Call(..) | ExprKind::MethodCall(..));\n             let sugg = if let Some(else_inner) = r#else {\n                 if eq_expr_value(cx, caller, peel_blocks(else_inner)) {\n-                    format!(\"Some({}?)\", receiver_str)\n+                    format!(\"Some({receiver_str}?)\")\n                 } else {\n                     return;\n                 }\n             } else {\n-                format!(\"{}{}?;\", receiver_str, if by_ref { \".as_ref()\" } else { \"\" })\n+                format!(\"{receiver_str}{}?;\", if by_ref { \".as_ref()\" } else { \"\" })\n             };\n \n             span_lint_and_sugg(\n@@ -126,7 +127,14 @@ fn check_if_let_some_or_err_and_early_return<'tcx>(cx: &LateContext<'tcx>, expr:\n         if ddpos.as_opt_usize().is_none();\n         if let PatKind::Binding(BindingAnnotation(by_ref, _), bind_id, ident, None) = field.kind;\n         let caller_ty = cx.typeck_results().expr_ty(let_expr);\n-        let if_block = IfBlockType::IfLet(path1, caller_ty, ident.name, let_expr, if_then, if_else);\n+        let if_block = IfBlockType::IfLet(\n+            cx.qpath_res(path1, let_pat.hir_id),\n+            caller_ty,\n+            ident.name,\n+            let_expr,\n+            if_then,\n+            if_else\n+        );\n         if (is_early_return(sym::Option, cx, &if_block) && path_to_local_id(peel_blocks(if_then), bind_id))\n             || is_early_return(sym::Result, cx, &if_block);\n         if if_else.map(|e| eq_expr_value(cx, let_expr, peel_blocks(e))).filter(|e| *e).is_none();\n@@ -135,8 +143,7 @@ fn check_if_let_some_or_err_and_early_return<'tcx>(cx: &LateContext<'tcx>, expr:\n             let receiver_str = snippet_with_applicability(cx, let_expr.span, \"..\", &mut applicability);\n             let requires_semi = matches!(get_parent_node(cx.tcx, expr.hir_id), Some(Node::Stmt(_)));\n             let sugg = format!(\n-                \"{}{}?{}\",\n-                receiver_str,\n+                \"{receiver_str}{}?{}\",\n                 if by_ref == ByRef::Yes { \".as_ref()\" } else { \"\" },\n                 if requires_semi { \";\" } else { \"\" }\n             );\n@@ -166,21 +173,21 @@ fn is_early_return(smbl: Symbol, cx: &LateContext<'_>, if_block: &IfBlockType<'_\n                     _ => false,\n                 }\n         },\n-        IfBlockType::IfLet(qpath, let_expr_ty, let_pat_sym, let_expr, if_then, if_else) => {\n+        IfBlockType::IfLet(res, let_expr_ty, let_pat_sym, let_expr, if_then, if_else) => {\n             is_type_diagnostic_item(cx, let_expr_ty, smbl)\n                 && match smbl {\n                     sym::Option => {\n                         // We only need to check `if let Some(x) = option` not `if let None = option`,\n                         // because the later one will be suggested as `if option.is_none()` thus causing conflict.\n-                        is_lang_ctor(cx, qpath, OptionSome)\n+                        is_res_lang_ctor(cx, res, OptionSome)\n                             && if_else.is_some()\n                             && expr_return_none_or_err(smbl, cx, if_else.unwrap(), let_expr, None)\n                     },\n                     sym::Result => {\n-                        (is_lang_ctor(cx, qpath, ResultOk)\n+                        (is_res_lang_ctor(cx, res, ResultOk)\n                             && if_else.is_some()\n                             && expr_return_none_or_err(smbl, cx, if_else.unwrap(), let_expr, Some(let_pat_sym)))\n-                            || is_lang_ctor(cx, qpath, ResultErr)\n+                            || is_res_lang_ctor(cx, res, ResultErr)\n                                 && expr_return_none_or_err(smbl, cx, if_then, let_expr, Some(let_pat_sym))\n                     },\n                     _ => false,\n@@ -199,7 +206,7 @@ fn expr_return_none_or_err(\n     match peel_blocks_with_stmt(expr).kind {\n         ExprKind::Ret(Some(ret_expr)) => expr_return_none_or_err(smbl, cx, ret_expr, cond_expr, err_sym),\n         ExprKind::Path(ref qpath) => match smbl {\n-            sym::Option => is_lang_ctor(cx, qpath, OptionNone),\n+            sym::Option => is_res_lang_ctor(cx, cx.qpath_res(qpath, expr.hir_id), OptionNone),\n             sym::Result => path_to_local(expr).is_some() && path_to_local(expr) == path_to_local(cond_expr),\n             _ => false,\n         },\n@@ -224,7 +231,9 @@ fn expr_return_none_or_err(\n \n impl<'tcx> LateLintPass<'tcx> for QuestionMark {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        check_is_none_or_err_and_early_return(cx, expr);\n-        check_if_let_some_or_err_and_early_return(cx, expr);\n+        if !in_constant(cx, expr.hir_id) {\n+            check_is_none_or_err_and_early_return(cx, expr);\n+            check_if_let_some_or_err_and_early_return(cx, expr);\n+        }\n     }\n }"}, {"sha": "c6fbb5e805ab2812a6da2d7db80b5ca4ec7d834d", "filename": "src/tools/clippy/clippy_lints/src/ranges.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -243,9 +243,9 @@ fn check_possible_range_contains(\n                 cx,\n                 MANUAL_RANGE_CONTAINS,\n                 span,\n-                &format!(\"manual `{}::contains` implementation\", range_type),\n+                &format!(\"manual `{range_type}::contains` implementation\"),\n                 \"use\",\n-                format!(\"({}{}{}{}).contains(&{})\", lo, space, range_op, hi, name),\n+                format!(\"({lo}{space}{range_op}{hi}).contains(&{name})\"),\n                 applicability,\n             );\n         } else if !combine_and && ord == Some(l.ord) {\n@@ -273,9 +273,9 @@ fn check_possible_range_contains(\n                 cx,\n                 MANUAL_RANGE_CONTAINS,\n                 span,\n-                &format!(\"manual `!{}::contains` implementation\", range_type),\n+                &format!(\"manual `!{range_type}::contains` implementation\"),\n                 \"use\",\n-                format!(\"!({}{}{}{}).contains(&{})\", lo, space, range_op, hi, name),\n+                format!(\"!({lo}{space}{range_op}{hi}).contains(&{name})\"),\n                 applicability,\n             );\n         }\n@@ -372,14 +372,14 @@ fn check_exclusive_range_plus_one(cx: &LateContext<'_>, expr: &Expr<'_>) {\n                             diag.span_suggestion(\n                                 span,\n                                 \"use\",\n-                                format!(\"({}..={})\", start, end),\n+                                format!(\"({start}..={end})\"),\n                                 Applicability::MaybeIncorrect,\n                             );\n                         } else {\n                             diag.span_suggestion(\n                                 span,\n                                 \"use\",\n-                                format!(\"{}..={}\", start, end),\n+                                format!(\"{start}..={end}\"),\n                                 Applicability::MachineApplicable, // snippet\n                             );\n                         }\n@@ -408,7 +408,7 @@ fn check_inclusive_range_minus_one(cx: &LateContext<'_>, expr: &Expr<'_>) {\n                     diag.span_suggestion(\n                         expr.span,\n                         \"use\",\n-                        format!(\"{}..{}\", start, end),\n+                        format!(\"{start}..{end}\"),\n                         Applicability::MachineApplicable, // snippet\n                     );\n                 },\n@@ -486,7 +486,7 @@ fn check_reversed_empty_range(cx: &LateContext<'_>, expr: &Expr<'_>) {\n                                 expr.span,\n                                 \"consider using the following if you are attempting to iterate over this \\\n                                  range in reverse\",\n-                                format!(\"({}{}{}).rev()\", end_snippet, dots, start_snippet),\n+                                format!(\"({end_snippet}{dots}{start_snippet}).rev()\"),\n                                 Applicability::MaybeIncorrect,\n                             );\n                         }"}, {"sha": "fa107858863a44c79f5087903acd52d2913b8b09", "filename": "src/tools/clippy/clippy_lints/src/read_zero_byte_vec.rs", "status": "modified", "additions": 18, "deletions": 25, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fread_zero_byte_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fread_zero_byte_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fread_zero_byte_vec.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -2,9 +2,10 @@ use clippy_utils::{\n     diagnostics::{span_lint, span_lint_and_sugg},\n     higher::{get_vec_init_kind, VecInitKind},\n     source::snippet,\n-    visitors::expr_visitor_no_bodies,\n+    visitors::for_each_expr,\n };\n-use hir::{intravisit::Visitor, ExprKind, Local, PatKind, PathSegment, QPath, StmtKind};\n+use core::ops::ControlFlow;\n+use hir::{Expr, ExprKind, Local, PatKind, PathSegment, QPath, StmtKind};\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass};\n@@ -58,38 +59,31 @@ impl<'tcx> LateLintPass<'tcx> for ReadZeroByteVec {\n                 && let PatKind::Binding(_, _, ident, _) = pat.kind\n                 && let Some(vec_init_kind) = get_vec_init_kind(cx, init)\n             {\n-                // finds use of `_.read(&mut v)`\n-                let mut read_found = false;\n-                let mut visitor = expr_visitor_no_bodies(|expr| {\n-                    if let ExprKind::MethodCall(path, _self, [arg], _) = expr.kind\n+                let visitor = |expr: &Expr<'_>| {\n+                    if let ExprKind::MethodCall(path, _, [arg], _) = expr.kind\n                         && let PathSegment { ident: read_or_read_exact, .. } = *path\n                         && matches!(read_or_read_exact.as_str(), \"read\" | \"read_exact\")\n                         && let ExprKind::AddrOf(_, hir::Mutability::Mut, inner) = arg.kind\n                         && let ExprKind::Path(QPath::Resolved(None, inner_path)) = inner.kind\n                         && let [inner_seg] = inner_path.segments\n                         && ident.name == inner_seg.ident.name\n                     {\n-                        read_found = true;\n+                        ControlFlow::Break(())\n+                    } else {\n+                        ControlFlow::Continue(())\n                     }\n-                    !read_found\n-                });\n+                };\n \n-                let next_stmt_span;\n-                if idx == block.stmts.len() - 1 {\n+                let (read_found, next_stmt_span) =\n+                if let Some(next_stmt) = block.stmts.get(idx + 1) {\n+                    // case { .. stmt; stmt; .. }\n+                    (for_each_expr(next_stmt, visitor).is_some(), next_stmt.span)\n+                } else if let Some(e) = block.expr {\n                     // case { .. stmt; expr }\n-                    if let Some(e) = block.expr {\n-                        visitor.visit_expr(e);\n-                        next_stmt_span = e.span;\n-                    } else {\n-                        return;\n-                    }\n+                    (for_each_expr(e, visitor).is_some(), e.span)\n                 } else {\n-                    // case { .. stmt; stmt; .. }\n-                    let next_stmt = &block.stmts[idx + 1];\n-                    visitor.visit_stmt(next_stmt);\n-                    next_stmt_span = next_stmt.span;\n-                }\n-                drop(visitor);\n+                    return\n+                };\n \n                 if read_found && !next_stmt_span.from_expansion() {\n                     let applicability = Applicability::MaybeIncorrect;\n@@ -101,9 +95,8 @@ impl<'tcx> LateLintPass<'tcx> for ReadZeroByteVec {\n                                 next_stmt_span,\n                                 \"reading zero byte data to `Vec`\",\n                                 \"try\",\n-                                format!(\"{}.resize({}, 0); {}\",\n+                                format!(\"{}.resize({len}, 0); {}\",\n                                     ident.as_str(),\n-                                    len,\n                                     snippet(cx, next_stmt_span, \"..\")\n                                 ),\n                                 applicability,"}, {"sha": "464f6827e1d54b2bb4f1f8a796b27228364ce8fd", "filename": "src/tools/clippy/clippy_lints/src/redundant_pub_crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_pub_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_pub_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_pub_crate.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -56,7 +56,7 @@ impl<'tcx> LateLintPass<'tcx> for RedundantPubCrate {\n                     cx,\n                     REDUNDANT_PUB_CRATE,\n                     span,\n-                    &format!(\"pub(crate) {} inside private module\", descr),\n+                    &format!(\"pub(crate) {descr} inside private module\"),\n                     |diag| {\n                         diag.span_suggestion(\n                             item.vis_span,"}, {"sha": "245a02ea26e61d35d2fa3842c436fc002556f2a7", "filename": "src/tools/clippy/clippy_lints/src/redundant_slicing.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_slicing.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -127,9 +127,9 @@ impl<'tcx> LateLintPass<'tcx> for RedundantSlicing {\n \n                     let snip = snippet_with_context(cx, indexed.span, ctxt, \"..\", &mut app).0;\n                     let sugg = if (deref_count != 0 || !reborrow_str.is_empty()) && needs_parens_for_prefix {\n-                        format!(\"({}{}{})\", reborrow_str, \"*\".repeat(deref_count), snip)\n+                        format!(\"({reborrow_str}{}{snip})\", \"*\".repeat(deref_count))\n                     } else {\n-                        format!(\"{}{}{}\", reborrow_str, \"*\".repeat(deref_count), snip)\n+                        format!(\"{reborrow_str}{}{snip}\", \"*\".repeat(deref_count))\n                     };\n \n                     (lint, help_str, sugg)\n@@ -141,9 +141,9 @@ impl<'tcx> LateLintPass<'tcx> for RedundantSlicing {\n                         if deref_ty == expr_ty {\n                             let snip = snippet_with_context(cx, indexed.span, ctxt, \"..\", &mut app).0;\n                             let sugg = if needs_parens_for_prefix {\n-                                format!(\"(&{}{}*{})\", mutability.prefix_str(), \"*\".repeat(indexed_ref_count), snip)\n+                                format!(\"(&{}{}*{snip})\", mutability.prefix_str(), \"*\".repeat(indexed_ref_count))\n                             } else {\n-                                format!(\"&{}{}*{}\", mutability.prefix_str(), \"*\".repeat(indexed_ref_count), snip)\n+                                format!(\"&{}{}*{snip}\", mutability.prefix_str(), \"*\".repeat(indexed_ref_count))\n                             };\n                             (DEREF_BY_SLICING_LINT, \"dereference the original value instead\", sugg)\n                         } else {"}, {"sha": "60ba62c4a4332532f2b42d46732005c7b3a10174", "filename": "src/tools/clippy/clippy_lints/src/redundant_static_lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_static_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_static_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_static_lifetimes.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -67,7 +67,7 @@ impl RedundantStaticLifetimes {\n                         TyKind::Path(..) | TyKind::Slice(..) | TyKind::Array(..) | TyKind::Tup(..) => {\n                             if lifetime.ident.name == rustc_span::symbol::kw::StaticLifetime {\n                                 let snip = snippet(cx, borrow_type.ty.span, \"<type>\");\n-                                let sugg = format!(\"&{}\", snip);\n+                                let sugg = format!(\"&{snip}\");\n                                 span_lint_and_then(\n                                     cx,\n                                     REDUNDANT_STATIC_LIFETIMES,"}, {"sha": "1fda58fa54de1e4ee233794abcec3578fb0edcce", "filename": "src/tools/clippy/clippy_lints/src/regex.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fregex.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -172,7 +172,7 @@ fn check_regex<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, utf8: bool) {\n                     );\n                 },\n                 Err(e) => {\n-                    span_lint(cx, INVALID_REGEX, expr.span, &format!(\"regex syntax error: {}\", e));\n+                    span_lint(cx, INVALID_REGEX, expr.span, &format!(\"regex syntax error: {e}\"));\n                 },\n             }\n         }\n@@ -200,7 +200,7 @@ fn check_regex<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, utf8: bool) {\n                 );\n             },\n             Err(e) => {\n-                span_lint(cx, INVALID_REGEX, expr.span, &format!(\"regex syntax error: {}\", e));\n+                span_lint(cx, INVALID_REGEX, expr.span, &format!(\"regex syntax error: {e}\"));\n             },\n         }\n     }"}, {"sha": "2b2a41d160117a5f781cf7d389df8ad550e353d4", "filename": "src/tools/clippy/clippy_lints/src/returns.rs", "status": "modified", "additions": 89, "deletions": 123, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturns.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -1,9 +1,11 @@\n-use clippy_utils::diagnostics::span_lint_hir_and_then;\n+use clippy_utils::diagnostics::{span_lint_and_then, span_lint_hir_and_then};\n use clippy_utils::source::{snippet_opt, snippet_with_context};\n+use clippy_utils::visitors::{for_each_expr, Descend};\n use clippy_utils::{fn_def_id, path_to_local_id};\n+use core::ops::ControlFlow;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::intravisit::{walk_expr, FnKind, Visitor};\n+use rustc_hir::intravisit::FnKind;\n use rustc_hir::{Block, Body, Expr, ExprKind, FnDecl, HirId, MatchSource, PatKind, StmtKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n@@ -72,6 +74,27 @@ enum RetReplacement {\n     Unit,\n }\n \n+impl RetReplacement {\n+    fn sugg_help(self) -> &'static str {\n+        match self {\n+            Self::Empty => \"remove `return`\",\n+            Self::Block => \"replace `return` with an empty block\",\n+            Self::Unit => \"replace `return` with a unit value\",\n+        }\n+    }\n+}\n+\n+impl ToString for RetReplacement {\n+    fn to_string(&self) -> String {\n+        match *self {\n+            Self::Empty => \"\",\n+            Self::Block => \"{}\",\n+            Self::Unit => \"()\",\n+        }\n+        .to_string()\n+    }\n+}\n+\n declare_lint_pass!(Return => [LET_AND_RETURN, NEEDLESS_RETURN]);\n \n impl<'tcx> LateLintPass<'tcx> for Return {\n@@ -139,62 +162,67 @@ impl<'tcx> LateLintPass<'tcx> for Return {\n                 } else {\n                     RetReplacement::Empty\n                 };\n-                check_final_expr(cx, body.value, Some(body.value.span), replacement);\n+                check_final_expr(cx, body.value, vec![], replacement);\n             },\n             FnKind::ItemFn(..) | FnKind::Method(..) => {\n-                if let ExprKind::Block(block, _) = body.value.kind {\n-                    check_block_return(cx, block);\n-                }\n+                check_block_return(cx, &body.value.kind, vec![]);\n             },\n         }\n     }\n }\n \n-fn check_block_return<'tcx>(cx: &LateContext<'tcx>, block: &Block<'tcx>) {\n-    if let Some(expr) = block.expr {\n-        check_final_expr(cx, expr, Some(expr.span), RetReplacement::Empty);\n-    } else if let Some(stmt) = block.stmts.iter().last() {\n-        match stmt.kind {\n-            StmtKind::Expr(expr) | StmtKind::Semi(expr) => {\n-                check_final_expr(cx, expr, Some(stmt.span), RetReplacement::Empty);\n-            },\n-            _ => (),\n+// if `expr` is a block, check if there are needless returns in it\n+fn check_block_return<'tcx>(cx: &LateContext<'tcx>, expr_kind: &ExprKind<'tcx>, semi_spans: Vec<Span>) {\n+    if let ExprKind::Block(block, _) = expr_kind {\n+        if let Some(block_expr) = block.expr {\n+            check_final_expr(cx, block_expr, semi_spans, RetReplacement::Empty);\n+        } else if let Some(stmt) = block.stmts.iter().last() {\n+            match stmt.kind {\n+                StmtKind::Expr(expr) => {\n+                    check_final_expr(cx, expr, semi_spans, RetReplacement::Empty);\n+                },\n+                StmtKind::Semi(semi_expr) => {\n+                    let mut semi_spans_and_this_one = semi_spans;\n+                    // we only want the span containing the semicolon so we can remove it later. From `entry.rs:382`\n+                    if let Some(semicolon_span) = stmt.span.trim_start(semi_expr.span) {\n+                        semi_spans_and_this_one.push(semicolon_span);\n+                        check_final_expr(cx, semi_expr, semi_spans_and_this_one, RetReplacement::Empty);\n+                    }\n+                },\n+                _ => (),\n+            }\n         }\n     }\n }\n \n fn check_final_expr<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &'tcx Expr<'tcx>,\n-    span: Option<Span>,\n+    semi_spans: Vec<Span>, /* containing all the places where we would need to remove semicolons if finding an\n+                            * needless return */\n     replacement: RetReplacement,\n ) {\n-    match expr.kind {\n+    let peeled_drop_expr = expr.peel_drop_temps();\n+    match &peeled_drop_expr.kind {\n         // simple return is always \"bad\"\n         ExprKind::Ret(ref inner) => {\n             if cx.tcx.hir().attrs(expr.hir_id).is_empty() {\n                 let borrows = inner.map_or(false, |inner| last_statement_borrows(cx, inner));\n                 if !borrows {\n                     emit_return_lint(\n                         cx,\n-                        inner.map_or(expr.hir_id, |inner| inner.hir_id),\n-                        span.expect(\"`else return` is not possible\"),\n+                        peeled_drop_expr.span,\n+                        semi_spans,\n                         inner.as_ref().map(|i| i.span),\n                         replacement,\n                     );\n                 }\n             }\n         },\n-        // a whole block? check it!\n-        ExprKind::Block(block, _) => {\n-            check_block_return(cx, block);\n-        },\n         ExprKind::If(_, then, else_clause_opt) => {\n-            if let ExprKind::Block(ifblock, _) = then.kind {\n-                check_block_return(cx, ifblock);\n-            }\n+            check_block_return(cx, &then.kind, semi_spans.clone());\n             if let Some(else_clause) = else_clause_opt {\n-                check_final_expr(cx, else_clause, None, RetReplacement::Empty);\n+                check_block_return(cx, &else_clause.kind, semi_spans);\n             }\n         },\n         // a match expr, check all arms\n@@ -203,123 +231,61 @@ fn check_final_expr<'tcx>(\n         // (except for unit type functions) so we don't match it\n         ExprKind::Match(_, arms, MatchSource::Normal) => {\n             for arm in arms.iter() {\n-                check_final_expr(cx, arm.body, Some(arm.body.span), RetReplacement::Unit);\n+                check_final_expr(cx, arm.body, semi_spans.clone(), RetReplacement::Unit);\n             }\n         },\n-        ExprKind::DropTemps(expr) => check_final_expr(cx, expr, None, RetReplacement::Empty),\n-        _ => (),\n+        // if it's a whole block, check it\n+        other_expr_kind => check_block_return(cx, other_expr_kind, semi_spans),\n     }\n }\n \n fn emit_return_lint(\n     cx: &LateContext<'_>,\n-    emission_place: HirId,\n     ret_span: Span,\n+    semi_spans: Vec<Span>,\n     inner_span: Option<Span>,\n     replacement: RetReplacement,\n ) {\n     if ret_span.from_expansion() {\n         return;\n     }\n-    match inner_span {\n-        Some(inner_span) => {\n-            let mut applicability = Applicability::MachineApplicable;\n-            span_lint_hir_and_then(\n-                cx,\n-                NEEDLESS_RETURN,\n-                emission_place,\n-                ret_span,\n-                \"unneeded `return` statement\",\n-                |diag| {\n-                    let (snippet, _) = snippet_with_context(cx, inner_span, ret_span.ctxt(), \"..\", &mut applicability);\n-                    diag.span_suggestion(ret_span, \"remove `return`\", snippet, applicability);\n-                },\n-            );\n-        },\n-        None => match replacement {\n-            RetReplacement::Empty => {\n-                span_lint_hir_and_then(\n-                    cx,\n-                    NEEDLESS_RETURN,\n-                    emission_place,\n-                    ret_span,\n-                    \"unneeded `return` statement\",\n-                    |diag| {\n-                        diag.span_suggestion(\n-                            ret_span,\n-                            \"remove `return`\",\n-                            String::new(),\n-                            Applicability::MachineApplicable,\n-                        );\n-                    },\n-                );\n-            },\n-            RetReplacement::Block => {\n-                span_lint_hir_and_then(\n-                    cx,\n-                    NEEDLESS_RETURN,\n-                    emission_place,\n-                    ret_span,\n-                    \"unneeded `return` statement\",\n-                    |diag| {\n-                        diag.span_suggestion(\n-                            ret_span,\n-                            \"replace `return` with an empty block\",\n-                            \"{}\".to_string(),\n-                            Applicability::MachineApplicable,\n-                        );\n-                    },\n-                );\n-            },\n-            RetReplacement::Unit => {\n-                span_lint_hir_and_then(\n-                    cx,\n-                    NEEDLESS_RETURN,\n-                    emission_place,\n-                    ret_span,\n-                    \"unneeded `return` statement\",\n-                    |diag| {\n-                        diag.span_suggestion(\n-                            ret_span,\n-                            \"replace `return` with a unit value\",\n-                            \"()\".to_string(),\n-                            Applicability::MachineApplicable,\n-                        );\n-                    },\n-                );\n-            },\n+    let mut applicability = Applicability::MachineApplicable;\n+    let return_replacement = inner_span.map_or_else(\n+        || replacement.to_string(),\n+        |inner_span| {\n+            let (snippet, _) = snippet_with_context(cx, inner_span, ret_span.ctxt(), \"..\", &mut applicability);\n+            snippet.to_string()\n         },\n-    }\n+    );\n+    let sugg_help = if inner_span.is_some() {\n+        \"remove `return`\"\n+    } else {\n+        replacement.sugg_help()\n+    };\n+    span_lint_and_then(cx, NEEDLESS_RETURN, ret_span, \"unneeded `return` statement\", |diag| {\n+        diag.span_suggestion_hidden(ret_span, sugg_help, return_replacement, applicability);\n+        // for each parent statement, we need to remove the semicolon\n+        for semi_stmt_span in semi_spans {\n+            diag.tool_only_span_suggestion(semi_stmt_span, \"remove this semicolon\", \"\", applicability);\n+        }\n+    });\n }\n \n fn last_statement_borrows<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n-    let mut visitor = BorrowVisitor { cx, borrows: false };\n-    walk_expr(&mut visitor, expr);\n-    visitor.borrows\n-}\n-\n-struct BorrowVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,\n-    borrows: bool,\n-}\n-\n-impl<'tcx> Visitor<'tcx> for BorrowVisitor<'_, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n-        if self.borrows || expr.span.from_expansion() {\n-            return;\n-        }\n-\n-        if let Some(def_id) = fn_def_id(self.cx, expr) {\n-            self.borrows = self\n-                .cx\n+    for_each_expr(expr, |e| {\n+        if let Some(def_id) = fn_def_id(cx, e)\n+            && cx\n                 .tcx\n                 .fn_sig(def_id)\n-                .output()\n                 .skip_binder()\n+                .output()\n                 .walk()\n-                .any(|arg| matches!(arg.unpack(), GenericArgKind::Lifetime(_)));\n+                .any(|arg| matches!(arg.unpack(), GenericArgKind::Lifetime(_)))\n+        {\n+            ControlFlow::Break(())\n+        } else {\n+            ControlFlow::Continue(Descend::from(!expr.span.from_expansion()))\n         }\n-\n-        walk_expr(self, expr);\n-    }\n+    })\n+    .is_some()\n }"}, {"sha": "4249063d2d472087deea575cd55fa68f338582b3", "filename": "src/tools/clippy/clippy_lints/src/same_name_method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsame_name_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsame_name_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsame_name_method.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -108,7 +108,7 @@ impl<'tcx> LateLintPass<'tcx> for SameNameMethod {\n                                     |diag| {\n                                         diag.span_note(\n                                             trait_method_span,\n-                                            &format!(\"existing `{}` defined here\", method_name),\n+                                            &format!(\"existing `{method_name}` defined here\"),\n                                         );\n                                     },\n                                 );\n@@ -151,7 +151,7 @@ impl<'tcx> LateLintPass<'tcx> for SameNameMethod {\n                                         // iterate on trait_spans?\n                                         diag.span_note(\n                                             trait_spans[0],\n-                                            &format!(\"existing `{}` defined here\", method_name),\n+                                            &format!(\"existing `{method_name}` defined here\"),\n                                         );\n                                     },\n                                 );"}, {"sha": "66638eed998371394176d11b826b5a9a5c74bcc4", "filename": "src/tools/clippy/clippy_lints/src/semicolon_if_nothing_returned.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsemicolon_if_nothing_returned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsemicolon_if_nothing_returned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsemicolon_if_nothing_returned.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -54,7 +54,7 @@ impl<'tcx> LateLintPass<'tcx> for SemicolonIfNothingReturned {\n                 }\n \n                 let sugg = sugg::Sugg::hir_with_macro_callsite(cx, expr, \"..\");\n-                let suggestion = format!(\"{0};\", sugg);\n+                let suggestion = format!(\"{sugg};\");\n                 span_lint_and_sugg(\n                     cx,\n                     SEMICOLON_IF_NOTHING_RETURNED,"}, {"sha": "760399231513f8a4b15668e35fb606f1745f313e", "filename": "src/tools/clippy/clippy_lints/src/slow_vector_initialization.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fslow_vector_initialization.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -1,9 +1,10 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{get_enclosing_block, is_expr_path_def_path, path_to_local, path_to_local_id, paths, SpanlessEq};\n+use clippy_utils::{\n+    get_enclosing_block, is_integer_literal, is_path_diagnostic_item, path_to_local, path_to_local_id, SpanlessEq,\n+};\n use if_chain::if_chain;\n-use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_block, walk_expr, walk_stmt, Visitor};\n use rustc_hir::{BindingAnnotation, Block, Expr, ExprKind, HirId, PatKind, QPath, Stmt, StmtKind};\n@@ -174,7 +175,7 @@ impl SlowVectorInit {\n             diag.span_suggestion(\n                 vec_alloc.allocation_expr.span,\n                 \"consider replace allocation with\",\n-                format!(\"vec![0; {}]\", len_expr),\n+                format!(\"vec![0; {len_expr}]\"),\n                 Applicability::Unspecified,\n             );\n         });\n@@ -219,8 +220,7 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n             && path_to_local_id(self_arg, self.vec_alloc.local_id)\n             && path.ident.name == sym!(resize)\n             // Check that is filled with 0\n-            && let ExprKind::Lit(ref lit) = fill_arg.kind\n-            && let LitKind::Int(0, _) = lit.node {\n+            && is_integer_literal(fill_arg, 0) {\n                 // Check that len expression is equals to `with_capacity` expression\n                 if SpanlessEq::new(self.cx).eq_expr(len_arg, self.vec_alloc.len_expr) {\n                     self.slow_expression = Some(InitializationType::Resize(expr));\n@@ -254,10 +254,8 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n     fn is_repeat_zero(&self, expr: &Expr<'_>) -> bool {\n         if_chain! {\n             if let ExprKind::Call(fn_expr, [repeat_arg]) = expr.kind;\n-            if is_expr_path_def_path(self.cx, fn_expr, &paths::ITER_REPEAT);\n-            if let ExprKind::Lit(ref lit) = repeat_arg.kind;\n-            if let LitKind::Int(0, _) = lit.node;\n-\n+            if is_path_diagnostic_item(self.cx, fn_expr, sym::iter_repeat);\n+            if is_integer_literal(repeat_arg, 0);\n             then {\n                 true\n             } else {"}, {"sha": "d6b336bef943ec9510ec68221d34da9599a411e0", "filename": "src/tools/clippy/clippy_lints/src/std_instead_of_core.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstd_instead_of_core.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstd_instead_of_core.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstd_instead_of_core.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -1,6 +1,8 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n+use rustc_hir::def_id::DefId;\n use rustc_hir::{def::Res, HirId, Path, PathSegment};\n use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::DefIdTree;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::{sym, symbol::kw, Span};\n \n@@ -94,6 +96,7 @@ impl<'tcx> LateLintPass<'tcx> for StdReexports {\n     fn check_path(&mut self, cx: &LateContext<'tcx>, path: &Path<'tcx>, _: HirId) {\n         if let Res::Def(_, def_id) = path.res\n             && let Some(first_segment) = get_first_segment(path)\n+            && is_stable(cx, def_id)\n         {\n             let (lint, msg, help) = match first_segment.ident.name {\n                 sym::std => match cx.tcx.crate_name(def_id.krate) {\n@@ -146,3 +149,22 @@ fn get_first_segment<'tcx>(path: &Path<'tcx>) -> Option<&'tcx PathSegment<'tcx>>\n         _ => None,\n     }\n }\n+\n+/// Checks if all ancestors of `def_id` are stable, to avoid linting\n+/// [unstable moves](https://github.com/rust-lang/rust/pull/95956)\n+fn is_stable(cx: &LateContext<'_>, mut def_id: DefId) -> bool {\n+    loop {\n+        if cx\n+            .tcx\n+            .lookup_stability(def_id)\n+            .map_or(false, |stability| stability.is_unstable())\n+        {\n+            return false;\n+        }\n+\n+        match cx.tcx.opt_parent(def_id) {\n+            Some(parent) => def_id = parent,\n+            None => return true,\n+        }\n+    }\n+}"}, {"sha": "d356c99c8fc470c1cdd6371e3589acdbc3a8b8c4", "filename": "src/tools/clippy/clippy_lints/src/strings.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrings.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -284,7 +284,7 @@ impl<'tcx> LateLintPass<'tcx> for StringLitAsBytes {\n                     e.span,\n                     \"calling a slice of `as_bytes()` with `from_utf8` should be not necessary\",\n                     \"try\",\n-                    format!(\"Some(&{}[{}])\", snippet_app, snippet(cx, right.span, \"..\")),\n+                    format!(\"Some(&{snippet_app}[{}])\", snippet(cx, right.span, \"..\")),\n                     applicability\n                 )\n             }\n@@ -500,8 +500,8 @@ impl<'tcx> LateLintPass<'tcx> for TrimSplitWhitespace {\n                     cx,\n                     TRIM_SPLIT_WHITESPACE,\n                     trim_span.with_hi(split_ws_span.lo()),\n-                    &format!(\"found call to `str::{}` before `str::split_whitespace`\", trim_fn_name),\n-                    &format!(\"remove `{}()`\", trim_fn_name),\n+                    &format!(\"found call to `str::{trim_fn_name}` before `str::split_whitespace`\"),\n+                    &format!(\"remove `{trim_fn_name}()`\"),\n                     String::new(),\n                     Applicability::MachineApplicable,\n                 );"}, {"sha": "03324c66e8efcf9796fc9314c6f1ab961ad878c8", "filename": "src/tools/clippy/clippy_lints/src/strlen_on_c_strings.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrlen_on_c_strings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrlen_on_c_strings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrlen_on_c_strings.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -79,7 +79,7 @@ impl<'tcx> LateLintPass<'tcx> for StrlenOnCStrings {\n                     span,\n                     \"using `libc::strlen` on a `CString` or `CStr` value\",\n                     \"try this\",\n-                    format!(\"{}.{}().len()\", val_name, method_name),\n+                    format!(\"{val_name}.{method_name}().len()\"),\n                     app,\n                 );\n             }"}, {"sha": "eef9bdc78494002515ec1e615bc726062eaaf1bd", "filename": "src/tools/clippy/clippy_lints/src/suspicious_operation_groupings.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -326,8 +326,7 @@ fn replace_left_sugg(\n     applicability: &mut Applicability,\n ) -> String {\n     format!(\n-        \"{} {} {}\",\n-        left_suggestion,\n+        \"{left_suggestion} {} {}\",\n         binop.op.to_string(),\n         snippet_with_applicability(cx, binop.right.span, \"..\", applicability),\n     )\n@@ -340,10 +339,9 @@ fn replace_right_sugg(\n     applicability: &mut Applicability,\n ) -> String {\n     format!(\n-        \"{} {} {}\",\n+        \"{} {} {right_suggestion}\",\n         snippet_with_applicability(cx, binop.left.span, \"..\", applicability),\n         binop.op.to_string(),\n-        right_suggestion,\n     )\n }\n \n@@ -676,9 +674,8 @@ fn suggestion_with_swapped_ident(\n         }\n \n         Some(format!(\n-            \"{}{}{}\",\n+            \"{}{new_ident}{}\",\n             snippet_with_applicability(cx, expr.span.with_hi(current_ident.span.lo()), \"..\", applicability),\n-            new_ident,\n             snippet_with_applicability(cx, expr.span.with_lo(current_ident.span.hi()), \"..\", applicability),\n         ))\n     })"}, {"sha": "b57b484bdc897ed87aa85ae99daa1147153818c5", "filename": "src/tools/clippy/clippy_lints/src/suspicious_trait_impl.rs", "status": "modified", "additions": 13, "deletions": 20, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -1,8 +1,9 @@\n use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::visitors::for_each_expr;\n use clippy_utils::{binop_traits, trait_ref_of_method, BINOP_TRAITS, OP_ASSIGN_TRAITS};\n+use core::ops::ControlFlow;\n use if_chain::if_chain;\n use rustc_hir as hir;\n-use rustc_hir::intravisit::{walk_expr, Visitor};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n@@ -92,25 +93,17 @@ impl<'tcx> LateLintPass<'tcx> for SuspiciousImpl {\n }\n \n fn count_binops(expr: &hir::Expr<'_>) -> u32 {\n-    let mut visitor = BinaryExprVisitor::default();\n-    visitor.visit_expr(expr);\n-    visitor.nb_binops\n-}\n-\n-#[derive(Default)]\n-struct BinaryExprVisitor {\n-    nb_binops: u32,\n-}\n-\n-impl<'tcx> Visitor<'tcx> for BinaryExprVisitor {\n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n-        match expr.kind {\n+    let mut count = 0u32;\n+    let _: Option<!> = for_each_expr(expr, |e| {\n+        if matches!(\n+            e.kind,\n             hir::ExprKind::Binary(..)\n-            | hir::ExprKind::Unary(hir::UnOp::Not | hir::UnOp::Neg, _)\n-            | hir::ExprKind::AssignOp(..) => self.nb_binops += 1,\n-            _ => {},\n+                | hir::ExprKind::Unary(hir::UnOp::Not | hir::UnOp::Neg, _)\n+                | hir::ExprKind::AssignOp(..)\n+        ) {\n+            count += 1;\n         }\n-\n-        walk_expr(self, expr);\n-    }\n+        ControlFlow::Continue(())\n+    });\n+    count\n }"}, {"sha": "f46c21e126552f1681438ac10ae6399a2776a963", "filename": "src/tools/clippy/clippy_lints/src/swap.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fswap.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -96,7 +96,7 @@ fn generate_swap_warning(cx: &LateContext<'_>, e1: &Expr<'_>, e2: &Expr<'_>, spa\n                             cx,\n                             MANUAL_SWAP,\n                             span,\n-                            &format!(\"this looks like you are swapping elements of `{}` manually\", slice),\n+                            &format!(\"this looks like you are swapping elements of `{slice}` manually\"),\n                             \"try\",\n                             format!(\n                                 \"{}.swap({}, {})\",\n@@ -121,16 +121,16 @@ fn generate_swap_warning(cx: &LateContext<'_>, e1: &Expr<'_>, e2: &Expr<'_>, spa\n         cx,\n         MANUAL_SWAP,\n         span,\n-        &format!(\"this looks like you are swapping `{}` and `{}` manually\", first, second),\n+        &format!(\"this looks like you are swapping `{first}` and `{second}` manually\"),\n         |diag| {\n             diag.span_suggestion(\n                 span,\n                 \"try\",\n-                format!(\"{}::mem::swap({}, {})\", sugg, first.mut_addr(), second.mut_addr()),\n+                format!(\"{sugg}::mem::swap({}, {})\", first.mut_addr(), second.mut_addr()),\n                 applicability,\n             );\n             if !is_xor_based {\n-                diag.note(&format!(\"or maybe you should use `{}::mem::replace`?\", sugg));\n+                diag.note(&format!(\"or maybe you should use `{sugg}::mem::replace`?\"));\n             }\n         },\n     );\n@@ -182,7 +182,7 @@ fn check_suspicious_swap(cx: &LateContext<'_>, block: &Block<'_>) {\n                 let rhs0 = Sugg::hir_opt(cx, rhs0);\n                 let (what, lhs, rhs) = if let (Some(first), Some(second)) = (lhs0, rhs0) {\n                     (\n-                        format!(\" `{}` and `{}`\", first, second),\n+                        format!(\" `{first}` and `{second}`\"),\n                         first.mut_addr().to_string(),\n                         second.mut_addr().to_string(),\n                     )\n@@ -196,22 +196,19 @@ fn check_suspicious_swap(cx: &LateContext<'_>, block: &Block<'_>) {\n                 span_lint_and_then(cx,\n                     ALMOST_SWAPPED,\n                     span,\n-                    &format!(\"this looks like you are trying to swap{}\", what),\n+                    &format!(\"this looks like you are trying to swap{what}\"),\n                     |diag| {\n                         if !what.is_empty() {\n                             diag.span_suggestion(\n                                 span,\n                                 \"try\",\n                                 format!(\n-                                    \"{}::mem::swap({}, {})\",\n-                                    sugg,\n-                                    lhs,\n-                                    rhs,\n+                                    \"{sugg}::mem::swap({lhs}, {rhs})\",\n                                 ),\n                                 Applicability::MaybeIncorrect,\n                             );\n                             diag.note(\n-                                &format!(\"or maybe you should use `{}::mem::replace`?\", sugg)\n+                                &format!(\"or maybe you should use `{sugg}::mem::replace`?\")\n                             );\n                         }\n                     });"}, {"sha": "d085dda3582bee65c259b7827294b0a582e818e5", "filename": "src/tools/clippy/clippy_lints/src/swap_ptr_to_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fswap_ptr_to_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fswap_ptr_to_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fswap_ptr_to_ref.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -58,7 +58,7 @@ impl LateLintPass<'_> for SwapPtrToRef {\n                         let mut app = Applicability::MachineApplicable;\n                         let snip1 = snippet_with_context(cx, arg1_span.unwrap_or(arg1.span), ctxt, \"..\", &mut app).0;\n                         let snip2 = snippet_with_context(cx, arg2_span.unwrap_or(arg2.span), ctxt, \"..\", &mut app).0;\n-                        diag.span_suggestion(e.span, \"use ptr::swap\", format!(\"core::ptr::swap({}, {})\", snip1, snip2), app);\n+                        diag.span_suggestion(e.span, \"use ptr::swap\", format!(\"core::ptr::swap({snip1}, {snip2})\"), app);\n                     }\n                 }\n             );"}, {"sha": "2512500a6be73d1db226109368e558bcd553f9df", "filename": "src/tools/clippy/clippy_lints/src/to_digit_is_some.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fto_digit_is_some.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fto_digit_is_some.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fto_digit_is_some.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -84,9 +84,9 @@ impl<'tcx> LateLintPass<'tcx> for ToDigitIsSome {\n                         \"use of `.to_digit(..).is_some()`\",\n                         \"try this\",\n                         if is_method_call {\n-                            format!(\"{}.is_digit({})\", char_arg_snip, radix_snip)\n+                            format!(\"{char_arg_snip}.is_digit({radix_snip})\")\n                         } else {\n-                            format!(\"char::is_digit({}, {})\", char_arg_snip, radix_snip)\n+                            format!(\"char::is_digit({char_arg_snip}, {radix_snip})\")\n                         },\n                         applicability,\n                     );"}, {"sha": "b5f11b4acae020e57f38d2fbf82cb0d7c1de57ea", "filename": "src/tools/clippy/clippy_lints/src/trait_bounds.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrait_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrait_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrait_bounds.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -215,9 +215,8 @@ impl TraitBounds {\n                         .map(|(_, _, span)| snippet_with_applicability(cx, span, \"..\", &mut applicability))\n                         .join(\" + \");\n                     let hint_string = format!(\n-                        \"consider combining the bounds: `{}: {}`\",\n+                        \"consider combining the bounds: `{}: {trait_bounds}`\",\n                         snippet(cx, p.bounded_ty.span, \"_\"),\n-                        trait_bounds,\n                     );\n                     span_lint_and_help(\n                         cx,"}, {"sha": "c4b9d82fc735bb05cbacea7481aee9f8c31bebd6", "filename": "src/tools/clippy/clippy_lints/src/transmute/crosspointer_transmute.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Fcrosspointer_transmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Fcrosspointer_transmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Fcrosspointer_transmute.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -13,10 +13,7 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, from_ty: Ty\n                 cx,\n                 CROSSPOINTER_TRANSMUTE,\n                 e.span,\n-                &format!(\n-                    \"transmute from a type (`{}`) to the type that it points to (`{}`)\",\n-                    from_ty, to_ty\n-                ),\n+                &format!(\"transmute from a type (`{from_ty}`) to the type that it points to (`{to_ty}`)\"),\n             );\n             true\n         },\n@@ -25,10 +22,7 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, from_ty: Ty\n                 cx,\n                 CROSSPOINTER_TRANSMUTE,\n                 e.span,\n-                &format!(\n-                    \"transmute from a type (`{}`) to a pointer to that type (`{}`)\",\n-                    from_ty, to_ty\n-                ),\n+                &format!(\"transmute from a type (`{from_ty}`) to a pointer to that type (`{to_ty}`)\"),\n             );\n             true\n         },"}, {"sha": "5ecba512b0fd64e9b0414f6dab5216031c37a989", "filename": "src/tools/clippy/clippy_lints/src/transmute/transmute_float_to_int.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_float_to_int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_float_to_int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_float_to_int.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -24,7 +24,7 @@ pub(super) fn check<'tcx>(\n                 cx,\n                 TRANSMUTE_FLOAT_TO_INT,\n                 e.span,\n-                &format!(\"transmute from a `{}` to a `{}`\", from_ty, to_ty),\n+                &format!(\"transmute from a `{from_ty}` to a `{to_ty}`\"),\n                 |diag| {\n                     let mut sugg = sugg::Sugg::hir(cx, arg, \"..\");\n \n@@ -38,7 +38,7 @@ pub(super) fn check<'tcx>(\n                         if let ExprKind::Lit(lit) = &arg.kind;\n                         if let ast::LitKind::Float(_, ast::LitFloatType::Unsuffixed) = lit.node;\n                         then {\n-                            let op = format!(\"{}{}\", sugg, float_ty.name_str()).into();\n+                            let op = format!(\"{sugg}{}\", float_ty.name_str()).into();\n                             match sugg {\n                                 sugg::Sugg::MaybeParen(_) => sugg = sugg::Sugg::MaybeParen(op),\n                                 _ => sugg = sugg::Sugg::NonParen(op)"}, {"sha": "58227c53de2f1c13c1015b3b6d4d5a8707079cee", "filename": "src/tools/clippy/clippy_lints/src/transmute/transmute_int_to_bool.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_bool.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -23,7 +23,7 @@ pub(super) fn check<'tcx>(\n                 cx,\n                 TRANSMUTE_INT_TO_BOOL,\n                 e.span,\n-                &format!(\"transmute from a `{}` to a `bool`\", from_ty),\n+                &format!(\"transmute from a `{from_ty}` to a `bool`\"),\n                 |diag| {\n                     let arg = sugg::Sugg::hir(cx, arg, \"..\");\n                     let zero = sugg::Sugg::NonParen(Cow::from(\"0\"));"}, {"sha": "7d31c375f8cf2607c9ea00f45800138d07daaf62", "filename": "src/tools/clippy/clippy_lints/src/transmute/transmute_int_to_char.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_char.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_char.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_char.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -23,7 +23,7 @@ pub(super) fn check<'tcx>(\n                 cx,\n                 TRANSMUTE_INT_TO_CHAR,\n                 e.span,\n-                &format!(\"transmute from a `{}` to a `char`\", from_ty),\n+                &format!(\"transmute from a `{from_ty}` to a `char`\"),\n                 |diag| {\n                     let arg = sugg::Sugg::hir(cx, arg, \"..\");\n                     let arg = if let ty::Int(_) = from_ty.kind() {\n@@ -34,7 +34,7 @@ pub(super) fn check<'tcx>(\n                     diag.span_suggestion(\n                         e.span,\n                         \"consider using\",\n-                        format!(\"std::char::from_u32({}).unwrap()\", arg),\n+                        format!(\"std::char::from_u32({arg}).unwrap()\"),\n                         Applicability::Unspecified,\n                     );\n                 },"}, {"sha": "cc3422edbbf13333c6987f0611064e3d9ee6abb3", "filename": "src/tools/clippy/clippy_lints/src/transmute/transmute_int_to_float.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_float.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_float.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_float.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -22,7 +22,7 @@ pub(super) fn check<'tcx>(\n                 cx,\n                 TRANSMUTE_INT_TO_FLOAT,\n                 e.span,\n-                &format!(\"transmute from a `{}` to a `{}`\", from_ty, to_ty),\n+                &format!(\"transmute from a `{from_ty}` to a `{to_ty}`\"),\n                 |diag| {\n                     let arg = sugg::Sugg::hir(cx, arg, \"..\");\n                     let arg = if let ty::Int(int_ty) = from_ty.kind() {\n@@ -36,7 +36,7 @@ pub(super) fn check<'tcx>(\n                     diag.span_suggestion(\n                         e.span,\n                         \"consider using\",\n-                        format!(\"{}::from_bits({})\", to_ty, arg),\n+                        format!(\"{to_ty}::from_bits({arg})\"),\n                         Applicability::Unspecified,\n                     );\n                 },"}, {"sha": "009d5a7c8ae182a7f0559cde03f2262ed62dfeaa", "filename": "src/tools/clippy/clippy_lints/src/transmute/transmute_num_to_bytes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_num_to_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_num_to_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_num_to_bytes.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -31,13 +31,13 @@ pub(super) fn check<'tcx>(\n                 cx,\n                 TRANSMUTE_NUM_TO_BYTES,\n                 e.span,\n-                &format!(\"transmute from a `{}` to a `{}`\", from_ty, to_ty),\n+                &format!(\"transmute from a `{from_ty}` to a `{to_ty}`\"),\n                 |diag| {\n                     let arg = sugg::Sugg::hir(cx, arg, \"..\");\n                     diag.span_suggestion(\n                         e.span,\n                         \"consider using `to_ne_bytes()`\",\n-                        format!(\"{}.to_ne_bytes()\", arg),\n+                        format!(\"{arg}.to_ne_bytes()\"),\n                         Applicability::Unspecified,\n                     );\n                 },"}, {"sha": "12d0b866e1c9bbcada978b4d065557fea93080d8", "filename": "src/tools/clippy/clippy_lints/src/transmute/transmute_ptr_to_ref.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ptr_to_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ptr_to_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ptr_to_ref.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -25,10 +25,7 @@ pub(super) fn check<'tcx>(\n                 cx,\n                 TRANSMUTE_PTR_TO_REF,\n                 e.span,\n-                &format!(\n-                    \"transmute from a pointer type (`{}`) to a reference type (`{}`)\",\n-                    from_ty, to_ty\n-                ),\n+                &format!(\"transmute from a pointer type (`{from_ty}`) to a reference type (`{to_ty}`)\"),\n                 |diag| {\n                     let arg = sugg::Sugg::hir(cx, arg, \"..\");\n                     let (deref, cast) = if *mutbl == Mutability::Mut {\n@@ -41,26 +38,25 @@ pub(super) fn check<'tcx>(\n                     let sugg = if let Some(ty) = get_explicit_type(path) {\n                         let ty_snip = snippet_with_applicability(cx, ty.span, \"..\", &mut app);\n                         if meets_msrv(msrv, msrvs::POINTER_CAST) {\n-                            format!(\"{}{}.cast::<{}>()\", deref, arg.maybe_par(), ty_snip)\n+                            format!(\"{deref}{}.cast::<{ty_snip}>()\", arg.maybe_par())\n                         } else if from_ptr_ty.has_erased_regions() {\n-                            sugg::make_unop(deref, arg.as_ty(format!(\"{} () as {} {}\", cast, cast, ty_snip)))\n-                                .to_string()\n+                            sugg::make_unop(deref, arg.as_ty(format!(\"{cast} () as {cast} {ty_snip}\"))).to_string()\n                         } else {\n-                            sugg::make_unop(deref, arg.as_ty(format!(\"{} {}\", cast, ty_snip))).to_string()\n+                            sugg::make_unop(deref, arg.as_ty(format!(\"{cast} {ty_snip}\"))).to_string()\n                         }\n                     } else if from_ptr_ty.ty == *to_ref_ty {\n                         if from_ptr_ty.has_erased_regions() {\n                             if meets_msrv(msrv, msrvs::POINTER_CAST) {\n-                                format!(\"{}{}.cast::<{}>()\", deref, arg.maybe_par(), to_ref_ty)\n+                                format!(\"{deref}{}.cast::<{to_ref_ty}>()\", arg.maybe_par())\n                             } else {\n-                                sugg::make_unop(deref, arg.as_ty(format!(\"{} () as {} {}\", cast, cast, to_ref_ty)))\n+                                sugg::make_unop(deref, arg.as_ty(format!(\"{cast} () as {cast} {to_ref_ty}\")))\n                                     .to_string()\n                             }\n                         } else {\n                             sugg::make_unop(deref, arg).to_string()\n                         }\n                     } else {\n-                        sugg::make_unop(deref, arg.as_ty(format!(\"{} {}\", cast, to_ref_ty))).to_string()\n+                        sugg::make_unop(deref, arg.as_ty(format!(\"{cast} {to_ref_ty}\"))).to_string()\n                     };\n \n                     diag.span_suggestion(e.span, \"try\", sugg, app);"}, {"sha": "afb7f2e13269648a14178a7a03253a7b3817732a", "filename": "src/tools/clippy/clippy_lints/src/transmute/transmute_ref_to_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ref_to_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ref_to_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ref_to_ref.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -38,7 +38,7 @@ pub(super) fn check<'tcx>(\n                     cx,\n                     TRANSMUTE_BYTES_TO_STR,\n                     e.span,\n-                    &format!(\"transmute from a `{}` to a `{}`\", from_ty, to_ty),\n+                    &format!(\"transmute from a `{from_ty}` to a `{to_ty}`\"),\n                     \"consider using\",\n                     if const_context {\n                         format!(\"std::str::from_utf8_unchecked{postfix}({snippet})\")"}, {"sha": "1c99a02e6c71ebc85a016fb3f75b0193c8bbf791", "filename": "src/tools/clippy/clippy_lints/src/transmute/transmute_undefined_repr.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -75,10 +75,10 @@ pub(super) fn check<'tcx>(\n                     cx,\n                     TRANSMUTE_UNDEFINED_REPR,\n                     e.span,\n-                    &format!(\"transmute from `{}` which has an undefined layout\", from_ty_orig),\n+                    &format!(\"transmute from `{from_ty_orig}` which has an undefined layout\"),\n                     |diag| {\n                         if from_ty_orig.peel_refs() != from_ty.peel_refs() {\n-                            diag.note(&format!(\"the contained type `{}` has an undefined layout\", from_ty));\n+                            diag.note(&format!(\"the contained type `{from_ty}` has an undefined layout\"));\n                         }\n                     },\n                 );\n@@ -89,10 +89,10 @@ pub(super) fn check<'tcx>(\n                     cx,\n                     TRANSMUTE_UNDEFINED_REPR,\n                     e.span,\n-                    &format!(\"transmute to `{}` which has an undefined layout\", to_ty_orig),\n+                    &format!(\"transmute to `{to_ty_orig}` which has an undefined layout\"),\n                     |diag| {\n                         if to_ty_orig.peel_refs() != to_ty.peel_refs() {\n-                            diag.note(&format!(\"the contained type `{}` has an undefined layout\", to_ty));\n+                            diag.note(&format!(\"the contained type `{to_ty}` has an undefined layout\"));\n                         }\n                     },\n                 );\n@@ -116,8 +116,7 @@ pub(super) fn check<'tcx>(\n                     TRANSMUTE_UNDEFINED_REPR,\n                     e.span,\n                     &format!(\n-                        \"transmute from `{}` to `{}`, both of which have an undefined layout\",\n-                        from_ty_orig, to_ty_orig\n+                        \"transmute from `{from_ty_orig}` to `{to_ty_orig}`, both of which have an undefined layout\"\n                     ),\n                     |diag| {\n                         if let Some(same_adt_did) = same_adt_did {\n@@ -127,10 +126,10 @@ pub(super) fn check<'tcx>(\n                             ));\n                         } else {\n                             if from_ty_orig.peel_refs() != from_ty {\n-                                diag.note(&format!(\"the contained type `{}` has an undefined layout\", from_ty));\n+                                diag.note(&format!(\"the contained type `{from_ty}` has an undefined layout\"));\n                             }\n                             if to_ty_orig.peel_refs() != to_ty {\n-                                diag.note(&format!(\"the contained type `{}` has an undefined layout\", to_ty));\n+                                diag.note(&format!(\"the contained type `{to_ty}` has an undefined layout\"));\n                             }\n                         }\n                     },\n@@ -145,10 +144,10 @@ pub(super) fn check<'tcx>(\n                     cx,\n                     TRANSMUTE_UNDEFINED_REPR,\n                     e.span,\n-                    &format!(\"transmute from `{}` which has an undefined layout\", from_ty_orig),\n+                    &format!(\"transmute from `{from_ty_orig}` which has an undefined layout\"),\n                     |diag| {\n                         if from_ty_orig.peel_refs() != from_ty {\n-                            diag.note(&format!(\"the contained type `{}` has an undefined layout\", from_ty));\n+                            diag.note(&format!(\"the contained type `{from_ty}` has an undefined layout\"));\n                         }\n                     },\n                 );\n@@ -162,10 +161,10 @@ pub(super) fn check<'tcx>(\n                     cx,\n                     TRANSMUTE_UNDEFINED_REPR,\n                     e.span,\n-                    &format!(\"transmute into `{}` which has an undefined layout\", to_ty_orig),\n+                    &format!(\"transmute into `{to_ty_orig}` which has an undefined layout\"),\n                     |diag| {\n                         if to_ty_orig.peel_refs() != to_ty {\n-                            diag.note(&format!(\"the contained type `{}` has an undefined layout\", to_ty));\n+                            diag.note(&format!(\"the contained type `{to_ty}` has an undefined layout\"));\n                         }\n                     },\n                 );"}, {"sha": "6b444922a7cc755b7907a28a12617dc6eacb2ede", "filename": "src/tools/clippy/clippy_lints/src/transmute/transmutes_expressible_as_ptr_casts.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmutes_expressible_as_ptr_casts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmutes_expressible_as_ptr_casts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmutes_expressible_as_ptr_casts.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -21,10 +21,7 @@ pub(super) fn check<'tcx>(\n             cx,\n             TRANSMUTES_EXPRESSIBLE_AS_PTR_CASTS,\n             e.span,\n-            &format!(\n-                \"transmute from `{}` to `{}` which could be expressed as a pointer cast instead\",\n-                from_ty, to_ty\n-            ),\n+            &format!(\"transmute from `{from_ty}` to `{to_ty}` which could be expressed as a pointer cast instead\"),\n             |diag| {\n                 if let Some(arg) = sugg::Sugg::hir_opt(cx, arg) {\n                     let sugg = arg.as_ty(&to_ty.to_string()).to_string();"}, {"sha": "19ce5ae72c24e8f7b21dd162fc9dcd29e8d81bd0", "filename": "src/tools/clippy/clippy_lints/src/transmute/transmuting_null.rs", "status": "modified", "additions": 15, "deletions": 26, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmuting_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmuting_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmuting_null.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -1,8 +1,6 @@\n use clippy_utils::consts::{constant_context, Constant};\n use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::is_path_diagnostic_item;\n-use if_chain::if_chain;\n-use rustc_ast::LitKind;\n+use clippy_utils::{is_integer_literal, is_path_diagnostic_item};\n use rustc_hir::{Expr, ExprKind};\n use rustc_lint::LateContext;\n use rustc_middle::ty::Ty;\n@@ -19,37 +17,28 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, arg: &'t\n \n     // Catching transmute over constants that resolve to `null`.\n     let mut const_eval_context = constant_context(cx, cx.typeck_results());\n-    if_chain! {\n-        if let ExprKind::Path(ref _qpath) = arg.kind;\n-        if let Some(Constant::RawPtr(x)) = const_eval_context.expr(arg);\n-        if x == 0;\n-        then {\n-            span_lint(cx, TRANSMUTING_NULL, expr.span, LINT_MSG);\n-            return true;\n-        }\n+    if let ExprKind::Path(ref _qpath) = arg.kind &&\n+        let Some(Constant::RawPtr(x)) = const_eval_context.expr(arg) &&\n+        x == 0\n+    {\n+        span_lint(cx, TRANSMUTING_NULL, expr.span, LINT_MSG);\n+        return true;\n     }\n \n     // Catching:\n     // `std::mem::transmute(0 as *const i32)`\n-    if_chain! {\n-        if let ExprKind::Cast(inner_expr, _cast_ty) = arg.kind;\n-        if let ExprKind::Lit(ref lit) = inner_expr.kind;\n-        if let LitKind::Int(0, _) = lit.node;\n-        then {\n-            span_lint(cx, TRANSMUTING_NULL, expr.span, LINT_MSG);\n-            return true;\n-        }\n+    if let ExprKind::Cast(inner_expr, _cast_ty) = arg.kind && is_integer_literal(inner_expr, 0) {\n+        span_lint(cx, TRANSMUTING_NULL, expr.span, LINT_MSG);\n+        return true;\n     }\n \n     // Catching:\n     // `std::mem::transmute(std::ptr::null::<i32>())`\n-    if_chain! {\n-        if let ExprKind::Call(func1, []) = arg.kind;\n-        if is_path_diagnostic_item(cx, func1, sym::ptr_null);\n-        then {\n-            span_lint(cx, TRANSMUTING_NULL, expr.span, LINT_MSG);\n-            return true;\n-        }\n+    if let ExprKind::Call(func1, []) = arg.kind &&\n+        is_path_diagnostic_item(cx, func1, sym::ptr_null)\n+    {\n+        span_lint(cx, TRANSMUTING_NULL, expr.span, LINT_MSG);\n+        return true;\n     }\n \n     // FIXME:"}, {"sha": "b1445311b711215f4c50ff0909d64a2c2578006d", "filename": "src/tools/clippy/clippy_lints/src/transmute/unsound_collection_transmute.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Funsound_collection_transmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Funsound_collection_transmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Funsound_collection_transmute.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -37,10 +37,7 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, from_ty: Ty\n                     cx,\n                     UNSOUND_COLLECTION_TRANSMUTE,\n                     e.span,\n-                    &format!(\n-                        \"transmute from `{}` to `{}` with mismatched layout is unsound\",\n-                        from_ty, to_ty\n-                    ),\n+                    &format!(\"transmute from `{from_ty}` to `{to_ty}` with mismatched layout is unsound\"),\n                 );\n                 true\n             } else {"}, {"sha": "f919bbd5afca3f823c9458c815ae7f8fab5e9fbe", "filename": "src/tools/clippy/clippy_lints/src/transmute/useless_transmute.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Fuseless_transmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Fuseless_transmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Fuseless_transmute.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -21,7 +21,7 @@ pub(super) fn check<'tcx>(\n                 cx,\n                 USELESS_TRANSMUTE,\n                 e.span,\n-                &format!(\"transmute from a type (`{}`) to itself\", from_ty),\n+                &format!(\"transmute from a type (`{from_ty}`) to itself\"),\n             );\n             true\n         },"}, {"sha": "b567d92230bb1cbe4085a444dbb6843b7b7a81bc", "filename": "src/tools/clippy/clippy_lints/src/transmute/utils.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Futils.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -1,8 +1,11 @@\n use rustc_hir::Expr;\n+use rustc_hir_analysis::check::{\n+    cast::{self, CastCheckResult},\n+    FnCtxt, Inherited,\n+};\n use rustc_lint::LateContext;\n use rustc_middle::ty::{cast::CastKind, Ty};\n use rustc_span::DUMMY_SP;\n-use rustc_hir_analysis::check::{cast::{self, CastCheckResult}, FnCtxt, Inherited};\n \n // check if the component types of the transmuted collection and the result have different ABI,\n // size or alignment"}, {"sha": "d1965565b9261a3462a1734d905a56afdd7dc038", "filename": "src/tools/clippy/clippy_lints/src/transmute/wrong_transmute.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Fwrong_transmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Fwrong_transmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Fwrong_transmute.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -13,7 +13,7 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, from_ty: Ty\n                 cx,\n                 WRONG_TRANSMUTE,\n                 e.span,\n-                &format!(\"transmute from a `{}` to a pointer\", from_ty),\n+                &format!(\"transmute from a `{from_ty}` to a pointer\"),\n             );\n             true\n         },"}, {"sha": "9c6629958401b24231f7852b77c20ec9dc53d16f", "filename": "src/tools/clippy/clippy_lints/src/types/borrowed_box.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fborrowed_box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fborrowed_box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fborrowed_box.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -49,15 +49,15 @@ pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, lt: &Lifetime, m\n                     let inner_snippet = snippet(cx, inner.span, \"..\");\n                     let suggestion = match &inner.kind {\n                         TyKind::TraitObject(bounds, lt_bound, _) if bounds.len() > 1 || !lt_bound.is_elided() => {\n-                            format!(\"&{}({})\", ltopt, &inner_snippet)\n+                            format!(\"&{ltopt}({})\", &inner_snippet)\n                         },\n                         TyKind::Path(qpath)\n                             if get_bounds_if_impl_trait(cx, qpath, inner.hir_id)\n                                 .map_or(false, |bounds| bounds.len() > 1) =>\n                         {\n-                            format!(\"&{}({})\", ltopt, &inner_snippet)\n+                            format!(\"&{ltopt}({})\", &inner_snippet)\n                         },\n-                        _ => format!(\"&{}{}\", ltopt, &inner_snippet),\n+                        _ => format!(\"&{ltopt}{}\", &inner_snippet),\n                     };\n                     span_lint_and_sugg(\n                         cx,"}, {"sha": "08020ce663817e1f2b8a60871d206068740d7474", "filename": "src/tools/clippy/clippy_lints/src/types/box_collection.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fbox_collection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fbox_collection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fbox_collection.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -16,7 +16,7 @@ pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_\n                 _ => \"<..>\",\n             };\n \n-            let box_content = format!(\"{outer}{generic}\", outer = item_type);\n+            let box_content = format!(\"{item_type}{generic}\");\n             span_lint_and_help(\n                 cx,\n                 BOX_COLLECTION,"}, {"sha": "79c31efb9fcdfb1accd261691499f97c5149b9bd", "filename": "src/tools/clippy/clippy_lints/src/types/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fmod.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -352,8 +352,10 @@ impl<'tcx> LateLintPass<'tcx> for Types {\n     fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx ImplItem<'_>) {\n         match item.kind {\n             ImplItemKind::Const(ty, _) => {\n-                let is_in_trait_impl = if let Some(hir::Node::Item(item)) =\n-                    cx.tcx.hir().find_by_def_id(cx.tcx.hir().get_parent_item(item.hir_id()).def_id)\n+                let is_in_trait_impl = if let Some(hir::Node::Item(item)) = cx\n+                    .tcx\n+                    .hir()\n+                    .find_by_def_id(cx.tcx.hir().get_parent_item(item.hir_id()).def_id)\n                 {\n                     matches!(item.kind, ItemKind::Impl(hir::Impl { of_trait: Some(_), .. }))\n                 } else {\n@@ -535,7 +537,7 @@ impl Types {\n                     QPath::LangItem(..) => {},\n                 }\n             },\n-            TyKind::Rptr(ref lt, ref mut_ty) => {\n+            TyKind::Rptr(lt, ref mut_ty) => {\n                 context.is_nested_call = true;\n                 if !borrowed_box::check(cx, hir_ty, lt, mut_ty) {\n                     self.check_ty(cx, mut_ty.ty, context);"}, {"sha": "6b9de64e24c93875b41de0b5fdd09de632acdcf1", "filename": "src/tools/clippy/clippy_lints/src/types/rc_buffer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Frc_buffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Frc_buffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Frc_buffer.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -17,7 +17,7 @@ pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_\n                 hir_ty.span,\n                 \"usage of `Rc<T>` when T is a buffer type\",\n                 \"try\",\n-                format!(\"Rc<{}>\", alternate),\n+                format!(\"Rc<{alternate}>\"),\n                 Applicability::MachineApplicable,\n             );\n         } else {\n@@ -57,7 +57,7 @@ pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_\n                 hir_ty.span,\n                 \"usage of `Arc<T>` when T is a buffer type\",\n                 \"try\",\n-                format!(\"Arc<{}>\", alternate),\n+                format!(\"Arc<{alternate}>\"),\n                 Applicability::MachineApplicable,\n             );\n         } else if let Some(ty) = qpath_generic_tys(qpath).next() {"}, {"sha": "ecb67200539089276fd008fabd402e02c335ae2b", "filename": "src/tools/clippy/clippy_lints/src/types/redundant_allocation.rs", "status": "modified", "additions": 10, "deletions": 21, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fredundant_allocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fredundant_allocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fredundant_allocation.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -3,9 +3,9 @@ use clippy_utils::source::{snippet, snippet_with_applicability};\n use clippy_utils::{path_def_id, qpath_generic_tys};\n use rustc_errors::Applicability;\n use rustc_hir::{self as hir, def_id::DefId, QPath, TyKind};\n+use rustc_hir_analysis::hir_ty_to_ty;\n use rustc_lint::LateContext;\n use rustc_span::symbol::sym;\n-use rustc_hir_analysis::hir_ty_to_ty;\n \n use super::{utils, REDUNDANT_ALLOCATION};\n \n@@ -27,13 +27,11 @@ pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_\n             cx,\n             REDUNDANT_ALLOCATION,\n             hir_ty.span,\n-            &format!(\"usage of `{}<{}>`\", outer_sym, generic_snippet),\n+            &format!(\"usage of `{outer_sym}<{generic_snippet}>`\"),\n             |diag| {\n-                diag.span_suggestion(hir_ty.span, \"try\", format!(\"{}\", generic_snippet), applicability);\n+                diag.span_suggestion(hir_ty.span, \"try\", format!(\"{generic_snippet}\"), applicability);\n                 diag.note(&format!(\n-                    \"`{generic}` is already a pointer, `{outer}<{generic}>` allocates a pointer on the heap\",\n-                    outer = outer_sym,\n-                    generic = generic_snippet\n+                    \"`{generic_snippet}` is already a pointer, `{outer_sym}<{generic_snippet}>` allocates a pointer on the heap\"\n                 ));\n             },\n         );\n@@ -72,19 +70,16 @@ pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_\n             cx,\n             REDUNDANT_ALLOCATION,\n             hir_ty.span,\n-            &format!(\"usage of `{}<{}<{}>>`\", outer_sym, inner_sym, generic_snippet),\n+            &format!(\"usage of `{outer_sym}<{inner_sym}<{generic_snippet}>>`\"),\n             |diag| {\n                 diag.span_suggestion(\n                     hir_ty.span,\n                     \"try\",\n-                    format!(\"{}<{}>\", outer_sym, generic_snippet),\n+                    format!(\"{outer_sym}<{generic_snippet}>\"),\n                     applicability,\n                 );\n                 diag.note(&format!(\n-                    \"`{inner}<{generic}>` is already on the heap, `{outer}<{inner}<{generic}>>` makes an extra allocation\",\n-                    outer = outer_sym,\n-                    inner = inner_sym,\n-                    generic = generic_snippet\n+                    \"`{inner_sym}<{generic_snippet}>` is already on the heap, `{outer_sym}<{inner_sym}<{generic_snippet}>>` makes an extra allocation\"\n                 ));\n             },\n         );\n@@ -94,19 +89,13 @@ pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_\n             cx,\n             REDUNDANT_ALLOCATION,\n             hir_ty.span,\n-            &format!(\"usage of `{}<{}<{}>>`\", outer_sym, inner_sym, generic_snippet),\n+            &format!(\"usage of `{outer_sym}<{inner_sym}<{generic_snippet}>>`\"),\n             |diag| {\n                 diag.note(&format!(\n-                    \"`{inner}<{generic}>` is already on the heap, `{outer}<{inner}<{generic}>>` makes an extra allocation\",\n-                    outer = outer_sym,\n-                    inner = inner_sym,\n-                    generic = generic_snippet\n+                    \"`{inner_sym}<{generic_snippet}>` is already on the heap, `{outer_sym}<{inner_sym}<{generic_snippet}>>` makes an extra allocation\"\n                 ));\n                 diag.help(&format!(\n-                    \"consider using just `{outer}<{generic}>` or `{inner}<{generic}>`\",\n-                    outer = outer_sym,\n-                    inner = inner_sym,\n-                    generic = generic_snippet\n+                    \"consider using just `{outer_sym}<{generic_snippet}>` or `{inner_sym}<{generic_snippet}>`\"\n                 ));\n             },\n         );"}, {"sha": "6c329d8cdf196a9b4311f6c242b0fc5a1c153372", "filename": "src/tools/clippy/clippy_lints/src/types/vec_box.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fvec_box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fvec_box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fvec_box.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -4,11 +4,11 @@ use clippy_utils::source::snippet;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{self as hir, def_id::DefId, GenericArg, QPath, TyKind};\n+use rustc_hir_analysis::hir_ty_to_ty;\n use rustc_lint::LateContext;\n use rustc_middle::ty::layout::LayoutOf;\n use rustc_middle::ty::TypeVisitable;\n use rustc_span::symbol::sym;\n-use rustc_hir_analysis::hir_ty_to_ty;\n \n use super::VEC_BOX;\n "}, {"sha": "1ab0162a88134165770c19ba80cc0fe3da0433f7", "filename": "src/tools/clippy/clippy_lints/src/uninit_vec.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funinit_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funinit_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funinit_vec.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::{span_lint, span_lint_and_then};\n use clippy_utils::higher::{get_vec_init_kind, VecInitKind};\n use clippy_utils::ty::{is_type_diagnostic_item, is_uninit_value_valid_for_ty};\n-use clippy_utils::{is_lint_allowed, path_to_local_id, peel_hir_expr_while, SpanlessEq};\n+use clippy_utils::{is_integer_literal, is_lint_allowed, path_to_local_id, peel_hir_expr_while, SpanlessEq};\n use rustc_hir::{Block, Expr, ExprKind, HirId, PatKind, PathSegment, Stmt, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::lint::in_external_macro;\n@@ -211,9 +211,12 @@ fn extract_set_len_self<'tcx>(cx: &LateContext<'_>, expr: &'tcx Expr<'_>) -> Opt\n         }\n     });\n     match expr.kind {\n-        ExprKind::MethodCall(path, self_expr, [_], _) => {\n+        ExprKind::MethodCall(path, self_expr, [arg], _) => {\n             let self_type = cx.typeck_results().expr_ty(self_expr).peel_refs();\n-            if is_type_diagnostic_item(cx, self_type, sym::Vec) && path.ident.name.as_str() == \"set_len\" {\n+            if is_type_diagnostic_item(cx, self_type, sym::Vec)\n+                && path.ident.name.as_str() == \"set_len\"\n+                && !is_integer_literal(arg, 0)\n+            {\n                 Some((self_expr, expr.span))\n             } else {\n                 None"}, {"sha": "57aff5367dd155af70592424eaf95cc1355093d3", "filename": "src/tools/clippy/clippy_lints/src/unit_return_expecting_ord.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_return_expecting_ord.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -157,8 +157,7 @@ impl<'tcx> LateLintPass<'tcx> for UnitReturnExpectingOrd {\n                                 span,\n                                 &format!(\n                                     \"this closure returns \\\n-                                   the unit type which also implements {}\",\n-                                    trait_name\n+                                   the unit type which also implements {trait_name}\"\n                                 ),\n                             );\n                         },\n@@ -169,8 +168,7 @@ impl<'tcx> LateLintPass<'tcx> for UnitReturnExpectingOrd {\n                                 span,\n                                 &format!(\n                                     \"this closure returns \\\n-                                   the unit type which also implements {}\",\n-                                    trait_name\n+                                   the unit type which also implements {trait_name}\"\n                                 ),\n                                 Some(last_semi),\n                                 \"probably caused by this trailing semicolon\","}, {"sha": "f6d3fb00f4ee5220926e4ffe3c261fc1d9a4a42f", "filename": "src/tools/clippy/clippy_lints/src/unit_types/unit_arg.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_types%2Funit_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_types%2Funit_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_types%2Funit_arg.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -74,7 +74,7 @@ fn lint_unit_args(cx: &LateContext<'_>, expr: &Expr<'_>, args_to_recover: &[&Exp\n         cx,\n         UNIT_ARG,\n         expr.span,\n-        &format!(\"passing {}unit value{} to a function\", singular, plural),\n+        &format!(\"passing {singular}unit value{plural} to a function\"),\n         |db| {\n             let mut or = \"\";\n             args_to_recover\n@@ -129,7 +129,7 @@ fn lint_unit_args(cx: &LateContext<'_>, expr: &Expr<'_>, args_to_recover: &[&Exp\n \n                 if arg_snippets_without_empty_blocks.is_empty() {\n                     db.multipart_suggestion(\n-                        &format!(\"use {}unit literal{} instead\", singular, plural),\n+                        &format!(\"use {singular}unit literal{plural} instead\"),\n                         args_to_recover\n                             .iter()\n                             .map(|arg| (arg.span, \"()\".to_string()))\n@@ -143,8 +143,7 @@ fn lint_unit_args(cx: &LateContext<'_>, expr: &Expr<'_>, args_to_recover: &[&Exp\n                     db.span_suggestion(\n                         expr.span,\n                         &format!(\n-                            \"{}move the expression{} in front of the call and replace {} with the unit literal `()`\",\n-                            or, empty_or_s, it_or_them\n+                            \"{or}move the expression{empty_or_s} in front of the call and replace {it_or_them} with the unit literal `()`\"\n                         ),\n                         sugg,\n                         applicability,"}, {"sha": "226495dcbda34ea2098281eb3ec1bd5a4711e290", "filename": "src/tools/clippy/clippy_lints/src/unit_types/unit_cmp.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_types%2Funit_cmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_types%2Funit_cmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_types%2Funit_cmp.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -22,7 +22,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>) {\n                 cx,\n                 UNIT_CMP,\n                 macro_call.span,\n-                &format!(\"`{}` of unit values detected. This will always {}\", macro_name, result),\n+                &format!(\"`{macro_name}` of unit values detected. This will always {result}\"),\n             );\n         }\n         return;\n@@ -40,9 +40,8 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>) {\n                 UNIT_CMP,\n                 expr.span,\n                 &format!(\n-                    \"{}-comparison of unit values detected. This will always be {}\",\n-                    op.as_str(),\n-                    result\n+                    \"{}-comparison of unit values detected. This will always be {result}\",\n+                    op.as_str()\n                 ),\n             );\n         }"}, {"sha": "016aacbf9da37c10de4e684b428429f4db34efa9", "filename": "src/tools/clippy/clippy_lints/src/unnecessary_owned_empty_strings.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_owned_empty_strings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_owned_empty_strings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_owned_empty_strings.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -3,7 +3,7 @@ use clippy_utils::{match_def_path, paths};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n-use rustc_hir::{BorrowKind, Expr, ExprKind, Mutability};\n+use rustc_hir::{BorrowKind, Expr, ExprKind, LangItem, Mutability};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -55,7 +55,7 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryOwnedEmptyStrings {\n                         );\n                 } else {\n                     if_chain! {\n-                        if match_def_path(cx, fun_def_id, &paths::FROM_FROM);\n+                        if cx.tcx.lang_items().require(LangItem::FromFrom).ok() == Some(fun_def_id);\n                         if let [.., last_arg] = args;\n                         if let ExprKind::Lit(spanned) = &last_arg.kind;\n                         if let LitKind::Str(symbol, _) = spanned.node;"}, {"sha": "bc0dd263d88ab2fdf0234097a2c6894609de7630", "filename": "src/tools/clippy/clippy_lints/src/unnecessary_self_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_self_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_self_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_self_imports.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -57,7 +57,7 @@ impl EarlyLintPass for UnnecessarySelfImports {\n                             format!(\n                                 \"{}{};\",\n                                 last_segment.ident,\n-                                if let UseTreeKind::Simple(Some(alias), ..) = self_tree.kind { format!(\" as {}\", alias) } else { String::new() },\n+                                if let UseTreeKind::Simple(Some(alias), ..) = self_tree.kind { format!(\" as {alias}\") } else { String::new() },\n                             ),\n                             Applicability::MaybeIncorrect,\n                         );"}, {"sha": "7211e6864f3a93b92692bb9ec524f34067814122", "filename": "src/tools/clippy/clippy_lints/src/unnecessary_wraps.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_wraps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_wraps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_wraps.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::source::snippet;\n-use clippy_utils::{contains_return, is_lang_ctor, return_ty, visitors::find_all_ret_expressions};\n+use clippy_utils::{contains_return, is_res_lang_ctor, path_res, return_ty, visitors::find_all_ret_expressions};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::FnKind;\n@@ -120,9 +120,7 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryWraps {\n                 if !ret_expr.span.from_expansion();\n                 // Check if a function call.\n                 if let ExprKind::Call(func, [arg]) = ret_expr.kind;\n-                // Check if OPTION_SOME or RESULT_OK, depending on return type.\n-                if let ExprKind::Path(qpath) = &func.kind;\n-                if is_lang_ctor(cx, qpath, lang_item);\n+                if is_res_lang_ctor(cx, path_res(cx, func), lang_item);\n                 // Make sure the function argument does not contain a return expression.\n                 if !contains_return(arg);\n                 then {\n@@ -153,11 +151,8 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryWraps {\n                 )\n             } else {\n                 (\n-                    format!(\n-                        \"this function's return value is unnecessarily wrapped by `{}`\",\n-                        return_type_label\n-                    ),\n-                    format!(\"remove `{}` from the return type...\", return_type_label),\n+                    format!(\"this function's return value is unnecessarily wrapped by `{return_type_label}`\"),\n+                    format!(\"remove `{return_type_label}` from the return type...\"),\n                     inner_type.to_string(),\n                     \"...and then change returning expressions\",\n                 )"}, {"sha": "32cd468120141ec5a4c79a5b1dc1c0f946ab906c", "filename": "src/tools/clippy/clippy_lints/src/unsafe_removed_from_name.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funsafe_removed_from_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funsafe_removed_from_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funsafe_removed_from_name.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -65,10 +65,7 @@ fn unsafe_to_safe_check(old_name: Ident, new_name: Ident, cx: &EarlyContext<'_>,\n             cx,\n             UNSAFE_REMOVED_FROM_NAME,\n             span,\n-            &format!(\n-                \"removed `unsafe` from the name of `{}` in use as `{}`\",\n-                old_str, new_str\n-            ),\n+            &format!(\"removed `unsafe` from the name of `{old_str}` in use as `{new_str}`\"),\n         );\n     }\n }"}, {"sha": "8bcdff66331d162c44d06971af7f9774f09698a3", "filename": "src/tools/clippy/clippy_lints/src/unused_io_amount.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_io_amount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_io_amount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_io_amount.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -1,8 +1,9 @@\n use clippy_utils::diagnostics::{span_lint, span_lint_and_help};\n-use clippy_utils::{is_try, match_trait_method, paths};\n+use clippy_utils::{is_trait_method, is_try, match_trait_method, paths};\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -116,13 +117,13 @@ fn check_method_call(cx: &LateContext<'_>, call: &hir::Expr<'_>, expr: &hir::Exp\n             match_trait_method(cx, call, &paths::FUTURES_IO_ASYNCREADEXT)\n                 || match_trait_method(cx, call, &paths::TOKIO_IO_ASYNCREADEXT)\n         } else {\n-            match_trait_method(cx, call, &paths::IO_READ)\n+            is_trait_method(cx, call, sym::IoRead)\n         };\n         let write_trait = if is_await {\n             match_trait_method(cx, call, &paths::FUTURES_IO_ASYNCWRITEEXT)\n                 || match_trait_method(cx, call, &paths::TOKIO_IO_ASYNCWRITEEXT)\n         } else {\n-            match_trait_method(cx, call, &paths::IO_WRITE)\n+            is_trait_method(cx, call, sym::IoWrite)\n         };\n \n         match (read_trait, write_trait, symbol, is_await) {"}, {"sha": "3164937293b6893e7e1ecaca177505494b3623d1", "filename": "src/tools/clippy/clippy_lints/src/unused_rounding.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_rounding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_rounding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_rounding.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -58,8 +58,8 @@ impl EarlyLintPass for UnusedRounding {\n                 cx,\n                 UNUSED_ROUNDING,\n                 expr.span,\n-                &format!(\"used the `{}` method with a whole number float\", method_name),\n-                &format!(\"remove the `{}` method call\", method_name),\n+                &format!(\"used the `{method_name}` method with a whole number float\"),\n+                &format!(\"remove the `{method_name}` method call\"),\n                 float,\n                 Applicability::MachineApplicable,\n             );"}, {"sha": "ea878043c04e3b789e351f99796d55b590d242d3", "filename": "src/tools/clippy/clippy_lints/src/unwrap.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -257,9 +257,8 @@ impl<'a, 'tcx> Visitor<'tcx> for UnwrappableVariablesVisitor<'a, 'tcx> {\n                             expr.hir_id,\n                             expr.span,\n                             &format!(\n-                                \"called `{}` on `{}` after checking its variant with `{}`\",\n+                                \"called `{}` on `{unwrappable_variable_name}` after checking its variant with `{}`\",\n                                 method_name.ident.name,\n-                                unwrappable_variable_name,\n                                 unwrappable.check_name.ident.as_str(),\n                             ),\n                             |diag| {\n@@ -268,9 +267,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnwrappableVariablesVisitor<'a, 'tcx> {\n                                         unwrappable.check.span.with_lo(unwrappable.if_expr.span.lo()),\n                                         \"try\",\n                                         format!(\n-                                            \"if let {} = {}\",\n-                                            suggested_pattern,\n-                                            unwrappable_variable_name,\n+                                            \"if let {suggested_pattern} = {unwrappable_variable_name}\",\n                                         ),\n                                         // We don't track how the unwrapped value is used inside the\n                                         // block or suggest deleting the unwrap, so we can't offer a"}, {"sha": "a69719b127b2fb04cc970d12356e83d1258dc687", "filename": "src/tools/clippy/clippy_lints/src/unwrap_in_result.rs", "status": "modified", "additions": 29, "deletions": 43, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap_in_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap_in_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap_in_result.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -1,12 +1,12 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::visitors::for_each_expr;\n use clippy_utils::{method_chain_args, return_ty};\n+use core::ops::ControlFlow;\n use if_chain::if_chain;\n use rustc_hir as hir;\n-use rustc_hir::intravisit::{self, Visitor};\n-use rustc_hir::{Expr, ImplItemKind};\n+use rustc_hir::ImplItemKind;\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{sym, Span};\n \n@@ -73,59 +73,45 @@ impl<'tcx> LateLintPass<'tcx> for UnwrapInResult {\n     }\n }\n \n-struct FindExpectUnwrap<'a, 'tcx> {\n-    lcx: &'a LateContext<'tcx>,\n-    typeck_results: &'tcx ty::TypeckResults<'tcx>,\n-    result: Vec<Span>,\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for FindExpectUnwrap<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n-        // check for `expect`\n-        if let Some(arglists) = method_chain_args(expr, &[\"expect\"]) {\n-            let receiver_ty = self.typeck_results.expr_ty(arglists[0].0).peel_refs();\n-            if is_type_diagnostic_item(self.lcx, receiver_ty, sym::Option)\n-                || is_type_diagnostic_item(self.lcx, receiver_ty, sym::Result)\n-            {\n-                self.result.push(expr.span);\n+fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, impl_item: &'tcx hir::ImplItem<'_>) {\n+    if let ImplItemKind::Fn(_, body_id) = impl_item.kind {\n+        let body = cx.tcx.hir().body(body_id);\n+        let typeck = cx.tcx.typeck(impl_item.def_id.def_id);\n+        let mut result = Vec::new();\n+        let _: Option<!> = for_each_expr(body.value, |e| {\n+            // check for `expect`\n+            if let Some(arglists) = method_chain_args(e, &[\"expect\"]) {\n+                let receiver_ty = typeck.expr_ty(arglists[0].0).peel_refs();\n+                if is_type_diagnostic_item(cx, receiver_ty, sym::Option)\n+                    || is_type_diagnostic_item(cx, receiver_ty, sym::Result)\n+                {\n+                    result.push(e.span);\n+                }\n             }\n-        }\n \n-        // check for `unwrap`\n-        if let Some(arglists) = method_chain_args(expr, &[\"unwrap\"]) {\n-            let receiver_ty = self.typeck_results.expr_ty(arglists[0].0).peel_refs();\n-            if is_type_diagnostic_item(self.lcx, receiver_ty, sym::Option)\n-                || is_type_diagnostic_item(self.lcx, receiver_ty, sym::Result)\n-            {\n-                self.result.push(expr.span);\n+            // check for `unwrap`\n+            if let Some(arglists) = method_chain_args(e, &[\"unwrap\"]) {\n+                let receiver_ty = typeck.expr_ty(arglists[0].0).peel_refs();\n+                if is_type_diagnostic_item(cx, receiver_ty, sym::Option)\n+                    || is_type_diagnostic_item(cx, receiver_ty, sym::Result)\n+                {\n+                    result.push(e.span);\n+                }\n             }\n-        }\n \n-        // and check sub-expressions\n-        intravisit::walk_expr(self, expr);\n-    }\n-}\n-\n-fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, impl_item: &'tcx hir::ImplItem<'_>) {\n-    if let ImplItemKind::Fn(_, body_id) = impl_item.kind {\n-        let body = cx.tcx.hir().body(body_id);\n-        let mut fpu = FindExpectUnwrap {\n-            lcx: cx,\n-            typeck_results: cx.tcx.typeck(impl_item.def_id.def_id),\n-            result: Vec::new(),\n-        };\n-        fpu.visit_expr(body.value);\n+            ControlFlow::Continue(())\n+        });\n \n         // if we've found one, lint\n-        if !fpu.result.is_empty() {\n+        if !result.is_empty() {\n             span_lint_and_then(\n                 cx,\n                 UNWRAP_IN_RESULT,\n                 impl_span,\n                 \"used unwrap or expect in a function that returns result or option\",\n                 move |diag| {\n                     diag.help(\"unwrap and expect should not be used in a function that returns result or option\");\n-                    diag.span_note(fpu.result, \"potential non-recoverable error(s)\");\n+                    diag.span_note(result, \"potential non-recoverable error(s)\");\n                 },\n             );\n         }"}, {"sha": "654ea306793bd20dc187bc7ea1a03abb01141e67", "filename": "src/tools/clippy/clippy_lints/src/upper_case_acronyms.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fupper_case_acronyms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fupper_case_acronyms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fupper_case_acronyms.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -93,7 +93,7 @@ fn check_ident(cx: &LateContext<'_>, ident: &Ident, be_aggressive: bool) {\n             cx,\n             UPPER_CASE_ACRONYMS,\n             span,\n-            &format!(\"name `{}` contains a capitalized acronym\", ident),\n+            &format!(\"name `{ident}` contains a capitalized acronym\"),\n             \"consider making the acronym lowercase, except the initial letter\",\n             corrected,\n             Applicability::MaybeIncorrect,\n@@ -114,6 +114,7 @@ impl LateLintPass<'_> for UpperCaseAcronyms {\n                 check_ident(cx, &it.ident, self.upper_case_acronyms_aggressive);\n             },\n             ItemKind::Enum(ref enumdef, _) => {\n+                check_ident(cx, &it.ident, self.upper_case_acronyms_aggressive);\n                 // check enum variants separately because again we only want to lint on private enums and\n                 // the fn check_variant does not know about the vis of the enum of its variants\n                 enumdef"}, {"sha": "65f1b5462081925f8faa6045e5f8de142952da1d", "filename": "src/tools/clippy/clippy_lints/src/use_self.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -12,11 +12,11 @@ use rustc_hir::{\n     Expr, ExprKind, FnRetTy, FnSig, GenericArg, HirId, Impl, ImplItemKind, Item, ItemKind, Pat, PatKind, Path, QPath,\n     TyKind,\n };\n+use rustc_hir_analysis::hir_ty_to_ty;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::Span;\n-use rustc_hir_analysis::hir_ty_to_ty;\n \n declare_clippy_lint! {\n     /// ### What it does"}, {"sha": "a82643a59f97bb11bc1c17c5ba62157073a5c753", "filename": "src/tools/clippy/clippy_lints/src/useless_conversion.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuseless_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuseless_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuseless_conversion.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -5,7 +5,7 @@ use clippy_utils::ty::{is_type_diagnostic_item, same_type_and_consts};\n use clippy_utils::{get_parent_expr, is_trait_method, match_def_path, paths};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind, HirId, MatchSource};\n+use rustc_hir::{Expr, ExprKind, HirId, LangItem, MatchSource};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n@@ -74,7 +74,7 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n                             cx,\n                             USELESS_CONVERSION,\n                             e.span,\n-                            &format!(\"useless conversion to the same type: `{}`\", b),\n+                            &format!(\"useless conversion to the same type: `{b}`\"),\n                             \"consider removing `.into()`\",\n                             sugg,\n                             Applicability::MachineApplicable, // snippet\n@@ -97,7 +97,7 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n                             cx,\n                             USELESS_CONVERSION,\n                             e.span,\n-                            &format!(\"useless conversion to the same type: `{}`\", b),\n+                            &format!(\"useless conversion to the same type: `{b}`\"),\n                             \"consider removing `.into_iter()`\",\n                             sugg,\n                             Applicability::MachineApplicable, // snippet\n@@ -118,7 +118,7 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n                             cx,\n                             USELESS_CONVERSION,\n                             e.span,\n-                            &format!(\"useless conversion to the same type: `{}`\", b),\n+                            &format!(\"useless conversion to the same type: `{b}`\"),\n                             None,\n                             \"consider removing `.try_into()`\",\n                         );\n@@ -146,15 +146,15 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n                                     cx,\n                                     USELESS_CONVERSION,\n                                     e.span,\n-                                    &format!(\"useless conversion to the same type: `{}`\", b),\n+                                    &format!(\"useless conversion to the same type: `{b}`\"),\n                                     None,\n                                     &hint,\n                                 );\n                             }\n                         }\n \n                         if_chain! {\n-                            if match_def_path(cx, def_id, &paths::FROM_FROM);\n+                            if cx.tcx.lang_items().require(LangItem::FromFrom).ok() == Some(def_id);\n                             if same_type_and_consts(a, b);\n \n                             then {\n@@ -165,7 +165,7 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n                                     cx,\n                                     USELESS_CONVERSION,\n                                     e.span,\n-                                    &format!(\"useless conversion to the same type: `{}`\", b),\n+                                    &format!(\"useless conversion to the same type: `{b}`\"),\n                                     &sugg_msg,\n                                     sugg.to_string(),\n                                     Applicability::MachineApplicable, // snippet"}, {"sha": "e069de8cb5c7e5148cba5f9789f9e98809c20dde", "filename": "src/tools/clippy/clippy_lints/src/utils/author.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -739,7 +739,7 @@ fn path_to_string(path: &QPath<'_>) -> String {\n                     *s += \", \";\n                     write!(s, \"{:?}\", segment.ident.as_str()).unwrap();\n                 },\n-                other => write!(s, \"/* unimplemented: {:?}*/\", other).unwrap(),\n+                other => write!(s, \"/* unimplemented: {other:?}*/\").unwrap(),\n             },\n             QPath::LangItem(..) => panic!(\"path_to_string: called for lang item qpath\"),\n         }"}, {"sha": "668123e4d6e394e5e73f7f0fb9b2ec6a990de8f2", "filename": "src/tools/clippy/clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -39,28 +39,28 @@ pub struct Rename {\n     pub rename: String,\n }\n \n-/// A single disallowed method, used by the `DISALLOWED_METHODS` lint.\n #[derive(Clone, Debug, Deserialize)]\n #[serde(untagged)]\n-pub enum DisallowedMethod {\n+pub enum DisallowedPath {\n     Simple(String),\n     WithReason { path: String, reason: Option<String> },\n }\n \n-impl DisallowedMethod {\n+impl DisallowedPath {\n     pub fn path(&self) -> &str {\n         let (Self::Simple(path) | Self::WithReason { path, .. }) = self;\n \n         path\n     }\n-}\n \n-/// A single disallowed type, used by the `DISALLOWED_TYPES` lint.\n-#[derive(Clone, Debug, Deserialize)]\n-#[serde(untagged)]\n-pub enum DisallowedType {\n-    Simple(String),\n-    WithReason { path: String, reason: Option<String> },\n+    pub fn reason(&self) -> Option<&str> {\n+        match self {\n+            Self::WithReason {\n+                reason: Some(reason), ..\n+            } => Some(reason),\n+            _ => None,\n+        }\n+    }\n }\n \n /// Conf with parse errors\n@@ -213,7 +213,7 @@ define_Conf! {\n     ///\n     /// Suppress lints whenever the suggested change would cause breakage for other crates.\n     (avoid_breaking_exported_api: bool = true),\n-    /// Lint: MANUAL_SPLIT_ONCE, MANUAL_STR_REPEAT, CLONED_INSTEAD_OF_COPIED, REDUNDANT_FIELD_NAMES, REDUNDANT_STATIC_LIFETIMES, FILTER_MAP_NEXT, CHECKED_CONVERSIONS, MANUAL_RANGE_CONTAINS, USE_SELF, MEM_REPLACE_WITH_DEFAULT, MANUAL_NON_EXHAUSTIVE, OPTION_AS_REF_DEREF, MAP_UNWRAP_OR, MATCH_LIKE_MATCHES_MACRO, MANUAL_STRIP, MISSING_CONST_FOR_FN, UNNESTED_OR_PATTERNS, FROM_OVER_INTO, PTR_AS_PTR, IF_THEN_SOME_ELSE_NONE, APPROX_CONSTANT, DEPRECATED_CFG_ATTR, INDEX_REFUTABLE_SLICE, MAP_CLONE, BORROW_AS_PTR, MANUAL_BITS, ERR_EXPECT, CAST_ABS_TO_UNSIGNED.\n+    /// Lint: MANUAL_SPLIT_ONCE, MANUAL_STR_REPEAT, CLONED_INSTEAD_OF_COPIED, REDUNDANT_FIELD_NAMES, REDUNDANT_STATIC_LIFETIMES, FILTER_MAP_NEXT, CHECKED_CONVERSIONS, MANUAL_RANGE_CONTAINS, USE_SELF, MEM_REPLACE_WITH_DEFAULT, MANUAL_NON_EXHAUSTIVE, OPTION_AS_REF_DEREF, MAP_UNWRAP_OR, MATCH_LIKE_MATCHES_MACRO, MANUAL_STRIP, MISSING_CONST_FOR_FN, UNNESTED_OR_PATTERNS, FROM_OVER_INTO, PTR_AS_PTR, IF_THEN_SOME_ELSE_NONE, APPROX_CONSTANT, DEPRECATED_CFG_ATTR, INDEX_REFUTABLE_SLICE, MAP_CLONE, BORROW_AS_PTR, MANUAL_BITS, ERR_EXPECT, CAST_ABS_TO_UNSIGNED, UNINLINED_FORMAT_ARGS, MANUAL_CLAMP.\n     ///\n     /// The minimum rust version that the project supports\n     (msrv: Option<String> = None),\n@@ -315,14 +315,18 @@ define_Conf! {\n     ///\n     /// Whether to allow certain wildcard imports (prelude, super in tests).\n     (warn_on_all_wildcard_imports: bool = false),\n+    /// Lint: DISALLOWED_MACROS.\n+    ///\n+    /// The list of disallowed macros, written as fully qualified paths.\n+    (disallowed_macros: Vec<crate::utils::conf::DisallowedPath> = Vec::new()),\n     /// Lint: DISALLOWED_METHODS.\n     ///\n     /// The list of disallowed methods, written as fully qualified paths.\n-    (disallowed_methods: Vec<crate::utils::conf::DisallowedMethod> = Vec::new()),\n+    (disallowed_methods: Vec<crate::utils::conf::DisallowedPath> = Vec::new()),\n     /// Lint: DISALLOWED_TYPES.\n     ///\n     /// The list of disallowed types, written as fully qualified paths.\n-    (disallowed_types: Vec<crate::utils::conf::DisallowedType> = Vec::new()),\n+    (disallowed_types: Vec<crate::utils::conf::DisallowedPath> = Vec::new()),\n     /// Lint: UNREADABLE_LITERAL.\n     ///\n     /// Should the fraction of a decimal be linted to include separators.\n@@ -362,7 +366,7 @@ define_Conf! {\n     /// For example, `[_, _, _, e, ..]` is a slice pattern with 4 elements.\n     (max_suggested_slice_pattern_length: u64 = 3),\n     /// Lint: AWAIT_HOLDING_INVALID_TYPE\n-    (await_holding_invalid_types: Vec<crate::utils::conf::DisallowedType> = Vec::new()),\n+    (await_holding_invalid_types: Vec<crate::utils::conf::DisallowedPath> = Vec::new()),\n     /// Lint: LARGE_INCLUDE_FILE.\n     ///\n     /// The maximum size of a file included via `include_bytes!()` or `include_str!()`, in bytes\n@@ -482,16 +486,13 @@ pub fn format_error(error: Box<dyn Error>) -> String {\n                     let field = fields.get(index).copied().unwrap_or_default();\n                     write!(\n                         msg,\n-                        \"{:separator_width$}{:field_width$}\",\n-                        \" \",\n-                        field,\n-                        separator_width = SEPARATOR_WIDTH,\n-                        field_width = column_width\n+                        \"{:SEPARATOR_WIDTH$}{field:column_width$}\",\n+                        \" \"\n                     )\n                     .unwrap();\n                 }\n             }\n-            write!(msg, \"\\n{}\", suffix).unwrap();\n+            write!(msg, \"\\n{suffix}\").unwrap();\n             msg\n         } else {\n             s"}, {"sha": "85bcbc7ad236966d9ec406e6caadc69432c3b1fb", "filename": "src/tools/clippy/clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 218, "deletions": 89, "changes": 307, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -2,11 +2,11 @@ use crate::utils::internal_lints::metadata_collector::is_deprecated_lint;\n use clippy_utils::consts::{constant_simple, Constant};\n use clippy_utils::diagnostics::{span_lint, span_lint_and_help, span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::macros::root_macro_call_first_node;\n-use clippy_utils::source::snippet;\n+use clippy_utils::source::{snippet, snippet_with_applicability};\n use clippy_utils::ty::match_type;\n use clippy_utils::{\n-    def_path_res, higher, is_else_clause, is_expn_of, is_expr_path_def_path, is_lint_allowed, match_def_path,\n-    method_calls, paths, peel_blocks_with_stmt, SpanlessEq,\n+    def_path_res, higher, is_else_clause, is_expn_of, is_expr_path_def_path, is_lint_allowed, match_any_def_paths,\n+    match_def_path, method_calls, paths, peel_blocks_with_stmt, peel_hir_expr_refs, SpanlessEq,\n };\n use if_chain::if_chain;\n use rustc_ast as ast;\n@@ -15,26 +15,29 @@ use rustc_ast::visit::FnKind;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n-use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::def::{DefKind, Namespace, Res};\n use rustc_hir::def_id::DefId;\n use rustc_hir::hir_id::CRATE_HIR_ID;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::{\n-    BinOpKind, Block, Closure, Expr, ExprKind, HirId, Item, Local, MutTy, Mutability, Node, Path, Stmt, StmtKind, Ty,\n+    BinOpKind, Block, Closure, Expr, ExprKind, HirId, Item, Local, MutTy, Mutability, Node, Path, Stmt, StmtKind,\n     TyKind, UnOp,\n };\n+use rustc_hir_analysis::hir_ty_to_ty;\n use rustc_lint::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::nested_filter;\n-use rustc_middle::mir::interpret::ConstValue;\n-use rustc_middle::ty::{self, fast_reject::SimplifiedTypeGen, subst::GenericArgKind, FloatTy};\n+use rustc_middle::mir::interpret::{Allocation, ConstValue, GlobalAlloc};\n+use rustc_middle::ty::{\n+    self, fast_reject::SimplifiedTypeGen, subst::GenericArgKind, AssocKind, DefIdTree, FloatTy, Ty,\n+};\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_lint_pass, declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Spanned;\n-use rustc_span::symbol::Symbol;\n+use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::{sym, BytePos, Span};\n-use rustc_hir_analysis::hir_ty_to_ty;\n \n use std::borrow::{Borrow, Cow};\n+use std::str;\n \n #[cfg(feature = \"internal\")]\n pub mod metadata_collector;\n@@ -226,11 +229,11 @@ declare_clippy_lint! {\n \n declare_clippy_lint! {\n     /// ### What it does\n-    /// Checks for calls to `utils::match_type()` on a type diagnostic item\n-    /// and suggests to use `utils::is_type_diagnostic_item()` instead.\n+    /// Checks for usages of def paths when a diagnostic item or a `LangItem` could be used.\n     ///\n     /// ### Why is this bad?\n-    /// `utils::is_type_diagnostic_item()` does not require hardcoded paths.\n+    /// The path for an item is subject to change and is less efficient to look up than a\n+    /// diagnostic item or a `LangItem`.\n     ///\n     /// ### Example\n     /// ```rust,ignore\n@@ -241,9 +244,9 @@ declare_clippy_lint! {\n     /// ```rust,ignore\n     /// utils::is_type_diagnostic_item(cx, ty, sym::Vec)\n     /// ```\n-    pub MATCH_TYPE_ON_DIAGNOSTIC_ITEM,\n+    pub UNNECESSARY_DEF_PATH,\n     internal,\n-    \"using `utils::match_type()` instead of `utils::is_type_diagnostic_item()`\"\n+    \"using a def path when a diagnostic item or a `LangItem` is available\"\n }\n \n declare_clippy_lint! {\n@@ -530,14 +533,14 @@ impl<'tcx> LateLintPass<'tcx> for LintWithoutLintPass {\n                     cx,\n                     LINT_WITHOUT_LINT_PASS,\n                     lint_span,\n-                    &format!(\"the lint `{}` is not added to any `LintPass`\", lint_name),\n+                    &format!(\"the lint `{lint_name}` is not added to any `LintPass`\"),\n                 );\n             }\n         }\n     }\n }\n \n-fn is_lint_ref_type<'tcx>(cx: &LateContext<'tcx>, ty: &Ty<'_>) -> bool {\n+fn is_lint_ref_type<'tcx>(cx: &LateContext<'tcx>, ty: &hir::Ty<'_>) -> bool {\n     if let TyKind::Rptr(\n         _,\n         MutTy {\n@@ -666,7 +669,7 @@ impl<'tcx> LateLintPass<'tcx> for CompilerLintFunctions {\n                     path.ident.span,\n                     \"usage of a compiler lint function\",\n                     None,\n-                    &format!(\"please use the Clippy variant of this function: `{}`\", sugg),\n+                    &format!(\"please use the Clippy variant of this function: `{sugg}`\"),\n                 );\n             }\n         }\n@@ -854,13 +857,8 @@ fn suggest_help(\n         \"this call is collapsible\",\n         \"collapse into\",\n         format!(\n-            \"span_lint_and_help({}, {}, {}, {}, {}, {})\",\n-            and_then_snippets.cx,\n-            and_then_snippets.lint,\n-            and_then_snippets.span,\n-            and_then_snippets.msg,\n-            &option_span,\n-            help\n+            \"span_lint_and_help({}, {}, {}, {}, {}, {help})\",\n+            and_then_snippets.cx, and_then_snippets.lint, and_then_snippets.span, and_then_snippets.msg, &option_span,\n         ),\n         Applicability::MachineApplicable,\n     );\n@@ -886,107 +884,238 @@ fn suggest_note(\n         \"this call is collapsible\",\n         \"collapse into\",\n         format!(\n-            \"span_lint_and_note({}, {}, {}, {}, {}, {})\",\n-            and_then_snippets.cx,\n-            and_then_snippets.lint,\n-            and_then_snippets.span,\n-            and_then_snippets.msg,\n-            note_span,\n-            note\n+            \"span_lint_and_note({}, {}, {}, {}, {note_span}, {note})\",\n+            and_then_snippets.cx, and_then_snippets.lint, and_then_snippets.span, and_then_snippets.msg,\n         ),\n         Applicability::MachineApplicable,\n     );\n }\n \n-declare_lint_pass!(MatchTypeOnDiagItem => [MATCH_TYPE_ON_DIAGNOSTIC_ITEM]);\n+declare_lint_pass!(UnnecessaryDefPath => [UNNECESSARY_DEF_PATH]);\n \n-impl<'tcx> LateLintPass<'tcx> for MatchTypeOnDiagItem {\n+#[allow(clippy::too_many_lines)]\n+impl<'tcx> LateLintPass<'tcx> for UnnecessaryDefPath {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n-        if is_lint_allowed(cx, MATCH_TYPE_ON_DIAGNOSTIC_ITEM, expr.hir_id) {\n+        enum Item {\n+            LangItem(Symbol),\n+            DiagnosticItem(Symbol),\n+        }\n+        static PATHS: &[&[&str]] = &[\n+            &[\"clippy_utils\", \"match_def_path\"],\n+            &[\"clippy_utils\", \"match_trait_method\"],\n+            &[\"clippy_utils\", \"ty\", \"match_type\"],\n+            &[\"clippy_utils\", \"is_expr_path_def_path\"],\n+        ];\n+\n+        if is_lint_allowed(cx, UNNECESSARY_DEF_PATH, expr.hir_id) {\n             return;\n         }\n \n         if_chain! {\n-            // Check if this is a call to utils::match_type()\n-            if let ExprKind::Call(fn_path, [context, ty, ty_path]) = expr.kind;\n-            if is_expr_path_def_path(cx, fn_path, &[\"clippy_utils\", \"ty\", \"match_type\"]);\n+            if let ExprKind::Call(func, [cx_arg, def_arg, args@..]) = expr.kind;\n+            if let ExprKind::Path(path) = &func.kind;\n+            if let Some(id) = cx.qpath_res(path, func.hir_id).opt_def_id();\n+            if let Some(which_path) = match_any_def_paths(cx, id, PATHS);\n+            let item_arg = if which_path == 4 { &args[1] } else { &args[0] };\n             // Extract the path to the matched type\n-            if let Some(segments) = path_to_matched_type(cx, ty_path);\n-            let segments: Vec<&str> = segments.iter().map(Symbol::as_str).collect();\n-            if let Some(ty_did) = def_path_res(cx, &segments[..]).opt_def_id();\n-            // Check if the matched type is a diagnostic item\n-            if let Some(item_name) = cx.tcx.get_diagnostic_name(ty_did);\n+            if let Some(segments) = path_to_matched_type(cx, item_arg);\n+            let segments: Vec<&str> = segments.iter().map(|sym| &**sym).collect();\n+            if let Some(def_id) = def_path_res(cx, &segments[..], None).opt_def_id();\n             then {\n-                // TODO: check paths constants from external crates.\n-                let cx_snippet = snippet(cx, context.span, \"_\");\n-                let ty_snippet = snippet(cx, ty.span, \"_\");\n+                // def_path_res will match field names before anything else, but for this we want to match\n+                // inherent functions first.\n+                let def_id = if cx.tcx.def_kind(def_id) == DefKind::Field {\n+                    let method_name = *segments.last().unwrap();\n+                    cx.tcx.def_key(def_id).parent\n+                        .and_then(|parent_idx|\n+                            cx.tcx.inherent_impls(DefId { index: parent_idx, krate: def_id.krate }).iter()\n+                                .find_map(|impl_id| cx.tcx.associated_items(*impl_id)\n+                                    .find_by_name_and_kind(\n+                                        cx.tcx,\n+                                        Ident::from_str(method_name),\n+                                        AssocKind::Fn,\n+                                        *impl_id,\n+                                    )\n+                                )\n+                        )\n+                        .map_or(def_id, |item| item.def_id)\n+                } else {\n+                    def_id\n+                };\n \n-                span_lint_and_sugg(\n+                // Check if the target item is a diagnostic item or LangItem.\n+                let (msg, item) = if let Some(item_name)\n+                    = cx.tcx.diagnostic_items(def_id.krate).id_to_name.get(&def_id)\n+                {\n+                    (\n+                        \"use of a def path to a diagnostic item\",\n+                        Item::DiagnosticItem(*item_name),\n+                    )\n+                } else if let Some(lang_item) = cx.tcx.lang_items().items().iter().position(|id| *id == Some(def_id)) {\n+                    let lang_items = def_path_res(cx, &[\"rustc_hir\", \"lang_items\", \"LangItem\"], Some(Namespace::TypeNS)).def_id();\n+                    let item_name = cx.tcx.adt_def(lang_items).variants().iter().nth(lang_item).unwrap().name;\n+                    (\n+                        \"use of a def path to a `LangItem`\",\n+                        Item::LangItem(item_name),\n+                    )\n+                } else {\n+                    return;\n+                };\n+\n+                let has_ctor = match cx.tcx.def_kind(def_id) {\n+                    DefKind::Struct => {\n+                        let variant = cx.tcx.adt_def(def_id).non_enum_variant();\n+                        variant.ctor_def_id.is_some() && variant.fields.iter().all(|f| f.vis.is_public())\n+                    }\n+                    DefKind::Variant => {\n+                        let variant = cx.tcx.adt_def(cx.tcx.parent(def_id)).variant_with_id(def_id);\n+                        variant.ctor_def_id.is_some() && variant.fields.iter().all(|f| f.vis.is_public())\n+                    }\n+                    _ => false,\n+                };\n+\n+                let mut app = Applicability::MachineApplicable;\n+                let cx_snip = snippet_with_applicability(cx, cx_arg.span, \"..\", &mut app);\n+                let def_snip = snippet_with_applicability(cx, def_arg.span, \"..\", &mut app);\n+                let (sugg, with_note) = match (which_path, item) {\n+                    // match_def_path\n+                    (0, Item::DiagnosticItem(item)) =>\n+                        (format!(\"{cx_snip}.tcx.is_diagnostic_item(sym::{item}, {def_snip})\"), has_ctor),\n+                    (0, Item::LangItem(item)) => (\n+                        format!(\"{cx_snip}.tcx.lang_items().require(LangItem::{item}).ok() == Some({def_snip})\"),\n+                        has_ctor\n+                    ),\n+                    // match_trait_method\n+                    (1, Item::DiagnosticItem(item)) =>\n+                        (format!(\"is_trait_method({cx_snip}, {def_snip}, sym::{item})\"), false),\n+                    // match_type\n+                    (2, Item::DiagnosticItem(item)) =>\n+                        (format!(\"is_type_diagnostic_item({cx_snip}, {def_snip}, sym::{item})\"), false),\n+                    (2, Item::LangItem(item)) =>\n+                        (format!(\"is_type_lang_item({cx_snip}, {def_snip}, LangItem::{item})\"), false),\n+                    // is_expr_path_def_path\n+                    (3, Item::DiagnosticItem(item)) if has_ctor => (\n+                        format!(\n+                            \"is_res_diag_ctor({cx_snip}, path_res({cx_snip}, {def_snip}), sym::{item})\",\n+                        ),\n+                        false,\n+                    ),\n+                    (3, Item::LangItem(item)) if has_ctor => (\n+                        format!(\n+                            \"is_res_lang_ctor({cx_snip}, path_res({cx_snip}, {def_snip}), LangItem::{item})\",\n+                        ),\n+                        false,\n+                    ),\n+                    (3, Item::DiagnosticItem(item)) =>\n+                        (format!(\"is_path_diagnostic_item({cx_snip}, {def_snip}, sym::{item})\"), false),\n+                    (3, Item::LangItem(item)) => (\n+                        format!(\n+                            \"path_res({cx_snip}, {def_snip}).opt_def_id()\\\n+                                .map_or(false, |id| {cx_snip}.tcx.lang_items().require(LangItem::{item}).ok() == Some(id))\",\n+                        ),\n+                        false,\n+                    ),\n+                    _ => return,\n+                };\n+\n+                span_lint_and_then(\n                     cx,\n-                    MATCH_TYPE_ON_DIAGNOSTIC_ITEM,\n+                    UNNECESSARY_DEF_PATH,\n                     expr.span,\n-                    \"usage of `clippy_utils::ty::match_type()` on a type diagnostic item\",\n-                    \"try\",\n-                    format!(\"clippy_utils::ty::is_type_diagnostic_item({}, {}, sym::{})\", cx_snippet, ty_snippet, item_name),\n-                    Applicability::MaybeIncorrect,\n+                    msg,\n+                    |diag| {\n+                        diag.span_suggestion(expr.span, \"try\", sugg, app);\n+                        if with_note {\n+                            diag.help(\n+                                \"if this `DefId` came from a constructor expression or pattern then the \\\n+                                    parent `DefId` should be used instead\"\n+                            );\n+                        }\n+                    },\n                 );\n             }\n         }\n     }\n }\n \n-fn path_to_matched_type(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> Option<Vec<Symbol>> {\n-    use rustc_hir::ItemKind;\n-\n-    match &expr.kind {\n-        ExprKind::AddrOf(.., expr) => return path_to_matched_type(cx, expr),\n-        ExprKind::Path(qpath) => match cx.qpath_res(qpath, expr.hir_id) {\n+fn path_to_matched_type(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> Option<Vec<String>> {\n+    match peel_hir_expr_refs(expr).0.kind {\n+        ExprKind::Path(ref qpath) => match cx.qpath_res(qpath, expr.hir_id) {\n             Res::Local(hir_id) => {\n                 let parent_id = cx.tcx.hir().get_parent_node(hir_id);\n-                if let Some(Node::Local(local)) = cx.tcx.hir().find(parent_id) {\n-                    if let Some(init) = local.init {\n-                        return path_to_matched_type(cx, init);\n-                    }\n+                if let Some(Node::Local(Local { init: Some(init), .. })) = cx.tcx.hir().find(parent_id) {\n+                    path_to_matched_type(cx, init)\n+                } else {\n+                    None\n                 }\n             },\n-            Res::Def(DefKind::Const | DefKind::Static(..), def_id) => {\n-                if let Some(Node::Item(item)) = cx.tcx.hir().get_if_local(def_id) {\n-                    if let ItemKind::Const(.., body_id) | ItemKind::Static(.., body_id) = item.kind {\n-                        let body = cx.tcx.hir().body(body_id);\n-                        return path_to_matched_type(cx, body.value);\n-                    }\n-                }\n+            Res::Def(DefKind::Static(_), def_id) => read_mir_alloc_def_path(\n+                cx,\n+                cx.tcx.eval_static_initializer(def_id).ok()?.inner(),\n+                cx.tcx.type_of(def_id),\n+            ),\n+            Res::Def(DefKind::Const, def_id) => match cx.tcx.const_eval_poly(def_id).ok()? {\n+                ConstValue::ByRef { alloc, offset } if offset.bytes() == 0 => {\n+                    read_mir_alloc_def_path(cx, alloc.inner(), cx.tcx.type_of(def_id))\n+                },\n+                _ => None,\n             },\n-            _ => {},\n+            _ => None,\n         },\n-        ExprKind::Array(exprs) => {\n-            let segments: Vec<Symbol> = exprs\n-                .iter()\n-                .filter_map(|expr| {\n-                    if let ExprKind::Lit(lit) = &expr.kind {\n-                        if let LitKind::Str(sym, _) = lit.node {\n-                            return Some(sym);\n-                        }\n+        ExprKind::Array(exprs) => exprs\n+            .iter()\n+            .map(|expr| {\n+                if let ExprKind::Lit(lit) = &expr.kind {\n+                    if let LitKind::Str(sym, _) = lit.node {\n+                        return Some((*sym.as_str()).to_owned());\n                     }\n+                }\n \n-                    None\n-                })\n-                .collect();\n-\n-            if segments.len() == exprs.len() {\n-                return Some(segments);\n-            }\n-        },\n-        _ => {},\n+                None\n+            })\n+            .collect(),\n+        _ => None,\n     }\n+}\n+\n+fn read_mir_alloc_def_path<'tcx>(cx: &LateContext<'tcx>, alloc: &'tcx Allocation, ty: Ty<'_>) -> Option<Vec<String>> {\n+    let (alloc, ty) = if let ty::Ref(_, ty, Mutability::Not) = *ty.kind() {\n+        let &alloc = alloc.provenance().values().next()?;\n+        if let GlobalAlloc::Memory(alloc) = cx.tcx.global_alloc(alloc) {\n+            (alloc.inner(), ty)\n+        } else {\n+            return None;\n+        }\n+    } else {\n+        (alloc, ty)\n+    };\n \n-    None\n+    if let ty::Array(ty, _) | ty::Slice(ty) = *ty.kind()\n+        && let ty::Ref(_, ty, Mutability::Not) = *ty.kind()\n+        && ty.is_str()\n+    {\n+        alloc\n+            .provenance()\n+            .values()\n+            .map(|&alloc| {\n+                if let GlobalAlloc::Memory(alloc) = cx.tcx.global_alloc(alloc) {\n+                    let alloc = alloc.inner();\n+                    str::from_utf8(alloc.inspect_with_uninit_and_ptr_outside_interpreter(0..alloc.len()))\n+                        .ok().map(ToOwned::to_owned)\n+                } else {\n+                    None\n+                }\n+            })\n+            .collect()\n+    } else {\n+        None\n+    }\n }\n \n // This is not a complete resolver for paths. It works on all the paths currently used in the paths\n // module.  That's all it does and all it needs to do.\n pub fn check_path(cx: &LateContext<'_>, path: &[&str]) -> bool {\n-    if def_path_res(cx, path) != Res::Err {\n+    if def_path_res(cx, path, None) != Res::Err {\n         return true;\n     }\n \n@@ -1077,7 +1206,7 @@ impl<'tcx> LateLintPass<'tcx> for InterningDefinedSymbol {\n         }\n \n         for &module in &[&paths::KW_MODULE, &paths::SYM_MODULE] {\n-            if let Some(def_id) = def_path_res(cx, module).opt_def_id() {\n+            if let Some(def_id) = def_path_res(cx, module, None).opt_def_id() {\n                 for item in cx.tcx.module_children(def_id).iter() {\n                     if_chain! {\n                         if let Res::Def(DefKind::Const, item_def_id) = item.res;"}, {"sha": "c84191bb01034bf0c18b426af5e35805e2d9b2c4", "filename": "src/tools/clippy/clippy_lints/src/utils/internal_lints/metadata_collector.rs", "status": "modified", "additions": 33, "deletions": 64, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -64,46 +64,6 @@ const DEFAULT_LINT_LEVELS: &[(&str, &str)] = &[\n /// This prefix is in front of the lint groups in the lint store. The prefix will be trimmed\n /// to only keep the actual lint group in the output.\n const CLIPPY_LINT_GROUP_PREFIX: &str = \"clippy::\";\n-\n-/// This template will be used to format the configuration section in the lint documentation.\n-/// The `configurations` parameter will be replaced with one or multiple formatted\n-/// `ClippyConfiguration` instances. See `CONFIGURATION_VALUE_TEMPLATE` for further customizations\n-macro_rules! CONFIGURATION_SECTION_TEMPLATE {\n-    () => {\n-        r#\"\n-### Configuration\n-This lint has the following configuration variables:\n-\n-{configurations}\n-\"#\n-    };\n-}\n-/// This template will be used to format an individual `ClippyConfiguration` instance in the\n-/// lint documentation.\n-///\n-/// The format function will provide strings for the following parameters: `name`, `ty`, `doc` and\n-/// `default`\n-macro_rules! CONFIGURATION_VALUE_TEMPLATE {\n-    () => {\n-        \"* `{name}`: `{ty}`: {doc} (defaults to `{default}`)\\n\"\n-    };\n-}\n-\n-macro_rules! RENAMES_SECTION_TEMPLATE {\n-    () => {\n-        r#\"\n-### Past names\n-\n-{names}\n-\"#\n-    };\n-}\n-macro_rules! RENAME_VALUE_TEMPLATE {\n-    () => {\n-        \"* `{name}`\\n\"\n-    };\n-}\n-\n const LINT_EMISSION_FUNCTIONS: [&[&str]; 7] = [\n     &[\"clippy_utils\", \"diagnostics\", \"span_lint\"],\n     &[\"clippy_utils\", \"diagnostics\", \"span_lint_and_help\"],\n@@ -205,7 +165,16 @@ impl MetadataCollector {\n             .filter(|config| config.lints.iter().any(|lint| lint == lint_name))\n             .map(ToString::to_string)\n             .reduce(|acc, x| acc + &x)\n-            .map(|configurations| format!(CONFIGURATION_SECTION_TEMPLATE!(), configurations = configurations))\n+            .map(|configurations| {\n+                format!(\n+                    r#\"\n+### Configuration\n+This lint has the following configuration variables:\n+\n+{configurations}\n+\"#\n+                )\n+            })\n     }\n }\n \n@@ -291,16 +260,13 @@ fn replace_produces(lint_name: &str, docs: &mut String, clippy_project_root: &Pa\n                             continue;\n                         }\n \n-                        panic!(\"lint `{}` has an unterminated code block\", lint_name)\n+                        panic!(\"lint `{lint_name}` has an unterminated code block\")\n                     }\n \n                     break;\n                 },\n                 Some(line) if line.trim_start() == \"{{produces}}\" => {\n-                    panic!(\n-                        \"lint `{}` has marker {{{{produces}}}} with an ignored or missing code block\",\n-                        lint_name\n-                    )\n+                    panic!(\"lint `{lint_name}` has marker {{{{produces}}}} with an ignored or missing code block\")\n                 },\n                 Some(line) => {\n                     let line = line.trim();\n@@ -319,7 +285,7 @@ fn replace_produces(lint_name: &str, docs: &mut String, clippy_project_root: &Pa\n             match lines.next() {\n                 Some(line) if line.trim_start() == \"```\" => break,\n                 Some(line) => example.push(line),\n-                None => panic!(\"lint `{}` has an unterminated code block\", lint_name),\n+                None => panic!(\"lint `{lint_name}` has an unterminated code block\"),\n             }\n         }\n \n@@ -336,10 +302,9 @@ fn replace_produces(lint_name: &str, docs: &mut String, clippy_project_root: &Pa\n                             <summary>Produces</summary>\\n\\\n                             \\n\\\n                             ```text\\n\\\n-                            {}\\n\\\n+                            {output}\\n\\\n                             ```\\n\\\n-                        </details>\",\n-                            output\n+                        </details>\"\n                         ),\n                     );\n \n@@ -394,7 +359,7 @@ fn get_lint_output(lint_name: &str, example: &[&mut String], clippy_project_root\n         panic!(\"failed to write to `{}`: {e}\", file.as_path().to_string_lossy());\n     }\n \n-    let prefixed_name = format!(\"{}{lint_name}\", CLIPPY_LINT_GROUP_PREFIX);\n+    let prefixed_name = format!(\"{CLIPPY_LINT_GROUP_PREFIX}{lint_name}\");\n \n     let mut cmd = Command::new(\"cargo\");\n \n@@ -417,7 +382,7 @@ fn get_lint_output(lint_name: &str, example: &[&mut String], clippy_project_root\n     let output = cmd\n         .arg(file.as_path())\n         .output()\n-        .unwrap_or_else(|e| panic!(\"failed to run `{:?}`: {e}\", cmd));\n+        .unwrap_or_else(|e| panic!(\"failed to run `{cmd:?}`: {e}\"));\n \n     let tmp_file_path = file.to_string_lossy();\n     let stderr = std::str::from_utf8(&output.stderr).unwrap();\n@@ -441,8 +406,7 @@ fn get_lint_output(lint_name: &str, example: &[&mut String], clippy_project_root\n         let rendered: Vec<&str> = msgs.iter().filter_map(|msg| msg[\"rendered\"].as_str()).collect();\n         let non_json: Vec<&str> = stderr.lines().filter(|line| !line.starts_with('{')).collect();\n         panic!(\n-            \"did not find lint `{}` in output of example, got:\\n{}\\n{}\",\n-            lint_name,\n+            \"did not find lint `{lint_name}` in output of example, got:\\n{}\\n{}\",\n             non_json.join(\"\\n\"),\n             rendered.join(\"\\n\")\n         );\n@@ -588,13 +552,10 @@ fn to_kebab(config_name: &str) -> String {\n \n impl fmt::Display for ClippyConfiguration {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> fmt::Result {\n-        write!(\n+        writeln!(\n             f,\n-            CONFIGURATION_VALUE_TEMPLATE!(),\n-            name = self.name,\n-            ty = self.config_type,\n-            doc = self.doc,\n-            default = self.default\n+            \"* `{}`: `{}`: {} (defaults to `{}`)\",\n+            self.name, self.config_type, self.doc, self.default\n         )\n     }\n }\n@@ -811,7 +772,7 @@ fn get_lint_group_and_level_or_lint(\n                 lint_collection_error_item(\n                     cx,\n                     item,\n-                    &format!(\"Unable to determine lint level for found group `{}`\", group),\n+                    &format!(\"Unable to determine lint level for found group `{group}`\"),\n                 );\n                 None\n             }\n@@ -869,7 +830,7 @@ fn collect_renames(lints: &mut Vec<LintMetadata>) {\n                         if name == lint_name;\n                         if let Some(past_name) = k.strip_prefix(CLIPPY_LINT_GROUP_PREFIX);\n                         then {\n-                            write!(collected, RENAME_VALUE_TEMPLATE!(), name = past_name).unwrap();\n+                            writeln!(collected, \"* `{past_name}`\").unwrap();\n                             names.push(past_name.to_string());\n                         }\n                     }\n@@ -882,7 +843,15 @@ fn collect_renames(lints: &mut Vec<LintMetadata>) {\n         }\n \n         if !collected.is_empty() {\n-            write!(&mut lint.docs, RENAMES_SECTION_TEMPLATE!(), names = collected).unwrap();\n+            write!(\n+                &mut lint.docs,\n+                r#\"\n+### Past names\n+\n+{collected}\n+\"#\n+            )\n+            .unwrap();\n         }\n     }\n }\n@@ -895,7 +864,7 @@ fn lint_collection_error_item(cx: &LateContext<'_>, item: &Item<'_>, message: &s\n         cx,\n         INTERNAL_METADATA_COLLECTOR,\n         item.ident.span,\n-        &format!(\"metadata collection error for `{}`: {}\", item.ident.name, message),\n+        &format!(\"metadata collection error for `{}`: {message}\", item.ident.name),\n     );\n }\n "}, {"sha": "301eed9a1fbfe72d995d687ed792358b45e4b6bf", "filename": "src/tools/clippy/clippy_lints/src/wildcard_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwildcard_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwildcard_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwildcard_imports.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -173,7 +173,7 @@ impl LateLintPass<'_> for WildcardImports {\n                 let sugg = if braced_glob {\n                     imports_string\n                 } else {\n-                    format!(\"{}::{}\", import_source_snippet, imports_string)\n+                    format!(\"{import_source_snippet}::{imports_string}\")\n                 };\n \n                 let (lint, message) = if let Res::Def(DefKind::Enum, _) = use_path.res {"}, {"sha": "36574198f9174a314dcc95ddf3356f1ba2aea54e", "filename": "src/tools/clippy/clippy_lints/src/write.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233384f3956b2b16bba935f6f8d10d073f8ddf4a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs?ref=233384f3956b2b16bba935f6f8d10d073f8ddf4a", "patch": "@@ -1,12 +1,12 @@\n use clippy_utils::diagnostics::{span_lint, span_lint_and_then};\n use clippy_utils::macros::{root_macro_call_first_node, FormatArgsExpn, MacroCall};\n-use clippy_utils::source::snippet_opt;\n+use clippy_utils::source::{expand_past_previous_comma, snippet_opt};\n use rustc_ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind, HirIdMap, Impl, Item, ItemKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::{sym, BytePos, Span};\n+use rustc_span::{sym, BytePos};\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -475,11 +475,11 @@ fn check_literal(cx: &LateContext<'_>, format_args: &FormatArgsExpn<'_>, name: &\n                 value.span,\n                 \"literal with an empty format string\",\n                 |diag| {\n-                    if let Some(replacement) = replacement {\n+                    if let Some(replacement) = replacement\n                         // `format!(\"{}\", \"a\")`, `format!(\"{named}\", named = \"b\")\n                         //              ~~~~~                      ~~~~~~~~~~~~~\n-                        let value_span = expand_past_previous_comma(cx, value.span);\n-\n+                        && let Some(value_span) = format_args.value_with_prev_comma_span(value.hir_id)\n+                    {\n                         let replacement = replacement.replace('{', \"{{\").replace('}', \"}}\");\n                         diag.multipart_suggestion(\n                             \"try this\",\n@@ -542,10 +542,3 @@ fn conservative_unescape(literal: &str) -> Result<String, UnescapeErr> {\n \n     if err { Err(UnescapeErr::Lint) } else { Ok(unescaped) }\n }\n-\n-// Expand from `writeln!(o, \"\")` to `writeln!(o, \"\")`\n-//                          ^^                 ^^^^\n-fn expand_past_previous_comma(cx: &LateContext<'_>, span: Span) -> Span {\n-    let extended = cx.sess().source_map().span_extend_to_prev_char(span, ',', true);\n-    extended.with_lo(extended.lo() - BytePos(1))\n-}"}]}