{"sha": "748bbf259a4835792a37558def86d5ef85a93de3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0OGJiZjI1OWE0ODM1NzkyYTM3NTU4ZGVmODZkNWVmODVhOTNkZTM=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2019-10-22T21:55:04Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2019-10-26T03:57:04Z"}, "message": "Deduplicate `promote_consts::Validator` and `check_consts::Item`", "tree": {"sha": "39ad2cc12df1ea46822d4daf31938a37a5bf1ccf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39ad2cc12df1ea46822d4daf31938a37a5bf1ccf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/748bbf259a4835792a37558def86d5ef85a93de3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/748bbf259a4835792a37558def86d5ef85a93de3", "html_url": "https://github.com/rust-lang/rust/commit/748bbf259a4835792a37558def86d5ef85a93de3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/748bbf259a4835792a37558def86d5ef85a93de3/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a462ff24a306a2a70235710a6bd96b695bc0197", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a462ff24a306a2a70235710a6bd96b695bc0197", "html_url": "https://github.com/rust-lang/rust/commit/8a462ff24a306a2a70235710a6bd96b695bc0197"}], "stats": {"total": 78, "additions": 30, "deletions": 48}, "files": [{"sha": "a3d535188f40723de70ede92f7e3aea6211fab9f", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 30, "deletions": 48, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/748bbf259a4835792a37558def86d5ef85a93de3/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/748bbf259a4835792a37558def86d5ef85a93de3/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=748bbf259a4835792a37558def86d5ef85a93de3", "patch": "@@ -12,7 +12,6 @@\n //! initialization and can otherwise silence errors, if\n //! move analysis runs after promotion on broken MIR.\n \n-use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::mir::*;\n use rustc::mir::interpret::ConstValue;\n@@ -30,7 +29,7 @@ use rustc_target::spec::abi::Abi;\n \n use std::{iter, mem, usize};\n \n-use crate::transform::check_consts::{qualifs, Item as ConstCx};\n+use crate::transform::check_consts::{qualifs, Item, ConstKind};\n \n /// State of a temporary during collection and promotion.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n@@ -224,18 +223,13 @@ pub fn collect_temps_and_candidates(\n     (collector.temps, collector.candidates)\n }\n \n+/// Checks whether locals that appear in a promotion context (`Candidate`) are actually promotable.\n+///\n+/// This wraps an `Item`, and has access to all fields of that `Item` via `Deref` coercion.\n struct Validator<'a, 'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    body: &'a Body<'tcx>,\n-    is_static: bool,\n-    is_static_mut: bool,\n-    is_non_const_fn: bool,\n+    item: Item<'a, 'tcx>,\n     temps: &'a IndexVec<Local, TempState>,\n \n-    // FIXME(eddyb) deduplicate the data in this vs other fields.\n-    const_cx: ConstCx<'a, 'tcx>,\n-\n     /// Explicit promotion happens e.g. for constant arguments declared via\n     /// `rustc_args_required_const`.\n     /// Implicit promotion has almost the same rules, except that disallows `const fn`\n@@ -245,6 +239,14 @@ struct Validator<'a, 'tcx> {\n     explicit: bool,\n }\n \n+impl std::ops::Deref for Validator<'a, 'tcx> {\n+    type Target = Item<'a, 'tcx>;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &self.item\n+    }\n+}\n+\n struct Unpromotable;\n \n impl<'tcx> Validator<'_, 'tcx> {\n@@ -317,13 +319,14 @@ impl<'tcx> Validator<'_, 'tcx> {\n                         if self.qualif_local::<qualifs::NeedsDrop>(base) {\n                             return Err(Unpromotable);\n                         }\n+\n                         if let BorrowKind::Mut { .. } = kind {\n                             let ty = place.ty(self.body, self.tcx).ty;\n \n                             // In theory, any zero-sized value could be borrowed\n                             // mutably without consequences. However, only &mut []\n                             // is allowed right now, and only in functions.\n-                            if self.is_static_mut {\n+                            if self.const_kind == Some(ConstKind::StaticMut) {\n                                 // Inside a `static mut`, &mut [...] is also allowed.\n                                 match ty.kind {\n                                     ty::Array(..) | ty::Slice(_) => {}\n@@ -333,7 +336,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                                 // FIXME(eddyb) the `self.is_non_const_fn` condition\n                                 // seems unnecessary, given that this is merely a ZST.\n                                 match len.try_eval_usize(self.tcx, self.param_env) {\n-                                    Some(0) if self.is_non_const_fn => {},\n+                                    Some(0) if self.const_kind.is_none() => {},\n                                     _ => return Err(Unpromotable),\n                                 }\n                             } else {\n@@ -386,7 +389,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 let statement = &self.body[loc.block].statements[loc.statement_index];\n                 match &statement.kind {\n                     StatementKind::Assign(box(_, rhs)) => {\n-                        Q::in_rvalue(&self.const_cx, per_local, rhs)\n+                        Q::in_rvalue(&self.item, per_local, rhs)\n                     }\n                     _ => {\n                         span_bug!(statement.source_info.span, \"{:?} is not an assignment\",\n@@ -398,7 +401,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 match &terminator.kind {\n                     TerminatorKind::Call { func, args, .. } => {\n                         let return_ty = self.body.local_decls[local].ty;\n-                        Q::in_call(&self.const_cx, per_local, func, args, return_ty)\n+                        Q::in_call(&self.item, per_local, func, args, return_ty)\n                     }\n                     kind => {\n                         span_bug!(terminator.source_info.span, \"{:?} not promotable\", kind);\n@@ -462,8 +465,8 @@ impl<'tcx> Validator<'_, 'tcx> {\n             } => {\n                 // Only allow statics (not consts) to refer to other statics.\n                 // FIXME(eddyb) does this matter at all for promotion?\n-                let allowed = self.is_static || self.is_static_mut;\n-                if !allowed {\n+                let is_static = self.const_kind.map_or(false, |k| k.is_static());\n+                if !is_static {\n                     return Err(Unpromotable);\n                 }\n \n@@ -490,7 +493,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                     }\n \n                     ProjectionElem::Field(..) => {\n-                        if self.is_non_const_fn {\n+                        if self.const_kind.is_none() {\n                             let base_ty =\n                                 Place::ty_from(place.base, proj_base, self.body, self.tcx).ty;\n                             if let Some(def) = base_ty.ty_adt_def() {\n@@ -545,7 +548,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n \n     fn validate_rvalue(&self, rvalue: &Rvalue<'tcx>) -> Result<(), Unpromotable> {\n         match *rvalue {\n-            Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) if self.is_non_const_fn => {\n+            Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) if self.const_kind.is_none() => {\n                 let operand_ty = operand.ty(self.body, self.tcx);\n                 let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n                 let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n@@ -559,7 +562,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 }\n             }\n \n-            Rvalue::BinaryOp(op, ref lhs, _) if self.is_non_const_fn => {\n+            Rvalue::BinaryOp(op, ref lhs, _) if self.const_kind.is_none() => {\n                 if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(self.body, self.tcx).kind {\n                     assert!(op == BinOp::Eq || op == BinOp::Ne ||\n                             op == BinOp::Le || op == BinOp::Lt ||\n@@ -600,17 +603,17 @@ impl<'tcx> Validator<'_, 'tcx> {\n                     // In theory, any zero-sized value could be borrowed\n                     // mutably without consequences. However, only &mut []\n                     // is allowed right now, and only in functions.\n-                    if self.is_static_mut {\n+                    if self.const_kind == Some(ConstKind::StaticMut) {\n                         // Inside a `static mut`, &mut [...] is also allowed.\n                         match ty.kind {\n                             ty::Array(..) | ty::Slice(_) => {}\n                             _ => return Err(Unpromotable),\n                         }\n                     } else if let ty::Array(_, len) = ty.kind {\n-                        // FIXME(eddyb) the `self.is_non_const_fn` condition\n-                        // seems unnecessary, given that this is merely a ZST.\n+                        // FIXME(eddyb): We only return `Unpromotable` for `&mut []` inside a\n+                        // const context which seems unnecessary given that this is merely a ZST.\n                         match len.try_eval_usize(self.tcx, self.param_env) {\n-                            Some(0) if self.is_non_const_fn => {},\n+                            Some(0) if self.const_kind.is_none() => {},\n                             _ => return Err(Unpromotable),\n                         }\n                     } else {\n@@ -683,7 +686,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n     ) -> Result<(), Unpromotable> {\n         let fn_ty = callee.ty(self.body, self.tcx);\n \n-        if !self.explicit && self.is_non_const_fn {\n+        if !self.explicit && self.const_kind.is_none() {\n             if let ty::FnDef(def_id, _) = fn_ty.kind {\n                 // Never promote runtime `const fn` calls of\n                 // functions without `#[rustc_promotable]`.\n@@ -714,6 +717,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n     }\n }\n \n+// FIXME(eddyb) remove the differences for promotability in `static`, `const`, `const fn`.\n pub fn validate_candidates(\n     tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n@@ -722,33 +726,11 @@ pub fn validate_candidates(\n     candidates: &[Candidate],\n ) -> Vec<Candidate> {\n     let mut validator = Validator {\n-        tcx,\n-        param_env: tcx.param_env(def_id),\n-        body,\n-        is_static: false,\n-        is_static_mut: false,\n-        is_non_const_fn: false,\n+        item: Item::new(tcx, def_id, body),\n         temps,\n-\n-        const_cx: ConstCx::new(tcx, def_id, body),\n-\n         explicit: false,\n     };\n \n-    // FIXME(eddyb) remove the distinctions that make this necessary.\n-    let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-    match tcx.hir().body_owner_kind(id) {\n-        hir::BodyOwnerKind::Closure => validator.is_non_const_fn = true,\n-        hir::BodyOwnerKind::Fn => {\n-            if !tcx.is_const_fn(def_id) {\n-                validator.is_non_const_fn = true;\n-            }\n-        },\n-        hir::BodyOwnerKind::Static(hir::MutImmutable) => validator.is_static = true,\n-        hir::BodyOwnerKind::Static(hir::MutMutable) => validator.is_static_mut = true,\n-        _ => {}\n-    }\n-\n     candidates.iter().copied().filter(|&candidate| {\n         validator.explicit = match candidate {\n             Candidate::Ref(_) |"}]}