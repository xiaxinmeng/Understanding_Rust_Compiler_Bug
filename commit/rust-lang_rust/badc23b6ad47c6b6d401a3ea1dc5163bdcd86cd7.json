{"sha": "badc23b6ad47c6b6d401a3ea1dc5163bdcd86cd7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhZGMyM2I2YWQ0N2M2YjZkNDAxYTNlYTFkYzUxNjNiZGNkODZjZDc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-04T20:24:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-04T20:24:35Z"}, "message": "Auto merge of #30602 - tsion:mir-graphviz-display, r=nikomatsakis\n\nr? @nikomatsakis\n\ncc @eddyb @nagisa\n\nThis PR changes most of the MIR graphviz debug output, making it smaller and more consistent. Also, it changes all fonts to monospace and adds a graph label containing the type of the `fn` the MIR is for and all the values (arguments, named bindings, and compiler temporaries).\n\nI chose to re-write the graphviz output code instead of using the existing libgraphviz API because I found it much easier to prototype usage of various graphviz features when I had full control of the text output. It also makes the code simpler, I think.\n\nBelow are a bunch of example functions and links to their output images on the current nightly vs. this PR. File names starting with numbers (e.g. `80-factorial_fold-new.png`) are for closures. There's still a bunch of low hanging fruit to make it even better, particularly around aggregates and references.\n\nI also imagine the textual output for MIR will be able to closely match the graphviz output. The list of statements should look identical and the terminators will be the same except that the text form will have a list of target blocks (potentially using the same edge labels as the graphviz does). I can PR a simple text output right after this PR.\n\nThis is my first large change to the compiler, so if anything should be reorganized/renamed/etc, let me know! Also, feel free to bikeshed the details of the output, though any minor changes can come in future PRs.\n\n```rust\nfn empty() {}\n```\n\nhttp://vps.solson.me/mir-graphviz/empty-new.png\nhttp://vps.solson.me/mir-graphviz/empty-old.png\n\n```rust\nfn constant() -> i32 {\n    42\n}\n```\n\nhttp://vps.solson.me/mir-graphviz/constant-new.png\nhttp://vps.solson.me/mir-graphviz/constant-old.png\n\n```rust\nfn increment(x: i32) -> i32 {\n    x + 1\n}\n```\n\nhttp://vps.solson.me/mir-graphviz/increment-new.png\nhttp://vps.solson.me/mir-graphviz/increment-old.png\n\n```rust\nfn factorial_recursive(n: usize) -> usize {\n    if n == 0 {\n        1\n    } else {\n        n * factorial_recursive(n - 1)\n    }\n}\n```\n\nhttp://vps.solson.me/mir-graphviz/factorial_recursive-new.png\nhttp://vps.solson.me/mir-graphviz/factorial_recursive-old.png\n\n```rust\nfn factorial_iterative(n: usize) -> usize {\n    let mut prod = 1;\n    for x in 1..n {\n        prod *= x;\n    }\n    prod\n}\n```\n\nhttp://vps.solson.me/mir-graphviz/factorial_iterative-new.png\nhttp://vps.solson.me/mir-graphviz/factorial_iterative-old.png\n\n```rust\nfn factorial_fold(n: usize) -> usize {\n    (1..n).fold(1, |prod, x| prod * x)\n}\n```\n\nhttp://vps.solson.me/mir-graphviz/factorial_fold-new.png\nhttp://vps.solson.me/mir-graphviz/factorial_fold-old.png\nhttp://vps.solson.me/mir-graphviz/80-factorial_fold-new.png\nhttp://vps.solson.me/mir-graphviz/80-factorial_fold-old.png\n\n```rust\nfn collatz(mut n: usize) {\n    while n != 1 {\n        if n % 2 == 0 {\n            n /= 2;\n        } else {\n            n = 3 * n + 1;\n        }\n    }\n}\n```\n\nhttp://vps.solson.me/mir-graphviz/collatz-new.png\nhttp://vps.solson.me/mir-graphviz/collatz-old.png\n\n```rust\nfn multi_switch(n: usize) -> usize {\n    match n {\n        5 | 10 | 15 => 3,\n        20 | 30 => 2,\n        _ => 1,\n    }\n}\n```\n\nhttp://vps.solson.me/mir-graphviz/multi_switch-new.png\nhttp://vps.solson.me/mir-graphviz/multi_switch-old.png", "tree": {"sha": "cb915eac5c2bbf08fe7ab9ba9ccad0ec687cea02", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb915eac5c2bbf08fe7ab9ba9ccad0ec687cea02"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/badc23b6ad47c6b6d401a3ea1dc5163bdcd86cd7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/badc23b6ad47c6b6d401a3ea1dc5163bdcd86cd7", "html_url": "https://github.com/rust-lang/rust/commit/badc23b6ad47c6b6d401a3ea1dc5163bdcd86cd7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/badc23b6ad47c6b6d401a3ea1dc5163bdcd86cd7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e8cb3819bf62527947634ad4d5e44b4b69daecd", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e8cb3819bf62527947634ad4d5e44b4b69daecd", "html_url": "https://github.com/rust-lang/rust/commit/5e8cb3819bf62527947634ad4d5e44b4b69daecd"}, {"sha": "56343cd6535f6e5910662244290da34a0c193f95", "url": "https://api.github.com/repos/rust-lang/rust/commits/56343cd6535f6e5910662244290da34a0c193f95", "html_url": "https://github.com/rust-lang/rust/commit/56343cd6535f6e5910662244290da34a0c193f95"}], "stats": {"total": 454, "additions": 254, "deletions": 200}, "files": [{"sha": "b6e86077ccff991091683e6cc2948386e8c6e96e", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 117, "deletions": 31, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/badc23b6ad47c6b6d401a3ea1dc5163bdcd86cd7/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/badc23b6ad47c6b6d401a3ea1dc5163bdcd86cd7/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=badc23b6ad47c6b6d401a3ea1dc5163bdcd86cd7", "patch": "@@ -11,14 +11,15 @@\n use middle::const_eval::ConstVal;\n use middle::def_id::DefId;\n use middle::subst::Substs;\n-use middle::ty::{AdtDef, ClosureSubsts, FnOutput, Region, Ty};\n+use middle::ty::{self, AdtDef, ClosureSubsts, FnOutput, Region, Ty};\n use rustc_back::slice;\n use rustc_data_structures::tuple_slice::TupleSlice;\n use rustc_front::hir::InlineAsm;\n use syntax::ast::Name;\n use syntax::codemap::Span;\n-use std::fmt::{Debug, Formatter, Error};\n-use std::u32;\n+use std::borrow::{Cow, IntoCow};\n+use std::fmt::{Debug, Formatter, Error, Write};\n+use std::{iter, u32};\n \n /// Lowered representation of a single function.\n #[derive(RustcEncodable, RustcDecodable)]\n@@ -317,31 +318,81 @@ impl<'tcx> BasicBlockData<'tcx> {\n \n impl<'tcx> Debug for Terminator<'tcx> {\n     fn fmt(&self, fmt: &mut Formatter) -> Result<(), Error> {\n+        try!(self.fmt_head(fmt));\n+        let successors = self.successors();\n+        let labels = self.fmt_successor_labels();\n+        assert_eq!(successors.len(), labels.len());\n+\n+        match successors.len() {\n+            0 => Ok(()),\n+\n+            1 => write!(fmt, \" -> {:?}\", successors[0]),\n+\n+            _ => {\n+                try!(write!(fmt, \" -> [\"));\n+                for (i, target) in successors.iter().enumerate() {\n+                    if i > 0 {\n+                        try!(write!(fmt, \", \"));\n+                    }\n+                    try!(write!(fmt, \"{}: {:?}\", labels[i], target));\n+                }\n+                write!(fmt, \"]\")\n+            }\n+\n+        }\n+    }\n+}\n+\n+impl<'tcx> Terminator<'tcx> {\n+    /// Write the \"head\" part of the terminator; that is, its name and the data it uses to pick the\n+    /// successor basic block, if any. The only information not inlcuded is the list of possible\n+    /// successors, which may be rendered differently between the text and the graphviz format.\n+    pub fn fmt_head<W: Write>(&self, fmt: &mut W) -> Result<(), Error> {\n         use self::Terminator::*;\n         match *self {\n-            Goto { target } =>\n-                write!(fmt, \"goto -> {:?}\", target),\n-            Panic { target } =>\n-                write!(fmt, \"panic -> {:?}\", target),\n-            If { cond: ref lv, ref targets } =>\n-                write!(fmt, \"if({:?}) -> {:?}\", lv, targets),\n-            Switch { discr: ref lv, adt_def: _, ref targets } =>\n-                write!(fmt, \"switch({:?}) -> {:?}\", lv, targets),\n-            SwitchInt { discr: ref lv, switch_ty: _, ref values, ref targets } =>\n-                write!(fmt, \"switchInt({:?}, {:?}) -> {:?}\", lv, values, targets),\n-            Diverge =>\n-                write!(fmt, \"diverge\"),\n-            Return =>\n-                write!(fmt, \"return\"),\n-            Call { data: ref c, targets } => {\n+            Goto { .. } => write!(fmt, \"goto\"),\n+            Panic { .. } => write!(fmt, \"panic\"),\n+            If { cond: ref lv, .. } => write!(fmt, \"if({:?})\", lv),\n+            Switch { discr: ref lv, .. } => write!(fmt, \"switch({:?})\", lv),\n+            SwitchInt { discr: ref lv, .. } => write!(fmt, \"switchInt({:?})\", lv),\n+            Diverge => write!(fmt, \"diverge\"),\n+            Return => write!(fmt, \"return\"),\n+            Call { data: ref c, .. } => {\n                 try!(write!(fmt, \"{:?} = {:?}(\", c.destination, c.func));\n                 for (index, arg) in c.args.iter().enumerate() {\n                     if index > 0 {\n                         try!(write!(fmt, \", \"));\n                     }\n                     try!(write!(fmt, \"{:?}\", arg));\n                 }\n-                write!(fmt, \") -> {:?}\", targets)\n+                write!(fmt, \")\")\n+            }\n+        }\n+    }\n+\n+    /// Return the list of labels for the edges to the successor basic blocks.\n+    pub fn fmt_successor_labels(&self) -> Vec<Cow<'static, str>> {\n+        use self::Terminator::*;\n+        match *self {\n+            Diverge | Return => vec![],\n+            Goto { .. } | Panic { .. } => vec![\"\".into_cow()],\n+            If { .. } => vec![\"true\".into_cow(), \"false\".into_cow()],\n+            Call { .. } => vec![\"return\".into_cow(), \"unwind\".into_cow()],\n+            Switch { ref adt_def, .. } => {\n+                adt_def.variants\n+                       .iter()\n+                       .map(|variant| variant.name.to_string().into_cow())\n+                       .collect()\n+            }\n+            SwitchInt { ref values, .. } => {\n+                values.iter()\n+                      .map(|const_val| {\n+                          let mut buf = String::new();\n+                          fmt_const_val(&mut buf, const_val).unwrap();\n+                          buf.into_cow()\n+                      })\n+                      .chain(iter::once(String::from(\"otherwise\").into_cow()))\n+                      .collect()\n             }\n         }\n     }\n@@ -495,19 +546,19 @@ impl<'tcx> Debug for Lvalue<'tcx> {\n \n         match *self {\n             Var(id) =>\n-                write!(fmt,\"Var({:?})\", id),\n+                write!(fmt,\"var{:?}\", id),\n             Arg(id) =>\n-                write!(fmt,\"Arg({:?})\", id),\n+                write!(fmt,\"arg{:?}\", id),\n             Temp(id) =>\n-                write!(fmt,\"Temp({:?})\", id),\n+                write!(fmt,\"tmp{:?}\", id),\n             Static(id) =>\n                 write!(fmt,\"Static({:?})\", id),\n             ReturnPointer =>\n                 write!(fmt,\"ReturnPointer\"),\n             Projection(ref data) =>\n                 match data.elem {\n-                    ProjectionElem::Downcast(_, variant_index) =>\n-                        write!(fmt,\"({:?} as {:?})\", data.base, variant_index),\n+                    ProjectionElem::Downcast(ref adt_def, index) =>\n+                        write!(fmt,\"({:?} as {})\", data.base, adt_def.variants[index].name),\n                     ProjectionElem::Deref =>\n                         write!(fmt,\"(*{:?})\", data.base),\n                     ProjectionElem::Field(field) =>\n@@ -671,12 +722,12 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n             Use(ref lvalue) => write!(fmt, \"{:?}\", lvalue),\n             Repeat(ref a, ref b) => write!(fmt, \"[{:?}; {:?}]\", a, b),\n             Ref(ref a, bk, ref b) => write!(fmt, \"&{:?} {:?} {:?}\", a, bk, b),\n-            Len(ref a) => write!(fmt, \"LEN({:?})\", a),\n-            Cast(ref kind, ref lv, ref ty) => write!(fmt, \"{:?} as {:?} ({:?}\", lv, ty, kind),\n-            BinaryOp(ref op, ref a, ref b) => write!(fmt, \"{:?}({:?},{:?})\", op, a, b),\n+            Len(ref a) => write!(fmt, \"Len({:?})\", a),\n+            Cast(ref kind, ref lv, ref ty) => write!(fmt, \"{:?} as {:?} ({:?})\", lv, ty, kind),\n+            BinaryOp(ref op, ref a, ref b) => write!(fmt, \"{:?}({:?}, {:?})\", op, a, b),\n             UnaryOp(ref op, ref a) => write!(fmt, \"{:?}({:?})\", op, a),\n-            Box(ref t) => write!(fmt, \"Box {:?}\", t),\n-            Aggregate(ref kind, ref lvs) => write!(fmt, \"Aggregate<{:?}>({:?})\", kind, lvs),\n+            Box(ref t) => write!(fmt, \"Box({:?})\", t),\n+            Aggregate(ref kind, ref lvs) => write!(fmt, \"Aggregate<{:?}>{:?}\", kind, lvs),\n             InlineAsm(ref asm) => write!(fmt, \"InlineAsm({:?})\", asm),\n             Slice { ref input, from_start, from_end } =>\n                 write!(fmt, \"{:?}[{:?}..-{:?}]\", input, from_start, from_end),\n@@ -691,7 +742,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n // this does not necessarily mean that they are \"==\" in Rust -- in\n // particular one must be wary of `NaN`!\n \n-#[derive(Clone, Debug, PartialEq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable)]\n pub struct Constant<'tcx> {\n     pub span: Span,\n     pub ty: Ty<'tcx>,\n@@ -707,7 +758,7 @@ pub enum ItemKind {\n     Method,\n }\n \n-#[derive(Clone, Debug, PartialEq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable)]\n pub enum Literal<'tcx> {\n     Item {\n         def_id: DefId,\n@@ -718,3 +769,38 @@ pub enum Literal<'tcx> {\n         value: ConstVal,\n     },\n }\n+\n+impl<'tcx> Debug for Constant<'tcx> {\n+    fn fmt(&self, fmt: &mut Formatter) -> Result<(), Error> {\n+        write!(fmt, \"{:?}\", self.literal)\n+    }\n+}\n+\n+impl<'tcx> Debug for Literal<'tcx> {\n+    fn fmt(&self, fmt: &mut Formatter) -> Result<(), Error> {\n+        use self::Literal::*;\n+        match *self {\n+            Item { def_id, .. } =>\n+                write!(fmt, \"{}\", ty::tls::with(|tcx| tcx.item_path_str(def_id))),\n+            Value { ref value } => fmt_const_val(fmt, value),\n+        }\n+    }\n+}\n+\n+/// Write a `ConstVal` in a way closer to the original source code than the `Debug` output.\n+pub fn fmt_const_val<W: Write>(fmt: &mut W, const_val: &ConstVal) -> Result<(), Error> {\n+    use middle::const_eval::ConstVal::*;\n+    match *const_val {\n+        Float(f) => write!(fmt, \"{:?}\", f),\n+        Int(n) => write!(fmt, \"{:?}\", n),\n+        Uint(n) => write!(fmt, \"{:?}\", n),\n+        Str(ref s) => write!(fmt, \"Str({:?})\", s),\n+        ByteStr(ref bytes) => write!(fmt, \"ByteStr{:?}\", bytes),\n+        Bool(b) => write!(fmt, \"{:?}\", b),\n+        Struct(id) => write!(fmt, \"Struct({:?})\", id),\n+        Tuple(id) => write!(fmt, \"Tuple({:?})\", id),\n+        Function(def_id) => write!(fmt, \"Function({:?})\", def_id),\n+        Array(id, n) => write!(fmt, \"Array({:?}, {:?})\", id, n),\n+        Repeat(id, n) => write!(fmt, \"Repeat({:?}, {:?})\", id, n),\n+    }\n+}"}, {"sha": "d1d3e80e3402f38df9ca0beedb636243277315d4", "filename": "src/librustc_mir/graphviz.rs", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/badc23b6ad47c6b6d401a3ea1dc5163bdcd86cd7/src%2Flibrustc_mir%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/badc23b6ad47c6b6d401a3ea1dc5163bdcd86cd7/src%2Flibrustc_mir%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fgraphviz.rs?ref=badc23b6ad47c6b6d401a3ea1dc5163bdcd86cd7", "patch": "@@ -0,0 +1,133 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use dot;\n+use rustc::mir::repr::*;\n+use rustc::middle::ty;\n+use std::fmt::Debug;\n+use std::io::{self, Write};\n+\n+/// Write a graphviz DOT graph for the given MIR.\n+pub fn write_mir_graphviz<W: Write>(mir: &Mir, w: &mut W) -> io::Result<()> {\n+    try!(writeln!(w, \"digraph Mir {{\"));\n+\n+    // Global graph properties\n+    try!(writeln!(w, r#\"    graph [fontname=\"monospace\"];\"#));\n+    try!(writeln!(w, r#\"    node [fontname=\"monospace\"];\"#));\n+    try!(writeln!(w, r#\"    edge [fontname=\"monospace\"];\"#));\n+\n+    // Graph label\n+    try!(write_graph_label(mir, w));\n+\n+    // Nodes\n+    for block in mir.all_basic_blocks() {\n+        try!(write_node(block, mir, w));\n+    }\n+\n+    // Edges\n+    for source in mir.all_basic_blocks() {\n+        try!(write_edges(source, mir, w));\n+    }\n+\n+    writeln!(w, \"}}\")\n+}\n+\n+/// Write a graphviz DOT node for the given basic block.\n+fn write_node<W: Write>(block: BasicBlock, mir: &Mir, w: &mut W) -> io::Result<()> {\n+    let data = mir.basic_block_data(block);\n+\n+    // Start a new node with the label to follow, in one of DOT's pseudo-HTML tables.\n+    try!(write!(w, r#\"    {} [shape=\"none\", label=<\"#, node(block)));\n+    try!(write!(w, r#\"<table border=\"0\" cellborder=\"1\" cellspacing=\"0\">\"#));\n+\n+    // Basic block number at the top.\n+    try!(write!(w, r#\"<tr><td bgcolor=\"gray\" align=\"center\">{}</td></tr>\"#, block.index()));\n+\n+    // List of statements in the middle.\n+    if !data.statements.is_empty() {\n+        try!(write!(w, r#\"<tr><td align=\"left\" balign=\"left\">\"#));\n+        for statement in &data.statements {\n+            try!(write!(w, \"{}<br/>\", escape(statement)));\n+        }\n+        try!(write!(w, \"</td></tr>\"));\n+    }\n+\n+    // Terminator head at the bottom, not including the list of successor blocks. Those will be\n+    // displayed as labels on the edges between blocks.\n+    let mut terminator_head = String::new();\n+    data.terminator.fmt_head(&mut terminator_head).unwrap();\n+    try!(write!(w, r#\"<tr><td align=\"left\">{}</td></tr>\"#, dot::escape_html(&terminator_head)));\n+\n+    // Close the table, node label, and the node itself.\n+    writeln!(w, \"</table>>];\")\n+}\n+\n+/// Write graphviz DOT edges with labels between the given basic block and all of its successors.\n+fn write_edges<W: Write>(source: BasicBlock, mir: &Mir, w: &mut W) -> io::Result<()> {\n+    let terminator = &mir.basic_block_data(source).terminator;\n+    let labels = terminator.fmt_successor_labels();\n+\n+    for (&target, label) in terminator.successors().iter().zip(labels) {\n+        try!(writeln!(w, r#\"    {} -> {} [label=\"{}\"];\"#, node(source), node(target), label));\n+    }\n+\n+    Ok(())\n+}\n+\n+/// Write the graphviz DOT label for the overall graph. This is essentially a block of text that\n+/// will appear below the graph, showing the type of the `fn` this MIR represents and the types of\n+/// all the variables and temporaries.\n+fn write_graph_label<W: Write>(mir: &Mir, w: &mut W) -> io::Result<()> {\n+    try!(write!(w, \"    label=<fn(\"));\n+\n+    // fn argument types.\n+    for (i, arg) in mir.arg_decls.iter().enumerate() {\n+        if i > 0 {\n+            try!(write!(w, \", \"));\n+        }\n+        try!(write!(w, \"{:?}: {}\", Lvalue::Arg(i as u32), escape(&arg.ty)));\n+    }\n+\n+    try!(write!(w, \") -&gt; \"));\n+\n+    // fn return type.\n+    match mir.return_ty {\n+        ty::FnOutput::FnConverging(ty) => try!(write!(w, \"{}\", escape(ty))),\n+        ty::FnOutput::FnDiverging => try!(write!(w, \"!\")),\n+    }\n+\n+    try!(write!(w, r#\"<br align=\"left\"/>\"#));\n+\n+    // User variable types (including the user's name in a comment).\n+    for (i, var) in mir.var_decls.iter().enumerate() {\n+        try!(write!(w, \"let \"));\n+        if var.mutability == Mutability::Mut {\n+            try!(write!(w, \"mut \"));\n+        }\n+        try!(write!(w, r#\"{:?}: {}; // {}<br align=\"left\"/>\"#,\n+                    Lvalue::Var(i as u32), escape(&var.ty), var.name));\n+    }\n+\n+    // Compiler-introduced temporary types.\n+    for (i, temp) in mir.temp_decls.iter().enumerate() {\n+        try!(write!(w, r#\"let mut {:?}: {};<br align=\"left\"/>\"#,\n+                    Lvalue::Temp(i as u32), escape(&temp.ty)));\n+    }\n+\n+    writeln!(w, \">;\")\n+}\n+\n+fn node(block: BasicBlock) -> String {\n+    format!(\"bb{}\", block.index())\n+}\n+\n+fn escape<T: Debug>(t: &T) -> String {\n+    dot::escape_html(&format!(\"{:?}\", t))\n+}"}, {"sha": "d5da606d76e80906f8b71efc0ebf5eb93c553c60", "filename": "src/librustc_mir/graphviz/mod.rs", "status": "removed", "additions": 0, "deletions": 166, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/5e8cb3819bf62527947634ad4d5e44b4b69daecd/src%2Flibrustc_mir%2Fgraphviz%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8cb3819bf62527947634ad4d5e44b4b69daecd/src%2Flibrustc_mir%2Fgraphviz%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fgraphviz%2Fmod.rs?ref=5e8cb3819bf62527947634ad4d5e44b4b69daecd", "patch": "@@ -1,166 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use dot;\n-use rustc::mir::repr::*;\n-use std::borrow::IntoCow;\n-\n-#[derive(Copy, Clone, PartialEq, Eq)]\n-pub struct EdgeIndex {\n-    source: BasicBlock,\n-    target: BasicBlock,\n-    index: usize,\n-}\n-\n-impl<'a,'tcx> dot::Labeller<'a, BasicBlock, EdgeIndex> for Mir<'tcx> {\n-    fn graph_id(&'a self) -> dot::Id<'a> {\n-        dot::Id::new(\"Mir\").unwrap()\n-    }\n-\n-    fn node_id(&'a self, n: &BasicBlock) -> dot::Id<'a> {\n-        dot::Id::new(format!(\"BB{}\", n.index())).unwrap()\n-    }\n-\n-    fn node_shape(&'a self, _: &BasicBlock) -> Option<dot::LabelText<'a>> {\n-        Some(dot::LabelText::label(\"none\"))\n-    }\n-\n-    fn node_label(&'a self, &n: &BasicBlock) -> dot::LabelText<'a> {\n-        let mut buffer = String::new();\n-        buffer.push_str(\"<table border=\\\"0\\\" cellborder=\\\"1\\\" cellspacing=\\\"0\\\">\");\n-\n-        buffer.push_str(\"<tr><td><b>\");\n-        buffer.push_str(&escape(format!(\"{:?}\", n)));\n-        buffer.push_str(\"</b></td></tr>\");\n-\n-        let data = self.basic_block_data(n);\n-        for statement in &data.statements {\n-            buffer.push_str(\"<tr><td align=\\\"left\\\">\");\n-            buffer.push_str(&escape(format!(\"{:?}\", statement)));\n-            buffer.push_str(\"</td></tr>\");\n-        }\n-\n-        buffer.push_str(\"<tr><td align=\\\"left\\\" bgcolor=\\\"cornsilk\\\">\");\n-        buffer.push_str(&escape(format!(\"{:?}\", &data.terminator)));\n-        buffer.push_str(\"</td></tr>\");\n-\n-        buffer.push_str(\"</table>\");\n-\n-        dot::LabelText::html(buffer)\n-    }\n-\n-    fn edge_label(&'a self, edge: &EdgeIndex) -> dot::LabelText<'a> {\n-        dot::LabelText::label(format!(\"{}\", edge.index))\n-    }\n-}\n-\n-impl<'a,'tcx> dot::GraphWalk<'a, BasicBlock, EdgeIndex> for Mir<'tcx> {\n-    fn nodes(&'a self) -> dot::Nodes<'a, BasicBlock> {\n-        self.all_basic_blocks().into_cow()\n-    }\n-\n-    fn edges(&'a self) -> dot::Edges<'a, EdgeIndex> {\n-        self.all_basic_blocks()\n-            .into_iter()\n-            .flat_map(|source| {\n-                self.basic_block_data(source)\n-                    .terminator\n-                    .successors()\n-                    .iter()\n-                    .enumerate()\n-                    .map(move |(index, &target)| {\n-                        EdgeIndex {\n-                            source: source,\n-                            target: target,\n-                            index: index,\n-                        }\n-                    })\n-            })\n-            .collect::<Vec<_>>()\n-            .into_cow()\n-    }\n-\n-    fn source(&'a self, edge: &EdgeIndex) -> BasicBlock {\n-        edge.source\n-    }\n-\n-    fn target(&'a self, edge: &EdgeIndex) -> BasicBlock {\n-        edge.target\n-    }\n-}\n-\n-fn escape(text: String) -> String {\n-    let text = dot::escape_html(&text);\n-    let text = all_to_subscript(\"Temp\", text);\n-    let text = all_to_subscript(\"Var\", text);\n-    let text = all_to_subscript(\"Arg\", text);\n-    let text = all_to_subscript(\"BB\", text);\n-    text\n-}\n-\n-/// A call like `all_to_subscript(\"Temp\", \"Temp(123)\")` will convert\n-/// to `Temp\u2081\u2082\u2083`.\n-fn all_to_subscript(header: &str, mut text: String) -> String {\n-    let mut offset = 0;\n-    while offset < text.len() {\n-        if let Some(text1) = to_subscript1(header, &text, &mut offset) {\n-            text = text1;\n-        }\n-    }\n-    return text;\n-\n-    /// Looks for `Foo(\\d*)` where `header==\"Foo\"` and replaces the `\\d` with subscripts.\n-    /// Updates `offset` to point to the next location where we might want to search.\n-    /// Returns an updated string if changes were made, else None.\n-    fn to_subscript1(header: &str, text: &str, offset: &mut usize) -> Option<String> {\n-        let a = match text[*offset..].find(header) {\n-            None => {\n-                *offset = text.len();\n-                return None;\n-            }\n-            Some(a) => a + *offset,\n-        };\n-\n-        // Example:\n-        //\n-        // header: \"Foo\"\n-        // text:   ....Foo(123)...\n-        //             ^  ^\n-        //             a  b\n-\n-        let b = a + header.len();\n-        *offset = b;\n-\n-        let mut chars = text[b..].chars();\n-        if Some('(') != chars.next() {\n-            return None;\n-        }\n-\n-        let mut result = String::new();\n-        result.push_str(&text[..b]);\n-\n-        while let Some(c) = chars.next() {\n-            if c == ')' {\n-                break;\n-            }\n-            if !c.is_digit(10) {\n-                return None;\n-            }\n-\n-            // 0x208 is _0 in unicode, 0x209 is _1, etc\n-            const SUBSCRIPTS: &'static str = \"\u2080\u2081\u2082\u2083\u2084\u2085\u2086\u2087\u2088\u2089\";\n-            let n = (c as usize) - ('0' as usize);\n-            result.extend(SUBSCRIPTS.chars().skip(n).take(1));\n-        }\n-\n-        result.extend(chars);\n-        return Some(result);\n-    }\n-}"}, {"sha": "6a1134385d96725764047a09ef1896d453e86584", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/badc23b6ad47c6b6d401a3ea1dc5163bdcd86cd7/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/badc23b6ad47c6b6d401a3ea1dc5163bdcd86cd7/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=badc23b6ad47c6b6d401a3ea1dc5163bdcd86cd7", "patch": "@@ -19,7 +19,6 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![crate_type = \"dylib\"]\n \n #![feature(rustc_private)]\n-#![feature(into_cow)]\n \n #[macro_use] extern crate log;\n extern crate graphviz as dot;"}, {"sha": "5c9399ebdadf7ff5128bad01f3d414ca5cfa9417", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/badc23b6ad47c6b6d401a3ea1dc5163bdcd86cd7/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/badc23b6ad47c6b6d401a3ea1dc5163bdcd86cd7/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=badc23b6ad47c6b6d401a3ea1dc5163bdcd86cd7", "patch": "@@ -21,7 +21,7 @@ extern crate rustc;\n extern crate rustc_front;\n \n use build;\n-use dot;\n+use graphviz;\n use transform::*;\n use rustc::mir::repr::Mir;\n use hair::cx::Cx;\n@@ -157,7 +157,9 @@ impl<'a, 'm, 'tcx> Visitor<'tcx> for InnerDump<'a,'m,'tcx> {\n                             Some(s) => {\n                                 match\n                                     File::create(format!(\"{}{}\", prefix, s))\n-                                    .and_then(|ref mut output| dot::render(&mir, output))\n+                                    .and_then(|ref mut output| {\n+                                        graphviz::write_mir_graphviz(&mir, output)\n+                                    })\n                                 {\n                                     Ok(()) => { }\n                                     Err(e) => {"}]}