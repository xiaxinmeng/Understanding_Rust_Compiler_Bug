{"sha": "630f31ce5ed38d13baf6cd16f26f1251183521c0", "node_id": "C_kwDOAAsO6NoAKDYzMGYzMWNlNWVkMzhkMTNiYWY2Y2QxNmYyNmYxMjUxMTgzNTIxYzA", "commit": {"author": {"name": "disco07", "email": "koneenok@outlook.fr", "date": "2023-05-07T00:45:11Z"}, "committer": {"name": "disco07", "email": "koneenok@outlook.fr", "date": "2023-05-07T00:45:11Z"}, "message": "fix conflict with matches macro", "tree": {"sha": "91caac2f066c12940d6036c024762a31c65d0e8d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/91caac2f066c12940d6036c024762a31c65d0e8d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/630f31ce5ed38d13baf6cd16f26f1251183521c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/630f31ce5ed38d13baf6cd16f26f1251183521c0", "html_url": "https://github.com/rust-lang/rust/commit/630f31ce5ed38d13baf6cd16f26f1251183521c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/630f31ce5ed38d13baf6cd16f26f1251183521c0/comments", "author": {"login": "disco07", "id": 60718751, "node_id": "MDQ6VXNlcjYwNzE4NzUx", "avatar_url": "https://avatars.githubusercontent.com/u/60718751?v=4", "gravatar_id": "", "url": "https://api.github.com/users/disco07", "html_url": "https://github.com/disco07", "followers_url": "https://api.github.com/users/disco07/followers", "following_url": "https://api.github.com/users/disco07/following{/other_user}", "gists_url": "https://api.github.com/users/disco07/gists{/gist_id}", "starred_url": "https://api.github.com/users/disco07/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/disco07/subscriptions", "organizations_url": "https://api.github.com/users/disco07/orgs", "repos_url": "https://api.github.com/users/disco07/repos", "events_url": "https://api.github.com/users/disco07/events{/privacy}", "received_events_url": "https://api.github.com/users/disco07/received_events", "type": "User", "site_admin": false}, "committer": {"login": "disco07", "id": 60718751, "node_id": "MDQ6VXNlcjYwNzE4NzUx", "avatar_url": "https://avatars.githubusercontent.com/u/60718751?v=4", "gravatar_id": "", "url": "https://api.github.com/users/disco07", "html_url": "https://github.com/disco07", "followers_url": "https://api.github.com/users/disco07/followers", "following_url": "https://api.github.com/users/disco07/following{/other_user}", "gists_url": "https://api.github.com/users/disco07/gists{/gist_id}", "starred_url": "https://api.github.com/users/disco07/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/disco07/subscriptions", "organizations_url": "https://api.github.com/users/disco07/orgs", "repos_url": "https://api.github.com/users/disco07/repos", "events_url": "https://api.github.com/users/disco07/events{/privacy}", "received_events_url": "https://api.github.com/users/disco07/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9e535f62888b691e50ae8d3cc32af45f2c82528d", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e535f62888b691e50ae8d3cc32af45f2c82528d", "html_url": "https://github.com/rust-lang/rust/commit/9e535f62888b691e50ae8d3cc32af45f2c82528d"}], "stats": {"total": 269, "additions": 133, "deletions": 136}, "files": [{"sha": "fe3b440ff58e5dc3bc677f902502ad2896c8e081", "filename": "clippy_lints/src/matches/match_like_matches.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/630f31ce5ed38d13baf6cd16f26f1251183521c0/clippy_lints%2Fsrc%2Fmatches%2Fmatch_like_matches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/630f31ce5ed38d13baf6cd16f26f1251183521c0/clippy_lints%2Fsrc%2Fmatches%2Fmatch_like_matches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_like_matches.rs?ref=630f31ce5ed38d13baf6cd16f26f1251183521c0", "patch": "@@ -183,15 +183,12 @@ fn find_bool_lit(ex: &ExprKind<'_>) -> Option<bool> {\n \n fn is_some(path_kind: PatKind<'_>) -> bool {\n     match path_kind {\n-        PatKind::TupleStruct(ref path_left, patterns, _) if is_wild(&patterns[0]) => match path_left {\n-            QPath::Resolved(_, path) => {\n-                let name = path.segments[0].ident;\n-                if name.as_str() == \"Some\" {\n-                    return true;\n-                }\n-                return false;\n-            },\n-            _ => false,\n+        PatKind::TupleStruct(QPath::Resolved(_, path), patterns, _) if is_wild(&patterns[0]) => {\n+            let name = path.segments[0].ident;\n+            if name.as_str() == \"Some\" {\n+                return true;\n+            }\n+            false\n         },\n         _ => false,\n     }"}, {"sha": "2ac6d9938eb9874f3f780382feb09b9e8cfc1d0d", "filename": "clippy_lints/src/matches/redundant_pattern_match.rs", "status": "modified", "additions": 127, "deletions": 127, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/630f31ce5ed38d13baf6cd16f26f1251183521c0/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/630f31ce5ed38d13baf6cd16f26f1251183521c0/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs?ref=630f31ce5ed38d13baf6cd16f26f1251183521c0", "patch": "@@ -188,132 +188,7 @@ fn find_sugg_for_if_let<'tcx>(\n pub(super) fn check_match<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, op: &Expr<'_>, arms: &[Arm<'_>]) {\n     if arms.len() == 2 {\n         let node_pair = (&arms[0].pat.kind, &arms[1].pat.kind);\n-        let found_good_method = match node_pair {\n-            (\n-                PatKind::TupleStruct(ref path_left, patterns_left, _),\n-                PatKind::TupleStruct(ref path_right, patterns_right, _),\n-            ) if patterns_left.len() == 1 && patterns_right.len() == 1 => {\n-                if let (PatKind::Wild, PatKind::Wild) = (&patterns_left[0].kind, &patterns_right[0].kind) {\n-                    find_good_method_for_match(\n-                        cx,\n-                        arms,\n-                        path_left,\n-                        path_right,\n-                        Item::Lang(ResultOk),\n-                        Item::Lang(ResultErr),\n-                        \"is_ok()\",\n-                        \"is_err()\",\n-                    )\n-                    .or_else(|| {\n-                        find_good_method_for_match(\n-                            cx,\n-                            arms,\n-                            path_left,\n-                            path_right,\n-                            Item::Diag(sym::IpAddr, sym!(V4)),\n-                            Item::Diag(sym::IpAddr, sym!(V6)),\n-                            \"is_ipv4()\",\n-                            \"is_ipv6()\",\n-                        )\n-                    })\n-                } else {\n-                    None\n-                }\n-            },\n-            (PatKind::TupleStruct(ref path_left, patterns, _), PatKind::Path(ref path_right))\n-            | (PatKind::Path(ref path_left), PatKind::TupleStruct(ref path_right, patterns, _))\n-                if patterns.len() == 1 =>\n-            {\n-                if let PatKind::Wild = patterns[0].kind {\n-                    find_good_method_for_match(\n-                        cx,\n-                        arms,\n-                        path_left,\n-                        path_right,\n-                        Item::Lang(OptionSome),\n-                        Item::Lang(OptionNone),\n-                        \"is_some()\",\n-                        \"is_none()\",\n-                    )\n-                    .or_else(|| {\n-                        find_good_method_for_match(\n-                            cx,\n-                            arms,\n-                            path_left,\n-                            path_right,\n-                            Item::Lang(PollReady),\n-                            Item::Lang(PollPending),\n-                            \"is_ready()\",\n-                            \"is_pending()\",\n-                        )\n-                    })\n-                } else {\n-                    None\n-                }\n-            },\n-            (PatKind::TupleStruct(ref path_left, patterns, _), PatKind::Wild) if patterns.len() == 1 => {\n-                if let PatKind::Wild = patterns[0].kind {\n-                    let ident = match path_left {\n-                        QPath::Resolved(_, path) => {\n-                            let name = path.segments[0].ident;\n-                            Some(name)\n-                        },\n-                        _ => None,\n-                    };\n-                    if let Some(name) = ident {\n-                        match name.as_str() {\n-                            \"Ok\" => find_good_method_for_matches_macro(\n-                                cx,\n-                                arms,\n-                                path_left,\n-                                Item::Lang(ResultOk),\n-                                \"is_ok()\",\n-                                \"is_err()\",\n-                            ),\n-                            \"Some\" => find_good_method_for_matches_macro(\n-                                cx,\n-                                arms,\n-                                path_left,\n-                                Item::Lang(OptionSome),\n-                                \"is_some()\",\n-                                \"is_none()\",\n-                            ),\n-                            _ => None,\n-                        }\n-                    } else {\n-                        None\n-                    }\n-                } else {\n-                    None\n-                }\n-            },\n-            (PatKind::Path(ref path_left), PatKind::Wild) => {\n-                let ident = match path_left {\n-                    QPath::Resolved(_, path) => {\n-                        let name = path.segments[0].ident;\n-                        Some(name)\n-                    },\n-                    _ => None,\n-                };\n-\n-                if let Some(name) = ident {\n-                    match name.as_str() {\n-                        \"None\" => find_good_method_for_matches_macro(\n-                            cx,\n-                            arms,\n-                            path_left,\n-                            Item::Lang(OptionNone),\n-                            \"is_none()\",\n-                            \"is_some()\",\n-                        ),\n-                        _ => None,\n-                    }\n-                } else {\n-                    None\n-                }\n-            },\n-            _ => None,\n-        };\n+        let found_good_method = found_good_method(cx, arms, node_pair);\n \n         if let Some(good_method) = found_good_method {\n             let span = expr.span.to(op.span);\n@@ -339,6 +214,132 @@ pub(super) fn check_match<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, op\n     }\n }\n \n+fn found_good_method<'a>(\n+    cx: &LateContext<'_>,\n+    arms: &[Arm<'_>],\n+    node: (&PatKind<'_>, &PatKind<'_>),\n+) -> Option<&'a str> {\n+    match node {\n+        (\n+            PatKind::TupleStruct(ref path_left, patterns_left, _),\n+            PatKind::TupleStruct(ref path_right, patterns_right, _),\n+        ) if patterns_left.len() == 1 && patterns_right.len() == 1 => {\n+            if let (PatKind::Wild, PatKind::Wild) = (&patterns_left[0].kind, &patterns_right[0].kind) {\n+                find_good_method_for_match(\n+                    cx,\n+                    arms,\n+                    path_left,\n+                    path_right,\n+                    Item::Lang(ResultOk),\n+                    Item::Lang(ResultErr),\n+                    \"is_ok()\",\n+                    \"is_err()\",\n+                )\n+                .or_else(|| {\n+                    find_good_method_for_match(\n+                        cx,\n+                        arms,\n+                        path_left,\n+                        path_right,\n+                        Item::Diag(sym::IpAddr, sym!(V4)),\n+                        Item::Diag(sym::IpAddr, sym!(V6)),\n+                        \"is_ipv4()\",\n+                        \"is_ipv6()\",\n+                    )\n+                })\n+            } else {\n+                None\n+            }\n+        },\n+        (PatKind::TupleStruct(ref path_left, patterns, _), PatKind::Path(ref path_right))\n+        | (PatKind::Path(ref path_left), PatKind::TupleStruct(ref path_right, patterns, _))\n+            if patterns.len() == 1 =>\n+        {\n+            if let PatKind::Wild = patterns[0].kind {\n+                find_good_method_for_match(\n+                    cx,\n+                    arms,\n+                    path_left,\n+                    path_right,\n+                    Item::Lang(OptionSome),\n+                    Item::Lang(OptionNone),\n+                    \"is_some()\",\n+                    \"is_none()\",\n+                )\n+                .or_else(|| {\n+                    find_good_method_for_match(\n+                        cx,\n+                        arms,\n+                        path_left,\n+                        path_right,\n+                        Item::Lang(PollReady),\n+                        Item::Lang(PollPending),\n+                        \"is_ready()\",\n+                        \"is_pending()\",\n+                    )\n+                })\n+            } else {\n+                None\n+            }\n+        },\n+        (PatKind::TupleStruct(ref path_left, patterns, _), PatKind::Wild) if patterns.len() == 1 => {\n+            if let PatKind::Wild = patterns[0].kind {\n+                get_good_method(cx, arms, path_left)\n+            } else {\n+                None\n+            }\n+        },\n+        (PatKind::Path(ref path_left), PatKind::Wild) => {\n+            if let Some(name) = get_ident(path_left) {\n+                match name.as_str() {\n+                    \"None\" => find_good_method_for_matches_macro(\n+                        cx,\n+                        arms,\n+                        path_left,\n+                        Item::Lang(OptionNone),\n+                        \"is_none()\",\n+                        \"is_some()\",\n+                    ),\n+                    _ => None,\n+                }\n+            } else {\n+                None\n+            }\n+        },\n+        _ => None,\n+    }\n+}\n+\n+fn get_ident(path: &QPath<'_>) -> Option<rustc_span::symbol::Ident> {\n+    match path {\n+        QPath::Resolved(_, path) => {\n+            let name = path.segments[0].ident;\n+            Some(name)\n+        },\n+        _ => None,\n+    }\n+}\n+\n+fn get_good_method<'a>(cx: &LateContext<'_>, arms: &[Arm<'_>], path_left: &QPath<'_>) -> Option<&'a str> {\n+    if let Some(name) = get_ident(path_left) {\n+        return match name.as_str() {\n+            \"Ok\" => {\n+                find_good_method_for_matches_macro(cx, arms, path_left, Item::Lang(ResultOk), \"is_ok()\", \"is_err()\")\n+            },\n+            \"Some\" => find_good_method_for_matches_macro(\n+                cx,\n+                arms,\n+                path_left,\n+                Item::Lang(OptionSome),\n+                \"is_some()\",\n+                \"is_none()\",\n+            ),\n+            _ => None,\n+        };\n+    }\n+    None\n+}\n+\n #[derive(Clone, Copy)]\n enum Item {\n     Lang(LangItem),\n@@ -406,7 +407,6 @@ fn find_good_method_for_match<'a>(\n     }\n }\n \n-#[expect(clippy::too_many_arguments)]\n fn find_good_method_for_matches_macro<'a>(\n     cx: &LateContext<'_>,\n     arms: &[Arm<'_>],"}]}