{"sha": "2c76710ecedb459d36ae110882931143a6fd5dd1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjNzY3MTBlY2VkYjQ1OWQzNmFlMTEwODgyOTMxMTQzYTZmZDVkZDE=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-01-02T01:38:02Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-01-11T20:09:45Z"}, "message": "rustc_typeck: make Expectation more composable by replacing map and map_to_option with to_option.", "tree": {"sha": "c8013436e50ed8cf25c65907fd0e541a8904df6b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c8013436e50ed8cf25c65907fd0e541a8904df6b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c76710ecedb459d36ae110882931143a6fd5dd1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c76710ecedb459d36ae110882931143a6fd5dd1", "html_url": "https://github.com/rust-lang/rust/commit/2c76710ecedb459d36ae110882931143a6fd5dd1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c76710ecedb459d36ae110882931143a6fd5dd1/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e4cef4e78253beb4c08ed35416fad076d978344", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e4cef4e78253beb4c08ed35416fad076d978344", "html_url": "https://github.com/rust-lang/rust/commit/2e4cef4e78253beb4c08ed35416fad076d978344"}], "stats": {"total": 41, "additions": 13, "deletions": 28}, "files": [{"sha": "bfe43086aab10205a38022dc89129dfce5712fb1", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c76710ecedb459d36ae110882931143a6fd5dd1/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c76710ecedb459d36ae110882931143a6fd5dd1/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=2c76710ecedb459d36ae110882931143a6fd5dd1", "patch": "@@ -33,7 +33,7 @@ pub fn check_expr_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n            expr.repr(fcx.tcx()),\n            expected.repr(fcx.tcx()));\n \n-    let expected_sig_and_kind = expected.map_to_option(fcx, |ty| {\n+    let expected_sig_and_kind = expected.to_option(fcx).and_then(|ty| {\n         deduce_unboxed_closure_expectations_from_expected_type(fcx, ty)\n     });\n "}, {"sha": "5c25b55287af92aa6c0ca632e6242a8b0e0781c6", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 12, "deletions": 27, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/2c76710ecedb459d36ae110882931143a6fd5dd1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c76710ecedb459d36ae110882931143a6fd5dd1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=2c76710ecedb459d36ae110882931143a6fd5dd1", "patch": "@@ -2844,7 +2844,7 @@ fn check_lit<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         ast::LitInt(_, ast::SignedIntLit(t, _)) => ty::mk_mach_int(tcx, t),\n         ast::LitInt(_, ast::UnsignedIntLit(t)) => ty::mk_mach_uint(tcx, t),\n         ast::LitInt(_, ast::UnsuffixedIntLit(_)) => {\n-            let opt_ty = expected.map_to_option(fcx, |ty| {\n+            let opt_ty = expected.to_option(fcx).and_then(|ty| {\n                 match ty.sty {\n                     ty::ty_int(_) | ty::ty_uint(_) => Some(ty),\n                     ty::ty_char => Some(tcx.types.u8),\n@@ -2858,7 +2858,7 @@ fn check_lit<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n         ast::LitFloat(_, t) => ty::mk_mach_float(tcx, t),\n         ast::LitFloatUnsuffixed(_) => {\n-            let opt_ty = expected.map_to_option(fcx, |ty| {\n+            let opt_ty = expected.to_option(fcx).and_then(|ty| {\n                 match ty.sty {\n                     ty::ty_float(_) => Some(ty),\n                     _ => None\n@@ -3761,7 +3761,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n       }\n       ast::ExprUnary(unop, ref oprnd) => {\n-        let expected_inner = expected.map(fcx, |ty| {\n+        let expected_inner = expected.to_option(fcx).map_or(NoExpectation, |ty| {\n             match unop {\n                 ast::UnUniq => match ty.sty {\n                     ty::ty_uniq(ty) => {\n@@ -3851,8 +3851,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         fcx.write_ty(id, oprnd_t);\n       }\n       ast::ExprAddrOf(mutbl, ref oprnd) => {\n-        let expected = expected.only_has_type();\n-        let hint = expected.map(fcx, |ty| {\n+        let hint = expected.only_has_type(fcx).map_or(NoExpectation, |ty| {\n             match ty.sty {\n                 ty::ty_rptr(_, ref mt) | ty::ty_ptr(ref mt) => {\n                     if ty::expr_is_lval(fcx.tcx(), &**oprnd) {\n@@ -4065,7 +4064,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         check_cast(fcx, expr, &**e, &**t);\n       }\n       ast::ExprVec(ref args) => {\n-        let uty = expected.map_to_option(fcx, |uty| {\n+        let uty = expected.to_option(fcx).and_then(|uty| {\n             match uty.sty {\n                 ty::ty_vec(ty, _) => Some(ty),\n                 _ => None\n@@ -4134,8 +4133,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n       }\n       ast::ExprTup(ref elts) => {\n-        let expected = expected.only_has_type();\n-        let flds = expected.map_to_option(fcx, |ty| {\n+        let flds = expected.only_has_type(fcx).and_then(|ty| {\n             match ty.sty {\n                 ty::ty_tup(ref flds) => Some(&flds[]),\n                 _ => None\n@@ -4428,13 +4426,6 @@ impl<'tcx> Expectation<'tcx> {\n         }\n     }\n \n-    fn only_has_type(self) -> Expectation<'tcx> {\n-        match self {\n-            ExpectHasType(t) => ExpectHasType(t),\n-            _ => NoExpectation\n-        }\n-    }\n-\n     // Resolves `expected` by a single level if it is a variable. If\n     // there is no expected type or resolution is not possible (e.g.,\n     // no constraints yet present), just returns `None`.\n@@ -4458,25 +4449,19 @@ impl<'tcx> Expectation<'tcx> {\n         }\n     }\n \n-    fn map<'a, F>(self, fcx: &FnCtxt<'a, 'tcx>, unpack: F) -> Expectation<'tcx> where\n-        F: FnOnce(Ty<'tcx>) -> Expectation<'tcx>\n-    {\n+    fn to_option<'a>(self, fcx: &FnCtxt<'a, 'tcx>) -> Option<Ty<'tcx>> {\n         match self.resolve(fcx) {\n-            NoExpectation => NoExpectation,\n+            NoExpectation => None,\n             ExpectCastableToType(ty) |\n             ExpectHasType(ty) |\n-            ExpectRvalueLikeUnsized(ty) => unpack(ty),\n+            ExpectRvalueLikeUnsized(ty) => Some(ty),\n         }\n     }\n \n-    fn map_to_option<'a, O, F>(self, fcx: &FnCtxt<'a, 'tcx>, unpack: F) -> Option<O> where\n-        F: FnOnce(Ty<'tcx>) -> Option<O>,\n-    {\n+    fn only_has_type<'a>(self, fcx: &FnCtxt<'a, 'tcx>) -> Option<Ty<'tcx>> {\n         match self.resolve(fcx) {\n-            NoExpectation => None,\n-            ExpectCastableToType(ty) |\n-            ExpectHasType(ty) |\n-            ExpectRvalueLikeUnsized(ty) => unpack(ty),\n+            ExpectHasType(ty) => Some(ty),\n+            _ => None\n         }\n     }\n }"}]}