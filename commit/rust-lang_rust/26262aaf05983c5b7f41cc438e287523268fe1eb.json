{"sha": "26262aaf05983c5b7f41cc438e287523268fe1eb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2MjYyYWFmMDU5ODNjNWI3ZjQxY2M0MzhlMjg3NTIzMjY4ZmUxZWI=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-08-10T19:23:17Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-08-10T19:23:17Z"}, "message": "extend selection via LSP", "tree": {"sha": "4473bd2559c838e0df5a10c9ea1307b49d51b8bc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4473bd2559c838e0df5a10c9ea1307b49d51b8bc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26262aaf05983c5b7f41cc438e287523268fe1eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26262aaf05983c5b7f41cc438e287523268fe1eb", "html_url": "https://github.com/rust-lang/rust/commit/26262aaf05983c5b7f41cc438e287523268fe1eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26262aaf05983c5b7f41cc438e287523268fe1eb/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3fff5e94ebf772f8485aaa2bda2ea36be766fdb3", "url": "https://api.github.com/repos/rust-lang/rust/commits/3fff5e94ebf772f8485aaa2bda2ea36be766fdb3", "html_url": "https://github.com/rust-lang/rust/commit/3fff5e94ebf772f8485aaa2bda2ea36be766fdb3"}], "stats": {"total": 321, "additions": 198, "deletions": 123}, "files": [{"sha": "1df932db15f6bc7d462f22fb34ee745796d5abb1", "filename": "codeless/package.json", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/26262aaf05983c5b7f41cc438e287523268fe1eb/codeless%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/26262aaf05983c5b7f41cc438e287523268fe1eb/codeless%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/codeless%2Fpackage.json?ref=26262aaf05983c5b7f41cc438e287523268fe1eb", "patch": "@@ -36,6 +36,13 @@\n         \"command\": \"libsyntax-rust.extendSelection\",\n         \"title\": \"Rust Extend Selection\"\n       }\n+    ],\n+    \"keybindings\": [\n+      {\n+        \"command\": \"libsyntax-rust.extendSelection\",\n+        \"key\": \"ctrl+w\",\n+        \"when\": \"editorTextFocus && editorLangId == rust\"\n+      }\n     ]\n   }\n }"}, {"sha": "2da0996e3bd8b13974828542d618ddecd18bce99", "filename": "codeless/server/src/dispatch.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/26262aaf05983c5b7f41cc438e287523268fe1eb/codeless%2Fserver%2Fsrc%2Fdispatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26262aaf05983c5b7f41cc438e287523268fe1eb/codeless%2Fserver%2Fsrc%2Fdispatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/codeless%2Fserver%2Fsrc%2Fdispatch.rs?ref=26262aaf05983c5b7f41cc438e287523268fe1eb", "patch": "@@ -52,7 +52,7 @@ impl<R: Request> Responder<R>\n }\n \n \n-pub fn parse_request_as<R>(raw: RawRequest) -> Result<::std::result::Result<(R::Params, Responder<R>), RawRequest>>\n+fn parse_request_as<R>(raw: RawRequest) -> Result<::std::result::Result<(R::Params, Responder<R>), RawRequest>>\n     where\n         R: Request,\n         R::Params: DeserializeOwned,\n@@ -71,6 +71,25 @@ pub fn parse_request_as<R>(raw: RawRequest) -> Result<::std::result::Result<(R::\n     Ok(Ok((params, responder)))\n }\n \n+pub fn handle_request<R, F>(req: &mut Option<RawRequest>, f: F) -> Result<()>\n+    where\n+        R: Request,\n+        R::Params: DeserializeOwned,\n+        R::Result: Serialize,\n+        F: FnOnce(R::Params, Responder<R>) -> Result<()>\n+{\n+    match req.take() {\n+        None => Ok(()),\n+        Some(r) => match parse_request_as::<R>(r)? {\n+            Ok((params, responder)) => f(params, responder),\n+            Err(r) => {\n+                *req = Some(r);\n+                Ok(())\n+            },\n+        }\n+    }\n+}\n+\n pub fn expect_request<R>(io: &mut Io, raw: RawRequest) -> Result<Option<(R::Params, Responder<R>)>>\n     where\n         R: Request,\n@@ -87,7 +106,7 @@ pub fn expect_request<R>(io: &mut Io, raw: RawRequest) -> Result<Option<(R::Para\n     Ok(ret)\n }\n \n-pub fn parse_notification_as<N>(raw: RawNotification) -> Result<::std::result::Result<N::Params, RawNotification>>\n+fn parse_notification_as<N>(raw: RawNotification) -> Result<::std::result::Result<N::Params, RawNotification>>\n     where\n         N: Notification,\n         N::Params: DeserializeOwned,"}, {"sha": "5ee87a4ddd49ece55a797decd1f17b9ced32a620", "filename": "codeless/server/src/handlers.rs", "status": "modified", "additions": 53, "deletions": 5, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/26262aaf05983c5b7f41cc438e287523268fe1eb/codeless%2Fserver%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26262aaf05983c5b7f41cc438e287523268fe1eb/codeless%2Fserver%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/codeless%2Fserver%2Fsrc%2Fhandlers.rs?ref=26262aaf05983c5b7f41cc438e287523268fe1eb", "patch": "@@ -1,13 +1,61 @@\n+use languageserver_types::{Range, Position};\n use libanalysis::World;\n-use libeditor;\n-use {req, Result};\n+use libeditor::{self, LineIndex, LineCol, TextRange, TextUnit};\n+use {req, Result, FilePath};\n \n pub fn handle_syntax_tree(\n     world: World,\n-    params: req::SyntaxTreeParams\n+    params: req::SyntaxTreeParams,\n ) -> Result<String> {\n-    let path = params.text_document.uri.to_file_path()\n-        .map_err(|()| format_err!(\"invalid path\"))?;\n+    let path = params.text_document.file_path()?;\n     let file = world.file_syntax(&path)?;\n     Ok(libeditor::syntax_tree(&file))\n }\n+\n+pub fn handle_extend_selection(\n+    world: World,\n+    params: req::ExtendSelectionParams,\n+) -> Result<req::ExtendSelectionResult> {\n+    let path = params.text_document.file_path()?;\n+    let file = world.file_syntax(&path)?;\n+    let line_index = world.file_line_index(&path)?;\n+    let selections = params.selections.into_iter()\n+        .map(|r| {\n+            let r = to_text_range(&line_index, r);\n+            let r = libeditor::extend_selection(&file, r).unwrap_or(r);\n+            to_vs_range(&line_index, r)\n+        })\n+        .collect();\n+    Ok(req::ExtendSelectionResult { selections })\n+}\n+\n+\n+fn to_text_range(line_index: &LineIndex, range: Range) -> TextRange {\n+    TextRange::from_to(\n+        to_text_unit(line_index, range.start),\n+        to_text_unit(line_index, range.end),\n+    )\n+}\n+\n+fn to_text_unit(line_index: &LineIndex, position: Position) -> TextUnit {\n+    // TODO: UTF-16\n+    let line_col = LineCol {\n+        line: position.line as u32,\n+        col: (position.character as u32).into(),\n+    };\n+    line_index.offset(line_col)\n+}\n+\n+\n+fn to_vs_range(line_index: &LineIndex, range: TextRange) -> Range {\n+    Range::new(\n+        to_vs_position(line_index, range.start()),\n+        to_vs_position(line_index, range.end()),\n+    )\n+}\n+\n+fn to_vs_position(line_index: &LineIndex, offset: TextUnit) -> Position {\n+    let line_col = line_index.line_col(offset);\n+    // TODO: UTF-16\n+    Position::new(line_col.line as u64, u32::from(line_col.col) as u64)\n+}"}, {"sha": "116abce1ce6472e1ef1c22539af7e9b13349bc87", "filename": "codeless/server/src/main.rs", "status": "modified", "additions": 29, "deletions": 21, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/26262aaf05983c5b7f41cc438e287523268fe1eb/codeless%2Fserver%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26262aaf05983c5b7f41cc438e287523268fe1eb/codeless%2Fserver%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/codeless%2Fserver%2Fsrc%2Fmain.rs?ref=26262aaf05983c5b7f41cc438e287523268fe1eb", "patch": "@@ -31,7 +31,7 @@ use languageserver_types::{TextDocumentItem, VersionedTextDocumentIdentifier, Te\n \n use ::{\n     io::{Io, RawMsg},\n-    handlers::handle_syntax_tree,\n+    handlers::{handle_syntax_tree, handle_extend_selection},\n };\n \n pub type Result<T> = ::std::result::Result<T, ::failure::Error>;\n@@ -153,42 +153,50 @@ fn main_loop(\n \n         match msg {\n             RawMsg::Request(req) => {\n-                let req = match dispatch::parse_request_as::<req::SyntaxTree>(req)? {\n-                    Ok((params, resp)) => {\n-                        let world = world.snapshot();\n-                        let sender = sender.clone();\n-                        pool.execute(move || {\n-                            let res: Result<String> = handle_syntax_tree(world, params);\n-                            sender.send(Box::new(|io: &mut Io| resp.response(io, res)))\n-                        });\n-                        continue;\n-                    }\n-                    Err(req) => req,\n-                };\n-\n-                if let Some(((), resp)) = dispatch::expect_request::<req::Shutdown>(io, req)? {\n-                    info!(\"clean shutdown started\");\n+                let mut req = Some(req);\n+                dispatch::handle_request::<req::SyntaxTree, _>(&mut req, |params, resp| {\n+                    let world = world.snapshot();\n+                    let sender = sender.clone();\n+                    pool.execute(move || {\n+                        let res = handle_syntax_tree(world, params);\n+                        sender.send(Box::new(|io: &mut Io| resp.response(io, res)))\n+                    });\n+                    Ok(())\n+                })?;\n+                dispatch::handle_request::<req::ExtendSelection, _>(&mut req, |params, resp| {\n+                    let world = world.snapshot();\n+                    let sender = sender.clone();\n+                    pool.execute(move || {\n+                        let res = handle_extend_selection(world, params);\n+                        sender.send(Box::new(|io: &mut Io| resp.response(io, res)))\n+                    });\n+                    Ok(())\n+                })?;\n+                dispatch::handle_request::<req::Shutdown, _>(&mut req, |(), resp| {\n                     resp.result(io, ())?;\n-                    return Ok(());\n+                    Ok(())\n+                })?;\n+                if let Some(req) = req {\n+                    error!(\"unknown method: {:?}\", req);\n+                    dispatch::unknown_method(io, req)?;\n                 }\n             }\n             RawMsg::Notification(not) => {\n-                use dispatch::handle_notification as h;\n                 let mut not = Some(not);\n-                h::<req::DidOpenTextDocument, _>(&mut not, |params| {\n+                dispatch::handle_notification::<req::DidOpenTextDocument, _>(&mut not, |params| {\n                     let path = params.text_document.file_path()?;\n                     world.change_overlay(path, Some(params.text_document.text));\n                     Ok(())\n                 })?;\n-                h::<req::DidChangeTextDocument, _>(&mut not, |mut params| {\n+                dispatch::handle_notification::<req::DidChangeTextDocument, _>(&mut not, |mut params| {\n                     let path = params.text_document.file_path()?;\n                     let text = params.content_changes.pop()\n                         .ok_or_else(|| format_err!(\"empty changes\"))?\n                         .text;\n                     world.change_overlay(path, Some(text));\n                     Ok(())\n                 })?;\n-                h::<req::DidCloseTextDocument, _>(&mut not, |params| {\n+                dispatch::handle_notification::<req::DidCloseTextDocument, _>(&mut not, |params| {\n                     let path = params.text_document.file_path()?;\n                     world.change_overlay(path, None);\n                     Ok(())"}, {"sha": "4e588159bc34e8370d71a49658b039bc83db96fa", "filename": "codeless/server/src/req.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/26262aaf05983c5b7f41cc438e287523268fe1eb/codeless%2Fserver%2Fsrc%2Freq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26262aaf05983c5b7f41cc438e287523268fe1eb/codeless%2Fserver%2Fsrc%2Freq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/codeless%2Fserver%2Fsrc%2Freq.rs?ref=26262aaf05983c5b7f41cc438e287523268fe1eb", "patch": "@@ -21,14 +21,21 @@ pub struct SyntaxTreeParams {\n \n pub enum ExtendSelection {}\n \n+impl Request for ExtendSelection {\n+    type Params = ExtendSelectionParams;\n+    type Result = ExtendSelectionResult;\n+    const METHOD: &'static str = \"m/extendSelection\";\n+}\n+\n #[derive(Deserialize, Debug)]\n #[serde(rename_all = \"camelCase\")]\n pub struct ExtendSelectionParams {\n     pub text_document: TextDocumentIdentifier,\n     pub selections: Vec<Range>,\n }\n \n-\n+#[derive(Serialize, Debug)]\n+#[serde(rename_all = \"camelCase\")]\n pub struct ExtendSelectionResult {\n     pub selections: Vec<Range>,\n }"}, {"sha": "2beea564053f42f7b81c986863cc35fc30cb7823", "filename": "libanalysis/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26262aaf05983c5b7f41cc438e287523268fe1eb/libanalysis%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/26262aaf05983c5b7f41cc438e287523268fe1eb/libanalysis%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/libanalysis%2FCargo.toml?ref=26262aaf05983c5b7f41cc438e287523268fe1eb", "patch": "@@ -7,4 +7,6 @@ authors = [\"Aleksey Kladov <aleksey.kladov@gmail.com>\"]\n log = \"0.4.2\"\n failure = \"0.1.2\"\n parking_lot = \"0.6.3\"\n+once_cell = \"0.1.4\"\n libsyntax2 = { path = \"../\" }\n+libeditor = { path = \"../libeditor\" }"}, {"sha": "fc0c25c54b9316bb3eaa35c6fca58459da0c3cfa", "filename": "libanalysis/src/arena.rs", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3fff5e94ebf772f8485aaa2bda2ea36be766fdb3/libanalysis%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fff5e94ebf772f8485aaa2bda2ea36be766fdb3/libanalysis%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/libanalysis%2Fsrc%2Farena.rs?ref=3fff5e94ebf772f8485aaa2bda2ea36be766fdb3", "patch": "@@ -1,42 +0,0 @@\n-use parking_lot::RwLock;\n-\n-const CHUNK_LEN: usize = 16;\n-\n-pub struct Arena<T> {\n-    chunks: RwLock<Vec<Vec<T>>>,\n-}\n-\n-impl<T> Arena<T> {\n-    pub fn new(&self) -> Arena<T> {\n-        Arena {\n-            chunks: RwLock::new(vec![Vec::with_capacity(CHUNK_LEN)]),\n-        }\n-    }\n-\n-    pub fn push(&self, value: T) -> usize {\n-        let mut guard = self.chunks.write();\n-        let mut idx = (guard.len() - 1) * CHUNK_LEN;\n-        let chunk = {\n-            if guard.last().unwrap().len() == CHUNK_LEN {\n-                guard.push(Vec::with_capacity(CHUNK_LEN));\n-            }\n-            guard.last_mut().unwrap()\n-        };\n-        assert!(chunk.len() < chunk.capacity());\n-        idx += chunk.len();\n-        chunk.push(value);\n-        idx\n-    }\n-\n-    pub fn get(&self, idx: usize) -> &T {\n-        let chunk_idx = idx / CHUNK_LEN;\n-        let chunk_off = idx - chunk_idx * CHUNK_LEN;\n-        let guard = self.chunks.read();\n-        let value = &guard[chunk_idx][chunk_off];\n-        unsafe {\n-            // We are careful to not move values in chunks,\n-            // so this hopefully is safe\n-            ::std::mem::transmute::<&T, &T>(value)\n-        }\n-    }\n-}"}, {"sha": "6a946a0b090a1390cfce322014d498365a1c4505", "filename": "libanalysis/src/lib.rs", "status": "modified", "additions": 54, "deletions": 35, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/26262aaf05983c5b7f41cc438e287523268fe1eb/libanalysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26262aaf05983c5b7f41cc438e287523268fe1eb/libanalysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/libanalysis%2Fsrc%2Flib.rs?ref=26262aaf05983c5b7f41cc438e287523268fe1eb", "patch": "@@ -2,9 +2,11 @@ extern crate failure;\n extern crate parking_lot;\n #[macro_use]\n extern crate log;\n+extern crate once_cell;\n extern crate libsyntax2;\n+extern crate libeditor;\n \n-mod arena;\n+use once_cell::sync::OnceCell;\n \n use std::{\n     fs,\n@@ -14,6 +16,7 @@ use std::{\n };\n use parking_lot::RwLock;\n use libsyntax2::ast;\n+use libeditor::LineIndex;\n \n pub type Result<T> = ::std::result::Result<T, ::failure::Error>;\n \n@@ -39,7 +42,6 @@ impl WorldState {\n     pub fn change_overlay(&mut self, path: PathBuf, text: Option<String>) {\n         let data = self.data_mut();\n         data.file_map.get_mut().remove(&path);\n-        data.fs_map.get_mut().remove(&path);\n         if let Some(text) = text {\n             data.mem_map.insert(path, Arc::new(text));\n         } else {\n@@ -49,11 +51,9 @@ impl WorldState {\n \n     fn data_mut(&mut self) -> &mut WorldData {\n         if Arc::get_mut(&mut self.data).is_none() {\n-            let fs_map = self.data.fs_map.read().clone();\n             let file_map = self.data.file_map.read().clone();\n             self.data = Arc::new(WorldData {\n                 mem_map: self.data.mem_map.clone(),\n-                fs_map: RwLock::new(fs_map),\n                 file_map: RwLock::new(file_map),\n             });\n         }\n@@ -64,50 +64,69 @@ impl WorldState {\n \n impl World {\n     pub fn file_syntax(&self, path: &Path) -> Result<ast::File> {\n-        {\n-            let guard = self.data.file_map.read();\n-            if let Some(file) = guard.get(path) {\n-                return Ok(file.clone());\n-            }\n-        }\n-        let file = self.with_file_text(path, |text| {\n-            trace!(\"parsing file: {}\", path.display());\n-            ast::File::parse(text)\n-        })?;\n-        let mut guard = self.data.file_map.write();\n-        let file = guard.entry(path.to_owned())\n-            .or_insert(file)\n-            .clone();\n-        Ok(file)\n+        let data = self.file_data(path)?;\n+        let syntax = data.syntax\n+            .get_or_init(|| {\n+                trace!(\"parsing: {}\", path.display());\n+                ast::File::parse(self.file_text(path, &data))\n+            }).clone();\n+        Ok(syntax)\n     }\n \n-    fn with_file_text<F: FnOnce(&str) -> R, R>(&self, path: &Path, f: F) -> Result<R> {\n-        if let Some(text) = self.data.mem_map.get(path) {\n-            return Ok(f(&*text));\n+    pub fn file_line_index(&self, path: &Path) -> Result<LineIndex> {\n+        let data = self.file_data(path)?;\n+        let index = data.lines\n+            .get_or_init(|| {\n+                trace!(\"calc line index: {}\", path.display());\n+                LineIndex::new(self.file_text(path, &data))\n+            });\n+        Ok(index.clone())\n+    }\n+\n+    fn file_text<'a>(&'a self, path: &Path, file_data: &'a FileData) -> &'a str {\n+        match file_data.text.as_ref() {\n+            Some(text) => text.as_str(),\n+            None => self.data.mem_map[path].as_str()\n         }\n+    }\n \n+    fn file_data(&self, path: &Path) -> Result<Arc<FileData>> {\n         {\n-            let guard = self.data.fs_map.read();\n-            if let Some(text) = guard.get(path) {\n-                return Ok(f(&*text));\n+            let guard = self.data.file_map.read();\n+            if let Some(data) = guard.get(path) {\n+                return Ok(data.clone());\n             }\n         }\n-        trace!(\"loading file from disk: {}\", path.display());\n-        let text = fs::read_to_string(path)?;\n-        {\n-            let mut guard = self.data.fs_map.write();\n+\n+        let text = if self.data.mem_map.contains_key(path) {\n+            None\n+        } else {\n+            trace!(\"loading file from disk: {}\", path.display());\n+            Some(fs::read_to_string(path)?)\n+        };\n+        let res = {\n+            let mut guard = self.data.file_map.write();\n             guard.entry(path.to_owned())\n-                .or_insert_with(|| Arc::new(text));\n-        }\n-        let guard = self.data.fs_map.read();\n-        Ok(f(&guard[path]))\n+                .or_insert_with(|| Arc::new(FileData {\n+                    text,\n+                    syntax: OnceCell::new(),\n+                    lines: OnceCell::new(),\n+                }))\n+                .clone()\n+        };\n+        Ok(res)\n     }\n }\n \n \n #[derive(Default)]\n struct WorldData {\n     mem_map: HashMap<PathBuf, Arc<String>>,\n-    fs_map: RwLock<HashMap<PathBuf, Arc<String>>>,\n-    file_map: RwLock<HashMap<PathBuf, ast::File>>,\n+    file_map: RwLock<HashMap<PathBuf, Arc<FileData>>>,\n+}\n+\n+struct FileData {\n+    text: Option<String>,\n+    syntax: OnceCell<ast::File>,\n+    lines: OnceCell<LineIndex>,\n }"}, {"sha": "f776473382f29354ab9e62658a16e1aa1df41a0a", "filename": "libeditor/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/26262aaf05983c5b7f41cc438e287523268fe1eb/libeditor%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26262aaf05983c5b7f41cc438e287523268fe1eb/libeditor%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/libeditor%2Fsrc%2Flib.rs?ref=26262aaf05983c5b7f41cc438e287523268fe1eb", "patch": "@@ -10,6 +10,7 @@ use libsyntax2::{\n     SyntaxKind::*,\n };\n pub use libsyntax2::{TextRange, TextUnit, ast};\n+pub use self::line_index::{LineIndex, LineCol};\n \n #[derive(Debug)]\n pub struct HighlightedRange {"}, {"sha": "801726aa59b953df5266c620c6cc5d32786f5fbf", "filename": "libeditor/src/line_index.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/26262aaf05983c5b7f41cc438e287523268fe1eb/libeditor%2Fsrc%2Fline_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26262aaf05983c5b7f41cc438e287523268fe1eb/libeditor%2Fsrc%2Fline_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/libeditor%2Fsrc%2Fline_index.rs?ref=26262aaf05983c5b7f41cc438e287523268fe1eb", "patch": "@@ -1,6 +1,7 @@\n use superslice::Ext;\n-use ::{TextUnit};\n+use ::TextUnit;\n \n+#[derive(Clone, Debug)]\n pub struct LineIndex {\n     newlines: Vec<TextUnit>,\n }\n@@ -24,33 +25,38 @@ impl LineIndex {\n         LineIndex { newlines }\n     }\n \n-    pub fn translate(&self, offset: TextUnit) -> LineCol {\n+    pub fn line_col(&self, offset: TextUnit) -> LineCol {\n         let line = self.newlines.upper_bound(&offset) - 1;\n         let line_start_offset = self.newlines[line];\n         let col = offset - line_start_offset;\n-        return LineCol { line: line as u32, col }\n+        return LineCol { line: line as u32, col };\n+    }\n+\n+    pub fn offset(&self, line_col: LineCol) -> TextUnit {\n+        //TODO: return Result\n+        self.newlines[line_col.line as usize] + line_col.col\n     }\n }\n \n #[test]\n fn test_line_index() {\n     let text = \"hello\\nworld\";\n     let index = LineIndex::new(text);\n-    assert_eq!(index.translate(0.into()), LineCol { line: 0, col: 0.into()});\n-    assert_eq!(index.translate(1.into()), LineCol { line: 0, col: 1.into()});\n-    assert_eq!(index.translate(5.into()), LineCol { line: 0, col: 5.into()});\n-    assert_eq!(index.translate(6.into()), LineCol { line: 1, col: 0.into()});\n-    assert_eq!(index.translate(7.into()), LineCol { line: 1, col: 1.into()});\n-    assert_eq!(index.translate(8.into()), LineCol { line: 1, col: 2.into()});\n-    assert_eq!(index.translate(10.into()), LineCol { line: 1, col: 4.into()});\n-    assert_eq!(index.translate(11.into()), LineCol { line: 1, col: 5.into()});\n-    assert_eq!(index.translate(12.into()), LineCol { line: 1, col: 6.into()});\n+    assert_eq!(index.line_col(0.into()), LineCol { line: 0, col: 0.into() });\n+    assert_eq!(index.line_col(1.into()), LineCol { line: 0, col: 1.into() });\n+    assert_eq!(index.line_col(5.into()), LineCol { line: 0, col: 5.into() });\n+    assert_eq!(index.line_col(6.into()), LineCol { line: 1, col: 0.into() });\n+    assert_eq!(index.line_col(7.into()), LineCol { line: 1, col: 1.into() });\n+    assert_eq!(index.line_col(8.into()), LineCol { line: 1, col: 2.into() });\n+    assert_eq!(index.line_col(10.into()), LineCol { line: 1, col: 4.into() });\n+    assert_eq!(index.line_col(11.into()), LineCol { line: 1, col: 5.into() });\n+    assert_eq!(index.line_col(12.into()), LineCol { line: 1, col: 6.into() });\n \n     let text = \"\\nhello\\nworld\";\n     let index = LineIndex::new(text);\n-    assert_eq!(index.translate(0.into()), LineCol { line: 0, col: 0.into()});\n-    assert_eq!(index.translate(1.into()), LineCol { line: 1, col: 0.into()});\n-    assert_eq!(index.translate(2.into()), LineCol { line: 1, col: 1.into()});\n-    assert_eq!(index.translate(6.into()), LineCol { line: 1, col: 5.into()});\n-    assert_eq!(index.translate(7.into()), LineCol { line: 2, col: 0.into()});\n+    assert_eq!(index.line_col(0.into()), LineCol { line: 0, col: 0.into() });\n+    assert_eq!(index.line_col(1.into()), LineCol { line: 1, col: 0.into() });\n+    assert_eq!(index.line_col(2.into()), LineCol { line: 1, col: 1.into() });\n+    assert_eq!(index.line_col(6.into()), LineCol { line: 1, col: 5.into() });\n+    assert_eq!(index.line_col(7.into()), LineCol { line: 2, col: 0.into() });\n }"}]}