{"sha": "1f6db7f4f6399628eaaca5d38cc5fb38e71b4c23", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmNmRiN2Y0ZjYzOTk2MjhlYWFjYTVkMzhjYzVmYjM4ZTcxYjRjMjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-06T17:16:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-06T17:16:40Z"}, "message": "auto merge of #13822 : EdorianDark/rust/master, r=cmr\n\nNew attempt to generalize stats, after #12606.\r\nSince #12355 did not get merged, i want go get first get my change done and the try to fix sum.", "tree": {"sha": "b00307d3ec57cb86241e20ff361839c64dc39c76", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b00307d3ec57cb86241e20ff361839c64dc39c76"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f6db7f4f6399628eaaca5d38cc5fb38e71b4c23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f6db7f4f6399628eaaca5d38cc5fb38e71b4c23", "html_url": "https://github.com/rust-lang/rust/commit/1f6db7f4f6399628eaaca5d38cc5fb38e71b4c23", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f6db7f4f6399628eaaca5d38cc5fb38e71b4c23/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c600dc0f535b4afc7722bda4154e35f948e3f6b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/c600dc0f535b4afc7722bda4154e35f948e3f6b2", "html_url": "https://github.com/rust-lang/rust/commit/c600dc0f535b4afc7722bda4154e35f948e3f6b2"}, {"sha": "a8da4f7309f1684d7c229de494c2527b6089b314", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8da4f7309f1684d7c229de494c2527b6089b314", "html_url": "https://github.com/rust-lang/rust/commit/a8da4f7309f1684d7c229de494c2527b6089b314"}], "stats": {"total": 213, "additions": 115, "deletions": 98}, "files": [{"sha": "fa55444fe5b2743da4bb25d13460c2cc40e6a417", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1f6db7f4f6399628eaaca5d38cc5fb38e71b4c23/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f6db7f4f6399628eaaca5d38cc5fb38e71b4c23/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=1f6db7f4f6399628eaaca5d38cc5fb38e71b4c23", "patch": "@@ -413,7 +413,7 @@ pub fn opt_shard(maybestr: Option<~str>) -> Option<(uint,uint)> {\n \n #[deriving(Clone, Eq)]\n pub struct BenchSamples {\n-    ns_iter_summ: stats::Summary,\n+    ns_iter_summ: stats::Summary<f64>,\n     mb_s: uint,\n }\n \n@@ -1249,7 +1249,7 @@ impl Bencher {\n     }\n \n     // This is a more statistics-driven benchmark algorithm\n-    pub fn auto_bench(&mut self, f: |&mut Bencher|) -> stats::Summary {\n+    pub fn auto_bench(&mut self, f: |&mut Bencher|) -> stats::Summary<f64> {\n \n         // Initial bench run to get ballpark figure.\n         let mut n = 1_u64;"}, {"sha": "e73a43efe76ddbd221ebe3e3d46a7dbf39c128e6", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 113, "deletions": 96, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/1f6db7f4f6399628eaaca5d38cc5fb38e71b4c23/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f6db7f4f6399628eaaca5d38cc5fb38e71b4c23/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=1f6db7f4f6399628eaaca5d38cc5fb38e71b4c23", "patch": "@@ -14,12 +14,11 @@ use std::hash::Hash;\n use std::io;\n use std::mem;\n use std::num;\n+use std::num::Zero;\n use collections::hashmap;\n+use std::fmt::Show;\n \n-// NB: this can probably be rewritten in terms of num::Num\n-// to be less f64-specific.\n-\n-fn f64_cmp(x: f64, y: f64) -> Ordering {\n+fn local_cmp<T:Float>(x: T, y: T) -> Ordering {\n     // arbitrarily decide that NaNs are larger than everything.\n     if y.is_nan() {\n         Less\n@@ -34,12 +33,12 @@ fn f64_cmp(x: f64, y: f64) -> Ordering {\n     }\n }\n \n-fn f64_sort(v: &mut [f64]) {\n-    v.sort_by(|x: &f64, y: &f64| f64_cmp(*x, *y));\n+fn local_sort<T: Float>(v: &mut [T]) {\n+    v.sort_by(|x: &T, y: &T| local_cmp(*x, *y));\n }\n \n /// Trait that provides simple descriptive statistics on a univariate set of numeric samples.\n-pub trait Stats {\n+pub trait Stats <T: Float + FromPrimitive>{\n \n     /// Sum of the samples.\n     ///\n@@ -48,24 +47,24 @@ pub trait Stats {\n     /// [\"Adaptive Precision Floating-Point Arithmetic and Fast Robust Geometric Predicates\"]\n     /// (http://www.cs.cmu.edu/~quake-papers/robust-arithmetic.ps)\n     /// *Discrete & Computational Geometry 18*, 3 (Oct 1997), 305-363, Shewchuk J.R.\n-    fn sum(self) -> f64;\n+    fn sum(self) -> T;\n \n     /// Minimum value of the samples.\n-    fn min(self) -> f64;\n+    fn min(self) -> T;\n \n     /// Maximum value of the samples.\n-    fn max(self) -> f64;\n+    fn max(self) -> T;\n \n     /// Arithmetic mean (average) of the samples: sum divided by sample-count.\n     ///\n     /// See: https://en.wikipedia.org/wiki/Arithmetic_mean\n-    fn mean(self) -> f64;\n+    fn mean(self) -> T;\n \n     /// Median of the samples: value separating the lower half of the samples from the higher half.\n     /// Equal to `self.percentile(50.0)`.\n     ///\n     /// See: https://en.wikipedia.org/wiki/Median\n-    fn median(self) -> f64;\n+    fn median(self) -> T;\n \n     /// Variance of the samples: bias-corrected mean of the squares of the differences of each\n     /// sample from the sample mean. Note that this calculates the _sample variance_ rather than the\n@@ -74,21 +73,21 @@ pub trait Stats {\n     /// than `n`.\n     ///\n     /// See: https://en.wikipedia.org/wiki/Variance\n-    fn var(self) -> f64;\n+    fn var(self) -> T;\n \n     /// Standard deviation: the square root of the sample variance.\n     ///\n     /// Note: this is not a robust statistic for non-normal distributions. Prefer the\n     /// `median_abs_dev` for unknown distributions.\n     ///\n     /// See: https://en.wikipedia.org/wiki/Standard_deviation\n-    fn std_dev(self) -> f64;\n+    fn std_dev(self) -> T;\n \n     /// Standard deviation as a percent of the mean value. See `std_dev` and `mean`.\n     ///\n     /// Note: this is not a robust statistic for non-normal distributions. Prefer the\n     /// `median_abs_dev_pct` for unknown distributions.\n-    fn std_dev_pct(self) -> f64;\n+    fn std_dev_pct(self) -> T;\n \n     /// Scaled median of the absolute deviations of each sample from the sample median. This is a\n     /// robust (distribution-agnostic) estimator of sample variability. Use this in preference to\n@@ -97,10 +96,10 @@ pub trait Stats {\n     /// deviation.\n     ///\n     /// See: http://en.wikipedia.org/wiki/Median_absolute_deviation\n-    fn median_abs_dev(self) -> f64;\n+    fn median_abs_dev(self) -> T;\n \n     /// Median absolute deviation as a percent of the median. See `median_abs_dev` and `median`.\n-    fn median_abs_dev_pct(self) -> f64;\n+    fn median_abs_dev_pct(self) -> T;\n \n     /// Percentile: the value below which `pct` percent of the values in `self` fall. For example,\n     /// percentile(95.0) will return the value `v` such that 95% of the samples `s` in `self`\n@@ -109,45 +108,45 @@ pub trait Stats {\n     /// Calculated by linear interpolation between closest ranks.\n     ///\n     /// See: http://en.wikipedia.org/wiki/Percentile\n-    fn percentile(self, pct: f64) -> f64;\n+    fn percentile(self, pct: T) -> T;\n \n     /// Quartiles of the sample: three values that divide the sample into four equal groups, each\n     /// with 1/4 of the data. The middle value is the median. See `median` and `percentile`. This\n     /// function may calculate the 3 quartiles more efficiently than 3 calls to `percentile`, but\n     /// is otherwise equivalent.\n     ///\n     /// See also: https://en.wikipedia.org/wiki/Quartile\n-    fn quartiles(self) -> (f64,f64,f64);\n+    fn quartiles(self) -> (T,T,T);\n \n     /// Inter-quartile range: the difference between the 25th percentile (1st quartile) and the 75th\n     /// percentile (3rd quartile). See `quartiles`.\n     ///\n     /// See also: https://en.wikipedia.org/wiki/Interquartile_range\n-    fn iqr(self) -> f64;\n+    fn iqr(self) -> T;\n }\n \n /// Extracted collection of all the summary statistics of a sample set.\n #[deriving(Clone, Eq)]\n #[allow(missing_doc)]\n-pub struct Summary {\n-    pub sum: f64,\n-    pub min: f64,\n-    pub max: f64,\n-    pub mean: f64,\n-    pub median: f64,\n-    pub var: f64,\n-    pub std_dev: f64,\n-    pub std_dev_pct: f64,\n-    pub median_abs_dev: f64,\n-    pub median_abs_dev_pct: f64,\n-    pub quartiles: (f64,f64,f64),\n-    pub iqr: f64,\n+pub struct Summary<T> {\n+    pub sum: T,\n+    pub min: T,\n+    pub max: T,\n+    pub mean: T,\n+    pub median: T,\n+    pub var: T,\n+    pub std_dev: T,\n+    pub std_dev_pct: T,\n+    pub median_abs_dev: T,\n+    pub median_abs_dev_pct: T,\n+    pub quartiles: (T,T,T),\n+    pub iqr: T,\n }\n \n-impl Summary {\n+impl<T: Float + FromPrimitive> Summary<T> {\n \n     /// Construct a new summary of a sample set.\n-    pub fn new(samples: &[f64]) -> Summary {\n+    pub fn new(samples: &[T]) -> Summary<T> {\n         Summary {\n             sum: samples.sum(),\n             min: samples.min(),\n@@ -165,11 +164,11 @@ impl Summary {\n     }\n }\n \n-impl<'a> Stats for &'a [f64] {\n+impl<'a,T: Float + FromPrimitive> Stats<T> for &'a [T] {\n \n     // FIXME #11059 handle NaN, inf and overflow\n     #[allow(deprecated_owned_vector)]\n-    fn sum(self) -> f64 {\n+    fn sum(self) -> T {\n         let mut partials = vec![];\n \n         for &mut x in self.iter() {\n@@ -185,7 +184,7 @@ impl<'a> Stats for &'a [f64] {\n                 // `lo`. Together `hi+lo` are exactly equal to `x+y`.\n                 let hi = x + y;\n                 let lo = y - (hi - x);\n-                if lo != 0f64 {\n+                if !lo.is_zero() {\n                     *partials.get_mut(j) = lo;\n                     j += 1;\n                 }\n@@ -198,81 +197,89 @@ impl<'a> Stats for &'a [f64] {\n                 partials.truncate(j+1);\n             }\n         }\n-        partials.iter().fold(0.0, |p, q| p + *q)\n+        let zero: T = Zero::zero();\n+        partials.iter().fold(zero, |p, q| p + *q)\n     }\n \n-    fn min(self) -> f64 {\n+    fn min(self) -> T {\n         assert!(self.len() != 0);\n         self.iter().fold(self[0], |p, q| p.min(*q))\n     }\n \n-    fn max(self) -> f64 {\n+    fn max(self) -> T {\n         assert!(self.len() != 0);\n         self.iter().fold(self[0], |p, q| p.max(*q))\n     }\n \n-    fn mean(self) -> f64 {\n+    fn mean(self) -> T {\n         assert!(self.len() != 0);\n-        self.sum() / (self.len() as f64)\n+        self.sum() / FromPrimitive::from_uint(self.len()).unwrap()\n     }\n \n-    fn median(self) -> f64 {\n-        self.percentile(50.0)\n+    fn median(self) -> T {\n+        self.percentile(FromPrimitive::from_uint(50).unwrap())\n     }\n \n-    fn var(self) -> f64 {\n+    fn var(self) -> T {\n         if self.len() < 2 {\n-            0.0\n+            Zero::zero()\n         } else {\n             let mean = self.mean();\n-            let mut v = 0.0;\n+            let mut v: T = Zero::zero();\n             for s in self.iter() {\n                 let x = *s - mean;\n-                v += x*x;\n+                v = v + x*x;\n             }\n             // NB: this is _supposed to be_ len-1, not len. If you\n             // change it back to len, you will be calculating a\n             // population variance, not a sample variance.\n-            v/((self.len()-1) as f64)\n+            let denom = FromPrimitive::from_uint(self.len()-1).unwrap();\n+            v/denom\n         }\n     }\n \n-    fn std_dev(self) -> f64 {\n+    fn std_dev(self) -> T {\n         self.var().sqrt()\n     }\n \n-    fn std_dev_pct(self) -> f64 {\n-        (self.std_dev() / self.mean()) * 100.0\n+    fn std_dev_pct(self) -> T {\n+        let hundred = FromPrimitive::from_uint(100).unwrap();\n+        (self.std_dev() / self.mean()) * hundred\n     }\n \n-    fn median_abs_dev(self) -> f64 {\n+    fn median_abs_dev(self) -> T {\n         let med = self.median();\n-        let abs_devs: Vec<f64> = self.iter().map(|&v| num::abs(med - v)).collect();\n+        let abs_devs: Vec<T> = self.iter().map(|&v| num::abs(med - v)).collect();\n         // This constant is derived by smarter statistics brains than me, but it is\n         // consistent with how R and other packages treat the MAD.\n-        abs_devs.as_slice().median() * 1.4826\n+        let number = FromPrimitive::from_f64(1.4826).unwrap();\n+        abs_devs.as_slice().median() * number\n     }\n \n-    fn median_abs_dev_pct(self) -> f64 {\n-        (self.median_abs_dev() / self.median()) * 100.0\n+    fn median_abs_dev_pct(self) -> T {\n+        let hundred = FromPrimitive::from_uint(100).unwrap();\n+        (self.median_abs_dev() / self.median()) * hundred\n     }\n \n-    fn percentile(self, pct: f64) -> f64 {\n+    fn percentile(self, pct: T) -> T {\n         let mut tmp = Vec::from_slice(self);\n-        f64_sort(tmp.as_mut_slice());\n+        local_sort(tmp.as_mut_slice());\n         percentile_of_sorted(tmp.as_slice(), pct)\n     }\n \n-    fn quartiles(self) -> (f64,f64,f64) {\n+    fn quartiles(self) -> (T,T,T) {\n         let mut tmp = Vec::from_slice(self);\n-        f64_sort(tmp.as_mut_slice());\n-        let a = percentile_of_sorted(tmp.as_slice(), 25.0);\n-        let b = percentile_of_sorted(tmp.as_slice(), 50.0);\n-        let c = percentile_of_sorted(tmp.as_slice(), 75.0);\n+        local_sort(tmp.as_mut_slice());\n+        let first = FromPrimitive::from_uint(25).unwrap();\n+        let a = percentile_of_sorted(tmp.as_slice(), first);\n+        let secound = FromPrimitive::from_uint(50).unwrap();\n+        let b = percentile_of_sorted(tmp.as_slice(), secound);\n+        let third = FromPrimitive::from_uint(75).unwrap();\n+        let c = percentile_of_sorted(tmp.as_slice(), third);\n         (a,b,c)\n     }\n \n-    fn iqr(self) -> f64 {\n+    fn iqr(self) -> T {\n         let (a,_,c) = self.quartiles();\n         c - a\n     }\n@@ -281,21 +288,24 @@ impl<'a> Stats for &'a [f64] {\n \n // Helper function: extract a value representing the `pct` percentile of a sorted sample-set, using\n // linear interpolation. If samples are not sorted, return nonsensical value.\n-fn percentile_of_sorted(sorted_samples: &[f64],\n-                             pct: f64) -> f64 {\n+fn percentile_of_sorted<T: Float + FromPrimitive>(sorted_samples: &[T],\n+                                                             pct: T) -> T {\n     assert!(sorted_samples.len() != 0);\n     if sorted_samples.len() == 1 {\n         return sorted_samples[0];\n     }\n-    assert!(0.0 <= pct);\n-    assert!(pct <= 100.0);\n-    if pct == 100.0 {\n+    let zero: T = Zero::zero();\n+    assert!(zero <= pct);\n+    let hundred = FromPrimitive::from_uint(100).unwrap();\n+    assert!(pct <= hundred);\n+    if pct == hundred {\n         return sorted_samples[sorted_samples.len() - 1];\n     }\n-    let rank = (pct / 100.0) * ((sorted_samples.len() - 1) as f64);\n+    let length = FromPrimitive::from_uint(sorted_samples.len() - 1).unwrap();\n+    let rank = (pct / hundred) * length;\n     let lrank = rank.floor();\n     let d = rank - lrank;\n-    let n = lrank as uint;\n+    let n = lrank.to_uint().unwrap();\n     let lo = sorted_samples[n];\n     let hi = sorted_samples[n+1];\n     lo + (hi - lo) * d\n@@ -308,11 +318,12 @@ fn percentile_of_sorted(sorted_samples: &[f64],\n /// change the number of samples, just changes the values of those that are outliers.\n ///\n /// See: http://en.wikipedia.org/wiki/Winsorising\n-pub fn winsorize(samples: &mut [f64], pct: f64) {\n+pub fn winsorize<T: Float + FromPrimitive>(samples: &mut [T], pct: T) {\n     let mut tmp = Vec::from_slice(samples);\n-    f64_sort(tmp.as_mut_slice());\n+    local_sort(tmp.as_mut_slice());\n     let lo = percentile_of_sorted(tmp.as_slice(), pct);\n-    let hi = percentile_of_sorted(tmp.as_slice(), 100.0-pct);\n+    let hundred: T = FromPrimitive::from_uint(100).unwrap();\n+    let hi = percentile_of_sorted(tmp.as_slice(), hundred-pct);\n     for samp in samples.mut_iter() {\n         if *samp > hi {\n             *samp = hi\n@@ -323,8 +334,8 @@ pub fn winsorize(samples: &mut [f64], pct: f64) {\n }\n \n /// Render writes the min, max and quartiles of the provided `Summary` to the provided `Writer`.\n-pub fn write_5_number_summary(w: &mut io::Writer,\n-                              s: &Summary) -> io::IoResult<()> {\n+pub fn write_5_number_summary<T: Float + Show>(w: &mut io::Writer,\n+                                               s: &Summary<T>) -> io::IoResult<()> {\n     let (q1,q2,q3) = s.quartiles;\n     write!(w, \"(min={}, q1={}, med={}, q3={}, max={})\",\n                      s.min,\n@@ -346,24 +357,29 @@ pub fn write_5_number_summary(w: &mut io::Writer,\n ///   10 |        [--****#******----------]          | 40\n /// ~~~~\n \n-pub fn write_boxplot(w: &mut io::Writer, s: &Summary,\n-                     width_hint: uint) -> io::IoResult<()> {\n+pub fn write_boxplot<T: Float + Show + FromPrimitive>(\n+                     w: &mut io::Writer,\n+                     s: &Summary<T>,\n+                     width_hint: uint)\n+                      -> io::IoResult<()> {\n \n     let (q1,q2,q3) = s.quartiles;\n \n     // the .abs() handles the case where numbers are negative\n-    let lomag = 10.0_f64.powf(s.min.abs().log10().floor());\n-    let himag = 10.0_f64.powf(s.max.abs().log10().floor());\n+    let ten: T = FromPrimitive::from_uint(10).unwrap();\n+    let lomag = ten.powf(s.min.abs().log10().floor());\n+    let himag = ten.powf(s.max.abs().log10().floor());\n \n     // need to consider when the limit is zero\n-    let lo = if lomag == 0.0 {\n-        0.0\n+    let zero: T = Zero::zero();\n+    let lo = if lomag.is_zero() {\n+        zero\n     } else {\n         (s.min / lomag).floor() * lomag\n     };\n \n-    let hi = if himag == 0.0 {\n-        0.0\n+    let hi = if himag.is_zero() {\n+        zero\n     } else {\n         (s.max / himag).ceil() * himag\n     };\n@@ -374,8 +390,9 @@ pub fn write_boxplot(w: &mut io::Writer, s: &Summary,\n     let histr = hi.to_str();\n \n     let overhead_width = lostr.len() + histr.len() + 4;\n-    let range_width = width_hint - overhead_width;;\n-    let char_step = range / (range_width as f64);\n+    let range_width = width_hint - overhead_width;\n+    let range_float = FromPrimitive::from_uint(range_width).unwrap();\n+    let char_step = range / range_float;\n \n     try!(write!(w, \"{} |\", lostr));\n \n@@ -384,37 +401,37 @@ pub fn write_boxplot(w: &mut io::Writer, s: &Summary,\n \n     while c < range_width && v < s.min {\n         try!(write!(w, \" \"));\n-        v += char_step;\n+        v = v + char_step;\n         c += 1;\n     }\n     try!(write!(w, \"[\"));\n     c += 1;\n     while c < range_width && v < q1 {\n         try!(write!(w, \"-\"));\n-        v += char_step;\n+        v = v + char_step;\n         c += 1;\n     }\n     while c < range_width && v < q2 {\n         try!(write!(w, \"*\"));\n-        v += char_step;\n+        v = v + char_step;\n         c += 1;\n     }\n     try!(write!(w, r\"\\#\"));\n     c += 1;\n     while c < range_width && v < q3 {\n         try!(write!(w, \"*\"));\n-        v += char_step;\n+        v = v + char_step;\n         c += 1;\n     }\n     while c < range_width && v < s.max {\n         try!(write!(w, \"-\"));\n-        v += char_step;\n+        v = v + char_step;\n         c += 1;\n     }\n     try!(write!(w, \"]\"));\n     while c < range_width {\n         try!(write!(w, \" \"));\n-        v += char_step;\n+        v = v + char_step;\n         c += 1;\n     }\n \n@@ -452,7 +469,7 @@ mod tests {\n         })\n     )\n \n-    fn check(samples: &[f64], summ: &Summary) {\n+    fn check(samples: &[f64], summ: &Summary<f64>) {\n \n         let summ2 = Summary::new(samples);\n \n@@ -1011,7 +1028,7 @@ mod tests {\n     #[test]\n     fn test_boxplot_nonpositive() {\n         #[allow(deprecated_owned_vector)]\n-        fn t(s: &Summary, expected: ~str) {\n+        fn t(s: &Summary<f64>, expected: ~str) {\n             use std::io::MemWriter;\n             let mut m = MemWriter::new();\n             write_boxplot(&mut m as &mut io::Writer, s, 30).unwrap();"}]}