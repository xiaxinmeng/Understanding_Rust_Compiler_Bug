{"sha": "4fae06824ce1a3de3d24677196bf2e0d53346830", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmYWUwNjgyNGNlMWEzZGUzZDI0Njc3MTk2YmYyZTBkNTMzNDY4MzA=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-03-05T14:36:01Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-03-17T07:53:06Z"}, "message": "De-@ Session usage.", "tree": {"sha": "621f085caa12b4f0903121f31b2864a5943d49f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/621f085caa12b4f0903121f31b2864a5943d49f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4fae06824ce1a3de3d24677196bf2e0d53346830", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4fae06824ce1a3de3d24677196bf2e0d53346830", "html_url": "https://github.com/rust-lang/rust/commit/4fae06824ce1a3de3d24677196bf2e0d53346830", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4fae06824ce1a3de3d24677196bf2e0d53346830/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb68beec4b809c1e091ce678a2c18347701497c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb68beec4b809c1e091ce678a2c18347701497c2", "html_url": "https://github.com/rust-lang/rust/commit/eb68beec4b809c1e091ce678a2c18347701497c2"}], "stats": {"total": 1058, "additions": 510, "deletions": 548}, "files": [{"sha": "dd1c754c257181914f66ea7963954194142a5505", "filename": "src/librustc/back/archive.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Farchive.rs?ref=4fae06824ce1a3de3d24677196bf2e0d53346830", "patch": "@@ -28,17 +28,17 @@ use syntax::abi;\n \n pub static METADATA_FILENAME: &'static str = \"rust.metadata.bin\";\n \n-pub struct Archive {\n-    priv sess: Session,\n+pub struct Archive<'a> {\n+    priv sess: &'a Session,\n     priv dst: Path,\n }\n \n pub struct ArchiveRO {\n     priv ptr: ArchiveRef,\n }\n \n-fn run_ar(sess: Session, args: &str, cwd: Option<&Path>,\n-        paths: &[&Path]) -> ProcessOutput {\n+fn run_ar(sess: &Session, args: &str, cwd: Option<&Path>,\n+          paths: &[&Path]) -> ProcessOutput {\n     let ar = get_ar_prog(sess);\n \n     let mut args = vec!(args.to_owned());\n@@ -74,16 +74,16 @@ fn run_ar(sess: Session, args: &str, cwd: Option<&Path>,\n     }\n }\n \n-impl Archive {\n+impl<'a> Archive<'a> {\n     /// Initializes a new static archive with the given object file\n-    pub fn create<'a>(sess: Session, dst: &'a Path,\n-                      initial_object: &'a Path) -> Archive {\n+    pub fn create<'b>(sess: &'a Session, dst: &'b Path,\n+                      initial_object: &'b Path) -> Archive<'a> {\n         run_ar(sess, \"crus\", None, [dst, initial_object]);\n         Archive { sess: sess, dst: dst.clone() }\n     }\n \n     /// Opens an existing static archive\n-    pub fn open(sess: Session, dst: Path) -> Archive {\n+    pub fn open(sess: &'a Session, dst: Path) -> Archive<'a> {\n         assert!(dst.exists());\n         Archive { sess: sess, dst: dst }\n     }"}, {"sha": "6d5f95b52ab8bbdbe0b5453bf62b47d403cdf537", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=4fae06824ce1a3de3d24677196bf2e0d53346830", "patch": "@@ -54,7 +54,7 @@ pub enum OutputType {\n     OutputTypeExe,\n }\n \n-pub fn llvm_err(sess: Session, msg: ~str) -> ! {\n+pub fn llvm_err(sess: &Session, msg: ~str) -> ! {\n     unsafe {\n         let cstr = llvm::LLVMRustGetLastError();\n         if cstr == ptr::null() {\n@@ -68,7 +68,7 @@ pub fn llvm_err(sess: Session, msg: ~str) -> ! {\n }\n \n pub fn WriteOutputFile(\n-        sess: Session,\n+        sess: &Session,\n         target: lib::llvm::TargetMachineRef,\n         pm: lib::llvm::PassManagerRef,\n         m: ModuleRef,\n@@ -125,7 +125,7 @@ pub mod write {\n         }\n     }\n \n-    pub fn run_passes(sess: Session,\n+    pub fn run_passes(sess: &Session,\n                       trans: &CrateTranslation,\n                       output_types: &[OutputType],\n                       output: &OutputFilenames) {\n@@ -156,7 +156,7 @@ pub mod write {\n \n             let tm = sess.targ_cfg.target_strs.target_triple.with_c_str(|t| {\n                 sess.opts.cg.target_cpu.with_c_str(|cpu| {\n-                    target_feature(&sess).with_c_str(|features| {\n+                    target_feature(sess).with_c_str(|features| {\n                         llvm::LLVMRustCreateTargetMachine(\n                             t, cpu, features,\n                             lib::llvm::CodeModelDefault,\n@@ -323,7 +323,7 @@ pub mod write {\n         }\n     }\n \n-    pub fn run_assembler(sess: Session, outputs: &OutputFilenames) {\n+    pub fn run_assembler(sess: &Session, outputs: &OutputFilenames) {\n         let cc = super::get_cc_prog(sess);\n         let assembly = outputs.temp_path(OutputTypeAssembly);\n         let object = outputs.path(OutputTypeObject);\n@@ -351,7 +351,7 @@ pub mod write {\n         }\n     }\n \n-    unsafe fn configure_llvm(sess: Session) {\n+    unsafe fn configure_llvm(sess: &Session) {\n         use sync::one::{Once, ONCE_INIT};\n         static mut INIT: Once = ONCE_INIT;\n \n@@ -719,7 +719,7 @@ pub fn output_lib_filename(id: &CrateId) -> ~str {\n     format!(\"{}-{}-{}\", id.name, crate_id_hash(id), id.version_or_default())\n }\n \n-pub fn get_cc_prog(sess: Session) -> ~str {\n+pub fn get_cc_prog(sess: &Session) -> ~str {\n     match sess.opts.cg.linker {\n         Some(ref linker) => return linker.to_owned(),\n         None => {}\n@@ -737,7 +737,7 @@ pub fn get_cc_prog(sess: Session) -> ~str {\n     get_system_tool(sess, \"cc\")\n }\n \n-pub fn get_ar_prog(sess: Session) -> ~str {\n+pub fn get_ar_prog(sess: &Session) -> ~str {\n     match sess.opts.cg.ar {\n         Some(ref ar) => return ar.to_owned(),\n         None => {}\n@@ -746,7 +746,7 @@ pub fn get_ar_prog(sess: Session) -> ~str {\n     get_system_tool(sess, \"ar\")\n }\n \n-fn get_system_tool(sess: Session, tool: &str) -> ~str {\n+fn get_system_tool(sess: &Session, tool: &str) -> ~str {\n     match sess.targ_cfg.os {\n         abi::OsAndroid => match sess.opts.cg.android_cross_path {\n             Some(ref path) => {\n@@ -765,7 +765,7 @@ fn get_system_tool(sess: Session, tool: &str) -> ~str {\n     }\n }\n \n-fn remove(sess: Session, path: &Path) {\n+fn remove(sess: &Session, path: &Path) {\n     match fs::unlink(path) {\n         Ok(..) => {}\n         Err(e) => {\n@@ -776,7 +776,7 @@ fn remove(sess: Session, path: &Path) {\n \n /// Perform the linkage portion of the compilation phase. This will generate all\n /// of the requested outputs for this compilation session.\n-pub fn link_binary(sess: Session,\n+pub fn link_binary(sess: &Session,\n                    trans: &CrateTranslation,\n                    outputs: &OutputFilenames,\n                    id: &CrateId) -> Vec<Path> {\n@@ -830,7 +830,7 @@ pub fn filename_for_input(sess: &Session, crate_type: session::CrateType,\n     }\n }\n \n-fn link_binary_output(sess: Session,\n+fn link_binary_output(sess: &Session,\n                       trans: &CrateTranslation,\n                       crate_type: session::CrateType,\n                       outputs: &OutputFilenames,\n@@ -840,7 +840,7 @@ fn link_binary_output(sess: Session,\n         Some(ref file) => file.clone(),\n         None => {\n             let out_filename = outputs.path(OutputTypeExe);\n-            filename_for_input(&sess, crate_type, id, &out_filename)\n+            filename_for_input(sess, crate_type, id, &out_filename)\n         }\n     };\n \n@@ -883,10 +883,10 @@ fn link_binary_output(sess: Session,\n // rlib primarily contains the object file of the crate, but it also contains\n // all of the object files from native libraries. This is done by unzipping\n // native libraries and inserting all of the contents into this archive.\n-fn link_rlib(sess: Session,\n-             trans: Option<&CrateTranslation>, // None == no metadata/bytecode\n-             obj_filename: &Path,\n-             out_filename: &Path) -> Archive {\n+fn link_rlib<'a>(sess: &'a Session,\n+                 trans: Option<&CrateTranslation>, // None == no metadata/bytecode\n+                 obj_filename: &Path,\n+                 out_filename: &Path) -> Archive<'a> {\n     let mut a = Archive::create(sess, out_filename, obj_filename);\n \n     let used_libraries = sess.cstore.get_used_libraries();\n@@ -985,7 +985,7 @@ fn link_rlib(sess: Session,\n // There's no need to include metadata in a static archive, so ensure to not\n // link in the metadata object file (and also don't prepare the archive with a\n // metadata file).\n-fn link_staticlib(sess: Session, obj_filename: &Path, out_filename: &Path) {\n+fn link_staticlib(sess: &Session, obj_filename: &Path, out_filename: &Path) {\n     let mut a = link_rlib(sess, None, obj_filename, out_filename);\n     a.add_native_library(\"morestack\").unwrap();\n     a.add_native_library(\"compiler-rt\").unwrap();\n@@ -1016,7 +1016,7 @@ fn link_staticlib(sess: Session, obj_filename: &Path, out_filename: &Path) {\n //\n // This will invoke the system linker/cc to create the resulting file. This\n // links to all upstream files as well.\n-fn link_natively(sess: Session, dylib: bool, obj_filename: &Path,\n+fn link_natively(sess: &Session, dylib: bool, obj_filename: &Path,\n                  out_filename: &Path) {\n     let tmpdir = TempDir::new(\"rustc\").expect(\"needs a temp dir\");\n     // The invocations of cc share some flags across platforms\n@@ -1066,7 +1066,7 @@ fn link_natively(sess: Session, dylib: bool, obj_filename: &Path,\n     }\n }\n \n-fn link_args(sess: Session,\n+fn link_args(sess: &Session,\n              dylib: bool,\n              tmpdir: &Path,\n              obj_filename: &Path,\n@@ -1248,7 +1248,7 @@ fn link_args(sess: Session,\n // Also note that the native libraries linked here are only the ones located\n // in the current crate. Upstream crates with native library dependencies\n // may have their native library pulled in above.\n-fn add_local_native_libraries(args: &mut Vec<~str> , sess: Session) {\n+fn add_local_native_libraries(args: &mut Vec<~str>, sess: &Session) {\n     let addl_lib_search_paths = sess.opts.addl_lib_search_paths.borrow();\n     for path in addl_lib_search_paths.get().iter() {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n@@ -1281,7 +1281,7 @@ fn add_local_native_libraries(args: &mut Vec<~str> , sess: Session) {\n // Rust crates are not considered at all when creating an rlib output. All\n // dependencies will be linked when producing the final output (instead of\n // the intermediate rlib version)\n-fn add_upstream_rust_crates(args: &mut Vec<~str> , sess: Session,\n+fn add_upstream_rust_crates(args: &mut Vec<~str>, sess: &Session,\n                             dylib: bool, tmpdir: &Path) {\n \n     // As a limitation of the current implementation, we require that everything\n@@ -1376,8 +1376,8 @@ fn add_upstream_rust_crates(args: &mut Vec<~str> , sess: Session,\n     }\n \n     // Adds the static \"rlib\" versions of all crates to the command line.\n-    fn add_static_crates(args: &mut Vec<~str> , sess: Session, tmpdir: &Path,\n-                         crates: Vec<(ast::CrateNum, Path)> ) {\n+    fn add_static_crates(args: &mut Vec<~str>, sess: &Session, tmpdir: &Path,\n+                         crates: Vec<(ast::CrateNum, Path)>) {\n         for (cnum, cratepath) in crates.move_iter() {\n             // When performing LTO on an executable output, all of the\n             // bytecode from the upstream libraries has already been\n@@ -1423,7 +1423,7 @@ fn add_upstream_rust_crates(args: &mut Vec<~str> , sess: Session,\n     }\n \n     // Same thing as above, but for dynamic crates instead of static crates.\n-    fn add_dynamic_crates(args: &mut Vec<~str> , sess: Session,\n+    fn add_dynamic_crates(args: &mut Vec<~str>, sess: &Session,\n                           crates: Vec<(ast::CrateNum, Path)> ) {\n         // If we're performing LTO, then it should have been previously required\n         // that all upstream rust dependencies were available in an rlib format.\n@@ -1458,7 +1458,7 @@ fn add_upstream_rust_crates(args: &mut Vec<~str> , sess: Session,\n // generic function calls a native function, then the generic function must\n // be instantiated in the target crate, meaning that the native symbol must\n // also be resolved in the target crate.\n-fn add_upstream_native_libraries(args: &mut Vec<~str> , sess: Session) {\n+fn add_upstream_native_libraries(args: &mut Vec<~str>, sess: &Session) {\n     let cstore = sess.cstore;\n     cstore.iter_crate_data(|cnum, _| {\n         let libs = csearch::get_native_libraries(cstore, cnum);"}, {"sha": "b42e8f1b92e2cede46d5347cab6d0983f0b947f6", "filename": "src/librustc/back/lto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flto.rs?ref=4fae06824ce1a3de3d24677196bf2e0d53346830", "patch": "@@ -18,7 +18,7 @@ use util::common::time;\n use std::libc;\n use flate;\n \n-pub fn run(sess: session::Session, llmod: ModuleRef,\n+pub fn run(sess: &session::Session, llmod: ModuleRef,\n            tm: TargetMachineRef, reachable: &[~str]) {\n     if sess.opts.cg.prefer_dynamic {\n         sess.err(\"cannot prefer dynamic linking when performing LTO\");"}, {"sha": "e4052f8cd6f0ffd610e1f72b1b3c31b68ca74b49", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=4fae06824ce1a3de3d24677196bf2e0d53346830", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n \n-use driver::session;\n+use driver::session::Session;\n use metadata::cstore;\n use metadata::filesearch;\n \n@@ -22,7 +22,7 @@ fn not_win32(os: abi::Os) -> bool {\n   os != abi::OsWin32\n }\n \n-pub fn get_rpath_flags(sess: session::Session, out_filename: &Path) -> Vec<~str> {\n+pub fn get_rpath_flags(sess: &Session, out_filename: &Path) -> Vec<~str> {\n     let os = sess.targ_cfg.os;\n \n     // No rpath on windows\n@@ -54,7 +54,7 @@ pub fn get_rpath_flags(sess: session::Session, out_filename: &Path) -> Vec<~str>\n     flags\n }\n \n-fn get_sysroot_absolute_rt_lib(sess: session::Session) -> Path {\n+fn get_sysroot_absolute_rt_lib(sess: &Session) -> Path {\n     let r = filesearch::relative_target_lib_path(sess.opts.target_triple);\n     let mut p = sess.filesearch.sysroot.join(&r);\n     p.push(os::dll_filename(\"rustrt\"));"}, {"sha": "592226a76be7c5b76b39cd766e2c18802ec4cf40", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 59, "deletions": 56, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=4fae06824ce1a3de3d24677196bf2e0d53346830", "patch": "@@ -13,7 +13,7 @@ use back::link;\n use back::{arm, x86, x86_64, mips};\n use driver::session::{Aggressive, CrateTypeExecutable, CrateType,\n                       FullDebugInfo, LimitedDebugInfo, NoDebugInfo};\n-use driver::session::{Session, Session_, No, Less, Default};\n+use driver::session::{Session, No, Less, Default};\n use driver::session;\n use front;\n use lib::llvm::llvm;\n@@ -80,7 +80,7 @@ pub fn source_name(input: &Input) -> ~str {\n     }\n }\n \n-pub fn default_configuration(sess: Session) ->\n+pub fn default_configuration(sess: &Session) ->\n    ast::CrateConfig {\n     let tos = match sess.targ_cfg.os {\n         abi::OsWin32 =>   InternedString::new(\"win32\"),\n@@ -123,7 +123,7 @@ pub fn append_configuration(cfg: &mut ast::CrateConfig,\n     }\n }\n \n-pub fn build_configuration(sess: Session) -> ast::CrateConfig {\n+pub fn build_configuration(sess: &Session) -> ast::CrateConfig {\n     // Combine the configuration requested by the session (command line) with\n     // some default and generated configuration items\n     let default_cfg = default_configuration(sess);\n@@ -170,7 +170,7 @@ impl Input {\n     }\n }\n \n-pub fn phase_1_parse_input(sess: Session, cfg: ast::CrateConfig, input: &Input)\n+pub fn phase_1_parse_input(sess: &Session, cfg: ast::CrateConfig, input: &Input)\n     -> ast::Crate {\n     let krate = time(sess.time_passes(), \"parsing\", (), |_| {\n         match *input {\n@@ -206,15 +206,15 @@ pub fn phase_1_parse_input(sess: Session, cfg: ast::CrateConfig, input: &Input)\n /// syntax expansion, secondary `cfg` expansion, synthesis of a test\n /// harness if one is to be provided and injection of a dependency on the\n /// standard library and prelude.\n-pub fn phase_2_configure_and_expand(sess: Session,\n+pub fn phase_2_configure_and_expand(sess: &Session,\n                                     loader: &mut CrateLoader,\n                                     mut krate: ast::Crate,\n                                     crate_id: &CrateId)\n                                     -> (ast::Crate, syntax::ast_map::Map) {\n     let time_passes = sess.time_passes();\n \n     sess.building_library.set(session::building_library(sess.opts, &krate));\n-    sess.crate_types.set(session::collect_crate_types(&sess,\n+    sess.crate_types.set(session::collect_crate_types(sess,\n                                                       krate.attrs\n                                                            .as_slice()));\n \n@@ -289,12 +289,12 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n     let time_passes = sess.time_passes();\n \n     time(time_passes, \"external crate/lib resolution\", (), |_|\n-         creader::read_crates(sess, krate,\n+         creader::read_crates(&sess, krate,\n                               session::sess_os_to_meta_os(sess.targ_cfg.os),\n                               token::get_ident_interner()));\n \n     let lang_items = time(time_passes, \"language item collection\", (), |_|\n-                          middle::lang_items::collect_language_items(krate, sess));\n+                          middle::lang_items::collect_language_items(krate, &sess));\n \n     let middle::resolve::CrateMap {\n         def_map: def_map,\n@@ -304,13 +304,13 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n         last_private_map: last_private_map\n     } =\n         time(time_passes, \"resolution\", (), |_|\n-             middle::resolve::resolve_crate(sess, lang_items, krate));\n+             middle::resolve::resolve_crate(&sess, lang_items, krate));\n \n     let named_region_map = time(time_passes, \"lifetime resolution\", (),\n-                                |_| middle::resolve_lifetime::krate(sess, krate));\n+                                |_| middle::resolve_lifetime::krate(&sess, krate));\n \n     time(time_passes, \"looking for entry point\", (),\n-         |_| middle::entry::find_entry_point(sess, krate, &ast_map));\n+         |_| middle::entry::find_entry_point(&sess, krate, &ast_map));\n \n     sess.macro_registrar_fn.with_mut(|r| *r =\n         time(time_passes, \"looking for macro registrar\", (), |_|\n@@ -321,7 +321,7 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n                         freevars::annotate_freevars(def_map, krate));\n \n     let region_map = time(time_passes, \"region resolution\", (), |_|\n-                          middle::region::resolve_crate(sess, krate));\n+                          middle::region::resolve_crate(&sess, krate));\n \n     let ty_cx = ty::mk_ctxt(sess, def_map, named_region_map, ast_map,\n                             freevars, region_map, lang_items);\n@@ -337,8 +337,7 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n          middle::const_eval::process_crate(krate, ty_cx));\n \n     time(time_passes, \"const checking\", (), |_|\n-         middle::check_const::check_crate(sess, krate, def_map,\n-                                          method_map, ty_cx));\n+         middle::check_const::check_crate(krate, def_map, method_map, ty_cx));\n \n     let maps = (external_exports, last_private_map);\n     let (exported_items, public_items) =\n@@ -418,17 +417,16 @@ pub struct CrateTranslation {\n \n /// Run the translation phase to LLVM, after which the AST and analysis can\n /// be discarded.\n-pub fn phase_4_translate_to_llvm(sess: Session,\n-                                 krate: ast::Crate,\n+pub fn phase_4_translate_to_llvm(krate: ast::Crate,\n                                  analysis: &CrateAnalysis,\n                                  outputs: &OutputFilenames) -> CrateTranslation {\n-    time(sess.time_passes(), \"translation\", krate, |krate|\n-         trans::base::trans_crate(sess, krate, analysis, outputs))\n+    time(analysis.ty_cx.sess.time_passes(), \"translation\", krate, |krate|\n+         trans::base::trans_crate(krate, analysis, outputs))\n }\n \n /// Run LLVM itself, producing a bitcode file, assembly file or object file\n /// as a side effect.\n-pub fn phase_5_run_llvm_passes(sess: Session,\n+pub fn phase_5_run_llvm_passes(sess: &Session,\n                                trans: &CrateTranslation,\n                                outputs: &OutputFilenames) {\n     if sess.opts.cg.no_integrated_as {\n@@ -454,7 +452,7 @@ pub fn phase_5_run_llvm_passes(sess: Session,\n \n /// Run the linker on any artifacts that resulted from the LLVM run.\n /// This should produce either a finished executable or library.\n-pub fn phase_6_link_output(sess: Session,\n+pub fn phase_6_link_output(sess: &Session,\n                            trans: &CrateTranslation,\n                            outputs: &OutputFilenames) {\n     time(sess.time_passes(), \"linking\", (), |_|\n@@ -464,15 +462,15 @@ pub fn phase_6_link_output(sess: Session,\n                            &trans.link.crateid));\n }\n \n-pub fn stop_after_phase_3(sess: Session) -> bool {\n+pub fn stop_after_phase_3(sess: &Session) -> bool {\n    if sess.opts.no_trans {\n         debug!(\"invoked with --no-trans, returning early from compile_input\");\n         return true;\n     }\n     return false;\n }\n \n-pub fn stop_after_phase_1(sess: Session) -> bool {\n+pub fn stop_after_phase_1(sess: &Session) -> bool {\n     if sess.opts.parse_only {\n         debug!(\"invoked with --parse-only, returning early from compile_input\");\n         return true;\n@@ -483,23 +481,23 @@ pub fn stop_after_phase_1(sess: Session) -> bool {\n     return sess.opts.debugging_opts & session::AST_JSON_NOEXPAND != 0;\n }\n \n-pub fn stop_after_phase_2(sess: Session) -> bool {\n+pub fn stop_after_phase_2(sess: &Session) -> bool {\n     if sess.opts.no_analysis {\n         debug!(\"invoked with --no-analysis, returning early from compile_input\");\n         return true;\n     }\n     return sess.opts.debugging_opts & session::AST_JSON != 0;\n }\n \n-pub fn stop_after_phase_5(sess: Session) -> bool {\n+pub fn stop_after_phase_5(sess: &Session) -> bool {\n     if !sess.opts.output_types.iter().any(|&i| i == link::OutputTypeExe) {\n         debug!(\"not building executable, returning early from compile_input\");\n         return true;\n     }\n     return false;\n }\n \n-fn write_out_deps(sess: Session,\n+fn write_out_deps(sess: &Session,\n                   input: &Input,\n                   outputs: &OutputFilenames,\n                   krate: &ast::Crate) -> io::IoResult<()> {\n@@ -512,7 +510,7 @@ fn write_out_deps(sess: Session,\n             link::OutputTypeExe => {\n                 let crate_types = sess.crate_types.borrow();\n                 for output in crate_types.get().iter() {\n-                    let p = link::filename_for_input(&sess, *output, &id, &file);\n+                    let p = link::filename_for_input(sess, *output, &id, &file);\n                     out_filenames.push(p);\n                 }\n             }\n@@ -566,33 +564,35 @@ pub fn compile_input(sess: Session, cfg: ast::CrateConfig, input: &Input,\n     // We need nested scopes here, because the intermediate results can keep\n     // large chunks of memory alive and we want to free them as soon as\n     // possible to keep the peak memory usage low\n-    let outputs;\n-    let trans = {\n-        let (expanded_crate, ast_map) = {\n-            let krate = phase_1_parse_input(sess, cfg, input);\n-            if stop_after_phase_1(sess) { return; }\n-            outputs = build_output_filenames(input,\n-                                             outdir,\n-                                             output,\n-                                             krate.attrs.as_slice(),\n-                                             sess);\n-            let loader = &mut Loader::new(sess);\n+    let (outputs, trans, sess) = {\n+        let (outputs, expanded_crate, ast_map) = {\n+            let krate = phase_1_parse_input(&sess, cfg, input);\n+            if stop_after_phase_1(&sess) { return; }\n+            let outputs = build_output_filenames(input,\n+                                                 outdir,\n+                                                 output,\n+                                                 krate.attrs.as_slice(),\n+                                                 &sess);\n+            let loader = &mut Loader::new(&sess);\n             let id = link::find_crate_id(krate.attrs.as_slice(),\n                                          outputs.out_filestem);\n-            phase_2_configure_and_expand(sess, loader, krate, &id)\n+            let (expanded_crate, ast_map) = phase_2_configure_and_expand(&sess, loader,\n+                                                                         krate, &id);\n+            (outputs, expanded_crate, ast_map)\n         };\n+        write_out_deps(&sess, input, &outputs, &expanded_crate).unwrap();\n \n-        write_out_deps(sess, input, &outputs, &expanded_crate).unwrap();\n-\n-        if stop_after_phase_2(sess) { return; }\n+        if stop_after_phase_2(&sess) { return; }\n \n         let analysis = phase_3_run_analysis_passes(sess, &expanded_crate, ast_map);\n-        if stop_after_phase_3(sess) { return; }\n-        phase_4_translate_to_llvm(sess, expanded_crate, &analysis, &outputs)\n+        if stop_after_phase_3(&analysis.ty_cx.sess) { return; }\n+        let trans = phase_4_translate_to_llvm(expanded_crate,\n+                                              &analysis, &outputs);\n+        (outputs, trans, analysis.ty_cx.sess)\n     };\n-    phase_5_run_llvm_passes(sess, &trans, &outputs);\n-    if stop_after_phase_5(sess) { return; }\n-    phase_6_link_output(sess, &trans, &outputs);\n+    phase_5_run_llvm_passes(&sess, &trans, &outputs);\n+    if stop_after_phase_5(&sess) { return; }\n+    phase_6_link_output(&sess, &trans, &outputs);\n }\n \n struct IdentifiedAnnotation;\n@@ -660,19 +660,22 @@ pub fn pretty_print_input(sess: Session,\n                           cfg: ast::CrateConfig,\n                           input: &Input,\n                           ppm: PpMode) {\n-    let krate = phase_1_parse_input(sess, cfg, input);\n+    let krate = phase_1_parse_input(&sess, cfg, input);\n     let id = link::find_crate_id(krate.attrs.as_slice(), input.filestem());\n \n     let (krate, ast_map, is_expanded) = match ppm {\n         PpmExpanded | PpmExpandedIdentified | PpmTyped => {\n-            let loader = &mut Loader::new(sess);\n-            let (krate, ast_map) = phase_2_configure_and_expand(sess, loader,\n+            let loader = &mut Loader::new(&sess);\n+            let (krate, ast_map) = phase_2_configure_and_expand(&sess, loader,\n                                                                 krate, &id);\n             (krate, Some(ast_map), true)\n         }\n         _ => (krate, None, false)\n     };\n \n+    let codemap = sess.codemap;\n+    let span_diagnostic = sess.span_diagnostic;\n+\n     let annotation = match ppm {\n         PpmIdentified | PpmExpandedIdentified => {\n             ~IdentifiedAnnotation as ~pprust::PpAnn\n@@ -687,11 +690,11 @@ pub fn pretty_print_input(sess: Session,\n         _ => ~pprust::NoAnn as ~pprust::PpAnn:,\n     };\n \n-    let src = &sess.codemap.get_filemap(source_name(input)).src;\n+    let src = &codemap.get_filemap(source_name(input)).src;\n     let mut rdr = MemReader::new(src.as_bytes().to_owned());\n     let stdout = io::stdout();\n-    pprust::print_crate(sess.codemap,\n-                        sess.span_diagnostic,\n+    pprust::print_crate(codemap,\n+                        span_diagnostic,\n                         &krate,\n                         source_name(input),\n                         &mut rdr,\n@@ -1020,7 +1023,7 @@ pub fn build_session_(sopts: @session::Options,\n         }\n     );\n \n-    @Session_ {\n+    Session {\n         targ_cfg: target_cfg,\n         opts: sopts,\n         cstore: cstore,\n@@ -1043,7 +1046,7 @@ pub fn build_session_(sopts: @session::Options,\n     }\n }\n \n-pub fn parse_pretty(sess: Session, name: &str) -> PpMode {\n+pub fn parse_pretty(sess: &Session, name: &str) -> PpMode {\n     match name {\n       &\"normal\" => PpmNormal,\n       &\"expanded\" => PpmExpanded,\n@@ -1143,7 +1146,7 @@ pub fn build_output_filenames(input: &Input,\n                               odir: &Option<Path>,\n                               ofile: &Option<Path>,\n                               attrs: &[ast::Attribute],\n-                              sess: Session)\n+                              sess: &Session)\n                            -> OutputFilenames {\n     match *ofile {\n         None => {\n@@ -1196,7 +1199,7 @@ pub fn early_error(msg: &str) -> ! {\n     fail!(diagnostic::FatalError);\n }\n \n-pub fn list_metadata(sess: Session, path: &Path,\n+pub fn list_metadata(sess: &Session, path: &Path,\n                      out: &mut io::Writer) -> io::IoResult<()> {\n     metadata::loader::list_file_metadata(\n         session::sess_os_to_meta_os(sess.targ_cfg.os), path, out)"}, {"sha": "76f6999ae75eb98b8932f117a01a2227039b442d", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=4fae06824ce1a3de3d24677196bf2e0d53346830", "patch": "@@ -173,7 +173,7 @@ pub enum CrateType {\n     CrateTypeStaticlib,\n }\n \n-pub struct Session_ {\n+pub struct Session {\n     targ_cfg: @Config,\n     opts: @Options,\n     cstore: @metadata::cstore::CStore,\n@@ -201,9 +201,7 @@ pub struct Session_ {\n     recursion_limit: Cell<uint>,\n }\n \n-pub type Session = @Session_;\n-\n-impl Session_ {\n+impl Session {\n     pub fn span_fatal(&self, sp: Span, msg: &str) -> ! {\n         self.span_diagnostic.span_fatal(sp, msg)\n     }\n@@ -451,7 +449,7 @@ cgoptions!(\n )\n \n // Seems out of place, but it uses session, so I'm putting it here\n-pub fn expect<T:Clone>(sess: Session, opt: Option<T>, msg: || -> ~str) -> T {\n+pub fn expect<T:Clone>(sess: &Session, opt: Option<T>, msg: || -> ~str) -> T {\n     diagnostic::expect(sess.diagnostic(), opt, msg)\n }\n "}, {"sha": "f7c919131a80939eb1a1e8bb78184b6d18c2f98e", "filename": "src/librustc/front/assign_node_ids_and_map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Ffront%2Fassign_node_ids_and_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Ffront%2Fassign_node_ids_and_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fassign_node_ids_and_map.rs?ref=4fae06824ce1a3de3d24677196bf2e0d53346830", "patch": "@@ -13,17 +13,17 @@ use driver::session::Session;\n use syntax::ast;\n use syntax::ast_map;\n \n-struct NodeIdAssigner {\n-    sess: Session\n+struct NodeIdAssigner<'a> {\n+    sess: &'a Session\n }\n \n-impl ast_map::FoldOps for NodeIdAssigner {\n+impl<'a> ast_map::FoldOps for NodeIdAssigner<'a> {\n     fn new_id(&self, old_id: ast::NodeId) -> ast::NodeId {\n         assert_eq!(old_id, ast::DUMMY_NODE_ID);\n         self.sess.next_node_id()\n     }\n }\n \n-pub fn assign_node_ids_and_map(sess: Session, krate: ast::Crate) -> (ast::Crate, ast_map::Map) {\n+pub fn assign_node_ids_and_map(sess: &Session, krate: ast::Crate) -> (ast::Crate, ast_map::Map) {\n     ast_map::map_crate(krate, NodeIdAssigner { sess: sess })\n }"}, {"sha": "99de2060eeecf295218d13d953eb1169951bf4aa", "filename": "src/librustc/front/feature_gate.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ffeature_gate.rs?ref=4fae06824ce1a3de3d24677196bf2e0d53346830", "patch": "@@ -86,12 +86,12 @@ impl Features {\n     }\n }\n \n-struct Context {\n-    features: Vec<&'static str> ,\n-    sess: Session,\n+struct Context<'a> {\n+    features: Vec<&'static str>,\n+    sess: &'a Session,\n }\n \n-impl Context {\n+impl<'a> Context<'a> {\n     fn gate_feature(&self, feature: &str, span: Span, explain: &str) {\n         if !self.has_feature(feature) {\n             self.sess.span_err(span, explain);\n@@ -114,7 +114,7 @@ impl Context {\n     }\n }\n \n-impl Visitor<()> for Context {\n+impl<'a> Visitor<()> for Context<'a> {\n     fn visit_ident(&mut self, sp: Span, id: ast::Ident, _: ()) {\n         if !token::get_ident(id).get().is_ascii() {\n             self.gate_feature(\"non_ascii_idents\", sp,\n@@ -293,7 +293,7 @@ impl Visitor<()> for Context {\n     }\n }\n \n-pub fn check_crate(sess: Session, krate: &ast::Crate) {\n+pub fn check_crate(sess: &Session, krate: &ast::Crate) {\n     let mut cx = Context {\n         features: Vec::new(),\n         sess: sess,"}, {"sha": "36db4e422c11d2bc679e490d5102f5e615d7696d", "filename": "src/librustc/front/show_span.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Ffront%2Fshow_span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Ffront%2Fshow_span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fshow_span.rs?ref=4fae06824ce1a3de3d24677196bf2e0d53346830", "patch": "@@ -19,18 +19,18 @@ use syntax::visit::Visitor;\n \n use driver::session::Session;\n \n-struct ShowSpanVisitor {\n-    sess: Session\n+struct ShowSpanVisitor<'a> {\n+    sess: &'a Session\n }\n \n-impl Visitor<()> for ShowSpanVisitor {\n+impl<'a> Visitor<()> for ShowSpanVisitor<'a> {\n     fn visit_expr(&mut self, e: &ast::Expr, _: ()) {\n         self.sess.span_note(e.span, \"expression\");\n         visit::walk_expr(self, e, ());\n     }\n }\n \n-pub fn run(sess: Session, krate: &ast::Crate) {\n+pub fn run(sess: &Session, krate: &ast::Crate) {\n     let mut v = ShowSpanVisitor { sess: sess };\n     visit::walk_crate(&mut v, krate, ());\n }"}, {"sha": "407476461673f3aa0eea74b1e58cb9a3e0b66078", "filename": "src/librustc/front/std_inject.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fstd_inject.rs?ref=4fae06824ce1a3de3d24677196bf2e0d53346830", "patch": "@@ -26,7 +26,7 @@ use syntax::util::small_vector::SmallVector;\n \n pub static VERSION: &'static str = \"0.10-pre\";\n \n-pub fn maybe_inject_crates_ref(sess: Session, krate: ast::Crate)\n+pub fn maybe_inject_crates_ref(sess: &Session, krate: ast::Crate)\n                                -> ast::Crate {\n     if use_std(&krate) {\n         inject_crates_ref(sess, krate)\n@@ -35,7 +35,7 @@ pub fn maybe_inject_crates_ref(sess: Session, krate: ast::Crate)\n     }\n }\n \n-pub fn maybe_inject_prelude(sess: Session, krate: ast::Crate) -> ast::Crate {\n+pub fn maybe_inject_prelude(sess: &Session, krate: ast::Crate) -> ast::Crate {\n     if use_std(&krate) {\n         inject_prelude(sess, krate)\n     } else {\n@@ -55,8 +55,8 @@ fn no_prelude(attrs: &[ast::Attribute]) -> bool {\n     attr::contains_name(attrs, \"no_implicit_prelude\")\n }\n \n-struct StandardLibraryInjector {\n-    sess: Session,\n+struct StandardLibraryInjector<'a> {\n+    sess: &'a Session,\n }\n \n pub fn with_version(krate: &str) -> Option<(InternedString, ast::StrStyle)> {\n@@ -71,7 +71,7 @@ pub fn with_version(krate: &str) -> Option<(InternedString, ast::StrStyle)> {\n     }\n }\n \n-impl fold::Folder for StandardLibraryInjector {\n+impl<'a> fold::Folder for StandardLibraryInjector<'a> {\n     fn fold_crate(&mut self, krate: ast::Crate) -> ast::Crate {\n         let mut vis = vec!(ast::ViewItem {\n             node: ast::ViewItemExternCrate(token::str_to_ident(\"std\"),\n@@ -120,19 +120,19 @@ impl fold::Folder for StandardLibraryInjector {\n     }\n }\n \n-fn inject_crates_ref(sess: Session, krate: ast::Crate) -> ast::Crate {\n+fn inject_crates_ref(sess: &Session, krate: ast::Crate) -> ast::Crate {\n     let mut fold = StandardLibraryInjector {\n         sess: sess,\n     };\n     fold.fold_crate(krate)\n }\n \n-struct PreludeInjector {\n-    sess: Session,\n+struct PreludeInjector<'a> {\n+    sess: &'a Session,\n }\n \n \n-impl fold::Folder for PreludeInjector {\n+impl<'a> fold::Folder for PreludeInjector<'a> {\n     fn fold_crate(&mut self, krate: ast::Crate) -> ast::Crate {\n         if !no_prelude(krate.attrs.as_slice()) {\n             // only add `use std::prelude::*;` if there wasn't a\n@@ -193,7 +193,7 @@ impl fold::Folder for PreludeInjector {\n     }\n }\n \n-fn inject_prelude(sess: Session, krate: ast::Crate) -> ast::Crate {\n+fn inject_prelude(sess: &Session, krate: ast::Crate) -> ast::Crate {\n     let mut fold = PreludeInjector {\n         sess: sess,\n     };"}, {"sha": "d79bdeb7884046aff782d3745fb07d6983030a87", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=4fae06824ce1a3de3d24677196bf2e0d53346830", "patch": "@@ -13,7 +13,7 @@\n #[allow(dead_code)];\n #[allow(unused_imports)];\n \n-use driver::session;\n+use driver::session::Session;\n use front::config;\n use front::std_inject::with_version;\n use metadata::creader::Loader;\n@@ -47,8 +47,8 @@ struct Test {\n }\n \n struct TestCtxt<'a> {\n-    sess: session::Session,\n-    path: RefCell<Vec<ast::Ident> >,\n+    sess: &'a Session,\n+    path: RefCell<Vec<ast::Ident>>,\n     ext_cx: ExtCtxt<'a>,\n     testfns: RefCell<Vec<Test> >,\n     is_test_crate: bool,\n@@ -57,7 +57,7 @@ struct TestCtxt<'a> {\n \n // Traverse the crate, collecting all the test functions, eliding any\n // existing main functions, and synthesizing a main test harness\n-pub fn modify_for_testing(sess: session::Session,\n+pub fn modify_for_testing(sess: &Session,\n                           krate: ast::Crate) -> ast::Crate {\n     // We generate the test harness when building in the 'test'\n     // configuration, either with the '--test' or '--cfg test'\n@@ -161,7 +161,7 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n     }\n }\n \n-fn generate_test_harness(sess: session::Session, krate: ast::Crate)\n+fn generate_test_harness(sess: &Session, krate: ast::Crate)\n                          -> ast::Crate {\n     let loader = &mut Loader::new(sess);\n     let mut cx: TestCtxt = TestCtxt {"}, {"sha": "8e8aee55648337ca98dffe4f7d332c5098cc90e4", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=4fae06824ce1a3de3d24677196bf2e0d53346830", "patch": "@@ -290,9 +290,9 @@ pub fn run_compiler(args: &[~str]) {\n     let sess = d::build_session(sopts, input_file_path);\n     let odir = matches.opt_str(\"out-dir\").map(|o| Path::new(o));\n     let ofile = matches.opt_str(\"o\").map(|o| Path::new(o));\n-    let cfg = d::build_configuration(sess);\n+    let cfg = d::build_configuration(&sess);\n     let pretty = matches.opt_default(\"pretty\", \"normal\").map(|a| {\n-        d::parse_pretty(sess, a)\n+        d::parse_pretty(&sess, a)\n     });\n     match pretty {\n       Some::<d::PpMode>(ppm) => {\n@@ -306,7 +306,7 @@ pub fn run_compiler(args: &[~str]) {\n         match input {\n           d::FileInput(ref ifile) => {\n             let mut stdout = io::stdout();\n-            d::list_metadata(sess, &(*ifile), &mut stdout).unwrap();\n+            d::list_metadata(&sess, &(*ifile), &mut stdout).unwrap();\n           }\n           d::StrInput(_) => {\n             d::early_error(\"can not list metadata for stdin\");\n@@ -317,9 +317,9 @@ pub fn run_compiler(args: &[~str]) {\n     let (crate_id, crate_name, crate_file_name) = sopts.print_metas;\n     // these nasty nested conditions are to avoid doing extra work\n     if crate_id || crate_name || crate_file_name {\n-        let attrs = parse_crate_attrs(sess, &input);\n+        let attrs = parse_crate_attrs(&sess, &input);\n         let t_outputs = d::build_output_filenames(&input, &odir, &ofile,\n-                                                  attrs.as_slice(), sess);\n+                                                  attrs.as_slice(), &sess);\n         let id = link::find_crate_id(attrs.as_slice(), t_outputs.out_filestem);\n \n         if crate_id {\n@@ -344,7 +344,7 @@ pub fn run_compiler(args: &[~str]) {\n     d::compile_input(sess, cfg, &input, &odir, &ofile);\n }\n \n-fn parse_crate_attrs(sess: session::Session, input: &d::Input) ->\n+fn parse_crate_attrs(sess: &session::Session, input: &d::Input) ->\n                      Vec<ast::Attribute> {\n     let result = match *input {\n         d::FileInput(ref ifile) => {"}, {"sha": "5c81b6227044ba1d9ee68a4d9db7b97b2ce2f79f", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 12, "deletions": 21, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=4fae06824ce1a3de3d24677196bf2e0d53346830", "patch": "@@ -39,7 +39,7 @@ use syntax::visit;\n \n // Traverses an AST, reading all the information about use'd crates and extern\n // libraries necessary for later resolving, typechecking, linking, etc.\n-pub fn read_crates(sess: Session,\n+pub fn read_crates(sess: &Session,\n                    krate: &ast::Crate,\n                    os: loader::Os,\n                    intr: @IdentInterner) {\n@@ -51,30 +51,21 @@ pub fn read_crates(sess: Session,\n         intr: intr\n     };\n     visit_crate(&e, krate);\n-    {\n-        let mut v = ReadCrateVisitor {\n-            e: &mut e\n-        };\n-        visit::walk_crate(&mut v, krate, ());\n-    }\n+    visit::walk_crate(&mut e, krate, ());\n     let crate_cache = e.crate_cache.borrow();\n     dump_crates(crate_cache.get().as_slice());\n     warn_if_multiple_versions(&mut e,\n                               sess.diagnostic(),\n                               crate_cache.get().as_slice());\n }\n \n-struct ReadCrateVisitor<'a> {\n-    e: &'a mut Env,\n-}\n-\n-impl<'a> visit::Visitor<()> for ReadCrateVisitor<'a> {\n+impl<'a> visit::Visitor<()> for Env<'a> {\n     fn visit_view_item(&mut self, a: &ast::ViewItem, _: ()) {\n-        visit_view_item(self.e, a);\n+        visit_view_item(self, a);\n         visit::walk_view_item(self, a, ());\n     }\n     fn visit_item(&mut self, a: &ast::Item, _: ()) {\n-        visit_item(self.e, a);\n+        visit_item(self, a);\n         visit::walk_item(self, a, ());\n     }\n }\n@@ -120,8 +111,8 @@ fn warn_if_multiple_versions(e: &mut Env,\n     }\n }\n \n-struct Env {\n-    sess: Session,\n+struct Env<'a> {\n+    sess: &'a Session,\n     os: loader::Os,\n     crate_cache: @RefCell<Vec<cache_entry>>,\n     next_crate_num: ast::CrateNum,\n@@ -391,12 +382,12 @@ fn resolve_crate_deps(e: &mut Env,\n     return @RefCell::new(cnum_map);\n }\n \n-pub struct Loader {\n-    priv env: Env,\n+pub struct Loader<'a> {\n+    priv env: Env<'a>,\n }\n \n-impl Loader {\n-    pub fn new(sess: Session) -> Loader {\n+impl<'a> Loader<'a> {\n+    pub fn new(sess: &'a Session) -> Loader<'a> {\n         let os = driver::get_os(driver::host_triple()).unwrap();\n         let os = session::sess_os_to_meta_os(os);\n         Loader {\n@@ -411,7 +402,7 @@ impl Loader {\n     }\n }\n \n-impl CrateLoader for Loader {\n+impl<'a> CrateLoader for Loader<'a> {\n     fn load_crate(&mut self, krate: &ast::ViewItem) -> MacroCrate {\n         let info = extract_crate_info(&self.env, krate).unwrap();\n         let cnum = resolve_crate(&mut self.env, None, info.ident,"}, {"sha": "e26759e2b3b616cca9aee3be31a0b4656aa5e992", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=4fae06824ce1a3de3d24677196bf2e0d53346830", "patch": "@@ -46,7 +46,7 @@ pub enum Os {\n }\n \n pub struct Context<'a> {\n-    sess: Session,\n+    sess: &'a Session,\n     span: Span,\n     ident: &'a str,\n     crate_id: &'a CrateId,"}, {"sha": "3ab44789838bc6b2b9c810af092198866c865485", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=4fae06824ce1a3de3d24677196bf2e0d53346830", "patch": "@@ -137,7 +137,7 @@ pub fn decode_inlined_item(cdata: @cstore::crate_metadata,\n         });\n         let mut ast_dsr = reader::Decoder(ast_doc);\n         let from_id_range = Decodable::decode(&mut ast_dsr);\n-        let to_id_range = reserve_id_range(dcx.tcx.sess, from_id_range);\n+        let to_id_range = reserve_id_range(&dcx.tcx.sess, from_id_range);\n         let xcx = @ExtendedDecodeContext {\n             dcx: dcx,\n             from_id_range: from_id_range,\n@@ -154,7 +154,7 @@ pub fn decode_inlined_item(cdata: @cstore::crate_metadata,\n         debug!(\"< Decoded inlined fn: {}::{}\",\n                path_as_str.unwrap(),\n                token::get_ident(ident));\n-        region::resolve_inlined_item(tcx.sess, &tcx.region_maps, &ii);\n+        region::resolve_inlined_item(&tcx.sess, &tcx.region_maps, &ii);\n         decode_side_tables(xcx, ast_doc);\n         match ii {\n           ast::IIItem(i) => {\n@@ -178,7 +178,7 @@ pub fn decode_exported_macro(par_doc: ebml::Doc) -> @ast::Item {\n // ______________________________________________________________________\n // Enumerating the IDs which appear in an AST\n \n-fn reserve_id_range(sess: Session,\n+fn reserve_id_range(sess: &Session,\n                     from_id_range: ast_util::IdRange) -> ast_util::IdRange {\n     // Handle the case of an empty range:\n     if from_id_range.empty() { return from_id_range; }"}, {"sha": "70d440e49e06da08a68d0fd5a08dc82d0937f6ec", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 33, "deletions": 52, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=4fae06824ce1a3de3d24677196bf2e0d53346830", "patch": "@@ -22,49 +22,41 @@ use syntax::visit::Visitor;\n use syntax::visit;\n \n pub struct CheckCrateVisitor {\n-    sess: Session,\n     def_map: resolve::DefMap,\n     method_map: typeck::MethodMap,\n     tcx: ty::ctxt,\n }\n \n impl Visitor<bool> for CheckCrateVisitor {\n     fn visit_item(&mut self, i: &Item, env: bool) {\n-        check_item(self, self.sess, self.def_map, i, env);\n+        check_item(self, i, env);\n     }\n     fn visit_pat(&mut self, p: &Pat, env: bool) {\n         check_pat(self, p, env);\n     }\n     fn visit_expr(&mut self, ex: &Expr, env: bool) {\n-        check_expr(self, self.sess, self.def_map, self.method_map,\n-                   self.tcx, ex, env);\n+        check_expr(self, ex, env);\n     }\n }\n \n-pub fn check_crate(sess: Session,\n-                   krate: &Crate,\n+pub fn check_crate(krate: &Crate,\n                    def_map: resolve::DefMap,\n                    method_map: typeck::MethodMap,\n                    tcx: ty::ctxt) {\n     let mut v = CheckCrateVisitor {\n-        sess: sess,\n         def_map: def_map,\n         method_map: method_map,\n         tcx: tcx,\n     };\n     visit::walk_crate(&mut v, krate, false);\n-    sess.abort_if_errors();\n+    tcx.sess.abort_if_errors();\n }\n \n-pub fn check_item(v: &mut CheckCrateVisitor,\n-                  sess: Session,\n-                  def_map: resolve::DefMap,\n-                  it: &Item,\n-                  _is_const: bool) {\n+fn check_item(v: &mut CheckCrateVisitor, it: &Item, _is_const: bool) {\n     match it.node {\n         ItemStatic(_, _, ex) => {\n             v.visit_expr(ex, true);\n-            check_item_recursion(sess, &v.tcx.map, def_map, it);\n+            check_item_recursion(&v.tcx.sess, &v.tcx.map, v.def_map, it);\n         }\n         ItemEnum(ref enum_definition, _) => {\n             for var in (*enum_definition).variants.iter() {\n@@ -77,8 +69,8 @@ pub fn check_item(v: &mut CheckCrateVisitor,\n     }\n }\n \n-pub fn check_pat(v: &mut CheckCrateVisitor, p: &Pat, _is_const: bool) {\n-    fn is_str(e: @Expr) -> bool {\n+fn check_pat(v: &mut CheckCrateVisitor, p: &Pat, _is_const: bool) {\n+    fn is_str(e: &Expr) -> bool {\n         match e.node {\n             ExprVstore(expr, ExprVstoreUniq) => {\n                 match expr.node {\n@@ -100,36 +92,30 @@ pub fn check_pat(v: &mut CheckCrateVisitor, p: &Pat, _is_const: bool) {\n     }\n }\n \n-pub fn check_expr(v: &mut CheckCrateVisitor,\n-                  sess: Session,\n-                  def_map: resolve::DefMap,\n-                  method_map: typeck::MethodMap,\n-                  tcx: ty::ctxt,\n-                  e: &Expr,\n-                  is_const: bool) {\n+fn check_expr(v: &mut CheckCrateVisitor, e: &Expr, is_const: bool) {\n     if is_const {\n         match e.node {\n           ExprUnary(UnDeref, _) => { }\n           ExprUnary(UnBox, _) | ExprUnary(UnUniq, _) => {\n-            sess.span_err(e.span,\n-                          \"cannot do allocations in constant expressions\");\n+            v.tcx.sess.span_err(e.span,\n+                                \"cannot do allocations in constant expressions\");\n             return;\n           }\n           ExprLit(lit) if ast_util::lit_is_str(lit) => {}\n           ExprBinary(..) | ExprUnary(..) => {\n-              let method_call = typeck::MethodCall::expr(e.id);\n-            if method_map.borrow().get().contains_key(&method_call) {\n-                sess.span_err(e.span, \"user-defined operators are not \\\n-                                       allowed in constant expressions\");\n+            let method_call = typeck::MethodCall::expr(e.id);\n+            if v.method_map.borrow().get().contains_key(&method_call) {\n+                v.tcx.sess.span_err(e.span, \"user-defined operators are not \\\n+                                             allowed in constant expressions\");\n             }\n           }\n           ExprLit(_) => (),\n           ExprCast(_, _) => {\n-            let ety = ty::expr_ty(tcx, e);\n+            let ety = ty::expr_ty(v.tcx, e);\n             if !ty::type_is_numeric(ety) && !ty::type_is_unsafe_ptr(ety) {\n-                sess.span_err(e.span, ~\"can not cast to `\" +\n-                              ppaux::ty_to_str(tcx, ety) +\n-                              \"` in a constant expression\");\n+                v.tcx.sess.span_err(e.span, ~\"can not cast to `\" +\n+                                              ppaux::ty_to_str(v.tcx, ety) +\n+                                             \"` in a constant expression\");\n             }\n           }\n           ExprPath(ref pth) => {\n@@ -138,37 +124,33 @@ pub fn check_expr(v: &mut CheckCrateVisitor,\n             // foo::<bar> in a const. Currently that is only done on\n             // a path in trans::callee that only works in block contexts.\n             if !pth.segments.iter().all(|segment| segment.types.is_empty()) {\n-                sess.span_err(\n-                    e.span, \"paths in constants may only refer to \\\n-                             items without type parameters\");\n+                v.tcx.sess.span_err(e.span,\n+                                    \"paths in constants may only refer to \\\n+                                     items without type parameters\");\n             }\n-            let def_map = def_map.borrow();\n-            match def_map.get().find(&e.id) {\n+            match v.def_map.borrow().get().find(&e.id) {\n               Some(&DefStatic(..)) |\n               Some(&DefFn(_, _)) |\n               Some(&DefVariant(_, _, _)) |\n               Some(&DefStruct(_)) => { }\n \n               Some(&def) => {\n                 debug!(\"(checking const) found bad def: {:?}\", def);\n-                sess.span_err(\n-                    e.span,\n+                v.tcx.sess.span_err(e.span,\n                     \"paths in constants may only refer to \\\n                      constants or functions\");\n               }\n               None => {\n-                sess.span_bug(e.span, \"unbound path in const?!\");\n+                v.tcx.sess.span_bug(e.span, \"unbound path in const?!\");\n               }\n             }\n           }\n           ExprCall(callee, _) => {\n-            let def_map = def_map.borrow();\n-            match def_map.get().find(&callee.id) {\n+            match v.def_map.borrow().get().find(&callee.id) {\n                 Some(&DefStruct(..)) => {}    // OK.\n                 Some(&DefVariant(..)) => {}    // OK.\n                 _ => {\n-                    sess.span_err(\n-                        e.span,\n+                    v.tcx.sess.span_err(e.span,\n                         \"function calls in constants are limited to \\\n                          struct and enum constructors\");\n                 }\n@@ -184,18 +166,17 @@ pub fn check_expr(v: &mut CheckCrateVisitor,\n           ExprRepeat(..) |\n           ExprStruct(..) => { }\n           ExprAddrOf(..) => {\n-                sess.span_err(\n-                    e.span,\n+                v.tcx.sess.span_err(e.span,\n                     \"references in constants may only refer to \\\n                      immutable values\");\n           },\n           ExprVstore(_, ExprVstoreUniq) => {\n-              sess.span_err(e.span, \"cannot allocate vectors in constant expressions\")\n+              v.tcx.sess.span_err(e.span, \"cannot allocate vectors in constant expressions\")\n           },\n \n           _ => {\n-            sess.span_err(e.span,\n-                          \"constant contains unimplemented expression type\");\n+            v.tcx.sess.span_err(e.span,\n+                                \"constant contains unimplemented expression type\");\n             return;\n           }\n         }\n@@ -205,14 +186,14 @@ pub fn check_expr(v: &mut CheckCrateVisitor,\n \n struct CheckItemRecursionVisitor<'a> {\n     root_it: &'a Item,\n-    sess: Session,\n+    sess: &'a Session,\n     ast_map: &'a ast_map::Map,\n     def_map: resolve::DefMap,\n     idstack: Vec<NodeId> }\n \n // Make sure a const item doesn't recursively refer to itself\n // FIXME: Should use the dependency graph when it's available (#1356)\n-pub fn check_item_recursion<'a>(sess: Session,\n+pub fn check_item_recursion<'a>(sess: &'a Session,\n                                 ast_map: &'a ast_map::Map,\n                                 def_map: resolve::DefMap,\n                                 it: &'a Item) {"}, {"sha": "88a6f7aa1e24ebb12d354fde0a7d38592035e866", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=4fae06824ce1a3de3d24677196bf2e0d53346830", "patch": "@@ -21,7 +21,7 @@ use syntax::visit;\n use syntax::visit::Visitor;\n \n struct EntryContext<'a> {\n-    session: Session,\n+    session: &'a Session,\n \n     ast_map: &'a ast_map::Map,\n \n@@ -48,7 +48,7 @@ impl<'a> Visitor<()> for EntryContext<'a> {\n     }\n }\n \n-pub fn find_entry_point(session: Session, krate: &Crate, ast_map: &ast_map::Map) {\n+pub fn find_entry_point(session: &Session, krate: &Crate, ast_map: &ast_map::Map) {\n     if session.building_library.get() {\n         // No need to find a main function\n         return;"}, {"sha": "ef1a84fd8869ca14975db0608c5b2ad695d758dc", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=4fae06824ce1a3de3d24677196bf2e0d53346830", "patch": "@@ -103,27 +103,23 @@ impl LanguageItems {\n     )*\n }\n \n-struct LanguageItemCollector {\n+struct LanguageItemCollector<'a> {\n     items: LanguageItems,\n \n-    session: Session,\n+    session: &'a Session,\n \n     item_refs: HashMap<&'static str, uint>,\n }\n \n-struct LanguageItemVisitor<'a> {\n-    this: &'a mut LanguageItemCollector,\n-}\n-\n-impl<'a> Visitor<()> for LanguageItemVisitor<'a> {\n+impl<'a> Visitor<()> for LanguageItemCollector<'a> {\n     fn visit_item(&mut self, item: &ast::Item, _: ()) {\n         match extract(item.attrs.as_slice()) {\n             Some(value) => {\n-                let item_index = self.this.item_refs.find_equiv(&value).map(|x| *x);\n+                let item_index = self.item_refs.find_equiv(&value).map(|x| *x);\n \n                 match item_index {\n                     Some(item_index) => {\n-                        self.this.collect_item(item_index, local_def(item.id))\n+                        self.collect_item(item_index, local_def(item.id))\n                     }\n                     None => {}\n                 }\n@@ -135,8 +131,8 @@ impl<'a> Visitor<()> for LanguageItemVisitor<'a> {\n     }\n }\n \n-impl LanguageItemCollector {\n-    pub fn new(session: Session) -> LanguageItemCollector {\n+impl<'a> LanguageItemCollector<'a> {\n+    pub fn new(session: &'a Session) -> LanguageItemCollector<'a> {\n         let mut item_refs = HashMap::new();\n \n         $( item_refs.insert($name, $variant as uint); )*\n@@ -165,8 +161,7 @@ impl LanguageItemCollector {\n     }\n \n     pub fn collect_local_language_items(&mut self, krate: &ast::Crate) {\n-        let mut v = LanguageItemVisitor { this: self };\n-        visit::walk_crate(&mut v, krate, ());\n+        visit::walk_crate(self, krate, ());\n     }\n \n     pub fn collect_external_language_items(&mut self) {\n@@ -200,7 +195,7 @@ pub fn extract(attrs: &[ast::Attribute]) -> Option<InternedString> {\n }\n \n pub fn collect_language_items(krate: &ast::Crate,\n-                              session: Session) -> @LanguageItems {\n+                              session: &Session) -> @LanguageItems {\n     let mut collector = LanguageItemCollector::new(session);\n     collector.collect(krate);\n     let LanguageItemCollector { items, .. } = collector;"}, {"sha": "10e56f90f6ef921546d49d5f0b7ae94d349de2b7", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=4fae06824ce1a3de3d24677196bf2e0d53346830", "patch": "@@ -530,7 +530,7 @@ impl<'a> Context<'a> {\n         // of what we changed so we can roll everything back after invoking the\n         // specified closure\n         let mut pushed = 0u;\n-        each_lint(self.tcx.sess, attrs, |meta, level, lintname| {\n+        each_lint(&self.tcx.sess, attrs, |meta, level, lintname| {\n             match self.dict.find_equiv(&lintname) {\n                 None => {\n                     self.span_lint(\n@@ -594,7 +594,7 @@ impl<'a> Context<'a> {\n \n // Check that every lint from the list of attributes satisfies `f`.\n // Return true if that's the case. Otherwise return false.\n-pub fn each_lint(sess: session::Session,\n+pub fn each_lint(sess: &session::Session,\n                  attrs: &[ast::Attribute],\n                  f: |@ast::MetaItem, level, InternedString| -> bool)\n                  -> bool {"}, {"sha": "a19b348b78aa0704c1471ad17399dc1112b12699", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=4fae06824ce1a3de3d24677196bf2e0d53346830", "patch": "@@ -92,7 +92,7 @@ pub struct Context {\n }\n \n struct RegionResolutionVisitor<'a> {\n-    sess: Session,\n+    sess: &'a Session,\n \n     // Generated maps:\n     region_maps: &'a RegionMaps,\n@@ -909,7 +909,7 @@ impl<'a> Visitor<Context> for RegionResolutionVisitor<'a> {\n     }\n }\n \n-pub fn resolve_crate(sess: Session, krate: &ast::Crate) -> RegionMaps {\n+pub fn resolve_crate(sess: &Session, krate: &ast::Crate) -> RegionMaps {\n     let maps = RegionMaps {\n         scope_map: RefCell::new(NodeMap::new()),\n         var_map: RefCell::new(NodeMap::new()),\n@@ -928,7 +928,7 @@ pub fn resolve_crate(sess: Session, krate: &ast::Crate) -> RegionMaps {\n     return maps;\n }\n \n-pub fn resolve_inlined_item(sess: Session,\n+pub fn resolve_inlined_item(sess: &Session,\n                             region_maps: &RegionMaps,\n                             item: &ast::InlinedItem) {\n     let cx = Context {parent: None,"}, {"sha": "1641623b9cb327c7aa1ed9195de83771e898eac7", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=4fae06824ce1a3de3d24677196bf2e0d53346830", "patch": "@@ -153,7 +153,7 @@ enum NameDefinition {\n     ImportNameDefinition(Def, LastPrivate) //< The name identifies an import.\n }\n \n-impl Visitor<()> for Resolver {\n+impl<'a> Visitor<()> for Resolver<'a> {\n     fn visit_item(&mut self, item: &Item, _: ()) {\n         self.resolve_item(item);\n     }\n@@ -787,9 +787,9 @@ fn namespace_error_to_str(ns: NamespaceError) -> &'static str {\n     }\n }\n \n-fn Resolver(session: Session,\n-            lang_items: @LanguageItems,\n-            crate_span: Span) -> Resolver {\n+fn Resolver<'a>(session: &'a Session,\n+                lang_items: @LanguageItems,\n+                crate_span: Span) -> Resolver<'a> {\n     let graph_root = @NameBindings();\n \n     graph_root.define_module(NoParentLink,\n@@ -802,7 +802,7 @@ fn Resolver(session: Session,\n     let current_module = graph_root.get_module();\n \n     let this = Resolver {\n-        session: @session,\n+        session: session,\n         lang_items: lang_items,\n \n         // The outermost module has def ID 0; this is not reflected in the\n@@ -843,8 +843,8 @@ fn Resolver(session: Session,\n }\n \n /// The main resolver class.\n-struct Resolver {\n-    session: @Session,\n+struct Resolver<'a> {\n+    session: &'a Session,\n     lang_items: @LanguageItems,\n \n     graph_root: @NameBindings,\n@@ -896,11 +896,11 @@ struct Resolver {\n     used_imports: HashSet<(NodeId, Namespace)>,\n }\n \n-struct BuildReducedGraphVisitor<'a> {\n-    resolver: &'a mut Resolver,\n+struct BuildReducedGraphVisitor<'a, 'b> {\n+    resolver: &'a mut Resolver<'b>,\n }\n \n-impl<'a> Visitor<ReducedGraphParent> for BuildReducedGraphVisitor<'a> {\n+impl<'a, 'b> Visitor<ReducedGraphParent> for BuildReducedGraphVisitor<'a, 'b> {\n \n     fn visit_item(&mut self, item: &Item, context: ReducedGraphParent) {\n         let p = self.resolver.build_reduced_graph_for_item(item, context);\n@@ -928,16 +928,16 @@ impl<'a> Visitor<ReducedGraphParent> for BuildReducedGraphVisitor<'a> {\n \n }\n \n-struct UnusedImportCheckVisitor<'a> { resolver: &'a mut Resolver }\n+struct UnusedImportCheckVisitor<'a, 'b> { resolver: &'a mut Resolver<'b> }\n \n-impl<'a> Visitor<()> for UnusedImportCheckVisitor<'a> {\n+impl<'a, 'b> Visitor<()> for UnusedImportCheckVisitor<'a, 'b> {\n     fn visit_view_item(&mut self, vi: &ViewItem, _: ()) {\n         self.resolver.check_for_item_unused_imports(vi);\n         visit::walk_view_item(self, vi, ());\n     }\n }\n \n-impl Resolver {\n+impl<'a> Resolver<'a> {\n     /// The main name resolution procedure.\n     fn resolve(&mut self, krate: &ast::Crate) {\n         self.build_reduced_graph(krate);\n@@ -5571,7 +5571,7 @@ pub struct CrateMap {\n }\n \n /// Entry point to crate resolution.\n-pub fn resolve_crate(session: Session,\n+pub fn resolve_crate(session: &Session,\n                      lang_items: @LanguageItems,\n                      krate: &Crate)\n                   -> CrateMap {"}, {"sha": "9790b392d0f4734185206f4541263f4733bfa009", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=4fae06824ce1a3de3d24677196bf2e0d53346830", "patch": "@@ -17,7 +17,7 @@\n  * way. Therefore we break lifetime name resolution into a separate pass.\n  */\n \n-use driver::session;\n+use driver::session::Session;\n use std::cell::RefCell;\n use std::vec_ng::Vec;\n use util::nodemap::NodeMap;\n@@ -40,8 +40,8 @@ fn lifetime_show(lt_name: &ast::Name) -> token::InternedString {\n     token::get_name(*lt_name)\n }\n \n-struct LifetimeContext {\n-    sess: session::Session,\n+struct LifetimeContext<'a> {\n+    sess: &'a Session,\n     named_region_map: @RefCell<NamedRegionMap>,\n }\n \n@@ -60,8 +60,7 @@ enum ScopeChain<'a> {\n \n type Scope<'a> = &'a ScopeChain<'a>;\n \n-pub fn krate(sess: session::Session, krate: &ast::Crate)\n-             -> @RefCell<NamedRegionMap> {\n+pub fn krate(sess: &Session, krate: &ast::Crate) -> @RefCell<NamedRegionMap> {\n     let mut ctxt = LifetimeContext {\n         sess: sess,\n         named_region_map: @RefCell::new(NodeMap::new())\n@@ -71,7 +70,7 @@ pub fn krate(sess: session::Session, krate: &ast::Crate)\n     ctxt.named_region_map\n }\n \n-impl<'a> Visitor<Scope<'a>> for LifetimeContext {\n+impl<'a, 'b> Visitor<Scope<'a>> for LifetimeContext<'b> {\n     fn visit_item(&mut self,\n                   item: &ast::Item,\n                   _: Scope<'a>) {\n@@ -181,7 +180,7 @@ impl<'a> ScopeChain<'a> {\n     }\n }\n \n-impl LifetimeContext {\n+impl<'a> LifetimeContext<'a> {\n     /// Visits self by adding a scope and handling recursive walk over the contents with `walk`.\n     fn visit_fn_decl(&mut self,\n                      n: ast::NodeId,"}, {"sha": "2f5173f9c0584503729ec9231372e8ce1dbc167f", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=4fae06824ce1a3de3d24677196bf2e0d53346830", "patch": "@@ -373,7 +373,7 @@ fn variant_opt(bcx: &Block, pat_id: ast::NodeId) -> Opt {\n             return lit(UnitLikeStructLit(pat_id));\n         }\n         _ => {\n-            ccx.sess.bug(\"non-variant or struct in variant_opt()\");\n+            ccx.sess().bug(\"non-variant or struct in variant_opt()\");\n         }\n     }\n }\n@@ -1324,8 +1324,7 @@ fn compare_values<'a>(\n             }\n         }\n         _ => {\n-            cx.tcx().sess.bug(\"only scalars and strings supported in \\\n-                                compare_values\");\n+            cx.sess().bug(\"only scalars and strings supported in compare_values\");\n         }\n     }\n }\n@@ -1585,7 +1584,7 @@ fn compile_submatch_continue<'r,\n         let tup_repr = adt::represent_type(bcx.ccx(), tup_ty);\n         let n_tup_elts = match ty::get(tup_ty).sty {\n           ty::ty_tup(ref elts) => elts.len(),\n-          _ => ccx.sess.bug(\"non-tuple type in tuple pattern\")\n+          _ => ccx.sess().bug(\"non-tuple type in tuple pattern\")\n         };\n         let tup_vals = Vec::from_fn(n_tup_elts, |i| {\n             adt::trans_field_ptr(bcx, tup_repr, val, 0, i)\n@@ -1612,7 +1611,7 @@ fn compile_submatch_continue<'r,\n                     ty::lookup_struct_fields(tcx, struct_id).len();\n             }\n             _ => {\n-                ccx.sess.bug(\"non-struct type in tuple struct pattern\");\n+                ccx.sess().bug(\"non-struct type in tuple struct pattern\");\n             }\n         }\n \n@@ -2093,7 +2092,7 @@ pub fn store_arg<'a>(mut bcx: &'a Block<'a>,\n             // like `x: T`\n             let arg_ty = node_id_type(bcx, pat.id);\n             if type_of::arg_is_indirect(bcx.ccx(), arg_ty)\n-                && bcx.ccx().sess.opts.debuginfo != FullDebugInfo {\n+                && bcx.sess().opts.debuginfo != FullDebugInfo {\n                 // Don't copy an indirect argument to an alloca, the caller\n                 // already put it in a temporary alloca and gave it up, unless\n                 // we emit extra-debug-info, which requires local allocas :(.\n@@ -2297,8 +2296,7 @@ fn bind_irrefutable_pat<'a>(\n             bcx = bind_irrefutable_pat(bcx, inner, loaded_val, binding_mode, cleanup_scope);\n         }\n         ast::PatVec(..) => {\n-            bcx.tcx().sess.span_bug(\n-                pat.span,\n+            bcx.sess().span_bug(pat.span,\n                 format!(\"vector patterns are never irrefutable!\"));\n         }\n         ast::PatWild | ast::PatWildMulti | ast::PatLit(_) | ast::PatRange(_, _) => ()"}, {"sha": "556e78a88f356393108cfe28091ff0b053cd0a80", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=4fae06824ce1a3de3d24677196bf2e0d53346830", "patch": "@@ -177,9 +177,9 @@ fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n             // non-empty body, explicit discriminants should have\n             // been rejected by a checker before this point.\n             if !cases.iter().enumerate().all(|(i,c)| c.discr == (i as Disr)) {\n-                cx.sess.bug(format!(\"non-C-like enum {} with specified \\\n-                                  discriminants\",\n-                                 ty::item_path_str(cx.tcx, def_id)))\n+                cx.sess().bug(format!(\"non-C-like enum {} with specified \\\n+                                      discriminants\",\n+                                      ty::item_path_str(cx.tcx, def_id)))\n             }\n \n             if cases.len() == 1 {\n@@ -230,7 +230,7 @@ fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n                           false)\n             }))\n         }\n-        _ => cx.sess.bug(\"adt::represent_type called on non-ADT type\")\n+        _ => cx.sess().bug(\"adt::represent_type called on non-ADT type\")\n     }\n }\n \n@@ -324,12 +324,12 @@ fn range_to_inttype(cx: &CrateContext, hint: Hint, bounds: &IntBounds) -> IntTyp\n     match hint {\n         attr::ReprInt(span, ity) => {\n             if !bounds_usable(cx, ity, bounds) {\n-                cx.sess.span_bug(span, \"representation hint insufficient for discriminant range\")\n+                cx.sess().span_bug(span, \"representation hint insufficient for discriminant range\")\n             }\n             return ity;\n         }\n         attr::ReprExtern => {\n-            attempts = match cx.sess.targ_cfg.arch {\n+            attempts = match cx.sess().targ_cfg.arch {\n                 X86 | X86_64 => at_least_32,\n                 // WARNING: the ARM EABI has two variants; the one corresponding to `at_least_32`\n                 // appears to be used on Linux and NetBSD, but some systems may use the variant\n@@ -577,7 +577,7 @@ pub fn trans_case<'a>(bcx: &'a Block<'a>, r: &Repr, discr: Disr)\n                                                        discr as u64, true)))\n         }\n         Univariant(..) => {\n-            bcx.ccx().sess.bug(\"no cases for univariants or structs\")\n+            bcx.ccx().sess().bug(\"no cases for univariants or structs\")\n         }\n         NullablePointer{ .. } => {\n             assert!(discr == 0 || discr == 1);\n@@ -651,7 +651,7 @@ pub fn num_args(r: &Repr, discr: Disr) -> uint {\n pub fn deref_ty(ccx: &CrateContext, r: &Repr) -> ty::t {\n     match *r {\n         CEnum(..) => {\n-            ccx.sess.bug(\"deref of c-like enum\")\n+            ccx.sess().bug(\"deref of c-like enum\")\n         }\n         Univariant(ref st, _) => {\n             *st.fields.get(0)\n@@ -661,7 +661,7 @@ pub fn deref_ty(ccx: &CrateContext, r: &Repr) -> ty::t {\n             *cases.get(0).fields.get(0)\n         }\n         NullablePointer{ .. } => {\n-            ccx.sess.bug(\"deref of nullable ptr\")\n+            ccx.sess().bug(\"deref of nullable ptr\")\n         }\n     }\n }\n@@ -674,7 +674,7 @@ pub fn trans_field_ptr(bcx: &Block, r: &Repr, val: ValueRef, discr: Disr,\n     // someday), it will need to return a possibly-new bcx as well.\n     match *r {\n         CEnum(..) => {\n-            bcx.ccx().sess.bug(\"element access in C-like enum\")\n+            bcx.ccx().sess().bug(\"element access in C-like enum\")\n         }\n         Univariant(ref st, _dtor) => {\n             assert_eq!(discr, 0);\n@@ -719,7 +719,7 @@ fn struct_field_ptr(bcx: &Block, st: &Struct, val: ValueRef, ix: uint,\n pub fn trans_drop_flag_ptr(bcx: &Block, r: &Repr, val: ValueRef) -> ValueRef {\n     match *r {\n         Univariant(ref st, true) => GEPi(bcx, val, [0, st.fields.len() - 1]),\n-        _ => bcx.ccx().sess.bug(\"tried to get drop flag of non-droppable type\")\n+        _ => bcx.ccx().sess().bug(\"tried to get drop flag of non-droppable type\")\n     }\n }\n \n@@ -874,7 +874,7 @@ pub fn const_get_discrim(ccx: &CrateContext, r: &Repr, val: ValueRef)\n pub fn const_get_field(ccx: &CrateContext, r: &Repr, val: ValueRef,\n                        _discr: Disr, ix: uint) -> ValueRef {\n     match *r {\n-        CEnum(..) => ccx.sess.bug(\"element access in C-like enum const\"),\n+        CEnum(..) => ccx.sess().bug(\"element access in C-like enum const\"),\n         Univariant(..) => const_struct_field(ccx, val, ix),\n         General(..) => const_struct_field(ccx, val, ix + 1),\n         NullablePointer{ .. } => const_struct_field(ccx, val, ix)"}, {"sha": "46afaccccf909c68a2b8accf184593032a077ab1", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 50, "deletions": 53, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=4fae06824ce1a3de3d24677196bf2e0d53346830", "patch": "@@ -144,7 +144,7 @@ pub struct StatRecorder {\n \n impl StatRecorder {\n     pub fn new(ccx: @CrateContext, name: ~str) -> StatRecorder {\n-        let start = if ccx.sess.trans_stats() {\n+        let start = if ccx.sess().trans_stats() {\n             time::precise_time_ns()\n         } else {\n             0\n@@ -162,7 +162,7 @@ impl StatRecorder {\n #[unsafe_destructor]\n impl Drop for StatRecorder {\n     fn drop(&mut self) {\n-        if self.ccx.sess.trans_stats() {\n+        if self.ccx.sess().trans_stats() {\n             let end = time::precise_time_ns();\n             let elapsed = ((end - self.start) / 1_000_000) as uint;\n             let iend = self.ccx.stats.n_llvm_insns.get();\n@@ -355,8 +355,8 @@ pub fn malloc_raw_dyn<'a>(\n         match li.require(it) {\n             Ok(id) => id,\n             Err(s) => {\n-                bcx.tcx().sess.fatal(format!(\"allocation of `{}` {}\",\n-                                          bcx.ty_to_str(t), s));\n+                bcx.sess().fatal(format!(\"allocation of `{}` {}\",\n+                                         bcx.ty_to_str(t), s));\n             }\n         }\n     }\n@@ -522,7 +522,7 @@ pub fn set_no_split_stack(f: ValueRef) {\n pub fn note_unique_llvm_symbol(ccx: &CrateContext, sym: ~str) {\n     let mut all_llvm_symbols = ccx.all_llvm_symbols.borrow_mut();\n     if all_llvm_symbols.get().contains(&sym) {\n-        ccx.sess.bug(~\"duplicate LLVM symbol: \" + sym);\n+        ccx.sess().bug(~\"duplicate LLVM symbol: \" + sym);\n     }\n     all_llvm_symbols.get().insert(sym);\n }\n@@ -555,7 +555,7 @@ pub fn get_res_dtor(ccx: @CrateContext,\n         get_item_val(ccx, did.node)\n     } else {\n         let tcx = ccx.tcx;\n-        let name = csearch::get_symbol(ccx.sess.cstore, did);\n+        let name = csearch::get_symbol(ccx.sess().cstore, did);\n         let class_ty = ty::subst_tps(tcx,\n                                      substs,\n                                      None,\n@@ -572,7 +572,7 @@ pub fn get_res_dtor(ccx: @CrateContext,\n \n // Structural comparison: a rather involved form of glue.\n pub fn maybe_name_value(cx: &CrateContext, v: ValueRef, s: &str) {\n-    if cx.sess.opts.cg.save_temps {\n+    if cx.sess().opts.cg.save_temps {\n         s.with_c_str(|buf| {\n             unsafe {\n                 llvm::LLVMSetValueName(v, buf)\n@@ -617,8 +617,7 @@ pub fn compare_scalar_values<'a>(\n                              -> ValueRef {\n     let _icx = push_ctxt(\"compare_scalar_values\");\n     fn die(cx: &Block) -> ! {\n-        cx.tcx().sess.bug(\"compare_scalar_values: must be a\\\n-                           comparison operator\");\n+        cx.sess().bug(\"compare_scalar_values: must be a comparison operator\");\n     }\n     match nt {\n       nil_type => {\n@@ -772,8 +771,8 @@ pub fn iter_structural_ty<'r,\n                           _match::single_result(r) => {\n                               AddCase(llswitch, r.val, variant_cx.llbb)\n                           }\n-                          _ => ccx.sess.unimpl(\"value from adt::trans_case \\\n-                                                in iter_structural_ty\")\n+                          _ => ccx.sess().unimpl(\"value from adt::trans_case \\\n+                                                  in iter_structural_ty\")\n                       }\n                       let variant_cx =\n                           iter_variant(variant_cx,\n@@ -786,8 +785,8 @@ pub fn iter_structural_ty<'r,\n                   }\n                   cx = next_cx;\n               }\n-              _ => ccx.sess.unimpl(\"value from adt::trans_switch \\\n-                                    in iter_structural_ty\")\n+              _ => ccx.sess().unimpl(\"value from adt::trans_switch \\\n+                                      in iter_structural_ty\")\n           }\n       }\n       _ => cx.sess().unimpl(\"type in iter_structural_ty\")\n@@ -865,8 +864,8 @@ pub fn fail_if_zero<'a>(\n         ICmp(cx, lib::llvm::IntEQ, rhs, zero)\n       }\n       _ => {\n-        cx.tcx().sess.bug(~\"fail-if-zero on unexpected type: \" +\n-                          ty_to_str(cx.ccx().tcx, rhs_t));\n+        cx.sess().bug(~\"fail-if-zero on unexpected type: \" +\n+                      ty_to_str(cx.ccx().tcx, rhs_t));\n       }\n     };\n     with_cond(cx, is_zero, |bcx| {\n@@ -875,11 +874,11 @@ pub fn fail_if_zero<'a>(\n }\n \n pub fn trans_external_path(ccx: &CrateContext, did: ast::DefId, t: ty::t) -> ValueRef {\n-    let name = csearch::get_symbol(ccx.sess.cstore, did);\n+    let name = csearch::get_symbol(ccx.sess().cstore, did);\n     match ty::get(t).sty {\n         ty::ty_bare_fn(ref fn_ty) => {\n-            match fn_ty.abis.for_target(ccx.sess.targ_cfg.os,\n-                                        ccx.sess.targ_cfg.arch) {\n+            match fn_ty.abis.for_target(ccx.sess().targ_cfg.os,\n+                                        ccx.sess().targ_cfg.arch) {\n                 Some(Rust) | Some(RustIntrinsic) => {\n                     get_extern_rust_fn(ccx,\n                                        fn_ty.sig.inputs.as_slice(),\n@@ -970,7 +969,7 @@ pub fn invoke<'a>(\n }\n \n pub fn need_invoke(bcx: &Block) -> bool {\n-    if bcx.ccx().sess.no_landing_pads() {\n+    if bcx.sess().no_landing_pads() {\n         return false;\n     }\n \n@@ -1081,7 +1080,7 @@ pub fn with_cond<'a>(\n pub fn call_memcpy(cx: &Block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef, align: u32) {\n     let _icx = push_ctxt(\"call_memcpy\");\n     let ccx = cx.ccx();\n-    let key = match ccx.sess.targ_cfg.arch {\n+    let key = match ccx.sess().targ_cfg.arch {\n         X86 | Arm | Mips => \"llvm.memcpy.p0i8.p0i8.i32\",\n         X86_64 => \"llvm.memcpy.p0i8.p0i8.i64\"\n     };\n@@ -1125,7 +1124,7 @@ fn memzero(b: &Builder, llptr: ValueRef, ty: Type) {\n     let _icx = push_ctxt(\"memzero\");\n     let ccx = b.ccx;\n \n-    let intrinsic_key = match ccx.sess.targ_cfg.arch {\n+    let intrinsic_key = match ccx.sess().targ_cfg.arch {\n         X86 | Arm | Mips => \"llvm.memset.p0i8.i32\",\n         X86_64 => \"llvm.memset.p0i8.i64\"\n     };\n@@ -1384,7 +1383,7 @@ fn copy_args_to_allocas<'a>(fcx: &FunctionContext<'a>,\n \n         bcx = _match::store_arg(bcx, args[i].pat, arg_datum, arg_scope_id);\n \n-        if fcx.ccx.sess.opts.debuginfo == FullDebugInfo {\n+        if fcx.ccx.sess().opts.debuginfo == FullDebugInfo {\n             debuginfo::create_argument_metadata(bcx, &args[i]);\n         }\n     }\n@@ -1615,7 +1614,7 @@ fn trans_enum_variant_or_tuple_like_struct(ccx: @CrateContext,\n \n     let result_ty = match ty::get(ctor_ty).sty {\n         ty::ty_bare_fn(ref bft) => bft.sig.output,\n-        _ => ccx.sess.bug(\n+        _ => ccx.sess().bug(\n             format!(\"trans_enum_variant_or_tuple_like_struct: \\\n                   unexpected ctor return type {}\",\n                  ty_to_str(ccx.tcx, ctor_ty)))\n@@ -1724,16 +1723,16 @@ pub fn trans_item(ccx: @CrateContext, item: &ast::Item) {\n           // because we need to get the value of the bool out of LLVM\n           if attr::contains_name(item.attrs.as_slice(), \"static_assert\") {\n               if m == ast::MutMutable {\n-                  ccx.sess.span_fatal(expr.span,\n-                                      \"cannot have static_assert on a mutable \\\n-                                       static\");\n+                  ccx.sess().span_fatal(expr.span,\n+                                        \"cannot have static_assert on a mutable \\\n+                                         static\");\n               }\n \n               let const_values = ccx.const_values.borrow();\n               let v = const_values.get().get_copy(&item.id);\n               unsafe {\n                   if !(llvm::LLVMConstIntGetZExtValue(v) != 0) {\n-                      ccx.sess.span_fatal(expr.span, \"static assertion failed\");\n+                      ccx.sess().span_fatal(expr.span, \"static assertion failed\");\n                   }\n               }\n           }\n@@ -1798,7 +1797,7 @@ fn finish_register_fn(ccx: @CrateContext, sp: Span, sym: ~str, node_id: ast::Nod\n         }\n     }\n \n-    if is_entry_fn(&ccx.sess, node_id) && !ccx.sess.building_library.get() {\n+    if is_entry_fn(ccx.sess(), node_id) && !ccx.sess().building_library.get() {\n         create_entry_wrapper(ccx, sp, llfn);\n     }\n }\n@@ -1853,7 +1852,7 @@ pub fn is_entry_fn(sess: &Session, node_id: ast::NodeId) -> bool {\n pub fn create_entry_wrapper(ccx: @CrateContext,\n                            _sp: Span,\n                            main_llfn: ValueRef) {\n-    let et = ccx.sess.entry_type.get().unwrap();\n+    let et = ccx.sess().entry_type.get().unwrap();\n     match et {\n         session::EntryMain => {\n             create_entry_fn(ccx, main_llfn, true);\n@@ -1881,7 +1880,7 @@ pub fn create_entry_wrapper(ccx: @CrateContext,\n             let (start_fn, args) = if use_start_lang_item {\n                 let start_def_id = match ccx.tcx.lang_items.require(StartFnLangItem) {\n                     Ok(id) => id,\n-                    Err(s) => { ccx.tcx.sess.fatal(s); }\n+                    Err(s) => { ccx.sess().fatal(s); }\n                 };\n                 let start_fn = if start_def_id.krate == ast::LOCAL_CRATE {\n                     get_item_val(ccx, start_def_id.node)\n@@ -1973,7 +1972,7 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n                                 match external_srcs.get().find(&i.id) {\n                                     Some(&did) => {\n                                         debug!(\"but found in other crate...\");\n-                                        (csearch::get_symbol(ccx.sess.cstore,\n+                                        (csearch::get_symbol(ccx.sess().cstore,\n                                                              did), false)\n                                     }\n                                     None => (sym, true)\n@@ -2013,7 +2012,7 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n                                         let reachable =\n                                             ccx.reachable.borrow();\n                                         if reachable.get().contains(&id) {\n-                                            ccx.sess.span_bug(i.span,\n+                                            ccx.sess().span_bug(i.span,\n                                                 \"insignificant static is \\\n                                                  reachable\");\n                                         }\n@@ -2093,8 +2092,8 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n                     debug!(\"get_item_val(): processing a NodeTraitMethod\");\n                     match *trait_method {\n                         ast::Required(_) => {\n-                            ccx.sess.bug(\"unexpected variant: required trait method in \\\n-                                         get_item_val()\");\n+                            ccx.sess().bug(\"unexpected variant: required trait method in \\\n+                                           get_item_val()\");\n                         }\n                         ast::Provided(m) => {\n                             register_method(ccx, id, m)\n@@ -2152,8 +2151,8 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n                     // Only register the constructor if this is a tuple-like struct.\n                     match struct_def.ctor_id {\n                         None => {\n-                            ccx.tcx.sess.bug(\"attempt to register a constructor of \\\n-                                              a non-tuple-like struct\")\n+                            ccx.sess().bug(\"attempt to register a constructor of \\\n+                                            a non-tuple-like struct\")\n                         }\n                         Some(ctor_id) => {\n                             let parent = ccx.tcx.map.get_parent(id);\n@@ -2173,8 +2172,8 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n                 }\n \n                 ref variant => {\n-                    ccx.sess.bug(format!(\"get_item_val(): unexpected variant: {:?}\",\n-                                 variant))\n+                    ccx.sess().bug(format!(\"get_item_val(): unexpected variant: {:?}\",\n+                                   variant))\n                 }\n             };\n \n@@ -2409,7 +2408,7 @@ pub fn symname(name: &str, hash: &str, vers: &str) -> ~str {\n     link::exported_name(ast_map::Values(path.iter()).chain(None), hash, vers)\n }\n \n-pub fn decl_crate_map(sess: session::Session, mapmeta: LinkMeta,\n+pub fn decl_crate_map(sess: &Session, mapmeta: LinkMeta,\n                       llmod: ModuleRef) -> (~str, ValueRef) {\n     let targ_cfg = sess.targ_cfg;\n     let int_type = Type::int(targ_cfg.arch);\n@@ -2452,7 +2451,7 @@ pub fn fill_crate_map(ccx: @CrateContext, map: ValueRef) {\n                 llvm::LLVMConstPointerCast(get_item_val(ccx, did.node),\n                                            ccx.int_type.ptr_to().to_ref())\n             } else {\n-                let name = csearch::get_symbol(ccx.sess.cstore, did);\n+                let name = csearch::get_symbol(ccx.sess().cstore, did);\n                 let global = name.with_c_str(|buf| {\n                     llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type.to_ref(), buf)\n                 });\n@@ -2472,7 +2471,7 @@ pub fn fill_crate_map(ccx: @CrateContext, map: ValueRef) {\n pub fn crate_ctxt_to_encode_parms<'r>(cx: &'r CrateContext, ie: encoder::EncodeInlinedItem<'r>)\n     -> encoder::EncodeParams<'r> {\n \n-        let diag = cx.sess.diagnostic();\n+        let diag = cx.sess().diagnostic();\n         let item_symbols = &cx.item_symbols;\n         let link_meta = &cx.link_meta;\n         encoder::EncodeParams {\n@@ -2482,15 +2481,15 @@ pub fn crate_ctxt_to_encode_parms<'r>(cx: &'r CrateContext, ie: encoder::EncodeI\n             item_symbols: item_symbols,\n             non_inlineable_statics: &cx.non_inlineable_statics,\n             link_meta: link_meta,\n-            cstore: cx.sess.cstore,\n+            cstore: cx.sess().cstore,\n             encode_inlined_item: ie,\n         }\n }\n \n pub fn write_metadata(cx: &CrateContext, krate: &ast::Crate) -> Vec<u8> {\n     use flate;\n \n-    if !cx.sess.building_library.get() {\n+    if !cx.sess().building_library.get() {\n         return Vec::new()\n     }\n \n@@ -2512,15 +2511,14 @@ pub fn write_metadata(cx: &CrateContext, krate: &ast::Crate) -> Vec<u8> {\n     });\n     unsafe {\n         llvm::LLVMSetInitializer(llglobal, llconst);\n-        cx.sess.targ_cfg.target_strs.meta_sect_name.with_c_str(|buf| {\n+        cx.sess().targ_cfg.target_strs.meta_sect_name.with_c_str(|buf| {\n             llvm::LLVMSetSection(llglobal, buf)\n         });\n     }\n     return metadata;\n }\n \n-pub fn trans_crate(sess: session::Session,\n-                   krate: ast::Crate,\n+pub fn trans_crate(krate: ast::Crate,\n                    analysis: &CrateAnalysis,\n                    output: &OutputFilenames) -> CrateTranslation {\n     // Before we touch LLVM, make sure that multithreading is enabled.\n@@ -2537,7 +2535,7 @@ pub fn trans_crate(sess: session::Session,\n         });\n \n         if POISONED {\n-            sess.bug(\"couldn't enable multi-threaded LLVM\");\n+            analysis.ty_cx.sess.bug(\"couldn't enable multi-threaded LLVM\");\n         }\n     }\n \n@@ -2553,8 +2551,7 @@ pub fn trans_crate(sess: session::Session,\n     // 1. http://llvm.org/bugs/show_bug.cgi?id=11479\n     let llmod_id = link_meta.crateid.name + \".rs\";\n \n-    let ccx = @CrateContext::new(sess,\n-                                 llmod_id,\n+    let ccx = @CrateContext::new(llmod_id,\n                                  analysis.ty_cx,\n                                  analysis.exp_map2,\n                                  analysis.maps,\n@@ -2574,7 +2571,7 @@ pub fn trans_crate(sess: session::Session,\n     // __rust_crate_map_toplevel symbol (extra underscore) which it will\n     // subsequently fail to find. So to mitigate that we just introduce\n     // an alias from the symbol it expects to the one that actually exists.\n-    if ccx.sess.targ_cfg.os == OsWin32 && !ccx.sess.building_library.get() {\n+    if ccx.sess().targ_cfg.os == OsWin32 && !ccx.sess().building_library.get() {\n \n         let maptype = val_ty(ccx.crate_map).to_ref();\n \n@@ -2587,13 +2584,13 @@ pub fn trans_crate(sess: session::Session,\n     }\n \n     glue::emit_tydescs(ccx);\n-    if ccx.sess.opts.debuginfo != NoDebugInfo {\n+    if ccx.sess().opts.debuginfo != NoDebugInfo {\n         debuginfo::finalize(ccx);\n     }\n \n     // Translate the metadata.\n     let metadata = write_metadata(ccx, &krate);\n-    if ccx.sess.trans_stats() {\n+    if ccx.sess().trans_stats() {\n         println!(\"--- trans stats ---\");\n         println!(\"n_static_tydescs: {}\", ccx.stats.n_static_tydescs.get());\n         println!(\"n_glues_created: {}\", ccx.stats.n_glues_created.get());\n@@ -2619,7 +2616,7 @@ pub fn trans_crate(sess: session::Session,\n             }\n         }\n     }\n-    if ccx.sess.count_llvm_insns() {\n+    if ccx.sess().count_llvm_insns() {\n         let llvm_insns = ccx.stats.llvm_insns.borrow();\n         for (k, v) in llvm_insns.get().iter() {\n             println!(\"{:7u} {}\", *v, *k);"}, {"sha": "dd34a034d0eb2079ca50224512aa66c905d2114a", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=4fae06824ce1a3de3d24677196bf2e0d53346830", "patch": "@@ -44,13 +44,13 @@ impl<'a> Builder<'a> {\n     }\n \n     pub fn count_insn(&self, category: &str) {\n-        if self.ccx.sess.trans_stats() {\n+        if self.ccx.sess().trans_stats() {\n             self.ccx.stats.n_llvm_insns.set(self.ccx\n                                                 .stats\n                                                 .n_llvm_insns\n                                                 .get() + 1);\n         }\n-        if self.ccx.sess.count_llvm_insns() {\n+        if self.ccx.sess().count_llvm_insns() {\n             base::with_insn_ctxt(|v| {\n                 let mut h = self.ccx.stats.llvm_insns.borrow_mut();\n \n@@ -748,15 +748,15 @@ impl<'a> Builder<'a> {\n     }\n \n     pub fn add_span_comment(&self, sp: Span, text: &str) {\n-        if self.ccx.sess.asm_comments() {\n-            let s = format!(\"{} ({})\", text, self.ccx.sess.codemap.span_to_str(sp));\n+        if self.ccx.sess().asm_comments() {\n+            let s = format!(\"{} ({})\", text, self.ccx.sess().codemap.span_to_str(sp));\n             debug!(\"{}\", s);\n             self.add_comment(s);\n         }\n     }\n \n     pub fn add_comment(&self, text: &str) {\n-        if self.ccx.sess.asm_comments() {\n+        if self.ccx.sess().asm_comments() {\n             let sanitized = text.replace(\"$\", \"\");\n             let comment_text = format!(\"\\\\# {}\", sanitized.replace(\"\\n\", \"\\n\\t# \"));\n             self.count_insn(\"inlineasm\");"}, {"sha": "d760c64544139bf72dd001c43528a02923b113df", "filename": "src/librustc/middle/trans/cabi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs?ref=4fae06824ce1a3de3d24677196bf2e0d53346830", "patch": "@@ -94,7 +94,7 @@ pub fn compute_abi_info(ccx: &CrateContext,\n                         atys: &[Type],\n                         rty: Type,\n                         ret_def: bool) -> FnType {\n-    match ccx.sess.targ_cfg.arch {\n+    match ccx.sess().targ_cfg.arch {\n         X86 => cabi_x86::compute_abi_info(ccx, atys, rty, ret_def),\n         X86_64 => cabi_x86_64::compute_abi_info(ccx, atys, rty, ret_def),\n         Arm => cabi_arm::compute_abi_info(ccx, atys, rty, ret_def),"}, {"sha": "dc099dba7d143d2fae6ebf64c0467f27ce517ee6", "filename": "src/librustc/middle/trans/cabi_x86.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs?ref=4fae06824ce1a3de3d24677196bf2e0d53346830", "patch": "@@ -36,7 +36,7 @@ pub fn compute_abi_info(ccx: &CrateContext,\n         // Clang's ABI handling is in lib/CodeGen/TargetInfo.cpp\n \n         enum Strategy { RetValue(Type), RetPointer }\n-        let strategy = match ccx.sess.targ_cfg.os {\n+        let strategy = match ccx.sess().targ_cfg.os {\n             OsWin32 | OsMacos => {\n                 match llsize_of_alloc(ccx, rty) {\n                     1 => RetValue(Type::i8()),"}, {"sha": "afa9e73c5f576dc525efd39dd29798ea8ff069af", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=4fae06824ce1a3de3d24677196bf2e0d53346830", "patch": "@@ -365,7 +365,7 @@ pub fn trans_fn_ref_with_vtables(\n         true\n     } else if def_id.krate == ast::LOCAL_CRATE {\n         let map_node = session::expect(\n-            ccx.sess,\n+            ccx.sess(),\n             ccx.tcx.map.find(def_id.node),\n             || format!(\"local item should be in ast map\"));\n "}, {"sha": "65b6670068824684c0fb300bf21f9f4becfd2e77", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=4fae06824ce1a3de3d24677196bf2e0d53346830", "patch": "@@ -227,7 +227,7 @@ pub fn store_environment<'a>(\n     for (i, bv) in bound_values.move_iter().enumerate() {\n         debug!(\"Copy {} into closure\", bv.to_str(ccx));\n \n-        if ccx.sess.asm_comments() {\n+        if ccx.sess().asm_comments() {\n             add_comment(bcx, format!(\"Copy {} into closure\",\n                                   bv.to_str(ccx)));\n         }\n@@ -301,7 +301,7 @@ fn load_environment<'a>(bcx: &'a Block<'a>, cdata_ty: ty::t,\n \n     // Store the pointer to closure data in an alloca for debug info because that's what the\n     // llvm.dbg.declare intrinsic expects\n-    let env_pointer_alloca = if bcx.ccx().sess.opts.debuginfo == FullDebugInfo {\n+    let env_pointer_alloca = if bcx.sess().opts.debuginfo == FullDebugInfo {\n         let alloc = alloc_ty(bcx, ty::mk_mut_ptr(bcx.tcx(), cdata_ty), \"__debuginfo_env_ptr\");\n         Store(bcx, llcdata, alloc);\n         Some(alloc)\n@@ -419,9 +419,9 @@ pub fn get_wrapper_for_bare_fn(ccx: @CrateContext,\n         ast::DefFn(did, _) | ast::DefStaticMethod(did, _, _) |\n         ast::DefVariant(_, did, _) | ast::DefStruct(did) => did,\n         _ => {\n-            ccx.sess.bug(format!(\"get_wrapper_for_bare_fn: \\\n-                                  expected a statically resolved fn, got {:?}\",\n-                                  def));\n+            ccx.sess().bug(format!(\"get_wrapper_for_bare_fn: \\\n+                                    expected a statically resolved fn, got {:?}\",\n+                                    def));\n         }\n     };\n \n@@ -440,9 +440,9 @@ pub fn get_wrapper_for_bare_fn(ccx: @CrateContext,\n     let f = match ty::get(closure_ty).sty {\n         ty::ty_closure(ref f) => f,\n         _ => {\n-            ccx.sess.bug(format!(\"get_wrapper_for_bare_fn: \\\n-                                  expected a closure ty, got {}\",\n-                                  closure_ty.repr(tcx)));\n+            ccx.sess().bug(format!(\"get_wrapper_for_bare_fn: \\\n+                                    expected a closure ty, got {}\",\n+                                    closure_ty.repr(tcx)));\n         }\n     };\n "}, {"sha": "5508cddefe0bf33c877c4306ab8bae77ffc0f725", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=4fae06824ce1a3de3d24677196bf2e0d53346830", "patch": "@@ -383,13 +383,6 @@ impl<'a> FunctionContext<'a> {\n     }\n }\n \n-pub fn warn_not_to_commit(ccx: &mut CrateContext, msg: &str) {\n-    if !ccx.do_not_commit_warning_issued.get() {\n-        ccx.do_not_commit_warning_issued.set(true);\n-        ccx.sess.warn(msg.to_str() + \" -- do not commit like this!\");\n-    }\n-}\n-\n // Heap selectors. Indicate which heap something should go on.\n #[deriving(Eq)]\n pub enum heap {\n@@ -446,7 +439,7 @@ impl<'a> Block<'a> {\n     pub fn tcx(&self) -> ty::ctxt {\n         self.fcx.ccx.tcx\n     }\n-    pub fn sess(&self) -> Session { self.fcx.ccx.sess }\n+    pub fn sess(&self) -> &'a Session { self.fcx.ccx.sess() }\n \n     pub fn ident(&self, ident: Ident) -> ~str {\n         token::get_ident(ident).get().to_str()"}, {"sha": "ff548f06f0b3368f7a29223360019ad6fc2dd630", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=4fae06824ce1a3de3d24677196bf2e0d53346830", "patch": "@@ -53,7 +53,7 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: ast::Lit)\n                 ty::ty_uint(t) => {\n                     C_integral(Type::uint_from_ty(cx, t), i as u64, false)\n                 }\n-                _ => cx.sess.span_bug(lit.span,\n+                _ => cx.sess().span_bug(lit.span,\n                         format!(\"integer literal has type {} (expected int or uint)\",\n                                 ty_to_str(cx.tcx, lit_int_ty)))\n             }\n@@ -68,7 +68,7 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: ast::Lit)\n                     C_floating(fs.get(), Type::float_from_ty(t))\n                 }\n                 _ => {\n-                    cx.sess.span_bug(lit.span,\n+                    cx.sess().span_bug(lit.span,\n                         \"floating point literal doesn't have the right type\");\n                 }\n             }\n@@ -147,15 +147,15 @@ fn const_deref(cx: &CrateContext, v: ValueRef, t: ty::t, explicit: bool)\n                     const_deref_newtype(cx, v, t)\n                 }\n                 _ => {\n-                    cx.sess.bug(format!(\"unexpected dereferenceable type {}\",\n-                                     ty_to_str(cx.tcx, t)))\n+                    cx.sess().bug(format!(\"unexpected dereferenceable type {}\",\n+                                          ty_to_str(cx.tcx, t)))\n                 }\n             };\n             (dv, mt.ty)\n         }\n         None => {\n-            cx.sess.bug(format!(\"can't dereference const of type {}\",\n-                             ty_to_str(cx.tcx, t)))\n+            cx.sess().bug(format!(\"can't dereference const of type {}\",\n+                                  ty_to_str(cx.tcx, t)))\n         }\n     }\n }\n@@ -210,15 +210,15 @@ pub fn const_expr(cx: @CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef\n                     llconst = C_struct([wrapper, C_null(Type::i8p())], false)\n                 }\n                 ty::AutoAddEnv(ref r, ref s) => {\n-                    cx.sess\n+                    cx.sess()\n                       .span_bug(e.span,\n                                 format!(\"unexpected static function: region \\\n                                          {:?} sigil {:?}\",\n                                         *r,\n                                         *s))\n                 }\n                 ty::AutoObject(..) => {\n-                    cx.sess\n+                    cx.sess()\n                       .span_unimpl(e.span,\n                                    \"unimplemented const coercion to trait \\\n                                     object\");\n@@ -266,11 +266,11 @@ pub fn const_expr(cx: @CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef\n                                     }\n                                 }\n                                 _ => {\n-                                    cx.sess.span_bug(e.span,\n-                                                     format!(\"unimplemented \\\n-                                                              const autoref \\\n-                                                              {:?}\",\n-                                                             autoref))\n+                                    cx.sess().span_bug(e.span,\n+                                                       format!(\"unimplemented \\\n+                                                                const autoref \\\n+                                                                {:?}\",\n+                                                               autoref))\n                                 }\n                             }\n                         }\n@@ -289,7 +289,7 @@ pub fn const_expr(cx: @CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef\n             llvm::LLVMDumpValue(llconst);\n             llvm::LLVMDumpValue(C_undef(llty));\n         }\n-        cx.sess.bug(format!(\"const {} of type {} has size {} instead of {}\",\n+        cx.sess().bug(format!(\"const {} of type {} has size {} instead of {}\",\n                          e.repr(cx.tcx), ty_to_str(cx.tcx, ety),\n                          csize, tsize));\n     }\n@@ -440,8 +440,8 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n               let iv = match const_eval::eval_const_expr(cx.tcx, index) {\n                   const_eval::const_int(i) => i as u64,\n                   const_eval::const_uint(u) => u,\n-                  _ => cx.sess.span_bug(index.span,\n-                                        \"index is not an integer-constant expression\")\n+                  _ => cx.sess().span_bug(index.span,\n+                                          \"index is not an integer-constant expression\")\n               };\n               let (arr, len) = match ty::get(bt).sty {\n                   ty::ty_vec(_, vstore) | ty::ty_str(vstore) =>\n@@ -453,11 +453,11 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n                           let e1 = const_get_elt(cx, bv, [0]);\n                           (const_deref_ptr(cx, e1), const_get_elt(cx, bv, [1]))\n                       },\n-                      _ => cx.sess.span_bug(base.span,\n-                                            \"index-expr base must be fixed-size or slice\")\n+                      _ => cx.sess().span_bug(base.span,\n+                                              \"index-expr base must be fixed-size or slice\")\n                   },\n-                  _ =>  cx.sess.span_bug(base.span,\n-                                         \"index-expr base must be a vector or string type\")\n+                  _ =>  cx.sess().span_bug(base.span,\n+                                           \"index-expr base must be a vector or string type\")\n               };\n \n               let len = llvm::LLVMConstIntGetZExtValue(len) as u64;\n@@ -468,8 +468,8 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n               if iv >= len {\n                   // FIXME #3170: report this earlier on in the const-eval\n                   // pass. Reporting here is a bit late.\n-                  cx.sess.span_err(e.span,\n-                                   \"const index-expr is out of bounds\");\n+                  cx.sess().span_err(e.span,\n+                                     \"const index-expr is out of bounds\");\n               }\n               (const_get_elt(cx, arr, [iv as c_uint]), inlineable)\n           }\n@@ -511,8 +511,8 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n                         llvm::LLVMConstIntCast(iv, llty.to_ref(), s)\n                     }\n                     expr::cast_float => llvm::LLVMConstUIToFP(iv, llty.to_ref()),\n-                    _ => cx.sess.bug(\"enum cast destination is not \\\n-                                      integral or float\")\n+                    _ => cx.sess().bug(\"enum cast destination is not \\\n+                                        integral or float\")\n                 }\n               }\n               (expr::cast_pointer, expr::cast_pointer) => {\n@@ -522,8 +522,8 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n                 llvm::LLVMConstIntToPtr(v, llty.to_ref())\n               }\n               _ => {\n-                cx.sess.impossible_case(e.span,\n-                                        \"bad combination of types for cast\")\n+                cx.sess().impossible_case(e.span,\n+                                          \"bad combination of types for cast\")\n               }\n             }, inlineable)\n           }\n@@ -558,7 +558,7 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n                                     (adt::const_get_field(cx, repr, bv, discr, ix),\n                                      inlineable)\n                                 }\n-                                None => cx.tcx.sess.span_bug(e.span, \"missing struct field\")\n+                                None => cx.sess().span_bug(e.span, \"missing struct field\")\n                               }\n                           }\n                       }\n@@ -580,7 +580,7 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n               ast::ExprLit(ref lit) => {\n                 match lit.node {\n                     ast::LitStr(..) => { const_expr(cx, sub, is_local) }\n-                    _ => { cx.sess.span_bug(e.span, \"bad const-slice lit\") }\n+                    _ => { cx.sess().span_bug(e.span, \"bad const-slice lit\") }\n                 }\n               }\n               ast::ExprVec(ref es, ast::MutImmutable) => {\n@@ -598,7 +598,7 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n                 let p = const_ptrcast(cx, gv, llunitty);\n                 (C_struct([p, C_uint(cx, es.len())], false), false)\n               }\n-              _ => cx.sess.span_bug(e.span, \"bad const-slice expr\")\n+              _ => cx.sess().span_bug(e.span, \"bad const-slice expr\")\n             }\n           }\n           ast::ExprRepeat(elem, count, _) => {\n@@ -608,7 +608,7 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n             let n = match const_eval::eval_const_expr(cx.tcx, count) {\n                 const_eval::const_int(i)  => i as uint,\n                 const_eval::const_uint(i) => i as uint,\n-                _ => cx.sess.span_bug(count.span, \"count must be integral const expression.\")\n+                _ => cx.sess().span_bug(count.span, \"count must be integral const expression.\")\n             };\n             let vs = vec::from_elem(n, const_expr(cx, elem, is_local).val0());\n             let v = if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n@@ -654,7 +654,7 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n                     (C_null(llty), true)\n                 }\n                 _ => {\n-                    cx.sess.span_bug(e.span, \"expected a const, fn, struct, or variant def\")\n+                    cx.sess().span_bug(e.span, \"expected a const, fn, struct, or variant def\")\n                 }\n             }\n           }\n@@ -684,11 +684,11 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n                                         vinfo.disr_val,\n                                         arg_vals.as_slice()), inlineable)\n                   }\n-                  _ => cx.sess.span_bug(e.span, \"expected a struct or variant def\")\n+                  _ => cx.sess().span_bug(e.span, \"expected a struct or variant def\")\n               }\n           }\n           ast::ExprParen(e) => { const_expr(cx, e, is_local) }\n-          _ => cx.sess.span_bug(e.span,\n+          _ => cx.sess().span_bug(e.span,\n                   \"bad constant expression type in consts::const_expr\")\n         };\n     }"}, {"sha": "b8a29bfebe5d69119d551c68d5a8413b496b5186", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=4fae06824ce1a3de3d24677196bf2e0d53346830", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n \n-use driver::session;\n use driver::session::NoDebugInfo;\n+use driver::session::Session;\n use lib::llvm::{ContextRef, ModuleRef, ValueRef};\n use lib::llvm::{llvm, TargetData, TypeNames};\n use lib::llvm::mk_target_data;\n@@ -39,7 +39,6 @@ use syntax::ast;\n use syntax::parse::token::InternedString;\n \n pub struct CrateContext {\n-    sess: session::Session,\n     llmod: ModuleRef,\n     llcx: ContextRef,\n     metadata_llmod: ModuleRef,\n@@ -115,12 +114,10 @@ pub struct CrateContext {\n     // is not emitted by LLVM's GC pass when no functions use GC.\n     uses_gc: bool,\n     dbg_cx: Option<debuginfo::CrateDebugContext>,\n-    do_not_commit_warning_issued: Cell<bool>,\n }\n \n impl CrateContext {\n-    pub fn new(sess: session::Session,\n-               name: &str,\n+    pub fn new(name: &str,\n                tcx: ty::ctxt,\n                emap2: resolve::ExportMap2,\n                maps: astencode::Maps,\n@@ -137,8 +134,8 @@ impl CrateContext {\n             let metadata_llmod = format!(\"{}_metadata\", name).with_c_str(|buf| {\n                 llvm::LLVMModuleCreateWithNameInContext(buf, llcx)\n             });\n-            let data_layout: &str = sess.targ_cfg.target_strs.data_layout;\n-            let targ_triple: &str = sess.targ_cfg.target_strs.target_triple;\n+            let data_layout: &str = tcx.sess.targ_cfg.target_strs.data_layout;\n+            let targ_triple: &str = tcx.sess.targ_cfg.target_strs.target_triple;\n             data_layout.with_c_str(|buf| {\n                 llvm::LLVMSetDataLayout(llmod, buf);\n                 llvm::LLVMSetDataLayout(metadata_llmod, buf);\n@@ -147,13 +144,13 @@ impl CrateContext {\n                 llvm::LLVMRustSetNormalizedTarget(llmod, buf);\n                 llvm::LLVMRustSetNormalizedTarget(metadata_llmod, buf);\n             });\n-            let targ_cfg = sess.targ_cfg;\n+            let targ_cfg = tcx.sess.targ_cfg;\n \n-            let td = mk_target_data(sess.targ_cfg.target_strs.data_layout);\n+            let td = mk_target_data(tcx.sess.targ_cfg.target_strs.data_layout);\n             let tn = TypeNames::new();\n \n             let mut intrinsics = base::declare_intrinsics(llmod);\n-            if sess.opts.debuginfo != NoDebugInfo {\n+            if tcx.sess.opts.debuginfo != NoDebugInfo {\n                 base::declare_dbg_intrinsics(llmod, &mut intrinsics);\n             }\n             let int_type = Type::int(targ_cfg.arch);\n@@ -166,19 +163,18 @@ impl CrateContext {\n             tn.associate_type(\"tydesc\", &tydesc_type);\n             tn.associate_type(\"str_slice\", &str_slice_ty);\n \n-            let (crate_map_name, crate_map) = decl_crate_map(sess, link_meta.clone(), llmod);\n-            let dbg_cx = if sess.opts.debuginfo != NoDebugInfo {\n+            let (crate_map_name, crate_map) = decl_crate_map(&tcx.sess, link_meta.clone(), llmod);\n+            let dbg_cx = if tcx.sess.opts.debuginfo != NoDebugInfo {\n                 Some(debuginfo::CrateDebugContext::new(llmod))\n             } else {\n                 None\n             };\n \n-            if sess.count_llvm_insns() {\n+            if tcx.sess.count_llvm_insns() {\n                 base::init_insn_ctxt()\n             }\n \n             CrateContext {\n-                 sess: sess,\n                  llmod: llmod,\n                  llcx: llcx,\n                  metadata_llmod: metadata_llmod,\n@@ -235,11 +231,14 @@ impl CrateContext {\n                  crate_map_name: crate_map_name,\n                  uses_gc: false,\n                  dbg_cx: dbg_cx,\n-                 do_not_commit_warning_issued: Cell::new(false),\n             }\n         }\n     }\n \n+    pub fn sess<'a>(&'a self) -> &'a Session {\n+        &self.tcx.sess\n+    }\n+\n     pub fn builder<'a>(&'a self) -> Builder<'a> {\n         Builder::new(self)\n     }"}, {"sha": "cf9a4aaedb81c068acab6f44dea13d29a695c665", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=4fae06824ce1a3de3d24677196bf2e0d53346830", "patch": "@@ -213,10 +213,10 @@ impl FunctionDebugContext {\n         match *self {\n             FunctionDebugContext(~ref data) => data,\n             DebugInfoDisabled => {\n-                cx.sess.span_bug(span, FunctionDebugContext::debuginfo_disabled_message());\n+                cx.sess().span_bug(span, FunctionDebugContext::debuginfo_disabled_message());\n             }\n             FunctionWithoutDebugInfo => {\n-                cx.sess.span_bug(span, FunctionDebugContext::should_be_ignored_message());\n+                cx.sess().span_bug(span, FunctionDebugContext::should_be_ignored_message());\n             }\n         }\n     }\n@@ -268,7 +268,7 @@ pub fn finalize(cx: @CrateContext) {\n         // instruct LLVM to emit an older version of dwarf, however,\n         // for OS X to understand. For more info see #11352\n         // This can be overridden using --llvm-opts -dwarf-version,N.\n-        if cx.sess.targ_cfg.os == abi::OsMacos {\n+        if cx.sess().targ_cfg.os == abi::OsMacos {\n             \"Dwarf Version\".with_c_str(\n                 |s| llvm::LLVMRustAddModuleFlag(cx.llmod, s, 2));\n         }\n@@ -299,7 +299,7 @@ pub fn create_local_var_metadata(bcx: &Block, local: &ast::Local) {\n             match lllocals.get().find_copy(&node_id) {\n                 Some(datum) => datum,\n                 None => {\n-                    bcx.tcx().sess.span_bug(span,\n+                    bcx.sess().span_bug(span,\n                         format!(\"no entry in lllocals table for {:?}\",\n                                 node_id));\n                 }\n@@ -338,15 +338,15 @@ pub fn create_captured_var_metadata(bcx: &Block,\n \n     let variable_ident = match ast_item {\n         None => {\n-            cx.sess.span_bug(span, \"debuginfo::create_captured_var_metadata() - NodeId not found\");\n+            cx.sess().span_bug(span, \"debuginfo::create_captured_var_metadata: node not found\");\n         }\n         Some(ast_map::NodeLocal(pat)) | Some(ast_map::NodeArg(pat)) => {\n             match pat.node {\n                 ast::PatIdent(_, ref path, _) => {\n                     ast_util::path_to_ident(path)\n                 }\n                 _ => {\n-                    cx.sess\n+                    cx.sess()\n                       .span_bug(span,\n                                 format!(\n                                 \"debuginfo::create_captured_var_metadata() - \\\n@@ -357,7 +357,7 @@ pub fn create_captured_var_metadata(bcx: &Block,\n             }\n         }\n         _ => {\n-            cx.sess.span_bug(span, format!(\"debuginfo::create_captured_var_metadata() - \\\n+            cx.sess().span_bug(span, format!(\"debuginfo::create_captured_var_metadata() - \\\n                 Captured var-id refers to unexpected ast_map variant: {:?}\", ast_item));\n         }\n     };\n@@ -441,15 +441,15 @@ pub fn create_argument_metadata(bcx: &Block, arg: &ast::Arg) {\n             match llargs.get().find_copy(&node_id) {\n                 Some(v) => v,\n                 None => {\n-                    bcx.tcx().sess.span_bug(span,\n+                    bcx.sess().span_bug(span,\n                         format!(\"no entry in llargs table for {:?}\",\n                                 node_id));\n                 }\n             }\n         };\n \n         if unsafe { llvm::LLVMIsAAllocaInst(llarg.val) } == ptr::null() {\n-            cx.sess.span_bug(span, \"debuginfo::create_argument_metadata() - \\\n+            cx.sess().span_bug(span, \"debuginfo::create_argument_metadata() - \\\n                                     Referenced variable location is not an alloca!\");\n         }\n \n@@ -485,7 +485,7 @@ pub fn set_source_location(fcx: &FunctionContext,\n \n     let cx = fcx.ccx;\n \n-    debug!(\"set_source_location: {}\", cx.sess.codemap.span_to_str(span));\n+    debug!(\"set_source_location: {}\", cx.sess().codemap.span_to_str(span));\n \n     if fcx.debug_context.get_ref(cx, span).source_locations_enabled.get() {\n         let loc = span_start(cx, span);\n@@ -532,7 +532,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                                      fn_ast_id: ast::NodeId,\n                                      param_substs: Option<@param_substs>,\n                                      llfn: ValueRef) -> FunctionDebugContext {\n-    if cx.sess.opts.debuginfo == NoDebugInfo {\n+    if cx.sess().opts.debuginfo == NoDebugInfo {\n         return DebugInfoDisabled;\n     }\n \n@@ -551,7 +551,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                     (item.ident, fn_decl, generics, top_level_block, item.span, true)\n                 }\n                 _ => {\n-                    cx.sess.span_bug(item.span,\n+                    cx.sess().span_bug(item.span,\n                         \"create_function_debug_context: item bound to non-function\");\n                 }\n             }\n@@ -579,7 +579,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                         // Don't try to lookup the item path:\n                         false)\n                 }\n-                _ => cx.sess.span_bug(expr.span,\n+                _ => cx.sess().span_bug(expr.span,\n                         \"create_function_debug_context: expected an expr_fn_block here\")\n             }\n         }\n@@ -594,7 +594,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                      true)\n                 }\n                 _ => {\n-                    cx.sess\n+                    cx.sess()\n                       .bug(format!(\"create_function_debug_context: \\\n                                     unexpected sort of node: {:?}\",\n                                     fnitem))\n@@ -606,8 +606,8 @@ pub fn create_function_debug_context(cx: &CrateContext,\n         ast_map::NodeStructCtor(..) => {\n             return FunctionWithoutDebugInfo;\n         }\n-        _ => cx.sess.bug(format!(\"create_function_debug_context: \\\n-                                  unexpected sort of node: {:?}\", fnitem))\n+        _ => cx.sess().bug(format!(\"create_function_debug_context: \\\n+                                    unexpected sort of node: {:?}\", fnitem))\n     };\n \n     // This can be the case for functions inlined from another crate\n@@ -672,7 +672,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                     true,\n                     scope_line as c_uint,\n                     FlagPrototyped as c_uint,\n-                    cx.sess.opts.optimize != session::No,\n+                    cx.sess().opts.optimize != session::No,\n                     llfn,\n                     template_parameters,\n                     ptr::null())\n@@ -708,7 +708,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                               fn_decl: &ast::FnDecl,\n                               param_substs: Option<@param_substs>,\n                               error_span: Span) -> DIArray {\n-        if cx.sess.opts.debuginfo == LimitedDebugInfo {\n+        if cx.sess().opts.debuginfo == LimitedDebugInfo {\n             return create_DIArray(DIB(cx), []);\n         }\n \n@@ -793,7 +793,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n             }\n \n             // Only create type information if full debuginfo is enabled\n-            if cx.sess.opts.debuginfo == FullDebugInfo {\n+            if cx.sess().opts.debuginfo == FullDebugInfo {\n                 let actual_self_type_metadata = type_metadata(cx,\n                                                               actual_self_type,\n                                                               codemap::DUMMY_SP);\n@@ -837,7 +837,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n             }\n \n             // Again, only create type information if full debuginfo is enabled\n-            if cx.sess.opts.debuginfo == FullDebugInfo {\n+            if cx.sess().opts.debuginfo == FullDebugInfo {\n                 let actual_type_metadata = type_metadata(cx, actual_type, codemap::DUMMY_SP);\n                 let param_metadata = token::get_ident(ident).get()\n                                                             .with_c_str(|name| {\n@@ -873,12 +873,12 @@ fn create_DIArray(builder: DIBuilderRef, arr: &[DIDescriptor]) -> DIArray {\n }\n \n fn compile_unit_metadata(cx: &CrateContext) {\n-    let work_dir = &cx.sess.working_dir;\n-    let compile_unit_name = match cx.sess.local_crate_source_file {\n+    let work_dir = &cx.sess().working_dir;\n+    let compile_unit_name = match cx.sess().local_crate_source_file {\n         None => fallback_path(cx),\n         Some(ref abs_path) => {\n             if abs_path.is_relative() {\n-                cx.sess.warn(\"debuginfo: Invalid path to crate's local root source file!\");\n+                cx.sess().warn(\"debuginfo: Invalid path to crate's local root source file!\");\n                 fallback_path(cx)\n             } else {\n                 match abs_path.path_relative_from(work_dir) {\n@@ -917,7 +917,7 @@ fn compile_unit_metadata(cx: &CrateContext) {\n                                 compile_unit_name,\n                                 work_dir,\n                                 producer,\n-                                cx.sess.opts.optimize != session::No,\n+                                cx.sess().opts.optimize != session::No,\n                                 flags,\n                                 0,\n                                 split_name);\n@@ -968,7 +968,7 @@ fn declare_local(bcx: &Block,\n                         file_metadata,\n                         loc.line as c_uint,\n                         type_metadata,\n-                        cx.sess.opts.optimize != session::No,\n+                        cx.sess().opts.optimize != session::No,\n                         0,\n                         argument_index)\n                 }\n@@ -1028,7 +1028,7 @@ fn file_metadata(cx: &CrateContext, full_path: &str) -> DIFile {\n     debug!(\"file_metadata: {}\", full_path);\n \n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    let work_dir = cx.sess.working_dir.as_str().unwrap();\n+    let work_dir = cx.sess().working_dir.as_str().unwrap();\n     let file_name =\n         if full_path.starts_with(work_dir) {\n             full_path.slice(work_dir.len() + 1u, full_path.len())\n@@ -1063,7 +1063,7 @@ fn scope_metadata(fcx: &FunctionContext,\n         None => {\n             let node = fcx.ccx.tcx.map.get(node_id);\n \n-            fcx.ccx.sess.span_bug(span,\n+            fcx.ccx.sess().span_bug(span,\n                 format!(\"debuginfo: Could not find scope info for node {:?}\", node));\n         }\n     }\n@@ -1096,7 +1096,7 @@ fn basic_type_metadata(cx: &CrateContext, t: ty::t) -> DIType {\n             ast::TyF32 => (~\"f32\", DW_ATE_float),\n             ast::TyF64 => (~\"f64\", DW_ATE_float)\n         },\n-        _ => cx.sess.bug(\"debuginfo::basic_type_metadata - t is invalid type\")\n+        _ => cx.sess().bug(\"debuginfo::basic_type_metadata - t is invalid type\")\n     };\n \n     let llvm_type = type_of::type_of(cx, t);\n@@ -1329,7 +1329,7 @@ impl GeneralMemberDescriptionFactory {\n         // Capture type_rep, so we don't have to copy the struct_defs array\n         let struct_defs = match *self.type_rep {\n             adt::General(_, ref struct_defs) => struct_defs,\n-            _ => cx.sess.bug(\"unreachable\")\n+            _ => cx.sess().bug(\"unreachable\")\n         };\n \n         struct_defs\n@@ -1653,9 +1653,9 @@ fn set_members_of_composite_type(cx: &CrateContext,\n         let mut composite_types_completed =\n             debug_context(cx).composite_types_completed.borrow_mut();\n         if composite_types_completed.get().contains(&composite_type_metadata) {\n-            cx.sess.span_bug(definition_span, \"debuginfo::set_members_of_composite_type() - \\\n-                                               Already completed forward declaration \\\n-                                               re-encountered.\");\n+            cx.sess().span_bug(definition_span, \"debuginfo::set_members_of_composite_type() - \\\n+                                                 Already completed forward declaration \\\n+                                                 re-encountered.\");\n         } else {\n             composite_types_completed.get().insert(composite_type_metadata);\n         }\n@@ -1856,7 +1856,7 @@ fn vec_metadata(cx: &CrateContext,\n     let element_llvm_type = type_of::type_of(cx, element_type);\n     let (element_size, element_align) = size_and_align_of(cx, element_llvm_type);\n \n-    let vec_llvm_type = Type::vec(cx.sess.targ_cfg.arch, &element_llvm_type);\n+    let vec_llvm_type = Type::vec(cx.sess().targ_cfg.arch, &element_llvm_type);\n     let vec_type_name: &str = format!(\"[{}]\", ppaux::ty_to_str(cx.tcx, element_type));\n \n     let member_llvm_types = vec_llvm_type.field_types();\n@@ -2144,7 +2144,7 @@ fn type_metadata(cx: &CrateContext,\n                                    elements.as_slice(),\n                                    usage_site_span).finalize(cx)\n         }\n-        _ => cx.sess.bug(format!(\"debuginfo: unexpected type in type_metadata: {:?}\", sty))\n+        _ => cx.sess().bug(format!(\"debuginfo: unexpected type in type_metadata: {:?}\", sty))\n     };\n \n     let mut created_types = debug_context(cx).created_types.borrow_mut();\n@@ -2218,7 +2218,7 @@ fn generate_unique_type_id(prefix: &'static str) -> ~str {\n \n /// Return codemap::Loc corresponding to the beginning of the span\n fn span_start(cx: &CrateContext, span: Span) -> codemap::Loc {\n-    cx.sess.codemap.lookup_char_pos(span.lo)\n+    cx.sess().codemap.lookup_char_pos(span.lo)\n }\n \n fn size_and_align_of(cx: &CrateContext, llvm_type: Type) -> (u64, u64) {\n@@ -2250,7 +2250,7 @@ fn fn_should_be_ignored(fcx: &FunctionContext) -> bool {\n fn assert_type_for_node_id(cx: &CrateContext, node_id: ast::NodeId, error_span: Span) {\n     let node_types = cx.tcx.node_types.borrow();\n     if !node_types.get().contains_key(&(node_id as uint)) {\n-        cx.sess.span_bug(error_span, \"debuginfo: Could not find type for node id!\");\n+        cx.sess().span_bug(error_span, \"debuginfo: Could not find type for node id!\");\n     }\n }\n \n@@ -2315,7 +2315,7 @@ fn populate_scope_map(cx: &CrateContext,\n                                    &mut Vec<ScopeStackEntry> ,\n                                    &mut HashMap<ast::NodeId, DIScope>|) {\n         // Create a new lexical scope and push it onto the stack\n-        let loc = cx.sess.codemap.lookup_char_pos(scope_span.lo);\n+        let loc = cx.sess().codemap.lookup_char_pos(scope_span.lo);\n         let file_metadata = file_metadata(cx, loc.file.name);\n         let parent_scope = scope_stack.last().unwrap().scope_metadata;\n \n@@ -2338,7 +2338,7 @@ fn populate_scope_map(cx: &CrateContext,\n         }\n \n         if scope_stack.last().unwrap().scope_metadata != scope_metadata {\n-            cx.sess.span_bug(scope_span, \"debuginfo: Inconsistency in scope management.\");\n+            cx.sess().span_bug(scope_span, \"debuginfo: Inconsistency in scope management.\");\n         }\n \n         scope_stack.pop();\n@@ -2432,7 +2432,7 @@ fn populate_scope_map(cx: &CrateContext,\n \n                     if need_new_scope {\n                         // Create a new lexical scope and push it onto the stack\n-                        let loc = cx.sess.codemap.lookup_char_pos(pat.span.lo);\n+                        let loc = cx.sess().codemap.lookup_char_pos(pat.span.lo);\n                         let file_metadata = file_metadata(cx, loc.file.name);\n                         let parent_scope = scope_stack.last().unwrap().scope_metadata;\n \n@@ -2614,13 +2614,13 @@ fn populate_scope_map(cx: &CrateContext,\n             }\n \n             ast::ExprForLoop(_, _, _, _) => {\n-                cx.sess.span_bug(exp.span, \"debuginfo::populate_scope_map() - \\\n-                                            Found unexpanded for-loop.\");\n+                cx.sess().span_bug(exp.span, \"debuginfo::populate_scope_map() - \\\n+                                              Found unexpanded for-loop.\");\n             }\n \n             ast::ExprMac(_) => {\n-                cx.sess.span_bug(exp.span, \"debuginfo::populate_scope_map() - \\\n-                                            Found unexpanded macro.\");\n+                cx.sess().span_bug(exp.span, \"debuginfo::populate_scope_map() - \\\n+                                              Found unexpanded macro.\");\n             }\n \n             ast::ExprLoop(block, _) |\n@@ -2827,7 +2827,7 @@ fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> @NamespaceTreeNo\n         match parent_node {\n             Some(node) => node,\n             None => {\n-                cx.sess.bug(format!(\"debuginfo::namespace_for_item(): \\\n+                cx.sess().bug(format!(\"debuginfo::namespace_for_item(): \\\n                     path too short for {:?}\", def_id));\n             }\n         }"}, {"sha": "55259cdae1cb1bb74446771514335265bc851026", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=4fae06824ce1a3de3d24677196bf2e0d53346830", "patch": "@@ -581,7 +581,7 @@ fn trans_def<'a>(bcx: &'a Block<'a>,\n                     unsafe {\n                         let llty = type_of::type_of(bcx.ccx(), const_ty);\n                         let symbol = csearch::get_symbol(\n-                            bcx.ccx().sess.cstore,\n+                            bcx.ccx().sess().cstore,\n                             did);\n                         let llval = symbol.with_c_str(|buf| {\n                                 llvm::LLVMAddGlobal(bcx.ccx().llmod,\n@@ -1618,16 +1618,16 @@ fn trans_imm_cast<'a>(bcx: &'a Block<'a>,\n                                           val_ty(lldiscrim_a),\n                                           lldiscrim_a, true),\n                 cast_float => SIToFP(bcx, lldiscrim_a, ll_t_out),\n-                _ => ccx.sess.bug(format!(\"translating unsupported cast: \\\n-                                          {} ({:?}) -> {} ({:?})\",\n-                                          t_in.repr(ccx.tcx), k_in,\n-                                          t_out.repr(ccx.tcx), k_out))\n+                _ => ccx.sess().bug(format!(\"translating unsupported cast: \\\n+                                            {} ({:?}) -> {} ({:?})\",\n+                                            t_in.repr(ccx.tcx), k_in,\n+                                            t_out.repr(ccx.tcx), k_out))\n             }\n         }\n-        _ => ccx.sess.bug(format!(\"translating unsupported cast: \\\n-                                  {} ({:?}) -> {} ({:?})\",\n-                                  t_in.repr(ccx.tcx), k_in,\n-                                  t_out.repr(ccx.tcx), k_out))\n+        _ => ccx.sess().bug(format!(\"translating unsupported cast: \\\n+                                    {} ({:?}) -> {} ({:?})\",\n+                                    t_in.repr(ccx.tcx), k_in,\n+                                    t_out.repr(ccx.tcx), k_out))\n     };\n     return immediate_rvalue_bcx(bcx, newval, t_out).to_expr_datumblock();\n }\n@@ -1665,7 +1665,6 @@ fn trans_assign_op<'a>(\n     return result_datum.store_to(bcx, dst_datum.val);\n }\n \n-\n fn auto_ref<'a>(bcx: &'a Block<'a>,\n                 datum: Datum<Expr>,\n                 expr: &ast::Expr)"}, {"sha": "ab3339339d227952523f91b2578890cfb1ffc259", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=4fae06824ce1a3de3d24677196bf2e0d53346830", "patch": "@@ -75,23 +75,23 @@ struct LlvmSignature {\n \n pub fn llvm_calling_convention(ccx: &CrateContext,\n                                abis: AbiSet) -> Option<CallConv> {\n-    let os = ccx.sess.targ_cfg.os;\n-    let arch = ccx.sess.targ_cfg.arch;\n+    let os = ccx.sess().targ_cfg.os;\n+    let arch = ccx.sess().targ_cfg.arch;\n     abis.for_target(os, arch).map(|abi| {\n         match abi {\n             RustIntrinsic => {\n                 // Intrinsics are emitted by monomorphic fn\n-                ccx.sess.bug(format!(\"asked to register intrinsic fn\"));\n+                ccx.sess().bug(format!(\"asked to register intrinsic fn\"));\n             }\n \n             Rust => {\n                 // FIXME(#3678) Implement linking to foreign fns with Rust ABI\n-                ccx.sess.unimpl(\n+                ccx.sess().unimpl(\n                     format!(\"foreign functions with Rust ABI\"));\n             }\n \n             // It's the ABI's job to select this, not us.\n-            System => ccx.sess.bug(\"system abi should be selected elsewhere\"),\n+            System => ccx.sess().bug(\"system abi should be selected elsewhere\"),\n \n             Stdcall => lib::llvm::X86StdcallCallConv,\n             Fastcall => lib::llvm::X86FastcallCallConv,\n@@ -222,7 +222,7 @@ pub fn register_foreign_item_fn(ccx: @CrateContext, abis: AbiSet,\n     let cc = match llvm_calling_convention(ccx, abis) {\n         Some(cc) => cc,\n         None => {\n-            ccx.sess.span_fatal(foreign_item.span,\n+            ccx.sess().span_fatal(foreign_item.span,\n                 format!(\"ABI `{}` has no suitable calling convention \\\n                       for target architecture\",\n                       abis.user_string(ccx.tcx)));\n@@ -294,7 +294,7 @@ pub fn trans_native_call<'a>(\n \n     let (fn_abis, fn_sig) = match ty::get(callee_ty).sty {\n         ty::ty_bare_fn(ref fn_ty) => (fn_ty.abis, fn_ty.sig.clone()),\n-        _ => ccx.sess.bug(\"trans_native_call called on non-function type\")\n+        _ => ccx.sess().bug(\"trans_native_call called on non-function type\")\n     };\n     let llsig = foreign_signature(ccx, &fn_sig, passed_arg_tys.as_slice());\n     let ret_def = !return_type_is_void(bcx.ccx(), fn_sig.output);\n@@ -383,7 +383,7 @@ pub fn trans_native_call<'a>(\n         Some(cc) => cc,\n         None => {\n             // FIXME(#8357) We really ought to report a span here\n-            ccx.sess.fatal(\n+            ccx.sess().fatal(\n                 format!(\"ABI string `{}` has no suitable ABI \\\n                         for target architecture\",\n                         fn_abis.user_string(ccx.tcx)));\n@@ -563,10 +563,10 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @CrateContext,\n                 f\n             }\n             _ => {\n-                ccx.sess.bug(format!(\"build_rust_fn: extern fn {} has ty {}, \\\n-                                  expected a bare fn ty\",\n-                                  ccx.tcx.map.path_to_str(id),\n-                                  t.repr(tcx)));\n+                ccx.sess().bug(format!(\"build_rust_fn: extern fn {} has ty {}, \\\n+                                       expected a bare fn ty\",\n+                                       ccx.tcx.map.path_to_str(id),\n+                                       t.repr(tcx)));\n             }\n         };\n \n@@ -860,7 +860,7 @@ fn foreign_types_for_fn_ty(ccx: &CrateContext,\n                            ty: ty::t) -> ForeignTypes {\n     let fn_sig = match ty::get(ty).sty {\n         ty::ty_bare_fn(ref fn_ty) => fn_ty.sig.clone(),\n-        _ => ccx.sess.bug(\"foreign_types_for_fn_ty called on non-function type\")\n+        _ => ccx.sess().bug(\"foreign_types_for_fn_ty called on non-function type\")\n     };\n     let llsig = foreign_signature(ccx, &fn_sig, fn_sig.inputs.as_slice());\n     let ret_def = !return_type_is_void(ccx, fn_sig.output);"}, {"sha": "11fc2fcdc090a2935683dcaf9cd95a1cbd9d7b4f", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=4fae06824ce1a3de3d24677196bf2e0d53346830", "patch": "@@ -173,7 +173,7 @@ pub fn call_visit_glue(bcx: &Block, v: ValueRef, tydesc: ValueRef,\n     let ccx = bcx.ccx();\n     // NB: Don't short-circuit even if this block is unreachable because\n     // GC-based cleanup needs to the see that the roots are live.\n-    if bcx.unreachable.get() && !ccx.sess.no_landing_pads() { return; }\n+    if bcx.unreachable.get() && !ccx.sess().no_landing_pads() { return; }\n \n     let static_glue_fn = match static_ti {\n         None => None,\n@@ -403,7 +403,7 @@ pub fn declare_tydesc(ccx: &CrateContext, t: ty::t) -> @tydesc_info {\n \n     let llty = type_of(ccx, t);\n \n-    if ccx.sess.count_type_sizes() {\n+    if ccx.sess().count_type_sizes() {\n         println!(\"{}\\t{}\", llsize_of_real(ccx, llty),\n                  ppaux::ty_to_str(ccx.tcx, t));\n     }"}, {"sha": "0ab113a546fca881375f6d5b6f3b73fecd960c21", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=4fae06824ce1a3de3d24677196bf2e0d53346830", "patch": "@@ -122,14 +122,14 @@ pub fn maybe_instantiate_inline(ccx: @CrateContext, fn_id: ast::DefId)\n                 }\n               }\n             }\n-            _ => ccx.sess.bug(\"maybe_instantiate_inline: item has a \\\n-                               non-enum, non-struct parent\")\n+            _ => ccx.sess().bug(\"maybe_instantiate_inline: item has a \\\n+                                 non-enum, non-struct parent\")\n           }\n           trans_item(ccx, item);\n           local_def(my_id)\n         }\n         csearch::found_parent(_, _) => {\n-            ccx.sess.bug(\"maybe_get_item_ast returned a found_parent \\\n+            ccx.sess().bug(\"maybe_get_item_ast returned a found_parent \\\n              with a non-item parent\");\n         }\n         csearch::found(ast::IIMethod(impl_did, is_provided, mth)) => {"}, {"sha": "c4208906043c0698a4fcf266e0babcad6c059800", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=4fae06824ce1a3de3d24677196bf2e0d53346830", "patch": "@@ -218,7 +218,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n                 \"acq\"     => lib::llvm::Acquire,\n                 \"rel\"     => lib::llvm::Release,\n                 \"acqrel\"  => lib::llvm::AcquireRelease,\n-                _ => ccx.sess.fatal(\"unknown ordering in atomic intrinsic\")\n+                _ => ccx.sess().fatal(\"unknown ordering in atomic intrinsic\")\n             }\n         };\n \n@@ -259,7 +259,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n                     \"min\"   => lib::llvm::Min,\n                     \"umax\"  => lib::llvm::UMax,\n                     \"umin\"  => lib::llvm::UMin,\n-                    _ => ccx.sess.fatal(\"unknown atomic operation\")\n+                    _ => ccx.sess().fatal(\"unknown atomic operation\")\n                 };\n \n                 let old = AtomicRMW(bcx, atom_op, get_param(decl, first_real_arg),\n@@ -377,7 +377,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n                     ast_map::NodeExpr(e) => e.span,\n                     _ => fail!(\"transmute has non-expr arg\"),\n                 };\n-                ccx.sess.span_fatal(sp,\n+                ccx.sess().span_fatal(sp,\n                     format!(\"transmute called on types with different sizes: \\\n                              {intype} ({insize, plural, =1{# bit} other{# bits}}) to \\\n                              {outtype} ({outsize, plural, =1{# bit} other{# bits}})\",\n@@ -527,7 +527,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n         _ => {\n             // Could we make this an enum rather than a string? does it get\n             // checked earlier?\n-            ccx.sess.span_bug(item.span, \"unknown intrinsic\");\n+            ccx.sess().span_bug(item.span, \"unknown intrinsic\");\n         }\n     }\n     fcx.cleanup();"}, {"sha": "68f21a6ff0ba983491076e767aabd23cad68a13e", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=4fae06824ce1a3de3d24677196bf2e0d53346830", "patch": "@@ -108,8 +108,8 @@ pub fn trans_method_callee<'a>(\n             (method.origin, method.ty)\n         }\n         None => {\n-            bcx.tcx().sess.span_bug(bcx.tcx().map.span(method_call.expr_id),\n-                                    \"method call expr wasn't in method map\")\n+            bcx.sess().span_bug(bcx.tcx().map.span(method_call.expr_id),\n+                                \"method call expr wasn't in method map\")\n         }\n     };\n \n@@ -145,9 +145,9 @@ pub fn trans_method_callee<'a>(\n             let self_expr = match self_expr {\n                 Some(self_expr) => self_expr,\n                 None => {\n-                    bcx.tcx().sess.span_bug(bcx.tcx().map.span(method_call.expr_id),\n-                                            \"self expr wasn't provided for trait object \\\n-                                            callee (trying to call overloaded op?)\")\n+                    bcx.sess().span_bug(bcx.tcx().map.span(method_call.expr_id),\n+                                        \"self expr wasn't provided for trait object \\\n+                                         callee (trying to call overloaded op?)\")\n                 }\n             };\n             trans_trait_callee(bcx,\n@@ -425,7 +425,7 @@ pub fn trans_trait_callee_from_llval<'a>(bcx: &'a Block<'a>,\n             type_of_rust_fn(ccx, true, f.sig.inputs.slice_from(1), f.sig.output)\n         }\n         _ => {\n-            ccx.sess.bug(\"meth::trans_trait_callee given non-bare-rust-fn\");\n+            ccx.sess().bug(\"meth::trans_trait_callee given non-bare-rust-fn\");\n         }\n     };\n     let llvtable = Load(bcx,\n@@ -500,7 +500,7 @@ pub fn get_vtable(bcx: &Block,\n                     methods.push(vtable_method)\n                 }\n             }\n-            _ => ccx.sess.bug(\"get_vtable: expected a static origin\"),\n+            _ => ccx.sess().bug(\"get_vtable: expected a static origin\"),\n         }\n     }\n \n@@ -548,8 +548,8 @@ fn emit_vtable_methods(bcx: &Block,\n \n     let trt_id = match ty::impl_trait_ref(tcx, impl_id) {\n         Some(t_id) => t_id.def_id,\n-        None       => ccx.sess.bug(\"make_impl_vtable: don't know how to \\\n-                                    make a vtable for a type impl!\")\n+        None       => ccx.sess().bug(\"make_impl_vtable: don't know how to \\\n+                                      make a vtable for a type impl!\")\n     };\n \n     ty::populate_implementations_for_trait_if_necessary(bcx.tcx(), trt_id);"}, {"sha": "4a5dcf148e0091b219f79952a5e977de215c5857", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=4fae06824ce1a3de3d24677196bf2e0d53346830", "patch": "@@ -95,7 +95,7 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n     let mut is_static_provided = None;\n \n     let map_node = session::expect(\n-        ccx.sess,\n+        ccx.sess(),\n         ccx.tcx.map.find(fn_id.node),\n         || format!(\"while monomorphizing {:?}, couldn't find it in the \\\n                     item map (may have attempted to monomorphize an item \\\n@@ -172,8 +172,8 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n         // Random cut-off -- code that needs to instantiate the same function\n         // recursively more than thirty times can probably safely be assumed\n         // to be causing an infinite expansion.\n-        if depth > ccx.sess.recursion_limit.get() {\n-            ccx.sess.span_fatal(ccx.tcx.map.span(fn_id.node),\n+        if depth > ccx.sess().recursion_limit.get() {\n+            ccx.sess().span_fatal(ccx.tcx.map.span(fn_id.node),\n                 \"reached the recursion limit during monomorphization\");\n         }\n \n@@ -207,7 +207,7 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n                   d\n               }\n               _ => {\n-                ccx.tcx.sess.bug(\"Can't monomorphize this kind of item\")\n+                ccx.sess().bug(\"Can't monomorphize this kind of item\")\n               }\n             }\n         }\n@@ -239,7 +239,7 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n                                        d);\n                 }\n                 ast::StructVariantKind(_) =>\n-                    ccx.tcx.sess.bug(\"can't monomorphize struct variants\"),\n+                    ccx.sess().bug(\"can't monomorphize struct variants\"),\n             }\n             d\n         }\n@@ -258,8 +258,8 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n                     d\n                 }\n                 _ => {\n-                    ccx.tcx.sess.bug(format!(\"can't monomorphize a {:?}\",\n-                                             map_node))\n+                    ccx.sess().bug(format!(\"can't monomorphize a {:?}\",\n+                                           map_node))\n                 }\n             }\n         }\n@@ -281,7 +281,7 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n         ast_map::NodeArg(..) |\n         ast_map::NodeBlock(..) |\n         ast_map::NodeLocal(..) => {\n-            ccx.tcx.sess.bug(format!(\"can't monomorphize a {:?}\", map_node))\n+            ccx.sess().bug(format!(\"can't monomorphize a {:?}\", map_node))\n         }\n     };\n "}, {"sha": "f1130fced24c3237d8667aadf50deac03a7e09a5", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=4fae06824ce1a3de3d24677196bf2e0d53346830", "patch": "@@ -86,7 +86,7 @@ pub fn type_of_fn_from_ty(cx: &CrateContext, fty: ty::t) -> Type {\n             }\n         }\n         _ => {\n-            cx.sess.bug(\"type_of_fn_from_ty given non-closure, non-bare-fn\")\n+            cx.sess().bug(\"type_of_fn_from_ty given non-closure, non-bare-fn\")\n         }\n     }\n }\n@@ -142,7 +142,7 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n \n         ty::ty_unboxed_vec(mt) => {\n             let sz_ty = sizing_type_of(cx, mt.ty);\n-            Type::vec(cx.sess.targ_cfg.arch, &sz_ty)\n+            Type::vec(cx.sess().targ_cfg.arch, &sz_ty)\n         }\n \n         ty::ty_tup(..) | ty::ty_enum(..) => {\n@@ -162,7 +162,8 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n         }\n \n         ty::ty_self(_) | ty::ty_infer(..) | ty::ty_param(..) | ty::ty_err(..) => {\n-            cx.tcx.sess.bug(format!(\"fictitious type {:?} in sizing_type_of()\", ty::get(t).sty))\n+            cx.sess().bug(format!(\"fictitious type {:?} in sizing_type_of()\",\n+                                  ty::get(t).sty))\n         }\n     };\n \n@@ -212,7 +213,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n       ty::ty_uint(t) => Type::uint_from_ty(cx, t),\n       ty::ty_float(t) => Type::float_from_ty(t),\n       ty::ty_str(ty::vstore_uniq) => {\n-        Type::vec(cx.sess.targ_cfg.arch, &Type::i8()).ptr_to()\n+        Type::vec(cx.sess().targ_cfg.arch, &Type::i8()).ptr_to()\n       }\n       ty::ty_enum(did, ref substs) => {\n         // Only create the named struct, but don't fill it in. We\n@@ -231,11 +232,11 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n       }\n       ty::ty_vec(ref mt, ty::vstore_uniq) => {\n           let ty = type_of(cx, mt.ty);\n-          Type::vec(cx.sess.targ_cfg.arch, &ty).ptr_to()\n+          Type::vec(cx.sess().targ_cfg.arch, &ty).ptr_to()\n       }\n       ty::ty_unboxed_vec(ref mt) => {\n           let ty = type_of(cx, mt.ty);\n-          Type::vec(cx.sess.targ_cfg.arch, &ty)\n+          Type::vec(cx.sess().targ_cfg.arch, &ty)\n       }\n       ty::ty_ptr(ref mt) => type_of(cx, mt.ty).ptr_to(),\n       ty::ty_rptr(_, ref mt) => type_of(cx, mt.ty).ptr_to(),\n@@ -288,10 +289,10 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n               adt::incomplete_type_of(cx, repr, name)\n           }\n       }\n-      ty::ty_self(..) => cx.tcx.sess.unimpl(\"type_of: ty_self\"),\n-      ty::ty_infer(..) => cx.tcx.sess.bug(\"type_of with ty_infer\"),\n-      ty::ty_param(..) => cx.tcx.sess.bug(\"type_of with ty_param\"),\n-      ty::ty_err(..) => cx.tcx.sess.bug(\"type_of with ty_err\")\n+      ty::ty_self(..) => cx.sess().unimpl(\"type_of: ty_self\"),\n+      ty::ty_infer(..) => cx.sess().bug(\"type_of with ty_infer\"),\n+      ty::ty_param(..) => cx.sess().bug(\"type_of with ty_param\"),\n+      ty::ty_err(..) => cx.sess().bug(\"type_of with ty_err\")\n     };\n \n     debug!(\"--> mapped t={} {:?} to llty={}\","}, {"sha": "51787aedff8bddd6f5ce466711ac6b16e2aed938", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=4fae06824ce1a3de3d24677196bf2e0d53346830", "patch": "@@ -11,7 +11,7 @@\n #[allow(non_camel_case_types)];\n \n use back::svh::Svh;\n-use driver::session;\n+use driver::session::Session;\n use metadata::csearch;\n use metadata;\n use middle::const_eval;\n@@ -262,7 +262,7 @@ pub struct ctxt_ {\n     interner: RefCell<FnvHashMap<intern_key, ~t_box_>>,\n     next_id: Cell<uint>,\n     cstore: @metadata::cstore::CStore,\n-    sess: session::Session,\n+    sess: Session,\n     def_map: resolve::DefMap,\n \n     named_region_map: @RefCell<resolve_lifetime::NamedRegionMap>,\n@@ -1081,7 +1081,7 @@ pub type type_cache = RefCell<DefIdMap<ty_param_bounds_and_ty>>;\n \n pub type node_type_table = RefCell<HashMap<uint,t>>;\n \n-pub fn mk_ctxt(s: session::Session,\n+pub fn mk_ctxt(s: Session,\n                dm: resolve::DefMap,\n                named_region_map: @RefCell<resolve_lifetime::NamedRegionMap>,\n                map: ast_map::Map,"}, {"sha": "1dfbc29b7f41d0fa926e0340659faddcfb14f59d", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=4fae06824ce1a3de3d24677196bf2e0d53346830", "patch": "@@ -189,7 +189,7 @@ impl<'a> visit::Visitor<()> for PrivilegedScopeVisitor<'a> {\n             ItemImpl(_, None, ast_ty, _) => {\n                 if !self.cc.ast_type_is_defined_in_local_crate(ast_ty) {\n                     // This is an error.\n-                    let session = self.cc.crate_context.tcx.sess;\n+                    let session = &self.cc.crate_context.tcx.sess;\n                     session.span_err(item.span,\n                                      \"cannot associate methods with a type outside the \\\n                                      crate the type is defined in; define and implement \\\n@@ -210,7 +210,7 @@ impl<'a> visit::Visitor<()> for PrivilegedScopeVisitor<'a> {\n                         self.cc.trait_ref_to_trait_def_id(trait_ref);\n \n                     if trait_def_id.krate != LOCAL_CRATE {\n-                        let session = self.cc.crate_context.tcx.sess;\n+                        let session = &self.cc.crate_context.tcx.sess;\n                         session.span_err(item.span,\n                                 \"cannot provide an extension implementation \\\n                                 where both trait and type are not defined in this crate\");\n@@ -274,7 +274,7 @@ impl CoherenceChecker {\n                                        item.span,\n                                        self_type.ty) {\n                 None => {\n-                    let session = self.crate_context.tcx.sess;\n+                    let session = &self.crate_context.tcx.sess;\n                     session.span_err(item.span,\n                                      \"no base type found for inherent implementation; \\\n                                       implement a trait or new type instead\");\n@@ -447,7 +447,7 @@ impl CoherenceChecker {\n                             implementation_b);\n \n                     if self.polytypes_unify(polytype_a.clone(), polytype_b) {\n-                        let session = self.crate_context.tcx.sess;\n+                        let session = &self.crate_context.tcx.sess;\n                         session.span_err(\n                             self.span_of_impl(implementation_a),\n                             format!(\"conflicting implementations for trait `{}`\","}, {"sha": "858a7ae12636b839c2265c8aadce254ad0f6376f", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=4fae06824ce1a3de3d24677196bf2e0d53346830", "patch": "@@ -26,6 +26,7 @@ use rustc::metadata::decoder;\n \n use std;\n \n+use core;\n use doctree;\n use visit_ast;\n use std::local_data;\n@@ -84,7 +85,7 @@ impl<'a> Clean<Crate> for visit_ast::RustdocVisitor<'a> {\n         let cx = local_data::get(super::ctxtkey, |x| *x.unwrap());\n \n         let mut externs = ~[];\n-        cx.sess.cstore.iter_crate_data(|n, meta| {\n+        cx.sess().cstore.iter_crate_data(|n, meta| {\n             externs.push((n, meta.clean()));\n         });\n \n@@ -683,7 +684,7 @@ impl Clean<Type> for ast::Ty {\n     fn clean(&self) -> Type {\n         use syntax::ast::*;\n         debug!(\"cleaning type `{:?}`\", self);\n-        let codemap = local_data::get(super::ctxtkey, |x| *x.unwrap()).sess.codemap;\n+        let codemap = local_data::get(super::ctxtkey, |x| *x.unwrap()).sess().codemap;\n         debug!(\"span corresponds to `{}`\", codemap.span_to_str(self.span));\n         match self.node {\n             TyNil => Unit,\n@@ -865,7 +866,7 @@ pub struct Span {\n \n impl Clean<Span> for syntax::codemap::Span {\n     fn clean(&self) -> Span {\n-        let cm = local_data::get(super::ctxtkey, |x| *x.unwrap()).sess.codemap;\n+        let cm = local_data::get(super::ctxtkey, |x| *x.unwrap()).sess().codemap;\n         let filename = cm.span_to_filename(*self);\n         let lo = cm.lookup_char_pos(self.lo);\n         let hi = cm.lookup_char_pos(self.hi);\n@@ -1179,7 +1180,7 @@ trait ToSource {\n impl ToSource for syntax::codemap::Span {\n     fn to_src(&self) -> ~str {\n         debug!(\"converting span {:?} to snippet\", self.clean());\n-        let cm = local_data::get(super::ctxtkey, |x| x.unwrap().clone()).sess.codemap.clone();\n+        let cm = local_data::get(super::ctxtkey, |x| x.unwrap().clone()).sess().codemap.clone();\n         let sn = match cm.span_to_snippet(*self) {\n             Some(x) => x,\n             None    => ~\"\"\n@@ -1234,10 +1235,10 @@ fn name_from_pat(p: &ast::Pat) -> ~str {\n fn resolve_type(path: Path, tpbs: Option<~[TyParamBound]>,\n                 id: ast::NodeId) -> Type {\n     let cx = local_data::get(super::ctxtkey, |x| *x.unwrap());\n-    let tycx = match cx.tycx {\n-        Some(tycx) => tycx,\n+    let tycx = match cx.maybe_typed {\n+        core::Typed(ref tycx) => tycx,\n         // If we're extracting tests, this return value doesn't matter.\n-        None => return Bool\n+        core::NotTyped(_) => return Bool\n     };\n     debug!(\"searching for {:?} in defmap\", id);\n     let def_map = tycx.def_map.borrow();\n@@ -1289,12 +1290,12 @@ fn resolve_use_source(path: Path, id: ast::NodeId) -> ImportSource {\n \n fn resolve_def(id: ast::NodeId) -> Option<ast::DefId> {\n     let cx = local_data::get(super::ctxtkey, |x| *x.unwrap());\n-    match cx.tycx {\n-        Some(tcx) => {\n+    match cx.maybe_typed {\n+        core::Typed(ref tcx) => {\n             let def_map = tcx.def_map.borrow();\n             def_map.get().find(&id).map(|&d| ast_util::def_id_of_def(d))\n         }\n-        None => None\n+        core::NotTyped(_) => None\n     }\n }\n "}, {"sha": "41b46f2a3a48c9f1b0d0e6241c5ca4cbf545b96d", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 26, "deletions": 13, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=4fae06824ce1a3de3d24677196bf2e0d53346830", "patch": "@@ -27,10 +27,23 @@ use visit_ast::RustdocVisitor;\n use clean;\n use clean::Clean;\n \n+pub enum MaybeTyped {\n+    Typed(middle::ty::ctxt),\n+    NotTyped(driver::session::Session)\n+}\n+\n pub struct DocContext {\n     krate: ast::Crate,\n-    tycx: Option<middle::ty::ctxt>,\n-    sess: driver::session::Session\n+    maybe_typed: MaybeTyped\n+}\n+\n+impl DocContext {\n+    pub fn sess<'a>(&'a self) -> &'a driver::session::Session {\n+        match self.maybe_typed {\n+            Typed(ref tcx) => &tcx.sess,\n+            NotTyped(ref sess) => sess\n+        }\n+    }\n }\n \n pub struct CrateAnalysis {\n@@ -67,27 +80,27 @@ fn get_ast_and_resolve(cpath: &Path,\n                                               parsesess.cm,\n                                               span_diagnostic_handler);\n \n-    let mut cfg = build_configuration(sess);\n+    let mut cfg = build_configuration(&sess);\n     for cfg_ in cfgs.move_iter() {\n         let cfg_ = token::intern_and_get_ident(cfg_);\n         cfg.push(@dummy_spanned(ast::MetaWord(cfg_)));\n     }\n \n-    let krate = phase_1_parse_input(sess, cfg, &input);\n-    let loader = &mut Loader::new(sess);\n-    let id = from_str(\"rustdoc\").unwrap();\n-    let (krate, ast_map) = phase_2_configure_and_expand(sess, loader,\n-                                                        krate, &id);\n+    let krate = phase_1_parse_input(&sess, cfg, &input);\n+    let (krate, ast_map) = phase_2_configure_and_expand(&sess, &mut Loader::new(sess),\n+                                                        krate, &from_str(\"rustdoc\").unwrap());\n     let driver::driver::CrateAnalysis {\n         exported_items, public_items, ty_cx, ..\n     } = phase_3_run_analysis_passes(sess, &krate, ast_map);\n \n     debug!(\"crate: {:?}\", krate);\n-    return (DocContext { krate: krate, tycx: Some(ty_cx), sess: sess },\n-            CrateAnalysis {\n-                exported_items: exported_items,\n-                public_items: public_items,\n-            });\n+    (DocContext {\n+        krate: krate,\n+        maybe_typed: Typed(ty_cx)\n+    }, CrateAnalysis {\n+        exported_items: exported_items,\n+        public_items: public_items,\n+    })\n }\n \n pub fn run_core (libs: HashSet<Path>, cfgs: ~[~str], path: &Path) -> (clean::Crate, CrateAnalysis) {"}, {"sha": "ac87a4af48360dab921802dcf2c2c6c900cce346", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=4fae06824ce1a3de3d24677196bf2e0d53346830", "patch": "@@ -58,17 +58,14 @@ pub fn run(input: &str, libs: @RefCell<HashSet<Path>>, mut test_args: ~[~str]) -\n                                       parsesess.cm,\n                                       span_diagnostic_handler);\n \n-    let cfg = driver::build_configuration(sess);\n-    let krate = driver::phase_1_parse_input(sess, cfg, &input);\n-    let loader = &mut Loader::new(sess);\n-    let id = from_str(\"rustdoc-test\").unwrap();\n-    let (krate, _) = driver::phase_2_configure_and_expand(sess, loader, krate,\n-                                                          &id);\n+    let cfg = driver::build_configuration(&sess);\n+    let krate = driver::phase_1_parse_input(&sess, cfg, &input);\n+    let (krate, _) = driver::phase_2_configure_and_expand(sess, &mut Loader::new(sess), krate,\n+                                                          &from_str(\"rustdoc-test\").unwrap());\n \n     let ctx = @core::DocContext {\n         krate: krate,\n-        tycx: None,\n-        sess: sess,\n+        maybe_typed: core::NotTyped(sess),\n     };\n     local_data::set(super::ctxtkey, ctx);\n \n@@ -140,7 +137,7 @@ fn runtest(test: &str, cratename: &str, libs: HashSet<Path>, should_fail: bool,\n \n     let outdir = TempDir::new(\"rustdoctest\").expect(\"rustdoc needs a tempdir\");\n     let out = Some(outdir.path().clone());\n-    let cfg = driver::build_configuration(sess);\n+    let cfg = driver::build_configuration(&sess);\n     driver::compile_input(sess, cfg, &input, &out, &None);\n \n     if no_run { return }"}, {"sha": "c0a39112b69a74dcc1e481dc41d3179dce514fa7", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fae06824ce1a3de3d24677196bf2e0d53346830/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=4fae06824ce1a3de3d24677196bf2e0d53346830", "patch": "@@ -183,21 +183,18 @@ impl<'a> RustdocVisitor<'a> {\n \n     fn resolve_id(&mut self, id: ast::NodeId, glob: bool,\n                   om: &mut Module) -> bool {\n-        let def = {\n-            let dm = match self.cx.tycx {\n-                Some(tcx) => tcx.def_map.borrow(),\n-                None => return false,\n-            };\n-            ast_util::def_id_of_def(*dm.get().get(&id))\n+        let tcx = match self.cx.maybe_typed {\n+            core::Typed(ref tcx) => tcx,\n+            core::NotTyped(_) => return false\n         };\n+        let def = ast_util::def_id_of_def(*tcx.def_map.borrow().get().get(&id));\n         if !ast_util::is_local(def) { return false }\n         let analysis = match self.analysis {\n             Some(analysis) => analysis, None => return false\n         };\n         if analysis.public_items.contains(&def.node) { return false }\n \n-        let item = self.cx.tycx.unwrap().map.get(def.node);\n-        match item {\n+        match tcx.map.get(def.node) {\n             ast_map::NodeItem(it) => {\n                 if glob {\n                     match it.node {"}]}