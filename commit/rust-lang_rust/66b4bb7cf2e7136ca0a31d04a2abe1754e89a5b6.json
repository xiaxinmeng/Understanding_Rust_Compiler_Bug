{"sha": "66b4bb7cf2e7136ca0a31d04a2abe1754e89a5b6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2YjRiYjdjZjJlNzEzNmNhMGEzMWQwNGEyYWJlMTc1NGU4OWE1YjY=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-16T16:01:50Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-16T16:35:27Z"}, "message": "stacked borrows: track refs and derefs", "tree": {"sha": "0a44db7b8c48d8707c5184df91955a2680854650", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a44db7b8c48d8707c5184df91955a2680854650"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66b4bb7cf2e7136ca0a31d04a2abe1754e89a5b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66b4bb7cf2e7136ca0a31d04a2abe1754e89a5b6", "html_url": "https://github.com/rust-lang/rust/commit/66b4bb7cf2e7136ca0a31d04a2abe1754e89a5b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66b4bb7cf2e7136ca0a31d04a2abe1754e89a5b6/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "348f782085ea60cbda5a1bd0beb8cd62b0ebd142", "url": "https://api.github.com/repos/rust-lang/rust/commits/348f782085ea60cbda5a1bd0beb8cd62b0ebd142", "html_url": "https://github.com/rust-lang/rust/commit/348f782085ea60cbda5a1bd0beb8cd62b0ebd142"}], "stats": {"total": 454, "additions": 388, "deletions": 66}, "files": [{"sha": "1613da4a487afc6e315021a57f8ad30b81498a03", "filename": "src/fn_call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66b4bb7cf2e7136ca0a31d04a2abe1754e89a5b6/src%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b4bb7cf2e7136ca0a31d04a2abe1754e89a5b6/src%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffn_call.rs?ref=66b4bb7cf2e7136ca0a31d04a2abe1754e89a5b6", "patch": "@@ -44,7 +44,7 @@ pub trait EvalContextExt<'tcx, 'mir> {\n     fn write_null(&mut self, dest: PlaceTy<'tcx, Borrow>) -> EvalResult<'tcx>;\n }\n \n-impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for EvalContext<'a, 'mir, 'tcx, super::Evaluator<'tcx>> {\n+impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalContext<'a, 'mir, 'tcx> {\n     fn find_fn(\n         &mut self,\n         instance: ty::Instance<'tcx>,"}, {"sha": "719bc93939589aaa75bda01563c718bbbf0a550c", "filename": "src/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/66b4bb7cf2e7136ca0a31d04a2abe1754e89a5b6/src%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b4bb7cf2e7136ca0a31d04a2abe1754e89a5b6/src%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic.rs?ref=66b4bb7cf2e7136ca0a31d04a2abe1754e89a5b6", "patch": "@@ -3,10 +3,9 @@ use rustc::ty::layout::{self, LayoutOf, Size};\n use rustc::ty;\n \n use rustc::mir::interpret::{EvalResult, PointerArithmetic};\n-use rustc_mir::interpret::{EvalContext, PlaceTy, OpTy};\n \n use super::{\n-    Value, Scalar, ScalarMaybeUndef, Borrow,\n+    PlaceTy, OpTy, Value, Scalar, ScalarMaybeUndef, Borrow,\n     FalibleScalarExt, OperatorEvalContextExt\n };\n \n@@ -19,7 +18,7 @@ pub trait EvalContextExt<'tcx> {\n     ) -> EvalResult<'tcx>;\n }\n \n-impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super::Evaluator<'tcx>> {\n+impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, 'tcx> {\n     fn call_intrinsic(\n         &mut self,\n         instance: ty::Instance<'tcx>,"}, {"sha": "97b73e60692cd2eea6b4b8cb8f80586183838b76", "filename": "src/lib.rs", "status": "modified", "additions": 45, "deletions": 4, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/66b4bb7cf2e7136ca0a31d04a2abe1754e89a5b6/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b4bb7cf2e7136ca0a31d04a2abe1754e89a5b6/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=66b4bb7cf2e7136ca0a31d04a2abe1754e89a5b6", "patch": "@@ -16,7 +16,7 @@ extern crate syntax;\n use std::collections::HashMap;\n use std::borrow::Cow;\n \n-use rustc::ty::{self, TyCtxt, query::TyCtxtAt};\n+use rustc::ty::{self, Ty, TyCtxt, query::TyCtxtAt};\n use rustc::ty::layout::{TyLayout, LayoutOf, Size};\n use rustc::hir::def_id::DefId;\n use rustc::mir;\n@@ -43,7 +43,7 @@ use tls::{EvalContextExt as TlsEvalContextExt, TlsData};\n use range_map::RangeMap;\n use helpers::FalibleScalarExt;\n use mono_hash_map::MonoHashMap;\n-use stacked_borrows::Borrow;\n+use stacked_borrows::{EvalContextExt as StackedBorEvalContextExt, Borrow};\n \n pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -232,7 +232,6 @@ impl MayLeak for MiriMemoryKind {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq)]\n pub struct Evaluator<'tcx> {\n     /// Environment variables set by `setenv`\n     /// Miri does not expose env vars from the host to the emulated program\n@@ -243,6 +242,9 @@ pub struct Evaluator<'tcx> {\n \n     /// Whether to enforce the validity invariant\n     pub(crate) validate: bool,\n+\n+    /// Stacked Borrows state\n+    pub(crate) stacked_borrows: stacked_borrows::State,\n }\n \n impl<'tcx> Evaluator<'tcx> {\n@@ -251,13 +253,18 @@ impl<'tcx> Evaluator<'tcx> {\n             env_vars: HashMap::default(),\n             tls: TlsData::default(),\n             validate,\n+            stacked_borrows: stacked_borrows::State::new(),\n         }\n     }\n }\n \n+#[allow(dead_code)] // FIXME https://github.com/rust-lang/rust/issues/47131\n+type MiriEvalContext<'a, 'mir, 'tcx> = EvalContext<'a, 'mir, 'tcx, Evaluator<'tcx>>;\n+\n+\n impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n     type MemoryKinds = MiriMemoryKind;\n-    type AllocExtra = ();\n+    type AllocExtra = stacked_borrows::Stacks;\n     type PointerTag = Borrow;\n \n     type MemoryMap = MonoHashMap<AllocId, (MemoryKind<MiriMemoryKind>, Allocation<Borrow, Self::AllocExtra>)>;\n@@ -288,6 +295,7 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n     }\n \n     /// Returns Ok() when the function was handled, fail otherwise\n+    #[inline(always)]\n     fn find_fn(\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n@@ -298,6 +306,7 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n         ecx.find_fn(instance, args, dest, ret)\n     }\n \n+    #[inline(always)]\n     fn call_intrinsic(\n         ecx: &mut rustc_mir::interpret::EvalContext<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n@@ -307,6 +316,7 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n         ecx.call_intrinsic(instance, args, dest)\n     }\n \n+    #[inline(always)]\n     fn ptr_op(\n         ecx: &rustc_mir::interpret::EvalContext<'a, 'mir, 'tcx, Self>,\n         bin_op: mir::BinOp,\n@@ -380,6 +390,7 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n         Ok(Cow::Owned(alloc))\n     }\n \n+    #[inline(always)]\n     fn before_terminator(_ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>) -> EvalResult<'tcx>\n     {\n         // We are not interested in detecting loops\n@@ -403,4 +414,34 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n         };\n         Cow::Owned(alloc)\n     }\n+\n+    #[inline(always)]\n+    fn tag_reference(\n+        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        ptr: Pointer<Self::PointerTag>,\n+        pointee_ty: Ty<'tcx>,\n+        pointee_size: Size,\n+        borrow_kind: mir::BorrowKind,\n+    ) -> EvalResult<'tcx, Self::PointerTag> {\n+        if !ecx.machine.validate {\n+            // No tracking\n+            Ok(Borrow::default())\n+        } else {\n+            ecx.tag_reference(ptr, pointee_ty, pointee_size, borrow_kind)\n+        }\n+    }\n+\n+    #[inline(always)]\n+    fn tag_dereference(\n+        ecx: &EvalContext<'a, 'mir, 'tcx, Self>,\n+        ptr: Pointer<Self::PointerTag>,\n+        ptr_ty: Ty<'tcx>,\n+    ) -> EvalResult<'tcx, Self::PointerTag> {\n+        if !ecx.machine.validate {\n+            // No tracking\n+            Ok(Borrow::default())\n+        } else {\n+            ecx.tag_dereference(ptr, ptr_ty)\n+        }\n+    }\n }"}, {"sha": "a11f8f34e7e86170c6a309cd0e1eb6f5a51f1816", "filename": "src/operator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66b4bb7cf2e7136ca0a31d04a2abe1754e89a5b6/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b4bb7cf2e7136ca0a31d04a2abe1754e89a5b6/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=66b4bb7cf2e7136ca0a31d04a2abe1754e89a5b6", "patch": "@@ -36,7 +36,7 @@ pub trait EvalContextExt<'tcx> {\n     ) -> EvalResult<'tcx, Scalar<Borrow>>;\n }\n \n-impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super::Evaluator<'tcx>> {\n+impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, 'tcx> {\n     fn ptr_op(\n         &self,\n         bin_op: mir::BinOp,"}, {"sha": "1d9a38cb5ef5366db3f924f27ceba3f98d0f8f30", "filename": "src/range_map.rs", "status": "modified", "additions": 98, "deletions": 52, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/66b4bb7cf2e7136ca0a31d04a2abe1754e89a5b6/src%2Frange_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b4bb7cf2e7136ca0a31d04a2abe1754e89a5b6/src%2Frange_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frange_map.rs?ref=66b4bb7cf2e7136ca0a31d04a2abe1754e89a5b6", "patch": "@@ -9,26 +9,40 @@\n use std::collections::BTreeMap;\n use std::ops;\n \n+use rustc::ty::layout::Size;\n+\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub struct RangeMap<T> {\n     map: BTreeMap<Range, T>,\n }\n \n+impl<T> Default for RangeMap<T> {\n+    #[inline(always)]\n+    fn default() -> Self {\n+        RangeMap::new()\n+    }\n+}\n+\n // The derived `Ord` impl sorts first by the first field, then, if the fields are the same,\n // by the second field.\n // This is exactly what we need for our purposes, since a range query on a BTReeSet/BTreeMap will give us all\n // `MemoryRange`s whose `start` is <= than the one we're looking for, but not > the end of the range we're checking.\n // At the same time the `end` is irrelevant for the sorting and range searching, but used for the check.\n // This kind of search breaks, if `end < start`, so don't do that!\n #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Debug)]\n-pub struct Range {\n+struct Range {\n     start: u64,\n     end: u64, // Invariant: end > start\n }\n \n impl Range {\n+    /// Compute a range of ranges that contains all ranges overlaping with [offset, offset+len)\n     fn range(offset: u64, len: u64) -> ops::Range<Range> {\n-        assert!(len > 0);\n+        if len == 0 {\n+            // We can produce an empty range, nothing overlaps with this.\n+            let r = Range { start: 0, end: 1 };\n+            return r..r;\n+        }\n         // We select all elements that are within\n         // the range given by the offset into the allocation and the length.\n         // This is sound if all ranges that intersect with the argument range, are in the\n@@ -46,14 +60,20 @@ impl Range {\n         left..right\n     }\n \n-    /// Tests if all of [offset, offset+len) are contained in this range.\n+    /// Tests if any element of [offset, offset+len) is contained in this range.\n+    #[inline(always)]\n     fn overlaps(&self, offset: u64, len: u64) -> bool {\n-        assert!(len > 0);\n-        offset < self.end && offset + len >= self.start\n+        if len == 0 {\n+            // `offset` totally does not matter, we cannot overlap with an empty interval\n+            false\n+        } else {\n+            offset < self.end && offset.checked_add(len).unwrap() >= self.start\n+        }\n     }\n }\n \n impl<T> RangeMap<T> {\n+    #[inline(always)]\n     pub fn new() -> RangeMap<T> {\n         RangeMap { map: BTreeMap::new() }\n     }\n@@ -63,10 +83,9 @@ impl<T> RangeMap<T> {\n         offset: u64,\n         len: u64,\n     ) -> impl Iterator<Item = (&'a Range, &'a T)> + 'a {\n-        assert!(len > 0);\n         self.map.range(Range::range(offset, len)).filter_map(\n-            move |(range,\n-                   data)| {\n+            move |(range, data)| {\n+                debug_assert!(len > 0);\n                 if range.overlaps(offset, len) {\n                     Some((range, data))\n                 } else {\n@@ -76,8 +95,8 @@ impl<T> RangeMap<T> {\n         )\n     }\n \n-    pub fn iter<'a>(&'a self, offset: u64, len: u64) -> impl Iterator<Item = &'a T> + 'a {\n-        self.iter_with_range(offset, len).map(|(_, data)| data)\n+    pub fn iter<'a>(&'a self, offset: Size, len: Size) -> impl Iterator<Item = &'a T> + 'a {\n+        self.iter_with_range(offset.bytes(), len.bytes()).map(|(_, data)| data)\n     }\n \n     fn split_entry_at(&mut self, offset: u64)\n@@ -114,28 +133,30 @@ impl<T> RangeMap<T> {\n         }\n     }\n \n-    pub fn iter_mut_all<'a>(&'a mut self) -> impl Iterator<Item = &'a mut T> + 'a {\n-        self.map.values_mut()\n-    }\n-\n     /// Provide mutable iteration over everything in the given range.  As a side-effect,\n     /// this will split entries in the map that are only partially hit by the given range,\n     /// to make sure that when they are mutated, the effect is constrained to the given range.\n+    /// If there are gaps, leave them be.\n     pub fn iter_mut_with_gaps<'a>(\n         &'a mut self,\n-        offset: u64,\n-        len: u64,\n+        offset: Size,\n+        len: Size,\n     ) -> impl Iterator<Item = &'a mut T> + 'a\n     where\n         T: Clone,\n     {\n-        assert!(len > 0);\n-        // Preparation: Split first and last entry as needed.\n-        self.split_entry_at(offset);\n-        self.split_entry_at(offset + len);\n+        let offset = offset.bytes();\n+        let len = len.bytes();\n+\n+        if len > 0 {\n+            // Preparation: Split first and last entry as needed.\n+            self.split_entry_at(offset);\n+            self.split_entry_at(offset + len);\n+        }\n         // Now we can provide a mutable iterator\n         self.map.range_mut(Range::range(offset, len)).filter_map(\n             move |(&range, data)| {\n+                debug_assert!(len > 0);\n                 if range.overlaps(offset, len) {\n                     assert!(\n                         offset <= range.start && offset + len >= range.end,\n@@ -151,35 +172,41 @@ impl<T> RangeMap<T> {\n     }\n \n     /// Provide a mutable iterator over everything in the given range, with the same side-effects as\n-    /// iter_mut_with_gaps.  Furthermore, if there are gaps between ranges, fill them with the given default.\n+    /// iter_mut_with_gaps.  Furthermore, if there are gaps between ranges, fill them with the given default\n+    /// before yielding them in the iterator.\n     /// This is also how you insert.\n-    pub fn iter_mut<'a>(&'a mut self, offset: u64, len: u64) -> impl Iterator<Item = &'a mut T> + 'a\n+    pub fn iter_mut<'a>(&'a mut self, offset: Size, len: Size) -> impl Iterator<Item = &'a mut T> + 'a\n     where\n         T: Clone + Default,\n     {\n-        // Do a first iteration to collect the gaps\n-        let mut gaps = Vec::new();\n-        let mut last_end = offset;\n-        for (range, _) in self.iter_with_range(offset, len) {\n-            if last_end < range.start {\n+        if len.bytes() > 0 {\n+            let offset = offset.bytes();\n+            let len = len.bytes();\n+\n+            // Do a first iteration to collect the gaps\n+            let mut gaps = Vec::new();\n+            let mut last_end = offset;\n+            for (range, _) in self.iter_with_range(offset, len) {\n+                if last_end < range.start {\n+                    gaps.push(Range {\n+                        start: last_end,\n+                        end: range.start,\n+                    });\n+                }\n+                last_end = range.end;\n+            }\n+            if last_end < offset + len {\n                 gaps.push(Range {\n                     start: last_end,\n-                    end: range.start,\n+                    end: offset + len,\n                 });\n             }\n-            last_end = range.end;\n-        }\n-        if last_end < offset + len {\n-            gaps.push(Range {\n-                start: last_end,\n-                end: offset + len,\n-            });\n-        }\n \n-        // Add default for all gaps\n-        for gap in gaps {\n-            let old = self.map.insert(gap, Default::default());\n-            assert!(old.is_none());\n+            // Add default for all gaps\n+            for gap in gaps {\n+                let old = self.map.insert(gap, Default::default());\n+                assert!(old.is_none());\n+            }\n         }\n \n         // Now provide mutable iteration\n@@ -208,45 +235,64 @@ mod tests {\n     use super::*;\n \n     /// Query the map at every offset in the range and collect the results.\n-    fn to_vec<T: Copy>(map: &RangeMap<T>, offset: u64, len: u64) -> Vec<T> {\n+    fn to_vec<T: Copy>(map: &RangeMap<T>, offset: u64, len: u64, default: Option<T>) -> Vec<T> {\n         (offset..offset + len)\n             .into_iter()\n-            .map(|i| *map.iter(i, 1).next().unwrap())\n+            .map(|i| map\n+                .iter(Size::from_bytes(i), Size::from_bytes(1))\n+                .next()\n+                .map(|&t| t)\n+                .or(default)\n+                .unwrap()\n+            )\n             .collect()\n     }\n \n     #[test]\n     fn basic_insert() {\n         let mut map = RangeMap::<i32>::new();\n         // Insert\n-        for x in map.iter_mut(10, 1) {\n+        for x in map.iter_mut(Size::from_bytes(10), Size::from_bytes(1)) {\n             *x = 42;\n         }\n         // Check\n-        assert_eq!(to_vec(&map, 10, 1), vec![42]);\n+        assert_eq!(to_vec(&map, 10, 1, None), vec![42]);\n+\n+        // Insert with size 0\n+        for x in map.iter_mut(Size::from_bytes(10), Size::from_bytes(0)) {\n+            *x = 19;\n+        }\n+        for x in map.iter_mut(Size::from_bytes(11), Size::from_bytes(0)) {\n+            *x = 19;\n+        }\n+        assert_eq!(to_vec(&map, 10, 2, Some(-1)), vec![42, -1]);\n     }\n \n     #[test]\n     fn gaps() {\n         let mut map = RangeMap::<i32>::new();\n-        for x in map.iter_mut(11, 1) {\n+        for x in map.iter_mut(Size::from_bytes(11), Size::from_bytes(1)) {\n             *x = 42;\n         }\n-        for x in map.iter_mut(15, 1) {\n-            *x = 42;\n+        for x in map.iter_mut(Size::from_bytes(15), Size::from_bytes(1)) {\n+            *x = 43;\n         }\n+        assert_eq!(\n+            to_vec(&map, 10, 10, Some(-1)),\n+            vec![-1, 42, -1, -1, -1, 43, -1, -1, -1, -1]\n+        );\n \n         // Now request a range that needs three gaps filled\n-        for x in map.iter_mut(10, 10) {\n-            if *x != 42 {\n+        for x in map.iter_mut(Size::from_bytes(10), Size::from_bytes(10)) {\n+            if *x < 42 {\n                 *x = 23;\n             }\n         }\n \n         assert_eq!(\n-            to_vec(&map, 10, 10),\n-            vec![23, 42, 23, 23, 23, 42, 23, 23, 23, 23]\n+            to_vec(&map, 10, 10, None),\n+            vec![23, 42, 23, 23, 23, 43, 23, 23, 23, 23]\n         );\n-        assert_eq!(to_vec(&map, 13, 5), vec![23, 23, 42, 23, 23]);\n+        assert_eq!(to_vec(&map, 13, 5, None), vec![23, 23, 43, 23, 23]);\n     }\n }"}, {"sha": "c3514efdbe71efdfdd825a7ced6521ee51576076", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 237, "deletions": 1, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/66b4bb7cf2e7136ca0a31d04a2abe1754e89a5b6/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b4bb7cf2e7136ca0a31d04a2abe1754e89a5b6/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=66b4bb7cf2e7136ca0a31d04a2abe1754e89a5b6", "patch": "@@ -1,4 +1,12 @@\n-use super::RangeMap;\n+use std::cell::RefCell;\n+\n+use rustc::ty::{Ty, layout::Size};\n+use rustc::mir;\n+\n+use super::{\n+    RangeMap, EvalResult,\n+    Pointer,\n+};\n \n pub type Timestamp = u64;\n \n@@ -11,6 +19,24 @@ pub enum Mut {\n   Raw,\n }\n \n+impl Mut {\n+    #[inline(always)]\n+    fn is_raw(self) -> bool {\n+        match self {\n+            Mut::Raw => true,\n+            _ => false,\n+        }\n+    }\n+\n+    #[inline(always)]\n+    fn is_uniq(self) -> bool {\n+        match self {\n+            Mut::Uniq(_) => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n /// Information about any kind of borrow\n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n pub enum Borrow {\n@@ -20,6 +46,24 @@ pub enum Borrow {\n   Frz(Timestamp)\n }\n \n+impl Borrow {\n+    #[inline(always)]\n+    fn is_mut(self) -> bool {\n+        match self {\n+            Borrow::Mut(_) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    #[inline(always)]\n+    fn is_uniq(self) -> bool {\n+        match self {\n+            Borrow::Mut(Mut::Uniq(_)) => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n /// An item in the borrow stack\n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n pub enum BorStackItem {\n@@ -34,3 +78,195 @@ impl Default for Borrow {\n         Borrow::Mut(Mut::Raw)\n     }\n }\n+\n+/// Extra global machine state\n+#[derive(Clone, Debug)]\n+pub struct State {\n+    clock: Timestamp\n+}\n+\n+impl State {\n+    pub fn new() -> State {\n+        State { clock: 0 }\n+    }\n+}\n+\n+/// Extra per-location state\n+#[derive(Clone, Debug)]\n+struct Stack {\n+    borrows: Vec<BorStackItem>, // used as a stack\n+    frozen_since: Option<Timestamp>,\n+}\n+\n+impl Default for Stack {\n+    fn default() -> Self {\n+        Stack {\n+            borrows: Vec::new(),\n+            frozen_since: None,\n+        }\n+    }\n+}\n+\n+/// Extra per-allocation state\n+#[derive(Clone, Debug, Default)]\n+pub struct Stacks {\n+    stacks: RefCell<RangeMap<Stack>>,\n+}\n+\n+/// Core operations\n+impl<'tcx> Stack {\n+    fn check(&self, bor: Borrow) -> bool {\n+        match bor {\n+            Borrow::Frz(acc_t) =>\n+                // Must be frozen at least as long as the `acc_t` says.\n+                self.frozen_since.map_or(false, |loc_t| loc_t <= acc_t),\n+            Borrow::Mut(acc_m) =>\n+                // Raw pointers are fine with frozen locations. This is important because &Cell is raw!\n+                if self.frozen_since.is_some() {\n+                    acc_m.is_raw()\n+                } else {\n+                    self.borrows.last().map_or(false, |&loc_itm| loc_itm == BorStackItem::Mut(acc_m))\n+                }\n+        }\n+    }\n+\n+    /// Reactive `bor` for this stack.  If `force_mut` is set, we want to aggressively\n+    /// unfreeze this location (because we are about to push a `Uniq`).\n+    fn reactivate(&mut self, bor: Borrow, force_mut: bool) -> EvalResult<'tcx> {\n+        assert!(!force_mut || bor.is_mut()); // if `force_mut` is set, this must be a mutable borrow\n+        // Do NOT change anything if `bor` is already active -- in particular, if\n+        // it is a `Mut(Raw)` and we are frozen.\n+        if !force_mut && self.check(bor) {\n+            return Ok(());\n+        }\n+\n+        let acc_m = match bor {\n+            Borrow::Frz(_) => return err!(MachineError(format!(\"Location should be frozen but it is not\"))),\n+            Borrow::Mut(acc_m) => acc_m,\n+        };\n+        // We definitely have to unfreeze this, even if we use the topmost item.\n+        self.frozen_since = None;\n+        // Pop until we see the one we are looking for.\n+        while let Some(&itm) = self.borrows.last() {\n+            match itm {\n+                BorStackItem::FnBarrier(_) => {\n+                    return err!(MachineError(format!(\"Trying to reactivate a borrow that lives behind a barrier\")));\n+                }\n+                BorStackItem::Mut(loc_m) => {\n+                    if loc_m == acc_m { return Ok(()); }\n+                    self.borrows.pop();\n+                }\n+            }\n+        }\n+        // Nothing to be found.  Simulate a \"virtual raw\" element at the bottom of the stack.\n+        if acc_m.is_raw() {\n+            Ok(())\n+        } else {\n+            err!(MachineError(format!(\"Borrow-to-reactivate does not exist on the stack\")))\n+        }\n+    }\n+\n+    fn initiate(&mut self, bor: Borrow) -> EvalResult<'tcx> {\n+        match bor {\n+            Borrow::Frz(t) => {\n+                match self.frozen_since {\n+                    None => self.frozen_since = Some(t),\n+                    Some(since) => assert!(since <= t),\n+                }\n+            }\n+            Borrow::Mut(m) => {\n+                match self.frozen_since {\n+                    None => self.borrows.push(BorStackItem::Mut(m)),\n+                    Some(_) =>\n+                        // FIXME: Do we want an exception for raw borrows?\n+                        return err!(MachineError(format!(\"Trying to mutate frozen location\")))\n+                }\n+            }\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl State {\n+    fn increment_clock(&mut self) -> Timestamp {\n+        self.clock += 1;\n+        self.clock\n+    }\n+}\n+\n+/// Machine hooks\n+pub trait EvalContextExt<'tcx> {\n+    fn tag_reference(\n+        &mut self,\n+        ptr: Pointer<Borrow>,\n+        pointee_ty: Ty<'tcx>,\n+        size: Size,\n+        borrow_kind: mir::BorrowKind,\n+    ) -> EvalResult<'tcx, Borrow>;\n+\n+    fn tag_dereference(\n+        &self,\n+        ptr: Pointer<Borrow>,\n+        ptr_ty: Ty<'tcx>,\n+    ) -> EvalResult<'tcx, Borrow>;\n+}\n+\n+impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, 'tcx> {\n+    fn tag_reference(\n+        &mut self,\n+        ptr: Pointer<Borrow>,\n+        pointee_ty: Ty<'tcx>,\n+        size: Size,\n+        borrow_kind: mir::BorrowKind,\n+    ) -> EvalResult<'tcx, Borrow> {\n+        let old_bor = ptr.tag;\n+        let time = self.machine.stacked_borrows.increment_clock();\n+        // FIXME This does not do enough checking when only part of the data lacks\n+        // interior mutability.\n+        let new_bor = match borrow_kind {\n+            mir::BorrowKind::Mut { .. } => Borrow::Mut(Mut::Uniq(time)),\n+            _ =>\n+                if self.type_is_freeze(pointee_ty) {\n+                    Borrow::Frz(time)\n+                } else {\n+                    Borrow::Mut(Mut::Raw)\n+                }\n+        };\n+        trace!(\"tag_reference: Creating new tag for {:?} (pointee {}, size {}): {:?}\", ptr, pointee_ty, size.bytes(), new_bor);\n+\n+        // Make sure this reference is not dangling or so\n+        self.memory.check_bounds(ptr, size, false)?;\n+\n+        // Update the stacks.  We cannot use `get_mut` becuse this might be immutable\n+        // memory.\n+        let alloc = self.memory.get(ptr.alloc_id).expect(\"We checked that the ptr is fine!\");\n+        let mut stacks = alloc.extra.stacks.borrow_mut();\n+        for stack in stacks.iter_mut(ptr.offset, size) {\n+            if stack.check(new_bor) {\n+                // The new borrow is already active!  This can happen when creating multiple\n+                // shared references from the same mutable reference.  Do nothing.\n+            } else {\n+                // FIXME: The blog post says we should `reset` if this is a local.\n+                stack.reactivate(old_bor, /*force_mut*/new_bor.is_uniq())?;\n+                stack.initiate(new_bor)?;\n+            }\n+        }\n+\n+        Ok(new_bor)\n+    }\n+\n+    fn tag_dereference(\n+        &self,\n+        ptr: Pointer<Borrow>,\n+        ptr_ty: Ty<'tcx>,\n+    ) -> EvalResult<'tcx, Borrow> {\n+        // If this is a raw ptr, forget about the tag.\n+        Ok(if ptr_ty.is_unsafe_ptr() {\n+            trace!(\"tag_dereference: Erasing tag for {:?} ({})\", ptr, ptr_ty);\n+            Borrow::Mut(Mut::Raw)\n+        } else {\n+            // FIXME: Do we want to adjust the tag if it does not match the type?\n+            ptr.tag\n+        })\n+    }\n+}"}, {"sha": "2bddc43df8c4ae1114974fa535bae84029e7b6c9", "filename": "src/tls.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/66b4bb7cf2e7136ca0a31d04a2abe1754e89a5b6/src%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b4bb7cf2e7136ca0a31d04a2abe1754e89a5b6/src%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftls.rs?ref=66b4bb7cf2e7136ca0a31d04a2abe1754e89a5b6", "patch": "@@ -4,19 +4,19 @@ use rustc_target::abi::LayoutOf;\n use rustc::{ty, ty::layout::HasDataLayout, mir};\n \n use super::{\n-    EvalResult, EvalErrorKind, StackPopCleanup, EvalContext, Evaluator,\n+    EvalResult, EvalErrorKind, StackPopCleanup,\n     MPlaceTy, Scalar, Borrow,\n };\n \n pub type TlsKey = u128;\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+#[derive(Copy, Clone, Debug)]\n pub struct TlsEntry<'tcx> {\n     pub(crate) data: Scalar<Borrow>, // Will eventually become a map from thread IDs to `Scalar`s, if we ever support more than one thread.\n     pub(crate) dtor: Option<ty::Instance<'tcx>>,\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq)]\n+#[derive(Debug)]\n pub struct TlsData<'tcx> {\n     /// The Key to use for the next thread-local allocation.\n     pub(crate) next_key: TlsKey,\n@@ -133,7 +133,7 @@ impl<'tcx> TlsData<'tcx> {\n     }\n }\n \n-impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, Evaluator<'tcx>> {\n+impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, 'tcx> {\n     fn run_tls_dtors(&mut self) -> EvalResult<'tcx> {\n         let mut dtor = self.machine.tls.fetch_tls_dtor(None, *self.tcx);\n         // FIXME: replace loop by some structure that works with stepping"}]}