{"sha": "32414310b7e0b93491ce6243e1ec0c92c6168557", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyNDE0MzEwYjdlMGI5MzQ5MWNlNjI0M2UxZWMwYzkyYzYxNjg1NTc=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-08-02T20:53:58Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-08-11T13:56:00Z"}, "message": "Add the notion of a dependency tracking status to commandline arguments.\n\nCommandline arguments influence whether incremental compilation\ncan use its compilation cache and thus their changes relative to\nprevious compilation sessions need to be taking into account. This\ncommit makes sure that one has to specify for every commandline\nargument whether it influences incremental compilation or not.", "tree": {"sha": "ecfe2a3c1106bba71ca68c8754be977795d1adf4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ecfe2a3c1106bba71ca68c8754be977795d1adf4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/32414310b7e0b93491ce6243e1ec0c92c6168557", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/32414310b7e0b93491ce6243e1ec0c92c6168557", "html_url": "https://github.com/rust-lang/rust/commit/32414310b7e0b93491ce6243e1ec0c92c6168557", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/32414310b7e0b93491ce6243e1ec0c92c6168557/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "695b3d8279e17689b988e000203ba95ffeb4a91c", "url": "https://api.github.com/repos/rust-lang/rust/commits/695b3d8279e17689b988e000203ba95ffeb4a91c", "html_url": "https://github.com/rust-lang/rust/commit/695b3d8279e17689b988e000203ba95ffeb4a91c"}], "stats": {"total": 1454, "additions": 1252, "deletions": 202}, "files": [{"sha": "f34b14224f7797f0ad798cd4e045e294fdb5104c", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32414310b7e0b93491ce6243e1ec0c92c6168557/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32414310b7e0b93491ce6243e1ec0c92c6168557/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=32414310b7e0b93491ce6243e1ec0c92c6168557", "patch": "@@ -269,7 +269,7 @@ impl LintId {\n }\n \n /// Setting for how to handle a lint.\n-#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Debug)]\n+#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Debug, Hash)]\n pub enum Level {\n     Allow, Warn, Deny, Forbid\n }"}, {"sha": "dec6f360847bfb2ac6a4928389f6523b266b9a6d", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32414310b7e0b93491ce6243e1ec0c92c6168557/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32414310b7e0b93491ce6243e1ec0c92c6168557/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=32414310b7e0b93491ce6243e1ec0c92c6168557", "patch": "@@ -73,7 +73,7 @@ pub enum LinkagePreference {\n }\n \n enum_from_u32! {\n-    #[derive(Copy, Clone, PartialEq)]\n+    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n     pub enum NativeLibraryKind {\n         NativeStatic,    // native static library (.a archive)\n         NativeFramework, // OSX-specific"}, {"sha": "e337c1232aab8e475332705c3b0df7a999df2774", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 1205, "deletions": 159, "changes": 1364, "blob_url": "https://github.com/rust-lang/rust/blob/32414310b7e0b93491ce6243e1ec0c92c6168557/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32414310b7e0b93491ce6243e1ec0c92c6168557/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=32414310b7e0b93491ce6243e1ec0c92c6168557", "patch": "@@ -33,9 +33,15 @@ use syntax::feature_gate::UnstableFeatures;\n use errors::{ColorConfig, FatalError, Handler};\n \n use getopts;\n-use std::collections::HashMap;\n+use std::collections::{BTreeMap, BTreeSet};\n+use std::collections::btree_map::Iter as BTreeMapIter;\n+use std::collections::btree_map::Keys as BTreeMapKeysIter;\n+use std::collections::btree_map::Values as BTreeMapValuesIter;\n+\n use std::env;\n use std::fmt;\n+use std::hash::{Hasher, SipHasher};\n+use std::iter::FromIterator;\n use std::path::PathBuf;\n \n pub struct Config {\n@@ -44,7 +50,7 @@ pub struct Config {\n     pub uint_type: UintTy,\n }\n \n-#[derive(Clone, Copy, PartialEq)]\n+#[derive(Clone, Copy, PartialEq, Hash)]\n pub enum OptLevel {\n     No, // -O0\n     Less, // -O1\n@@ -54,14 +60,15 @@ pub enum OptLevel {\n     SizeMin, // -Oz\n }\n \n-#[derive(Clone, Copy, PartialEq)]\n+#[derive(Clone, Copy, PartialEq, Hash)]\n pub enum DebugInfoLevel {\n     NoDebugInfo,\n     LimitedDebugInfo,\n     FullDebugInfo,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, PartialOrd, Ord,\n+         RustcEncodable, RustcDecodable)]\n pub enum OutputType {\n     Bitcode,\n     Assembly,\n@@ -118,57 +125,183 @@ impl OutputType {\n     }\n }\n \n-#[derive(Clone)]\n-pub struct Options {\n-    // The crate config requested for the session, which may be combined\n-    // with additional crate configurations during the compile process\n-    pub crate_types: Vec<CrateType>,\n-\n-    pub optimize: OptLevel,\n-    pub debug_assertions: bool,\n-    pub debuginfo: DebugInfoLevel,\n-    pub lint_opts: Vec<(String, lint::Level)>,\n-    pub lint_cap: Option<lint::Level>,\n-    pub describe_lints: bool,\n-    pub output_types: HashMap<OutputType, Option<PathBuf>>,\n-    // This was mutable for rustpkg, which updates search paths based on the\n-    // parsed code. It remains mutable in case its replacements wants to use\n-    // this.\n-    pub search_paths: SearchPaths,\n-    pub libs: Vec<(String, cstore::NativeLibraryKind)>,\n-    pub maybe_sysroot: Option<PathBuf>,\n-    pub target_triple: String,\n-    // User-specified cfg meta items. The compiler itself will add additional\n-    // items to the crate config, and during parsing the entire crate config\n-    // will be added to the crate AST node.  This should not be used for\n-    // anything except building the full crate config prior to parsing.\n-    pub cfg: ast::CrateConfig,\n-    pub test: bool,\n-    pub parse_only: bool,\n-    pub no_trans: bool,\n-    pub error_format: ErrorOutputType,\n-    pub treat_err_as_bug: bool,\n-    pub continue_parse_after_error: bool,\n-    pub mir_opt_level: usize,\n-\n-    /// if Some, enable incremental compilation, using the given\n-    /// directory to store intermediate results\n-    pub incremental: Option<PathBuf>,\n-\n-    pub no_analysis: bool,\n-    pub debugging_opts: DebuggingOptions,\n-    pub prints: Vec<PrintRequest>,\n-    pub cg: CodegenOptions,\n-    pub externs: HashMap<String, Vec<String>>,\n-    pub crate_name: Option<String>,\n-    /// An optional name to use as the crate for std during std injection,\n-    /// written `extern crate std = \"name\"`. Default to \"std\". Used by\n-    /// out-of-tree drivers.\n-    pub alt_std_name: Option<String>,\n-    /// Indicates how the compiler should treat unstable features\n-    pub unstable_features: UnstableFeatures\n+// Use tree-based collections to cheaply get a deterministic Hash implementation.\n+// DO NOT switch BTreeMap out for an unsorted container type! That would break\n+// dependency tracking for commandline arguments.\n+#[derive(Clone, Hash)]\n+pub struct OutputTypes(BTreeMap<OutputType, Option<PathBuf>>);\n+\n+impl OutputTypes {\n+    pub fn new(entries: &[(OutputType, Option<PathBuf>)]) -> OutputTypes {\n+        OutputTypes(BTreeMap::from_iter(entries.iter()\n+                                               .map(|&(k, ref v)| (k, v.clone()))))\n+    }\n+\n+    pub fn get(&self, key: &OutputType) -> Option<&Option<PathBuf>> {\n+        self.0.get(key)\n+    }\n+\n+    pub fn contains_key(&self, key: &OutputType) -> bool {\n+        self.0.contains_key(key)\n+    }\n+\n+    pub fn keys<'a>(&'a self) -> BTreeMapKeysIter<'a, OutputType, Option<PathBuf>> {\n+        self.0.keys()\n+    }\n+\n+    pub fn values<'a>(&'a self) -> BTreeMapValuesIter<'a, OutputType, Option<PathBuf>> {\n+        self.0.values()\n+    }\n+}\n+\n+\n+// Use tree-based collections to cheaply get a deterministic Hash implementation.\n+// DO NOT switch BTreeMap or BTreeSet out for an unsorted container type! That\n+// would break dependency tracking for commandline arguments.\n+#[derive(Clone, Hash)]\n+pub struct Externs(BTreeMap<String, BTreeSet<String>>);\n+\n+impl Externs {\n+    pub fn new(data: BTreeMap<String, BTreeSet<String>>) -> Externs {\n+        Externs(data)\n+    }\n+\n+    pub fn get(&self, key: &str) -> Option<&BTreeSet<String>> {\n+        self.0.get(key)\n+    }\n+\n+    pub fn iter<'a>(&'a self) -> BTreeMapIter<'a, String, BTreeSet<String>> {\n+        self.0.iter()\n+    }\n+}\n+\n+macro_rules! hash_option {\n+    ($opt_name:ident, $opt_expr:expr, $sub_hashes:expr, [UNTRACKED]) => ({});\n+    ($opt_name:ident, $opt_expr:expr, $sub_hashes:expr, [TRACKED]) => ({\n+        if $sub_hashes.insert(stringify!($opt_name),\n+                              $opt_expr as &dep_tracking::DepTrackingHash).is_some() {\n+            bug!(\"Duplicate key in CLI DepTrackingHash: {}\", stringify!($opt_name))\n+        }\n+    });\n+    ($opt_name:ident,\n+     $opt_expr:expr,\n+     $sub_hashes:expr,\n+     [UNTRACKED_WITH_WARNING $warn_val:expr, $warn_text:expr, $error_format:expr]) => ({\n+        if *$opt_expr == $warn_val {\n+            early_warn($error_format, $warn_text)\n+        }\n+    });\n+}\n+\n+macro_rules! top_level_options {\n+    (pub struct Options { $(\n+        $opt:ident : $t:ty [$dep_tracking_marker:ident $($warn_val:expr, $warn_text:expr)*],\n+    )* } ) => (\n+        #[derive(Clone)]\n+        pub struct Options {\n+            $(pub $opt: $t),*\n+        }\n+\n+        impl Options {\n+            pub fn dep_tracking_hash(&self) -> u64 {\n+                let mut sub_hashes = BTreeMap::new();\n+                $({\n+                    hash_option!($opt,\n+                                 &self.$opt,\n+                                 &mut sub_hashes,\n+                                 [$dep_tracking_marker $($warn_val,\n+                                                         $warn_text,\n+                                                         self.error_format)*]);\n+                })*\n+                let mut hasher =  SipHasher::new();\n+                dep_tracking::stable_hash(sub_hashes,\n+                                          &mut hasher,\n+                                          self.error_format);\n+                hasher.finish()\n+            }\n+        }\n+    );\n }\n \n+// The top-level commandline options struct\n+//\n+// For each option, one has to specify how it behaves with regard to the\n+// dependency tracking system of incremental compilation. This is done via the\n+// square-bracketed directive after the field type. The options are:\n+//\n+// [TRACKED]\n+// A change in the given field will cause the compiler to completely clear the\n+// incremental compilation cache before proceeding.\n+//\n+// [UNTRACKED]\n+// Incremental compilation is not influenced by this option.\n+//\n+// [UNTRACKED_WITH_WARNING(val, warning)]\n+// The option is incompatible with incremental compilation in some way. If it\n+// has the value `val`, the string `warning` is emitted as a warning.\n+//\n+// If you add a new option to this struct or one of the sub-structs like\n+// CodegenOptions, think about how it influences incremental compilation. If in\n+// doubt, specify [TRACKED], which is always \"correct\" but might lead to\n+// unnecessary re-compilation.\n+top_level_options!(\n+    pub struct Options {\n+        // The crate config requested for the session, which may be combined\n+        // with additional crate configurations during the compile process\n+        crate_types: Vec<CrateType> [TRACKED],\n+        optimize: OptLevel [TRACKED],\n+        // Include the debug_assertions flag into dependency tracking, since it\n+        // can influence whether overflow checks are done or not.\n+        debug_assertions: bool [TRACKED],\n+        debuginfo: DebugInfoLevel [TRACKED],\n+        lint_opts: Vec<(String, lint::Level)> [TRACKED],\n+        lint_cap: Option<lint::Level> [TRACKED],\n+        describe_lints: bool [UNTRACKED],\n+        output_types: OutputTypes [TRACKED],\n+        // FIXME(mw): I'm not entirely sure if this can have any influence on\n+        //            incremental compilation apart from what is already handled\n+        //            by crate metadata hashes. Better track it.\n+        search_paths: SearchPaths [TRACKED],\n+        // FIXME(mw): Might not need to do dep-tracking for `libs`?\n+        libs: Vec<(String, cstore::NativeLibraryKind)> [TRACKED],\n+        // FIXME(mw): Might not need to do dep-tracking for `maybe_sysroot`?\n+        maybe_sysroot: Option<PathBuf> [TRACKED],\n+\n+        target_triple: String [TRACKED],\n+\n+        // User-specified cfg meta items. The compiler itself will add additional\n+        // items to the crate config, and during parsing the entire crate config\n+        // will be added to the crate AST node.  This should not be used for\n+        // anything except building the full crate config prior to parsing.\n+        // FIXME(mw): If we could be entirely sure that the `cfg` only ever\n+        //            influenced which HIR nodes get filtered out, we wouldn't\n+        //            need to track this separately. However, we can't rely on\n+        //            this (see `debug_assertions` above).\n+        cfg: ast::CrateConfig [TRACKED],\n+        test: bool [TRACKED],\n+        error_format: ErrorOutputType [UNTRACKED],\n+        mir_opt_level: usize [TRACKED],\n+\n+        // if Some, enable incremental compilation, using the given\n+        // directory to store intermediate results\n+        incremental: Option<PathBuf> [UNTRACKED],\n+\n+        debugging_opts: DebuggingOptions [TRACKED],\n+        prints: Vec<PrintRequest> [UNTRACKED],\n+        cg: CodegenOptions [TRACKED],\n+        // FIXME(mw): `externs` might not need to be tracked but let's err on\n+        //            the side of caution for now.\n+        externs: Externs [TRACKED],\n+        crate_name: Option<String> [TRACKED],\n+        // An optional name to use as the crate for std during std injection,\n+        // written `extern crate std = \"name\"`. Default to \"std\". Used by\n+        // out-of-tree drivers.\n+        alt_std_name: Option<String> [TRACKED],\n+        // Indicates how the compiler should treat unstable features\n+        unstable_features: UnstableFeatures [TRACKED],\n+    }\n+);\n+\n #[derive(Clone, PartialEq, Eq)]\n pub enum PrintRequest {\n     FileNames,\n@@ -209,7 +342,7 @@ pub struct OutputFilenames {\n     pub out_filestem: String,\n     pub single_output_file: Option<PathBuf>,\n     pub extra: String,\n-    pub outputs: HashMap<OutputType, Option<PathBuf>>,\n+    pub outputs: OutputTypes,\n }\n \n /// Codegen unit names generated by the numbered naming scheme will contain this\n@@ -301,24 +434,19 @@ pub fn basic_options() -> Options {\n         lint_opts: Vec::new(),\n         lint_cap: None,\n         describe_lints: false,\n-        output_types: HashMap::new(),\n+        output_types: OutputTypes(BTreeMap::new()),\n         search_paths: SearchPaths::new(),\n         maybe_sysroot: None,\n         target_triple: host_triple().to_string(),\n         cfg: Vec::new(),\n         test: false,\n-        parse_only: false,\n-        no_trans: false,\n-        treat_err_as_bug: false,\n-        continue_parse_after_error: false,\n         mir_opt_level: 1,\n         incremental: None,\n-        no_analysis: false,\n         debugging_opts: basic_debugging_options(),\n         prints: Vec::new(),\n         cg: basic_codegen_options(),\n         error_format: ErrorOutputType::default(),\n-        externs: HashMap::new(),\n+        externs: Externs(BTreeMap::new()),\n         crate_name: None,\n         alt_std_name: None,\n         libs: Vec::new(),\n@@ -361,7 +489,7 @@ pub enum CrateType {\n     CrateTypeCdylib,\n }\n \n-#[derive(Clone)]\n+#[derive(Clone, Hash)]\n pub enum Passes {\n     SomePasses(Vec<String>),\n     AllPasses,\n@@ -376,7 +504,7 @@ impl Passes {\n     }\n }\n \n-#[derive(Clone, PartialEq)]\n+#[derive(Clone, PartialEq, Hash)]\n pub enum PanicStrategy {\n     Unwind,\n     Abort,\n@@ -405,7 +533,12 @@ macro_rules! options {\n     ($struct_name:ident, $setter_name:ident, $defaultfn:ident,\n      $buildfn:ident, $prefix:expr, $outputname:expr,\n      $stat:ident, $mod_desc:ident, $mod_set:ident,\n-     $($opt:ident : $t:ty = ($init:expr, $parse:ident, $desc:expr)),* ,) =>\n+     $($opt:ident : $t:ty = (\n+        $init:expr,\n+        $parse:ident,\n+        [$dep_tracking_marker:ident $(($dep_warn_val:expr, $dep_warn_text:expr))*],\n+        $desc:expr)\n+     ),* ,) =>\n (\n     #[derive(Clone)]\n     pub struct $struct_name { $(pub $opt: $t),* }\n@@ -457,6 +590,22 @@ macro_rules! options {\n         return op;\n     }\n \n+    impl<'a> dep_tracking::DepTrackingHash for $struct_name {\n+\n+        fn hash(&self, hasher: &mut SipHasher, error_format: ErrorOutputType) {\n+            let mut sub_hashes = BTreeMap::new();\n+            $({\n+                hash_option!($opt,\n+                             &self.$opt,\n+                             &mut sub_hashes,\n+                             [$dep_tracking_marker $($dep_warn_val,\n+                                                     $dep_warn_text,\n+                                                     error_format)*]);\n+            })*\n+            dep_tracking::stable_hash(sub_hashes, hasher, error_format);\n+        }\n+    }\n+\n     pub type $setter_name = fn(&mut $struct_name, v: Option<&str>) -> bool;\n     pub const $stat: &'static [(&'static str, $setter_name,\n                                      Option<&'static str>, &'static str)] =\n@@ -622,168 +771,177 @@ macro_rules! options {\n options! {CodegenOptions, CodegenSetter, basic_codegen_options,\n          build_codegen_options, \"C\", \"codegen\",\n          CG_OPTIONS, cg_type_desc, cgsetters,\n-    ar: Option<String> = (None, parse_opt_string,\n+    ar: Option<String> = (None, parse_opt_string, [UNTRACKED],\n         \"tool to assemble archives with\"),\n-    linker: Option<String> = (None, parse_opt_string,\n+    linker: Option<String> = (None, parse_opt_string, [UNTRACKED],\n         \"system linker to link outputs with\"),\n-    link_args: Option<Vec<String>> = (None, parse_opt_list,\n+    link_args: Option<Vec<String>> = (None, parse_opt_list, [UNTRACKED],\n         \"extra arguments to pass to the linker (space separated)\"),\n-    link_dead_code: bool = (false, parse_bool,\n+    link_dead_code: bool = (false, parse_bool, [UNTRACKED],\n         \"don't let linker strip dead code (turning it on can be used for code coverage)\"),\n-    lto: bool = (false, parse_bool,\n+    lto: bool = (false, parse_bool, [TRACKED],\n         \"perform LLVM link-time optimizations\"),\n-    target_cpu: Option<String> = (None, parse_opt_string,\n+    target_cpu: Option<String> = (None, parse_opt_string, [TRACKED],\n         \"select target processor (rustc --print target-cpus for details)\"),\n-    target_feature: String = (\"\".to_string(), parse_string,\n+    target_feature: String = (\"\".to_string(), parse_string, [TRACKED],\n         \"target specific attributes (rustc --print target-features for details)\"),\n-    passes: Vec<String> = (Vec::new(), parse_list,\n+    passes: Vec<String> = (Vec::new(), parse_list, [TRACKED],\n         \"a list of extra LLVM passes to run (space separated)\"),\n-    llvm_args: Vec<String> = (Vec::new(), parse_list,\n+    llvm_args: Vec<String> = (Vec::new(), parse_list, [TRACKED],\n         \"a list of arguments to pass to llvm (space separated)\"),\n-    save_temps: bool = (false, parse_bool,\n+    save_temps: bool = (false, parse_bool, [UNTRACKED_WITH_WARNING(true,\n+        \"`-C save-temps` might not produce all requested temporary products \\\n+         when incremental compilation is enabled.\")],\n         \"save all temporary output files during compilation\"),\n-    rpath: bool = (false, parse_bool,\n+    rpath: bool = (false, parse_bool, [UNTRACKED],\n         \"set rpath values in libs/exes\"),\n-    no_prepopulate_passes: bool = (false, parse_bool,\n+    no_prepopulate_passes: bool = (false, parse_bool, [TRACKED],\n         \"don't pre-populate the pass manager with a list of passes\"),\n-    no_vectorize_loops: bool = (false, parse_bool,\n+    no_vectorize_loops: bool = (false, parse_bool, [TRACKED],\n         \"don't run the loop vectorization optimization passes\"),\n-    no_vectorize_slp: bool = (false, parse_bool,\n+    no_vectorize_slp: bool = (false, parse_bool, [TRACKED],\n         \"don't run LLVM's SLP vectorization pass\"),\n-    soft_float: bool = (false, parse_bool,\n+    soft_float: bool = (false, parse_bool, [TRACKED],\n         \"generate software floating point library calls\"),\n-    prefer_dynamic: bool = (false, parse_bool,\n+    prefer_dynamic: bool = (false, parse_bool, [TRACKED],\n         \"prefer dynamic linking to static linking\"),\n-    no_integrated_as: bool = (false, parse_bool,\n+    no_integrated_as: bool = (false, parse_bool, [TRACKED],\n         \"use an external assembler rather than LLVM's integrated one\"),\n-    no_redzone: Option<bool> = (None, parse_opt_bool,\n+    no_redzone: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"disable the use of the redzone\"),\n-    relocation_model: Option<String> = (None, parse_opt_string,\n+    relocation_model: Option<String> = (None, parse_opt_string, [TRACKED],\n          \"choose the relocation model to use (rustc --print relocation-models for details)\"),\n-    code_model: Option<String> = (None, parse_opt_string,\n+    code_model: Option<String> = (None, parse_opt_string, [TRACKED],\n          \"choose the code model to use (rustc --print code-models for details)\"),\n-    metadata: Vec<String> = (Vec::new(), parse_list,\n+    metadata: Vec<String> = (Vec::new(), parse_list, [TRACKED],\n          \"metadata to mangle symbol names with\"),\n-    extra_filename: String = (\"\".to_string(), parse_string,\n+    extra_filename: String = (\"\".to_string(), parse_string, [UNTRACKED],\n          \"extra data to put in each output filename\"),\n-    codegen_units: usize = (1, parse_uint,\n+    codegen_units: usize = (1, parse_uint, [UNTRACKED],\n         \"divide crate into N units to optimize in parallel\"),\n-    remark: Passes = (SomePasses(Vec::new()), parse_passes,\n+    remark: Passes = (SomePasses(Vec::new()), parse_passes, [UNTRACKED],\n         \"print remarks for these optimization passes (space separated, or \\\"all\\\")\"),\n-    no_stack_check: bool = (false, parse_bool,\n+    no_stack_check: bool = (false, parse_bool, [UNTRACKED],\n         \"disable checks for stack exhaustion (a memory-safety hazard!)\"),\n-    debuginfo: Option<usize> = (None, parse_opt_uint,\n+    debuginfo: Option<usize> = (None, parse_opt_uint, [TRACKED],\n         \"debug info emission level, 0 = no debug info, 1 = line tables only, \\\n          2 = full debug info with variable and type information\"),\n-    opt_level: Option<String> = (None, parse_opt_string,\n+    opt_level: Option<String> = (None, parse_opt_string, [TRACKED],\n         \"optimize with possible levels 0-3, s, or z\"),\n-    debug_assertions: Option<bool> = (None, parse_opt_bool,\n+    debug_assertions: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"explicitly enable the cfg(debug_assertions) directive\"),\n-    inline_threshold: Option<usize> = (None, parse_opt_uint,\n+    inline_threshold: Option<usize> = (None, parse_opt_uint, [TRACKED],\n         \"set the inlining threshold for\"),\n     panic: PanicStrategy = (PanicStrategy::Unwind, parse_panic_strategy,\n-        \"panic strategy to compile crate with\"),\n+        [TRACKED], \"panic strategy to compile crate with\"),\n }\n \n options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n          build_debugging_options, \"Z\", \"debugging\",\n          DB_OPTIONS, db_type_desc, dbsetters,\n-    verbose: bool = (false, parse_bool,\n+    verbose: bool = (false, parse_bool, [UNTRACKED],\n         \"in general, enable more debug printouts\"),\n-    time_passes: bool = (false, parse_bool,\n+    time_passes: bool = (false, parse_bool, [UNTRACKED],\n         \"measure time of each rustc pass\"),\n     count_llvm_insns: bool = (false, parse_bool,\n+        [UNTRACKED_WITH_WARNING(true,\n+        \"The output generated by `-Z count_llvm_insns` might not be reliable \\\n+         when used with incremental compilation\")],\n         \"count where LLVM instrs originate\"),\n-    time_llvm_passes: bool = (false, parse_bool,\n+    time_llvm_passes: bool = (false, parse_bool, [UNTRACKED_WITH_WARNING(true,\n+        \"The output of `-Z time-llvm-passes` will only reflect timings of \\\n+         re-translated modules when used with incremental compilation\" )],\n         \"measure time of each LLVM pass\"),\n-    input_stats: bool = (false, parse_bool,\n+    input_stats: bool = (false, parse_bool, [UNTRACKED],\n         \"gather statistics about the input\"),\n-    trans_stats: bool = (false, parse_bool,\n+    trans_stats: bool = (false, parse_bool, [UNTRACKED_WITH_WARNING(true,\n+        \"The output of `-Z trans-stats` might not be accurate when incremental \\\n+         compilation is enabled\")],\n         \"gather trans statistics\"),\n-    asm_comments: bool = (false, parse_bool,\n+    asm_comments: bool = (false, parse_bool, [TRACKED],\n         \"generate comments into the assembly (may change behavior)\"),\n-    no_verify: bool = (false, parse_bool,\n+    no_verify: bool = (false, parse_bool, [TRACKED],\n         \"skip LLVM verification\"),\n-    borrowck_stats: bool = (false, parse_bool,\n+    borrowck_stats: bool = (false, parse_bool, [UNTRACKED],\n         \"gather borrowck statistics\"),\n-    no_landing_pads: bool = (false, parse_bool,\n+    no_landing_pads: bool = (false, parse_bool, [TRACKED],\n         \"omit landing pads for unwinding\"),\n-    debug_llvm: bool = (false, parse_bool,\n+    debug_llvm: bool = (false, parse_bool, [UNTRACKED],\n         \"enable debug output from LLVM\"),\n-    meta_stats: bool = (false, parse_bool,\n+    meta_stats: bool = (false, parse_bool, [UNTRACKED],\n         \"gather metadata statistics\"),\n-    print_link_args: bool = (false, parse_bool,\n+    print_link_args: bool = (false, parse_bool, [UNTRACKED],\n         \"print the arguments passed to the linker\"),\n-    print_llvm_passes: bool = (false, parse_bool,\n+    print_llvm_passes: bool = (false, parse_bool, [UNTRACKED],\n         \"prints the llvm optimization passes being run\"),\n-    ast_json: bool = (false, parse_bool,\n+    ast_json: bool = (false, parse_bool, [UNTRACKED],\n         \"print the AST as JSON and halt\"),\n-    ast_json_noexpand: bool = (false, parse_bool,\n+    ast_json_noexpand: bool = (false, parse_bool, [UNTRACKED],\n         \"print the pre-expansion AST as JSON and halt\"),\n-    ls: bool = (false, parse_bool,\n+    ls: bool = (false, parse_bool, [UNTRACKED],\n         \"list the symbols defined by a library crate\"),\n-    save_analysis: bool = (false, parse_bool,\n+    save_analysis: bool = (false, parse_bool, [UNTRACKED],\n         \"write syntax and type analysis (in JSON format) information in addition to normal output\"),\n-    save_analysis_csv: bool = (false, parse_bool,\n+    save_analysis_csv: bool = (false, parse_bool, [UNTRACKED],\n         \"write syntax and type analysis (in CSV format) information in addition to normal output\"),\n-    print_move_fragments: bool = (false, parse_bool,\n+    print_move_fragments: bool = (false, parse_bool, [UNTRACKED],\n         \"print out move-fragment data for every fn\"),\n-    flowgraph_print_loans: bool = (false, parse_bool,\n+    flowgraph_print_loans: bool = (false, parse_bool, [UNTRACKED],\n         \"include loan analysis data in --unpretty flowgraph output\"),\n-    flowgraph_print_moves: bool = (false, parse_bool,\n+    flowgraph_print_moves: bool = (false, parse_bool, [UNTRACKED],\n         \"include move analysis data in --unpretty flowgraph output\"),\n-    flowgraph_print_assigns: bool = (false, parse_bool,\n+    flowgraph_print_assigns: bool = (false, parse_bool, [UNTRACKED],\n         \"include assignment analysis data in --unpretty flowgraph output\"),\n-    flowgraph_print_all: bool = (false, parse_bool,\n+    flowgraph_print_all: bool = (false, parse_bool, [UNTRACKED],\n         \"include all dataflow analysis data in --unpretty flowgraph output\"),\n-    print_region_graph: bool = (false, parse_bool,\n+    print_region_graph: bool = (false, parse_bool, [UNTRACKED],\n          \"prints region inference graph. \\\n           Use with RUST_REGION_GRAPH=help for more info\"),\n-    parse_only: bool = (false, parse_bool,\n+    parse_only: bool = (false, parse_bool, [UNTRACKED],\n           \"parse only; do not compile, assemble, or link\"),\n-    no_trans: bool = (false, parse_bool,\n+    no_trans: bool = (false, parse_bool, [TRACKED],\n           \"run all passes except translation; no output\"),\n-    treat_err_as_bug: bool = (false, parse_bool,\n+    treat_err_as_bug: bool = (false, parse_bool, [TRACKED],\n           \"treat all errors that occur as bugs\"),\n-    continue_parse_after_error: bool = (false, parse_bool,\n+    continue_parse_after_error: bool = (false, parse_bool, [TRACKED],\n           \"attempt to recover from parse errors (experimental)\"),\n-    incremental: Option<String> = (None, parse_opt_string,\n+    incremental: Option<String> = (None, parse_opt_string, [UNTRACKED],\n           \"enable incremental compilation (experimental)\"),\n-    incremental_info: bool = (false, parse_bool,\n+    incremental_info: bool = (false, parse_bool, [UNTRACKED],\n         \"print high-level information about incremental reuse (or the lack thereof)\"),\n-    dump_dep_graph: bool = (false, parse_bool,\n+    dump_dep_graph: bool = (false, parse_bool, [UNTRACKED],\n           \"dump the dependency graph to $RUST_DEP_GRAPH (default: /tmp/dep_graph.gv)\"),\n-    query_dep_graph: bool = (false, parse_bool,\n+    query_dep_graph: bool = (false, parse_bool, [UNTRACKED],\n           \"enable queries of the dependency graph for regression testing\"),\n-    no_analysis: bool = (false, parse_bool,\n+    no_analysis: bool = (false, parse_bool, [UNTRACKED],\n           \"parse and expand the source, but run no analysis\"),\n-    extra_plugins: Vec<String> = (Vec::new(), parse_list,\n+    extra_plugins: Vec<String> = (Vec::new(), parse_list, [TRACKED],\n         \"load extra plugins\"),\n-    unstable_options: bool = (false, parse_bool,\n+    unstable_options: bool = (false, parse_bool, [UNTRACKED],\n           \"adds unstable command line options to rustc interface\"),\n-    force_overflow_checks: Option<bool> = (None, parse_opt_bool,\n+    force_overflow_checks: Option<bool> = (None, parse_opt_bool, [TRACKED],\n           \"force overflow checks on or off\"),\n-    force_dropflag_checks: Option<bool> = (None, parse_opt_bool,\n+    force_dropflag_checks: Option<bool> = (None, parse_opt_bool, [TRACKED],\n           \"force drop flag checks on or off\"),\n-    trace_macros: bool = (false, parse_bool,\n+    trace_macros: bool = (false, parse_bool, [UNTRACKED],\n           \"for every macro invocation, print its name and arguments\"),\n-    enable_nonzeroing_move_hints: bool = (false, parse_bool,\n+    enable_nonzeroing_move_hints: bool = (false, parse_bool, [TRACKED],\n           \"force nonzeroing move optimization on\"),\n-    keep_hygiene_data: bool = (false, parse_bool,\n+    keep_hygiene_data: bool = (false, parse_bool, [UNTRACKED],\n           \"don't clear the hygiene data after analysis\"),\n-    keep_ast: bool = (false, parse_bool,\n+    keep_ast: bool = (false, parse_bool, [UNTRACKED],\n           \"keep the AST after lowering it to HIR\"),\n-    show_span: Option<String> = (None, parse_opt_string,\n+    show_span: Option<String> = (None, parse_opt_string, [TRACKED],\n           \"show spans for compiler debugging (expr|pat|ty)\"),\n-    print_trans_items: Option<String> = (None, parse_opt_string,\n+    print_trans_items: Option<String> = (None, parse_opt_string, [UNTRACKED],\n           \"print the result of the translation item collection pass\"),\n-    mir_opt_level: Option<usize> = (None, parse_opt_uint,\n+    mir_opt_level: Option<usize> = (None, parse_opt_uint, [TRACKED],\n           \"set the MIR optimization level (0-3)\"),\n-    dump_mir: Option<String> = (None, parse_opt_string,\n+    dump_mir: Option<String> = (None, parse_opt_string, [UNTRACKED],\n           \"dump MIR state at various points in translation\"),\n-    dump_mir_dir: Option<String> = (None, parse_opt_string,\n+    dump_mir_dir: Option<String> = (None, parse_opt_string, [UNTRACKED],\n           \"the directory the MIR is dumped into\"),\n-    orbit: bool = (true, parse_all_bool,\n+    orbit: bool = (true, parse_all_bool, [UNTRACKED],\n           \"get MIR where it belongs - everywhere; most importantly, in orbit\"),\n }\n \n@@ -1185,14 +1343,9 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         debugging_opts.orbit = true;\n     }\n \n-    let parse_only = debugging_opts.parse_only;\n-    let no_trans = debugging_opts.no_trans;\n-    let treat_err_as_bug = debugging_opts.treat_err_as_bug;\n-    let continue_parse_after_error = debugging_opts.continue_parse_after_error;\n     let mir_opt_level = debugging_opts.mir_opt_level.unwrap_or(1);\n-    let no_analysis = debugging_opts.no_analysis;\n \n-    let mut output_types = HashMap::new();\n+    let mut output_types = BTreeMap::new();\n     if !debugging_opts.parse_only {\n         for list in matches.opt_strs(\"emit\") {\n             for output_type in list.split(',') {\n@@ -1360,7 +1513,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n                                 --debuginfo\");\n     }\n \n-    let mut externs = HashMap::new();\n+    let mut externs = BTreeMap::new();\n     for arg in &matches.opt_strs(\"extern\") {\n         let mut parts = arg.splitn(2, '=');\n         let name = match parts.next() {\n@@ -1372,7 +1525,9 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n             None => early_error(error_format, \"--extern value must be of the format `foo=bar`\"),\n         };\n \n-        externs.entry(name.to_string()).or_insert(vec![]).push(location.to_string());\n+        externs.entry(name.to_string())\n+               .or_insert_with(BTreeSet::new)\n+               .insert(location.to_string());\n     }\n \n     let crate_name = matches.opt_str(\"crate-name\");\n@@ -1386,24 +1541,19 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         lint_opts: lint_opts,\n         lint_cap: lint_cap,\n         describe_lints: describe_lints,\n-        output_types: output_types,\n+        output_types: OutputTypes(output_types),\n         search_paths: search_paths,\n         maybe_sysroot: sysroot_opt,\n         target_triple: target,\n         cfg: cfg,\n         test: test,\n-        parse_only: parse_only,\n-        no_trans: no_trans,\n-        treat_err_as_bug: treat_err_as_bug,\n-        continue_parse_after_error: continue_parse_after_error,\n         mir_opt_level: mir_opt_level,\n         incremental: incremental,\n-        no_analysis: no_analysis,\n         debugging_opts: debugging_opts,\n         prints: prints,\n         cg: cg,\n         error_format: error_format,\n-        externs: externs,\n+        externs: Externs(externs),\n         crate_name: crate_name,\n         alt_std_name: None,\n         libs: libs,\n@@ -1530,24 +1680,220 @@ impl fmt::Display for CrateType {\n     }\n }\n \n+/// Commandline arguments passed to the compiler have to be incorporated with\n+/// the dependency tracking system for incremental compilation. This module\n+/// provides some utilities to make this more convenient.\n+///\n+/// The values of all commandline arguments that are relevant for dependency\n+/// tracking are hashed into a single value that determines whether the\n+/// incremental compilation cache can be re-used or not. This hashing is done\n+/// via the DepTrackingHash trait defined below, since the standard Hash\n+/// implementation might not be suitable (e.g. arguments are stored in a Vec,\n+/// the hash of which is order dependent, but we might not want the order of\n+/// arguments to make a difference for the hash).\n+///\n+/// However, since the value provided by Hash::hash often *is* suitable,\n+/// especially for primitive types, there is the\n+/// impl_dep_tracking_hash_via_hash!() macro that allows to simply reuse the\n+/// Hash implementation for DepTrackingHash. It's important though that\n+/// we have an opt-in scheme here, so one is hopefully forced to think about\n+/// how the hash should be calculated when adding a new commandline argument.\n+mod dep_tracking {\n+    use lint;\n+    use middle::cstore;\n+    use session::search_paths::{PathKind, SearchPaths};\n+    use std::collections::BTreeMap;\n+    use std::hash::{Hash, SipHasher};\n+    use std::path::PathBuf;\n+    use super::{Passes, PanicStrategy, CrateType, OptLevel, DebugInfoLevel,\n+                OutputTypes, Externs, ErrorOutputType};\n+    use syntax::ast;\n+    use syntax::feature_gate::UnstableFeatures;\n+    use syntax::parse::token::InternedString;\n+    use syntax::ptr::P;\n+\n+    pub trait DepTrackingHash {\n+        fn hash(&self, &mut SipHasher, ErrorOutputType);\n+    }\n+\n+    macro_rules! impl_dep_tracking_hash_via_hash {\n+        ($t:ty) => (\n+            impl DepTrackingHash for $t {\n+                fn hash(&self, hasher: &mut SipHasher, _: ErrorOutputType) {\n+                    Hash::hash(self, hasher);\n+                }\n+            }\n+        )\n+    }\n+\n+    macro_rules! impl_dep_tracking_hash_for_sortable_vec_of {\n+        ($t:ty) => (\n+            impl DepTrackingHash for Vec<$t> {\n+                fn hash(&self, hasher: &mut SipHasher, error_format: ErrorOutputType) {\n+                    let mut elems = self.clone();\n+                    elems.sort();\n+                    for (i, e) in elems.iter().enumerate() {\n+                        Hash::hash(&i, hasher);\n+                        DepTrackingHash::hash(e, hasher, error_format);\n+                    }\n+                }\n+            }\n+        );\n+    }\n+\n+    impl_dep_tracking_hash_via_hash!(bool);\n+    impl_dep_tracking_hash_via_hash!(usize);\n+    impl_dep_tracking_hash_via_hash!(String);\n+    impl_dep_tracking_hash_via_hash!(lint::Level);\n+    impl_dep_tracking_hash_via_hash!(Option<bool>);\n+    impl_dep_tracking_hash_via_hash!(Option<usize>);\n+    impl_dep_tracking_hash_via_hash!(Option<String>);\n+    impl_dep_tracking_hash_via_hash!(Option<lint::Level>);\n+    impl_dep_tracking_hash_via_hash!(Option<PathBuf>);\n+    impl_dep_tracking_hash_via_hash!(CrateType);\n+    impl_dep_tracking_hash_via_hash!(PanicStrategy);\n+    impl_dep_tracking_hash_via_hash!(Passes);\n+    impl_dep_tracking_hash_via_hash!(OptLevel);\n+    impl_dep_tracking_hash_via_hash!(DebugInfoLevel);\n+    impl_dep_tracking_hash_via_hash!(UnstableFeatures);\n+    impl_dep_tracking_hash_via_hash!(Externs);\n+    impl_dep_tracking_hash_via_hash!(OutputTypes);\n+    impl_dep_tracking_hash_via_hash!(cstore::NativeLibraryKind);\n+\n+    impl_dep_tracking_hash_for_sortable_vec_of!(String);\n+    impl_dep_tracking_hash_for_sortable_vec_of!(CrateType);\n+    impl_dep_tracking_hash_for_sortable_vec_of!((String, lint::Level));\n+    impl_dep_tracking_hash_for_sortable_vec_of!((String, cstore::NativeLibraryKind));\n+\n+    impl DepTrackingHash for SearchPaths {\n+        fn hash(&self, hasher: &mut SipHasher, _: ErrorOutputType) {\n+            let mut elems: Vec<_> = self\n+                .iter(PathKind::All)\n+                .collect();\n+            elems.sort();\n+            Hash::hash(&elems, hasher);\n+        }\n+    }\n+\n+    fn sorted_meta_items(items: &[P<ast::MetaItem>]) -> Vec<&ast::MetaItem> {\n+        // Sort subitems so the hash does not depend on their order\n+        let mut items: Vec<&ast::MetaItem> = items.iter()\n+                                             .map(|r| &**r)\n+                                             .collect();\n+        items.sort_by_key(meta_item_sort_key);\n+        return items;\n+\n+        fn meta_item_sort_key(item: &&ast::MetaItem) -> InternedString {\n+            match item.node {\n+                ast::MetaItemKind::Word(ref s) |\n+                ast::MetaItemKind::NameValue(ref s, _) |\n+                ast::MetaItemKind::List(ref s, _) => s.clone()\n+            }\n+        }\n+    }\n+\n+    impl DepTrackingHash for ast::MetaItem {\n+        fn hash(&self, hasher: &mut SipHasher, error_format: ErrorOutputType) {\n+            // ignoring span information, it doesn't matter here\n+            match self.node {\n+                ast::MetaItemKind::Word(ref s) => {\n+                    Hash::hash(\"Word\", hasher);\n+                    Hash::hash(&s.len(), hasher);\n+                    Hash::hash(s, hasher);\n+                }\n+                ast::MetaItemKind::NameValue(ref s, ref lit) => {\n+                    Hash::hash(\"NameValue\", hasher);\n+                    Hash::hash(&s.len(), hasher);\n+                    Hash::hash(s, hasher);\n+                    Hash::hash(&lit.node, hasher);\n+                }\n+                ast::MetaItemKind::List(ref s, ref items) => {\n+                    Hash::hash(\"List\", hasher);\n+                    Hash::hash(&s.len(), hasher);\n+                    Hash::hash(s, hasher);\n+                    // Sort subitems so the hash does not depend on their order\n+                    let sorted = sorted_meta_items(&items[..]);\n+                    for (index, item) in sorted.iter().enumerate() {\n+                        Hash::hash(&index, hasher);\n+                        DepTrackingHash::hash(*item, hasher, error_format);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    impl DepTrackingHash for ast::CrateConfig {\n+        fn hash(&self, hasher: &mut SipHasher, error_format: ErrorOutputType) {\n+            // Sort subitems so the hash does not depend on their order\n+            let sorted = sorted_meta_items(&self[..]);\n+            for (index, item) in sorted.iter().enumerate() {\n+                Hash::hash(&index, hasher);\n+                DepTrackingHash::hash(*item, hasher, error_format);\n+            }\n+        }\n+    }\n+\n+    impl<T1, T2> DepTrackingHash for (T1, T2)\n+        where T1: DepTrackingHash,\n+              T2: DepTrackingHash\n+    {\n+        fn hash(&self, hasher: &mut SipHasher, error_format: ErrorOutputType) {\n+            Hash::hash(&0, hasher);\n+            DepTrackingHash::hash(&self.0, hasher, error_format);\n+            Hash::hash(&1, hasher);\n+            DepTrackingHash::hash(&self.1, hasher, error_format);\n+        }\n+    }\n+\n+    // This is a stable hash because BTreeMap is a sorted container\n+    pub fn stable_hash(sub_hashes: BTreeMap<&'static str, &DepTrackingHash>,\n+                       hasher: &mut SipHasher,\n+                       error_format: ErrorOutputType) {\n+        for (key, sub_hash) in sub_hashes {\n+            // Using Hash::hash() instead of DepTrackingHash::hash() is fine for\n+            // the keys, as they are just plain strings\n+            Hash::hash(&key.len(), hasher);\n+            Hash::hash(key, hasher);\n+            sub_hash.hash(hasher, error_format);\n+        }\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use dep_graph::DepGraph;\n-    use middle::cstore::DummyCrateStore;\n+    use errors;\n+    use getopts::{getopts, OptGroup};\n+    use lint;\n+    use middle::cstore::{self, DummyCrateStore};\n     use session::config::{build_configuration, build_session_options};\n     use session::build_session;\n-    use errors;\n+    use std::collections::{BTreeMap, BTreeSet};\n+    use std::iter::FromIterator;\n+    use std::path::PathBuf;\n     use std::rc::Rc;\n-    use getopts::{getopts, OptGroup};\n+    use super::{OutputType, OutputTypes, Externs, PanicStrategy};\n+    use syntax::ast::{self, MetaItemKind};\n     use syntax::attr;\n     use syntax::attr::AttrMetaMethods;\n+    use syntax::codemap::dummy_spanned;\n+    use syntax::parse::token::InternedString;\n+    use syntax::ptr::P;\n \n     fn optgroups() -> Vec<OptGroup> {\n         super::rustc_optgroups().into_iter()\n                                 .map(|a| a.opt_group)\n                                 .collect()\n     }\n \n+    fn mk_map<K: Ord, V>(entries: Vec<(K, V)>) -> BTreeMap<K, V> {\n+        BTreeMap::from_iter(entries.into_iter())\n+    }\n+\n+    fn mk_set<V: Ord>(entries: Vec<V>) -> BTreeSet<V> {\n+        BTreeSet::from_iter(entries.into_iter())\n+    }\n+\n     // When the user supplies --test we should implicitly supply --cfg test\n     #[test]\n     fn test_switch_implies_cfg_test() {\n@@ -1624,4 +1970,704 @@ mod tests {\n             assert!(sess.diagnostic().can_emit_warnings);\n         }\n     }\n+\n+    #[test]\n+    fn test_output_types_tracking_hash_different_paths() {\n+        let mut v1 = super::basic_options();\n+        let mut v2 = super::basic_options();\n+        let mut v3 = super::basic_options();\n+\n+        v1.output_types = OutputTypes::new(&[(OutputType::Exe,\n+                                              Some(PathBuf::from(\"./some/thing\")))]);\n+        v2.output_types = OutputTypes::new(&[(OutputType::Exe,\n+                                              Some(PathBuf::from(\"/some/thing\")))]);\n+        v3.output_types = OutputTypes::new(&[(OutputType::Exe, None)]);\n+\n+        assert!(v1.dep_tracking_hash() != v2.dep_tracking_hash());\n+        assert!(v1.dep_tracking_hash() != v3.dep_tracking_hash());\n+        assert!(v2.dep_tracking_hash() != v3.dep_tracking_hash());\n+\n+        // Check clone\n+        assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n+        assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n+        assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n+    }\n+\n+    #[test]\n+    fn test_output_types_tracking_hash_different_construction_order() {\n+        let mut v1 = super::basic_options();\n+        let mut v2 = super::basic_options();\n+\n+        v1.output_types = OutputTypes::new(&[\n+            (OutputType::Exe, Some(PathBuf::from(\"./some/thing\"))),\n+            (OutputType::Bitcode, Some(PathBuf::from(\"./some/thing.bc\"))),\n+        ]);\n+\n+        v2.output_types = OutputTypes::new(&[\n+            (OutputType::Bitcode, Some(PathBuf::from(\"./some/thing.bc\"))),\n+            (OutputType::Exe, Some(PathBuf::from(\"./some/thing\"))),\n+        ]);\n+\n+        assert_eq!(v1.dep_tracking_hash(), v2.dep_tracking_hash());\n+\n+        // Check clone\n+        assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n+    }\n+\n+    #[test]\n+    fn test_externs_tracking_hash_different_values() {\n+        let mut v1 = super::basic_options();\n+        let mut v2 = super::basic_options();\n+        let mut v3 = super::basic_options();\n+\n+        v1.externs = Externs::new(mk_map(vec![\n+            (String::from(\"a\"), mk_set(vec![String::from(\"b\"),\n+                                            String::from(\"c\")])),\n+            (String::from(\"d\"), mk_set(vec![String::from(\"e\"),\n+                                            String::from(\"f\")])),\n+        ]));\n+\n+        v2.externs = Externs::new(mk_map(vec![\n+            (String::from(\"a\"), mk_set(vec![String::from(\"b\"),\n+                                            String::from(\"c\")])),\n+            (String::from(\"X\"), mk_set(vec![String::from(\"e\"),\n+                                            String::from(\"f\")])),\n+        ]));\n+\n+        v3.externs = Externs::new(mk_map(vec![\n+            (String::from(\"a\"), mk_set(vec![String::from(\"b\"),\n+                                            String::from(\"c\")])),\n+            (String::from(\"d\"), mk_set(vec![String::from(\"X\"),\n+                                            String::from(\"f\")])),\n+        ]));\n+\n+        assert!(v1.dep_tracking_hash() != v2.dep_tracking_hash());\n+        assert!(v1.dep_tracking_hash() != v3.dep_tracking_hash());\n+        assert!(v2.dep_tracking_hash() != v3.dep_tracking_hash());\n+\n+        // Check clone\n+        assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n+        assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n+        assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n+    }\n+\n+    #[test]\n+    fn test_externs_tracking_hash_different_construction_order() {\n+        let mut v1 = super::basic_options();\n+        let mut v2 = super::basic_options();\n+        let mut v3 = super::basic_options();\n+\n+        v1.externs = Externs::new(mk_map(vec![\n+            (String::from(\"a\"), mk_set(vec![String::from(\"b\"),\n+                                            String::from(\"c\")])),\n+            (String::from(\"d\"), mk_set(vec![String::from(\"e\"),\n+                                            String::from(\"f\")])),\n+        ]));\n+\n+        v2.externs = Externs::new(mk_map(vec![\n+            (String::from(\"d\"), mk_set(vec![String::from(\"e\"),\n+                                            String::from(\"f\")])),\n+            (String::from(\"a\"), mk_set(vec![String::from(\"b\"),\n+                                            String::from(\"c\")])),\n+        ]));\n+\n+        v3.externs = Externs::new(mk_map(vec![\n+            (String::from(\"a\"), mk_set(vec![String::from(\"b\"),\n+                                            String::from(\"c\")])),\n+            (String::from(\"d\"), mk_set(vec![String::from(\"f\"),\n+                                            String::from(\"e\")])),\n+        ]));\n+\n+        assert_eq!(v1.dep_tracking_hash(), v2.dep_tracking_hash());\n+        assert_eq!(v1.dep_tracking_hash(), v3.dep_tracking_hash());\n+        assert_eq!(v2.dep_tracking_hash(), v3.dep_tracking_hash());\n+\n+        // Check clone\n+        assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n+        assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n+        assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n+    }\n+\n+    #[test]\n+    fn test_lints_tracking_hash_different_values() {\n+        let mut v1 = super::basic_options();\n+        let mut v2 = super::basic_options();\n+        let mut v3 = super::basic_options();\n+\n+        v1.lint_opts = vec![(String::from(\"a\"), lint::Allow),\n+                            (String::from(\"b\"), lint::Warn),\n+                            (String::from(\"c\"), lint::Deny),\n+                            (String::from(\"d\"), lint::Forbid)];\n+\n+        v2.lint_opts = vec![(String::from(\"a\"), lint::Allow),\n+                            (String::from(\"b\"), lint::Warn),\n+                            (String::from(\"X\"), lint::Deny),\n+                            (String::from(\"d\"), lint::Forbid)];\n+\n+        v3.lint_opts = vec![(String::from(\"a\"), lint::Allow),\n+                            (String::from(\"b\"), lint::Warn),\n+                            (String::from(\"c\"), lint::Forbid),\n+                            (String::from(\"d\"), lint::Deny)];\n+\n+        assert!(v1.dep_tracking_hash() != v2.dep_tracking_hash());\n+        assert!(v1.dep_tracking_hash() != v3.dep_tracking_hash());\n+        assert!(v2.dep_tracking_hash() != v3.dep_tracking_hash());\n+\n+        // Check clone\n+        assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n+        assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n+        assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n+    }\n+\n+    #[test]\n+    fn test_lints_tracking_hash_different_construction_order() {\n+        let mut v1 = super::basic_options();\n+        let mut v2 = super::basic_options();\n+\n+        v1.lint_opts = vec![(String::from(\"a\"), lint::Allow),\n+                            (String::from(\"b\"), lint::Warn),\n+                            (String::from(\"c\"), lint::Deny),\n+                            (String::from(\"d\"), lint::Forbid)];\n+\n+        v2.lint_opts = vec![(String::from(\"a\"), lint::Allow),\n+                            (String::from(\"c\"), lint::Deny),\n+                            (String::from(\"b\"), lint::Warn),\n+                            (String::from(\"d\"), lint::Forbid)];\n+\n+        assert_eq!(v1.dep_tracking_hash(), v2.dep_tracking_hash());\n+\n+        // Check clone\n+        assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n+        assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n+    }\n+\n+    #[test]\n+    fn test_crate_config_tracking_hash_different_values() {\n+        let mut v1 = super::basic_options();\n+        let mut v2 = super::basic_options();\n+        let mut v3 = super::basic_options();\n+        let mut v4 = super::basic_options();\n+\n+        // Reference value\n+        v1.cfg = vec![\n+            P(dummy_spanned(MetaItemKind::Word(InternedString::new(\"a\")))),\n+            P(dummy_spanned(MetaItemKind::List(InternedString::new(\"b\"),\n+                    vec![\n+                        P(dummy_spanned(MetaItemKind::Word(InternedString::new(\"c\")))),\n+                        P(dummy_spanned(MetaItemKind::NameValue(InternedString::new(\"d\"),\n+                                                    dummy_spanned(ast::LitKind::Byte(1))))),\n+                    ]))),\n+            P(dummy_spanned(MetaItemKind::NameValue(InternedString::new(\"e\"),\n+                                                    dummy_spanned(ast::LitKind::Byte(2))))),\n+        ];\n+\n+        // Change a label\n+        v2.cfg = vec![\n+            P(dummy_spanned(MetaItemKind::Word(InternedString::new(\"a\")))),\n+            P(dummy_spanned(MetaItemKind::List(InternedString::new(\"X\"),\n+                    vec![\n+                        P(dummy_spanned(MetaItemKind::Word(InternedString::new(\"c\")))),\n+                        P(dummy_spanned(MetaItemKind::NameValue(InternedString::new(\"d\"),\n+                                                    dummy_spanned(ast::LitKind::Byte(1))))),\n+                    ]))),\n+            P(dummy_spanned(MetaItemKind::NameValue(InternedString::new(\"e\"),\n+                                                    dummy_spanned(ast::LitKind::Byte(2))))),\n+        ];\n+\n+        // Change a literal\n+        v3.cfg = vec![\n+            P(dummy_spanned(MetaItemKind::Word(InternedString::new(\"a\")))),\n+            P(dummy_spanned(MetaItemKind::List(InternedString::new(\"X\"),\n+                    vec![\n+                        P(dummy_spanned(MetaItemKind::Word(InternedString::new(\"c\")))),\n+                        P(dummy_spanned(MetaItemKind::NameValue(InternedString::new(\"d\"),\n+                                                    dummy_spanned(ast::LitKind::Byte(99))))),\n+                    ]))),\n+            P(dummy_spanned(MetaItemKind::NameValue(InternedString::new(\"e\"),\n+                                                    dummy_spanned(ast::LitKind::Byte(2))))),\n+        ];\n+\n+        // Remove something\n+        v4.cfg = vec![\n+            P(dummy_spanned(MetaItemKind::Word(InternedString::new(\"a\")))),\n+            P(dummy_spanned(MetaItemKind::List(InternedString::new(\"X\"),\n+                    vec![\n+                        P(dummy_spanned(MetaItemKind::NameValue(InternedString::new(\"d\"),\n+                                                    dummy_spanned(ast::LitKind::Byte(99))))),\n+                    ]))),\n+            P(dummy_spanned(MetaItemKind::NameValue(InternedString::new(\"e\"),\n+                                                    dummy_spanned(ast::LitKind::Byte(2))))),\n+        ];\n+\n+        assert!(v1.dep_tracking_hash() != v2.dep_tracking_hash());\n+        assert!(v1.dep_tracking_hash() != v3.dep_tracking_hash());\n+        assert!(v1.dep_tracking_hash() != v4.dep_tracking_hash());\n+\n+        // Check clone\n+        assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n+        assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n+        assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n+        assert_eq!(v4.dep_tracking_hash(), v4.clone().dep_tracking_hash());\n+    }\n+\n+    #[test]\n+    fn test_crate_config_tracking_hash_different_order() {\n+        let mut v1 = super::basic_options();\n+        let mut v2 = super::basic_options();\n+        let mut v3 = super::basic_options();\n+\n+        // Reference value\n+        v1.cfg = vec![\n+            P(dummy_spanned(MetaItemKind::Word(InternedString::new(\"a\")))),\n+            P(dummy_spanned(MetaItemKind::List(InternedString::new(\"b\"),\n+                    vec![\n+                        P(dummy_spanned(MetaItemKind::Word(InternedString::new(\"c\")))),\n+                        P(dummy_spanned(MetaItemKind::NameValue(InternedString::new(\"d\"),\n+                                                    dummy_spanned(ast::LitKind::Byte(1))))),\n+                    ]))),\n+            P(dummy_spanned(MetaItemKind::NameValue(InternedString::new(\"e\"),\n+                                                    dummy_spanned(ast::LitKind::Byte(2))))),\n+        ];\n+\n+        v2.cfg = vec![\n+            P(dummy_spanned(MetaItemKind::List(InternedString::new(\"b\"),\n+                    vec![\n+                        P(dummy_spanned(MetaItemKind::Word(InternedString::new(\"c\")))),\n+                        P(dummy_spanned(MetaItemKind::NameValue(InternedString::new(\"d\"),\n+                                                    dummy_spanned(ast::LitKind::Byte(1))))),\n+                    ]))),\n+            P(dummy_spanned(MetaItemKind::NameValue(InternedString::new(\"e\"),\n+                                                    dummy_spanned(ast::LitKind::Byte(2))))),\n+            P(dummy_spanned(MetaItemKind::Word(InternedString::new(\"a\")))),\n+        ];\n+\n+        v3.cfg = vec![\n+            P(dummy_spanned(MetaItemKind::Word(InternedString::new(\"a\")))),\n+            P(dummy_spanned(MetaItemKind::List(InternedString::new(\"b\"),\n+                    vec![\n+                        P(dummy_spanned(MetaItemKind::NameValue(InternedString::new(\"d\"),\n+                                                    dummy_spanned(ast::LitKind::Byte(1))))),\n+                        P(dummy_spanned(MetaItemKind::Word(InternedString::new(\"c\")))),\n+                    ]))),\n+            P(dummy_spanned(MetaItemKind::NameValue(InternedString::new(\"e\"),\n+                                                    dummy_spanned(ast::LitKind::Byte(2))))),\n+        ];\n+\n+        assert!(v1.dep_tracking_hash() == v2.dep_tracking_hash());\n+        assert!(v1.dep_tracking_hash() == v3.dep_tracking_hash());\n+\n+        // Check clone\n+        assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n+        assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n+        assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n+    }\n+\n+    #[test]\n+    fn test_search_paths_tracking_hash_different_values() {\n+        let mut v1 = super::basic_options();\n+        let mut v2 = super::basic_options();\n+        let mut v3 = super::basic_options();\n+        let mut v4 = super::basic_options();\n+        let mut v5 = super::basic_options();\n+\n+        // Reference\n+        v1.search_paths.add_path(\"native=abc\", super::ErrorOutputType::Json);\n+        v1.search_paths.add_path(\"crate=def\", super::ErrorOutputType::Json);\n+        v1.search_paths.add_path(\"dependency=ghi\", super::ErrorOutputType::Json);\n+        v1.search_paths.add_path(\"framework=jkl\", super::ErrorOutputType::Json);\n+        v1.search_paths.add_path(\"all=mno\", super::ErrorOutputType::Json);\n+\n+        // Native changed\n+        v2.search_paths.add_path(\"native=XXX\", super::ErrorOutputType::Json);\n+        v2.search_paths.add_path(\"crate=def\", super::ErrorOutputType::Json);\n+        v2.search_paths.add_path(\"dependency=ghi\", super::ErrorOutputType::Json);\n+        v2.search_paths.add_path(\"framework=jkl\", super::ErrorOutputType::Json);\n+        v2.search_paths.add_path(\"all=mno\", super::ErrorOutputType::Json);\n+\n+        // Crate changed\n+        v2.search_paths.add_path(\"native=abc\", super::ErrorOutputType::Json);\n+        v2.search_paths.add_path(\"crate=XXX\", super::ErrorOutputType::Json);\n+        v2.search_paths.add_path(\"dependency=ghi\", super::ErrorOutputType::Json);\n+        v2.search_paths.add_path(\"framework=jkl\", super::ErrorOutputType::Json);\n+        v2.search_paths.add_path(\"all=mno\", super::ErrorOutputType::Json);\n+\n+        // Dependency changed\n+        v3.search_paths.add_path(\"native=abc\", super::ErrorOutputType::Json);\n+        v3.search_paths.add_path(\"crate=def\", super::ErrorOutputType::Json);\n+        v3.search_paths.add_path(\"dependency=XXX\", super::ErrorOutputType::Json);\n+        v3.search_paths.add_path(\"framework=jkl\", super::ErrorOutputType::Json);\n+        v3.search_paths.add_path(\"all=mno\", super::ErrorOutputType::Json);\n+\n+        // Framework changed\n+        v4.search_paths.add_path(\"native=abc\", super::ErrorOutputType::Json);\n+        v4.search_paths.add_path(\"crate=def\", super::ErrorOutputType::Json);\n+        v4.search_paths.add_path(\"dependency=ghi\", super::ErrorOutputType::Json);\n+        v4.search_paths.add_path(\"framework=XXX\", super::ErrorOutputType::Json);\n+        v4.search_paths.add_path(\"all=mno\", super::ErrorOutputType::Json);\n+\n+        // All changed\n+        v5.search_paths.add_path(\"native=abc\", super::ErrorOutputType::Json);\n+        v5.search_paths.add_path(\"crate=def\", super::ErrorOutputType::Json);\n+        v5.search_paths.add_path(\"dependency=ghi\", super::ErrorOutputType::Json);\n+        v5.search_paths.add_path(\"framework=jkl\", super::ErrorOutputType::Json);\n+        v5.search_paths.add_path(\"all=XXX\", super::ErrorOutputType::Json);\n+\n+        assert!(v1.dep_tracking_hash() != v2.dep_tracking_hash());\n+        assert!(v1.dep_tracking_hash() != v3.dep_tracking_hash());\n+        assert!(v1.dep_tracking_hash() != v4.dep_tracking_hash());\n+        assert!(v1.dep_tracking_hash() != v5.dep_tracking_hash());\n+\n+        // Check clone\n+        assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n+        assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n+        assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n+        assert_eq!(v4.dep_tracking_hash(), v4.clone().dep_tracking_hash());\n+        assert_eq!(v5.dep_tracking_hash(), v5.clone().dep_tracking_hash());\n+    }\n+\n+    #[test]\n+    fn test_search_paths_tracking_hash_different_order() {\n+        let mut v1 = super::basic_options();\n+        let mut v2 = super::basic_options();\n+        let mut v3 = super::basic_options();\n+        let mut v4 = super::basic_options();\n+\n+        // Reference\n+        v1.search_paths.add_path(\"native=abc\", super::ErrorOutputType::Json);\n+        v1.search_paths.add_path(\"crate=def\", super::ErrorOutputType::Json);\n+        v1.search_paths.add_path(\"dependency=ghi\", super::ErrorOutputType::Json);\n+        v1.search_paths.add_path(\"framework=jkl\", super::ErrorOutputType::Json);\n+        v1.search_paths.add_path(\"all=mno\", super::ErrorOutputType::Json);\n+\n+        v2.search_paths.add_path(\"native=abc\", super::ErrorOutputType::Json);\n+        v2.search_paths.add_path(\"dependency=ghi\", super::ErrorOutputType::Json);\n+        v2.search_paths.add_path(\"crate=def\", super::ErrorOutputType::Json);\n+        v2.search_paths.add_path(\"framework=jkl\", super::ErrorOutputType::Json);\n+        v2.search_paths.add_path(\"all=mno\", super::ErrorOutputType::Json);\n+\n+        v3.search_paths.add_path(\"crate=def\", super::ErrorOutputType::Json);\n+        v3.search_paths.add_path(\"framework=jkl\", super::ErrorOutputType::Json);\n+        v3.search_paths.add_path(\"native=abc\", super::ErrorOutputType::Json);\n+        v3.search_paths.add_path(\"dependency=ghi\", super::ErrorOutputType::Json);\n+        v3.search_paths.add_path(\"all=mno\", super::ErrorOutputType::Json);\n+\n+        v4.search_paths.add_path(\"all=mno\", super::ErrorOutputType::Json);\n+        v4.search_paths.add_path(\"native=abc\", super::ErrorOutputType::Json);\n+        v4.search_paths.add_path(\"crate=def\", super::ErrorOutputType::Json);\n+        v4.search_paths.add_path(\"dependency=ghi\", super::ErrorOutputType::Json);\n+        v4.search_paths.add_path(\"framework=jkl\", super::ErrorOutputType::Json);\n+\n+        assert!(v1.dep_tracking_hash() == v2.dep_tracking_hash());\n+        assert!(v1.dep_tracking_hash() == v3.dep_tracking_hash());\n+        assert!(v1.dep_tracking_hash() == v4.dep_tracking_hash());\n+\n+        // Check clone\n+        assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n+        assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n+        assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n+        assert_eq!(v4.dep_tracking_hash(), v4.clone().dep_tracking_hash());\n+    }\n+\n+    #[test]\n+    fn test_native_libs_tracking_hash_different_values() {\n+        let mut v1 = super::basic_options();\n+        let mut v2 = super::basic_options();\n+        let mut v3 = super::basic_options();\n+\n+        // Reference\n+        v1.libs = vec![(String::from(\"a\"), cstore::NativeStatic),\n+                       (String::from(\"b\"), cstore::NativeFramework),\n+                       (String::from(\"c\"), cstore::NativeUnknown)];\n+\n+        // Change label\n+        v2.libs = vec![(String::from(\"a\"), cstore::NativeStatic),\n+                       (String::from(\"X\"), cstore::NativeFramework),\n+                       (String::from(\"c\"), cstore::NativeUnknown)];\n+\n+        // Change kind\n+        v3.libs = vec![(String::from(\"a\"), cstore::NativeStatic),\n+                       (String::from(\"b\"), cstore::NativeStatic),\n+                       (String::from(\"c\"), cstore::NativeUnknown)];\n+\n+        assert!(v1.dep_tracking_hash() != v2.dep_tracking_hash());\n+        assert!(v1.dep_tracking_hash() != v3.dep_tracking_hash());\n+\n+        // Check clone\n+        assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n+        assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n+        assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n+    }\n+\n+    #[test]\n+    fn test_native_libs_tracking_hash_different_order() {\n+        let mut v1 = super::basic_options();\n+        let mut v2 = super::basic_options();\n+        let mut v3 = super::basic_options();\n+\n+        // Reference\n+        v1.libs = vec![(String::from(\"a\"), cstore::NativeStatic),\n+                       (String::from(\"b\"), cstore::NativeFramework),\n+                       (String::from(\"c\"), cstore::NativeUnknown)];\n+\n+        v2.libs = vec![(String::from(\"b\"), cstore::NativeFramework),\n+                       (String::from(\"a\"), cstore::NativeStatic),\n+                       (String::from(\"c\"), cstore::NativeUnknown)];\n+\n+        v3.libs = vec![(String::from(\"c\"), cstore::NativeUnknown),\n+                       (String::from(\"a\"), cstore::NativeStatic),\n+                       (String::from(\"b\"), cstore::NativeFramework)];\n+\n+        assert!(v1.dep_tracking_hash() == v2.dep_tracking_hash());\n+        assert!(v1.dep_tracking_hash() == v3.dep_tracking_hash());\n+        assert!(v2.dep_tracking_hash() == v3.dep_tracking_hash());\n+\n+        // Check clone\n+        assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n+        assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n+        assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n+    }\n+\n+    #[test]\n+    fn test_codegen_options_tracking_hash() {\n+        let reference = super::basic_options();\n+        let mut opts = super::basic_options();\n+\n+        // Make sure the changing an [UNTRACKED] option leaves the hash unchanged\n+        opts.cg.ar = Some(String::from(\"abc\"));\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+\n+        opts.cg.linker = Some(String::from(\"linker\"));\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+\n+        opts.cg.link_args = Some(vec![String::from(\"abc\"), String::from(\"def\")]);\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+\n+        opts.cg.link_dead_code = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+\n+        opts.cg.rpath = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+\n+        opts.cg.extra_filename = String::from(\"extra-filename\");\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+\n+        opts.cg.codegen_units = 42;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+\n+        opts.cg.remark = super::SomePasses(vec![String::from(\"pass1\"),\n+                                                String::from(\"pass2\")]);\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+\n+        opts.cg.save_temps = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+\n+\n+        // Make sure changing a [TRACKED] option changes the hash\n+        opts = reference.clone();\n+        opts.cg.lto = true;\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.cg.target_cpu = Some(String::from(\"abc\"));\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.cg.target_feature = String::from(\"all the features, all of them\");\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.cg.passes = vec![String::from(\"1\"), String::from(\"2\")];\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.cg.llvm_args = vec![String::from(\"1\"), String::from(\"2\")];\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.cg.no_prepopulate_passes = true;\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.cg.no_vectorize_loops = true;\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.cg.no_vectorize_slp = true;\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.cg.soft_float = true;\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.cg.prefer_dynamic = true;\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.cg.no_integrated_as = true;\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.cg.no_redzone = Some(true);\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.cg.relocation_model = Some(String::from(\"relocation model\"));\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.cg.code_model = Some(String::from(\"code model\"));\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.cg.metadata = vec![String::from(\"A\"), String::from(\"B\")];\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.cg.debuginfo = Some(0xdeadbeef);\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.cg.debuginfo = Some(0xba5eba11);\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.cg.debug_assertions = Some(true);\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.cg.inline_threshold = Some(0xf007ba11);\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.cg.panic = PanicStrategy::Abort;\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+    }\n+\n+    #[test]\n+    fn test_debugging_options_tracking_hash() {\n+        let reference = super::basic_options();\n+        let mut opts = super::basic_options();\n+\n+        // Make sure the changing an [UNTRACKED] option leaves the hash unchanged\n+        opts.debugging_opts.verbose = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.time_passes = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.count_llvm_insns = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.time_llvm_passes = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.input_stats = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.trans_stats = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.borrowck_stats = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.debug_llvm = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.meta_stats = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.print_link_args = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.print_llvm_passes = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.ast_json = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.ast_json_noexpand = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.ls = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.save_analysis = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.save_analysis_csv = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.print_move_fragments = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.flowgraph_print_loans = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.flowgraph_print_moves = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.flowgraph_print_assigns = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.flowgraph_print_all = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.print_region_graph = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.parse_only = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.incremental = Some(String::from(\"abc\"));\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.dump_dep_graph = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.query_dep_graph = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.no_analysis = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.unstable_options = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.trace_macros = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.keep_hygiene_data = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.keep_ast = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.print_trans_items = Some(String::from(\"abc\"));\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.dump_mir = Some(String::from(\"abc\"));\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.dump_mir_dir = Some(String::from(\"abc\"));\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.orbit = false;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+\n+        // Make sure changing a [TRACKED] option changes the hash\n+        opts = reference.clone();\n+        opts.debugging_opts.asm_comments = true;\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.debugging_opts.no_verify = true;\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.debugging_opts.no_landing_pads = true;\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.debugging_opts.no_trans = true;\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.debugging_opts.treat_err_as_bug = true;\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.debugging_opts.continue_parse_after_error = true;\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.debugging_opts.extra_plugins = vec![String::from(\"plugin1\"), String::from(\"plugin2\")];\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.debugging_opts.force_overflow_checks = Some(true);\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.debugging_opts.force_dropflag_checks = Some(true);\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.debugging_opts.enable_nonzeroing_move_hints = true;\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.debugging_opts.show_span = Some(String::from(\"abc\"));\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.debugging_opts.mir_opt_level = Some(1);\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+    }\n }"}, {"sha": "c71253aee568f9a1e0cd8dcc905557cd7fa7bb20", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32414310b7e0b93491ce6243e1ec0c92c6168557/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32414310b7e0b93491ce6243e1ec0c92c6168557/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=32414310b7e0b93491ce6243e1ec0c92c6168557", "patch": "@@ -363,7 +363,7 @@ pub fn build_session_with_codemap(sopts: config::Options,\n         .map(|&(_, ref level)| *level != lint::Allow)\n         .last()\n         .unwrap_or(true);\n-    let treat_err_as_bug = sopts.treat_err_as_bug;\n+    let treat_err_as_bug = sopts.debugging_opts.treat_err_as_bug;\n \n     let emitter: Box<Emitter> = match sopts.error_format {\n         config::ErrorOutputType::HumanReadable(color_config) => {"}, {"sha": "5bbc6841693ea3628c75c8ebf35988b046485ac1", "filename": "src/librustc/session/search_paths.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32414310b7e0b93491ce6243e1ec0c92c6168557/src%2Flibrustc%2Fsession%2Fsearch_paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32414310b7e0b93491ce6243e1ec0c92c6168557/src%2Flibrustc%2Fsession%2Fsearch_paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fsearch_paths.rs?ref=32414310b7e0b93491ce6243e1ec0c92c6168557", "patch": "@@ -22,7 +22,7 @@ pub struct Iter<'a> {\n     iter: slice::Iter<'a, (PathKind, PathBuf)>,\n }\n \n-#[derive(Eq, PartialEq, Clone, Copy, Debug)]\n+#[derive(Eq, PartialEq, Clone, Copy, Debug, PartialOrd, Ord, Hash)]\n pub enum PathKind {\n     Native,\n     Crate,"}, {"sha": "aa794829be2caa556ca8a9dd2a1a3cc1092b8155", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/32414310b7e0b93491ce6243e1ec0c92c6168557/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32414310b7e0b93491ce6243e1ec0c92c6168557/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=32414310b7e0b93491ce6243e1ec0c92c6168557", "patch": "@@ -15,7 +15,8 @@ use rustc::hir::lowering::lower_crate;\n use rustc_mir as mir;\n use rustc::mir::mir_map::MirMap;\n use rustc::session::{Session, CompileResult, compile_result_from_err_count};\n-use rustc::session::config::{self, Input, OutputFilenames, OutputType};\n+use rustc::session::config::{self, Input, OutputFilenames, OutputType,\n+                             OutputTypes};\n use rustc::session::search_paths::PathKind;\n use rustc::lint;\n use rustc::middle::{self, dependency_format, stability, reachable};\n@@ -42,7 +43,6 @@ use super::Compilation;\n \n use serialize::json;\n \n-use std::collections::HashMap;\n use std::env;\n use std::ffi::{OsString, OsStr};\n use std::fs;\n@@ -478,7 +478,7 @@ pub fn phase_1_parse_input<'a>(sess: &'a Session,\n                                cfg: ast::CrateConfig,\n                                input: &Input)\n                                -> PResult<'a, ast::Crate> {\n-    let continue_after_error = sess.opts.continue_parse_after_error;\n+    let continue_after_error = sess.opts.debugging_opts.continue_parse_after_error;\n     sess.diagnostic().set_continue_after_error(continue_after_error);\n \n     let krate = time(sess.time_passes(), \"parsing\", || {\n@@ -1026,11 +1026,10 @@ pub fn phase_5_run_llvm_passes(sess: &Session,\n                                trans: &trans::CrateTranslation,\n                                outputs: &OutputFilenames) -> CompileResult {\n     if sess.opts.cg.no_integrated_as {\n-        let mut map = HashMap::new();\n-        map.insert(OutputType::Assembly, None);\n+        let output_types = OutputTypes::new(&[(OutputType::Assembly, None)]);\n         time(sess.time_passes(),\n              \"LLVM passes\",\n-             || write::run_passes(sess, trans, &map, outputs));\n+             || write::run_passes(sess, trans, &output_types, outputs));\n \n         write::run_assembler(sess, outputs);\n "}, {"sha": "b2a6df8d345c9dd4750e9cbd864dd17e93b6b7d8", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/32414310b7e0b93491ce6243e1ec0c92c6168557/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32414310b7e0b93491ce6243e1ec0c92c6168557/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=32414310b7e0b93491ce6243e1ec0c92c6168557", "patch": "@@ -506,12 +506,14 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n             return control;\n         }\n \n-        if sess.opts.parse_only || sess.opts.debugging_opts.show_span.is_some() ||\n+        if sess.opts.debugging_opts.parse_only ||\n+           sess.opts.debugging_opts.show_span.is_some() ||\n            sess.opts.debugging_opts.ast_json_noexpand {\n             control.after_parse.stop = Compilation::Stop;\n         }\n \n-        if sess.opts.no_analysis || sess.opts.debugging_opts.ast_json {\n+        if sess.opts.debugging_opts.no_analysis ||\n+           sess.opts.debugging_opts.ast_json {\n             control.after_hir_lowering.stop = Compilation::Stop;\n         }\n "}, {"sha": "543a9c88a586a847b8bac39337ed63848b0f870d", "filename": "src/librustc_metadata/loader.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/32414310b7e0b93491ce6243e1ec0c92c6168557/src%2Flibrustc_metadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32414310b7e0b93491ce6243e1ec0c92c6168557/src%2Flibrustc_metadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Floader.rs?ref=32414310b7e0b93491ce6243e1ec0c92c6168557", "patch": "@@ -400,7 +400,7 @@ impl<'a> Context<'a> {\n         if self.hash.is_none() {\n             self.should_match_name = false;\n             if let Some(s) = self.sess.opts.externs.get(self.crate_name) {\n-                return self.find_commandline_library(s);\n+                return self.find_commandline_library(s.iter());\n             }\n             self.should_match_name = true;\n         }\n@@ -661,7 +661,9 @@ impl<'a> Context<'a> {\n         (t.options.staticlib_prefix.clone(), t.options.staticlib_suffix.clone())\n     }\n \n-    fn find_commandline_library(&mut self, locs: &[String]) -> Option<Library> {\n+    fn find_commandline_library<'b, LOCS> (&mut self, locs: LOCS) -> Option<Library>\n+        where LOCS: Iterator<Item=&'b String>\n+    {\n         // First, filter out all libraries that look suspicious. We only accept\n         // files which actually exist that have the correct naming scheme for\n         // rlibs/dylibs.\n@@ -670,7 +672,7 @@ impl<'a> Context<'a> {\n         let mut rlibs = HashMap::new();\n         let mut dylibs = HashMap::new();\n         {\n-            let locs = locs.iter().map(|l| PathBuf::from(l)).filter(|loc| {\n+            let locs = locs.map(|l| PathBuf::from(l)).filter(|loc| {\n                 if !loc.exists() {\n                     sess.err(&format!(\"extern location for {} does not exist: {}\",\n                                      self.crate_name, loc.display()));"}, {"sha": "f17d1a7f1cf31bd04aae8fe593632bef4f97edc0", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/32414310b7e0b93491ce6243e1ec0c92c6168557/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32414310b7e0b93491ce6243e1ec0c92c6168557/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=32414310b7e0b93491ce6243e1ec0c92c6168557", "patch": "@@ -190,7 +190,8 @@ pub fn link_binary(sess: &Session,\n     let mut out_filenames = Vec::new();\n     for &crate_type in sess.crate_types.borrow().iter() {\n         // Ignore executable crates if we have -Z no-trans, as they will error.\n-        if sess.opts.no_trans && crate_type == config::CrateTypeExecutable {\n+        if sess.opts.debugging_opts.no_trans &&\n+           crate_type == config::CrateTypeExecutable {\n             continue;\n         }\n "}, {"sha": "4b9c29d3d7db3a57b4f17063464315143175d6fb", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/32414310b7e0b93491ce6243e1ec0c92c6168557/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32414310b7e0b93491ce6243e1ec0c92c6168557/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=32414310b7e0b93491ce6243e1ec0c92c6168557", "patch": "@@ -11,7 +11,7 @@\n use back::lto;\n use back::link::{get_linker, remove};\n use rustc_incremental::save_trans_partition;\n-use session::config::{OutputFilenames, Passes, SomePasses, AllPasses};\n+use session::config::{OutputFilenames, OutputTypes, Passes, SomePasses, AllPasses};\n use session::Session;\n use session::config::{self, OutputType};\n use llvm;\n@@ -26,7 +26,6 @@ use errors::emitter::Emitter;\n use syntax_pos::MultiSpan;\n use context::{is_pie_binary, get_reloc_model};\n \n-use std::collections::HashMap;\n use std::ffi::{CStr, CString};\n use std::fs;\n use std::path::{Path, PathBuf};\n@@ -641,7 +640,7 @@ pub fn cleanup_llvm(trans: &CrateTranslation) {\n \n pub fn run_passes(sess: &Session,\n                   trans: &CrateTranslation,\n-                  output_types: &HashMap<OutputType, Option<PathBuf>>,\n+                  output_types: &OutputTypes,\n                   crate_output: &OutputFilenames) {\n     // It's possible that we have `codegen_units > 1` but only one item in\n     // `trans.modules`.  We could theoretically proceed and do LTO in that"}, {"sha": "a79eca15a369a2cb81a8e93bb31247e573c0abf3", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32414310b7e0b93491ce6243e1ec0c92c6168557/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32414310b7e0b93491ce6243e1ec0c92c6168557/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=32414310b7e0b93491ce6243e1ec0c92c6168557", "patch": "@@ -2569,7 +2569,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     assert_module_sources::assert_module_sources(tcx, &modules);\n \n     // Skip crate items and just output metadata in -Z no-trans mode.\n-    if tcx.sess.opts.no_trans {\n+    if tcx.sess.opts.debugging_opts.no_trans {\n         let linker_info = LinkerInfo::new(&shared_ccx, &[]);\n         return CrateTranslation {\n             modules: modules,"}, {"sha": "863b787c58d7401384e7d31c31b64b04c8f77454", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/32414310b7e0b93491ce6243e1ec0c92c6168557/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32414310b7e0b93491ce6243e1ec0c92c6168557/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=32414310b7e0b93491ce6243e1ec0c92c6168557", "patch": "@@ -45,7 +45,6 @@ pub enum MaybeTyped<'a, 'tcx: 'a> {\n     NotTyped(&'a session::Session)\n }\n \n-pub type Externs = HashMap<String, Vec<String>>;\n pub type ExternalPaths = HashMap<DefId, (Vec<String>, clean::TypeKind)>;\n \n pub struct DocContext<'a, 'tcx: 'a> {\n@@ -99,7 +98,7 @@ impl DocAccessLevels for AccessLevels<DefId> {\n \n pub fn run_core(search_paths: SearchPaths,\n                 cfgs: Vec<String>,\n-                externs: Externs,\n+                externs: config::Externs,\n                 input: Input,\n                 triple: Option<String>) -> (clean::Crate, RenderInfo)\n {"}, {"sha": "255e6b1e786dfd38f621eaee0d7d318a6519a45e", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/32414310b7e0b93491ce6243e1ec0c92c6168557/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32414310b7e0b93491ce6243e1ec0c92c6168557/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=32414310b7e0b93491ce6243e1ec0c92c6168557", "patch": "@@ -51,7 +51,7 @@ extern crate rustc_errors as errors;\n \n extern crate serialize as rustc_serialize; // used by deriving\n \n-use std::collections::HashMap;\n+use std::collections::{BTreeMap, BTreeSet};\n use std::default::Default;\n use std::env;\n use std::path::PathBuf;\n@@ -60,7 +60,8 @@ use std::sync::mpsc::channel;\n \n use externalfiles::ExternalHtml;\n use rustc::session::search_paths::SearchPaths;\n-use rustc::session::config::{ErrorOutputType, RustcOptGroup, nightly_options};\n+use rustc::session::config::{ErrorOutputType, RustcOptGroup, nightly_options,\n+                             Externs};\n \n #[macro_use]\n pub mod externalfiles;\n@@ -323,7 +324,7 @@ pub fn main_args(args: &[String]) -> isize {\n /// Looks inside the command line arguments to extract the relevant input format\n /// and files and then generates the necessary rustdoc output for formatting.\n fn acquire_input(input: &str,\n-                 externs: core::Externs,\n+                 externs: Externs,\n                  matches: &getopts::Matches) -> Result<Output, String> {\n     match matches.opt_str(\"r\").as_ref().map(|s| &**s) {\n         Some(\"rust\") => Ok(rust_input(input, externs, matches)),\n@@ -335,28 +336,28 @@ fn acquire_input(input: &str,\n }\n \n /// Extracts `--extern CRATE=PATH` arguments from `matches` and\n-/// returns a `HashMap` mapping crate names to their paths or else an\n+/// returns a map mapping crate names to their paths or else an\n /// error message.\n-fn parse_externs(matches: &getopts::Matches) -> Result<core::Externs, String> {\n-    let mut externs = HashMap::new();\n+fn parse_externs(matches: &getopts::Matches) -> Result<Externs, String> {\n+    let mut externs = BTreeMap::new();\n     for arg in &matches.opt_strs(\"extern\") {\n         let mut parts = arg.splitn(2, '=');\n         let name = parts.next().ok_or(\"--extern value must not be empty\".to_string())?;\n         let location = parts.next()\n                                  .ok_or(\"--extern value must be of the format `foo=bar`\"\n                                     .to_string())?;\n         let name = name.to_string();\n-        externs.entry(name).or_insert(vec![]).push(location.to_string());\n+        externs.entry(name).or_insert_with(BTreeSet::new).insert(location.to_string());\n     }\n-    Ok(externs)\n+    Ok(Externs::new(externs))\n }\n \n /// Interprets the input file as a rust source file, passing it through the\n /// compiler all the way through the analysis passes. The rustdoc output is then\n /// generated from the cleaned AST of the crate.\n ///\n /// This form of input will run all of the plug/cleaning passes\n-fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matches) -> Output {\n+fn rust_input(cratefile: &str, externs: Externs, matches: &getopts::Matches) -> Output {\n     let mut default_passes = !matches.opt_present(\"no-defaults\");\n     let mut passes = matches.opt_strs(\"passes\");\n     let mut plugins = matches.opt_strs(\"plugins\");"}, {"sha": "1421a3c78fc5a40a7c4803b2cc21ff73677cc4c4", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32414310b7e0b93491ce6243e1ec0c92c6168557/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32414310b7e0b93491ce6243e1ec0c92c6168557/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=32414310b7e0b93491ce6243e1ec0c92c6168557", "patch": "@@ -14,10 +14,10 @@ use std::io::prelude::*;\n use std::io;\n use std::path::{PathBuf, Path};\n \n-use core;\n use getopts;\n use testing;\n use rustc::session::search_paths::SearchPaths;\n+use rustc::session::config::Externs;\n \n use externalfiles::ExternalHtml;\n \n@@ -142,7 +142,7 @@ pub fn render(input: &str, mut output: PathBuf, matches: &getopts::Matches,\n }\n \n /// Run any tests/code examples in the markdown file `input`.\n-pub fn test(input: &str, cfgs: Vec<String>, libs: SearchPaths, externs: core::Externs,\n+pub fn test(input: &str, cfgs: Vec<String>, libs: SearchPaths, externs: Externs,\n             mut test_args: Vec<String>) -> isize {\n     let input_str = load_or_return!(input, 1, 2);\n "}, {"sha": "12749c857ab91f1321b340315f2a10d74a4da179", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/32414310b7e0b93491ce6243e1ec0c92c6168557/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32414310b7e0b93491ce6243e1ec0c92c6168557/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=32414310b7e0b93491ce6243e1ec0c92c6168557", "patch": "@@ -26,7 +26,8 @@ use rustc_lint;\n use rustc::dep_graph::DepGraph;\n use rustc::hir::map as hir_map;\n use rustc::session::{self, config};\n-use rustc::session::config::{get_unstable_features_setting, OutputType};\n+use rustc::session::config::{get_unstable_features_setting, OutputType,\n+                             OutputTypes, Externs};\n use rustc::session::search_paths::{SearchPaths, PathKind};\n use rustc_back::dynamic_lib::DynamicLibrary;\n use rustc_back::tempdir::TempDir;\n@@ -55,7 +56,7 @@ pub struct TestOptions {\n pub fn run(input: &str,\n            cfgs: Vec<String>,\n            libs: SearchPaths,\n-           externs: core::Externs,\n+           externs: Externs,\n            mut test_args: Vec<String>,\n            crate_name: Option<String>)\n            -> isize {\n@@ -172,7 +173,7 @@ fn scrape_test_config(krate: &::rustc::hir::Crate) -> TestOptions {\n }\n \n fn runtest(test: &str, cratename: &str, cfgs: Vec<String>, libs: SearchPaths,\n-           externs: core::Externs,\n+           externs: Externs,\n            should_panic: bool, no_run: bool, as_test_harness: bool,\n            compile_fail: bool, mut error_codes: Vec<String>, opts: &TestOptions) {\n     // the test harness wants its own `main` & top level functions, so\n@@ -182,8 +183,7 @@ fn runtest(test: &str, cratename: &str, cfgs: Vec<String>, libs: SearchPaths,\n         name: driver::anon_src(),\n         input: test.to_owned(),\n     };\n-    let mut outputs = HashMap::new();\n-    outputs.insert(OutputType::Exe, None);\n+    let outputs = OutputTypes::new(&[(OutputType::Exe, None)]);\n \n     let sessopts = config::Options {\n         maybe_sysroot: Some(env::current_exe().unwrap().parent().unwrap()\n@@ -396,7 +396,7 @@ pub struct Collector {\n     names: Vec<String>,\n     cfgs: Vec<String>,\n     libs: SearchPaths,\n-    externs: core::Externs,\n+    externs: Externs,\n     cnt: usize,\n     use_headers: bool,\n     current_header: Option<String>,\n@@ -405,7 +405,7 @@ pub struct Collector {\n }\n \n impl Collector {\n-    pub fn new(cratename: String, cfgs: Vec<String>, libs: SearchPaths, externs: core::Externs,\n+    pub fn new(cratename: String, cfgs: Vec<String>, libs: SearchPaths, externs: Externs,\n                use_headers: bool, opts: TestOptions) -> Collector {\n         Collector {\n             tests: Vec::new(),"}, {"sha": "d7a6c16ede0ce3e6a2ba4fde15de6aec48ed415a", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32414310b7e0b93491ce6243e1ec0c92c6168557/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32414310b7e0b93491ce6243e1ec0c92c6168557/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=32414310b7e0b93491ce6243e1ec0c92c6168557", "patch": "@@ -1171,7 +1171,7 @@ pub fn check_crate(krate: &ast::Crate,\n     visit::walk_crate(&mut PostExpansionVisitor { context: &ctx }, krate);\n }\n \n-#[derive(Clone, Copy)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n pub enum UnstableFeatures {\n     /// Hard errors for unstable features are active, as on\n     /// beta/stable channels."}, {"sha": "f501c06a823b5d03ec83826e2b86d81ad488199a", "filename": "src/test/run-make/issue-19371/foo.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/32414310b7e0b93491ce6243e1ec0c92c6168557/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32414310b7e0b93491ce6243e1ec0c92c6168557/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs?ref=32414310b7e0b93491ce6243e1ec0c92c6168557", "patch": "@@ -19,7 +19,8 @@ extern crate syntax;\n \n use rustc::dep_graph::DepGraph;\n use rustc::session::{build_session, Session};\n-use rustc::session::config::{basic_options, build_configuration, Input, OutputType};\n+use rustc::session::config::{basic_options, build_configuration, Input,\n+                             OutputType, OutputTypes};\n use rustc_driver::driver::{compile_input, CompileController, anon_src};\n use rustc_metadata::cstore::CStore;\n use rustc_errors::registry::Registry;\n@@ -51,7 +52,7 @@ fn main() {\n \n fn basic_sess(sysroot: PathBuf) -> (Session, Rc<CStore>) {\n     let mut opts = basic_options();\n-    opts.output_types.insert(OutputType::Exe, None);\n+    opts.output_types = OutputTypes::new([(OutputType::Exe, None)]);\n     opts.maybe_sysroot = Some(sysroot);\n \n     let descriptions = Registry::new(&rustc::DIAGNOSTICS);"}]}