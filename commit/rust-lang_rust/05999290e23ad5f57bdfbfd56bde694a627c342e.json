{"sha": "05999290e23ad5f57bdfbfd56bde694a627c342e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1OTk5MjkwZTIzYWQ1ZjU3YmRmYmZkNTZiZGU2OTRhNjI3YzM0MmU=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-10-06T00:19:50Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-10-06T04:03:40Z"}, "message": "Finally removing all uses of by-mut-ref\n\nThe code for the mode itself is still there.", "tree": {"sha": "4c46f6dd9fd367e445413743bd0f7bc7722c42b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c46f6dd9fd367e445413743bd0f7bc7722c42b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/05999290e23ad5f57bdfbfd56bde694a627c342e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/05999290e23ad5f57bdfbfd56bde694a627c342e", "html_url": "https://github.com/rust-lang/rust/commit/05999290e23ad5f57bdfbfd56bde694a627c342e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/05999290e23ad5f57bdfbfd56bde694a627c342e/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "688a920045627a3afa8ef46ee9d62b253ccfa243", "url": "https://api.github.com/repos/rust-lang/rust/commits/688a920045627a3afa8ef46ee9d62b253ccfa243", "html_url": "https://github.com/rust-lang/rust/commit/688a920045627a3afa8ef46ee9d62b253ccfa243"}], "stats": {"total": 215, "additions": 6, "deletions": 209}, "files": [{"sha": "ce3dec89e418582802c63146226743bcfbb5123a", "filename": "src/libcore/at_vec.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/05999290e23ad5f57bdfbfd56bde694a627c342e/src%2Flibcore%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05999290e23ad5f57bdfbfd56bde694a627c342e/src%2Flibcore%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fat_vec.rs?ref=05999290e23ad5f57bdfbfd56bde694a627c342e", "patch": "@@ -21,10 +21,6 @@ extern mod rustrt {\n #[abi = \"rust-intrinsic\"]\n extern mod rusti {\n     #[legacy_exports];\n-    #[cfg(stage0)]\n-    fn move_val_init<T>(&dst: T, -src: T);\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     fn move_val_init<T>(dst: &mut T, -src: T);\n }\n \n@@ -181,20 +177,6 @@ pub mod raw {\n         }\n     }\n \n-    // This doesn't bother to make sure we have space.\n-    #[cfg(stage0)]\n-    #[inline(always)] // really pretty please\n-    pub unsafe fn push_fast<T>(v: &mut @[const T], initval: T) {\n-        let repr: **VecRepr = ::cast::reinterpret_cast(&v);\n-        let fill = (**repr).unboxed.fill;\n-        (**repr).unboxed.fill += sys::size_of::<T>();\n-        let p = addr_of(&((**repr).unboxed.data));\n-        let p = ptr::offset(p, fill) as *mut T;\n-        rusti::move_val_init(*p, move initval);\n-    }\n-    // This doesn't bother to make sure we have space.\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     #[inline(always)] // really pretty please\n     pub unsafe fn push_fast<T>(v: &mut @[const T], initval: T) {\n         let repr: **VecRepr = ::cast::reinterpret_cast(&v);"}, {"sha": "3a2b73f5b5b4ebef63cc2e5af8c0a7fed1018357", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/05999290e23ad5f57bdfbfd56bde694a627c342e/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05999290e23ad5f57bdfbfd56bde694a627c342e/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=05999290e23ad5f57bdfbfd56bde694a627c342e", "patch": "@@ -18,10 +18,6 @@ extern mod rustrt {\n \n #[abi = \"rust-intrinsic\"]\n extern mod rusti {\n-    #[cfg(stage0)]\n-    fn move_val_init<T>(&dst: T, -src: T);\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     fn move_val_init<T>(dst: &mut T, -src: T);\n }\n \n@@ -103,23 +99,6 @@ pub pure fn len<T>(v: &[const T]) -> uint {\n  * Creates an immutable vector of size `n_elts` and initializes the elements\n  * to the value returned by the function `op`.\n  */\n-#[cfg(stage0)]\n-pub pure fn from_fn<T>(n_elts: uint, op: iter::InitOp<T>) -> ~[T] {\n-    unsafe {\n-        let mut v = with_capacity(n_elts);\n-        do as_mut_buf(v) |p, _len| {\n-            let mut i: uint = 0u;\n-            while i < n_elts {\n-                rusti::move_val_init(*ptr::mut_offset(p, i), op(i));\n-                i += 1u;\n-            }\n-        }\n-        raw::set_len(&mut v, n_elts);\n-        return move v;\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n pub pure fn from_fn<T>(n_elts: uint, op: iter::InitOp<T>) -> ~[T] {\n     unsafe {\n         let mut v = with_capacity(n_elts);\n@@ -503,19 +482,6 @@ pub fn push<T>(v: &mut ~[T], initval: T) {\n     }\n }\n \n-#[cfg(stage0)]\n-// This doesn't bother to make sure we have space.\n-#[inline(always)] // really pretty please\n-unsafe fn push_fast<T>(v: &mut ~[T], initval: T) {\n-    let repr: **raw::VecRepr = ::cast::transmute(v);\n-    let fill = (**repr).unboxed.fill;\n-    (**repr).unboxed.fill += sys::size_of::<T>();\n-    let p = addr_of(&((**repr).unboxed.data));\n-    let p = ptr::offset(p, fill) as *mut T;\n-    rusti::move_val_init(*p, move initval);\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n // This doesn't bother to make sure we have space.\n #[inline(always)] // really pretty please\n unsafe fn push_fast<T>(v: &mut ~[T], initval: T) {\n@@ -1793,18 +1759,6 @@ pub mod raw {\n         as_const_buf(v, |p, _len| *ptr::const_offset(p, i))\n     }\n \n-    #[cfg(stage0)]\n-    #[inline(always)]\n-    pub unsafe fn init_elem<T>(v: &[mut T], i: uint, val: T) {\n-        let mut box = Some(move val);\n-        do as_mut_buf(v) |p, _len| {\n-            let mut box2 = None;\n-            box2 <-> box;\n-            rusti::move_val_init(*ptr::mut_offset(p, i),\n-                                 option::unwrap(move box2));\n-        }\n-    }\n-    #[cfg(stage1)]\n     /**\n      * Unchecked vector index assignment.  Does not drop the\n      * old value and hence is only suitable when the vector"}, {"sha": "6a2ac88f71435d7565cb13c62a069ba2833d92ac", "filename": "src/libstd/arena.rs", "status": "modified", "additions": 0, "deletions": 115, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/05999290e23ad5f57bdfbfd56bde694a627c342e/src%2Flibstd%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05999290e23ad5f57bdfbfd56bde694a627c342e/src%2Flibstd%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farena.rs?ref=05999290e23ad5f57bdfbfd56bde694a627c342e", "patch": "@@ -31,10 +31,6 @@ use libc::size_t;\n \n #[abi = \"rust-intrinsic\"]\n extern mod rusti {\n-    #[cfg(stage0)]\n-    fn move_val_init<T>(&dst: T, -src: T);\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     fn move_val_init<T>(dst: &mut T, -src: T);\n     fn needs_drop<T>() -> bool;\n }\n@@ -132,117 +128,6 @@ unsafe fn un_bitpack_tydesc_ptr(p: uint) -> (*TypeDesc, bool) {\n     (reinterpret_cast(&(p & !1)), p & 1 == 1)\n }\n \n-// tjc: Can get rid of the duplication post-snapshot\n-#[cfg(stage0)]\n-// The duplication between the POD and non-POD functions is annoying.\n-impl &Arena {\n-    // Functions for the POD part of the arena\n-    fn alloc_pod_grow(n_bytes: uint, align: uint) -> *u8 {\n-        // Allocate a new chunk.\n-        let chunk_size = at_vec::capacity(self.pod_head.data);\n-        let new_min_chunk_size = uint::max(n_bytes, chunk_size);\n-        self.chunks = @Cons(copy self.pod_head, self.chunks);\n-        self.pod_head =\n-            chunk(uint::next_power_of_two(new_min_chunk_size + 1u), true);\n-\n-        return self.alloc_pod_inner(n_bytes, align);\n-    }\n-\n-    #[inline(always)]\n-    fn alloc_pod_inner(n_bytes: uint, align: uint) -> *u8 {\n-        let head = &mut self.pod_head;\n-\n-        let start = round_up_to(head.fill, align);\n-        let end = start + n_bytes;\n-        if end > at_vec::capacity(head.data) {\n-            return self.alloc_pod_grow(n_bytes, align);\n-        }\n-        head.fill = end;\n-\n-        //debug!(\"idx = %u, size = %u, align = %u, fill = %u\",\n-        //       start, n_bytes, align, head.fill);\n-\n-        unsafe {\n-            ptr::offset(vec::raw::to_ptr(head.data), start)\n-        }\n-    }\n-\n-    #[inline(always)]\n-    fn alloc_pod<T>(op: fn() -> T) -> &self/T {\n-        unsafe {\n-            let tydesc = sys::get_type_desc::<T>();\n-            let ptr = self.alloc_pod_inner((*tydesc).size, (*tydesc).align);\n-            let ptr: *mut T = reinterpret_cast(&ptr);\n-            rusti::move_val_init(*ptr, op());\n-            return reinterpret_cast(&ptr);\n-        }\n-    }\n-\n-    // Functions for the non-POD part of the arena\n-    fn alloc_nonpod_grow(n_bytes: uint, align: uint) -> (*u8, *u8) {\n-        // Allocate a new chunk.\n-        let chunk_size = at_vec::capacity(self.head.data);\n-        let new_min_chunk_size = uint::max(n_bytes, chunk_size);\n-        self.chunks = @Cons(copy self.head, self.chunks);\n-        self.head =\n-            chunk(uint::next_power_of_two(new_min_chunk_size + 1u), false);\n-\n-        return self.alloc_nonpod_inner(n_bytes, align);\n-    }\n-\n-    #[inline(always)]\n-    fn alloc_nonpod_inner(n_bytes: uint, align: uint) -> (*u8, *u8) {\n-        let head = &mut self.head;\n-\n-        let tydesc_start = head.fill;\n-        let after_tydesc = head.fill + sys::size_of::<*TypeDesc>();\n-        let start = round_up_to(after_tydesc, align);\n-        let end = start + n_bytes;\n-        if end > at_vec::capacity(head.data) {\n-            return self.alloc_nonpod_grow(n_bytes, align);\n-        }\n-        head.fill = round_up_to(end, sys::pref_align_of::<*TypeDesc>());\n-\n-        //debug!(\"idx = %u, size = %u, align = %u, fill = %u\",\n-        //       start, n_bytes, align, head.fill);\n-\n-        unsafe {\n-            let buf = vec::raw::to_ptr(head.data);\n-            return (ptr::offset(buf, tydesc_start), ptr::offset(buf, start));\n-        }\n-    }\n-\n-    #[inline(always)]\n-    fn alloc_nonpod<T>(op: fn() -> T) -> &self/T {\n-        unsafe {\n-            let tydesc = sys::get_type_desc::<T>();\n-            let (ty_ptr, ptr) =\n-                self.alloc_nonpod_inner((*tydesc).size, (*tydesc).align);\n-            let ty_ptr: *mut uint = reinterpret_cast(&ty_ptr);\n-            let ptr: *mut T = reinterpret_cast(&ptr);\n-            // Write in our tydesc along with a bit indicating that it\n-            // has *not* been initialized yet.\n-            *ty_ptr = reinterpret_cast(&tydesc);\n-            // Actually initialize it\n-            rusti::move_val_init(*ptr, op());\n-            // Now that we are done, update the tydesc to indicate that\n-            // the object is there.\n-            *ty_ptr = bitpack_tydesc_ptr(tydesc, true);\n-\n-            return reinterpret_cast(&ptr);\n-        }\n-    }\n-\n-    // The external interface\n-    #[inline(always)]\n-    fn alloc<T>(op: fn() -> T) -> &self/T {\n-        if !rusti::needs_drop::<T>() {\n-            self.alloc_pod(op)\n-        } else { self.alloc_nonpod(op) }\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl &Arena {\n     // Functions for the POD part of the arena\n     fn alloc_pod_grow(n_bytes: uint, align: uint) -> *u8 {"}, {"sha": "65872a013aba8247aae88528600a5f62832e5a7a", "filename": "src/libstd/time.rs", "status": "modified", "additions": 4, "deletions": 29, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/05999290e23ad5f57bdfbfd56bde694a627c342e/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05999290e23ad5f57bdfbfd56bde694a627c342e/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=05999290e23ad5f57bdfbfd56bde694a627c342e", "patch": "@@ -8,24 +8,16 @@ use result::{Result, Ok, Err};\n #[abi = \"cdecl\"]\n extern mod rustrt {\n     #[legacy_exports]\n-    #[cfg(stage0)]\n-    fn get_time(&sec: i64, &nsec: i32);\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     fn get_time(sec: &mut i64, nsec: &mut i32);\n \n-    #[cfg(stage0)]\n-    fn precise_time_ns(&ns: u64);\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     fn precise_time_ns(ns: &mut u64);\n \n     fn rust_tzset();\n     // FIXME: The i64 values can be passed by-val when #2064 is fixed.\n     fn rust_gmtime(&&sec: i64, &&nsec: i32, &&result: Tm);\n     fn rust_localtime(&&sec: i64, &&nsec: i32, &&result: Tm);\n-    fn rust_timegm(&&tm: Tm, &sec: i64);\n-    fn rust_mktime(&&tm: Tm, &sec: i64);\n+    fn rust_timegm(&&tm: Tm, sec: &mut i64);\n+    fn rust_mktime(&&tm: Tm, sec: &mut i64);\n }\n \n /// A record specifying a time value in seconds and nanoseconds.\n@@ -42,15 +34,6 @@ impl Timespec : Eq {\n  * Returns the current time as a `timespec` containing the seconds and\n  * nanoseconds since 1970-01-01T00:00:00Z.\n  */\n-#[cfg(stage0)]\n-pub fn get_time() -> Timespec {\n-    let mut sec = 0i64;\n-    let mut nsec = 0i32;\n-    rustrt::get_time(sec, nsec);\n-    return {sec: sec, nsec: nsec};\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n pub fn get_time() -> Timespec {\n     let mut sec = 0i64;\n     let mut nsec = 0i32;\n@@ -63,14 +46,6 @@ pub fn get_time() -> Timespec {\n  * Returns the current value of a high-resolution performance counter\n  * in nanoseconds since an unspecified epoch.\n  */\n-#[cfg(stage0)]\n-pub fn precise_time_ns() -> u64 {\n-    let mut ns = 0u64;\n-    rustrt::precise_time_ns(ns);\n-    ns\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n pub fn precise_time_ns() -> u64 {\n     let mut ns = 0u64;\n     rustrt::precise_time_ns(&mut ns);\n@@ -790,9 +765,9 @@ impl Tm {\n     fn to_timespec() -> Timespec {\n         let mut sec = 0i64;\n         if self.tm_gmtoff == 0_i32 {\n-            rustrt::rust_timegm(self, sec);\n+            rustrt::rust_timegm(self, &mut sec);\n         } else {\n-            rustrt::rust_mktime(self, sec);\n+            rustrt::rust_mktime(self, &mut sec);\n         }\n         { sec: sec, nsec: self.tm_nsec }\n     }"}, {"sha": "6bee9190a832f41259e846a2d76578561b1b93a2", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/05999290e23ad5f57bdfbfd56bde694a627c342e/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05999290e23ad5f57bdfbfd56bde694a627c342e/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=05999290e23ad5f57bdfbfd56bde694a627c342e", "patch": "@@ -570,7 +570,8 @@ impl parser {\n \n     fn parse_arg_mode() -> mode {\n         if self.eat(token::BINOP(token::AND)) {\n-            self.warn(~\"Obsolete syntax has no effect\");\n+            self.span_fatal(copy self.last_span,\n+                            ~\"Obsolete syntax has no effect\");\n             expl(by_mutbl_ref)\n         } else if self.eat(token::BINOP(token::MINUS)) {\n             expl(by_move)"}]}