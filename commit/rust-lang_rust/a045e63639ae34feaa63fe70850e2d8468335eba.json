{"sha": "a045e63639ae34feaa63fe70850e2d8468335eba", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwNDVlNjM2MzlhZTM0ZmVhYTYzZmU3MDg1MGUyZDg0NjgzMzVlYmE=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2012-04-19T06:49:20Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-04-20T22:23:23Z"}, "message": "std: get_monitor_task_gl() is global_loop::get() default", "tree": {"sha": "05ba81ada993b552bfa800ce55deba699afed7b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05ba81ada993b552bfa800ce55deba699afed7b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a045e63639ae34feaa63fe70850e2d8468335eba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a045e63639ae34feaa63fe70850e2d8468335eba", "html_url": "https://github.com/rust-lang/rust/commit/a045e63639ae34feaa63fe70850e2d8468335eba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a045e63639ae34feaa63fe70850e2d8468335eba/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e15f1d5cad5d35cc640252377344dcdfbec04b22", "url": "https://api.github.com/repos/rust-lang/rust/commits/e15f1d5cad5d35cc640252377344dcdfbec04b22", "html_url": "https://github.com/rust-lang/rust/commit/e15f1d5cad5d35cc640252377344dcdfbec04b22"}], "stats": {"total": 130, "additions": 120, "deletions": 10}, "files": [{"sha": "e710ef1fc130646a9bdc0e887b1cbbf4d57fccee", "filename": "src/libstd/uv_global_loop.rs", "status": "modified", "additions": 103, "deletions": 4, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/a045e63639ae34feaa63fe70850e2d8468335eba/src%2Flibstd%2Fuv_global_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a045e63639ae34feaa63fe70850e2d8468335eba/src%2Flibstd%2Fuv_global_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_global_loop.rs?ref=a045e63639ae34feaa63fe70850e2d8468335eba", "patch": "@@ -1,15 +1,16 @@\n #[doc=\"\n-Process-wide, lazily started/stopped libuv event loop interaction.\n+A process-wide libuv event loop for library use.\n \"];\n \n import ll = uv_ll;\n import hl = uv_hl;\n import get_gl = get;\n \n-export get, get_single_task_gl;\n+export get, get_single_task_gl, get_monitor_task_gl;\n \n native mod rustrt {\n     fn rust_uv_get_kernel_global_chan_ptr() -> *libc::uintptr_t;\n+    fn rust_uv_get_kernel_monitor_global_chan_ptr() -> *libc::uintptr_t;\n     fn rust_uv_get_kernel_global_async_handle() -> *libc::uintptr_t;\n     fn rust_compare_and_swap_ptr(address: *libc::uintptr_t,\n                                  oldval: libc::uintptr_t,\n@@ -20,13 +21,34 @@ native mod rustrt {\n Race-free helper to get access to a global task where a libuv\n loop is running.\n \n+Use `uv::hl::interact`, `uv::hl::ref_handle` and `uv::hl::unref_handle` to\n+do operations against the global loop that this function returns.\n+\n # Return\n \n * A `hl::high_level_loop` that encapsulates communication with the global\n loop.\n \"]\n fn get() -> hl::high_level_loop {\n-    ret get_single_task_gl();\n+    ret get_monitor_task_gl();\n+}\n+\n+#[doc(hidden)]\n+fn get_monitor_task_gl() -> hl::high_level_loop {\n+    let monitor_loop_chan =\n+        rustrt::rust_uv_get_kernel_monitor_global_chan_ptr();\n+    ret spawn_global_weak_task(\n+        monitor_loop_chan,\n+        {|weak_exit_po, msg_po, loop_ptr, first_msg|\n+            log(debug, \"monitor gl: entering inner loop\");\n+            unsafe {\n+                monitor_task_loop_body(weak_exit_po, msg_po, loop_ptr,\n+                                       copy(first_msg))\n+            }\n+        },\n+        {|msg_ch|\n+            hl::monitor_task_loop({op_chan: msg_ch})\n+        });\n }\n \n #[doc(hidden)]\n@@ -35,7 +57,7 @@ fn get_single_task_gl() -> hl::high_level_loop {\n     ret spawn_global_weak_task(\n         global_loop_chan_ptr,\n         {|weak_exit_po, msg_po, loop_ptr, first_msg|\n-            log(debug, \"about to enter inner loop\");\n+            log(debug, \"single-task gl: about to enter inner loop\");\n             unsafe {\n                 single_task_loop_body(weak_exit_po, msg_po, loop_ptr,\n                                       copy(first_msg))\n@@ -135,6 +157,83 @@ unsafe fn outer_global_loop_body(\n \n     ll::loop_delete(loop_ptr);\n }\n+        \n+unsafe fn monitor_task_loop_body(weak_exit_po_in: comm::port<()>,\n+                          msg_po_in: comm::port<hl::high_level_msg>,\n+                          loop_ptr: *libc::c_void,\n+                          -first_interaction: hl::high_level_msg) -> bool {\n+    // resend the msg to be handled in the select2 loop below..\n+    comm::send(comm::chan(msg_po_in), first_interaction);\n+\n+    // our async_handle\n+    let async_handle_po = comm::port::<*ll::uv_async_t>();\n+    let async_handle_ch = comm::chan(async_handle_po);\n+\n+    // the msg_po that libuv will be receiving on..\n+    let loop_msg_po = comm::port::<hl::high_level_msg>();\n+    let loop_msg_po_ptr = ptr::addr_of(loop_msg_po);\n+    let loop_msg_ch = comm::chan(loop_msg_po);\n+\n+    // the question of whether unsupervising this will even do any\n+    // good is there.. but since this'll go into blocking in libuv with\n+    // a quickness.. any errors that occur (including inside crust) will\n+    // be segfaults.. so yeah.\n+    task::spawn_sched(task::manual_threads(1u)) {||\n+        let loop_msg_po_in = *loop_msg_po_ptr;\n+        hl::run_high_level_loop(\n+            loop_ptr,\n+            loop_msg_po_in, // here the loop gets handed a different message\n+                            // port, as we'll be receiving all of the messages\n+                            // initially and then passing them on..\n+            // before_run\n+            {|async_handle|\n+                log(debug,#fmt(\"monitor gl: before_run: async_handle %?\",\n+                              async_handle));\n+                // when this is ran, our async_handle is set up, so let's\n+                // do an async_send with it.. letting the loop know, once it\n+                // starts, that is has work\n+                ll::async_send(async_handle);\n+                comm::send(async_handle_ch, copy(async_handle));\n+            },\n+            // before_msg_drain\n+            {|async_handle|\n+                log(debug,#fmt(\"monitor gl: b4_msg_drain: async_handle %?\",\n+                              async_handle));\n+                true\n+            },\n+            // before_tear_down\n+            {|async_handle|\n+                log(debug,#fmt(\"monitor gl: b4_tear_down: async_handle %?\",\n+                              async_handle));\n+            });\n+    };\n+\n+    // our loop is set up, so let's emit the handle back out to our users..\n+    let async_handle = comm::recv(async_handle_po);\n+    // supposed to return a bool to indicate to the enclosing loop whether\n+    // it should continue or not..\n+    let mut continue_inner_loop = true;\n+    let mut didnt_get_hl_bailout = true;\n+    while continue_inner_loop {\n+        log(debug, \"monitor task inner loop.. about to block on select2\");\n+        continue_inner_loop = either::either(\n+            {|left_val|\n+                // bail out..\n+                log(debug, #fmt(\"monitor inner weak_exit_po recv'd msg: %?\",\n+                               left_val));\n+                // TODO: make loop bail out\n+                didnt_get_hl_bailout = false;\n+                false\n+            }, {|right_val|\n+                // wake up our inner loop and pass it a msg..\n+                comm::send(loop_msg_ch, copy(right_val));\n+                ll::async_send(async_handle);\n+                true\n+            }, comm::select2(weak_exit_po_in, msg_po_in)\n+        )\n+    }\n+    didnt_get_hl_bailout\n+}\n \n unsafe fn single_task_loop_body(weak_exit_po_in: comm::port<()>,\n                           msg_po_in: comm::port<hl::high_level_msg>,"}, {"sha": "7eaf52ad96f5a89586397f20ff33f74b1ed3c578", "filename": "src/libstd/uv_hl.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a045e63639ae34feaa63fe70850e2d8468335eba/src%2Flibstd%2Fuv_hl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a045e63639ae34feaa63fe70850e2d8468335eba/src%2Flibstd%2Fuv_hl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_hl.rs?ref=a045e63639ae34feaa63fe70850e2d8468335eba", "patch": "@@ -193,12 +193,17 @@ unsafe fn send_high_level_msg(hl_loop: high_level_loop,\n     // the loop isn't active, so we don't need to wake it up,\n     // (the loop's enclosing task should be blocking on a message\n     // receive on this port)\n-    if (*(hl_loop.async_handle()) != 0 as *ll::uv_async_t) {\n-        log(debug,\"global async handle != 0, waking up loop..\");\n-        ll::async_send(*(hl_loop.async_handle()));\n-    }\n-    else {\n-        log(debug,\"GLOBAL ASYNC handle == 0\");\n+    alt hl_loop {\n+      single_task_loop({async_handle, op_chan}) {\n+        if ((*async_handle) != 0 as *ll::uv_async_t) {\n+            log(debug,\"global async handle != 0, waking up loop..\");\n+            ll::async_send((*async_handle));\n+        }\n+        else {\n+            log(debug,\"GLOBAL ASYNC handle == 0\");\n+        }\n+      }\n+      _ {}\n     }\n }\n "}, {"sha": "199a1aeb55e9692e42d5cf241c86bc6cd64bd41a", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a045e63639ae34feaa63fe70850e2d8468335eba/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/a045e63639ae34feaa63fe70850e2d8468335eba/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=a045e63639ae34feaa63fe70850e2d8468335eba", "patch": "@@ -446,6 +446,11 @@ rust_uv_get_kernel_global_chan_ptr() {\n     return result;\n }\n \n+extern \"C\" uintptr_t*\n+rust_uv_get_kernel_monitor_global_chan_ptr() {\n+\treturn rust_uv_get_kernel_global_chan_ptr();\n+}\n+\n extern \"C\" uintptr_t*\n rust_uv_get_kernel_global_async_handle() {\n     return rust_get_current_task()->kernel->get_global_async_handle();"}, {"sha": "545c3581425e71227a598c85fc29b1cdb5298a6a", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a045e63639ae34feaa63fe70850e2d8468335eba/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/a045e63639ae34feaa63fe70850e2d8468335eba/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=a045e63639ae34feaa63fe70850e2d8468335eba", "patch": "@@ -138,6 +138,7 @@ rust_uv_set_data_for_req\n rust_uv_get_base_from_buf\n rust_uv_get_len_from_buf\n rust_uv_get_kernel_global_chan_ptr\n+rust_uv_get_kernel_monitor_global_chan_ptr\n rust_uv_get_kernel_global_async_handle\n rust_dbg_lock_create\n rust_dbg_lock_destroy"}]}