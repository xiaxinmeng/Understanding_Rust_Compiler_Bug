{"sha": "e34abbacf62cb1d35b761ea698b0afa0372aa642", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzNGFiYmFjZjYyY2IxZDM1Yjc2MWVhNjk4YjBhZmEwMzcyYWE2NDI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2011-12-21T04:12:52Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-01-03T21:13:51Z"}, "message": "minimal changes to permit fn blocks in expr", "tree": {"sha": "4df822c8c1abe127c22423719199c44893f5ca8b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4df822c8c1abe127c22423719199c44893f5ca8b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e34abbacf62cb1d35b761ea698b0afa0372aa642", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e34abbacf62cb1d35b761ea698b0afa0372aa642", "html_url": "https://github.com/rust-lang/rust/commit/e34abbacf62cb1d35b761ea698b0afa0372aa642", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e34abbacf62cb1d35b761ea698b0afa0372aa642/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "513a263e81eff098762e1531bc4d13366da0e554", "url": "https://api.github.com/repos/rust-lang/rust/commits/513a263e81eff098762e1531bc4d13366da0e554", "html_url": "https://github.com/rust-lang/rust/commit/513a263e81eff098762e1531bc4d13366da0e554"}], "stats": {"total": 132, "additions": 64, "deletions": 68}, "files": [{"sha": "ecdfe19e499a37f9ae76568891754c2967cb7872", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 64, "deletions": 68, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/e34abbacf62cb1d35b761ea698b0afa0372aa642/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e34abbacf62cb1d35b761ea698b0afa0372aa642/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=e34abbacf62cb1d35b761ea698b0afa0372aa642", "patch": "@@ -10,7 +10,12 @@ import util::interner;\n import ast::{node_id, spanned};\n import front::attr;\n \n-tag restriction { UNRESTRICTED; RESTRICT_NO_CALL_EXPRS; RESTRICT_NO_BAR_OP; }\n+tag restriction {\n+    UNRESTRICTED;\n+    RESTRICT_STMT_EXPR;\n+    RESTRICT_NO_CALL_EXPRS;\n+    RESTRICT_NO_BAR_OP;\n+}\n \n tag file_type { CRATE_FILE; SOURCE_FILE; }\n \n@@ -977,35 +982,54 @@ fn parse_syntax_ext_naked(p: parser, lo: uint) -> @ast::expr {\n \n fn parse_dot_or_call_expr(p: parser) -> @ast::expr {\n     let b = parse_bottom_expr(p);\n-    if expr_has_value(b) { parse_dot_or_call_expr_with(p, b) }\n-    else { b }\n+    parse_dot_or_call_expr_with(p, b)\n+}\n+\n+fn permits_call(p: parser) -> bool {\n+    ret p.get_restriction() != RESTRICT_NO_CALL_EXPRS;\n }\n \n fn parse_dot_or_call_expr_with(p: parser, e: @ast::expr) -> @ast::expr {\n     let lo = e.span.lo;\n     let hi = e.span.hi;\n     let e = e;\n-    while true {\n+    while !expr_is_complete(p, e) {\n         alt p.peek() {\n-          token::LPAREN. {\n-            if p.get_restriction() == RESTRICT_NO_CALL_EXPRS {\n-                ret e;\n-            } else {\n-                // Call expr.\n-                let es = parse_seq(token::LPAREN, token::RPAREN,\n-                                   seq_sep(token::COMMA), parse_expr, p);\n-                hi = es.span.hi;\n-                let nd = ast::expr_call(e, es.node, false);\n-                e = mk_expr(p, lo, hi, nd);\n+          // expr(...)\n+          token::LPAREN. when permits_call(p) {\n+            let es = parse_seq(token::LPAREN, token::RPAREN,\n+                               seq_sep(token::COMMA), parse_expr, p);\n+            hi = es.span.hi;\n+            let nd = ast::expr_call(e, es.node, false);\n+            e = mk_expr(p, lo, hi, nd);\n+          }\n+\n+          // expr { || ... }\n+          token::LBRACE. when is_bar(p.look_ahead(1u)) && permits_call(p) {\n+            p.bump();\n+            let blk = parse_fn_block_expr(p);\n+            alt e.node {\n+              ast::expr_call(f, args, false) {\n+                e = @{node: ast::expr_call(f, args + [blk], true)\n+                      with *e};\n+              }\n+              _ {\n+                e = mk_expr(p, lo, p.get_last_hi_pos(),\n+                            ast::expr_call(e, [blk], true));\n+              }\n             }\n           }\n+\n+          // expr[...]\n           token::LBRACKET. {\n             p.bump();\n             let ix = parse_expr(p);\n             hi = ix.span.hi;\n             expect(p, token::RBRACKET);\n             e = mk_expr(p, lo, hi, ast::expr_index(e, ix));\n           }\n+\n+          // expr.f\n           token::DOT. {\n             p.bump();\n             alt p.peek() {\n@@ -1022,6 +1046,7 @@ fn parse_dot_or_call_expr_with(p: parser, e: @ast::expr) -> @ast::expr {\n               t { unexpected(p, t); }\n             }\n           }\n+\n           _ { ret e; }\n         }\n     }\n@@ -1126,7 +1151,7 @@ const ternary_prec: int = 0;\n \n fn parse_more_binops(p: parser, lhs: @ast::expr, min_prec: int) ->\n    @ast::expr {\n-    if !expr_has_value(lhs) { ret lhs; }\n+    if expr_is_complete(p, lhs) { ret lhs; }\n     let peeked = p.peek();\n     if peeked == token::BINOP(token::OR) &&\n        p.get_restriction() == RESTRICT_NO_BAR_OP { ret lhs; }\n@@ -1550,61 +1575,40 @@ fn parse_stmt(p: parser) -> @ast::stmt {\n           }\n         }\n \n-        let maybe_item = parse_item(p, item_attrs);\n-\n-        // If we have attributes then we should have an item\n-        if vec::len(item_attrs) > 0u {\n-            alt maybe_item {\n-              some(_) {/* fallthrough */ }\n-              _ { ret p.fatal(\"expected item\"); }\n-            }\n-        }\n-\n-        alt maybe_item {\n+        alt parse_item(p, item_attrs) {\n           some(i) {\n             let hi = i.span.hi;\n             let decl = @spanned(lo, hi, ast::decl_item(i));\n             ret @spanned(lo, hi, ast::stmt_decl(decl, p.get_id()));\n           }\n-          none. {\n-            // Remainder are line-expr stmts.\n-            let e = parse_expr(p);\n-            // See if it is a block call\n-            if expr_has_value(e) && p.peek() == token::LBRACE &&\n-               is_bar(p.look_ahead(1u)) {\n-                p.bump();\n-                let blk = parse_fn_block_expr(p);\n-                alt e.node {\n-                  ast::expr_call(f, args, false) {\n-                    e = @{node: ast::expr_call(f, args + [blk], true)\n-                        with *e};\n-                  }\n-                  _ {\n-                    e = mk_expr(p, lo, p.get_last_hi_pos(),\n-                                ast::expr_call(e, [blk], true));\n-                  }\n-                }\n-            }\n-            ret @spanned(lo, e.span.hi, ast::stmt_expr(e, p.get_id()));\n-          }\n-          _ { p.fatal(\"expected statement\"); }\n+          none() { /* fallthrough */ }\n         }\n+\n+        // If we have attributes then we should have an item\n+        if vec::len(item_attrs) > 0u {\n+            ret p.fatal(\"expected item\");\n+        }\n+\n+        // Remainder are line-expr stmts.\n+        let e = parse_expr_res(p, RESTRICT_STMT_EXPR);\n+        ret @spanned(lo, e.span.hi, ast::stmt_expr(e, p.get_id()));\n     }\n }\n \n-fn expr_has_value(e: @ast::expr) -> bool {\n+fn expr_is_complete(p: parser, e: @ast::expr) -> bool {\n+    ret p.get_restriction() == RESTRICT_STMT_EXPR &&\n+        !expr_requires_semi_to_be_stmt(e);\n+}\n+\n+fn expr_requires_semi_to_be_stmt(e: @ast::expr) -> bool {\n     alt e.node {\n       ast::expr_if(_, th, els) | ast::expr_if_check(_, th, els) {\n         if option::is_none(els) { false }\n         else { !option::is_none(th.node.expr) ||\n-            expr_has_value(option::get(els)) }\n+                  expr_requires_semi_to_be_stmt(option::get(els)) }\n       }\n       ast::expr_alt(_, arms) {\n-        let found_expr = false;\n-        for arm in arms {\n-            if !option::is_none(arm.body.node.expr) { found_expr = true; }\n-        }\n-        found_expr\n+        vec::any({|arm| !option::is_none(arm.body.node.expr)}, arms)\n       }\n       ast::expr_block(blk) | ast::expr_while(_, blk) |\n       ast::expr_for(_, _, blk) | ast::expr_do_while(blk, _) {\n@@ -1615,19 +1619,11 @@ fn expr_has_value(e: @ast::expr) -> bool {\n     }\n }\n \n-fn stmt_is_expr(stmt: @ast::stmt) -> bool {\n-    ret alt stmt.node {\n-      ast::stmt_expr(e, _) { expr_has_value(e) }\n-      _ { false }\n-    };\n-}\n-\n fn stmt_to_expr(stmt: @ast::stmt) -> option::t<@ast::expr> {\n-    ret if stmt_is_expr(stmt) {\n-        alt stmt.node {\n-          ast::stmt_expr(e, _) { some(e) }\n-        }\n-    } else { none };\n+    alt stmt.node {\n+      ast::stmt_expr(e, _) { some(e) }\n+      ast::stmt_decl(_, _) { none }\n+    }\n }\n \n fn stmt_ends_with_semi(stmt: ast::stmt) -> bool {\n@@ -1639,7 +1635,7 @@ fn stmt_ends_with_semi(stmt: ast::stmt) -> bool {\n             }\n       }\n       ast::stmt_expr(e, _) {\n-        ret expr_has_value(e);\n+        ret expr_requires_semi_to_be_stmt(e);\n       }\n     }\n }"}]}