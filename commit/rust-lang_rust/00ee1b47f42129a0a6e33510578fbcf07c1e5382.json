{"sha": "00ee1b47f42129a0a6e33510578fbcf07c1e5382", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwZWUxYjQ3ZjQyMTI5YTBhNmUzMzUxMDU3OGZiY2YwN2MxZTUzODI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-11T19:19:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-11T19:19:33Z"}, "message": "Auto merge of #63471 - Mark-Simulacrum:rollup-m756lnx, r=Mark-Simulacrum\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #61969 (Add #[repr(transparent)] for several types)\n - #63346 (Lint on some incorrect uses of mem::zeroed / mem::uninitialized)\n - #63433 (Miri shouldn't look at types)\n - #63440 (rename RUST_CTFE_BACKTRACE to RUSTC_CTFE_BACKTRACE)\n - #63441 (Derive Debug for CrateInfo)\n - #63442 (Add an example to show how to insert item to a sorted vec)\n - #63453 (rustdoc: general cleanup)\n - #63464 (Copy ty::Instance instead of passing by reference)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "a0e1a3e4c92814f3487c1df5d13af152f1d496dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a0e1a3e4c92814f3487c1df5d13af152f1d496dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/00ee1b47f42129a0a6e33510578fbcf07c1e5382", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/00ee1b47f42129a0a6e33510578fbcf07c1e5382", "html_url": "https://github.com/rust-lang/rust/commit/00ee1b47f42129a0a6e33510578fbcf07c1e5382", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/00ee1b47f42129a0a6e33510578fbcf07c1e5382/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a068699a24de306334a1f66b9a83552766d853c", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a068699a24de306334a1f66b9a83552766d853c", "html_url": "https://github.com/rust-lang/rust/commit/8a068699a24de306334a1f66b9a83552766d853c"}, {"sha": "4229dc3538bbf473ab142fd708bc3ebbebb7bc1f", "url": "https://api.github.com/repos/rust-lang/rust/commits/4229dc3538bbf473ab142fd708bc3ebbebb7bc1f", "html_url": "https://github.com/rust-lang/rust/commit/4229dc3538bbf473ab142fd708bc3ebbebb7bc1f"}], "stats": {"total": 1182, "additions": 795, "deletions": 387}, "files": [{"sha": "ab6731e4d433d583bcfa0c7dccbeff6c631216bf", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/00ee1b47f42129a0a6e33510578fbcf07c1e5382/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/00ee1b47f42129a0a6e33510578fbcf07c1e5382/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=00ee1b47f42129a0a6e33510578fbcf07c1e5382", "patch": "@@ -3252,7 +3252,6 @@ name = \"rustdoc\"\n version = \"0.0.0\"\n dependencies = [\n  \"minifier 0.0.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"parking_lot 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pulldown-cmark 0.5.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-rayon 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"tempfile 3.0.5 (registry+https://github.com/rust-lang/crates.io-index)\","}, {"sha": "1bbea02e0c7c984b8a6d3a12c031368f01c6cd17", "filename": "src/libcore/mem/maybe_uninit.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs?ref=00ee1b47f42129a0a6e33510578fbcf07c1e5382", "patch": "@@ -13,6 +13,7 @@ use crate::mem::ManuallyDrop;\n /// ever gets used to access memory:\n ///\n /// ```rust,no_run\n+/// # #![allow(invalid_value)]\n /// use std::mem::{self, MaybeUninit};\n ///\n /// let x: &i32 = unsafe { mem::zeroed() }; // undefined behavior!\n@@ -27,6 +28,7 @@ use crate::mem::ManuallyDrop;\n /// always be `true` or `false`. Hence, creating an uninitialized `bool` is undefined behavior:\n ///\n /// ```rust,no_run\n+/// # #![allow(invalid_value)]\n /// use std::mem::{self, MaybeUninit};\n ///\n /// let b: bool = unsafe { mem::uninitialized() }; // undefined behavior!\n@@ -40,6 +42,7 @@ use crate::mem::ManuallyDrop;\n /// which otherwise can hold any *fixed* bit pattern:\n ///\n /// ```rust,no_run\n+/// # #![allow(invalid_value)]\n /// use std::mem::{self, MaybeUninit};\n ///\n /// let x: i32 = unsafe { mem::uninitialized() }; // undefined behavior!"}, {"sha": "2534400b8334f43915ad5e7e019a84d477d2d67a", "filename": "src/libcore/mem/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibcore%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibcore%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmod.rs?ref=00ee1b47f42129a0a6e33510578fbcf07c1e5382", "patch": "@@ -445,7 +445,8 @@ pub const fn needs_drop<T>() -> bool {\n ///\n /// *Incorrect* usage of this function: initializing a reference with zero.\n ///\n-/// ```no_run\n+/// ```rust,no_run\n+/// # #![allow(invalid_value)]\n /// use std::mem;\n ///\n /// let _x: &i32 = unsafe { mem::zeroed() }; // Undefined behavior!"}, {"sha": "ce5af13d4ca90d4b8552fcd89cbe4033187ac48d", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=00ee1b47f42129a0a6e33510578fbcf07c1e5382", "patch": "@@ -1364,6 +1364,17 @@ impl<T> [T] {\n     /// let r = s.binary_search(&1);\n     /// assert!(match r { Ok(1..=4) => true, _ => false, });\n     /// ```\n+    ///\n+    /// If you want to insert an item to a sorted vector, while maintaining\n+    /// sort order:\n+    ///\n+    /// ```\n+    /// let mut s = vec![0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n+    /// let num = 42;\n+    /// let idx = s.binary_search(&num).unwrap_or_else(|x| x);\n+    /// s.insert(idx, num);\n+    /// assert_eq!(s, [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 42, 55]);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn binary_search(&self, x: &T) -> Result<usize, usize>\n         where T: Ord"}, {"sha": "d37b2367ae77e45def26db8fbf73118567a33432", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=00ee1b47f42129a0a6e33510578fbcf07c1e5382", "patch": "@@ -87,7 +87,7 @@ pub enum LinkagePreference {\n     RequireStatic,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash,\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash,\n          RustcEncodable, RustcDecodable, HashStable)]\n pub enum NativeLibraryKind {\n     /// native static library (.a archive)\n@@ -100,7 +100,7 @@ pub enum NativeLibraryKind {\n     NativeUnknown,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct NativeLibrary {\n     pub kind: NativeLibraryKind,\n     pub name: Option<Symbol>,"}, {"sha": "ef0e205184871403d36f00f849674b201f2ca6a4", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=00ee1b47f42129a0a6e33510578fbcf07c1e5382", "patch": "@@ -217,7 +217,7 @@ fn print_backtrace(backtrace: &mut Backtrace) {\n \n impl<'tcx> From<InterpError<'tcx>> for InterpErrorInfo<'tcx> {\n     fn from(kind: InterpError<'tcx>) -> Self {\n-        let backtrace = match env::var(\"RUST_CTFE_BACKTRACE\") {\n+        let backtrace = match env::var(\"RUSTC_CTFE_BACKTRACE\") {\n             // Matching `RUST_BACKTRACE` -- we treat \"0\" the same as \"not present\".\n             Ok(ref val) if val != \"0\" => {\n                 let mut backtrace = Backtrace::new_unresolved();"}, {"sha": "19c753bc30436e822d3e2931dda6ea32cd5c5478", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=00ee1b47f42129a0a6e33510578fbcf07c1e5382", "patch": "@@ -2518,7 +2518,7 @@ where\n         + HasTyCtxt<'tcx>\n         + HasParamEnv<'tcx>,\n {\n-    fn of_instance(cx: &C, instance: &ty::Instance<'tcx>) -> Self;\n+    fn of_instance(cx: &C, instance: ty::Instance<'tcx>) -> Self;\n     fn new(cx: &C, sig: ty::FnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> Self;\n     fn new_vtable(cx: &C, sig: ty::FnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> Self;\n     fn new_internal(\n@@ -2538,7 +2538,7 @@ where\n         + HasTyCtxt<'tcx>\n         + HasParamEnv<'tcx>,\n {\n-    fn of_instance(cx: &C, instance: &ty::Instance<'tcx>) -> Self {\n+    fn of_instance(cx: &C, instance: ty::Instance<'tcx>) -> Self {\n         let sig = instance.fn_sig(cx.tcx());\n         let sig = cx\n             .tcx()"}, {"sha": "9d563e290de966f78e9e0a084fc59d40e1f585c1", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=00ee1b47f42129a0a6e33510578fbcf07c1e5382", "patch": "@@ -1842,7 +1842,8 @@ pub struct VariantDef {\n     pub ctor_kind: CtorKind,\n     /// Flags of the variant (e.g. is field list non-exhaustive)?\n     flags: VariantFlags,\n-    /// Recovered?\n+    /// Variant is obtained as part of recovering from a syntactic error.\n+    /// May be incomplete or bogus.\n     pub recovered: bool,\n }\n \n@@ -1949,7 +1950,7 @@ pub struct FieldDef {\n pub struct AdtDef {\n     /// `DefId` of the struct, enum or union item.\n     pub did: DefId,\n-    /// Variants of the ADT. If this is a struct or enum, then there will be a single variant.\n+    /// Variants of the ADT. If this is a struct or union, then there will be a single variant.\n     pub variants: IndexVec<self::layout::VariantIdx, VariantDef>,\n     /// Flags of the ADT (e.g. is this a struct? is this non-exhaustive?)\n     flags: AdtFlags,\n@@ -2565,6 +2566,8 @@ impl<'tcx> AdtDef {\n }\n \n impl<'tcx> FieldDef {\n+    /// Returns the type of this field. The `subst` is typically obtained\n+    /// via the second field of `TyKind::AdtDef`.\n     pub fn ty(&self, tcx: TyCtxt<'tcx>, subst: SubstsRef<'tcx>) -> Ty<'tcx> {\n         tcx.type_of(self.did).subst(tcx, subst)\n     }"}, {"sha": "129ea9b5b674a8737a701c8239d8538e1f7aecc2", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=00ee1b47f42129a0a6e33510578fbcf07c1e5382", "patch": "@@ -171,6 +171,7 @@ pub enum TyKind<'tcx> {\n     Never,\n \n     /// A tuple type. For example, `(i32, bool)`.\n+    /// Use `TyS::tuple_fields` to iterate over the field types.\n     Tuple(SubstsRef<'tcx>),\n \n     /// The projection of an associated type. For example,\n@@ -1723,8 +1724,8 @@ impl<'tcx> TyS<'tcx> {\n                     })\n                 })\n             }\n-            ty::Tuple(tys) => tys.iter().any(|ty| {\n-                ty.expect_ty().conservative_is_privately_uninhabited(tcx)\n+            ty::Tuple(..) => self.tuple_fields().any(|ty| {\n+                ty.conservative_is_privately_uninhabited(tcx)\n             }),\n             ty::Array(ty, len) => {\n                 match len.try_eval_usize(tcx, ParamEnv::empty()) {\n@@ -2103,6 +2104,15 @@ impl<'tcx> TyS<'tcx> {\n         }\n     }\n \n+    /// Iterates over tuple fields.\n+    /// Panics when called on anything but a tuple.\n+    pub fn tuple_fields(&self) -> impl DoubleEndedIterator<Item=Ty<'tcx>> {\n+        match self.sty {\n+            Tuple(substs) => substs.iter().map(|field| field.expect_ty()),\n+            _ => bug!(\"tuple_fields called on non-tuple\"),\n+        }\n+    }\n+\n     /// If the type contains variants, returns the valid range of variant indices.\n     /// FIXME This requires the optimized MIR in the case of generators.\n     #[inline]"}, {"sha": "96e16efd1300af0a144ab9a10681cfe13cbe2b4a", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=00ee1b47f42129a0a6e33510578fbcf07c1e5382", "patch": "@@ -845,15 +845,15 @@ impl<'tcx> ty::TyS<'tcx> {\n             ty: Ty<'tcx>,\n         ) -> Representability {\n             match ty.sty {\n-                Tuple(ref ts) => {\n+                Tuple(..) => {\n                     // Find non representable\n-                    fold_repr(ts.iter().map(|ty| {\n+                    fold_repr(ty.tuple_fields().map(|ty| {\n                         is_type_structurally_recursive(\n                             tcx,\n                             sp,\n                             seen,\n                             representable_cache,\n-                            ty.expect_ty(),\n+                            ty,\n                         )\n                     }))\n                 }\n@@ -1095,7 +1095,7 @@ fn needs_drop_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>\n         // state transformation pass\n         ty::Generator(..) => true,\n \n-        ty::Tuple(ref tys) => tys.iter().map(|k| k.expect_ty()).any(needs_drop),\n+        ty::Tuple(..) => ty.tuple_fields().any(needs_drop),\n \n         // unions don't have destructors because of the child types,\n         // only if they manually implement `Drop` (handled above)."}, {"sha": "8c3110792a8b4152b3b64314ee0c78fcaf161dce", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=00ee1b47f42129a0a6e33510578fbcf07c1e5382", "patch": "@@ -119,8 +119,8 @@ fn push_subtypes<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent_ty: Ty<'tcx>) {\n         ty::GeneratorWitness(ts) => {\n             stack.extend(ts.skip_binder().iter().cloned().rev());\n         }\n-        ty::Tuple(ts) => {\n-            stack.extend(ts.iter().map(|k| k.expect_ty()).rev());\n+        ty::Tuple(..) => {\n+            stack.extend(parent_ty.tuple_fields().rev());\n         }\n         ty::FnDef(_, substs) => {\n             stack.extend(substs.types().rev());"}, {"sha": "68640abb0433eb9dcb8086ff4e22f2d3881045ff", "filename": "src/librustc_codegen_ssa/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustc_codegen_ssa%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustc_codegen_ssa%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Flib.rs?ref=00ee1b47f42129a0a6e33510578fbcf07c1e5382", "patch": "@@ -128,6 +128,7 @@ bitflags::bitflags! {\n }\n \n /// Misc info we load from metadata to persist beyond the tcx.\n+#[derive(Debug)]\n pub struct CrateInfo {\n     pub panic_runtime: Option<CrateNum>,\n     pub compiler_builtins: Option<CrateNum>,"}, {"sha": "ce98979cc0c641a7b99071c112db9ac2dadde557", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=00ee1b47f42129a0a6e33510578fbcf07c1e5382", "patch": "@@ -337,7 +337,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n             _ => {\n                 (bx.get_fn(drop_fn),\n-                 FnType::of_instance(&bx, &drop_fn))\n+                 FnType::of_instance(&bx, drop_fn))\n             }\n         };\n         helper.do_call(self, &mut bx, fn_ty, drop_fn, args,\n@@ -435,7 +435,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         // Obtain the panic entry point.\n         let def_id = common::langcall(bx.tcx(), Some(span), \"\", lang_item);\n         let instance = ty::Instance::mono(bx.tcx(), def_id);\n-        let fn_ty = FnType::of_instance(&bx, &instance);\n+        let fn_ty = FnType::of_instance(&bx, instance);\n         let llfn = bx.get_fn(instance);\n \n         // Codegen the actual panic invoke/call.\n@@ -552,7 +552,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let def_id =\n                     common::langcall(bx.tcx(), Some(span), \"\", lang_items::PanicFnLangItem);\n                 let instance = ty::Instance::mono(bx.tcx(), def_id);\n-                let fn_ty = FnType::of_instance(&bx, &instance);\n+                let fn_ty = FnType::of_instance(&bx, instance);\n                 let llfn = bx.get_fn(instance);\n \n                 // Codegen the actual panic invoke/call."}, {"sha": "13ec27aa1ab3f67ccd67b85a50f05210eb581859", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 90, "deletions": 1, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=00ee1b47f42129a0a6e33510578fbcf07c1e5382", "patch": "@@ -23,7 +23,7 @@\n \n use rustc::hir::def::{Res, DefKind};\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::{self, Ty, TyCtxt, layout::VariantIdx};\n use rustc::{lint, util};\n use hir::Node;\n use util::nodemap::HirIdSet;\n@@ -1862,3 +1862,92 @@ impl EarlyLintPass for IncompleteFeatures {\n             });\n     }\n }\n+\n+declare_lint! {\n+    pub INVALID_VALUE,\n+    Warn,\n+    \"an invalid value is being created (such as a NULL reference)\"\n+}\n+\n+declare_lint_pass!(InvalidValue => [INVALID_VALUE]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &hir::Expr) {\n+\n+        const ZEROED_PATH: &[Symbol] = &[sym::core, sym::mem, sym::zeroed];\n+        const UININIT_PATH: &[Symbol] = &[sym::core, sym::mem, sym::uninitialized];\n+\n+        /// Return `false` only if we are sure this type does *not*\n+        /// allow zero initialization.\n+        fn ty_maybe_allows_zero_init<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n+            use rustc::ty::TyKind::*;\n+            match ty.sty {\n+                // Primitive types that don't like 0 as a value.\n+                Ref(..) | FnPtr(..) | Never => false,\n+                Adt(..) if ty.is_box() => false,\n+                // Recurse for some compound types.\n+                Adt(adt_def, substs) if !adt_def.is_union() => {\n+                    match adt_def.variants.len() {\n+                        0 => false, // Uninhabited enum!\n+                        1 => {\n+                            // Struct, or enum with exactly one variant.\n+                            // Proceed recursively, check all fields.\n+                            let variant = &adt_def.variants[VariantIdx::from_u32(0)];\n+                            variant.fields.iter().all(|field| {\n+                                ty_maybe_allows_zero_init(\n+                                    tcx,\n+                                    field.ty(tcx, substs),\n+                                )\n+                            })\n+                        }\n+                        _ => true, // Conservative fallback for multi-variant enum.\n+                    }\n+                }\n+                Tuple(..) => {\n+                    // Proceed recursively, check all fields.\n+                    ty.tuple_fields().all(|field| ty_maybe_allows_zero_init(tcx, field))\n+                }\n+                // FIXME: Would be nice to also warn for `NonNull`/`NonZero*`.\n+                // FIXME: *Only for `mem::uninitialized`*, we could also warn for `bool`,\n+                //        `char`, and any multivariant enum.\n+                // Conservative fallback.\n+                _ => true,\n+            }\n+        }\n+\n+        if let hir::ExprKind::Call(ref path_expr, ref _args) = expr.node {\n+            if let hir::ExprKind::Path(ref qpath) = path_expr.node {\n+                if let Some(def_id) = cx.tables.qpath_res(qpath, path_expr.hir_id).opt_def_id() {\n+                    if cx.match_def_path(def_id, &ZEROED_PATH) ||\n+                        cx.match_def_path(def_id, &UININIT_PATH)\n+                    {\n+                        // This conjures an instance of a type out of nothing,\n+                        // using zeroed or uninitialized memory.\n+                        // We are extremely conservative with what we warn about.\n+                        let conjured_ty = cx.tables.expr_ty(expr);\n+\n+                        if !ty_maybe_allows_zero_init(cx.tcx, conjured_ty) {\n+                            cx.struct_span_lint(\n+                                INVALID_VALUE,\n+                                expr.span,\n+                                &format!(\n+                                    \"the type `{}` does not permit {}\",\n+                                    conjured_ty,\n+                                    if cx.match_def_path(def_id, &ZEROED_PATH) {\n+                                        \"zero-initialization\"\n+                                    } else {\n+                                        \"being left uninitialized\"\n+                                    }\n+                                ),\n+                            )\n+                            .note(\"this means that this code causes undefined behavior \\\n+                                when executed\")\n+                            .help(\"use `MaybeUninit` instead\")\n+                            .emit();\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "3a540fdf4b91f80c292478e22f03ccfa80cfba6f", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=00ee1b47f42129a0a6e33510578fbcf07c1e5382", "patch": "@@ -177,6 +177,7 @@ macro_rules! late_lint_mod_passes {\n             UnreachablePub: UnreachablePub,\n \n             ExplicitOutlivesRequirements: ExplicitOutlivesRequirements,\n+            InvalidValue: InvalidValue,\n         ]);\n     )\n }"}, {"sha": "6f4227ed34cc425adf44effc31669c81098b541b", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=00ee1b47f42129a0a6e33510578fbcf07c1e5382", "patch": "@@ -385,15 +385,19 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         local: mir::Local,\n         layout: Option<TyLayout<'tcx>>,\n     ) -> InterpResult<'tcx, TyLayout<'tcx>> {\n-        match frame.locals[local].layout.get() {\n+        // `const_prop` runs into this with an invalid (empty) frame, so we\n+        // have to support that case (mostly by skipping all caching).\n+        match frame.locals.get(local).and_then(|state| state.layout.get()) {\n             None => {\n                 let layout = crate::interpret::operand::from_known_layout(layout, || {\n                     let local_ty = frame.body.local_decls[local].ty;\n                     let local_ty = self.monomorphize_with_substs(local_ty, frame.instance.substs)?;\n                     self.layout_of(local_ty)\n                 })?;\n-                // Layouts of locals are requested a lot, so we cache them.\n-                frame.locals[local].layout.set(Some(layout));\n+                if let Some(state) = frame.locals.get(local) {\n+                    // Layouts of locals are requested a lot, so we cache them.\n+                    state.layout.set(Some(layout));\n+                }\n                 Ok(layout)\n             }\n             Some(layout) => Ok(layout),"}, {"sha": "47289064f4d0d576a3a22e24c628d62edf6a2899", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=00ee1b47f42129a0a6e33510578fbcf07c1e5382", "patch": "@@ -304,7 +304,7 @@ impl_stable_hash_for!(enum crate::interpret::eval_context::StackPopCleanup {\n \n #[derive(Eq, PartialEq)]\n struct FrameSnapshot<'a, 'tcx> {\n-    instance: &'a ty::Instance<'tcx>,\n+    instance: ty::Instance<'tcx>,\n     span: Span,\n     return_to_block: &'a StackPopCleanup,\n     return_place: Option<Place<(), AllocIdSnapshot<'a>>>,\n@@ -344,7 +344,7 @@ impl<'a, 'mir, 'tcx, Ctx> Snapshot<'a, Ctx> for &'a Frame<'mir, 'tcx>\n         } = self;\n \n         FrameSnapshot {\n-            instance,\n+            instance: *instance,\n             span: *span,\n             return_to_block,\n             block,"}, {"sha": "1d6b48e9da4c4e38d9813defeb91075b41b19227", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=00ee1b47f42129a0a6e33510578fbcf07c1e5382", "patch": "@@ -405,9 +405,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         }\n                     } else {\n                         let local = mir::RETURN_PLACE;\n-                        let ty = self.frame().body.local_decls[local].ty;\n-                        if !self.tcx.is_ty_uninhabited_from_any_module(ty) {\n-                            throw_unsup!(FunctionRetMismatch(self.tcx.types.never, ty))\n+                        let callee_layout = self.layout_of_local(self.frame(), local, None)?;\n+                        if !callee_layout.abi.is_uninhabited() {\n+                            throw_unsup!(FunctionRetMismatch(\n+                                self.tcx.types.never, callee_layout.ty\n+                            ))\n                         }\n                     }\n                     Ok(())"}, {"sha": "33447eba7492a03418ac96b55db9e826f6acd9f6", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=00ee1b47f42129a0a6e33510578fbcf07c1e5382", "patch": "@@ -324,7 +324,7 @@ fn build_clone_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, self_ty: Ty<'tcx>) -\n                 substs.upvar_tys(def_id, tcx)\n             )\n         }\n-        ty::Tuple(tys) => builder.tuple_like_shim(dest, src, tys.iter().map(|k| k.expect_ty())),\n+        ty::Tuple(..) => builder.tuple_like_shim(dest, src, self_ty.tuple_fields()),\n         _ => {\n             bug!(\"clone shim for `{:?}` which is not `Copy` and is not an aggregate\", self_ty)\n         }"}, {"sha": "52fd645e38e2248421ecad3ca54f5efde6b6d2bb", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=00ee1b47f42129a0a6e33510578fbcf07c1e5382", "patch": "@@ -804,8 +804,8 @@ where\n                 let tys : Vec<_> = substs.upvar_tys(def_id, self.tcx()).collect();\n                 self.open_drop_for_tuple(&tys)\n             }\n-            ty::Tuple(tys) => {\n-                let tys: Vec<_> = tys.iter().map(|k| k.expect_ty()).collect();\n+            ty::Tuple(..) => {\n+                let tys: Vec<_> = ty.tuple_fields().collect();\n                 self.open_drop_for_tuple(&tys)\n             }\n             ty::Adt(def, substs) => {"}, {"sha": "0eb8b73016d1048493b682d6b33f86cee31ed05f", "filename": "src/librustdoc/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustdoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustdoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2FCargo.toml?ref=00ee1b47f42129a0a6e33510578fbcf07c1e5382", "patch": "@@ -13,4 +13,3 @@ pulldown-cmark = { version = \"0.5.3\", default-features = false }\n minifier = \"0.0.33\"\n rayon = { version = \"0.2.0\", package = \"rustc-rayon\" }\n tempfile = \"3\"\n-parking_lot = \"0.7\""}, {"sha": "490d4107c51abf325cb65d0212b663d3a68f7008", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=00ee1b47f42129a0a6e33510578fbcf07c1e5382", "patch": "@@ -3,6 +3,7 @@ use rustc::traits;\n use rustc::ty::ToPredicate;\n use rustc::ty::subst::Subst;\n use rustc::infer::InferOk;\n+use rustc::hir::def_id::LOCAL_CRATE;\n use syntax_pos::DUMMY_SP;\n \n use super::*;\n@@ -27,7 +28,7 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n \n         debug!(\"get_blanket_impls({:?})\", ty);\n         let mut impls = Vec::new();\n-        for &trait_def_id in self.cx.all_traits.iter() {\n+        for &trait_def_id in self.cx.tcx.all_traits(LOCAL_CRATE).iter() {\n             if !self.cx.renderinfo.borrow().access_levels.is_public(trait_def_id) ||\n                self.cx.generated_synthetics\n                       .borrow_mut()"}, {"sha": "6f93c95edef08713d5a625ac8b3a1a46b576e455", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=00ee1b47f42129a0a6e33510578fbcf07c1e5382", "patch": "@@ -163,10 +163,7 @@ pub fn load_attrs<'hir>(cx: &DocContext<'hir>, did: DefId) -> Attrs<'hir> {\n /// These names are used later on by HTML rendering to generate things like\n /// source links back to the original item.\n pub fn record_extern_fqn(cx: &DocContext<'_>, did: DefId, kind: clean::TypeKind) {\n-    let mut crate_name = cx.tcx.crate_name(did.krate).to_string();\n-    if did.is_local() {\n-        crate_name = cx.crate_name.clone().unwrap_or(crate_name);\n-    }\n+    let crate_name = cx.tcx.crate_name(did.krate).to_string();\n \n     let relative = cx.tcx.def_path(did).data.into_iter().filter_map(|elem| {\n         // extern blocks have an empty name\n@@ -577,22 +574,18 @@ pub fn record_extern_trait(cx: &DocContext<'_>, did: DefId) {\n     }\n \n     {\n-        let external_traits = cx.external_traits.lock();\n-        if external_traits.borrow().contains_key(&did) ||\n+        if cx.external_traits.borrow().contains_key(&did) ||\n             cx.active_extern_traits.borrow().contains(&did)\n         {\n             return;\n         }\n     }\n \n-    cx.active_extern_traits.borrow_mut().push(did);\n+    cx.active_extern_traits.borrow_mut().insert(did);\n \n     debug!(\"record_extern_trait: {:?}\", did);\n     let trait_ = build_external_trait(cx, did);\n \n-    {\n-        let external_traits = cx.external_traits.lock();\n-        external_traits.borrow_mut().insert(did, trait_);\n-    }\n-    cx.active_extern_traits.borrow_mut().remove_item(&did);\n+    cx.external_traits.borrow_mut().insert(did, trait_);\n+    cx.active_extern_traits.borrow_mut().remove(&did);\n }"}, {"sha": "b281505956d6ab3a807377b310da379ad76b972b", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 4, "deletions": 22, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=00ee1b47f42129a0a6e33510578fbcf07c1e5382", "patch": "@@ -39,14 +39,12 @@ use std::fmt;\n use std::hash::{Hash, Hasher};\n use std::default::Default;\n use std::{mem, slice, vec};\n-use std::iter::{FromIterator, once};\n+use std::iter::FromIterator;\n use std::rc::Rc;\n use std::cell::RefCell;\n use std::sync::Arc;\n use std::u32;\n \n-use parking_lot::ReentrantMutex;\n-\n use crate::core::{self, DocContext};\n use crate::doctree;\n use crate::html::render::{cache, ExternalLocation};\n@@ -133,8 +131,9 @@ pub struct Crate {\n     pub primitives: Vec<(DefId, PrimitiveType, Attributes)>,\n     // These are later on moved into `CACHEKEY`, leaving the map empty.\n     // Only here so that they can be filtered through the rustdoc passes.\n-    pub external_traits: Arc<ReentrantMutex<RefCell<FxHashMap<DefId, Trait>>>>,\n+    pub external_traits: Rc<RefCell<FxHashMap<DefId, Trait>>>,\n     pub masked_crates: FxHashSet<CrateNum>,\n+    pub collapsed: bool,\n }\n \n impl Clean<Crate> for hir::Crate {\n@@ -223,6 +222,7 @@ impl Clean<Crate> for hir::Crate {\n             primitives,\n             external_traits: cx.external_traits.clone(),\n             masked_crates,\n+            collapsed: false,\n         }\n     }\n }\n@@ -4398,24 +4398,6 @@ impl Clean<TypeBindingKind> for hir::TypeBindingKind {\n     }\n }\n \n-pub fn def_id_to_path(\n-    cx: &DocContext<'_>,\n-    did: DefId,\n-    name: Option<String>\n-) -> Vec<String> {\n-    let crate_name = name.unwrap_or_else(|| cx.tcx.crate_name(did.krate).to_string());\n-    let relative = cx.tcx.def_path(did).data.into_iter().filter_map(|elem| {\n-        // extern blocks have an empty name\n-        let s = elem.data.to_string();\n-        if !s.is_empty() {\n-            Some(s)\n-        } else {\n-            None\n-        }\n-    });\n-    once(crate_name).chain(relative).collect()\n-}\n-\n pub fn enter_impl_trait<F, R>(cx: &DocContext<'_>, f: F) -> R\n where\n     F: FnOnce() -> R,"}, {"sha": "98ab957ecbb38078a3b5fea1af8d3e21c9d03235", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=00ee1b47f42129a0a6e33510578fbcf07c1e5382", "patch": "@@ -220,22 +220,22 @@ impl Options {\n                 println!(\"{:>20} - {}\", pass.name, pass.description);\n             }\n             println!(\"\\nDefault passes for rustdoc:\");\n-            for &name in passes::DEFAULT_PASSES {\n-                println!(\"{:>20}\", name);\n+            for pass in passes::DEFAULT_PASSES {\n+                println!(\"{:>20}\", pass.name);\n             }\n             println!(\"\\nPasses run with `--document-private-items`:\");\n-            for &name in passes::DEFAULT_PRIVATE_PASSES {\n-                println!(\"{:>20}\", name);\n+            for pass in passes::DEFAULT_PRIVATE_PASSES {\n+                println!(\"{:>20}\", pass.name);\n             }\n \n             if nightly_options::is_nightly_build() {\n                 println!(\"\\nPasses run with `--show-coverage`:\");\n-                for &name in passes::DEFAULT_COVERAGE_PASSES {\n-                    println!(\"{:>20}\", name);\n+                for pass in passes::DEFAULT_COVERAGE_PASSES {\n+                    println!(\"{:>20}\", pass.name);\n                 }\n                 println!(\"\\nPasses run with `--show-coverage --document-private-items`:\");\n-                for &name in passes::PRIVATE_COVERAGE_PASSES {\n-                    println!(\"{:>20}\", name);\n+                for pass in passes::PRIVATE_COVERAGE_PASSES {\n+                    println!(\"{:>20}\", pass.name);\n                 }\n             }\n \n@@ -378,7 +378,7 @@ impl Options {\n                 &matches.opt_strs(\"html-after-content\"),\n                 &matches.opt_strs(\"markdown-before-content\"),\n                 &matches.opt_strs(\"markdown-after-content\"),\n-                &diag, &mut id_map, edition) {\n+                &diag, &mut id_map, edition, &None) {\n             Some(eh) => eh,\n             None => return Err(3),\n         };"}, {"sha": "87381f224d0bb424482d1c6f409599da3a84f81b", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 20, "deletions": 27, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=00ee1b47f42129a0a6e33510578fbcf07c1e5382", "patch": "@@ -22,12 +22,10 @@ use syntax::json::JsonEmitter;\n use syntax::symbol::sym;\n use errors;\n use errors::emitter::{Emitter, EmitterWriter};\n-use parking_lot::ReentrantMutex;\n \n use std::cell::RefCell;\n use std::mem;\n use rustc_data_structures::sync::{self, Lrc};\n-use std::sync::Arc;\n use std::rc::Rc;\n \n use crate::config::{Options as RustdocOptions, RenderOptions};\n@@ -46,16 +44,14 @@ pub struct DocContext<'tcx> {\n \n     pub tcx: TyCtxt<'tcx>,\n     pub resolver: Rc<RefCell<interface::BoxedResolver>>,\n-    /// The stack of module NodeIds up till this point\n-    pub crate_name: Option<String>,\n     pub cstore: Lrc<CStore>,\n     /// Later on moved into `html::render::CACHE_KEY`\n     pub renderinfo: RefCell<RenderInfo>,\n     /// Later on moved through `clean::Crate` into `html::render::CACHE_KEY`\n-    pub external_traits: Arc<ReentrantMutex<RefCell<FxHashMap<DefId, clean::Trait>>>>,\n+    pub external_traits: Rc<RefCell<FxHashMap<DefId, clean::Trait>>>,\n     /// Used while populating `external_traits` to ensure we don't process the same trait twice at\n     /// the same time.\n-    pub active_extern_traits: RefCell<Vec<DefId>>,\n+    pub active_extern_traits: RefCell<FxHashSet<DefId>>,\n     // The current set of type and lifetime substitutions,\n     // for expanding type aliases at the HIR level:\n \n@@ -72,7 +68,6 @@ pub struct DocContext<'tcx> {\n     /// Auto-trait or blanket impls processed so far, as `(self_ty, trait_def_id)`.\n     // FIXME(eddyb) make this a `ty::TraitRef<'tcx>` set.\n     pub generated_synthetics: RefCell<FxHashSet<(Ty<'tcx>, DefId)>>,\n-    pub all_traits: Vec<DefId>,\n     pub auto_traits: Vec<DefId>,\n }\n \n@@ -227,7 +222,7 @@ pub fn new_handler(error_format: ErrorOutputType,\n     )\n }\n \n-pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOptions, Vec<String>) {\n+pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOptions) {\n     // Parse, resolve, and typecheck the given crate.\n \n     let RustdocOptions {\n@@ -332,7 +327,7 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n         file_loader: None,\n         diagnostic_output: DiagnosticOutput::Default,\n         stderr: None,\n-        crate_name: crate_name.clone(),\n+        crate_name,\n         lint_caps,\n     };\n \n@@ -368,11 +363,9 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n             let mut renderinfo = RenderInfo::default();\n             renderinfo.access_levels = access_levels;\n \n-            let all_traits = tcx.all_traits(LOCAL_CRATE).to_vec();\n             let ctxt = DocContext {\n                 tcx,\n                 resolver,\n-                crate_name,\n                 cstore: compiler.cstore().clone(),\n                 external_traits: Default::default(),\n                 active_extern_traits: Default::default(),\n@@ -384,10 +377,9 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n                 fake_def_ids: Default::default(),\n                 all_fake_def_ids: Default::default(),\n                 generated_synthetics: Default::default(),\n-                auto_traits: all_traits.iter().cloned().filter(|trait_def_id| {\n+                auto_traits: tcx.all_traits(LOCAL_CRATE).iter().cloned().filter(|trait_def_id| {\n                     tcx.trait_is_auto(*trait_def_id)\n                 }).collect(),\n-                all_traits,\n             };\n             debug!(\"crate: {:?}\", tcx.hir().krate());\n \n@@ -432,8 +424,8 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n                         },\n                         _ => continue,\n                     };\n-                    for p in value.as_str().split_whitespace() {\n-                        sink.push(p.to_string());\n+                    for name in value.as_str().split_whitespace() {\n+                        sink.push(name.to_string());\n                     }\n                 }\n \n@@ -444,25 +436,26 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n                 }\n             }\n \n-            let mut passes: Vec<String> =\n-                passes::defaults(default_passes).iter().map(|p| p.to_string()).collect();\n-            passes.extend(manual_passes);\n+            let passes = passes::defaults(default_passes).iter().chain(manual_passes.into_iter()\n+                .flat_map(|name| {\n+                    if let Some(pass) = passes::find_pass(&name) {\n+                        Some(pass)\n+                    } else {\n+                        error!(\"unknown pass {}, skipping\", name);\n+                        None\n+                    }\n+                }));\n \n             info!(\"Executing passes\");\n \n-            for pass_name in &passes {\n-                match passes::find_pass(pass_name).map(|p| p.pass) {\n-                    Some(pass) => {\n-                        debug!(\"running pass {}\", pass_name);\n-                        krate = pass(krate, &ctxt);\n-                    }\n-                    None => error!(\"unknown pass {}, skipping\", *pass_name),\n-                }\n+            for pass in passes {\n+                debug!(\"running pass {}\", pass.name);\n+                krate = (pass.pass)(krate, &ctxt);\n             }\n \n             ctxt.sess().abort_if_errors();\n \n-            (krate, ctxt.renderinfo.into_inner(), render_options, passes)\n+            (krate, ctxt.renderinfo.into_inner(), render_options)\n         })\n     })\n }"}, {"sha": "6e453561f6da20f06d283b1e666dbc958f4a3032", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=00ee1b47f42129a0a6e33510578fbcf07c1e5382", "patch": "@@ -13,7 +13,7 @@ use rustc::hir::ptr::P;\n \n pub struct Module<'hir> {\n     pub name: Option<Name>,\n-    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n+    pub attrs: &'hir [ast::Attribute],\n     pub where_outer: Span,\n     pub where_inner: Span,\n     pub extern_crates: Vec<ExternCrate<'hir>>,\n@@ -41,7 +41,7 @@ pub struct Module<'hir> {\n impl Module<'hir> {\n     pub fn new(\n         name: Option<Name>,\n-        attrs: &'hir hir::HirVec<ast::Attribute>,\n+        attrs: &'hir [ast::Attribute],\n         vis: &'hir hir::Visibility,\n     ) -> Module<'hir> {\n         Module {\n@@ -89,7 +89,7 @@ pub struct Struct<'hir> {\n     pub struct_type: StructType,\n     pub name: Name,\n     pub generics: &'hir hir::Generics,\n-    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n+    pub attrs: &'hir [ast::Attribute],\n     pub fields: &'hir [hir::StructField],\n     pub whence: Span,\n }\n@@ -100,7 +100,7 @@ pub struct Union<'hir> {\n     pub struct_type: StructType,\n     pub name: Name,\n     pub generics: &'hir hir::Generics,\n-    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n+    pub attrs: &'hir [ast::Attribute],\n     pub fields: &'hir [hir::StructField],\n     pub whence: Span,\n }\n@@ -109,7 +109,7 @@ pub struct Enum<'hir> {\n     pub vis: &'hir hir::Visibility,\n     pub variants: Vec<Variant<'hir>>,\n     pub generics: &'hir hir::Generics,\n-    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n+    pub attrs: &'hir [ast::Attribute],\n     pub id: hir::HirId,\n     pub whence: Span,\n     pub name: Name,\n@@ -118,14 +118,14 @@ pub struct Enum<'hir> {\n pub struct Variant<'hir> {\n     pub name: Name,\n     pub id: hir::HirId,\n-    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n+    pub attrs: &'hir [ast::Attribute],\n     pub def: &'hir hir::VariantData,\n     pub whence: Span,\n }\n \n pub struct Function<'hir> {\n     pub decl: &'hir hir::FnDecl,\n-    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n+    pub attrs: &'hir [ast::Attribute],\n     pub id: hir::HirId,\n     pub name: Name,\n     pub vis: &'hir hir::Visibility,\n@@ -140,7 +140,7 @@ pub struct Typedef<'hir> {\n     pub gen: &'hir hir::Generics,\n     pub name: Name,\n     pub id: hir::HirId,\n-    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n+    pub attrs: &'hir [ast::Attribute],\n     pub whence: Span,\n     pub vis: &'hir hir::Visibility,\n }\n@@ -149,7 +149,7 @@ pub struct OpaqueTy<'hir> {\n     pub opaque_ty: &'hir hir::OpaqueTy,\n     pub name: Name,\n     pub id: hir::HirId,\n-    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n+    pub attrs: &'hir [ast::Attribute],\n     pub whence: Span,\n     pub vis: &'hir hir::Visibility,\n }\n@@ -160,7 +160,7 @@ pub struct Static<'hir> {\n     pub mutability: hir::Mutability,\n     pub expr: hir::BodyId,\n     pub name: Name,\n-    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n+    pub attrs: &'hir [ast::Attribute],\n     pub vis: &'hir hir::Visibility,\n     pub id: hir::HirId,\n     pub whence: Span,\n@@ -170,7 +170,7 @@ pub struct Constant<'hir> {\n     pub type_: &'hir P<hir::Ty>,\n     pub expr: hir::BodyId,\n     pub name: Name,\n-    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n+    pub attrs: &'hir [ast::Attribute],\n     pub vis: &'hir hir::Visibility,\n     pub id: hir::HirId,\n     pub whence: Span,\n@@ -182,8 +182,8 @@ pub struct Trait<'hir> {\n     pub name: Name,\n     pub items: Vec<&'hir hir::TraitItem>,\n     pub generics: &'hir hir::Generics,\n-    pub bounds: &'hir hir::HirVec<hir::GenericBound>,\n-    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n+    pub bounds: &'hir [hir::GenericBound],\n+    pub attrs: &'hir [ast::Attribute],\n     pub id: hir::HirId,\n     pub whence: Span,\n     pub vis: &'hir hir::Visibility,\n@@ -192,8 +192,8 @@ pub struct Trait<'hir> {\n pub struct TraitAlias<'hir> {\n     pub name: Name,\n     pub generics: &'hir hir::Generics,\n-    pub bounds: &'hir hir::HirVec<hir::GenericBound>,\n-    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n+    pub bounds: &'hir [hir::GenericBound],\n+    pub attrs: &'hir [ast::Attribute],\n     pub id: hir::HirId,\n     pub whence: Span,\n     pub vis: &'hir hir::Visibility,\n@@ -208,7 +208,7 @@ pub struct Impl<'hir> {\n     pub trait_: &'hir Option<hir::TraitRef>,\n     pub for_: &'hir P<hir::Ty>,\n     pub items: Vec<&'hir hir::ImplItem>,\n-    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n+    pub attrs: &'hir [ast::Attribute],\n     pub whence: Span,\n     pub vis: &'hir hir::Visibility,\n     pub id: hir::HirId,\n@@ -219,7 +219,7 @@ pub struct ForeignItem<'hir> {\n     pub id: hir::HirId,\n     pub name: Name,\n     pub kind: &'hir hir::ForeignItemKind,\n-    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n+    pub attrs: &'hir [ast::Attribute],\n     pub whence: Span,\n }\n \n@@ -229,7 +229,7 @@ pub struct Macro<'hir> {\n     pub name: Name,\n     pub hid: hir::HirId,\n     pub def_id: hir::def_id::DefId,\n-    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n+    pub attrs: &'hir [ast::Attribute],\n     pub whence: Span,\n     pub matchers: hir::HirVec<Span>,\n     pub imported_from: Option<Name>,\n@@ -240,15 +240,15 @@ pub struct ExternCrate<'hir> {\n     pub cnum: CrateNum,\n     pub path: Option<String>,\n     pub vis: &'hir hir::Visibility,\n-    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n+    pub attrs: &'hir [ast::Attribute],\n     pub whence: Span,\n }\n \n pub struct Import<'hir> {\n     pub name: Name,\n     pub id: hir::HirId,\n     pub vis: &'hir hir::Visibility,\n-    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n+    pub attrs: &'hir [ast::Attribute],\n     pub path: &'hir hir::Path,\n     pub glob: bool,\n     pub whence: Span,\n@@ -259,7 +259,7 @@ pub struct ProcMacro<'hir> {\n     pub id: hir::HirId,\n     pub kind: MacroKind,\n     pub helpers: Vec<Name>,\n-    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n+    pub attrs: &'hir [ast::Attribute],\n     pub whence: Span,\n }\n "}, {"sha": "56f1191feed0bb7cca9da143bc25605d2b4a7e05", "filename": "src/librustdoc/externalfiles.rs", "status": "modified", "additions": 16, "deletions": 32, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustdoc%2Fexternalfiles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustdoc%2Fexternalfiles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fexternalfiles.rs?ref=00ee1b47f42129a0a6e33510578fbcf07c1e5382", "patch": "@@ -4,9 +4,7 @@ use std::str;\n use errors;\n use crate::syntax::feature_gate::UnstableFeatures;\n use crate::syntax::edition::Edition;\n-use crate::html::markdown::{IdMap, ErrorCodes, Markdown};\n-\n-use std::cell::RefCell;\n+use crate::html::markdown::{IdMap, ErrorCodes, Markdown, Playground};\n \n #[derive(Clone, Debug)]\n pub struct ExternalHtml {\n@@ -24,37 +22,23 @@ pub struct ExternalHtml {\n impl ExternalHtml {\n     pub fn load(in_header: &[String], before_content: &[String], after_content: &[String],\n                 md_before_content: &[String], md_after_content: &[String], diag: &errors::Handler,\n-                id_map: &mut IdMap, edition: Edition)\n+                id_map: &mut IdMap, edition: Edition, playground: &Option<Playground>)\n             -> Option<ExternalHtml> {\n         let codes = ErrorCodes::from(UnstableFeatures::from_environment().is_nightly_build());\n-        load_external_files(in_header, diag)\n-            .and_then(|ih|\n-                load_external_files(before_content, diag)\n-                    .map(|bc| (ih, bc))\n-            )\n-            .and_then(|(ih, bc)|\n-                load_external_files(md_before_content, diag)\n-                    .map(|m_bc| (ih,\n-                            format!(\"{}{}\", bc, Markdown(&m_bc, &[], RefCell::new(id_map),\n-                                    codes, edition))))\n-            )\n-            .and_then(|(ih, bc)|\n-                load_external_files(after_content, diag)\n-                    .map(|ac| (ih, bc, ac))\n-            )\n-            .and_then(|(ih, bc, ac)|\n-                load_external_files(md_after_content, diag)\n-                    .map(|m_ac| (ih, bc,\n-                            format!(\"{}{}\", ac, Markdown(&m_ac, &[], RefCell::new(id_map),\n-                                    codes, edition))))\n-            )\n-            .map(|(ih, bc, ac)|\n-                ExternalHtml {\n-                    in_header: ih,\n-                    before_content: bc,\n-                    after_content: ac,\n-                }\n-            )\n+        let ih = load_external_files(in_header, diag)?;\n+        let bc = load_external_files(before_content, diag)?;\n+        let m_bc = load_external_files(md_before_content, diag)?;\n+        let bc = format!(\"{}{}\", bc, Markdown(&m_bc, &[], id_map,\n+                                    codes, edition, playground).to_string());\n+        let ac = load_external_files(after_content, diag)?;\n+        let m_ac = load_external_files(md_after_content, diag)?;\n+        let ac = format!(\"{}{}\", ac, Markdown(&m_ac, &[], id_map,\n+                                    codes, edition, playground).to_string());\n+        Some(ExternalHtml {\n+            in_header: ih,\n+            before_content: bc,\n+            after_content: ac,\n+        })\n     }\n }\n "}, {"sha": "5482239c7ce28dd2b1ac3da5be0ba57f341b82f8", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=00ee1b47f42129a0a6e33510578fbcf07c1e5382", "patch": "@@ -105,12 +105,12 @@ pub trait DocFolder : Sized {\n         c.module = c.module.take().and_then(|module| self.fold_item(module));\n \n         {\n-            let guard = c.external_traits.lock();\n-            let traits = guard.replace(Default::default());\n-            guard.borrow_mut().extend(traits.into_iter().map(|(k, mut v)| {\n+            let mut guard = c.external_traits.borrow_mut();\n+            let external_traits = std::mem::replace(&mut *guard, Default::default());\n+            *guard = external_traits.into_iter().map(|(k, mut v)| {\n                 v.items = v.items.into_iter().filter_map(|i| self.fold_item(i)).collect();\n                 (k, v)\n-            }));\n+            }).collect();\n         }\n         c\n     }"}, {"sha": "5a7deb651b00d8e9866fde5c3dd3b133621f1319", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 133, "deletions": 126, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=00ee1b47f42129a0a6e33510578fbcf07c1e5382", "patch": "@@ -1,9 +1,6 @@\n //! Markdown formatting for rustdoc.\n //!\n-//! This module implements markdown formatting through the pulldown-cmark\n-//! rust-library. This module exposes all of the\n-//! functionality through a unit struct, `Markdown`, which has an implementation\n-//! of `fmt::Display`. Example usage:\n+//! This module implements markdown formatting through the pulldown-cmark library.\n //!\n //! ```\n //! #![feature(rustc_private)]\n@@ -12,12 +9,11 @@\n //!\n //! use syntax::edition::Edition;\n //! use rustdoc::html::markdown::{IdMap, Markdown, ErrorCodes};\n-//! use std::cell::RefCell;\n //!\n //! let s = \"My *markdown* _text_\";\n //! let mut id_map = IdMap::new();\n-//! let html = format!(\"{}\", Markdown(s, &[], RefCell::new(&mut id_map),\n-//!                                   ErrorCodes::Yes, Edition::Edition2015));\n+//! let md = Markdown(s, &[], &mut id_map, ErrorCodes::Yes, Edition::Edition2015, &None);\n+//! let html = md.to_string();\n //! // ... something using html\n //! ```\n \n@@ -27,7 +23,7 @@ use rustc_data_structures::fx::FxHashMap;\n use std::cell::RefCell;\n use std::collections::VecDeque;\n use std::default::Default;\n-use std::fmt::{self, Write};\n+use std::fmt::Write;\n use std::borrow::Cow;\n use std::ops::Range;\n use std::str;\n@@ -46,29 +42,36 @@ fn opts() -> Options {\n     Options::ENABLE_TABLES | Options::ENABLE_FOOTNOTES\n }\n \n-/// A tuple struct that has the `fmt::Display` trait implemented.\n-/// When formatted, this struct will emit the HTML corresponding to the rendered\n-/// version of the contained markdown string.\n+/// When `to_string` is called, this struct will emit the HTML corresponding to\n+/// the rendered version of the contained markdown string.\n pub struct Markdown<'a>(\n     pub &'a str,\n     /// A list of link replacements.\n     pub &'a [(String, String)],\n     /// The current list of used header IDs.\n-    pub RefCell<&'a mut IdMap>,\n+    pub &'a mut IdMap,\n     /// Whether to allow the use of explicit error codes in doctest lang strings.\n     pub ErrorCodes,\n     /// Default edition to use when parsing doctests (to add a `fn main`).\n     pub Edition,\n+    pub &'a Option<Playground>,\n );\n /// A tuple struct like `Markdown` that renders the markdown with a table of contents.\n pub struct MarkdownWithToc<'a>(\n     pub &'a str,\n-    pub RefCell<&'a mut IdMap>,\n+    pub &'a mut IdMap,\n     pub ErrorCodes,\n     pub Edition,\n+    pub &'a Option<Playground>,\n );\n /// A tuple struct like `Markdown` that renders the markdown escaping HTML tags.\n-pub struct MarkdownHtml<'a>(pub &'a str, pub RefCell<&'a mut IdMap>, pub ErrorCodes, pub Edition);\n+pub struct MarkdownHtml<'a>(\n+    pub &'a str,\n+    pub &'a mut IdMap,\n+    pub ErrorCodes,\n+    pub Edition,\n+    pub &'a Option<Playground>,\n+);\n /// A tuple struct like `Markdown` that renders only the first paragraph.\n pub struct MarkdownSummaryLine<'a>(pub &'a str, pub &'a [(String, String)]);\n \n@@ -155,30 +158,39 @@ fn slugify(c: char) -> Option<char> {\n     }\n }\n \n-// Information about the playground if a URL has been specified, containing an\n-// optional crate name and the URL.\n-thread_local!(pub static PLAYGROUND: RefCell<Option<(Option<String>, String)>> = {\n-    RefCell::new(None)\n-});\n+#[derive(Clone, Debug)]\n+pub struct Playground {\n+    pub crate_name: Option<String>,\n+    pub url: String,\n+}\n \n /// Adds syntax highlighting and playground Run buttons to Rust code blocks.\n-struct CodeBlocks<'a, I: Iterator<Item = Event<'a>>> {\n+struct CodeBlocks<'p, 'a, I: Iterator<Item = Event<'a>>> {\n     inner: I,\n     check_error_codes: ErrorCodes,\n     edition: Edition,\n+    // Information about the playground if a URL has been specified, containing an\n+    // optional crate name and the URL.\n+    playground: &'p Option<Playground>,\n }\n \n-impl<'a, I: Iterator<Item = Event<'a>>> CodeBlocks<'a, I> {\n-    fn new(iter: I, error_codes: ErrorCodes, edition: Edition) -> Self {\n+impl<'p, 'a, I: Iterator<Item = Event<'a>>> CodeBlocks<'p, 'a, I> {\n+    fn new(\n+        iter: I,\n+        error_codes: ErrorCodes,\n+        edition: Edition,\n+        playground: &'p Option<Playground>,\n+    ) -> Self {\n         CodeBlocks {\n             inner: iter,\n             check_error_codes: error_codes,\n             edition,\n+            playground,\n         }\n     }\n }\n \n-impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'a, I> {\n+impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'_, 'a, I> {\n     type Item = Event<'a>;\n \n     fn next(&mut self) -> Option<Self::Item> {\n@@ -213,86 +225,86 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'a, I> {\n         }\n         let lines = origtext.lines().filter_map(|l| map_line(l).for_html());\n         let text = lines.collect::<Vec<Cow<'_, str>>>().join(\"\\n\");\n-        PLAYGROUND.with(|play| {\n-            // insert newline to clearly separate it from the\n-            // previous block so we can shorten the html output\n-            let mut s = String::from(\"\\n\");\n-            let playground_button = play.borrow().as_ref().and_then(|&(ref krate, ref url)| {\n-                if url.is_empty() {\n-                    return None;\n-                }\n-                let test = origtext.lines()\n-                    .map(|l| map_line(l).for_code())\n-                    .collect::<Vec<Cow<'_, str>>>().join(\"\\n\");\n-                let krate = krate.as_ref().map(|s| &**s);\n-                let (test, _) = test::make_test(&test, krate, false,\n-                                           &Default::default(), edition);\n-                let channel = if test.contains(\"#![feature(\") {\n-                    \"&amp;version=nightly\"\n-                } else {\n-                    \"\"\n-                };\n-\n-                let edition_string = format!(\"&amp;edition={}\", edition);\n-\n-                // These characters don't need to be escaped in a URI.\n-                // FIXME: use a library function for percent encoding.\n-                fn dont_escape(c: u8) -> bool {\n-                    (b'a' <= c && c <= b'z') ||\n-                    (b'A' <= c && c <= b'Z') ||\n-                    (b'0' <= c && c <= b'9') ||\n-                    c == b'-' || c == b'_' || c == b'.' ||\n-                    c == b'~' || c == b'!' || c == b'\\'' ||\n-                    c == b'(' || c == b')' || c == b'*'\n-                }\n-                let mut test_escaped = String::new();\n-                for b in test.bytes() {\n-                    if dont_escape(b) {\n-                        test_escaped.push(char::from(b));\n-                    } else {\n-                        write!(test_escaped, \"%{:02X}\", b).unwrap();\n-                    }\n-                }\n-                Some(format!(\n-                    r#\"<a class=\"test-arrow\" target=\"_blank\" href=\"{}?code={}{}{}\">Run</a>\"#,\n-                    url, test_escaped, channel, edition_string\n-                ))\n-            });\n-\n-            let tooltip = if ignore {\n-                Some((\"This example is not tested\".to_owned(), \"ignore\"))\n-            } else if compile_fail {\n-                Some((\"This example deliberately fails to compile\".to_owned(), \"compile_fail\"))\n-            } else if explicit_edition {\n-                Some((format!(\"This code runs with edition {}\", edition), \"edition\"))\n+        // insert newline to clearly separate it from the\n+        // previous block so we can shorten the html output\n+        let mut s = String::from(\"\\n\");\n+        let playground_button = self.playground.as_ref().and_then(|playground| {\n+            let krate = &playground.crate_name;\n+            let url = &playground.url;\n+            if url.is_empty() {\n+                return None;\n+            }\n+            let test = origtext.lines()\n+                .map(|l| map_line(l).for_code())\n+                .collect::<Vec<Cow<'_, str>>>().join(\"\\n\");\n+            let krate = krate.as_ref().map(|s| &**s);\n+            let (test, _) = test::make_test(&test, krate, false,\n+                                        &Default::default(), edition);\n+            let channel = if test.contains(\"#![feature(\") {\n+                \"&amp;version=nightly\"\n             } else {\n-                None\n+                \"\"\n             };\n \n-            if let Some((s1, s2)) = tooltip {\n-                s.push_str(&highlight::render_with_highlighting(\n-                    &text,\n-                    Some(&format!(\"rust-example-rendered{}\",\n-                                  if ignore { \" ignore\" }\n-                                  else if compile_fail { \" compile_fail\" }\n-                                  else if explicit_edition { \" edition \" }\n-                                  else { \"\" })),\n-                    playground_button.as_ref().map(String::as_str),\n-                    Some((s1.as_str(), s2))));\n-                Some(Event::Html(s.into()))\n-            } else {\n-                s.push_str(&highlight::render_with_highlighting(\n-                    &text,\n-                    Some(&format!(\"rust-example-rendered{}\",\n-                                  if ignore { \" ignore\" }\n-                                  else if compile_fail { \" compile_fail\" }\n-                                  else if explicit_edition { \" edition \" }\n-                                  else { \"\" })),\n-                    playground_button.as_ref().map(String::as_str),\n-                    None));\n-                Some(Event::Html(s.into()))\n+            let edition_string = format!(\"&amp;edition={}\", edition);\n+\n+            // These characters don't need to be escaped in a URI.\n+            // FIXME: use a library function for percent encoding.\n+            fn dont_escape(c: u8) -> bool {\n+                (b'a' <= c && c <= b'z') ||\n+                (b'A' <= c && c <= b'Z') ||\n+                (b'0' <= c && c <= b'9') ||\n+                c == b'-' || c == b'_' || c == b'.' ||\n+                c == b'~' || c == b'!' || c == b'\\'' ||\n+                c == b'(' || c == b')' || c == b'*'\n+            }\n+            let mut test_escaped = String::new();\n+            for b in test.bytes() {\n+                if dont_escape(b) {\n+                    test_escaped.push(char::from(b));\n+                } else {\n+                    write!(test_escaped, \"%{:02X}\", b).unwrap();\n+                }\n             }\n-        })\n+            Some(format!(\n+                r#\"<a class=\"test-arrow\" target=\"_blank\" href=\"{}?code={}{}{}\">Run</a>\"#,\n+                url, test_escaped, channel, edition_string\n+            ))\n+        });\n+\n+        let tooltip = if ignore {\n+            Some((\"This example is not tested\".to_owned(), \"ignore\"))\n+        } else if compile_fail {\n+            Some((\"This example deliberately fails to compile\".to_owned(), \"compile_fail\"))\n+        } else if explicit_edition {\n+            Some((format!(\"This code runs with edition {}\", edition), \"edition\"))\n+        } else {\n+            None\n+        };\n+\n+        if let Some((s1, s2)) = tooltip {\n+            s.push_str(&highlight::render_with_highlighting(\n+                &text,\n+                Some(&format!(\"rust-example-rendered{}\",\n+                                if ignore { \" ignore\" }\n+                                else if compile_fail { \" compile_fail\" }\n+                                else if explicit_edition { \" edition \" }\n+                                else { \"\" })),\n+                playground_button.as_ref().map(String::as_str),\n+                Some((s1.as_str(), s2))));\n+            Some(Event::Html(s.into()))\n+        } else {\n+            s.push_str(&highlight::render_with_highlighting(\n+                &text,\n+                Some(&format!(\"rust-example-rendered{}\",\n+                                if ignore { \" ignore\" }\n+                                else if compile_fail { \" compile_fail\" }\n+                                else if explicit_edition { \" edition \" }\n+                                else { \"\" })),\n+                playground_button.as_ref().map(String::as_str),\n+                None));\n+            Some(Event::Html(s.into()))\n+        }\n     }\n }\n \n@@ -674,13 +686,12 @@ impl LangString {\n     }\n }\n \n-impl<'a> fmt::Display for Markdown<'a> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let Markdown(md, links, ref ids, codes, edition) = *self;\n-        let mut ids = ids.borrow_mut();\n+impl Markdown<'_> {\n+    pub fn to_string(self) -> String {\n+        let Markdown(md, links, mut ids, codes, edition, playground) = self;\n \n         // This is actually common enough to special-case\n-        if md.is_empty() { return Ok(()) }\n+        if md.is_empty() { return String::new(); }\n         let replacer = |_: &str, s: &str| {\n             if let Some(&(_, ref replace)) = links.into_iter().find(|link| &*link.0 == s) {\n                 Some((replace.clone(), s.to_owned()))\n@@ -695,18 +706,17 @@ impl<'a> fmt::Display for Markdown<'a> {\n \n         let p = HeadingLinks::new(p, None, &mut ids);\n         let p = LinkReplacer::new(p, links);\n-        let p = CodeBlocks::new(p, codes, edition);\n+        let p = CodeBlocks::new(p, codes, edition, playground);\n         let p = Footnotes::new(p);\n         html::push_html(&mut s, p);\n \n-        fmt.write_str(&s)\n+        s\n     }\n }\n \n-impl<'a> fmt::Display for MarkdownWithToc<'a> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let MarkdownWithToc(md, ref ids, codes, edition) = *self;\n-        let mut ids = ids.borrow_mut();\n+impl MarkdownWithToc<'_> {\n+    pub fn to_string(self) -> String {\n+        let MarkdownWithToc(md, mut ids, codes, edition, playground) = self;\n \n         let p = Parser::new_ext(md, opts());\n \n@@ -716,24 +726,21 @@ impl<'a> fmt::Display for MarkdownWithToc<'a> {\n \n         {\n             let p = HeadingLinks::new(p, Some(&mut toc), &mut ids);\n-            let p = CodeBlocks::new(p, codes, edition);\n+            let p = CodeBlocks::new(p, codes, edition, playground);\n             let p = Footnotes::new(p);\n             html::push_html(&mut s, p);\n         }\n \n-        write!(fmt, \"<nav id=\\\"TOC\\\">{}</nav>\", toc.into_toc())?;\n-\n-        fmt.write_str(&s)\n+        format!(\"<nav id=\\\"TOC\\\">{}</nav>{}\", toc.into_toc(), s)\n     }\n }\n \n-impl<'a> fmt::Display for MarkdownHtml<'a> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let MarkdownHtml(md, ref ids, codes, edition) = *self;\n-        let mut ids = ids.borrow_mut();\n+impl MarkdownHtml<'_> {\n+    pub fn to_string(self) -> String {\n+        let MarkdownHtml(md, mut ids, codes, edition, playground) = self;\n \n         // This is actually common enough to special-case\n-        if md.is_empty() { return Ok(()) }\n+        if md.is_empty() { return String::new(); }\n         let p = Parser::new_ext(md, opts());\n \n         // Treat inline HTML as plain text.\n@@ -745,19 +752,19 @@ impl<'a> fmt::Display for MarkdownHtml<'a> {\n         let mut s = String::with_capacity(md.len() * 3 / 2);\n \n         let p = HeadingLinks::new(p, None, &mut ids);\n-        let p = CodeBlocks::new(p, codes, edition);\n+        let p = CodeBlocks::new(p, codes, edition, playground);\n         let p = Footnotes::new(p);\n         html::push_html(&mut s, p);\n \n-        fmt.write_str(&s)\n+        s\n     }\n }\n \n-impl<'a> fmt::Display for MarkdownSummaryLine<'a> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let MarkdownSummaryLine(md, links) = *self;\n+impl MarkdownSummaryLine<'_> {\n+    pub fn to_string(self) -> String {\n+        let MarkdownSummaryLine(md, links) = self;\n         // This is actually common enough to special-case\n-        if md.is_empty() { return Ok(()) }\n+        if md.is_empty() { return String::new(); }\n \n         let replacer = |_: &str, s: &str| {\n             if let Some(&(_, ref replace)) = links.into_iter().find(|link| &*link.0 == s) {\n@@ -773,7 +780,7 @@ impl<'a> fmt::Display for MarkdownSummaryLine<'a> {\n \n         html::push_html(&mut s, LinkReplacer::new(SummaryLine::new(p), links));\n \n-        fmt.write_str(&s)\n+        s\n     }\n }\n "}, {"sha": "a95c29038d46f77cced598d2b3c959db0ae4bac4", "filename": "src/librustdoc/html/markdown/tests.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustdoc%2Fhtml%2Fmarkdown%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustdoc%2Fhtml%2Fmarkdown%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown%2Ftests.rs?ref=00ee1b47f42129a0a6e33510578fbcf07c1e5382", "patch": "@@ -73,8 +73,8 @@ fn test_lang_string_parse() {\n fn test_header() {\n     fn t(input: &str, expect: &str) {\n         let mut map = IdMap::new();\n-        let output = Markdown(input, &[], RefCell::new(&mut map),\n-                              ErrorCodes::Yes, DEFAULT_EDITION).to_string();\n+        let output = Markdown(\n+            input, &[], &mut map, ErrorCodes::Yes, DEFAULT_EDITION, &None).to_string();\n         assert_eq!(output, expect, \"original: {}\", input);\n     }\n \n@@ -96,8 +96,8 @@ fn test_header() {\n fn test_header_ids_multiple_blocks() {\n     let mut map = IdMap::new();\n     fn t(map: &mut IdMap, input: &str, expect: &str) {\n-        let output = Markdown(input, &[], RefCell::new(map),\n-                              ErrorCodes::Yes, DEFAULT_EDITION).to_string();\n+        let output = Markdown(input, &[], map,\n+                              ErrorCodes::Yes, DEFAULT_EDITION, &None).to_string();\n         assert_eq!(output, expect, \"original: {}\", input);\n     }\n \n@@ -134,8 +134,8 @@ fn test_plain_summary_line() {\n fn test_markdown_html_escape() {\n     fn t(input: &str, expect: &str) {\n         let mut idmap = IdMap::new();\n-        let output = MarkdownHtml(input, RefCell::new(&mut idmap),\n-                                  ErrorCodes::Yes, DEFAULT_EDITION).to_string();\n+        let output = MarkdownHtml(input, &mut idmap,\n+                                  ErrorCodes::Yes, DEFAULT_EDITION, &None).to_string();\n         assert_eq!(output, expect, \"original: {}\", input);\n     }\n "}, {"sha": "ea97cea942820a61266789fe4159f29cfd96cf1a", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 28, "deletions": 24, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=00ee1b47f42129a0a6e33510578fbcf07c1e5382", "patch": "@@ -170,6 +170,7 @@ struct Context {\n     /// The map used to ensure all generated 'id=' attributes are unique.\n     id_map: Rc<RefCell<IdMap>>,\n     pub shared: Arc<SharedContext>,\n+    playground: Option<markdown::Playground>,\n }\n \n struct SharedContext {\n@@ -185,8 +186,8 @@ struct SharedContext {\n     pub include_sources: bool,\n     /// The local file sources we've emitted and their respective url-paths.\n     pub local_sources: FxHashMap<PathBuf, String>,\n-    /// All the passes that were run on this crate.\n-    pub passes: FxHashSet<String>,\n+    /// Whether the collapsed pass ran\n+    pub collapsed: bool,\n     /// The base-URL of the issue tracker for when an item has been tagged with\n     /// an issue number.\n     pub issue_tracker_base_url: Option<String>,\n@@ -229,15 +230,10 @@ impl SharedContext {\n }\n \n impl SharedContext {\n-    /// Returns `true` if the `collapse-docs` pass was run on this crate.\n-    pub fn was_collapsed(&self) -> bool {\n-        self.passes.contains(\"collapse-docs\")\n-    }\n-\n     /// Based on whether the `collapse-docs` pass was run, return either the `doc_value` or the\n     /// `collapsed_doc_value` of the given item.\n     pub fn maybe_collapsed_doc_value<'a>(&self, item: &'a clean::Item) -> Option<Cow<'a, str>> {\n-        if self.was_collapsed() {\n+        if self.collapsed {\n             item.collapsed_doc_value().map(|s| s.into())\n         } else {\n             item.doc_value().map(|s| s.into())\n@@ -526,7 +522,6 @@ pub fn initial_ids() -> Vec<String> {\n /// Generates the documentation for `crate` into the directory `dst`\n pub fn run(mut krate: clean::Crate,\n            options: RenderOptions,\n-           passes: FxHashSet<String>,\n            renderinfo: RenderInfo,\n            diag: &errors::Handler,\n            edition: Edition) -> Result<(), Error> {\n@@ -557,8 +552,8 @@ pub fn run(mut krate: clean::Crate,\n     };\n     let mut errors = Arc::new(ErrorStorage::new());\n     let mut scx = SharedContext {\n+        collapsed: krate.collapsed,\n         src_root,\n-        passes,\n         include_sources: true,\n         local_sources: Default::default(),\n         issue_tracker_base_url: None,\n@@ -580,9 +575,11 @@ pub fn run(mut krate: clean::Crate,\n     };\n \n     // If user passed in `--playground-url` arg, we fill in crate name here\n+    let mut playground = None;\n     if let Some(url) = playground_url {\n-        markdown::PLAYGROUND.with(|slot| {\n-            *slot.borrow_mut() = Some((Some(krate.name.clone()), url));\n+        playground = Some(markdown::Playground {\n+            crate_name: Some(krate.name.clone()),\n+            url,\n         });\n     }\n \n@@ -598,9 +595,9 @@ pub fn run(mut krate: clean::Crate,\n                     scx.layout.logo = s.to_string();\n                 }\n                 (sym::html_playground_url, Some(s)) => {\n-                    markdown::PLAYGROUND.with(|slot| {\n-                        let name = krate.name.clone();\n-                        *slot.borrow_mut() = Some((Some(name), s.to_string()));\n+                    playground = Some(markdown::Playground {\n+                        crate_name: Some(krate.name.clone()),\n+                        url: s.to_string(),\n                     });\n                 }\n                 (sym::issue_tracker_base_url, Some(s)) => {\n@@ -624,6 +621,7 @@ pub fn run(mut krate: clean::Crate,\n         edition,\n         id_map: Rc::new(RefCell::new(id_map)),\n         shared: Arc::new(scx),\n+        playground,\n     };\n \n     // Crawl the crate to build various caches used for the output\n@@ -659,7 +657,7 @@ pub fn run(mut krate: clean::Crate,\n         crate_version: krate.version.take(),\n         orphan_impl_items: Vec::new(),\n         orphan_trait_impls: Vec::new(),\n-        traits: krate.external_traits.lock().replace(Default::default()),\n+        traits: krate.external_traits.replace(Default::default()),\n         deref_trait_did,\n         deref_mut_trait_did,\n         owned_box_did,\n@@ -2597,8 +2595,8 @@ fn render_markdown(w: &mut fmt::Formatter<'_>,\n     write!(w, \"<div class='docblock{}'>{}{}</div>\",\n            if is_hidden { \" hidden\" } else { \"\" },\n            prefix,\n-           Markdown(md_text, &links, RefCell::new(&mut ids),\n-           cx.codes, cx.edition))\n+           Markdown(md_text, &links, &mut ids,\n+           cx.codes, cx.edition, &cx.playground).to_string())\n }\n \n fn document_short(\n@@ -2868,7 +2866,7 @@ fn item_module(w: &mut fmt::Formatter<'_>, cx: &Context,\n                        </tr>\",\n                        name = *myitem.name.as_ref().unwrap(),\n                        stab_tags = stability_tags(myitem),\n-                       docs = MarkdownSummaryLine(doc_value, &myitem.links()),\n+                       docs = MarkdownSummaryLine(doc_value, &myitem.links()).to_string(),\n                        class = myitem.type_(),\n                        add = add,\n                        stab = stab.unwrap_or_else(|| String::new()),\n@@ -2963,8 +2961,8 @@ fn short_stability(item: &clean::Item, cx: &Context) -> Vec<String> {\n \n         if let Some(note) = note {\n             let mut ids = cx.id_map.borrow_mut();\n-            let html = MarkdownHtml(&note, RefCell::new(&mut ids), error_codes, cx.edition);\n-            message.push_str(&format!(\": {}\", html));\n+            let html = MarkdownHtml(&note, &mut ids, error_codes, cx.edition, &cx.playground);\n+            message.push_str(&format!(\": {}\", html.to_string()));\n         }\n         stability.push(format!(\"<div class='stab deprecated'>{}</div>\", message));\n     }\n@@ -3012,7 +3010,13 @@ fn short_stability(item: &clean::Item, cx: &Context) -> Vec<String> {\n             message = format!(\n                 \"<details><summary>{}</summary>{}</details>\",\n                 message,\n-                MarkdownHtml(&unstable_reason, RefCell::new(&mut ids), error_codes, cx.edition)\n+                MarkdownHtml(\n+                    &unstable_reason,\n+                    &mut ids,\n+                    error_codes,\n+                    cx.edition,\n+                    &cx.playground,\n+                ).to_string()\n             );\n         }\n \n@@ -4242,8 +4246,8 @@ fn render_impl(w: &mut fmt::Formatter<'_>, cx: &Context, i: &Impl, link: AssocIt\n         if let Some(ref dox) = cx.shared.maybe_collapsed_doc_value(&i.impl_item) {\n             let mut ids = cx.id_map.borrow_mut();\n             write!(w, \"<div class='docblock'>{}</div>\",\n-                   Markdown(&*dox, &i.impl_item.links(), RefCell::new(&mut ids),\n-                            cx.codes, cx.edition))?;\n+                   Markdown(&*dox, &i.impl_item.links(), &mut ids,\n+                            cx.codes, cx.edition, &cx.playground).to_string())?;\n         }\n     }\n "}, {"sha": "e30b35937db9fbf55f518b43273401287f8b48fa", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=00ee1b47f42129a0a6e33510578fbcf07c1e5382", "patch": "@@ -44,7 +44,6 @@ use std::default::Default;\n use std::env;\n use std::panic;\n use std::process;\n-use std::sync::mpsc::channel;\n \n use rustc::session::{early_warn, early_error};\n use rustc::session::config::{ErrorOutputType, RustcOptGroup};\n@@ -80,7 +79,6 @@ struct Output {\n     krate: clean::Crate,\n     renderinfo: html::render::RenderInfo,\n     renderopts: config::RenderOptions,\n-    passes: Vec<String>,\n }\n \n pub fn main() {\n@@ -419,14 +417,13 @@ fn main_options(options: config::Options) -> i32 {\n             return rustc_driver::EXIT_SUCCESS;\n         }\n \n-        let Output { krate, passes, renderinfo, renderopts } = out;\n+        let Output { krate, renderinfo, renderopts } = out;\n         info!(\"going to format\");\n         let (error_format, treat_err_as_bug, ui_testing, edition) = diag_opts;\n         let diag = core::new_handler(error_format, None, treat_err_as_bug, ui_testing);\n         match html::render::run(\n             krate,\n             renderopts,\n-            passes.into_iter().collect(),\n             renderinfo,\n             &diag,\n             edition,\n@@ -454,12 +451,10 @@ where R: 'static + Send,\n     // First, parse the crate and extract all relevant information.\n     info!(\"starting to run rustc\");\n \n-    let (tx, rx) = channel();\n-\n     let result = rustc_driver::report_ices_to_stderr_if_any(move || {\n         let crate_name = options.crate_name.clone();\n         let crate_version = options.crate_version.clone();\n-        let (mut krate, renderinfo, renderopts, passes) = core::run_core(options);\n+        let (mut krate, renderinfo, renderopts) = core::run_core(options);\n \n         info!(\"finished with rustc\");\n \n@@ -469,16 +464,15 @@ where R: 'static + Send,\n \n         krate.version = crate_version;\n \n-        tx.send(f(Output {\n+        f(Output {\n             krate: krate,\n             renderinfo: renderinfo,\n             renderopts,\n-            passes: passes\n-        })).unwrap();\n+        })\n     });\n \n     match result {\n-        Ok(()) => rx.recv().unwrap(),\n+        Ok(output) => output,\n         Err(_) => panic::resume_unwind(Box::new(errors::FatalErrorMarker)),\n     }\n }"}, {"sha": "eaaae3261c728950bca315aa2745c584f4af8e4d", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=00ee1b47f42129a0a6e33510578fbcf07c1e5382", "patch": "@@ -1,7 +1,6 @@\n use std::fs::File;\n use std::io::prelude::*;\n use std::path::PathBuf;\n-use std::cell::RefCell;\n \n use errors;\n use testing;\n@@ -60,9 +59,10 @@ pub fn render(\n     };\n     let playground_url = options.markdown_playground_url\n                             .or(options.playground_url);\n-    if let Some(playground) = playground_url {\n-        markdown::PLAYGROUND.with(|s| { *s.borrow_mut() = Some((None, playground)); });\n-    }\n+    let playground = playground_url.map(|url| markdown::Playground {\n+        crate_name: None,\n+        url,\n+    });\n \n     let mut out = match File::create(&output) {\n         Err(e) => {\n@@ -82,9 +82,9 @@ pub fn render(\n     let mut ids = IdMap::new();\n     let error_codes = ErrorCodes::from(UnstableFeatures::from_environment().is_nightly_build());\n     let text = if !options.markdown_no_toc {\n-        MarkdownWithToc(text, RefCell::new(&mut ids), error_codes, edition).to_string()\n+        MarkdownWithToc(text, &mut ids, error_codes, edition, &playground).to_string()\n     } else {\n-        Markdown(text, &[], RefCell::new(&mut ids), error_codes, edition).to_string()\n+        Markdown(text, &[], &mut ids, error_codes, edition, &playground).to_string()\n     };\n \n     let err = write!("}, {"sha": "31288345ce57b1b6a735311ddfa8385b15a4427b", "filename": "src/librustdoc/passes/collapse_docs.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs?ref=00ee1b47f42129a0a6e33510578fbcf07c1e5382", "patch": "@@ -30,7 +30,9 @@ impl DocFragment {\n }\n \n pub fn collapse_docs(krate: clean::Crate, _: &DocContext<'_>) -> clean::Crate {\n-    Collapser.fold_crate(krate)\n+    let mut krate = Collapser.fold_crate(krate);\n+    krate.collapsed = true;\n+    krate\n }\n \n struct Collapser;"}, {"sha": "86e4e9fd95637c208fe02c2b1a269774b2f75f67", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=00ee1b47f42129a0a6e33510578fbcf07c1e5382", "patch": "@@ -4,7 +4,7 @@ use crate::fold::DocFolder;\n use super::Pass;\n \n use rustc::util::nodemap::FxHashSet;\n-use rustc::hir::def_id::DefId;\n+use rustc::hir::def_id::{LOCAL_CRATE, DefId};\n use syntax::symbol::sym;\n \n pub const COLLECT_TRAIT_IMPLS: Pass = Pass {\n@@ -116,7 +116,7 @@ pub fn collect_trait_impls(krate: Crate, cx: &DocContext<'_>) -> Crate {\n \n     // `tcx.crates()` doesn't include the local crate, and `tcx.all_trait_implementations`\n     // doesn't work with it anyway, so pull them from the HIR map instead\n-    for &trait_did in cx.all_traits.iter() {\n+    for &trait_did in cx.tcx.all_traits(LOCAL_CRATE).iter() {\n         for &impl_node in cx.tcx.hir().trait_impls(trait_did) {\n             let impl_did = cx.tcx.hir().local_def_id(impl_node);\n             inline::build_impl(cx, impl_did, None, &mut new_items);"}, {"sha": "641a6df2214462ed6a51db76a8284a200b21bcf7", "filename": "src/librustdoc/passes/mod.rs", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=00ee1b47f42129a0a6e33510578fbcf07c1e5382", "patch": "@@ -57,8 +57,9 @@ pub struct Pass {\n     pub description: &'static str,\n }\n \n+\n /// The full list of passes.\n-pub const PASSES: &'static [Pass] = &[\n+pub const PASSES: &[Pass] = &[\n     CHECK_PRIVATE_ITEMS_DOC_TESTS,\n     STRIP_HIDDEN,\n     UNINDENT_COMMENTS,\n@@ -73,43 +74,43 @@ pub const PASSES: &'static [Pass] = &[\n ];\n \n /// The list of passes run by default.\n-pub const DEFAULT_PASSES: &[&str] = &[\n-    \"collect-trait-impls\",\n-    \"collapse-docs\",\n-    \"unindent-comments\",\n-    \"check-private-items-doc-tests\",\n-    \"strip-hidden\",\n-    \"strip-private\",\n-    \"collect-intra-doc-links\",\n-    \"check-code-block-syntax\",\n-    \"propagate-doc-cfg\",\n+pub const DEFAULT_PASSES: &[Pass] = &[\n+    COLLECT_TRAIT_IMPLS,\n+    COLLAPSE_DOCS,\n+    UNINDENT_COMMENTS,\n+    CHECK_PRIVATE_ITEMS_DOC_TESTS,\n+    STRIP_HIDDEN,\n+    STRIP_PRIVATE,\n+    COLLECT_INTRA_DOC_LINKS,\n+    CHECK_CODE_BLOCK_SYNTAX,\n+    PROPAGATE_DOC_CFG,\n ];\n \n /// The list of default passes run with `--document-private-items` is passed to rustdoc.\n-pub const DEFAULT_PRIVATE_PASSES: &[&str] = &[\n-    \"collect-trait-impls\",\n-    \"collapse-docs\",\n-    \"unindent-comments\",\n-    \"check-private-items-doc-tests\",\n-    \"strip-priv-imports\",\n-    \"collect-intra-doc-links\",\n-    \"check-code-block-syntax\",\n-    \"propagate-doc-cfg\",\n+pub const DEFAULT_PRIVATE_PASSES: &[Pass] = &[\n+    COLLECT_TRAIT_IMPLS,\n+    COLLAPSE_DOCS,\n+    UNINDENT_COMMENTS,\n+    CHECK_PRIVATE_ITEMS_DOC_TESTS,\n+    STRIP_PRIV_IMPORTS,\n+    COLLECT_INTRA_DOC_LINKS,\n+    CHECK_CODE_BLOCK_SYNTAX,\n+    PROPAGATE_DOC_CFG,\n ];\n \n /// The list of default passes run when `--doc-coverage` is passed to rustdoc.\n-pub const DEFAULT_COVERAGE_PASSES: &'static [&'static str] = &[\n-    \"collect-trait-impls\",\n-    \"strip-hidden\",\n-    \"strip-private\",\n-    \"calculate-doc-coverage\",\n+pub const DEFAULT_COVERAGE_PASSES: &[Pass] = &[\n+    COLLECT_TRAIT_IMPLS,\n+    STRIP_HIDDEN,\n+    STRIP_PRIVATE,\n+    CALCULATE_DOC_COVERAGE,\n ];\n \n /// The list of default passes run when `--doc-coverage --document-private-items` is passed to\n /// rustdoc.\n-pub const PRIVATE_COVERAGE_PASSES: &'static [&'static str] = &[\n-    \"collect-trait-impls\",\n-    \"calculate-doc-coverage\",\n+pub const PRIVATE_COVERAGE_PASSES: &[Pass] = &[\n+    COLLECT_TRAIT_IMPLS,\n+    CALCULATE_DOC_COVERAGE,\n ];\n \n /// A shorthand way to refer to which set of passes to use, based on the presence of\n@@ -124,7 +125,7 @@ pub enum DefaultPassOption {\n }\n \n /// Returns the given default set of passes.\n-pub fn defaults(default_set: DefaultPassOption) -> &'static [&'static str] {\n+pub fn defaults(default_set: DefaultPassOption) -> &'static [Pass] {\n     match default_set {\n         DefaultPassOption::Default => DEFAULT_PASSES,\n         DefaultPassOption::Private => DEFAULT_PRIVATE_PASSES,"}, {"sha": "35b6d9972da06a2c96e2ce875b85b49f509a43b9", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=00ee1b47f42129a0a6e33510578fbcf07c1e5382", "patch": "@@ -6,6 +6,7 @@ use rustc::hir::def::{Res, DefKind};\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::middle::privacy::AccessLevel;\n use rustc::util::nodemap::{FxHashSet, FxHashMap};\n+use rustc::ty::TyCtxt;\n use syntax::ast;\n use syntax::ext::base::MacroKind;\n use syntax::source_map::Spanned;\n@@ -15,9 +16,26 @@ use syntax_pos::{self, Span};\n use std::mem;\n \n use crate::core;\n-use crate::clean::{self, AttributesExt, NestedAttributesExt, def_id_to_path};\n+use crate::clean::{self, AttributesExt, NestedAttributesExt};\n use crate::doctree::*;\n \n+// FIXME: Should this be replaced with tcx.def_path_str?\n+fn def_id_to_path(\n+    tcx: TyCtxt<'_>,\n+    did: DefId,\n+) -> Vec<String> {\n+    let crate_name = tcx.crate_name(did.krate).to_string();\n+    let relative = tcx.def_path(did).data.into_iter().filter_map(|elem| {\n+        // extern blocks have an empty name\n+        let s = elem.data.to_string();\n+        if !s.is_empty() {\n+            Some(s)\n+        } else {\n+            None\n+        }\n+    });\n+    std::iter::once(crate_name).chain(relative).collect()\n+}\n \n // Also, is there some reason that this doesn't use the 'visit'\n // framework from syntax?.\n@@ -48,12 +66,8 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     }\n \n     fn store_path(&mut self, did: DefId) {\n-        // We can't use the entry API, as that keeps the mutable borrow of `self` active\n-        // when we try to use `cx`.\n-        if self.exact_paths.get(&did).is_none() {\n-            let path = def_id_to_path(self.cx, did, self.cx.crate_name.clone());\n-            self.exact_paths.insert(did, path);\n-        }\n+        let tcx = self.cx.tcx;\n+        self.exact_paths.entry(did).or_insert_with(|| def_id_to_path(tcx, did));\n     }\n \n     pub fn visit(mut self, krate: &'tcx hir::Crate) -> Module<'tcx> {"}, {"sha": "512839a12c0e415c56420d1892e0155be9b9361a", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=00ee1b47f42129a0a6e33510578fbcf07c1e5382", "patch": "@@ -195,6 +195,12 @@ pub struct CString {\n /// [`from_ptr`]: #method.from_ptr\n #[derive(Hash)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+// FIXME:\n+// `fn from` in `impl From<&CStr> for Box<CStr>` current implementation relies\n+// on `CStr` being layout-compatible with `[u8]`.\n+// When attribute privacy is implemented, `CStr` should be annotated as `#[repr(transparent)]`.\n+// Anyway, `CStr` representation and layout are considered implementation detail, are\n+// not documented and must not be relied upon.\n pub struct CStr {\n     // FIXME: this should not be represented with a DST slice but rather with\n     //        just a raw `c_char` along with some form of marker to make"}, {"sha": "1f384cbada3dae3f9f844dbafd236a8f9e573e4b", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=00ee1b47f42129a0a6e33510578fbcf07c1e5382", "patch": "@@ -97,6 +97,12 @@ pub struct OsString {\n /// [`String`]: ../string/struct.String.html\n /// [conversions]: index.html#conversions\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+// FIXME:\n+// `OsStr::from_inner` current implementation relies\n+// on `OsStr` being layout-compatible with `Slice`.\n+// When attribute privacy is implemented, `OsStr` should be annotated as `#[repr(transparent)]`.\n+// Anyway, `OsStr` representation and layout are considered implementation detail, are\n+// not documented and must not be relied upon.\n pub struct OsStr {\n     inner: Slice\n }"}, {"sha": "fd6ff1032bb81da2a22097645ba66636938a2e4d", "filename": "src/libstd/path.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=00ee1b47f42129a0a6e33510578fbcf07c1e5382", "patch": "@@ -1123,6 +1123,12 @@ impl FusedIterator for Ancestors<'_> {}\n /// Which method works best depends on what kind of situation you're in.\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+// FIXME:\n+// `PathBuf::as_mut_vec` current implementation relies\n+// on `PathBuf` being layout-compatible with `Vec<u8>`.\n+// When attribute privacy is implemented, `PathBuf` should be annotated as `#[repr(transparent)]`.\n+// Anyway, `PathBuf` representation and layout are considered implementation detail, are\n+// not documented and must not be relied upon.\n pub struct PathBuf {\n     inner: OsString,\n }\n@@ -1745,6 +1751,12 @@ impl AsRef<OsStr> for PathBuf {\n /// assert_eq!(extension, Some(OsStr::new(\"txt\")));\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+// FIXME:\n+// `Path::new` current implementation relies\n+// on `Path` being layout-compatible with `OsStr`.\n+// When attribute privacy is implemented, `Path` should be annotated as `#[repr(transparent)]`.\n+// Anyway, `Path` representation and layout are considered implementation detail, are\n+// not documented and must not be relied upon.\n pub struct Path {\n     inner: OsStr,\n }"}, {"sha": "d734f412bf88650115881856f86ea744c1aa1d04", "filename": "src/libstd/sys_common/os_str_bytes.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibstd%2Fsys_common%2Fos_str_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibstd%2Fsys_common%2Fos_str_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fos_str_bytes.rs?ref=00ee1b47f42129a0a6e33510578fbcf07c1e5382", "patch": "@@ -18,6 +18,12 @@ pub(crate) struct Buf {\n     pub inner: Vec<u8>\n }\n \n+// FIXME:\n+// `Buf::as_slice` current implementation relies\n+// on `Slice` being layout-compatible with `[u8]`.\n+// When attribute privacy is implemented, `Slice` should be annotated as `#[repr(transparent)]`.\n+// Anyway, `Slice` representation and layout are considered implementation detail, are\n+// not documented and must not be relied upon.\n pub(crate) struct Slice {\n     pub inner: [u8]\n }"}, {"sha": "2d9556233d15fb85a557462bbb2ea13a7312e73a", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=00ee1b47f42129a0a6e33510578fbcf07c1e5382", "patch": "@@ -412,6 +412,7 @@ symbols! {\n         match_beginning_vert,\n         match_default_bindings,\n         may_dangle,\n+        mem,\n         member_constraints,\n         message,\n         meta,\n@@ -695,6 +696,7 @@ symbols! {\n         underscore_imports,\n         underscore_lifetimes,\n         uniform_paths,\n+        uninitialized,\n         universal_impl_trait,\n         unmarked_api,\n         unreachable_code,\n@@ -726,6 +728,7 @@ symbols! {\n         windows,\n         windows_subsystem,\n         Yield,\n+        zeroed,\n     }\n }\n "}, {"sha": "4509ebc6338a87f7f543b61f91f7d7db6b6caafb", "filename": "src/test/ui/consts/uninhabited-const-issue-61744.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Ftest%2Fui%2Fconsts%2Funinhabited-const-issue-61744.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Ftest%2Fui%2Fconsts%2Funinhabited-const-issue-61744.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Funinhabited-const-issue-61744.rs?ref=00ee1b47f42129a0a6e33510578fbcf07c1e5382", "patch": "@@ -1,11 +1,11 @@\n // compile-fail\n \n pub const unsafe fn fake_type<T>() -> T {\n-    hint_unreachable()\n+    hint_unreachable() //~ ERROR any use of this value will cause an error\n }\n \n pub const unsafe fn hint_unreachable() -> ! {\n-    fake_type() //~ ERROR any use of this value will cause an error\n+    fake_type()\n }\n \n trait Const {"}, {"sha": "f390676fda6d08b4d3fd2e98a148745849bf3e08", "filename": "src/test/ui/consts/uninhabited-const-issue-61744.stderr", "status": "modified", "additions": 53, "deletions": 4, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Ftest%2Fui%2Fconsts%2Funinhabited-const-issue-61744.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Ftest%2Fui%2Fconsts%2Funinhabited-const-issue-61744.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Funinhabited-const-issue-61744.stderr?ref=00ee1b47f42129a0a6e33510578fbcf07c1e5382", "patch": "@@ -1,11 +1,60 @@\n error: any use of this value will cause an error\n-  --> $DIR/uninhabited-const-issue-61744.rs:8:5\n+  --> $DIR/uninhabited-const-issue-61744.rs:4:5\n    |\n-LL |     fake_type()\n-   |     ^^^^^^^^^^^\n+LL |     hint_unreachable()\n+   |     ^^^^^^^^^^^^^^^^^^\n    |     |\n-   |     tried to call a function with return type T passing return place of type !\n+   |     reached the configured maximum number of stack frames\n    |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside call to `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside call to `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside call to `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside call to `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside call to `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside call to `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside call to `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside call to `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside call to `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside call to `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside call to `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside call to `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside call to `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside call to `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside call to `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside call to `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside call to `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside call to `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside call to `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside call to `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside call to `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside call to `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside call to `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside call to `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside call to `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside call to `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside call to `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside call to `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside call to `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside call to `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside call to `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside call to `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside call to `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside call to `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside call to `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside call to `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside call to `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside call to `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside call to `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside call to `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside call to `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside call to `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside call to `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside call to `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside call to `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside call to `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside call to `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside call to `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:8:5\n    |     inside call to `fake_type::<i32>` at $DIR/uninhabited-const-issue-61744.rs:12:36\n ...\n LL |     const CONSTANT: i32 = unsafe { fake_type() };"}, {"sha": "8f9ca8717bda6b1ed77847b7247b3d9c636f2c52", "filename": "src/test/ui/lint/uninitialized-zeroed.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.rs?ref=00ee1b47f42129a0a6e33510578fbcf07c1e5382", "patch": "@@ -0,0 +1,58 @@\n+// ignore-tidy-linelength\n+// This test checks that calling `mem::{uninitialized,zeroed}` with certain types results\n+// in a lint.\n+\n+#![feature(never_type)]\n+#![allow(deprecated)]\n+#![deny(invalid_value)]\n+\n+use std::mem::{self, MaybeUninit};\n+\n+enum Void {}\n+\n+struct Ref(&'static i32);\n+\n+struct Wrap<T> { wrapped: T }\n+\n+#[allow(unused)]\n+fn generic<T: 'static>() {\n+    unsafe {\n+        let _val: &'static T = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n+        let _val: &'static T = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n+        let _val: Wrap<&'static T> = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n+        let _val: Wrap<&'static T> = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+    }\n+}\n+\n+fn main() {\n+    unsafe {\n+        let _val: ! = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n+        let _val: ! = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n+        let _val: (i32, !) = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n+        let _val: (i32, !) = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n+        let _val: Void = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n+        let _val: Void = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n+        let _val: &'static i32 = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n+        let _val: &'static i32 = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n+        let _val: Ref = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n+        let _val: Ref = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n+        let _val: fn() = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n+        let _val: fn() = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n+        let _val: Wrap<fn()> = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n+        let _val: Wrap<fn()> = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n+        // Some types that should work just fine.\n+        let _val: Option<&'static i32> = mem::zeroed();\n+        let _val: Option<fn()> = mem::zeroed();\n+        let _val: MaybeUninit<&'static i32> = mem::zeroed();\n+        let _val: bool = mem::zeroed();\n+        let _val: i32 = mem::zeroed();\n+    }\n+}"}, {"sha": "af54b16bd0b242552b7766bfcf41c85561f16fd8", "filename": "src/test/ui/lint/uninitialized-zeroed.stderr", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.stderr?ref=00ee1b47f42129a0a6e33510578fbcf07c1e5382", "patch": "@@ -0,0 +1,169 @@\n+error: the type `&'static T` does not permit zero-initialization\n+  --> $DIR/uninitialized-zeroed.rs:20:32\n+   |\n+LL |         let _val: &'static T = mem::zeroed();\n+   |                                ^^^^^^^^^^^^^\n+   |\n+note: lint level defined here\n+  --> $DIR/uninitialized-zeroed.rs:7:9\n+   |\n+LL | #![deny(invalid_value)]\n+   |         ^^^^^^^^^^^^^\n+   = note: this means that this code causes undefined behavior when executed\n+   = help: use `MaybeUninit` instead\n+\n+error: the type `&'static T` does not permit being left uninitialized\n+  --> $DIR/uninitialized-zeroed.rs:21:32\n+   |\n+LL |         let _val: &'static T = mem::uninitialized();\n+   |                                ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this means that this code causes undefined behavior when executed\n+   = help: use `MaybeUninit` instead\n+\n+error: the type `Wrap<&'static T>` does not permit zero-initialization\n+  --> $DIR/uninitialized-zeroed.rs:23:38\n+   |\n+LL |         let _val: Wrap<&'static T> = mem::zeroed();\n+   |                                      ^^^^^^^^^^^^^\n+   |\n+   = note: this means that this code causes undefined behavior when executed\n+   = help: use `MaybeUninit` instead\n+\n+error: the type `Wrap<&'static T>` does not permit being left uninitialized\n+  --> $DIR/uninitialized-zeroed.rs:24:38\n+   |\n+LL |         let _val: Wrap<&'static T> = mem::uninitialized();\n+   |                                      ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this means that this code causes undefined behavior when executed\n+   = help: use `MaybeUninit` instead\n+\n+error: the type `!` does not permit zero-initialization\n+  --> $DIR/uninitialized-zeroed.rs:30:23\n+   |\n+LL |         let _val: ! = mem::zeroed();\n+   |                       ^^^^^^^^^^^^^\n+   |\n+   = note: this means that this code causes undefined behavior when executed\n+   = help: use `MaybeUninit` instead\n+\n+error: the type `!` does not permit being left uninitialized\n+  --> $DIR/uninitialized-zeroed.rs:31:23\n+   |\n+LL |         let _val: ! = mem::uninitialized();\n+   |                       ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this means that this code causes undefined behavior when executed\n+   = help: use `MaybeUninit` instead\n+\n+error: the type `(i32, !)` does not permit zero-initialization\n+  --> $DIR/uninitialized-zeroed.rs:33:30\n+   |\n+LL |         let _val: (i32, !) = mem::zeroed();\n+   |                              ^^^^^^^^^^^^^\n+   |\n+   = note: this means that this code causes undefined behavior when executed\n+   = help: use `MaybeUninit` instead\n+\n+error: the type `(i32, !)` does not permit being left uninitialized\n+  --> $DIR/uninitialized-zeroed.rs:34:30\n+   |\n+LL |         let _val: (i32, !) = mem::uninitialized();\n+   |                              ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this means that this code causes undefined behavior when executed\n+   = help: use `MaybeUninit` instead\n+\n+error: the type `Void` does not permit zero-initialization\n+  --> $DIR/uninitialized-zeroed.rs:36:26\n+   |\n+LL |         let _val: Void = mem::zeroed();\n+   |                          ^^^^^^^^^^^^^\n+   |\n+   = note: this means that this code causes undefined behavior when executed\n+   = help: use `MaybeUninit` instead\n+\n+error: the type `Void` does not permit being left uninitialized\n+  --> $DIR/uninitialized-zeroed.rs:37:26\n+   |\n+LL |         let _val: Void = mem::uninitialized();\n+   |                          ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this means that this code causes undefined behavior when executed\n+   = help: use `MaybeUninit` instead\n+\n+error: the type `&'static i32` does not permit zero-initialization\n+  --> $DIR/uninitialized-zeroed.rs:39:34\n+   |\n+LL |         let _val: &'static i32 = mem::zeroed();\n+   |                                  ^^^^^^^^^^^^^\n+   |\n+   = note: this means that this code causes undefined behavior when executed\n+   = help: use `MaybeUninit` instead\n+\n+error: the type `&'static i32` does not permit being left uninitialized\n+  --> $DIR/uninitialized-zeroed.rs:40:34\n+   |\n+LL |         let _val: &'static i32 = mem::uninitialized();\n+   |                                  ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this means that this code causes undefined behavior when executed\n+   = help: use `MaybeUninit` instead\n+\n+error: the type `Ref` does not permit zero-initialization\n+  --> $DIR/uninitialized-zeroed.rs:42:25\n+   |\n+LL |         let _val: Ref = mem::zeroed();\n+   |                         ^^^^^^^^^^^^^\n+   |\n+   = note: this means that this code causes undefined behavior when executed\n+   = help: use `MaybeUninit` instead\n+\n+error: the type `Ref` does not permit being left uninitialized\n+  --> $DIR/uninitialized-zeroed.rs:43:25\n+   |\n+LL |         let _val: Ref = mem::uninitialized();\n+   |                         ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this means that this code causes undefined behavior when executed\n+   = help: use `MaybeUninit` instead\n+\n+error: the type `fn()` does not permit zero-initialization\n+  --> $DIR/uninitialized-zeroed.rs:45:26\n+   |\n+LL |         let _val: fn() = mem::zeroed();\n+   |                          ^^^^^^^^^^^^^\n+   |\n+   = note: this means that this code causes undefined behavior when executed\n+   = help: use `MaybeUninit` instead\n+\n+error: the type `fn()` does not permit being left uninitialized\n+  --> $DIR/uninitialized-zeroed.rs:46:26\n+   |\n+LL |         let _val: fn() = mem::uninitialized();\n+   |                          ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this means that this code causes undefined behavior when executed\n+   = help: use `MaybeUninit` instead\n+\n+error: the type `Wrap<fn()>` does not permit zero-initialization\n+  --> $DIR/uninitialized-zeroed.rs:48:32\n+   |\n+LL |         let _val: Wrap<fn()> = mem::zeroed();\n+   |                                ^^^^^^^^^^^^^\n+   |\n+   = note: this means that this code causes undefined behavior when executed\n+   = help: use `MaybeUninit` instead\n+\n+error: the type `Wrap<fn()>` does not permit being left uninitialized\n+  --> $DIR/uninitialized-zeroed.rs:49:32\n+   |\n+LL |         let _val: Wrap<fn()> = mem::uninitialized();\n+   |                                ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this means that this code causes undefined behavior when executed\n+   = help: use `MaybeUninit` instead\n+\n+error: aborting due to 18 previous errors\n+"}, {"sha": "b0d6629561803077c5324c0c2d9d61e553657557", "filename": "src/test/ui/panic-uninitialized-zeroed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Ftest%2Fui%2Fpanic-uninitialized-zeroed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Ftest%2Fui%2Fpanic-uninitialized-zeroed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpanic-uninitialized-zeroed.rs?ref=00ee1b47f42129a0a6e33510578fbcf07c1e5382", "patch": "@@ -4,7 +4,7 @@\n // in a runtime panic.\n \n #![feature(never_type)]\n-#![allow(deprecated)]\n+#![allow(deprecated, invalid_value)]\n \n use std::{mem, panic};\n "}, {"sha": "72da1015d6d918fe1b29170acbf486d30e0c2695", "filename": "src/tools/clippy", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy?ref=00ee1b47f42129a0a6e33510578fbcf07c1e5382", "patch": "@@ -1 +1 @@\n-Subproject commit b041511b5fcd386c4ae74a30b60a5081f8717fbe\n+Subproject commit 72da1015d6d918fe1b29170acbf486d30e0c2695"}, {"sha": "a9d1d9997f6ef3f7cfc18ce3ce052e3fc2a24a52", "filename": "src/tools/error_index_generator/main.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Ftools%2Ferror_index_generator%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ee1b47f42129a0a6e33510578fbcf07c1e5382/src%2Ftools%2Ferror_index_generator%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ferror_index_generator%2Fmain.rs?ref=00ee1b47f42129a0a6e33510578fbcf07c1e5382", "patch": "@@ -16,7 +16,7 @@ use std::cell::RefCell;\n use syntax::edition::DEFAULT_EDITION;\n use syntax::diagnostics::metadata::{get_metadata_dir, ErrorMetadataMap, ErrorMetadata};\n \n-use rustdoc::html::markdown::{Markdown, IdMap, ErrorCodes, PLAYGROUND};\n+use rustdoc::html::markdown::{Markdown, IdMap, ErrorCodes, Playground};\n use rustc_serialize::json;\n \n enum OutputFormat {\n@@ -95,9 +95,13 @@ impl Formatter for HTMLFormatter {\n         match info.description {\n             Some(ref desc) => {\n                 let mut id_map = self.0.borrow_mut();\n+                let playground = Playground {\n+                    crate_name: None,\n+                    url: String::from(\"https://play.rust-lang.org/\"),\n+                };\n                 write!(output, \"{}\",\n-                    Markdown(desc, &[], RefCell::new(&mut id_map),\n-                             ErrorCodes::Yes, DEFAULT_EDITION))?\n+                    Markdown(desc, &[], &mut id_map,\n+                             ErrorCodes::Yes, DEFAULT_EDITION, &Some(playground)).to_string())?\n             },\n             None => write!(output, \"<p>No description.</p>\\n\")?,\n         }\n@@ -260,9 +264,6 @@ fn parse_args() -> (OutputFormat, PathBuf) {\n \n fn main() {\n     env_logger::init();\n-    PLAYGROUND.with(|slot| {\n-        *slot.borrow_mut() = Some((None, String::from(\"https://play.rust-lang.org/\")));\n-    });\n     let (format, dst) = parse_args();\n     let result = syntax::with_default_globals(move || {\n         main_with_result(format, &dst)"}]}