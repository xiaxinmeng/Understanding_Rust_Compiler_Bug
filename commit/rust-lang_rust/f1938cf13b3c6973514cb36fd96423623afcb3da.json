{"sha": "f1938cf13b3c6973514cb36fd96423623afcb3da", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxOTM4Y2YxM2IzYzY5NzM1MTRjYjM2ZmQ5NjQyMzYyM2FmY2IzZGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-10-04T03:28:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-10-04T03:28:24Z"}, "message": "Auto merge of #44999 - pnkfelix:mir-borrowck-fix-assert-left-right, r=nikomatsakis\n\nOverlapping borrows can point to different lvalues.\n\nOverlapping borrows can point to different lvalues.\n\nThere's always a basis for the overlap, so instead of removing the assert entirely, I instead pass in the prefix that we found and check that it actually is a prefix of both lvalues.\n\nFix #44829", "tree": {"sha": "f30804180426f08e313effe3734ec8242fe9a068", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f30804180426f08e313effe3734ec8242fe9a068"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1938cf13b3c6973514cb36fd96423623afcb3da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1938cf13b3c6973514cb36fd96423623afcb3da", "html_url": "https://github.com/rust-lang/rust/commit/f1938cf13b3c6973514cb36fd96423623afcb3da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1938cf13b3c6973514cb36fd96423623afcb3da/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2db48d7fcbf0a2a1ceb4d8bbcbc74cd37349f629", "url": "https://api.github.com/repos/rust-lang/rust/commits/2db48d7fcbf0a2a1ceb4d8bbcbc74cd37349f629", "html_url": "https://github.com/rust-lang/rust/commit/2db48d7fcbf0a2a1ceb4d8bbcbc74cd37349f629"}, {"sha": "aac64c47565bab9d87afd1bfa5459e8f485cdbea", "url": "https://api.github.com/repos/rust-lang/rust/commits/aac64c47565bab9d87afd1bfa5459e8f485cdbea", "html_url": "https://github.com/rust-lang/rust/commit/aac64c47565bab9d87afd1bfa5459e8f485cdbea"}], "stats": {"total": 48, "additions": 38, "deletions": 10}, "files": [{"sha": "0ad22f91855068eb0a343d90b4387a647fa90d46", "filename": "src/librustc_mir/borrow_check.rs", "status": "modified", "additions": 38, "deletions": 10, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f1938cf13b3c6973514cb36fd96423623afcb3da/src%2Flibrustc_mir%2Fborrow_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1938cf13b3c6973514cb36fd96423623afcb3da/src%2Flibrustc_mir%2Fborrow_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check.rs?ref=f1938cf13b3c6973514cb36fd96423623afcb3da", "patch": "@@ -385,7 +385,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n         // borrow of immutable ref, moves through non-`Box`-ref)\n         let (sd, rw) = kind;\n         self.each_borrow_involving_path(\n-            context, (sd, lvalue_span.0), flow_state, |this, _index, borrow| {\n+            context, (sd, lvalue_span.0), flow_state, |this, _index, borrow, common_prefix| {\n                 match (rw, borrow.kind) {\n                     (Read(_), BorrowKind::Shared) => {\n                         Control::Continue\n@@ -399,6 +399,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n                             ReadKind::Borrow(bk) =>\n                                 this.report_conflicting_borrow(\n                                     context, lvalue_span,\n+                                    common_prefix,\n                                     (lvalue_span.0, bk), (&borrow.lvalue, borrow.kind)),\n                         }\n                         Control::Break\n@@ -408,6 +409,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n                             WriteKind::MutableBorrow(bk) =>\n                                 this.report_conflicting_borrow(\n                                     context, lvalue_span,\n+                                    common_prefix,\n                                     (lvalue_span.0, bk), (&borrow.lvalue, borrow.kind)),\n                             WriteKind::StorageDead |\n                             WriteKind::Mutate =>\n@@ -704,7 +706,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n                                      access_lvalue: (ShallowOrDeep, &Lvalue<'gcx>),\n                                      flow_state: &InProgress<'b, 'gcx>,\n                                      mut op: F)\n-        where F: FnMut(&mut Self, BorrowIndex, &BorrowData<'gcx>) -> Control\n+        where F: FnMut(&mut Self, BorrowIndex, &BorrowData<'gcx>, &Lvalue) -> Control\n     {\n         let (access, lvalue) = access_lvalue;\n \n@@ -726,9 +728,8 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n             // to #38899. Will probably need back-compat mode flag.\n             for accessed_prefix in self.prefixes(lvalue, PrefixSet::All) {\n                 if *accessed_prefix == borrowed.lvalue {\n-                    // FIXME: pass in prefix here too? And/or enum\n-                    // describing case we are in?\n-                    let ctrl = op(self, i, borrowed);\n+                    // FIXME: pass in enum describing case we are in?\n+                    let ctrl = op(self, i, borrowed, accessed_prefix);\n                     if ctrl == Control::Break { return; }\n                 }\n             }\n@@ -753,9 +754,8 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n \n             for borrowed_prefix in self.prefixes(&borrowed.lvalue, prefix_kind) {\n                 if borrowed_prefix == lvalue {\n-                    // FIXME: pass in prefix here too? And/or enum\n-                    // describing case we are in?\n-                    let ctrl = op(self, i, borrowed);\n+                    // FIXME: pass in enum describing case we are in?\n+                    let ctrl = op(self, i, borrowed, borrowed_prefix);\n                     if ctrl == Control::Break { return; }\n                 }\n             }\n@@ -780,6 +780,30 @@ mod prefixes {\n     use rustc::ty::{self, TyCtxt};\n     use rustc::mir::{Lvalue, Mir, ProjectionElem};\n \n+    pub trait IsPrefixOf<'tcx> {\n+        fn is_prefix_of(&self, other: &Lvalue<'tcx>) -> bool;\n+    }\n+\n+    impl<'tcx> IsPrefixOf<'tcx> for Lvalue<'tcx> {\n+        fn is_prefix_of(&self, other: &Lvalue<'tcx>) -> bool {\n+            let mut cursor = other;\n+            loop {\n+                if self == cursor {\n+                    return true;\n+                }\n+\n+                match *cursor {\n+                    Lvalue::Local(_) |\n+                    Lvalue::Static(_) => return false,\n+                    Lvalue::Projection(ref proj) => {\n+                        cursor = &proj.base;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+\n     pub(super) struct Prefixes<'c, 'tcx: 'c> {\n         mir: &'c Mir<'tcx>,\n         tcx: TyCtxt<'c, 'tcx, 'tcx>,\n@@ -943,12 +967,16 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n     fn report_conflicting_borrow(&mut self,\n                                  _context: Context,\n                                  (lvalue, span): (&Lvalue, Span),\n+                                 common_prefix: &Lvalue,\n                                  loan1: (&Lvalue, BorrowKind),\n                                  loan2: (&Lvalue, BorrowKind)) {\n+        use self::prefixes::IsPrefixOf;\n+\n         let (loan1_lvalue, loan1_kind) = loan1;\n         let (loan2_lvalue, loan2_kind) = loan2;\n-        // FIXME: obviously falsifiable. Generalize for non-eq lvalues later.\n-        assert_eq!(loan1_lvalue, loan2_lvalue);\n+\n+        assert!(common_prefix.is_prefix_of(loan1_lvalue));\n+        assert!(common_prefix.is_prefix_of(loan2_lvalue));\n \n         // FIXME: supply non-\"\" `opt_via` when appropriate\n         let mut err = match (loan1_kind, \"immutable\", \"mutable\","}]}