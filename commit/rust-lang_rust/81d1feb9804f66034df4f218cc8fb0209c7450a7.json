{"sha": "81d1feb9804f66034df4f218cc8fb0209c7450a7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxZDFmZWI5ODA0ZjY2MDM0ZGY0ZjIxOGNjOGZiMDIwOWM3NDUwYTc=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-09-17T17:47:05Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-09-22T04:05:05Z"}, "message": "Remove #[allow(deprecated)] from libstd", "tree": {"sha": "0c524deb8ce5015102af2d2f7a0df93d0fd2f5f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c524deb8ce5015102af2d2f7a0df93d0fd2f5f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/81d1feb9804f66034df4f218cc8fb0209c7450a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/81d1feb9804f66034df4f218cc8fb0209c7450a7", "html_url": "https://github.com/rust-lang/rust/commit/81d1feb9804f66034df4f218cc8fb0209c7450a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/81d1feb9804f66034df4f218cc8fb0209c7450a7/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72841b128df8b6a4eb88b1048548e2eec5244449", "url": "https://api.github.com/repos/rust-lang/rust/commits/72841b128df8b6a4eb88b1048548e2eec5244449", "html_url": "https://github.com/rust-lang/rust/commit/72841b128df8b6a4eb88b1048548e2eec5244449"}], "stats": {"total": 112, "additions": 59, "deletions": 53}, "files": [{"sha": "fe2b8a15c7375387c96f0193ac794f4cd25a4cf8", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/81d1feb9804f66034df4f218cc8fb0209c7450a7/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81d1feb9804f66034df4f218cc8fb0209c7450a7/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=81d1feb9804f66034df4f218cc8fb0209c7450a7", "patch": "@@ -21,8 +21,7 @@ use mem;\n use option::{Option, Some, None};\n use slice::{ImmutableSlice, MutableSlice, Slice};\n use str::{Str, StrSlice};\n-use str;\n-use string::String;\n+use string::{mod, String};\n use to_string::IntoStr;\n use vec::Vec;\n \n@@ -113,7 +112,7 @@ impl Ascii {\n     /// Check if the character is a letter or number\n     #[inline]\n     pub fn is_alphanumeric(&self) -> bool {\n-        self.is_alpha() || self.is_digit()\n+        self.is_alphabetic() || self.is_digit()\n     }\n \n     /// Check if the character is a space or horizontal tab\n@@ -169,7 +168,7 @@ impl Ascii {\n     /// Checks if the character is punctuation\n     #[inline]\n     pub fn is_punctuation(&self) -> bool {\n-        self.is_graph() && !self.is_alnum()\n+        self.is_graph() && !self.is_alphanumeric()\n     }\n \n     /// Checks if the character is a valid hex digit\n@@ -338,12 +337,12 @@ impl<'a> AsciiStr for &'a [Ascii] {\n \n     #[inline]\n     fn to_lower(&self) -> Vec<Ascii> {\n-        self.iter().map(|a| a.to_lower()).collect()\n+        self.iter().map(|a| a.to_lowercase()).collect()\n     }\n \n     #[inline]\n     fn to_upper(&self) -> Vec<Ascii> {\n-        self.iter().map(|a| a.to_upper()).collect()\n+        self.iter().map(|a| a.to_uppercase()).collect()\n     }\n \n     #[inline]\n@@ -410,13 +409,13 @@ impl<'a> AsciiExt<String> for &'a str {\n     #[inline]\n     fn to_ascii_upper(&self) -> String {\n         // Vec<u8>::to_ascii_upper() preserves the UTF-8 invariant.\n-        unsafe { str::raw::from_utf8_owned(self.as_bytes().to_ascii_upper()) }\n+        unsafe { string::raw::from_utf8(self.as_bytes().to_ascii_upper()) }\n     }\n \n     #[inline]\n     fn to_ascii_lower(&self) -> String {\n         // Vec<u8>::to_ascii_lower() preserves the UTF-8 invariant.\n-        unsafe { str::raw::from_utf8_owned(self.as_bytes().to_ascii_lower()) }\n+        unsafe { string::raw::from_utf8(self.as_bytes().to_ascii_lower()) }\n     }\n \n     #[inline]\n@@ -429,13 +428,13 @@ impl OwnedAsciiExt for String {\n     #[inline]\n     fn into_ascii_upper(self) -> String {\n         // Vec<u8>::into_ascii_upper() preserves the UTF-8 invariant.\n-        unsafe { str::raw::from_utf8_owned(self.into_bytes().into_ascii_upper()) }\n+        unsafe { string::raw::from_utf8(self.into_bytes().into_ascii_upper()) }\n     }\n \n     #[inline]\n     fn into_ascii_lower(self) -> String {\n         // Vec<u8>::into_ascii_lower() preserves the UTF-8 invariant.\n-        unsafe { str::raw::from_utf8_owned(self.into_bytes().into_ascii_lower()) }\n+        unsafe { string::raw::from_utf8(self.into_bytes().into_ascii_lower()) }\n     }\n }\n "}, {"sha": "b0604e1316304fb855771ea0ab22d222e719d7f4", "filename": "src/libstd/collections/hashmap/map.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/81d1feb9804f66034df4f218cc8fb0209c7450a7/src%2Flibstd%2Fcollections%2Fhashmap%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81d1feb9804f66034df4f218cc8fb0209c7450a7/src%2Flibstd%2Fcollections%2Fhashmap%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhashmap%2Fmap.rs?ref=81d1feb9804f66034df4f218cc8fb0209c7450a7", "patch": "@@ -1288,7 +1288,7 @@ impl<K: Eq + Hash<S>, V: Clone, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// let s: String = map.get_copy(&1);\n     /// ```\n     pub fn get_copy(&self, k: &K) -> V {\n-        (*self.get(k)).clone()\n+        self[*k].clone()\n     }\n }\n \n@@ -1325,6 +1325,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S> + Default> Default for HashMap<K, V, H>\n \n impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> Index<K, V> for HashMap<K, V, H> {\n     #[inline]\n+    #[allow(deprecated)]\n     fn index<'a>(&'a self, index: &K) -> &'a V {\n         self.get(index)\n     }"}, {"sha": "45ca633b41f9a62862b52692f9ae9c93cd409dfb", "filename": "src/libstd/collections/hashmap/table.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81d1feb9804f66034df4f218cc8fb0209c7450a7/src%2Flibstd%2Fcollections%2Fhashmap%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81d1feb9804f66034df4f218cc8fb0209c7450a7/src%2Flibstd%2Fcollections%2Fhashmap%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhashmap%2Ftable.rs?ref=81d1feb9804f66034df4f218cc8fb0209c7450a7", "patch": "@@ -846,8 +846,8 @@ impl<K: Clone, V: Clone> Clone for RawTable<K, V> {\n                                 (full.hash(), k.clone(), v.clone())\n                             };\n                             *new_buckets.raw.hash = h.inspect();\n-                            mem::overwrite(new_buckets.raw.key, k);\n-                            mem::overwrite(new_buckets.raw.val, v);\n+                            ptr::write(new_buckets.raw.key, k);\n+                            ptr::write(new_buckets.raw.val, v);\n                         }\n                         Empty(..) => {\n                             *new_buckets.raw.hash = EMPTY_BUCKET;"}, {"sha": "a7de84184ff5db719651ce22e92fb55a5d61c1f5", "filename": "src/libstd/failure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81d1feb9804f66034df4f218cc8fb0209c7450a7/src%2Flibstd%2Ffailure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81d1feb9804f66034df4f218cc8fb0209c7450a7/src%2Flibstd%2Ffailure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffailure.rs?ref=81d1feb9804f66034df4f218cc8fb0209c7450a7", "patch": "@@ -38,9 +38,9 @@ impl Writer for Stdio {\n }\n \n pub fn on_fail(obj: &Any + Send, file: &'static str, line: uint) {\n-    let msg = match obj.as_ref::<&'static str>() {\n+    let msg = match obj.downcast_ref::<&'static str>() {\n         Some(s) => *s,\n-        None => match obj.as_ref::<String>() {\n+        None => match obj.downcast_ref::<String>() {\n             Some(s) => s.as_slice(),\n             None => \"Box<Any>\",\n         }"}, {"sha": "d9543a06b350c83e385fa91401cff37c8ea571ac", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/81d1feb9804f66034df4f218cc8fb0209c7450a7/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81d1feb9804f66034df4f218cc8fb0209c7450a7/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=81d1feb9804f66034df4f218cc8fb0209c7450a7", "patch": "@@ -162,7 +162,7 @@ impl<W: Writer> BufferedWriter<W> {\n \n     fn flush_buf(&mut self) -> IoResult<()> {\n         if self.pos != 0 {\n-            let ret = self.inner.get_mut_ref().write(self.buf.slice_to(self.pos));\n+            let ret = self.inner.as_mut().unwrap().write(self.buf.slice_to(self.pos));\n             self.pos = 0;\n             ret\n         } else {\n@@ -174,7 +174,7 @@ impl<W: Writer> BufferedWriter<W> {\n     ///\n     /// This type does not expose the ability to get a mutable reference to the\n     /// underlying reader because that could possibly corrupt the buffer.\n-    pub fn get_ref<'a>(&'a self) -> &'a W { self.inner.get_ref() }\n+    pub fn get_ref<'a>(&'a self) -> &'a W { self.inner.as_ref().unwrap() }\n \n     /// Unwraps this `BufferedWriter`, returning the underlying writer.\n     ///\n@@ -193,7 +193,7 @@ impl<W: Writer> Writer for BufferedWriter<W> {\n         }\n \n         if buf.len() > self.buf.len() {\n-            self.inner.get_mut_ref().write(buf)\n+            self.inner.as_mut().unwrap().write(buf)\n         } else {\n             let dst = self.buf.slice_from_mut(self.pos);\n             slice::bytes::copy_memory(dst, buf);\n@@ -203,7 +203,7 @@ impl<W: Writer> Writer for BufferedWriter<W> {\n     }\n \n     fn flush(&mut self) -> IoResult<()> {\n-        self.flush_buf().and_then(|()| self.inner.get_mut_ref().flush())\n+        self.flush_buf().and_then(|()| self.inner.as_mut().unwrap().flush())\n     }\n }\n \n@@ -273,7 +273,7 @@ impl<W> InternalBufferedWriter<W> {\n \n impl<W: Reader> Reader for InternalBufferedWriter<W> {\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n-        self.get_mut().inner.get_mut_ref().read(buf)\n+        self.get_mut().inner.as_mut().unwrap().read(buf)\n     }\n }\n "}, {"sha": "a93f9826fa56b89def4a3aca4c7ddce33033f642", "filename": "src/libstd/io/extensions.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/81d1feb9804f66034df4f218cc8fb0209c7450a7/src%2Flibstd%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81d1feb9804f66034df4f218cc8fb0209c7450a7/src%2Flibstd%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fextensions.rs?ref=81d1feb9804f66034df4f218cc8fb0209c7450a7", "patch": "@@ -16,13 +16,14 @@\n // FIXME: Iteration should probably be considered separately\n \n use collections::{Collection, MutableSeq};\n+use io::{IoError, IoResult, Reader};\n+use io;\n use iter::Iterator;\n+use num::Int;\n use option::{Option, Some, None};\n+use ptr::RawPtr;\n use result::{Ok, Err};\n-use io;\n-use io::{IoError, IoResult, Reader};\n use slice::{ImmutableSlice, Slice};\n-use ptr::RawPtr;\n \n /// An iterator that reads a single byte on each iteration,\n /// until `.read_byte()` returns `EndOfFile`.\n@@ -76,16 +77,15 @@ impl<'r, R: Reader> Iterator<IoResult<u8>> for Bytes<'r, R> {\n ///\n /// This function returns the value returned by the callback, for convenience.\n pub fn u64_to_le_bytes<T>(n: u64, size: uint, f: |v: &[u8]| -> T) -> T {\n-    use mem::{to_le16, to_le32, to_le64};\n     use mem::transmute;\n \n     // LLVM fails to properly optimize this when using shifts instead of the to_le* intrinsics\n     assert!(size <= 8u);\n     match size {\n       1u => f(&[n as u8]),\n-      2u => f(unsafe { transmute::<_, [u8, ..2]>(to_le16(n as u16)) }),\n-      4u => f(unsafe { transmute::<_, [u8, ..4]>(to_le32(n as u32)) }),\n-      8u => f(unsafe { transmute::<_, [u8, ..8]>(to_le64(n)) }),\n+      2u => f(unsafe { transmute::<_, [u8, ..2]>((n as u16).to_le()) }),\n+      4u => f(unsafe { transmute::<_, [u8, ..4]>((n as u32).to_le()) }),\n+      8u => f(unsafe { transmute::<_, [u8, ..8]>(n.to_le()) }),\n       _ => {\n \n         let mut bytes = vec!();\n@@ -116,16 +116,15 @@ pub fn u64_to_le_bytes<T>(n: u64, size: uint, f: |v: &[u8]| -> T) -> T {\n ///\n /// This function returns the value returned by the callback, for convenience.\n pub fn u64_to_be_bytes<T>(n: u64, size: uint, f: |v: &[u8]| -> T) -> T {\n-    use mem::{to_be16, to_be32, to_be64};\n     use mem::transmute;\n \n     // LLVM fails to properly optimize this when using shifts instead of the to_be* intrinsics\n     assert!(size <= 8u);\n     match size {\n       1u => f(&[n as u8]),\n-      2u => f(unsafe { transmute::<_, [u8, ..2]>(to_be16(n as u16)) }),\n-      4u => f(unsafe { transmute::<_, [u8, ..4]>(to_be32(n as u32)) }),\n-      8u => f(unsafe { transmute::<_, [u8, ..8]>(to_be64(n)) }),\n+      2u => f(unsafe { transmute::<_, [u8, ..2]>((n as u16).to_be()) }),\n+      4u => f(unsafe { transmute::<_, [u8, ..4]>((n as u32).to_be()) }),\n+      8u => f(unsafe { transmute::<_, [u8, ..8]>(n.to_be()) }),\n       _ => {\n         let mut bytes = vec!();\n         let mut i = size;\n@@ -152,7 +151,6 @@ pub fn u64_to_be_bytes<T>(n: u64, size: uint, f: |v: &[u8]| -> T) -> T {\n ///           32-bit value is parsed.\n pub fn u64_from_be_bytes(data: &[u8], start: uint, size: uint) -> u64 {\n     use ptr::{copy_nonoverlapping_memory};\n-    use mem::from_be64;\n     use slice::MutableSlice;\n \n     assert!(size <= 8u);\n@@ -166,7 +164,7 @@ pub fn u64_from_be_bytes(data: &[u8], start: uint, size: uint) -> u64 {\n         let ptr = data.as_ptr().offset(start as int);\n         let out = buf.as_mut_ptr();\n         copy_nonoverlapping_memory(out.offset((8 - size) as int), ptr, size);\n-        from_be64(*(out as *const u64))\n+        (*(out as *const u64)).to_be()\n     }\n }\n "}, {"sha": "6eb7d1c02fbc7b47942a4fdcd90ce8b4fd11900f", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/81d1feb9804f66034df4f218cc8fb0209c7450a7/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81d1feb9804f66034df4f218cc8fb0209c7450a7/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=81d1feb9804f66034df4f218cc8fb0209c7450a7", "patch": "@@ -103,7 +103,12 @@ impl<'a> Parser<'a> {\n     // Commit only if parser read till EOF\n     fn read_till_eof<T>(&mut self, cb: |&mut Parser| -> Option<T>)\n                      -> Option<T> {\n-        self.read_atomically(|p| cb(p).filtered(|_| p.is_eof()))\n+        self.read_atomically(|p| {\n+            match cb(p) {\n+                Some(x) => if p.is_eof() {Some(x)} else {None},\n+                None => None,\n+            }\n+        })\n     }\n \n     // Return result of first successful parser\n@@ -152,7 +157,10 @@ impl<'a> Parser<'a> {\n     // Return char and advance iff next char is equal to requested\n     fn read_given_char(&mut self, c: char) -> Option<char> {\n         self.read_atomically(|p| {\n-            p.read_char().filtered(|&next| next == c)\n+            match p.read_char() {\n+                Some(next) if next == c => Some(next),\n+                _ => None,\n+            }\n         })\n     }\n \n@@ -232,8 +240,8 @@ impl<'a> Parser<'a> {\n         fn ipv6_addr_from_head_tail(head: &[u16], tail: &[u16]) -> IpAddr {\n             assert!(head.len() + tail.len() <= 8);\n             let mut gs = [0u16, ..8];\n-            gs.copy_from(head);\n-            gs.slice_mut(8 - tail.len(), 8).copy_from(tail);\n+            gs.clone_from_slice(head);\n+            gs.slice_mut(8 - tail.len(), 8).clone_from_slice(tail);\n             Ipv6Addr(gs[0], gs[1], gs[2], gs[3], gs[4], gs[5], gs[6], gs[7])\n         }\n "}, {"sha": "9d6713b25b7248452ca2fc8c5bccd157390db88b", "filename": "src/libstd/io/tempfile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81d1feb9804f66034df4f218cc8fb0209c7450a7/src%2Flibstd%2Fio%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81d1feb9804f66034df4f218cc8fb0209c7450a7/src%2Flibstd%2Fio%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftempfile.rs?ref=81d1feb9804f66034df4f218cc8fb0209c7450a7", "patch": "@@ -79,7 +79,7 @@ impl TempDir {\n \n     /// Access the wrapped `std::path::Path` to the temporary directory.\n     pub fn path<'a>(&'a self) -> &'a Path {\n-        self.path.get_ref()\n+        self.path.as_ref().unwrap()\n     }\n \n     /// Close and remove the temporary directory"}, {"sha": "299e41f72191d148504886ec52537afceeb4be2f", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81d1feb9804f66034df4f218cc8fb0209c7450a7/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81d1feb9804f66034df4f218cc8fb0209c7450a7/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=81d1feb9804f66034df4f218cc8fb0209c7450a7", "patch": "@@ -112,7 +112,6 @@\n // Don't link to std. We are std.\n #![no_std]\n \n-#![allow(deprecated)]\n #![deny(missing_doc)]\n \n #![reexport_test_harness_main = \"test_main\"]"}, {"sha": "594a1cd131aaafaac706d06e95803a1b5ba3f23b", "filename": "src/libstd/os.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/81d1feb9804f66034df4f218cc8fb0209c7450a7/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81d1feb9804f66034df4f218cc8fb0209c7450a7/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=81d1feb9804f66034df4f218cc8fb0209c7450a7", "patch": "@@ -276,17 +276,18 @@ pub fn env_as_bytes() -> Vec<(Vec<u8>,Vec<u8>)> {\n             extern {\n                 fn rust_env_pairs() -> *const *const c_char;\n             }\n-            let environ = rust_env_pairs();\n+            let mut environ = rust_env_pairs();\n             if environ as uint == 0 {\n                 fail!(\"os::env() failure getting env string from OS: {}\",\n                        os::last_os_error());\n             }\n             let mut result = Vec::new();\n-            ptr::array_each(environ, |e| {\n+            while *environ != 0 as *const _ {\n                 let env_pair =\n-                    Vec::from_slice(CString::new(e, false).as_bytes_no_nul());\n+                    Vec::from_slice(CString::new(*environ, false).as_bytes_no_nul());\n                 result.push(env_pair);\n-            });\n+                environ = environ.offset(1);\n+            }\n             result\n         }\n "}, {"sha": "7d3c7ea71f6766a170aa582484a50925f5c83e7a", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81d1feb9804f66034df4f218cc8fb0209c7450a7/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81d1feb9804f66034df4f218cc8fb0209c7450a7/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=81d1feb9804f66034df4f218cc8fb0209c7450a7", "patch": "@@ -264,7 +264,7 @@ impl GenericPath for Path {\n \n     #[inline]\n     fn is_absolute(&self) -> bool {\n-        *self.repr.get(0) == SEP_BYTE\n+        self.repr[0] == SEP_BYTE\n     }\n \n     fn is_ancestor_of(&self, other: &Path) -> bool {\n@@ -409,7 +409,7 @@ impl Path {\n     /// /a/b/c and a/b/c yield the same set of components.\n     /// A path of \"/\" yields no components. A path of \".\" yields one component.\n     pub fn components<'a>(&'a self) -> Components<'a> {\n-        let v = if *self.repr.get(0) == SEP_BYTE {\n+        let v = if self.repr[0] == SEP_BYTE {\n             self.repr.slice_from(1)\n         } else { self.repr.as_slice() };\n         let mut ret = v.split(is_sep_byte);"}, {"sha": "e703bfae61089f6e08c5fbb53627d0771ab2d160", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/81d1feb9804f66034df4f218cc8fb0209c7450a7/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81d1feb9804f66034df4f218cc8fb0209c7450a7/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=81d1feb9804f66034df4f218cc8fb0209c7450a7", "patch": "@@ -264,10 +264,10 @@ impl GenericPathUnsafe for Path {\n             let repr = me.repr.as_slice();\n             match me.prefix {\n                 Some(DiskPrefix) => {\n-                    repr.as_bytes()[0] == path.as_bytes()[0].to_ascii().to_upper().to_byte()\n+                    repr.as_bytes()[0] == path.as_bytes()[0].to_ascii().to_uppercase().to_byte()\n                 }\n                 Some(VerbatimDiskPrefix) => {\n-                    repr.as_bytes()[4] == path.as_bytes()[0].to_ascii().to_upper().to_byte()\n+                    repr.as_bytes()[4] == path.as_bytes()[0].to_ascii().to_uppercase().to_byte()\n                 }\n                 _ => false\n             }\n@@ -776,9 +776,9 @@ impl Path {\n                                 let mut s = String::from_str(s.slice_to(len));\n                                 unsafe {\n                                     let v = s.as_mut_vec();\n-                                    *v.get_mut(0) = v.get(0)\n+                                    *v.get_mut(0) = (*v)[0]\n                                                      .to_ascii()\n-                                                     .to_upper()\n+                                                     .to_uppercase()\n                                                      .to_byte();\n                                 }\n                                 if is_abs {\n@@ -794,7 +794,7 @@ impl Path {\n                                 let mut s = String::from_str(s.slice_to(len));\n                                 unsafe {\n                                     let v = s.as_mut_vec();\n-                                    *v.get_mut(4) = v.get(4).to_ascii().to_upper().to_byte();\n+                                    *v.get_mut(4) = (*v)[4].to_ascii().to_uppercase().to_byte();\n                                 }\n                                 Some(s)\n                             }\n@@ -815,12 +815,12 @@ impl Path {\n                         let mut s = String::with_capacity(n);\n                         match prefix {\n                             Some(DiskPrefix) => {\n-                                s.push_char(prefix_.as_bytes()[0].to_ascii().to_upper().to_char());\n+                                s.push_char(prefix_.as_bytes()[0].to_ascii().to_uppercase().to_char());\n                                 s.push_char(':');\n                             }\n                             Some(VerbatimDiskPrefix) => {\n                                 s.push_str(prefix_.slice_to(4));\n-                                s.push_char(prefix_.as_bytes()[4].to_ascii().to_upper().to_char());\n+                                s.push_char(prefix_.as_bytes()[4].to_ascii().to_uppercase().to_char());\n                                 s.push_str(prefix_.slice_from(5));\n                             }\n                             Some(UNCPrefix(a,b)) => {"}, {"sha": "a00eeb1f938389afb640722cf94cf25abbec8ba4", "filename": "src/libstd/sync/task_pool.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81d1feb9804f66034df4f218cc8fb0209c7450a7/src%2Flibstd%2Fsync%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81d1feb9804f66034df4f218cc8fb0209c7450a7/src%2Flibstd%2Fsync%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ftask_pool.rs?ref=81d1feb9804f66034df4f218cc8fb0209c7450a7", "patch": "@@ -79,7 +79,7 @@ impl<T> TaskPool<T> {\n     /// Executes the function `f` on a task in the pool. The function\n     /// receives a reference to the local data returned by the `init_fn`.\n     pub fn execute(&mut self, f: proc(&T):Send) {\n-        self.channels.get(self.next_index).send(Execute(f));\n+        self.channels[self.next_index].send(Execute(f));\n         self.next_index += 1;\n         if self.next_index == self.channels.len() { self.next_index = 0; }\n     }"}]}