{"sha": "903427b2e807cb1292388940b3f44f3b061cfebf", "node_id": "C_kwDOAAsO6NoAKDkwMzQyN2IyZTgwN2NiMTI5MjM4ODk0MGIzZjQ0ZjNiMDYxY2ZlYmY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-25T11:35:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-25T11:35:19Z"}, "message": "Auto merge of #95255 - petrochenkov:suggresolve, r=michaelwoerister\n\nresolve: Do not build expensive suggestions if they are not actually used\n\nAnd remove a bunch of (conditionally) unused parameters from path resolution functions.\n\nThis helps with performance issues in https://github.com/rust-lang/rust/pull/94857, and should be helpful in general even without that.", "tree": {"sha": "61110571592368f1de2628ecb54b53de9a19c28c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/61110571592368f1de2628ecb54b53de9a19c28c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/903427b2e807cb1292388940b3f44f3b061cfebf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/903427b2e807cb1292388940b3f44f3b061cfebf", "html_url": "https://github.com/rust-lang/rust/commit/903427b2e807cb1292388940b3f44f3b061cfebf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/903427b2e807cb1292388940b3f44f3b061cfebf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e70e211e99b3b7a4c3d75ff56598662530828f65", "url": "https://api.github.com/repos/rust-lang/rust/commits/e70e211e99b3b7a4c3d75ff56598662530828f65", "html_url": "https://github.com/rust-lang/rust/commit/e70e211e99b3b7a4c3d75ff56598662530828f65"}, {"sha": "1ad64a23d4dc99df9cea4b1394d05538f0ccc86a", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ad64a23d4dc99df9cea4b1394d05538f0ccc86a", "html_url": "https://github.com/rust-lang/rust/commit/1ad64a23d4dc99df9cea4b1394d05538f0ccc86a"}], "stats": {"total": 1281, "additions": 457, "deletions": 824}, "files": [{"sha": "34218e87b51a60a0336b18565f2eeb8069956123", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/903427b2e807cb1292388940b3f44f3b061cfebf/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/903427b2e807cb1292388940b3f44f3b061cfebf/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=903427b2e807cb1292388940b3f44f3b061cfebf", "patch": "@@ -9,7 +9,7 @@ use crate::def_collector::collect_definitions;\n use crate::imports::{Import, ImportKind};\n use crate::macros::{MacroRulesBinding, MacroRulesScope, MacroRulesScopeRef};\n use crate::Namespace::{self, MacroNS, TypeNS, ValueNS};\n-use crate::{CrateLint, Determinacy, ExternPreludeEntry, Module, ModuleKind, ModuleOrUniformRoot};\n+use crate::{Determinacy, ExternPreludeEntry, Finalize, Module, ModuleKind, ModuleOrUniformRoot};\n use crate::{NameBinding, NameBindingKind, ParentScope, PathResult, PerNS, ResolutionError};\n use crate::{Resolver, ResolverArenas, Segment, ToNameBinding, VisResolutionError};\n \n@@ -235,16 +235,16 @@ impl<'a> AsMut<Resolver<'a>> for BuildReducedGraphVisitor<'a, '_> {\n \n impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n     fn resolve_visibility(&mut self, vis: &ast::Visibility) -> ty::Visibility {\n-        self.resolve_visibility_speculative(vis, false).unwrap_or_else(|err| {\n+        self.try_resolve_visibility(vis, true).unwrap_or_else(|err| {\n             self.r.report_vis_error(err);\n             ty::Visibility::Public\n         })\n     }\n \n-    fn resolve_visibility_speculative<'ast>(\n+    fn try_resolve_visibility<'ast>(\n         &mut self,\n         vis: &'ast ast::Visibility,\n-        speculative: bool,\n+        finalize: bool,\n     ) -> Result<ty::Visibility, VisResolutionError<'ast>> {\n         let parent_scope = &self.parent_scope;\n         match vis.kind {\n@@ -296,13 +296,11 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                     &segments,\n                     Some(TypeNS),\n                     parent_scope,\n-                    !speculative,\n-                    path.span,\n-                    CrateLint::SimplePath(id),\n+                    if finalize { Finalize::SimplePath(id, path.span) } else { Finalize::No },\n                 ) {\n                     PathResult::Module(ModuleOrUniformRoot::Module(module)) => {\n                         let res = module.res().expect(\"visibility resolved to unnamed block\");\n-                        if !speculative {\n+                        if finalize {\n                             self.r.record_partial_res(id, PartialRes::new(res));\n                         }\n                         if module.is_normal() {\n@@ -772,7 +770,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                         // correct visibilities for unnamed field placeholders specifically, so the\n                         // constructor visibility should still be determined correctly.\n                         let field_vis = self\n-                            .resolve_visibility_speculative(&field.vis, true)\n+                            .try_resolve_visibility(&field.vis, false)\n                             .unwrap_or(ty::Visibility::Public);\n                         if ctor_vis.is_at_least(field_vis, &*self.r) {\n                             ctor_vis = field_vis;\n@@ -1131,8 +1129,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                     ident,\n                     MacroNS,\n                     &self.parent_scope,\n-                    false,\n-                    ident.span,\n+                    None,\n                 );\n                 if let Ok(binding) = result {\n                     let import = macro_use_import(self, ident.span);\n@@ -1272,9 +1269,9 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             let vis = match item.kind {\n                 // Visibilities must not be resolved non-speculatively twice\n                 // and we already resolved this one as a `fn` item visibility.\n-                ItemKind::Fn(..) => self\n-                    .resolve_visibility_speculative(&item.vis, true)\n-                    .unwrap_or(ty::Visibility::Public),\n+                ItemKind::Fn(..) => {\n+                    self.try_resolve_visibility(&item.vis, false).unwrap_or(ty::Visibility::Public)\n+                }\n                 _ => self.resolve_visibility(&item.vis),\n             };\n             if vis != ty::Visibility::Public {"}, {"sha": "d1685006881d5c3aa783b865ec55ce0c54b58a54", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/903427b2e807cb1292388940b3f44f3b061cfebf/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/903427b2e807cb1292388940b3f44f3b061cfebf/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=903427b2e807cb1292388940b3f44f3b061cfebf", "patch": "@@ -24,10 +24,8 @@ use tracing::debug;\n use crate::imports::{Import, ImportKind, ImportResolver};\n use crate::path_names_to_string;\n use crate::{AmbiguityError, AmbiguityErrorMisc, AmbiguityKind};\n-use crate::{\n-    BindingError, CrateLint, HasGenericParams, MacroRulesScope, Module, ModuleOrUniformRoot,\n-};\n-use crate::{NameBinding, NameBindingKind, PrivacyError, VisResolutionError};\n+use crate::{BindingError, HasGenericParams, MacroRulesScope, Module, ModuleOrUniformRoot};\n+use crate::{Finalize, NameBinding, NameBindingKind, PrivacyError, VisResolutionError};\n use crate::{ParentScope, PathResult, ResolutionError, Resolver, Scope, ScopeSet, Segment};\n \n type Res = def::Res<ast::NodeId>;\n@@ -1076,9 +1074,8 @@ impl<'a> Resolver<'a> {\n                 ident,\n                 ScopeSet::All(ns, false),\n                 &parent_scope,\n+                None,\n                 false,\n-                false,\n-                ident.span,\n             ) {\n                 let desc = match binding.res() {\n                     Res::Def(DefKind::Macro(MacroKind::Bang), _) => {\n@@ -1405,10 +1402,10 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             _ => return None,\n         }\n \n-        self.make_missing_self_suggestion(span, path.clone(), parent_scope)\n-            .or_else(|| self.make_missing_crate_suggestion(span, path.clone(), parent_scope))\n-            .or_else(|| self.make_missing_super_suggestion(span, path.clone(), parent_scope))\n-            .or_else(|| self.make_external_crate_suggestion(span, path, parent_scope))\n+        self.make_missing_self_suggestion(path.clone(), parent_scope)\n+            .or_else(|| self.make_missing_crate_suggestion(path.clone(), parent_scope))\n+            .or_else(|| self.make_missing_super_suggestion(path.clone(), parent_scope))\n+            .or_else(|| self.make_external_crate_suggestion(path, parent_scope))\n     }\n \n     /// Suggest a missing `self::` if that resolves to an correct module.\n@@ -1420,13 +1417,12 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     /// ```\n     fn make_missing_self_suggestion(\n         &mut self,\n-        span: Span,\n         mut path: Vec<Segment>,\n         parent_scope: &ParentScope<'b>,\n     ) -> Option<(Vec<Segment>, Vec<String>)> {\n         // Replace first ident with `self` and check if that is valid.\n         path[0].ident.name = kw::SelfLower;\n-        let result = self.r.resolve_path(&path, None, parent_scope, false, span, CrateLint::No);\n+        let result = self.r.resolve_path(&path, None, parent_scope, Finalize::No);\n         debug!(\"make_missing_self_suggestion: path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result { Some((path, Vec::new())) } else { None }\n     }\n@@ -1440,13 +1436,12 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     /// ```\n     fn make_missing_crate_suggestion(\n         &mut self,\n-        span: Span,\n         mut path: Vec<Segment>,\n         parent_scope: &ParentScope<'b>,\n     ) -> Option<(Vec<Segment>, Vec<String>)> {\n         // Replace first ident with `crate` and check if that is valid.\n         path[0].ident.name = kw::Crate;\n-        let result = self.r.resolve_path(&path, None, parent_scope, false, span, CrateLint::No);\n+        let result = self.r.resolve_path(&path, None, parent_scope, Finalize::No);\n         debug!(\"make_missing_crate_suggestion:  path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result {\n             Some((\n@@ -1472,13 +1467,12 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     /// ```\n     fn make_missing_super_suggestion(\n         &mut self,\n-        span: Span,\n         mut path: Vec<Segment>,\n         parent_scope: &ParentScope<'b>,\n     ) -> Option<(Vec<Segment>, Vec<String>)> {\n         // Replace first ident with `crate` and check if that is valid.\n         path[0].ident.name = kw::Super;\n-        let result = self.r.resolve_path(&path, None, parent_scope, false, span, CrateLint::No);\n+        let result = self.r.resolve_path(&path, None, parent_scope, Finalize::No);\n         debug!(\"make_missing_super_suggestion:  path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result { Some((path, Vec::new())) } else { None }\n     }\n@@ -1495,7 +1489,6 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     /// name as the first part of path.\n     fn make_external_crate_suggestion(\n         &mut self,\n-        span: Span,\n         mut path: Vec<Segment>,\n         parent_scope: &ParentScope<'b>,\n     ) -> Option<(Vec<Segment>, Vec<String>)> {\n@@ -1513,7 +1506,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         for name in extern_crate_names.into_iter() {\n             // Replace first ident with a crate name and check if that is valid.\n             path[0].ident.name = name;\n-            let result = self.r.resolve_path(&path, None, parent_scope, false, span, CrateLint::No);\n+            let result = self.r.resolve_path(&path, None, parent_scope, Finalize::No);\n             debug!(\n                 \"make_external_crate_suggestion: name={:?} path={:?} result={:?}\",\n                 name, path, result"}, {"sha": "4f0dad13b5bbeed1540b9d0d3d3ac59ab05ed967", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 30, "deletions": 67, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/903427b2e807cb1292388940b3f44f3b061cfebf/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/903427b2e807cb1292388940b3f44f3b061cfebf/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=903427b2e807cb1292388940b3f44f3b061cfebf", "patch": "@@ -6,7 +6,7 @@ use crate::Namespace::{self, MacroNS, TypeNS};\n use crate::{module_to_string, names_to_string};\n use crate::{AmbiguityError, AmbiguityErrorMisc, AmbiguityKind};\n use crate::{BindingKey, ModuleKind, ResolutionError, Resolver, Segment};\n-use crate::{CrateLint, Module, ModuleOrUniformRoot, ParentScope, PerNS, ScopeSet, Weak};\n+use crate::{Finalize, Module, ModuleOrUniformRoot, ParentScope, PerNS, ScopeSet, Weak};\n use crate::{NameBinding, NameBindingKind, PathResult, PrivacyError, ToNameBinding};\n \n use rustc_ast::NodeId;\n@@ -123,10 +123,6 @@ impl<'a> Import<'a> {\n             _ => false,\n         }\n     }\n-\n-    crate fn crate_lint(&self) -> CrateLint {\n-        CrateLint::UsePath { root_id: self.root_id, root_span: self.root_span }\n-    }\n }\n \n #[derive(Clone, Default, Debug)]\n@@ -179,32 +175,29 @@ impl<'a> Resolver<'a> {\n         ident: Ident,\n         ns: Namespace,\n         parent_scope: &ParentScope<'a>,\n-        record_used: bool,\n-        path_span: Span,\n+        finalize: Option<Span>,\n     ) -> Result<&'a NameBinding<'a>, Determinacy> {\n         self.resolve_ident_in_module_unadjusted_ext(\n             module,\n             ident,\n             ns,\n             parent_scope,\n             false,\n-            record_used,\n-            path_span,\n+            finalize,\n         )\n         .map_err(|(determinacy, _)| determinacy)\n     }\n \n     /// Attempts to resolve `ident` in namespaces `ns` of `module`.\n-    /// Invariant: if `record_used` is `Some`, expansion and import resolution must be complete.\n+    /// Invariant: if `finalize` is `Some`, expansion and import resolution must be complete.\n     crate fn resolve_ident_in_module_unadjusted_ext(\n         &mut self,\n         module: ModuleOrUniformRoot<'a>,\n         ident: Ident,\n         ns: Namespace,\n         parent_scope: &ParentScope<'a>,\n         restricted_shadowing: bool,\n-        record_used: bool,\n-        path_span: Span,\n+        finalize: Option<Span>,\n     ) -> Result<&'a NameBinding<'a>, (Determinacy, Weak)> {\n         let module = match module {\n             ModuleOrUniformRoot::Module(module) => module,\n@@ -214,17 +207,16 @@ impl<'a> Resolver<'a> {\n                     ident,\n                     ScopeSet::AbsolutePath(ns),\n                     parent_scope,\n-                    record_used,\n-                    record_used,\n-                    path_span,\n+                    finalize,\n+                    finalize.is_some(),\n                 );\n                 return binding.map_err(|determinacy| (determinacy, Weak::No));\n             }\n             ModuleOrUniformRoot::ExternPrelude => {\n                 assert!(!restricted_shadowing);\n                 return if ns != TypeNS {\n                     Err((Determined, Weak::No))\n-                } else if let Some(binding) = self.extern_prelude_get(ident, !record_used) {\n+                } else if let Some(binding) = self.extern_prelude_get(ident, finalize.is_some()) {\n                     Ok(binding)\n                 } else if !self.graph_root.unexpanded_invocations.borrow().is_empty() {\n                     // Macro-expanded `extern crate` items can add names to extern prelude.\n@@ -254,9 +246,8 @@ impl<'a> Resolver<'a> {\n                     ident,\n                     scopes,\n                     parent_scope,\n-                    record_used,\n-                    record_used,\n-                    path_span,\n+                    finalize,\n+                    finalize.is_some(),\n                 );\n                 return binding.map_err(|determinacy| (determinacy, Weak::No));\n             }\n@@ -266,7 +257,7 @@ impl<'a> Resolver<'a> {\n         let resolution =\n             self.resolution(module, key).try_borrow_mut().map_err(|_| (Determined, Weak::No))?; // This happens when there is a cycle of imports.\n \n-        if let Some(binding) = resolution.binding {\n+        if let Some(binding) = resolution.binding && let Some(path_span) = finalize {\n             if !restricted_shadowing && binding.expansion != LocalExpnId::ROOT {\n                 if let NameBindingKind::Res(_, true) = binding.kind {\n                     self.macro_expanded_macro_export_errors.insert((path_span, binding.span));\n@@ -284,7 +275,7 @@ impl<'a> Resolver<'a> {\n             if usable { Ok(binding) } else { Err((Determined, Weak::No)) }\n         };\n \n-        if record_used {\n+        if let Some(path_span) = finalize {\n             return resolution\n                 .binding\n                 .and_then(|binding| {\n@@ -357,14 +348,8 @@ impl<'a> Resolver<'a> {\n             let ImportKind::Single { source: ident, .. } = single_import.kind else {\n                 unreachable!();\n             };\n-            match self.resolve_ident_in_module(\n-                module,\n-                ident,\n-                ns,\n-                &single_import.parent_scope,\n-                false,\n-                path_span,\n-            ) {\n+            match self.resolve_ident_in_module(module, ident, ns, &single_import.parent_scope, None)\n+            {\n                 Err(Determined) => continue,\n                 Ok(binding)\n                     if !self.is_accessible_from(binding.vis, single_import.parent_scope.module) =>\n@@ -438,8 +423,7 @@ impl<'a> Resolver<'a> {\n                 ident,\n                 ns,\n                 adjusted_parent_scope,\n-                false,\n-                path_span,\n+                None,\n             );\n \n             match result {\n@@ -787,14 +771,8 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             // For better failure detection, pretend that the import will\n             // not define any names while resolving its module path.\n             let orig_vis = import.vis.replace(ty::Visibility::Invisible);\n-            let path_res = self.r.resolve_path(\n-                &import.module_path,\n-                None,\n-                &import.parent_scope,\n-                false,\n-                import.span,\n-                import.crate_lint(),\n-            );\n+            let path_res =\n+                self.r.resolve_path(&import.module_path, None, &import.parent_scope, Finalize::No);\n             import.vis.set(orig_vis);\n \n             match path_res {\n@@ -833,8 +811,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                         source,\n                         ns,\n                         &import.parent_scope,\n-                        false,\n-                        import.span,\n+                        None,\n                     );\n                     import.vis.set(orig_vis);\n                     source_bindings[ns].set(binding);\n@@ -887,14 +864,13 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             _ => None,\n         };\n         let prev_ambiguity_errors_len = self.r.ambiguity_errors.len();\n-        let path_res = self.r.resolve_path(\n-            &import.module_path,\n-            None,\n-            &import.parent_scope,\n-            true,\n-            import.span,\n-            import.crate_lint(),\n-        );\n+        let finalize = Finalize::UsePath {\n+            root_id: import.root_id,\n+            root_span: import.root_span,\n+            path_span: import.span,\n+        };\n+        let path_res =\n+            self.r.resolve_path(&import.module_path, None, &import.parent_scope, finalize);\n         let no_ambiguity = self.r.ambiguity_errors.len() == prev_ambiguity_errors_len;\n         if let Some(orig_unusable_binding) = orig_unusable_binding {\n             self.r.unusable_binding = orig_unusable_binding;\n@@ -981,12 +957,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                     // 2 segments, so the `resolve_path` above won't trigger it.\n                     let mut full_path = import.module_path.clone();\n                     full_path.push(Segment::from_ident(Ident::empty()));\n-                    self.r.lint_if_path_starts_with_module(\n-                        import.crate_lint(),\n-                        &full_path,\n-                        import.span,\n-                        None,\n-                    );\n+                    self.r.lint_if_path_starts_with_module(finalize, &full_path, None);\n                 }\n \n                 if let ModuleOrUniformRoot::Module(module) = module {\n@@ -1024,8 +995,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                     ident,\n                     ns,\n                     &import.parent_scope,\n-                    true,\n-                    import.span,\n+                    Some(import.span),\n                 );\n                 this.last_import_segment = orig_last_import_segment;\n                 this.unusable_binding = orig_unusable_binding;\n@@ -1086,8 +1056,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                         ident,\n                         ns,\n                         &import.parent_scope,\n-                        true,\n-                        import.span,\n+                        Some(import.span),\n                     );\n                     if binding.is_ok() {\n                         all_ns_failed = false;\n@@ -1253,12 +1222,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             full_path.push(Segment::from_ident(ident));\n             self.r.per_ns(|this, ns| {\n                 if let Ok(binding) = source_bindings[ns].get() {\n-                    this.lint_if_path_starts_with_module(\n-                        import.crate_lint(),\n-                        &full_path,\n-                        import.span,\n-                        Some(binding),\n-                    );\n+                    this.lint_if_path_starts_with_module(finalize, &full_path, Some(binding));\n                 }\n             });\n         }\n@@ -1314,9 +1278,8 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                     target,\n                     ScopeSet::All(ns, false),\n                     &import.parent_scope,\n+                    None,\n                     false,\n-                    false,\n-                    import.span,\n                 ) {\n                     Ok(other_binding) => {\n                         is_redundant[ns] = Some("}, {"sha": "bb05a3d7510e1f465046237c2d280f6a839253e5", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 53, "deletions": 85, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/903427b2e807cb1292388940b3f44f3b061cfebf/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/903427b2e807cb1292388940b3f44f3b061cfebf/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=903427b2e807cb1292388940b3f44f3b061cfebf", "patch": "@@ -7,7 +7,7 @@\n \n use RibKind::*;\n \n-use crate::{path_names_to_string, BindingError, CrateLint, LexicalScopeBinding};\n+use crate::{path_names_to_string, BindingError, Finalize, LexicalScopeBinding};\n use crate::{Module, ModuleOrUniformRoot, ParentScope, PathResult};\n use crate::{ResolutionError, Resolver, Segment, UseError};\n \n@@ -483,7 +483,11 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n             TyKind::ImplicitSelf => {\n                 let self_ty = Ident::with_dummy_span(kw::SelfUpper);\n                 let res = self\n-                    .resolve_ident_in_lexical_scope(self_ty, TypeNS, Some(ty.id), ty.span)\n+                    .resolve_ident_in_lexical_scope(\n+                        self_ty,\n+                        TypeNS,\n+                        Finalize::SimplePath(ty.id, ty.span),\n+                    )\n                     .map_or(Res::Err, |d| d.res());\n                 self.r.record_partial_res(ty.id, PartialRes::new(res));\n             }\n@@ -675,8 +679,7 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                             self.resolve_ident_in_lexical_scope(\n                                 path.segments[0].ident,\n                                 ns,\n-                                None,\n-                                path.span,\n+                                Finalize::No,\n                             )\n                             .is_some()\n                         };\n@@ -751,15 +754,13 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         &mut self,\n         ident: Ident,\n         ns: Namespace,\n-        record_used_id: Option<NodeId>,\n-        path_span: Span,\n+        finalize: Finalize,\n     ) -> Option<LexicalScopeBinding<'a>> {\n         self.r.resolve_ident_in_lexical_scope(\n             ident,\n             ns,\n             &self.parent_scope,\n-            record_used_id,\n-            path_span,\n+            finalize,\n             &self.ribs[ns],\n         )\n     }\n@@ -768,19 +769,9 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         &mut self,\n         path: &[Segment],\n         opt_ns: Option<Namespace>, // `None` indicates a module path in import\n-        record_used: bool,\n-        path_span: Span,\n-        crate_lint: CrateLint,\n+        finalize: Finalize,\n     ) -> PathResult<'a> {\n-        self.r.resolve_path_with_ribs(\n-            path,\n-            opt_ns,\n-            &self.parent_scope,\n-            record_used,\n-            path_span,\n-            crate_lint,\n-            Some(&self.ribs),\n-        )\n+        self.r.resolve_path_with_ribs(path, opt_ns, &self.parent_scope, finalize, Some(&self.ribs))\n     }\n \n     // AST resolution\n@@ -943,15 +934,15 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             };\n \n             for &ns in nss {\n-                match self.resolve_ident_in_lexical_scope(ident, ns, None, use_tree.prefix.span) {\n+                match self.resolve_ident_in_lexical_scope(ident, ns, Finalize::No) {\n                     Some(LexicalScopeBinding::Res(..)) => {\n                         report_error(self, ns);\n                     }\n                     Some(LexicalScopeBinding::Item(binding)) => {\n                         let orig_unusable_binding =\n                             replace(&mut self.r.unusable_binding, Some(binding));\n-                        if let Some(LexicalScopeBinding::Res(..)) = self\n-                            .resolve_ident_in_lexical_scope(ident, ns, None, use_tree.prefix.span)\n+                        if let Some(LexicalScopeBinding::Res(..)) =\n+                            self.resolve_ident_in_lexical_scope(ident, ns, Finalize::No)\n                         {\n                             report_error(self, ns);\n                         }\n@@ -1246,25 +1237,14 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         if let Some(trait_ref) = opt_trait_ref {\n             let path: Vec<_> = Segment::from_path(&trait_ref.path);\n             let res = self.smart_resolve_path_fragment(\n-                trait_ref.ref_id,\n                 None,\n                 &path,\n-                trait_ref.path.span,\n                 PathSource::Trait(AliasPossibility::No),\n-                CrateLint::SimplePath(trait_ref.ref_id),\n+                Finalize::SimplePath(trait_ref.ref_id, trait_ref.path.span),\n             );\n-            let res = res.base_res();\n-            if res != Res::Err {\n-                if let PathResult::Module(ModuleOrUniformRoot::Module(module)) = self.resolve_path(\n-                    &path,\n-                    Some(TypeNS),\n-                    true,\n-                    trait_ref.path.span,\n-                    CrateLint::SimplePath(trait_ref.ref_id),\n-                ) {\n-                    new_id = Some(res.def_id());\n-                    new_val = Some((module, trait_ref.clone()));\n-                }\n+            if let Some(def_id) = res.base_res().opt_def_id() {\n+                new_id = Some(def_id);\n+                new_val = Some((self.r.expect_module(def_id), trait_ref.clone()));\n             }\n         }\n         let original_trait_ref = replace(&mut self.current_trait_ref, new_val);\n@@ -1702,7 +1682,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     // then fall back to a fresh binding.\n                     let has_sub = sub.is_some();\n                     let res = self\n-                        .try_resolve_as_non_binding(pat_src, pat, bmode, ident, has_sub)\n+                        .try_resolve_as_non_binding(pat_src, bmode, ident, has_sub)\n                         .unwrap_or_else(|| self.fresh_binding(ident, pat.id, pat_src, bindings));\n                     self.r.record_partial_res(pat.id, PartialRes::new(res));\n                     self.r.record_pat_span(pat.id, pat.span);\n@@ -1813,7 +1793,6 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     fn try_resolve_as_non_binding(\n         &mut self,\n         pat_src: PatternSource,\n-        pat: &Pat,\n         bm: BindingMode,\n         ident: Ident,\n         has_sub: bool,\n@@ -1823,7 +1802,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         // also be interpreted as a path to e.g. a constant, variant, etc.\n         let is_syntactic_ambiguity = !has_sub && bm == BindingMode::ByValue(Mutability::Not);\n \n-        let ls_binding = self.resolve_ident_in_lexical_scope(ident, ValueNS, None, pat.span)?;\n+        let ls_binding = self.resolve_ident_in_lexical_scope(ident, ValueNS, Finalize::No)?;\n         let (res, binding) = match ls_binding {\n             LexicalScopeBinding::Item(binding)\n                 if is_syntactic_ambiguity && binding.is_ambiguity() =>\n@@ -1912,35 +1891,34 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         source: PathSource<'ast>,\n     ) {\n         self.smart_resolve_path_fragment(\n-            id,\n             qself,\n             &Segment::from_path(path),\n-            path.span,\n             source,\n-            CrateLint::SimplePath(id),\n+            Finalize::SimplePath(id, path.span),\n         );\n     }\n \n     fn smart_resolve_path_fragment(\n         &mut self,\n-        id: NodeId,\n         qself: Option<&QSelf>,\n         path: &[Segment],\n-        span: Span,\n         source: PathSource<'ast>,\n-        crate_lint: CrateLint,\n+        finalize: Finalize,\n     ) -> PartialRes {\n         tracing::debug!(\n-            \"smart_resolve_path_fragment(id={:?}, qself={:?}, path={:?})\",\n-            id,\n+            \"smart_resolve_path_fragment(qself={:?}, path={:?}, finalize={:?})\",\n             qself,\n-            path\n+            path,\n+            finalize,\n         );\n         let ns = source.namespace();\n \n+        let (id, path_span) =\n+            finalize.node_id_and_path_span().expect(\"unexpected speculative resolution\");\n         let report_errors = |this: &mut Self, res: Option<Res>| {\n             if this.should_report_errs() {\n-                let (err, candidates) = this.smart_resolve_report_errors(path, span, source, res);\n+                let (err, candidates) =\n+                    this.smart_resolve_report_errors(path, path_span, source, res);\n \n                 let def_id = this.parent_scope.module.nearest_parent_mod();\n                 let instead = res.is_some();\n@@ -1978,7 +1956,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             };\n \n             let (mut err, candidates) =\n-                this.smart_resolve_report_errors(path, span, PathSource::Type, None);\n+                this.smart_resolve_report_errors(path, path_span, PathSource::Type, None);\n \n             if candidates.is_empty() {\n                 err.cancel();\n@@ -2027,13 +2005,12 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         };\n \n         let partial_res = match self.resolve_qpath_anywhere(\n-            id,\n             qself,\n             path,\n             ns,\n-            span,\n+            path_span,\n             source.defer_to_typeck(),\n-            crate_lint,\n+            finalize,\n         ) {\n             Ok(Some(partial_res)) if partial_res.unresolved_segments() == 0 => {\n                 if source.is_expected(partial_res.base_res()) || partial_res.base_res() == Res::Err\n@@ -2060,14 +2037,14 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     std_path.push(Segment::from_ident(Ident::with_dummy_span(sym::std)));\n                     std_path.extend(path);\n                     if let PathResult::Module(_) | PathResult::NonModule(_) =\n-                        self.resolve_path(&std_path, Some(ns), false, span, CrateLint::No)\n+                        self.resolve_path(&std_path, Some(ns), Finalize::No)\n                     {\n                         // Check if we wrote `str::from_utf8` instead of `std::str::from_utf8`\n                         let item_span =\n-                            path.iter().last().map_or(span, |segment| segment.ident.span);\n+                            path.iter().last().map_or(path_span, |segment| segment.ident.span);\n \n-                        self.r.confused_type_with_std_module.insert(item_span, span);\n-                        self.r.confused_type_with_std_module.insert(span, span);\n+                        self.r.confused_type_with_std_module.insert(item_span, path_span);\n+                        self.r.confused_type_with_std_module.insert(path_span, path_span);\n                     }\n                 }\n \n@@ -2093,19 +2070,18 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         partial_res\n     }\n \n-    fn self_type_is_available(&mut self, span: Span) -> bool {\n+    fn self_type_is_available(&mut self) -> bool {\n         let binding = self.resolve_ident_in_lexical_scope(\n             Ident::with_dummy_span(kw::SelfUpper),\n             TypeNS,\n-            None,\n-            span,\n+            Finalize::No,\n         );\n         if let Some(LexicalScopeBinding::Res(res)) = binding { res != Res::Err } else { false }\n     }\n \n-    fn self_value_is_available(&mut self, self_span: Span, path_span: Span) -> bool {\n+    fn self_value_is_available(&mut self, self_span: Span) -> bool {\n         let ident = Ident::new(kw::SelfLower, self_span);\n-        let binding = self.resolve_ident_in_lexical_scope(ident, ValueNS, None, path_span);\n+        let binding = self.resolve_ident_in_lexical_scope(ident, ValueNS, Finalize::No);\n         if let Some(LexicalScopeBinding::Res(res)) = binding { res != Res::Err } else { false }\n     }\n \n@@ -2127,19 +2103,18 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     // Resolve in alternative namespaces if resolution in the primary namespace fails.\n     fn resolve_qpath_anywhere(\n         &mut self,\n-        id: NodeId,\n         qself: Option<&QSelf>,\n         path: &[Segment],\n         primary_ns: Namespace,\n         span: Span,\n         defer_to_typeck: bool,\n-        crate_lint: CrateLint,\n+        finalize: Finalize,\n     ) -> Result<Option<PartialRes>, Spanned<ResolutionError<'a>>> {\n         let mut fin_res = None;\n \n         for (i, &ns) in [primary_ns, TypeNS, ValueNS].iter().enumerate() {\n             if i == 0 || ns != primary_ns {\n-                match self.resolve_qpath(id, qself, path, ns, span, crate_lint)? {\n+                match self.resolve_qpath(qself, path, ns, finalize)? {\n                     Some(partial_res)\n                         if partial_res.unresolved_segments() == 0 || defer_to_typeck =>\n                     {\n@@ -2172,16 +2147,14 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     /// Handles paths that may refer to associated items.\n     fn resolve_qpath(\n         &mut self,\n-        id: NodeId,\n         qself: Option<&QSelf>,\n         path: &[Segment],\n         ns: Namespace,\n-        span: Span,\n-        crate_lint: CrateLint,\n+        finalize: Finalize,\n     ) -> Result<Option<PartialRes>, Spanned<ResolutionError<'a>>> {\n         debug!(\n-            \"resolve_qpath(id={:?}, qself={:?}, path={:?}, ns={:?}, span={:?})\",\n-            id, qself, path, ns, span,\n+            \"resolve_qpath(qself={:?}, path={:?}, ns={:?}, finalize={:?})\",\n+            qself, path, ns, finalize,\n         );\n \n         if let Some(qself) = qself {\n@@ -2208,15 +2181,15 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             // *actually* appears, so for the purposes of the crate\n             // lint we pass along information that this is the trait\n             // name from a fully qualified path, and this also\n-            // contains the full span (the `CrateLint::QPathTrait`).\n+            // contains the full span (the `Finalize::QPathTrait`).\n             let ns = if qself.position + 1 == path.len() { ns } else { TypeNS };\n             let partial_res = self.smart_resolve_path_fragment(\n-                id,\n                 None,\n                 &path[..=qself.position],\n-                span,\n                 PathSource::TraitItem(ns),\n-                CrateLint::QPathTrait { qpath_id: id, qpath_span: qself.path_span },\n+                finalize.node_id_and_path_span().map_or(Finalize::No, |(qpath_id, path_span)| {\n+                    Finalize::QPathTrait { qpath_id, qpath_span: qself.path_span, path_span }\n+                }),\n             );\n \n             // The remaining segments (the `C` in our example) will\n@@ -2228,7 +2201,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             )));\n         }\n \n-        let result = match self.resolve_path(&path, Some(ns), true, span, crate_lint) {\n+        let result = match self.resolve_path(&path, Some(ns), finalize) {\n             PathResult::NonModule(path_res) => path_res,\n             PathResult::Module(ModuleOrUniformRoot::Module(module)) if !module.is_normal() => {\n                 PartialRes::new(module.res().unwrap())\n@@ -2266,15 +2239,10 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             && result.base_res() != Res::Err\n             && path[0].ident.name != kw::PathRoot\n             && path[0].ident.name != kw::DollarCrate\n+            && let Some((id, path_span)) = finalize.node_id_and_path_span()\n         {\n             let unqualified_result = {\n-                match self.resolve_path(\n-                    &[*path.last().unwrap()],\n-                    Some(ns),\n-                    false,\n-                    span,\n-                    CrateLint::No,\n-                ) {\n+                match self.resolve_path(&[*path.last().unwrap()], Some(ns), Finalize::No) {\n                     PathResult::NonModule(path_res) => path_res.base_res(),\n                     PathResult::Module(ModuleOrUniformRoot::Module(module)) => {\n                         module.res().unwrap()\n@@ -2284,7 +2252,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             };\n             if result.base_res() == unqualified_result {\n                 let lint = lint::builtin::UNUSED_QUALIFICATIONS;\n-                self.r.lint_buffer.buffer_lint(lint, id, span, \"unnecessary qualification\")\n+                self.r.lint_buffer.buffer_lint(lint, id, path_span, \"unnecessary qualification\")\n             }\n         }\n "}, {"sha": "038ba2206086e5e3e01a1b69a1602bd4018329e0", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 17, "deletions": 23, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/903427b2e807cb1292388940b3f44f3b061cfebf/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/903427b2e807cb1292388940b3f44f3b061cfebf/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=903427b2e807cb1292388940b3f44f3b061cfebf", "patch": "@@ -2,7 +2,7 @@ use crate::diagnostics::{ImportSuggestion, LabelSuggestion, TypoSuggestion};\n use crate::late::lifetimes::{ElisionFailureInfo, LifetimeContext};\n use crate::late::{AliasPossibility, LateResolutionVisitor, RibKind};\n use crate::path_names_to_string;\n-use crate::{CrateLint, Module, ModuleKind, ModuleOrUniformRoot};\n+use crate::{Finalize, Module, ModuleKind, ModuleOrUniformRoot};\n use crate::{PathResult, PathSource, Segment};\n \n use rustc_ast::visit::FnKind;\n@@ -187,12 +187,11 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                 (String::new(), \"the crate root\".to_string())\n             } else {\n                 let mod_path = &path[..path.len() - 1];\n-                let mod_prefix =\n-                    match self.resolve_path(mod_path, Some(TypeNS), false, span, CrateLint::No) {\n-                        PathResult::Module(ModuleOrUniformRoot::Module(module)) => module.res(),\n-                        _ => None,\n-                    }\n-                    .map_or_else(String::new, |res| format!(\"{} \", res.descr()));\n+                let mod_prefix = match self.resolve_path(mod_path, Some(TypeNS), Finalize::No) {\n+                    PathResult::Module(ModuleOrUniformRoot::Module(module)) => module.res(),\n+                    _ => None,\n+                }\n+                .map_or_else(String::new, |res| format!(\"{} \", res.descr()));\n                 (mod_prefix, format!(\"`{}`\", Segment::names_to_string(mod_path)))\n             };\n             (\n@@ -232,7 +231,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n             _ => {}\n         }\n \n-        let is_assoc_fn = self.self_type_is_available(span);\n+        let is_assoc_fn = self.self_type_is_available();\n         // Emit help message for fake-self from other languages (e.g., `this` in Javascript).\n         if [\"this\", \"my\"].contains(&item_str.as_str()) && is_assoc_fn {\n             err.span_suggestion_short(\n@@ -241,7 +240,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                 \"self\".to_string(),\n                 Applicability::MaybeIncorrect,\n             );\n-            if !self.self_value_is_available(path[0].ident.span, span) {\n+            if !self.self_value_is_available(path[0].ident.span) {\n                 if let Some((FnKind::Fn(_, _, sig, ..), fn_span)) =\n                     &self.diagnostic_metadata.current_function\n                 {\n@@ -402,9 +401,9 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                 );\n             }\n         }\n-        if path.len() == 1 && self.self_type_is_available(span) {\n+        if path.len() == 1 && self.self_type_is_available() {\n             if let Some(candidate) = self.lookup_assoc_candidate(ident, ns, is_expected) {\n-                let self_is_available = self.self_value_is_available(path[0].ident.span, span);\n+                let self_is_available = self.self_value_is_available(path[0].ident.span);\n                 match candidate {\n                     AssocSuggestion::Field => {\n                         if self_is_available {\n@@ -461,7 +460,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         }\n \n         // Try Levenshtein algorithm.\n-        let typo_sugg = self.lookup_typo_candidate(path, ns, is_expected, span);\n+        let typo_sugg = self.lookup_typo_candidate(path, ns, is_expected);\n         // Try context-dependent help if relaxed lookup didn't work.\n         if let Some(res) = res {\n             if self.smart_resolve_context_dependent_help(\n@@ -562,7 +561,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                 }\n \n                 // If the trait has a single item (which wasn't matched by Levenshtein), suggest it\n-                let suggestion = self.get_single_associated_item(&path, span, &source, is_expected);\n+                let suggestion = self.get_single_associated_item(&path, &source, is_expected);\n                 self.r.add_typo_suggestion(&mut err, suggestion, ident_span);\n             }\n             if fallback {\n@@ -641,14 +640,13 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n     fn get_single_associated_item(\n         &mut self,\n         path: &[Segment],\n-        span: Span,\n         source: &PathSource<'_>,\n         filter_fn: &impl Fn(Res) -> bool,\n     ) -> Option<TypoSuggestion> {\n         if let crate::PathSource::TraitItem(_) = source {\n             let mod_path = &path[..path.len() - 1];\n             if let PathResult::Module(ModuleOrUniformRoot::Module(module)) =\n-                self.resolve_path(mod_path, None, false, span, CrateLint::No)\n+                self.resolve_path(mod_path, None, Finalize::No)\n             {\n                 let resolutions = self.r.resolutions(module).borrow();\n                 let targets: Vec<_> =\n@@ -699,13 +697,12 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         {\n             // use this to verify that ident is a type param.\n             let Ok(Some(partial_res)) = self.resolve_qpath_anywhere(\n-                bounded_ty.id,\n                 None,\n                 &Segment::from_path(path),\n                 Namespace::TypeNS,\n                 span,\n                 true,\n-                CrateLint::No,\n+                Finalize::No,\n             ) else {\n                 return false;\n             };\n@@ -724,13 +721,12 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         if let ast::TyKind::Path(None, type_param_path) = &ty.peel_refs().kind {\n             // Confirm that the `SelfTy` is a type parameter.\n             let Ok(Some(partial_res)) = self.resolve_qpath_anywhere(\n-                bounded_ty.id,\n                 None,\n                 &Segment::from_path(type_param_path),\n                 Namespace::TypeNS,\n                 span,\n                 true,\n-                CrateLint::No,\n+                Finalize::No,\n             ) else {\n                 return false;\n             };\n@@ -1292,8 +1288,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                 ident,\n                 ns,\n                 &self.parent_scope,\n-                false,\n-                module.span,\n+                None,\n             ) {\n                 let res = binding.res();\n                 if filter_fn(res) {\n@@ -1323,7 +1318,6 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         path: &[Segment],\n         ns: Namespace,\n         filter_fn: &impl Fn(Res) -> bool,\n-        span: Span,\n     ) -> Option<TypoSuggestion> {\n         let mut names = Vec::new();\n         if path.len() == 1 {\n@@ -1384,7 +1378,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n             // Search in module.\n             let mod_path = &path[..path.len() - 1];\n             if let PathResult::Module(ModuleOrUniformRoot::Module(module)) =\n-                self.resolve_path(mod_path, Some(TypeNS), false, span, CrateLint::No)\n+                self.resolve_path(mod_path, Some(TypeNS), Finalize::No)\n             {\n                 self.r.add_module_candidates(module, &mut names, &filter_fn);\n             }"}, {"sha": "19eeae4cf233ba238c386074af156becf4350707", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 272, "deletions": 358, "changes": 630, "blob_url": "https://github.com/rust-lang/rust/blob/903427b2e807cb1292388940b3f44f3b061cfebf/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/903427b2e807cb1292388940b3f44f3b061cfebf/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=903427b2e807cb1292388940b3f44f3b061cfebf", "patch": "@@ -13,6 +13,7 @@\n #![feature(drain_filter)]\n #![feature(bool_to_option)]\n #![feature(crate_visibility_modifier)]\n+#![feature(let_chains)]\n #![feature(let_else)]\n #![feature(never_type)]\n #![feature(nll)]\n@@ -54,9 +55,9 @@ use rustc_index::vec::IndexVec;\n use rustc_metadata::creader::{CStore, CrateLoader};\n use rustc_middle::metadata::ModChild;\n use rustc_middle::middle::privacy::AccessLevels;\n-use rustc_middle::span_bug;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, DefIdTree, MainDefinition, RegisteredTools, ResolverOutputs};\n+use rustc_middle::{bug, span_bug};\n use rustc_query_system::ich::StableHashingContext;\n use rustc_session::cstore::{CrateStore, MetadataLoaderDyn};\n use rustc_session::lint;\n@@ -71,7 +72,7 @@ use rustc_span::{Span, DUMMY_SP};\n use smallvec::{smallvec, SmallVec};\n use std::cell::{Cell, RefCell};\n use std::collections::BTreeSet;\n-use std::{cmp, fmt, iter, mem, ptr};\n+use std::{cmp, fmt, mem, ptr};\n use tracing::debug;\n \n use diagnostics::{extend_span_to_previous_binding, find_span_of_binding_until_next_binding};\n@@ -449,6 +450,19 @@ enum PathResult<'a> {\n     },\n }\n \n+impl<'a> PathResult<'a> {\n+    fn failed(\n+        span: Span,\n+        is_error_from_last_segment: bool,\n+        finalize: bool,\n+        label_and_suggestion: impl FnOnce() -> (String, Option<Suggestion>),\n+    ) -> PathResult<'a> {\n+        let (label, suggestion) =\n+            if finalize { label_and_suggestion() } else { (String::new(), None) };\n+        PathResult::Failed { span, label, suggestion, is_error_from_last_segment }\n+    }\n+}\n+\n #[derive(Debug)]\n enum ModuleKind {\n     /// An anonymous module; e.g., just a block.\n@@ -1936,8 +1950,7 @@ impl<'a> Resolver<'a> {\n         mut ident: Ident,\n         ns: Namespace,\n         parent_scope: &ParentScope<'a>,\n-        record_used_id: Option<NodeId>,\n-        path_span: Span,\n+        finalize_full: Finalize,\n         ribs: &[Rib<'a>],\n     ) -> Option<LexicalScopeBinding<'a>> {\n         assert!(ns == TypeNS || ns == ValueNS);\n@@ -1959,7 +1972,7 @@ impl<'a> Resolver<'a> {\n         let normalized_ident = Ident { span: normalized_span, ..ident };\n \n         // Walk backwards up the ribs in scope.\n-        let record_used = record_used_id.is_some();\n+        let finalize = finalize_full.path_span();\n         let mut module = self.graph_root;\n         for i in (0..ribs.len()).rev() {\n             debug!(\"walk rib\\n{:?}\", ribs[i].bindings);\n@@ -1973,8 +1986,7 @@ impl<'a> Resolver<'a> {\n                     i,\n                     rib_ident,\n                     *res,\n-                    record_used,\n-                    path_span,\n+                    finalize,\n                     *original_rib_ident_def,\n                     ribs,\n                 )));\n@@ -2001,8 +2013,7 @@ impl<'a> Resolver<'a> {\n                 ident,\n                 ns,\n                 parent_scope,\n-                record_used,\n-                path_span,\n+                finalize,\n             );\n             if let Ok(binding) = item {\n                 // The ident resolves to an item.\n@@ -2011,11 +2022,10 @@ impl<'a> Resolver<'a> {\n         }\n         self.early_resolve_ident_in_lexical_scope(\n             orig_ident,\n-            ScopeSet::Late(ns, module, record_used_id),\n+            ScopeSet::Late(ns, module, finalize_full.node_id()),\n             parent_scope,\n-            record_used,\n-            record_used,\n-            path_span,\n+            finalize,\n+            finalize.is_some(),\n         )\n         .ok()\n         .map(LexicalScopeBinding::Item)\n@@ -2075,10 +2085,9 @@ impl<'a> Resolver<'a> {\n         ident: Ident,\n         ns: Namespace,\n         parent_scope: &ParentScope<'a>,\n-        record_used: bool,\n-        path_span: Span,\n+        finalize: Option<Span>,\n     ) -> Result<&'a NameBinding<'a>, Determinacy> {\n-        self.resolve_ident_in_module_ext(module, ident, ns, parent_scope, record_used, path_span)\n+        self.resolve_ident_in_module_ext(module, ident, ns, parent_scope, finalize)\n             .map_err(|(determinacy, _)| determinacy)\n     }\n \n@@ -2088,8 +2097,7 @@ impl<'a> Resolver<'a> {\n         mut ident: Ident,\n         ns: Namespace,\n         parent_scope: &ParentScope<'a>,\n-        record_used: bool,\n-        path_span: Span,\n+        finalize: Option<Span>,\n     ) -> Result<&'a NameBinding<'a>, (Determinacy, Weak)> {\n         let tmp_parent_scope;\n         let mut adjusted_parent_scope = parent_scope;\n@@ -2114,8 +2122,7 @@ impl<'a> Resolver<'a> {\n             ns,\n             adjusted_parent_scope,\n             false,\n-            record_used,\n-            path_span,\n+            finalize,\n         )\n     }\n \n@@ -2206,45 +2213,30 @@ impl<'a> Resolver<'a> {\n         path: &[Segment],\n         opt_ns: Option<Namespace>, // `None` indicates a module path in import\n         parent_scope: &ParentScope<'a>,\n-        record_used: bool,\n-        path_span: Span,\n-        crate_lint: CrateLint,\n+        finalize: Finalize,\n     ) -> PathResult<'a> {\n-        self.resolve_path_with_ribs(\n-            path,\n-            opt_ns,\n-            parent_scope,\n-            record_used,\n-            path_span,\n-            crate_lint,\n-            None,\n-        )\n+        self.resolve_path_with_ribs(path, opt_ns, parent_scope, finalize, None)\n     }\n \n     fn resolve_path_with_ribs(\n         &mut self,\n         path: &[Segment],\n         opt_ns: Option<Namespace>, // `None` indicates a module path in import\n         parent_scope: &ParentScope<'a>,\n-        record_used: bool,\n-        path_span: Span,\n-        crate_lint: CrateLint,\n+        finalize_full: Finalize,\n         ribs: Option<&PerNS<Vec<Rib<'a>>>>,\n     ) -> PathResult<'a> {\n+        debug!(\"resolve_path(path={:?}, opt_ns={:?}, finalize={:?})\", path, opt_ns, finalize_full);\n+\n+        let finalize = finalize_full.path_span();\n         let mut module = None;\n         let mut allow_super = true;\n         let mut second_binding = None;\n \n-        debug!(\n-            \"resolve_path(path={:?}, opt_ns={:?}, record_used={:?}, \\\n-             path_span={:?}, crate_lint={:?})\",\n-            path, opt_ns, record_used, path_span, crate_lint,\n-        );\n-\n         for (i, &Segment { ident, id, has_generic_args: _ }) in path.iter().enumerate() {\n             debug!(\"resolve_path ident {} {:?} {:?}\", i, ident, id);\n             let record_segment_res = |this: &mut Self, res| {\n-                if record_used {\n+                if finalize.is_some() {\n                     if let Some(id) = id {\n                         if !this.partial_res_map.contains_key(&id) {\n                             assert!(id != ast::DUMMY_NODE_ID, \"Trying to resolve dummy id\");\n@@ -2278,13 +2270,9 @@ impl<'a> Resolver<'a> {\n                             continue;\n                         }\n                     }\n-                    let msg = \"there are too many leading `super` keywords\".to_string();\n-                    return PathResult::Failed {\n-                        span: ident.span,\n-                        label: msg,\n-                        suggestion: None,\n-                        is_error_from_last_segment: false,\n-                    };\n+                    return PathResult::failed(ident.span, false, finalize.is_some(), || {\n+                        (\"there are too many leading `super` keywords\".to_string(), None)\n+                    });\n                 }\n                 if i == 0 {\n                     if name == kw::SelfLower {\n@@ -2313,22 +2301,19 @@ impl<'a> Resolver<'a> {\n \n             // Report special messages for path segment keywords in wrong positions.\n             if ident.is_path_segment_keyword() && i != 0 {\n-                let name_str = if name == kw::PathRoot {\n-                    \"crate root\".to_string()\n-                } else {\n-                    format!(\"`{}`\", name)\n-                };\n-                let label = if i == 1 && path[0].ident.name == kw::PathRoot {\n-                    format!(\"global paths cannot start with {}\", name_str)\n-                } else {\n-                    format!(\"{} in paths can only be used in start position\", name_str)\n-                };\n-                return PathResult::Failed {\n-                    span: ident.span,\n-                    label,\n-                    suggestion: None,\n-                    is_error_from_last_segment: false,\n-                };\n+                return PathResult::failed(ident.span, false, finalize.is_some(), || {\n+                    let name_str = if name == kw::PathRoot {\n+                        \"crate root\".to_string()\n+                    } else {\n+                        format!(\"`{}`\", name)\n+                    };\n+                    let label = if i == 1 && path[0].ident.name == kw::PathRoot {\n+                        format!(\"global paths cannot start with {}\", name_str)\n+                    } else {\n+                        format!(\"{} in paths can only be used in start position\", name_str)\n+                    };\n+                    (label, None)\n+                });\n             }\n \n             enum FindBindingResult<'a> {\n@@ -2337,36 +2322,22 @@ impl<'a> Resolver<'a> {\n             }\n             let find_binding_in_ns = |this: &mut Self, ns| {\n                 let binding = if let Some(module) = module {\n-                    this.resolve_ident_in_module(\n-                        module,\n-                        ident,\n-                        ns,\n-                        parent_scope,\n-                        record_used,\n-                        path_span,\n-                    )\n+                    this.resolve_ident_in_module(module, ident, ns, parent_scope, finalize)\n                 } else if ribs.is_none() || opt_ns.is_none() || opt_ns == Some(MacroNS) {\n                     let scopes = ScopeSet::All(ns, opt_ns.is_none());\n                     this.early_resolve_ident_in_lexical_scope(\n                         ident,\n                         scopes,\n                         parent_scope,\n-                        record_used,\n-                        record_used,\n-                        path_span,\n+                        finalize,\n+                        finalize.is_some(),\n                     )\n                 } else {\n-                    let record_used_id = if record_used {\n-                        crate_lint.node_id().or(Some(CRATE_NODE_ID))\n-                    } else {\n-                        None\n-                    };\n                     match this.resolve_ident_in_lexical_scope(\n                         ident,\n                         ns,\n                         parent_scope,\n-                        record_used_id,\n-                        path_span,\n+                        finalize_full,\n                         &ribs.unwrap()[ns],\n                     ) {\n                         // we found a locally-imported or available item/module\n@@ -2380,7 +2351,7 @@ impl<'a> Resolver<'a> {\n                                 PartialRes::with_unresolved_segments(res, path.len() - 1),\n                             ));\n                         }\n-                        _ => Err(Determinacy::determined(record_used)),\n+                        _ => Err(Determinacy::determined(finalize.is_some())),\n                     }\n                 };\n                 FindBindingResult::Binding(binding)\n@@ -2414,30 +2385,20 @@ impl<'a> Resolver<'a> {\n                     } else if res == Res::Err {\n                         return PathResult::NonModule(PartialRes::new(Res::Err));\n                     } else if opt_ns.is_some() && (is_last || maybe_assoc) {\n-                        self.lint_if_path_starts_with_module(\n-                            crate_lint,\n-                            path,\n-                            path_span,\n-                            second_binding,\n-                        );\n+                        self.lint_if_path_starts_with_module(finalize_full, path, second_binding);\n                         return PathResult::NonModule(PartialRes::with_unresolved_segments(\n                             res,\n                             path.len() - i - 1,\n                         ));\n                     } else {\n-                        let label = format!(\n-                            \"`{}` is {} {}, not a module\",\n-                            ident,\n-                            res.article(),\n-                            res.descr(),\n-                        );\n-\n-                        return PathResult::Failed {\n-                            span: ident.span,\n-                            label,\n-                            suggestion: None,\n-                            is_error_from_last_segment: is_last,\n-                        };\n+                        return PathResult::failed(ident.span, is_last, finalize.is_some(), || {\n+                            let label = format!(\n+                                \"`{ident}` is {} {}, not a module\",\n+                                res.article(),\n+                                res.descr()\n+                            );\n+                            (label, None)\n+                        });\n                     }\n                 }\n                 Err(Undetermined) => return PathResult::Indeterminate,\n@@ -2450,196 +2411,192 @@ impl<'a> Resolver<'a> {\n                             ));\n                         }\n                     }\n-                    let module_res = match module {\n-                        Some(ModuleOrUniformRoot::Module(module)) => module.res(),\n-                        _ => None,\n-                    };\n-                    let (label, suggestion) = if module_res == self.graph_root.res() {\n-                        let is_mod = |res| matches!(res, Res::Def(DefKind::Mod, _));\n-                        // Don't look up import candidates if this is a speculative resolve\n-                        let mut candidates = if record_used {\n-                            self.lookup_import_candidates(ident, TypeNS, parent_scope, is_mod)\n-                        } else {\n-                            Vec::new()\n-                        };\n-                        candidates.sort_by_cached_key(|c| {\n-                            (c.path.segments.len(), pprust::path_to_string(&c.path))\n-                        });\n-                        if let Some(candidate) = candidates.get(0) {\n-                            (\n-                                String::from(\"unresolved import\"),\n-                                Some((\n-                                    vec![(ident.span, pprust::path_to_string(&candidate.path))],\n-                                    String::from(\"a similar path exists\"),\n-                                    Applicability::MaybeIncorrect,\n-                                )),\n-                            )\n-                        } else if self.session.edition() == Edition::Edition2015 {\n-                            (format!(\"maybe a missing crate `{}`?\", ident), None)\n-                        } else {\n-                            (format!(\"could not find `{}` in the crate root\", ident), None)\n-                        }\n-                    } else if i == 0 {\n-                        if ident\n-                            .name\n-                            .as_str()\n-                            .chars()\n-                            .next()\n-                            .map_or(false, |c| c.is_ascii_uppercase())\n-                        {\n-                            // Check whether the name refers to an item in the value namespace.\n-                            let suggestion = if ribs.is_some() {\n-                                let match_span = match self.resolve_ident_in_lexical_scope(\n-                                    ident,\n-                                    ValueNS,\n-                                    parent_scope,\n-                                    None,\n-                                    path_span,\n-                                    &ribs.unwrap()[ValueNS],\n-                                ) {\n-                                    // Name matches a local variable. For example:\n-                                    // ```\n-                                    // fn f() {\n-                                    //     let Foo: &str = \"\";\n-                                    //     println!(\"{}\", Foo::Bar); // Name refers to local\n-                                    //                               // variable `Foo`.\n-                                    // }\n-                                    // ```\n-                                    Some(LexicalScopeBinding::Res(Res::Local(id))) => {\n-                                        Some(*self.pat_span_map.get(&id).unwrap())\n-                                    }\n \n-                                    // Name matches item from a local name binding\n-                                    // created by `use` declaration. For example:\n-                                    // ```\n-                                    // pub Foo: &str = \"\";\n-                                    //\n-                                    // mod submod {\n-                                    //     use super::Foo;\n-                                    //     println!(\"{}\", Foo::Bar); // Name refers to local\n-                                    //                               // binding `Foo`.\n-                                    // }\n-                                    // ```\n-                                    Some(LexicalScopeBinding::Item(name_binding)) => {\n-                                        Some(name_binding.span)\n-                                    }\n-                                    _ => None,\n-                                };\n-\n-                                if let Some(span) = match_span {\n+                    return PathResult::failed(ident.span, is_last, finalize.is_some(), || {\n+                        let module_res = match module {\n+                            Some(ModuleOrUniformRoot::Module(module)) => module.res(),\n+                            _ => None,\n+                        };\n+                        if module_res == self.graph_root.res() {\n+                            let is_mod = |res| matches!(res, Res::Def(DefKind::Mod, _));\n+                            let mut candidates =\n+                                self.lookup_import_candidates(ident, TypeNS, parent_scope, is_mod);\n+                            candidates.sort_by_cached_key(|c| {\n+                                (c.path.segments.len(), pprust::path_to_string(&c.path))\n+                            });\n+                            if let Some(candidate) = candidates.get(0) {\n+                                (\n+                                    String::from(\"unresolved import\"),\n                                     Some((\n-                                        vec![(span, String::from(\"\"))],\n-                                        format!(\"`{}` is defined here, but is not a type\", ident),\n+                                        vec![(ident.span, pprust::path_to_string(&candidate.path))],\n+                                        String::from(\"a similar path exists\"),\n                                         Applicability::MaybeIncorrect,\n-                                    ))\n-                                } else {\n-                                    None\n-                                }\n+                                    )),\n+                                )\n+                            } else if self.session.edition() == Edition::Edition2015 {\n+                                (format!(\"maybe a missing crate `{}`?\", ident), None)\n                             } else {\n-                                None\n-                            };\n+                                (format!(\"could not find `{}` in the crate root\", ident), None)\n+                            }\n+                        } else if i == 0 {\n+                            if ident\n+                                .name\n+                                .as_str()\n+                                .chars()\n+                                .next()\n+                                .map_or(false, |c| c.is_ascii_uppercase())\n+                            {\n+                                // Check whether the name refers to an item in the value namespace.\n+                                let suggestion = if ribs.is_some() {\n+                                    let match_span = match self.resolve_ident_in_lexical_scope(\n+                                        ident,\n+                                        ValueNS,\n+                                        parent_scope,\n+                                        Finalize::No,\n+                                        &ribs.unwrap()[ValueNS],\n+                                    ) {\n+                                        // Name matches a local variable. For example:\n+                                        // ```\n+                                        // fn f() {\n+                                        //     let Foo: &str = \"\";\n+                                        //     println!(\"{}\", Foo::Bar); // Name refers to local\n+                                        //                               // variable `Foo`.\n+                                        // }\n+                                        // ```\n+                                        Some(LexicalScopeBinding::Res(Res::Local(id))) => {\n+                                            Some(*self.pat_span_map.get(&id).unwrap())\n+                                        }\n+\n+                                        // Name matches item from a local name binding\n+                                        // created by `use` declaration. For example:\n+                                        // ```\n+                                        // pub Foo: &str = \"\";\n+                                        //\n+                                        // mod submod {\n+                                        //     use super::Foo;\n+                                        //     println!(\"{}\", Foo::Bar); // Name refers to local\n+                                        //                               // binding `Foo`.\n+                                        // }\n+                                        // ```\n+                                        Some(LexicalScopeBinding::Item(name_binding)) => {\n+                                            Some(name_binding.span)\n+                                        }\n+                                        _ => None,\n+                                    };\n \n-                            (format!(\"use of undeclared type `{}`\", ident), suggestion)\n-                        } else {\n-                            (\n-                                format!(\"use of undeclared crate or module `{}`\", ident),\n-                                if ident.name == sym::alloc {\n-                                    Some((\n-                                        vec![],\n-                                        String::from(\n-                                            \"add `extern crate alloc` to use the `alloc` crate\",\n-                                        ),\n-                                        Applicability::MaybeIncorrect,\n-                                    ))\n+                                    if let Some(span) = match_span {\n+                                        Some((\n+                                            vec![(span, String::from(\"\"))],\n+                                            format!(\n+                                                \"`{}` is defined here, but is not a type\",\n+                                                ident\n+                                            ),\n+                                            Applicability::MaybeIncorrect,\n+                                        ))\n+                                    } else {\n+                                        None\n+                                    }\n                                 } else {\n-                                    self.find_similarly_named_module_or_crate(\n-                                        ident.name,\n-                                        &parent_scope.module,\n-                                    )\n-                                    .map(|sugg| {\n-                                        (\n-                                            vec![(ident.span, sugg.to_string())],\n+                                    None\n+                                };\n+\n+                                (format!(\"use of undeclared type `{}`\", ident), suggestion)\n+                            } else {\n+                                (\n+                                    format!(\"use of undeclared crate or module `{}`\", ident),\n+                                    if ident.name == sym::alloc {\n+                                        Some((\n+                                            vec![],\n                                             String::from(\n-                                                \"there is a crate or module with a similar name\",\n+                                                \"add `extern crate alloc` to use the `alloc` crate\",\n                                             ),\n                                             Applicability::MaybeIncorrect,\n+                                        ))\n+                                    } else {\n+                                        self.find_similarly_named_module_or_crate(\n+                                            ident.name,\n+                                            &parent_scope.module,\n                                         )\n-                                    })\n-                                },\n-                            )\n-                        }\n-                    } else {\n-                        let parent = path[i - 1].ident.name;\n-                        let parent = match parent {\n-                            // ::foo is mounted at the crate root for 2015, and is the extern\n-                            // prelude for 2018+\n-                            kw::PathRoot if self.session.edition() > Edition::Edition2015 => {\n-                                \"the list of imported crates\".to_owned()\n-                            }\n-                            kw::PathRoot | kw::Crate => \"the crate root\".to_owned(),\n-                            _ => {\n-                                format!(\"`{}`\", parent)\n+                                        .map(|sugg| {\n+                                            (\n+                                                vec![(ident.span, sugg.to_string())],\n+                                                String::from(\n+                                                    \"there is a crate or module with a similar name\",\n+                                                ),\n+                                                Applicability::MaybeIncorrect,\n+                                            )\n+                                        })\n+                                    },\n+                                )\n                             }\n-                        };\n-\n-                        let mut msg = format!(\"could not find `{}` in {}\", ident, parent);\n-                        if ns == TypeNS || ns == ValueNS {\n-                            let ns_to_try = if ns == TypeNS { ValueNS } else { TypeNS };\n-                            if let FindBindingResult::Binding(Ok(binding)) =\n-                                find_binding_in_ns(self, ns_to_try)\n-                            {\n-                                let mut found = |what| {\n-                                    msg = format!(\n-                                        \"expected {}, found {} `{}` in {}\",\n-                                        ns.descr(),\n-                                        what,\n-                                        ident,\n-                                        parent\n-                                    )\n-                                };\n-                                if binding.module().is_some() {\n-                                    found(\"module\")\n-                                } else {\n-                                    match binding.res() {\n-                                        def::Res::<NodeId>::Def(kind, id) => found(kind.descr(id)),\n-                                        _ => found(ns_to_try.descr()),\n-                                    }\n+                        } else {\n+                            let parent = path[i - 1].ident.name;\n+                            let parent = match parent {\n+                                // ::foo is mounted at the crate root for 2015, and is the extern\n+                                // prelude for 2018+\n+                                kw::PathRoot if self.session.edition() > Edition::Edition2015 => {\n+                                    \"the list of imported crates\".to_owned()\n+                                }\n+                                kw::PathRoot | kw::Crate => \"the crate root\".to_owned(),\n+                                _ => {\n+                                    format!(\"`{}`\", parent)\n                                 }\n                             };\n+\n+                            let mut msg = format!(\"could not find `{}` in {}\", ident, parent);\n+                            if ns == TypeNS || ns == ValueNS {\n+                                let ns_to_try = if ns == TypeNS { ValueNS } else { TypeNS };\n+                                if let FindBindingResult::Binding(Ok(binding)) =\n+                                    find_binding_in_ns(self, ns_to_try)\n+                                {\n+                                    let mut found = |what| {\n+                                        msg = format!(\n+                                            \"expected {}, found {} `{}` in {}\",\n+                                            ns.descr(),\n+                                            what,\n+                                            ident,\n+                                            parent\n+                                        )\n+                                    };\n+                                    if binding.module().is_some() {\n+                                        found(\"module\")\n+                                    } else {\n+                                        match binding.res() {\n+                                            def::Res::<NodeId>::Def(kind, id) => {\n+                                                found(kind.descr(id))\n+                                            }\n+                                            _ => found(ns_to_try.descr()),\n+                                        }\n+                                    }\n+                                };\n+                            }\n+                            (msg, None)\n                         }\n-                        (msg, None)\n-                    };\n-                    return PathResult::Failed {\n-                        span: ident.span,\n-                        label,\n-                        suggestion,\n-                        is_error_from_last_segment: is_last,\n-                    };\n+                    });\n                 }\n             }\n         }\n \n-        self.lint_if_path_starts_with_module(crate_lint, path, path_span, second_binding);\n+        self.lint_if_path_starts_with_module(finalize_full, path, second_binding);\n \n         PathResult::Module(match module {\n             Some(module) => module,\n             None if path.is_empty() => ModuleOrUniformRoot::CurrentScope,\n-            _ => span_bug!(path_span, \"resolve_path: non-empty path `{:?}` has no module\", path),\n+            _ => bug!(\"resolve_path: non-empty path `{:?}` has no module\", path),\n         })\n     }\n \n     fn lint_if_path_starts_with_module(\n         &mut self,\n-        crate_lint: CrateLint,\n+        finalize: Finalize,\n         path: &[Segment],\n-        path_span: Span,\n         second_binding: Option<&NameBinding<'_>>,\n     ) {\n-        let (diag_id, diag_span) = match crate_lint {\n-            CrateLint::No => return,\n-            CrateLint::SimplePath(id) => (id, path_span),\n-            CrateLint::UsePath { root_id, root_span } => (root_id, root_span),\n-            CrateLint::QPathTrait { qpath_id, qpath_span } => (qpath_id, qpath_span),\n+        let (diag_id, diag_span) = match finalize {\n+            Finalize::No => return,\n+            Finalize::SimplePath(id, path_span) => (id, path_span),\n+            Finalize::UsePath { root_id, root_span, .. } => (root_id, root_span),\n+            Finalize::QPathTrait { qpath_id, qpath_span, .. } => (qpath_id, qpath_span),\n         };\n \n         let first_name = match path.get(0) {\n@@ -2694,8 +2651,7 @@ impl<'a> Resolver<'a> {\n         rib_index: usize,\n         rib_ident: Ident,\n         mut res: Res,\n-        record_used: bool,\n-        span: Span,\n+        finalize: Option<Span>,\n         original_rib_ident_def: Ident,\n         all_ribs: &[Rib<'a>],\n     ) -> Res {\n@@ -2705,7 +2661,7 @@ impl<'a> Resolver<'a> {\n \n         // An invalid forward use of a generic parameter from a previous default.\n         if let ForwardGenericParamBanRibKind = all_ribs[rib_index].kind {\n-            if record_used {\n+            if let Some(span) = finalize {\n                 let res_error = if rib_ident.name == kw::SelfUpper {\n                     ResolutionError::SelfInGenericParamDefault\n                 } else {\n@@ -2735,17 +2691,17 @@ impl<'a> Resolver<'a> {\n                             // This was an attempt to access an upvar inside a\n                             // named function item. This is not allowed, so we\n                             // report an error.\n-                            if record_used {\n+                            if let Some(span) = finalize {\n                                 // We don't immediately trigger a resolve error, because\n                                 // we want certain other resolution errors (namely those\n                                 // emitted for `ConstantItemRibKind` below) to take\n                                 // precedence.\n-                                res_err = Some(CannotCaptureDynamicEnvironmentInFnItem);\n+                                res_err = Some((span, CannotCaptureDynamicEnvironmentInFnItem));\n                             }\n                         }\n                         ConstantItemRibKind(_, item) => {\n                             // Still doesn't deal with upvars\n-                            if record_used {\n+                            if let Some(span) = finalize {\n                                 let (span, resolution_error) =\n                                     if let Some((ident, constant_item_kind)) = item {\n                                         let kind_str = match constant_item_kind {\n@@ -2773,14 +2729,14 @@ impl<'a> Resolver<'a> {\n                             return Res::Err;\n                         }\n                         ConstParamTyRibKind => {\n-                            if record_used {\n+                            if let Some(span) = finalize {\n                                 self.report_error(span, ParamInTyOfConstParam(rib_ident.name));\n                             }\n                             return Res::Err;\n                         }\n                     }\n                 }\n-                if let Some(res_err) = res_err {\n+                if let Some((span, res_err)) = res_err {\n                     self.report_error(span, res_err);\n                     return Res::Err;\n                 }\n@@ -2808,17 +2764,17 @@ impl<'a> Resolver<'a> {\n                                 if let Res::SelfTy { trait_, alias_to: Some((def, _)) } = res {\n                                     res = Res::SelfTy { trait_, alias_to: Some((def, true)) }\n                                 } else {\n-                                    if record_used {\n+                                    if let Some(span) = finalize {\n                                         self.report_error(\n                                             span,\n                                             ResolutionError::ParamInNonTrivialAnonConst {\n                                                 name: rib_ident.name,\n                                                 is_type: true,\n                                             },\n                                         );\n+                                        self.session.delay_span_bug(span, CG_BUG_STR);\n                                     }\n \n-                                    self.session.delay_span_bug(span, CG_BUG_STR);\n                                     return Res::Err;\n                                 }\n                             }\n@@ -2830,7 +2786,7 @@ impl<'a> Resolver<'a> {\n                         ItemRibKind(has_generic_params) => has_generic_params,\n                         FnItemRibKind => HasGenericParams::Yes,\n                         ConstParamTyRibKind => {\n-                            if record_used {\n+                            if let Some(span) = finalize {\n                                 self.report_error(\n                                     span,\n                                     ResolutionError::ParamInTyOfConstParam(rib_ident.name),\n@@ -2840,7 +2796,7 @@ impl<'a> Resolver<'a> {\n                         }\n                     };\n \n-                    if record_used {\n+                    if let Some(span) = finalize {\n                         self.report_error(\n                             span,\n                             ResolutionError::GenericParamsFromOuterFunction(\n@@ -2874,17 +2830,17 @@ impl<'a> Resolver<'a> {\n                             let features = self.session.features_untracked();\n                             // HACK(min_const_generics): We currently only allow `N` or `{ N }`.\n                             if !(trivial || features.generic_const_exprs) {\n-                                if record_used {\n+                                if let Some(span) = finalize {\n                                     self.report_error(\n                                         span,\n                                         ResolutionError::ParamInNonTrivialAnonConst {\n                                             name: rib_ident.name,\n                                             is_type: false,\n                                         },\n                                     );\n+                                    self.session.delay_span_bug(span, CG_BUG_STR);\n                                 }\n \n-                                self.session.delay_span_bug(span, CG_BUG_STR);\n                                 return Res::Err;\n                             }\n \n@@ -2894,7 +2850,7 @@ impl<'a> Resolver<'a> {\n                         ItemRibKind(has_generic_params) => has_generic_params,\n                         FnItemRibKind => HasGenericParams::Yes,\n                         ConstParamTyRibKind => {\n-                            if record_used {\n+                            if let Some(span) = finalize {\n                                 self.report_error(\n                                     span,\n                                     ResolutionError::ParamInTyOfConstParam(rib_ident.name),\n@@ -2905,7 +2861,7 @@ impl<'a> Resolver<'a> {\n                     };\n \n                     // This was an attempt to use a const parameter outside its scope.\n-                    if record_used {\n+                    if let Some(span) = finalize {\n                         self.report_error(\n                             span,\n                             ResolutionError::GenericParamsFromOuterFunction(\n@@ -3293,23 +3249,19 @@ impl<'a> Resolver<'a> {\n         err.span_suggestion(span, message, String::new(), Applicability::MachineApplicable);\n     }\n \n-    fn extern_prelude_get(\n-        &mut self,\n-        ident: Ident,\n-        speculative: bool,\n-    ) -> Option<&'a NameBinding<'a>> {\n+    fn extern_prelude_get(&mut self, ident: Ident, finalize: bool) -> Option<&'a NameBinding<'a>> {\n         if ident.is_path_segment_keyword() {\n             // Make sure `self`, `super` etc produce an error when passed to here.\n             return None;\n         }\n         self.extern_prelude.get(&ident.normalize_to_macros_2_0()).cloned().and_then(|entry| {\n             if let Some(binding) = entry.extern_crate_item {\n-                if !speculative && entry.introduced_by_item {\n+                if finalize && entry.introduced_by_item {\n                     self.record_use(ident, binding, false);\n                 }\n                 Some(binding)\n             } else {\n-                let crate_id = if !speculative {\n+                let crate_id = if finalize {\n                     let Some(crate_id) =\n                         self.crate_loader.process_path_extern(ident.name, ident.span) else { return Some(self.dummy_binding); };\n                     crate_id\n@@ -3325,83 +3277,38 @@ impl<'a> Resolver<'a> {\n         })\n     }\n \n-    /// Rustdoc uses this to resolve things in a recoverable way. `ResolutionError<'a>`\n+    /// Rustdoc uses this to resolve doc link paths in a recoverable way. `PathResult<'a>`\n     /// isn't something that can be returned because it can't be made to live that long,\n     /// and also it's a private type. Fortunately rustdoc doesn't need to know the error,\n     /// just that an error occurred.\n-    // FIXME(Manishearth): intra-doc links won't get warned of epoch changes.\n-    pub fn resolve_str_path_error(\n+    pub fn resolve_rustdoc_path(\n         &mut self,\n-        span: Span,\n         path_str: &str,\n         ns: Namespace,\n         module_id: DefId,\n-    ) -> Result<(ast::Path, Res), ()> {\n-        let path = if path_str.starts_with(\"::\") {\n-            ast::Path {\n-                span,\n-                segments: iter::once(Ident::with_dummy_span(kw::PathRoot))\n-                    .chain(path_str.split(\"::\").skip(1).map(Ident::from_str))\n-                    .map(|i| self.new_ast_path_segment(i))\n-                    .collect(),\n-                tokens: None,\n-            }\n-        } else {\n-            ast::Path {\n-                span,\n-                segments: path_str\n-                    .split(\"::\")\n-                    .map(Ident::from_str)\n-                    .map(|i| self.new_ast_path_segment(i))\n-                    .collect(),\n-                tokens: None,\n-            }\n-        };\n-        let module = self.expect_module(module_id);\n-        let parent_scope = &ParentScope::module(module, self);\n-        let res = self.resolve_ast_path(&path, ns, parent_scope).map_err(|_| ())?;\n-        Ok((path, res))\n-    }\n+    ) -> Option<Res> {\n+        let mut segments =\n+            Vec::from_iter(path_str.split(\"::\").map(Ident::from_str).map(Segment::from_ident));\n+        if path_str.starts_with(\"::\") {\n+            segments[0].ident.name = kw::PathRoot;\n+        }\n \n-    // Resolve a path passed from rustdoc or HIR lowering.\n-    fn resolve_ast_path(\n-        &mut self,\n-        path: &ast::Path,\n-        ns: Namespace,\n-        parent_scope: &ParentScope<'a>,\n-    ) -> Result<Res, (Span, ResolutionError<'a>)> {\n+        let module = self.expect_module(module_id);\n         match self.resolve_path(\n-            &Segment::from_path(path),\n+            &segments,\n             Some(ns),\n-            parent_scope,\n-            false,\n-            path.span,\n-            CrateLint::No,\n+            &ParentScope::module(module, self),\n+            Finalize::No,\n         ) {\n-            PathResult::Module(ModuleOrUniformRoot::Module(module)) => Ok(module.res().unwrap()),\n+            PathResult::Module(ModuleOrUniformRoot::Module(module)) => Some(module.res().unwrap()),\n             PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 => {\n-                Ok(path_res.base_res())\n+                Some(path_res.base_res())\n             }\n-            PathResult::NonModule(..) => Err((\n-                path.span,\n-                ResolutionError::FailedToResolve {\n-                    label: String::from(\"type-relative paths are not supported in this context\"),\n-                    suggestion: None,\n-                },\n-            )),\n+            PathResult::NonModule(..) | PathResult::Failed { .. } => None,\n             PathResult::Module(..) | PathResult::Indeterminate => unreachable!(),\n-            PathResult::Failed { span, label, suggestion, .. } => {\n-                Err((span, ResolutionError::FailedToResolve { label, suggestion }))\n-            }\n         }\n     }\n \n-    fn new_ast_path_segment(&mut self, ident: Ident) -> ast::PathSegment {\n-        let mut seg = ast::PathSegment::from_ident(ident);\n-        seg.id = self.next_node_id();\n-        seg\n-    }\n-\n     // For rustdoc.\n     pub fn graph_root(&self) -> Module<'a> {\n         self.graph_root\n@@ -3485,8 +3392,7 @@ impl<'a> Resolver<'a> {\n             ident,\n             ValueNS,\n             parent_scope,\n-            false,\n-            DUMMY_SP,\n+            None\n         ) else {\n             return;\n         };\n@@ -3544,35 +3450,43 @@ fn module_to_string(module: Module<'_>) -> Option<String> {\n }\n \n #[derive(Copy, Clone, Debug)]\n-enum CrateLint {\n+enum Finalize {\n     /// Do not issue the lint.\n     No,\n \n     /// This lint applies to some arbitrary path; e.g., `impl ::foo::Bar`.\n     /// In this case, we can take the span of that path.\n-    SimplePath(NodeId),\n+    SimplePath(NodeId, Span),\n \n     /// This lint comes from a `use` statement. In this case, what we\n     /// care about really is the *root* `use` statement; e.g., if we\n     /// have nested things like `use a::{b, c}`, we care about the\n     /// `use a` part.\n-    UsePath { root_id: NodeId, root_span: Span },\n+    UsePath { root_id: NodeId, root_span: Span, path_span: Span },\n \n     /// This is the \"trait item\" from a fully qualified path. For example,\n     /// we might be resolving  `X::Y::Z` from a path like `<T as X::Y>::Z`.\n     /// The `path_span` is the span of the to the trait itself (`X::Y`).\n-    QPathTrait { qpath_id: NodeId, qpath_span: Span },\n+    QPathTrait { qpath_id: NodeId, qpath_span: Span, path_span: Span },\n }\n \n-impl CrateLint {\n-    fn node_id(&self) -> Option<NodeId> {\n+impl Finalize {\n+    fn node_id_and_path_span(&self) -> Option<(NodeId, Span)> {\n         match *self {\n-            CrateLint::No => None,\n-            CrateLint::SimplePath(id)\n-            | CrateLint::UsePath { root_id: id, .. }\n-            | CrateLint::QPathTrait { qpath_id: id, .. } => Some(id),\n+            Finalize::No => None,\n+            Finalize::SimplePath(id, path_span)\n+            | Finalize::UsePath { root_id: id, path_span, .. }\n+            | Finalize::QPathTrait { qpath_id: id, path_span, .. } => Some((id, path_span)),\n         }\n     }\n+\n+    fn node_id(&self) -> Option<NodeId> {\n+        self.node_id_and_path_span().map(|(id, _)| id)\n+    }\n+\n+    fn path_span(&self) -> Option<Span> {\n+        self.node_id_and_path_span().map(|(_, path_span)| path_span)\n+    }\n }\n \n pub fn provide(providers: &mut Providers) {"}, {"sha": "dc94ba49a5400b7b64640229519bb37dc942e880", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 21, "deletions": 35, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/903427b2e807cb1292388940b3f44f3b061cfebf/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/903427b2e807cb1292388940b3f44f3b061cfebf/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=903427b2e807cb1292388940b3f44f3b061cfebf", "patch": "@@ -4,7 +4,7 @@\n use crate::imports::ImportResolver;\n use crate::Namespace::*;\n use crate::{AmbiguityError, AmbiguityErrorMisc, AmbiguityKind, BuiltinMacroState, Determinacy};\n-use crate::{CrateLint, DeriveData, ParentScope, ResolutionError, Resolver, Scope, ScopeSet, Weak};\n+use crate::{DeriveData, Finalize, ParentScope, ResolutionError, Resolver, Scope, ScopeSet, Weak};\n use crate::{ModuleKind, ModuleOrUniformRoot, NameBinding, PathResult, Segment, ToNameBinding};\n use rustc_ast::{self as ast, Inline, ItemKind, ModKind, NodeId};\n use rustc_ast_lowering::ResolverAstLowering;\n@@ -415,7 +415,7 @@ impl<'a> ResolverExpand for Resolver<'a> {\n \n         let mut indeterminate = false;\n         for ns in [TypeNS, ValueNS, MacroNS].iter().copied() {\n-            match self.resolve_path(path, Some(ns), &parent_scope, false, span, CrateLint::No) {\n+            match self.resolve_path(path, Some(ns), &parent_scope, Finalize::No) {\n                 PathResult::Module(ModuleOrUniformRoot::Module(_)) => return Ok(true),\n                 PathResult::NonModule(partial_res) if partial_res.unresolved_segments() == 0 => {\n                     return Ok(true);\n@@ -575,14 +575,7 @@ impl<'a> Resolver<'a> {\n         }\n \n         let res = if path.len() > 1 {\n-            let res = match self.resolve_path(\n-                &path,\n-                Some(MacroNS),\n-                parent_scope,\n-                false,\n-                path_span,\n-                CrateLint::No,\n-            ) {\n+            let res = match self.resolve_path(&path, Some(MacroNS), parent_scope, Finalize::No) {\n                 PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 => {\n                     Ok(path_res.base_res())\n                 }\n@@ -612,9 +605,8 @@ impl<'a> Resolver<'a> {\n                 path[0].ident,\n                 scope_set,\n                 parent_scope,\n-                false,\n+                None,\n                 force,\n-                path_span,\n             );\n             if let Err(Determinacy::Undetermined) = binding {\n                 return Err(Determinacy::Undetermined);\n@@ -648,9 +640,8 @@ impl<'a> Resolver<'a> {\n         orig_ident: Ident,\n         scope_set: ScopeSet<'a>,\n         parent_scope: &ParentScope<'a>,\n-        record_used: bool,\n+        finalize: Option<Span>,\n         force: bool,\n-        path_span: Span,\n     ) -> Result<&'a NameBinding<'a>, Determinacy> {\n         bitflags::bitflags! {\n             struct Flags: u8 {\n@@ -662,7 +653,7 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        assert!(force || !record_used); // `record_used` implies `force`\n+        assert!(force || !finalize.is_some()); // `finalize` implies `force`\n \n         // Make sure `self`, `super` etc produce an error when passed to here.\n         if orig_ident.is_path_segment_keyword() {\n@@ -769,8 +760,7 @@ impl<'a> Resolver<'a> {\n                             ident,\n                             ns,\n                             parent_scope,\n-                            record_used,\n-                            path_span,\n+                            finalize,\n                         );\n                         match binding {\n                             Ok(binding) => Ok((binding, Flags::MODULE | Flags::MISC_SUGGEST_CRATE)),\n@@ -791,8 +781,7 @@ impl<'a> Resolver<'a> {\n                             ns,\n                             adjusted_parent_scope,\n                             !matches!(scope_set, ScopeSet::Late(..)),\n-                            record_used,\n-                            path_span,\n+                            finalize,\n                         );\n                         match binding {\n                             Ok(binding) => {\n@@ -856,12 +845,14 @@ impl<'a> Resolver<'a> {\n                             Err(Determinacy::Determined)\n                         }\n                     }\n-                    Scope::ExternPrelude => match this.extern_prelude_get(ident, !record_used) {\n-                        Some(binding) => Ok((binding, Flags::empty())),\n-                        None => Err(Determinacy::determined(\n-                            this.graph_root.unexpanded_invocations.borrow().is_empty(),\n-                        )),\n-                    },\n+                    Scope::ExternPrelude => {\n+                        match this.extern_prelude_get(ident, finalize.is_some()) {\n+                            Some(binding) => Ok((binding, Flags::empty())),\n+                            None => Err(Determinacy::determined(\n+                                this.graph_root.unexpanded_invocations.borrow().is_empty(),\n+                            )),\n+                        }\n+                    }\n                     Scope::ToolPrelude => match this.registered_tools.get(&ident).cloned() {\n                         Some(ident) => ok(Res::ToolMod, ident.span, this.arenas),\n                         None => Err(Determinacy::Determined),\n@@ -874,8 +865,7 @@ impl<'a> Resolver<'a> {\n                                 ident,\n                                 ns,\n                                 parent_scope,\n-                                false,\n-                                path_span,\n+                                None,\n                             ) {\n                                 if use_prelude || this.is_builtin_macro(binding.res()) {\n                                     result = Ok((binding, Flags::MISC_FROM_PRELUDE));\n@@ -894,7 +884,7 @@ impl<'a> Resolver<'a> {\n                     Ok((binding, flags))\n                         if sub_namespace_match(binding.macro_kind(), macro_kind) =>\n                     {\n-                        if !record_used || matches!(scope_set, ScopeSet::Late(..)) {\n+                        if finalize.is_none() || matches!(scope_set, ScopeSet::Late(..)) {\n                             return Some(Ok(binding));\n                         }\n \n@@ -1033,9 +1023,7 @@ impl<'a> Resolver<'a> {\n                 &path,\n                 Some(MacroNS),\n                 &parent_scope,\n-                true,\n-                path_span,\n-                CrateLint::No,\n+                Finalize::SimplePath(ast::CRATE_NODE_ID, path_span),\n             ) {\n                 PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 => {\n                     let res = path_res.base_res();\n@@ -1069,9 +1057,8 @@ impl<'a> Resolver<'a> {\n                 ident,\n                 ScopeSet::Macro(kind),\n                 &parent_scope,\n+                Some(ident.span),\n                 true,\n-                true,\n-                ident.span,\n             ) {\n                 Ok(binding) => {\n                     let initial_res = initial_binding.map(|initial_binding| {\n@@ -1111,9 +1098,8 @@ impl<'a> Resolver<'a> {\n                 ident,\n                 ScopeSet::Macro(MacroKind::Attr),\n                 &parent_scope,\n+                Some(ident.span),\n                 true,\n-                true,\n-                ident.span,\n             );\n         }\n     }"}, {"sha": "6d7ca9a94cfbde9432fcff3e52c30dc7e435a125", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/903427b2e807cb1292388940b3f44f3b061cfebf/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/903427b2e807cb1292388940b3f44f3b061cfebf/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=903427b2e807cb1292388940b3f44f3b061cfebf", "patch": "@@ -568,7 +568,7 @@ fn configure_cmake(\n     // We also do this if the user explicitly requested static libstdc++.\n     if builder.config.llvm_static_stdcpp {\n         if !target.contains(\"msvc\") && !target.contains(\"netbsd\") {\n-            if target.contains(\"apple\") {\n+            if target.contains(\"apple\") || target.contains(\"windows\") {\n                 ldflags.push_all(\"-static-libstdc++\");\n             } else {\n                 ldflags.push_all(\"-Wl,-Bsymbolic -static-libstdc++\");"}, {"sha": "5b14aca064e8ab85f2751cdc45e81454fe001443", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/903427b2e807cb1292388940b3f44f3b061cfebf/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/903427b2e807cb1292388940b3f44f3b061cfebf/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=903427b2e807cb1292388940b3f44f3b061cfebf", "patch": "@@ -487,12 +487,10 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         module_id: DefId,\n     ) -> Result<Res, ResolutionFailure<'a>> {\n         self.cx.enter_resolver(|resolver| {\n-            // NOTE: this needs 2 separate lookups because `resolve_str_path_error` doesn't take\n+            // NOTE: this needs 2 separate lookups because `resolve_rustdoc_path` doesn't take\n             // lexical scope into account (it ignores all macros not defined at the mod-level)\n             debug!(\"resolving {} as a macro in the module {:?}\", path_str, module_id);\n-            if let Ok((_, res)) =\n-                resolver.resolve_str_path_error(DUMMY_SP, path_str, MacroNS, module_id)\n-            {\n+            if let Some(res) = resolver.resolve_rustdoc_path(path_str, MacroNS, module_id) {\n                 // don't resolve builtins like `#[derive]`\n                 if let Ok(res) = res.try_into() {\n                     return Ok(res);\n@@ -540,10 +538,10 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             })\n     }\n \n-    /// Convenience wrapper around `resolve_str_path_error`.\n+    /// Convenience wrapper around `resolve_rustdoc_path`.\n     ///\n     /// This also handles resolving `true` and `false` as booleans.\n-    /// NOTE: `resolve_str_path_error` knows only about paths, not about types.\n+    /// NOTE: `resolve_rustdoc_path` knows only about paths, not about types.\n     /// Associated items will never be resolved by this function.\n     fn resolve_path(\n         &self,\n@@ -556,18 +554,14 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             return res;\n         }\n \n-        let result = self.cx.enter_resolver(|resolver| {\n-            resolver\n-                .resolve_str_path_error(DUMMY_SP, path_str, ns, module_id)\n-                .and_then(|(_, res)| res.try_into())\n-        });\n+        // Resolver doesn't know about true, false, and types that aren't paths (e.g. `()`).\n+        let result = self\n+            .cx\n+            .enter_resolver(|resolver| resolver.resolve_rustdoc_path(path_str, ns, module_id))\n+            .and_then(|res| res.try_into().ok())\n+            .or_else(|| resolve_primitive(path_str, ns));\n         debug!(\"{} resolved to {:?} in namespace {:?}\", path_str, result, ns);\n-        match result {\n-            // resolver doesn't know about true, false, and types that aren't paths (e.g. `()`)\n-            // manually as bool\n-            Err(()) => resolve_primitive(path_str, ns),\n-            Ok(res) => Some(res),\n-        }\n+        result\n     }\n \n     /// Resolves a string as a path within a particular namespace. Returns an"}, {"sha": "30636faf98c1f295e583926f1534886229194eac", "filename": "src/librustdoc/passes/collect_intra_doc_links/early.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/903427b2e807cb1292388940b3f44f3b061cfebf/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/903427b2e807cb1292388940b3f44f3b061cfebf/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs?ref=903427b2e807cb1292388940b3f44f3b061cfebf", "patch": "@@ -13,7 +13,7 @@ use rustc_hir::TraitCandidate;\n use rustc_middle::ty::{DefIdTree, Visibility};\n use rustc_resolve::{ParentScope, Resolver};\n use rustc_session::config::Externs;\n-use rustc_span::{Span, SyntaxContext, DUMMY_SP};\n+use rustc_span::SyntaxContext;\n \n use std::collections::hash_map::Entry;\n use std::mem;\n@@ -39,7 +39,7 @@ crate fn early_resolve_intra_doc_links(\n \n     // Overridden `visit_item` below doesn't apply to the crate root,\n     // so we have to visit its attributes and reexports separately.\n-    loader.load_links_in_attrs(&krate.attrs, krate.spans.inner_span);\n+    loader.load_links_in_attrs(&krate.attrs);\n     loader.process_module_children_or_reexports(CRATE_DEF_ID.to_def_id());\n     visit::walk_crate(&mut loader, krate);\n     loader.add_foreign_traits_in_scope();\n@@ -49,12 +49,7 @@ crate fn early_resolve_intra_doc_links(\n     // DO NOT REMOVE THIS without first testing on the reproducer in\n     // https://github.com/jyn514/objr/commit/edcee7b8124abf0e4c63873e8422ff81beb11ebb\n     for (extern_name, _) in externs.iter().filter(|(_, entry)| entry.add_prelude) {\n-        let _ = loader.resolver.resolve_str_path_error(\n-            DUMMY_SP,\n-            extern_name,\n-            TypeNS,\n-            CRATE_DEF_ID.to_def_id(),\n-        );\n+        loader.resolver.resolve_rustdoc_path(extern_name, TypeNS, CRATE_DEF_ID.to_def_id());\n     }\n \n     ResolverCaches {\n@@ -151,7 +146,7 @@ impl IntraLinkCrateLoader<'_, '_> {\n         }\n     }\n \n-    fn load_links_in_attrs(&mut self, attrs: &[ast::Attribute], span: Span) {\n+    fn load_links_in_attrs(&mut self, attrs: &[ast::Attribute]) {\n         // FIXME: this needs to consider reexport inlining.\n         let attrs = clean::Attributes::from_ast(attrs, None);\n         for (parent_module, doc) in attrs.collapsed_doc_value_by_module_level() {\n@@ -165,7 +160,7 @@ impl IntraLinkCrateLoader<'_, '_> {\n                 } else {\n                     continue;\n                 };\n-                let _ = self.resolver.resolve_str_path_error(span, &path_str, TypeNS, module_id);\n+                self.resolver.resolve_rustdoc_path(&path_str, TypeNS, module_id);\n             }\n         }\n     }\n@@ -201,7 +196,7 @@ impl Visitor<'_> for IntraLinkCrateLoader<'_, '_> {\n             // loaded, even if the module itself has no doc comments.\n             self.add_traits_in_parent_scope(self.current_mod.to_def_id());\n \n-            self.load_links_in_attrs(&item.attrs, item.span);\n+            self.load_links_in_attrs(&item.attrs);\n             self.process_module_children_or_reexports(self.current_mod.to_def_id());\n             visit::walk_item(self, item);\n \n@@ -216,28 +211,28 @@ impl Visitor<'_> for IntraLinkCrateLoader<'_, '_> {\n                 }\n                 _ => {}\n             }\n-            self.load_links_in_attrs(&item.attrs, item.span);\n+            self.load_links_in_attrs(&item.attrs);\n             visit::walk_item(self, item);\n         }\n     }\n \n     fn visit_assoc_item(&mut self, item: &ast::AssocItem, ctxt: AssocCtxt) {\n-        self.load_links_in_attrs(&item.attrs, item.span);\n+        self.load_links_in_attrs(&item.attrs);\n         visit::walk_assoc_item(self, item, ctxt)\n     }\n \n     fn visit_foreign_item(&mut self, item: &ast::ForeignItem) {\n-        self.load_links_in_attrs(&item.attrs, item.span);\n+        self.load_links_in_attrs(&item.attrs);\n         visit::walk_foreign_item(self, item)\n     }\n \n     fn visit_variant(&mut self, v: &ast::Variant) {\n-        self.load_links_in_attrs(&v.attrs, v.span);\n+        self.load_links_in_attrs(&v.attrs);\n         visit::walk_variant(self, v)\n     }\n \n     fn visit_field_def(&mut self, field: &ast::FieldDef) {\n-        self.load_links_in_attrs(&field.attrs, field.span);\n+        self.load_links_in_attrs(&field.attrs);\n         visit::walk_field_def(self, field)\n     }\n "}, {"sha": "5786ed7b1d533fea151b82679a397ac20f337a94", "filename": "src/test/ui/rust-2018/edition-lint-nested-empty-paths.fixed", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/903427b2e807cb1292388940b3f44f3b061cfebf/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-nested-empty-paths.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/903427b2e807cb1292388940b3f44f3b061cfebf/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-nested-empty-paths.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-nested-empty-paths.fixed?ref=903427b2e807cb1292388940b3f44f3b061cfebf", "patch": "@@ -17,28 +17,18 @@ crate mod foo {\n use crate::foo::{bar::{baz::{}}};\n //~^ ERROR absolute paths must start with\n //~| WARN this is accepted in the current edition\n-//~| ERROR absolute paths must start with\n-//~| WARN this is accepted in the current edition\n \n use crate::foo::{bar::{XX, baz::{}}};\n //~^ ERROR absolute paths must start with\n //~| WARN this is accepted in the current edition\n //~| ERROR absolute paths must start with\n //~| WARN this is accepted in the current edition\n-//~| ERROR absolute paths must start with\n-//~| WARN this is accepted in the current edition\n-//~| ERROR absolute paths must start with\n-//~| WARN this is accepted in the current edition\n \n use crate::foo::{bar::{baz::{}, baz1::{}}};\n //~^ ERROR absolute paths must start with\n //~| WARN this is accepted in the current edition\n //~| ERROR absolute paths must start with\n //~| WARN this is accepted in the current edition\n-//~| ERROR absolute paths must start with\n-//~| WARN this is accepted in the current edition\n-//~| ERROR absolute paths must start with\n-//~| WARN this is accepted in the current edition\n \n fn main() {\n }"}, {"sha": "b7c86088c75ed30db248c63fb12925ed8ff6d53f", "filename": "src/test/ui/rust-2018/edition-lint-nested-empty-paths.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/903427b2e807cb1292388940b3f44f3b061cfebf/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-nested-empty-paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/903427b2e807cb1292388940b3f44f3b061cfebf/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-nested-empty-paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-nested-empty-paths.rs?ref=903427b2e807cb1292388940b3f44f3b061cfebf", "patch": "@@ -17,28 +17,18 @@ crate mod foo {\n use foo::{bar::{baz::{}}};\n //~^ ERROR absolute paths must start with\n //~| WARN this is accepted in the current edition\n-//~| ERROR absolute paths must start with\n-//~| WARN this is accepted in the current edition\n \n use foo::{bar::{XX, baz::{}}};\n //~^ ERROR absolute paths must start with\n //~| WARN this is accepted in the current edition\n //~| ERROR absolute paths must start with\n //~| WARN this is accepted in the current edition\n-//~| ERROR absolute paths must start with\n-//~| WARN this is accepted in the current edition\n-//~| ERROR absolute paths must start with\n-//~| WARN this is accepted in the current edition\n \n use foo::{bar::{baz::{}, baz1::{}}};\n //~^ ERROR absolute paths must start with\n //~| WARN this is accepted in the current edition\n //~| ERROR absolute paths must start with\n //~| WARN this is accepted in the current edition\n-//~| ERROR absolute paths must start with\n-//~| WARN this is accepted in the current edition\n-//~| ERROR absolute paths must start with\n-//~| WARN this is accepted in the current edition\n \n fn main() {\n }"}, {"sha": "e47c320f78f09a10a251a9cf60f9e6c0b38db3d2", "filename": "src/test/ui/rust-2018/edition-lint-nested-empty-paths.stderr", "status": "modified", "additions": 5, "deletions": 50, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/903427b2e807cb1292388940b3f44f3b061cfebf/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-nested-empty-paths.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/903427b2e807cb1292388940b3f44f3b061cfebf/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-nested-empty-paths.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-nested-empty-paths.stderr?ref=903427b2e807cb1292388940b3f44f3b061cfebf", "patch": "@@ -13,16 +13,7 @@ LL | #![deny(absolute_paths_not_starting_with_crate)]\n    = note: for more information, see issue #53130 <https://github.com/rust-lang/rust/issues/53130>\n \n error: absolute paths must start with `self`, `super`, `crate`, or an external crate name in the 2018 edition\n-  --> $DIR/edition-lint-nested-empty-paths.rs:17:5\n-   |\n-LL | use foo::{bar::{baz::{}}};\n-   |     ^^^^^^^^^^^^^^^^^^^^^ help: use `crate`: `crate::foo::{bar::{baz::{}}}`\n-   |\n-   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2018!\n-   = note: for more information, see issue #53130 <https://github.com/rust-lang/rust/issues/53130>\n-\n-error: absolute paths must start with `self`, `super`, `crate`, or an external crate name in the 2018 edition\n-  --> $DIR/edition-lint-nested-empty-paths.rs:23:5\n+  --> $DIR/edition-lint-nested-empty-paths.rs:21:5\n    |\n LL | use foo::{bar::{XX, baz::{}}};\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `crate`: `crate::foo::{bar::{XX, baz::{}}}`\n@@ -31,7 +22,7 @@ LL | use foo::{bar::{XX, baz::{}}};\n    = note: for more information, see issue #53130 <https://github.com/rust-lang/rust/issues/53130>\n \n error: absolute paths must start with `self`, `super`, `crate`, or an external crate name in the 2018 edition\n-  --> $DIR/edition-lint-nested-empty-paths.rs:23:5\n+  --> $DIR/edition-lint-nested-empty-paths.rs:21:5\n    |\n LL | use foo::{bar::{XX, baz::{}}};\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `crate`: `crate::foo::{bar::{XX, baz::{}}}`\n@@ -40,43 +31,7 @@ LL | use foo::{bar::{XX, baz::{}}};\n    = note: for more information, see issue #53130 <https://github.com/rust-lang/rust/issues/53130>\n \n error: absolute paths must start with `self`, `super`, `crate`, or an external crate name in the 2018 edition\n-  --> $DIR/edition-lint-nested-empty-paths.rs:23:5\n-   |\n-LL | use foo::{bar::{XX, baz::{}}};\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `crate`: `crate::foo::{bar::{XX, baz::{}}}`\n-   |\n-   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2018!\n-   = note: for more information, see issue #53130 <https://github.com/rust-lang/rust/issues/53130>\n-\n-error: absolute paths must start with `self`, `super`, `crate`, or an external crate name in the 2018 edition\n-  --> $DIR/edition-lint-nested-empty-paths.rs:23:5\n-   |\n-LL | use foo::{bar::{XX, baz::{}}};\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `crate`: `crate::foo::{bar::{XX, baz::{}}}`\n-   |\n-   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2018!\n-   = note: for more information, see issue #53130 <https://github.com/rust-lang/rust/issues/53130>\n-\n-error: absolute paths must start with `self`, `super`, `crate`, or an external crate name in the 2018 edition\n-  --> $DIR/edition-lint-nested-empty-paths.rs:33:5\n-   |\n-LL | use foo::{bar::{baz::{}, baz1::{}}};\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `crate`: `crate::foo::{bar::{baz::{}, baz1::{}}}`\n-   |\n-   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2018!\n-   = note: for more information, see issue #53130 <https://github.com/rust-lang/rust/issues/53130>\n-\n-error: absolute paths must start with `self`, `super`, `crate`, or an external crate name in the 2018 edition\n-  --> $DIR/edition-lint-nested-empty-paths.rs:33:5\n-   |\n-LL | use foo::{bar::{baz::{}, baz1::{}}};\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `crate`: `crate::foo::{bar::{baz::{}, baz1::{}}}`\n-   |\n-   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2018!\n-   = note: for more information, see issue #53130 <https://github.com/rust-lang/rust/issues/53130>\n-\n-error: absolute paths must start with `self`, `super`, `crate`, or an external crate name in the 2018 edition\n-  --> $DIR/edition-lint-nested-empty-paths.rs:33:5\n+  --> $DIR/edition-lint-nested-empty-paths.rs:27:5\n    |\n LL | use foo::{bar::{baz::{}, baz1::{}}};\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `crate`: `crate::foo::{bar::{baz::{}, baz1::{}}}`\n@@ -85,13 +40,13 @@ LL | use foo::{bar::{baz::{}, baz1::{}}};\n    = note: for more information, see issue #53130 <https://github.com/rust-lang/rust/issues/53130>\n \n error: absolute paths must start with `self`, `super`, `crate`, or an external crate name in the 2018 edition\n-  --> $DIR/edition-lint-nested-empty-paths.rs:33:5\n+  --> $DIR/edition-lint-nested-empty-paths.rs:27:5\n    |\n LL | use foo::{bar::{baz::{}, baz1::{}}};\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `crate`: `crate::foo::{bar::{baz::{}, baz1::{}}}`\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2018!\n    = note: for more information, see issue #53130 <https://github.com/rust-lang/rust/issues/53130>\n \n-error: aborting due to 10 previous errors\n+error: aborting due to 5 previous errors\n "}, {"sha": "c4546f8c82129514f1e6355a492a73709ea6c2e7", "filename": "src/test/ui/rust-2018/edition-lint-nested-paths.fixed", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/903427b2e807cb1292388940b3f44f3b061cfebf/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-nested-paths.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/903427b2e807cb1292388940b3f44f3b061cfebf/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-nested-paths.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-nested-paths.fixed?ref=903427b2e807cb1292388940b3f44f3b061cfebf", "patch": "@@ -8,10 +8,6 @@ use crate::foo::{a, b};\n //~| this is accepted in the current edition\n //~| ERROR absolute paths must start with\n //~| this is accepted in the current edition\n-//~| ERROR absolute paths must start with\n-//~| this is accepted in the current edition\n-//~| ERROR absolute paths must start with\n-//~| this is accepted in the current edition\n \n mod foo {\n     crate fn a() {}\n@@ -29,8 +25,6 @@ fn main() {\n         //~| this is accepted in the current edition\n         //~| ERROR absolute paths must start with\n         //~| this is accepted in the current edition\n-        //~| ERROR absolute paths must start with\n-        //~| this is accepted in the current edition\n         x::a();\n         c();\n     }"}, {"sha": "a7e34e407a382c7b0f215d34e2bca3bf61d50e8c", "filename": "src/test/ui/rust-2018/edition-lint-nested-paths.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/903427b2e807cb1292388940b3f44f3b061cfebf/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-nested-paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/903427b2e807cb1292388940b3f44f3b061cfebf/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-nested-paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-nested-paths.rs?ref=903427b2e807cb1292388940b3f44f3b061cfebf", "patch": "@@ -8,10 +8,6 @@ use foo::{a, b};\n //~| this is accepted in the current edition\n //~| ERROR absolute paths must start with\n //~| this is accepted in the current edition\n-//~| ERROR absolute paths must start with\n-//~| this is accepted in the current edition\n-//~| ERROR absolute paths must start with\n-//~| this is accepted in the current edition\n \n mod foo {\n     crate fn a() {}\n@@ -29,8 +25,6 @@ fn main() {\n         //~| this is accepted in the current edition\n         //~| ERROR absolute paths must start with\n         //~| this is accepted in the current edition\n-        //~| ERROR absolute paths must start with\n-        //~| this is accepted in the current edition\n         x::a();\n         c();\n     }"}, {"sha": "24b17f212eb15bd4ce409935b849d6bb1159030e", "filename": "src/test/ui/rust-2018/edition-lint-nested-paths.stderr", "status": "modified", "additions": 3, "deletions": 30, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/903427b2e807cb1292388940b3f44f3b061cfebf/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-nested-paths.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/903427b2e807cb1292388940b3f44f3b061cfebf/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-nested-paths.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-nested-paths.stderr?ref=903427b2e807cb1292388940b3f44f3b061cfebf", "patch": "@@ -22,34 +22,7 @@ LL | use foo::{a, b};\n    = note: for more information, see issue #53130 <https://github.com/rust-lang/rust/issues/53130>\n \n error: absolute paths must start with `self`, `super`, `crate`, or an external crate name in the 2018 edition\n-  --> $DIR/edition-lint-nested-paths.rs:6:5\n-   |\n-LL | use foo::{a, b};\n-   |     ^^^^^^^^^^^ help: use `crate`: `crate::foo::{a, b}`\n-   |\n-   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2018!\n-   = note: for more information, see issue #53130 <https://github.com/rust-lang/rust/issues/53130>\n-\n-error: absolute paths must start with `self`, `super`, `crate`, or an external crate name in the 2018 edition\n-  --> $DIR/edition-lint-nested-paths.rs:6:5\n-   |\n-LL | use foo::{a, b};\n-   |     ^^^^^^^^^^^ help: use `crate`: `crate::foo::{a, b}`\n-   |\n-   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2018!\n-   = note: for more information, see issue #53130 <https://github.com/rust-lang/rust/issues/53130>\n-\n-error: absolute paths must start with `self`, `super`, `crate`, or an external crate name in the 2018 edition\n-  --> $DIR/edition-lint-nested-paths.rs:27:13\n-   |\n-LL |         use foo::{self as x, c};\n-   |             ^^^^^^^^^^^^^^^^^^^ help: use `crate`: `crate::foo::{self as x, c}`\n-   |\n-   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2018!\n-   = note: for more information, see issue #53130 <https://github.com/rust-lang/rust/issues/53130>\n-\n-error: absolute paths must start with `self`, `super`, `crate`, or an external crate name in the 2018 edition\n-  --> $DIR/edition-lint-nested-paths.rs:27:13\n+  --> $DIR/edition-lint-nested-paths.rs:23:13\n    |\n LL |         use foo::{self as x, c};\n    |             ^^^^^^^^^^^^^^^^^^^ help: use `crate`: `crate::foo::{self as x, c}`\n@@ -58,13 +31,13 @@ LL |         use foo::{self as x, c};\n    = note: for more information, see issue #53130 <https://github.com/rust-lang/rust/issues/53130>\n \n error: absolute paths must start with `self`, `super`, `crate`, or an external crate name in the 2018 edition\n-  --> $DIR/edition-lint-nested-paths.rs:27:13\n+  --> $DIR/edition-lint-nested-paths.rs:23:13\n    |\n LL |         use foo::{self as x, c};\n    |             ^^^^^^^^^^^^^^^^^^^ help: use `crate`: `crate::foo::{self as x, c}`\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2018!\n    = note: for more information, see issue #53130 <https://github.com/rust-lang/rust/issues/53130>\n \n-error: aborting due to 7 previous errors\n+error: aborting due to 4 previous errors\n "}, {"sha": "47f82c51daeaaaa65cf31c6a9b1ce34536e38a80", "filename": "src/test/ui/rust-2018/edition-lint-paths.fixed", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/903427b2e807cb1292388940b3f44f3b061cfebf/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-paths.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/903427b2e807cb1292388940b3f44f3b061cfebf/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-paths.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-paths.fixed?ref=903427b2e807cb1292388940b3f44f3b061cfebf", "patch": "@@ -12,8 +12,6 @@ pub mod foo {\n     use crate::bar::Bar;\n     //~^ ERROR absolute\n     //~| WARN this is accepted in the current edition\n-    //~| ERROR absolute\n-    //~| WARN this is accepted in the current edition\n \n     use super::bar::Bar2;\n     use crate::bar::Bar3;\n@@ -42,8 +40,6 @@ pub mod foo {\n use crate::bar::Bar;\n //~^ ERROR absolute\n //~| WARN this is accepted in the current edition\n-//~| ERROR absolute\n-//~| WARN this is accepted in the current edition\n \n pub mod bar {\n     use edition_lint_paths as foo;\n@@ -61,8 +57,6 @@ mod baz {\n impl crate::foo::SomeTrait for u32 {}\n //~^ ERROR absolute\n //~| WARN this is accepted in the current edition\n-//~| ERROR absolute\n-//~| WARN this is accepted in the current edition\n \n fn main() {\n     let x = crate::bar::Bar;"}, {"sha": "e278983da4a9041ababda4b8897e1b3b3cda3857", "filename": "src/test/ui/rust-2018/edition-lint-paths.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/903427b2e807cb1292388940b3f44f3b061cfebf/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/903427b2e807cb1292388940b3f44f3b061cfebf/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-paths.rs?ref=903427b2e807cb1292388940b3f44f3b061cfebf", "patch": "@@ -12,8 +12,6 @@ pub mod foo {\n     use bar::Bar;\n     //~^ ERROR absolute\n     //~| WARN this is accepted in the current edition\n-    //~| ERROR absolute\n-    //~| WARN this is accepted in the current edition\n \n     use super::bar::Bar2;\n     use crate::bar::Bar3;\n@@ -42,8 +40,6 @@ pub mod foo {\n use bar::Bar;\n //~^ ERROR absolute\n //~| WARN this is accepted in the current edition\n-//~| ERROR absolute\n-//~| WARN this is accepted in the current edition\n \n pub mod bar {\n     use edition_lint_paths as foo;\n@@ -61,8 +57,6 @@ mod baz {\n impl ::foo::SomeTrait for u32 {}\n //~^ ERROR absolute\n //~| WARN this is accepted in the current edition\n-//~| ERROR absolute\n-//~| WARN this is accepted in the current edition\n \n fn main() {\n     let x = ::bar::Bar;"}, {"sha": "1ded8cd3694c053317c6ec34564158b821742550", "filename": "src/test/ui/rust-2018/edition-lint-paths.stderr", "status": "modified", "additions": 9, "deletions": 36, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/903427b2e807cb1292388940b3f44f3b061cfebf/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-paths.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/903427b2e807cb1292388940b3f44f3b061cfebf/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-paths.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-paths.stderr?ref=903427b2e807cb1292388940b3f44f3b061cfebf", "patch": "@@ -13,16 +13,7 @@ LL | #![deny(absolute_paths_not_starting_with_crate)]\n    = note: for more information, see issue #53130 <https://github.com/rust-lang/rust/issues/53130>\n \n error: absolute paths must start with `self`, `super`, `crate`, or an external crate name in the 2018 edition\n-  --> $DIR/edition-lint-paths.rs:12:9\n-   |\n-LL |     use bar::Bar;\n-   |         ^^^^^^^^ help: use `crate`: `crate::bar::Bar`\n-   |\n-   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2018!\n-   = note: for more information, see issue #53130 <https://github.com/rust-lang/rust/issues/53130>\n-\n-error: absolute paths must start with `self`, `super`, `crate`, or an external crate name in the 2018 edition\n-  --> $DIR/edition-lint-paths.rs:21:9\n+  --> $DIR/edition-lint-paths.rs:19:9\n    |\n LL |     use bar;\n    |         ^^^ help: use `crate`: `crate::bar`\n@@ -31,7 +22,7 @@ LL |     use bar;\n    = note: for more information, see issue #53130 <https://github.com/rust-lang/rust/issues/53130>\n \n error: absolute paths must start with `self`, `super`, `crate`, or an external crate name in the 2018 edition\n-  --> $DIR/edition-lint-paths.rs:27:9\n+  --> $DIR/edition-lint-paths.rs:25:9\n    |\n LL |     use {main, Bar as SomethingElse};\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `crate`: `crate::{main, Bar as SomethingElse}`\n@@ -40,7 +31,7 @@ LL |     use {main, Bar as SomethingElse};\n    = note: for more information, see issue #53130 <https://github.com/rust-lang/rust/issues/53130>\n \n error: absolute paths must start with `self`, `super`, `crate`, or an external crate name in the 2018 edition\n-  --> $DIR/edition-lint-paths.rs:27:9\n+  --> $DIR/edition-lint-paths.rs:25:9\n    |\n LL |     use {main, Bar as SomethingElse};\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `crate`: `crate::{main, Bar as SomethingElse}`\n@@ -49,7 +40,7 @@ LL |     use {main, Bar as SomethingElse};\n    = note: for more information, see issue #53130 <https://github.com/rust-lang/rust/issues/53130>\n \n error: absolute paths must start with `self`, `super`, `crate`, or an external crate name in the 2018 edition\n-  --> $DIR/edition-lint-paths.rs:27:9\n+  --> $DIR/edition-lint-paths.rs:25:9\n    |\n LL |     use {main, Bar as SomethingElse};\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `crate`: `crate::{main, Bar as SomethingElse}`\n@@ -58,7 +49,7 @@ LL |     use {main, Bar as SomethingElse};\n    = note: for more information, see issue #53130 <https://github.com/rust-lang/rust/issues/53130>\n \n error: absolute paths must start with `self`, `super`, `crate`, or an external crate name in the 2018 edition\n-  --> $DIR/edition-lint-paths.rs:42:5\n+  --> $DIR/edition-lint-paths.rs:40:5\n    |\n LL | use bar::Bar;\n    |     ^^^^^^^^ help: use `crate`: `crate::bar::Bar`\n@@ -67,16 +58,7 @@ LL | use bar::Bar;\n    = note: for more information, see issue #53130 <https://github.com/rust-lang/rust/issues/53130>\n \n error: absolute paths must start with `self`, `super`, `crate`, or an external crate name in the 2018 edition\n-  --> $DIR/edition-lint-paths.rs:42:5\n-   |\n-LL | use bar::Bar;\n-   |     ^^^^^^^^ help: use `crate`: `crate::bar::Bar`\n-   |\n-   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2018!\n-   = note: for more information, see issue #53130 <https://github.com/rust-lang/rust/issues/53130>\n-\n-error: absolute paths must start with `self`, `super`, `crate`, or an external crate name in the 2018 edition\n-  --> $DIR/edition-lint-paths.rs:56:9\n+  --> $DIR/edition-lint-paths.rs:52:9\n    |\n LL |     use *;\n    |         ^ help: use `crate`: `crate::*`\n@@ -85,16 +67,7 @@ LL |     use *;\n    = note: for more information, see issue #53130 <https://github.com/rust-lang/rust/issues/53130>\n \n error: absolute paths must start with `self`, `super`, `crate`, or an external crate name in the 2018 edition\n-  --> $DIR/edition-lint-paths.rs:61:6\n-   |\n-LL | impl ::foo::SomeTrait for u32 {}\n-   |      ^^^^^^^^^^^^^^^^ help: use `crate`: `crate::foo::SomeTrait`\n-   |\n-   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2018!\n-   = note: for more information, see issue #53130 <https://github.com/rust-lang/rust/issues/53130>\n-\n-error: absolute paths must start with `self`, `super`, `crate`, or an external crate name in the 2018 edition\n-  --> $DIR/edition-lint-paths.rs:61:6\n+  --> $DIR/edition-lint-paths.rs:57:6\n    |\n LL | impl ::foo::SomeTrait for u32 {}\n    |      ^^^^^^^^^^^^^^^^ help: use `crate`: `crate::foo::SomeTrait`\n@@ -103,13 +76,13 @@ LL | impl ::foo::SomeTrait for u32 {}\n    = note: for more information, see issue #53130 <https://github.com/rust-lang/rust/issues/53130>\n \n error: absolute paths must start with `self`, `super`, `crate`, or an external crate name in the 2018 edition\n-  --> $DIR/edition-lint-paths.rs:68:13\n+  --> $DIR/edition-lint-paths.rs:62:13\n    |\n LL |     let x = ::bar::Bar;\n    |             ^^^^^^^^^^ help: use `crate`: `crate::bar::Bar`\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2018!\n    = note: for more information, see issue #53130 <https://github.com/rust-lang/rust/issues/53130>\n \n-error: aborting due to 12 previous errors\n+error: aborting due to 9 previous errors\n "}, {"sha": "ea832ef3e7d70b52387367238f5eef453ef73303", "filename": "src/test/ui/rust-2018/extern-crate-rename.fixed", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/903427b2e807cb1292388940b3f44f3b061cfebf/src%2Ftest%2Fui%2Frust-2018%2Fextern-crate-rename.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/903427b2e807cb1292388940b3f44f3b061cfebf/src%2Ftest%2Fui%2Frust-2018%2Fextern-crate-rename.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fextern-crate-rename.fixed?ref=903427b2e807cb1292388940b3f44f3b061cfebf", "patch": "@@ -12,8 +12,6 @@ extern crate edition_lint_paths as my_crate;\n use crate::my_crate::foo;\n //~^ ERROR absolute paths must start\n //~| WARNING this is accepted in the current edition\n-//~| ERROR absolute paths must start\n-//~| WARNING this is accepted in the current edition\n \n fn main() {\n     foo();"}, {"sha": "b1f617dd8847844b6f74eb4509ab1b5d2b0efb20", "filename": "src/test/ui/rust-2018/extern-crate-rename.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/903427b2e807cb1292388940b3f44f3b061cfebf/src%2Ftest%2Fui%2Frust-2018%2Fextern-crate-rename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/903427b2e807cb1292388940b3f44f3b061cfebf/src%2Ftest%2Fui%2Frust-2018%2Fextern-crate-rename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fextern-crate-rename.rs?ref=903427b2e807cb1292388940b3f44f3b061cfebf", "patch": "@@ -12,8 +12,6 @@ extern crate edition_lint_paths as my_crate;\n use my_crate::foo;\n //~^ ERROR absolute paths must start\n //~| WARNING this is accepted in the current edition\n-//~| ERROR absolute paths must start\n-//~| WARNING this is accepted in the current edition\n \n fn main() {\n     foo();"}, {"sha": "4bccbc51223f3b5c9ca2fb809d433ff8e920a162", "filename": "src/test/ui/rust-2018/extern-crate-rename.stderr", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/903427b2e807cb1292388940b3f44f3b061cfebf/src%2Ftest%2Fui%2Frust-2018%2Fextern-crate-rename.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/903427b2e807cb1292388940b3f44f3b061cfebf/src%2Ftest%2Fui%2Frust-2018%2Fextern-crate-rename.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fextern-crate-rename.stderr?ref=903427b2e807cb1292388940b3f44f3b061cfebf", "patch": "@@ -12,14 +12,5 @@ LL | #![deny(absolute_paths_not_starting_with_crate)]\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2018!\n    = note: for more information, see issue #53130 <https://github.com/rust-lang/rust/issues/53130>\n \n-error: absolute paths must start with `self`, `super`, `crate`, or an external crate name in the 2018 edition\n-  --> $DIR/extern-crate-rename.rs:12:5\n-   |\n-LL | use my_crate::foo;\n-   |     ^^^^^^^^^^^^^ help: use `crate`: `crate::my_crate::foo`\n-   |\n-   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2018!\n-   = note: for more information, see issue #53130 <https://github.com/rust-lang/rust/issues/53130>\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n "}, {"sha": "9b0b0dd8ee1d43f810691719bb340c9b3da11f37", "filename": "src/test/ui/rust-2018/extern-crate-submod.fixed", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/903427b2e807cb1292388940b3f44f3b061cfebf/src%2Ftest%2Fui%2Frust-2018%2Fextern-crate-submod.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/903427b2e807cb1292388940b3f44f3b061cfebf/src%2Ftest%2Fui%2Frust-2018%2Fextern-crate-submod.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fextern-crate-submod.fixed?ref=903427b2e807cb1292388940b3f44f3b061cfebf", "patch": "@@ -19,9 +19,6 @@ mod m {\n use crate::m::edition_lint_paths::foo;\n //~^ ERROR absolute paths must start\n //~| WARNING this is accepted in the current edition\n-//~| ERROR absolute paths must start\n-//~| WARNING this is accepted in the current edition\n-\n \n fn main() {\n     foo();"}, {"sha": "dfce9128c51148494f86cd73af5fc9506ee0f42b", "filename": "src/test/ui/rust-2018/extern-crate-submod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/903427b2e807cb1292388940b3f44f3b061cfebf/src%2Ftest%2Fui%2Frust-2018%2Fextern-crate-submod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/903427b2e807cb1292388940b3f44f3b061cfebf/src%2Ftest%2Fui%2Frust-2018%2Fextern-crate-submod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fextern-crate-submod.rs?ref=903427b2e807cb1292388940b3f44f3b061cfebf", "patch": "@@ -19,9 +19,6 @@ mod m {\n use m::edition_lint_paths::foo;\n //~^ ERROR absolute paths must start\n //~| WARNING this is accepted in the current edition\n-//~| ERROR absolute paths must start\n-//~| WARNING this is accepted in the current edition\n-\n \n fn main() {\n     foo();"}, {"sha": "3c75319aedaedfc320dc904d13bab8f1528ec851", "filename": "src/test/ui/rust-2018/extern-crate-submod.stderr", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/903427b2e807cb1292388940b3f44f3b061cfebf/src%2Ftest%2Fui%2Frust-2018%2Fextern-crate-submod.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/903427b2e807cb1292388940b3f44f3b061cfebf/src%2Ftest%2Fui%2Frust-2018%2Fextern-crate-submod.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fextern-crate-submod.stderr?ref=903427b2e807cb1292388940b3f44f3b061cfebf", "patch": "@@ -12,14 +12,5 @@ LL | #![deny(absolute_paths_not_starting_with_crate)]\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2018!\n    = note: for more information, see issue #53130 <https://github.com/rust-lang/rust/issues/53130>\n \n-error: absolute paths must start with `self`, `super`, `crate`, or an external crate name in the 2018 edition\n-  --> $DIR/extern-crate-submod.rs:19:5\n-   |\n-LL | use m::edition_lint_paths::foo;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `crate`: `crate::m::edition_lint_paths::foo`\n-   |\n-   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2018!\n-   = note: for more information, see issue #53130 <https://github.com/rust-lang/rust/issues/53130>\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n "}]}