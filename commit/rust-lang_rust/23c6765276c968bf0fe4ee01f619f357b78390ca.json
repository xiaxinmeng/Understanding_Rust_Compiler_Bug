{"sha": "23c6765276c968bf0fe4ee01f619f357b78390ca", "node_id": "C_kwDOAAsO6NoAKDIzYzY3NjUyNzZjOTY4YmYwZmU0ZWUwMWY2MTlmMzU3Yjc4MzkwY2E", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-28T17:24:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-28T17:24:06Z"}, "message": "Auto merge of #8921 - Jarcho:merge_passes, r=llogiq\n\nAdd `Operators` lint pass\n\nchangelog: None", "tree": {"sha": "cefbb86e8814ae20c4341d78b8e5ee6bd7e020fc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cefbb86e8814ae20c4341d78b8e5ee6bd7e020fc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/23c6765276c968bf0fe4ee01f619f357b78390ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/23c6765276c968bf0fe4ee01f619f357b78390ca", "html_url": "https://github.com/rust-lang/rust/commit/23c6765276c968bf0fe4ee01f619f357b78390ca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/23c6765276c968bf0fe4ee01f619f357b78390ca/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b776fb82941cadfc752368901f210831d5184d95", "url": "https://api.github.com/repos/rust-lang/rust/commits/b776fb82941cadfc752368901f210831d5184d95", "html_url": "https://github.com/rust-lang/rust/commit/b776fb82941cadfc752368901f210831d5184d95"}, {"sha": "ffbba8550a9fb02528638307c93235f758dcf78c", "url": "https://api.github.com/repos/rust-lang/rust/commits/ffbba8550a9fb02528638307c93235f758dcf78c", "html_url": "https://github.com/rust-lang/rust/commit/ffbba8550a9fb02528638307c93235f758dcf78c"}], "stats": {"total": 4688, "additions": 2366, "deletions": 2322}, "files": [{"sha": "f81da2d42233380e9bd5a633b8b13237dfcac68a", "filename": "clippy_lints/src/assign_ops.rs", "status": "removed", "additions": 0, "deletions": 235, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/b776fb82941cadfc752368901f210831d5184d95/clippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b776fb82941cadfc752368901f210831d5184d95/clippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassign_ops.rs?ref=b776fb82941cadfc752368901f210831d5184d95", "patch": "@@ -1,235 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::source::snippet_opt;\n-use clippy_utils::ty::implements_trait;\n-use clippy_utils::{binop_traits, sugg};\n-use clippy_utils::{eq_expr_value, trait_ref_of_method};\n-use if_chain::if_chain;\n-use rustc_errors::Applicability;\n-use rustc_hir as hir;\n-use rustc_hir::intravisit::{walk_expr, Visitor};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for `a = a op b` or `a = b commutative_op a`\n-    /// patterns.\n-    ///\n-    /// ### Why is this bad?\n-    /// These can be written as the shorter `a op= b`.\n-    ///\n-    /// ### Known problems\n-    /// While forbidden by the spec, `OpAssign` traits may have\n-    /// implementations that differ from the regular `Op` impl.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// let mut a = 5;\n-    /// let b = 0;\n-    /// // ...\n-    ///\n-    /// a = a + b;\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust\n-    /// let mut a = 5;\n-    /// let b = 0;\n-    /// // ...\n-    ///\n-    /// a += b;\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub ASSIGN_OP_PATTERN,\n-    style,\n-    \"assigning the result of an operation on a variable to that same variable\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for `a op= a op b` or `a op= b op a` patterns.\n-    ///\n-    /// ### Why is this bad?\n-    /// Most likely these are bugs where one meant to write `a\n-    /// op= b`.\n-    ///\n-    /// ### Known problems\n-    /// Clippy cannot know for sure if `a op= a op b` should have\n-    /// been `a = a op a op b` or `a = a op b`/`a op= b`. Therefore, it suggests both.\n-    /// If `a op= a op b` is really the correct behavior it should be\n-    /// written as `a = a op a op b` as it's less confusing.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// let mut a = 5;\n-    /// let b = 2;\n-    /// // ...\n-    /// a += a + b;\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub MISREFACTORED_ASSIGN_OP,\n-    suspicious,\n-    \"having a variable on both sides of an assign op\"\n-}\n-\n-declare_lint_pass!(AssignOps => [ASSIGN_OP_PATTERN, MISREFACTORED_ASSIGN_OP]);\n-\n-impl<'tcx> LateLintPass<'tcx> for AssignOps {\n-    #[allow(clippy::too_many_lines)]\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n-        match &expr.kind {\n-            hir::ExprKind::AssignOp(op, lhs, rhs) => {\n-                if let hir::ExprKind::Binary(binop, l, r) = &rhs.kind {\n-                    if op.node != binop.node {\n-                        return;\n-                    }\n-                    // lhs op= l op r\n-                    if eq_expr_value(cx, lhs, l) {\n-                        lint_misrefactored_assign_op(cx, expr, *op, rhs, lhs, r);\n-                    }\n-                    // lhs op= l commutative_op r\n-                    if is_commutative(op.node) && eq_expr_value(cx, lhs, r) {\n-                        lint_misrefactored_assign_op(cx, expr, *op, rhs, lhs, l);\n-                    }\n-                }\n-            },\n-            hir::ExprKind::Assign(assignee, e, _) => {\n-                if let hir::ExprKind::Binary(op, l, r) = &e.kind {\n-                    let lint = |assignee: &hir::Expr<'_>, rhs: &hir::Expr<'_>| {\n-                        let ty = cx.typeck_results().expr_ty(assignee);\n-                        let rty = cx.typeck_results().expr_ty(rhs);\n-                        if_chain! {\n-                            if let Some((_, lang_item)) = binop_traits(op.node);\n-                            if let Ok(trait_id) = cx.tcx.lang_items().require(lang_item);\n-                            let parent_fn = cx.tcx.hir().get_parent_item(e.hir_id);\n-                            if trait_ref_of_method(cx, parent_fn)\n-                                .map_or(true, |t| t.path.res.def_id() != trait_id);\n-                            if implements_trait(cx, ty, trait_id, &[rty.into()]);\n-                            then {\n-                                span_lint_and_then(\n-                                    cx,\n-                                    ASSIGN_OP_PATTERN,\n-                                    expr.span,\n-                                    \"manual implementation of an assign operation\",\n-                                    |diag| {\n-                                        if let (Some(snip_a), Some(snip_r)) =\n-                                            (snippet_opt(cx, assignee.span), snippet_opt(cx, rhs.span))\n-                                        {\n-                                            diag.span_suggestion(\n-                                                expr.span,\n-                                                \"replace it with\",\n-                                                format!(\"{} {}= {}\", snip_a, op.node.as_str(), snip_r),\n-                                                Applicability::MachineApplicable,\n-                                            );\n-                                        }\n-                                    },\n-                                );\n-                            }\n-                        }\n-                    };\n-\n-                    let mut visitor = ExprVisitor {\n-                        assignee,\n-                        counter: 0,\n-                        cx,\n-                    };\n-\n-                    walk_expr(&mut visitor, e);\n-\n-                    if visitor.counter == 1 {\n-                        // a = a op b\n-                        if eq_expr_value(cx, assignee, l) {\n-                            lint(assignee, r);\n-                        }\n-                        // a = b commutative_op a\n-                        // Limited to primitive type as these ops are know to be commutative\n-                        if eq_expr_value(cx, assignee, r) && cx.typeck_results().expr_ty(assignee).is_primitive_ty() {\n-                            match op.node {\n-                                hir::BinOpKind::Add\n-                                | hir::BinOpKind::Mul\n-                                | hir::BinOpKind::And\n-                                | hir::BinOpKind::Or\n-                                | hir::BinOpKind::BitXor\n-                                | hir::BinOpKind::BitAnd\n-                                | hir::BinOpKind::BitOr => {\n-                                    lint(assignee, l);\n-                                },\n-                                _ => {},\n-                            }\n-                        }\n-                    }\n-                }\n-            },\n-            _ => {},\n-        }\n-    }\n-}\n-\n-fn lint_misrefactored_assign_op(\n-    cx: &LateContext<'_>,\n-    expr: &hir::Expr<'_>,\n-    op: hir::BinOp,\n-    rhs: &hir::Expr<'_>,\n-    assignee: &hir::Expr<'_>,\n-    rhs_other: &hir::Expr<'_>,\n-) {\n-    span_lint_and_then(\n-        cx,\n-        MISREFACTORED_ASSIGN_OP,\n-        expr.span,\n-        \"variable appears on both sides of an assignment operation\",\n-        |diag| {\n-            if let (Some(snip_a), Some(snip_r)) = (snippet_opt(cx, assignee.span), snippet_opt(cx, rhs_other.span)) {\n-                let a = &sugg::Sugg::hir(cx, assignee, \"..\");\n-                let r = &sugg::Sugg::hir(cx, rhs, \"..\");\n-                let long = format!(\"{} = {}\", snip_a, sugg::make_binop(op.node.into(), a, r));\n-                diag.span_suggestion(\n-                    expr.span,\n-                    &format!(\n-                        \"did you mean `{} = {} {} {}` or `{}`? Consider replacing it with\",\n-                        snip_a,\n-                        snip_a,\n-                        op.node.as_str(),\n-                        snip_r,\n-                        long\n-                    ),\n-                    format!(\"{} {}= {}\", snip_a, op.node.as_str(), snip_r),\n-                    Applicability::MaybeIncorrect,\n-                );\n-                diag.span_suggestion(\n-                    expr.span,\n-                    \"or\",\n-                    long,\n-                    Applicability::MaybeIncorrect, // snippet\n-                );\n-            }\n-        },\n-    );\n-}\n-\n-#[must_use]\n-fn is_commutative(op: hir::BinOpKind) -> bool {\n-    use rustc_hir::BinOpKind::{\n-        Add, And, BitAnd, BitOr, BitXor, Div, Eq, Ge, Gt, Le, Lt, Mul, Ne, Or, Rem, Shl, Shr, Sub,\n-    };\n-    match op {\n-        Add | Mul | And | Or | BitXor | BitAnd | BitOr | Eq | Ne => true,\n-        Sub | Div | Rem | Shl | Shr | Lt | Le | Ge | Gt => false,\n-    }\n-}\n-\n-struct ExprVisitor<'a, 'tcx> {\n-    assignee: &'a hir::Expr<'a>,\n-    counter: u8,\n-    cx: &'a LateContext<'tcx>,\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for ExprVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n-        if eq_expr_value(self.cx, self.assignee, expr) {\n-            self.counter += 1;\n-        }\n-\n-        walk_expr(self, expr);\n-    }\n-}"}, {"sha": "ee0440e52ff85a1ec3bb65d8c88d4801348fa2d3", "filename": "clippy_lints/src/double_comparison.rs", "status": "removed", "additions": 0, "deletions": 96, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/b776fb82941cadfc752368901f210831d5184d95/clippy_lints%2Fsrc%2Fdouble_comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b776fb82941cadfc752368901f210831d5184d95/clippy_lints%2Fsrc%2Fdouble_comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdouble_comparison.rs?ref=b776fb82941cadfc752368901f210831d5184d95", "patch": "@@ -1,96 +0,0 @@\n-//! Lint on unnecessary double comparisons. Some examples:\n-\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::eq_expr_value;\n-use clippy_utils::source::snippet_with_applicability;\n-use rustc_errors::Applicability;\n-use rustc_hir::{BinOpKind, Expr, ExprKind};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::source_map::Span;\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for double comparisons that could be simplified to a single expression.\n-    ///\n-    ///\n-    /// ### Why is this bad?\n-    /// Readability.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # let x = 1;\n-    /// # let y = 2;\n-    /// if x == y || x < y {}\n-    /// ```\n-    ///\n-    /// Use instead:\n-    ///\n-    /// ```rust\n-    /// # let x = 1;\n-    /// # let y = 2;\n-    /// if x <= y {}\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub DOUBLE_COMPARISONS,\n-    complexity,\n-    \"unnecessary double comparisons that can be simplified\"\n-}\n-\n-declare_lint_pass!(DoubleComparisons => [DOUBLE_COMPARISONS]);\n-\n-impl<'tcx> DoubleComparisons {\n-    #[expect(clippy::similar_names)]\n-    fn check_binop(cx: &LateContext<'tcx>, op: BinOpKind, lhs: &'tcx Expr<'_>, rhs: &'tcx Expr<'_>, span: Span) {\n-        let (lkind, llhs, lrhs, rkind, rlhs, rrhs) = match (&lhs.kind, &rhs.kind) {\n-            (ExprKind::Binary(lb, llhs, lrhs), ExprKind::Binary(rb, rlhs, rrhs)) => {\n-                (lb.node, llhs, lrhs, rb.node, rlhs, rrhs)\n-            },\n-            _ => return,\n-        };\n-        if !(eq_expr_value(cx, llhs, rlhs) && eq_expr_value(cx, lrhs, rrhs)) {\n-            return;\n-        }\n-        macro_rules! lint_double_comparison {\n-            ($op:tt) => {{\n-                let mut applicability = Applicability::MachineApplicable;\n-                let lhs_str = snippet_with_applicability(cx, llhs.span, \"\", &mut applicability);\n-                let rhs_str = snippet_with_applicability(cx, lrhs.span, \"\", &mut applicability);\n-                let sugg = format!(\"{} {} {}\", lhs_str, stringify!($op), rhs_str);\n-                span_lint_and_sugg(\n-                    cx,\n-                    DOUBLE_COMPARISONS,\n-                    span,\n-                    \"this binary expression can be simplified\",\n-                    \"try\",\n-                    sugg,\n-                    applicability,\n-                );\n-            }};\n-        }\n-        #[rustfmt::skip]\n-        match (op, lkind, rkind) {\n-            (BinOpKind::Or, BinOpKind::Eq, BinOpKind::Lt) | (BinOpKind::Or, BinOpKind::Lt, BinOpKind::Eq) => {\n-                lint_double_comparison!(<=);\n-            },\n-            (BinOpKind::Or, BinOpKind::Eq, BinOpKind::Gt) | (BinOpKind::Or, BinOpKind::Gt, BinOpKind::Eq) => {\n-                lint_double_comparison!(>=);\n-            },\n-            (BinOpKind::Or, BinOpKind::Lt, BinOpKind::Gt) | (BinOpKind::Or, BinOpKind::Gt, BinOpKind::Lt) => {\n-                lint_double_comparison!(!=);\n-            },\n-            (BinOpKind::And, BinOpKind::Le, BinOpKind::Ge) | (BinOpKind::And, BinOpKind::Ge, BinOpKind::Le) => {\n-                lint_double_comparison!(==);\n-            },\n-            _ => (),\n-        };\n-    }\n-}\n-\n-impl<'tcx> LateLintPass<'tcx> for DoubleComparisons {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let ExprKind::Binary(ref kind, lhs, rhs) = expr.kind {\n-            Self::check_binop(cx, kind.node, lhs, rhs, expr.span);\n-        }\n-    }\n-}"}, {"sha": "d85ace3a279b3b8e4b9d586301c06c75222f5246", "filename": "clippy_lints/src/duration_subsec.rs", "status": "removed", "additions": 0, "deletions": 75, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/b776fb82941cadfc752368901f210831d5184d95/clippy_lints%2Fsrc%2Fduration_subsec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b776fb82941cadfc752368901f210831d5184d95/clippy_lints%2Fsrc%2Fduration_subsec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fduration_subsec.rs?ref=b776fb82941cadfc752368901f210831d5184d95", "patch": "@@ -1,75 +0,0 @@\n-use clippy_utils::consts::{constant, Constant};\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::ty::is_type_diagnostic_item;\n-use if_chain::if_chain;\n-use rustc_errors::Applicability;\n-use rustc_hir::{BinOpKind, Expr, ExprKind};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::source_map::Spanned;\n-use rustc_span::sym;\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for calculation of subsecond microseconds or milliseconds\n-    /// from other `Duration` methods.\n-    ///\n-    /// ### Why is this bad?\n-    /// It's more concise to call `Duration::subsec_micros()` or\n-    /// `Duration::subsec_millis()` than to calculate them.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # use std::time::Duration;\n-    /// # let duration = Duration::new(5, 0);\n-    /// let micros = duration.subsec_nanos() / 1_000;\n-    /// let millis = duration.subsec_nanos() / 1_000_000;\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust\n-    /// # use std::time::Duration;\n-    /// # let duration = Duration::new(5, 0);\n-    /// let micros = duration.subsec_micros();\n-    /// let millis = duration.subsec_millis();\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub DURATION_SUBSEC,\n-    complexity,\n-    \"checks for calculation of subsecond microseconds or milliseconds\"\n-}\n-\n-declare_lint_pass!(DurationSubsec => [DURATION_SUBSEC]);\n-\n-impl<'tcx> LateLintPass<'tcx> for DurationSubsec {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if_chain! {\n-            if let ExprKind::Binary(Spanned { node: BinOpKind::Div, .. }, left, right) = expr.kind;\n-            if let ExprKind::MethodCall(method_path, args, _) = left.kind;\n-            if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&args[0]).peel_refs(), sym::Duration);\n-            if let Some((Constant::Int(divisor), _)) = constant(cx, cx.typeck_results(), right);\n-            then {\n-                let suggested_fn = match (method_path.ident.as_str(), divisor) {\n-                    (\"subsec_micros\", 1_000) | (\"subsec_nanos\", 1_000_000) => \"subsec_millis\",\n-                    (\"subsec_nanos\", 1_000) => \"subsec_micros\",\n-                    _ => return,\n-                };\n-                let mut applicability = Applicability::MachineApplicable;\n-                span_lint_and_sugg(\n-                    cx,\n-                    DURATION_SUBSEC,\n-                    expr.span,\n-                    &format!(\"calling `{}()` is more concise than this calculation\", suggested_fn),\n-                    \"try\",\n-                    format!(\n-                        \"{}.{}()\",\n-                        snippet_with_applicability(cx, args[0].span, \"_\", &mut applicability),\n-                        suggested_fn\n-                    ),\n-                    applicability,\n-                );\n-            }\n-        }\n-    }\n-}"}, {"sha": "2f4c90d07cf666c9dede8ea2bbba5b1bddeaf5f2", "filename": "clippy_lints/src/eq_op.rs", "status": "removed", "additions": 0, "deletions": 319, "changes": 319, "blob_url": "https://github.com/rust-lang/rust/blob/b776fb82941cadfc752368901f210831d5184d95/clippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b776fb82941cadfc752368901f210831d5184d95/clippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feq_op.rs?ref=b776fb82941cadfc752368901f210831d5184d95", "patch": "@@ -1,319 +0,0 @@\n-use clippy_utils::diagnostics::{multispan_sugg, span_lint, span_lint_and_then};\n-use clippy_utils::get_enclosing_block;\n-use clippy_utils::macros::{find_assert_eq_args, first_node_macro_backtrace};\n-use clippy_utils::source::snippet;\n-use clippy_utils::ty::{implements_trait, is_copy};\n-use clippy_utils::{ast_utils::is_useless_with_eq_exprs, eq_expr_value, is_in_test_function};\n-use if_chain::if_chain;\n-use rustc_errors::Applicability;\n-use rustc_hir::{def::Res, def_id::DefId, BinOpKind, BorrowKind, Expr, ExprKind, GenericArg, ItemKind, QPath, TyKind};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::{self, Ty};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for equal operands to comparison, logical and\n-    /// bitwise, difference and division binary operators (`==`, `>`, etc., `&&`,\n-    /// `||`, `&`, `|`, `^`, `-` and `/`).\n-    ///\n-    /// ### Why is this bad?\n-    /// This is usually just a typo or a copy and paste error.\n-    ///\n-    /// ### Known problems\n-    /// False negatives: We had some false positives regarding\n-    /// calls (notably [racer](https://github.com/phildawes/racer) had one instance\n-    /// of `x.pop() && x.pop()`), so we removed matching any function or method\n-    /// calls. We may introduce a list of known pure functions in the future.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # let x = 1;\n-    /// if x + 1 == x + 1 {}\n-    ///\n-    /// // or\n-    ///\n-    /// # let a = 3;\n-    /// # let b = 4;\n-    /// assert_eq!(a, a);\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub EQ_OP,\n-    correctness,\n-    \"equal operands on both sides of a comparison or bitwise combination (e.g., `x == x`)\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for arguments to `==` which have their address\n-    /// taken to satisfy a bound\n-    /// and suggests to dereference the other argument instead\n-    ///\n-    /// ### Why is this bad?\n-    /// It is more idiomatic to dereference the other argument.\n-    ///\n-    /// ### Example\n-    /// ```rust,ignore\n-    /// &x == y\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust,ignore\n-    /// x == *y\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub OP_REF,\n-    style,\n-    \"taking a reference to satisfy the type constraints on `==`\"\n-}\n-\n-declare_lint_pass!(EqOp => [EQ_OP, OP_REF]);\n-\n-impl<'tcx> LateLintPass<'tcx> for EqOp {\n-    #[expect(clippy::similar_names, clippy::too_many_lines)]\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n-        if_chain! {\n-            if let Some((macro_call, macro_name)) = first_node_macro_backtrace(cx, e).find_map(|macro_call| {\n-                let name = cx.tcx.item_name(macro_call.def_id);\n-                matches!(name.as_str(), \"assert_eq\" | \"assert_ne\" | \"debug_assert_eq\" | \"debug_assert_ne\")\n-                    .then(|| (macro_call, name))\n-            });\n-            if let Some((lhs, rhs, _)) = find_assert_eq_args(cx, e, macro_call.expn);\n-            if eq_expr_value(cx, lhs, rhs);\n-            if macro_call.is_local();\n-            if !is_in_test_function(cx.tcx, e.hir_id);\n-            then {\n-                span_lint(\n-                    cx,\n-                    EQ_OP,\n-                    lhs.span.to(rhs.span),\n-                    &format!(\"identical args used in this `{}!` macro call\", macro_name),\n-                );\n-            }\n-        }\n-        if let ExprKind::Binary(op, left, right) = e.kind {\n-            if e.span.from_expansion() {\n-                return;\n-            }\n-            let macro_with_not_op = |expr_kind: &ExprKind<'_>| {\n-                if let ExprKind::Unary(_, expr) = *expr_kind {\n-                    expr.span.from_expansion()\n-                } else {\n-                    false\n-                }\n-            };\n-            if macro_with_not_op(&left.kind) || macro_with_not_op(&right.kind) {\n-                return;\n-            }\n-            if is_useless_with_eq_exprs(op.node.into())\n-                && eq_expr_value(cx, left, right)\n-                && !is_in_test_function(cx.tcx, e.hir_id)\n-            {\n-                span_lint(\n-                    cx,\n-                    EQ_OP,\n-                    e.span,\n-                    &format!(\"equal expressions as operands to `{}`\", op.node.as_str()),\n-                );\n-                return;\n-            }\n-            let (trait_id, requires_ref) = match op.node {\n-                BinOpKind::Add => (cx.tcx.lang_items().add_trait(), false),\n-                BinOpKind::Sub => (cx.tcx.lang_items().sub_trait(), false),\n-                BinOpKind::Mul => (cx.tcx.lang_items().mul_trait(), false),\n-                BinOpKind::Div => (cx.tcx.lang_items().div_trait(), false),\n-                BinOpKind::Rem => (cx.tcx.lang_items().rem_trait(), false),\n-                // don't lint short circuiting ops\n-                BinOpKind::And | BinOpKind::Or => return,\n-                BinOpKind::BitXor => (cx.tcx.lang_items().bitxor_trait(), false),\n-                BinOpKind::BitAnd => (cx.tcx.lang_items().bitand_trait(), false),\n-                BinOpKind::BitOr => (cx.tcx.lang_items().bitor_trait(), false),\n-                BinOpKind::Shl => (cx.tcx.lang_items().shl_trait(), false),\n-                BinOpKind::Shr => (cx.tcx.lang_items().shr_trait(), false),\n-                BinOpKind::Ne | BinOpKind::Eq => (cx.tcx.lang_items().eq_trait(), true),\n-                BinOpKind::Lt | BinOpKind::Le | BinOpKind::Ge | BinOpKind::Gt => {\n-                    (cx.tcx.lang_items().partial_ord_trait(), true)\n-                },\n-            };\n-            if let Some(trait_id) = trait_id {\n-                match (&left.kind, &right.kind) {\n-                    // do not suggest to dereference literals\n-                    (&ExprKind::Lit(..), _) | (_, &ExprKind::Lit(..)) => {},\n-                    // &foo == &bar\n-                    (&ExprKind::AddrOf(BorrowKind::Ref, _, l), &ExprKind::AddrOf(BorrowKind::Ref, _, r)) => {\n-                        let lty = cx.typeck_results().expr_ty(l);\n-                        let rty = cx.typeck_results().expr_ty(r);\n-                        let lcpy = is_copy(cx, lty);\n-                        let rcpy = is_copy(cx, rty);\n-                        if let Some((self_ty, other_ty)) = in_impl(cx, e, trait_id) {\n-                            if (are_equal(cx, rty, self_ty) && are_equal(cx, lty, other_ty))\n-                                || (are_equal(cx, rty, other_ty) && are_equal(cx, lty, self_ty))\n-                            {\n-                                return; // Don't lint\n-                            }\n-                        }\n-                        // either operator autorefs or both args are copyable\n-                        if (requires_ref || (lcpy && rcpy)) && implements_trait(cx, lty, trait_id, &[rty.into()]) {\n-                            span_lint_and_then(\n-                                cx,\n-                                OP_REF,\n-                                e.span,\n-                                \"needlessly taken reference of both operands\",\n-                                |diag| {\n-                                    let lsnip = snippet(cx, l.span, \"...\").to_string();\n-                                    let rsnip = snippet(cx, r.span, \"...\").to_string();\n-                                    multispan_sugg(\n-                                        diag,\n-                                        \"use the values directly\",\n-                                        vec![(left.span, lsnip), (right.span, rsnip)],\n-                                    );\n-                                },\n-                            );\n-                        } else if lcpy\n-                            && !rcpy\n-                            && implements_trait(cx, lty, trait_id, &[cx.typeck_results().expr_ty(right).into()])\n-                        {\n-                            span_lint_and_then(\n-                                cx,\n-                                OP_REF,\n-                                e.span,\n-                                \"needlessly taken reference of left operand\",\n-                                |diag| {\n-                                    let lsnip = snippet(cx, l.span, \"...\").to_string();\n-                                    diag.span_suggestion(\n-                                        left.span,\n-                                        \"use the left value directly\",\n-                                        lsnip,\n-                                        Applicability::MaybeIncorrect, // FIXME #2597\n-                                    );\n-                                },\n-                            );\n-                        } else if !lcpy\n-                            && rcpy\n-                            && implements_trait(cx, cx.typeck_results().expr_ty(left), trait_id, &[rty.into()])\n-                        {\n-                            span_lint_and_then(\n-                                cx,\n-                                OP_REF,\n-                                e.span,\n-                                \"needlessly taken reference of right operand\",\n-                                |diag| {\n-                                    let rsnip = snippet(cx, r.span, \"...\").to_string();\n-                                    diag.span_suggestion(\n-                                        right.span,\n-                                        \"use the right value directly\",\n-                                        rsnip,\n-                                        Applicability::MaybeIncorrect, // FIXME #2597\n-                                    );\n-                                },\n-                            );\n-                        }\n-                    },\n-                    // &foo == bar\n-                    (&ExprKind::AddrOf(BorrowKind::Ref, _, l), _) => {\n-                        let lty = cx.typeck_results().expr_ty(l);\n-                        if let Some((self_ty, other_ty)) = in_impl(cx, e, trait_id) {\n-                            let rty = cx.typeck_results().expr_ty(right);\n-                            if (are_equal(cx, rty, self_ty) && are_equal(cx, lty, other_ty))\n-                                || (are_equal(cx, rty, other_ty) && are_equal(cx, lty, self_ty))\n-                            {\n-                                return; // Don't lint\n-                            }\n-                        }\n-                        let lcpy = is_copy(cx, lty);\n-                        if (requires_ref || lcpy)\n-                            && implements_trait(cx, lty, trait_id, &[cx.typeck_results().expr_ty(right).into()])\n-                        {\n-                            span_lint_and_then(\n-                                cx,\n-                                OP_REF,\n-                                e.span,\n-                                \"needlessly taken reference of left operand\",\n-                                |diag| {\n-                                    let lsnip = snippet(cx, l.span, \"...\").to_string();\n-                                    diag.span_suggestion(\n-                                        left.span,\n-                                        \"use the left value directly\",\n-                                        lsnip,\n-                                        Applicability::MaybeIncorrect, // FIXME #2597\n-                                    );\n-                                },\n-                            );\n-                        }\n-                    },\n-                    // foo == &bar\n-                    (_, &ExprKind::AddrOf(BorrowKind::Ref, _, r)) => {\n-                        let rty = cx.typeck_results().expr_ty(r);\n-                        if let Some((self_ty, other_ty)) = in_impl(cx, e, trait_id) {\n-                            let lty = cx.typeck_results().expr_ty(left);\n-                            if (are_equal(cx, rty, self_ty) && are_equal(cx, lty, other_ty))\n-                                || (are_equal(cx, rty, other_ty) && are_equal(cx, lty, self_ty))\n-                            {\n-                                return; // Don't lint\n-                            }\n-                        }\n-                        let rcpy = is_copy(cx, rty);\n-                        if (requires_ref || rcpy)\n-                            && implements_trait(cx, cx.typeck_results().expr_ty(left), trait_id, &[rty.into()])\n-                        {\n-                            span_lint_and_then(cx, OP_REF, e.span, \"taken reference of right operand\", |diag| {\n-                                let rsnip = snippet(cx, r.span, \"...\").to_string();\n-                                diag.span_suggestion(\n-                                    right.span,\n-                                    \"use the right value directly\",\n-                                    rsnip,\n-                                    Applicability::MaybeIncorrect, // FIXME #2597\n-                                );\n-                            });\n-                        }\n-                    },\n-                    _ => {},\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-fn in_impl<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    e: &'tcx Expr<'_>,\n-    bin_op: DefId,\n-) -> Option<(&'tcx rustc_hir::Ty<'tcx>, &'tcx rustc_hir::Ty<'tcx>)> {\n-    if_chain! {\n-        if let Some(block) = get_enclosing_block(cx, e.hir_id);\n-        if let Some(impl_def_id) = cx.tcx.impl_of_method(block.hir_id.owner.to_def_id());\n-        let item = cx.tcx.hir().expect_item(impl_def_id.expect_local());\n-        if let ItemKind::Impl(item) = &item.kind;\n-        if let Some(of_trait) = &item.of_trait;\n-        if let Some(seg) = of_trait.path.segments.last();\n-        if let Some(Res::Def(_, trait_id)) = seg.res;\n-        if trait_id == bin_op;\n-        if let Some(generic_args) = seg.args;\n-        if let Some(GenericArg::Type(other_ty)) = generic_args.args.last();\n-\n-        then {\n-            Some((item.self_ty, other_ty))\n-        }\n-        else {\n-            None\n-        }\n-    }\n-}\n-\n-fn are_equal<'tcx>(cx: &LateContext<'tcx>, middle_ty: Ty<'_>, hir_ty: &rustc_hir::Ty<'_>) -> bool {\n-    if_chain! {\n-        if let ty::Adt(adt_def, _) = middle_ty.kind();\n-        if let Some(local_did) = adt_def.did().as_local();\n-        let item = cx.tcx.hir().expect_item(local_did);\n-        let middle_ty_id = item.def_id.to_def_id();\n-        if let TyKind::Path(QPath::Resolved(_, path)) = hir_ty.kind;\n-        if let Res::Def(_, hir_ty_id) = path.res;\n-\n-        then {\n-            hir_ty_id == middle_ty_id\n-        }\n-        else {\n-            false\n-        }\n-    }\n-}"}, {"sha": "c1a84973c42114945130d4c5e9fbeeba75042efd", "filename": "clippy_lints/src/erasing_op.rs", "status": "removed", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/b776fb82941cadfc752368901f210831d5184d95/clippy_lints%2Fsrc%2Ferasing_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b776fb82941cadfc752368901f210831d5184d95/clippy_lints%2Fsrc%2Ferasing_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ferasing_op.rs?ref=b776fb82941cadfc752368901f210831d5184d95", "patch": "@@ -1,77 +0,0 @@\n-use clippy_utils::consts::{constant_simple, Constant};\n-use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::ty::same_type_and_consts;\n-\n-use rustc_hir::{BinOpKind, Expr, ExprKind};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::TypeckResults;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for erasing operations, e.g., `x * 0`.\n-    ///\n-    /// ### Why is this bad?\n-    /// The whole expression can be replaced by zero.\n-    /// This is most likely not the intended outcome and should probably be\n-    /// corrected\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// let x = 1;\n-    /// 0 / x;\n-    /// 0 * x;\n-    /// x & 0;\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub ERASING_OP,\n-    correctness,\n-    \"using erasing operations, e.g., `x * 0` or `y & 0`\"\n-}\n-\n-declare_lint_pass!(ErasingOp => [ERASING_OP]);\n-\n-impl<'tcx> LateLintPass<'tcx> for ErasingOp {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n-        if e.span.from_expansion() {\n-            return;\n-        }\n-        if let ExprKind::Binary(ref cmp, left, right) = e.kind {\n-            let tck = cx.typeck_results();\n-            match cmp.node {\n-                BinOpKind::Mul | BinOpKind::BitAnd => {\n-                    check(cx, tck, left, right, e);\n-                    check(cx, tck, right, left, e);\n-                },\n-                BinOpKind::Div => check(cx, tck, left, right, e),\n-                _ => (),\n-            }\n-        }\n-    }\n-}\n-\n-fn different_types(tck: &TypeckResults<'_>, input: &Expr<'_>, output: &Expr<'_>) -> bool {\n-    let input_ty = tck.expr_ty(input).peel_refs();\n-    let output_ty = tck.expr_ty(output).peel_refs();\n-    !same_type_and_consts(input_ty, output_ty)\n-}\n-\n-fn check<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    tck: &TypeckResults<'tcx>,\n-    op: &Expr<'tcx>,\n-    other: &Expr<'tcx>,\n-    parent: &Expr<'tcx>,\n-) {\n-    if constant_simple(cx, tck, op) == Some(Constant::Int(0)) {\n-        if different_types(tck, other, parent) {\n-            return;\n-        }\n-        span_lint(\n-            cx,\n-            ERASING_OP,\n-            parent.span,\n-            \"this operation will always return zero. This is likely not the intended outcome\",\n-        );\n-    }\n-}"}, {"sha": "98aee7592ae80a496bde4da3e3f47327a7a547b3", "filename": "clippy_lints/src/float_equality_without_abs.rs", "status": "removed", "additions": 0, "deletions": 116, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/b776fb82941cadfc752368901f210831d5184d95/clippy_lints%2Fsrc%2Ffloat_equality_without_abs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b776fb82941cadfc752368901f210831d5184d95/clippy_lints%2Fsrc%2Ffloat_equality_without_abs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffloat_equality_without_abs.rs?ref=b776fb82941cadfc752368901f210831d5184d95", "patch": "@@ -1,116 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::{match_def_path, paths, sugg};\n-use if_chain::if_chain;\n-use rustc_ast::util::parser::AssocOp;\n-use rustc_errors::Applicability;\n-use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::{BinOpKind, Expr, ExprKind};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::source_map::Spanned;\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for statements of the form `(a - b) < f32::EPSILON` or\n-    /// `(a - b) < f64::EPSILON`. Notes the missing `.abs()`.\n-    ///\n-    /// ### Why is this bad?\n-    /// The code without `.abs()` is more likely to have a bug.\n-    ///\n-    /// ### Known problems\n-    /// If the user can ensure that b is larger than a, the `.abs()` is\n-    /// technically unnecessary. However, it will make the code more robust and doesn't have any\n-    /// large performance implications. If the abs call was deliberately left out for performance\n-    /// reasons, it is probably better to state this explicitly in the code, which then can be done\n-    /// with an allow.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// pub fn is_roughly_equal(a: f32, b: f32) -> bool {\n-    ///     (a - b) < f32::EPSILON\n-    /// }\n-    /// ```\n-    /// Use instead:\n-    /// ```rust\n-    /// pub fn is_roughly_equal(a: f32, b: f32) -> bool {\n-    ///     (a - b).abs() < f32::EPSILON\n-    /// }\n-    /// ```\n-    #[clippy::version = \"1.48.0\"]\n-    pub FLOAT_EQUALITY_WITHOUT_ABS,\n-    suspicious,\n-    \"float equality check without `.abs()`\"\n-}\n-\n-declare_lint_pass!(FloatEqualityWithoutAbs => [FLOAT_EQUALITY_WITHOUT_ABS]);\n-\n-impl<'tcx> LateLintPass<'tcx> for FloatEqualityWithoutAbs {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        let lhs;\n-        let rhs;\n-\n-        // check if expr is a binary expression with a lt or gt operator\n-        if let ExprKind::Binary(op, left, right) = expr.kind {\n-            match op.node {\n-                BinOpKind::Lt => {\n-                    lhs = left;\n-                    rhs = right;\n-                },\n-                BinOpKind::Gt => {\n-                    lhs = right;\n-                    rhs = left;\n-                },\n-                _ => return,\n-            };\n-        } else {\n-            return;\n-        }\n-\n-        if_chain! {\n-\n-            // left hand side is a subtraction\n-            if let ExprKind::Binary(\n-                Spanned {\n-                    node: BinOpKind::Sub,\n-                    ..\n-                },\n-                val_l,\n-                val_r,\n-            ) = lhs.kind;\n-\n-            // right hand side matches either f32::EPSILON or f64::EPSILON\n-            if let ExprKind::Path(ref epsilon_path) = rhs.kind;\n-            if let Res::Def(DefKind::AssocConst, def_id) = cx.qpath_res(epsilon_path, rhs.hir_id);\n-            if match_def_path(cx, def_id, &paths::F32_EPSILON) || match_def_path(cx, def_id, &paths::F64_EPSILON);\n-\n-            // values of the subtractions on the left hand side are of the type float\n-            let t_val_l = cx.typeck_results().expr_ty(val_l);\n-            let t_val_r = cx.typeck_results().expr_ty(val_r);\n-            if let ty::Float(_) = t_val_l.kind();\n-            if let ty::Float(_) = t_val_r.kind();\n-\n-            then {\n-                let sug_l = sugg::Sugg::hir(cx, val_l, \"..\");\n-                let sug_r = sugg::Sugg::hir(cx, val_r, \"..\");\n-                // format the suggestion\n-                let suggestion = format!(\"{}.abs()\", sugg::make_assoc(AssocOp::Subtract, &sug_l, &sug_r).maybe_par());\n-                // spans the lint\n-                span_lint_and_then(\n-                    cx,\n-                    FLOAT_EQUALITY_WITHOUT_ABS,\n-                    expr.span,\n-                    \"float equality check without `.abs()`\",\n-                    | diag | {\n-                        diag.span_suggestion(\n-                            lhs.span,\n-                            \"add `.abs()`\",\n-                            suggestion,\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n-                );\n-            }\n-        }\n-    }\n-}"}, {"sha": "3effba5682607a241c208124760c2905a25c1997", "filename": "clippy_lints/src/integer_division.rs", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/b776fb82941cadfc752368901f210831d5184d95/clippy_lints%2Fsrc%2Finteger_division.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b776fb82941cadfc752368901f210831d5184d95/clippy_lints%2Fsrc%2Finteger_division.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finteger_division.rs?ref=b776fb82941cadfc752368901f210831d5184d95", "patch": "@@ -1,61 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_help;\n-use if_chain::if_chain;\n-use rustc_hir as hir;\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for division of integers\n-    ///\n-    /// ### Why is this bad?\n-    /// When outside of some very specific algorithms,\n-    /// integer division is very often a mistake because it discards the\n-    /// remainder.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// let x = 3 / 2;\n-    /// println!(\"{}\", x);\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust\n-    /// let x = 3f32 / 2f32;\n-    /// println!(\"{}\", x);\n-    /// ```\n-    #[clippy::version = \"1.37.0\"]\n-    pub INTEGER_DIVISION,\n-    restriction,\n-    \"integer division may cause loss of precision\"\n-}\n-\n-declare_lint_pass!(IntegerDivision => [INTEGER_DIVISION]);\n-\n-impl<'tcx> LateLintPass<'tcx> for IntegerDivision {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n-        if is_integer_division(cx, expr) {\n-            span_lint_and_help(\n-                cx,\n-                INTEGER_DIVISION,\n-                expr.span,\n-                \"integer division\",\n-                None,\n-                \"division of integers may cause loss of precision. consider using floats\",\n-            );\n-        }\n-    }\n-}\n-\n-fn is_integer_division<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) -> bool {\n-    if_chain! {\n-        if let hir::ExprKind::Binary(binop, left, right) = &expr.kind;\n-        if binop.node == hir::BinOpKind::Div;\n-        then {\n-            let (left_ty, right_ty) = (cx.typeck_results().expr_ty(left), cx.typeck_results().expr_ty(right));\n-            return left_ty.is_integral() && right_ty.is_integral();\n-        }\n-    }\n-\n-    false\n-}"}, {"sha": "27acdd7c726e1e9611899e8e23dacb76b9f80343", "filename": "clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_all.rs?ref=23c6765276c968bf0fe4ee01f619f357b78390ca", "patch": "@@ -3,12 +3,9 @@\n // Manual edits will be overwritten.\n \n store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n-    LintId::of(absurd_extreme_comparisons::ABSURD_EXTREME_COMPARISONS),\n     LintId::of(almost_complete_letter_range::ALMOST_COMPLETE_LETTER_RANGE),\n     LintId::of(approx_const::APPROX_CONSTANT),\n     LintId::of(assertions_on_constants::ASSERTIONS_ON_CONSTANTS),\n-    LintId::of(assign_ops::ASSIGN_OP_PATTERN),\n-    LintId::of(assign_ops::MISREFACTORED_ASSIGN_OP),\n     LintId::of(async_yields_async::ASYNC_YIELDS_ASYNC),\n     LintId::of(attrs::BLANKET_CLIPPY_RESTRICTION_LINTS),\n     LintId::of(attrs::DEPRECATED_CFG_ATTR),\n@@ -18,8 +15,6 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(await_holding_invalid::AWAIT_HOLDING_INVALID_TYPE),\n     LintId::of(await_holding_invalid::AWAIT_HOLDING_LOCK),\n     LintId::of(await_holding_invalid::AWAIT_HOLDING_REFCELL_REF),\n-    LintId::of(bit_mask::BAD_BIT_MASK),\n-    LintId::of(bit_mask::INEFFECTIVE_BIT_MASK),\n     LintId::of(blacklisted_name::BLACKLISTED_NAME),\n     LintId::of(blocks_in_if_conditions::BLOCKS_IN_IF_CONDITIONS),\n     LintId::of(bool_assert_comparison::BOOL_ASSERT_COMPARISON),\n@@ -53,7 +48,6 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(disallowed_types::DISALLOWED_TYPES),\n     LintId::of(doc::MISSING_SAFETY_DOC),\n     LintId::of(doc::NEEDLESS_DOCTEST_MAIN),\n-    LintId::of(double_comparison::DOUBLE_COMPARISONS),\n     LintId::of(double_parens::DOUBLE_PARENS),\n     LintId::of(drop_forget_ref::DROP_COPY),\n     LintId::of(drop_forget_ref::DROP_NON_DROP),\n@@ -63,18 +57,13 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(drop_forget_ref::FORGET_REF),\n     LintId::of(drop_forget_ref::UNDROPPED_MANUALLY_DROPS),\n     LintId::of(duplicate_mod::DUPLICATE_MOD),\n-    LintId::of(duration_subsec::DURATION_SUBSEC),\n     LintId::of(entry::MAP_ENTRY),\n     LintId::of(enum_clike::ENUM_CLIKE_UNPORTABLE_VARIANT),\n     LintId::of(enum_variants::ENUM_VARIANT_NAMES),\n     LintId::of(enum_variants::MODULE_INCEPTION),\n-    LintId::of(eq_op::EQ_OP),\n-    LintId::of(eq_op::OP_REF),\n-    LintId::of(erasing_op::ERASING_OP),\n     LintId::of(escape::BOXED_LOCAL),\n     LintId::of(eta_reduction::REDUNDANT_CLOSURE),\n     LintId::of(explicit_write::EXPLICIT_WRITE),\n-    LintId::of(float_equality_without_abs::FLOAT_EQUALITY_WITHOUT_ABS),\n     LintId::of(float_literal::EXCESSIVE_PRECISION),\n     LintId::of(format::USELESS_FORMAT),\n     LintId::of(format_args::FORMAT_IN_FORMAT_ARGS),\n@@ -94,7 +83,6 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(functions::RESULT_UNIT_ERR),\n     LintId::of(functions::TOO_MANY_ARGUMENTS),\n     LintId::of(get_first::GET_FIRST),\n-    LintId::of(identity_op::IDENTITY_OP),\n     LintId::of(if_let_mutex::IF_LET_MUTEX),\n     LintId::of(indexing_slicing::OUT_OF_BOUNDS_INDEXING),\n     LintId::of(infinite_iter::INFINITE_ITER),\n@@ -224,9 +212,6 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(methods::WRONG_SELF_CONVENTION),\n     LintId::of(methods::ZST_OFFSET),\n     LintId::of(minmax::MIN_MAX),\n-    LintId::of(misc::CMP_NAN),\n-    LintId::of(misc::CMP_OWNED),\n-    LintId::of(misc::MODULO_ONE),\n     LintId::of(misc::SHORT_CIRCUIT_STATEMENT),\n     LintId::of(misc::TOPLEVEL_REF_ARG),\n     LintId::of(misc::ZERO_PTR),\n@@ -260,6 +245,23 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(non_octal_unix_permissions::NON_OCTAL_UNIX_PERMISSIONS),\n     LintId::of(octal_escapes::OCTAL_ESCAPES),\n     LintId::of(open_options::NONSENSICAL_OPEN_OPTIONS),\n+    LintId::of(operators::ABSURD_EXTREME_COMPARISONS),\n+    LintId::of(operators::ASSIGN_OP_PATTERN),\n+    LintId::of(operators::BAD_BIT_MASK),\n+    LintId::of(operators::CMP_NAN),\n+    LintId::of(operators::CMP_OWNED),\n+    LintId::of(operators::DOUBLE_COMPARISONS),\n+    LintId::of(operators::DURATION_SUBSEC),\n+    LintId::of(operators::EQ_OP),\n+    LintId::of(operators::ERASING_OP),\n+    LintId::of(operators::FLOAT_EQUALITY_WITHOUT_ABS),\n+    LintId::of(operators::IDENTITY_OP),\n+    LintId::of(operators::INEFFECTIVE_BIT_MASK),\n+    LintId::of(operators::MISREFACTORED_ASSIGN_OP),\n+    LintId::of(operators::MODULO_ONE),\n+    LintId::of(operators::OP_REF),\n+    LintId::of(operators::PTR_EQ),\n+    LintId::of(operators::SELF_ASSIGNMENT),\n     LintId::of(option_env_unwrap::OPTION_ENV_UNWRAP),\n     LintId::of(overflow_check_conditional::OVERFLOW_CHECK_CONDITIONAL),\n     LintId::of(partialeq_ne_impl::PARTIALEQ_NE_IMPL),\n@@ -268,7 +270,6 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(ptr::INVALID_NULL_PTR_USAGE),\n     LintId::of(ptr::MUT_FROM_REF),\n     LintId::of(ptr::PTR_ARG),\n-    LintId::of(ptr_eq::PTR_EQ),\n     LintId::of(ptr_offset_with_cast::PTR_OFFSET_WITH_CAST),\n     LintId::of(question_mark::QUESTION_MARK),\n     LintId::of(ranges::MANUAL_RANGE_CONTAINS),\n@@ -286,7 +287,6 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(repeat_once::REPEAT_ONCE),\n     LintId::of(returns::LET_AND_RETURN),\n     LintId::of(returns::NEEDLESS_RETURN),\n-    LintId::of(self_assignment::SELF_ASSIGNMENT),\n     LintId::of(self_named_constructors::SELF_NAMED_CONSTRUCTORS),\n     LintId::of(serde_api::SERDE_API_MISUSE),\n     LintId::of(single_component_path_imports::SINGLE_COMPONENT_PATH_IMPORTS),"}, {"sha": "ed5446f58441149b8806138cc7176de7fb0653ae", "filename": "clippy_lints/src/lib.register_complexity.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Flib.register_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Flib.register_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_complexity.rs?ref=23c6765276c968bf0fe4ee01f619f357b78390ca", "patch": "@@ -10,13 +10,10 @@ store.register_group(true, \"clippy::complexity\", Some(\"clippy_complexity\"), vec!\n     LintId::of(casts::CHAR_LIT_AS_U8),\n     LintId::of(casts::UNNECESSARY_CAST),\n     LintId::of(derivable_impls::DERIVABLE_IMPLS),\n-    LintId::of(double_comparison::DOUBLE_COMPARISONS),\n     LintId::of(double_parens::DOUBLE_PARENS),\n-    LintId::of(duration_subsec::DURATION_SUBSEC),\n     LintId::of(explicit_write::EXPLICIT_WRITE),\n     LintId::of(format::USELESS_FORMAT),\n     LintId::of(functions::TOO_MANY_ARGUMENTS),\n-    LintId::of(identity_op::IDENTITY_OP),\n     LintId::of(int_plus_one::INT_PLUS_ONE),\n     LintId::of(lifetimes::EXTRA_UNUSED_LIFETIMES),\n     LintId::of(lifetimes::NEEDLESS_LIFETIMES),\n@@ -71,6 +68,9 @@ store.register_group(true, \"clippy::complexity\", Some(\"clippy_complexity\"), vec!\n     LintId::of(neg_cmp_op_on_partial_ord::NEG_CMP_OP_ON_PARTIAL_ORD),\n     LintId::of(no_effect::NO_EFFECT),\n     LintId::of(no_effect::UNNECESSARY_OPERATION),\n+    LintId::of(operators::DOUBLE_COMPARISONS),\n+    LintId::of(operators::DURATION_SUBSEC),\n+    LintId::of(operators::IDENTITY_OP),\n     LintId::of(overflow_check_conditional::OVERFLOW_CHECK_CONDITIONAL),\n     LintId::of(partialeq_ne_impl::PARTIALEQ_NE_IMPL),\n     LintId::of(precedence::PRECEDENCE),"}, {"sha": "7d5e65cb27a1f709177d69e5b2105d16a69cb581", "filename": "clippy_lints/src/lib.register_correctness.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Flib.register_correctness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Flib.register_correctness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_correctness.rs?ref=23c6765276c968bf0fe4ee01f619f357b78390ca", "patch": "@@ -3,14 +3,11 @@\n // Manual edits will be overwritten.\n \n store.register_group(true, \"clippy::correctness\", Some(\"clippy_correctness\"), vec![\n-    LintId::of(absurd_extreme_comparisons::ABSURD_EXTREME_COMPARISONS),\n     LintId::of(approx_const::APPROX_CONSTANT),\n     LintId::of(async_yields_async::ASYNC_YIELDS_ASYNC),\n     LintId::of(attrs::DEPRECATED_SEMVER),\n     LintId::of(attrs::MISMATCHED_TARGET_OS),\n     LintId::of(attrs::USELESS_ATTRIBUTE),\n-    LintId::of(bit_mask::BAD_BIT_MASK),\n-    LintId::of(bit_mask::INEFFECTIVE_BIT_MASK),\n     LintId::of(booleans::LOGIC_BUG),\n     LintId::of(casts::CAST_REF_TO_MUT),\n     LintId::of(casts::CAST_SLICE_DIFFERENT_SIZES),\n@@ -24,8 +21,6 @@ store.register_group(true, \"clippy::correctness\", Some(\"clippy_correctness\"), ve\n     LintId::of(drop_forget_ref::FORGET_REF),\n     LintId::of(drop_forget_ref::UNDROPPED_MANUALLY_DROPS),\n     LintId::of(enum_clike::ENUM_CLIKE_UNPORTABLE_VARIANT),\n-    LintId::of(eq_op::EQ_OP),\n-    LintId::of(erasing_op::ERASING_OP),\n     LintId::of(format_impl::RECURSIVE_FORMAT_IMPL),\n     LintId::of(formatting::POSSIBLE_MISSING_COMMA),\n     LintId::of(functions::NOT_UNSAFE_PTR_ARG_DEREF),\n@@ -47,17 +42,22 @@ store.register_group(true, \"clippy::correctness\", Some(\"clippy_correctness\"), ve\n     LintId::of(methods::UNINIT_ASSUMED_INIT),\n     LintId::of(methods::ZST_OFFSET),\n     LintId::of(minmax::MIN_MAX),\n-    LintId::of(misc::CMP_NAN),\n-    LintId::of(misc::MODULO_ONE),\n     LintId::of(non_octal_unix_permissions::NON_OCTAL_UNIX_PERMISSIONS),\n     LintId::of(open_options::NONSENSICAL_OPEN_OPTIONS),\n+    LintId::of(operators::ABSURD_EXTREME_COMPARISONS),\n+    LintId::of(operators::BAD_BIT_MASK),\n+    LintId::of(operators::CMP_NAN),\n+    LintId::of(operators::EQ_OP),\n+    LintId::of(operators::ERASING_OP),\n+    LintId::of(operators::INEFFECTIVE_BIT_MASK),\n+    LintId::of(operators::MODULO_ONE),\n+    LintId::of(operators::SELF_ASSIGNMENT),\n     LintId::of(option_env_unwrap::OPTION_ENV_UNWRAP),\n     LintId::of(ptr::INVALID_NULL_PTR_USAGE),\n     LintId::of(ptr::MUT_FROM_REF),\n     LintId::of(ranges::REVERSED_EMPTY_RANGES),\n     LintId::of(read_zero_byte_vec::READ_ZERO_BYTE_VEC),\n     LintId::of(regex::INVALID_REGEX),\n-    LintId::of(self_assignment::SELF_ASSIGNMENT),\n     LintId::of(serde_api::SERDE_API_MISUSE),\n     LintId::of(size_of_in_element_count::SIZE_OF_IN_ELEMENT_COUNT),\n     LintId::of(swap::ALMOST_SWAPPED),"}, {"sha": "af7226f242f3cb35f328f5e8a10f8944bc56cb67", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=23c6765276c968bf0fe4ee01f619f357b78390ca", "patch": "@@ -35,16 +35,13 @@ store.register_lints(&[\n     utils::internal_lints::PRODUCE_ICE,\n     #[cfg(feature = \"internal\")]\n     utils::internal_lints::UNNECESSARY_SYMBOL_STR,\n-    absurd_extreme_comparisons::ABSURD_EXTREME_COMPARISONS,\n     almost_complete_letter_range::ALMOST_COMPLETE_LETTER_RANGE,\n     approx_const::APPROX_CONSTANT,\n     as_conversions::AS_CONVERSIONS,\n     as_underscore::AS_UNDERSCORE,\n     asm_syntax::INLINE_ASM_X86_ATT_SYNTAX,\n     asm_syntax::INLINE_ASM_X86_INTEL_SYNTAX,\n     assertions_on_constants::ASSERTIONS_ON_CONSTANTS,\n-    assign_ops::ASSIGN_OP_PATTERN,\n-    assign_ops::MISREFACTORED_ASSIGN_OP,\n     async_yields_async::ASYNC_YIELDS_ASYNC,\n     attrs::ALLOW_ATTRIBUTES_WITHOUT_REASON,\n     attrs::BLANKET_CLIPPY_RESTRICTION_LINTS,\n@@ -57,9 +54,6 @@ store.register_lints(&[\n     await_holding_invalid::AWAIT_HOLDING_INVALID_TYPE,\n     await_holding_invalid::AWAIT_HOLDING_LOCK,\n     await_holding_invalid::AWAIT_HOLDING_REFCELL_REF,\n-    bit_mask::BAD_BIT_MASK,\n-    bit_mask::INEFFECTIVE_BIT_MASK,\n-    bit_mask::VERBOSE_BIT_MASK,\n     blacklisted_name::BLACKLISTED_NAME,\n     blocks_in_if_conditions::BLOCKS_IN_IF_CONDITIONS,\n     bool_assert_comparison::BOOL_ASSERT_COMPARISON,\n@@ -128,7 +122,6 @@ store.register_lints(&[\n     doc::MISSING_SAFETY_DOC,\n     doc::NEEDLESS_DOCTEST_MAIN,\n     doc_link_with_quotes::DOC_LINK_WITH_QUOTES,\n-    double_comparison::DOUBLE_COMPARISONS,\n     double_parens::DOUBLE_PARENS,\n     drop_forget_ref::DROP_COPY,\n     drop_forget_ref::DROP_NON_DROP,\n@@ -138,7 +131,6 @@ store.register_lints(&[\n     drop_forget_ref::FORGET_REF,\n     drop_forget_ref::UNDROPPED_MANUALLY_DROPS,\n     duplicate_mod::DUPLICATE_MOD,\n-    duration_subsec::DURATION_SUBSEC,\n     else_if_without_else::ELSE_IF_WITHOUT_ELSE,\n     empty_drop::EMPTY_DROP,\n     empty_enum::EMPTY_ENUM,\n@@ -148,10 +140,7 @@ store.register_lints(&[\n     enum_variants::ENUM_VARIANT_NAMES,\n     enum_variants::MODULE_INCEPTION,\n     enum_variants::MODULE_NAME_REPETITIONS,\n-    eq_op::EQ_OP,\n-    eq_op::OP_REF,\n     equatable_if_let::EQUATABLE_IF_LET,\n-    erasing_op::ERASING_OP,\n     escape::BOXED_LOCAL,\n     eta_reduction::REDUNDANT_CLOSURE,\n     eta_reduction::REDUNDANT_CLOSURE_FOR_METHOD_CALLS,\n@@ -162,7 +151,6 @@ store.register_lints(&[\n     exit::EXIT,\n     explicit_write::EXPLICIT_WRITE,\n     fallible_impl_from::FALLIBLE_IMPL_FROM,\n-    float_equality_without_abs::FLOAT_EQUALITY_WITHOUT_ABS,\n     float_literal::EXCESSIVE_PRECISION,\n     float_literal::LOSSY_FLOAT_LITERAL,\n     floating_point_arithmetic::IMPRECISE_FLOPS,\n@@ -188,7 +176,6 @@ store.register_lints(&[\n     functions::TOO_MANY_LINES,\n     future_not_send::FUTURE_NOT_SEND,\n     get_first::GET_FIRST,\n-    identity_op::IDENTITY_OP,\n     if_let_mutex::IF_LET_MUTEX,\n     if_not_else::IF_NOT_ELSE,\n     if_then_some_else_none::IF_THEN_SOME_ELSE_NONE,\n@@ -207,7 +194,6 @@ store.register_lints(&[\n     init_numbered_fields::INIT_NUMBERED_FIELDS,\n     inline_fn_without_body::INLINE_FN_WITHOUT_BODY,\n     int_plus_one::INT_PLUS_ONE,\n-    integer_division::INTEGER_DIVISION,\n     invalid_upcast_comparisons::INVALID_UPCAST_COMPARISONS,\n     items_after_statements::ITEMS_AFTER_STATEMENTS,\n     iter_not_returning_iterator::ITER_NOT_RETURNING_ITERATOR,\n@@ -370,11 +356,6 @@ store.register_lints(&[\n     methods::WRONG_SELF_CONVENTION,\n     methods::ZST_OFFSET,\n     minmax::MIN_MAX,\n-    misc::CMP_NAN,\n-    misc::CMP_OWNED,\n-    misc::FLOAT_CMP,\n-    misc::FLOAT_CMP_CONST,\n-    misc::MODULO_ONE,\n     misc::SHORT_CIRCUIT_STATEMENT,\n     misc::TOPLEVEL_REF_ARG,\n     misc::USED_UNDERSCORE_BINDING,\n@@ -398,7 +379,6 @@ store.register_lints(&[\n     mixed_read_write_in_expression::MIXED_READ_WRITE_IN_EXPRESSION,\n     module_style::MOD_MODULE_FILES,\n     module_style::SELF_NAMED_MODULE_FILES,\n-    modulo_arithmetic::MODULO_ARITHMETIC,\n     mut_key::MUTABLE_KEY_TYPE,\n     mut_mut::MUT_MUT,\n     mut_mutex_lock::MUT_MUTEX_LOCK,\n@@ -407,7 +387,6 @@ store.register_lints(&[\n     mutex_atomic::MUTEX_ATOMIC,\n     mutex_atomic::MUTEX_INTEGER,\n     needless_arbitrary_self_type::NEEDLESS_ARBITRARY_SELF_TYPE,\n-    needless_bitwise_bool::NEEDLESS_BITWISE_BOOL,\n     needless_bool::BOOL_COMPARISON,\n     needless_bool::NEEDLESS_BOOL,\n     needless_borrowed_ref::NEEDLESS_BORROWED_REFERENCE,\n@@ -432,11 +411,34 @@ store.register_lints(&[\n     non_octal_unix_permissions::NON_OCTAL_UNIX_PERMISSIONS,\n     non_send_fields_in_send_ty::NON_SEND_FIELDS_IN_SEND_TY,\n     nonstandard_macro_braces::NONSTANDARD_MACRO_BRACES,\n-    numeric_arithmetic::FLOAT_ARITHMETIC,\n-    numeric_arithmetic::INTEGER_ARITHMETIC,\n     octal_escapes::OCTAL_ESCAPES,\n     only_used_in_recursion::ONLY_USED_IN_RECURSION,\n     open_options::NONSENSICAL_OPEN_OPTIONS,\n+    operators::ABSURD_EXTREME_COMPARISONS,\n+    operators::ASSIGN_OP_PATTERN,\n+    operators::BAD_BIT_MASK,\n+    operators::CMP_NAN,\n+    operators::CMP_OWNED,\n+    operators::DOUBLE_COMPARISONS,\n+    operators::DURATION_SUBSEC,\n+    operators::EQ_OP,\n+    operators::ERASING_OP,\n+    operators::FLOAT_ARITHMETIC,\n+    operators::FLOAT_CMP,\n+    operators::FLOAT_CMP_CONST,\n+    operators::FLOAT_EQUALITY_WITHOUT_ABS,\n+    operators::IDENTITY_OP,\n+    operators::INEFFECTIVE_BIT_MASK,\n+    operators::INTEGER_ARITHMETIC,\n+    operators::INTEGER_DIVISION,\n+    operators::MISREFACTORED_ASSIGN_OP,\n+    operators::MODULO_ARITHMETIC,\n+    operators::MODULO_ONE,\n+    operators::NEEDLESS_BITWISE_BOOL,\n+    operators::OP_REF,\n+    operators::PTR_EQ,\n+    operators::SELF_ASSIGNMENT,\n+    operators::VERBOSE_BIT_MASK,\n     option_env_unwrap::OPTION_ENV_UNWRAP,\n     option_if_let_else::OPTION_IF_LET_ELSE,\n     overflow_check_conditional::OVERFLOW_CHECK_CONDITIONAL,\n@@ -455,7 +457,6 @@ store.register_lints(&[\n     ptr::INVALID_NULL_PTR_USAGE,\n     ptr::MUT_FROM_REF,\n     ptr::PTR_ARG,\n-    ptr_eq::PTR_EQ,\n     ptr_offset_with_cast::PTR_OFFSET_WITH_CAST,\n     pub_use::PUB_USE,\n     question_mark::QUESTION_MARK,\n@@ -483,7 +484,6 @@ store.register_lints(&[\n     returns::LET_AND_RETURN,\n     returns::NEEDLESS_RETURN,\n     same_name_method::SAME_NAME_METHOD,\n-    self_assignment::SELF_ASSIGNMENT,\n     self_named_constructors::SELF_NAMED_CONSTRUCTORS,\n     semicolon_if_nothing_returned::SEMICOLON_IF_NOTHING_RETURNED,\n     serde_api::SERDE_API_MISUSE,"}, {"sha": "4d4b89687d040d74f95cb9df0c8fc03e996663ba", "filename": "clippy_lints/src/lib.register_pedantic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Flib.register_pedantic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Flib.register_pedantic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_pedantic.rs?ref=23c6765276c968bf0fe4ee01f619f357b78390ca", "patch": "@@ -4,7 +4,6 @@\n \n store.register_group(true, \"clippy::pedantic\", Some(\"clippy_pedantic\"), vec![\n     LintId::of(attrs::INLINE_ALWAYS),\n-    LintId::of(bit_mask::VERBOSE_BIT_MASK),\n     LintId::of(borrow_as_ptr::BORROW_AS_PTR),\n     LintId::of(bytecount::NAIVE_BYTECOUNT),\n     LintId::of(case_sensitive_file_extension_comparisons::CASE_SENSITIVE_FILE_EXTENSION_COMPARISONS),\n@@ -65,17 +64,18 @@ store.register_group(true, \"clippy::pedantic\", Some(\"clippy_pedantic\"), vec![\n     LintId::of(methods::INEFFICIENT_TO_STRING),\n     LintId::of(methods::MAP_UNWRAP_OR),\n     LintId::of(methods::UNNECESSARY_JOIN),\n-    LintId::of(misc::FLOAT_CMP),\n     LintId::of(misc::USED_UNDERSCORE_BINDING),\n     LintId::of(mismatching_type_param_order::MISMATCHING_TYPE_PARAM_ORDER),\n     LintId::of(mut_mut::MUT_MUT),\n-    LintId::of(needless_bitwise_bool::NEEDLESS_BITWISE_BOOL),\n     LintId::of(needless_continue::NEEDLESS_CONTINUE),\n     LintId::of(needless_for_each::NEEDLESS_FOR_EACH),\n     LintId::of(needless_pass_by_value::NEEDLESS_PASS_BY_VALUE),\n     LintId::of(no_effect::NO_EFFECT_UNDERSCORE_BINDING),\n     LintId::of(non_expressive_names::MANY_SINGLE_CHAR_NAMES),\n     LintId::of(non_expressive_names::SIMILAR_NAMES),\n+    LintId::of(operators::FLOAT_CMP),\n+    LintId::of(operators::NEEDLESS_BITWISE_BOOL),\n+    LintId::of(operators::VERBOSE_BIT_MASK),\n     LintId::of(pass_by_ref_or_value::LARGE_TYPES_PASSED_BY_VALUE),\n     LintId::of(pass_by_ref_or_value::TRIVIALLY_COPY_PASS_BY_REF),\n     LintId::of(ranges::RANGE_MINUS_ONE),"}, {"sha": "6bf519c24e848ad2272d6f11e48b1e5166a32596", "filename": "clippy_lints/src/lib.register_perf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Flib.register_perf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Flib.register_perf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_perf.rs?ref=23c6765276c968bf0fe4ee01f619f357b78390ca", "patch": "@@ -22,7 +22,7 @@ store.register_group(true, \"clippy::perf\", Some(\"clippy_perf\"), vec![\n     LintId::of(methods::OR_FUN_CALL),\n     LintId::of(methods::SINGLE_CHAR_PATTERN),\n     LintId::of(methods::UNNECESSARY_TO_OWNED),\n-    LintId::of(misc::CMP_OWNED),\n+    LintId::of(operators::CMP_OWNED),\n     LintId::of(redundant_clone::REDUNDANT_CLONE),\n     LintId::of(slow_vector_initialization::SLOW_VECTOR_INITIALIZATION),\n     LintId::of(types::BOX_COLLECTION),"}, {"sha": "970e9db4772cb192eaf80ba336d213f92061f6e7", "filename": "clippy_lints/src/lib.register_restriction.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Flib.register_restriction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Flib.register_restriction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_restriction.rs?ref=23c6765276c968bf0fe4ee01f619f357b78390ca", "patch": "@@ -25,7 +25,6 @@ store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), ve\n     LintId::of(implicit_return::IMPLICIT_RETURN),\n     LintId::of(indexing_slicing::INDEXING_SLICING),\n     LintId::of(inherent_impl::MULTIPLE_INHERENT_IMPL),\n-    LintId::of(integer_division::INTEGER_DIVISION),\n     LintId::of(large_include_file::LARGE_INCLUDE_FILE),\n     LintId::of(let_underscore::LET_UNDERSCORE_MUST_USE),\n     LintId::of(literal_representation::DECIMAL_LITERAL_REPRESENTATION),\n@@ -39,7 +38,6 @@ store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), ve\n     LintId::of(methods::FILETYPE_IS_FILE),\n     LintId::of(methods::GET_UNWRAP),\n     LintId::of(methods::UNWRAP_USED),\n-    LintId::of(misc::FLOAT_CMP_CONST),\n     LintId::of(misc_early::SEPARATED_LITERAL_SUFFIX),\n     LintId::of(misc_early::UNNEEDED_FIELD_PATTERN),\n     LintId::of(misc_early::UNSEPARATED_LITERAL_SUFFIX),\n@@ -49,9 +47,11 @@ store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), ve\n     LintId::of(mixed_read_write_in_expression::MIXED_READ_WRITE_IN_EXPRESSION),\n     LintId::of(module_style::MOD_MODULE_FILES),\n     LintId::of(module_style::SELF_NAMED_MODULE_FILES),\n-    LintId::of(modulo_arithmetic::MODULO_ARITHMETIC),\n-    LintId::of(numeric_arithmetic::FLOAT_ARITHMETIC),\n-    LintId::of(numeric_arithmetic::INTEGER_ARITHMETIC),\n+    LintId::of(operators::FLOAT_ARITHMETIC),\n+    LintId::of(operators::FLOAT_CMP_CONST),\n+    LintId::of(operators::INTEGER_ARITHMETIC),\n+    LintId::of(operators::INTEGER_DIVISION),\n+    LintId::of(operators::MODULO_ARITHMETIC),\n     LintId::of(panic_in_result_fn::PANIC_IN_RESULT_FN),\n     LintId::of(panic_unimplemented::PANIC),\n     LintId::of(panic_unimplemented::TODO),"}, {"sha": "15a1bc569af2332160e5ceac92fe3fa3f3e1d7ab", "filename": "clippy_lints/src/lib.register_style.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Flib.register_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Flib.register_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_style.rs?ref=23c6765276c968bf0fe4ee01f619f357b78390ca", "patch": "@@ -4,7 +4,6 @@\n \n store.register_group(true, \"clippy::style\", Some(\"clippy_style\"), vec![\n     LintId::of(assertions_on_constants::ASSERTIONS_ON_CONSTANTS),\n-    LintId::of(assign_ops::ASSIGN_OP_PATTERN),\n     LintId::of(blacklisted_name::BLACKLISTED_NAME),\n     LintId::of(blocks_in_if_conditions::BLOCKS_IN_IF_CONDITIONS),\n     LintId::of(bool_assert_comparison::BOOL_ASSERT_COMPARISON),\n@@ -23,7 +22,6 @@ store.register_group(true, \"clippy::style\", Some(\"clippy_style\"), vec![\n     LintId::of(doc::NEEDLESS_DOCTEST_MAIN),\n     LintId::of(enum_variants::ENUM_VARIANT_NAMES),\n     LintId::of(enum_variants::MODULE_INCEPTION),\n-    LintId::of(eq_op::OP_REF),\n     LintId::of(eta_reduction::REDUNDANT_CLOSURE),\n     LintId::of(float_literal::EXCESSIVE_PRECISION),\n     LintId::of(from_over_into::FROM_OVER_INTO),\n@@ -98,9 +96,11 @@ store.register_group(true, \"clippy::style\", Some(\"clippy_style\"), vec![\n     LintId::of(non_copy_const::BORROW_INTERIOR_MUTABLE_CONST),\n     LintId::of(non_copy_const::DECLARE_INTERIOR_MUTABLE_CONST),\n     LintId::of(non_expressive_names::JUST_UNDERSCORES_AND_DIGITS),\n+    LintId::of(operators::ASSIGN_OP_PATTERN),\n+    LintId::of(operators::OP_REF),\n+    LintId::of(operators::PTR_EQ),\n     LintId::of(ptr::CMP_NULL),\n     LintId::of(ptr::PTR_ARG),\n-    LintId::of(ptr_eq::PTR_EQ),\n     LintId::of(question_mark::QUESTION_MARK),\n     LintId::of(ranges::MANUAL_RANGE_CONTAINS),\n     LintId::of(redundant_field_names::REDUNDANT_FIELD_NAMES),"}, {"sha": "f7558f8709810fe51d3475758f954fa76fa7fece", "filename": "clippy_lints/src/lib.register_suspicious.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Flib.register_suspicious.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Flib.register_suspicious.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_suspicious.rs?ref=23c6765276c968bf0fe4ee01f619f357b78390ca", "patch": "@@ -4,7 +4,6 @@\n \n store.register_group(true, \"clippy::suspicious\", Some(\"clippy_suspicious\"), vec![\n     LintId::of(almost_complete_letter_range::ALMOST_COMPLETE_LETTER_RANGE),\n-    LintId::of(assign_ops::MISREFACTORED_ASSIGN_OP),\n     LintId::of(attrs::BLANKET_CLIPPY_RESTRICTION_LINTS),\n     LintId::of(await_holding_invalid::AWAIT_HOLDING_INVALID_TYPE),\n     LintId::of(await_holding_invalid::AWAIT_HOLDING_LOCK),\n@@ -16,7 +15,6 @@ store.register_group(true, \"clippy::suspicious\", Some(\"clippy_suspicious\"), vec!\n     LintId::of(drop_forget_ref::DROP_NON_DROP),\n     LintId::of(drop_forget_ref::FORGET_NON_DROP),\n     LintId::of(duplicate_mod::DUPLICATE_MOD),\n-    LintId::of(float_equality_without_abs::FLOAT_EQUALITY_WITHOUT_ABS),\n     LintId::of(format_impl::PRINT_IN_FORMAT_IMPL),\n     LintId::of(formatting::SUSPICIOUS_ASSIGNMENT_FORMATTING),\n     LintId::of(formatting::SUSPICIOUS_ELSE_FORMATTING),\n@@ -29,6 +27,8 @@ store.register_group(true, \"clippy::suspicious\", Some(\"clippy_suspicious\"), vec!\n     LintId::of(methods::SUSPICIOUS_MAP),\n     LintId::of(mut_key::MUTABLE_KEY_TYPE),\n     LintId::of(octal_escapes::OCTAL_ESCAPES),\n+    LintId::of(operators::FLOAT_EQUALITY_WITHOUT_ABS),\n+    LintId::of(operators::MISREFACTORED_ASSIGN_OP),\n     LintId::of(rc_clone_in_vec_init::RC_CLONE_IN_VEC_INIT),\n     LintId::of(suspicious_trait_impl::SUSPICIOUS_ARITHMETIC_IMPL),\n     LintId::of(suspicious_trait_impl::SUSPICIOUS_OP_ASSIGN_IMPL),"}, {"sha": "172fdf8c85269c4944122c81f9e55ad7fcf905b1", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 3, "deletions": 31, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=23c6765276c968bf0fe4ee01f619f357b78390ca", "patch": "@@ -168,18 +168,15 @@ mod utils;\n mod renamed_lints;\n \n // begin lints modules, do not remove this comment, it\u2019s used in `update_lints`\n-mod absurd_extreme_comparisons;\n mod almost_complete_letter_range;\n mod approx_const;\n mod as_conversions;\n mod as_underscore;\n mod asm_syntax;\n mod assertions_on_constants;\n-mod assign_ops;\n mod async_yields_async;\n mod attrs;\n mod await_holding_invalid;\n-mod bit_mask;\n mod blacklisted_name;\n mod blocks_in_if_conditions;\n mod bool_assert_comparison;\n@@ -212,29 +209,24 @@ mod disallowed_script_idents;\n mod disallowed_types;\n mod doc;\n mod doc_link_with_quotes;\n-mod double_comparison;\n mod double_parens;\n mod drop_forget_ref;\n mod duplicate_mod;\n-mod duration_subsec;\n mod else_if_without_else;\n mod empty_drop;\n mod empty_enum;\n mod empty_structs_with_brackets;\n mod entry;\n mod enum_clike;\n mod enum_variants;\n-mod eq_op;\n mod equatable_if_let;\n-mod erasing_op;\n mod escape;\n mod eta_reduction;\n mod excessive_bools;\n mod exhaustive_items;\n mod exit;\n mod explicit_write;\n mod fallible_impl_from;\n-mod float_equality_without_abs;\n mod float_literal;\n mod floating_point_arithmetic;\n mod format;\n@@ -247,7 +239,6 @@ mod from_str_radix_10;\n mod functions;\n mod future_not_send;\n mod get_first;\n-mod identity_op;\n mod if_let_mutex;\n mod if_not_else;\n mod if_then_some_else_none;\n@@ -263,7 +254,6 @@ mod inherent_to_string;\n mod init_numbered_fields;\n mod inline_fn_without_body;\n mod int_plus_one;\n-mod integer_division;\n mod invalid_upcast_comparisons;\n mod items_after_statements;\n mod iter_not_returning_iterator;\n@@ -305,15 +295,13 @@ mod missing_enforced_import_rename;\n mod missing_inline;\n mod mixed_read_write_in_expression;\n mod module_style;\n-mod modulo_arithmetic;\n mod mut_key;\n mod mut_mut;\n mod mut_mutex_lock;\n mod mut_reference;\n mod mutable_debug_assertion;\n mod mutex_atomic;\n mod needless_arbitrary_self_type;\n-mod needless_bitwise_bool;\n mod needless_bool;\n mod needless_borrowed_ref;\n mod needless_continue;\n@@ -332,10 +320,10 @@ mod non_expressive_names;\n mod non_octal_unix_permissions;\n mod non_send_fields_in_send_ty;\n mod nonstandard_macro_braces;\n-mod numeric_arithmetic;\n mod octal_escapes;\n mod only_used_in_recursion;\n mod open_options;\n+mod operators;\n mod option_env_unwrap;\n mod option_if_let_else;\n mod overflow_check_conditional;\n@@ -347,7 +335,6 @@ mod path_buf_push_overwrite;\n mod pattern_type_mismatch;\n mod precedence;\n mod ptr;\n-mod ptr_eq;\n mod ptr_offset_with_cast;\n mod pub_use;\n mod question_mark;\n@@ -368,7 +355,6 @@ mod repeat_once;\n mod return_self_not_must_use;\n mod returns;\n mod same_name_method;\n-mod self_assignment;\n mod self_named_constructors;\n mod semicolon_if_nothing_returned;\n mod serde_api;\n@@ -580,21 +566,14 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         ))\n     });\n     store.register_late_pass(|| Box::new(booleans::NonminimalBool));\n-    store.register_late_pass(|| Box::new(needless_bitwise_bool::NeedlessBitwiseBool));\n-    store.register_late_pass(|| Box::new(eq_op::EqOp));\n     store.register_late_pass(|| Box::new(enum_clike::UnportableVariant));\n     store.register_late_pass(|| Box::new(float_literal::FloatLiteral));\n-    let verbose_bit_mask_threshold = conf.verbose_bit_mask_threshold;\n-    store.register_late_pass(move || Box::new(bit_mask::BitMask::new(verbose_bit_mask_threshold)));\n     store.register_late_pass(|| Box::new(ptr::Ptr));\n-    store.register_late_pass(|| Box::new(ptr_eq::PtrEq));\n     store.register_late_pass(|| Box::new(needless_bool::NeedlessBool));\n     store.register_late_pass(|| Box::new(needless_bool::BoolComparison));\n     store.register_late_pass(|| Box::new(needless_for_each::NeedlessForEach));\n     store.register_late_pass(|| Box::new(misc::MiscLints));\n     store.register_late_pass(|| Box::new(eta_reduction::EtaReduction));\n-    store.register_late_pass(|| Box::new(identity_op::IdentityOp));\n-    store.register_late_pass(|| Box::new(erasing_op::ErasingOp));\n     store.register_late_pass(|| Box::new(mut_mut::MutMut));\n     store.register_late_pass(|| Box::new(mut_reference::UnnecessaryMutPassed));\n     store.register_late_pass(|| Box::new(len_zero::LenZero));\n@@ -683,7 +662,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(derivable_impls::DerivableImpls));\n     store.register_late_pass(|| Box::new(drop_forget_ref::DropForgetRef));\n     store.register_late_pass(|| Box::new(empty_enum::EmptyEnum));\n-    store.register_late_pass(|| Box::new(absurd_extreme_comparisons::AbsurdExtremeComparisons));\n     store.register_late_pass(|| Box::new(invalid_upcast_comparisons::InvalidUpcastComparisons));\n     store.register_late_pass(|| Box::new(regex::Regex));\n     store.register_late_pass(|| Box::new(copies::CopyAndPaste));\n@@ -706,8 +684,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(move || Box::new(doc::DocMarkdown::new(doc_valid_idents.clone())));\n     store.register_late_pass(|| Box::new(neg_multiply::NegMultiply));\n     store.register_late_pass(|| Box::new(mem_forget::MemForget));\n-    store.register_late_pass(|| Box::new(numeric_arithmetic::NumericArithmetic::default()));\n-    store.register_late_pass(|| Box::new(assign_ops::AssignOps));\n     store.register_late_pass(|| Box::new(let_if_seq::LetIfSeq));\n     store.register_late_pass(|| Box::new(mixed_read_write_in_expression::EvalOrderDependence));\n     store.register_late_pass(|| Box::new(missing_doc::MissingDoc::new()));\n@@ -734,15 +710,13 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(useless_conversion::UselessConversion::default()));\n     store.register_late_pass(|| Box::new(implicit_hasher::ImplicitHasher));\n     store.register_late_pass(|| Box::new(fallible_impl_from::FallibleImplFrom));\n-    store.register_late_pass(|| Box::new(double_comparison::DoubleComparisons));\n     store.register_late_pass(|| Box::new(question_mark::QuestionMark));\n     store.register_early_pass(|| Box::new(suspicious_operation_groupings::SuspiciousOperationGroupings));\n     store.register_late_pass(|| Box::new(suspicious_trait_impl::SuspiciousImpl));\n     store.register_late_pass(|| Box::new(map_unit_fn::MapUnit));\n     store.register_late_pass(|| Box::new(inherent_impl::MultipleInherentImpl));\n     store.register_late_pass(|| Box::new(neg_cmp_op_on_partial_ord::NoNegCompOpForPartialOrd));\n     store.register_late_pass(|| Box::new(unwrap::Unwrap));\n-    store.register_late_pass(|| Box::new(duration_subsec::DurationSubsec));\n     store.register_late_pass(|| Box::new(indexing_slicing::IndexingSlicing));\n     store.register_late_pass(|| Box::new(non_copy_const::NonCopyConst));\n     store.register_late_pass(|| Box::new(ptr_offset_with_cast::PtrOffsetWithCast));\n@@ -753,13 +727,11 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(assertions_on_constants::AssertionsOnConstants));\n     store.register_late_pass(|| Box::new(transmuting_null::TransmutingNull));\n     store.register_late_pass(|| Box::new(path_buf_push_overwrite::PathBufPushOverwrite));\n-    store.register_late_pass(|| Box::new(integer_division::IntegerDivision));\n     store.register_late_pass(|| Box::new(inherent_to_string::InherentToString));\n     let max_trait_bounds = conf.max_trait_bounds;\n     store.register_late_pass(move || Box::new(trait_bounds::TraitBounds::new(max_trait_bounds)));\n     store.register_late_pass(|| Box::new(comparison_chain::ComparisonChain));\n     store.register_late_pass(|| Box::new(mut_key::MutableKeyType));\n-    store.register_late_pass(|| Box::new(modulo_arithmetic::ModuloArithmetic));\n     store.register_early_pass(|| Box::new(reference::DerefAddrOf));\n     store.register_early_pass(|| Box::new(double_parens::DoubleParens));\n     store.register_late_pass(|| Box::new(format_impl::FormatImpl::new()));\n@@ -856,9 +828,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(stable_sort_primitive::StableSortPrimitive));\n     store.register_late_pass(|| Box::new(repeat_once::RepeatOnce));\n     store.register_late_pass(|| Box::new(unwrap_in_result::UnwrapInResult));\n-    store.register_late_pass(|| Box::new(self_assignment::SelfAssignment));\n     store.register_late_pass(|| Box::new(manual_ok_or::ManualOkOr));\n-    store.register_late_pass(|| Box::new(float_equality_without_abs::FloatEqualityWithoutAbs));\n     store.register_late_pass(|| Box::new(semicolon_if_nothing_returned::SemicolonIfNothingReturned));\n     store.register_late_pass(|| Box::new(async_yields_async::AsyncYieldsAsync));\n     let disallowed_methods = conf.disallowed_methods.clone();\n@@ -941,6 +911,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(default_instead_of_iter_empty::DefaultIterEmpty));\n     store.register_late_pass(move || Box::new(manual_rem_euclid::ManualRemEuclid::new(msrv)));\n     store.register_late_pass(move || Box::new(manual_retain::ManualRetain::new(msrv)));\n+    let verbose_bit_mask_threshold = conf.verbose_bit_mask_threshold;\n+    store.register_late_pass(move || Box::new(operators::Operators::new(verbose_bit_mask_threshold)));\n     // add lints here, do not remove this comment, it's used in `new_lint`\n }\n "}, {"sha": "df2430ced6b621b11d7e442e83b1f9c1a6d16178", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 6, "deletions": 477, "changes": 483, "blob_url": "https://github.com/rust-lang/rust/blob/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=23c6765276c968bf0fe4ee01f619f357b78390ca", "patch": "@@ -1,28 +1,21 @@\n-use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg, span_lint_and_then, span_lint_hir_and_then};\n+use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg, span_lint_hir_and_then};\n use clippy_utils::source::{snippet, snippet_opt};\n-use clippy_utils::ty::{implements_trait, is_copy};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::FnKind;\n use rustc_hir::{\n     self as hir, def, BinOpKind, BindingAnnotation, Body, Expr, ExprKind, FnDecl, HirId, Mutability, PatKind, Stmt,\n-    StmtKind, TyKind, UnOp,\n+    StmtKind, TyKind,\n };\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::hygiene::DesugaringKind;\n use rustc_span::source_map::{ExpnKind, Span};\n-use rustc_span::symbol::sym;\n \n-use clippy_utils::consts::{constant, Constant};\n use clippy_utils::sugg::Sugg;\n-use clippy_utils::{\n-    get_item_name, get_parent_expr, in_constant, is_integer_const, iter_input_pats, last_path_segment,\n-    match_any_def_paths, path_def_id, paths, unsext, SpanlessEq,\n-};\n+use clippy_utils::{get_parent_expr, in_constant, iter_input_pats, last_path_segment, SpanlessEq};\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -58,122 +51,6 @@ declare_clippy_lint! {\n     style,\n     \"an entire binding declared as `ref`, in a function argument or a `let` statement\"\n }\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for comparisons to NaN.\n-    ///\n-    /// ### Why is this bad?\n-    /// NaN does not compare meaningfully to anything \u2013 not\n-    /// even itself \u2013 so those comparisons are simply wrong.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # let x = 1.0;\n-    /// if x == f32::NAN { }\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust\n-    /// # let x = 1.0f32;\n-    /// if x.is_nan() { }\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub CMP_NAN,\n-    correctness,\n-    \"comparisons to `NAN`, which will always return false, probably not intended\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for (in-)equality comparisons on floating-point\n-    /// values (apart from zero), except in functions called `*eq*` (which probably\n-    /// implement equality for a type involving floats).\n-    ///\n-    /// ### Why is this bad?\n-    /// Floating point calculations are usually imprecise, so\n-    /// asking if two values are *exactly* equal is asking for trouble. For a good\n-    /// guide on what to do, see [the floating point\n-    /// guide](http://www.floating-point-gui.de/errors/comparison).\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// let x = 1.2331f64;\n-    /// let y = 1.2332f64;\n-    ///\n-    /// if y == 1.23f64 { }\n-    /// if y != x {} // where both are floats\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust\n-    /// # let x = 1.2331f64;\n-    /// # let y = 1.2332f64;\n-    /// let error_margin = f64::EPSILON; // Use an epsilon for comparison\n-    /// // Or, if Rust <= 1.42, use `std::f64::EPSILON` constant instead.\n-    /// // let error_margin = std::f64::EPSILON;\n-    /// if (y - 1.23f64).abs() < error_margin { }\n-    /// if (y - x).abs() > error_margin { }\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub FLOAT_CMP,\n-    pedantic,\n-    \"using `==` or `!=` on float values instead of comparing difference with an epsilon\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for conversions to owned values just for the sake\n-    /// of a comparison.\n-    ///\n-    /// ### Why is this bad?\n-    /// The comparison can operate on a reference, so creating\n-    /// an owned value effectively throws it away directly afterwards, which is\n-    /// needlessly consuming code and heap space.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # let x = \"foo\";\n-    /// # let y = String::from(\"foo\");\n-    /// if x.to_owned() == y {}\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust\n-    /// # let x = \"foo\";\n-    /// # let y = String::from(\"foo\");\n-    /// if x == y {}\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub CMP_OWNED,\n-    perf,\n-    \"creating owned instances for comparing with others, e.g., `x == \\\"foo\\\".to_string()`\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for getting the remainder of a division by one or minus\n-    /// one.\n-    ///\n-    /// ### Why is this bad?\n-    /// The result for a divisor of one can only ever be zero; for\n-    /// minus one it can cause panic/overflow (if the left operand is the minimal value of\n-    /// the respective integer type) or results in zero. No one will write such code\n-    /// deliberately, unless trying to win an Underhanded Rust Contest. Even for that\n-    /// contest, it's probably a bad idea. Use something more underhanded.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # let x = 1;\n-    /// let a = x % 1;\n-    /// let a = x % -1;\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub MODULO_ONE,\n-    correctness,\n-    \"taking a number modulo +/-1, which can either panic/overflow or always returns 0\"\n-}\n-\n declare_clippy_lint! {\n     /// ### What it does\n     /// Checks for the use of bindings with a single leading\n@@ -244,51 +121,11 @@ declare_clippy_lint! {\n     \"using `0 as *{const, mut} T`\"\n }\n \n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for (in-)equality comparisons on floating-point\n-    /// value and constant, except in functions called `*eq*` (which probably\n-    /// implement equality for a type involving floats).\n-    ///\n-    /// ### Why is this bad?\n-    /// Floating point calculations are usually imprecise, so\n-    /// asking if two values are *exactly* equal is asking for trouble. For a good\n-    /// guide on what to do, see [the floating point\n-    /// guide](http://www.floating-point-gui.de/errors/comparison).\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// let x: f64 = 1.0;\n-    /// const ONE: f64 = 1.00;\n-    ///\n-    /// if x == ONE { } // where both are floats\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust\n-    /// # let x: f64 = 1.0;\n-    /// # const ONE: f64 = 1.00;\n-    /// let error_margin = f64::EPSILON; // Use an epsilon for comparison\n-    /// // Or, if Rust <= 1.42, use `std::f64::EPSILON` constant instead.\n-    /// // let error_margin = std::f64::EPSILON;\n-    /// if (x - ONE).abs() < error_margin { }\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub FLOAT_CMP_CONST,\n-    restriction,\n-    \"using `==` or `!=` on float constants instead of comparing difference with an epsilon\"\n-}\n-\n declare_lint_pass!(MiscLints => [\n     TOPLEVEL_REF_ARG,\n-    CMP_NAN,\n-    FLOAT_CMP,\n-    CMP_OWNED,\n-    MODULO_ONE,\n     USED_UNDERSCORE_BINDING,\n     SHORT_CIRCUIT_STATEMENT,\n     ZERO_PTR,\n-    FLOAT_CMP_CONST\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for MiscLints {\n@@ -398,16 +235,9 @@ impl<'tcx> LateLintPass<'tcx> for MiscLints {\n     }\n \n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        match expr.kind {\n-            ExprKind::Cast(e, ty) => {\n-                check_cast(cx, expr.span, e, ty);\n-                return;\n-            },\n-            ExprKind::Binary(ref cmp, left, right) => {\n-                check_binary(cx, expr, cmp, left, right);\n-                return;\n-            },\n-            _ => {},\n+        if let ExprKind::Cast(e, ty) = expr.kind {\n+            check_cast(cx, expr.span, e, ty);\n+            return;\n         }\n         if in_attributes_expansion(expr) || expr.span.is_desugaring(DesugaringKind::Await) {\n             // Don't lint things expanded by #[derive(...)], etc or `await` desugaring\n@@ -455,236 +285,6 @@ impl<'tcx> LateLintPass<'tcx> for MiscLints {\n     }\n }\n \n-fn get_lint_and_message(\n-    is_comparing_constants: bool,\n-    is_comparing_arrays: bool,\n-) -> (&'static rustc_lint::Lint, &'static str) {\n-    if is_comparing_constants {\n-        (\n-            FLOAT_CMP_CONST,\n-            if is_comparing_arrays {\n-                \"strict comparison of `f32` or `f64` constant arrays\"\n-            } else {\n-                \"strict comparison of `f32` or `f64` constant\"\n-            },\n-        )\n-    } else {\n-        (\n-            FLOAT_CMP,\n-            if is_comparing_arrays {\n-                \"strict comparison of `f32` or `f64` arrays\"\n-            } else {\n-                \"strict comparison of `f32` or `f64`\"\n-            },\n-        )\n-    }\n-}\n-\n-fn check_nan(cx: &LateContext<'_>, expr: &Expr<'_>, cmp_expr: &Expr<'_>) {\n-    if_chain! {\n-        if !in_constant(cx, cmp_expr.hir_id);\n-        if let Some((value, _)) = constant(cx, cx.typeck_results(), expr);\n-        if match value {\n-            Constant::F32(num) => num.is_nan(),\n-            Constant::F64(num) => num.is_nan(),\n-            _ => false,\n-        };\n-        then {\n-            span_lint(\n-                cx,\n-                CMP_NAN,\n-                cmp_expr.span,\n-                \"doomed comparison with `NAN`, use `{f32,f64}::is_nan()` instead\",\n-            );\n-        }\n-    }\n-}\n-\n-fn is_named_constant<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n-    if let Some((_, res)) = constant(cx, cx.typeck_results(), expr) {\n-        res\n-    } else {\n-        false\n-    }\n-}\n-\n-fn is_allowed<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n-    match constant(cx, cx.typeck_results(), expr) {\n-        Some((Constant::F32(f), _)) => f == 0.0 || f.is_infinite(),\n-        Some((Constant::F64(f), _)) => f == 0.0 || f.is_infinite(),\n-        Some((Constant::Vec(vec), _)) => vec.iter().all(|f| match f {\n-            Constant::F32(f) => *f == 0.0 || (*f).is_infinite(),\n-            Constant::F64(f) => *f == 0.0 || (*f).is_infinite(),\n-            _ => false,\n-        }),\n-        _ => false,\n-    }\n-}\n-\n-// Return true if `expr` is the result of `signum()` invoked on a float value.\n-fn is_signum(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    // The negation of a signum is still a signum\n-    if let ExprKind::Unary(UnOp::Neg, child_expr) = expr.kind {\n-        return is_signum(cx, child_expr);\n-    }\n-\n-    if_chain! {\n-        if let ExprKind::MethodCall(method_name, [ref self_arg, ..], _) = expr.kind;\n-        if sym!(signum) == method_name.ident.name;\n-        // Check that the receiver of the signum() is a float (expressions[0] is the receiver of\n-        // the method call)\n-        then {\n-            return is_float(cx, self_arg);\n-        }\n-    }\n-    false\n-}\n-\n-fn is_float(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    let value = &cx.typeck_results().expr_ty(expr).peel_refs().kind();\n-\n-    if let ty::Array(arr_ty, _) = value {\n-        return matches!(arr_ty.kind(), ty::Float(_));\n-    };\n-\n-    matches!(value, ty::Float(_))\n-}\n-\n-fn is_array(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    matches!(&cx.typeck_results().expr_ty(expr).peel_refs().kind(), ty::Array(_, _))\n-}\n-\n-#[expect(clippy::too_many_lines)]\n-fn check_to_owned(cx: &LateContext<'_>, expr: &Expr<'_>, other: &Expr<'_>, left: bool) {\n-    #[derive(Default)]\n-    struct EqImpl {\n-        ty_eq_other: bool,\n-        other_eq_ty: bool,\n-    }\n-\n-    impl EqImpl {\n-        fn is_implemented(&self) -> bool {\n-            self.ty_eq_other || self.other_eq_ty\n-        }\n-    }\n-\n-    fn symmetric_partial_eq<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, other: Ty<'tcx>) -> Option<EqImpl> {\n-        cx.tcx.lang_items().eq_trait().map(|def_id| EqImpl {\n-            ty_eq_other: implements_trait(cx, ty, def_id, &[other.into()]),\n-            other_eq_ty: implements_trait(cx, other, def_id, &[ty.into()]),\n-        })\n-    }\n-\n-    let typeck = cx.typeck_results();\n-    let (arg, arg_span) = match expr.kind {\n-        ExprKind::MethodCall(.., [arg], _)\n-            if typeck\n-                .type_dependent_def_id(expr.hir_id)\n-                .and_then(|id| cx.tcx.trait_of_item(id))\n-                .map_or(false, |id| {\n-                    matches!(cx.tcx.get_diagnostic_name(id), Some(sym::ToString | sym::ToOwned))\n-                }) =>\n-        {\n-            (arg, arg.span)\n-        },\n-        ExprKind::Call(path, [arg])\n-            if path_def_id(cx, path)\n-                .and_then(|id| match_any_def_paths(cx, id, &[&paths::FROM_STR_METHOD, &paths::FROM_FROM]))\n-                .map_or(false, |idx| match idx {\n-                    0 => true,\n-                    1 => !is_copy(cx, typeck.expr_ty(expr)),\n-                    _ => false,\n-                }) =>\n-        {\n-            (arg, arg.span)\n-        },\n-        _ => return,\n-    };\n-\n-    let arg_ty = typeck.expr_ty(arg);\n-    let other_ty = typeck.expr_ty(other);\n-\n-    let without_deref = symmetric_partial_eq(cx, arg_ty, other_ty).unwrap_or_default();\n-    let with_deref = arg_ty\n-        .builtin_deref(true)\n-        .and_then(|tam| symmetric_partial_eq(cx, tam.ty, other_ty))\n-        .unwrap_or_default();\n-\n-    if !with_deref.is_implemented() && !without_deref.is_implemented() {\n-        return;\n-    }\n-\n-    let other_gets_derefed = matches!(other.kind, ExprKind::Unary(UnOp::Deref, _));\n-\n-    let lint_span = if other_gets_derefed {\n-        expr.span.to(other.span)\n-    } else {\n-        expr.span\n-    };\n-\n-    span_lint_and_then(\n-        cx,\n-        CMP_OWNED,\n-        lint_span,\n-        \"this creates an owned instance just for comparison\",\n-        |diag| {\n-            // This also catches `PartialEq` implementations that call `to_owned`.\n-            if other_gets_derefed {\n-                diag.span_label(lint_span, \"try implementing the comparison without allocating\");\n-                return;\n-            }\n-\n-            let arg_snip = snippet(cx, arg_span, \"..\");\n-            let expr_snip;\n-            let eq_impl;\n-            if with_deref.is_implemented() {\n-                expr_snip = format!(\"*{}\", arg_snip);\n-                eq_impl = with_deref;\n-            } else {\n-                expr_snip = arg_snip.to_string();\n-                eq_impl = without_deref;\n-            };\n-\n-            let span;\n-            let hint;\n-            if (eq_impl.ty_eq_other && left) || (eq_impl.other_eq_ty && !left) {\n-                span = expr.span;\n-                hint = expr_snip;\n-            } else {\n-                span = expr.span.to(other.span);\n-\n-                let cmp_span = if other.span < expr.span {\n-                    other.span.between(expr.span)\n-                } else {\n-                    expr.span.between(other.span)\n-                };\n-                if eq_impl.ty_eq_other {\n-                    hint = format!(\n-                        \"{}{}{}\",\n-                        expr_snip,\n-                        snippet(cx, cmp_span, \"..\"),\n-                        snippet(cx, other.span, \"..\")\n-                    );\n-                } else {\n-                    hint = format!(\n-                        \"{}{}{}\",\n-                        snippet(cx, other.span, \"..\"),\n-                        snippet(cx, cmp_span, \"..\"),\n-                        expr_snip\n-                    );\n-                }\n-            }\n-\n-            diag.span_suggestion(\n-                span,\n-                \"try\",\n-                hint,\n-                Applicability::MachineApplicable, // snippet\n-            );\n-        },\n-    );\n-}\n-\n /// Heuristic to see if an expression is used. Should be compatible with\n /// `unused_variables`'s idea\n /// of what it means for an expression to be \"used\".\n@@ -740,74 +340,3 @@ fn check_cast(cx: &LateContext<'_>, span: Span, e: &Expr<'_>, ty: &hir::Ty<'_>)\n         }\n     }\n }\n-\n-fn check_binary<'a>(\n-    cx: &LateContext<'a>,\n-    expr: &Expr<'_>,\n-    cmp: &rustc_span::source_map::Spanned<rustc_hir::BinOpKind>,\n-    left: &'a Expr<'_>,\n-    right: &'a Expr<'_>,\n-) {\n-    let op = cmp.node;\n-    if op.is_comparison() {\n-        check_nan(cx, left, expr);\n-        check_nan(cx, right, expr);\n-        check_to_owned(cx, left, right, true);\n-        check_to_owned(cx, right, left, false);\n-    }\n-    if (op == BinOpKind::Eq || op == BinOpKind::Ne) && (is_float(cx, left) || is_float(cx, right)) {\n-        if is_allowed(cx, left) || is_allowed(cx, right) {\n-            return;\n-        }\n-\n-        // Allow comparing the results of signum()\n-        if is_signum(cx, left) && is_signum(cx, right) {\n-            return;\n-        }\n-\n-        if let Some(name) = get_item_name(cx, expr) {\n-            let name = name.as_str();\n-            if name == \"eq\" || name == \"ne\" || name == \"is_nan\" || name.starts_with(\"eq_\") || name.ends_with(\"_eq\") {\n-                return;\n-            }\n-        }\n-        let is_comparing_arrays = is_array(cx, left) || is_array(cx, right);\n-        let (lint, msg) = get_lint_and_message(\n-            is_named_constant(cx, left) || is_named_constant(cx, right),\n-            is_comparing_arrays,\n-        );\n-        span_lint_and_then(cx, lint, expr.span, msg, |diag| {\n-            let lhs = Sugg::hir(cx, left, \"..\");\n-            let rhs = Sugg::hir(cx, right, \"..\");\n-\n-            if !is_comparing_arrays {\n-                diag.span_suggestion(\n-                    expr.span,\n-                    \"consider comparing them within some margin of error\",\n-                    format!(\n-                        \"({}).abs() {} error_margin\",\n-                        lhs - rhs,\n-                        if op == BinOpKind::Eq { '<' } else { '>' }\n-                    ),\n-                    Applicability::HasPlaceholders, // snippet\n-                );\n-            }\n-            diag.note(\"`f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\");\n-        });\n-    } else if op == BinOpKind::Rem {\n-        if is_integer_const(cx, right, 1) {\n-            span_lint(cx, MODULO_ONE, expr.span, \"any number modulo 1 will be 0\");\n-        }\n-\n-        if let ty::Int(ity) = cx.typeck_results().expr_ty(right).kind() {\n-            if is_integer_const(cx, right, unsext(cx.tcx, -1, *ity)) {\n-                span_lint(\n-                    cx,\n-                    MODULO_ONE,\n-                    expr.span,\n-                    \"any number modulo -1 will panic/overflow or result in 0\",\n-                );\n-            }\n-        };\n-    }\n-}"}, {"sha": "623d22bc9bdfe6a6a6c1c1ef674da4ff5946e64c", "filename": "clippy_lints/src/needless_bitwise_bool.rs", "status": "removed", "additions": 0, "deletions": 85, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/b776fb82941cadfc752368901f210831d5184d95/clippy_lints%2Fsrc%2Fneedless_bitwise_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b776fb82941cadfc752368901f210831d5184d95/clippy_lints%2Fsrc%2Fneedless_bitwise_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_bitwise_bool.rs?ref=b776fb82941cadfc752368901f210831d5184d95", "patch": "@@ -1,85 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::source::snippet_opt;\n-use if_chain::if_chain;\n-use rustc_errors::Applicability;\n-use rustc_hir::{BinOpKind, Expr, ExprKind};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for uses of bitwise and/or operators between booleans, where performance may be improved by using\n-    /// a lazy and.\n-    ///\n-    /// ### Why is this bad?\n-    /// The bitwise operators do not support short-circuiting, so it may hinder code performance.\n-    /// Additionally, boolean logic \"masked\" as bitwise logic is not caught by lints like `unnecessary_fold`\n-    ///\n-    /// ### Known problems\n-    /// This lint evaluates only when the right side is determined to have no side effects. At this time, that\n-    /// determination is quite conservative.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// let (x,y) = (true, false);\n-    /// if x & !y {} // where both x and y are booleans\n-    /// ```\n-    /// Use instead:\n-    /// ```rust\n-    /// let (x,y) = (true, false);\n-    /// if x && !y {}\n-    /// ```\n-    #[clippy::version = \"1.54.0\"]\n-    pub NEEDLESS_BITWISE_BOOL,\n-    pedantic,\n-    \"Boolean expressions that use bitwise rather than lazy operators\"\n-}\n-\n-declare_lint_pass!(NeedlessBitwiseBool => [NEEDLESS_BITWISE_BOOL]);\n-\n-fn is_bitwise_operation(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    let ty = cx.typeck_results().expr_ty(expr);\n-    if_chain! {\n-        if !expr.span.from_expansion();\n-        if let (&ExprKind::Binary(ref op, _, right), &ty::Bool) = (&expr.kind, &ty.kind());\n-        if op.node == BinOpKind::BitAnd || op.node == BinOpKind::BitOr;\n-        if let ExprKind::Call(..) | ExprKind::MethodCall(..) | ExprKind::Binary(..) | ExprKind::Unary(..) = right.kind;\n-        if !right.can_have_side_effects();\n-        then {\n-            return true;\n-        }\n-    }\n-    false\n-}\n-\n-fn suggestion_snippet(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<String> {\n-    if let ExprKind::Binary(ref op, left, right) = expr.kind {\n-        if let (Some(l_snippet), Some(r_snippet)) = (snippet_opt(cx, left.span), snippet_opt(cx, right.span)) {\n-            let op_snippet = match op.node {\n-                BinOpKind::BitAnd => \"&&\",\n-                _ => \"||\",\n-            };\n-            return Some(format!(\"{} {} {}\", l_snippet, op_snippet, r_snippet));\n-        }\n-    }\n-    None\n-}\n-\n-impl LateLintPass<'_> for NeedlessBitwiseBool {\n-    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n-        if is_bitwise_operation(cx, expr) {\n-            span_lint_and_then(\n-                cx,\n-                NEEDLESS_BITWISE_BOOL,\n-                expr.span,\n-                \"use of bitwise operator instead of lazy operator between booleans\",\n-                |diag| {\n-                    if let Some(sugg) = suggestion_snippet(cx, expr) {\n-                        diag.span_suggestion(expr.span, \"try\", sugg, Applicability::MachineApplicable);\n-                    }\n-                },\n-            );\n-        }\n-    }\n-}"}, {"sha": "5c4de3381496cd839567ba17a5b2de1eef2e2b99", "filename": "clippy_lints/src/numeric_arithmetic.rs", "status": "removed", "additions": 0, "deletions": 170, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/b776fb82941cadfc752368901f210831d5184d95/clippy_lints%2Fsrc%2Fnumeric_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b776fb82941cadfc752368901f210831d5184d95/clippy_lints%2Fsrc%2Fnumeric_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnumeric_arithmetic.rs?ref=b776fb82941cadfc752368901f210831d5184d95", "patch": "@@ -1,170 +0,0 @@\n-use clippy_utils::consts::constant_simple;\n-use clippy_utils::diagnostics::span_lint;\n-use rustc_hir as hir;\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::source_map::Span;\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for integer arithmetic operations which could overflow or panic.\n-    ///\n-    /// Specifically, checks for any operators (`+`, `-`, `*`, `<<`, etc) which are capable\n-    /// of overflowing according to the [Rust\n-    /// Reference](https://doc.rust-lang.org/reference/expressions/operator-expr.html#overflow),\n-    /// or which can panic (`/`, `%`). No bounds analysis or sophisticated reasoning is\n-    /// attempted.\n-    ///\n-    /// ### Why is this bad?\n-    /// Integer overflow will trigger a panic in debug builds or will wrap in\n-    /// release mode. Division by zero will cause a panic in either mode. In some applications one\n-    /// wants explicitly checked, wrapping or saturating arithmetic.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # let a = 0;\n-    /// a + 1;\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub INTEGER_ARITHMETIC,\n-    restriction,\n-    \"any integer arithmetic expression which could overflow or panic\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for float arithmetic.\n-    ///\n-    /// ### Why is this bad?\n-    /// For some embedded systems or kernel development, it\n-    /// can be useful to rule out floating-point numbers.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # let a = 0.0;\n-    /// a + 1.0;\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub FLOAT_ARITHMETIC,\n-    restriction,\n-    \"any floating-point arithmetic statement\"\n-}\n-\n-#[derive(Copy, Clone, Default)]\n-pub struct NumericArithmetic {\n-    expr_span: Option<Span>,\n-    /// This field is used to check whether expressions are constants, such as in enum discriminants\n-    /// and consts\n-    const_span: Option<Span>,\n-}\n-\n-impl_lint_pass!(NumericArithmetic => [INTEGER_ARITHMETIC, FLOAT_ARITHMETIC]);\n-\n-impl<'tcx> LateLintPass<'tcx> for NumericArithmetic {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n-        if self.expr_span.is_some() {\n-            return;\n-        }\n-\n-        if let Some(span) = self.const_span {\n-            if span.contains(expr.span) {\n-                return;\n-            }\n-        }\n-        match &expr.kind {\n-            hir::ExprKind::Binary(op, l, r) | hir::ExprKind::AssignOp(op, l, r) => {\n-                match op.node {\n-                    hir::BinOpKind::And\n-                    | hir::BinOpKind::Or\n-                    | hir::BinOpKind::BitAnd\n-                    | hir::BinOpKind::BitOr\n-                    | hir::BinOpKind::BitXor\n-                    | hir::BinOpKind::Eq\n-                    | hir::BinOpKind::Lt\n-                    | hir::BinOpKind::Le\n-                    | hir::BinOpKind::Ne\n-                    | hir::BinOpKind::Ge\n-                    | hir::BinOpKind::Gt => return,\n-                    _ => (),\n-                }\n-\n-                let (l_ty, r_ty) = (cx.typeck_results().expr_ty(l), cx.typeck_results().expr_ty(r));\n-                if l_ty.peel_refs().is_integral() && r_ty.peel_refs().is_integral() {\n-                    match op.node {\n-                        hir::BinOpKind::Div | hir::BinOpKind::Rem => match &r.kind {\n-                            hir::ExprKind::Lit(_lit) => (),\n-                            hir::ExprKind::Unary(hir::UnOp::Neg, expr) => {\n-                                if let hir::ExprKind::Lit(lit) = &expr.kind {\n-                                    if let rustc_ast::ast::LitKind::Int(1, _) = lit.node {\n-                                        span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");\n-                                        self.expr_span = Some(expr.span);\n-                                    }\n-                                }\n-                            },\n-                            _ => {\n-                                span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");\n-                                self.expr_span = Some(expr.span);\n-                            },\n-                        },\n-                        _ => {\n-                            span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");\n-                            self.expr_span = Some(expr.span);\n-                        },\n-                    }\n-                } else if r_ty.peel_refs().is_floating_point() && r_ty.peel_refs().is_floating_point() {\n-                    span_lint(cx, FLOAT_ARITHMETIC, expr.span, \"floating-point arithmetic detected\");\n-                    self.expr_span = Some(expr.span);\n-                }\n-            },\n-            hir::ExprKind::Unary(hir::UnOp::Neg, arg) => {\n-                let ty = cx.typeck_results().expr_ty(arg);\n-                if constant_simple(cx, cx.typeck_results(), expr).is_none() {\n-                    if ty.is_integral() {\n-                        span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");\n-                        self.expr_span = Some(expr.span);\n-                    } else if ty.is_floating_point() {\n-                        span_lint(cx, FLOAT_ARITHMETIC, expr.span, \"floating-point arithmetic detected\");\n-                        self.expr_span = Some(expr.span);\n-                    }\n-                }\n-            },\n-            _ => (),\n-        }\n-    }\n-\n-    fn check_expr_post(&mut self, _: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n-        if Some(expr.span) == self.expr_span {\n-            self.expr_span = None;\n-        }\n-    }\n-\n-    fn check_body(&mut self, cx: &LateContext<'_>, body: &hir::Body<'_>) {\n-        let body_owner = cx.tcx.hir().body_owner_def_id(body.id());\n-\n-        match cx.tcx.hir().body_owner_kind(body_owner) {\n-            hir::BodyOwnerKind::Static(_) | hir::BodyOwnerKind::Const => {\n-                let body_span = cx.tcx.def_span(body_owner);\n-\n-                if let Some(span) = self.const_span {\n-                    if span.contains(body_span) {\n-                        return;\n-                    }\n-                }\n-                self.const_span = Some(body_span);\n-            },\n-            hir::BodyOwnerKind::Fn | hir::BodyOwnerKind::Closure => (),\n-        }\n-    }\n-\n-    fn check_body_post(&mut self, cx: &LateContext<'_>, body: &hir::Body<'_>) {\n-        let body_owner = cx.tcx.hir().body_owner(body.id());\n-        let body_span = cx.tcx.hir().span(body_owner);\n-\n-        if let Some(span) = self.const_span {\n-            if span.contains(body_span) {\n-                return;\n-            }\n-        }\n-        self.const_span = None;\n-    }\n-}"}, {"sha": "1ec4240afefe5c4939909735ef9d17c881d23efe", "filename": "clippy_lints/src/operators/absurd_extreme_comparisons.rs", "status": "renamed", "additions": 35, "deletions": 68, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Foperators%2Fabsurd_extreme_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Foperators%2Fabsurd_extreme_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Fabsurd_extreme_comparisons.rs?ref=23c6765276c968bf0fe4ee01f619f357b78390ca", "patch": "@@ -1,7 +1,6 @@\n use rustc_hir::{BinOpKind, Expr, ExprKind};\n-use rustc_lint::{LateContext, LateLintPass};\n+use rustc_lint::LateContext;\n use rustc_middle::ty;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n use clippy_utils::comparisons::{normalize_comparison, Rel};\n use clippy_utils::consts::{constant, Constant};\n@@ -10,73 +9,41 @@ use clippy_utils::source::snippet;\n use clippy_utils::ty::is_isize_or_usize;\n use clippy_utils::{clip, int_bits, unsext};\n \n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for comparisons where one side of the relation is\n-    /// either the minimum or maximum value for its type and warns if it involves a\n-    /// case that is always true or always false. Only integer and boolean types are\n-    /// checked.\n-    ///\n-    /// ### Why is this bad?\n-    /// An expression like `min <= x` may misleadingly imply\n-    /// that it is possible for `x` to be less than the minimum. Expressions like\n-    /// `max < x` are probably mistakes.\n-    ///\n-    /// ### Known problems\n-    /// For `usize` the size of the current compile target will\n-    /// be assumed (e.g., 64 bits on 64 bit systems). This means code that uses such\n-    /// a comparison to detect target pointer width will trigger this lint. One can\n-    /// use `mem::sizeof` and compare its value or conditional compilation\n-    /// attributes\n-    /// like `#[cfg(target_pointer_width = \"64\")] ..` instead.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// let vec: Vec<isize> = Vec::new();\n-    /// if vec.len() <= 0 {}\n-    /// if 100 > i32::MAX {}\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub ABSURD_EXTREME_COMPARISONS,\n-    correctness,\n-    \"a comparison with a maximum or minimum value that is always true or false\"\n-}\n+use super::ABSURD_EXTREME_COMPARISONS;\n \n-declare_lint_pass!(AbsurdExtremeComparisons => [ABSURD_EXTREME_COMPARISONS]);\n-\n-impl<'tcx> LateLintPass<'tcx> for AbsurdExtremeComparisons {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let ExprKind::Binary(ref cmp, lhs, rhs) = expr.kind {\n-            if let Some((culprit, result)) = detect_absurd_comparison(cx, cmp.node, lhs, rhs) {\n-                if !expr.span.from_expansion() {\n-                    let msg = \"this comparison involving the minimum or maximum element for this \\\n-                               type contains a case that is always true or always false\";\n-\n-                    let conclusion = match result {\n-                        AbsurdComparisonResult::AlwaysFalse => \"this comparison is always false\".to_owned(),\n-                        AbsurdComparisonResult::AlwaysTrue => \"this comparison is always true\".to_owned(),\n-                        AbsurdComparisonResult::InequalityImpossible => format!(\n-                            \"the case where the two sides are not equal never occurs, consider using `{} == {}` \\\n-                             instead\",\n-                            snippet(cx, lhs.span, \"lhs\"),\n-                            snippet(cx, rhs.span, \"rhs\")\n-                        ),\n-                    };\n-\n-                    let help = format!(\n-                        \"because `{}` is the {} value for this type, {}\",\n-                        snippet(cx, culprit.expr.span, \"x\"),\n-                        match culprit.which {\n-                            ExtremeType::Minimum => \"minimum\",\n-                            ExtremeType::Maximum => \"maximum\",\n-                        },\n-                        conclusion\n-                    );\n-\n-                    span_lint_and_help(cx, ABSURD_EXTREME_COMPARISONS, expr.span, msg, None, &help);\n-                }\n-            }\n-        }\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    op: BinOpKind,\n+    lhs: &'tcx Expr<'_>,\n+    rhs: &'tcx Expr<'_>,\n+) {\n+    if let Some((culprit, result)) = detect_absurd_comparison(cx, op, lhs, rhs) {\n+        let msg = \"this comparison involving the minimum or maximum element for this \\\n+                           type contains a case that is always true or always false\";\n+\n+        let conclusion = match result {\n+            AbsurdComparisonResult::AlwaysFalse => \"this comparison is always false\".to_owned(),\n+            AbsurdComparisonResult::AlwaysTrue => \"this comparison is always true\".to_owned(),\n+            AbsurdComparisonResult::InequalityImpossible => format!(\n+                \"the case where the two sides are not equal never occurs, consider using `{} == {}` \\\n+                         instead\",\n+                snippet(cx, lhs.span, \"lhs\"),\n+                snippet(cx, rhs.span, \"rhs\")\n+            ),\n+        };\n+\n+        let help = format!(\n+            \"because `{}` is the {} value for this type, {}\",\n+            snippet(cx, culprit.expr.span, \"x\"),\n+            match culprit.which {\n+                ExtremeType::Minimum => \"minimum\",\n+                ExtremeType::Maximum => \"maximum\",\n+            },\n+            conclusion\n+        );\n+\n+        span_lint_and_help(cx, ABSURD_EXTREME_COMPARISONS, expr.span, msg, None, &help);\n     }\n }\n ", "previous_filename": "clippy_lints/src/absurd_extreme_comparisons.rs"}, {"sha": "979e0a66707dda33463259430cefe05e6c01df62", "filename": "clippy_lints/src/operators/assign_op_pattern.rs", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Foperators%2Fassign_op_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Foperators%2Fassign_op_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Fassign_op_pattern.rs?ref=23c6765276c968bf0fe4ee01f619f357b78390ca", "patch": "@@ -0,0 +1,101 @@\n+use clippy_utils::binop_traits;\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::source::snippet_opt;\n+use clippy_utils::ty::implements_trait;\n+use clippy_utils::{eq_expr_value, trait_ref_of_method};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_hir::intravisit::{walk_expr, Visitor};\n+use rustc_lint::LateContext;\n+\n+use super::ASSIGN_OP_PATTERN;\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx hir::Expr<'_>,\n+    assignee: &'tcx hir::Expr<'_>,\n+    e: &'tcx hir::Expr<'_>,\n+) {\n+    if let hir::ExprKind::Binary(op, l, r) = &e.kind {\n+        let lint = |assignee: &hir::Expr<'_>, rhs: &hir::Expr<'_>| {\n+            let ty = cx.typeck_results().expr_ty(assignee);\n+            let rty = cx.typeck_results().expr_ty(rhs);\n+            if_chain! {\n+                if let Some((_, lang_item)) = binop_traits(op.node);\n+                if let Ok(trait_id) = cx.tcx.lang_items().require(lang_item);\n+                let parent_fn = cx.tcx.hir().get_parent_item(e.hir_id);\n+                if trait_ref_of_method(cx, parent_fn)\n+                    .map_or(true, |t| t.path.res.def_id() != trait_id);\n+                if implements_trait(cx, ty, trait_id, &[rty.into()]);\n+                then {\n+                    span_lint_and_then(\n+                        cx,\n+                        ASSIGN_OP_PATTERN,\n+                        expr.span,\n+                        \"manual implementation of an assign operation\",\n+                        |diag| {\n+                            if let (Some(snip_a), Some(snip_r)) =\n+                                (snippet_opt(cx, assignee.span), snippet_opt(cx, rhs.span))\n+                            {\n+                                diag.span_suggestion(\n+                                    expr.span,\n+                                    \"replace it with\",\n+                                    format!(\"{} {}= {}\", snip_a, op.node.as_str(), snip_r),\n+                                    Applicability::MachineApplicable,\n+                                );\n+                            }\n+                        },\n+                    );\n+                }\n+            }\n+        };\n+\n+        let mut visitor = ExprVisitor {\n+            assignee,\n+            counter: 0,\n+            cx,\n+        };\n+\n+        walk_expr(&mut visitor, e);\n+\n+        if visitor.counter == 1 {\n+            // a = a op b\n+            if eq_expr_value(cx, assignee, l) {\n+                lint(assignee, r);\n+            }\n+            // a = b commutative_op a\n+            // Limited to primitive type as these ops are know to be commutative\n+            if eq_expr_value(cx, assignee, r) && cx.typeck_results().expr_ty(assignee).is_primitive_ty() {\n+                match op.node {\n+                    hir::BinOpKind::Add\n+                    | hir::BinOpKind::Mul\n+                    | hir::BinOpKind::And\n+                    | hir::BinOpKind::Or\n+                    | hir::BinOpKind::BitXor\n+                    | hir::BinOpKind::BitAnd\n+                    | hir::BinOpKind::BitOr => {\n+                        lint(assignee, l);\n+                    },\n+                    _ => {},\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+struct ExprVisitor<'a, 'tcx> {\n+    assignee: &'a hir::Expr<'a>,\n+    counter: u8,\n+    cx: &'a LateContext<'tcx>,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for ExprVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n+        if eq_expr_value(self.cx, self.assignee, expr) {\n+            self.counter += 1;\n+        }\n+\n+        walk_expr(self, expr);\n+    }\n+}"}, {"sha": "74387fbc87be06be2f3b5e9b370f2fdf6af642c4", "filename": "clippy_lints/src/operators/bit_mask.rs", "status": "renamed", "additions": 15, "deletions": 153, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Foperators%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Foperators%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Fbit_mask.rs?ref=23c6765276c968bf0fe4ee01f619f357b78390ca", "patch": "@@ -1,161 +1,23 @@\n use clippy_utils::consts::{constant, Constant};\n-use clippy_utils::diagnostics::{span_lint, span_lint_and_then};\n-use clippy_utils::sugg::Sugg;\n-use rustc_ast::ast::LitKind;\n-use rustc_errors::Applicability;\n+use clippy_utils::diagnostics::span_lint;\n use rustc_hir::{BinOpKind, Expr, ExprKind};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_lint::LateContext;\n use rustc_span::source_map::Span;\n \n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for incompatible bit masks in comparisons.\n-    ///\n-    /// The formula for detecting if an expression of the type `_ <bit_op> m\n-    /// <cmp_op> c` (where `<bit_op>` is one of {`&`, `|`} and `<cmp_op>` is one of\n-    /// {`!=`, `>=`, `>`, `!=`, `>=`, `>`}) can be determined from the following\n-    /// table:\n-    ///\n-    /// |Comparison  |Bit Op|Example      |is always|Formula               |\n-    /// |------------|------|-------------|---------|----------------------|\n-    /// |`==` or `!=`| `&`  |`x & 2 == 3` |`false`  |`c & m != c`          |\n-    /// |`<`  or `>=`| `&`  |`x & 2 < 3`  |`true`   |`m < c`               |\n-    /// |`>`  or `<=`| `&`  |`x & 1 > 1`  |`false`  |`m <= c`              |\n-    /// |`==` or `!=`| `\\|` |`x \\| 1 == 0`|`false`  |`c \\| m != c`         |\n-    /// |`<`  or `>=`| `\\|` |`x \\| 1 < 1` |`false`  |`m >= c`              |\n-    /// |`<=` or `>` | `\\|` |`x \\| 1 > 0` |`true`   |`m > c`               |\n-    ///\n-    /// ### Why is this bad?\n-    /// If the bits that the comparison cares about are always\n-    /// set to zero or one by the bit mask, the comparison is constant `true` or\n-    /// `false` (depending on mask, compared value, and operators).\n-    ///\n-    /// So the code is actively misleading, and the only reason someone would write\n-    /// this intentionally is to win an underhanded Rust contest or create a\n-    /// test-case for this lint.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # let x = 1;\n-    /// if (x & 1 == 2) { }\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub BAD_BIT_MASK,\n-    correctness,\n-    \"expressions of the form `_ & mask == select` that will only ever return `true` or `false`\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for bit masks in comparisons which can be removed\n-    /// without changing the outcome. The basic structure can be seen in the\n-    /// following table:\n-    ///\n-    /// |Comparison| Bit Op   |Example     |equals |\n-    /// |----------|----------|------------|-------|\n-    /// |`>` / `<=`|`\\|` / `^`|`x \\| 2 > 3`|`x > 3`|\n-    /// |`<` / `>=`|`\\|` / `^`|`x ^ 1 < 4` |`x < 4`|\n-    ///\n-    /// ### Why is this bad?\n-    /// Not equally evil as [`bad_bit_mask`](#bad_bit_mask),\n-    /// but still a bit misleading, because the bit mask is ineffective.\n-    ///\n-    /// ### Known problems\n-    /// False negatives: This lint will only match instances\n-    /// where we have figured out the math (which is for a power-of-two compared\n-    /// value). This means things like `x | 1 >= 7` (which would be better written\n-    /// as `x >= 6`) will not be reported (but bit masks like this are fairly\n-    /// uncommon).\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # let x = 1;\n-    /// if (x | 1 > 3) {  }\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub INEFFECTIVE_BIT_MASK,\n-    correctness,\n-    \"expressions where a bit mask will be rendered useless by a comparison, e.g., `(x | 1) > 2`\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for bit masks that can be replaced by a call\n-    /// to `trailing_zeros`\n-    ///\n-    /// ### Why is this bad?\n-    /// `x.trailing_zeros() > 4` is much clearer than `x & 15\n-    /// == 0`\n-    ///\n-    /// ### Known problems\n-    /// llvm generates better code for `x & 15 == 0` on x86\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # let x = 1;\n-    /// if x & 0b1111 == 0 { }\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub VERBOSE_BIT_MASK,\n-    pedantic,\n-    \"expressions where a bit mask is less readable than the corresponding method call\"\n-}\n+use super::{BAD_BIT_MASK, INEFFECTIVE_BIT_MASK};\n \n-#[derive(Copy, Clone)]\n-pub struct BitMask {\n-    verbose_bit_mask_threshold: u64,\n-}\n-\n-impl BitMask {\n-    #[must_use]\n-    pub fn new(verbose_bit_mask_threshold: u64) -> Self {\n-        Self {\n-            verbose_bit_mask_threshold,\n-        }\n-    }\n-}\n-\n-impl_lint_pass!(BitMask => [BAD_BIT_MASK, INEFFECTIVE_BIT_MASK, VERBOSE_BIT_MASK]);\n-\n-impl<'tcx> LateLintPass<'tcx> for BitMask {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n-        if let ExprKind::Binary(cmp, left, right) = &e.kind {\n-            if cmp.node.is_comparison() {\n-                if let Some(cmp_opt) = fetch_int_literal(cx, right) {\n-                    check_compare(cx, left, cmp.node, cmp_opt, e.span);\n-                } else if let Some(cmp_val) = fetch_int_literal(cx, left) {\n-                    check_compare(cx, right, invert_cmp(cmp.node), cmp_val, e.span);\n-                }\n-            }\n-        }\n-\n-        if let ExprKind::Binary(op, left, right) = &e.kind\n-            && BinOpKind::Eq == op.node\n-            && let ExprKind::Binary(op1, left1, right1) = &left.kind\n-            && BinOpKind::BitAnd == op1.node\n-            && let ExprKind::Lit(lit) = &right1.kind\n-            && let LitKind::Int(n, _) = lit.node\n-            && let ExprKind::Lit(lit1) = &right.kind\n-            && let LitKind::Int(0, _) = lit1.node\n-            && n.leading_zeros() == n.count_zeros()\n-            && n > u128::from(self.verbose_bit_mask_threshold)\n-        {\n-            span_lint_and_then(\n-                cx,\n-                VERBOSE_BIT_MASK,\n-                e.span,\n-                \"bit mask could be simplified with a call to `trailing_zeros`\",\n-                |diag| {\n-                    let sugg = Sugg::hir(cx, left1, \"...\").maybe_par();\n-                    diag.span_suggestion(\n-                        e.span,\n-                        \"try\",\n-                        format!(\"{}.trailing_zeros() >= {}\", sugg, n.count_ones()),\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                },\n-            );\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    op: BinOpKind,\n+    left: &'tcx Expr<'_>,\n+    right: &'tcx Expr<'_>,\n+) {\n+    if op.is_comparison() {\n+        if let Some(cmp_opt) = fetch_int_literal(cx, right) {\n+            check_compare(cx, left, op, cmp_opt, e.span);\n+        } else if let Some(cmp_val) = fetch_int_literal(cx, left) {\n+            check_compare(cx, right, invert_cmp(op), cmp_val, e.span);\n         }\n     }\n }", "previous_filename": "clippy_lints/src/bit_mask.rs"}, {"sha": "786ae1552ad3d01283d3e6e33dd8665cbe480c87", "filename": "clippy_lints/src/operators/cmp_nan.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Foperators%2Fcmp_nan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Foperators%2Fcmp_nan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Fcmp_nan.rs?ref=23c6765276c968bf0fe4ee01f619f357b78390ca", "patch": "@@ -0,0 +1,30 @@\n+use clippy_utils::consts::{constant, Constant};\n+use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::in_constant;\n+use rustc_hir::{BinOpKind, Expr};\n+use rustc_lint::LateContext;\n+\n+use super::CMP_NAN;\n+\n+pub(super) fn check(cx: &LateContext<'_>, e: &Expr<'_>, op: BinOpKind, lhs: &Expr<'_>, rhs: &Expr<'_>) {\n+    if op.is_comparison() && !in_constant(cx, e.hir_id) && (is_nan(cx, lhs) || is_nan(cx, rhs)) {\n+        span_lint(\n+            cx,\n+            CMP_NAN,\n+            e.span,\n+            \"doomed comparison with `NAN`, use `{f32,f64}::is_nan()` instead\",\n+        );\n+    }\n+}\n+\n+fn is_nan(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n+    if let Some((value, _)) = constant(cx, cx.typeck_results(), e) {\n+        match value {\n+            Constant::F32(num) => num.is_nan(),\n+            Constant::F64(num) => num.is_nan(),\n+            _ => false,\n+        }\n+    } else {\n+        false\n+    }\n+}"}, {"sha": "e1f9b5906f667cdb8e62ae670ecba722bb13773f", "filename": "clippy_lints/src/operators/cmp_owned.rs", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Foperators%2Fcmp_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Foperators%2Fcmp_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Fcmp_owned.rs?ref=23c6765276c968bf0fe4ee01f619f357b78390ca", "patch": "@@ -0,0 +1,147 @@\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::source::snippet;\n+use clippy_utils::ty::{implements_trait, is_copy};\n+use clippy_utils::{match_any_def_paths, path_def_id, paths};\n+use rustc_errors::Applicability;\n+use rustc_hir::{BinOpKind, Expr, ExprKind, UnOp};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::Ty;\n+use rustc_span::symbol::sym;\n+\n+use super::CMP_OWNED;\n+\n+pub(super) fn check(cx: &LateContext<'_>, op: BinOpKind, lhs: &Expr<'_>, rhs: &Expr<'_>) {\n+    if op.is_comparison() {\n+        check_op(cx, lhs, rhs, true);\n+        check_op(cx, rhs, lhs, false);\n+    }\n+}\n+\n+#[derive(Default)]\n+struct EqImpl {\n+    ty_eq_other: bool,\n+    other_eq_ty: bool,\n+}\n+impl EqImpl {\n+    fn is_implemented(&self) -> bool {\n+        self.ty_eq_other || self.other_eq_ty\n+    }\n+}\n+\n+fn symmetric_partial_eq<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, other: Ty<'tcx>) -> Option<EqImpl> {\n+    cx.tcx.lang_items().eq_trait().map(|def_id| EqImpl {\n+        ty_eq_other: implements_trait(cx, ty, def_id, &[other.into()]),\n+        other_eq_ty: implements_trait(cx, other, def_id, &[ty.into()]),\n+    })\n+}\n+\n+fn check_op(cx: &LateContext<'_>, expr: &Expr<'_>, other: &Expr<'_>, left: bool) {\n+    let typeck = cx.typeck_results();\n+    let (arg, arg_span) = match expr.kind {\n+        ExprKind::MethodCall(.., [arg], _)\n+            if typeck\n+                .type_dependent_def_id(expr.hir_id)\n+                .and_then(|id| cx.tcx.trait_of_item(id))\n+                .map_or(false, |id| {\n+                    matches!(cx.tcx.get_diagnostic_name(id), Some(sym::ToString | sym::ToOwned))\n+                }) =>\n+        {\n+            (arg, arg.span)\n+        },\n+        ExprKind::Call(path, [arg])\n+            if path_def_id(cx, path)\n+                .and_then(|id| match_any_def_paths(cx, id, &[&paths::FROM_STR_METHOD, &paths::FROM_FROM]))\n+                .map_or(false, |idx| match idx {\n+                    0 => true,\n+                    1 => !is_copy(cx, typeck.expr_ty(expr)),\n+                    _ => false,\n+                }) =>\n+        {\n+            (arg, arg.span)\n+        },\n+        _ => return,\n+    };\n+\n+    let arg_ty = typeck.expr_ty(arg);\n+    let other_ty = typeck.expr_ty(other);\n+\n+    let without_deref = symmetric_partial_eq(cx, arg_ty, other_ty).unwrap_or_default();\n+    let with_deref = arg_ty\n+        .builtin_deref(true)\n+        .and_then(|tam| symmetric_partial_eq(cx, tam.ty, other_ty))\n+        .unwrap_or_default();\n+\n+    if !with_deref.is_implemented() && !without_deref.is_implemented() {\n+        return;\n+    }\n+\n+    let other_gets_derefed = matches!(other.kind, ExprKind::Unary(UnOp::Deref, _));\n+\n+    let lint_span = if other_gets_derefed {\n+        expr.span.to(other.span)\n+    } else {\n+        expr.span\n+    };\n+\n+    span_lint_and_then(\n+        cx,\n+        CMP_OWNED,\n+        lint_span,\n+        \"this creates an owned instance just for comparison\",\n+        |diag| {\n+            // This also catches `PartialEq` implementations that call `to_owned`.\n+            if other_gets_derefed {\n+                diag.span_label(lint_span, \"try implementing the comparison without allocating\");\n+                return;\n+            }\n+\n+            let arg_snip = snippet(cx, arg_span, \"..\");\n+            let expr_snip;\n+            let eq_impl;\n+            if with_deref.is_implemented() {\n+                expr_snip = format!(\"*{}\", arg_snip);\n+                eq_impl = with_deref;\n+            } else {\n+                expr_snip = arg_snip.to_string();\n+                eq_impl = without_deref;\n+            };\n+\n+            let span;\n+            let hint;\n+            if (eq_impl.ty_eq_other && left) || (eq_impl.other_eq_ty && !left) {\n+                span = expr.span;\n+                hint = expr_snip;\n+            } else {\n+                span = expr.span.to(other.span);\n+\n+                let cmp_span = if other.span < expr.span {\n+                    other.span.between(expr.span)\n+                } else {\n+                    expr.span.between(other.span)\n+                };\n+                if eq_impl.ty_eq_other {\n+                    hint = format!(\n+                        \"{}{}{}\",\n+                        expr_snip,\n+                        snippet(cx, cmp_span, \"..\"),\n+                        snippet(cx, other.span, \"..\")\n+                    );\n+                } else {\n+                    hint = format!(\n+                        \"{}{}{}\",\n+                        snippet(cx, other.span, \"..\"),\n+                        snippet(cx, cmp_span, \"..\"),\n+                        expr_snip\n+                    );\n+                }\n+            }\n+\n+            diag.span_suggestion(\n+                span,\n+                \"try\",\n+                hint,\n+                Applicability::MachineApplicable, // snippet\n+            );\n+        },\n+    );\n+}"}, {"sha": "56a86d0ffa212347bcf2b9ce12c554ad1cdabfe9", "filename": "clippy_lints/src/operators/double_comparison.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Foperators%2Fdouble_comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Foperators%2Fdouble_comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Fdouble_comparison.rs?ref=23c6765276c968bf0fe4ee01f619f357b78390ca", "patch": "@@ -0,0 +1,54 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::eq_expr_value;\n+use clippy_utils::source::snippet_with_applicability;\n+use rustc_errors::Applicability;\n+use rustc_hir::{BinOpKind, Expr, ExprKind};\n+use rustc_lint::LateContext;\n+use rustc_span::source_map::Span;\n+\n+use super::DOUBLE_COMPARISONS;\n+\n+#[expect(clippy::similar_names)]\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, op: BinOpKind, lhs: &'tcx Expr<'_>, rhs: &'tcx Expr<'_>, span: Span) {\n+    let (lkind, llhs, lrhs, rkind, rlhs, rrhs) = match (&lhs.kind, &rhs.kind) {\n+        (ExprKind::Binary(lb, llhs, lrhs), ExprKind::Binary(rb, rlhs, rrhs)) => {\n+            (lb.node, llhs, lrhs, rb.node, rlhs, rrhs)\n+        },\n+        _ => return,\n+    };\n+    if !(eq_expr_value(cx, llhs, rlhs) && eq_expr_value(cx, lrhs, rrhs)) {\n+        return;\n+    }\n+    macro_rules! lint_double_comparison {\n+        ($op:tt) => {{\n+            let mut applicability = Applicability::MachineApplicable;\n+            let lhs_str = snippet_with_applicability(cx, llhs.span, \"\", &mut applicability);\n+            let rhs_str = snippet_with_applicability(cx, lrhs.span, \"\", &mut applicability);\n+            let sugg = format!(\"{} {} {}\", lhs_str, stringify!($op), rhs_str);\n+            span_lint_and_sugg(\n+                cx,\n+                DOUBLE_COMPARISONS,\n+                span,\n+                \"this binary expression can be simplified\",\n+                \"try\",\n+                sugg,\n+                applicability,\n+            );\n+        }};\n+    }\n+    match (op, lkind, rkind) {\n+        (BinOpKind::Or, BinOpKind::Eq, BinOpKind::Lt) | (BinOpKind::Or, BinOpKind::Lt, BinOpKind::Eq) => {\n+            lint_double_comparison!(<=);\n+        },\n+        (BinOpKind::Or, BinOpKind::Eq, BinOpKind::Gt) | (BinOpKind::Or, BinOpKind::Gt, BinOpKind::Eq) => {\n+            lint_double_comparison!(>=);\n+        },\n+        (BinOpKind::Or, BinOpKind::Lt, BinOpKind::Gt) | (BinOpKind::Or, BinOpKind::Gt, BinOpKind::Lt) => {\n+            lint_double_comparison!(!=);\n+        },\n+        (BinOpKind::And, BinOpKind::Le, BinOpKind::Ge) | (BinOpKind::And, BinOpKind::Ge, BinOpKind::Le) => {\n+            lint_double_comparison!(==);\n+        },\n+        _ => (),\n+    };\n+}"}, {"sha": "0d067d1e1968c4ec2d729e932c08f6cabf6e7577", "filename": "clippy_lints/src/operators/duration_subsec.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Foperators%2Fduration_subsec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Foperators%2Fduration_subsec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Fduration_subsec.rs?ref=23c6765276c968bf0fe4ee01f619f357b78390ca", "patch": "@@ -0,0 +1,44 @@\n+use clippy_utils::consts::{constant, Constant};\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use rustc_errors::Applicability;\n+use rustc_hir::{BinOpKind, Expr, ExprKind};\n+use rustc_lint::LateContext;\n+use rustc_span::sym;\n+\n+use super::DURATION_SUBSEC;\n+\n+pub(crate) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    op: BinOpKind,\n+    left: &'tcx Expr<'_>,\n+    right: &'tcx Expr<'_>,\n+) {\n+    if op == BinOpKind::Div\n+        && let ExprKind::MethodCall(method_path, [self_arg], _) = left.kind\n+        && is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(self_arg).peel_refs(), sym::Duration)\n+        && let Some((Constant::Int(divisor), _)) = constant(cx, cx.typeck_results(), right)\n+    {\n+        let suggested_fn = match (method_path.ident.as_str(), divisor) {\n+            (\"subsec_micros\", 1_000) | (\"subsec_nanos\", 1_000_000) => \"subsec_millis\",\n+            (\"subsec_nanos\", 1_000) => \"subsec_micros\",\n+            _ => return,\n+        };\n+        let mut applicability = Applicability::MachineApplicable;\n+        span_lint_and_sugg(\n+            cx,\n+            DURATION_SUBSEC,\n+            expr.span,\n+            &format!(\"calling `{}()` is more concise than this calculation\", suggested_fn),\n+            \"try\",\n+            format!(\n+                \"{}.{}()\",\n+                snippet_with_applicability(cx, self_arg.span, \"_\", &mut applicability),\n+                suggested_fn\n+            ),\n+            applicability,\n+        );\n+    }\n+}"}, {"sha": "44cf0bb06120aba79134dba1ee969294fcdb1e58", "filename": "clippy_lints/src/operators/eq_op.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Foperators%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Foperators%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Feq_op.rs?ref=23c6765276c968bf0fe4ee01f619f357b78390ca", "patch": "@@ -0,0 +1,45 @@\n+use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::macros::{find_assert_eq_args, first_node_macro_backtrace};\n+use clippy_utils::{ast_utils::is_useless_with_eq_exprs, eq_expr_value, is_in_test_function};\n+use rustc_hir::{BinOpKind, Expr};\n+use rustc_lint::LateContext;\n+\n+use super::EQ_OP;\n+\n+pub(crate) fn check_assert<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n+    if let Some((macro_call, macro_name))\n+        = first_node_macro_backtrace(cx, e).find_map(|macro_call| {\n+            let name = cx.tcx.item_name(macro_call.def_id);\n+            matches!(name.as_str(), \"assert_eq\" | \"assert_ne\" | \"debug_assert_eq\" | \"debug_assert_ne\")\n+                .then(|| (macro_call, name))\n+        })\n+        && let Some((lhs, rhs, _)) = find_assert_eq_args(cx, e, macro_call.expn)\n+        && eq_expr_value(cx, lhs, rhs)\n+        && macro_call.is_local()\n+        && !is_in_test_function(cx.tcx, e.hir_id)\n+    {\n+        span_lint(\n+            cx,\n+            EQ_OP,\n+            lhs.span.to(rhs.span),\n+            &format!(\"identical args used in this `{}!` macro call\", macro_name),\n+        );\n+    }\n+}\n+\n+pub(crate) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    op: BinOpKind,\n+    left: &'tcx Expr<'_>,\n+    right: &'tcx Expr<'_>,\n+) {\n+    if is_useless_with_eq_exprs(op.into()) && eq_expr_value(cx, left, right) && !is_in_test_function(cx.tcx, e.hir_id) {\n+        span_lint(\n+            cx,\n+            EQ_OP,\n+            e.span,\n+            &format!(\"equal expressions as operands to `{}`\", op.as_str()),\n+        );\n+    }\n+}"}, {"sha": "066e08f3bd4cac6c34c672c0239262fd34536e36", "filename": "clippy_lints/src/operators/erasing_op.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Foperators%2Ferasing_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Foperators%2Ferasing_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Ferasing_op.rs?ref=23c6765276c968bf0fe4ee01f619f357b78390ca", "patch": "@@ -0,0 +1,53 @@\n+use clippy_utils::consts::{constant_simple, Constant};\n+use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::ty::same_type_and_consts;\n+\n+use rustc_hir::{BinOpKind, Expr};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::TypeckResults;\n+\n+use super::ERASING_OP;\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    op: BinOpKind,\n+    left: &'tcx Expr<'_>,\n+    right: &'tcx Expr<'_>,\n+) {\n+    let tck = cx.typeck_results();\n+    match op {\n+        BinOpKind::Mul | BinOpKind::BitAnd => {\n+            check_op(cx, tck, left, right, e);\n+            check_op(cx, tck, right, left, e);\n+        },\n+        BinOpKind::Div => check_op(cx, tck, left, right, e),\n+        _ => (),\n+    }\n+}\n+\n+fn different_types(tck: &TypeckResults<'_>, input: &Expr<'_>, output: &Expr<'_>) -> bool {\n+    let input_ty = tck.expr_ty(input).peel_refs();\n+    let output_ty = tck.expr_ty(output).peel_refs();\n+    !same_type_and_consts(input_ty, output_ty)\n+}\n+\n+fn check_op<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    tck: &TypeckResults<'tcx>,\n+    op: &Expr<'tcx>,\n+    other: &Expr<'tcx>,\n+    parent: &Expr<'tcx>,\n+) {\n+    if constant_simple(cx, tck, op) == Some(Constant::Int(0)) {\n+        if different_types(tck, other, parent) {\n+            return;\n+        }\n+        span_lint(\n+            cx,\n+            ERASING_OP,\n+            parent.span,\n+            \"this operation will always return zero. This is likely not the intended outcome\",\n+        );\n+    }\n+}"}, {"sha": "0ef793443ff45ce618c7bfc2d32ae2363674c6d1", "filename": "clippy_lints/src/operators/float_cmp.rs", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Foperators%2Ffloat_cmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Foperators%2Ffloat_cmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Ffloat_cmp.rs?ref=23c6765276c968bf0fe4ee01f619f357b78390ca", "patch": "@@ -0,0 +1,139 @@\n+use clippy_utils::consts::{constant, Constant};\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::get_item_name;\n+use clippy_utils::sugg::Sugg;\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{BinOpKind, Expr, ExprKind, UnOp};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+\n+use super::{FLOAT_CMP, FLOAT_CMP_CONST};\n+\n+pub(crate) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    op: BinOpKind,\n+    left: &'tcx Expr<'_>,\n+    right: &'tcx Expr<'_>,\n+) {\n+    if (op == BinOpKind::Eq || op == BinOpKind::Ne) && (is_float(cx, left) || is_float(cx, right)) {\n+        if is_allowed(cx, left) || is_allowed(cx, right) {\n+            return;\n+        }\n+\n+        // Allow comparing the results of signum()\n+        if is_signum(cx, left) && is_signum(cx, right) {\n+            return;\n+        }\n+\n+        if let Some(name) = get_item_name(cx, expr) {\n+            let name = name.as_str();\n+            if name == \"eq\" || name == \"ne\" || name == \"is_nan\" || name.starts_with(\"eq_\") || name.ends_with(\"_eq\") {\n+                return;\n+            }\n+        }\n+        let is_comparing_arrays = is_array(cx, left) || is_array(cx, right);\n+        let (lint, msg) = get_lint_and_message(\n+            is_named_constant(cx, left) || is_named_constant(cx, right),\n+            is_comparing_arrays,\n+        );\n+        span_lint_and_then(cx, lint, expr.span, msg, |diag| {\n+            let lhs = Sugg::hir(cx, left, \"..\");\n+            let rhs = Sugg::hir(cx, right, \"..\");\n+\n+            if !is_comparing_arrays {\n+                diag.span_suggestion(\n+                    expr.span,\n+                    \"consider comparing them within some margin of error\",\n+                    format!(\n+                        \"({}).abs() {} error_margin\",\n+                        lhs - rhs,\n+                        if op == BinOpKind::Eq { '<' } else { '>' }\n+                    ),\n+                    Applicability::HasPlaceholders, // snippet\n+                );\n+            }\n+            diag.note(\"`f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\");\n+        });\n+    }\n+}\n+\n+fn get_lint_and_message(\n+    is_comparing_constants: bool,\n+    is_comparing_arrays: bool,\n+) -> (&'static rustc_lint::Lint, &'static str) {\n+    if is_comparing_constants {\n+        (\n+            FLOAT_CMP_CONST,\n+            if is_comparing_arrays {\n+                \"strict comparison of `f32` or `f64` constant arrays\"\n+            } else {\n+                \"strict comparison of `f32` or `f64` constant\"\n+            },\n+        )\n+    } else {\n+        (\n+            FLOAT_CMP,\n+            if is_comparing_arrays {\n+                \"strict comparison of `f32` or `f64` arrays\"\n+            } else {\n+                \"strict comparison of `f32` or `f64`\"\n+            },\n+        )\n+    }\n+}\n+\n+fn is_named_constant<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n+    if let Some((_, res)) = constant(cx, cx.typeck_results(), expr) {\n+        res\n+    } else {\n+        false\n+    }\n+}\n+\n+fn is_allowed<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n+    match constant(cx, cx.typeck_results(), expr) {\n+        Some((Constant::F32(f), _)) => f == 0.0 || f.is_infinite(),\n+        Some((Constant::F64(f), _)) => f == 0.0 || f.is_infinite(),\n+        Some((Constant::Vec(vec), _)) => vec.iter().all(|f| match f {\n+            Constant::F32(f) => *f == 0.0 || (*f).is_infinite(),\n+            Constant::F64(f) => *f == 0.0 || (*f).is_infinite(),\n+            _ => false,\n+        }),\n+        _ => false,\n+    }\n+}\n+\n+// Return true if `expr` is the result of `signum()` invoked on a float value.\n+fn is_signum(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n+    // The negation of a signum is still a signum\n+    if let ExprKind::Unary(UnOp::Neg, child_expr) = expr.kind {\n+        return is_signum(cx, child_expr);\n+    }\n+\n+    if_chain! {\n+        if let ExprKind::MethodCall(method_name, [ref self_arg, ..], _) = expr.kind;\n+        if sym!(signum) == method_name.ident.name;\n+        // Check that the receiver of the signum() is a float (expressions[0] is the receiver of\n+        // the method call)\n+        then {\n+            return is_float(cx, self_arg);\n+        }\n+    }\n+    false\n+}\n+\n+fn is_float(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n+    let value = &cx.typeck_results().expr_ty(expr).peel_refs().kind();\n+\n+    if let ty::Array(arr_ty, _) = value {\n+        return matches!(arr_ty.kind(), ty::Float(_));\n+    };\n+\n+    matches!(value, ty::Float(_))\n+}\n+\n+fn is_array(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n+    matches!(&cx.typeck_results().expr_ty(expr).peel_refs().kind(), ty::Array(_, _))\n+}"}, {"sha": "a0a8b6aabd9e37b0237aeed23a6c3cc278fa11ab", "filename": "clippy_lints/src/operators/float_equality_without_abs.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Foperators%2Ffloat_equality_without_abs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Foperators%2Ffloat_equality_without_abs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Ffloat_equality_without_abs.rs?ref=23c6765276c968bf0fe4ee01f619f357b78390ca", "patch": "@@ -0,0 +1,71 @@\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::{match_def_path, paths, sugg};\n+use if_chain::if_chain;\n+use rustc_ast::util::parser::AssocOp;\n+use rustc_errors::Applicability;\n+use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::{BinOpKind, Expr, ExprKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+use rustc_span::source_map::Spanned;\n+\n+use super::FLOAT_EQUALITY_WITHOUT_ABS;\n+\n+pub(crate) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    op: BinOpKind,\n+    lhs: &'tcx Expr<'_>,\n+    rhs: &'tcx Expr<'_>,\n+) {\n+    let (lhs, rhs) = match op {\n+        BinOpKind::Lt => (lhs, rhs),\n+        BinOpKind::Gt => (rhs, lhs),\n+        _ => return,\n+    };\n+\n+    if_chain! {\n+        // left hand side is a subtraction\n+        if let ExprKind::Binary(\n+            Spanned {\n+                node: BinOpKind::Sub,\n+                ..\n+            },\n+            val_l,\n+            val_r,\n+        ) = lhs.kind;\n+\n+        // right hand side matches either f32::EPSILON or f64::EPSILON\n+        if let ExprKind::Path(ref epsilon_path) = rhs.kind;\n+        if let Res::Def(DefKind::AssocConst, def_id) = cx.qpath_res(epsilon_path, rhs.hir_id);\n+        if match_def_path(cx, def_id, &paths::F32_EPSILON) || match_def_path(cx, def_id, &paths::F64_EPSILON);\n+\n+        // values of the subtractions on the left hand side are of the type float\n+        let t_val_l = cx.typeck_results().expr_ty(val_l);\n+        let t_val_r = cx.typeck_results().expr_ty(val_r);\n+        if let ty::Float(_) = t_val_l.kind();\n+        if let ty::Float(_) = t_val_r.kind();\n+\n+        then {\n+            let sug_l = sugg::Sugg::hir(cx, val_l, \"..\");\n+            let sug_r = sugg::Sugg::hir(cx, val_r, \"..\");\n+            // format the suggestion\n+            let suggestion = format!(\"{}.abs()\", sugg::make_assoc(AssocOp::Subtract, &sug_l, &sug_r).maybe_par());\n+            // spans the lint\n+            span_lint_and_then(\n+                cx,\n+                FLOAT_EQUALITY_WITHOUT_ABS,\n+                expr.span,\n+                \"float equality check without `.abs()`\",\n+                | diag | {\n+                    diag.span_suggestion(\n+                        lhs.span,\n+                        \"add `.abs()`\",\n+                        suggestion,\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+            );\n+        }\n+    }\n+}"}, {"sha": "b48d6c4e2e2af96318e38bdcb81ce5b2f3a548e9", "filename": "clippy_lints/src/operators/identity_op.rs", "status": "renamed", "additions": 33, "deletions": 54, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Foperators%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Foperators%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Fidentity_op.rs?ref=23c6765276c968bf0fe4ee01f619f357b78390ca", "patch": "@@ -3,61 +3,40 @@ use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::{clip, unsext};\n use rustc_errors::Applicability;\n-use rustc_hir::{BinOp, BinOpKind, Expr, ExprKind, Node};\n-use rustc_lint::{LateContext, LateLintPass};\n+use rustc_hir::{BinOpKind, Expr, ExprKind, Node};\n+use rustc_lint::LateContext;\n use rustc_middle::ty;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n \n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for identity operations, e.g., `x + 0`.\n-    ///\n-    /// ### Why is this bad?\n-    /// This code can be removed without changing the\n-    /// meaning. So it just obscures what's going on. Delete it mercilessly.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # let x = 1;\n-    /// x / 1 + 0 * 1 - 0 | 0;\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub IDENTITY_OP,\n-    complexity,\n-    \"using identity operations, e.g., `x + 0` or `y / 1`\"\n-}\n-\n-declare_lint_pass!(IdentityOp => [IDENTITY_OP]);\n+use super::IDENTITY_OP;\n \n-impl<'tcx> LateLintPass<'tcx> for IdentityOp {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if expr.span.from_expansion() {\n-            return;\n-        }\n-        if let ExprKind::Binary(cmp, left, right) = &expr.kind {\n-            if !is_allowed(cx, *cmp, left, right) {\n-                match cmp.node {\n-                    BinOpKind::Add | BinOpKind::BitOr | BinOpKind::BitXor => {\n-                        check(cx, left, 0, expr.span, right.span, needs_parenthesis(cx, expr, right));\n-                        check(cx, right, 0, expr.span, left.span, Parens::Unneeded);\n-                    },\n-                    BinOpKind::Shl | BinOpKind::Shr | BinOpKind::Sub => {\n-                        check(cx, right, 0, expr.span, left.span, Parens::Unneeded);\n-                    },\n-                    BinOpKind::Mul => {\n-                        check(cx, left, 1, expr.span, right.span, needs_parenthesis(cx, expr, right));\n-                        check(cx, right, 1, expr.span, left.span, Parens::Unneeded);\n-                    },\n-                    BinOpKind::Div => check(cx, right, 1, expr.span, left.span, Parens::Unneeded),\n-                    BinOpKind::BitAnd => {\n-                        check(cx, left, -1, expr.span, right.span, needs_parenthesis(cx, expr, right));\n-                        check(cx, right, -1, expr.span, left.span, Parens::Unneeded);\n-                    },\n-                    BinOpKind::Rem => check_remainder(cx, left, right, expr.span, left.span),\n-                    _ => (),\n-                }\n-            }\n+pub(crate) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    op: BinOpKind,\n+    left: &'tcx Expr<'_>,\n+    right: &'tcx Expr<'_>,\n+) {\n+    if !is_allowed(cx, op, left, right) {\n+        match op {\n+            BinOpKind::Add | BinOpKind::BitOr | BinOpKind::BitXor => {\n+                check_op(cx, left, 0, expr.span, right.span, needs_parenthesis(cx, expr, right));\n+                check_op(cx, right, 0, expr.span, left.span, Parens::Unneeded);\n+            },\n+            BinOpKind::Shl | BinOpKind::Shr | BinOpKind::Sub => {\n+                check_op(cx, right, 0, expr.span, left.span, Parens::Unneeded);\n+            },\n+            BinOpKind::Mul => {\n+                check_op(cx, left, 1, expr.span, right.span, needs_parenthesis(cx, expr, right));\n+                check_op(cx, right, 1, expr.span, left.span, Parens::Unneeded);\n+            },\n+            BinOpKind::Div => check_op(cx, right, 1, expr.span, left.span, Parens::Unneeded),\n+            BinOpKind::BitAnd => {\n+                check_op(cx, left, -1, expr.span, right.span, needs_parenthesis(cx, expr, right));\n+                check_op(cx, right, -1, expr.span, left.span, Parens::Unneeded);\n+            },\n+            BinOpKind::Rem => check_remainder(cx, left, right, expr.span, left.span),\n+            _ => (),\n         }\n     }\n }\n@@ -108,12 +87,12 @@ fn needs_parenthesis(cx: &LateContext<'_>, binary: &Expr<'_>, right: &Expr<'_>)\n     Parens::Needed\n }\n \n-fn is_allowed(cx: &LateContext<'_>, cmp: BinOp, left: &Expr<'_>, right: &Expr<'_>) -> bool {\n+fn is_allowed(cx: &LateContext<'_>, cmp: BinOpKind, left: &Expr<'_>, right: &Expr<'_>) -> bool {\n     // This lint applies to integers\n     !cx.typeck_results().expr_ty(left).peel_refs().is_integral()\n         || !cx.typeck_results().expr_ty(right).peel_refs().is_integral()\n         // `1 << 0` is a common pattern in bit manipulation code\n-        || (cmp.node == BinOpKind::Shl\n+        || (cmp == BinOpKind::Shl\n             && constant_simple(cx, cx.typeck_results(), right) == Some(Constant::Int(0))\n             && constant_simple(cx, cx.typeck_results(), left) == Some(Constant::Int(1)))\n }\n@@ -130,7 +109,7 @@ fn check_remainder(cx: &LateContext<'_>, left: &Expr<'_>, right: &Expr<'_>, span\n     }\n }\n \n-fn check(cx: &LateContext<'_>, e: &Expr<'_>, m: i8, span: Span, arg: Span, parens: Parens) {\n+fn check_op(cx: &LateContext<'_>, e: &Expr<'_>, m: i8, span: Span, arg: Span, parens: Parens) {\n     if let Some(Constant::Int(v)) = constant_simple(cx, cx.typeck_results(), e).map(Constant::peel_refs) {\n         let check = match *cx.typeck_results().expr_ty(e).peel_refs().kind() {\n             ty::Int(ity) => unsext(cx.tcx, -1_i128, ity),", "previous_filename": "clippy_lints/src/identity_op.rs"}, {"sha": "631d10f4a72e9b14710096f4508a7667e466682f", "filename": "clippy_lints/src/operators/integer_division.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Foperators%2Finteger_division.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Foperators%2Finteger_division.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Finteger_division.rs?ref=23c6765276c968bf0fe4ee01f619f357b78390ca", "patch": "@@ -0,0 +1,27 @@\n+use clippy_utils::diagnostics::span_lint_and_help;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+\n+use super::INTEGER_DIVISION;\n+\n+pub(crate) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx hir::Expr<'_>,\n+    op: hir::BinOpKind,\n+    left: &'tcx hir::Expr<'_>,\n+    right: &'tcx hir::Expr<'_>,\n+) {\n+    if op == hir::BinOpKind::Div\n+        && cx.typeck_results().expr_ty(left).is_integral()\n+        && cx.typeck_results().expr_ty(right).is_integral()\n+    {\n+        span_lint_and_help(\n+            cx,\n+            INTEGER_DIVISION,\n+            expr.span,\n+            \"integer division\",\n+            None,\n+            \"division of integers may cause loss of precision. consider using floats\",\n+        );\n+    }\n+}"}, {"sha": "0024384d9278daaaae0aba70a72c27013bad40de", "filename": "clippy_lints/src/operators/misrefactored_assign_op.rs", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Foperators%2Fmisrefactored_assign_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Foperators%2Fmisrefactored_assign_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Fmisrefactored_assign_op.rs?ref=23c6765276c968bf0fe4ee01f619f357b78390ca", "patch": "@@ -0,0 +1,84 @@\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::eq_expr_value;\n+use clippy_utils::source::snippet_opt;\n+use clippy_utils::sugg;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+\n+use super::MISREFACTORED_ASSIGN_OP;\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx hir::Expr<'_>,\n+    op: hir::BinOpKind,\n+    lhs: &'tcx hir::Expr<'_>,\n+    rhs: &'tcx hir::Expr<'_>,\n+) {\n+    if let hir::ExprKind::Binary(binop, l, r) = &rhs.kind {\n+        if op != binop.node {\n+            return;\n+        }\n+        // lhs op= l op r\n+        if eq_expr_value(cx, lhs, l) {\n+            lint_misrefactored_assign_op(cx, expr, op, rhs, lhs, r);\n+        }\n+        // lhs op= l commutative_op r\n+        if is_commutative(op) && eq_expr_value(cx, lhs, r) {\n+            lint_misrefactored_assign_op(cx, expr, op, rhs, lhs, l);\n+        }\n+    }\n+}\n+\n+fn lint_misrefactored_assign_op(\n+    cx: &LateContext<'_>,\n+    expr: &hir::Expr<'_>,\n+    op: hir::BinOpKind,\n+    rhs: &hir::Expr<'_>,\n+    assignee: &hir::Expr<'_>,\n+    rhs_other: &hir::Expr<'_>,\n+) {\n+    span_lint_and_then(\n+        cx,\n+        MISREFACTORED_ASSIGN_OP,\n+        expr.span,\n+        \"variable appears on both sides of an assignment operation\",\n+        |diag| {\n+            if let (Some(snip_a), Some(snip_r)) = (snippet_opt(cx, assignee.span), snippet_opt(cx, rhs_other.span)) {\n+                let a = &sugg::Sugg::hir(cx, assignee, \"..\");\n+                let r = &sugg::Sugg::hir(cx, rhs, \"..\");\n+                let long = format!(\"{} = {}\", snip_a, sugg::make_binop(op.into(), a, r));\n+                diag.span_suggestion(\n+                    expr.span,\n+                    &format!(\n+                        \"did you mean `{} = {} {} {}` or `{}`? Consider replacing it with\",\n+                        snip_a,\n+                        snip_a,\n+                        op.as_str(),\n+                        snip_r,\n+                        long\n+                    ),\n+                    format!(\"{} {}= {}\", snip_a, op.as_str(), snip_r),\n+                    Applicability::MaybeIncorrect,\n+                );\n+                diag.span_suggestion(\n+                    expr.span,\n+                    \"or\",\n+                    long,\n+                    Applicability::MaybeIncorrect, // snippet\n+                );\n+            }\n+        },\n+    );\n+}\n+\n+#[must_use]\n+fn is_commutative(op: hir::BinOpKind) -> bool {\n+    use rustc_hir::BinOpKind::{\n+        Add, And, BitAnd, BitOr, BitXor, Div, Eq, Ge, Gt, Le, Lt, Mul, Ne, Or, Rem, Shl, Shr, Sub,\n+    };\n+    match op {\n+        Add | Mul | And | Or | BitXor | BitAnd | BitOr | Eq | Ne => true,\n+        Sub | Div | Rem | Shl | Shr | Lt | Le | Ge | Gt => false,\n+    }\n+}"}, {"sha": "35fe405bcf14fa052fcb77949ce4f687b4d6ec13", "filename": "clippy_lints/src/operators/mod.rs", "status": "added", "additions": 849, "deletions": 0, "changes": 849, "blob_url": "https://github.com/rust-lang/rust/blob/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Foperators%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Foperators%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Fmod.rs?ref=23c6765276c968bf0fe4ee01f619f357b78390ca", "patch": "@@ -0,0 +1,849 @@\n+use rustc_hir::{Body, Expr, ExprKind, UnOp};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+\n+mod absurd_extreme_comparisons;\n+mod assign_op_pattern;\n+mod bit_mask;\n+mod cmp_nan;\n+mod cmp_owned;\n+mod double_comparison;\n+mod duration_subsec;\n+mod eq_op;\n+mod erasing_op;\n+mod float_cmp;\n+mod float_equality_without_abs;\n+mod identity_op;\n+mod integer_division;\n+mod misrefactored_assign_op;\n+mod modulo_arithmetic;\n+mod modulo_one;\n+mod needless_bitwise_bool;\n+mod numeric_arithmetic;\n+mod op_ref;\n+mod ptr_eq;\n+mod self_assignment;\n+mod verbose_bit_mask;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for comparisons where one side of the relation is\n+    /// either the minimum or maximum value for its type and warns if it involves a\n+    /// case that is always true or always false. Only integer and boolean types are\n+    /// checked.\n+    ///\n+    /// ### Why is this bad?\n+    /// An expression like `min <= x` may misleadingly imply\n+    /// that it is possible for `x` to be less than the minimum. Expressions like\n+    /// `max < x` are probably mistakes.\n+    ///\n+    /// ### Known problems\n+    /// For `usize` the size of the current compile target will\n+    /// be assumed (e.g., 64 bits on 64 bit systems). This means code that uses such\n+    /// a comparison to detect target pointer width will trigger this lint. One can\n+    /// use `mem::sizeof` and compare its value or conditional compilation\n+    /// attributes\n+    /// like `#[cfg(target_pointer_width = \"64\")] ..` instead.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let vec: Vec<isize> = Vec::new();\n+    /// if vec.len() <= 0 {}\n+    /// if 100 > i32::MAX {}\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub ABSURD_EXTREME_COMPARISONS,\n+    correctness,\n+    \"a comparison with a maximum or minimum value that is always true or false\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for integer arithmetic operations which could overflow or panic.\n+    ///\n+    /// Specifically, checks for any operators (`+`, `-`, `*`, `<<`, etc) which are capable\n+    /// of overflowing according to the [Rust\n+    /// Reference](https://doc.rust-lang.org/reference/expressions/operator-expr.html#overflow),\n+    /// or which can panic (`/`, `%`). No bounds analysis or sophisticated reasoning is\n+    /// attempted.\n+    ///\n+    /// ### Why is this bad?\n+    /// Integer overflow will trigger a panic in debug builds or will wrap in\n+    /// release mode. Division by zero will cause a panic in either mode. In some applications one\n+    /// wants explicitly checked, wrapping or saturating arithmetic.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # let a = 0;\n+    /// a + 1;\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub INTEGER_ARITHMETIC,\n+    restriction,\n+    \"any integer arithmetic expression which could overflow or panic\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for float arithmetic.\n+    ///\n+    /// ### Why is this bad?\n+    /// For some embedded systems or kernel development, it\n+    /// can be useful to rule out floating-point numbers.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # let a = 0.0;\n+    /// a + 1.0;\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub FLOAT_ARITHMETIC,\n+    restriction,\n+    \"any floating-point arithmetic statement\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for `a = a op b` or `a = b commutative_op a`\n+    /// patterns.\n+    ///\n+    /// ### Why is this bad?\n+    /// These can be written as the shorter `a op= b`.\n+    ///\n+    /// ### Known problems\n+    /// While forbidden by the spec, `OpAssign` traits may have\n+    /// implementations that differ from the regular `Op` impl.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let mut a = 5;\n+    /// let b = 0;\n+    /// // ...\n+    ///\n+    /// a = a + b;\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust\n+    /// let mut a = 5;\n+    /// let b = 0;\n+    /// // ...\n+    ///\n+    /// a += b;\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub ASSIGN_OP_PATTERN,\n+    style,\n+    \"assigning the result of an operation on a variable to that same variable\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for `a op= a op b` or `a op= b op a` patterns.\n+    ///\n+    /// ### Why is this bad?\n+    /// Most likely these are bugs where one meant to write `a\n+    /// op= b`.\n+    ///\n+    /// ### Known problems\n+    /// Clippy cannot know for sure if `a op= a op b` should have\n+    /// been `a = a op a op b` or `a = a op b`/`a op= b`. Therefore, it suggests both.\n+    /// If `a op= a op b` is really the correct behavior it should be\n+    /// written as `a = a op a op b` as it's less confusing.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let mut a = 5;\n+    /// let b = 2;\n+    /// // ...\n+    /// a += a + b;\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub MISREFACTORED_ASSIGN_OP,\n+    suspicious,\n+    \"having a variable on both sides of an assign op\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for incompatible bit masks in comparisons.\n+    ///\n+    /// The formula for detecting if an expression of the type `_ <bit_op> m\n+    /// <cmp_op> c` (where `<bit_op>` is one of {`&`, `|`} and `<cmp_op>` is one of\n+    /// {`!=`, `>=`, `>`, `!=`, `>=`, `>`}) can be determined from the following\n+    /// table:\n+    ///\n+    /// |Comparison  |Bit Op|Example      |is always|Formula               |\n+    /// |------------|------|-------------|---------|----------------------|\n+    /// |`==` or `!=`| `&`  |`x & 2 == 3` |`false`  |`c & m != c`          |\n+    /// |`<`  or `>=`| `&`  |`x & 2 < 3`  |`true`   |`m < c`               |\n+    /// |`>`  or `<=`| `&`  |`x & 1 > 1`  |`false`  |`m <= c`              |\n+    /// |`==` or `!=`| `\\|` |`x \\| 1 == 0`|`false`  |`c \\| m != c`         |\n+    /// |`<`  or `>=`| `\\|` |`x \\| 1 < 1` |`false`  |`m >= c`              |\n+    /// |`<=` or `>` | `\\|` |`x \\| 1 > 0` |`true`   |`m > c`               |\n+    ///\n+    /// ### Why is this bad?\n+    /// If the bits that the comparison cares about are always\n+    /// set to zero or one by the bit mask, the comparison is constant `true` or\n+    /// `false` (depending on mask, compared value, and operators).\n+    ///\n+    /// So the code is actively misleading, and the only reason someone would write\n+    /// this intentionally is to win an underhanded Rust contest or create a\n+    /// test-case for this lint.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # let x = 1;\n+    /// if (x & 1 == 2) { }\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub BAD_BIT_MASK,\n+    correctness,\n+    \"expressions of the form `_ & mask == select` that will only ever return `true` or `false`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for bit masks in comparisons which can be removed\n+    /// without changing the outcome. The basic structure can be seen in the\n+    /// following table:\n+    ///\n+    /// |Comparison| Bit Op   |Example     |equals |\n+    /// |----------|----------|------------|-------|\n+    /// |`>` / `<=`|`\\|` / `^`|`x \\| 2 > 3`|`x > 3`|\n+    /// |`<` / `>=`|`\\|` / `^`|`x ^ 1 < 4` |`x < 4`|\n+    ///\n+    /// ### Why is this bad?\n+    /// Not equally evil as [`bad_bit_mask`](#bad_bit_mask),\n+    /// but still a bit misleading, because the bit mask is ineffective.\n+    ///\n+    /// ### Known problems\n+    /// False negatives: This lint will only match instances\n+    /// where we have figured out the math (which is for a power-of-two compared\n+    /// value). This means things like `x | 1 >= 7` (which would be better written\n+    /// as `x >= 6`) will not be reported (but bit masks like this are fairly\n+    /// uncommon).\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # let x = 1;\n+    /// if (x | 1 > 3) {  }\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub INEFFECTIVE_BIT_MASK,\n+    correctness,\n+    \"expressions where a bit mask will be rendered useless by a comparison, e.g., `(x | 1) > 2`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for bit masks that can be replaced by a call\n+    /// to `trailing_zeros`\n+    ///\n+    /// ### Why is this bad?\n+    /// `x.trailing_zeros() > 4` is much clearer than `x & 15\n+    /// == 0`\n+    ///\n+    /// ### Known problems\n+    /// llvm generates better code for `x & 15 == 0` on x86\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # let x = 1;\n+    /// if x & 0b1111 == 0 { }\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub VERBOSE_BIT_MASK,\n+    pedantic,\n+    \"expressions where a bit mask is less readable than the corresponding method call\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for double comparisons that could be simplified to a single expression.\n+    ///\n+    ///\n+    /// ### Why is this bad?\n+    /// Readability.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # let x = 1;\n+    /// # let y = 2;\n+    /// if x == y || x < y {}\n+    /// ```\n+    ///\n+    /// Use instead:\n+    ///\n+    /// ```rust\n+    /// # let x = 1;\n+    /// # let y = 2;\n+    /// if x <= y {}\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub DOUBLE_COMPARISONS,\n+    complexity,\n+    \"unnecessary double comparisons that can be simplified\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for calculation of subsecond microseconds or milliseconds\n+    /// from other `Duration` methods.\n+    ///\n+    /// ### Why is this bad?\n+    /// It's more concise to call `Duration::subsec_micros()` or\n+    /// `Duration::subsec_millis()` than to calculate them.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # use std::time::Duration;\n+    /// # let duration = Duration::new(5, 0);\n+    /// let micros = duration.subsec_nanos() / 1_000;\n+    /// let millis = duration.subsec_nanos() / 1_000_000;\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust\n+    /// # use std::time::Duration;\n+    /// # let duration = Duration::new(5, 0);\n+    /// let micros = duration.subsec_micros();\n+    /// let millis = duration.subsec_millis();\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub DURATION_SUBSEC,\n+    complexity,\n+    \"checks for calculation of subsecond microseconds or milliseconds\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for equal operands to comparison, logical and\n+    /// bitwise, difference and division binary operators (`==`, `>`, etc., `&&`,\n+    /// `||`, `&`, `|`, `^`, `-` and `/`).\n+    ///\n+    /// ### Why is this bad?\n+    /// This is usually just a typo or a copy and paste error.\n+    ///\n+    /// ### Known problems\n+    /// False negatives: We had some false positives regarding\n+    /// calls (notably [racer](https://github.com/phildawes/racer) had one instance\n+    /// of `x.pop() && x.pop()`), so we removed matching any function or method\n+    /// calls. We may introduce a list of known pure functions in the future.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # let x = 1;\n+    /// if x + 1 == x + 1 {}\n+    ///\n+    /// // or\n+    ///\n+    /// # let a = 3;\n+    /// # let b = 4;\n+    /// assert_eq!(a, a);\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub EQ_OP,\n+    correctness,\n+    \"equal operands on both sides of a comparison or bitwise combination (e.g., `x == x`)\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for arguments to `==` which have their address\n+    /// taken to satisfy a bound\n+    /// and suggests to dereference the other argument instead\n+    ///\n+    /// ### Why is this bad?\n+    /// It is more idiomatic to dereference the other argument.\n+    ///\n+    /// ### Example\n+    /// ```rust,ignore\n+    /// &x == y\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust,ignore\n+    /// x == *y\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub OP_REF,\n+    style,\n+    \"taking a reference to satisfy the type constraints on `==`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for erasing operations, e.g., `x * 0`.\n+    ///\n+    /// ### Why is this bad?\n+    /// The whole expression can be replaced by zero.\n+    /// This is most likely not the intended outcome and should probably be\n+    /// corrected\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let x = 1;\n+    /// 0 / x;\n+    /// 0 * x;\n+    /// x & 0;\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub ERASING_OP,\n+    correctness,\n+    \"using erasing operations, e.g., `x * 0` or `y & 0`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for statements of the form `(a - b) < f32::EPSILON` or\n+    /// `(a - b) < f64::EPSILON`. Notes the missing `.abs()`.\n+    ///\n+    /// ### Why is this bad?\n+    /// The code without `.abs()` is more likely to have a bug.\n+    ///\n+    /// ### Known problems\n+    /// If the user can ensure that b is larger than a, the `.abs()` is\n+    /// technically unnecessary. However, it will make the code more robust and doesn't have any\n+    /// large performance implications. If the abs call was deliberately left out for performance\n+    /// reasons, it is probably better to state this explicitly in the code, which then can be done\n+    /// with an allow.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// pub fn is_roughly_equal(a: f32, b: f32) -> bool {\n+    ///     (a - b) < f32::EPSILON\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// pub fn is_roughly_equal(a: f32, b: f32) -> bool {\n+    ///     (a - b).abs() < f32::EPSILON\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.48.0\"]\n+    pub FLOAT_EQUALITY_WITHOUT_ABS,\n+    suspicious,\n+    \"float equality check without `.abs()`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for identity operations, e.g., `x + 0`.\n+    ///\n+    /// ### Why is this bad?\n+    /// This code can be removed without changing the\n+    /// meaning. So it just obscures what's going on. Delete it mercilessly.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # let x = 1;\n+    /// x / 1 + 0 * 1 - 0 | 0;\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub IDENTITY_OP,\n+    complexity,\n+    \"using identity operations, e.g., `x + 0` or `y / 1`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for division of integers\n+    ///\n+    /// ### Why is this bad?\n+    /// When outside of some very specific algorithms,\n+    /// integer division is very often a mistake because it discards the\n+    /// remainder.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let x = 3 / 2;\n+    /// println!(\"{}\", x);\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust\n+    /// let x = 3f32 / 2f32;\n+    /// println!(\"{}\", x);\n+    /// ```\n+    #[clippy::version = \"1.37.0\"]\n+    pub INTEGER_DIVISION,\n+    restriction,\n+    \"integer division may cause loss of precision\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for comparisons to NaN.\n+    ///\n+    /// ### Why is this bad?\n+    /// NaN does not compare meaningfully to anything \u2013 not\n+    /// even itself \u2013 so those comparisons are simply wrong.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # let x = 1.0;\n+    /// if x == f32::NAN { }\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust\n+    /// # let x = 1.0f32;\n+    /// if x.is_nan() { }\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub CMP_NAN,\n+    correctness,\n+    \"comparisons to `NAN`, which will always return false, probably not intended\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for conversions to owned values just for the sake\n+    /// of a comparison.\n+    ///\n+    /// ### Why is this bad?\n+    /// The comparison can operate on a reference, so creating\n+    /// an owned value effectively throws it away directly afterwards, which is\n+    /// needlessly consuming code and heap space.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # let x = \"foo\";\n+    /// # let y = String::from(\"foo\");\n+    /// if x.to_owned() == y {}\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust\n+    /// # let x = \"foo\";\n+    /// # let y = String::from(\"foo\");\n+    /// if x == y {}\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub CMP_OWNED,\n+    perf,\n+    \"creating owned instances for comparing with others, e.g., `x == \\\"foo\\\".to_string()`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for (in-)equality comparisons on floating-point\n+    /// values (apart from zero), except in functions called `*eq*` (which probably\n+    /// implement equality for a type involving floats).\n+    ///\n+    /// ### Why is this bad?\n+    /// Floating point calculations are usually imprecise, so\n+    /// asking if two values are *exactly* equal is asking for trouble. For a good\n+    /// guide on what to do, see [the floating point\n+    /// guide](http://www.floating-point-gui.de/errors/comparison).\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let x = 1.2331f64;\n+    /// let y = 1.2332f64;\n+    ///\n+    /// if y == 1.23f64 { }\n+    /// if y != x {} // where both are floats\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust\n+    /// # let x = 1.2331f64;\n+    /// # let y = 1.2332f64;\n+    /// let error_margin = f64::EPSILON; // Use an epsilon for comparison\n+    /// // Or, if Rust <= 1.42, use `std::f64::EPSILON` constant instead.\n+    /// // let error_margin = std::f64::EPSILON;\n+    /// if (y - 1.23f64).abs() < error_margin { }\n+    /// if (y - x).abs() > error_margin { }\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub FLOAT_CMP,\n+    pedantic,\n+    \"using `==` or `!=` on float values instead of comparing difference with an epsilon\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for (in-)equality comparisons on floating-point\n+    /// value and constant, except in functions called `*eq*` (which probably\n+    /// implement equality for a type involving floats).\n+    ///\n+    /// ### Why is this bad?\n+    /// Floating point calculations are usually imprecise, so\n+    /// asking if two values are *exactly* equal is asking for trouble. For a good\n+    /// guide on what to do, see [the floating point\n+    /// guide](http://www.floating-point-gui.de/errors/comparison).\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let x: f64 = 1.0;\n+    /// const ONE: f64 = 1.00;\n+    ///\n+    /// if x == ONE { } // where both are floats\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust\n+    /// # let x: f64 = 1.0;\n+    /// # const ONE: f64 = 1.00;\n+    /// let error_margin = f64::EPSILON; // Use an epsilon for comparison\n+    /// // Or, if Rust <= 1.42, use `std::f64::EPSILON` constant instead.\n+    /// // let error_margin = std::f64::EPSILON;\n+    /// if (x - ONE).abs() < error_margin { }\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub FLOAT_CMP_CONST,\n+    restriction,\n+    \"using `==` or `!=` on float constants instead of comparing difference with an epsilon\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for getting the remainder of a division by one or minus\n+    /// one.\n+    ///\n+    /// ### Why is this bad?\n+    /// The result for a divisor of one can only ever be zero; for\n+    /// minus one it can cause panic/overflow (if the left operand is the minimal value of\n+    /// the respective integer type) or results in zero. No one will write such code\n+    /// deliberately, unless trying to win an Underhanded Rust Contest. Even for that\n+    /// contest, it's probably a bad idea. Use something more underhanded.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # let x = 1;\n+    /// let a = x % 1;\n+    /// let a = x % -1;\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub MODULO_ONE,\n+    correctness,\n+    \"taking a number modulo +/-1, which can either panic/overflow or always returns 0\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for modulo arithmetic.\n+    ///\n+    /// ### Why is this bad?\n+    /// The results of modulo (%) operation might differ\n+    /// depending on the language, when negative numbers are involved.\n+    /// If you interop with different languages it might be beneficial\n+    /// to double check all places that use modulo arithmetic.\n+    ///\n+    /// For example, in Rust `17 % -3 = 2`, but in Python `17 % -3 = -1`.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let x = -17 % 3;\n+    /// ```\n+    #[clippy::version = \"1.42.0\"]\n+    pub MODULO_ARITHMETIC,\n+    restriction,\n+    \"any modulo arithmetic statement\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for uses of bitwise and/or operators between booleans, where performance may be improved by using\n+    /// a lazy and.\n+    ///\n+    /// ### Why is this bad?\n+    /// The bitwise operators do not support short-circuiting, so it may hinder code performance.\n+    /// Additionally, boolean logic \"masked\" as bitwise logic is not caught by lints like `unnecessary_fold`\n+    ///\n+    /// ### Known problems\n+    /// This lint evaluates only when the right side is determined to have no side effects. At this time, that\n+    /// determination is quite conservative.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let (x,y) = (true, false);\n+    /// if x & !y {} // where both x and y are booleans\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let (x,y) = (true, false);\n+    /// if x && !y {}\n+    /// ```\n+    #[clippy::version = \"1.54.0\"]\n+    pub NEEDLESS_BITWISE_BOOL,\n+    pedantic,\n+    \"Boolean expressions that use bitwise rather than lazy operators\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Use `std::ptr::eq` when applicable\n+    ///\n+    /// ### Why is this bad?\n+    /// `ptr::eq` can be used to compare `&T` references\n+    /// (which coerce to `*const T` implicitly) by their address rather than\n+    /// comparing the values they point to.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let a = &[1, 2, 3];\n+    /// let b = &[1, 2, 3];\n+    ///\n+    /// assert!(a as *const _ as usize == b as *const _ as usize);\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let a = &[1, 2, 3];\n+    /// let b = &[1, 2, 3];\n+    ///\n+    /// assert!(std::ptr::eq(a, b));\n+    /// ```\n+    #[clippy::version = \"1.49.0\"]\n+    pub PTR_EQ,\n+    style,\n+    \"use `std::ptr::eq` when comparing raw pointers\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for explicit self-assignments.\n+    ///\n+    /// ### Why is this bad?\n+    /// Self-assignments are redundant and unlikely to be\n+    /// intentional.\n+    ///\n+    /// ### Known problems\n+    /// If expression contains any deref coercions or\n+    /// indexing operations they are assumed not to have any side effects.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// struct Event {\n+    ///     x: i32,\n+    /// }\n+    ///\n+    /// fn copy_position(a: &mut Event, b: &Event) {\n+    ///     a.x = a.x;\n+    /// }\n+    /// ```\n+    ///\n+    /// Should be:\n+    /// ```rust\n+    /// struct Event {\n+    ///     x: i32,\n+    /// }\n+    ///\n+    /// fn copy_position(a: &mut Event, b: &Event) {\n+    ///     a.x = b.x;\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.48.0\"]\n+    pub SELF_ASSIGNMENT,\n+    correctness,\n+    \"explicit self-assignment\"\n+}\n+\n+pub struct Operators {\n+    arithmetic_context: numeric_arithmetic::Context,\n+    verbose_bit_mask_threshold: u64,\n+}\n+impl_lint_pass!(Operators => [\n+    ABSURD_EXTREME_COMPARISONS,\n+    INTEGER_ARITHMETIC,\n+    FLOAT_ARITHMETIC,\n+    ASSIGN_OP_PATTERN,\n+    MISREFACTORED_ASSIGN_OP,\n+    BAD_BIT_MASK,\n+    INEFFECTIVE_BIT_MASK,\n+    VERBOSE_BIT_MASK,\n+    DOUBLE_COMPARISONS,\n+    DURATION_SUBSEC,\n+    EQ_OP,\n+    OP_REF,\n+    ERASING_OP,\n+    FLOAT_EQUALITY_WITHOUT_ABS,\n+    IDENTITY_OP,\n+    INTEGER_DIVISION,\n+    CMP_NAN,\n+    CMP_OWNED,\n+    FLOAT_CMP,\n+    FLOAT_CMP_CONST,\n+    MODULO_ONE,\n+    MODULO_ARITHMETIC,\n+    NEEDLESS_BITWISE_BOOL,\n+    PTR_EQ,\n+    SELF_ASSIGNMENT,\n+]);\n+impl Operators {\n+    pub fn new(verbose_bit_mask_threshold: u64) -> Self {\n+        Self {\n+            arithmetic_context: numeric_arithmetic::Context::default(),\n+            verbose_bit_mask_threshold,\n+        }\n+    }\n+}\n+impl<'tcx> LateLintPass<'tcx> for Operators {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n+        eq_op::check_assert(cx, e);\n+        match e.kind {\n+            ExprKind::Binary(op, lhs, rhs) => {\n+                if !e.span.from_expansion() {\n+                    absurd_extreme_comparisons::check(cx, e, op.node, lhs, rhs);\n+                    if !(macro_with_not_op(lhs) || macro_with_not_op(rhs)) {\n+                        eq_op::check(cx, e, op.node, lhs, rhs);\n+                        op_ref::check(cx, e, op.node, lhs, rhs);\n+                    }\n+                    erasing_op::check(cx, e, op.node, lhs, rhs);\n+                    identity_op::check(cx, e, op.node, lhs, rhs);\n+                    needless_bitwise_bool::check(cx, e, op.node, lhs, rhs);\n+                    ptr_eq::check(cx, e, op.node, lhs, rhs);\n+                }\n+                self.arithmetic_context.check_binary(cx, e, op.node, lhs, rhs);\n+                bit_mask::check(cx, e, op.node, lhs, rhs);\n+                verbose_bit_mask::check(cx, e, op.node, lhs, rhs, self.verbose_bit_mask_threshold);\n+                double_comparison::check(cx, op.node, lhs, rhs, e.span);\n+                duration_subsec::check(cx, e, op.node, lhs, rhs);\n+                float_equality_without_abs::check(cx, e, op.node, lhs, rhs);\n+                integer_division::check(cx, e, op.node, lhs, rhs);\n+                cmp_nan::check(cx, e, op.node, lhs, rhs);\n+                cmp_owned::check(cx, op.node, lhs, rhs);\n+                float_cmp::check(cx, e, op.node, lhs, rhs);\n+                modulo_one::check(cx, e, op.node, rhs);\n+                modulo_arithmetic::check(cx, e, op.node, lhs, rhs);\n+            },\n+            ExprKind::AssignOp(op, lhs, rhs) => {\n+                self.arithmetic_context.check_binary(cx, e, op.node, lhs, rhs);\n+                misrefactored_assign_op::check(cx, e, op.node, lhs, rhs);\n+                modulo_arithmetic::check(cx, e, op.node, lhs, rhs);\n+            },\n+            ExprKind::Assign(lhs, rhs, _) => {\n+                assign_op_pattern::check(cx, e, lhs, rhs);\n+                self_assignment::check(cx, e, lhs, rhs);\n+            },\n+            ExprKind::Unary(op, arg) => {\n+                if op == UnOp::Neg {\n+                    self.arithmetic_context.check_negate(cx, e, arg);\n+                }\n+            },\n+            _ => (),\n+        }\n+    }\n+\n+    fn check_expr_post(&mut self, _: &LateContext<'_>, e: &Expr<'_>) {\n+        self.arithmetic_context.expr_post(e.hir_id);\n+    }\n+\n+    fn check_body(&mut self, cx: &LateContext<'tcx>, b: &'tcx Body<'_>) {\n+        self.arithmetic_context.enter_body(cx, b);\n+    }\n+\n+    fn check_body_post(&mut self, cx: &LateContext<'tcx>, b: &'tcx Body<'_>) {\n+        self.arithmetic_context.body_post(cx, b);\n+    }\n+}\n+\n+fn macro_with_not_op(e: &Expr<'_>) -> bool {\n+    if let ExprKind::Unary(_, e) = e.kind {\n+        e.span.from_expansion()\n+    } else {\n+        false\n+    }\n+}"}, {"sha": "af4e74947f41d60ceeaaeb6442852e08e8d36a1f", "filename": "clippy_lints/src/operators/modulo_arithmetic.rs", "status": "renamed", "additions": 25, "deletions": 49, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Foperators%2Fmodulo_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Foperators%2Fmodulo_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Fmodulo_arithmetic.rs?ref=23c6765276c968bf0fe4ee01f619f357b78390ca", "patch": "@@ -2,35 +2,35 @@ use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::sext;\n use if_chain::if_chain;\n-use rustc_hir::{BinOpKind, Expr, ExprKind};\n-use rustc_lint::{LateContext, LateLintPass};\n+use rustc_hir::{BinOpKind, Expr};\n+use rustc_lint::LateContext;\n use rustc_middle::ty::{self, Ty};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n use std::fmt::Display;\n \n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for modulo arithmetic.\n-    ///\n-    /// ### Why is this bad?\n-    /// The results of modulo (%) operation might differ\n-    /// depending on the language, when negative numbers are involved.\n-    /// If you interop with different languages it might be beneficial\n-    /// to double check all places that use modulo arithmetic.\n-    ///\n-    /// For example, in Rust `17 % -3 = 2`, but in Python `17 % -3 = -1`.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// let x = -17 % 3;\n-    /// ```\n-    #[clippy::version = \"1.42.0\"]\n-    pub MODULO_ARITHMETIC,\n-    restriction,\n-    \"any modulo arithmetic statement\"\n-}\n+use super::MODULO_ARITHMETIC;\n \n-declare_lint_pass!(ModuloArithmetic => [MODULO_ARITHMETIC]);\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    op: BinOpKind,\n+    lhs: &'tcx Expr<'_>,\n+    rhs: &'tcx Expr<'_>,\n+) {\n+    if op == BinOpKind::Rem {\n+        let lhs_operand = analyze_operand(lhs, cx, e);\n+        let rhs_operand = analyze_operand(rhs, cx, e);\n+        if_chain! {\n+            if let Some(lhs_operand) = lhs_operand;\n+            if let Some(rhs_operand) = rhs_operand;\n+            then {\n+                check_const_operands(cx, e, &lhs_operand, &rhs_operand);\n+            }\n+            else {\n+                check_non_const_operands(cx, e, lhs);\n+            }\n+        }\n+    };\n+}\n \n struct OperandInfo {\n     string_representation: Option<String>,\n@@ -124,27 +124,3 @@ fn check_non_const_operands<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>,\n         );\n     }\n }\n-\n-impl<'tcx> LateLintPass<'tcx> for ModuloArithmetic {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        match &expr.kind {\n-            ExprKind::Binary(op, lhs, rhs) | ExprKind::AssignOp(op, lhs, rhs) => {\n-                if op.node == BinOpKind::Rem {\n-                    let lhs_operand = analyze_operand(lhs, cx, expr);\n-                    let rhs_operand = analyze_operand(rhs, cx, expr);\n-                    if_chain! {\n-                        if let Some(lhs_operand) = lhs_operand;\n-                        if let Some(rhs_operand) = rhs_operand;\n-                        then {\n-                            check_const_operands(cx, expr, &lhs_operand, &rhs_operand);\n-                        }\n-                        else {\n-                            check_non_const_operands(cx, expr, lhs);\n-                        }\n-                    }\n-                };\n-            },\n-            _ => {},\n-        }\n-    }\n-}", "previous_filename": "clippy_lints/src/modulo_arithmetic.rs"}, {"sha": "54eea14833ffe065c85c1584c516eeb39819afd9", "filename": "clippy_lints/src/operators/modulo_one.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Foperators%2Fmodulo_one.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Foperators%2Fmodulo_one.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Fmodulo_one.rs?ref=23c6765276c968bf0fe4ee01f619f357b78390ca", "patch": "@@ -0,0 +1,26 @@\n+use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::{is_integer_const, unsext};\n+use rustc_hir::{BinOpKind, Expr};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+\n+use super::MODULO_ONE;\n+\n+pub(crate) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, op: BinOpKind, right: &Expr<'_>) {\n+    if op == BinOpKind::Rem {\n+        if is_integer_const(cx, right, 1) {\n+            span_lint(cx, MODULO_ONE, expr.span, \"any number modulo 1 will be 0\");\n+        }\n+\n+        if let ty::Int(ity) = cx.typeck_results().expr_ty(right).kind() {\n+            if is_integer_const(cx, right, unsext(cx.tcx, -1, *ity)) {\n+                span_lint(\n+                    cx,\n+                    MODULO_ONE,\n+                    expr.span,\n+                    \"any number modulo -1 will panic/overflow or result in 0\",\n+                );\n+            }\n+        };\n+    }\n+}"}, {"sha": "e902235a014e865777976dd26029cf4d84ea7da3", "filename": "clippy_lints/src/operators/needless_bitwise_bool.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Foperators%2Fneedless_bitwise_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Foperators%2Fneedless_bitwise_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Fneedless_bitwise_bool.rs?ref=23c6765276c968bf0fe4ee01f619f357b78390ca", "patch": "@@ -0,0 +1,36 @@\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::source::snippet_opt;\n+use rustc_errors::Applicability;\n+use rustc_hir::{BinOpKind, Expr, ExprKind};\n+use rustc_lint::LateContext;\n+\n+use super::NEEDLESS_BITWISE_BOOL;\n+\n+pub(super) fn check(cx: &LateContext<'_>, e: &Expr<'_>, op: BinOpKind, lhs: &Expr<'_>, rhs: &Expr<'_>) {\n+    let op_str = match op {\n+        BinOpKind::BitAnd => \"&&\",\n+        BinOpKind::BitOr => \"||\",\n+        _ => return,\n+    };\n+    if matches!(\n+        rhs.kind,\n+        ExprKind::Call(..) | ExprKind::MethodCall(..) | ExprKind::Binary(..) | ExprKind::Unary(..)\n+    ) && cx.typeck_results().expr_ty(e).is_bool()\n+        && !rhs.can_have_side_effects()\n+    {\n+        span_lint_and_then(\n+            cx,\n+            NEEDLESS_BITWISE_BOOL,\n+            e.span,\n+            \"use of bitwise operator instead of lazy operator between booleans\",\n+            |diag| {\n+                if let Some(lhs_snip) = snippet_opt(cx, lhs.span)\n+                    && let Some(rhs_snip) = snippet_opt(cx, rhs.span)\n+                {\n+                    let sugg = format!(\"{} {} {}\", lhs_snip, op_str, rhs_snip);\n+                    diag.span_suggestion(e.span, \"try\", sugg, Applicability::MachineApplicable);\n+                }\n+            },\n+        );\n+    }\n+}"}, {"sha": "82f454d02f713ad6bf90522c4ba779126294f5bc", "filename": "clippy_lints/src/operators/numeric_arithmetic.rs", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Foperators%2Fnumeric_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Foperators%2Fnumeric_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Fnumeric_arithmetic.rs?ref=23c6765276c968bf0fe4ee01f619f357b78390ca", "patch": "@@ -0,0 +1,127 @@\n+use clippy_utils::consts::constant_simple;\n+use clippy_utils::diagnostics::span_lint;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_span::source_map::Span;\n+\n+use super::{FLOAT_ARITHMETIC, INTEGER_ARITHMETIC};\n+\n+#[derive(Default)]\n+pub struct Context {\n+    expr_id: Option<hir::HirId>,\n+    /// This field is used to check whether expressions are constants, such as in enum discriminants\n+    /// and consts\n+    const_span: Option<Span>,\n+}\n+impl Context {\n+    fn skip_expr(&mut self, e: &hir::Expr<'_>) -> bool {\n+        self.expr_id.is_some() || self.const_span.map_or(false, |span| span.contains(e.span))\n+    }\n+\n+    pub fn check_binary<'tcx>(\n+        &mut self,\n+        cx: &LateContext<'tcx>,\n+        expr: &'tcx hir::Expr<'_>,\n+        op: hir::BinOpKind,\n+        l: &'tcx hir::Expr<'_>,\n+        r: &'tcx hir::Expr<'_>,\n+    ) {\n+        if self.skip_expr(expr) {\n+            return;\n+        }\n+        match op {\n+            hir::BinOpKind::And\n+            | hir::BinOpKind::Or\n+            | hir::BinOpKind::BitAnd\n+            | hir::BinOpKind::BitOr\n+            | hir::BinOpKind::BitXor\n+            | hir::BinOpKind::Eq\n+            | hir::BinOpKind::Lt\n+            | hir::BinOpKind::Le\n+            | hir::BinOpKind::Ne\n+            | hir::BinOpKind::Ge\n+            | hir::BinOpKind::Gt => return,\n+            _ => (),\n+        }\n+\n+        let (l_ty, r_ty) = (cx.typeck_results().expr_ty(l), cx.typeck_results().expr_ty(r));\n+        if l_ty.peel_refs().is_integral() && r_ty.peel_refs().is_integral() {\n+            match op {\n+                hir::BinOpKind::Div | hir::BinOpKind::Rem => match &r.kind {\n+                    hir::ExprKind::Lit(_lit) => (),\n+                    hir::ExprKind::Unary(hir::UnOp::Neg, expr) => {\n+                        if let hir::ExprKind::Lit(lit) = &expr.kind {\n+                            if let rustc_ast::ast::LitKind::Int(1, _) = lit.node {\n+                                span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");\n+                                self.expr_id = Some(expr.hir_id);\n+                            }\n+                        }\n+                    },\n+                    _ => {\n+                        span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");\n+                        self.expr_id = Some(expr.hir_id);\n+                    },\n+                },\n+                _ => {\n+                    span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");\n+                    self.expr_id = Some(expr.hir_id);\n+                },\n+            }\n+        } else if r_ty.peel_refs().is_floating_point() && r_ty.peel_refs().is_floating_point() {\n+            span_lint(cx, FLOAT_ARITHMETIC, expr.span, \"floating-point arithmetic detected\");\n+            self.expr_id = Some(expr.hir_id);\n+        }\n+    }\n+\n+    pub fn check_negate<'tcx>(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, arg: &'tcx hir::Expr<'_>) {\n+        if self.skip_expr(expr) {\n+            return;\n+        }\n+        let ty = cx.typeck_results().expr_ty(arg);\n+        if constant_simple(cx, cx.typeck_results(), expr).is_none() {\n+            if ty.is_integral() {\n+                span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");\n+                self.expr_id = Some(expr.hir_id);\n+            } else if ty.is_floating_point() {\n+                span_lint(cx, FLOAT_ARITHMETIC, expr.span, \"floating-point arithmetic detected\");\n+                self.expr_id = Some(expr.hir_id);\n+            }\n+        }\n+    }\n+\n+    pub fn expr_post(&mut self, id: hir::HirId) {\n+        if Some(id) == self.expr_id {\n+            self.expr_id = None;\n+        }\n+    }\n+\n+    pub fn enter_body(&mut self, cx: &LateContext<'_>, body: &hir::Body<'_>) {\n+        let body_owner = cx.tcx.hir().body_owner_def_id(body.id());\n+\n+        match cx.tcx.hir().body_owner_kind(body_owner) {\n+            hir::BodyOwnerKind::Static(_) | hir::BodyOwnerKind::Const => {\n+                let body_span = cx.tcx.def_span(body_owner);\n+\n+                if let Some(span) = self.const_span {\n+                    if span.contains(body_span) {\n+                        return;\n+                    }\n+                }\n+                self.const_span = Some(body_span);\n+            },\n+            hir::BodyOwnerKind::Fn | hir::BodyOwnerKind::Closure => (),\n+        }\n+    }\n+\n+    pub fn body_post(&mut self, cx: &LateContext<'_>, body: &hir::Body<'_>) {\n+        let body_owner = cx.tcx.hir().body_owner(body.id());\n+        let body_span = cx.tcx.hir().span(body_owner);\n+\n+        if let Some(span) = self.const_span {\n+            if span.contains(body_span) {\n+                return;\n+            }\n+        }\n+        self.const_span = None;\n+    }\n+}"}, {"sha": "1805672e372544d8b34e64548fd7118a67e3c8b9", "filename": "clippy_lints/src/operators/op_ref.rs", "status": "added", "additions": 218, "deletions": 0, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Foperators%2Fop_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Foperators%2Fop_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Fop_ref.rs?ref=23c6765276c968bf0fe4ee01f619f357b78390ca", "patch": "@@ -0,0 +1,218 @@\n+use clippy_utils::diagnostics::{multispan_sugg, span_lint_and_then};\n+use clippy_utils::get_enclosing_block;\n+use clippy_utils::source::snippet;\n+use clippy_utils::ty::{implements_trait, is_copy};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{def::Res, def_id::DefId, BinOpKind, BorrowKind, Expr, ExprKind, GenericArg, ItemKind, QPath, TyKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty};\n+\n+use super::OP_REF;\n+\n+#[expect(clippy::similar_names, clippy::too_many_lines)]\n+pub(crate) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    op: BinOpKind,\n+    left: &'tcx Expr<'_>,\n+    right: &'tcx Expr<'_>,\n+) {\n+    let (trait_id, requires_ref) = match op {\n+        BinOpKind::Add => (cx.tcx.lang_items().add_trait(), false),\n+        BinOpKind::Sub => (cx.tcx.lang_items().sub_trait(), false),\n+        BinOpKind::Mul => (cx.tcx.lang_items().mul_trait(), false),\n+        BinOpKind::Div => (cx.tcx.lang_items().div_trait(), false),\n+        BinOpKind::Rem => (cx.tcx.lang_items().rem_trait(), false),\n+        // don't lint short circuiting ops\n+        BinOpKind::And | BinOpKind::Or => return,\n+        BinOpKind::BitXor => (cx.tcx.lang_items().bitxor_trait(), false),\n+        BinOpKind::BitAnd => (cx.tcx.lang_items().bitand_trait(), false),\n+        BinOpKind::BitOr => (cx.tcx.lang_items().bitor_trait(), false),\n+        BinOpKind::Shl => (cx.tcx.lang_items().shl_trait(), false),\n+        BinOpKind::Shr => (cx.tcx.lang_items().shr_trait(), false),\n+        BinOpKind::Ne | BinOpKind::Eq => (cx.tcx.lang_items().eq_trait(), true),\n+        BinOpKind::Lt | BinOpKind::Le | BinOpKind::Ge | BinOpKind::Gt => {\n+            (cx.tcx.lang_items().partial_ord_trait(), true)\n+        },\n+    };\n+    if let Some(trait_id) = trait_id {\n+        match (&left.kind, &right.kind) {\n+            // do not suggest to dereference literals\n+            (&ExprKind::Lit(..), _) | (_, &ExprKind::Lit(..)) => {},\n+            // &foo == &bar\n+            (&ExprKind::AddrOf(BorrowKind::Ref, _, l), &ExprKind::AddrOf(BorrowKind::Ref, _, r)) => {\n+                let lty = cx.typeck_results().expr_ty(l);\n+                let rty = cx.typeck_results().expr_ty(r);\n+                let lcpy = is_copy(cx, lty);\n+                let rcpy = is_copy(cx, rty);\n+                if let Some((self_ty, other_ty)) = in_impl(cx, e, trait_id) {\n+                    if (are_equal(cx, rty, self_ty) && are_equal(cx, lty, other_ty))\n+                        || (are_equal(cx, rty, other_ty) && are_equal(cx, lty, self_ty))\n+                    {\n+                        return; // Don't lint\n+                    }\n+                }\n+                // either operator autorefs or both args are copyable\n+                if (requires_ref || (lcpy && rcpy)) && implements_trait(cx, lty, trait_id, &[rty.into()]) {\n+                    span_lint_and_then(\n+                        cx,\n+                        OP_REF,\n+                        e.span,\n+                        \"needlessly taken reference of both operands\",\n+                        |diag| {\n+                            let lsnip = snippet(cx, l.span, \"...\").to_string();\n+                            let rsnip = snippet(cx, r.span, \"...\").to_string();\n+                            multispan_sugg(\n+                                diag,\n+                                \"use the values directly\",\n+                                vec![(left.span, lsnip), (right.span, rsnip)],\n+                            );\n+                        },\n+                    );\n+                } else if lcpy\n+                    && !rcpy\n+                    && implements_trait(cx, lty, trait_id, &[cx.typeck_results().expr_ty(right).into()])\n+                {\n+                    span_lint_and_then(\n+                        cx,\n+                        OP_REF,\n+                        e.span,\n+                        \"needlessly taken reference of left operand\",\n+                        |diag| {\n+                            let lsnip = snippet(cx, l.span, \"...\").to_string();\n+                            diag.span_suggestion(\n+                                left.span,\n+                                \"use the left value directly\",\n+                                lsnip,\n+                                Applicability::MaybeIncorrect, // FIXME #2597\n+                            );\n+                        },\n+                    );\n+                } else if !lcpy\n+                    && rcpy\n+                    && implements_trait(cx, cx.typeck_results().expr_ty(left), trait_id, &[rty.into()])\n+                {\n+                    span_lint_and_then(\n+                        cx,\n+                        OP_REF,\n+                        e.span,\n+                        \"needlessly taken reference of right operand\",\n+                        |diag| {\n+                            let rsnip = snippet(cx, r.span, \"...\").to_string();\n+                            diag.span_suggestion(\n+                                right.span,\n+                                \"use the right value directly\",\n+                                rsnip,\n+                                Applicability::MaybeIncorrect, // FIXME #2597\n+                            );\n+                        },\n+                    );\n+                }\n+            },\n+            // &foo == bar\n+            (&ExprKind::AddrOf(BorrowKind::Ref, _, l), _) => {\n+                let lty = cx.typeck_results().expr_ty(l);\n+                if let Some((self_ty, other_ty)) = in_impl(cx, e, trait_id) {\n+                    let rty = cx.typeck_results().expr_ty(right);\n+                    if (are_equal(cx, rty, self_ty) && are_equal(cx, lty, other_ty))\n+                        || (are_equal(cx, rty, other_ty) && are_equal(cx, lty, self_ty))\n+                    {\n+                        return; // Don't lint\n+                    }\n+                }\n+                let lcpy = is_copy(cx, lty);\n+                if (requires_ref || lcpy)\n+                    && implements_trait(cx, lty, trait_id, &[cx.typeck_results().expr_ty(right).into()])\n+                {\n+                    span_lint_and_then(\n+                        cx,\n+                        OP_REF,\n+                        e.span,\n+                        \"needlessly taken reference of left operand\",\n+                        |diag| {\n+                            let lsnip = snippet(cx, l.span, \"...\").to_string();\n+                            diag.span_suggestion(\n+                                left.span,\n+                                \"use the left value directly\",\n+                                lsnip,\n+                                Applicability::MaybeIncorrect, // FIXME #2597\n+                            );\n+                        },\n+                    );\n+                }\n+            },\n+            // foo == &bar\n+            (_, &ExprKind::AddrOf(BorrowKind::Ref, _, r)) => {\n+                let rty = cx.typeck_results().expr_ty(r);\n+                if let Some((self_ty, other_ty)) = in_impl(cx, e, trait_id) {\n+                    let lty = cx.typeck_results().expr_ty(left);\n+                    if (are_equal(cx, rty, self_ty) && are_equal(cx, lty, other_ty))\n+                        || (are_equal(cx, rty, other_ty) && are_equal(cx, lty, self_ty))\n+                    {\n+                        return; // Don't lint\n+                    }\n+                }\n+                let rcpy = is_copy(cx, rty);\n+                if (requires_ref || rcpy)\n+                    && implements_trait(cx, cx.typeck_results().expr_ty(left), trait_id, &[rty.into()])\n+                {\n+                    span_lint_and_then(cx, OP_REF, e.span, \"taken reference of right operand\", |diag| {\n+                        let rsnip = snippet(cx, r.span, \"...\").to_string();\n+                        diag.span_suggestion(\n+                            right.span,\n+                            \"use the right value directly\",\n+                            rsnip,\n+                            Applicability::MaybeIncorrect, // FIXME #2597\n+                        );\n+                    });\n+                }\n+            },\n+            _ => {},\n+        }\n+    }\n+}\n+\n+fn in_impl<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    bin_op: DefId,\n+) -> Option<(&'tcx rustc_hir::Ty<'tcx>, &'tcx rustc_hir::Ty<'tcx>)> {\n+    if_chain! {\n+        if let Some(block) = get_enclosing_block(cx, e.hir_id);\n+        if let Some(impl_def_id) = cx.tcx.impl_of_method(block.hir_id.owner.to_def_id());\n+        let item = cx.tcx.hir().expect_item(impl_def_id.expect_local());\n+        if let ItemKind::Impl(item) = &item.kind;\n+        if let Some(of_trait) = &item.of_trait;\n+        if let Some(seg) = of_trait.path.segments.last();\n+        if let Some(Res::Def(_, trait_id)) = seg.res;\n+        if trait_id == bin_op;\n+        if let Some(generic_args) = seg.args;\n+        if let Some(GenericArg::Type(other_ty)) = generic_args.args.last();\n+\n+        then {\n+            Some((item.self_ty, other_ty))\n+        }\n+        else {\n+            None\n+        }\n+    }\n+}\n+\n+fn are_equal<'tcx>(cx: &LateContext<'tcx>, middle_ty: Ty<'_>, hir_ty: &rustc_hir::Ty<'_>) -> bool {\n+    if_chain! {\n+        if let ty::Adt(adt_def, _) = middle_ty.kind();\n+        if let Some(local_did) = adt_def.did().as_local();\n+        let item = cx.tcx.hir().expect_item(local_did);\n+        let middle_ty_id = item.def_id.to_def_id();\n+        if let TyKind::Path(QPath::Resolved(_, path)) = hir_ty.kind;\n+        if let Res::Def(_, hir_ty_id) = path.res;\n+\n+        then {\n+            hir_ty_id == middle_ty_id\n+        }\n+        else {\n+            false\n+        }\n+    }\n+}"}, {"sha": "1aefc2741c21ca345c8376675a7dc9d9db1ba4c6", "filename": "clippy_lints/src/operators/ptr_eq.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Foperators%2Fptr_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Foperators%2Fptr_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Fptr_eq.rs?ref=23c6765276c968bf0fe4ee01f619f357b78390ca", "patch": "@@ -0,0 +1,65 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet_opt;\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{BinOpKind, Expr, ExprKind};\n+use rustc_lint::LateContext;\n+\n+use super::PTR_EQ;\n+\n+static LINT_MSG: &str = \"use `std::ptr::eq` when comparing raw pointers\";\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    op: BinOpKind,\n+    left: &'tcx Expr<'_>,\n+    right: &'tcx Expr<'_>,\n+) {\n+    if BinOpKind::Eq == op {\n+        let (left, right) = match (expr_as_cast_to_usize(cx, left), expr_as_cast_to_usize(cx, right)) {\n+            (Some(lhs), Some(rhs)) => (lhs, rhs),\n+            _ => (left, right),\n+        };\n+\n+        if_chain! {\n+            if let Some(left_var) = expr_as_cast_to_raw_pointer(cx, left);\n+            if let Some(right_var) = expr_as_cast_to_raw_pointer(cx, right);\n+            if let Some(left_snip) = snippet_opt(cx, left_var.span);\n+            if let Some(right_snip) = snippet_opt(cx, right_var.span);\n+            then {\n+                span_lint_and_sugg(\n+                    cx,\n+                    PTR_EQ,\n+                    expr.span,\n+                    LINT_MSG,\n+                    \"try\",\n+                    format!(\"std::ptr::eq({}, {})\", left_snip, right_snip),\n+                    Applicability::MachineApplicable,\n+                    );\n+            }\n+        }\n+    }\n+}\n+\n+// If the given expression is a cast to a usize, return the lhs of the cast\n+// E.g., `foo as *const _ as usize` returns `foo as *const _`.\n+fn expr_as_cast_to_usize<'tcx>(cx: &LateContext<'tcx>, cast_expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n+    if cx.typeck_results().expr_ty(cast_expr) == cx.tcx.types.usize {\n+        if let ExprKind::Cast(expr, _) = cast_expr.kind {\n+            return Some(expr);\n+        }\n+    }\n+    None\n+}\n+\n+// If the given expression is a cast to a `*const` pointer, return the lhs of the cast\n+// E.g., `foo as *const _` returns `foo`.\n+fn expr_as_cast_to_raw_pointer<'tcx>(cx: &LateContext<'tcx>, cast_expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n+    if cx.typeck_results().expr_ty(cast_expr).is_unsafe_ptr() {\n+        if let ExprKind::Cast(expr, _) = cast_expr.kind {\n+            return Some(expr);\n+        }\n+    }\n+    None\n+}"}, {"sha": "9d6bec05bf095d15327032512d2b2f8d2bb11666", "filename": "clippy_lints/src/operators/self_assignment.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Foperators%2Fself_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Foperators%2Fself_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Fself_assignment.rs?ref=23c6765276c968bf0fe4ee01f619f357b78390ca", "patch": "@@ -0,0 +1,20 @@\n+use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::eq_expr_value;\n+use clippy_utils::source::snippet;\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+\n+use super::SELF_ASSIGNMENT;\n+\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, lhs: &'tcx Expr<'_>, rhs: &'tcx Expr<'_>) {\n+    if eq_expr_value(cx, lhs, rhs) {\n+        let lhs = snippet(cx, lhs.span, \"<lhs>\");\n+        let rhs = snippet(cx, rhs.span, \"<rhs>\");\n+        span_lint(\n+            cx,\n+            SELF_ASSIGNMENT,\n+            e.span,\n+            &format!(\"self-assignment of `{}` to `{}`\", rhs, lhs),\n+        );\n+    }\n+}"}, {"sha": "ff85fd554298822f768df19441cafa4b959f00c9", "filename": "clippy_lints/src/operators/verbose_bit_mask.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Foperators%2Fverbose_bit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23c6765276c968bf0fe4ee01f619f357b78390ca/clippy_lints%2Fsrc%2Foperators%2Fverbose_bit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Fverbose_bit_mask.rs?ref=23c6765276c968bf0fe4ee01f619f357b78390ca", "patch": "@@ -0,0 +1,44 @@\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::sugg::Sugg;\n+use rustc_ast::ast::LitKind;\n+use rustc_errors::Applicability;\n+use rustc_hir::{BinOpKind, Expr, ExprKind};\n+use rustc_lint::LateContext;\n+\n+use super::VERBOSE_BIT_MASK;\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    op: BinOpKind,\n+    left: &'tcx Expr<'_>,\n+    right: &'tcx Expr<'_>,\n+    threshold: u64,\n+) {\n+    if BinOpKind::Eq == op\n+        && let ExprKind::Binary(op1, left1, right1) = &left.kind\n+        && BinOpKind::BitAnd == op1.node\n+        && let ExprKind::Lit(lit) = &right1.kind\n+        && let LitKind::Int(n, _) = lit.node\n+        && let ExprKind::Lit(lit1) = &right.kind\n+        && let LitKind::Int(0, _) = lit1.node\n+        && n.leading_zeros() == n.count_zeros()\n+        && n > u128::from(threshold)\n+    {\n+        span_lint_and_then(\n+            cx,\n+            VERBOSE_BIT_MASK,\n+            e.span,\n+            \"bit mask could be simplified with a call to `trailing_zeros`\",\n+            |diag| {\n+                let sugg = Sugg::hir(cx, left1, \"...\").maybe_par();\n+                diag.span_suggestion(\n+                    e.span,\n+                    \"try\",\n+                    format!(\"{}.trailing_zeros() >= {}\", sugg, n.count_ones()),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            },\n+        );\n+    }\n+}"}, {"sha": "2bec93ac606057e22c483777f9a9a546d332a787", "filename": "clippy_lints/src/ptr_eq.rs", "status": "removed", "additions": 0, "deletions": 97, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/b776fb82941cadfc752368901f210831d5184d95/clippy_lints%2Fsrc%2Fptr_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b776fb82941cadfc752368901f210831d5184d95/clippy_lints%2Fsrc%2Fptr_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr_eq.rs?ref=b776fb82941cadfc752368901f210831d5184d95", "patch": "@@ -1,97 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::source::snippet_opt;\n-use if_chain::if_chain;\n-use rustc_errors::Applicability;\n-use rustc_hir::{BinOpKind, Expr, ExprKind};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Use `std::ptr::eq` when applicable\n-    ///\n-    /// ### Why is this bad?\n-    /// `ptr::eq` can be used to compare `&T` references\n-    /// (which coerce to `*const T` implicitly) by their address rather than\n-    /// comparing the values they point to.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// let a = &[1, 2, 3];\n-    /// let b = &[1, 2, 3];\n-    ///\n-    /// assert!(a as *const _ as usize == b as *const _ as usize);\n-    /// ```\n-    /// Use instead:\n-    /// ```rust\n-    /// let a = &[1, 2, 3];\n-    /// let b = &[1, 2, 3];\n-    ///\n-    /// assert!(std::ptr::eq(a, b));\n-    /// ```\n-    #[clippy::version = \"1.49.0\"]\n-    pub PTR_EQ,\n-    style,\n-    \"use `std::ptr::eq` when comparing raw pointers\"\n-}\n-\n-declare_lint_pass!(PtrEq => [PTR_EQ]);\n-\n-static LINT_MSG: &str = \"use `std::ptr::eq` when comparing raw pointers\";\n-\n-impl<'tcx> LateLintPass<'tcx> for PtrEq {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if expr.span.from_expansion() {\n-            return;\n-        }\n-\n-        if let ExprKind::Binary(ref op, left, right) = expr.kind {\n-            if BinOpKind::Eq == op.node {\n-                let (left, right) = match (expr_as_cast_to_usize(cx, left), expr_as_cast_to_usize(cx, right)) {\n-                    (Some(lhs), Some(rhs)) => (lhs, rhs),\n-                    _ => (left, right),\n-                };\n-\n-                if_chain! {\n-                    if let Some(left_var) = expr_as_cast_to_raw_pointer(cx, left);\n-                    if let Some(right_var) = expr_as_cast_to_raw_pointer(cx, right);\n-                    if let Some(left_snip) = snippet_opt(cx, left_var.span);\n-                    if let Some(right_snip) = snippet_opt(cx, right_var.span);\n-                    then {\n-                        span_lint_and_sugg(\n-                            cx,\n-                            PTR_EQ,\n-                            expr.span,\n-                            LINT_MSG,\n-                            \"try\",\n-                            format!(\"std::ptr::eq({}, {})\", left_snip, right_snip),\n-                            Applicability::MachineApplicable,\n-                            );\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-// If the given expression is a cast to a usize, return the lhs of the cast\n-// E.g., `foo as *const _ as usize` returns `foo as *const _`.\n-fn expr_as_cast_to_usize<'tcx>(cx: &LateContext<'tcx>, cast_expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n-    if cx.typeck_results().expr_ty(cast_expr) == cx.tcx.types.usize {\n-        if let ExprKind::Cast(expr, _) = cast_expr.kind {\n-            return Some(expr);\n-        }\n-    }\n-    None\n-}\n-\n-// If the given expression is a cast to a `*const` pointer, return the lhs of the cast\n-// E.g., `foo as *const _` returns `foo`.\n-fn expr_as_cast_to_raw_pointer<'tcx>(cx: &LateContext<'tcx>, cast_expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n-    if cx.typeck_results().expr_ty(cast_expr).is_unsafe_ptr() {\n-        if let ExprKind::Cast(expr, _) = cast_expr.kind {\n-            return Some(expr);\n-        }\n-    }\n-    None\n-}"}, {"sha": "af7f5c9b681bb26c0bcfd4041c7c0fb1b700b305", "filename": "clippy_lints/src/self_assignment.rs", "status": "removed", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/b776fb82941cadfc752368901f210831d5184d95/clippy_lints%2Fsrc%2Fself_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b776fb82941cadfc752368901f210831d5184d95/clippy_lints%2Fsrc%2Fself_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fself_assignment.rs?ref=b776fb82941cadfc752368901f210831d5184d95", "patch": "@@ -1,64 +0,0 @@\n-use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::eq_expr_value;\n-use clippy_utils::source::snippet;\n-use rustc_hir::{Expr, ExprKind};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for explicit self-assignments.\n-    ///\n-    /// ### Why is this bad?\n-    /// Self-assignments are redundant and unlikely to be\n-    /// intentional.\n-    ///\n-    /// ### Known problems\n-    /// If expression contains any deref coercions or\n-    /// indexing operations they are assumed not to have any side effects.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// struct Event {\n-    ///     x: i32,\n-    /// }\n-    ///\n-    /// fn copy_position(a: &mut Event, b: &Event) {\n-    ///     a.x = a.x;\n-    /// }\n-    /// ```\n-    ///\n-    /// Should be:\n-    /// ```rust\n-    /// struct Event {\n-    ///     x: i32,\n-    /// }\n-    ///\n-    /// fn copy_position(a: &mut Event, b: &Event) {\n-    ///     a.x = b.x;\n-    /// }\n-    /// ```\n-    #[clippy::version = \"1.48.0\"]\n-    pub SELF_ASSIGNMENT,\n-    correctness,\n-    \"explicit self-assignment\"\n-}\n-\n-declare_lint_pass!(SelfAssignment => [SELF_ASSIGNMENT]);\n-\n-impl<'tcx> LateLintPass<'tcx> for SelfAssignment {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let ExprKind::Assign(lhs, rhs, _) = &expr.kind {\n-            if eq_expr_value(cx, lhs, rhs) {\n-                let lhs = snippet(cx, lhs.span, \"<lhs>\");\n-                let rhs = snippet(cx, rhs.span, \"<rhs>\");\n-                span_lint(\n-                    cx,\n-                    SELF_ASSIGNMENT,\n-                    expr.span,\n-                    &format!(\"self-assignment of `{}` to `{}`\", rhs, lhs),\n-                );\n-            }\n-        }\n-    }\n-}"}, {"sha": "968c58f40aefa27f3518a66017eb785da09c8129", "filename": "tests/ui/zero_div_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/23c6765276c968bf0fe4ee01f619f357b78390ca/tests%2Fui%2Fzero_div_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23c6765276c968bf0fe4ee01f619f357b78390ca/tests%2Fui%2Fzero_div_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fzero_div_zero.rs?ref=23c6765276c968bf0fe4ee01f619f357b78390ca", "patch": "@@ -1,4 +1,4 @@\n-#[allow(unused_variables)]\n+#[allow(unused_variables, clippy::eq_op)]\n #[warn(clippy::zero_divided_by_zero)]\n fn main() {\n     let nan = 0.0 / 0.0;"}, {"sha": "86563542e0602ef7da031d962fab44ba042d9920", "filename": "tests/ui/zero_div_zero.stderr", "status": "modified", "additions": 1, "deletions": 27, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/23c6765276c968bf0fe4ee01f619f357b78390ca/tests%2Fui%2Fzero_div_zero.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/23c6765276c968bf0fe4ee01f619f357b78390ca/tests%2Fui%2Fzero_div_zero.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fzero_div_zero.stderr?ref=23c6765276c968bf0fe4ee01f619f357b78390ca", "patch": "@@ -1,11 +1,3 @@\n-error: equal expressions as operands to `/`\n-  --> $DIR/zero_div_zero.rs:4:15\n-   |\n-LL |     let nan = 0.0 / 0.0;\n-   |               ^^^^^^^^^\n-   |\n-   = note: `#[deny(clippy::eq_op)]` on by default\n-\n error: constant division of `0.0` with `0.0` will always result in NaN\n   --> $DIR/zero_div_zero.rs:4:15\n    |\n@@ -15,12 +7,6 @@ LL |     let nan = 0.0 / 0.0;\n    = note: `-D clippy::zero-divided-by-zero` implied by `-D warnings`\n    = help: consider using `f64::NAN` if you would like a constant representing NaN\n \n-error: equal expressions as operands to `/`\n-  --> $DIR/zero_div_zero.rs:5:19\n-   |\n-LL |     let f64_nan = 0.0 / 0.0f64;\n-   |                   ^^^^^^^^^^^^\n-\n error: constant division of `0.0` with `0.0` will always result in NaN\n   --> $DIR/zero_div_zero.rs:5:19\n    |\n@@ -29,12 +15,6 @@ LL |     let f64_nan = 0.0 / 0.0f64;\n    |\n    = help: consider using `f64::NAN` if you would like a constant representing NaN\n \n-error: equal expressions as operands to `/`\n-  --> $DIR/zero_div_zero.rs:6:25\n-   |\n-LL |     let other_f64_nan = 0.0f64 / 0.0;\n-   |                         ^^^^^^^^^^^^\n-\n error: constant division of `0.0` with `0.0` will always result in NaN\n   --> $DIR/zero_div_zero.rs:6:25\n    |\n@@ -43,12 +23,6 @@ LL |     let other_f64_nan = 0.0f64 / 0.0;\n    |\n    = help: consider using `f64::NAN` if you would like a constant representing NaN\n \n-error: equal expressions as operands to `/`\n-  --> $DIR/zero_div_zero.rs:7:28\n-   |\n-LL |     let one_more_f64_nan = 0.0f64 / 0.0f64;\n-   |                            ^^^^^^^^^^^^^^^\n-\n error: constant division of `0.0` with `0.0` will always result in NaN\n   --> $DIR/zero_div_zero.rs:7:28\n    |\n@@ -57,5 +31,5 @@ LL |     let one_more_f64_nan = 0.0f64 / 0.0f64;\n    |\n    = help: consider using `f64::NAN` if you would like a constant representing NaN\n \n-error: aborting due to 8 previous errors\n+error: aborting due to 4 previous errors\n "}]}