{"sha": "dc2544712c19720cd82f70461f6ad5525dc2db7e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjMjU0NDcxMmMxOTcyMGNkODJmNzA0NjFmNmFkNTUyNWRjMmRiN2U=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-08-14T08:00:22Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-08-19T20:08:11Z"}, "message": "Rewrite match expressions", "tree": {"sha": "198a6c1162ffe5f85189b8c196447d776eac02ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/198a6c1162ffe5f85189b8c196447d776eac02ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc2544712c19720cd82f70461f6ad5525dc2db7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc2544712c19720cd82f70461f6ad5525dc2db7e", "html_url": "https://github.com/rust-lang/rust/commit/dc2544712c19720cd82f70461f6ad5525dc2db7e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc2544712c19720cd82f70461f6ad5525dc2db7e/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8dbe2133fb342c0db21a583d10c2882a42f2e869", "url": "https://api.github.com/repos/rust-lang/rust/commits/8dbe2133fb342c0db21a583d10c2882a42f2e869", "html_url": "https://github.com/rust-lang/rust/commit/8dbe2133fb342c0db21a583d10c2882a42f2e869"}], "stats": {"total": 246, "additions": 245, "deletions": 1}, "files": [{"sha": "ce5dfb8cddfadc2ca7b25a3e10688bcda03a6e51", "filename": "src/expr.rs", "status": "modified", "additions": 173, "deletions": 1, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/dc2544712c19720cd82f70461f6ad5525dc2db7e/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc2544712c19720cd82f70461f6ad5525dc2db7e/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=dc2544712c19720cd82f70461f6ad5525dc2db7e", "patch": "@@ -12,7 +12,7 @@ use rewrite::{Rewrite, RewriteContext};\n use lists::{write_list, itemize_list, ListFormatting, SeparatorTactic, ListTactic};\n use string::{StringFormat, rewrite_string};\n use StructLitStyle;\n-use utils::{span_after, make_indent, extra_offset};\n+use utils::{span_after, make_indent, extra_offset, first_line_width, last_line_width};\n use visitor::FmtVisitor;\n use config::BlockIndentStyle;\n use comment::{FindUncommented, rewrite_comment};\n@@ -99,6 +99,9 @@ impl Rewrite for ast::Expr {\n                               width,\n                               offset)\n             }\n+            ast::Expr_::ExprMatch(ref cond, ref arms, _) => {\n+                rewrite_match(context, cond, arms, width, offset)\n+            }\n             ast::Expr_::ExprPath(ref qself, ref path) => {\n                 rewrite_path(context, qself.as_ref(), path, width, offset)\n             }\n@@ -303,6 +306,175 @@ fn rewrite_if_else(context: &RewriteContext,\n     Some(result)\n }\n \n+fn rewrite_match(context: &RewriteContext,\n+                 cond: &ast::Expr,\n+                 arms: &[ast::Arm],\n+                 width: usize,\n+                 offset: usize)\n+                 -> Option<String> {\n+    // TODO comments etc. (I am somewhat surprised we don't need handling for these).\n+\n+    // `match `cond` {`\n+    let cond_str = try_opt!(cond.rewrite(context, width - 8, offset + 6));\n+    let mut result = format!(\"match {} {{\", cond_str);\n+\n+    let block_indent = context.block_indent;\n+    let nested_context = context.nested_context();\n+    let arm_indent_str = make_indent(nested_context.block_indent);\n+\n+    for arm in arms {\n+        result.push('\\n');\n+        result.push_str(&arm_indent_str);\n+        result.push_str(&&try_opt!(arm.rewrite(&nested_context,\n+                                               context.config.max_width -\n+                                                   nested_context.block_indent,\n+                                               nested_context.block_indent)));\n+    }\n+\n+    result.push('\\n');\n+    result.push_str(&make_indent(block_indent));\n+    result.push('}');\n+    Some(result)\n+}\n+\n+// Match arms.\n+impl Rewrite for ast::Arm {\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n+        let &ast::Arm { ref attrs, ref pats, ref guard, ref body } = self;\n+        let indent_str = make_indent(offset);\n+\n+        // TODO attrs\n+\n+        // Patterns\n+        let pat_strs = pats.iter().map(|p| p.rewrite(context,\n+                                                     // 5 = ` => {`\n+                                                     width - 5,\n+                                                     offset + context.config.tab_spaces)).collect::<Vec<_>>();\n+        if pat_strs.iter().any(|p| p.is_none()) {\n+            return None;\n+        }\n+        let pat_strs = pat_strs.into_iter().map(|p| p.unwrap()).collect::<Vec<_>>();\n+                                  \n+        let mut total_width = pat_strs.iter().fold(0, |a, p| a + p.len());\n+        // Add ` | `.len().\n+        total_width += (pat_strs.len() - 1) * 3;\n+\n+        let mut vertical = total_width > width - 5 || pat_strs.iter().any(|p| p.contains('\\n'));\n+        if !vertical {\n+            // If the patterns were previously stacked, keep them stacked.\n+            // FIXME should be an option.\n+            let pat_span = mk_sp(pats[0].span.lo, pats[pats.len() - 1].span.hi);\n+            let pat_str = context.codemap.span_to_snippet(pat_span).unwrap();\n+            vertical = pat_str.find('\\n').is_some();\n+        }\n+\n+\n+        let pats_width = if vertical {\n+            pat_strs[pat_strs.len() - 1].len()\n+        } else {\n+            total_width\n+        };\n+\n+        let mut pats_str = String::new();\n+        for p in pat_strs {\n+            if pats_str.len() > 0 {\n+                if vertical {\n+                    pats_str.push_str(\" |\\n\");\n+                    pats_str.push_str(&indent_str);\n+                } else {\n+                    pats_str.push_str(\" | \");\n+                }\n+            }\n+            pats_str.push_str(&p);\n+        }\n+\n+        // TODO probably want to compute the guard width first, then the rest\n+        // TODO also, only subtract the guard width from the last pattern.\n+        // If guard.\n+        let guard_str = try_opt!(rewrite_guard(context, guard, width, offset, pats_width));\n+\n+        let pats_str = format!(\"{}{}\", pats_str, guard_str);\n+        // Where the next text can start.\n+        let mut line_start = last_line_width(&pats_str);\n+        if pats_str.find('\\n').is_none() {\n+            line_start += offset;\n+        }\n+\n+        let comma = if let ast::ExprBlock(_) = body.node {\n+            String::new()\n+        } else {\n+            \",\".to_owned()\n+        };\n+\n+        // Let's try and get the arm body on the same line as the condition.\n+        // 4 = ` => `.len()\n+        if context.config.max_width > line_start + comma.len() + 4 {\n+            let budget = context.config.max_width - line_start - comma.len() - 4;\n+            if let Some(ref body_str) = body.rewrite(context,\n+                                                     budget,\n+                                                     offset + context.config.tab_spaces) {\n+                if first_line_width(body_str) <= budget {\n+                    return Some(format!(\"{} => {}{}\", pats_str, body_str, comma));\n+                }\n+            }\n+        }\n+\n+        // We have to push the body to the next line.\n+        if comma.len() > 0 {\n+            // We're trying to fit a block in, but it still failed, give up.\n+            return None;\n+        }\n+\n+        let body_str = try_opt!(body.rewrite(context,\n+                                             width - context.config.tab_spaces,\n+                                             offset + context.config.tab_spaces));\n+        Some(format!(\"{} =>\\n{}{}\",\n+                     pats_str,\n+                     make_indent(offset + context.config.tab_spaces),\n+                     body_str))\n+    }\n+}\n+\n+// The `if ...` guard on a match arm.\n+fn rewrite_guard(context: &RewriteContext,\n+                 guard: &Option<ptr::P<ast::Expr>>,\n+                 width: usize,\n+                 offset: usize,\n+                 // The amount of space used up on this line for the pattern in\n+                 // the arm.\n+                 pattern_width: usize)\n+                 -> Option<String> {\n+    if let &Some(ref guard) = guard {\n+        // 4 = ` if `, 5 = ` => {`\n+        let overhead = pattern_width + 4 + 5;\n+        if overhead < width {\n+            let cond_str = guard.rewrite(context,\n+                                         width - overhead,\n+                                         offset + context.config.tab_spaces);\n+            if let Some(cond_str) = cond_str {\n+                return Some(format!(\" if {}\", cond_str));\n+            }\n+        }\n+\n+        // Not enough space to put the guard after the pattern, try a newline.\n+        let overhead = context.config.tab_spaces + 4 + 5;\n+        if overhead < width {\n+            let cond_str = guard.rewrite(context,\n+                                         width - overhead,\n+                                         offset + context.config.tab_spaces);\n+            if let Some(cond_str) = cond_str {\n+                return Some(format!(\"\\n{}if {}\",\n+                                    make_indent(offset + context.config.tab_spaces),\n+                                    cond_str));\n+            }\n+        }\n+\n+        None\n+    } else {\n+        Some(String::new())\n+    }\n+}\n+\n fn rewrite_pat_expr(context: &RewriteContext,\n                     pat: Option<&ast::Pat>,\n                     expr: &ast::Expr,"}, {"sha": "d30d81a4885c3336d44edc7ef87fc8cbd7fb230d", "filename": "src/rewrite.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dc2544712c19720cd82f70461f6ad5525dc2db7e/src%2Frewrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc2544712c19720cd82f70461f6ad5525dc2db7e/src%2Frewrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frewrite.rs?ref=dc2544712c19720cd82f70461f6ad5525dc2db7e", "patch": "@@ -30,3 +30,13 @@ pub struct RewriteContext<'a> {\n     pub config: &'a Config,\n     pub block_indent: usize,\n }\n+\n+impl<'a> RewriteContext<'a> {\n+    pub fn nested_context(&self) -> RewriteContext<'a> {\n+        RewriteContext {\n+            codemap: self.codemap,\n+            config: self.config,\n+            block_indent: self.block_indent + self.config.tab_spaces,\n+        }\n+    }\n+}"}, {"sha": "f80e1185baed2a06e3617b0367218923c56e158b", "filename": "src/utils.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/dc2544712c19720cd82f70461f6ad5525dc2db7e/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc2544712c19720cd82f70461f6ad5525dc2db7e/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=dc2544712c19720cd82f70461f6ad5525dc2db7e", "patch": "@@ -82,6 +82,25 @@ pub fn format_mutability(mutability: ast::Mutability) -> &'static str {\n     }\n }\n \n+// The width of the first line in s.\n+#[inline]\n+pub fn first_line_width(s: &str) -> usize {\n+    match s.find('\\n') {\n+        Some(n) => n,\n+        None => s.len(),\n+    }\n+}\n+\n+// The width of the last line in s.\n+#[inline]\n+pub fn last_line_width(s: &str) -> usize {\n+    match s.rfind('\\n') {\n+        Some(n) => s.len() - n,\n+        None => s.len(),\n+    }\n+}\n+\n+#[inline]\n fn is_skip(meta_item: &MetaItem) -> bool {\n     match meta_item.node {\n         MetaItem_::MetaWord(ref s) => *s == SKIP_ANNOTATION,\n@@ -95,6 +114,7 @@ pub fn contains_skip(attrs: &[Attribute]) -> bool {\n }\n \n // Find the end of a TyParam\n+#[inline]\n pub fn end_typaram(typaram: &ast::TyParam) -> BytePos {\n     typaram.bounds.last().map(|bound| match *bound {\n         ast::RegionTyParamBound(ref lt) => lt.span,"}, {"sha": "9d8a484028ba35d02d0b8d2da29e0f256493ee15", "filename": "tests/target/match.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/dc2544712c19720cd82f70461f6ad5525dc2db7e/tests%2Ftarget%2Fmatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc2544712c19720cd82f70461f6ad5525dc2db7e/tests%2Ftarget%2Fmatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fmatch.rs?ref=dc2544712c19720cd82f70461f6ad5525dc2db7e", "patch": "@@ -0,0 +1,42 @@\n+// Match expressions.\n+\n+fn foo() {\n+    // A match expression.\n+    match x {\n+        // Some comment.\n+        a => foo(),\n+        b if 0 < 42 => foo(),\n+        c => { // Another comment.\n+            // Comment.\n+            an_expression;\n+            foo()\n+        }\n+        // Perhaps this should introduce braces?\n+        Foo(ref bar) =>\n+            aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\n+        Pattern1 | Pattern2 | Pattern3 => false,\n+        Paternnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn |\n+        Paternnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn => {\n+            blah\n+        }\n+        Patternnnnnnnnnnnnnnnnnnn |\n+        Patternnnnnnnnnnnnnnnnnnn |\n+        Patternnnnnnnnnnnnnnnnnnn |\n+        Patternnnnnnnnnnnnnnnnnnn => meh,\n+\n+        Patternnnnnnnnnnnnnnnnnnn |\n+        Patternnnnnnnnnnnnnnnnnnn if looooooooooooooooooong_guard => meh,\n+\n+        Patternnnnnnnnnnnnnnnnnnnnnnnnn |\n+        Patternnnnnnnnnnnnnnnnnnnnnnnnn\n+            if looooooooooooooooooooooooooooooooooooooooong_guard => meh,\n+        _ => {}\n+    }\n+\n+    let whatever = match something {\n+        /// DOC COMMENT!\n+        Some(_) => 42,\n+        #[an_attribute]\n+        None => 0,\n+    };\n+}"}]}