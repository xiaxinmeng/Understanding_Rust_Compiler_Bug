{"sha": "90f642bb3d74ee0ba8e0faf967748f36ff78d572", "node_id": "C_kwDOAAsO6NoAKDkwZjY0MmJiM2Q3NGVlMGJhOGUwZmFmOTY3NzQ4ZjM2ZmY3OGQ1NzI", "commit": {"author": {"name": "clubby789", "email": "jamie@hill-daniel.co.uk", "date": "2023-02-16T17:17:55Z"}, "committer": {"name": "clubby789", "email": "jamie@hill-daniel.co.uk", "date": "2023-02-16T19:44:03Z"}, "message": "Properly check for builtin derives", "tree": {"sha": "c9a478d633e2cdb6c2a3037c746650fdfe5a0b3d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9a478d633e2cdb6c2a3037c746650fdfe5a0b3d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/90f642bb3d74ee0ba8e0faf967748f36ff78d572", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/90f642bb3d74ee0ba8e0faf967748f36ff78d572", "html_url": "https://github.com/rust-lang/rust/commit/90f642bb3d74ee0ba8e0faf967748f36ff78d572", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/90f642bb3d74ee0ba8e0faf967748f36ff78d572/comments", "author": {"login": "clubby789", "id": 13556931, "node_id": "MDQ6VXNlcjEzNTU2OTMx", "avatar_url": "https://avatars.githubusercontent.com/u/13556931?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clubby789", "html_url": "https://github.com/clubby789", "followers_url": "https://api.github.com/users/clubby789/followers", "following_url": "https://api.github.com/users/clubby789/following{/other_user}", "gists_url": "https://api.github.com/users/clubby789/gists{/gist_id}", "starred_url": "https://api.github.com/users/clubby789/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clubby789/subscriptions", "organizations_url": "https://api.github.com/users/clubby789/orgs", "repos_url": "https://api.github.com/users/clubby789/repos", "events_url": "https://api.github.com/users/clubby789/events{/privacy}", "received_events_url": "https://api.github.com/users/clubby789/received_events", "type": "User", "site_admin": false}, "committer": {"login": "clubby789", "id": 13556931, "node_id": "MDQ6VXNlcjEzNTU2OTMx", "avatar_url": "https://avatars.githubusercontent.com/u/13556931?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clubby789", "html_url": "https://github.com/clubby789", "followers_url": "https://api.github.com/users/clubby789/followers", "following_url": "https://api.github.com/users/clubby789/following{/other_user}", "gists_url": "https://api.github.com/users/clubby789/gists{/gist_id}", "starred_url": "https://api.github.com/users/clubby789/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clubby789/subscriptions", "organizations_url": "https://api.github.com/users/clubby789/orgs", "repos_url": "https://api.github.com/users/clubby789/repos", "events_url": "https://api.github.com/users/clubby789/events{/privacy}", "received_events_url": "https://api.github.com/users/clubby789/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "999ac5f7770bff68bd65f490990d32c3ec1faaa6", "url": "https://api.github.com/repos/rust-lang/rust/commits/999ac5f7770bff68bd65f490990d32c3ec1faaa6", "html_url": "https://github.com/rust-lang/rust/commit/999ac5f7770bff68bd65f490990d32c3ec1faaa6"}], "stats": {"total": 94, "additions": 60, "deletions": 34}, "files": [{"sha": "dd5c85531fd7fb565dc5588ee80ad2d6520f6648", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/90f642bb3d74ee0ba8e0faf967748f36ff78d572/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90f642bb3d74ee0ba8e0faf967748f36ff78d572/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=90f642bb3d74ee0ba8e0faf967748f36ff78d572", "patch": "@@ -761,8 +761,7 @@ impl<'a> TraitDef<'a> {\n         let path = cx.path_all(self.span, false, vec![type_ident], self_params);\n         let self_type = cx.ty_path(path);\n \n-        let attr = cx.attr_word(sym::automatically_derived, self.span);\n-        let attrs = thin_vec![attr];\n+        let attrs = thin_vec![cx.attr_word(sym::automatically_derived, self.span),];\n         let opt_trait_ref = Some(trait_ref);\n \n         cx.item("}, {"sha": "8e6fd231f2570ce1f77fd55d7d9a72172dc8aa59", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/90f642bb3d74ee0ba8e0faf967748f36ff78d572/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90f642bb3d74ee0ba8e0faf967748f36ff78d572/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=90f642bb3d74ee0ba8e0faf967748f36ff78d572", "patch": "@@ -46,7 +46,7 @@ use rustc_serialize::{Decodable, Encodable};\n use rustc_session::cstore::Untracked;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n-use rustc_span::{ExpnId, Span};\n+use rustc_span::{ExpnId, ExpnKind, Span};\n use rustc_target::abi::{Align, Integer, IntegerType, VariantIdx};\n pub use rustc_target::abi::{ReprFlags, ReprOptions};\n use rustc_type_ir::WithCachedTypeInfo;\n@@ -2436,8 +2436,23 @@ impl<'tcx> TyCtxt<'tcx> {\n         None\n     }\n \n-    /// If the given `DefId` belongs to a trait that was automatically derived, returns `true`.\n-    pub fn is_builtin_derive(self, def_id: DefId) -> bool {\n+    /// Check if the given `DefId` is `#\\[automatically_derived\\], *and*\n+    /// whether it was produced by expanding a builtin derive macro.\n+    pub fn is_builtin_derived(self, def_id: DefId) -> bool {\n+        if self.is_automatically_derived(def_id)\n+            && let Some(def_id) = def_id.as_local()\n+            && let outer = self.def_span(def_id).ctxt().outer_expn_data()\n+            && matches!(outer.kind, ExpnKind::Macro(MacroKind::Derive, _))\n+            && self.has_attr(outer.macro_def_id.unwrap(), sym::rustc_builtin_macro)\n+        {\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    /// Check if the given `DefId` is `#\\[automatically_derived\\]`.\n+    pub fn is_automatically_derived(self, def_id: DefId) -> bool {\n         self.has_attr(def_id, sym::automatically_derived)\n     }\n "}, {"sha": "f5f1c1010e15586a8805f9cb7b8ed5c859d6be02", "filename": "compiler/rustc_mir_transform/src/check_packed_ref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/90f642bb3d74ee0ba8e0faf967748f36ff78d572/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_packed_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90f642bb3d74ee0ba8e0faf967748f36ff78d572/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_packed_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_packed_ref.rs?ref=90f642bb3d74ee0ba8e0faf967748f36ff78d572", "patch": "@@ -42,12 +42,12 @@ impl<'tcx> Visitor<'tcx> for PackedRefChecker<'_, 'tcx> {\n             if util::is_disaligned(self.tcx, self.body, self.param_env, *place) {\n                 let def_id = self.body.source.instance.def_id();\n                 if let Some(impl_def_id) = self.tcx.impl_of_method(def_id)\n-                    && self.tcx.is_builtin_derive(impl_def_id)\n+                    && self.tcx.is_builtin_derived(impl_def_id)\n                 {\n                     // If we ever reach here it means that the generated derive\n                     // code is somehow doing an unaligned reference, which it\n                     // shouldn't do.\n-                    unreachable!();\n+                    span_bug!(self.source_info.span, \"builtin derive created an unaligned reference\");\n                 } else {\n                     struct_span_err!(\n                         self.tcx.sess,"}, {"sha": "c380b3d1e39f4bc649e2fb7459cd9171643c183c", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90f642bb3d74ee0ba8e0faf967748f36ff78d572/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90f642bb3d74ee0ba8e0faf967748f36ff78d572/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=90f642bb3d74ee0ba8e0faf967748f36ff78d572", "patch": "@@ -259,7 +259,7 @@ impl<'tcx> MarkSymbolVisitor<'tcx> {\n     /// for discussion).\n     fn should_ignore_item(&mut self, def_id: DefId) -> bool {\n         if let Some(impl_of) = self.tcx.impl_of_method(def_id) {\n-            if !self.tcx.has_attr(impl_of, sym::automatically_derived) {\n+            if !self.tcx.is_automatically_derived(impl_of) {\n                 return false;\n             }\n "}, {"sha": "873c40e8cb6121e22191e448f9daa8b238fa4160", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90f642bb3d74ee0ba8e0faf967748f36ff78d572/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90f642bb3d74ee0ba8e0faf967748f36ff78d572/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=90f642bb3d74ee0ba8e0faf967748f36ff78d572", "patch": "@@ -537,7 +537,7 @@ impl<'tcx> MissingStabilityAnnotations<'tcx> {\n         // then it would be \"stable\" at least for the impl.\n         // We gate usages of it using `feature(const_trait_impl)` anyways\n         // so there is no unstable leakage\n-        if self.tcx.is_builtin_derive(def_id.to_def_id()) {\n+        if self.tcx.is_automatically_derived(def_id.to_def_id()) {\n             return;\n         }\n "}, {"sha": "68669590ba268e667e1a028d39d272cd1d39fb1e", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90f642bb3d74ee0ba8e0faf967748f36ff78d572/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90f642bb3d74ee0ba8e0faf967748f36ff78d572/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=90f642bb3d74ee0ba8e0faf967748f36ff78d572", "patch": "@@ -2097,7 +2097,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 // Ignore automatically derived impls and `!Trait` impls.\n                 .filter(|&def_id| {\n                     self.tcx.impl_polarity(def_id) != ty::ImplPolarity::Negative\n-                        || self.tcx.is_builtin_derive(def_id)\n+                        || self.tcx.is_automatically_derived(def_id)\n                 })\n                 .filter_map(|def_id| self.tcx.impl_trait_ref(def_id))\n                 .map(ty::EarlyBinder::subst_identity)"}, {"sha": "0c9c79c08b251884f87d1d133fd9d59236c1dee8", "filename": "tests/ui/lint/unaligned_references.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/90f642bb3d74ee0ba8e0faf967748f36ff78d572/tests%2Fui%2Flint%2Funaligned_references.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90f642bb3d74ee0ba8e0faf967748f36ff78d572/tests%2Fui%2Flint%2Funaligned_references.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Funaligned_references.rs?ref=90f642bb3d74ee0ba8e0faf967748f36ff78d572", "patch": "@@ -13,6 +13,20 @@ pub struct Packed2 {\n     z: u8,\n }\n \n+trait Foo {\n+    fn evil(&self);\n+}\n+\n+// Test for #108122\n+#[automatically_derived]\n+impl Foo for Packed2 {\n+    fn evil(&self) {\n+        unsafe {\n+            &self.x; //~ ERROR reference to packed field\n+        }\n+    }\n+}\n+\n fn main() {\n     unsafe {\n         let good = Good { data: 0, ptr: &0, data2: [0, 0], aligned: [0; 32] };\n@@ -37,6 +51,7 @@ fn main() {\n         let _ = &packed2.x; //~ ERROR reference to packed field\n         let _ = &packed2.y; // ok, has align 2 in packed(2) struct\n         let _ = &packed2.z; // ok, has align 1\n+        packed2.evil();\n     }\n \n     unsafe {\n@@ -71,22 +86,10 @@ fn main() {\n         #[repr(packed)]\n         struct Misalign<T>(u8, T);\n \n-        let m1 = Misalign(\n-            0,\n-            Wrapper {\n-                a: U16(10),\n-                b: HasDrop,\n-            },\n-        );\n+        let m1 = Misalign(0, Wrapper { a: U16(10), b: HasDrop });\n         let _ref = &m1.1.a; //~ ERROR reference to packed field\n \n-        let m2 = Misalign(\n-            0,\n-            Wrapper2 {\n-                a: U16(10),\n-                b: HasDrop,\n-            },\n-        );\n+        let m2 = Misalign(0, Wrapper2 { a: U16(10), b: HasDrop });\n         let _ref = &m2.1.a; //~ ERROR reference to packed field\n     }\n }"}, {"sha": "775dcac678e7605cd20b273bfae3a61fb27a7caf", "filename": "tests/ui/lint/unaligned_references.stderr", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/90f642bb3d74ee0ba8e0faf967748f36ff78d572/tests%2Fui%2Flint%2Funaligned_references.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/90f642bb3d74ee0ba8e0faf967748f36ff78d572/tests%2Fui%2Flint%2Funaligned_references.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Funaligned_references.stderr?ref=90f642bb3d74ee0ba8e0faf967748f36ff78d572", "patch": "@@ -1,5 +1,14 @@\n error[E0793]: reference to packed field is unaligned\n-  --> $DIR/unaligned_references.rs:20:17\n+  --> $DIR/unaligned_references.rs:25:13\n+   |\n+LL |             &self.x;\n+   |             ^^^^^^^\n+   |\n+   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+   = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n+\n+error[E0793]: reference to packed field is unaligned\n+  --> $DIR/unaligned_references.rs:34:17\n    |\n LL |         let _ = &good.ptr;\n    |                 ^^^^^^^^^\n@@ -8,7 +17,7 @@ LL |         let _ = &good.ptr;\n    = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n \n error[E0793]: reference to packed field is unaligned\n-  --> $DIR/unaligned_references.rs:21:17\n+  --> $DIR/unaligned_references.rs:35:17\n    |\n LL |         let _ = &good.data;\n    |                 ^^^^^^^^^^\n@@ -17,7 +26,7 @@ LL |         let _ = &good.data;\n    = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n \n error[E0793]: reference to packed field is unaligned\n-  --> $DIR/unaligned_references.rs:23:17\n+  --> $DIR/unaligned_references.rs:37:17\n    |\n LL |         let _ = &good.data as *const _;\n    |                 ^^^^^^^^^^\n@@ -26,7 +35,7 @@ LL |         let _ = &good.data as *const _;\n    = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n \n error[E0793]: reference to packed field is unaligned\n-  --> $DIR/unaligned_references.rs:24:27\n+  --> $DIR/unaligned_references.rs:38:27\n    |\n LL |         let _: *const _ = &good.data;\n    |                           ^^^^^^^^^^\n@@ -35,7 +44,7 @@ LL |         let _: *const _ = &good.data;\n    = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n \n error[E0793]: reference to packed field is unaligned\n-  --> $DIR/unaligned_references.rs:26:17\n+  --> $DIR/unaligned_references.rs:40:17\n    |\n LL |         let _ = good.data.clone();\n    |                 ^^^^^^^^^^^^^^^^^\n@@ -44,7 +53,7 @@ LL |         let _ = good.data.clone();\n    = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n \n error[E0793]: reference to packed field is unaligned\n-  --> $DIR/unaligned_references.rs:28:17\n+  --> $DIR/unaligned_references.rs:42:17\n    |\n LL |         let _ = &good.data2[0];\n    |                 ^^^^^^^^^^^^^^\n@@ -53,7 +62,7 @@ LL |         let _ = &good.data2[0];\n    = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n \n error[E0793]: reference to packed field is unaligned\n-  --> $DIR/unaligned_references.rs:37:17\n+  --> $DIR/unaligned_references.rs:51:17\n    |\n LL |         let _ = &packed2.x;\n    |                 ^^^^^^^^^^\n@@ -62,7 +71,7 @@ LL |         let _ = &packed2.x;\n    = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n \n error[E0793]: reference to packed field is unaligned\n-  --> $DIR/unaligned_references.rs:81:20\n+  --> $DIR/unaligned_references.rs:90:20\n    |\n LL |         let _ref = &m1.1.a;\n    |                    ^^^^^^^\n@@ -71,14 +80,14 @@ LL |         let _ref = &m1.1.a;\n    = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n \n error[E0793]: reference to packed field is unaligned\n-  --> $DIR/unaligned_references.rs:90:20\n+  --> $DIR/unaligned_references.rs:93:20\n    |\n LL |         let _ref = &m2.1.a;\n    |                    ^^^^^^^\n    |\n    = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n    = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n \n-error: aborting due to 9 previous errors\n+error: aborting due to 10 previous errors\n \n For more information about this error, try `rustc --explain E0793`."}]}