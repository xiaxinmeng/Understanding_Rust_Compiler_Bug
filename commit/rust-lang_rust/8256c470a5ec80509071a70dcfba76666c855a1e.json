{"sha": "8256c470a5ec80509071a70dcfba76666c855a1e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyNTZjNDcwYTVlYzgwNTA5MDcxYTcwZGNmYmE3NjY2NmM4NTVhMWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-27T12:12:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-27T12:12:52Z"}, "message": "Auto merge of #31089 - fhahn:macro-ice, r=pnkfelix\n\nThis is a  work in progress PR that potentially should fix #29084, #28308, #25385, #28288, #31011. I think this may also adresse parts of  #2887.\n\nThe problem in this issues seems to be that when transcribing macro arguments, we just clone the argument Nonterminal, which still has to original spans. This leads to the unprintable spans. One solution would be to update the spans of the inserted argument to match the argument in the macro definition. So for [this testcase](https://github.com/rust-lang/rust/compare/master...fhahn:macro-ice?expand=1#diff-f7def7420c51621640707b6337726876R2) the error message would be displayed in the macro definition:\n\n    src/test/compile-fail/issue-31011.rs:4:12: 4:22 error: attempted access of field `trace` on type `&T`, but no field with that name was found\n    src/test/compile-fail/issue-31011.rs:4         if $ctx.trace {\n\nCurrently I've added a very simple `update_span` function, which updates the span of the outer-most expression of a `NtExpr`, but this `update_span` function should be updated to handle all Nonterminals. But I'm pretty new to the macro system and would like to check if this approach makes sense, before doing that.", "tree": {"sha": "38d273581a098812363d0bd33ef3a85a8c964517", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/38d273581a098812363d0bd33ef3a85a8c964517"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8256c470a5ec80509071a70dcfba76666c855a1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8256c470a5ec80509071a70dcfba76666c855a1e", "html_url": "https://github.com/rust-lang/rust/commit/8256c470a5ec80509071a70dcfba76666c855a1e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8256c470a5ec80509071a70dcfba76666c855a1e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8b18aac12214d7135a083e2e6946aa197185d49", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8b18aac12214d7135a083e2e6946aa197185d49", "html_url": "https://github.com/rust-lang/rust/commit/b8b18aac12214d7135a083e2e6946aa197185d49"}, {"sha": "ecb7b01a08095a8b657995da344bb47097efd43f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ecb7b01a08095a8b657995da344bb47097efd43f", "html_url": "https://github.com/rust-lang/rust/commit/ecb7b01a08095a8b657995da344bb47097efd43f"}], "stats": {"total": 384, "additions": 354, "deletions": 30}, "files": [{"sha": "b8e5642474c78be775e6268b1869f6d730abe570", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 60, "deletions": 30, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/8256c470a5ec80509071a70dcfba76666c855a1e/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8256c470a5ec80509071a70dcfba76666c855a1e/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=8256c470a5ec80509071a70dcfba76666c855a1e", "patch": "@@ -233,7 +233,6 @@ macro_rules! maybe_whole {\n     )\n }\n \n-\n fn maybe_append(mut lhs: Vec<Attribute>, rhs: Option<Vec<Attribute>>)\n                 -> Vec<Attribute> {\n     if let Some(ref attrs) = rhs {\n@@ -255,6 +254,7 @@ pub struct Parser<'a> {\n     pub cfg: CrateConfig,\n     /// the previous token or None (only stashed sometimes).\n     pub last_token: Option<Box<token::Token>>,\n+    last_token_interpolated: bool,\n     pub buffer: [TokenAndSpan; 4],\n     pub buffer_start: isize,\n     pub buffer_end: isize,\n@@ -362,6 +362,7 @@ impl<'a> Parser<'a> {\n             span: span,\n             last_span: span,\n             last_token: None,\n+            last_token_interpolated: false,\n             buffer: [\n                 placeholder.clone(),\n                 placeholder.clone(),\n@@ -542,6 +543,19 @@ impl<'a> Parser<'a> {\n         self.commit_stmt(&[edible], &[])\n     }\n \n+    /// returns the span of expr, if it was not interpolated or the span of the interpolated token\n+    fn interpolated_or_expr_span(&self,\n+                                 expr: PResult<'a, P<Expr>>)\n+                                 -> PResult<'a, (Span, P<Expr>)> {\n+        expr.map(|e| {\n+            if self.last_token_interpolated {\n+                (self.last_span, e)\n+            } else {\n+                (e.span, e)\n+            }\n+        })\n+    }\n+\n     pub fn parse_ident(&mut self) -> PResult<'a, ast::Ident> {\n         self.check_strict_keywords();\n         self.check_reserved_keywords();\n@@ -933,6 +947,7 @@ impl<'a> Parser<'a> {\n         } else {\n             None\n         };\n+        self.last_token_interpolated = self.token.is_interpolated();\n         let next = if self.buffer_start == self.buffer_end {\n             self.reader.real_token()\n         } else {\n@@ -2328,18 +2343,20 @@ impl<'a> Parser<'a> {\n                                   -> PResult<'a, P<Expr>> {\n         let attrs = try!(self.parse_or_use_outer_attributes(already_parsed_attrs));\n \n-        let b = try!(self.parse_bottom_expr());\n-        self.parse_dot_or_call_expr_with(b, attrs)\n+        let b = self.parse_bottom_expr();\n+        let (span, b) = try!(self.interpolated_or_expr_span(b));\n+        self.parse_dot_or_call_expr_with(b, span.lo, attrs)\n     }\n \n     pub fn parse_dot_or_call_expr_with(&mut self,\n                                        e0: P<Expr>,\n+                                       lo: BytePos,\n                                        attrs: ThinAttributes)\n                                        -> PResult<'a, P<Expr>> {\n         // Stitch the list of outer attributes onto the return value.\n         // A little bit ugly, but the best way given the current code\n         // structure\n-        self.parse_dot_or_call_expr_with_(e0)\n+        self.parse_dot_or_call_expr_with_(e0, lo)\n         .map(|expr|\n             expr.map(|mut expr| {\n                 expr.attrs.update(|a| a.prepend(attrs));\n@@ -2366,7 +2383,8 @@ impl<'a> Parser<'a> {\n     fn parse_dot_suffix(&mut self,\n                         ident: Ident,\n                         ident_span: Span,\n-                        self_value: P<Expr>)\n+                        self_value: P<Expr>,\n+                        lo: BytePos)\n                         -> PResult<'a, P<Expr>> {\n         let (_, tys, bindings) = if self.eat(&token::ModSep) {\n             try!(self.expect_lt());\n@@ -2380,8 +2398,6 @@ impl<'a> Parser<'a> {\n             self.span_err(last_span, \"type bindings are only permitted on trait paths\");\n         }\n \n-        let lo = self_value.span.lo;\n-\n         Ok(match self.token {\n             // expr.f() method call.\n             token::OpenDelim(token::Paren) => {\n@@ -2414,9 +2430,8 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    fn parse_dot_or_call_expr_with_(&mut self, e0: P<Expr>) -> PResult<'a, P<Expr>> {\n+    fn parse_dot_or_call_expr_with_(&mut self, e0: P<Expr>, lo: BytePos) -> PResult<'a, P<Expr>> {\n         let mut e = e0;\n-        let lo = e.span.lo;\n         let mut hi;\n         loop {\n             // expr.f\n@@ -2427,7 +2442,7 @@ impl<'a> Parser<'a> {\n                     hi = self.span.hi;\n                     self.bump();\n \n-                    e = try!(self.parse_dot_suffix(i, mk_sp(dot_pos, hi), e));\n+                    e = try!(self.parse_dot_suffix(i, mk_sp(dot_pos, hi), e, lo));\n                   }\n                   token::Literal(token::Integer(n), suf) => {\n                     let sp = self.span;\n@@ -2480,7 +2495,7 @@ impl<'a> Parser<'a> {\n                     let dot_pos = self.last_span.hi;\n                     e = try!(self.parse_dot_suffix(special_idents::invalid,\n                                                    mk_sp(dot_pos, dot_pos),\n-                                                   e));\n+                                                   e, lo));\n                   }\n                 }\n                 continue;\n@@ -2715,27 +2730,31 @@ impl<'a> Parser<'a> {\n         let ex = match self.token {\n             token::Not => {\n                 self.bump();\n-                let e = try!(self.parse_prefix_expr(None));\n-                hi = e.span.hi;\n+                let e = self.parse_prefix_expr(None);\n+                let (span, e) = try!(self.interpolated_or_expr_span(e));\n+                hi = span.hi;\n                 self.mk_unary(UnNot, e)\n             }\n             token::BinOp(token::Minus) => {\n                 self.bump();\n-                let e = try!(self.parse_prefix_expr(None));\n-                hi = e.span.hi;\n+                let e = self.parse_prefix_expr(None);\n+                let (span, e) = try!(self.interpolated_or_expr_span(e));\n+                hi = span.hi;\n                 self.mk_unary(UnNeg, e)\n             }\n             token::BinOp(token::Star) => {\n                 self.bump();\n-                let e = try!(self.parse_prefix_expr(None));\n-                hi = e.span.hi;\n+                let e = self.parse_prefix_expr(None);\n+                let (span, e) = try!(self.interpolated_or_expr_span(e));\n+                hi = span.hi;\n                 self.mk_unary(UnDeref, e)\n             }\n             token::BinOp(token::And) | token::AndAnd => {\n                 try!(self.expect_and());\n                 let m = try!(self.parse_mutability());\n-                let e = try!(self.parse_prefix_expr(None));\n-                hi = e.span.hi;\n+                let e = self.parse_prefix_expr(None);\n+                let (span, e) = try!(self.interpolated_or_expr_span(e));\n+                hi = span.hi;\n                 ExprAddrOf(m, e)\n             }\n             token::Ident(..) if self.token.is_keyword(keywords::In) => {\n@@ -2753,9 +2772,10 @@ impl<'a> Parser<'a> {\n             }\n             token::Ident(..) if self.token.is_keyword(keywords::Box) => {\n                 self.bump();\n-                let subexpression = try!(self.parse_prefix_expr(None));\n-                hi = subexpression.span.hi;\n-                ExprBox(subexpression)\n+                let e = self.parse_prefix_expr(None);\n+                let (span, e) = try!(self.interpolated_or_expr_span(e));\n+                hi = span.hi;\n+                ExprBox(e)\n             }\n             _ => return self.parse_dot_or_call_expr(Some(attrs))\n         };\n@@ -2790,12 +2810,21 @@ impl<'a> Parser<'a> {\n                 try!(self.parse_prefix_expr(attrs))\n             }\n         };\n+\n+\n         if self.expr_is_complete(&*lhs) {\n             // Semi-statement forms are odd. See https://github.com/rust-lang/rust/issues/29071\n             return Ok(lhs);\n         }\n         self.expected_tokens.push(TokenType::Operator);\n         while let Some(op) = AssocOp::from_token(&self.token) {\n+\n+            let lhs_span = if self.last_token_interpolated {\n+                self.last_span\n+            } else {\n+                lhs.span\n+            };\n+\n             let cur_op_span = self.span;\n             let restrictions = if op.is_assign_like() {\n                 self.restrictions & Restrictions::RESTRICTION_NO_STRUCT_LITERAL\n@@ -2812,12 +2841,12 @@ impl<'a> Parser<'a> {\n             // Special cases:\n             if op == AssocOp::As {\n                 let rhs = try!(self.parse_ty());\n-                lhs = self.mk_expr(lhs.span.lo, rhs.span.hi,\n+                lhs = self.mk_expr(lhs_span.lo, rhs.span.hi,\n                                    ExprCast(lhs, rhs), None);\n                 continue\n             } else if op == AssocOp::Colon {\n                 let rhs = try!(self.parse_ty());\n-                lhs = self.mk_expr(lhs.span.lo, rhs.span.hi,\n+                lhs = self.mk_expr(lhs_span.lo, rhs.span.hi,\n                                    ExprType(lhs, rhs), None);\n                 continue\n             } else if op == AssocOp::DotDot {\n@@ -2839,7 +2868,7 @@ impl<'a> Parser<'a> {\n                     } else {\n                         None\n                     };\n-                    let (lhs_span, rhs_span) = (lhs.span, if let Some(ref x) = rhs {\n+                    let (lhs_span, rhs_span) = (lhs_span, if let Some(ref x) = rhs {\n                         x.span\n                     } else {\n                         cur_op_span\n@@ -2879,14 +2908,14 @@ impl<'a> Parser<'a> {\n                 AssocOp::Equal | AssocOp::Less | AssocOp::LessEqual | AssocOp::NotEqual |\n                 AssocOp::Greater | AssocOp::GreaterEqual => {\n                     let ast_op = op.to_ast_binop().unwrap();\n-                    let (lhs_span, rhs_span) = (lhs.span, rhs.span);\n+                    let (lhs_span, rhs_span) = (lhs_span, rhs.span);\n                     let binary = self.mk_binary(codemap::respan(cur_op_span, ast_op), lhs, rhs);\n                     self.mk_expr(lhs_span.lo, rhs_span.hi, binary, None)\n                 }\n                 AssocOp::Assign =>\n-                    self.mk_expr(lhs.span.lo, rhs.span.hi, ExprAssign(lhs, rhs), None),\n+                    self.mk_expr(lhs_span.lo, rhs.span.hi, ExprAssign(lhs, rhs), None),\n                 AssocOp::Inplace =>\n-                    self.mk_expr(lhs.span.lo, rhs.span.hi, ExprInPlace(lhs, rhs), None),\n+                    self.mk_expr(lhs_span.lo, rhs.span.hi, ExprInPlace(lhs, rhs), None),\n                 AssocOp::AssignOp(k) => {\n                     let aop = match k {\n                         token::Plus =>    BiAdd,\n@@ -2900,7 +2929,7 @@ impl<'a> Parser<'a> {\n                         token::Shl =>     BiShl,\n                         token::Shr =>     BiShr\n                     };\n-                    let (lhs_span, rhs_span) = (lhs.span, rhs.span);\n+                    let (lhs_span, rhs_span) = (lhs_span, rhs.span);\n                     let aopexpr = self.mk_assign_op(codemap::respan(cur_op_span, aop), lhs, rhs);\n                     self.mk_expr(lhs_span.lo, rhs_span.hi, aopexpr, None)\n                 }\n@@ -3834,7 +3863,8 @@ impl<'a> Parser<'a> {\n                             let e = self.mk_mac_expr(span.lo, span.hi,\n                                                      mac.and_then(|m| m.node),\n                                                      None);\n-                            let e = try!(self.parse_dot_or_call_expr_with(e, attrs));\n+                            let lo = e.span.lo;\n+                            let e = try!(self.parse_dot_or_call_expr_with(e, lo, attrs));\n                             let e = try!(self.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(e)));\n                             try!(self.handle_expression_like_statement(\n                                 e,"}, {"sha": "220d0aff2e3af64ae6c1020b0827631838dd9d76", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8256c470a5ec80509071a70dcfba76666c855a1e/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8256c470a5ec80509071a70dcfba76666c855a1e/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=8256c470a5ec80509071a70dcfba76666c855a1e", "patch": "@@ -223,6 +223,14 @@ impl Token {\n         }\n     }\n \n+    /// Returns `true` if the token is interpolated.\n+    pub fn is_interpolated(&self) -> bool {\n+        match *self {\n+            Interpolated(..) => true,\n+            _                => false,\n+        }\n+    }\n+\n     /// Returns `true` if the token is an interpolated path.\n     pub fn is_path(&self) -> bool {\n         match *self {"}, {"sha": "4aacb6840e9d51f22a578ba7c8cc950c08aed1e5", "filename": "src/test/compile-fail/issue-25385.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8256c470a5ec80509071a70dcfba76666c855a1e/src%2Ftest%2Fcompile-fail%2Fissue-25385.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8256c470a5ec80509071a70dcfba76666c855a1e/src%2Ftest%2Fcompile-fail%2Fissue-25385.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-25385.rs?ref=8256c470a5ec80509071a70dcfba76666c855a1e", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+macro_rules! foo {\n+    ($e:expr) => { $e.foo() }\n+    //~^ ERROR no method named `foo` found for type `i32` in the current scope\n+}\n+\n+fn main() {\n+    let a = 1i32;\n+    foo!(a);\n+    //~^ NOTE in this expansion of foo!\n+\n+    foo!(1i32.foo());\n+    //~^ ERROR no method named `foo` found for type `i32` in the current scope\n+}"}, {"sha": "297d3aacfd51e987710ee7a08e14a1d234452b6b", "filename": "src/test/compile-fail/issue-25386.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8256c470a5ec80509071a70dcfba76666c855a1e/src%2Ftest%2Fcompile-fail%2Fissue-25386.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8256c470a5ec80509071a70dcfba76666c855a1e/src%2Ftest%2Fcompile-fail%2Fissue-25386.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-25386.rs?ref=8256c470a5ec80509071a70dcfba76666c855a1e", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod stuff {\n+    pub struct Item {\n+        c_object: Box<CObj>,\n+    }\n+    pub struct CObj {\n+        name: Option<String>,\n+    }\n+    impl Item {\n+        pub fn new() -> Item {\n+            Item {\n+                c_object: Box::new(CObj { name: None }),\n+            }\n+        }\n+    }\n+}\n+\n+macro_rules! check_ptr_exist {\n+    ($var:expr, $member:ident) => (\n+        (*$var.c_object).$member.is_some()\n+        //~^ ERROR field `name` of struct `stuff::CObj` is private\n+        //~^^ ERROR field `c_object` of struct `stuff::Item` is private\n+    );\n+}\n+\n+fn main() {\n+    let item = stuff::Item::new();\n+    println!(\"{}\", check_ptr_exist!(item, name));\n+    //~^ NOTE in this expansion of check_ptr_exist!\n+    //~^^ NOTE in this expansion of check_ptr_exist!\n+}"}, {"sha": "fd3e3186bc5c9b020c0b2b07df3745f6efb6bb42", "filename": "src/test/compile-fail/issue-25793.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8256c470a5ec80509071a70dcfba76666c855a1e/src%2Ftest%2Fcompile-fail%2Fissue-25793.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8256c470a5ec80509071a70dcfba76666c855a1e/src%2Ftest%2Fcompile-fail%2Fissue-25793.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-25793.rs?ref=8256c470a5ec80509071a70dcfba76666c855a1e", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+macro_rules! width(\n+    ($this:expr) => {\n+        $this.width.unwrap()\n+        //~^ ERROR cannot use `self.width` because it was mutably borrowed\n+    }\n+);\n+\n+struct HasInfo {\n+    width: Option<usize>\n+}\n+\n+impl HasInfo {\n+    fn get_size(&mut self, n: usize) -> usize {\n+        n\n+    }\n+\n+    fn get_other(&mut self) -> usize {\n+        self.get_size(width!(self))\n+        //~^ NOTE in this expansion of width!\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "2f43388b7afb08790aa6c61ffc86235b68f5e811", "filename": "src/test/compile-fail/issue-26093.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8256c470a5ec80509071a70dcfba76666c855a1e/src%2Ftest%2Fcompile-fail%2Fissue-26093.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8256c470a5ec80509071a70dcfba76666c855a1e/src%2Ftest%2Fcompile-fail%2Fissue-26093.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-26093.rs?ref=8256c470a5ec80509071a70dcfba76666c855a1e", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+macro_rules! not_an_lvalue {\n+    ($thing:expr) => {\n+        $thing = 42;\n+        //~^ ERROR invalid left-hand side expression\n+    }\n+}\n+\n+fn main() {\n+    not_an_lvalue!(99);\n+    //~^ NOTE in this expansion of not_an_lvalue!\n+}"}, {"sha": "99add95e806f6458c5bd6e8fb17de655f8c6b959", "filename": "src/test/compile-fail/issue-26094.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8256c470a5ec80509071a70dcfba76666c855a1e/src%2Ftest%2Fcompile-fail%2Fissue-26094.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8256c470a5ec80509071a70dcfba76666c855a1e/src%2Ftest%2Fcompile-fail%2Fissue-26094.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-26094.rs?ref=8256c470a5ec80509071a70dcfba76666c855a1e", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+macro_rules! some_macro {\n+    ($other: expr) => ({\n+        $other(None)\n+        //~^ this function takes 0 parameters but 1 parameter was supplied\n+    })\n+}\n+\n+fn some_function() {}\n+\n+fn main() {\n+    some_macro!(some_function);\n+    //~^ in this expansion of some_macro!\n+}"}, {"sha": "11e236d22126b3638504f4bb00019c4529d220bf", "filename": "src/test/compile-fail/issue-26237.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8256c470a5ec80509071a70dcfba76666c855a1e/src%2Ftest%2Fcompile-fail%2Fissue-26237.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8256c470a5ec80509071a70dcfba76666c855a1e/src%2Ftest%2Fcompile-fail%2Fissue-26237.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-26237.rs?ref=8256c470a5ec80509071a70dcfba76666c855a1e", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+macro_rules! macro_panic {\n+    ($not_a_function:expr, $some_argument:ident) => {\n+        $not_a_function($some_argument)\n+        //~^ ERROR expected function, found `_`\n+    }\n+}\n+\n+fn main() {\n+    let mut value_a = 0;\n+    let mut value_b = 0;\n+    macro_panic!(value_a, value_b);\n+    //~^ in this expansion of macro_panic!\n+}"}, {"sha": "903df42291c6317efbdb83ced40661d5f76912f0", "filename": "src/test/compile-fail/issue-26480.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/8256c470a5ec80509071a70dcfba76666c855a1e/src%2Ftest%2Fcompile-fail%2Fissue-26480.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8256c470a5ec80509071a70dcfba76666c855a1e/src%2Ftest%2Fcompile-fail%2Fissue-26480.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-26480.rs?ref=8256c470a5ec80509071a70dcfba76666c855a1e", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern {\n+    fn write(fildes: i32, buf: *const i8, nbyte: u64) -> i64;\n+}\n+\n+#[inline(always)]\n+fn size_of<T>(_: T) -> usize {\n+    ::std::mem::size_of::<T>()\n+}\n+\n+macro_rules! write {\n+    ($arr:expr) => {{\n+        #[allow(non_upper_case_globals)]\n+        const stdout: i32 = 1;\n+        unsafe {\n+            write(stdout, $arr.as_ptr() as *const i8,\n+                  $arr.len() * size_of($arr[0]));\n+            //~^ ERROR mismatched types\n+        }\n+    }}\n+}\n+\n+macro_rules! cast {\n+    ($x:expr) => ($x as ())\n+    //~^ ERROR non-scalar cast: `i32` as `()`\n+}\n+\n+fn main() {\n+    let hello = ['H', 'e', 'y'];\n+    write!(hello);\n+    //~^ NOTE in this expansion of write!\n+\n+    cast!(2);\n+    //~^ NOTE in this expansion of cast!\n+}"}, {"sha": "b0c44b5f33af1711deaaa62e4288d9f051f4764b", "filename": "src/test/compile-fail/issue-28308.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8256c470a5ec80509071a70dcfba76666c855a1e/src%2Ftest%2Fcompile-fail%2Fissue-28308.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8256c470a5ec80509071a70dcfba76666c855a1e/src%2Ftest%2Fcompile-fail%2Fissue-28308.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-28308.rs?ref=8256c470a5ec80509071a70dcfba76666c855a1e", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// this error is dispayed in `<std macros>`\n+// error-pattern:cannot apply unary operator `!` to type `&'static str`\n+// error-pattern:in this expansion of assert!\n+\n+fn main() {\n+    assert!(\"foo\");\n+}"}, {"sha": "78913e759a1cc080a019a9985fd6dfaaaaf96dd8", "filename": "src/test/compile-fail/issue-29084.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8256c470a5ec80509071a70dcfba76666c855a1e/src%2Ftest%2Fcompile-fail%2Fissue-29084.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8256c470a5ec80509071a70dcfba76666c855a1e/src%2Ftest%2Fcompile-fail%2Fissue-29084.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-29084.rs?ref=8256c470a5ec80509071a70dcfba76666c855a1e", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+macro_rules! foo {\n+    ($d:expr) => {{\n+        fn bar(d: u8) { }\n+        bar(&mut $d);\n+        //~^ ERROR mismatched types\n+    }}\n+}\n+\n+fn main() {\n+    foo!(0u8);\n+    //~^ NOTE in this expansion of foo!\n+}"}, {"sha": "b828b11030d712722f30ee76d155fd56445b533c", "filename": "src/test/compile-fail/issue-31011.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/8256c470a5ec80509071a70dcfba76666c855a1e/src%2Ftest%2Fcompile-fail%2Fissue-31011.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8256c470a5ec80509071a70dcfba76666c855a1e/src%2Ftest%2Fcompile-fail%2Fissue-31011.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-31011.rs?ref=8256c470a5ec80509071a70dcfba76666c855a1e", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+macro_rules! log {\n+    ( $ctx:expr, $( $args:expr),* ) => {\n+        if $ctx.trace {\n+        //~^ ERROR attempted access of field `trace` on type `&T`, but no field with that name\n+            println!( $( $args, )* );\n+        }\n+    }\n+}\n+\n+// Create a structure.\n+struct Foo {\n+  trace: bool,\n+}\n+\n+// Generic wrapper calls log! with a structure.\n+fn wrap<T>(context: &T) -> ()\n+{\n+    log!(context, \"entered wrapper\");\n+    //~^ in this expansion of log!\n+}\n+\n+fn main() {\n+    // Create a structure.\n+    let x = Foo { trace: true };\n+    log!(x, \"run started\");\n+    // Apply a closure which accesses internal fields.\n+    wrap(&x);\n+    log!(x, \"run finished\");\n+}"}]}