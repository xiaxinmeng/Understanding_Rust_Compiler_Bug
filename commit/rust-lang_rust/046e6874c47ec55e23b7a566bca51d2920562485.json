{"sha": "046e6874c47ec55e23b7a566bca51d2920562485", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0NmU2ODc0YzQ3ZWM1NWUyM2I3YTU2NmJjYTUxZDI5MjA1NjI0ODU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-11-19T23:20:12Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-02-11T18:42:28Z"}, "message": "Add a Cargo-based build system\n\nThis commit is the start of a series of commits which start to replace the\nmakefiles with a Cargo-based build system. The aim is not to remove the\nmakefiles entirely just yet but rather just replace the portions that invoke the\ncompiler to do the bootstrap. This commit specifically adds enough support to\nperform the bootstrap (and all the cross compilation within) along with\ngenerating documentation.\n\nMore commits will follow up in this series to actually wire up the makefiles to\ncall this build system, so stay tuned!", "tree": {"sha": "6775c618f253d3851738f8d5572f204c0ec7db8d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6775c618f253d3851738f8d5572f204c0ec7db8d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/046e6874c47ec55e23b7a566bca51d2920562485", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/046e6874c47ec55e23b7a566bca51d2920562485", "html_url": "https://github.com/rust-lang/rust/commit/046e6874c47ec55e23b7a566bca51d2920562485", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/046e6874c47ec55e23b7a566bca51d2920562485/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a91ff1c9d1842918329ef7a81afd3848854d53c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/a91ff1c9d1842918329ef7a81afd3848854d53c7", "html_url": "https://github.com/rust-lang/rust/commit/a91ff1c9d1842918329ef7a81afd3848854d53c7"}], "stats": {"total": 3325, "additions": 3324, "deletions": 1}, "files": [{"sha": "b6f5f04bff62fc209f6f42654cba6079df8270ef", "filename": ".gitignore", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/046e6874c47ec55e23b7a566bca51d2920562485/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/046e6874c47ec55e23b7a566bca51d2920562485/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=046e6874c47ec55e23b7a566bca51d2920562485", "patch": "@@ -93,3 +93,4 @@ tmp.*.rs\n version.md\n version.ml\n version.texi\n+/target"}, {"sha": "f9593eb1609d8bb10bff8696298ecdff3c273b4d", "filename": "src/bootstrap/Cargo.lock", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/046e6874c47ec55e23b7a566bca51d2920562485/src%2Fbootstrap%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/046e6874c47ec55e23b7a566bca51d2920562485/src%2Fbootstrap%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.lock?ref=046e6874c47ec55e23b7a566bca51d2920562485", "patch": "@@ -0,0 +1,109 @@\n+[root]\n+name = \"bootstrap\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"build_helper 0.1.0\",\n+ \"cmake 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"filetime 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"kernel32-sys 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num_cpus 0.2.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-serialize 0.3.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"toml 0.1.23 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.2.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"advapi32-sys\"\n+version = \"0.1.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"winapi 0.2.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"build_helper\"\n+version = \"0.1.0\"\n+\n+[[package]]\n+name = \"cmake\"\n+version = \"0.1.10\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"gcc 0.3.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"filetime\"\n+version = \"0.1.8\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"kernel32-sys 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.2.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"gcc\"\n+version = \"0.3.19\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"advapi32-sys 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.2.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"getopts\"\n+version = \"0.2.14\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"kernel32-sys\"\n+version = \"0.2.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"winapi 0.2.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"libc\"\n+version = \"0.2.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"num_cpus\"\n+version = \"0.2.9\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"kernel32-sys 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.2.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"rustc-serialize\"\n+version = \"0.3.16\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"toml\"\n+version = \"0.1.23\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"rustc-serialize 0.3.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"winapi\"\n+version = \"0.2.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"winapi-build\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+"}, {"sha": "8321f93c90f61f23e039ffda2cc0b8e73cee57c5", "filename": "src/bootstrap/Cargo.toml", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/046e6874c47ec55e23b7a566bca51d2920562485/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/046e6874c47ec55e23b7a566bca51d2920562485/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=046e6874c47ec55e23b7a566bca51d2920562485", "patch": "@@ -0,0 +1,29 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"bootstrap\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"bootstrap\"\n+path = \"lib.rs\"\n+\n+[[bin]]\n+name = \"bootstrap\"\n+path = \"main.rs\"\n+\n+[[bin]]\n+name = \"rustc\"\n+path = \"rustc.rs\"\n+\n+[dependencies]\n+build_helper = { path = \"../build_helper\" }\n+cmake = \"0.1.10\"\n+filetime = \"0.1\"\n+num_cpus = \"0.2\"\n+toml = \"0.1\"\n+getopts = \"0.2\"\n+rustc-serialize = \"0.3\"\n+winapi = \"0.2\"\n+kernel32-sys = \"0.2\"\n+gcc = \"0.3.17\"\n+libc = \"0.2\""}, {"sha": "9e97ec4da0769ecd5d6ef5fd0ba186f385b306c4", "filename": "src/bootstrap/README.md", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/046e6874c47ec55e23b7a566bca51d2920562485/src%2Fbootstrap%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/046e6874c47ec55e23b7a566bca51d2920562485/src%2Fbootstrap%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FREADME.md?ref=046e6874c47ec55e23b7a566bca51d2920562485", "patch": "@@ -0,0 +1,110 @@\n+# Bootstrapping Rust\n+\n+This is an in-progress README which is targeted at helping to explain how Rust\n+is bootstrapped and in general some of the technical details of the build\n+system.\n+\n+> **Note**: This build system is currently under active development and is not\n+> intended to be the primarily used one just yet. The makefiles are currently\n+> the ones that are still \"guaranteed to work\" as much as possible at least.\n+\n+## Using the new build system\n+\n+When configuring Rust via `./configure`, pass the following to enable building\n+via this build system:\n+\n+```\n+./configure --enable-rustbuild\n+```\n+\n+## ...\n+\n+## Directory Layout\n+\n+This build system houses all output under the `target` directory, which looks\n+like this:\n+\n+```\n+# Root folder of all output. Everything is scoped underneath here\n+build/\n+\n+  # Location where the stage0 compiler downloads are all cached. This directory\n+  # only contains the tarballs themselves as they're extracted elsewhere.\n+  cache/\n+    2015-12-19/\n+    2016-01-15/\n+    2016-01-21/\n+    ...\n+\n+  # Output directory for building this build system itself. The stage0\n+  # cargo/rustc are used to build the build system into this location.\n+  bootstrap/\n+    debug/\n+    release/\n+\n+  # Each remaining directory is scoped by the \"host\" triple of compilation at\n+  # hand.\n+  x86_64-unknown-linux-gnu/\n+\n+    # The build artifacts for the `compiler-rt` library for the target this\n+    # folder is under. The exact layout here will likely depend on the platform,\n+    # and this is also built with CMake so the build system is also likely\n+    # different.\n+    compiler-rt/build/\n+\n+    # Output folder for LLVM if it is compiled for this target\n+    llvm/\n+\n+      # build folder (e.g. the platform-specific build system). Like with\n+      # compiler-rt this is compiled with CMake\n+      build/\n+\n+      # Installation of LLVM. Note that we run the equivalent of 'make install'\n+      # for LLVM to setup these folders.\n+      bin/\n+      lib/\n+      include/\n+      share/\n+      ...\n+\n+    # Location where the stage0 Cargo and Rust compiler are unpacked. This\n+    # directory is purely an extracted and overlaid tarball of these two (done\n+    # by the bootstrapy python script). In theory the build system does not\n+    # modify anything under this directory afterwards.\n+    stage0/\n+\n+    # These to build directories are the cargo output directories for builds of\n+    # the standard library and compiler, respectively. Internally these may also\n+    # have other target directories, which represent artifacts being compiled\n+    # from the host to the specified target.\n+    #\n+    # Essentially, each of these directories is filled in by one `cargo`\n+    # invocation. The build system instruments calling Cargo in the right order\n+    # with the right variables to ensure these are filled in correctly.\n+    stageN-std/\n+    stageN-rustc/\n+\n+    # This is a special case of the above directories, **not** filled in via\n+    # Cargo but rather the build system itself. The stage0 compiler already has\n+    # a set of target libraries for its own host triple (in its own sysroot)\n+    # inside of stage0/. When we run the stage0 compiler to bootstrap more\n+    # things, however, we don't want to use any of these libraries (as those are\n+    # the ones that we're building). So essentially, when the stage1 compiler is\n+    # being compiled (e.g. after libstd has been built), *this* is used as the\n+    # sysroot for the stage0 compiler being run.\n+    #\n+    # Basically this directory is just a temporary artifact use to configure the\n+    # stage0 compiler to ensure that the libstd we just built is used to\n+    # compile the stage1 compiler.\n+    stage0-rustc/lib/\n+\n+    # These output directories are intended to be standalone working\n+    # implementations of the compiler (corresponding to each stage). The build\n+    # system will link (using hard links) output from stageN-{std,rustc} into\n+    # each of these directories.\n+    #\n+    # In theory there is no extra build output in these directories.\n+    stage1/\n+    stage2/\n+    stage3/\n+```"}, {"sha": "435304645459da98116d5c56fd8b02ceb5eb80a1", "filename": "src/bootstrap/bootstrap.py", "status": "added", "additions": 300, "deletions": 0, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/046e6874c47ec55e23b7a566bca51d2920562485/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/046e6874c47ec55e23b7a566bca51d2920562485/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=046e6874c47ec55e23b7a566bca51d2920562485", "patch": "@@ -0,0 +1,300 @@\n+# Copyright 2015-2016 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+import argparse\n+import contextlib\n+import os\n+import shutil\n+import subprocess\n+import sys\n+import tarfile\n+\n+def get(url, path, verbose=False):\n+    print(\"downloading \" + url)\n+    # see http://serverfault.com/questions/301128/how-to-download\n+    if sys.platform == 'win32':\n+        run([\"PowerShell.exe\", \"/nologo\", \"-Command\",\n+             \"(New-Object System.Net.WebClient).DownloadFile('\" + url +\n+                \"', '\" + path + \"')\"], verbose=verbose)\n+    else:\n+        run([\"curl\", \"-o\", path, url], verbose=verbose)\n+\n+def unpack(tarball, dst, verbose=False, match=None):\n+    print(\"extracting \" + tarball)\n+    fname = os.path.basename(tarball).replace(\".tar.gz\", \"\")\n+    with contextlib.closing(tarfile.open(tarball)) as tar:\n+        for p in tar.getnames():\n+            if \"/\" not in p:\n+                continue\n+            name = p.replace(fname + \"/\", \"\", 1)\n+            if match is not None and not name.startswith(match):\n+                continue\n+            name = name[len(match) + 1:]\n+\n+            fp = os.path.join(dst, name)\n+            if verbose:\n+                print(\"  extracting \" + p)\n+            tar.extract(p, dst)\n+            tp = os.path.join(dst, p)\n+            if os.path.isdir(tp) and os.path.exists(fp):\n+                continue\n+            shutil.move(tp, fp)\n+    shutil.rmtree(os.path.join(dst, fname))\n+\n+def run(args, verbose=False):\n+    if verbose:\n+        print(\"running: \" + ' '.join(args))\n+    sys.stdout.flush()\n+    # Use Popen here instead of call() as it apparently allows powershell on\n+    # Windows to not lock up waiting for input presumably.\n+    ret = subprocess.Popen(args)\n+    code = ret.wait()\n+    if code != 0:\n+        if not verbose:\n+            print(\"failed to run: \" + ' '.join(args))\n+        raise RuntimeError(\"failed to run command\")\n+\n+class RustBuild:\n+    def download_rust_nightly(self):\n+        cache_dst = os.path.join(self.build_dir, \"cache\")\n+        rustc_cache = os.path.join(cache_dst, self.snap_rustc_date())\n+        cargo_cache = os.path.join(cache_dst, self.snap_cargo_date())\n+        if not os.path.exists(rustc_cache):\n+            os.makedirs(rustc_cache)\n+        if not os.path.exists(cargo_cache):\n+            os.makedirs(cargo_cache)\n+\n+        if self.rustc().startswith(self.bin_root()) and \\\n+           (not os.path.exists(self.rustc()) or self.rustc_out_of_date()):\n+            filename = \"rust-std-nightly-\" + self.build + \".tar.gz\"\n+            url = \"https://static.rust-lang.org/dist/\" + self.snap_rustc_date()\n+            tarball = os.path.join(rustc_cache, filename)\n+            if not os.path.exists(tarball):\n+                get(url + \"/\" + filename, tarball, verbose=self.verbose)\n+            unpack(tarball, self.bin_root(),\n+                   match=\"rust-std-\" + self.build,\n+                   verbose=self.verbose)\n+\n+            filename = \"rustc-nightly-\" + self.build + \".tar.gz\"\n+            url = \"https://static.rust-lang.org/dist/\" + self.snap_rustc_date()\n+            tarball = os.path.join(rustc_cache, filename)\n+            if not os.path.exists(tarball):\n+                get(url + \"/\" + filename, tarball, verbose=self.verbose)\n+            unpack(tarball, self.bin_root(), match=\"rustc\", verbose=self.verbose)\n+            with open(self.rustc_stamp(), 'w') as f:\n+                f.write(self.snap_rustc_date())\n+\n+        if self.cargo().startswith(self.bin_root()) and \\\n+           (not os.path.exists(self.cargo()) or self.cargo_out_of_date()):\n+            filename = \"cargo-nightly-\" + self.build + \".tar.gz\"\n+            url = \"https://static.rust-lang.org/cargo-dist/\" + self.snap_cargo_date()\n+            tarball = os.path.join(cargo_cache, filename)\n+            if not os.path.exists(tarball):\n+                get(url + \"/\" + filename, tarball, verbose=self.verbose)\n+            unpack(tarball, self.bin_root(), match=\"cargo\", verbose=self.verbose)\n+            with open(self.cargo_stamp(), 'w') as f:\n+                f.write(self.snap_cargo_date())\n+\n+    def snap_cargo_date(self):\n+        return self._cargo_date\n+\n+    def snap_rustc_date(self):\n+        return self._rustc_date\n+\n+    def rustc_stamp(self):\n+        return os.path.join(self.bin_root(), '.rustc-stamp')\n+\n+    def cargo_stamp(self):\n+        return os.path.join(self.bin_root(), '.cargo-stamp')\n+\n+    def rustc_out_of_date(self):\n+        if not os.path.exists(self.rustc_stamp()):\n+            return True\n+        with open(self.rustc_stamp(), 'r') as f:\n+            return self.snap_rustc_date() != f.read()\n+\n+    def cargo_out_of_date(self):\n+        if not os.path.exists(self.cargo_stamp()):\n+            return True\n+        with open(self.cargo_stamp(), 'r') as f:\n+            return self.snap_cargo_date() != f.read()\n+\n+    def bin_root(self):\n+        return os.path.join(self.build_dir, self.build, \"stage0\")\n+\n+    def get_toml(self, key):\n+        for line in self.config_toml.splitlines():\n+            if line.startswith(key + ' ='):\n+                return self.get_string(line)\n+        return None\n+\n+    def cargo(self):\n+        config = self.get_toml('cargo')\n+        if config:\n+            return config\n+        return os.path.join(self.bin_root(), \"bin/cargo\" + self.exe_suffix())\n+\n+    def rustc(self):\n+        config = self.get_toml('rustc')\n+        if config:\n+            return config\n+        return os.path.join(self.bin_root(), \"bin/rustc\" + self.exe_suffix())\n+\n+    def get_string(self, line):\n+        start = line.find('\"')\n+        end = start + 1 + line[start+1:].find('\"')\n+        return line[start+1:end]\n+\n+    def exe_suffix(self):\n+        if sys.platform == 'win32':\n+            return '.exe'\n+        else:\n+            return ''\n+\n+    def parse_nightly_dates(self):\n+        nightlies = os.path.join(self.rust_root, \"src/nightlies.txt\")\n+        with open(nightlies, 'r') as nightlies:\n+            rustc, cargo = nightlies.read().split(\"\\n\")[:2]\n+            assert rustc.startswith(\"rustc: \")\n+            assert cargo.startswith(\"cargo: \")\n+            self._rustc_date = rustc[len(\"rustc: \"):]\n+            self._cargo_date = cargo[len(\"cargo: \"):]\n+\n+    def build_bootstrap(self):\n+        env = os.environ.copy()\n+        env[\"CARGO_TARGET_DIR\"] = os.path.join(self.build_dir, \"bootstrap\")\n+        env[\"RUSTC\"] = self.rustc()\n+        env[\"LD_LIBRARY_PATH\"] = os.path.join(self.bin_root(), \"lib\")\n+        env[\"DYLD_LIBRARY_PATH\"] = os.path.join(self.bin_root(), \"lib\")\n+        env[\"PATH\"] = os.path.join(self.bin_root(), \"bin\") + \\\n+                      os.pathsep + env[\"PATH\"]\n+        self.run([self.cargo(), \"build\", \"--manifest-path\",\n+                  os.path.join(self.rust_root, \"src/bootstrap/Cargo.toml\")],\n+                 env)\n+\n+    def run(self, args, env):\n+        proc = subprocess.Popen(args, env = env)\n+        ret = proc.wait()\n+        if ret != 0:\n+            sys.exit(ret)\n+\n+    def build_triple(self):\n+        config = self.get_toml('build')\n+        if config:\n+            return config\n+        try:\n+            ostype = subprocess.check_output(['uname', '-s']).strip()\n+            cputype = subprocess.check_output(['uname', '-m']).strip()\n+        except FileNotFoundError:\n+            if sys.platform == 'win32':\n+                return 'x86_64-pc-windows-msvc'\n+            else:\n+                raise\n+\n+        # Darwin's `uname -s` lies and always returns i386. We have to use\n+        # sysctl instead.\n+        if ostype == 'Darwin' and cputype == 'i686':\n+            sysctl = subprocess.check_output(['sysctl', 'hw.optional.x86_64'])\n+            if sysctl.contains(': 1'):\n+                cputype = 'x86_64'\n+\n+        # The goal here is to come up with the same triple as LLVM would,\n+        # at least for the subset of platforms we're willing to target.\n+        if ostype == 'Linux':\n+            ostype = 'unknown-linux-gnu'\n+        elif ostype == 'FreeBSD':\n+            ostype = 'unknown-freebsd'\n+        elif ostype == 'DragonFly':\n+            ostype = 'unknown-dragonfly'\n+        elif ostype == 'Bitrig':\n+            ostype = 'unknown-bitrig'\n+        elif ostype == 'OpenBSD':\n+            ostype = 'unknown-openbsd'\n+        elif ostype == 'NetBSD':\n+            ostype = 'unknown-netbsd'\n+        elif ostype == 'Darwin':\n+            ostype = 'apple-darwin'\n+        elif ostype.startswith('MINGW'):\n+            # msys' `uname` does not print gcc configuration, but prints msys\n+            # configuration. so we cannot believe `uname -m`:\n+            # msys1 is always i686 and msys2 is always x86_64.\n+            # instead, msys defines $MSYSTEM which is MINGW32 on i686 and\n+            # MINGW64 on x86_64.\n+            ostype = 'pc-windows-gnu'\n+            cputype = 'i686'\n+            if os.environ.get('MSYSTEM') == 'MINGW64':\n+                cputype = 'x86_64'\n+        elif ostype.startswith('MSYS'):\n+            ostype = 'pc-windows-gnu'\n+        elif ostype.startswith('CYGWIN_NT'):\n+            cputype = 'i686'\n+            if ostype.endswith('WOW64'):\n+                cputype = 'x86_64'\n+            ostype = 'pc-windows-gnu'\n+        else:\n+            raise ValueError(\"unknown OS type: \" + ostype)\n+\n+        if cputype in {'i386', 'i486', 'i686', 'i786', 'x86'}:\n+            cputype = 'i686'\n+        elif cputype in {'xscale', 'arm'}:\n+            cputype = 'arm'\n+        elif cputype == 'armv7l':\n+            cputype = 'arm'\n+            ostype += 'eabihf'\n+        elif cputype == 'aarch64':\n+            cputype = 'aarch64'\n+        elif cputype in {'powerpc', 'ppc', 'ppc64'}:\n+            cputype = 'powerpc'\n+        elif cputype in {'amd64', 'x86_64', 'x86-64', 'x64'}:\n+            cputype = 'x86_64'\n+        else:\n+            raise ValueError(\"unknown cpu type: \" + cputype)\n+\n+        return cputype + '-' + ostype\n+\n+parser = argparse.ArgumentParser(description='Build rust')\n+parser.add_argument('--config')\n+parser.add_argument('-v', '--verbose', action='store_true')\n+\n+args = [a for a in sys.argv if a != '-h']\n+args, _ = parser.parse_known_args(args)\n+\n+# Configure initial bootstrap\n+rb = RustBuild()\n+rb.config_toml = ''\n+rb.config_mk = ''\n+rb.rust_root = os.path.abspath(os.path.join(__file__, '../../..'))\n+rb.build_dir = os.path.join(os.getcwd(), \"build\")\n+rb.verbose = args.verbose\n+\n+try:\n+    with open(args.config or 'config.toml') as config:\n+        rb.config_toml = config.read()\n+except:\n+    pass\n+\n+# Fetch/build the bootstrap\n+rb.build = rb.build_triple()\n+rb.parse_nightly_dates()\n+rb.download_rust_nightly()\n+sys.stdout.flush()\n+rb.build_bootstrap()\n+sys.stdout.flush()\n+\n+# Run the bootstrap\n+args = [os.path.join(rb.build_dir, \"bootstrap/debug/bootstrap\")]\n+args.extend(sys.argv[1:])\n+args.append('--src')\n+args.append(rb.rust_root)\n+args.append('--build')\n+args.append(rb.build)\n+env = os.environ.copy()\n+env[\"BOOTSTRAP_PARENT_ID\"] = str(os.getpid())\n+rb.run(args, env)"}, {"sha": "9f962e9d9e61a2b5c5ed710bb5fc7459a15b9e25", "filename": "src/bootstrap/build/cc.rs", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/046e6874c47ec55e23b7a566bca51d2920562485/src%2Fbootstrap%2Fbuild%2Fcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/046e6874c47ec55e23b7a566bca51d2920562485/src%2Fbootstrap%2Fbuild%2Fcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fcc.rs?ref=046e6874c47ec55e23b7a566bca51d2920562485", "patch": "@@ -0,0 +1,98 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::process::Command;\n+\n+use build_helper::{cc2ar, output};\n+use gcc;\n+\n+use build::Build;\n+use build::config::Target;\n+\n+pub fn find(build: &mut Build) {\n+    // For all targets we're going to need a C compiler for building some shims\n+    // and such as well as for being a linker for Rust code.\n+    for target in build.config.target.iter() {\n+        let mut cfg = gcc::Config::new();\n+        cfg.cargo_metadata(false).opt_level(0).debug(false)\n+           .target(target).host(&build.config.build);\n+\n+        let config = build.config.target_config.get(target);\n+        if let Some(cc) = config.and_then(|c| c.cc.as_ref()) {\n+            cfg.compiler(cc);\n+        } else {\n+            set_compiler(&mut cfg, \"gcc\", target, config);\n+        }\n+\n+        let compiler = cfg.get_compiler();\n+        let ar = cc2ar(compiler.path(), target);\n+        build.verbose(&format!(\"CC_{} = {:?}\", target, compiler.path()));\n+        build.verbose(&format!(\"AR_{} = {:?}\", target, ar));\n+        build.cc.insert(target.to_string(), (compiler, ar));\n+    }\n+\n+    // For all host triples we need to find a C++ compiler as well\n+    for host in build.config.host.iter() {\n+        let mut cfg = gcc::Config::new();\n+        cfg.cargo_metadata(false).opt_level(0).debug(false).cpp(true)\n+           .target(host).host(&build.config.build);\n+        let config = build.config.target_config.get(host);\n+        if let Some(cxx) = config.and_then(|c| c.cxx.as_ref()) {\n+            cfg.compiler(cxx);\n+        } else {\n+            set_compiler(&mut cfg, \"g++\", host, config);\n+        }\n+        let compiler = cfg.get_compiler();\n+        build.verbose(&format!(\"CXX_{} = {:?}\", host, compiler.path()));\n+        build.cxx.insert(host.to_string(), compiler);\n+    }\n+}\n+\n+fn set_compiler(cfg: &mut gcc::Config,\n+                gnu_compiler: &str,\n+                target: &str,\n+                config: Option<&Target>) {\n+    match target {\n+        // When compiling for android we may have the NDK configured in the\n+        // config.toml in which case we look there. Otherwise the default\n+        // compiler already takes into account the triple in question.\n+        t if t.contains(\"android\") => {\n+            if let Some(ndk) = config.and_then(|c| c.ndk.as_ref()) {\n+                let compiler = format!(\"{}-{}\", target, gnu_compiler);\n+                cfg.compiler(ndk.join(\"bin\").join(compiler));\n+            }\n+        }\n+\n+        // The default gcc version from OpenBSD may be too old, try using egcc,\n+        // which is a gcc version from ports, if this is the case.\n+        t if t.contains(\"openbsd\") => {\n+            let c = cfg.get_compiler();\n+            if !c.path().ends_with(gnu_compiler) {\n+                return\n+            }\n+\n+            let output = output(c.to_command().arg(\"--version\"));\n+            let i = match output.find(\" 4.\") {\n+                Some(i) => i,\n+                None => return,\n+            };\n+            match output[i + 3..].chars().next().unwrap() {\n+                '0' ... '6' => {}\n+                _ => return,\n+            }\n+            let alternative = format!(\"e{}\", gnu_compiler);\n+            if Command::new(&alternative).output().is_ok() {\n+                cfg.compiler(alternative);\n+            }\n+        }\n+\n+        _ => {}\n+    }\n+}"}, {"sha": "628b1d764320b845f01030d9264b3511e1bc16f2", "filename": "src/bootstrap/build/channel.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/046e6874c47ec55e23b7a566bca51d2920562485/src%2Fbootstrap%2Fbuild%2Fchannel.rs", "raw_url": "https://github.com/rust-lang/rust/raw/046e6874c47ec55e23b7a566bca51d2920562485/src%2Fbootstrap%2Fbuild%2Fchannel.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fchannel.rs?ref=046e6874c47ec55e23b7a566bca51d2920562485", "patch": "@@ -0,0 +1,82 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::fs::{self, File};\n+use std::io::prelude::*;\n+use std::path::Path;\n+use std::process::Command;\n+\n+use build_helper::output;\n+\n+use build::Build;\n+use build::util::mtime;\n+\n+pub fn collect(build: &mut Build) {\n+    let mut main_mk = String::new();\n+    t!(t!(File::open(build.src.join(\"mk/main.mk\"))).read_to_string(&mut main_mk));\n+    let mut release_num = \"\";\n+    let mut prerelease_version = \"\";\n+    for line in main_mk.lines() {\n+        if line.starts_with(\"CFG_RELEASE_NUM\") {\n+            release_num = line.split('=').skip(1).next().unwrap().trim();\n+        }\n+        if line.starts_with(\"CFG_PRERELEASE_VERSION\") {\n+            prerelease_version = line.split('=').skip(1).next().unwrap().trim();\n+        }\n+    }\n+\n+    // FIXME: this is duplicating makefile logic\n+    match &build.config.channel[..] {\n+        \"stable\" => {\n+            build.release = release_num.to_string();\n+            build.unstable_features = false;\n+        }\n+        \"beta\" => {\n+            build.release = format!(\"{}-beta{}\", release_num,\n+                                   prerelease_version);\n+            build.unstable_features = false;\n+        }\n+        \"nightly\" => {\n+            build.release = format!(\"{}-nightly\", release_num);\n+            build.unstable_features = true;\n+        }\n+        _ => {\n+            build.release = format!(\"{}-dev\", release_num);\n+            build.unstable_features = true;\n+        }\n+    }\n+    build.version = build.release.clone();\n+\n+    if fs::metadata(build.src.join(\".git\")).is_ok() {\n+        let ver_date = output(Command::new(\"git\").current_dir(&build.src)\n+                                      .arg(\"log\").arg(\"-1\")\n+                                      .arg(\"--date=short\")\n+                                      .arg(\"--pretty=format:%cd\"));\n+        let ver_hash = output(Command::new(\"git\").current_dir(&build.src)\n+                                      .arg(\"rev-parse\").arg(\"HEAD\"));\n+        let short_ver_hash = output(Command::new(\"git\")\n+                                            .current_dir(&build.src)\n+                                            .arg(\"rev-parse\")\n+                                            .arg(\"--short=9\")\n+                                            .arg(\"HEAD\"));\n+        let ver_date = ver_date.trim().to_string();\n+        let ver_hash = ver_hash.trim().to_string();\n+        let short_ver_hash = short_ver_hash.trim().to_string();\n+        build.version.push_str(&format!(\" ({} {})\", short_ver_hash,\n+                                       ver_date));\n+        build.ver_date = Some(ver_date.to_string());\n+        build.ver_hash = Some(ver_hash);\n+        build.short_ver_hash = Some(short_ver_hash);\n+    }\n+\n+    build.bootstrap_key = mtime(Path::new(\"config.toml\")).seconds()\n+                                                        .to_string();\n+}\n+"}, {"sha": "05b444633b4cc1e2f825481257e4979c51c78e9a", "filename": "src/bootstrap/build/compile.rs", "status": "added", "additions": 248, "deletions": 0, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/046e6874c47ec55e23b7a566bca51d2920562485/src%2Fbootstrap%2Fbuild%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/046e6874c47ec55e23b7a566bca51d2920562485/src%2Fbootstrap%2Fbuild%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fcompile.rs?ref=046e6874c47ec55e23b7a566bca51d2920562485", "patch": "@@ -0,0 +1,248 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::collections::HashMap;\n+use std::fs;\n+use std::path::{Path, PathBuf};\n+use std::process::Command;\n+\n+use build_helper::output;\n+\n+use build::util::{exe, staticlib, libdir, mtime, is_dylib};\n+use build::{Build, Compiler};\n+\n+/// Build the standard library.\n+///\n+/// This will build the standard library for a particular stage of the build\n+/// using the `compiler` targeting the `target` architecture. The artifacts\n+/// created will also be linked into the sysroot directory.\n+pub fn std<'a>(build: &'a Build, stage: u32, target: &str,\n+               compiler: &Compiler<'a>) {\n+    let host = compiler.host;\n+    println!(\"Building stage{} std artifacts ({} -> {})\", stage,\n+             host, target);\n+\n+    // Move compiler-rt into place as it'll be required by the compiler when\n+    // building the standard library to link the dylib of libstd\n+    let libdir = build.sysroot_libdir(stage, &host, target);\n+    let _ = fs::remove_dir_all(&libdir);\n+    t!(fs::create_dir_all(&libdir));\n+    t!(fs::hard_link(&build.compiler_rt_built.borrow()[target],\n+                     libdir.join(staticlib(\"compiler-rt\", target))));\n+\n+    build_startup_objects(build, target, &libdir);\n+\n+    let out_dir = build.cargo_out(stage, &host, true, target);\n+    build.clear_if_dirty(&out_dir, &build.compiler_path(compiler));\n+    let mut cargo = build.cargo(stage, compiler, true, target, \"build\");\n+    cargo.arg(\"--features\").arg(build.std_features())\n+         .arg(\"--manifest-path\")\n+         .arg(build.src.join(\"src/rustc/std_shim/Cargo.toml\"));\n+\n+    if let Some(target) = build.config.target_config.get(target) {\n+        if let Some(ref jemalloc) = target.jemalloc {\n+            cargo.env(\"JEMALLOC_OVERRIDE\", jemalloc);\n+        }\n+    }\n+    if let Some(ref p) = build.config.musl_root {\n+        if target.contains(\"musl\") {\n+            cargo.env(\"MUSL_ROOT\", p);\n+        }\n+    }\n+\n+    build.run(&mut cargo);\n+    add_to_sysroot(&out_dir, &libdir);\n+}\n+\n+/// Build and prepare startup objects like rsbegin.o and rsend.o\n+///\n+/// These are primarily used on Windows right now for linking executables/dlls.\n+/// They don't require any library support as they're just plain old object\n+/// files, so we just use the nightly snapshot compiler to always build them (as\n+/// no other compilers are guaranteed to be available).\n+fn build_startup_objects(build: &Build, target: &str, into: &Path) {\n+    if !target.contains(\"pc-windows-gnu\") {\n+        return\n+    }\n+    let compiler = Compiler::new(0, &build.config.build);\n+    let compiler = build.compiler_path(&compiler);\n+\n+    for file in t!(fs::read_dir(build.src.join(\"src/rtstartup\"))) {\n+        let file = t!(file);\n+        build.run(Command::new(&compiler)\n+                          .arg(\"--emit=obj\")\n+                          .arg(\"--out-dir\").arg(into)\n+                          .arg(file.path()));\n+    }\n+\n+    for obj in [\"crt2.o\", \"dllcrt2.o\"].iter() {\n+        t!(fs::copy(compiler_file(build.cc(target), obj), into.join(obj)));\n+    }\n+}\n+\n+/// Build the compiler.\n+///\n+/// This will build the compiler for a particular stage of the build using\n+/// the `compiler` targeting the `target` architecture. The artifacts\n+/// created will also be linked into the sysroot directory.\n+pub fn rustc<'a>(build: &'a Build, stage: u32, target: &str,\n+                 compiler: &Compiler<'a>) {\n+    let host = compiler.host;\n+    println!(\"Building stage{} compiler artifacts ({} -> {})\", stage,\n+             host, target);\n+\n+    let out_dir = build.cargo_out(stage, &host, false, target);\n+    let rustc = out_dir.join(exe(\"rustc\", target));\n+    build.clear_if_dirty(&out_dir, &libstd_shim(build, stage, &host, target));\n+\n+    let mut cargo = build.cargo(stage, compiler, false, target, \"build\");\n+    cargo.arg(\"--features\").arg(build.rustc_features(stage))\n+         .arg(\"--manifest-path\")\n+         .arg(build.src.join(\"src/rustc/Cargo.toml\"));\n+\n+    // In stage0 we may not need to build as many executables\n+    if stage == 0 {\n+        cargo.arg(\"--bin\").arg(\"rustc\");\n+    }\n+\n+    // Set some configuration variables picked up by build scripts and\n+    // the compiler alike\n+    cargo.env(\"CFG_RELEASE\", &build.release)\n+         .env(\"CFG_RELEASE_CHANNEL\", &build.config.channel)\n+         .env(\"CFG_VERSION\", &build.version)\n+         .env(\"CFG_BOOTSTRAP_KEY\", &build.bootstrap_key)\n+         .env(\"RUSTC_BOOTSTRAP_KEY\", &build.bootstrap_key)\n+         .env(\"CFG_LIBDIR_RELATIVE\", \"lib\");\n+\n+    if let Some(ref ver_date) = build.ver_date {\n+        cargo.env(\"CFG_VER_DATE\", ver_date);\n+    }\n+    if let Some(ref ver_hash) = build.ver_hash {\n+        cargo.env(\"CFG_VER_HASH\", ver_hash);\n+    }\n+    if !build.unstable_features {\n+        cargo.env(\"CFG_DISABLE_UNSTABLE_FEATURES\", \"1\");\n+    }\n+    if let Some(config) = build.config.target_config.get(target) {\n+        if let Some(ref s) = config.llvm_config {\n+            cargo.env(\"LLVM_CONFIG\", s);\n+        }\n+    }\n+    if build.config.llvm_static_stdcpp {\n+        cargo.env(\"LLVM_STATIC_STDCPP\",\n+                  compiler_file(build.cxx(target), \"libstdc++.a\"));\n+    }\n+    if let Some(ref s) = build.config.rustc_default_linker {\n+        cargo.env(\"CFG_DEFAULT_LINKER\", s);\n+    }\n+    if let Some(ref s) = build.config.rustc_default_ar {\n+        cargo.env(\"CFG_DEFAULT_AR\", s);\n+    }\n+    build.run(&mut cargo);\n+\n+    let sysroot_libdir = build.sysroot_libdir(stage, host, target);\n+    add_to_sysroot(&out_dir, &sysroot_libdir);\n+\n+    if host == target {\n+        assemble_compiler(build, stage, target, &rustc);\n+    }\n+}\n+\n+/// Cargo's output path for the standard library in a given stage, compiled\n+/// by a particular compiler for the specified target.\n+fn libstd_shim(build: &Build, stage: u32, host: &str, target: &str) -> PathBuf {\n+    build.cargo_out(stage, host, true, target).join(\"libstd_shim.rlib\")\n+}\n+\n+fn compiler_file(compiler: &Path, file: &str) -> String {\n+    output(Command::new(compiler)\n+                   .arg(format!(\"-print-file-name={}\", file))).trim().to_string()\n+}\n+\n+/// Prepare a new compiler from the artifacts in `stage`\n+///\n+/// This will link the compiler built by `host` during the stage\n+/// specified to the sysroot location for `host` to be the official\n+/// `stage + 1` compiler for that host. This means that the `rustc` binary\n+/// itself will be linked into place along with all supporting dynamic\n+/// libraries.\n+fn assemble_compiler(build: &Build, stage: u32, host: &str, rustc: &Path) {\n+    // Clear out old files\n+    let sysroot = build.sysroot(stage + 1, host);\n+    let _ = fs::remove_dir_all(&sysroot);\n+    t!(fs::create_dir_all(&sysroot));\n+\n+    // Link in all dylibs to the libdir\n+    let sysroot_libdir = sysroot.join(libdir(host));\n+    t!(fs::create_dir_all(&sysroot_libdir));\n+    let src_libdir = build.sysroot_libdir(stage, host, host);\n+    for f in t!(fs::read_dir(&src_libdir)).map(|f| t!(f)) {\n+        let filename = f.file_name().into_string().unwrap();\n+        if is_dylib(&filename) {\n+            t!(fs::hard_link(&f.path(), sysroot_libdir.join(&filename)));\n+        }\n+    }\n+\n+    // Link the compiler binary itself into place\n+    let bindir = sysroot.join(\"bin\");\n+    t!(fs::create_dir_all(&bindir));\n+    let compiler = build.compiler_path(&Compiler::new(stage + 1, host));\n+    let _ = fs::remove_file(&compiler);\n+    t!(fs::hard_link(rustc, compiler));\n+\n+    // See if rustdoc exists to link it into place\n+    let exe = exe(\"rustdoc\", host);\n+    let rustdoc_src = rustc.parent().unwrap().join(&exe);\n+    let rustdoc_dst = bindir.join(exe);\n+    if fs::metadata(&rustdoc_src).is_ok() {\n+        let _ = fs::remove_file(&rustdoc_dst);\n+        t!(fs::hard_link(&rustdoc_src, &rustdoc_dst));\n+    }\n+}\n+\n+/// Link some files into a rustc sysroot.\n+///\n+/// For a particular stage this will link all of the contents of `out_dir`\n+/// into the sysroot of the `host` compiler, assuming the artifacts are\n+/// compiled for the specified `target`.\n+fn add_to_sysroot(out_dir: &Path, sysroot_dst: &Path) {\n+    // Collect the set of all files in the dependencies directory, keyed\n+    // off the name of the library. We assume everything is of the form\n+    // `foo-<hash>.{rlib,so,...}`, and there could be multiple different\n+    // `<hash>` values for the same name (of old builds).\n+    let mut map = HashMap::new();\n+    for file in t!(fs::read_dir(out_dir.join(\"deps\"))).map(|f| t!(f)) {\n+        let filename = file.file_name().into_string().unwrap();\n+\n+        // We're only interested in linking rlibs + dylibs, other things like\n+        // unit tests don't get linked in\n+        if !filename.ends_with(\".rlib\") &&\n+           !filename.ends_with(\".lib\") &&\n+           !is_dylib(&filename) {\n+            continue\n+        }\n+        let file = file.path();\n+        let dash = filename.find(\"-\").unwrap();\n+        let key = (filename[..dash].to_string(),\n+                   file.extension().unwrap().to_owned());\n+        map.entry(key).or_insert(Vec::new())\n+           .push(file.clone());\n+    }\n+\n+    // For all hash values found, pick the most recent one to move into the\n+    // sysroot, that should be the one we just built.\n+    for (_, paths) in map {\n+        let (_, path) = paths.iter().map(|path| {\n+            (mtime(&path).seconds(), path)\n+        }).max().unwrap();\n+        t!(fs::hard_link(&path,\n+                         sysroot_dst.join(path.file_name().unwrap())));\n+    }\n+}"}, {"sha": "862ee15cb080ce96793cb7ba1dd23f75b7d2db8c", "filename": "src/bootstrap/build/config.rs", "status": "added", "additions": 255, "deletions": 0, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/046e6874c47ec55e23b7a566bca51d2920562485/src%2Fbootstrap%2Fbuild%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/046e6874c47ec55e23b7a566bca51d2920562485/src%2Fbootstrap%2Fbuild%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fconfig.rs?ref=046e6874c47ec55e23b7a566bca51d2920562485", "patch": "@@ -0,0 +1,255 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::collections::HashMap;\n+use std::env;\n+use std::fs::File;\n+use std::io::prelude::*;\n+use std::path::PathBuf;\n+use std::process;\n+\n+use num_cpus;\n+use rustc_serialize::Decodable;\n+use toml::{Parser, Decoder, Value};\n+\n+/// Global configuration for the entire build and/or bootstrap.\n+///\n+/// This structure is derived from a combination of both `config.toml` and\n+/// `config.mk`. As of the time of this writing it's unlikely that `config.toml`\n+/// is used all that much, so this is primarily filled out by `config.mk` which\n+/// is generated from `./configure`.\n+///\n+/// Note that this structure is not decoded directly into, but rather it is\n+/// filled out from the decoded forms of the structs below.\n+#[derive(Default)]\n+pub struct Config {\n+    pub ccache: bool,\n+    pub verbose: bool,\n+    pub submodules: bool,\n+    pub compiler_docs: bool,\n+    pub docs: bool,\n+    pub target_config: HashMap<String, Target>,\n+\n+    // llvm codegen options\n+    pub llvm_assertions: bool,\n+    pub llvm_optimize: bool,\n+    pub llvm_version_check: bool,\n+    pub llvm_static_stdcpp: bool,\n+\n+    // rust codegen options\n+    pub rust_optimize: bool,\n+    pub rust_codegen_units: u32,\n+    pub rust_debug_assertions: bool,\n+    pub rust_debuginfo: bool,\n+    pub rust_rpath: bool,\n+    pub rustc_default_linker: Option<String>,\n+    pub rustc_default_ar: Option<String>,\n+\n+    pub build: String,\n+    pub host: Vec<String>,\n+    pub target: Vec<String>,\n+    pub rustc: Option<String>,\n+    pub cargo: Option<String>,\n+\n+    // libstd features\n+    pub debug_jemalloc: bool,\n+    pub use_jemalloc: bool,\n+\n+    // misc\n+    pub channel: String,\n+    pub musl_root: Option<PathBuf>,\n+}\n+\n+/// Per-target configuration stored in the global configuration structure.\n+#[derive(Default)]\n+pub struct Target {\n+    pub llvm_config: Option<PathBuf>,\n+    pub jemalloc: Option<PathBuf>,\n+    pub cc: Option<PathBuf>,\n+    pub cxx: Option<PathBuf>,\n+    pub ndk: Option<PathBuf>,\n+}\n+\n+/// Structure of the `config.toml` file that configuration is read from.\n+///\n+/// This structure uses `Decodable` to automatically decode a TOML configuration\n+/// file into this format, and then this is traversed and written into the above\n+/// `Config` structure.\n+#[derive(RustcDecodable, Default)]\n+struct TomlConfig {\n+    build: Option<Build>,\n+    llvm: Option<Llvm>,\n+    rust: Option<Rust>,\n+    target: Option<HashMap<String, TomlTarget>>,\n+}\n+\n+/// TOML representation of various global build decisions.\n+#[derive(RustcDecodable, Default, Clone)]\n+struct Build {\n+    build: Option<String>,\n+    host: Vec<String>,\n+    target: Vec<String>,\n+    cargo: Option<String>,\n+    rustc: Option<String>,\n+    compiler_docs: Option<bool>,\n+    docs: Option<bool>,\n+}\n+\n+/// TOML representation of how the LLVM build is configured.\n+#[derive(RustcDecodable, Default)]\n+struct Llvm {\n+    ccache: Option<bool>,\n+    assertions: Option<bool>,\n+    optimize: Option<bool>,\n+    version_check: Option<bool>,\n+    static_libstdcpp: Option<bool>,\n+}\n+\n+/// TOML representation of how the Rust build is configured.\n+#[derive(RustcDecodable, Default)]\n+struct Rust {\n+    optimize: Option<bool>,\n+    codegen_units: Option<u32>,\n+    debug_assertions: Option<bool>,\n+    debuginfo: Option<bool>,\n+    debug_jemalloc: Option<bool>,\n+    use_jemalloc: Option<bool>,\n+    default_linker: Option<String>,\n+    default_ar: Option<String>,\n+    channel: Option<String>,\n+    musl_root: Option<String>,\n+    rpath: Option<bool>,\n+}\n+\n+/// TOML representation of how each build target is configured.\n+#[derive(RustcDecodable, Default)]\n+struct TomlTarget {\n+    llvm_config: Option<String>,\n+    jemalloc: Option<String>,\n+    cc: Option<String>,\n+    cxx: Option<String>,\n+    android_ndk: Option<String>,\n+}\n+\n+impl Config {\n+    pub fn parse(build: &str, file: Option<PathBuf>) -> Config {\n+        let mut config = Config::default();\n+        config.llvm_optimize = true;\n+        config.use_jemalloc = true;\n+        config.rust_optimize = true;\n+        config.submodules = true;\n+        config.docs = true;\n+        config.rust_rpath = true;\n+        config.rust_codegen_units = 1;\n+        config.build = build.to_string();\n+        config.channel = \"dev\".to_string();\n+\n+        let toml = file.map(|file| {\n+            let mut f = t!(File::open(&file));\n+            let mut toml = String::new();\n+            t!(f.read_to_string(&mut toml));\n+            let mut p = Parser::new(&toml);\n+            let table = match p.parse() {\n+                Some(table) => table,\n+                None => {\n+                    println!(\"failed to parse TOML configuration:\");\n+                    for err in p.errors.iter() {\n+                        let (loline, locol) = p.to_linecol(err.lo);\n+                        let (hiline, hicol) = p.to_linecol(err.hi);\n+                        println!(\"{}:{}-{}:{}: {}\", loline, locol, hiline,\n+                                 hicol, err.desc);\n+                    }\n+                    process::exit(2);\n+                }\n+            };\n+            let mut d = Decoder::new(Value::Table(table));\n+            match Decodable::decode(&mut d) {\n+                Ok(cfg) => cfg,\n+                Err(e) => {\n+                    println!(\"failed to decode TOML: {}\", e);\n+                    process::exit(2);\n+                }\n+            }\n+        }).unwrap_or_else(|| TomlConfig::default());\n+\n+        let build = toml.build.clone().unwrap_or(Build::default());\n+        set(&mut config.build, build.build.clone());\n+        config.host.push(config.build.clone());\n+        for host in build.host.iter() {\n+            if !config.host.contains(host) {\n+                config.host.push(host.clone());\n+            }\n+        }\n+        for target in config.host.iter().chain(&build.target) {\n+            if !config.target.contains(target) {\n+                config.target.push(target.clone());\n+            }\n+        }\n+        config.rustc = build.rustc;\n+        config.cargo = build.cargo;\n+        set(&mut config.compiler_docs, build.compiler_docs);\n+        set(&mut config.docs, build.docs);\n+\n+        if let Some(ref llvm) = toml.llvm {\n+            set(&mut config.ccache, llvm.ccache);\n+            set(&mut config.llvm_assertions, llvm.assertions);\n+            set(&mut config.llvm_optimize, llvm.optimize);\n+            set(&mut config.llvm_optimize, llvm.optimize);\n+            set(&mut config.llvm_version_check, llvm.version_check);\n+            set(&mut config.llvm_static_stdcpp, llvm.static_libstdcpp);\n+        }\n+        if let Some(ref rust) = toml.rust {\n+            set(&mut config.rust_debug_assertions, rust.debug_assertions);\n+            set(&mut config.rust_debuginfo, rust.debuginfo);\n+            set(&mut config.rust_optimize, rust.optimize);\n+            set(&mut config.rust_rpath, rust.rpath);\n+            set(&mut config.debug_jemalloc, rust.debug_jemalloc);\n+            set(&mut config.use_jemalloc, rust.use_jemalloc);\n+            set(&mut config.channel, rust.channel.clone());\n+            config.rustc_default_linker = rust.default_linker.clone();\n+            config.rustc_default_ar = rust.default_ar.clone();\n+            config.musl_root = rust.musl_root.clone().map(PathBuf::from);\n+\n+            match rust.codegen_units {\n+                Some(0) => config.rust_codegen_units = num_cpus::get() as u32,\n+                Some(n) => config.rust_codegen_units = n,\n+                None => {}\n+            }\n+        }\n+\n+        if let Some(ref t) = toml.target {\n+            for (triple, cfg) in t {\n+                let mut target = Target::default();\n+\n+                if let Some(ref s) = cfg.llvm_config {\n+                    target.llvm_config = Some(env::current_dir().unwrap().join(s));\n+                }\n+                if let Some(ref s) = cfg.jemalloc {\n+                    target.jemalloc = Some(env::current_dir().unwrap().join(s));\n+                }\n+                if let Some(ref s) = cfg.android_ndk {\n+                    target.ndk = Some(env::current_dir().unwrap().join(s));\n+                }\n+                target.cxx = cfg.cxx.clone().map(PathBuf::from);\n+                target.cc = cfg.cc.clone().map(PathBuf::from);\n+\n+                config.target_config.insert(triple.clone(), target);\n+            }\n+        }\n+\n+        return config\n+    }\n+}\n+\n+fn set<T>(field: &mut T, val: Option<T>) {\n+    if let Some(v) = val {\n+        *field = v;\n+    }\n+}"}, {"sha": "cd538bb0a905ad5598c7060854d5711f85366fa5", "filename": "src/bootstrap/build/flags.rs", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/046e6874c47ec55e23b7a566bca51d2920562485/src%2Fbootstrap%2Fbuild%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/046e6874c47ec55e23b7a566bca51d2920562485/src%2Fbootstrap%2Fbuild%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fflags.rs?ref=046e6874c47ec55e23b7a566bca51d2920562485", "patch": "@@ -0,0 +1,99 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::fs;\n+use std::path::PathBuf;\n+use std::process;\n+use std::slice;\n+\n+use getopts::Options;\n+\n+pub struct Flags {\n+    pub verbose: bool,\n+    pub stage: Option<u32>,\n+    pub build: String,\n+    pub host: Filter,\n+    pub target: Filter,\n+    pub step: Vec<String>,\n+    pub config: Option<PathBuf>,\n+    pub src: Option<PathBuf>,\n+    pub jobs: Option<u32>,\n+    pub args: Vec<String>,\n+}\n+\n+pub struct Filter {\n+    values: Vec<String>,\n+}\n+\n+impl Flags {\n+    pub fn parse(args: &[String]) -> Flags {\n+        let mut opts = Options::new();\n+        opts.optflag(\"v\", \"verbose\", \"use verbose output\");\n+        opts.optopt(\"\", \"config\", \"TOML configuration file for build\", \"FILE\");\n+        opts.optmulti(\"\", \"host\", \"host targets to build\", \"HOST\");\n+        opts.reqopt(\"\", \"build\", \"build target of the stage0 compiler\", \"BUILD\");\n+        opts.optmulti(\"\", \"target\", \"targets to build\", \"TARGET\");\n+        opts.optmulti(\"s\", \"step\", \"build step to execute\", \"STEP\");\n+        opts.optopt(\"\", \"stage\", \"stage to build\", \"N\");\n+        opts.optopt(\"\", \"src\", \"path to repo root\", \"DIR\");\n+        opts.optopt(\"j\", \"jobs\", \"number of jobs to run in parallel\", \"JOBS\");\n+        opts.optflag(\"h\", \"help\", \"print this help message\");\n+\n+        let usage = |n| -> ! {\n+            let brief = format!(\"Usage: rust.py [options]\");\n+            print!(\"{}\", opts.usage(&brief));\n+            process::exit(n);\n+        };\n+\n+        let m = opts.parse(args).unwrap_or_else(|e| {\n+            println!(\"failed to parse options: {}\", e);\n+            usage(1);\n+        });\n+        if m.opt_present(\"h\") {\n+            usage(0);\n+        }\n+\n+        if m.free.len() > 0 {\n+            println!(\"free arguments are not currently accepted\");\n+            usage(1);\n+        }\n+\n+        let cfg_file = m.opt_str(\"config\").map(PathBuf::from).or_else(|| {\n+            if fs::metadata(\"config.toml\").is_ok() {\n+                Some(PathBuf::from(\"config.toml\"))\n+            } else {\n+                None\n+            }\n+        });\n+\n+        Flags {\n+            verbose: m.opt_present(\"v\"),\n+            stage: m.opt_str(\"stage\").map(|j| j.parse().unwrap()),\n+            build: m.opt_str(\"build\").unwrap(),\n+            host: Filter { values: m.opt_strs(\"host\") },\n+            target: Filter { values: m.opt_strs(\"target\") },\n+            step: m.opt_strs(\"step\"),\n+            config: cfg_file,\n+            src: m.opt_str(\"src\").map(PathBuf::from),\n+            jobs: m.opt_str(\"jobs\").map(|j| j.parse().unwrap()),\n+            args: m.free.clone(),\n+        }\n+    }\n+}\n+\n+impl Filter {\n+    pub fn contains(&self, name: &str) -> bool {\n+        self.values.len() == 0 || self.values.iter().any(|s| s == name)\n+    }\n+\n+    pub fn iter(&self) -> slice::Iter<String> {\n+        self.values.iter()\n+    }\n+}"}, {"sha": "49e027ffda596112ceaf635f7ebbfe5fd8ac762b", "filename": "src/bootstrap/build/job.rs", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/046e6874c47ec55e23b7a566bca51d2920562485/src%2Fbootstrap%2Fbuild%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/046e6874c47ec55e23b7a566bca51d2920562485/src%2Fbootstrap%2Fbuild%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fjob.rs?ref=046e6874c47ec55e23b7a566bca51d2920562485", "patch": "@@ -0,0 +1,100 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Job management on Windows for bootstrapping\n+//!\n+//! Most of the time when you're running a build system (e.g. make) you expect\n+//! Ctrl-C or abnormal termination to actually terminate the entire tree of\n+//! process in play, not just the one at the top. This currently works \"by\n+//! default\" on Unix platforms because Ctrl-C actually sends a signal to the\n+//! *process group* rather than the parent process, so everything will get torn\n+//! down. On Windows, however, this does not happen and Ctrl-C just kills the\n+//! parent process.\n+//!\n+//! To achieve the same semantics on Windows we use Job Objects to ensure that\n+//! all processes die at the same time. Job objects have a mode of operation\n+//! where when all handles to the object are closed it causes all child\n+//! processes associated with the object to be terminated immediately.\n+//! Conveniently whenever a process in the job object spawns a new process the\n+//! child will be associated with the job object as well. This means if we add\n+//! ourselves to the job object we create then everything will get torn down!\n+//!\n+//! Unfortunately most of the time the build system is actually called from a\n+//! python wrapper (which manages things like building the build system) so this\n+//! all doesn't quite cut it so far. To go the last mile we duplicate the job\n+//! object handle into our parent process (a python process probably) and then\n+//! close our own handle. This means that the only handle to the job object\n+//! resides in the parent python process, so when python dies the whole build\n+//! system dies (as one would probably expect!).\n+//!\n+//! Note that this module has a #[cfg(windows)] above it as none of this logic\n+//! is required on Unix.\n+\n+extern crate kernel32;\n+extern crate winapi;\n+\n+use std::env;\n+use std::io;\n+use std::mem;\n+\n+use self::winapi::*;\n+use self::kernel32::*;\n+\n+pub unsafe fn setup() {\n+    // Create a new job object for us to use\n+    let job = CreateJobObjectW(0 as *mut _, 0 as *const _);\n+    assert!(job != 0 as *mut _, \"{}\", io::Error::last_os_error());\n+\n+    // Indicate that when all handles to the job object are gone that all\n+    // process in the object should be killed. Note that this includes our\n+    // entire process tree by default because we've added ourselves and and our\n+    // children will reside in the job by default.\n+    let mut info = mem::zeroed::<JOBOBJECT_EXTENDED_LIMIT_INFORMATION>();\n+    info.BasicLimitInformation.LimitFlags = JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE;\n+    let r = SetInformationJobObject(job,\n+                                    JobObjectExtendedLimitInformation,\n+                                    &mut info as *mut _ as LPVOID,\n+                                    mem::size_of_val(&info) as DWORD);\n+    assert!(r != 0, \"{}\", io::Error::last_os_error());\n+\n+    // Assign our process to this job object\n+    let r = AssignProcessToJobObject(job, GetCurrentProcess());\n+    assert!(r != 0, \"{}\", io::Error::last_os_error());\n+\n+    // If we've got a parent process (e.g. the python script that called us)\n+    // then move ownership of this job object up to them. That way if the python\n+    // script is killed (e.g. via ctrl-c) then we'll all be torn down.\n+    //\n+    // If we don't have a parent (e.g. this was run directly) then we\n+    // intentionally leak the job object handle. When our process exits\n+    // (normally or abnormally) it will close the handle implicitly, causing all\n+    // processes in the job to be cleaned up.\n+    let pid = match env::var(\"BOOTSTRAP_PARENT_ID\") {\n+        Ok(s) => s,\n+        Err(..) => return,\n+    };\n+\n+    let parent = OpenProcess(PROCESS_DUP_HANDLE, FALSE, pid.parse().unwrap());\n+    assert!(parent != 0 as *mut _, \"{}\", io::Error::last_os_error());\n+    let mut parent_handle = 0 as *mut _;\n+    let r = DuplicateHandle(GetCurrentProcess(), job,\n+                            parent, &mut parent_handle,\n+                            0, FALSE, DUPLICATE_SAME_ACCESS);\n+\n+    // If this failed, well at least we tried! An example of DuplicateHandle\n+    // failing in the past has been when the wrong python2 package spawed this\n+    // build system (e.g. the `python2` package in MSYS instead of\n+    // `mingw-w64-x86_64-python2`. Not sure why it failed, but the \"failure\n+    // mode\" here is that we only clean everything up when the build system\n+    // dies, not when the python parent does, so not too bad.\n+    if r != 0 {\n+        CloseHandle(job);\n+    }\n+}"}, {"sha": "6f962aae923348040e1222da35a6902d38c9c530", "filename": "src/bootstrap/build/mod.rs", "status": "added", "additions": 452, "deletions": 0, "changes": 452, "blob_url": "https://github.com/rust-lang/rust/blob/046e6874c47ec55e23b7a566bca51d2920562485/src%2Fbootstrap%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/046e6874c47ec55e23b7a566bca51d2920562485/src%2Fbootstrap%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fmod.rs?ref=046e6874c47ec55e23b7a566bca51d2920562485", "patch": "@@ -0,0 +1,452 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::cell::RefCell;\n+use std::collections::HashMap;\n+use std::env;\n+use std::fs::{self, File};\n+use std::path::{PathBuf, Path};\n+use std::process::Command;\n+\n+use build_helper::{run_silent, output};\n+use gcc;\n+use num_cpus;\n+\n+use build::util::{exe, mtime, libdir, add_lib_path};\n+\n+macro_rules! t {\n+    ($e:expr) => (match $e {\n+        Ok(e) => e,\n+        Err(e) => panic!(\"{} failed with {}\", stringify!($e), e),\n+    })\n+}\n+\n+mod cc;\n+mod channel;\n+mod compile;\n+mod config;\n+mod flags;\n+mod native;\n+mod sanity;\n+mod step;\n+mod util;\n+\n+pub use build::config::Config;\n+pub use build::flags::Flags;\n+\n+#[derive(Eq, PartialEq, Clone, Copy, Hash, Debug)]\n+pub struct Compiler<'a> {\n+    stage: u32,\n+    host: &'a str,\n+}\n+\n+pub struct Build {\n+    // User-specified configuration via config.toml\n+    config: Config,\n+\n+    // User-specified configuration via CLI flags\n+    flags: Flags,\n+\n+    // Derived properties from the above two configurations\n+    cargo: PathBuf,\n+    rustc: PathBuf,\n+    src: PathBuf,\n+    out: PathBuf,\n+    release: String,\n+    unstable_features: bool,\n+    ver_hash: Option<String>,\n+    short_ver_hash: Option<String>,\n+    ver_date: Option<String>,\n+    version: String,\n+    bootstrap_key: String,\n+\n+    // Runtime state filled in later on\n+    cc: HashMap<String, (gcc::Tool, PathBuf)>,\n+    cxx: HashMap<String, gcc::Tool>,\n+    compiler_rt_built: RefCell<HashMap<String, PathBuf>>,\n+}\n+\n+impl Build {\n+    pub fn new(flags: Flags, config: Config) -> Build {\n+        let cwd = t!(env::current_dir());\n+        let src = flags.src.clone().unwrap_or(cwd.clone());\n+        let out = cwd.join(\"build\");\n+\n+        let stage0_root = out.join(&config.build).join(\"stage0/bin\");\n+        let rustc = match config.rustc {\n+            Some(ref s) => PathBuf::from(s),\n+            None => stage0_root.join(exe(\"rustc\", &config.build)),\n+        };\n+        let cargo = match config.cargo {\n+            Some(ref s) => PathBuf::from(s),\n+            None => stage0_root.join(exe(\"cargo\", &config.build)),\n+        };\n+\n+        Build {\n+            flags: flags,\n+            config: config,\n+            cargo: cargo,\n+            rustc: rustc,\n+            src: src,\n+            out: out,\n+\n+            release: String::new(),\n+            unstable_features: false,\n+            ver_hash: None,\n+            short_ver_hash: None,\n+            ver_date: None,\n+            version: String::new(),\n+            bootstrap_key: String::new(),\n+            cc: HashMap::new(),\n+            cxx: HashMap::new(),\n+            compiler_rt_built: RefCell::new(HashMap::new()),\n+        }\n+    }\n+\n+    pub fn build(&mut self) {\n+        use build::step::Source::*;\n+\n+        // see comments in job.rs for what's going on here\n+        #[cfg(windows)]\n+        fn setup_job() {\n+            mod job;\n+            unsafe { job::setup() }\n+        }\n+        #[cfg(not(windows))] fn setup_job() {}\n+        setup_job();\n+\n+        cc::find(self);\n+        sanity::check(self);\n+        channel::collect(self);\n+        self.update_submodules();\n+\n+        for target in step::all(self) {\n+            match target.src {\n+                Llvm { _dummy } => {\n+                    native::llvm(self, target.target);\n+                }\n+                CompilerRt { _dummy } => {\n+                    native::compiler_rt(self, target.target);\n+                }\n+                Libstd { stage, compiler } => {\n+                    compile::std(self, stage, target.target, &compiler);\n+                }\n+                Librustc { stage, compiler } => {\n+                    compile::rustc(self, stage, target.target, &compiler);\n+                }\n+                Rustc { stage } => {\n+                    println!(\"ok, rustc stage{} in {}\", stage, target.target);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn update_submodules(&self) {\n+        if !self.config.submodules {\n+            return\n+        }\n+        if fs::metadata(self.src.join(\".git\")).is_err() {\n+            return\n+        }\n+        let out = output(Command::new(\"git\").arg(\"submodule\").arg(\"status\"));\n+        if !out.lines().any(|l| l.starts_with(\"+\") || l.starts_with(\"-\")) {\n+            return\n+        }\n+\n+        self.run(Command::new(\"git\").arg(\"submodule\").arg(\"sync\"));\n+        self.run(Command::new(\"git\").arg(\"submodule\").arg(\"init\"));\n+        self.run(Command::new(\"git\").arg(\"submodule\").arg(\"update\"));\n+        self.run(Command::new(\"git\").arg(\"submodule\").arg(\"update\")\n+                                    .arg(\"--recursive\"));\n+        self.run(Command::new(\"git\").arg(\"submodule\").arg(\"status\")\n+                                    .arg(\"--recursive\"));\n+        self.run(Command::new(\"git\").arg(\"submodule\").arg(\"foreach\")\n+                                    .arg(\"--recursive\")\n+                                    .arg(\"git\").arg(\"clean\").arg(\"-fdx\"));\n+        self.run(Command::new(\"git\").arg(\"submodule\").arg(\"foreach\")\n+                                    .arg(\"--recursive\")\n+                                    .arg(\"git\").arg(\"checkout\").arg(\".\"));\n+    }\n+\n+    /// Clear out `dir` if our build has been flagged as dirty, and also set\n+    /// ourselves as dirty if `file` changes when `f` is executed.\n+    fn clear_if_dirty(&self, dir: &Path, input: &Path) {\n+        let stamp = dir.join(\".stamp\");\n+        if mtime(&stamp) < mtime(input) {\n+            self.verbose(&format!(\"Dirty - {}\", dir.display()));\n+            let _ = fs::remove_dir_all(dir);\n+        }\n+        t!(fs::create_dir_all(dir));\n+        t!(File::create(stamp));\n+    }\n+\n+    /// Prepares an invocation of `cargo` to be run.\n+    ///\n+    /// This will create a `Command` that represents a pending execution of\n+    /// Cargo for the specified stage, whether or not the standard library is\n+    /// being built, and using the specified compiler targeting `target`.\n+    // FIXME: aren't stage/compiler duplicated?\n+    fn cargo(&self, stage: u32, compiler: &Compiler, is_std: bool,\n+             target: &str, cmd: &str) -> Command {\n+        let mut cargo = Command::new(&self.cargo);\n+        let host = compiler.host;\n+        let out_dir = self.stage_out(stage, host, is_std);\n+        cargo.env(\"CARGO_TARGET_DIR\", out_dir)\n+             .arg(cmd)\n+             .arg(\"--target\").arg(target)\n+             .arg(\"-j\").arg(self.jobs().to_string());\n+\n+        // Customize the compiler we're running. Specify the compiler to cargo\n+        // as our shim and then pass it some various options used to configure\n+        // how the actual compiler itself is called.\n+        cargo.env(\"RUSTC\", self.out.join(\"bootstrap/debug/rustc\"))\n+             .env(\"RUSTC_REAL\", self.compiler_path(compiler))\n+             .env(\"RUSTC_STAGE\", self.stage_arg(stage, compiler).to_string())\n+             .env(\"RUSTC_DEBUGINFO\", self.config.rust_debuginfo.to_string())\n+             .env(\"RUSTC_CODEGEN_UNITS\",\n+                  self.config.rust_codegen_units.to_string())\n+             .env(\"RUSTC_DEBUG_ASSERTIONS\",\n+                  self.config.rust_debug_assertions.to_string())\n+             .env(\"RUSTC_SNAPSHOT\", &self.rustc)\n+             .env(\"RUSTC_SYSROOT\", self.sysroot(stage, host))\n+             .env(\"RUSTC_SNAPSHOT_LIBDIR\", self.rustc_snapshot_libdir())\n+             .env(\"RUSTC_FLAGS\", self.rustc_flags(target).join(\" \"))\n+             .env(\"RUSTC_RPATH\", self.config.rust_rpath.to_string())\n+             .env(\"RUSTDOC\", self.tool(compiler, \"rustdoc\"));\n+\n+        // Specify some variuos options for build scripts used throughout the\n+        // build.\n+        //\n+        // FIXME: the guard against msvc shouldn't need to be here\n+        if !target.contains(\"msvc\") {\n+            cargo.env(format!(\"CC_{}\", target), self.cc(target))\n+                 .env(format!(\"AR_{}\", target), self.ar(target))\n+                 .env(format!(\"CFLAGS_{}\", target), self.cflags(target));\n+        }\n+\n+        // Environment variables *required* needed throughout the build\n+        //\n+        // FIXME: should update code to not require this env vars\n+        cargo.env(\"CFG_COMPILER_HOST_TRIPLE\", target);\n+\n+        if self.config.verbose || self.flags.verbose {\n+            cargo.arg(\"-v\");\n+        }\n+        if self.config.rust_optimize {\n+            cargo.arg(\"--release\");\n+        }\n+        self.add_rustc_lib_path(compiler, &mut cargo);\n+        return cargo\n+    }\n+\n+    /// Get a path to the compiler specified.\n+    fn compiler_path(&self, compiler: &Compiler) -> PathBuf {\n+        if compiler.is_snapshot(self) {\n+            self.rustc.clone()\n+        } else {\n+            self.sysroot(compiler.stage, compiler.host).join(\"bin\")\n+                .join(exe(\"rustc\", compiler.host))\n+        }\n+    }\n+\n+    /// Get the specified tool next to the specified compiler\n+    fn tool(&self, compiler: &Compiler, tool: &str) -> PathBuf {\n+        if compiler.is_snapshot(self) {\n+            assert!(tool == \"rustdoc\", \"no tools other than rustdoc in stage0\");\n+            let mut rustdoc = self.rustc.clone();\n+            rustdoc.pop();\n+            rustdoc.push(exe(\"rustdoc\", &self.config.build));\n+            return rustdoc\n+        }\n+        let (stage, host) = (compiler.stage, compiler.host);\n+        self.cargo_out(stage - 1, host, false, host).join(exe(tool, host))\n+    }\n+\n+    /// Get a `Command` which is ready to run `tool` in `stage` built for\n+    /// `host`.\n+    #[allow(dead_code)] // this will be used soon\n+    fn tool_cmd(&self, compiler: &Compiler, tool: &str) -> Command {\n+        let mut cmd = Command::new(self.tool(&compiler, tool));\n+        let host = compiler.host;\n+        let stage = compiler.stage;\n+        let paths = vec![\n+            self.cargo_out(stage - 1, host, true, host).join(\"deps\"),\n+            self.cargo_out(stage - 1, host, false, host).join(\"deps\"),\n+        ];\n+        add_lib_path(paths, &mut cmd);\n+        return cmd\n+    }\n+\n+    fn stage_arg(&self, stage: u32, compiler: &Compiler) -> u32 {\n+        if stage == 0 && compiler.host != self.config.build {1} else {stage}\n+    }\n+\n+    /// Get the space-separated set of activated features for the standard\n+    /// library.\n+    fn std_features(&self) -> String {\n+        let mut features = String::new();\n+        if self.config.debug_jemalloc {\n+            features.push_str(\" debug-jemalloc\");\n+        }\n+        if self.config.use_jemalloc {\n+            features.push_str(\" jemalloc\");\n+        }\n+        return features\n+    }\n+\n+    /// Get the space-separated set of activated features for the compiler.\n+    fn rustc_features(&self, stage: u32) -> String {\n+        let mut features = String::new();\n+        if self.config.use_jemalloc {\n+            features.push_str(\" jemalloc\");\n+        }\n+        if stage > 0 {\n+            features.push_str(\" rustdoc\");\n+            features.push_str(\" rustbook\");\n+        }\n+        return features\n+    }\n+\n+    /// Component directory that Cargo will produce output into (e.g.\n+    /// release/debug)\n+    fn cargo_dir(&self) -> &'static str {\n+        if self.config.rust_optimize {\"release\"} else {\"debug\"}\n+    }\n+\n+    fn sysroot(&self, stage: u32, host: &str) -> PathBuf {\n+        if stage == 0 {\n+            self.stage_out(stage, host, false)\n+        } else {\n+            self.out.join(host).join(format!(\"stage{}\", stage))\n+        }\n+    }\n+\n+    fn sysroot_libdir(&self, stage: u32, host: &str, target: &str) -> PathBuf {\n+        self.sysroot(stage, host).join(\"lib\").join(\"rustlib\")\n+            .join(target).join(\"lib\")\n+    }\n+\n+    /// Returns the root directory for all output generated in a particular\n+    /// stage when running with a particular host compiler.\n+    ///\n+    /// The `is_std` flag indicates whether the root directory is for the\n+    /// bootstrap of the standard library or for the compiler.\n+    fn stage_out(&self, stage: u32, host: &str, is_std: bool) -> PathBuf {\n+        self.out.join(host)\n+            .join(format!(\"stage{}{}\", stage, if is_std {\"-std\"} else {\"-rustc\"}))\n+    }\n+\n+    /// Returns the root output directory for all Cargo output in a given stage,\n+    /// running a particular comipler, wehther or not we're building the\n+    /// standard library, and targeting the specified architecture.\n+    fn cargo_out(&self, stage: u32, host: &str, is_std: bool,\n+                 target: &str) -> PathBuf {\n+        self.stage_out(stage, host, is_std).join(target).join(self.cargo_dir())\n+    }\n+\n+    /// Root output directory for LLVM compiled for `target`\n+    fn llvm_out(&self, target: &str) -> PathBuf {\n+        self.out.join(target).join(\"llvm\")\n+    }\n+\n+    /// Root output directory for compiler-rt compiled for `target`\n+    fn compiler_rt_out(&self, target: &str) -> PathBuf {\n+        self.out.join(target).join(\"compiler-rt\")\n+    }\n+\n+    fn add_rustc_lib_path(&self, compiler: &Compiler, cmd: &mut Command) {\n+        // Windows doesn't need dylib path munging because the dlls for the\n+        // compiler live next to the compiler and the system will find them\n+        // automatically.\n+        if cfg!(windows) { return }\n+\n+        add_lib_path(vec![self.rustc_libdir(compiler)], cmd);\n+    }\n+\n+    fn rustc_libdir(&self, compiler: &Compiler) -> PathBuf {\n+        if compiler.is_snapshot(self) {\n+            self.rustc_snapshot_libdir()\n+        } else {\n+            self.sysroot(compiler.stage, compiler.host)\n+                .join(libdir(compiler.host))\n+        }\n+    }\n+\n+    fn rustc_snapshot_libdir(&self) -> PathBuf {\n+        self.rustc.parent().unwrap().parent().unwrap()\n+            .join(libdir(&self.config.build))\n+    }\n+\n+    fn run(&self, cmd: &mut Command) {\n+        self.verbose(&format!(\"running: {:?}\", cmd));\n+        run_silent(cmd)\n+    }\n+\n+    fn verbose(&self, msg: &str) {\n+        if self.flags.verbose || self.config.verbose {\n+            println!(\"{}\", msg);\n+        }\n+    }\n+\n+    fn jobs(&self) -> u32 {\n+        self.flags.jobs.unwrap_or(num_cpus::get() as u32)\n+    }\n+\n+    fn cc(&self, target: &str) -> &Path {\n+        self.cc[target].0.path()\n+    }\n+\n+    fn cflags(&self, target: &str) -> String {\n+        self.cc[target].0.args().iter()\n+            .map(|s| s.to_string_lossy())\n+            .collect::<Vec<_>>()\n+            .join(\" \")\n+    }\n+\n+    fn ar(&self, target: &str) -> &Path {\n+        &self.cc[target].1\n+    }\n+\n+    fn cxx(&self, target: &str) -> &Path {\n+        self.cxx[target].path()\n+    }\n+\n+    fn rustc_flags(&self, target: &str) -> Vec<String> {\n+        let mut base = match target {\n+            \"arm-unknown-linux-gnueabihf\" => {\n+                vec![\"-Ctarget-feature=+v6,+vfp2\".to_string()]\n+            }\n+            \"mips-unknown-linux-gnu\" => {\n+                vec![\"-Ctarget-cpu=mips32r2\".to_string(),\n+                     \"-Ctarget-feature=+mips32r2\".to_string(),\n+                     \"-Csoft-float\".to_string()]\n+            }\n+            \"mipsel-unknown-linux-gnu\" => {\n+                vec![\"-Ctarget-cpu=mips32\".to_string(),\n+                     \"-Ctarget-feature=+mips32\".to_string()]\n+            }\n+            _ => Vec::new(),\n+        };\n+        if target != self.config.build && !target.contains(\"msvc\") {\n+            base.push(format!(\"-Clinker={}\", self.cc(target).display()));\n+        }\n+        return base\n+    }\n+}\n+\n+impl<'a> Compiler<'a> {\n+    fn new(stage: u32, host: &'a str) -> Compiler<'a> {\n+        Compiler { stage: stage, host: host }\n+    }\n+\n+    fn is_snapshot(&self, build: &Build) -> bool {\n+        self.stage == 0 && self.host == build.config.build\n+    }\n+}"}, {"sha": "6ad5f4041239418c3741e27924f7fd1ff4a1dbf6", "filename": "src/bootstrap/build/native.rs", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/046e6874c47ec55e23b7a566bca51d2920562485/src%2Fbootstrap%2Fbuild%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/046e6874c47ec55e23b7a566bca51d2920562485/src%2Fbootstrap%2Fbuild%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fnative.rs?ref=046e6874c47ec55e23b7a566bca51d2920562485", "patch": "@@ -0,0 +1,157 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::path::Path;\n+use std::process::Command;\n+use std::fs;\n+\n+use build_helper::output;\n+use cmake;\n+\n+use build::Build;\n+use build::util::{exe, staticlib};\n+\n+pub fn llvm(build: &Build, target: &str) {\n+    // If we're using a custom LLVM bail out here, but we can only use a\n+    // custom LLVM for the build triple.\n+    if let Some(config) = build.config.target_config.get(target) {\n+        if let Some(ref s) = config.llvm_config {\n+            return check_llvm_version(build, s);\n+        }\n+    }\n+\n+    // If the cleaning trigger is newer than our built artifacts (or if the\n+    // artifacts are missing) then we keep going, otherwise we bail out.\n+    let dst = build.llvm_out(target);\n+    let stamp = build.src.join(\"src/rustllvm/llvm-auto-clean-trigger\");\n+    let llvm_config = dst.join(\"bin\").join(exe(\"llvm-config\", target));\n+    build.clear_if_dirty(&dst, &stamp);\n+    if fs::metadata(llvm_config).is_ok() {\n+        return\n+    }\n+\n+    let _ = fs::remove_dir_all(&dst.join(\"build\"));\n+    t!(fs::create_dir_all(&dst.join(\"build\")));\n+    let assertions = if build.config.llvm_assertions {\"ON\"} else {\"OFF\"};\n+\n+    // http://llvm.org/docs/CMake.html\n+    let mut cfg = cmake::Config::new(build.src.join(\"src/llvm\"));\n+    cfg.target(target)\n+       .host(&build.config.build)\n+       .out_dir(&dst)\n+       .profile(if build.config.llvm_optimize {\"Release\"} else {\"Debug\"})\n+       .define(\"LLVM_ENABLE_ASSERTIONS\", assertions)\n+       .define(\"LLVM_TARGETS_TO_BUILD\", \"X86;ARM;AArch64;Mips;PowerPC\")\n+       .define(\"LLVM_INCLUDE_EXAMPLES\", \"OFF\")\n+       .define(\"LLVM_INCLUDE_TESTS\", \"OFF\")\n+       .define(\"LLVM_INCLUDE_DOCS\", \"OFF\")\n+       .define(\"LLVM_ENABLE_ZLIB\", \"OFF\")\n+       .define(\"WITH_POLLY\", \"OFF\")\n+       .define(\"LLVM_ENABLE_TERMINFO\", \"OFF\")\n+       .define(\"LLVM_ENABLE_LIBEDIT\", \"OFF\")\n+       .define(\"LLVM_PARALLEL_COMPILE_JOBS\", build.jobs().to_string());\n+\n+    if target.starts_with(\"i686\") {\n+        cfg.define(\"LLVM_BUILD_32_BITS\", \"ON\");\n+    }\n+\n+    // http://llvm.org/docs/HowToCrossCompileLLVM.html\n+    if target != build.config.build {\n+        // FIXME: if the llvm root for the build triple is overridden then we\n+        //        should use llvm-tblgen from there, also should verify that it\n+        //        actually exists most of the time in normal installs of LLVM.\n+        let host = build.llvm_out(&build.config.build).join(\"bin/llvm-tblgen\");\n+        cfg.define(\"CMAKE_CROSSCOMPILING\", \"True\")\n+           .define(\"LLVM_TARGET_ARCH\", target.split('-').next().unwrap())\n+           .define(\"LLVM_TABLEGEN\", &host)\n+           .define(\"LLVM_DEFAULT_TARGET_TRIPLE\", target);\n+    }\n+\n+    // MSVC handles compiler business itself\n+    if !target.contains(\"msvc\") {\n+        if build.config.ccache {\n+           cfg.define(\"CMAKE_C_COMPILER\", \"ccache\")\n+              .define(\"CMAKE_C_COMPILER_ARG1\", build.cc(target))\n+              .define(\"CMAKE_CXX_COMPILER\", \"ccache\")\n+              .define(\"CMAKE_CXX_COMPILER_ARG1\", build.cxx(target));\n+        } else {\n+           cfg.define(\"CMAKE_C_COMPILER\", build.cc(target))\n+              .define(\"CMAKE_CXX_COMPILER\", build.cxx(target));\n+        }\n+        cfg.build_arg(\"-j\").build_arg(build.jobs().to_string());\n+    }\n+\n+    // FIXME: we don't actually need to build all LLVM tools and all LLVM\n+    //        libraries here, e.g. we just want a few components and a few\n+    //        tools. Figure out how to filter them down and only build the right\n+    //        tools and libs on all platforms.\n+    cfg.build();\n+}\n+\n+fn check_llvm_version(build: &Build, llvm_config: &Path) {\n+    if !build.config.llvm_version_check {\n+        return\n+    }\n+\n+    let mut cmd = Command::new(llvm_config);\n+    let version = output(cmd.arg(\"--version\"));\n+    if version.starts_with(\"3.5\") || version.starts_with(\"3.6\") ||\n+       version.starts_with(\"3.7\") {\n+        return\n+    }\n+    panic!(\"\\n\\nbad LLVM version: {}, need >=3.5\\n\\n\", version)\n+}\n+\n+pub fn compiler_rt(build: &Build, target: &str) {\n+    let dst = build.compiler_rt_out(target);\n+    let arch = target.split('-').next().unwrap();\n+    let mode = if build.config.rust_optimize {\"Release\"} else {\"Debug\"};\n+    let (dir, build_target, libname) = if target.contains(\"linux\") {\n+        let os = if target.contains(\"android\") {\"-android\"} else {\"\"};\n+        let target = format!(\"clang_rt.builtins-{}{}\", arch, os);\n+        (\"linux\".to_string(), target.clone(), target)\n+    } else if target.contains(\"darwin\") {\n+        let target = format!(\"clang_rt.builtins_{}_osx\", arch);\n+        (\"builtins\".to_string(), target.clone(), target)\n+    } else if target.contains(\"windows-gnu\") {\n+        let target = format!(\"clang_rt.builtins-{}\", arch);\n+        (\"windows\".to_string(), target.clone(), target)\n+    } else if target.contains(\"windows-msvc\") {\n+        (format!(\"windows/{}\", mode),\n+         \"lib/builtins/builtins\".to_string(),\n+         format!(\"clang_rt.builtins-{}\", arch.replace(\"i686\", \"i386\")))\n+    } else {\n+        panic!(\"can't get os from target: {}\", target)\n+    };\n+    let output = dst.join(\"build/lib\").join(dir)\n+                    .join(staticlib(&libname, target));\n+    build.compiler_rt_built.borrow_mut().insert(target.to_string(),\n+                                                output.clone());\n+    if fs::metadata(&output).is_ok() {\n+        return\n+    }\n+    let _ = fs::remove_dir_all(&dst);\n+    t!(fs::create_dir_all(&dst));\n+    let build_llvm_config = build.llvm_out(&build.config.build)\n+                                 .join(\"bin\")\n+                                 .join(exe(\"llvm-config\", &build.config.build));\n+    let mut cfg = cmake::Config::new(build.src.join(\"src/compiler-rt\"));\n+    cfg.target(target)\n+       .host(&build.config.build)\n+       .out_dir(&dst)\n+       .profile(mode)\n+       .define(\"LLVM_CONFIG_PATH\", build_llvm_config)\n+       .define(\"COMPILER_RT_DEFAULT_TARGET_TRIPLE\", target)\n+       .define(\"COMPILER_RT_BUILD_SANITIZERS\", \"OFF\")\n+       .define(\"COMPILER_RT_BUILD_EMUTLS\", \"OFF\")\n+       .define(\"CMAKE_C_COMPILER\", build.cc(target))\n+       .build_target(&build_target);\n+    cfg.build();\n+}"}, {"sha": "40f4c7076092d78f5e70dcfe16182f4fcf0a195a", "filename": "src/bootstrap/build/sanity.rs", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/046e6874c47ec55e23b7a566bca51d2920562485/src%2Fbootstrap%2Fbuild%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/046e6874c47ec55e23b7a566bca51d2920562485/src%2Fbootstrap%2Fbuild%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fsanity.rs?ref=046e6874c47ec55e23b7a566bca51d2920562485", "patch": "@@ -0,0 +1,122 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::collections::HashSet;\n+use std::env;\n+use std::ffi::{OsStr, OsString};\n+use std::fs;\n+use std::process::Command;\n+\n+use build_helper::output;\n+\n+use build::Build;\n+\n+pub fn check(build: &mut Build) {\n+    let mut checked = HashSet::new();\n+    let path = env::var_os(\"PATH\").unwrap_or(OsString::new());\n+    let mut need_cmd = |cmd: &OsStr| {\n+        if !checked.insert(cmd.to_owned()) {\n+            return\n+        }\n+        for path in env::split_paths(&path).map(|p| p.join(cmd)) {\n+            if fs::metadata(&path).is_ok() ||\n+               fs::metadata(path.with_extension(\"exe\")).is_ok() {\n+                return\n+            }\n+        }\n+        panic!(\"\\n\\ncouldn't find required command: {:?}\\n\\n\", cmd);\n+    };\n+\n+    // If we've got a git directory we're gona need git to update\n+    // submodules and learn about various other aspects.\n+    if fs::metadata(build.src.join(\".git\")).is_ok() {\n+        need_cmd(\"git\".as_ref());\n+    }\n+\n+    // We need cmake, but only if we're actually building LLVM\n+    for host in build.config.host.iter() {\n+        if let Some(config) = build.config.target_config.get(host) {\n+            if config.llvm_config.is_some() {\n+                continue\n+            }\n+        }\n+        need_cmd(\"cmake\".as_ref());\n+        break\n+    }\n+\n+    need_cmd(\"python\".as_ref());\n+\n+    // We're gonna build some custom C code here and there, host triples\n+    // also build some C++ shims for LLVM so we need a C++ compiler.\n+    for target in build.config.target.iter() {\n+        need_cmd(build.cc(target).as_ref());\n+        need_cmd(build.ar(target).as_ref());\n+    }\n+    for host in build.config.host.iter() {\n+        need_cmd(build.cxx(host).as_ref());\n+    }\n+\n+    for target in build.config.target.iter() {\n+        // Either can't build or don't want to run jemalloc on these targets\n+        if target.contains(\"rumprun\") ||\n+           target.contains(\"bitrig\") ||\n+           target.contains(\"openbsd\") ||\n+           target.contains(\"msvc\") {\n+            build.config.use_jemalloc = false;\n+        }\n+\n+        // Can't compile for iOS unless we're on OSX\n+        if target.contains(\"apple-ios\") &&\n+           !build.config.build.contains(\"apple-darwin\") {\n+            panic!(\"the iOS target is only supported on OSX\");\n+        }\n+\n+        // Make sure musl-root is valid if specified\n+        if target.contains(\"musl\") {\n+            match build.config.musl_root {\n+                Some(ref root) => {\n+                    if fs::metadata(root.join(\"lib/libc.a\")).is_err() {\n+                        panic!(\"couldn't find libc.a in musl dir: {}\",\n+                               root.join(\"lib\").display());\n+                    }\n+                    if fs::metadata(root.join(\"lib/libunwind.a\")).is_err() {\n+                        panic!(\"couldn't find libunwind.a in musl dir: {}\",\n+                               root.join(\"lib\").display());\n+                    }\n+                }\n+                None => {\n+                    panic!(\"when targeting MUSL the build.musl-root option \\\n+                            must be specified in config.toml\")\n+                }\n+            }\n+        }\n+\n+        if target.contains(\"msvc\") {\n+            // There are three builds of cmake on windows: MSVC, MinGW, and\n+            // Cygwin. The Cygwin build does not have generators for Visual\n+            // Studio, so detect that here and error.\n+            let out = output(Command::new(\"cmake\").arg(\"--help\"));\n+            if !out.contains(\"Visual Studio\") {\n+                panic!(\"\n+cmake does not support Visual Studio generators.\n+\n+This is likely due to it being an msys/cygwin build of cmake,\n+rather than the required windows version, built using MinGW\n+or Visual Studio.\n+\n+If you are building under msys2 try installing the mingw-w64-x86_64-cmake\n+package instead of cmake:\n+\n+$ pacman -R cmake && pacman -S mingw-w64-x86_64-cmake\n+\");\n+            }\n+        }\n+    }\n+}"}, {"sha": "2fbf1a6ad1db251240d34a560176241d0ca5e602", "filename": "src/bootstrap/build/step.rs", "status": "added", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/046e6874c47ec55e23b7a566bca51d2920562485/src%2Fbootstrap%2Fbuild%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/046e6874c47ec55e23b7a566bca51d2920562485/src%2Fbootstrap%2Fbuild%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fstep.rs?ref=046e6874c47ec55e23b7a566bca51d2920562485", "patch": "@@ -0,0 +1,177 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::collections::HashSet;\n+\n+use build::{Build, Compiler};\n+\n+#[derive(Hash, Eq, PartialEq, Clone, Debug)]\n+pub struct Step<'a> {\n+    pub src: Source<'a>,\n+    pub target: &'a str,\n+}\n+\n+macro_rules! targets {\n+    ($m:ident) => {\n+        $m! {\n+            (rustc, Rustc { stage: u32 }),\n+            (libstd, Libstd { stage: u32, compiler: Compiler<'a> }),\n+            (librustc, Librustc { stage: u32, compiler: Compiler<'a> }),\n+            (llvm, Llvm { _dummy: () }),\n+            (compiler_rt, CompilerRt { _dummy: () }),\n+        }\n+    }\n+}\n+\n+macro_rules! item { ($a:item) => ($a) }\n+\n+macro_rules! define_source {\n+    ($(($short:ident, $name:ident { $($args:tt)* }),)*) => {\n+        item! {\n+            #[derive(Hash, Eq, PartialEq, Clone, Debug)]\n+            pub enum Source<'a> {\n+                $($name { $($args)* }),*\n+            }\n+        }\n+    }\n+}\n+\n+targets!(define_source);\n+\n+pub fn all(build: &Build) -> Vec<Step> {\n+    let mut ret = Vec::new();\n+    let mut all = HashSet::new();\n+    for target in top_level(build) {\n+        fill(build, &target, &mut ret, &mut all);\n+    }\n+    return ret;\n+\n+    fn fill<'a>(build: &'a Build,\n+                target: &Step<'a>,\n+                ret: &mut Vec<Step<'a>>,\n+                set: &mut HashSet<Step<'a>>) {\n+        if set.insert(target.clone()) {\n+            for dep in target.deps(build) {\n+                fill(build, &dep, ret, set);\n+            }\n+            ret.push(target.clone());\n+        }\n+    }\n+}\n+\n+fn top_level(build: &Build) -> Vec<Step> {\n+    let mut targets = Vec::new();\n+    let stage = build.flags.stage.unwrap_or(2);\n+\n+    let host = Step {\n+        src: Source::Llvm { _dummy: () },\n+        target: build.flags.host.iter().next()\n+                     .unwrap_or(&build.config.build),\n+    };\n+    let target = Step {\n+        src: Source::Llvm { _dummy: () },\n+        target: build.flags.target.iter().next().map(|x| &x[..])\n+                     .unwrap_or(host.target)\n+    };\n+\n+    add_steps(build, stage, &host, &target, &mut targets);\n+\n+    if targets.len() == 0 {\n+        let t = Step {\n+            src: Source::Llvm { _dummy: () },\n+            target: &build.config.build,\n+        };\n+        for host in build.config.host.iter() {\n+            if !build.flags.host.contains(host) {\n+                continue\n+            }\n+            let host = t.target(host);\n+            targets.push(host.librustc(stage, host.compiler(stage)));\n+            for target in build.config.target.iter() {\n+                if !build.flags.target.contains(target) {\n+                    continue\n+                }\n+                targets.push(host.target(target)\n+                                 .libstd(stage, host.compiler(stage)));\n+            }\n+        }\n+    }\n+\n+    return targets\n+\n+}\n+\n+fn add_steps<'a>(build: &'a Build,\n+                 stage: u32,\n+                 host: &Step<'a>,\n+                 target: &Step<'a>,\n+                 targets: &mut Vec<Step<'a>>) {\n+    for step in build.flags.step.iter() {\n+        let compiler = host.compiler(stage);\n+        match &step[..] {\n+            \"libstd\" => targets.push(target.libstd(stage, compiler)),\n+            \"librustc\" => targets.push(target.libstd(stage, compiler)),\n+            \"rustc\" => targets.push(host.rustc(stage)),\n+            \"llvm\" => targets.push(target.llvm(())),\n+            \"compiler-rt\" => targets.push(target.compiler_rt(())),\n+            _ => panic!(\"unknown build target: `{}`\", step),\n+        }\n+    }\n+}\n+\n+macro_rules! constructors {\n+    ($(($short:ident, $name:ident { $($arg:ident: $t:ty),* }),)*) => {$(\n+        fn $short(&self, $($arg: $t),*) -> Step<'a> {\n+            Step {\n+                src: Source::$name { $($arg: $arg),* },\n+                target: self.target,\n+            }\n+        }\n+    )*}\n+}\n+\n+impl<'a> Step<'a> {\n+    fn compiler(&self, stage: u32) -> Compiler<'a> {\n+        Compiler::new(stage, self.target)\n+    }\n+\n+    fn target(&self, target: &'a str) -> Step<'a> {\n+        Step { target: target, src: self.src.clone() }\n+    }\n+\n+    targets!(constructors);\n+\n+    pub fn deps(&self, build: &'a Build) -> Vec<Step<'a>> {\n+        match self.src {\n+            Source::Rustc { stage: 0 } => {\n+                if self.target == build.config.build {\n+                    Vec::new()\n+                } else {\n+                    let compiler = Compiler::new(0, &build.config.build);\n+                    vec![self.librustc(0, compiler)]\n+                }\n+            }\n+            Source::Rustc { stage } => {\n+                vec![self.librustc(stage - 1, self.compiler(stage - 1))]\n+            }\n+            Source::Librustc { stage, compiler } => {\n+                vec![self.libstd(stage, compiler), self.llvm(())]\n+            }\n+            Source::Libstd { stage: _, compiler } => {\n+                vec![self.compiler_rt(()),\n+                     self.rustc(compiler.stage).target(compiler.host)]\n+            }\n+            Source::CompilerRt { _dummy } => {\n+                vec![self.llvm(()).target(&build.config.build)]\n+            }\n+            Source::Llvm { _dummy } => Vec::new(),\n+        }\n+    }\n+}"}, {"sha": "6c700671f11115d396897e1e537a5ca66f6364f0", "filename": "src/bootstrap/build/util.rs", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/046e6874c47ec55e23b7a566bca51d2920562485/src%2Fbootstrap%2Fbuild%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/046e6874c47ec55e23b7a566bca51d2920562485/src%2Fbootstrap%2Fbuild%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Futil.rs?ref=046e6874c47ec55e23b7a566bca51d2920562485", "patch": "@@ -0,0 +1,97 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::env;\n+use std::path::{Path, PathBuf};\n+use std::fs;\n+use std::process::Command;\n+\n+use bootstrap::{dylib_path, dylib_path_var};\n+use filetime::FileTime;\n+\n+pub fn staticlib(name: &str, target: &str) -> String {\n+    if target.contains(\"windows-msvc\") {\n+        format!(\"{}.lib\", name)\n+    } else {\n+        format!(\"lib{}.a\", name)\n+    }\n+}\n+\n+pub fn mtime(path: &Path) -> FileTime {\n+    fs::metadata(path).map(|f| {\n+        FileTime::from_last_modification_time(&f)\n+    }).unwrap_or(FileTime::zero())\n+}\n+\n+#[allow(dead_code)] // this will be used soon\n+pub fn cp_r(src: &Path, dst: &Path) {\n+    for f in t!(fs::read_dir(src)) {\n+        let f = t!(f);\n+        let path = f.path();\n+        let name = path.file_name().unwrap();\n+        let dst = dst.join(name);\n+        if t!(f.file_type()).is_dir() {\n+            let _ = fs::remove_dir_all(&dst);\n+            t!(fs::create_dir(&dst));\n+            cp_r(&path, &dst);\n+        } else {\n+            let _ = fs::remove_file(&dst);\n+            t!(fs::hard_link(&path, dst));\n+        }\n+    }\n+}\n+\n+/// Given an executable called `name`, return the filename for the\n+/// executable for a particular target.\n+pub fn exe(name: &str, target: &str) -> String {\n+    if target.contains(\"windows\") {\n+        format!(\"{}.exe\", name)\n+    } else {\n+        name.to_string()\n+    }\n+}\n+\n+pub fn is_dylib(name: &str) -> bool {\n+    name.ends_with(\".dylib\") || name.ends_with(\".so\") || name.ends_with(\".dll\")\n+}\n+\n+pub fn libdir(target: &str) -> &'static str {\n+    if target.contains(\"windows\") {\"bin\"} else {\"lib\"}\n+}\n+\n+pub fn add_lib_path(path: Vec<PathBuf>, cmd: &mut Command) {\n+    let mut list = dylib_path();\n+    for path in path {\n+        list.insert(0, path);\n+    }\n+    cmd.env(dylib_path_var(), t!(env::join_paths(list)));\n+}\n+\n+#[allow(dead_code)] // this will be used soon\n+pub fn up_to_date(src: &Path, dst: &Path) -> bool {\n+    let threshold = mtime(dst);\n+    let meta = t!(fs::metadata(src));\n+    if meta.is_dir() {\n+        dir_up_to_date(src, &threshold)\n+    } else {\n+        FileTime::from_last_modification_time(&meta) <= threshold\n+    }\n+}\n+\n+fn dir_up_to_date(src: &Path, threshold: &FileTime) -> bool {\n+    t!(fs::read_dir(src)).map(|e| t!(e)).all(|e| {\n+        let meta = t!(e.metadata());\n+        if meta.is_dir() {\n+            dir_up_to_date(&e.path(), threshold)\n+        } else {\n+            FileTime::from_last_modification_time(&meta) < *threshold\n+        }\n+    })\n+}"}, {"sha": "3158a3ab058609a9719626dc656e01c38aee109b", "filename": "src/bootstrap/lib.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/046e6874c47ec55e23b7a566bca51d2920562485/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/046e6874c47ec55e23b7a566bca51d2920562485/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=046e6874c47ec55e23b7a566bca51d2920562485", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::env;\n+use std::ffi::OsString;\n+use std::path::PathBuf;\n+\n+pub fn dylib_path_var() -> &'static str {\n+    if cfg!(target_os = \"windows\") {\n+        \"PATH\"\n+    } else if cfg!(target_os = \"macos\") {\n+        \"DYLD_LIBRARY_PATH\"\n+    } else {\n+        \"LD_LIBRARY_PATH\"\n+    }\n+}\n+\n+pub fn dylib_path() -> Vec<PathBuf> {\n+    env::split_paths(&env::var_os(dylib_path_var()).unwrap_or(OsString::new()))\n+        .collect()\n+}"}, {"sha": "32432132c1730bfa42aa095ca2b3fe88b1189e3c", "filename": "src/bootstrap/main.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/046e6874c47ec55e23b7a566bca51d2920562485/src%2Fbootstrap%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/046e6874c47ec55e23b7a566bca51d2920562485/src%2Fbootstrap%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmain.rs?ref=046e6874c47ec55e23b7a566bca51d2920562485", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![deny(warnings)]\n+\n+extern crate bootstrap;\n+extern crate build_helper;\n+extern crate cmake;\n+extern crate filetime;\n+extern crate gcc;\n+extern crate getopts;\n+extern crate libc;\n+extern crate num_cpus;\n+extern crate rustc_serialize;\n+extern crate toml;\n+\n+use std::env;\n+\n+use build::{Flags, Config, Build};\n+\n+mod build;\n+\n+fn main() {\n+    let args = env::args().skip(1).collect::<Vec<_>>();\n+    let flags = Flags::parse(&args);\n+    let mut config = Config::parse(&flags.build, flags.config.clone());\n+    if std::fs::metadata(\"config.mk\").is_ok() {\n+        config.update_with_config_mk();\n+    }\n+    Build::new(flags, config).build();\n+}"}, {"sha": "0c30360ba79f046c16f0078149d5fdccc80a76b0", "filename": "src/bootstrap/rustc.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/046e6874c47ec55e23b7a566bca51d2920562485/src%2Fbootstrap%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/046e6874c47ec55e23b7a566bca51d2920562485/src%2Fbootstrap%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Frustc.rs?ref=046e6874c47ec55e23b7a566bca51d2920562485", "patch": "@@ -0,0 +1,91 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern crate bootstrap;\n+\n+use std::env;\n+use std::ffi::OsString;\n+use std::path::PathBuf;\n+use std::process::Command;\n+\n+fn main() {\n+    let args = env::args_os().skip(1).collect::<Vec<_>>();\n+    // Detect whether or not we're a build script depending on whether --target\n+    // is passed (a bit janky...)\n+    let is_build_script = args.iter()\n+                              .position(|i| i.to_str() == Some(\"--target\"))\n+                              .is_none();\n+\n+    // Build scripts always use the snapshot compiler which is guaranteed to be\n+    // able to produce an executable, whereas intermediate compilers may not\n+    // have the standard library built yet and may not be able to produce an\n+    // executable. Otherwise we just use the standard compiler we're\n+    // bootstrapping with.\n+    let rustc = if is_build_script {\n+        env::var_os(\"RUSTC_SNAPSHOT\").unwrap()\n+    } else {\n+        env::var_os(\"RUSTC_REAL\").unwrap()\n+    };\n+\n+    let mut cmd = Command::new(rustc);\n+    cmd.args(&args)\n+       .arg(\"--cfg\").arg(format!(\"stage{}\", env::var(\"RUSTC_STAGE\").unwrap()));\n+\n+    if is_build_script {\n+        // Build scripts are always built with the snapshot compiler, so we need\n+        // to be sure to set up the right path information for the OS dynamic\n+        // linker to find the libraries in question.\n+        if let Some(p) = env::var_os(\"RUSTC_SNAPSHOT_LIBDIR\") {\n+            let mut path = bootstrap::dylib_path();\n+            path.insert(0, PathBuf::from(p));\n+            cmd.env(bootstrap::dylib_path_var(), env::join_paths(path).unwrap());\n+        }\n+    } else {\n+        cmd.arg(\"--sysroot\").arg(env::var_os(\"RUSTC_SYSROOT\").unwrap());\n+\n+        // When we build Rust dylibs they're all intended for intermediate\n+        // usage, so make sure we pass the -Cprefer-dynamic flag instead of\n+        // linking all deps statically into the dylib.\n+        cmd.arg(\"-Cprefer-dynamic\");\n+\n+        if let Some(s) = env::var_os(\"MUSL_ROOT\") {\n+            let mut root = OsString::from(\"native=\");\n+            root.push(&s);\n+            root.push(\"/lib\");\n+            cmd.arg(\"-L\").arg(&root);\n+        }\n+    }\n+\n+    // Set various options from config.toml to configure how we're building\n+    // code.\n+    if env::var(\"RUSTC_DEBUGINFO\") == Ok(\"true\".to_string()) {\n+        cmd.arg(\"-g\");\n+    }\n+    if env::var(\"RUSTC_RPATH\") == Ok(\"true\".to_string()) {\n+        cmd.arg(\"-Crpath\");\n+    }\n+    let debug_assertions = match env::var(\"RUSTC_DEBUG_ASSERTIONS\") {\n+        Ok(s) => if s == \"true\" {\"y\"} else {\"n\"},\n+        Err(..) => \"n\",\n+    };\n+    cmd.arg(\"-C\").arg(format!(\"debug-assertions={}\", debug_assertions));\n+    if let Ok(s) = env::var(\"RUSTC_CODEGEN_UNITS\") {\n+        cmd.arg(\"-C\").arg(format!(\"codegen-units={}\", s));\n+    }\n+    if let Ok(s) = env::var(\"RUSTC_FLAGS\") {\n+        cmd.args(&s.split(\" \").filter(|s| !s.is_empty()).collect::<Vec<_>>());\n+    }\n+\n+    // Actually run the compiler!\n+    std::process::exit(match cmd.status() {\n+        Ok(s) => s.code().unwrap_or(1),\n+        Err(e) => panic!(\"\\n\\nfailed to run {:?}: {}\\n\\n\", cmd, e),\n+    })\n+}"}, {"sha": "01d704f816bbc8fc00813d2636f3fe44a847db35", "filename": "src/build_helper/Cargo.toml", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/046e6874c47ec55e23b7a566bca51d2920562485/src%2Fbuild_helper%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/046e6874c47ec55e23b7a566bca51d2920562485/src%2Fbuild_helper%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuild_helper%2FCargo.toml?ref=046e6874c47ec55e23b7a566bca51d2920562485", "patch": "@@ -0,0 +1,8 @@\n+[package]\n+name = \"build_helper\"\n+version = \"0.1.0\"\n+authors = [\"The Rust Project Developers\"]\n+\n+[lib]\n+name = \"build_helper\"\n+path = \"lib.rs\""}, {"sha": "092a1cabc746fb8ab44139c76e565eb8be397c09", "filename": "src/build_helper/lib.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/046e6874c47ec55e23b7a566bca51d2920562485/src%2Fbuild_helper%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/046e6874c47ec55e23b7a566bca51d2920562485/src%2Fbuild_helper%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuild_helper%2Flib.rs?ref=046e6874c47ec55e23b7a566bca51d2920562485", "patch": "@@ -0,0 +1,68 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![deny(warnings)]\n+\n+use std::process::{Command, Stdio};\n+use std::path::{Path, PathBuf};\n+\n+pub fn run(cmd: &mut Command) {\n+    println!(\"running: {:?}\", cmd);\n+    run_silent(cmd);\n+}\n+\n+pub fn run_silent(cmd: &mut Command) {\n+    let status = match cmd.status() {\n+        Ok(status) => status,\n+        Err(e) => fail(&format!(\"failed to execute command: {}\", e)),\n+    };\n+    if !status.success() {\n+        fail(&format!(\"command did not execute successfully: {:?}\\n\\\n+                       expected success, got: {}\", cmd, status));\n+    }\n+}\n+\n+pub fn gnu_target(target: &str) -> String {\n+    match target {\n+        \"i686-pc-windows-msvc\" => \"i686-pc-win32\".to_string(),\n+        \"x86_64-pc-windows-msvc\" => \"x86_64-pc-win32\".to_string(),\n+        \"i686-pc-windows-gnu\" => \"i686-w64-mingw32\".to_string(),\n+        \"x86_64-pc-windows-gnu\" => \"x86_64-w64-mingw32\".to_string(),\n+        s => s.to_string(),\n+    }\n+}\n+\n+pub fn cc2ar(cc: &Path, target: &str) -> PathBuf {\n+    if target.contains(\"musl\") || target.contains(\"msvc\") {\n+        PathBuf::from(\"ar\")\n+    } else {\n+        let file = cc.file_name().unwrap().to_str().unwrap();\n+        cc.parent().unwrap().join(file.replace(\"gcc\", \"ar\")\n+                                      .replace(\"cc\", \"ar\")\n+                                      .replace(\"clang\", \"ar\"))\n+    }\n+}\n+\n+pub fn output(cmd: &mut Command) -> String {\n+    let output = match cmd.stderr(Stdio::inherit()).output() {\n+        Ok(status) => status,\n+        Err(e) => fail(&format!(\"failed to execute command: {}\", e)),\n+    };\n+    if !output.status.success() {\n+        panic!(\"command did not execute successfully: {:?}\\n\\\n+                expected success, got: {}\", cmd, output.status);\n+    }\n+    String::from_utf8(output.stdout).unwrap()\n+}\n+\n+fn fail(s: &str) -> ! {\n+    println!(\"\\n\\n{}\\n\\n\", s);\n+    std::process::exit(1);\n+}"}, {"sha": "fd3f4bf0b13b1111f57a7e2ba3d394821b443663", "filename": "src/etc/tidy.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/046e6874c47ec55e23b7a566bca51d2920562485/src%2Fetc%2Ftidy.py", "raw_url": "https://github.com/rust-lang/rust/raw/046e6874c47ec55e23b7a566bca51d2920562485/src%2Fetc%2Ftidy.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftidy.py?ref=046e6874c47ec55e23b7a566bca51d2920562485", "patch": "@@ -147,7 +147,7 @@ def interesting_file(f):\n                         report_err(\"snapshot out of date (\" + date\n                             + \"): \" + line)\n                 else:\n-                    if \"SNAP\" in line:\n+                    if \"SNAP \" in line:\n                         report_warn(\"unmatched SNAP line: \" + line)\n \n             if cr_flag in line:"}, {"sha": "86186222d90bb4806bc3d6690d2b693517ae3726", "filename": "src/nightlies.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/046e6874c47ec55e23b7a566bca51d2920562485/src%2Fnightlies.txt", "raw_url": "https://github.com/rust-lang/rust/raw/046e6874c47ec55e23b7a566bca51d2920562485/src%2Fnightlies.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fnightlies.txt?ref=046e6874c47ec55e23b7a566bca51d2920562485", "patch": "@@ -0,0 +1,2 @@\n+rustc: 2015-12-19\n+cargo: 2016-01-21"}, {"sha": "db1a87679c2716ebf6956e6ea32ab817c4282f9d", "filename": "src/rustc/Cargo.lock", "status": "added", "additions": 356, "deletions": 0, "changes": 356, "blob_url": "https://github.com/rust-lang/rust/blob/046e6874c47ec55e23b7a566bca51d2920562485/src%2Frustc%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/046e6874c47ec55e23b7a566bca51d2920562485/src%2Frustc%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2FCargo.lock?ref=046e6874c47ec55e23b7a566bca51d2920562485", "patch": "@@ -0,0 +1,356 @@\n+[root]\n+name = \"rustc-main\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"rustbook 0.0.0\",\n+ \"rustc_back 0.0.0\",\n+ \"rustc_driver 0.0.0\",\n+ \"rustdoc 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"advapi32-sys\"\n+version = \"0.1.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"winapi 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"arena\"\n+version = \"0.0.0\"\n+\n+[[package]]\n+name = \"build_helper\"\n+version = \"0.1.0\"\n+\n+[[package]]\n+name = \"flate\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"build_helper 0.1.0\",\n+ \"gcc 0.3.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"fmt_macros\"\n+version = \"0.0.0\"\n+\n+[[package]]\n+name = \"gcc\"\n+version = \"0.3.17\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"advapi32-sys 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"getopts\"\n+version = \"0.0.0\"\n+\n+[[package]]\n+name = \"graphviz\"\n+version = \"0.0.0\"\n+\n+[[package]]\n+name = \"log\"\n+version = \"0.0.0\"\n+\n+[[package]]\n+name = \"rbml\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"log 0.0.0\",\n+ \"serialize 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustbook\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"rustc_back 0.0.0\",\n+ \"rustdoc 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"arena 0.0.0\",\n+ \"flate 0.0.0\",\n+ \"fmt_macros 0.0.0\",\n+ \"getopts 0.0.0\",\n+ \"graphviz 0.0.0\",\n+ \"log 0.0.0\",\n+ \"rbml 0.0.0\",\n+ \"rustc_back 0.0.0\",\n+ \"rustc_data_structures 0.0.0\",\n+ \"rustc_front 0.0.0\",\n+ \"rustc_llvm 0.0.0\",\n+ \"serialize 0.0.0\",\n+ \"syntax 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc_back\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"log 0.0.0\",\n+ \"rustc_front 0.0.0\",\n+ \"rustc_llvm 0.0.0\",\n+ \"serialize 0.0.0\",\n+ \"syntax 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc_borrowck\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"graphviz 0.0.0\",\n+ \"log 0.0.0\",\n+ \"rustc 0.0.0\",\n+ \"rustc_front 0.0.0\",\n+ \"syntax 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc_data_structures\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"log 0.0.0\",\n+ \"serialize 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc_driver\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"arena 0.0.0\",\n+ \"flate 0.0.0\",\n+ \"getopts 0.0.0\",\n+ \"graphviz 0.0.0\",\n+ \"log 0.0.0\",\n+ \"rustc 0.0.0\",\n+ \"rustc_back 0.0.0\",\n+ \"rustc_borrowck 0.0.0\",\n+ \"rustc_front 0.0.0\",\n+ \"rustc_lint 0.0.0\",\n+ \"rustc_llvm 0.0.0\",\n+ \"rustc_metadata 0.0.0\",\n+ \"rustc_mir 0.0.0\",\n+ \"rustc_plugin 0.0.0\",\n+ \"rustc_privacy 0.0.0\",\n+ \"rustc_resolve 0.0.0\",\n+ \"rustc_trans 0.0.0\",\n+ \"rustc_typeck 0.0.0\",\n+ \"serialize 0.0.0\",\n+ \"syntax 0.0.0\",\n+ \"syntax_ext 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc_front\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"log 0.0.0\",\n+ \"serialize 0.0.0\",\n+ \"syntax 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc_lint\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"log 0.0.0\",\n+ \"rustc 0.0.0\",\n+ \"rustc_back 0.0.0\",\n+ \"rustc_front 0.0.0\",\n+ \"syntax 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc_llvm\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"build_helper 0.1.0\",\n+ \"gcc 0.3.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"rustc_metadata\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"flate 0.0.0\",\n+ \"log 0.0.0\",\n+ \"rbml 0.0.0\",\n+ \"rustc 0.0.0\",\n+ \"rustc_back 0.0.0\",\n+ \"rustc_front 0.0.0\",\n+ \"rustc_llvm 0.0.0\",\n+ \"serialize 0.0.0\",\n+ \"syntax 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc_mir\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"graphviz 0.0.0\",\n+ \"log 0.0.0\",\n+ \"rustc 0.0.0\",\n+ \"rustc_back 0.0.0\",\n+ \"rustc_data_structures 0.0.0\",\n+ \"rustc_front 0.0.0\",\n+ \"syntax 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc_platform_intrinsics\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"rustc 0.0.0\",\n+ \"rustc_llvm 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc_plugin\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"log 0.0.0\",\n+ \"rustc 0.0.0\",\n+ \"rustc_front 0.0.0\",\n+ \"rustc_metadata 0.0.0\",\n+ \"syntax 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc_privacy\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"log 0.0.0\",\n+ \"rustc 0.0.0\",\n+ \"rustc_front 0.0.0\",\n+ \"syntax 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc_resolve\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"arena 0.0.0\",\n+ \"log 0.0.0\",\n+ \"rustc 0.0.0\",\n+ \"rustc_front 0.0.0\",\n+ \"syntax 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc_trans\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"arena 0.0.0\",\n+ \"flate 0.0.0\",\n+ \"getopts 0.0.0\",\n+ \"graphviz 0.0.0\",\n+ \"log 0.0.0\",\n+ \"rustc 0.0.0\",\n+ \"rustc_back 0.0.0\",\n+ \"rustc_data_structures 0.0.0\",\n+ \"rustc_front 0.0.0\",\n+ \"rustc_llvm 0.0.0\",\n+ \"rustc_mir 0.0.0\",\n+ \"rustc_platform_intrinsics 0.0.0\",\n+ \"serialize 0.0.0\",\n+ \"syntax 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc_typeck\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"arena 0.0.0\",\n+ \"fmt_macros 0.0.0\",\n+ \"log 0.0.0\",\n+ \"rustc 0.0.0\",\n+ \"rustc_back 0.0.0\",\n+ \"rustc_front 0.0.0\",\n+ \"rustc_platform_intrinsics 0.0.0\",\n+ \"syntax 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustdoc\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"arena 0.0.0\",\n+ \"build_helper 0.1.0\",\n+ \"gcc 0.3.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"getopts 0.0.0\",\n+ \"log 0.0.0\",\n+ \"rustc 0.0.0\",\n+ \"rustc_back 0.0.0\",\n+ \"rustc_driver 0.0.0\",\n+ \"rustc_front 0.0.0\",\n+ \"rustc_lint 0.0.0\",\n+ \"rustc_metadata 0.0.0\",\n+ \"rustc_resolve 0.0.0\",\n+ \"rustc_trans 0.0.0\",\n+ \"serialize 0.0.0\",\n+ \"syntax 0.0.0\",\n+ \"test 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"serialize\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"log 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"syntax\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"arena 0.0.0\",\n+ \"fmt_macros 0.0.0\",\n+ \"log 0.0.0\",\n+ \"serialize 0.0.0\",\n+ \"term 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"syntax_ext\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"fmt_macros 0.0.0\",\n+ \"syntax 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"term\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"log 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"test\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"getopts 0.0.0\",\n+ \"serialize 0.0.0\",\n+ \"term 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"winapi\"\n+version = \"0.2.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"winapi-build\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+"}, {"sha": "9fcefd9d3a4dd5e399304489270f3865c25908b9", "filename": "src/rustc/Cargo.toml", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/046e6874c47ec55e23b7a566bca51d2920562485/src%2Frustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/046e6874c47ec55e23b7a566bca51d2920562485/src%2Frustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2FCargo.toml?ref=046e6874c47ec55e23b7a566bca51d2920562485", "patch": "@@ -0,0 +1,36 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc-main\"\n+version = \"0.0.0\"\n+\n+[[bin]]\n+name = \"rustc\"\n+path = \"rustc.rs\"\n+\n+[[bin]]\n+name = \"rustdoc\"\n+path = \"rustdoc.rs\"\n+\n+[[bin]]\n+name = \"rustbook\"\n+path = \"rustbook.rs\"\n+\n+[profile.release]\n+opt-level = 2\n+\n+# These options are controlled from our rustc wrapper script, so turn them off\n+# here and have them controlled elsewhere.\n+[profile.dev]\n+debug = false\n+debug-assertions = false\n+\n+# All optional dependencies so the features passed to this Cargo.toml select\n+# what should actually be built.\n+[dependencies]\n+rustbook = { path = \"../rustbook\", optional = true }\n+rustc_back = { path = \"../librustc_back\" }\n+rustc_driver = { path = \"../librustc_driver\" }\n+rustdoc = { path = \"../librustdoc\", optional = true }\n+\n+[features]\n+jemalloc = [\"rustc_back/jemalloc\"]"}, {"sha": "a7860b50e08ff50aa19ebf1f256c5f4daba474d9", "filename": "src/rustc/libc_shim/Cargo.toml", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/046e6874c47ec55e23b7a566bca51d2920562485/src%2Frustc%2Flibc_shim%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/046e6874c47ec55e23b7a566bca51d2920562485/src%2Frustc%2Flibc_shim%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Flibc_shim%2FCargo.toml?ref=046e6874c47ec55e23b7a566bca51d2920562485", "patch": "@@ -0,0 +1,20 @@\n+# This is a shim Cargo.toml over the \"real Cargo.toml\" found in the libc\n+# repository itself. The purpose for this is to add a build script which prints\n+# out `--cfg stdbuild` to mirror the makefiles' build system.\n+#\n+# Note that other than that this isn't actually needed, and we should probably\n+# remove this shim in favor of just working with cargo features directly with\n+# libc. That should make everything nicer!\n+\n+[package]\n+name = \"libc\"\n+version = \"0.0.0\"\n+authors = [\"The Rust Project Developers\"]\n+build = \"build.rs\"\n+\n+[lib]\n+name = \"libc\"\n+path = \"../../liblibc/src/lib.rs\"\n+\n+[dependencies]\n+core = { path = \"../../libcore\" }"}, {"sha": "bc428d6908235622cf3206dd5c90366d9ef3fbba", "filename": "src/rustc/libc_shim/build.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/046e6874c47ec55e23b7a566bca51d2920562485/src%2Frustc%2Flibc_shim%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/046e6874c47ec55e23b7a566bca51d2920562485/src%2Frustc%2Flibc_shim%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Flibc_shim%2Fbuild.rs?ref=046e6874c47ec55e23b7a566bca51d2920562485", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// See comments in Cargo.toml for why this exists\n+\n+fn main() {\n+    println!(\"cargo:rustc-cfg=stdbuild\");\n+}"}, {"sha": "6f78f78bc55a61f9fddf98a6503ccda3a11663ca", "filename": "src/rustc/rustbook.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/046e6874c47ec55e23b7a566bca51d2920562485/src%2Frustc%2Frustbook.rs", "raw_url": "https://github.com/rust-lang/rust/raw/046e6874c47ec55e23b7a566bca51d2920562485/src%2Frustc%2Frustbook.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Frustbook.rs?ref=046e6874c47ec55e23b7a566bca51d2920562485", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern crate rustbook;\n+\n+fn main() { rustbook::main() }\n+"}, {"sha": "bfd01146d2c4644eda47b5490b0789b424dd53f3", "filename": "src/rustc/rustc.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/046e6874c47ec55e23b7a566bca51d2920562485/src%2Frustc%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/046e6874c47ec55e23b7a566bca51d2920562485/src%2Frustc%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Frustc.rs?ref=046e6874c47ec55e23b7a566bca51d2920562485", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_private)]\n+\n+extern crate rustc_driver;\n+\n+fn main() { rustc_driver::main() }"}, {"sha": "6fecd3a27a8a459f2d3237fe67d3bc4be2ca5502", "filename": "src/rustc/rustdoc.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/046e6874c47ec55e23b7a566bca51d2920562485/src%2Frustc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/046e6874c47ec55e23b7a566bca51d2920562485/src%2Frustc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Frustdoc.rs?ref=046e6874c47ec55e23b7a566bca51d2920562485", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustdoc)]\n+\n+extern crate rustdoc;\n+\n+fn main() { rustdoc::main() }"}, {"sha": "d88e9c7e5aa942797bd3823ce10c1508f5131d6e", "filename": "src/rustc/std_shim/Cargo.lock", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/046e6874c47ec55e23b7a566bca51d2920562485/src%2Frustc%2Fstd_shim%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/046e6874c47ec55e23b7a566bca51d2920562485/src%2Frustc%2Fstd_shim%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fstd_shim%2FCargo.lock?ref=046e6874c47ec55e23b7a566bca51d2920562485", "patch": "@@ -0,0 +1,124 @@\n+[root]\n+name = \"std_shim\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"std 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"advapi32-sys\"\n+version = \"0.1.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"winapi 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"alloc\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"alloc_system 0.0.0\",\n+ \"core 0.0.0\",\n+ \"libc 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"alloc_jemalloc\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"build_helper 0.1.0\",\n+ \"core 0.0.0\",\n+ \"gcc 0.3.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"alloc_system\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"core 0.0.0\",\n+ \"libc 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"build_helper\"\n+version = \"0.1.0\"\n+\n+[[package]]\n+name = \"collections\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"alloc 0.0.0\",\n+ \"core 0.0.0\",\n+ \"rustc_unicode 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"core\"\n+version = \"0.0.0\"\n+\n+[[package]]\n+name = \"gcc\"\n+version = \"0.3.17\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"advapi32-sys 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"libc\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"core 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rand\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"core 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc_bitflags\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"core 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc_unicode\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"core 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"std\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"alloc 0.0.0\",\n+ \"alloc_jemalloc 0.0.0\",\n+ \"alloc_system 0.0.0\",\n+ \"build_helper 0.1.0\",\n+ \"collections 0.0.0\",\n+ \"core 0.0.0\",\n+ \"gcc 0.3.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.0.0\",\n+ \"rand 0.0.0\",\n+ \"rustc_bitflags 0.0.0\",\n+ \"rustc_unicode 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"winapi\"\n+version = \"0.2.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"winapi-build\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+"}, {"sha": "1ce3937157da04de1a804f56441b5cc9e9ee8dfa", "filename": "src/rustc/std_shim/Cargo.toml", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/046e6874c47ec55e23b7a566bca51d2920562485/src%2Frustc%2Fstd_shim%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/046e6874c47ec55e23b7a566bca51d2920562485/src%2Frustc%2Fstd_shim%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fstd_shim%2FCargo.toml?ref=046e6874c47ec55e23b7a566bca51d2920562485", "patch": "@@ -0,0 +1,46 @@\n+# This is a shim Cargo.toml which serves as a proxy for building the standard\n+# library. The reason for this is a little subtle, as one might reasonably\n+# expect that we just `cargo build` the standard library itself.\n+#\n+# One of the output artifacts for the standard library is a dynamic library, and\n+# on platforms like OSX the name of the output artifact is actually encoded into\n+# the library itself (similar to a soname on Linux). When the library is linked\n+# against, this encoded name is what's literally looked for at runtime when the\n+# dynamic loader is probing for libraries.\n+#\n+# Cargo, however, by default will not mangle the output filename of the\n+# top-level target. If we were to run `cargo build` on libstd itself, we would\n+# generate a file `libstd.so`. When installing, however, this file is called\n+# something like `libstd-abcdef0123.so`. On OSX at least this causes a failure\n+# at runtime because the encoded \"soname\" is `libstd.so`, not what the file is\n+# actually called.\n+#\n+# By using this shim library to build the standard library by proxy we sidestep\n+# this problem. The standard library is built with mangled hex already in its\n+# name so there's nothing extra we need to do.\n+\n+[package]\n+name = \"std_shim\"\n+version = \"0.1.0\"\n+authors = [\"The Rust Project Developers\"]\n+\n+[lib]\n+name = \"std_shim\"\n+path = \"lib.rs\"\n+\n+[profile.release]\n+opt-level = 2\n+\n+# These options are controlled from our rustc wrapper script, so turn them off\n+# here and have them controlled elsewhere.\n+[profile.dev]\n+debug = false\n+debug-assertions = false\n+\n+[dependencies]\n+std = { path = \"../../libstd\" }\n+\n+# Reexport features from std\n+[features]\n+jemalloc = [\"std/jemalloc\"]\n+debug-jemalloc = [\"std/debug-jemalloc\"]"}, {"sha": "3cf4cfab135fd4f7d4a84c8a4708d9fae1b99c4e", "filename": "src/rustc/std_shim/lib.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/046e6874c47ec55e23b7a566bca51d2920562485/src%2Frustc%2Fstd_shim%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/046e6874c47ec55e23b7a566bca51d2920562485/src%2Frustc%2Fstd_shim%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fstd_shim%2Flib.rs?ref=046e6874c47ec55e23b7a566bca51d2920562485", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// See comments in Cargo.toml for why this exists"}]}