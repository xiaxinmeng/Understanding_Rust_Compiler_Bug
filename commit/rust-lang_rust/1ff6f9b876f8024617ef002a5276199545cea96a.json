{"sha": "1ff6f9b876f8024617ef002a5276199545cea96a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmZjZmOWI4NzZmODAyNDYxN2VmMDAyYTUyNzYxOTk1NDVjZWE5NmE=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-06-27T17:11:57Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-06-28T04:10:09Z"}, "message": "Add task-local storage in libcore.", "tree": {"sha": "c1f88abaa50d74992e1231f1210f620271cb4b3b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c1f88abaa50d74992e1231f1210f620271cb4b3b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ff6f9b876f8024617ef002a5276199545cea96a", "comment_count": 2, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ff6f9b876f8024617ef002a5276199545cea96a", "html_url": "https://github.com/rust-lang/rust/commit/1ff6f9b876f8024617ef002a5276199545cea96a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ff6f9b876f8024617ef002a5276199545cea96a/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ba3028d8b7acb0c97859ea438f2beb4ccd364f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ba3028d8b7acb0c97859ea438f2beb4ccd364f9", "html_url": "https://github.com/rust-lang/rust/commit/1ba3028d8b7acb0c97859ea438f2beb4ccd364f9"}], "stats": {"total": 309, "additions": 308, "deletions": 1}, "files": [{"sha": "2867b8e8703e88f5a62f6ef4cf64a372af68afc3", "filename": "src/libcore/task.rs", "status": "modified", "additions": 286, "deletions": 0, "changes": 286, "blob_url": "https://github.com/rust-lang/rust/blob/1ff6f9b876f8024617ef002a5276199545cea96a/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ff6f9b876f8024617ef002a5276199545cea96a/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=1ff6f9b876f8024617ef002a5276199545cea96a", "patch": "@@ -23,6 +23,7 @@ spawn {||\n \"];\n \n import result::result;\n+import dvec::extensions;\n \n export task;\n export task_result;\n@@ -53,6 +54,12 @@ export failing;\n export get_task;\n export unkillable;\n \n+export local_data_key;\n+export local_data_pop;\n+export local_data_get;\n+export local_data_set;\n+export local_data_modify;\n+\n /* Data types */\n \n #[doc = \"A handle to a task\"]\n@@ -573,6 +580,187 @@ fn spawn_raw(opts: task_opts, +f: fn~()) {\n \n }\n \n+/****************************************************************************\n+ * Task local data management\n+ *\n+ * Allows storing boxes with arbitrary types inside, to be accessed anywhere\n+ * within a task, keyed by a pointer to a global finaliser function. Useful\n+ * for task-spawning metadata (tracking linked failure state), dynamic\n+ * variables, and interfacing with foreign code with bad callback interfaces.\n+ *\n+ * To use, declare a monomorphic global function at the type to store, and use\n+ * it as the 'key' when accessing. See the 'tls' tests below for examples.\n+ *\n+ * Casting 'Arcane Sight' reveals an overwhelming aura of Transmutation magic.\n+ ****************************************************************************/\n+\n+#[doc = \"Indexes a task-local data slot. The function itself is used to\n+automatically finalise stored values; also, its code pointer is used for\n+comparison. Recommended use is to write an empty function for each desired\n+task-local data slot (and use class destructors, instead of code inside the\n+finaliser, if specific teardown is needed). DO NOT use multiple instantiations\n+of a single polymorphic function to index data of different types; arbitrary\n+type coercion is possible this way. The interface is safe as long as all key\n+functions are monomorphic.\"]\n+type local_data_key<T> = fn@(+@T);\n+\n+// We use dvec because it's the best data structure in core. If TLS is used\n+// heavily in future, this could be made more efficient with a proper map.\n+type task_local_element = (*libc::c_void, *libc::c_void, fn@(+*libc::c_void));\n+// Has to be a pointer at the outermost layer; the native call returns void *.\n+type task_local_map = @dvec::dvec<option<task_local_element>>;\n+\n+crust fn cleanup_task_local_map(map_ptr: *libc::c_void) unsafe {\n+    assert !map_ptr.is_null();\n+    // Get and keep the single reference that was created at the beginning.\n+    let map: task_local_map = unsafe::reinterpret_cast(map_ptr);\n+    for (*map).each {|entry|\n+        alt entry {\n+            // Finaliser drops data. We drop the finaliser implicitly here.\n+            some((_key, data, finalise_fn)) { finalise_fn(data); }\n+            none { }\n+        }\n+    }\n+}\n+\n+// Gets the map from the runtime. Lazily initialises if not done so already.\n+unsafe fn get_task_local_map(task: *rust_task) -> task_local_map {\n+    // Relies on the runtime initialising the pointer to null.\n+    // NOTE: The map's box lives in TLS invisibly referenced once. Each time\n+    // we retrieve it for get/set, we make another reference, which get/set\n+    // drop when they finish. No \"re-storing after modifying\" is needed.\n+    let map_ptr = rustrt::rust_get_task_local_data(task);\n+    if map_ptr.is_null() {\n+        let map: task_local_map = @dvec::dvec();\n+        // Use reinterpret_cast -- transmute would take map away from us also.\n+        rustrt::rust_set_task_local_data(task, unsafe::reinterpret_cast(map));\n+        rustrt::rust_task_local_data_atexit(task, cleanup_task_local_map);\n+        // Also need to reference it an extra time to keep it for now.\n+        unsafe::bump_box_refcount(map);\n+        map\n+    } else {\n+        let map = unsafe::transmute(map_ptr);\n+        unsafe::bump_box_refcount(map);\n+        map\n+    }\n+}\n+\n+unsafe fn key_to_key_value<T>(key: local_data_key<T>) -> *libc::c_void {\n+    // Keys are closures, which are (fnptr,envptr) pairs. Use fnptr.\n+    // Use reintepret_cast -- transmute would leak (forget) the closure.\n+    let pair: (*libc::c_void, *libc::c_void) = unsafe::reinterpret_cast(key);\n+    tuple::first(pair)\n+}\n+\n+// If returning some(..), returns with @T with the map's reference. Careful!\n+unsafe fn local_data_lookup<T>(map: task_local_map, key: local_data_key<T>)\n+        -> option<(uint, *libc::c_void, fn@(+*libc::c_void))> {\n+    let key_value = key_to_key_value(key);\n+    let map_pos = (*map).position {|entry|\n+        alt entry { some((k,_,_)) { k == key_value } none { false } }\n+    };\n+    map_pos.map {|index|\n+        // .get() is guaranteed because of \"none { false }\" above.\n+        let (_, data_ptr, finaliser) = (*map)[index].get();\n+        (index, data_ptr, finaliser)\n+    }\n+}\n+\n+unsafe fn local_get_helper<T>(task: *rust_task, key: local_data_key<T>,\n+                              do_pop: bool) -> option<@T> {\n+    let map = get_task_local_map(task);\n+    // Interpret our findings from the map\n+    local_data_lookup(map, key).map {|result|\n+        // A reference count magically appears on 'data' out of thin air.\n+        // 'data' has the reference we originally stored it with. We either\n+        // need to erase it from the map or artificially bump the count.\n+        let (index, data_ptr, _) = result;\n+        let data: @T = unsafe::transmute(data_ptr);\n+        if do_pop {\n+            (*map).set_elt(index, none);\n+        } else {\n+            unsafe::bump_box_refcount(data);\n+        }\n+        data\n+    }\n+}\n+\n+unsafe fn local_pop<T>(task: *rust_task,\n+                       key: local_data_key<T>) -> option<@T> {\n+    local_get_helper(task, key, true)\n+}\n+\n+unsafe fn local_get<T>(task: *rust_task,\n+                       key: local_data_key<T>) -> option<@T> {\n+    local_get_helper(task, key, false)\n+}\n+\n+unsafe fn local_set<T>(task: *rust_task, key: local_data_key<T>, -data: @T) {\n+    let map = get_task_local_map(task);\n+    // Store key+data as *voids. Data is invisibly referenced once; key isn't.\n+    let keyval = key_to_key_value(key);\n+    let data_ptr = unsafe::transmute(data);\n+    // Finaliser is called at task exit to de-reference up remaining entries.\n+    let finaliser: fn@(+*libc::c_void) = unsafe::reinterpret_cast(key);\n+    // Construct new entry to store in the map.\n+    let new_entry = some((keyval, data_ptr, finaliser));\n+    // Find a place to put it.\n+    alt local_data_lookup(map, key) {\n+        some((index, old_data_ptr, old_finaliser)) {\n+            // Key already had a value set, old_data_ptr, whose reference we\n+            // need to drop. After that, overwriting its slot will be safe.\n+            // (The heap-allocated finaliser will be freed in the overwrite.)\n+            // FIXME(2734): just transmuting old_data_ptr to @T doesn't work,\n+            // similarly to the sample there (but more our/unsafety's fault?).\n+            old_finaliser(old_data_ptr);\n+            (*map).set_elt(index, new_entry);\n+        }\n+        none {\n+            // Find an empty slot. If not, grow the vector.\n+            alt (*map).position({|x| x == none}) {\n+                some(empty_index) {\n+                    (*map).set_elt(empty_index, new_entry);\n+                }\n+                none {\n+                    (*map).push(new_entry);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+unsafe fn local_modify<T>(task: *rust_task, key: local_data_key<T>,\n+                          modify_fn: fn(option<@T>) -> option<@T>) {\n+    // Could be more efficient by doing the lookup work, but this is easy.\n+    let newdata = modify_fn(local_pop(task, key));\n+    if newdata.is_some() {\n+        local_set(task, key, option::unwrap(newdata));\n+    }\n+}\n+\n+/* Exported interface for task-local data (plus local_data_key above). */\n+#[doc = \"Remove a task-local data value from the table, returning the\n+reference that was originally created to insert it.\"]\n+unsafe fn local_data_pop<T>(key: local_data_key<T>) -> option<@T> {\n+    local_pop(rustrt::rust_get_task(), key)\n+}\n+#[doc = \"Retrieve a task-local data value. It will also be kept alive in the\n+table until explicitly removed.\"]\n+unsafe fn local_data_get<T>(key: local_data_key<T>) -> option<@T> {\n+    local_get(rustrt::rust_get_task(), key)\n+}\n+#[doc = \"Store a value in task-local data. If this key already has a value,\n+that value is overwritten (and its destructor is run).\"]\n+unsafe fn local_data_set<T>(key: local_data_key<T>, -data: @T) {\n+    local_set(rustrt::rust_get_task(), key, data)\n+}\n+#[doc = \"Modify a task-local data value. If the function returns 'none', the\n+data is removed (and its reference dropped).\"]\n+unsafe fn local_data_modify<T>(key: local_data_key<T>,\n+                               modify_fn: fn(option<@T>) -> option<@T>) {\n+    local_modify(rustrt::rust_get_task(), key, modify_fn)\n+}\n+\n native mod rustrt {\n     #[rust_stack]\n     fn rust_task_yield(task: *rust_task, &killed: bool);\n@@ -596,6 +784,13 @@ native mod rustrt {\n     fn rust_osmain_sched_id() -> sched_id;\n     fn rust_task_inhibit_kill();\n     fn rust_task_allow_kill();\n+\n+    #[rust_stack]\n+    fn rust_get_task_local_data(task: *rust_task) -> *libc::c_void;\n+    #[rust_stack]\n+    fn rust_set_task_local_data(task: *rust_task, map: *libc::c_void);\n+    #[rust_stack]\n+    fn rust_task_local_data_atexit(task: *rust_task, cleanup_fn: *u8);\n }\n \n \n@@ -997,3 +1192,94 @@ fn test_unkillable() {\n     // Now we can be killed\n     po.recv();\n }\n+\n+#[test]\n+fn test_tls_multitask() unsafe {\n+    fn my_key(+_x: @str) { }\n+    local_data_set(my_key, @\"parent data\");\n+    task::spawn {||\n+        assert local_data_get(my_key) == none; // TLS shouldn't carry over.\n+        local_data_set(my_key, @\"child data\");\n+        assert *(local_data_get(my_key).get()) == \"child data\";\n+        // should be cleaned up for us\n+    }\n+    // Must work multiple times\n+    assert *(local_data_get(my_key).get()) == \"parent data\";\n+    assert *(local_data_get(my_key).get()) == \"parent data\";\n+    assert *(local_data_get(my_key).get()) == \"parent data\";\n+}\n+\n+#[test]\n+fn test_tls_overwrite() unsafe {\n+    fn my_key(+_x: @str) { }\n+    local_data_set(my_key, @\"first data\");\n+    local_data_set(my_key, @\"next data\"); // Shouldn't leak.\n+    assert *(local_data_get(my_key).get()) == \"next data\";\n+}\n+\n+#[test]\n+fn test_tls_pop() unsafe {\n+    fn my_key(+_x: @str) { }\n+    local_data_set(my_key, @\"weasel\");\n+    assert *(local_data_pop(my_key).get()) == \"weasel\";\n+    // Pop must remove the data from the map.\n+    assert local_data_pop(my_key) == none;\n+}\n+\n+#[test]\n+fn test_tls_modify() unsafe {\n+    fn my_key(+_x: @str) { }\n+    local_data_modify(my_key) {|data|\n+        alt data {\n+            some(@val) { fail \"unwelcome value: \" + val }\n+            none       { some(@\"first data\") }\n+        }\n+    }\n+    local_data_modify(my_key) {|data|\n+        alt data {\n+            some(@\"first data\") { some(@\"next data\") }\n+            some(@val)          { fail \"wrong value: \" + val }\n+            none                { fail \"missing value\" }\n+        }\n+    }\n+    assert *(local_data_pop(my_key).get()) == \"next data\";\n+}\n+\n+#[test]\n+fn test_tls_crust_automorestack_memorial_bug() unsafe {\n+    // This might result in a stack-canary clobber if the runtime fails to set\n+    // sp_limit to 0 when calling the cleanup crust - it might automatically\n+    // jump over to the rust stack, which causes next_c_sp to get recorded as\n+    // something within a rust stack segment. Then a subsequent upcall (esp.\n+    // for logging, think vsnprintf) would run on a stack smaller than 1 MB.\n+    fn my_key(+_x: @str) { }\n+    task::spawn {||\n+        unsafe { local_data_set(my_key, @\"hax\"); }\n+    }\n+}\n+\n+#[test]\n+fn test_tls_multiple_types() unsafe {\n+    fn str_key(+_x: @str) { }\n+    fn box_key(+_x: @@()) { }\n+    fn int_key(+_x: @int) { }\n+    task::spawn{||\n+        local_data_set(str_key, @\"string data\");\n+        local_data_set(box_key, @@());\n+        local_data_set(int_key, @42);\n+    }\n+}\n+\n+#[test]\n+fn test_tls_overwrite_multiple_types() unsafe {\n+    fn str_key(+_x: @str) { }\n+    fn box_key(+_x: @@()) { }\n+    fn int_key(+_x: @int) { }\n+    task::spawn{||\n+        local_data_set(str_key, @\"string data\");\n+        local_data_set(int_key, @42);\n+        // This could cause a segfault if overwriting-destruction is done with\n+        // the crazy polymorphic transmute rather than the provided finaliser.\n+        local_data_set(int_key, @31337);\n+    }\n+}"}, {"sha": "999609a537d7a4575621e390868460082890168d", "filename": "src/libcore/unsafe.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1ff6f9b876f8024617ef002a5276199545cea96a/src%2Flibcore%2Funsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ff6f9b876f8024617ef002a5276199545cea96a/src%2Flibcore%2Funsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funsafe.rs?ref=1ff6f9b876f8024617ef002a5276199545cea96a", "patch": "@@ -1,6 +1,6 @@\n #[doc = \"Unsafe operations\"];\n \n-export reinterpret_cast, forget, transmute;\n+export reinterpret_cast, forget, bump_box_refcount, transmute;\n \n #[abi = \"rust-intrinsic\"]\n native mod rusti {\n@@ -27,6 +27,12 @@ reinterpret_cast on managed pointer types.\n #[inline(always)]\n unsafe fn forget<T>(-thing: T) { rusti::forget(thing); }\n \n+#[doc = \"Force-increment the reference count on a shared box. If used\n+uncarefully, this can leak the box. Use this in conjunction with transmute\n+and/or reinterpret_cast when such calls would otherwise scramble a box's\n+reference count\"]\n+unsafe fn bump_box_refcount<T>(+t: @T) { forget(t); }\n+\n #[doc = \"\n Transform a value of one type into a value of another type.\n Both types must have the same size and alignment.\n@@ -49,6 +55,21 @@ mod tests {\n         assert unsafe { reinterpret_cast(1) } == 1u;\n     }\n \n+    #[test]\n+    fn test_bump_box_refcount() {\n+        unsafe {\n+            let box = @\"box box box\";       // refcount 1\n+            bump_box_refcount(box);         // refcount 2\n+            let ptr: *int = transmute(box); // refcount 2\n+            let _box1: @str = reinterpret_cast(ptr);\n+            let _box2: @str = reinterpret_cast(ptr);\n+            assert *_box1 == \"box box box\";\n+            assert *_box2 == \"box box box\";\n+            // Will destroy _box1 and _box2. Without the bump, this would\n+            // use-after-free. With too many bumps, it would leak.\n+        }\n+    }\n+\n     #[test]\n     fn test_transmute() {\n         unsafe {"}]}