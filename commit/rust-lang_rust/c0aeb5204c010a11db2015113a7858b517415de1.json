{"sha": "c0aeb5204c010a11db2015113a7858b517415de1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwYWViNTIwNGMwMTBhMTFkYjIwMTUxMTNhNzg1OGI1MTc0MTVkZTE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-18T13:36:56Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-19T12:37:25Z"}, "message": "switched to lowerd module", "tree": {"sha": "0a41b5828fde247ce21af57c182235e935d3ffb8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a41b5828fde247ce21af57c182235e935d3ffb8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0aeb5204c010a11db2015113a7858b517415de1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0aeb5204c010a11db2015113a7858b517415de1", "html_url": "https://github.com/rust-lang/rust/commit/c0aeb5204c010a11db2015113a7858b517415de1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0aeb5204c010a11db2015113a7858b517415de1/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b93c6bc5575db4acc5aa5867b6f0cc0dd37858f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/b93c6bc5575db4acc5aa5867b6f0cc0dd37858f4", "html_url": "https://github.com/rust-lang/rust/commit/b93c6bc5575db4acc5aa5867b6f0cc0dd37858f4"}], "stats": {"total": 349, "additions": 284, "deletions": 65}, "files": [{"sha": "865e5e80929505390c9f9ea1d5ec0c803f885ea5", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c0aeb5204c010a11db2015113a7858b517415de1/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0aeb5204c010a11db2015113a7858b517415de1/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=c0aeb5204c010a11db2015113a7858b517415de1", "patch": "@@ -7,7 +7,7 @@ use ra_syntax::{ast, TreeArc, SyntaxNode};\n use crate::{\n     Name, DefId, Path, PerNs, ScopesWithSyntaxMapping, Ty, HirFileId,\n     type_ref::TypeRef,\n-    nameres::ModuleScope,\n+    nameres::{ModuleScope, lower::LoweredImport},\n     db::HirDatabase,\n     expr::BodySyntaxMapping,\n     ty::InferenceResult,\n@@ -96,6 +96,15 @@ impl Module {\n         self.declaration_source_impl(db)\n     }\n \n+    /// Returns the syntax of the last path segment corresponding to this import\n+    pub fn import_source(\n+        &self,\n+        db: &impl HirDatabase,\n+        import: LoweredImport,\n+    ) -> TreeArc<ast::PathSegment> {\n+        self.import_source_impl(db, import)\n+    }\n+\n     /// Returns the crate this module is part of.\n     pub fn krate(&self, db: &impl HirDatabase) -> Option<Crate> {\n         self.krate_impl(db)"}, {"sha": "f110548c645f069eca7fea5113f9655a51810298", "filename": "crates/ra_hir/src/code_model_impl/module.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c0aeb5204c010a11db2015113a7858b517415de1/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0aeb5204c010a11db2015113a7858b517415de1/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs?ref=c0aeb5204c010a11db2015113a7858b517415de1", "patch": "@@ -5,7 +5,7 @@ use crate::{\n     Module, ModuleSource, Problem,\n     Crate, DefId, DefLoc, DefKind, Name, Path, PathKind, PerNs, Def,\n     module_tree::ModuleId,\n-    nameres::ModuleScope,\n+    nameres::{ModuleScope, lower::LoweredImport},\n     db::HirDatabase,\n };\n \n@@ -37,7 +37,7 @@ impl Module {\n         Some(link.name(&module_tree).clone())\n     }\n \n-    pub fn definition_source_impl(&self, db: &impl HirDatabase) -> (FileId, ModuleSource) {\n+    pub(crate) fn definition_source_impl(&self, db: &impl HirDatabase) -> (FileId, ModuleSource) {\n         let loc = self.def_id.loc(db);\n         let file_id = loc.source_item_id.file_id.as_original_file();\n         let syntax_node = db.file_item(loc.source_item_id);\n@@ -50,7 +50,7 @@ impl Module {\n         (file_id, module_source)\n     }\n \n-    pub fn declaration_source_impl(\n+    pub(crate) fn declaration_source_impl(\n         &self,\n         db: &impl HirDatabase,\n     ) -> Option<(FileId, TreeArc<ast::Module>)> {\n@@ -66,6 +66,17 @@ impl Module {\n         Some((file_id, src))\n     }\n \n+    pub(crate) fn import_source_impl(\n+        &self,\n+        db: &impl HirDatabase,\n+        import: LoweredImport,\n+    ) -> TreeArc<ast::PathSegment> {\n+        let loc = self.def_id.loc(db);\n+        let source_map = db.lower_module_source_map(loc.source_root_id, loc.module_id);\n+        let (_, source) = self.definition_source(db);\n+        source_map.get(&source, import)\n+    }\n+\n     pub(crate) fn krate_impl(&self, db: &impl HirDatabase) -> Option<Crate> {\n         let root = self.crate_root(db);\n         let loc = root.def_id.loc(db);"}, {"sha": "ccc53c454ce172ae9019a78a85770b34015a368c", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c0aeb5204c010a11db2015113a7858b517415de1/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0aeb5204c010a11db2015113a7858b517415de1/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=c0aeb5204c010a11db2015113a7858b517415de1", "patch": "@@ -10,7 +10,7 @@ use crate::{\n     FnSignature, FnScopes,\n     macros::MacroExpansion,\n     module_tree::{ModuleId, ModuleTree},\n-    nameres::{ItemMap, lower::InputModuleItems},\n+    nameres::{ItemMap, lower::{InputModuleItems, LoweredModule, ImportSourceMap}},\n     ty::{InferenceResult, Ty, method_resolution::CrateImplBlocks},\n     adt::{StructData, EnumData, EnumVariantData},\n     impl_block::ModuleImplBlocks,\n@@ -65,6 +65,27 @@ pub trait HirDatabase:\n         module_id: ModuleId,\n     ) -> Arc<InputModuleItems>;\n \n+    #[salsa::invoke(crate::nameres::lower::LoweredModule::lower_module_query)]\n+    fn lower_module(\n+        &self,\n+        source_root_id: SourceRootId,\n+        module_id: ModuleId,\n+    ) -> (Arc<LoweredModule>, Arc<ImportSourceMap>);\n+\n+    #[salsa::invoke(crate::nameres::lower::LoweredModule::lower_module_module_query)]\n+    fn lower_module_module(\n+        &self,\n+        source_root_id: SourceRootId,\n+        module_id: ModuleId,\n+    ) -> Arc<LoweredModule>;\n+\n+    #[salsa::invoke(crate::nameres::lower::LoweredModule::lower_module_source_map_query)]\n+    fn lower_module_source_map(\n+        &self,\n+        source_root_id: SourceRootId,\n+        module_id: ModuleId,\n+    ) -> Arc<ImportSourceMap>;\n+\n     #[salsa::invoke(query_definitions::item_map)]\n     fn item_map(&self, source_root_id: SourceRootId) -> Arc<ItemMap>;\n "}, {"sha": "ab0a9041da67f2d6ab0a58b71f3e0637a167295b", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/c0aeb5204c010a11db2015113a7858b517415de1/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0aeb5204c010a11db2015113a7858b517415de1/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=c0aeb5204c010a11db2015113a7858b517415de1", "patch": "@@ -60,7 +60,7 @@ pub struct Resolution {\n     /// None for unresolved\n     pub def_id: PerNs<DefId>,\n     /// ident by whitch this is imported into local scope.\n-    pub import: Option<NamedImport>,\n+    pub import: Option<LoweredImport>,\n }\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n@@ -151,10 +151,10 @@ impl<T> PerNs<T> {\n \n pub(crate) struct Resolver<'a, DB> {\n     db: &'a DB,\n-    input: &'a FxHashMap<ModuleId, Arc<InputModuleItems>>,\n+    input: &'a FxHashMap<ModuleId, Arc<LoweredModule>>,\n     source_root: SourceRootId,\n     module_tree: Arc<ModuleTree>,\n-    processed_imports: FxHashSet<(ModuleId, usize)>,\n+    processed_imports: FxHashSet<(ModuleId, LoweredImport)>,\n     result: ItemMap,\n }\n \n@@ -164,7 +164,7 @@ where\n {\n     pub(crate) fn new(\n         db: &'a DB,\n-        input: &'a FxHashMap<ModuleId, Arc<InputModuleItems>>,\n+        input: &'a FxHashMap<ModuleId, Arc<LoweredModule>>,\n         source_root: SourceRootId,\n         module_tree: Arc<ModuleTree>,\n     ) -> Resolver<'a, DB> {\n@@ -197,7 +197,7 @@ where\n         self.result\n     }\n \n-    fn populate_module(&mut self, module_id: ModuleId, input: Arc<InputModuleItems>) {\n+    fn populate_module(&mut self, module_id: ModuleId, input: Arc<LoweredModule>) {\n         let mut module_items = ModuleScope::default();\n \n         // Populate extern crates prelude\n@@ -220,14 +220,14 @@ where\n                 }\n             };\n         }\n-        for import in input.imports.iter() {\n-            if let Some(name) = import.path.segments.iter().last() {\n-                if let ImportKind::Named(import) = import.kind {\n+        for (import_id, import_data) in input.imports.iter() {\n+            if let Some(name) = import_data.path.segments.iter().last() {\n+                if !import_data.is_glob {\n                     module_items.items.insert(\n                         name.clone(),\n                         Resolution {\n                             def_id: PerNs::none(),\n-                            import: Some(import),\n+                            import: Some(import_id),\n                         },\n                     );\n                 }\n@@ -281,23 +281,27 @@ where\n     }\n \n     fn resolve_imports(&mut self, module_id: ModuleId) {\n-        for (i, import) in self.input[&module_id].imports.iter().enumerate() {\n-            if self.processed_imports.contains(&(module_id, i)) {\n+        for (import_id, import_data) in self.input[&module_id].imports.iter() {\n+            if self.processed_imports.contains(&(module_id, import_id)) {\n                 // already done\n                 continue;\n             }\n-            if self.resolve_import(module_id, import) {\n-                log::debug!(\"import {:?} resolved (or definite error)\", import);\n-                self.processed_imports.insert((module_id, i));\n+            if self.resolve_import(module_id, import_id, import_data) {\n+                log::debug!(\"import {:?} resolved (or definite error)\", import_id);\n+                self.processed_imports.insert((module_id, import_id));\n             }\n         }\n     }\n \n-    fn resolve_import(&mut self, module_id: ModuleId, import: &Import) -> bool {\n+    fn resolve_import(\n+        &mut self,\n+        module_id: ModuleId,\n+        import_id: LoweredImport,\n+        import: &ImportData,\n+    ) -> bool {\n         log::debug!(\"resolving import: {:?}\", import);\n-        let ptr = match import.kind {\n-            ImportKind::Glob => return false,\n-            ImportKind::Named(ptr) => ptr,\n+        if import.is_glob {\n+            return false;\n         };\n \n         let mut curr: ModuleId = match import.path.kind {\n@@ -358,7 +362,7 @@ where\n                                 self.update(module_id, |items| {\n                                     let res = Resolution {\n                                         def_id,\n-                                        import: Some(ptr),\n+                                        import: Some(import_id),\n                                     };\n                                     items.items.insert(name.clone(), res);\n                                 });\n@@ -394,7 +398,7 @@ where\n                 self.update(module_id, |items| {\n                     let res = Resolution {\n                         def_id,\n-                        import: Some(ptr),\n+                        import: Some(import_id),\n                     };\n                     items.items.insert(name.clone(), res);\n                 })"}, {"sha": "6bca1444429d50ac31e3463636fc512899dc7542", "filename": "crates/ra_hir/src/nameres/lower.rs", "status": "modified", "additions": 193, "deletions": 20, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/c0aeb5204c010a11db2015113a7858b517415de1/crates%2Fra_hir%2Fsrc%2Fnameres%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0aeb5204c010a11db2015113a7858b517415de1/crates%2Fra_hir%2Fsrc%2Fnameres%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Flower.rs?ref=c0aeb5204c010a11db2015113a7858b517415de1", "patch": "@@ -1,10 +1,11 @@\n use std::sync::Arc;\n \n use ra_syntax::{\n-    TextRange, SyntaxKind, AstNode,\n+    TextRange, SyntaxKind, AstNode, SourceFile, TreeArc,\n     ast::{self, ModuleItemOwner},\n };\n-use ra_db::{FileId, SourceRootId};\n+use ra_db::{SourceRootId, LocalSyntaxPtr};\n+use ra_arena::{Arena, RawId, impl_arena_id, map::ArenaMap};\n \n use crate::{\n     SourceItemId, SourceFileItemId, Path, ModuleSource, HirDatabase, Name, SourceFileItems,\n@@ -139,12 +140,12 @@ impl InputModuleItems {\n     fn add_use_item(&mut self, file_items: &SourceFileItems, item: &ast::UseItem) {\n         let file_item_id = file_items.id_of_unchecked(item.syntax());\n         let start_offset = item.syntax().range().start();\n-        Path::expand_use_item(item, |path, range| {\n-            let kind = match range {\n+        Path::expand_use_item(item, |path, segment| {\n+            let kind = match segment {\n                 None => ImportKind::Glob,\n-                Some(range) => ImportKind::Named(NamedImport {\n+                Some(segment) => ImportKind::Named(NamedImport {\n                     file_item_id,\n-                    relative_range: range - start_offset,\n+                    relative_range: segment.syntax().range() - start_offset,\n                 }),\n             };\n             self.imports.push(Import { kind, path })\n@@ -199,22 +200,194 @@ pub struct NamedImport {\n     pub relative_range: TextRange,\n }\n \n-impl NamedImport {\n-    // FIXME: this is only here for one use-case in completion. Seems like a\n-    // pretty gross special case.\n-    pub fn range(&self, db: &impl HirDatabase, file_id: FileId) -> TextRange {\n-        let source_item_id = SourceItemId {\n-            file_id: file_id.into(),\n-            item_id: Some(self.file_item_id),\n-        };\n-        let syntax = db.file_item(source_item_id);\n-        let offset = syntax.range().start();\n-        self.relative_range + offset\n-    }\n-}\n-\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub(super) enum ImportKind {\n     Glob,\n     Named(NamedImport),\n }\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct LoweredImport(RawId);\n+impl_arena_id!(LoweredImport);\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub(super) struct ImportData {\n+    pub(super) path: Path,\n+    pub(super) is_glob: bool,\n+}\n+\n+#[derive(Debug, Default, PartialEq, Eq)]\n+pub struct LoweredModule {\n+    pub(super) items: Vec<ModuleItem>,\n+    pub(super) imports: Arena<LoweredImport, ImportData>,\n+}\n+\n+#[derive(Debug, Default, PartialEq, Eq)]\n+pub struct ImportSourceMap {\n+    map: ArenaMap<LoweredImport, LocalSyntaxPtr>,\n+}\n+\n+impl ImportSourceMap {\n+    fn insert(&mut self, import: LoweredImport, segment: &ast::PathSegment) {\n+        self.map\n+            .insert(import, LocalSyntaxPtr::new(segment.syntax()))\n+    }\n+\n+    pub fn get(&self, source: &ModuleSource, import: LoweredImport) -> TreeArc<ast::PathSegment> {\n+        let file = match source {\n+            ModuleSource::SourceFile(file) => &*file,\n+            ModuleSource::Module(m) => m.syntax().ancestors().find_map(SourceFile::cast).unwrap(),\n+        };\n+\n+        ast::PathSegment::cast(&self.map[import].resolve(file))\n+            .unwrap()\n+            .to_owned()\n+    }\n+}\n+\n+impl LoweredModule {\n+    pub(crate) fn lower_module_module_query(\n+        db: &impl HirDatabase,\n+        source_root_id: SourceRootId,\n+        module_id: ModuleId,\n+    ) -> Arc<LoweredModule> {\n+        db.lower_module(source_root_id, module_id).0\n+    }\n+\n+    pub(crate) fn lower_module_source_map_query(\n+        db: &impl HirDatabase,\n+        source_root_id: SourceRootId,\n+        module_id: ModuleId,\n+    ) -> Arc<ImportSourceMap> {\n+        db.lower_module(source_root_id, module_id).1\n+    }\n+\n+    pub(crate) fn lower_module_query(\n+        db: &impl HirDatabase,\n+        source_root_id: SourceRootId,\n+        module_id: ModuleId,\n+    ) -> (Arc<LoweredModule>, Arc<ImportSourceMap>) {\n+        let module_tree = db.module_tree(source_root_id);\n+        let source = module_id.source(&module_tree);\n+        let file_id = source.file_id;\n+        let source = ModuleSource::from_source_item_id(db, source);\n+        let mut source_map = ImportSourceMap::default();\n+        let mut res = LoweredModule::default();\n+        match source {\n+            ModuleSource::SourceFile(it) => res.fill(\n+                &mut source_map,\n+                db,\n+                source_root_id,\n+                module_id,\n+                file_id,\n+                &mut it.items_with_macros(),\n+            ),\n+            ModuleSource::Module(it) => {\n+                if let Some(item_list) = it.item_list() {\n+                    res.fill(\n+                        &mut source_map,\n+                        db,\n+                        source_root_id,\n+                        module_id,\n+                        file_id,\n+                        &mut item_list.items_with_macros(),\n+                    )\n+                }\n+            }\n+        };\n+        (Arc::new(res), Arc::new(source_map))\n+    }\n+\n+    fn fill(\n+        &mut self,\n+        source_map: &mut ImportSourceMap,\n+        db: &impl HirDatabase,\n+        source_root_id: SourceRootId,\n+        module_id: ModuleId,\n+        file_id: HirFileId,\n+        items: &mut Iterator<Item = ast::ItemOrMacro>,\n+    ) {\n+        let file_items = db.file_items(file_id);\n+\n+        for item in items {\n+            match item {\n+                ast::ItemOrMacro::Item(it) => {\n+                    self.add_item(source_map, file_id, &file_items, it);\n+                }\n+                ast::ItemOrMacro::Macro(macro_call) => {\n+                    let item_id = file_items.id_of_unchecked(macro_call.syntax());\n+                    let loc = MacroCallLoc {\n+                        source_root_id,\n+                        module_id,\n+                        source_item_id: SourceItemId {\n+                            file_id,\n+                            item_id: Some(item_id),\n+                        },\n+                    };\n+                    let id = loc.id(db);\n+                    let file_id = HirFileId::from(id);\n+                    let file_items = db.file_items(file_id);\n+                    //FIXME: expand recursively\n+                    for item in db.hir_source_file(file_id).items() {\n+                        self.add_item(source_map, file_id, &file_items, item);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn add_item(\n+        &mut self,\n+        source_map: &mut ImportSourceMap,\n+        file_id: HirFileId,\n+        file_items: &SourceFileItems,\n+        item: &ast::ModuleItem,\n+    ) -> Option<()> {\n+        match item.kind() {\n+            ast::ModuleItemKind::StructDef(it) => {\n+                self.items.push(ModuleItem::new(file_id, file_items, it)?)\n+            }\n+            ast::ModuleItemKind::EnumDef(it) => {\n+                self.items.push(ModuleItem::new(file_id, file_items, it)?)\n+            }\n+            ast::ModuleItemKind::FnDef(it) => {\n+                self.items.push(ModuleItem::new(file_id, file_items, it)?)\n+            }\n+            ast::ModuleItemKind::TraitDef(it) => {\n+                self.items.push(ModuleItem::new(file_id, file_items, it)?)\n+            }\n+            ast::ModuleItemKind::TypeDef(it) => {\n+                self.items.push(ModuleItem::new(file_id, file_items, it)?)\n+            }\n+            ast::ModuleItemKind::ImplBlock(_) => {\n+                // impls don't define items\n+            }\n+            ast::ModuleItemKind::UseItem(it) => self.add_use_item(source_map, it),\n+            ast::ModuleItemKind::ExternCrateItem(_) => {\n+                // TODO\n+            }\n+            ast::ModuleItemKind::ConstDef(it) => {\n+                self.items.push(ModuleItem::new(file_id, file_items, it)?)\n+            }\n+            ast::ModuleItemKind::StaticDef(it) => {\n+                self.items.push(ModuleItem::new(file_id, file_items, it)?)\n+            }\n+            ast::ModuleItemKind::Module(it) => {\n+                self.items.push(ModuleItem::new(file_id, file_items, it)?)\n+            }\n+        }\n+        Some(())\n+    }\n+\n+    fn add_use_item(&mut self, source_map: &mut ImportSourceMap, item: &ast::UseItem) {\n+        Path::expand_use_item(item, |path, segment| {\n+            let import = self.imports.alloc(ImportData {\n+                path,\n+                is_glob: segment.is_none(),\n+            });\n+            if let Some(segment) = segment {\n+                source_map.insert(import, segment)\n+            }\n+        })\n+    }\n+}"}, {"sha": "7b0ce3b6132eaa2409bf743dc1a6ebe6fe60740f", "filename": "crates/ra_hir/src/path.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c0aeb5204c010a11db2015113a7858b517415de1/crates%2Fra_hir%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0aeb5204c010a11db2015113a7858b517415de1/crates%2Fra_hir%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fpath.rs?ref=c0aeb5204c010a11db2015113a7858b517415de1", "patch": "@@ -1,4 +1,4 @@\n-use ra_syntax::{ast, AstNode, TextRange};\n+use ra_syntax::{ast, AstNode};\n \n use crate::{Name, AsName};\n \n@@ -18,7 +18,10 @@ pub enum PathKind {\n \n impl Path {\n     /// Calls `cb` with all paths, represented by this use item.\n-    pub fn expand_use_item(item: &ast::UseItem, mut cb: impl FnMut(Path, Option<TextRange>)) {\n+    pub fn expand_use_item<'a>(\n+        item: &'a ast::UseItem,\n+        mut cb: impl FnMut(Path, Option<&'a ast::PathSegment>),\n+    ) {\n         if let Some(tree) = item.use_tree() {\n             expand_use_tree(None, tree, &mut cb);\n         }\n@@ -98,10 +101,10 @@ impl From<Name> for Path {\n     }\n }\n \n-fn expand_use_tree(\n+fn expand_use_tree<'a>(\n     prefix: Option<Path>,\n-    tree: &ast::UseTree,\n-    cb: &mut impl FnMut(Path, Option<TextRange>),\n+    tree: &'a ast::UseTree,\n+    cb: &mut impl FnMut(Path, Option<&'a ast::PathSegment>),\n ) {\n     if let Some(use_tree_list) = tree.use_tree_list() {\n         let prefix = match tree.path() {\n@@ -125,20 +128,18 @@ fn expand_use_tree(\n                 if let Some(segment) = ast_path.segment() {\n                     if segment.kind() == Some(ast::PathSegmentKind::SelfKw) {\n                         if let Some(prefix) = prefix {\n-                            cb(prefix, Some(segment.syntax().range()));\n+                            cb(prefix, Some(segment));\n                             return;\n                         }\n                     }\n                 }\n             }\n             if let Some(path) = convert_path(prefix, ast_path) {\n-                let range = if tree.has_star() {\n-                    None\n-                } else {\n-                    let range = ast_path.segment().unwrap().syntax().range();\n-                    Some(range)\n+                if tree.has_star() {\n+                    cb(path, None)\n+                } else if let Some(segment) = ast_path.segment() {\n+                    cb(path, Some(segment))\n                 };\n-                cb(path, range)\n             }\n             // TODO: report errors somewhere\n             // We get here if we do"}, {"sha": "07415386260808fdb202eda79c7c0855bfdead7a", "filename": "crates/ra_hir/src/query_definitions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0aeb5204c010a11db2015113a7858b517415de1/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0aeb5204c010a11db2015113a7858b517415de1/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs?ref=c0aeb5204c010a11db2015113a7858b517415de1", "patch": "@@ -46,7 +46,7 @@ pub(super) fn item_map(db: &impl HirDatabase, source_root: SourceRootId) -> Arc<\n     let module_tree = db.module_tree(source_root);\n     let input = module_tree\n         .modules()\n-        .map(|id| (id, db.input_module_items(source_root, id)))\n+        .map(|id| (id, db.lower_module_module(source_root, id)))\n         .collect::<FxHashMap<_, _>>();\n \n     let resolver = Resolver::new(db, &input, source_root, module_tree);"}, {"sha": "4276e47e897aefab2bbd7853100f31285702284b", "filename": "crates/ra_ide_api/src/completion/complete_scope.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c0aeb5204c010a11db2015113a7858b517415de1/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0aeb5204c010a11db2015113a7858b517415de1/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_scope.rs?ref=c0aeb5204c010a11db2015113a7858b517415de1", "patch": "@@ -1,5 +1,5 @@\n use rustc_hash::FxHashSet;\n-use ra_syntax::TextUnit;\n+use ra_syntax::{AstNode, TextUnit};\n \n use crate::completion::{CompletionItem, CompletionItemKind, Completions, CompletionKind, CompletionContext};\n \n@@ -17,18 +17,15 @@ pub(super) fn complete_scope(acc: &mut Completions, ctx: &CompletionContext) {\n     }\n \n     let module_scope = module.scope(ctx.db);\n-    let (file_id, _) = module.definition_source(ctx.db);\n     module_scope\n         .entries()\n         .filter(|(_name, res)| {\n-            // Don't expose this item\n-            // FIXME: this penetrates through all kinds of abstractions,\n-            // we need to figura out the way to do it less ugly.\n+            // For cases like `use self::foo<|>` don't suggest foo itself.\n             match res.import {\n                 None => true,\n                 Some(import) => {\n-                    let range = import.range(ctx.db, file_id);\n-                    !range.is_subrange(&ctx.leaf.range())\n+                    let source = module.import_source(ctx.db, import);\n+                    !source.syntax().range().is_subrange(&ctx.leaf.range())\n                 }\n             }\n         })"}, {"sha": "a1d3333b2cb744e83fc66390e5f06b0e6b6e56ea", "filename": "crates/ra_ide_api/src/db.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c0aeb5204c010a11db2015113a7858b517415de1/crates%2Fra_ide_api%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0aeb5204c010a11db2015113a7858b517415de1/crates%2Fra_ide_api%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdb.rs?ref=c0aeb5204c010a11db2015113a7858b517415de1", "patch": "@@ -114,6 +114,9 @@ salsa::database_storage! {\n             fn file_items() for hir::db::FileItemsQuery;\n             fn file_item() for hir::db::FileItemQuery;\n             fn input_module_items() for hir::db::InputModuleItemsQuery;\n+            fn lower_module() for hir::db::LowerModuleQuery;\n+            fn lower_module_module() for hir::db::LowerModuleModuleQuery;\n+            fn lower_module_source_map() for hir::db::LowerModuleSourceMapQuery;\n             fn item_map() for hir::db::ItemMapQuery;\n             fn submodules() for hir::db::SubmodulesQuery;\n             fn infer() for hir::db::InferQuery;"}]}