{"sha": "470b4fca0ed132e6f2d6d1dd856f93c31856c9e5", "node_id": "C_kwDOAAsO6NoAKDQ3MGI0ZmNhMGVkMTMyZTZmMmQ2ZDFkZDg1NmY5M2MzMTg1NmM5ZTU", "commit": {"author": {"name": "Takayuki Maeda", "email": "41065217+TaKO8Ki@users.noreply.github.com", "date": "2022-04-08T15:01:40Z"}, "committer": {"name": "Takayuki Maeda", "email": "41065217+TaKO8Ki@users.noreply.github.com", "date": "2022-04-08T15:01:40Z"}, "message": "use `format-args-capture` and remove unnecessary nested blocks", "tree": {"sha": "a9effe423f1239d164c0e18d3cdade829e5808ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9effe423f1239d164c0e18d3cdade829e5808ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/470b4fca0ed132e6f2d6d1dd856f93c31856c9e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/470b4fca0ed132e6f2d6d1dd856f93c31856c9e5", "html_url": "https://github.com/rust-lang/rust/commit/470b4fca0ed132e6f2d6d1dd856f93c31856c9e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/470b4fca0ed132e6f2d6d1dd856f93c31856c9e5/comments", "author": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc1f8298ef1abe9cbc648b4d7db620f21f2cec32", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc1f8298ef1abe9cbc648b4d7db620f21f2cec32", "html_url": "https://github.com/rust-lang/rust/commit/dc1f8298ef1abe9cbc648b4d7db620f21f2cec32"}], "stats": {"total": 249, "additions": 116, "deletions": 133}, "files": [{"sha": "e7fd89c140fc7986ba6d04dfbd5deb2300bb8a24", "filename": "compiler/rustc_borrowck/src/diagnostics/move_errors.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/470b4fca0ed132e6f2d6d1dd856f93c31856c9e5/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470b4fca0ed132e6f2d6d1dd856f93c31856c9e5/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs?ref=470b4fca0ed132e6f2d6d1dd856f93c31856c9e5", "patch": "@@ -157,14 +157,14 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             // Error with the match place\n             LookupResult::Parent(_) => {\n                 for ge in &mut *grouped_errors {\n-                    if let GroupedMoveError::MovesFromPlace { span, binds_to, .. } = ge {\n-                        if match_span == *span {\n-                            debug!(\"appending local({:?}) to list\", bind_to);\n-                            if !binds_to.is_empty() {\n-                                binds_to.push(bind_to);\n-                            }\n-                            return;\n+                    if let GroupedMoveError::MovesFromPlace { span, binds_to, .. } = ge\n+                        && match_span == *span\n+                    {\n+                        debug!(\"appending local({:?}) to list\", bind_to);\n+                        if !binds_to.is_empty() {\n+                            binds_to.push(bind_to);\n                         }\n+                        return;\n                     }\n                 }\n                 debug!(\"found a new move error location\");\n@@ -353,7 +353,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     None => bug!(\"closure kind not inferred by borrowck\"),\n                 };\n                 let capture_description =\n-                    format!(\"captured variable in an `{}` closure\", closure_kind);\n+                    format!(\"captured variable in an `{closure_kind}` closure\");\n \n                 let upvar = &self.upvars[upvar_field.unwrap().index()];\n                 let upvar_hir_id = upvar.place.get_root_variable();\n@@ -364,9 +364,9 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n                 let place_description =\n                     if self.is_upvar_field_projection(move_place.as_ref()).is_some() {\n-                        format!(\"{}, a {}\", place_name, capture_description)\n+                        format!(\"{place_name}, a {capture_description}\")\n                     } else {\n-                        format!(\"{}, as `{}` is a {}\", place_name, upvar_name, capture_description)\n+                        format!(\"{place_name}, as `{upvar_name}` is a {capture_description}\")\n                     };\n \n                 debug!(\n@@ -379,7 +379,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 diag.span_label(upvar_span, \"captured outer variable\");\n                 diag.span_label(\n                     self.body.span,\n-                    format!(\"captured by this `{}` closure\", closure_kind),\n+                    format!(\"captured by this `{closure_kind}` closure\"),\n                 );\n \n                 diag\n@@ -390,7 +390,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 {\n                     (Some(place_desc), Some(source_desc)) => self.cannot_move_out_of(\n                         span,\n-                        &format!(\"`{}` which is behind a {}\", place_desc, source_desc),\n+                        &format!(\"`{place_desc}` which is behind a {source_desc}\"),\n                     ),\n                     (_, _) => self.cannot_move_out_of(\n                         span,\n@@ -435,15 +435,15 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     err.span_suggestion(\n                         span,\n                         \"consider borrowing here\",\n-                        format!(\"&{}\", snippet),\n+                        format!(\"&{snippet}\"),\n                         Applicability::Unspecified,\n                     );\n                 }\n \n                 if binds_to.is_empty() {\n                     let place_ty = move_from.ty(self.body, self.infcx.tcx).ty;\n                     let place_desc = match self.describe_place(move_from.as_ref()) {\n-                        Some(desc) => format!(\"`{}`\", desc),\n+                        Some(desc) => format!(\"`{desc}`\"),\n                         None => \"value\".to_string(),\n                     };\n \n@@ -472,12 +472,12 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 let span = use_spans.var_or_use();\n                 let place_ty = original_path.ty(self.body, self.infcx.tcx).ty;\n                 let place_desc = match self.describe_place(original_path.as_ref()) {\n-                    Some(desc) => format!(\"`{}`\", desc),\n+                    Some(desc) => format!(\"`{desc}`\"),\n                     None => \"value\".to_string(),\n                 };\n                 self.note_type_does_not_implement_copy(err, &place_desc, place_ty, Some(span), \"\");\n \n-                use_spans.args_span_label(err, format!(\"move out of {} occurs here\", place_desc));\n+                use_spans.args_span_label(err, format!(\"move out of {place_desc} occurs here\"));\n             }\n         }\n     }\n@@ -511,7 +511,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         for (span, to_remove, suggestion) in suggestions {\n             err.span_suggestion(\n                 span,\n-                &format!(\"consider removing the `{}`\", to_remove),\n+                &format!(\"consider removing the `{to_remove}`\"),\n                 suggestion,\n                 Applicability::MachineApplicable,\n             );"}, {"sha": "8b12db071b6ac255a210b215a181b0d12b25169b", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 72, "deletions": 78, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/470b4fca0ed132e6f2d6d1dd856f93c31856c9e5/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470b4fca0ed132e6f2d6d1dd856f93c31856c9e5/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=470b4fca0ed132e6f2d6d1dd856f93c31856c9e5", "patch": "@@ -55,7 +55,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     reason = \", as it is not declared as mutable\".to_string();\n                 } else {\n                     let name = self.local_names[local].expect(\"immutable unnamed local\");\n-                    reason = format!(\", as `{}` is not declared as mutable\", name);\n+                    reason = format!(\", as `{name}` is not declared as mutable\");\n                 }\n             }\n \n@@ -88,7 +88,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         reason = \", as it is not declared as mutable\".to_string();\n                     } else {\n                         let name = self.upvars[upvar_index.index()].place.to_string(self.infcx.tcx);\n-                        reason = format!(\", as `{}` is not declared as mutable\", name);\n+                        reason = format!(\", as `{name}` is not declared as mutable\");\n                     }\n                 }\n             }\n@@ -103,14 +103,14 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 if self.body.local_decls[local].is_ref_to_static() =>\n             {\n                 if access_place.projection.len() == 1 {\n-                    item_msg = format!(\"immutable static item {}\", access_place_desc);\n+                    item_msg = format!(\"immutable static item {access_place_desc}\");\n                     reason = String::new();\n                 } else {\n                     item_msg = access_place_desc;\n                     let local_info = &self.body.local_decls[local].local_info;\n                     if let Some(box LocalInfo::StaticRef { def_id, .. }) = *local_info {\n                         let static_name = &self.infcx.tcx.item_name(def_id);\n-                        reason = format!(\", as `{}` is an immutable static item\", static_name);\n+                        reason = format!(\", as `{static_name}` is an immutable static item\");\n                     } else {\n                         bug!(\"is_ref_to_static return true, but not ref to static?\");\n                     }\n@@ -148,15 +148,15 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     let pointer_type = source.describe_for_immutable_place(self.infcx.tcx);\n                     opt_source = Some(source);\n                     if let Some(desc) = self.describe_place(access_place.as_ref()) {\n-                        item_msg = format!(\"`{}`\", desc);\n+                        item_msg = format!(\"`{desc}`\");\n                         reason = match error_access {\n-                            AccessKind::Mutate => format!(\", which is behind {}\", pointer_type),\n+                            AccessKind::Mutate => format!(\", which is behind {pointer_type}\"),\n                             AccessKind::MutableBorrow => {\n-                                format!(\", as it is behind {}\", pointer_type)\n+                                format!(\", as it is behind {pointer_type}\")\n                             }\n                         }\n                     } else {\n-                        item_msg = format!(\"data in {}\", pointer_type);\n+                        item_msg = format!(\"data in {pointer_type}\");\n                         reason = String::new();\n                     }\n                 }\n@@ -362,29 +362,27 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n                 let upvar_hir_id = captured_place.get_root_variable();\n \n-                if let Some(Node::Binding(pat)) = self.infcx.tcx.hir().find(upvar_hir_id) {\n-                    if let hir::PatKind::Binding(\n+                if let Some(Node::Binding(pat)) = self.infcx.tcx.hir().find(upvar_hir_id)\n+                    && let hir::PatKind::Binding(\n                         hir::BindingAnnotation::Unannotated,\n                         _,\n                         upvar_ident,\n                         _,\n                     ) = pat.kind\n-                    {\n-                        err.span_suggestion(\n-                            upvar_ident.span,\n-                            \"consider changing this to be mutable\",\n-                            format!(\"mut {}\", upvar_ident.name),\n-                            Applicability::MachineApplicable,\n-                        );\n-                    }\n+                {\n+                    err.span_suggestion(\n+                        upvar_ident.span,\n+                        \"consider changing this to be mutable\",\n+                        format!(\"mut {}\", upvar_ident.name),\n+                        Applicability::MachineApplicable,\n+                    );\n                 }\n \n                 let tcx = self.infcx.tcx;\n                 if let ty::Ref(_, ty, Mutability::Mut) = the_place_err.ty(self.body, tcx).ty.kind()\n+                    && let ty::Closure(id, _) = *ty.kind()\n                 {\n-                    if let ty::Closure(id, _) = *ty.kind() {\n-                        self.show_mutating_upvar(tcx, id, the_place_err, &mut err);\n-                    }\n+                    self.show_mutating_upvar(tcx, id, the_place_err, &mut err);\n                 }\n             }\n \n@@ -544,8 +542,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                                     err.span_suggestion(\n                                         err_help_span,\n                                         &format!(\n-                                            \"consider changing this to be a mutable {}\",\n-                                            pointer_desc\n+                                            \"consider changing this to be a mutable {pointer_desc}\"\n                                         ),\n                                         suggested_code,\n                                         Applicability::MachineApplicable,\n@@ -554,8 +551,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                                     err.span_suggestion(\n                                         x,\n                                         &format!(\n-                                            \"consider changing that to be a mutable {}\",\n-                                            pointer_desc\n+                                            \"consider changing that to be a mutable {pointer_desc}\"\n                                         ),\n                                         suggested_code,\n                                         Applicability::MachineApplicable,\n@@ -606,15 +602,13 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     Some(BorrowedContentSource::OverloadedDeref(ty)) => {\n                         err.help(&format!(\n                             \"trait `DerefMut` is required to modify through a dereference, \\\n-                                but it is not implemented for `{}`\",\n-                            ty,\n+                                but it is not implemented for `{ty}`\",\n                         ));\n                     }\n                     Some(BorrowedContentSource::OverloadedIndex(ty)) => {\n                         err.help(&format!(\n                             \"trait `IndexMut` is required to modify indexed content, \\\n-                                but it is not implemented for `{}`\",\n-                            ty,\n+                                but it is not implemented for `{ty}`\",\n                         ));\n                     }\n                     _ => (),\n@@ -724,18 +718,18 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                             ty::UpvarCapture::ByRef(\n                                 ty::BorrowKind::MutBorrow | ty::BorrowKind::UniqueImmBorrow,\n                             ) => {\n-                                capture_reason = format!(\"mutable borrow of `{}`\", upvar);\n+                                capture_reason = format!(\"mutable borrow of `{upvar}`\");\n                             }\n                             ty::UpvarCapture::ByValue => {\n-                                capture_reason = format!(\"possible mutation of `{}`\", upvar);\n+                                capture_reason = format!(\"possible mutation of `{upvar}`\");\n                             }\n-                            _ => bug!(\"upvar `{}` borrowed, but not mutably\", upvar),\n+                            _ => bug!(\"upvar `{upvar}` borrowed, but not mutably\"),\n                         }\n                         break;\n                     }\n                 }\n                 if capture_reason.is_empty() {\n-                    bug!(\"upvar `{}` borrowed, but cannot find reason\", upvar);\n+                    bug!(\"upvar `{upvar}` borrowed, but cannot find reason\");\n                 }\n                 capture_reason\n             } else {\n@@ -829,27 +823,27 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                                         .as_str()\n                                         .starts_with(&original_method_ident.name.to_string())\n                             })\n-                            .map(|ident| format!(\"{}()\", ident))\n+                            .map(|ident| format!(\"{ident}()\"))\n                             .peekable()\n                     });\n \n-                if let Some(mut suggestions) = opt_suggestions {\n-                    if suggestions.peek().is_some() {\n-                        err.span_suggestions(\n-                            *span,\n-                            \"use mutable method\",\n-                            suggestions,\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n+                if let Some(mut suggestions) = opt_suggestions\n+                    && suggestions.peek().is_some()\n+                {\n+                    err.span_suggestions(\n+                        *span,\n+                        \"use mutable method\",\n+                        suggestions,\n+                        Applicability::MaybeIncorrect,\n+                    );\n                 }\n             }\n         };\n     }\n \n     /// Targeted error when encountering an `FnMut` closure where an `Fn` closure was expected.\n     fn expected_fn_found_fn_mut_call(&self, err: &mut Diagnostic, sp: Span, act: &str) {\n-        err.span_label(sp, format!(\"cannot {}\", act));\n+        err.span_label(sp, format!(\"cannot {act}\"));\n \n         let hir = self.infcx.tcx.hir();\n         let closure_id = self.mir_hir_id();\n@@ -1011,35 +1005,35 @@ fn suggest_ampmut<'tcx>(\n     opt_assignment_rhs_span: Option<Span>,\n     opt_ty_info: Option<Span>,\n ) -> (Span, String) {\n-    if let Some(assignment_rhs_span) = opt_assignment_rhs_span {\n-        if let Ok(src) = tcx.sess.source_map().span_to_snippet(assignment_rhs_span) {\n-            let is_mutbl = |ty: &str| -> bool {\n-                if let Some(rest) = ty.strip_prefix(\"mut\") {\n-                    match rest.chars().next() {\n-                        // e.g. `&mut x`\n-                        Some(c) if c.is_whitespace() => true,\n-                        // e.g. `&mut(x)`\n-                        Some('(') => true,\n-                        // e.g. `&mut{x}`\n-                        Some('{') => true,\n-                        // e.g. `&mutablevar`\n-                        _ => false,\n-                    }\n-                } else {\n-                    false\n-                }\n-            };\n-            if let (true, Some(ws_pos)) = (src.starts_with(\"&'\"), src.find(char::is_whitespace)) {\n-                let lt_name = &src[1..ws_pos];\n-                let ty = src[ws_pos..].trim_start();\n-                if !is_mutbl(ty) {\n-                    return (assignment_rhs_span, format!(\"&{} mut {}\", lt_name, ty));\n-                }\n-            } else if let Some(stripped) = src.strip_prefix('&') {\n-                let stripped = stripped.trim_start();\n-                if !is_mutbl(stripped) {\n-                    return (assignment_rhs_span, format!(\"&mut {}\", stripped));\n+    if let Some(assignment_rhs_span) = opt_assignment_rhs_span\n+        && let Ok(src) = tcx.sess.source_map().span_to_snippet(assignment_rhs_span)\n+    {\n+        let is_mutbl = |ty: &str| -> bool {\n+            if let Some(rest) = ty.strip_prefix(\"mut\") {\n+                match rest.chars().next() {\n+                    // e.g. `&mut x`\n+                    Some(c) if c.is_whitespace() => true,\n+                    // e.g. `&mut(x)`\n+                    Some('(') => true,\n+                    // e.g. `&mut{x}`\n+                    Some('{') => true,\n+                    // e.g. `&mutablevar`\n+                    _ => false,\n                 }\n+            } else {\n+                false\n+            }\n+        };\n+        if let (true, Some(ws_pos)) = (src.starts_with(\"&'\"), src.find(char::is_whitespace)) {\n+            let lt_name = &src[1..ws_pos];\n+            let ty = src[ws_pos..].trim_start();\n+            if !is_mutbl(ty) {\n+                return (assignment_rhs_span, format!(\"&{lt_name} mut {ty}\"));\n+            }\n+        } else if let Some(stripped) = src.strip_prefix('&') {\n+            let stripped = stripped.trim_start();\n+            if !is_mutbl(stripped) {\n+                return (assignment_rhs_span, format!(\"&mut {stripped}\"));\n             }\n         }\n     }\n@@ -1054,12 +1048,12 @@ fn suggest_ampmut<'tcx>(\n         None => local_decl.source_info.span,\n     };\n \n-    if let Ok(src) = tcx.sess.source_map().span_to_snippet(highlight_span) {\n-        if let (true, Some(ws_pos)) = (src.starts_with(\"&'\"), src.find(char::is_whitespace)) {\n-            let lt_name = &src[1..ws_pos];\n-            let ty = &src[ws_pos..];\n-            return (highlight_span, format!(\"&{} mut{}\", lt_name, ty));\n-        }\n+    if let Ok(src) = tcx.sess.source_map().span_to_snippet(highlight_span)\n+        && let (true, Some(ws_pos)) = (src.starts_with(\"&'\"), src.find(char::is_whitespace))\n+    {\n+        let lt_name = &src[1..ws_pos];\n+        let ty = &src[ws_pos..];\n+        return (highlight_span, format!(\"&{} mut{}\", lt_name, ty));\n     }\n \n     let ty_mut = local_decl.ty.builtin_deref(true).unwrap();"}, {"sha": "ab9c206a46f4519e872d41945445bddc32306db1", "filename": "compiler/rustc_borrowck/src/diagnostics/outlives_suggestion.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/470b4fca0ed132e6f2d6d1dd856f93c31856c9e5/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470b4fca0ed132e6f2d6d1dd856f93c31856c9e5/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs?ref=470b4fca0ed132e6f2d6d1dd856f93c31856c9e5", "patch": "@@ -168,13 +168,12 @@ impl OutlivesSuggestionBuilder {\n         let fr_name = self.region_vid_to_name(mbcx, errci.fr);\n         let outlived_fr_name = self.region_vid_to_name(mbcx, errci.outlived_fr);\n \n-        if let (Some(fr_name), Some(outlived_fr_name)) = (fr_name, outlived_fr_name) {\n-            if !matches!(outlived_fr_name.source, RegionNameSource::Static) {\n-                diag.help(&format!(\n-                    \"consider adding the following bound: `{}: {}`\",\n-                    fr_name, outlived_fr_name\n-                ));\n-            }\n+        if let (Some(fr_name), Some(outlived_fr_name)) = (fr_name, outlived_fr_name)\n+            && !matches!(outlived_fr_name.source, RegionNameSource::Static)\n+        {\n+            diag.help(&format!(\n+                \"consider adding the following bound: `{fr_name}: {outlived_fr_name}`\",\n+            ));\n         }\n     }\n "}, {"sha": "5fd9ecf4513661c4301705d5d0db35c7950a122d", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/470b4fca0ed132e6f2d6d1dd856f93c31856c9e5/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470b4fca0ed132e6f2d6d1dd856f93c31856c9e5/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=470b4fca0ed132e6f2d6d1dd856f93c31856c9e5", "patch": "@@ -337,7 +337,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     ty::Ref(_, inner_ty, mutbl) => {\n                         assert_eq!(*mutbl, rustc_hir::Mutability::Mut);\n                         (\n-                            format!(\"a mutable reference to `{}`\", inner_ty),\n+                            format!(\"a mutable reference to `{inner_ty}`\"),\n                             \"mutable references are invariant over their type parameter\"\n                                 .to_string(),\n                         )\n@@ -523,23 +523,19 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         if let Some((Some(outlived_fr_name), outlived_fr_span)) = outlived_fr_name_and_span {\n             diag.span_label(\n                 outlived_fr_span,\n-                format!(\n-                    \"`{}` declared here, outside of the {} body\",\n-                    outlived_fr_name, escapes_from\n-                ),\n+                format!(\"`{outlived_fr_name}` declared here, outside of the {escapes_from} body\",),\n             );\n         }\n \n         if let Some((Some(fr_name), fr_span)) = fr_name_and_span {\n             diag.span_label(\n                 fr_span,\n                 format!(\n-                    \"`{}` is a reference that is only valid in the {} body\",\n-                    fr_name, escapes_from\n+                    \"`{fr_name}` is a reference that is only valid in the {escapes_from} body\",\n                 ),\n             );\n \n-            diag.span_label(*span, format!(\"`{}` escapes the {} body here\", fr_name, escapes_from));\n+            diag.span_label(*span, format!(\"`{fr_name}` escapes the {escapes_from} body here\"));\n         }\n \n         // Only show an extra note if we can find an 'error region' for both of the region\n@@ -611,9 +607,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 diag.span_label(\n                     *span,\n                     format!(\n-                        \"{} was supposed to return data with lifetime `{}` but it is returning \\\n-                         data with lifetime `{}`\",\n-                        mir_def_name, outlived_fr_name, fr_name\n+                        \"{mir_def_name} was supposed to return data with lifetime `{outlived_fr_name}` but it is returning \\\n+                         data with lifetime `{fr_name}`\",\n                     ),\n                 );\n             }\n@@ -698,7 +693,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 // If there is a static predicate, then the only sensible suggestion is to replace\n                 // fr with `'static`.\n                 if has_static_predicate {\n-                    diag.help(&format!(\"consider replacing `{}` with `{}`\", fr_name, static_str));\n+                    diag.help(&format!(\"consider replacing `{fr_name}` with `{static_str}`\"));\n                 } else {\n                     // Otherwise, we should suggest adding a constraint on the return type.\n                     let span = self.infcx.tcx.def_span(did);\n@@ -714,14 +709,13 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         } else {\n                             span\n                         };\n-                        let suggestion = format!(\" + {}\", suggestable_fr_name);\n+                        let suggestion = format!(\" + {suggestable_fr_name}\");\n                         let span = span.shrink_to_hi();\n                         diag.span_suggestion(\n                             span,\n                             &format!(\n                                 \"to allow this `impl Trait` to capture borrowed data with lifetime \\\n-                                 `{}`, add `{}` as a bound\",\n-                                fr_name, suggestable_fr_name,\n+                                 `{fr_name}`, add `{suggestable_fr_name}` as a bound\",\n                             ),\n                             suggestion,\n                             Applicability::MachineApplicable,"}, {"sha": "7742813888e535848e185b5404e6d85992aec197", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/470b4fca0ed132e6f2d6d1dd856f93c31856c9e5/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470b4fca0ed132e6f2d6d1dd856f93c31856c9e5/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=470b4fca0ed132e6f2d6d1dd856f93c31856c9e5", "patch": "@@ -102,27 +102,24 @@ impl RegionName {\n         match &self.source {\n             RegionNameSource::NamedFreeRegion(span)\n             | RegionNameSource::NamedEarlyBoundRegion(span) => {\n-                diag.span_label(*span, format!(\"lifetime `{}` defined here\", self));\n+                diag.span_label(*span, format!(\"lifetime `{self}` defined here\"));\n             }\n             RegionNameSource::SynthesizedFreeEnvRegion(span, note) => {\n-                diag.span_label(\n-                    *span,\n-                    format!(\"lifetime `{}` represents this closure's body\", self),\n-                );\n+                diag.span_label(*span, format!(\"lifetime `{self}` represents this closure's body\"));\n                 diag.note(note);\n             }\n             RegionNameSource::AnonRegionFromArgument(RegionNameHighlight::CannotMatchHirTy(\n                 span,\n                 type_name,\n             )) => {\n-                diag.span_label(*span, format!(\"has type `{}`\", type_name));\n+                diag.span_label(*span, format!(\"has type `{type_name}`\"));\n             }\n             RegionNameSource::AnonRegionFromArgument(RegionNameHighlight::MatchedHirTy(span))\n             | RegionNameSource::AnonRegionFromOutput(RegionNameHighlight::MatchedHirTy(span), _)\n             | RegionNameSource::AnonRegionFromAsyncFn(span) => {\n                 diag.span_label(\n                     *span,\n-                    format!(\"let's call the lifetime of this reference `{}`\", self),\n+                    format!(\"let's call the lifetime of this reference `{self}`\"),\n                 );\n             }\n             RegionNameSource::AnonRegionFromArgument(\n@@ -132,15 +129,15 @@ impl RegionName {\n                 RegionNameHighlight::MatchedAdtAndSegment(span),\n                 _,\n             ) => {\n-                diag.span_label(*span, format!(\"let's call this `{}`\", self));\n+                diag.span_label(*span, format!(\"let's call this `{self}`\"));\n             }\n             RegionNameSource::AnonRegionFromArgument(RegionNameHighlight::Occluded(\n                 span,\n                 type_name,\n             )) => {\n                 diag.span_label(\n                     *span,\n-                    format!(\"lifetime `{}` appears in the type {}\", self, type_name),\n+                    format!(\"lifetime `{self}` appears in the type {type_name}\"),\n                 );\n             }\n             RegionNameSource::AnonRegionFromOutput(\n@@ -150,25 +147,24 @@ impl RegionName {\n                 diag.span_label(\n                     *span,\n                     format!(\n-                        \"return type{} `{}` contains a lifetime `{}`\",\n-                        mir_description, type_name, self\n+                        \"return type{mir_description} `{type_name}` contains a lifetime `{self}`\"\n                     ),\n                 );\n             }\n             RegionNameSource::AnonRegionFromUpvar(span, upvar_name) => {\n                 diag.span_label(\n                     *span,\n-                    format!(\"lifetime `{}` appears in the type of `{}`\", self, upvar_name),\n+                    format!(\"lifetime `{self}` appears in the type of `{upvar_name}`\"),\n                 );\n             }\n             RegionNameSource::AnonRegionFromOutput(\n                 RegionNameHighlight::CannotMatchHirTy(span, type_name),\n                 mir_description,\n             ) => {\n-                diag.span_label(*span, format!(\"return type{} is {}\", mir_description, type_name));\n+                diag.span_label(*span, format!(\"return type{mir_description} is {type_name}\"));\n             }\n             RegionNameSource::AnonRegionFromYieldTy(span, type_name) => {\n-                diag.span_label(*span, format!(\"yield type is {}\", type_name));\n+                diag.span_label(*span, format!(\"yield type is {type_name}\"));\n             }\n             RegionNameSource::Static => {}\n         }\n@@ -442,7 +438,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n             \"highlight_if_we_cannot_match_hir_ty: type_name={:?} needle_fr={:?}\",\n             type_name, needle_fr\n         );\n-        if type_name.contains(&format!(\"'{}\", counter)) {\n+        if type_name.contains(&format!(\"'{counter}\")) {\n             // Only add a label if we can confirm that a region was labelled.\n             RegionNameHighlight::CannotMatchHirTy(span, type_name)\n         } else {\n@@ -809,7 +805,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         // Note: generators from `async fn` yield `()`, so we don't have to\n         // worry about them here.\n         let yield_ty = self.regioncx.universal_regions().yield_ty?;\n-        debug!(\"give_name_if_anonymous_region_appears_in_yield_ty: yield_ty = {:?}\", yield_ty,);\n+        debug!(\"give_name_if_anonymous_region_appears_in_yield_ty: yield_ty = {:?}\", yield_ty);\n \n         let tcx = self.infcx.tcx;\n "}]}