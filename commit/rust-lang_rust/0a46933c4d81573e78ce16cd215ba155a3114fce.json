{"sha": "0a46933c4d81573e78ce16cd215ba155a3114fce", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhNDY5MzNjNGQ4MTU3M2U3OGNlMTZjZDIxNWJhMTU1YTMxMTRmY2U=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-13T18:55:00Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-16T16:44:33Z"}, "message": "rustdoc: Overhaul stability displays\n\nThis commit is an overhaul to how rustdoc deals with stability of the standard\nlibrary. The handling has all been revisited with respect to Rust's current\napproach to stability in terms of implementation as well as the state of the\nstandard library today. The high level changes made were:\n\n* Stable items now have no marker by default\n* Color-based small stability markers have been removed\n* Module listings now fade out unstable/deprecated items slightly\n* Trait methods have a separate background color based on stability and also\n  list the reason that they are unstable.\n* `impl` blocks with stability no longer render at all. This may be re-added\n  once the compiler recognizes stability on `impl` blocks.\n* `impl` blocks no longer have stability of the methods implemente indicated\n* The stability summary has been removed\n\nCloses #15468\nCloses #21674\nCloses #24201", "tree": {"sha": "66e4e0f08fdeccc9854787943fadd692b83e6810", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/66e4e0f08fdeccc9854787943fadd692b83e6810"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a46933c4d81573e78ce16cd215ba155a3114fce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a46933c4d81573e78ce16cd215ba155a3114fce", "html_url": "https://github.com/rust-lang/rust/commit/0a46933c4d81573e78ce16cd215ba155a3114fce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a46933c4d81573e78ce16cd215ba155a3114fce/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5576b0558c7f46faa5331be72113238c677979b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/5576b0558c7f46faa5331be72113238c677979b6", "html_url": "https://github.com/rust-lang/rust/commit/5576b0558c7f46faa5331be72113238c677979b6"}], "stats": {"total": 579, "additions": 132, "deletions": 447}, "files": [{"sha": "8b65a7d6791cb4854fc1d4bc73422f18551e15f4", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0a46933c4d81573e78ce16cd215ba155a3114fce/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a46933c4d81573e78ce16cd215ba155a3114fce/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=0a46933c4d81573e78ce16cd215ba155a3114fce", "patch": "@@ -313,6 +313,22 @@ impl Item {\n     pub fn is_fn(&self) -> bool {\n         match self.inner { FunctionItem(..) => true, _ => false }\n     }\n+\n+    pub fn stability_class(&self) -> String {\n+        match self.stability {\n+            Some(ref s) => {\n+                let mut base = match s.level {\n+                    attr::Unstable => \"unstable\".to_string(),\n+                    attr::Stable => String::new(),\n+                };\n+                if s.deprecated_since.len() > 0 {\n+                    base.push_str(\" deprecated\");\n+                }\n+                base\n+            }\n+            _ => String::new(),\n+        }\n+    }\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]"}, {"sha": "8b6969f586e44dec80550b8aeef506b93e6baace", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 0, "deletions": 122, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/0a46933c4d81573e78ce16cd215ba155a3114fce/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a46933c4d81573e78ce16cd215ba155a3114fce/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=0a46933c4d81573e78ce16cd215ba155a3114fce", "patch": "@@ -23,10 +23,8 @@ use syntax::ast;\n use syntax::ast_util;\n \n use clean;\n-use stability_summary::ModuleSummary;\n use html::item_type::ItemType;\n use html::render;\n-use html::escape::Escape;\n use html::render::{cache, CURRENT_LOCATION_KEY};\n \n /// Helper to render an optional visibility with a space after it (if the\n@@ -45,10 +43,6 @@ pub struct MutableSpace(pub clean::Mutability);\n /// Similar to VisSpace, but used for mutability\n #[derive(Copy, Clone)]\n pub struct RawMutableSpace(pub clean::Mutability);\n-/// Wrapper struct for properly emitting the stability level.\n-pub struct Stability<'a>(pub &'a Option<clean::Stability>);\n-/// Wrapper struct for emitting the stability level concisely.\n-pub struct ConciseStability<'a>(pub &'a Option<clean::Stability>);\n /// Wrapper struct for emitting a where clause from Generics.\n pub struct WhereClause<'a>(pub &'a clean::Generics);\n /// Wrapper struct for emitting type parameter bounds.\n@@ -702,119 +696,3 @@ impl fmt::Display for AbiSpace {\n         }\n     }\n }\n-\n-impl<'a> fmt::Display for Stability<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        let Stability(stab) = *self;\n-        match *stab {\n-            Some(ref stability) => {\n-                let lvl = if stability.deprecated_since.is_empty() {\n-                    format!(\"{}\", stability.level)\n-                } else {\n-                    \"Deprecated\".to_string()\n-                };\n-                write!(f, \"<a class='stability {lvl}' title='{reason}'>{lvl}</a>\",\n-                       lvl = Escape(&*lvl),\n-                       reason = Escape(&*stability.reason))\n-            }\n-            None => Ok(())\n-        }\n-    }\n-}\n-\n-impl<'a> fmt::Display for ConciseStability<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        let ConciseStability(stab) = *self;\n-        match *stab {\n-            Some(ref stability) => {\n-                let lvl = if stability.deprecated_since.is_empty() {\n-                    format!(\"{}\", stability.level)\n-                } else {\n-                    \"Deprecated\".to_string()\n-                };\n-                write!(f, \"<a class='stability {lvl}' title='{lvl}{colon}{reason}'></a>\",\n-                       lvl = Escape(&*lvl),\n-                       colon = if !stability.reason.is_empty() { \": \" } else { \"\" },\n-                       reason = Escape(&*stability.reason))\n-            }\n-            None => {\n-                write!(f, \"<a class='stability Unmarked' title='No stability level'></a>\")\n-            }\n-        }\n-    }\n-}\n-\n-impl fmt::Display for ModuleSummary {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fn fmt_inner<'a>(f: &mut fmt::Formatter,\n-                         context: &mut Vec<&'a str>,\n-                         m: &'a ModuleSummary)\n-                     -> fmt::Result {\n-            let cnt = m.counts;\n-            let tot = cnt.total();\n-            if tot == 0 { return Ok(()) }\n-\n-            context.push(&m.name);\n-            let path = context.connect(\"::\");\n-\n-            try!(write!(f, \"<tr>\"));\n-            try!(write!(f, \"<td><a href='{}'>{}</a></td>\", {\n-                            let mut url = context[1..].to_vec();\n-                            url.push(\"index.html\");\n-                            url.connect(\"/\")\n-                        },\n-                        path));\n-            try!(write!(f, \"<td class='summary-column'>\"));\n-            try!(write!(f, \"<span class='summary Stable' \\\n-                            style='width: {:.4}%; display: inline-block'>&nbsp</span>\",\n-                        (100 * cnt.stable) as f64/tot as f64));\n-            try!(write!(f, \"<span class='summary Unstable' \\\n-                            style='width: {:.4}%; display: inline-block'>&nbsp</span>\",\n-                        (100 * cnt.unstable) as f64/tot as f64));\n-            try!(write!(f, \"<span class='summary Deprecated' \\\n-                            style='width: {:.4}%; display: inline-block'>&nbsp</span>\",\n-                        (100 * cnt.deprecated) as f64/tot as f64));\n-            try!(write!(f, \"<span class='summary Unmarked' \\\n-                            style='width: {:.4}%; display: inline-block'>&nbsp</span>\",\n-                        (100 * cnt.unmarked) as f64/tot as f64));\n-            try!(write!(f, \"</td></tr>\"));\n-\n-            for submodule in &m.submodules {\n-                try!(fmt_inner(f, context, submodule));\n-            }\n-            context.pop();\n-            Ok(())\n-        }\n-\n-        let mut context = Vec::new();\n-\n-        let tot = self.counts.total();\n-        let (stable, unstable, deprecated, unmarked) = if tot == 0 {\n-            (0, 0, 0, 0)\n-        } else {\n-            ((100 * self.counts.stable)/tot,\n-             (100 * self.counts.unstable)/tot,\n-             (100 * self.counts.deprecated)/tot,\n-             (100 * self.counts.unmarked)/tot)\n-        };\n-\n-        try!(write!(f,\n-r\"<h1 class='fqn'>Stability dashboard: crate <a class='mod' href='index.html'>{name}</a></h1>\n-This dashboard summarizes the stability levels for all of the public modules of\n-the crate, according to the total number of items at each level in the module and\n-its children (percentages total for {name}):\n-<blockquote>\n-<a class='stability Stable'></a> stable ({}%),<br/>\n-<a class='stability Unstable'></a> unstable ({}%),<br/>\n-<a class='stability Deprecated'></a> deprecated ({}%),<br/>\n-<a class='stability Unmarked'></a> unmarked ({}%)\n-</blockquote>\n-The counts do not include methods or trait\n-implementations that are visible only through a re-exported type.\",\n-stable, unstable, deprecated, unmarked,\n-name=self.name));\n-        try!(write!(f, \"<table>\"));\n-        try!(fmt_inner(f, &mut context, self));\n-        write!(f, \"</table>\")\n-    }\n-}"}, {"sha": "c619421635dece4a4371c947382015848bdd51b6", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 86, "deletions": 96, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/0a46933c4d81573e78ce16cd215ba155a3114fce/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a46933c4d81573e78ce16cd215ba155a3114fce/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=0a46933c4d81573e78ce16cd215ba155a3114fce", "patch": "@@ -56,19 +56,20 @@ use serialize::json::ToJson;\n use syntax::abi;\n use syntax::ast;\n use syntax::ast_util;\n+use syntax::attr;\n use rustc::util::nodemap::NodeSet;\n \n use clean;\n use doctree;\n use fold::DocFolder;\n-use html::format::{VisSpace, Method, UnsafetySpace, MutableSpace, Stability};\n-use html::format::{ConciseStability, TyParamBounds, WhereClause, href, AbiSpace};\n+use html::escape::Escape;\n+use html::format::{TyParamBounds, WhereClause, href, AbiSpace};\n+use html::format::{VisSpace, Method, UnsafetySpace, MutableSpace};\n use html::highlight;\n use html::item_type::ItemType;\n use html::layout;\n use html::markdown::Markdown;\n use html::markdown;\n-use stability_summary;\n \n /// A pair of name and its optional document.\n pub type NameDoc = (String, Option<String>);\n@@ -437,11 +438,8 @@ pub fn run(mut krate: clean::Crate,\n     try!(write_shared(&cx, &krate, &*cache, index));\n     let krate = try!(render_sources(&mut cx, krate));\n \n-    // Crawl the crate, building a summary of the stability levels.\n-    let summary = stability_summary::build(&krate);\n-\n     // And finally render the whole crate's documentation\n-    cx.krate(krate, summary)\n+    cx.krate(krate)\n }\n \n fn build_index(krate: &clean::Crate, cache: &mut Cache) -> io::Result<String> {\n@@ -645,8 +643,7 @@ fn write_shared(cx: &Context,\n             // going on). If they're in different crates then the crate defining\n             // the trait will be interested in our implementation.\n             if imp.def_id.krate == did.krate { continue }\n-            try!(write!(&mut f, r#\"\"{}impl{} {}{} for {}\",\"#,\n-                        ConciseStability(&imp.stability),\n+            try!(write!(&mut f, r#\"\"impl{} {}{} for {}\",\"#,\n                         imp.generics,\n                         if imp.polarity == Some(clean::ImplPolarity::Negative) { \"!\" } else { \"\" },\n                         imp.trait_, imp.for_));\n@@ -1143,38 +1140,13 @@ impl Context {\n     ///\n     /// This currently isn't parallelized, but it'd be pretty easy to add\n     /// parallelization to this function.\n-    fn krate(mut self, mut krate: clean::Crate,\n-             stability: stability_summary::ModuleSummary) -> io::Result<()> {\n+    fn krate(self, mut krate: clean::Crate) -> io::Result<()> {\n         let mut item = match krate.module.take() {\n             Some(i) => i,\n             None => return Ok(())\n         };\n         item.name = Some(krate.name);\n \n-        // render stability dashboard\n-        try!(self.recurse(stability.name.clone(), |this| {\n-            let json_dst = &this.dst.join(\"stability.json\");\n-            let mut json_out = BufWriter::new(try!(File::create(json_dst)));\n-            try!(write!(&mut json_out, \"{}\", json::as_json(&stability)));\n-\n-            let mut title = stability.name.clone();\n-            title.push_str(\" - Stability dashboard\");\n-            let desc = format!(\"API stability overview for the Rust `{}` crate.\",\n-                               this.layout.krate);\n-            let page = layout::Page {\n-                ty: \"mod\",\n-                root_path: &this.root_path,\n-                title: &title,\n-                description: &desc,\n-                keywords: get_basic_keywords(),\n-            };\n-            let html_dst = &this.dst.join(\"stability.html\");\n-            let mut html_out = BufWriter::new(try!(File::create(html_dst)));\n-            layout::render(&mut html_out, &this.layout, &page,\n-                           &Sidebar{ cx: this, item: &item },\n-                           &stability)\n-        }));\n-\n         // render the crate documentation\n         let mut work = vec!((self, item));\n         loop {\n@@ -1456,21 +1428,8 @@ impl<'a> fmt::Display for Item<'a> {\n         try!(write!(fmt, \"<a class='{}' href=''>{}</a>\",\n                     shortty(self.item), self.item.name.as_ref().unwrap()));\n \n-        // Write stability level\n-        try!(write!(fmt, \"<wbr>{}\", Stability(&self.item.stability)));\n-\n         try!(write!(fmt, \"</span>\")); // in-band\n-        // Links to out-of-band information, i.e. src and stability dashboard\n         try!(write!(fmt, \"<span class='out-of-band'>\"));\n-\n-        // Write stability dashboard link\n-        match self.item.inner {\n-            clean::ModuleItem(ref m) if m.is_crate => {\n-                try!(write!(fmt, \"<a href='stability.html'>[stability]</a> \"));\n-            }\n-            _ => {}\n-        };\n-\n         try!(write!(fmt,\n         r##\"<span id='render-detail'>\n             <a id=\"collapse-all\" href=\"#\">[-]</a>&nbsp;<a id=\"expand-all\" href=\"#\">[+]</a>\n@@ -1554,11 +1513,11 @@ fn plain_summary_line(s: Option<&str>) -> String {\n }\n \n fn document(w: &mut fmt::Formatter, item: &clean::Item) -> fmt::Result {\n-    match item.doc_value() {\n-        Some(s) => {\n-            try!(write!(w, \"<div class='docblock'>{}</div>\", Markdown(s)));\n-        }\n-        None => {}\n+    if let Some(s) = short_stability(item, true) {\n+        try!(write!(w, \"<div class='stability'>{}</div>\", s));\n+    }\n+    if let Some(s) = item.doc_value() {\n+        try!(write!(w, \"<div class='docblock'>{}</div>\", Markdown(s)));\n     }\n     Ok(())\n }\n@@ -1593,10 +1552,17 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n     fn cmp(i1: &clean::Item, i2: &clean::Item, idx1: usize, idx2: usize) -> Ordering {\n         let ty1 = shortty(i1);\n         let ty2 = shortty(i2);\n-        if ty1 == ty2 {\n-            return i1.name.cmp(&i2.name);\n+        if ty1 != ty2 {\n+            return (reorder(ty1), idx1).cmp(&(reorder(ty2), idx2))\n+        }\n+        let s1 = i1.stability.as_ref().map(|s| s.level);\n+        let s2 = i2.stability.as_ref().map(|s| s.level);\n+        match (s1, s2) {\n+            (Some(attr::Unstable), Some(attr::Stable)) => return Ordering::Greater,\n+            (Some(attr::Stable), Some(attr::Unstable)) => return Ordering::Less,\n+            _ => {}\n         }\n-        (reorder(ty1), idx1).cmp(&(reorder(ty2), idx2))\n+        i1.name.cmp(&i2.name)\n     }\n \n     indices.sort_by(|&i1, &i2| cmp(&items[i1], &items[i2], i1, i2));\n@@ -1665,26 +1631,58 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n \n             _ => {\n                 if myitem.name.is_none() { continue }\n+                let stab_docs = if let Some(s) = short_stability(myitem, false) {\n+                    format!(\"[{}]\", s)\n+                } else {\n+                    String::new()\n+                };\n                 try!(write!(w, \"\n-                    <tr>\n-                        <td>{stab}<a class='{class}' href='{href}'\n-                               title='{title}'>{}</a></td>\n-                        <td class='docblock short'>{}</td>\n+                    <tr class='{stab} module-item'>\n+                        <td><a class='{class}' href='{href}'\n+                               title='{title}'>{name}</a></td>\n+                        <td class='docblock short'>\n+                            {stab_docs} {docs}\n+                        </td>\n                     </tr>\n                 \",\n-                *myitem.name.as_ref().unwrap(),\n-                Markdown(&shorter(myitem.doc_value())[..]),\n+                name = *myitem.name.as_ref().unwrap(),\n+                stab_docs = stab_docs,\n+                docs = Markdown(&shorter(myitem.doc_value())),\n                 class = shortty(myitem),\n+                stab = myitem.stability_class(),\n                 href = item_path(myitem),\n-                title = full_path(cx, myitem),\n-                stab = ConciseStability(&myitem.stability)));\n+                title = full_path(cx, myitem)));\n             }\n         }\n     }\n \n     write!(w, \"</table>\")\n }\n \n+fn short_stability(item: &clean::Item, show_reason: bool) -> Option<String> {\n+    item.stability.as_ref().and_then(|stab| {\n+        let reason = if show_reason && stab.reason.len() > 0 {\n+            format!(\": {}\", stab.reason)\n+        } else {\n+            String::new()\n+        };\n+        let text = if stab.deprecated_since.len() > 0 {\n+            let since = if show_reason {\n+                format!(\" since {}\", Escape(&stab.deprecated_since))\n+            } else {\n+                String::new()\n+            };\n+            format!(\"Deprecated{}{}\", since, Markdown(&reason))\n+        } else if stab.level == attr::Unstable {\n+            format!(\"Unstable{}\", Markdown(&reason))\n+        } else {\n+            return None\n+        };\n+        Some(format!(\"<em class='stab {}'>{}</em>\",\n+                     item.stability_class(), text))\n+    })\n+}\n+\n struct Initializer<'a>(&'a str);\n \n impl<'a> fmt::Display for Initializer<'a> {\n@@ -1800,10 +1798,10 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n \n     fn trait_item(w: &mut fmt::Formatter, m: &clean::Item)\n                   -> fmt::Result {\n-        try!(write!(w, \"<h3 id='{}.{}' class='method'>{}<code>\",\n-                    shortty(m),\n-                    *m.name.as_ref().unwrap(),\n-                    ConciseStability(&m.stability)));\n+        try!(write!(w, \"<h3 id='{ty}.{name}' class='method stab {stab}'><code>\",\n+                    ty = shortty(m),\n+                    name = *m.name.as_ref().unwrap(),\n+                    stab = m.stability_class()));\n         try!(render_method(w, m, MethodLink::Anchor));\n         try!(write!(w, \"</code></h3>\"));\n         try!(document(w, m));\n@@ -1854,8 +1852,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     match cache.implementors.get(&it.def_id) {\n         Some(implementors) => {\n             for i in implementors {\n-                try!(writeln!(w, \"<li>{}<code>impl{} {} for {}{}</code></li>\",\n-                              ConciseStability(&i.stability),\n+                try!(writeln!(w, \"<li><code>impl{} {} for {}{}</code></li>\",\n                               i.generics, i.trait_, i.for_, WhereClause(&i.generics)));\n             }\n         }\n@@ -1964,9 +1961,10 @@ fn item_struct(w: &mut fmt::Formatter, it: &clean::Item,\n         if fields.peek().is_some() {\n             try!(write!(w, \"<h2 class='fields'>Fields</h2>\\n<table>\"));\n             for field in fields {\n-                try!(write!(w, \"<tr><td id='structfield.{name}'>\\\n-                                  {stab}<code>{name}</code></td><td>\",\n-                            stab = ConciseStability(&field.stability),\n+                try!(write!(w, \"<tr class='stab {stab}'>\n+                                  <td id='structfield.{name}'>\\\n+                                    <code>{name}</code></td><td>\",\n+                            stab = field.stability_class(),\n                             name = field.name.as_ref().unwrap()));\n                 try!(document(w, field));\n                 try!(write!(w, \"</td></tr>\"));\n@@ -2034,8 +2032,7 @@ fn item_enum(w: &mut fmt::Formatter, it: &clean::Item,\n     if !e.variants.is_empty() {\n         try!(write!(w, \"<h2 class='variants'>Variants</h2>\\n<table>\"));\n         for variant in &e.variants {\n-            try!(write!(w, \"<tr><td id='variant.{name}'>{stab}<code>{name}</code></td><td>\",\n-                          stab = ConciseStability(&variant.stability),\n+            try!(write!(w, \"<tr><td id='variant.{name}'><code>{name}</code></td><td>\",\n                           name = variant.name.as_ref().unwrap()));\n             try!(document(w, variant));\n             match variant.inner {\n@@ -2200,8 +2197,7 @@ fn render_methods(w: &mut fmt::Formatter, it: &clean::Item) -> fmt::Result {\n \n fn render_impl(w: &mut fmt::Formatter, i: &Impl, link: MethodLink)\n                -> fmt::Result {\n-    try!(write!(w, \"<h3 class='impl'>{}<code>impl{} \",\n-                ConciseStability(&i.stability),\n+    try!(write!(w, \"<h3 class='impl'><code>impl{} \",\n                 i.impl_.generics));\n     if let Some(clean::ImplPolarity::Negative) = i.impl_.polarity {\n         try!(write!(w, \"!\"));\n@@ -2216,48 +2212,43 @@ fn render_impl(w: &mut fmt::Formatter, i: &Impl, link: MethodLink)\n     }\n \n     fn doctraititem(w: &mut fmt::Formatter, item: &clean::Item,\n-                    dox: bool, link: MethodLink) -> fmt::Result {\n+                    link: MethodLink) -> fmt::Result {\n         match item.inner {\n             clean::MethodItem(..) | clean::TyMethodItem(..) => {\n-                try!(write!(w, \"<h4 id='method.{}' class='{}'>{}<code>\",\n+                try!(write!(w, \"<h4 id='method.{}' class='{}'><code>\",\n                             *item.name.as_ref().unwrap(),\n-                            shortty(item),\n-                            ConciseStability(&item.stability)));\n+                            shortty(item)));\n                 try!(render_method(w, item, link));\n                 try!(write!(w, \"</code></h4>\\n\"));\n             }\n             clean::TypedefItem(ref tydef) => {\n                 let name = item.name.as_ref().unwrap();\n-                try!(write!(w, \"<h4 id='assoc_type.{}' class='{}'>{}<code>\",\n+                try!(write!(w, \"<h4 id='assoc_type.{}' class='{}'><code>\",\n                             *name,\n-                            shortty(item),\n-                            ConciseStability(&item.stability)));\n+                            shortty(item)));\n                 try!(write!(w, \"type {} = {}\", name, tydef.type_));\n                 try!(write!(w, \"</code></h4>\\n\"));\n             }\n             clean::AssociatedTypeItem(ref bounds, ref default) => {\n                 let name = item.name.as_ref().unwrap();\n-                try!(write!(w, \"<h4 id='assoc_type.{}' class='{}'>{}<code>\",\n+                try!(write!(w, \"<h4 id='assoc_type.{}' class='{}'><code>\",\n                             *name,\n-                            shortty(item),\n-                            ConciseStability(&item.stability)));\n+                            shortty(item)));\n                 try!(assoc_type(w, item, bounds, default));\n                 try!(write!(w, \"</code></h4>\\n\"));\n             }\n             _ => panic!(\"can't make docs for trait item with name {:?}\", item.name)\n         }\n-        match item.doc_value() {\n-            Some(s) if dox => {\n-                try!(write!(w, \"<div class='docblock'>{}</div>\", Markdown(s)));\n-                Ok(())\n-            }\n-            Some(..) | None => Ok(())\n+        if let MethodLink::Anchor = link {\n+            document(w, item)\n+        } else {\n+            Ok(())\n         }\n     }\n \n     try!(write!(w, \"<div class='impl-items'>\"));\n     for trait_item in i.impl_.items.iter() {\n-        try!(doctraititem(w, trait_item, true, link));\n+        try!(doctraititem(w, trait_item, link));\n     }\n \n     fn render_default_methods(w: &mut fmt::Formatter,\n@@ -2271,8 +2262,7 @@ fn render_impl(w: &mut fmt::Formatter, i: &Impl, link: MethodLink)\n                 None => {}\n             }\n \n-            try!(doctraititem(w, trait_item, false,\n-                              MethodLink::GotoSource(did)));\n+            try!(doctraititem(w, trait_item, MethodLink::GotoSource(did)));\n         }\n         Ok(())\n     }"}, {"sha": "657b2c8fef872fa881d38a90ebc0d3e3ac8cfd30", "filename": "src/librustdoc/html/static/main.css", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/0a46933c4d81573e78ce16cd215ba155a3114fce/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "raw_url": "https://github.com/rust-lang/rust/raw/0a46933c4d81573e78ce16cd215ba155a3114fce/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css?ref=0a46933c4d81573e78ce16cd215ba155a3114fce", "patch": "@@ -245,6 +245,10 @@ nav.sub {\n .content .highlighted.tymethod { background-color: #c6afb3; }\n .content .highlighted.type { background-color: #c6afb3; }\n \n+.docblock.short p {\n+    display: inline;\n+}\n+\n .docblock.short.nowrap {\n     display: block;\n     overflow: hidden;\n@@ -337,11 +341,16 @@ nav.sub {\n /* Shift \"where ...\" part of method definition down a line */\n .content .method .where { display: block; }\n /* Bit of whitespace to indent it */\n-.content .method .where::before { content: '      '; }\n+.content .method .where::before { content: '  '; }\n \n-.content .methods .docblock { margin-left: 40px; }\n+.content .methods > div { margin-left: 40px; }\n \n-.content .impl-items .docblock { margin-left: 40px; }\n+.content .impl-items .docblock, .content .impl-items .stability {\n+    margin-left: 40px;\n+}\n+.content .impl-items .method, .content .impl-items .type {\n+    margin-left: 20px;\n+}\n \n nav {\n     border-bottom: 1px solid #e0e0e0;\n@@ -468,30 +477,27 @@ a {\n     padding: 20px;\n }\n \n-.stability {\n-    border-left: 6px solid;\n-    padding: 3px 6px;\n-    border-radius: 3px;\n+em.stab.unstable { background: #FFF5D6; border-color: #FFC600; }\n+em.stab.deprecated { background: #F3DFFF; border-color: #7F0087; }\n+em.stab {\n+    display: inline-block;\n+    border-width: 2px;\n+    border-style: solid;\n+    padding: 5px;\n }\n-\n-h1 .stability {\n-    text-transform: lowercase;\n-    font-weight: 400;\n-    margin-left: 14px;\n-    padding: 4px 10px;\n+em.stab p {\n+    display: inline;\n }\n \n-.impl-items .stability, .methods .stability {\n-    margin-right: 20px;\n+.module-item .stab {\n+    border-width: 0;\n+    padding: 0;\n+    background: inherit !important;\n }\n \n-.stability.Deprecated { border-color: #A071A8; color: #82478C; }\n-.stability.Experimental { border-color: #D46D6A; color: #AA3C39; }\n-.stability.Unstable { border-color: #D4B16A; color: #AA8439; }\n-.stability.Stable { border-color: #54A759; color: #2D8632; }\n-.stability.Frozen { border-color: #009431; color: #007726; }\n-.stability.Locked { border-color: #0084B6; color: #00668c; }\n-.stability.Unmarked { border-color: #BBBBBB; }\n+.module-item.unstable {\n+    opacity: 0.65;\n+}\n \n td.summary-column {\n     width: 100%;\n@@ -500,11 +506,6 @@ td.summary-column {\n .summary {\n     padding-right: 0px;\n }\n-.summary.Deprecated { background-color: #A071A8; }\n-.summary.Experimental { background-color: #D46D6A; }\n-.summary.Unstable { background-color: #D4B16A; }\n-.summary.Stable { background-color: #54A759; }\n-.summary.Unmarked { background-color: #BBBBBB; }\n \n :target { background: #FDFFD3; }\n .line-numbers :target { background-color: transparent; }\n@@ -555,9 +556,9 @@ pre.rust { position: relative; }\n .collapse-toggle {\n     font-weight: 300;\n     position: absolute;\n-    left: 13px;\n+    left: -23px;\n     color: #999;\n-    margin-top: 2px;\n+    top: 0;\n }\n \n .toggle-wrapper > .collapse-toggle {"}, {"sha": "2682bbf4662e042c739abe4b87d4d064ed931330", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0a46933c4d81573e78ce16cd215ba155a3114fce/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a46933c4d81573e78ce16cd215ba155a3114fce/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=0a46933c4d81573e78ce16cd215ba155a3114fce", "patch": "@@ -91,7 +91,6 @@ pub mod html {\n pub mod markdown;\n pub mod passes;\n pub mod plugins;\n-pub mod stability_summary;\n pub mod visit_ast;\n pub mod test;\n mod flock;"}, {"sha": "3e4f6896ee68db2181121dd351b79ae33ee65ed2", "filename": "src/librustdoc/stability_summary.rs", "status": "removed", "additions": 0, "deletions": 199, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/5576b0558c7f46faa5331be72113238c677979b6/src%2Flibrustdoc%2Fstability_summary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5576b0558c7f46faa5331be72113238c677979b6/src%2Flibrustdoc%2Fstability_summary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fstability_summary.rs?ref=5576b0558c7f46faa5331be72113238c677979b6", "patch": "@@ -1,199 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! This module crawls a `clean::Crate` and produces a summarization of the\n-//! stability levels within the crate. The summary contains the module\n-//! hierarchy, with item counts for every stability level per module. A parent\n-//! module's count includes its children's.\n-\n-use std::cmp::Ordering;\n-use std::ops::Add;\n-\n-use syntax::attr::{Unstable, Stable};\n-use syntax::ast::Public;\n-\n-use clean::{Crate, Item, ModuleItem, Module, EnumItem, Enum};\n-use clean::{ImplItem, Impl, Trait, TraitItem};\n-use clean::{ExternCrateItem, ImportItem, PrimitiveItem, Stability};\n-\n-use html::render::cache;\n-\n-#[derive(RustcEncodable, RustcDecodable, PartialEq, Eq)]\n-/// The counts for each stability level.\n-#[derive(Copy, Clone)]\n-pub struct Counts {\n-    pub deprecated: u64,\n-    pub unstable: u64,\n-    pub stable: u64,\n-\n-    /// No stability level, inherited or otherwise.\n-    pub unmarked: u64,\n-}\n-\n-impl Add for Counts {\n-    type Output = Counts;\n-\n-    fn add(self, other: Counts) -> Counts {\n-        Counts {\n-            deprecated:   self.deprecated   + other.deprecated,\n-            unstable:     self.unstable     + other.unstable,\n-            stable:       self.stable       + other.stable,\n-            unmarked:     self.unmarked     + other.unmarked,\n-        }\n-    }\n-}\n-\n-impl Counts {\n-    fn zero() -> Counts {\n-        Counts {\n-            deprecated:   0,\n-            unstable:     0,\n-            stable:       0,\n-            unmarked:     0,\n-        }\n-    }\n-\n-    pub fn total(&self) -> u64 {\n-        self.deprecated + self.unstable + self.stable + self.unmarked\n-    }\n-}\n-\n-#[derive(RustcEncodable, RustcDecodable, PartialEq, Eq)]\n-/// A summarized module, which includes total counts and summarized children\n-/// modules.\n-pub struct ModuleSummary {\n-    pub name: String,\n-    pub counts: Counts,\n-    pub submodules: Vec<ModuleSummary>,\n-}\n-\n-impl PartialOrd for ModuleSummary {\n-    fn partial_cmp(&self, other: &ModuleSummary) -> Option<Ordering> {\n-        self.name.partial_cmp(&other.name)\n-    }\n-}\n-\n-impl Ord for ModuleSummary {\n-    fn cmp(&self, other: &ModuleSummary) -> Ordering {\n-        self.name.cmp(&other.name)\n-    }\n-}\n-\n-// is the item considered publicly visible?\n-fn visible(item: &Item) -> bool {\n-    match item.inner {\n-        ImplItem(_) => true,\n-        _ => item.visibility == Some(Public)\n-    }\n-}\n-\n-fn count_stability(stab: Option<&Stability>) -> Counts {\n-    match stab {\n-        None            => Counts { unmarked: 1,     .. Counts::zero() },\n-        Some(ref stab) => {\n-            if !stab.deprecated_since.is_empty() {\n-                return Counts { deprecated: 1, .. Counts::zero() };\n-            }\n-            match stab.level {\n-                Unstable    => Counts { unstable: 1,     .. Counts::zero() },\n-                Stable      => Counts { stable: 1,       .. Counts::zero() },\n-            }\n-        }\n-    }\n-}\n-\n-fn summarize_methods(item: &Item) -> Counts {\n-    match cache().impls.get(&item.def_id) {\n-        Some(v) => {\n-            v.iter().map(|i| {\n-                let count = count_stability(i.stability.as_ref());\n-                if i.impl_.trait_.is_none() {\n-                    count + i.impl_.items.iter()\n-                        .map(|ti| summarize_item(ti).0)\n-                        .fold(Counts::zero(), |acc, c| acc + c)\n-                } else {\n-                    count\n-                }\n-            }).fold(Counts::zero(), |acc, c| acc + c)\n-        },\n-        None => {\n-            Counts::zero()\n-        },\n-    }\n-}\n-\n-\n-// Produce the summary for an arbitrary item. If the item is a module, include a\n-// module summary. The counts for items with nested items (e.g. modules, traits,\n-// impls) include all children counts.\n-fn summarize_item(item: &Item) -> (Counts, Option<ModuleSummary>) {\n-    let item_counts = count_stability(item.stability.as_ref()) + summarize_methods(item);\n-\n-    // Count this item's children, if any. Note that a trait impl is\n-    // considered to have no children.\n-    match item.inner {\n-        // Require explicit `pub` to be visible\n-        ImplItem(Impl { ref items, trait_: None, .. }) => {\n-            let subcounts = items.iter().filter(|i| visible(*i))\n-                                        .map(summarize_item)\n-                                        .map(|s| s.0)\n-                                        .fold(Counts::zero(), |acc, x| acc + x);\n-            (subcounts, None)\n-        }\n-        // `pub` automatically\n-        EnumItem(Enum { variants: ref subitems, .. }) => {\n-            let subcounts = subitems.iter().map(summarize_item)\n-                                           .map(|s| s.0)\n-                                           .fold(Counts::zero(), |acc, x| acc + x);\n-            (item_counts + subcounts, None)\n-        }\n-        TraitItem(Trait { ref items, .. }) => {\n-            let subcounts = items.iter().map(summarize_item)\n-                                        .map(|s| s.0)\n-                                        .fold(Counts::zero(), |acc, x| acc + x);\n-            (item_counts + subcounts, None)\n-        }\n-        ModuleItem(Module { ref items, .. }) => {\n-            let mut counts = item_counts;\n-            let mut submodules = Vec::new();\n-\n-            for (subcounts, submodule) in items.iter().filter(|i| visible(*i))\n-                                                      .map(summarize_item) {\n-                counts = counts + subcounts;\n-                submodule.map(|m| submodules.push(m));\n-            }\n-            submodules.sort();\n-\n-            (counts, Some(ModuleSummary {\n-                name: item.name.as_ref().map_or(\"\".to_string(), |n| n.clone()),\n-                counts: counts,\n-                submodules: submodules,\n-            }))\n-        }\n-        // no stability information for the following items:\n-        ExternCrateItem(..) | ImportItem(_) |\n-        PrimitiveItem(_) => (Counts::zero(), None),\n-        _ => (item_counts, None)\n-    }\n-}\n-\n-/// Summarizes the stability levels in a crate.\n-pub fn build(krate: &Crate) -> ModuleSummary {\n-    match krate.module {\n-        None => ModuleSummary {\n-            name: krate.name.clone(),\n-            counts: Counts::zero(),\n-            submodules: Vec::new(),\n-        },\n-        Some(ref item) => ModuleSummary {\n-            name: krate.name.clone(), .. summarize_item(item).1.unwrap()\n-        }\n-    }\n-}"}]}