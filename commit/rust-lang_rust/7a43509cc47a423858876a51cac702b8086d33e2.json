{"sha": "7a43509cc47a423858876a51cac702b8086d33e2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhNDM1MDljYzQ3YTQyMzg1ODg3NmE1MWNhYzcwMmI4MDg2ZDMzZTI=", "commit": {"author": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2019-02-22T06:05:21Z"}, "committer": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2019-02-22T06:05:21Z"}, "message": "rustfmt tests/ui/methods.rs", "tree": {"sha": "29cf8d2e84350c6c90768260d25196d36ba61c77", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/29cf8d2e84350c6c90768260d25196d36ba61c77"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a43509cc47a423858876a51cac702b8086d33e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a43509cc47a423858876a51cac702b8086d33e2", "html_url": "https://github.com/rust-lang/rust/commit/7a43509cc47a423858876a51cac702b8086d33e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a43509cc47a423858876a51cac702b8086d33e2/comments", "author": null, "committer": null, "parents": [{"sha": "b96c4329dbe2812c6bd3a11bd3fde38a68fa6b58", "url": "https://api.github.com/repos/rust-lang/rust/commits/b96c4329dbe2812c6bd3a11bd3fde38a68fa6b58", "html_url": "https://github.com/rust-lang/rust/commit/b96c4329dbe2812c6bd3a11bd3fde38a68fa6b58"}], "stats": {"total": 199, "additions": 124, "deletions": 75}, "files": [{"sha": "9af3c3a335dd1af89dca6e1e4558dfd720c6e86f", "filename": "ci/base-tests.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a43509cc47a423858876a51cac702b8086d33e2/ci%2Fbase-tests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/7a43509cc47a423858876a51cac702b8086d33e2/ci%2Fbase-tests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/ci%2Fbase-tests.sh?ref=7a43509cc47a423858876a51cac702b8086d33e2", "patch": "@@ -59,7 +59,7 @@ rustup override set nightly\n # avoid loop spam and allow cmds with exit status != 0\n set +ex\n \n-for file in `find tests -not -path \"tests/ui/methods.rs\" -not -path \"tests/ui/format.rs\" -not -path \"tests/ui/formatting.rs\" -not -path \"tests/ui/empty_line_after_outer_attribute.rs\" -not -path \"tests/ui/double_parens.rs\" -not -path \"tests/ui/doc.rs\" -not -path \"tests/ui/unused_unit.rs\" | grep \"\\.rs$\"` ; do\n+for file in `find tests -not -path \"tests/ui/format.rs\" -not -path \"tests/ui/formatting.rs\" -not -path \"tests/ui/empty_line_after_outer_attribute.rs\" -not -path \"tests/ui/double_parens.rs\" -not -path \"tests/ui/doc.rs\" -not -path \"tests/ui/unused_unit.rs\" | grep \"\\.rs$\"` ; do\n   rustfmt ${file} --check\n   if [ $? -ne 0 ]; then\n     echo \"${file} needs reformatting!\""}, {"sha": "6cda888f17ffa16ff3a81b7596476f186b9925e1", "filename": "tests/ui/methods.rs", "status": "modified", "additions": 74, "deletions": 27, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/7a43509cc47a423858876a51cac702b8086d33e2/tests%2Fui%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a43509cc47a423858876a51cac702b8086d33e2/tests%2Fui%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.rs?ref=7a43509cc47a423858876a51cac702b8086d33e2", "patch": "@@ -22,8 +22,8 @@ use std::collections::BTreeMap;\n use std::collections::HashMap;\n use std::collections::HashSet;\n use std::collections::VecDeque;\n-use std::ops::Mul;\n use std::iter::FromIterator;\n+use std::ops::Mul;\n use std::rc::{self, Rc};\n use std::sync::{self, Arc};\n \n@@ -32,22 +32,51 @@ use option_helpers::IteratorFalsePositives;\n pub struct T;\n \n impl T {\n-    pub fn add(self, other: T) -> T { self }\n+    pub fn add(self, other: T) -> T {\n+        self\n+    }\n+\n+    // no error, not public interface\n+    pub(crate) fn drop(&mut self) {}\n \n-    pub(crate) fn drop(&mut self) { } // no error, not public interfact\n-    fn neg(self) -> Self { self } // no error, private function\n-    fn eq(&self, other: T) -> bool { true } // no error, private function\n+    // no error, private function\n+    fn neg(self) -> Self {\n+        self\n+    }\n+\n+    // no error, private function\n+    fn eq(&self, other: T) -> bool {\n+        true\n+    }\n \n-    fn sub(&self, other: T) -> &T { self } // no error, self is a ref\n-    fn div(self) -> T { self } // no error, different #arguments\n-    fn rem(self, other: T) { } // no error, wrong return type\n+    // no error, self is a ref\n+    fn sub(&self, other: T) -> &T {\n+        self\n+    }\n+\n+    // no error, different #arguments\n+    fn div(self) -> T {\n+        self\n+    }\n+\n+    fn rem(self, other: T) {} // no error, wrong return type\n+\n+    // fine\n+    fn into_u32(self) -> u32 {\n+        0\n+    }\n \n-    fn into_u32(self) -> u32 { 0 } // fine\n-    fn into_u16(&self) -> u16 { 0 }\n+    fn into_u16(&self) -> u16 {\n+        0\n+    }\n \n-    fn to_something(self) -> u32 { 0 }\n+    fn to_something(self) -> u32 {\n+        0\n+    }\n \n-    fn new(self) -> Self { unimplemented!(); }\n+    fn new(self) -> Self {\n+        unimplemented!();\n+    }\n }\n \n struct Lt<'a> {\n@@ -57,7 +86,9 @@ struct Lt<'a> {\n impl<'a> Lt<'a> {\n     // The lifetime is different, but that\u2019s irrelevant, see #734\n     #[allow(clippy::needless_lifetimes)]\n-    pub fn new<'b>(s: &'b str) -> Lt<'b> { unimplemented!() }\n+    pub fn new<'b>(s: &'b str) -> Lt<'b> {\n+        unimplemented!()\n+    }\n }\n \n struct Lt2<'a> {\n@@ -66,7 +97,9 @@ struct Lt2<'a> {\n \n impl<'a> Lt2<'a> {\n     // The lifetime is different, but that\u2019s irrelevant, see #734\n-    pub fn new(s: &str) -> Lt2 { unimplemented!() }\n+    pub fn new(s: &str) -> Lt2 {\n+        unimplemented!()\n+    }\n }\n \n struct Lt3<'a> {\n@@ -75,28 +108,40 @@ struct Lt3<'a> {\n \n impl<'a> Lt3<'a> {\n     // The lifetime is different, but that\u2019s irrelevant, see #734\n-    pub fn new() -> Lt3<'static> { unimplemented!() }\n+    pub fn new() -> Lt3<'static> {\n+        unimplemented!()\n+    }\n }\n \n-#[derive(Clone,Copy)]\n+#[derive(Clone, Copy)]\n struct U;\n \n impl U {\n-    fn new() -> Self { U }\n-    fn to_something(self) -> u32 { 0 } // ok because U is Copy\n+    fn new() -> Self {\n+        U\n+    }\n+    // ok because U is Copy\n+    fn to_something(self) -> u32 {\n+        0\n+    }\n }\n \n struct V<T> {\n-    _dummy: T\n+    _dummy: T,\n }\n \n impl<T> V<T> {\n-    fn new() -> Option<V<T>> { None }\n+    fn new() -> Option<V<T>> {\n+        None\n+    }\n }\n \n impl Mul<T> for T {\n     type Output = T;\n-    fn mul(self, other: T) -> T { self } // no error, obviously\n+    // no error, obviously\n+    fn mul(self, other: T) -> T {\n+        self\n+    }\n }\n \n /// Checks implementation of the following lints:\n@@ -238,16 +283,18 @@ fn or_fun_call() {\n     struct Foo;\n \n     impl Foo {\n-        fn new() -> Foo { Foo }\n+        fn new() -> Foo {\n+            Foo\n+        }\n     }\n \n     enum Enum {\n         A(i32),\n     }\n \n-\n-\n-    fn make<T>() -> T { unimplemented!(); }\n+    fn make<T>() -> T {\n+        unimplemented!();\n+    }\n \n     let with_enum = Some(Enum::A(1));\n     with_enum.unwrap_or(Enum::A(5));\n@@ -264,10 +311,10 @@ fn or_fun_call() {\n     let with_const_args = Some(vec![1]);\n     with_const_args.unwrap_or(Vec::with_capacity(12));\n \n-    let with_err : Result<_, ()> = Ok(vec![1]);\n+    let with_err: Result<_, ()> = Ok(vec![1]);\n     with_err.unwrap_or(make());\n \n-    let with_err_args : Result<_, ()> = Ok(vec![1]);\n+    let with_err_args: Result<_, ()> = Ok(vec![1]);\n     with_err_args.unwrap_or(Vec::with_capacity(12));\n \n     let with_default_trait = Some(1);"}, {"sha": "33f51a81f6ea389cfc5be14c7a672a79161c7574", "filename": "tests/ui/methods.stderr", "status": "modified", "additions": 49, "deletions": 47, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/7a43509cc47a423858876a51cac702b8086d33e2/tests%2Fui%2Fmethods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a43509cc47a423858876a51cac702b8086d33e2/tests%2Fui%2Fmethods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.stderr?ref=7a43509cc47a423858876a51cac702b8086d33e2", "patch": "@@ -1,33 +1,35 @@\n error: defining a method called `add` on this type; consider implementing the `std::ops::Add` trait or choosing a less ambiguous name\n   --> $DIR/methods.rs:35:5\n    |\n-LL |     pub fn add(self, other: T) -> T { self }\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | /     pub fn add(self, other: T) -> T {\n+LL | |         self\n+LL | |     }\n+   | |_____^\n    |\n    = note: `-D clippy::should-implement-trait` implied by `-D warnings`\n \n error: methods called `into_*` usually take self by value; consider choosing a less ambiguous name\n-  --> $DIR/methods.rs:46:17\n+  --> $DIR/methods.rs:69:17\n    |\n-LL |     fn into_u16(&self) -> u16 { 0 }\n+LL |     fn into_u16(&self) -> u16 {\n    |                 ^^^^^\n    |\n    = note: `-D clippy::wrong-self-convention` implied by `-D warnings`\n \n error: methods called `to_*` usually take self by reference; consider choosing a less ambiguous name\n-  --> $DIR/methods.rs:48:21\n+  --> $DIR/methods.rs:73:21\n    |\n-LL |     fn to_something(self) -> u32 { 0 }\n+LL |     fn to_something(self) -> u32 {\n    |                     ^^^^\n \n error: methods called `new` usually take no self; consider choosing a less ambiguous name\n-  --> $DIR/methods.rs:50:12\n+  --> $DIR/methods.rs:77:12\n    |\n-LL |     fn new(self) -> Self { unimplemented!(); }\n+LL |     fn new(self) -> Self {\n    |            ^^^^\n \n error: called `map(f).unwrap_or(a)` on an Option value. This can be done more directly by calling `map_or(a, f)` instead\n-  --> $DIR/methods.rs:112:13\n+  --> $DIR/methods.rs:157:13\n    |\n LL |       let _ = opt.map(|x| x + 1)\n    |  _____________^\n@@ -39,7 +41,7 @@ LL | |                .unwrap_or(0); // should lint even though this call is on\n    = note: replace `map(|x| x + 1).unwrap_or(0)` with `map_or(0, |x| x + 1)`\n \n error: called `map(f).unwrap_or(a)` on an Option value. This can be done more directly by calling `map_or(a, f)` instead\n-  --> $DIR/methods.rs:116:13\n+  --> $DIR/methods.rs:161:13\n    |\n LL |       let _ = opt.map(|x| {\n    |  _____________^\n@@ -49,7 +51,7 @@ LL | |               ).unwrap_or(0);\n    | |____________________________^\n \n error: called `map(f).unwrap_or(a)` on an Option value. This can be done more directly by calling `map_or(a, f)` instead\n-  --> $DIR/methods.rs:120:13\n+  --> $DIR/methods.rs:165:13\n    |\n LL |       let _ = opt.map(|x| x + 1)\n    |  _____________^\n@@ -59,15 +61,15 @@ LL | |                 });\n    | |__________________^\n \n error: called `map(f).unwrap_or(None)` on an Option value. This can be done more directly by calling `and_then(f)` instead\n-  --> $DIR/methods.rs:125:13\n+  --> $DIR/methods.rs:170:13\n    |\n LL |     let _ = opt.map(|x| Some(x + 1)).unwrap_or(None);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: replace `map(|x| Some(x + 1)).unwrap_or(None)` with `and_then(|x| Some(x + 1))`\n \n error: called `map(f).unwrap_or(None)` on an Option value. This can be done more directly by calling `and_then(f)` instead\n-  --> $DIR/methods.rs:127:13\n+  --> $DIR/methods.rs:172:13\n    |\n LL |       let _ = opt.map(|x| {\n    |  _____________^\n@@ -77,7 +79,7 @@ LL | |     ).unwrap_or(None);\n    | |_____________________^\n \n error: called `map(f).unwrap_or(None)` on an Option value. This can be done more directly by calling `and_then(f)` instead\n-  --> $DIR/methods.rs:131:13\n+  --> $DIR/methods.rs:176:13\n    |\n LL |       let _ = opt\n    |  _____________^\n@@ -88,7 +90,7 @@ LL | |         .unwrap_or(None);\n    = note: replace `map(|x| Some(x + 1)).unwrap_or(None)` with `and_then(|x| Some(x + 1))`\n \n error: called `map(f).unwrap_or_else(g)` on an Option value. This can be done more directly by calling `map_or_else(g, f)` instead\n-  --> $DIR/methods.rs:139:13\n+  --> $DIR/methods.rs:184:13\n    |\n LL |       let _ = opt.map(|x| x + 1)\n    |  _____________^\n@@ -100,7 +102,7 @@ LL | |                .unwrap_or_else(|| 0); // should lint even though this cal\n    = note: replace `map(|x| x + 1).unwrap_or_else(|| 0)` with `map_or_else(|| 0, |x| x + 1)`\n \n error: called `map(f).unwrap_or_else(g)` on an Option value. This can be done more directly by calling `map_or_else(g, f)` instead\n-  --> $DIR/methods.rs:143:13\n+  --> $DIR/methods.rs:188:13\n    |\n LL |       let _ = opt.map(|x| {\n    |  _____________^\n@@ -110,7 +112,7 @@ LL | |               ).unwrap_or_else(|| 0);\n    | |____________________________________^\n \n error: called `map(f).unwrap_or_else(g)` on an Option value. This can be done more directly by calling `map_or_else(g, f)` instead\n-  --> $DIR/methods.rs:147:13\n+  --> $DIR/methods.rs:192:13\n    |\n LL |       let _ = opt.map(|x| x + 1)\n    |  _____________^\n@@ -120,15 +122,15 @@ LL | |                 );\n    | |_________________^\n \n error: called `map_or(None, f)` on an Option value. This can be done more directly by calling `and_then(f)` instead\n-  --> $DIR/methods.rs:156:13\n+  --> $DIR/methods.rs:201:13\n    |\n LL |     let _ = opt.map_or(None, |x| Some(x + 1));\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using and_then instead: `opt.and_then(|x| Some(x + 1))`\n    |\n    = note: `-D clippy::option-map-or-none` implied by `-D warnings`\n \n error: called `map_or(None, f)` on an Option value. This can be done more directly by calling `and_then(f)` instead\n-  --> $DIR/methods.rs:158:13\n+  --> $DIR/methods.rs:203:13\n    |\n LL |       let _ = opt.map_or(None, |x| {\n    |  _____________^\n@@ -144,7 +146,7 @@ LL |                        });\n    |\n \n error: called `filter(p).next()` on an `Iterator`. This is more succinctly expressed by calling `.find(p)` instead.\n-  --> $DIR/methods.rs:184:13\n+  --> $DIR/methods.rs:229:13\n    |\n LL |     let _ = v.iter().filter(|&x| *x < 0).next();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -153,7 +155,7 @@ LL |     let _ = v.iter().filter(|&x| *x < 0).next();\n    = note: replace `filter(|&x| *x < 0).next()` with `find(|&x| *x < 0)`\n \n error: called `filter(p).next()` on an `Iterator`. This is more succinctly expressed by calling `.find(p)` instead.\n-  --> $DIR/methods.rs:187:13\n+  --> $DIR/methods.rs:232:13\n    |\n LL |       let _ = v.iter().filter(|&x| {\n    |  _____________^\n@@ -163,7 +165,7 @@ LL | |                    ).next();\n    | |___________________________^\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:203:13\n+  --> $DIR/methods.rs:248:13\n    |\n LL |     let _ = v.iter().find(|&x| *x < 0).is_some();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -172,7 +174,7 @@ LL |     let _ = v.iter().find(|&x| *x < 0).is_some();\n    = note: replace `find(|&x| *x < 0).is_some()` with `any(|&x| *x < 0)`\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:206:13\n+  --> $DIR/methods.rs:251:13\n    |\n LL |       let _ = v.iter().find(|&x| {\n    |  _____________^\n@@ -182,15 +184,15 @@ LL | |                    ).is_some();\n    | |______________________________^\n \n error: called `is_some()` after searching an `Iterator` with position. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:212:13\n+  --> $DIR/methods.rs:257:13\n    |\n LL |     let _ = v.iter().position(|&x| x < 0).is_some();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: replace `position(|&x| x < 0).is_some()` with `any(|&x| x < 0)`\n \n error: called `is_some()` after searching an `Iterator` with position. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:215:13\n+  --> $DIR/methods.rs:260:13\n    |\n LL |       let _ = v.iter().position(|&x| {\n    |  _____________^\n@@ -200,15 +202,15 @@ LL | |                    ).is_some();\n    | |______________________________^\n \n error: called `is_some()` after searching an `Iterator` with rposition. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:221:13\n+  --> $DIR/methods.rs:266:13\n    |\n LL |     let _ = v.iter().rposition(|&x| x < 0).is_some();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: replace `rposition(|&x| x < 0).is_some()` with `any(|&x| x < 0)`\n \n error: called `is_some()` after searching an `Iterator` with rposition. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:224:13\n+  --> $DIR/methods.rs:269:13\n    |\n LL |       let _ = v.iter().rposition(|&x| {\n    |  _____________^\n@@ -218,125 +220,125 @@ LL | |                    ).is_some();\n    | |______________________________^\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/methods.rs:259:22\n+  --> $DIR/methods.rs:306:22\n    |\n LL |     with_constructor.unwrap_or(make());\n    |                      ^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(make)`\n    |\n    = note: `-D clippy::or-fun-call` implied by `-D warnings`\n \n error: use of `unwrap_or` followed by a call to `new`\n-  --> $DIR/methods.rs:262:5\n+  --> $DIR/methods.rs:309:5\n    |\n LL |     with_new.unwrap_or(Vec::new());\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `with_new.unwrap_or_default()`\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/methods.rs:265:21\n+  --> $DIR/methods.rs:312:21\n    |\n LL |     with_const_args.unwrap_or(Vec::with_capacity(12));\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| Vec::with_capacity(12))`\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/methods.rs:268:14\n+  --> $DIR/methods.rs:315:14\n    |\n LL |     with_err.unwrap_or(make());\n    |              ^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|_| make())`\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/methods.rs:271:19\n+  --> $DIR/methods.rs:318:19\n    |\n LL |     with_err_args.unwrap_or(Vec::with_capacity(12));\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|_| Vec::with_capacity(12))`\n \n error: use of `unwrap_or` followed by a call to `default`\n-  --> $DIR/methods.rs:274:5\n+  --> $DIR/methods.rs:321:5\n    |\n LL |     with_default_trait.unwrap_or(Default::default());\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `with_default_trait.unwrap_or_default()`\n \n error: use of `unwrap_or` followed by a call to `default`\n-  --> $DIR/methods.rs:277:5\n+  --> $DIR/methods.rs:324:5\n    |\n LL |     with_default_type.unwrap_or(u64::default());\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `with_default_type.unwrap_or_default()`\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/methods.rs:280:14\n+  --> $DIR/methods.rs:327:14\n    |\n LL |     with_vec.unwrap_or(vec![]);\n    |              ^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| vec![])`\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/methods.rs:285:21\n+  --> $DIR/methods.rs:332:21\n    |\n LL |     without_default.unwrap_or(Foo::new());\n    |                     ^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(Foo::new)`\n \n error: use of `or_insert` followed by a function call\n-  --> $DIR/methods.rs:288:19\n+  --> $DIR/methods.rs:335:19\n    |\n LL |     map.entry(42).or_insert(String::new());\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `or_insert_with(String::new)`\n \n error: use of `or_insert` followed by a function call\n-  --> $DIR/methods.rs:291:21\n+  --> $DIR/methods.rs:338:21\n    |\n LL |     btree.entry(42).or_insert(String::new());\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `or_insert_with(String::new)`\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/methods.rs:294:21\n+  --> $DIR/methods.rs:341:21\n    |\n LL |     let _ = stringy.unwrap_or(\"\".to_owned());\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| \"\".to_owned())`\n \n error: called `.iter().nth()` on a Vec. Calling `.get()` is both faster and more readable\n-  --> $DIR/methods.rs:305:23\n+  --> $DIR/methods.rs:352:23\n    |\n LL |         let bad_vec = some_vec.iter().nth(3);\n    |                       ^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::iter-nth` implied by `-D warnings`\n \n error: called `.iter().nth()` on a slice. Calling `.get()` is both faster and more readable\n-  --> $DIR/methods.rs:306:26\n+  --> $DIR/methods.rs:353:26\n    |\n LL |         let bad_slice = &some_vec[..].iter().nth(3);\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `.iter().nth()` on a slice. Calling `.get()` is both faster and more readable\n-  --> $DIR/methods.rs:307:31\n+  --> $DIR/methods.rs:354:31\n    |\n LL |         let bad_boxed_slice = boxed_slice.iter().nth(3);\n    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `.iter().nth()` on a VecDeque. Calling `.get()` is both faster and more readable\n-  --> $DIR/methods.rs:308:29\n+  --> $DIR/methods.rs:355:29\n    |\n LL |         let bad_vec_deque = some_vec_deque.iter().nth(3);\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `.iter_mut().nth()` on a Vec. Calling `.get_mut()` is both faster and more readable\n-  --> $DIR/methods.rs:313:23\n+  --> $DIR/methods.rs:360:23\n    |\n LL |         let bad_vec = some_vec.iter_mut().nth(3);\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `.iter_mut().nth()` on a slice. Calling `.get_mut()` is both faster and more readable\n-  --> $DIR/methods.rs:316:26\n+  --> $DIR/methods.rs:363:26\n    |\n LL |         let bad_slice = &some_vec[..].iter_mut().nth(3);\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `.iter_mut().nth()` on a VecDeque. Calling `.get_mut()` is both faster and more readable\n-  --> $DIR/methods.rs:319:29\n+  --> $DIR/methods.rs:366:29\n    |\n LL |         let bad_vec_deque = some_vec_deque.iter_mut().nth(3);\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: used unwrap() on an Option value. If you don't want to handle the None case gracefully, consider using expect() to provide a better panic message\n-  --> $DIR/methods.rs:331:13\n+  --> $DIR/methods.rs:378:13\n    |\n LL |     let _ = opt.unwrap();\n    |             ^^^^^^^^^^^^"}]}