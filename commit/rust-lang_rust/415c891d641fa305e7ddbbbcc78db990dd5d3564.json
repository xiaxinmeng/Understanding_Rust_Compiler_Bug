{"sha": "415c891d641fa305e7ddbbbcc78db990dd5d3564", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxNWM4OTFkNjQxZmEzMDVlN2RkYmJiY2M3OGRiOTkwZGQ1ZDM1NjQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-07-29T12:16:07Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-07-29T12:16:07Z"}, "message": "Reorganize", "tree": {"sha": "4b6e1e0aa4b5a732aeae8945e75c9bee3bbf1d65", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b6e1e0aa4b5a732aeae8945e75c9bee3bbf1d65"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/415c891d641fa305e7ddbbbcc78db990dd5d3564", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/415c891d641fa305e7ddbbbcc78db990dd5d3564", "html_url": "https://github.com/rust-lang/rust/commit/415c891d641fa305e7ddbbbcc78db990dd5d3564", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/415c891d641fa305e7ddbbbcc78db990dd5d3564/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad188d4c3db34f035408afbdd6d2f3c308121f0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad188d4c3db34f035408afbdd6d2f3c308121f0a", "html_url": "https://github.com/rust-lang/rust/commit/ad188d4c3db34f035408afbdd6d2f3c308121f0a"}], "stats": {"total": 399, "additions": 206, "deletions": 193}, "files": [{"sha": "01acb65157267fca71f5f7266aafd3ccd78da819", "filename": "src/lexer/comments.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/415c891d641fa305e7ddbbbcc78db990dd5d3564/src%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/415c891d641fa305e7ddbbbcc78db990dd5d3564/src%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flexer%2Fcomments.rs?ref=415c891d641fa305e7ddbbbcc78db990dd5d3564", "patch": "@@ -1,7 +1,6 @@\n use lexer::ptr::Ptr;\n \n-use SyntaxKind;\n-use syntax_kinds::*;\n+use SyntaxKind::{self, *};\n \n pub(crate) fn scan_shebang(ptr: &mut Ptr) -> bool {\n     if ptr.next_is('!') && ptr.nnext_is('/') {"}, {"sha": "69cab5b57a12b80313dd5eca7cb5ae53725bf901", "filename": "src/lexer/mod.rs", "status": "modified", "additions": 31, "deletions": 19, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/415c891d641fa305e7ddbbbcc78db990dd5d3564/src%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/415c891d641fa305e7ddbbbcc78db990dd5d3564/src%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flexer%2Fmod.rs?ref=415c891d641fa305e7ddbbbcc78db990dd5d3564", "patch": "@@ -1,21 +1,32 @@\n-use {SyntaxKind, Token};\n-use syntax_kinds::*;\n-\n mod ptr;\n-use self::ptr::Ptr;\n-\n+mod comments;\n+mod strings;\n+mod numbers;\n mod classes;\n-use self::classes::*;\n \n-mod numbers;\n-use self::numbers::scan_number;\n+use {\n+    TextUnit,\n+    SyntaxKind::{self, *},\n+};\n \n-mod strings;\n-use self::strings::{is_string_literal_start, scan_byte_char_or_string, scan_char, scan_raw_string,\n-                    scan_string};\n+use self::{\n+    ptr::Ptr,\n+    classes::*,\n+    numbers::scan_number,\n+    strings::{\n+        is_string_literal_start, scan_byte_char_or_string, scan_char,\n+        scan_raw_string, scan_string},\n+    comments::{scan_comment, scan_shebang},\n+};\n \n-mod comments;\n-use self::comments::{scan_comment, scan_shebang};\n+/// A token of Rust source.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct Token {\n+    /// The kind of token.\n+    pub kind: SyntaxKind,\n+    /// The length of the token.\n+    pub len: TextUnit,\n+}\n \n /// Break a string up into its component tokens\n pub fn tokenize(text: &str) -> Vec<Token> {\n@@ -29,6 +40,7 @@ pub fn tokenize(text: &str) -> Vec<Token> {\n     }\n     acc\n }\n+\n /// Get the next token from a string\n pub fn next_token(text: &str) -> Token {\n     assert!(!text.is_empty());\n@@ -109,7 +121,7 @@ fn next_token_inner(c: char, ptr: &mut Ptr) -> SyntaxKind {\n                     DOTDOT\n                 }\n                 _ => DOT,\n-            }\n+            };\n         }\n         ':' => {\n             return match ptr.next() {\n@@ -118,7 +130,7 @@ fn next_token_inner(c: char, ptr: &mut Ptr) -> SyntaxKind {\n                     COLONCOLON\n                 }\n                 _ => COLON,\n-            }\n+            };\n         }\n         '=' => {\n             return match ptr.next() {\n@@ -131,7 +143,7 @@ fn next_token_inner(c: char, ptr: &mut Ptr) -> SyntaxKind {\n                     FAT_ARROW\n                 }\n                 _ => EQ,\n-            }\n+            };\n         }\n         '!' => {\n             return match ptr.next() {\n@@ -140,15 +152,15 @@ fn next_token_inner(c: char, ptr: &mut Ptr) -> SyntaxKind {\n                     NEQ\n                 }\n                 _ => EXCL,\n-            }\n+            };\n         }\n         '-' => {\n             return if ptr.next_is('>') {\n                 ptr.bump();\n                 THIN_ARROW\n             } else {\n                 MINUS\n-            }\n+            };\n         }\n \n         // If the character is an ident start not followed by another single\n@@ -202,7 +214,7 @@ fn scan_ident(c: char, ptr: &mut Ptr) -> SyntaxKind {\n         return if c == '_' { UNDERSCORE } else { IDENT };\n     }\n     ptr.bump_while(is_ident_continue);\n-    if let Some(kind) = ident_to_keyword(ptr.current_token_text()) {\n+    if let Some(kind) = SyntaxKind::from_keyword(ptr.current_token_text()) {\n         return kind;\n     }\n     IDENT"}, {"sha": "38eac92129c09351642c553fbd408b28296219d1", "filename": "src/lexer/numbers.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/415c891d641fa305e7ddbbbcc78db990dd5d3564/src%2Flexer%2Fnumbers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/415c891d641fa305e7ddbbbcc78db990dd5d3564/src%2Flexer%2Fnumbers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flexer%2Fnumbers.rs?ref=415c891d641fa305e7ddbbbcc78db990dd5d3564", "patch": "@@ -1,8 +1,7 @@\n use lexer::ptr::Ptr;\n use lexer::classes::*;\n \n-use SyntaxKind;\n-use syntax_kinds::*;\n+use SyntaxKind::{self, *};\n \n pub(crate) fn scan_number(c: char, ptr: &mut Ptr) -> SyntaxKind {\n     if c == '0' {"}, {"sha": "e3704fbb30fc65e9156ff581d186a2adb238ccfe", "filename": "src/lexer/strings.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/415c891d641fa305e7ddbbbcc78db990dd5d3564/src%2Flexer%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/415c891d641fa305e7ddbbbcc78db990dd5d3564/src%2Flexer%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flexer%2Fstrings.rs?ref=415c891d641fa305e7ddbbbcc78db990dd5d3564", "patch": "@@ -1,5 +1,4 @@\n-use SyntaxKind;\n-use syntax_kinds::*;\n+use SyntaxKind::{self, *};\n \n use lexer::ptr::Ptr;\n "}, {"sha": "4260e22e715a8f46ff2c97b220b152e13c6e2e71", "filename": "src/lib.rs", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/415c891d641fa305e7ddbbbcc78db990dd5d3564/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/415c891d641fa305e7ddbbbcc78db990dd5d3564/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=415c891d641fa305e7ddbbbcc78db990dd5d3564", "patch": "@@ -19,27 +19,36 @@\n extern crate unicode_xid;\n extern crate text_unit;\n \n-mod tree;\n mod lexer;\n mod parser;\n mod yellow;\n+mod syntax_kinds;\n+\n+pub use {\n+    text_unit::{TextRange, TextUnit},\n+    syntax_kinds::SyntaxKind,\n+    yellow::{SyntaxNode},\n+    lexer::{tokenize, Token},\n+};\n+\n+pub(crate) use {\n+    yellow::SyntaxError\n+};\n+\n+pub fn parse(text: String) -> SyntaxNode {\n+    let tokens = tokenize(&text);\n+    parser::parse::<yellow::GreenBuilder>(text, &tokens)\n+}\n \n-pub mod syntax_kinds;\n-pub use text_unit::{TextRange, TextUnit};\n-pub use tree::{SyntaxKind, Token};\n-pub(crate) use tree::{Sink, GreenBuilder};\n-pub use lexer::{next_token, tokenize};\n-pub use yellow::SyntaxNode;\n-pub(crate) use yellow::SError;\n-pub use parser::{parse_green};\n \n /// Utilities for simple uses of the parser.\n pub mod utils {\n-    use std::fmt::Write;\n+    use std::{\n+        fmt::Write,\n+        collections::BTreeSet\n+    };\n \n-    use {SyntaxNode};\n-    use std::collections::BTreeSet;\n-    use SError;\n+    use {SyntaxNode, SyntaxError};\n \n     /// Parse a file and create a string representation of the resulting parse tree.\n     pub fn dump_tree_green(syntax: &SyntaxNode) -> String {\n@@ -48,7 +57,7 @@ pub mod utils {\n         go(syntax, &mut result, 0, &mut errors);\n         return result;\n \n-        fn go(node: &SyntaxNode, buff: &mut String, level: usize, errors: &mut BTreeSet<SError>) {\n+        fn go(node: &SyntaxNode, buff: &mut String, level: usize, errors: &mut BTreeSet<SyntaxError>) {\n             buff.push_str(&String::from(\"  \").repeat(level));\n             write!(buff, \"{:?}\\n\", node).unwrap();\n             let my_errors: Vec<_> = errors.iter().filter(|e| e.offset == node.range().start())"}, {"sha": "a8d503b3d7bfcd86714fcc18e7662a9d24a24a60", "filename": "src/parser/event.rs", "status": "modified", "additions": 27, "deletions": 6, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/415c891d641fa305e7ddbbbcc78db990dd5d3564/src%2Fparser%2Fevent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/415c891d641fa305e7ddbbbcc78db990dd5d3564/src%2Fparser%2Fevent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fevent.rs?ref=415c891d641fa305e7ddbbbcc78db990dd5d3564", "patch": "@@ -1,8 +1,29 @@\n+//! This module provides a way to construct a `File`.\n+//! It is intended to be completely decoupled from the\n+//! parser, so as to allow to evolve the tree representation\n+//! and the parser algorithm independently.\n+//!\n+//! The `Sink` trait is the bridge between the parser and the\n+//! tree builder: the parser produces a stream of events like\n+//! `start node`, `finish node`, and `FileBuilder` converts\n+//! this stream to a real tree.\n use {\n-    Sink, SyntaxKind, Token,\n-    syntax_kinds::TOMBSTONE,\n+    TextUnit,\n+    SyntaxKind::{self, TOMBSTONE},\n+    lexer::Token,\n };\n-use super::is_insignificant;\n+\n+pub(crate) trait Sink {\n+    type Tree;\n+\n+    fn new(text: String) -> Self;\n+\n+    fn leaf(&mut self, kind: SyntaxKind, len: TextUnit);\n+    fn start_internal(&mut self, kind: SyntaxKind);\n+    fn finish_internal(&mut self);\n+    fn error(&mut self, err: String);\n+    fn finish(self) -> Self::Tree;\n+}\n \n /// `Parser` produces a flat list of `Event`s.\n /// They are converted to a tree-structure in\n@@ -67,7 +88,7 @@ pub(crate) enum Event {\n     },\n }\n \n-pub(super) fn process(builder: &mut Sink, tokens: &[Token], events: Vec<Event>) {\n+pub(super) fn process(builder: &mut impl Sink, tokens: &[Token], events: Vec<Event>) {\n     let mut idx = 0;\n \n     let mut holes = Vec::new();\n@@ -111,7 +132,7 @@ pub(super) fn process(builder: &mut Sink, tokens: &[Token], events: Vec<Event>)\n             &Event::Finish => {\n                 while idx < tokens.len() {\n                     let token = tokens[idx];\n-                    if is_insignificant(token.kind) {\n+                    if token.kind.is_trivia() {\n                         idx += 1;\n                         builder.leaf(token.kind, token.len);\n                     } else {\n@@ -128,7 +149,7 @@ pub(super) fn process(builder: &mut Sink, tokens: &[Token], events: Vec<Event>)\n                 // this should be done in a sensible manner instead\n                 loop {\n                     let token = tokens[idx];\n-                    if !is_insignificant(token.kind) {\n+                    if !token.kind.is_trivia() {\n                         break;\n                     }\n                     builder.leaf(token.kind, token.len);"}, {"sha": "085e62d56e77c0c567e88c9e7c636f73e3525914", "filename": "src/parser/grammar/mod.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/415c891d641fa305e7ddbbbcc78db990dd5d3564/src%2Fparser%2Fgrammar%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/415c891d641fa305e7ddbbbcc78db990dd5d3564/src%2Fparser%2Fgrammar%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fgrammar%2Fmod.rs?ref=415c891d641fa305e7ddbbbcc78db990dd5d3564", "patch": "@@ -21,11 +21,6 @@\n //! After adding a new inline-test, run `cargo collect-tests` to extract\n //! it as a standalone text-fixture into `tests/data/parser/inline`, and\n //! run `cargo test` once to create the \"gold\" value.\n-use parser::parser::Parser;\n-use parser::token_set::TokenSet;\n-use SyntaxKind;\n-use syntax_kinds::*;\n-\n mod items;\n mod attributes;\n mod expressions;\n@@ -34,6 +29,14 @@ mod patterns;\n mod paths;\n mod type_params;\n \n+use {\n+    SyntaxKind::{self, *},\n+    parser::{\n+        parser::Parser,\n+        token_set::TokenSet\n+    }\n+};\n+\n pub(crate) fn file(p: &mut Parser) {\n     let file = p.start();\n     p.eat(SHEBANG);"}, {"sha": "052981fbce1034ef142689923953740b2a77c5c8", "filename": "src/parser/input.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/415c891d641fa305e7ddbbbcc78db990dd5d3564/src%2Fparser%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/415c891d641fa305e7ddbbbcc78db990dd5d3564/src%2Fparser%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Finput.rs?ref=415c891d641fa305e7ddbbbcc78db990dd5d3564", "patch": "@@ -1,6 +1,8 @@\n-use {SyntaxKind, TextRange, TextUnit, Token};\n-use syntax_kinds::EOF;\n-use super::is_insignificant;\n+use {\n+    SyntaxKind, TextRange, TextUnit,\n+    SyntaxKind::EOF,\n+    lexer::Token,\n+};\n \n use std::ops::{Add, AddAssign};\n \n@@ -16,7 +18,7 @@ impl<'t> ParserInput<'t> {\n         let mut start_offsets = Vec::new();\n         let mut len = 0.into();\n         for &token in raw_tokens.iter() {\n-            if !is_insignificant(token.kind) {\n+            if !token.kind.is_trivia() {\n                 tokens.push(token);\n                 start_offsets.push(len);\n             }"}, {"sha": "e72ab05af025781ab1c192576727f7789a52f788", "filename": "src/parser/mod.rs", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/415c891d641fa305e7ddbbbcc78db990dd5d3564/src%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/415c891d641fa305e7ddbbbcc78db990dd5d3564/src%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fmod.rs?ref=415c891d641fa305e7ddbbbcc78db990dd5d3564", "patch": "@@ -5,34 +5,24 @@ mod input;\n mod event;\n mod grammar;\n \n-use std::sync::Arc;\n use {\n-    Token,\n-    yellow::SyntaxNode,\n-    syntax_kinds::*\n+    lexer::Token,\n+    parser::event::{process}\n };\n-use GreenBuilder;\n-use parser::event::process;\n+\n+pub(crate) use self::event::Sink;\n \n \n /// Parse a sequence of tokens into the representative node tree\n-pub fn parse_green(text: String, tokens: &[Token]) -> SyntaxNode {\n+pub(crate) fn parse<S: Sink>(text: String, tokens: &[Token]) -> S::Tree {\n     let events = {\n         let input = input::ParserInput::new(&text, tokens);\n         let parser_impl = parser::imp::ParserImpl::new(&input);\n         let mut parser = parser::Parser(parser_impl);\n         grammar::file(&mut parser);\n         parser.0.into_events()\n     };\n-    let mut builder = GreenBuilder::new(text);\n-    process(&mut builder, tokens, events);\n-    let (green, errors) = builder.finish();\n-    SyntaxNode::new(Arc::new(green), errors)\n-}\n-\n-fn is_insignificant(kind: SyntaxKind) -> bool {\n-    match kind {\n-        WHITESPACE | COMMENT => true,\n-        _ => false,\n-    }\n+    let mut sink = S::new(text);\n+    process(&mut sink, tokens, events);\n+    sink.finish()\n }"}, {"sha": "38237ac06c33d18953347daf6788860ca79c7bfb", "filename": "src/parser/parser/imp.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/415c891d641fa305e7ddbbbcc78db990dd5d3564/src%2Fparser%2Fparser%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/415c891d641fa305e7ddbbbcc78db990dd5d3564/src%2Fparser%2Fparser%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fparser%2Fimp.rs?ref=415c891d641fa305e7ddbbbcc78db990dd5d3564", "patch": "@@ -1,8 +1,7 @@\n use parser::input::{InputPosition, ParserInput};\n use parser::event::Event;\n \n-use SyntaxKind;\n-use syntax_kinds::{EOF, TOMBSTONE};\n+use SyntaxKind::{self, EOF, TOMBSTONE};\n \n /// Implementation details of `Parser`, extracted\n /// to a separate struct in order not to pollute"}, {"sha": "0930ff9e47dcb44bd05a91f267297a25e5344e74", "filename": "src/parser/parser/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/415c891d641fa305e7ddbbbcc78db990dd5d3564/src%2Fparser%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/415c891d641fa305e7ddbbbcc78db990dd5d3564/src%2Fparser%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fparser%2Fmod.rs?ref=415c891d641fa305e7ddbbbcc78db990dd5d3564", "patch": "@@ -1,5 +1,4 @@\n-use SyntaxKind;\n-use syntax_kinds::ERROR;\n+use SyntaxKind::{self, ERROR};\n \n pub(super) mod imp;\n use self::imp::ParserImpl;"}, {"sha": "d332fd02e72a9e55dbab0dd4f4cd29c48e12419d", "filename": "src/syntax_kinds/generated.rs", "status": "renamed", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/415c891d641fa305e7ddbbbcc78db990dd5d3564/src%2Fsyntax_kinds%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/415c891d641fa305e7ddbbbcc78db990dd5d3564/src%2Fsyntax_kinds%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsyntax_kinds%2Fgenerated.rs?ref=415c891d641fa305e7ddbbbcc78db990dd5d3564", "patch": "@@ -1,7 +1,7 @@\n #![allow(bad_style, missing_docs, unreachable_pub)]\n #![cfg_attr(rustfmt, rustfmt_skip)]\n //! Generated from grammar.ron\n-use tree::SyntaxInfo;\n+use super::SyntaxInfo;\n \n /// The kind of syntax node, e.g. `IDENT`, `USE_KW`, or `STRUCT_DEF`.\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n@@ -288,39 +288,39 @@ impl SyntaxKind {\n             EOF => &SyntaxInfo { name: \"EOF\" },\n         }\n     }\n-}\n-\n-pub(crate) fn ident_to_keyword(ident: &str) -> Option<SyntaxKind> {\n-    match ident {\n-        \"use\" => Some(USE_KW),\n-        \"fn\" => Some(FN_KW),\n-        \"struct\" => Some(STRUCT_KW),\n-        \"enum\" => Some(ENUM_KW),\n-        \"trait\" => Some(TRAIT_KW),\n-        \"impl\" => Some(IMPL_KW),\n-        \"true\" => Some(TRUE_KW),\n-        \"false\" => Some(FALSE_KW),\n-        \"as\" => Some(AS_KW),\n-        \"extern\" => Some(EXTERN_KW),\n-        \"crate\" => Some(CRATE_KW),\n-        \"mod\" => Some(MOD_KW),\n-        \"pub\" => Some(PUB_KW),\n-        \"self\" => Some(SELF_KW),\n-        \"super\" => Some(SUPER_KW),\n-        \"in\" => Some(IN_KW),\n-        \"where\" => Some(WHERE_KW),\n-        \"for\" => Some(FOR_KW),\n-        \"loop\" => Some(LOOP_KW),\n-        \"while\" => Some(WHILE_KW),\n-        \"if\" => Some(IF_KW),\n-        \"match\" => Some(MATCH_KW),\n-        \"const\" => Some(CONST_KW),\n-        \"static\" => Some(STATIC_KW),\n-        \"mut\" => Some(MUT_KW),\n-        \"unsafe\" => Some(UNSAFE_KW),\n-        \"type\" => Some(TYPE_KW),\n-        \"ref\" => Some(REF_KW),\n-        \"let\" => Some(LET_KW),\n-        _ => None,\n+    pub(crate) fn from_keyword(ident: &str) -> Option<SyntaxKind> {\n+        match ident {\n+            \"use\" => Some(USE_KW),\n+            \"fn\" => Some(FN_KW),\n+            \"struct\" => Some(STRUCT_KW),\n+            \"enum\" => Some(ENUM_KW),\n+            \"trait\" => Some(TRAIT_KW),\n+            \"impl\" => Some(IMPL_KW),\n+            \"true\" => Some(TRUE_KW),\n+            \"false\" => Some(FALSE_KW),\n+            \"as\" => Some(AS_KW),\n+            \"extern\" => Some(EXTERN_KW),\n+            \"crate\" => Some(CRATE_KW),\n+            \"mod\" => Some(MOD_KW),\n+            \"pub\" => Some(PUB_KW),\n+            \"self\" => Some(SELF_KW),\n+            \"super\" => Some(SUPER_KW),\n+            \"in\" => Some(IN_KW),\n+            \"where\" => Some(WHERE_KW),\n+            \"for\" => Some(FOR_KW),\n+            \"loop\" => Some(LOOP_KW),\n+            \"while\" => Some(WHILE_KW),\n+            \"if\" => Some(IF_KW),\n+            \"match\" => Some(MATCH_KW),\n+            \"const\" => Some(CONST_KW),\n+            \"static\" => Some(STATIC_KW),\n+            \"mut\" => Some(MUT_KW),\n+            \"unsafe\" => Some(UNSAFE_KW),\n+            \"type\" => Some(TYPE_KW),\n+            \"ref\" => Some(REF_KW),\n+            \"let\" => Some(LET_KW),\n+            _ => None,\n+        }\n     }\n }\n+", "previous_filename": "src/syntax_kinds.rs"}, {"sha": "a8e9bfe294df88f6489b748a5fe0b7b340fdf20b", "filename": "src/syntax_kinds/mod.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/415c891d641fa305e7ddbbbcc78db990dd5d3564/src%2Fsyntax_kinds%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/415c891d641fa305e7ddbbbcc78db990dd5d3564/src%2Fsyntax_kinds%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsyntax_kinds%2Fmod.rs?ref=415c891d641fa305e7ddbbbcc78db990dd5d3564", "patch": "@@ -0,0 +1,27 @@\n+mod generated;\n+\n+use std::fmt;\n+use ::{SyntaxKind::*};\n+\n+pub use self::generated::SyntaxKind;\n+\n+impl fmt::Debug for SyntaxKind {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let name = self.info().name;\n+        f.write_str(name)\n+    }\n+}\n+\n+pub(crate) struct SyntaxInfo {\n+    pub name: &'static str,\n+}\n+\n+\n+impl SyntaxKind {\n+    pub(crate) fn is_trivia(self: SyntaxKind) -> bool {\n+        match self {\n+            WHITESPACE | COMMENT | DOC_COMMENT => true,\n+            _ => false,\n+        }\n+    }\n+}"}, {"sha": "efba8282501a2b2a13ac4c3d76e76652d1b7fa82", "filename": "src/tree/mod.rs", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ad188d4c3db34f035408afbdd6d2f3c308121f0a/src%2Ftree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad188d4c3db34f035408afbdd6d2f3c308121f0a/src%2Ftree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftree%2Fmod.rs?ref=ad188d4c3db34f035408afbdd6d2f3c308121f0a", "patch": "@@ -1,27 +0,0 @@\n-mod file_builder;\n-\n-use ::{TextUnit};\n-use std::{fmt};\n-pub(crate) use self::file_builder::{Sink, GreenBuilder};\n-\n-pub use syntax_kinds::SyntaxKind;\n-\n-impl fmt::Debug for SyntaxKind {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        let name = self.info().name;\n-        f.write_str(name)\n-    }\n-}\n-\n-pub(crate) struct SyntaxInfo {\n-    pub name: &'static str,\n-}\n-\n-/// A token of Rust source.\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct Token {\n-    /// The kind of token.\n-    pub kind: SyntaxKind,\n-    /// The length of the token.\n-    pub len: TextUnit,\n-}"}, {"sha": "346d561cdeac062a5ea1132e8af2a0623bcce8f8", "filename": "src/yellow/builder.rs", "status": "renamed", "additions": 15, "deletions": 34, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/415c891d641fa305e7ddbbbcc78db990dd5d3564/src%2Fyellow%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/415c891d641fa305e7ddbbbcc78db990dd5d3564/src%2Fyellow%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fyellow%2Fbuilder.rs?ref=415c891d641fa305e7ddbbbcc78db990dd5d3564", "patch": "@@ -1,36 +1,26 @@\n-//! This module provides a way to construct a `File`.\n-//! It is intended to be completely decoupled from the\n-//! parser, so as to allow to evolve the tree representation\n-//! and the parser algorithm independently.\n-//!\n-//! The `Sink` trait is the bridge between the parser and the\n-//! tree builder: the parser produces a stream of events like\n-//! `start node`, `finish node`, and `FileBuilder` converts\n-//! this stream to a real tree.\n use std::sync::Arc;\n use {\n     SyntaxKind, TextRange, TextUnit,\n-    yellow::GreenNode\n+    yellow::{SyntaxNode, GreenNode, SyntaxError},\n+    parser::Sink\n };\n-use SError;\n-\n-pub(crate) trait Sink {\n-    fn leaf(&mut self, kind: SyntaxKind, len: TextUnit);\n-    fn start_internal(&mut self, kind: SyntaxKind);\n-    fn finish_internal(&mut self);\n-    fn error(&mut self, err: String);\n-}\n \n pub(crate) struct GreenBuilder {\n     text: String,\n     stack: Vec<GreenNode>,\n     pos: TextUnit,\n     root: Option<GreenNode>,\n-    errors: Vec<SError>,\n+    errors: Vec<SyntaxError>,\n }\n \n impl GreenBuilder {\n-    pub(crate) fn new(text: String) -> GreenBuilder {\n+\n+}\n+\n+impl Sink for GreenBuilder {\n+    type Tree = SyntaxNode;\n+\n+    fn new(text: String) -> Self {\n         GreenBuilder {\n             text,\n             stack: Vec::new(),\n@@ -40,12 +30,6 @@ impl GreenBuilder {\n         }\n     }\n \n-    pub(crate) fn finish(self) -> (GreenNode, Vec<SError>) {\n-        (self.root.unwrap(), self.errors)\n-    }\n-}\n-\n-impl Sink for GreenBuilder {\n     fn leaf(&mut self, kind: SyntaxKind, len: TextUnit) {\n         let range = TextRange::offset_len(self.pos, len);\n         self.pos += len;\n@@ -73,15 +57,12 @@ impl Sink for GreenBuilder {\n     }\n \n     fn error(&mut self, message: String) {\n-        self.errors.push(SError { message, offset: self.pos })\n+        self.errors.push(SyntaxError { message, offset: self.pos })\n     }\n-}\n-impl SyntaxKind {\n-    fn is_trivia(self) -> bool {\n-        match self {\n-            SyntaxKind::WHITESPACE | SyntaxKind::DOC_COMMENT | SyntaxKind::COMMENT => true,\n-            _ => false\n-        }\n+\n+    fn finish(self) -> SyntaxNode {\n+        SyntaxNode::new(Arc::new(self.root.unwrap()), self.errors)\n     }\n }\n \n+", "previous_filename": "src/tree/file_builder.rs"}, {"sha": "9e64d042fa2bdeaa4796afe7989e3503aa06f0c4", "filename": "src/yellow/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/415c891d641fa305e7ddbbbcc78db990dd5d3564/src%2Fyellow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/415c891d641fa305e7ddbbbcc78db990dd5d3564/src%2Fyellow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fyellow%2Fmod.rs?ref=415c891d641fa305e7ddbbbcc78db990dd5d3564", "patch": "@@ -1,6 +1,7 @@\n mod green;\n mod red;\n mod syntax;\n+mod builder;\n \n use std::{\n     sync::{Arc, Weak},\n@@ -9,7 +10,8 @@ use std::{\n pub(crate) use self::{\n     green::{GreenNode, TextLen},\n     red::RedNode,\n-    syntax::SError,\n+    syntax::SyntaxError,\n+    builder::GreenBuilder,\n };\n pub use self::syntax::SyntaxNode;\n "}, {"sha": "78fa5bf957b54c3242548820532cea686fb945aa", "filename": "src/yellow/syntax.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/415c891d641fa305e7ddbbbcc78db990dd5d3564/src%2Fyellow%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/415c891d641fa305e7ddbbbcc78db990dd5d3564/src%2Fyellow%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fyellow%2Fsyntax.rs?ref=415c891d641fa305e7ddbbbcc78db990dd5d3564", "patch": "@@ -4,7 +4,8 @@ use std::{\n };\n \n use {\n-    TextRange, TextUnit, SyntaxKind,\n+    TextRange, TextUnit,\n+    SyntaxKind::{self, *},\n     yellow::{Ptr, RedNode, GreenNode, TextLen},\n };\n \n@@ -18,17 +19,17 @@ pub struct SyntaxNode {\n #[derive(Clone)]\n pub struct SyntaxRoot {\n     red: Arc<RedNode>,\n-    pub(crate) errors: Arc<Vec<SError>>,\n+    pub(crate) errors: Arc<Vec<SyntaxError>>,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash, Ord, PartialOrd)]\n-pub(crate) struct SError {\n+pub(crate) struct SyntaxError {\n     pub(crate) message: String,\n     pub(crate) offset: TextUnit,\n }\n \n impl SyntaxNode {\n-    pub(crate) fn new(root: Arc<GreenNode>, errors: Vec<SError>) -> SyntaxNode {\n+    pub(crate) fn new(root: Arc<GreenNode>, errors: Vec<SyntaxError>) -> SyntaxNode {\n         let root = Arc::new(RedNode::new_root(root));\n         let red = Ptr::new(&root);\n         let root = SyntaxRoot { red: root, errors: Arc::new(errors) };\n@@ -123,7 +124,6 @@ impl fmt::Debug for SyntaxNode {\n }\n \n fn has_short_text(kind: SyntaxKind) -> bool {\n-    use syntax_kinds::*;\n     match kind {\n         IDENT | LIFETIME => true,\n         _ => false,"}, {"sha": "3b6670cb05523978941f82ed2996b3a6fb188727", "filename": "tests/parser.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/415c891d641fa305e7ddbbbcc78db990dd5d3564/tests%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/415c891d641fa305e7ddbbbcc78db990dd5d3564/tests%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fparser.rs?ref=415c891d641fa305e7ddbbbcc78db990dd5d3564", "patch": "@@ -1,15 +1,14 @@\n extern crate libsyntax2;\n extern crate testutils;\n \n-use libsyntax2::{tokenize, parse_green};\n+use libsyntax2::{parse};\n use libsyntax2::utils::{dump_tree_green};\n use testutils::dir_tests;\n \n #[test]\n fn parser_tests() {\n     dir_tests(&[\"parser/inline\", \"parser/ok\", \"parser/err\"], |text| {\n-        let tokens = tokenize(text);\n-        let file = parse_green(text.to_string(), &tokens);\n+        let file = parse(text.to_string());\n         dump_tree_green(&file)\n     })\n }"}, {"sha": "e772922baa330a54f933b37c6e951636811ef015", "filename": "tools/src/bin/gen.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/415c891d641fa305e7ddbbbcc78db990dd5d3564/tools%2Fsrc%2Fbin%2Fgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/415c891d641fa305e7ddbbbcc78db990dd5d3564/tools%2Fsrc%2Fbin%2Fgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tools%2Fsrc%2Fbin%2Fgen.rs?ref=415c891d641fa305e7ddbbbcc78db990dd5d3564", "patch": "@@ -36,7 +36,7 @@ impl Grammar {\n         acc.push_str(\"#![allow(bad_style, missing_docs, unreachable_pub)]\\n\");\n         acc.push_str(\"#![cfg_attr(rustfmt, rustfmt_skip)]\\n\");\n         acc.push_str(\"//! Generated from grammar.ron\\n\");\n-        acc.push_str(\"use tree::SyntaxInfo;\\n\");\n+        acc.push_str(\"use super::SyntaxInfo;\\n\");\n         acc.push_str(\"\\n\");\n \n         let syntax_kinds: Vec<String> = self.tokens\n@@ -82,19 +82,19 @@ impl Grammar {\n         acc.push_str(\"            EOF => &SyntaxInfo { name: \\\"EOF\\\" },\\n\");\n         acc.push_str(\"        }\\n\");\n         acc.push_str(\"    }\\n\");\n-        acc.push_str(\"}\\n\");\n-        acc.push_str(\"\\n\");\n \n-        // fn ident_to_keyword\n-        acc.push_str(\"pub(crate) fn ident_to_keyword(ident: &str) -> Option<SyntaxKind> {\\n\");\n-        acc.push_str(\"    match ident {\\n\");\n+        // fn from_keyword\n+        acc.push_str(\"    pub(crate) fn from_keyword(ident: &str) -> Option<SyntaxKind> {\\n\");\n+        acc.push_str(\"        match ident {\\n\");\n         // NB: no contextual_keywords here!\n         for kw in self.keywords.iter() {\n-            write!(acc, \"        {:?} => Some({}),\\n\", kw, kw_token(kw)).unwrap();\n+            write!(acc, \"            {:?} => Some({}),\\n\", kw, kw_token(kw)).unwrap();\n         }\n-        acc.push_str(\"        _ => None,\\n\");\n+        acc.push_str(\"            _ => None,\\n\");\n+        acc.push_str(\"        }\\n\");\n         acc.push_str(\"    }\\n\");\n         acc.push_str(\"}\\n\");\n+        acc.push_str(\"\\n\");\n         acc\n     }\n }\n@@ -104,7 +104,7 @@ fn grammar_file() -> PathBuf {\n }\n \n fn generated_file() -> PathBuf {\n-    base_dir().join(\"src/syntax_kinds.rs\")\n+    base_dir().join(\"src/syntax_kinds/generated.rs\")\n }\n \n fn scream(word: &str) -> String {"}, {"sha": "cb3414711af5cbe93039f325834e30bb70747970", "filename": "tools/src/bin/parse.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/415c891d641fa305e7ddbbbcc78db990dd5d3564/tools%2Fsrc%2Fbin%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/415c891d641fa305e7ddbbbcc78db990dd5d3564/tools%2Fsrc%2Fbin%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tools%2Fsrc%2Fbin%2Fparse.rs?ref=415c891d641fa305e7ddbbbcc78db990dd5d3564", "patch": "@@ -2,13 +2,12 @@ extern crate libsyntax2;\n \n use std::io::Read;\n \n-use libsyntax2::{parse_green, tokenize};\n+use libsyntax2::{parse};\n use libsyntax2::utils::dump_tree_green;\n \n fn main() {\n     let text = read_input();\n-    let tokens = tokenize(&text);\n-    let file = parse_green(text, &tokens);\n+    let file = parse(text);\n     let tree = dump_tree_green(&file);\n     println!(\"{}\", tree);\n }"}]}