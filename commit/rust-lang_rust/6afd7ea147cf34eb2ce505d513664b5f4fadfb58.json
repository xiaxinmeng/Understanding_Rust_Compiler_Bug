{"sha": "6afd7ea147cf34eb2ce505d513664b5f4fadfb58", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhZmQ3ZWExNDdjZjM0ZWIyY2U1MDVkNTEzNjY0YjVmNGZhZGZiNTg=", "commit": {"author": {"name": "ThibsG", "email": "Thibs@debian.com", "date": "2020-01-19T10:07:13Z"}, "committer": {"name": "ThibsG", "email": "Thibs@debian.com", "date": "2020-02-04T21:49:08Z"}, "message": "Use span_lint_and_sugg + move infaillible lint\n\n - moving infaillible lint to prevent collisions", "tree": {"sha": "d1441fe1bfd257218c8e16f2ccf9a6a54fc0f7be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d1441fe1bfd257218c8e16f2ccf9a6a54fc0f7be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6afd7ea147cf34eb2ce505d513664b5f4fadfb58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6afd7ea147cf34eb2ce505d513664b5f4fadfb58", "html_url": "https://github.com/rust-lang/rust/commit/6afd7ea147cf34eb2ce505d513664b5f4fadfb58", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6afd7ea147cf34eb2ce505d513664b5f4fadfb58/comments", "author": {"login": "ThibsG", "id": 12683889, "node_id": "MDQ6VXNlcjEyNjgzODg5", "avatar_url": "https://avatars.githubusercontent.com/u/12683889?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ThibsG", "html_url": "https://github.com/ThibsG", "followers_url": "https://api.github.com/users/ThibsG/followers", "following_url": "https://api.github.com/users/ThibsG/following{/other_user}", "gists_url": "https://api.github.com/users/ThibsG/gists{/gist_id}", "starred_url": "https://api.github.com/users/ThibsG/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ThibsG/subscriptions", "organizations_url": "https://api.github.com/users/ThibsG/orgs", "repos_url": "https://api.github.com/users/ThibsG/repos", "events_url": "https://api.github.com/users/ThibsG/events{/privacy}", "received_events_url": "https://api.github.com/users/ThibsG/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ThibsG", "id": 12683889, "node_id": "MDQ6VXNlcjEyNjgzODg5", "avatar_url": "https://avatars.githubusercontent.com/u/12683889?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ThibsG", "html_url": "https://github.com/ThibsG", "followers_url": "https://api.github.com/users/ThibsG/followers", "following_url": "https://api.github.com/users/ThibsG/following{/other_user}", "gists_url": "https://api.github.com/users/ThibsG/gists{/gist_id}", "starred_url": "https://api.github.com/users/ThibsG/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ThibsG/subscriptions", "organizations_url": "https://api.github.com/users/ThibsG/orgs", "repos_url": "https://api.github.com/users/ThibsG/repos", "events_url": "https://api.github.com/users/ThibsG/events{/privacy}", "received_events_url": "https://api.github.com/users/ThibsG/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3445d41f07aba83d83b2093381512a24b9fa974c", "url": "https://api.github.com/repos/rust-lang/rust/commits/3445d41f07aba83d83b2093381512a24b9fa974c", "html_url": "https://github.com/rust-lang/rust/commit/3445d41f07aba83d83b2093381512a24b9fa974c"}], "stats": {"total": 278, "additions": 166, "deletions": 112}, "files": [{"sha": "49de9df64694c779aff4340c01a9ad55bcb2e6a9", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6afd7ea147cf34eb2ce505d513664b5f4fadfb58/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/6afd7ea147cf34eb2ce505d513664b5f4fadfb58/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=6afd7ea147cf34eb2ce505d513664b5f4fadfb58", "patch": "@@ -1217,6 +1217,7 @@ Released 2018-09-13\n [`match_overlapping_arm`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_overlapping_arm\n [`match_ref_pats`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_ref_pats\n [`match_same_arms`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_same_arms\n+[`match_single_binding`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_single_binding\n [`match_wild_err_arm`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_wild_err_arm\n [`maybe_infinite_iter`]: https://rust-lang.github.io/rust-clippy/master/index.html#maybe_infinite_iter\n [`mem_discriminant_non_enum`]: https://rust-lang.github.io/rust-clippy/master/index.html#mem_discriminant_non_enum"}, {"sha": "1d23dd115bc49d9b5346dbe2152201d345c3fc62", "filename": "clippy_lints/src/infallible_destructuring_match.rs", "status": "removed", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/3445d41f07aba83d83b2093381512a24b9fa974c/clippy_lints%2Fsrc%2Finfallible_destructuring_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3445d41f07aba83d83b2093381512a24b9fa974c/clippy_lints%2Fsrc%2Finfallible_destructuring_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finfallible_destructuring_match.rs?ref=3445d41f07aba83d83b2093381512a24b9fa974c", "patch": "@@ -1,77 +0,0 @@\n-use super::utils::{get_arg_name, match_var, remove_blocks, snippet_with_applicability, span_lint_and_sugg};\n-use if_chain::if_chain;\n-use rustc_errors::Applicability;\n-use rustc_hir::*;\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for matches being used to destructure a single-variant enum\n-    /// or tuple struct where a `let` will suffice.\n-    ///\n-    /// **Why is this bad?** Just readability \u2013 `let` doesn't nest, whereas a `match` does.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// enum Wrapper {\n-    ///     Data(i32),\n-    /// }\n-    ///\n-    /// let wrapper = Wrapper::Data(42);\n-    ///\n-    /// let data = match wrapper {\n-    ///     Wrapper::Data(i) => i,\n-    /// };\n-    /// ```\n-    ///\n-    /// The correct use would be:\n-    /// ```rust\n-    /// enum Wrapper {\n-    ///     Data(i32),\n-    /// }\n-    ///\n-    /// let wrapper = Wrapper::Data(42);\n-    /// let Wrapper::Data(data) = wrapper;\n-    /// ```\n-    pub INFALLIBLE_DESTRUCTURING_MATCH,\n-    style,\n-    \"a `match` statement with a single infallible arm instead of a `let`\"\n-}\n-\n-declare_lint_pass!(InfallibleDestructingMatch => [INFALLIBLE_DESTRUCTURING_MATCH]);\n-\n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InfallibleDestructingMatch {\n-    fn check_local(&mut self, cx: &LateContext<'a, 'tcx>, local: &'tcx Local<'_>) {\n-        if_chain! {\n-            if let Some(ref expr) = local.init;\n-            if let ExprKind::Match(ref target, ref arms, MatchSource::Normal) = expr.kind;\n-            if arms.len() == 1 && arms[0].guard.is_none();\n-            if let PatKind::TupleStruct(QPath::Resolved(None, ref variant_name), ref args, _) = arms[0].pat.kind;\n-            if args.len() == 1;\n-            if let Some(arg) = get_arg_name(&args[0]);\n-            let body = remove_blocks(&arms[0].body);\n-            if match_var(body, arg);\n-\n-            then {\n-                let mut applicability = Applicability::MachineApplicable;\n-                span_lint_and_sugg(\n-                    cx,\n-                    INFALLIBLE_DESTRUCTURING_MATCH,\n-                    local.span,\n-                    \"you seem to be trying to use `match` to destructure a single infallible pattern. \\\n-                     Consider using `let`\",\n-                    \"try this\",\n-                    format!(\n-                        \"let {}({}) = {};\",\n-                        snippet_with_applicability(cx, variant_name.span, \"..\", &mut applicability),\n-                        snippet_with_applicability(cx, local.pat.span, \"..\", &mut applicability),\n-                        snippet_with_applicability(cx, target.span, \"..\", &mut applicability),\n-                    ),\n-                    applicability,\n-                );\n-            }\n-        }\n-    }\n-}"}, {"sha": "45342cc7e0070f66d44f81d9ec801f98b2576835", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6afd7ea147cf34eb2ce505d513664b5f4fadfb58/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6afd7ea147cf34eb2ce505d513664b5f4fadfb58/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=6afd7ea147cf34eb2ce505d513664b5f4fadfb58", "patch": "@@ -218,7 +218,6 @@ pub mod if_let_some_result;\n pub mod if_not_else;\n pub mod implicit_return;\n pub mod indexing_slicing;\n-pub mod infallible_destructuring_match;\n pub mod infinite_iter;\n pub mod inherent_impl;\n pub mod inherent_to_string;\n@@ -555,7 +554,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &implicit_return::IMPLICIT_RETURN,\n         &indexing_slicing::INDEXING_SLICING,\n         &indexing_slicing::OUT_OF_BOUNDS_INDEXING,\n-        &infallible_destructuring_match::INFALLIBLE_DESTRUCTURING_MATCH,\n         &infinite_iter::INFINITE_ITER,\n         &infinite_iter::MAYBE_INFINITE_ITER,\n         &inherent_impl::MULTIPLE_INHERENT_IMPL,\n@@ -600,12 +598,13 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &map_clone::MAP_CLONE,\n         &map_unit_fn::OPTION_MAP_UNIT_FN,\n         &map_unit_fn::RESULT_MAP_UNIT_FN,\n+        &matches::INFALLIBLE_DESTRUCTURING_MATCH,\n         &matches::MATCH_AS_REF,\n         &matches::MATCH_BOOL,\n         &matches::MATCH_OVERLAPPING_ARM,\n         &matches::MATCH_REF_PATS,\n-        &matches::MATCH_WILD_ERR_ARM,\n         &matches::MATCH_SINGLE_BINDING,\n+        &matches::MATCH_WILD_ERR_ARM,\n         &matches::SINGLE_MATCH,\n         &matches::SINGLE_MATCH_ELSE,\n         &matches::WILDCARD_ENUM_MATCH_ARM,\n@@ -865,7 +864,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box types::Casts);\n     let type_complexity_threshold = conf.type_complexity_threshold;\n     store.register_late_pass(move || box types::TypeComplexity::new(type_complexity_threshold));\n-    store.register_late_pass(|| box matches::Matches);\n+    store.register_late_pass(|| box matches::Matches::default());\n     store.register_late_pass(|| box minmax::MinMaxPass);\n     store.register_late_pass(|| box open_options::OpenOptions);\n     store.register_late_pass(|| box zero_div_zero::ZeroDiv);\n@@ -942,7 +941,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box question_mark::QuestionMark);\n     store.register_late_pass(|| box suspicious_trait_impl::SuspiciousImpl);\n     store.register_late_pass(|| box map_unit_fn::MapUnit);\n-    store.register_late_pass(|| box infallible_destructuring_match::InfallibleDestructingMatch);\n     store.register_late_pass(|| box inherent_impl::MultipleInherentImpl::default());\n     store.register_late_pass(|| box neg_cmp_op_on_partial_ord::NoNegCompOpForPartialOrd);\n     store.register_late_pass(|| box unwrap::Unwrap);\n@@ -1167,7 +1165,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&identity_op::IDENTITY_OP),\n         LintId::of(&if_let_some_result::IF_LET_SOME_RESULT),\n         LintId::of(&indexing_slicing::OUT_OF_BOUNDS_INDEXING),\n-        LintId::of(&infallible_destructuring_match::INFALLIBLE_DESTRUCTURING_MATCH),\n         LintId::of(&infinite_iter::INFINITE_ITER),\n         LintId::of(&inherent_to_string::INHERENT_TO_STRING),\n         LintId::of(&inherent_to_string::INHERENT_TO_STRING_SHADOW_DISPLAY),\n@@ -1202,12 +1199,13 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&map_clone::MAP_CLONE),\n         LintId::of(&map_unit_fn::OPTION_MAP_UNIT_FN),\n         LintId::of(&map_unit_fn::RESULT_MAP_UNIT_FN),\n+        LintId::of(&matches::INFALLIBLE_DESTRUCTURING_MATCH),\n         LintId::of(&matches::MATCH_AS_REF),\n         LintId::of(&matches::MATCH_BOOL),\n         LintId::of(&matches::MATCH_OVERLAPPING_ARM),\n         LintId::of(&matches::MATCH_REF_PATS),\n-        LintId::of(&matches::MATCH_WILD_ERR_ARM),\n         LintId::of(&matches::MATCH_SINGLE_BINDING),\n+        LintId::of(&matches::MATCH_WILD_ERR_ARM),\n         LintId::of(&matches::SINGLE_MATCH),\n         LintId::of(&matches::WILDCARD_IN_OR_PATTERNS),\n         LintId::of(&mem_discriminant::MEM_DISCRIMINANT_NON_ENUM),\n@@ -1384,7 +1382,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&functions::DOUBLE_MUST_USE),\n         LintId::of(&functions::MUST_USE_UNIT),\n         LintId::of(&if_let_some_result::IF_LET_SOME_RESULT),\n-        LintId::of(&infallible_destructuring_match::INFALLIBLE_DESTRUCTURING_MATCH),\n         LintId::of(&inherent_to_string::INHERENT_TO_STRING),\n         LintId::of(&len_zero::LEN_WITHOUT_IS_EMPTY),\n         LintId::of(&len_zero::LEN_ZERO),\n@@ -1397,6 +1394,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&loops::WHILE_LET_ON_ITERATOR),\n         LintId::of(&main_recursion::MAIN_RECURSION),\n         LintId::of(&map_clone::MAP_CLONE),\n+        LintId::of(&matches::INFALLIBLE_DESTRUCTURING_MATCH),\n         LintId::of(&matches::MATCH_BOOL),\n         LintId::of(&matches::MATCH_OVERLAPPING_ARM),\n         LintId::of(&matches::MATCH_REF_PATS),"}, {"sha": "e4335abcea2a4518815d94deef7ef518f4a37634", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 110, "deletions": 20, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/6afd7ea147cf34eb2ce505d513664b5f4fadfb58/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6afd7ea147cf34eb2ce505d513664b5f4fadfb58/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=6afd7ea147cf34eb2ce505d513664b5f4fadfb58", "patch": "@@ -5,7 +5,7 @@ use crate::utils::usage::is_unused;\n use crate::utils::{\n     span_lint_and_help, span_lint_and_note, \n     expr_block, in_macro, is_allowed, is_expn_of, is_wild, match_qpath, match_type, multispan_sugg, remove_blocks,\n-    snippet, snippet_with_applicability, span_lint_and_sugg, span_lint_and_then,\n+    snippet, snippet_block, snippet_with_applicability,  span_lint_and_sugg, span_lint_and_then,\n };\n use if_chain::if_chain;\n use rustc::lint::in_external_macro;\n@@ -14,7 +14,7 @@ use rustc_errors::Applicability;\n use rustc_hir::def::CtorKind;\n use rustc_hir::*;\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Span;\n use std::cmp::Ordering;\n use std::collections::Bound;\n@@ -245,12 +245,47 @@ declare_clippy_lint! {\n     \"a wildcard pattern used with others patterns in same match arm\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Checks for matches being used to destructure a single-variant enum\n+    /// or tuple struct where a `let` will suffice.\n+    ///\n+    /// **Why is this bad?** Just readability \u2013 `let` doesn't nest, whereas a `match` does.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// enum Wrapper {\n+    ///     Data(i32),\n+    /// }\n+    ///\n+    /// let wrapper = Wrapper::Data(42);\n+    ///\n+    /// let data = match wrapper {\n+    ///     Wrapper::Data(i) => i,\n+    /// };\n+    /// ```\n+    ///\n+    /// The correct use would be:\n+    /// ```rust\n+    /// enum Wrapper {\n+    ///     Data(i32),\n+    /// }\n+    ///\n+    /// let wrapper = Wrapper::Data(42);\n+    /// let Wrapper::Data(data) = wrapper;\n+    /// ```\n+    pub INFALLIBLE_DESTRUCTURING_MATCH,\n+    style,\n+    \"a `match` statement with a single infallible arm instead of a `let`\"\n+}\n+\n declare_clippy_lint! {\n     /// **What it does:** Checks for useless match that binds to only one value.\n     ///\n     /// **Why is this bad?** Readability and needless complexity.\n     ///\n-    /// **Known problems:** This situation frequently happen in macros, so can't lint there.\n+    /// **Known problems:** None.\n     ///\n     /// **Example:**\n     /// ```rust\n@@ -272,7 +307,12 @@ declare_clippy_lint! {\n     \"a match with a single binding instead of using `let` statement\"\n }\n \n-declare_lint_pass!(Matches => [\n+#[derive(Default)]\n+pub struct Matches {\n+    infallible_destructuring_match_linted: bool,\n+}\n+\n+impl_lint_pass!(Matches => [\n     SINGLE_MATCH,\n     MATCH_REF_PATS,\n     MATCH_BOOL,\n@@ -283,6 +323,7 @@ declare_lint_pass!(Matches => [\n     WILDCARD_ENUM_MATCH_ARM,\n     WILDCARD_IN_OR_PATTERNS,\n     MATCH_SINGLE_BINDING,\n+    INFALLIBLE_DESTRUCTURING_MATCH\n ]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Matches {\n@@ -298,12 +339,51 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Matches {\n             check_wild_enum_match(cx, ex, arms);\n             check_match_as_ref(cx, ex, arms, expr);\n             check_wild_in_or_pats(cx, arms);\n-            check_match_single_binding(cx, ex, arms, expr);\n+\n+            if self.infallible_destructuring_match_linted {\n+                self.infallible_destructuring_match_linted = false;\n+            } else {\n+                check_match_single_binding(cx, ex, arms, expr);\n+            }\n         }\n         if let ExprKind::Match(ref ex, ref arms, _) = expr.kind {\n             check_match_ref_pats(cx, ex, arms, expr);\n         }\n     }\n+\n+    fn check_local(&mut self, cx: &LateContext<'a, 'tcx>, local: &'tcx Local<'_>) {\n+        if_chain! {\n+            if let Some(ref expr) = local.init;\n+            if let ExprKind::Match(ref target, ref arms, MatchSource::Normal) = expr.kind;\n+            if arms.len() == 1 && arms[0].guard.is_none();\n+            if let PatKind::TupleStruct(\n+                QPath::Resolved(None, ref variant_name), ref args, _) = arms[0].pat.kind;\n+            if args.len() == 1;\n+            if let Some(arg) = get_arg_name(&args[0]);\n+            let body = remove_blocks(&arms[0].body);\n+            if match_var(body, arg);\n+\n+            then {\n+                let mut applicability = Applicability::MachineApplicable;\n+                self.infallible_destructuring_match_linted = true;\n+                span_lint_and_sugg(\n+                    cx,\n+                    INFALLIBLE_DESTRUCTURING_MATCH,\n+                    local.span,\n+                    \"you seem to be trying to use `match` to destructure a single infallible pattern. \\\n+                    Consider using `let`\",\n+                    \"try this\",\n+                    format!(\n+                        \"let {}({}) = {};\",\n+                        snippet_with_applicability(cx, variant_name.span, \"..\", &mut applicability),\n+                        snippet_with_applicability(cx, local.pat.span, \"..\", &mut applicability),\n+                        snippet_with_applicability(cx, target.span, \"..\", &mut applicability),\n+                    ),\n+                    applicability,\n+                );\n+            }\n+        }\n+    }\n }\n \n #[rustfmt::skip]\n@@ -746,21 +826,31 @@ fn check_match_single_binding(cx: &LateContext<'_, '_>, ex: &Expr<'_>, arms: &[A\n         return;\n     }\n     if arms.len() == 1 {\n-        let bind_names = arms[0].pat.span;\n-        let matched_vars = ex.span;\n-        span_lint_and_sugg(\n-            cx,\n-            MATCH_SINGLE_BINDING,\n-            expr.span,\n-            \"this match could be written as a `let` statement\",\n-            \"try this\",\n-            format!(\n-                \"let {} = {};\",\n-                snippet(cx, bind_names, \"..\"),\n-                snippet(cx, matched_vars, \"..\")\n-            ),\n-            Applicability::HasPlaceholders,\n-        );\n+        if is_refutable(cx, arms[0].pat) {\n+            return;\n+        }\n+        match arms[0].pat.kind {\n+            PatKind::Binding(..) | PatKind::Tuple(_, _) => {\n+                let bind_names = arms[0].pat.span;\n+                let matched_vars = ex.span;\n+                let match_body = remove_blocks(&arms[0].body);\n+                span_lint_and_sugg(\n+                    cx,\n+                    MATCH_SINGLE_BINDING,\n+                    expr.span,\n+                    \"this match could be written as a `let` statement\",\n+                    \"consider using `let` statement\",\n+                    format!(\n+                        \"let {} = {};\\n{}\",\n+                        snippet(cx, bind_names, \"..\"),\n+                        snippet(cx, matched_vars, \"..\"),\n+                        snippet_block(cx, match_body.span, \"..\")\n+                    ),\n+                    Applicability::MachineApplicable,\n+                );\n+            },\n+            _ => (),\n+        }\n     }\n }\n "}, {"sha": "b28a0917a91e1f8b61fefbb057556633e2cf84b5", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6afd7ea147cf34eb2ce505d513664b5f4fadfb58/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6afd7ea147cf34eb2ce505d513664b5f4fadfb58/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=6afd7ea147cf34eb2ce505d513664b5f4fadfb58", "patch": "@@ -775,7 +775,7 @@ pub const ALL_LINTS: [Lint; 351] = [\n         group: \"style\",\n         desc: \"a `match` statement with a single infallible arm instead of a `let`\",\n         deprecation: None,\n-        module: \"infallible_destructuring_match\",\n+        module: \"matches\",\n     },\n     Lint {\n         name: \"infinite_iter\",\n@@ -1092,6 +1092,13 @@ pub const ALL_LINTS: [Lint; 351] = [\n         deprecation: None,\n         module: \"copies\",\n     },\n+    Lint {\n+        name: \"match_single_binding\",\n+        group: \"complexity\",\n+        desc: \"a match with a single binding instead of using `let` statement\",\n+        deprecation: None,\n+        module: \"matches\",\n+    },\n     Lint {\n         name: \"match_wild_err_arm\",\n         group: \"style\","}, {"sha": "7d4b71d09dc5dbdab58d8357db5f8e2890f8f814", "filename": "tests/ui/escape_analysis.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6afd7ea147cf34eb2ce505d513664b5f4fadfb58/tests%2Fui%2Fescape_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6afd7ea147cf34eb2ce505d513664b5f4fadfb58/tests%2Fui%2Fescape_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fescape_analysis.rs?ref=6afd7ea147cf34eb2ce505d513664b5f4fadfb58", "patch": "@@ -3,7 +3,7 @@\n     clippy::borrowed_box,\n     clippy::needless_pass_by_value,\n     clippy::unused_unit,\n-    clippy::redundant_clone\n+    clippy::redundant_clone,\n )]\n #![warn(clippy::boxed_local)]\n "}, {"sha": "c86a769a3da4b170e2dbbc93118ed5a49dd0b216", "filename": "tests/ui/escape_analysis.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6afd7ea147cf34eb2ce505d513664b5f4fadfb58/tests%2Fui%2Fescape_analysis.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6afd7ea147cf34eb2ce505d513664b5f4fadfb58/tests%2Fui%2Fescape_analysis.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fescape_analysis.stderr?ref=6afd7ea147cf34eb2ce505d513664b5f4fadfb58", "patch": "@@ -1,13 +1,13 @@\n error: local variable doesn't need to be boxed here\n-  --> $DIR/escape_analysis.rs:39:13\n+  --> $DIR/escape_analysis.rs:40:13\n    |\n LL | fn warn_arg(x: Box<A>) {\n    |             ^\n    |\n    = note: `-D clippy::boxed-local` implied by `-D warnings`\n \n error: local variable doesn't need to be boxed here\n-  --> $DIR/escape_analysis.rs:130:12\n+  --> $DIR/escape_analysis.rs:131:12\n    |\n LL | pub fn new(_needs_name: Box<PeekableSeekable<&()>>) -> () {}\n    |            ^^^^^^^^^^^"}, {"sha": "41faa1e1c21fcce38161dbe03996963707ffd59b", "filename": "tests/ui/match_single_binding.fixed", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6afd7ea147cf34eb2ce505d513664b5f4fadfb58/tests%2Fui%2Fmatch_single_binding.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/6afd7ea147cf34eb2ce505d513664b5f4fadfb58/tests%2Fui%2Fmatch_single_binding.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_single_binding.fixed?ref=6afd7ea147cf34eb2ce505d513664b5f4fadfb58", "patch": "@@ -0,0 +1,26 @@\n+// run-rustfix\n+\n+#![warn(clippy::match_single_binding)]\n+#[allow(clippy::many_single_char_names)]\n+\n+fn main() {\n+    let a = 1;\n+    let b = 2;\n+    let c = 3;\n+    // Lint\n+    let (x, y, z) = (a, b, c);\n+{\n+    println!(\"{} {} {}\", x, y, z);\n+}\n+    // Ok\n+    match a {\n+        2 => println!(\"2\"),\n+        _ => println!(\"Not 2\"),\n+    }\n+    // Ok\n+    let d = Some(5);\n+    match d {\n+        Some(d) => println!(\"{}\", d),\n+        _ => println!(\"None\"),\n+    }\n+}"}, {"sha": "06b924d04719cde15fb6ef5d39eb03713444e963", "filename": "tests/ui/match_single_binding.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6afd7ea147cf34eb2ce505d513664b5f4fadfb58/tests%2Fui%2Fmatch_single_binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6afd7ea147cf34eb2ce505d513664b5f4fadfb58/tests%2Fui%2Fmatch_single_binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_single_binding.rs?ref=6afd7ea147cf34eb2ce505d513664b5f4fadfb58", "patch": "@@ -1,3 +1,5 @@\n+// run-rustfix\n+\n #![warn(clippy::match_single_binding)]\n #[allow(clippy::many_single_char_names)]\n \n@@ -19,7 +21,7 @@ fn main() {\n     // Ok\n     let d = Some(5);\n     match d {\n-        Some(d) => println!(\"5\"),\n+        Some(d) => println!(\"{}\", d),\n         _ => println!(\"None\"),\n     }\n }"}, {"sha": "64216a72ef70567943f315c3655cff17974932f9", "filename": "tests/ui/match_single_binding.stderr", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6afd7ea147cf34eb2ce505d513664b5f4fadfb58/tests%2Fui%2Fmatch_single_binding.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6afd7ea147cf34eb2ce505d513664b5f4fadfb58/tests%2Fui%2Fmatch_single_binding.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_single_binding.stderr?ref=6afd7ea147cf34eb2ce505d513664b5f4fadfb58", "patch": "@@ -1,14 +1,21 @@\n error: this match could be written as a `let` statement\n-  --> $DIR/match_single_binding.rs:9:5\n+  --> $DIR/match_single_binding.rs:11:5\n    |\n LL | /     match (a, b, c) {\n LL | |         (x, y, z) => {\n LL | |             println!(\"{} {} {}\", x, y, z);\n LL | |         },\n LL | |     }\n-   | |_____^ help: try this: `let (x, y, z) = (a, b, c);`\n+   | |_____^\n    |\n    = note: `-D clippy::match-single-binding` implied by `-D warnings`\n+help: consider using `let` statement\n+   |\n+LL |     let (x, y, z) = (a, b, c);\n+LL | {\n+LL |     println!(\"{} {} {}\", x, y, z);\n+LL | }\n+   |\n \n error: aborting due to previous error\n "}]}