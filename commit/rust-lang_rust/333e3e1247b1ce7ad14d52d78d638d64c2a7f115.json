{"sha": "333e3e1247b1ce7ad14d52d78d638d64c2a7f115", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzM2UzZTEyNDdiMWNlN2FkMTRkNTJkNzhkNjM4ZDY0YzJhN2YxMTU=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2018-02-17T17:54:54Z"}, "committer": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2018-02-17T17:59:54Z"}, "message": "Get rid of macro", "tree": {"sha": "84997686c087c614b66f5702153454ea97f83a8b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84997686c087c614b66f5702153454ea97f83a8b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/333e3e1247b1ce7ad14d52d78d638d64c2a7f115", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/333e3e1247b1ce7ad14d52d78d638d64c2a7f115", "html_url": "https://github.com/rust-lang/rust/commit/333e3e1247b1ce7ad14d52d78d638d64c2a7f115", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/333e3e1247b1ce7ad14d52d78d638d64c2a7f115/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a915916f24a774753d948f061dc385abd978c222", "url": "https://api.github.com/repos/rust-lang/rust/commits/a915916f24a774753d948f061dc385abd978c222", "html_url": "https://github.com/rust-lang/rust/commit/a915916f24a774753d948f061dc385abd978c222"}], "stats": {"total": 117, "additions": 64, "deletions": 53}, "files": [{"sha": "769036f9162bf72785560d9bea56a92c38a4cb0f", "filename": "rustfmt-core/src/reorder.rs", "status": "modified", "additions": 61, "deletions": 50, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/333e3e1247b1ce7ad14d52d78d638d64c2a7f115/rustfmt-core%2Fsrc%2Freorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/333e3e1247b1ce7ad14d52d78d638d64c2a7f115/rustfmt-core%2Fsrc%2Freorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-core%2Fsrc%2Freorder.rs?ref=333e3e1247b1ce7ad14d52d78d638d64c2a7f115", "patch": "@@ -14,7 +14,7 @@\n //! order. Trait items are reordered in pre-determined order (associated types\n //! and constatns comes before methods).\n \n-use config::lists::*;\n+use config::{Config, lists::*};\n use syntax::{ast, attr, codemap::Span};\n \n use codemap::LineRangeUtils;\n@@ -26,8 +26,7 @@ use rewrite::{Rewrite, RewriteContext};\n use shape::Shape;\n use spanned::Spanned;\n use utils::mk_sp;\n-use visitor::{filter_inline_attrs, is_extern_crate, is_mod_decl, is_use_item,\n-              rewrite_extern_crate, FmtVisitor};\n+use visitor::{filter_inline_attrs, rewrite_extern_crate, FmtVisitor};\n \n use std::cmp::Ordering;\n \n@@ -212,43 +211,70 @@ fn rewrite_reorderable_items(\n     write_list(&item_vec, &fmt)\n }\n \n-fn contains_macro_use_attr(attrs: &[ast::Attribute], span: Span) -> bool {\n-    attr::contains_name(&filter_inline_attrs(attrs, span), \"macro_use\")\n+fn contains_macro_use_attr(item: &ast::Item) -> bool {\n+    attr::contains_name(&filter_inline_attrs(&item.attrs, item.span()), \"macro_use\")\n }\n \n-/// Returns true for `mod foo;` without any inline attributes.\n-/// We cannot reorder modules with attributes because doing so can break the code.\n-/// e.g. `#[macro_use]`.\n-fn is_mod_decl_without_attr(item: &ast::Item) -> bool {\n-    is_mod_decl(item) && !contains_macro_use_attr(&item.attrs, item.span())\n+/// A simplified version of `ast::ItemKind`.\n+#[derive(Debug, PartialEq, Eq, Copy, Clone)]\n+enum ReorderableItemKind {\n+    ExternCrate,\n+    Mod,\n+    Use,\n+    /// An item that cannot be reordered. Either has an unreorderable item kind\n+    /// or an `macro_use` attribute.\n+    Other,\n }\n \n-fn is_use_item_without_attr(item: &ast::Item) -> bool {\n-    is_use_item(item) && !contains_macro_use_attr(&item.attrs, item.span())\n-}\n+impl ReorderableItemKind {\n+    pub fn from(item: &ast::Item) -> Self {\n+        match item.node {\n+            _ if contains_macro_use_attr(item) => ReorderableItemKind::Other,\n+            ast::ItemKind::ExternCrate(..) => ReorderableItemKind::ExternCrate,\n+            ast::ItemKind::Mod(..) => ReorderableItemKind::Mod,\n+            ast::ItemKind::Use(..) => ReorderableItemKind::Use,\n+            _ => ReorderableItemKind::Other,\n+        }\n+    }\n+\n+    pub fn is_same_item_kind(&self, item: &ast::Item) -> bool {\n+        ReorderableItemKind::from(item) == *self\n+    }\n \n-fn is_extern_crate_without_attr(item: &ast::Item) -> bool {\n-    is_extern_crate(item) && !contains_macro_use_attr(&item.attrs, item.span())\n+    pub fn is_reorderable(&self, config: &Config) -> bool {\n+        match *self {\n+            ReorderableItemKind::ExternCrate => config.reorder_extern_crates(),\n+            ReorderableItemKind::Mod => config.reorder_modules(),\n+            ReorderableItemKind::Use => config.reorder_imports(),\n+            ReorderableItemKind::Other => false,\n+        }\n+    }\n+\n+    pub fn in_group(&self, config: &Config) -> bool {\n+        match *self {\n+            ReorderableItemKind::ExternCrate => config.reorder_extern_crates_in_group(),\n+            ReorderableItemKind::Mod => config.reorder_modules(),\n+            ReorderableItemKind::Use => config.reorder_imports_in_group(),\n+            ReorderableItemKind::Other => false,\n+        }\n+    }\n }\n \n impl<'b, 'a: 'b> FmtVisitor<'a> {\n     /// Format items with the same item kind and reorder them. If `in_group` is\n     /// `true`, then the items separated by an empty line will not be reordered\n     /// together.\n-    fn walk_items_with_reordering<F>(\n+    fn walk_reorderable_items(\n         &mut self,\n         items: &[&ast::Item],\n-        is_item: &F,\n+        item_kind: ReorderableItemKind,\n         in_group: bool,\n-    ) -> usize\n-    where\n-        F: Fn(&ast::Item) -> bool,\n-    {\n+    ) -> usize {\n         let mut last = self.codemap.lookup_line_range(items[0].span());\n         let item_length = items\n             .iter()\n             .take_while(|ppi| {\n-                is_item(&***ppi) && (!in_group || {\n+                item_kind.is_same_item_kind(&***ppi) && (!in_group || {\n                     let current = self.codemap.lookup_line_range(ppi.span());\n                     let in_same_group = current.lo < last.hi + 2;\n                     last = current;\n@@ -280,38 +306,23 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n     /// Visit and format the given items. Items are reordered If they are\n     /// consecutive and reorderable.\n     pub fn visit_items_with_reordering(&mut self, mut items: &[&ast::Item]) {\n-        macro try_reorder_items_with($reorder: ident, $in_group: ident, $pred: ident) {\n-            if self.config.$reorder() && $pred(&*items[0]) {\n-                let used_items_len =\n-                    self.walk_items_with_reordering(items, &$pred, self.config.$in_group());\n-                let (_, rest) = items.split_at(used_items_len);\n-                items = rest;\n-                continue;\n-            }\n-        }\n-\n         while !items.is_empty() {\n             // If the next item is a `use`, `extern crate` or `mod`, then extract it and any\n             // subsequent items that have the same item kind to be reordered within\n-            // `walk_items_with_reordering`. Otherwise, just format the next item for output.\n-            {\n-                try_reorder_items_with!(\n-                    reorder_imports,\n-                    reorder_imports_in_group,\n-                    is_use_item_without_attr\n-                );\n-                try_reorder_items_with!(\n-                    reorder_extern_crates,\n-                    reorder_extern_crates_in_group,\n-                    is_extern_crate_without_attr\n-                );\n-                try_reorder_items_with!(reorder_modules, reorder_modules, is_mod_decl_without_attr);\n+            // `walk_reorderable_items`. Otherwise, just format the next item for output.\n+            let item_kind = ReorderableItemKind::from(items[0]);\n+            if item_kind.is_reorderable(self.config) {\n+                let visited_items_num =\n+                    self.walk_reorderable_items(items, item_kind, item_kind.in_group(self.config));\n+                let (_, rest) = items.split_at(visited_items_num);\n+                items = rest;\n+            } else {\n+                // Reaching here means items were not reordered. There must be at least\n+                // one item left in `items`, so calling `unwrap()` here is safe.\n+                let (item, rest) = items.split_first().unwrap();\n+                self.visit_item(item);\n+                items = rest;\n             }\n-            // Reaching here means items were not reordered. There must be at least\n-            // one item left in `items`, so calling `unwrap()` here is safe.\n-            let (item, rest) = items.split_first().unwrap();\n-            self.visit_item(item);\n-            items = rest;\n         }\n     }\n }"}, {"sha": "d1b9859245f10f58010cef25f2a2c0fe62aad31b", "filename": "rustfmt-core/src/visitor.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/333e3e1247b1ce7ad14d52d78d638d64c2a7f115/rustfmt-core%2Fsrc%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/333e3e1247b1ce7ad14d52d78d638d64c2a7f115/rustfmt-core%2Fsrc%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-core%2Fsrc%2Fvisitor.rs?ref=333e3e1247b1ce7ad14d52d78d638d64c2a7f115", "patch": "@@ -42,21 +42,21 @@ pub fn filter_inline_attrs(attrs: &[ast::Attribute], outer_span: Span) -> Vec<as\n }\n \n /// Returns true for `mod foo;`, false for `mod foo { .. }`.\n-pub fn is_mod_decl(item: &ast::Item) -> bool {\n+fn is_mod_decl(item: &ast::Item) -> bool {\n     match item.node {\n         ast::ItemKind::Mod(ref m) => m.inner.hi() != item.span.hi(),\n         _ => false,\n     }\n }\n \n-pub fn is_use_item(item: &ast::Item) -> bool {\n+fn is_use_item(item: &ast::Item) -> bool {\n     match item.node {\n         ast::ItemKind::Use(_) => true,\n         _ => false,\n     }\n }\n \n-pub fn is_extern_crate(item: &ast::Item) -> bool {\n+fn is_extern_crate(item: &ast::Item) -> bool {\n     match item.node {\n         ast::ItemKind::ExternCrate(..) => true,\n         _ => false,"}]}