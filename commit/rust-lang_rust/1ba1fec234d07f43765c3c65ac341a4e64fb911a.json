{"sha": "1ba1fec234d07f43765c3c65ac341a4e64fb911a", "node_id": "C_kwDOAAsO6NoAKDFiYTFmZWMyMzRkMDdmNDM3NjVjM2M2NWFjMzQxYTRlNjRmYjkxMWE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-14T21:50:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-14T21:50:14Z"}, "message": "Auto merge of #96544 - m-ysk:feature/issue-96358, r=cjgillot\n\nStop keeping metadata in memory before writing it to disk\n\nFixes #96358\n\nI created this PR according with the instruction given in the issue except for the following points:\n\n- While the issue says \"Write metadata into the temporary file in `encode_and_write_metadata` even if `!need_metadata_file`\", I could not do that. That is because though I tried to do that and run `x.py test`, I got a lot of test failures as follows.\n\n<details>\n<summary>List of failed tests</summary>\n<pre>\n<code>\nfailures:\n    [ui] src/test/ui/json-multiple.rs\n    [ui] src/test/ui/json-options.rs\n    [ui] src/test/ui/rmeta/rmeta-rpass.rs\n    [ui] src/test/ui/save-analysis/emit-notifications.rs\n    [ui] src/test/ui/svh/changing-crates.rs\n    [ui] src/test/ui/svh/svh-change-lit.rs\n    [ui] src/test/ui/svh/svh-change-significant-cfg.rs\n    [ui] src/test/ui/svh/svh-change-trait-bound.rs\n    [ui] src/test/ui/svh/svh-change-type-arg.rs\n    [ui] src/test/ui/svh/svh-change-type-ret.rs\n    [ui] src/test/ui/svh/svh-change-type-static.rs\n    [ui] src/test/ui/svh/svh-use-trait.rs\n\ntest result: FAILED. 12915 passed; 12 failed; 100 ignored; 0 measured; 0 filtered out; finished in 71.41s\n\nSome tests failed in compiletest suite=ui mode=ui host=x86_64-unknown-linux-gnu target=x86_64-unknown-linux-gnu\nBuild completed unsuccessfully in 0:01:58\n</code>\n</pre>\n</details>\n\n- I could not resolve the extra tasks about `create_rmeta_file` and `create_compressed_metadata_file` for my lack of ability.", "tree": {"sha": "febf27a6b848a9b2b78f7865799cada36b303f26", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/febf27a6b848a9b2b78f7865799cada36b303f26"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ba1fec234d07f43765c3c65ac341a4e64fb911a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ba1fec234d07f43765c3c65ac341a4e64fb911a", "html_url": "https://github.com/rust-lang/rust/commit/1ba1fec234d07f43765c3c65ac341a4e64fb911a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ba1fec234d07f43765c3c65ac341a4e64fb911a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2f428d2f3340a0e7d995f4726223db91b93704c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2f428d2f3340a0e7d995f4726223db91b93704c", "html_url": "https://github.com/rust-lang/rust/commit/c2f428d2f3340a0e7d995f4726223db91b93704c"}, {"sha": "1147d50050788851438e80c57279b99b9a457924", "url": "https://api.github.com/repos/rust-lang/rust/commits/1147d50050788851438e80c57279b99b9a457924", "html_url": "https://github.com/rust-lang/rust/commit/1147d50050788851438e80c57279b99b9a457924"}], "stats": {"total": 447, "additions": 300, "deletions": 147}, "files": [{"sha": "0b44201d56f0b67a23d7bd3226e8ae669bada70d", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ba1fec234d07f43765c3c65ac341a4e64fb911a/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/1ba1fec234d07f43765c3c65ac341a4e64fb911a/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=1ba1fec234d07f43765c3c65ac341a4e64fb911a", "patch": "@@ -3969,7 +3969,6 @@ dependencies = [\n  \"rustc_ty_utils\",\n  \"rustc_typeck\",\n  \"smallvec\",\n- \"tempfile\",\n  \"tracing\",\n  \"winapi\",\n ]\n@@ -4080,6 +4079,7 @@ dependencies = [\n  \"rustc_type_ir\",\n  \"smallvec\",\n  \"snap\",\n+ \"tempfile\",\n  \"tracing\",\n ]\n "}, {"sha": "878a670cba3efeded5fbe32795bfbc74f6359b99", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 2, "deletions": 20, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1ba1fec234d07f43765c3c65ac341a4e64fb911a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ba1fec234d07f43765c3c65ac341a4e64fb911a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=1ba1fec234d07f43765c3c65ac341a4e64fb911a", "patch": "@@ -6,6 +6,7 @@ use rustc_data_structures::temp_dir::MaybeTempDir;\n use rustc_errors::{ErrorGuaranteed, Handler};\n use rustc_fs_util::fix_windows_verbatim_for_gcc;\n use rustc_hir::def_id::CrateNum;\n+use rustc_metadata::fs::{emit_metadata, METADATA_FILENAME};\n use rustc_middle::middle::dependency_format::Linkage;\n use rustc_middle::middle::exported_symbols::SymbolExportKind;\n use rustc_session::config::{self, CFGuard, CrateType, DebugInfo, LdImpl, Strip};\n@@ -28,10 +29,7 @@ use super::command::Command;\n use super::linker::{self, Linker};\n use super::metadata::{create_rmeta_file, MetadataPosition};\n use super::rpath::{self, RPathConfig};\n-use crate::{\n-    looks_like_rust_object_file, CodegenResults, CompiledModule, CrateInfo, NativeLib,\n-    METADATA_FILENAME,\n-};\n+use crate::{looks_like_rust_object_file, CodegenResults, CompiledModule, CrateInfo, NativeLib};\n \n use cc::windows_registry;\n use regex::Regex;\n@@ -241,22 +239,6 @@ pub fn each_linked_rlib(\n     Ok(())\n }\n \n-/// We use a temp directory here to avoid races between concurrent rustc processes,\n-/// such as builds in the same directory using the same filename for metadata while\n-/// building an `.rlib` (stomping over one another), or writing an `.rmeta` into a\n-/// directory being searched for `extern crate` (observing an incomplete file).\n-/// The returned path is the temporary file containing the complete metadata.\n-pub fn emit_metadata(sess: &Session, metadata: &[u8], tmpdir: &MaybeTempDir) -> PathBuf {\n-    let out_filename = tmpdir.as_ref().join(METADATA_FILENAME);\n-    let result = fs::write(&out_filename, metadata);\n-\n-    if let Err(e) = result {\n-        sess.fatal(&format!(\"failed to write {}: {}\", out_filename.display(), e));\n-    }\n-\n-    out_filename\n-}\n-\n /// Create an 'rlib'.\n ///\n /// An rlib in its current incarnation is essentially a renamed .a file. The rlib primarily contains"}, {"sha": "0302c28815ab81a701da7c588b6669c96ddbed25", "filename": "compiler/rustc_codegen_ssa/src/back/metadata.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1ba1fec234d07f43765c3c65ac341a4e64fb911a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ba1fec234d07f43765c3c65ac341a4e64fb911a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs?ref=1ba1fec234d07f43765c3c65ac341a4e64fb911a", "patch": "@@ -16,14 +16,13 @@ use rustc_data_structures::memmap::Mmap;\n use rustc_data_structures::owning_ref::OwningRef;\n use rustc_data_structures::rustc_erase_owner;\n use rustc_data_structures::sync::MetadataRef;\n+use rustc_metadata::fs::METADATA_FILENAME;\n use rustc_metadata::EncodedMetadata;\n use rustc_session::cstore::MetadataLoader;\n use rustc_session::Session;\n use rustc_target::abi::Endian;\n use rustc_target::spec::{RelocModel, Target};\n \n-use crate::METADATA_FILENAME;\n-\n /// The default metadata loader. This is used by cg_llvm and cg_clif.\n ///\n /// # Metadata location"}, {"sha": "1802eedf193aa321a7c22b9690becc90349d3b2d", "filename": "compiler/rustc_codegen_ssa/src/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1ba1fec234d07f43765c3c65ac341a4e64fb911a/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ba1fec234d07f43765c3c65ac341a4e64fb911a/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs?ref=1ba1fec234d07f43765c3c65ac341a4e64fb911a", "patch": "@@ -64,9 +64,6 @@ pub struct ModuleCodegen<M> {\n     pub kind: ModuleKind,\n }\n \n-// FIXME(eddyb) maybe include the crate name in this?\n-pub const METADATA_FILENAME: &str = \"lib.rmeta\";\n-\n impl<M> ModuleCodegen<M> {\n     pub fn into_compiled_module(\n         self,"}, {"sha": "917416df6b86703602d642c901aed666763a98d3", "filename": "compiler/rustc_data_structures/src/memmap.rs", "status": "modified", "additions": 62, "deletions": 1, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/1ba1fec234d07f43765c3c65ac341a4e64fb911a/compiler%2Frustc_data_structures%2Fsrc%2Fmemmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ba1fec234d07f43765c3c65ac341a4e64fb911a/compiler%2Frustc_data_structures%2Fsrc%2Fmemmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fmemmap.rs?ref=1ba1fec234d07f43765c3c65ac341a4e64fb911a", "patch": "@@ -1,6 +1,6 @@\n use std::fs::File;\n use std::io;\n-use std::ops::Deref;\n+use std::ops::{Deref, DerefMut};\n \n use crate::owning_ref::StableAddress;\n \n@@ -45,3 +45,64 @@ impl Deref for Mmap {\n // export any function that can cause the `Vec` to be re-allocated. As such the address of the\n // bytes inside this `Vec` is stable.\n unsafe impl StableAddress for Mmap {}\n+\n+#[cfg(not(target_arch = \"wasm32\"))]\n+pub struct MmapMut(memmap2::MmapMut);\n+\n+#[cfg(target_arch = \"wasm32\")]\n+pub struct MmapMut(Vec<u8>);\n+\n+#[cfg(not(target_arch = \"wasm32\"))]\n+impl MmapMut {\n+    #[inline]\n+    pub fn map_anon(len: usize) -> io::Result<Self> {\n+        let mmap = memmap2::MmapMut::map_anon(len)?;\n+        Ok(MmapMut(mmap))\n+    }\n+\n+    #[inline]\n+    pub fn flush(&mut self) -> io::Result<()> {\n+        self.0.flush()\n+    }\n+\n+    #[inline]\n+    pub fn make_read_only(self) -> std::io::Result<Mmap> {\n+        let mmap = self.0.make_read_only()?;\n+        Ok(Mmap(mmap))\n+    }\n+}\n+\n+#[cfg(target_arch = \"wasm32\")]\n+impl MmapMut {\n+    #[inline]\n+    pub fn map_anon(len: usize) -> io::Result<Self> {\n+        let data = Vec::with_capacity(len);\n+        Ok(MmapMut(data))\n+    }\n+\n+    #[inline]\n+    pub fn flush(&mut self) -> io::Result<()> {\n+        Ok(())\n+    }\n+\n+    #[inline]\n+    pub fn make_read_only(self) -> std::io::Result<Mmap> {\n+        Ok(Mmap(self.0))\n+    }\n+}\n+\n+impl Deref for MmapMut {\n+    type Target = [u8];\n+\n+    #[inline]\n+    fn deref(&self) -> &[u8] {\n+        &*self.0\n+    }\n+}\n+\n+impl DerefMut for MmapMut {\n+    #[inline]\n+    fn deref_mut(&mut self) -> &mut [u8] {\n+        &mut *self.0\n+    }\n+}"}, {"sha": "1ecbc876c8d8a121f0e8c149c571ee57107e39d5", "filename": "compiler/rustc_interface/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1ba1fec234d07f43765c3c65ac341a4e64fb911a/compiler%2Frustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1ba1fec234d07f43765c3c65ac341a4e64fb911a/compiler%2Frustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2FCargo.toml?ref=1ba1fec234d07f43765c3c65ac341a4e64fb911a", "patch": "@@ -46,7 +46,6 @@ rustc_query_impl = { path = \"../rustc_query_impl\" }\n rustc_resolve = { path = \"../rustc_resolve\" }\n rustc_trait_selection = { path = \"../rustc_trait_selection\" }\n rustc_ty_utils = { path = \"../rustc_ty_utils\" }\n-tempfile = \"3.2\"\n \n [target.'cfg(unix)'.dependencies]\n libc = \"0.2\""}, {"sha": "334a595a88ae6328451b7debf2abda7274ae8491", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 4, "deletions": 70, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/1ba1fec234d07f43765c3c65ac341a4e64fb911a/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ba1fec234d07f43765c3c65ac341a4e64fb911a/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=1ba1fec234d07f43765c3c65ac341a4e64fb911a", "patch": "@@ -5,18 +5,15 @@ use crate::util;\n use ast::CRATE_NODE_ID;\n use rustc_ast::{self as ast, visit};\n use rustc_borrowck as mir_borrowck;\n-use rustc_codegen_ssa::back::link::emit_metadata;\n use rustc_codegen_ssa::traits::CodegenBackend;\n use rustc_data_structures::parallel;\n use rustc_data_structures::sync::{Lrc, OnceCell, WorkerLocal};\n-use rustc_data_structures::temp_dir::MaybeTempDir;\n use rustc_errors::{Applicability, ErrorGuaranteed, MultiSpan, PResult};\n use rustc_expand::base::{ExtCtxt, LintStoreExpand, ResolverExpand};\n-use rustc_hir::def_id::{StableCrateId, LOCAL_CRATE};\n+use rustc_hir::def_id::StableCrateId;\n use rustc_hir::definitions::Definitions;\n use rustc_lint::{BufferedEarlyLint, EarlyCheckNode, LintStore};\n use rustc_metadata::creader::CStore;\n-use rustc_metadata::{encode_metadata, EncodedMetadata};\n use rustc_middle::arena::Arena;\n use rustc_middle::dep_graph::DepGraph;\n use rustc_middle::ty::query::{ExternProviders, Providers};\n@@ -29,14 +26,13 @@ use rustc_query_impl::{OnDiskCache, Queries as TcxQueries};\n use rustc_resolve::{Resolver, ResolverArenas};\n use rustc_session::config::{CrateType, Input, OutputFilenames, OutputType};\n use rustc_session::cstore::{CrateStoreDyn, MetadataLoader, MetadataLoaderDyn};\n-use rustc_session::output::{filename_for_input, filename_for_metadata};\n+use rustc_session::output::filename_for_input;\n use rustc_session::search_paths::PathKind;\n use rustc_session::{Limit, Session};\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::FileName;\n use rustc_trait_selection::traits;\n use rustc_typeck as typeck;\n-use tempfile::Builder as TempFileBuilder;\n use tracing::{info, warn};\n \n use std::any::Any;\n@@ -993,69 +989,6 @@ fn analysis(tcx: TyCtxt<'_>, (): ()) -> Result<()> {\n     Ok(())\n }\n \n-fn encode_and_write_metadata(\n-    tcx: TyCtxt<'_>,\n-    outputs: &OutputFilenames,\n-) -> (EncodedMetadata, bool) {\n-    #[derive(PartialEq, Eq, PartialOrd, Ord)]\n-    enum MetadataKind {\n-        None,\n-        Uncompressed,\n-        Compressed,\n-    }\n-\n-    let metadata_kind = tcx\n-        .sess\n-        .crate_types()\n-        .iter()\n-        .map(|ty| match *ty {\n-            CrateType::Executable | CrateType::Staticlib | CrateType::Cdylib => MetadataKind::None,\n-\n-            CrateType::Rlib => MetadataKind::Uncompressed,\n-\n-            CrateType::Dylib | CrateType::ProcMacro => MetadataKind::Compressed,\n-        })\n-        .max()\n-        .unwrap_or(MetadataKind::None);\n-\n-    let metadata = match metadata_kind {\n-        MetadataKind::None => EncodedMetadata::new(),\n-        MetadataKind::Uncompressed | MetadataKind::Compressed => encode_metadata(tcx),\n-    };\n-\n-    let _prof_timer = tcx.sess.prof.generic_activity(\"write_crate_metadata\");\n-\n-    let need_metadata_file = tcx.sess.opts.output_types.contains_key(&OutputType::Metadata);\n-    if need_metadata_file {\n-        let crate_name = tcx.crate_name(LOCAL_CRATE);\n-        let out_filename = filename_for_metadata(tcx.sess, crate_name.as_str(), outputs);\n-        // To avoid races with another rustc process scanning the output directory,\n-        // we need to write the file somewhere else and atomically move it to its\n-        // final destination, with an `fs::rename` call. In order for the rename to\n-        // always succeed, the temporary file needs to be on the same filesystem,\n-        // which is why we create it inside the output directory specifically.\n-        let metadata_tmpdir = TempFileBuilder::new()\n-            .prefix(\"rmeta\")\n-            .tempdir_in(out_filename.parent().unwrap())\n-            .unwrap_or_else(|err| tcx.sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)));\n-        let metadata_tmpdir = MaybeTempDir::new(metadata_tmpdir, tcx.sess.opts.cg.save_temps);\n-        let metadata_filename = emit_metadata(tcx.sess, metadata.raw_data(), &metadata_tmpdir);\n-        if let Err(e) = util::non_durable_rename(&metadata_filename, &out_filename) {\n-            tcx.sess.fatal(&format!(\"failed to write {}: {}\", out_filename.display(), e));\n-        }\n-        if tcx.sess.opts.json_artifact_notifications {\n-            tcx.sess\n-                .parse_sess\n-                .span_diagnostic\n-                .emit_artifact_notification(&out_filename, \"metadata\");\n-        }\n-    }\n-\n-    let need_metadata_module = metadata_kind == MetadataKind::Compressed;\n-\n-    (metadata, need_metadata_module)\n-}\n-\n /// Runs the codegen backend, after which the AST and analysis can\n /// be discarded.\n pub fn start_codegen<'tcx>(\n@@ -1065,7 +998,8 @@ pub fn start_codegen<'tcx>(\n ) -> Box<dyn Any> {\n     info!(\"Pre-codegen\\n{:?}\", tcx.debug_stats());\n \n-    let (metadata, need_metadata_module) = encode_and_write_metadata(tcx, outputs);\n+    let (metadata, need_metadata_module) =\n+        rustc_metadata::fs::encode_and_write_metadata(tcx, outputs);\n \n     let codegen = tcx.sess.time(\"codegen_crate\", move || {\n         codegen_backend.codegen_crate(tcx, metadata, need_metadata_module)"}, {"sha": "97856ecf22c66020f21e9021909f9313f0a8629d", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1ba1fec234d07f43765c3c65ac341a4e64fb911a/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ba1fec234d07f43765c3c65ac341a4e64fb911a/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=1ba1fec234d07f43765c3c65ac341a4e64fb911a", "patch": "@@ -650,24 +650,6 @@ pub fn build_output_filenames(\n     }\n }\n \n-#[cfg(not(target_os = \"linux\"))]\n-pub fn non_durable_rename(src: &Path, dst: &Path) -> std::io::Result<()> {\n-    std::fs::rename(src, dst)\n-}\n-\n-/// This function attempts to bypass the auto_da_alloc heuristic implemented by some filesystems\n-/// such as btrfs and ext4. When renaming over a file that already exists then they will \"helpfully\"\n-/// write back the source file before committing the rename in case a developer forgot some of\n-/// the fsyncs in the open/write/fsync(file)/rename/fsync(dir) dance for atomic file updates.\n-///\n-/// To avoid triggering this heuristic we delete the destination first, if it exists.\n-/// The cost of an extra syscall is much lower than getting descheduled for the sync IO.\n-#[cfg(target_os = \"linux\")]\n-pub fn non_durable_rename(src: &Path, dst: &Path) -> std::io::Result<()> {\n-    let _ = std::fs::remove_file(dst);\n-    std::fs::rename(src, dst)\n-}\n-\n /// Returns a version string such as \"1.46.0 (04488afe3 2020-08-24)\"\n pub fn version_str() -> Option<&'static str> {\n     option_env!(\"CFG_VERSION\")"}, {"sha": "2c5db9d8b2765eab5ad0f4628ebe1e872692a656", "filename": "compiler/rustc_metadata/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1ba1fec234d07f43765c3c65ac341a4e64fb911a/compiler%2Frustc_metadata%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1ba1fec234d07f43765c3c65ac341a4e64fb911a/compiler%2Frustc_metadata%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2FCargo.toml?ref=1ba1fec234d07f43765c3c65ac341a4e64fb911a", "patch": "@@ -12,6 +12,7 @@ odht = { version = \"0.3.1\", features = [\"nightly\"] }\n snap = \"1\"\n tracing = \"0.1\"\n smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }\n+tempfile = \"3.2\"\n rustc_middle = { path = \"../rustc_middle\" }\n rustc_attr = { path = \"../rustc_attr\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }"}, {"sha": "e6072901aaa43df068a8df0f72d27de5f9980471", "filename": "compiler/rustc_metadata/src/fs.rs", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/1ba1fec234d07f43765c3c65ac341a4e64fb911a/compiler%2Frustc_metadata%2Fsrc%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ba1fec234d07f43765c3c65ac341a4e64fb911a/compiler%2Frustc_metadata%2Fsrc%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Ffs.rs?ref=1ba1fec234d07f43765c3c65ac341a4e64fb911a", "patch": "@@ -0,0 +1,137 @@\n+use crate::{encode_metadata, EncodedMetadata};\n+\n+use rustc_data_structures::temp_dir::MaybeTempDir;\n+use rustc_hir::def_id::LOCAL_CRATE;\n+use rustc_middle::ty::TyCtxt;\n+use rustc_session::config::{CrateType, OutputFilenames, OutputType};\n+use rustc_session::output::filename_for_metadata;\n+use rustc_session::Session;\n+use tempfile::Builder as TempFileBuilder;\n+\n+use std::fs;\n+use std::path::{Path, PathBuf};\n+\n+// FIXME(eddyb) maybe include the crate name in this?\n+pub const METADATA_FILENAME: &str = \"lib.rmeta\";\n+\n+/// We use a temp directory here to avoid races between concurrent rustc processes,\n+/// such as builds in the same directory using the same filename for metadata while\n+/// building an `.rlib` (stomping over one another), or writing an `.rmeta` into a\n+/// directory being searched for `extern crate` (observing an incomplete file).\n+/// The returned path is the temporary file containing the complete metadata.\n+pub fn emit_metadata(sess: &Session, metadata: &[u8], tmpdir: &MaybeTempDir) -> PathBuf {\n+    let out_filename = tmpdir.as_ref().join(METADATA_FILENAME);\n+    let result = fs::write(&out_filename, metadata);\n+\n+    if let Err(e) = result {\n+        sess.fatal(&format!(\"failed to write {}: {}\", out_filename.display(), e));\n+    }\n+\n+    out_filename\n+}\n+\n+pub fn encode_and_write_metadata(\n+    tcx: TyCtxt<'_>,\n+    outputs: &OutputFilenames,\n+) -> (EncodedMetadata, bool) {\n+    #[derive(PartialEq, Eq, PartialOrd, Ord)]\n+    enum MetadataKind {\n+        None,\n+        Uncompressed,\n+        Compressed,\n+    }\n+\n+    let metadata_kind = tcx\n+        .sess\n+        .crate_types()\n+        .iter()\n+        .map(|ty| match *ty {\n+            CrateType::Executable | CrateType::Staticlib | CrateType::Cdylib => MetadataKind::None,\n+\n+            CrateType::Rlib => MetadataKind::Uncompressed,\n+\n+            CrateType::Dylib | CrateType::ProcMacro => MetadataKind::Compressed,\n+        })\n+        .max()\n+        .unwrap_or(MetadataKind::None);\n+\n+    let crate_name = tcx.crate_name(LOCAL_CRATE);\n+    let out_filename = filename_for_metadata(tcx.sess, crate_name.as_str(), outputs);\n+    // To avoid races with another rustc process scanning the output directory,\n+    // we need to write the file somewhere else and atomically move it to its\n+    // final destination, with an `fs::rename` call. In order for the rename to\n+    // always succeed, the temporary file needs to be on the same filesystem,\n+    // which is why we create it inside the output directory specifically.\n+    let metadata_tmpdir = TempFileBuilder::new()\n+        .prefix(\"rmeta\")\n+        .tempdir_in(out_filename.parent().unwrap_or_else(|| Path::new(\"\")))\n+        .unwrap_or_else(|err| tcx.sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)));\n+    let metadata_tmpdir = MaybeTempDir::new(metadata_tmpdir, tcx.sess.opts.cg.save_temps);\n+    let metadata_filename = metadata_tmpdir.as_ref().join(METADATA_FILENAME);\n+\n+    // Always create a file at `metadata_filename`, even if we have nothing to write to it.\n+    // This simplifies the creation of the output `out_filename` when requested.\n+    match metadata_kind {\n+        MetadataKind::None => {\n+            std::fs::File::create(&metadata_filename).unwrap_or_else(|e| {\n+                tcx.sess.fatal(&format!(\n+                    \"failed to create the file {}: {}\",\n+                    metadata_filename.display(),\n+                    e\n+                ))\n+            });\n+        }\n+        MetadataKind::Uncompressed | MetadataKind::Compressed => {\n+            encode_metadata(tcx, &metadata_filename);\n+        }\n+    };\n+\n+    let _prof_timer = tcx.sess.prof.generic_activity(\"write_crate_metadata\");\n+\n+    // If the user requests metadata as output, rename `metadata_filename`\n+    // to the expected output `out_filename`.  The match above should ensure\n+    // this file always exists.\n+    let need_metadata_file = tcx.sess.opts.output_types.contains_key(&OutputType::Metadata);\n+    let (metadata_filename, metadata_tmpdir) = if need_metadata_file {\n+        if let Err(e) = non_durable_rename(&metadata_filename, &out_filename) {\n+            tcx.sess.fatal(&format!(\"failed to write {}: {}\", out_filename.display(), e));\n+        }\n+        if tcx.sess.opts.json_artifact_notifications {\n+            tcx.sess\n+                .parse_sess\n+                .span_diagnostic\n+                .emit_artifact_notification(&out_filename, \"metadata\");\n+        }\n+        (out_filename, None)\n+    } else {\n+        (metadata_filename, Some(metadata_tmpdir))\n+    };\n+\n+    // Load metadata back to memory: codegen may need to include it in object files.\n+    let metadata =\n+        EncodedMetadata::from_path(metadata_filename, metadata_tmpdir).unwrap_or_else(|e| {\n+            tcx.sess.fatal(&format!(\"failed to create encoded metadata from file: {}\", e))\n+        });\n+\n+    let need_metadata_module = metadata_kind == MetadataKind::Compressed;\n+\n+    (metadata, need_metadata_module)\n+}\n+\n+#[cfg(not(target_os = \"linux\"))]\n+pub fn non_durable_rename(src: &Path, dst: &Path) -> std::io::Result<()> {\n+    std::fs::rename(src, dst)\n+}\n+\n+/// This function attempts to bypass the auto_da_alloc heuristic implemented by some filesystems\n+/// such as btrfs and ext4. When renaming over a file that already exists then they will \"helpfully\"\n+/// write back the source file before committing the rename in case a developer forgot some of\n+/// the fsyncs in the open/write/fsync(file)/rename/fsync(dir) dance for atomic file updates.\n+///\n+/// To avoid triggering this heuristic we delete the destination first, if it exists.\n+/// The cost of an extra syscall is much lower than getting descheduled for the sync IO.\n+#[cfg(target_os = \"linux\")]\n+pub fn non_durable_rename(src: &Path, dst: &Path) -> std::io::Result<()> {\n+    let _ = std::fs::remove_file(dst);\n+    std::fs::rename(src, dst)\n+}"}, {"sha": "6440f3e390cf1fde772fe34a0b50f79eef8faf20", "filename": "compiler/rustc_metadata/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ba1fec234d07f43765c3c65ac341a4e64fb911a/compiler%2Frustc_metadata%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ba1fec234d07f43765c3c65ac341a4e64fb911a/compiler%2Frustc_metadata%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flib.rs?ref=1ba1fec234d07f43765c3c65ac341a4e64fb911a", "patch": "@@ -34,6 +34,8 @@ mod native_libs;\n mod rmeta;\n \n pub mod creader;\n+pub mod fs;\n pub mod locator;\n \n+pub use fs::{emit_metadata, METADATA_FILENAME};\n pub use rmeta::{encode_metadata, EncodedMetadata, METADATA_HEADER};"}, {"sha": "8e97300977723abd722fbd6ef3701218da2ec69f", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 78, "deletions": 25, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/1ba1fec234d07f43765c3c65ac341a4e64fb911a/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ba1fec234d07f43765c3c65ac341a4e64fb911a/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=1ba1fec234d07f43765c3c65ac341a4e64fb911a", "patch": "@@ -4,8 +4,10 @@ use crate::rmeta::*;\n \n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxIndexSet};\n+use rustc_data_structures::memmap::{Mmap, MmapMut};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::{join, par_iter, Lrc, ParallelIterator};\n+use rustc_data_structures::temp_dir::MaybeTempDir;\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{\n@@ -27,8 +29,7 @@ use rustc_middle::ty::codec::TyEncoder;\n use rustc_middle::ty::fast_reject::{self, SimplifiedType, TreatParams};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, SymbolName, Ty, TyCtxt};\n-use rustc_serialize::opaque::MemEncoder;\n-use rustc_serialize::{Encodable, Encoder};\n+use rustc_serialize::{opaque, Decodable, Decoder, Encodable, Encoder};\n use rustc_session::config::CrateType;\n use rustc_session::cstore::{ForeignModule, LinkagePreference, NativeLib};\n use rustc_span::hygiene::{ExpnIndex, HygieneEncodeContext, MacroKind};\n@@ -39,12 +40,14 @@ use rustc_span::{\n use rustc_target::abi::VariantIdx;\n use std::borrow::Borrow;\n use std::hash::Hash;\n+use std::io::{Read, Seek, Write};\n use std::iter;\n use std::num::NonZeroUsize;\n+use std::path::{Path, PathBuf};\n use tracing::{debug, trace};\n \n pub(super) struct EncodeContext<'a, 'tcx> {\n-    opaque: MemEncoder,\n+    opaque: opaque::FileEncoder,\n     tcx: TyCtxt<'tcx>,\n     feat: &'tcx rustc_feature::Features,\n \n@@ -729,12 +732,19 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         assert_eq!(total_bytes, computed_total_bytes);\n \n         if tcx.sess.meta_stats() {\n+            self.opaque.flush();\n+\n+            // Rewind and re-read all the metadata to count the zero bytes we wrote.\n+            let pos_before_rewind = self.opaque.file().stream_position().unwrap();\n             let mut zero_bytes = 0;\n-            for e in self.opaque.data.iter() {\n-                if *e == 0 {\n+            self.opaque.file().rewind().unwrap();\n+            let file = std::io::BufReader::new(self.opaque.file());\n+            for e in file.bytes() {\n+                if e.unwrap() == 0 {\n                     zero_bytes += 1;\n                 }\n             }\n+            assert_eq!(self.opaque.file().stream_position().unwrap(), pos_before_rewind);\n \n             let perc = |bytes| (bytes * 100) as f64 / total_bytes as f64;\n             let p = |label, bytes| {\n@@ -2133,32 +2143,66 @@ fn prefetch_mir(tcx: TyCtxt<'_>) {\n // will allow us to slice the metadata to the precise length that we just\n // generated regardless of trailing bytes that end up in it.\n \n-#[derive(Encodable, Decodable)]\n pub struct EncodedMetadata {\n-    raw_data: Vec<u8>,\n+    // The declaration order matters because `mmap` should be dropped before `_temp_dir`.\n+    mmap: Option<Mmap>,\n+    // We need to carry MaybeTempDir to avoid deleting the temporary\n+    // directory while accessing the Mmap.\n+    _temp_dir: Option<MaybeTempDir>,\n }\n \n impl EncodedMetadata {\n     #[inline]\n-    pub fn new() -> EncodedMetadata {\n-        EncodedMetadata { raw_data: Vec::new() }\n+    pub fn from_path(path: PathBuf, temp_dir: Option<MaybeTempDir>) -> std::io::Result<Self> {\n+        let file = std::fs::File::open(&path)?;\n+        let file_metadata = file.metadata()?;\n+        if file_metadata.len() == 0 {\n+            return Ok(Self { mmap: None, _temp_dir: None });\n+        }\n+        let mmap = unsafe { Some(Mmap::map(file)?) };\n+        Ok(Self { mmap, _temp_dir: temp_dir })\n     }\n \n     #[inline]\n     pub fn raw_data(&self) -> &[u8] {\n-        &self.raw_data\n+        self.mmap.as_ref().map(|mmap| mmap.as_ref()).unwrap_or_default()\n+    }\n+}\n+\n+impl<S: Encoder> Encodable<S> for EncodedMetadata {\n+    fn encode(&self, s: &mut S) {\n+        let slice = self.raw_data();\n+        slice.encode(s)\n+    }\n+}\n+\n+impl<D: Decoder> Decodable<D> for EncodedMetadata {\n+    fn decode(d: &mut D) -> Self {\n+        let len = d.read_usize();\n+        let mmap = if len > 0 {\n+            let mut mmap = MmapMut::map_anon(len).unwrap();\n+            for _ in 0..len {\n+                (&mut mmap[..]).write(&[d.read_u8()]).unwrap();\n+            }\n+            mmap.flush().unwrap();\n+            Some(mmap.make_read_only().unwrap())\n+        } else {\n+            None\n+        };\n+\n+        Self { mmap, _temp_dir: None }\n     }\n }\n \n-pub fn encode_metadata(tcx: TyCtxt<'_>) -> EncodedMetadata {\n+pub fn encode_metadata(tcx: TyCtxt<'_>, path: &Path) {\n     let _prof_timer = tcx.prof.verbose_generic_activity(\"generate_crate_metadata\");\n \n     // Since encoding metadata is not in a query, and nothing is cached,\n     // there's no need to do dep-graph tracking for any of it.\n     tcx.dep_graph.assert_ignored();\n \n     join(\n-        || encode_metadata_impl(tcx),\n+        || encode_metadata_impl(tcx, path),\n         || {\n             if tcx.sess.threads() == 1 {\n                 return;\n@@ -2168,12 +2212,12 @@ pub fn encode_metadata(tcx: TyCtxt<'_>) -> EncodedMetadata {\n             // It can be removed if it turns out to cause trouble or be detrimental to performance.\n             join(|| prefetch_mir(tcx), || tcx.exported_symbols(LOCAL_CRATE));\n         },\n-    )\n-    .0\n+    );\n }\n \n-fn encode_metadata_impl(tcx: TyCtxt<'_>) -> EncodedMetadata {\n-    let mut encoder = MemEncoder::new();\n+fn encode_metadata_impl(tcx: TyCtxt<'_>, path: &Path) {\n+    let mut encoder = opaque::FileEncoder::new(path)\n+        .unwrap_or_else(|err| tcx.sess.fatal(&format!(\"failed to create file encoder: {}\", err)));\n     encoder.emit_raw_bytes(METADATA_HEADER);\n \n     // Will be filled with the root position after encoding everything.\n@@ -2208,20 +2252,29 @@ fn encode_metadata_impl(tcx: TyCtxt<'_>) -> EncodedMetadata {\n     // culminating in the `CrateRoot` which points to all of it.\n     let root = ecx.encode_crate_root();\n \n-    let mut result = ecx.opaque.finish();\n+    ecx.opaque.flush();\n+\n+    let mut file = ecx.opaque.file();\n+    // We will return to this position after writing the root position.\n+    let pos_before_seek = file.stream_position().unwrap();\n \n     // Encode the root position.\n     let header = METADATA_HEADER.len();\n+    file.seek(std::io::SeekFrom::Start(header as u64))\n+        .unwrap_or_else(|err| tcx.sess.fatal(&format!(\"failed to seek the file: {}\", err)));\n     let pos = root.position.get();\n-    result[header + 0] = (pos >> 24) as u8;\n-    result[header + 1] = (pos >> 16) as u8;\n-    result[header + 2] = (pos >> 8) as u8;\n-    result[header + 3] = (pos >> 0) as u8;\n+    file.write_all(&[(pos >> 24) as u8, (pos >> 16) as u8, (pos >> 8) as u8, (pos >> 0) as u8])\n+        .unwrap_or_else(|err| tcx.sess.fatal(&format!(\"failed to write to the file: {}\", err)));\n \n-    // Record metadata size for self-profiling\n-    tcx.prof.artifact_size(\"crate_metadata\", \"crate_metadata\", result.len() as u64);\n+    // Return to the position where we are before writing the root position.\n+    file.seek(std::io::SeekFrom::Start(pos_before_seek)).unwrap();\n \n-    EncodedMetadata { raw_data: result }\n+    // Record metadata size for self-profiling\n+    tcx.prof.artifact_size(\n+        \"crate_metadata\",\n+        \"crate_metadata\",\n+        file.metadata().unwrap().len() as u64,\n+    );\n }\n \n pub fn provide(providers: &mut Providers) {\n@@ -2242,5 +2295,5 @@ pub fn provide(providers: &mut Providers) {\n         },\n \n         ..*providers\n-    };\n+    }\n }"}, {"sha": "af1c09f4ae87adb86111644348fd2c5689c6ba29", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1ba1fec234d07f43765c3c65ac341a4e64fb911a/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ba1fec234d07f43765c3c65ac341a4e64fb911a/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=1ba1fec234d07f43765c3c65ac341a4e64fb911a", "patch": "@@ -21,7 +21,7 @@ use rustc_middle::ty::fast_reject::SimplifiedType;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, ReprOptions, Ty};\n use rustc_middle::ty::{GeneratorDiagnosticData, ParameterizedOverTcx, TyCtxt};\n-use rustc_serialize::opaque::MemEncoder;\n+use rustc_serialize::opaque::FileEncoder;\n use rustc_session::config::SymbolManglingVersion;\n use rustc_session::cstore::{CrateDepKind, ForeignModule, LinkagePreference, NativeLib};\n use rustc_span::edition::Edition;\n@@ -322,7 +322,7 @@ macro_rules! define_tables {\n         }\n \n         impl TableBuilders {\n-            fn encode(&self, buf: &mut MemEncoder) -> LazyTables {\n+            fn encode(&self, buf: &mut FileEncoder) -> LazyTables {\n                 LazyTables {\n                     $($name: self.$name.encode(buf)),+\n                 }"}, {"sha": "42759f0a652b3199b9dff5599c072c5763091c74", "filename": "compiler/rustc_metadata/src/rmeta/table.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1ba1fec234d07f43765c3c65ac341a4e64fb911a/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ba1fec234d07f43765c3c65ac341a4e64fb911a/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs?ref=1ba1fec234d07f43765c3c65ac341a4e64fb911a", "patch": "@@ -4,8 +4,8 @@ use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_hir::def::{CtorKind, CtorOf};\n use rustc_index::vec::Idx;\n use rustc_middle::ty::ParameterizedOverTcx;\n-use rustc_serialize::opaque::MemEncoder;\n-use rustc_serialize::Encoder;\n+use rustc_serialize::opaque::FileEncoder;\n+use rustc_serialize::Encoder as _;\n use rustc_span::hygiene::MacroKind;\n use std::convert::TryInto;\n use std::marker::PhantomData;\n@@ -281,7 +281,7 @@ where\n         Some(value).write_to_bytes(&mut self.blocks[i]);\n     }\n \n-    pub(crate) fn encode<const N: usize>(&self, buf: &mut MemEncoder) -> LazyTable<I, T>\n+    pub(crate) fn encode<const N: usize>(&self, buf: &mut FileEncoder) -> LazyTable<I, T>\n     where\n         Option<T>: FixedSizeEncoding<ByteArray = [u8; N]>,\n     {"}, {"sha": "5c17ef6ace2d50344173bf9a41de8502aec971bc", "filename": "compiler/rustc_serialize/src/opaque.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1ba1fec234d07f43765c3c65ac341a4e64fb911a/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ba1fec234d07f43765c3c65ac341a4e64fb911a/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs?ref=1ba1fec234d07f43765c3c65ac341a4e64fb911a", "patch": "@@ -297,6 +297,10 @@ impl FileEncoder {\n         }\n     }\n \n+    pub fn file(&self) -> &File {\n+        &self.file\n+    }\n+\n     #[inline]\n     fn capacity(&self) -> usize {\n         self.buf.len()"}, {"sha": "885f45a022431e46a79fe77357fb058ad4ba841f", "filename": "src/test/run-make-fulldeps/issue-26092/Makefile", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1ba1fec234d07f43765c3c65ac341a4e64fb911a/src%2Ftest%2Frun-make-fulldeps%2Fissue-26092%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/1ba1fec234d07f43765c3c65ac341a4e64fb911a/src%2Ftest%2Frun-make-fulldeps%2Fissue-26092%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fissue-26092%2FMakefile?ref=1ba1fec234d07f43765c3c65ac341a4e64fb911a", "patch": "@@ -1,4 +1,6 @@\n -include ../tools.mk\n \n+# This test ensures that rustc does not panic with `-o \"\"` option.\n+\n all:\n-\t$(RUSTC) -o \"\" blank.rs 2>&1 | $(CGREP) -i 'No such file or directory'\n+\t$(RUSTC) -o \"\" blank.rs 2>&1 | $(CGREP) -i 'panic' && exit 1 || exit 0"}]}