{"sha": "6379d260e7f75db77b67968aa7b878f4c461a906", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzNzlkMjYwZTdmNzVkYjc3YjY3OTY4YWE3Yjg3OGY0YzQ2MWE5MDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-14T05:49:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-14T05:49:29Z"}, "message": "Auto merge of #7288 - camsteffen:use-self2, r=phansch\n\nFix use_self FPs on type params\n\nchangelog: Fix [`use_self`] false positives on type parameters\n\nFixes #4140\nFixes #7139", "tree": {"sha": "93d9e06aef662035e5ea43201fafbc267c6213cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/93d9e06aef662035e5ea43201fafbc267c6213cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6379d260e7f75db77b67968aa7b878f4c461a906", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6379d260e7f75db77b67968aa7b878f4c461a906", "html_url": "https://github.com/rust-lang/rust/commit/6379d260e7f75db77b67968aa7b878f4c461a906", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6379d260e7f75db77b67968aa7b878f4c461a906/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1f5ccd63a93b04d4d8dcb15b5a5de58a0d8c109", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1f5ccd63a93b04d4d8dcb15b5a5de58a0d8c109", "html_url": "https://github.com/rust-lang/rust/commit/f1f5ccd63a93b04d4d8dcb15b5a5de58a0d8c109"}, {"sha": "29b4b4c10d89b2278485ac0e24a393ef58290672", "url": "https://api.github.com/repos/rust-lang/rust/commits/29b4b4c10d89b2278485ac0e24a393ef58290672", "html_url": "https://github.com/rust-lang/rust/commit/29b4b4c10d89b2278485ac0e24a393ef58290672"}], "stats": {"total": 232, "additions": 101, "deletions": 131}, "files": [{"sha": "f71dfd024999d832d17d5f33882e8a3bee68a48b", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 52, "deletions": 128, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/6379d260e7f75db77b67968aa7b878f4c461a906/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6379d260e7f75db77b67968aa7b878f4c461a906/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=6379d260e7f75db77b67968aa7b878f4c461a906", "patch": "@@ -1,23 +1,21 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::same_type_and_consts;\n use clippy_utils::{in_macro, meets_msrv, msrvs};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{\n     self as hir,\n-    def::{self, DefKind},\n+    def::{CtorOf, DefKind, Res},\n     def_id::LocalDefId,\n     intravisit::{walk_ty, NestedVisitorMap, Visitor},\n-    Expr, ExprKind, FnRetTy, FnSig, GenericArg, HirId, Impl, ImplItemKind, Item, ItemKind, Node, Path, PathSegment,\n-    QPath, TyKind,\n+    Expr, ExprKind, FnRetTy, FnSig, GenericArg, HirId, Impl, ImplItemKind, Item, ItemKind, Node, Path, QPath, TyKind,\n };\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty::{AssocKind, Ty};\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::{BytePos, Span};\n+use rustc_span::Span;\n use rustc_typeck::hir_ty_to_ty;\n \n declare_clippy_lint! {\n@@ -234,111 +232,58 @@ impl<'tcx> LateLintPass<'tcx> for UseSelf {\n     }\n \n     fn check_ty(&mut self, cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>) {\n-        if in_macro(hir_ty.span)\n-            || in_impl(cx, hir_ty)\n-            || !meets_msrv(self.msrv.as_ref(), &msrvs::TYPE_ALIAS_ENUM_VARIANTS)\n-        {\n-            return;\n-        }\n-\n-        let lint_dependend_on_expr_kind = if let Some(StackItem::Check {\n-            hir_id,\n-            types_to_lint,\n-            types_to_skip,\n-            ..\n-        }) = self.stack.last()\n-        {\n-            if types_to_skip.contains(&hir_ty.hir_id) {\n-                false\n-            } else if types_to_lint.contains(&hir_ty.hir_id) {\n-                true\n-            } else {\n-                let self_ty = ty_from_hir_id(cx, *hir_id);\n-                should_lint_ty(hir_ty, hir_ty_to_ty(cx.tcx, hir_ty), self_ty)\n-            }\n-        } else {\n-            false\n-        };\n-\n-        if lint_dependend_on_expr_kind {\n-            // FIXME: this span manipulation should not be necessary\n-            // @flip1995 found an ast lowering issue in\n-            // https://github.com/rust-lang/rust/blob/master/src/librustc_ast_lowering/path.rs#l142-l162\n+        if_chain! {\n+            if !in_macro(hir_ty.span) && !in_impl(cx, hir_ty);\n+            if meets_msrv(self.msrv.as_ref(), &msrvs::TYPE_ALIAS_ENUM_VARIANTS);\n+            if let Some(StackItem::Check {\n+                hir_id,\n+                types_to_lint,\n+                types_to_skip,\n+                ..\n+            }) = self.stack.last();\n+            if !types_to_skip.contains(&hir_ty.hir_id);\n+            if types_to_lint.contains(&hir_ty.hir_id)\n+                || {\n+                    let self_ty = ty_from_hir_id(cx, *hir_id);\n+                    should_lint_ty(hir_ty, hir_ty_to_ty(cx.tcx, hir_ty), self_ty)\n+                };\n             let hir = cx.tcx.hir();\n             let id = hir.get_parent_node(hir_ty.hir_id);\n-\n-            if !hir.opt_span(id).map_or(false, in_macro) {\n-                match hir.find(id) {\n-                    Some(Node::Expr(Expr {\n-                        kind: ExprKind::Path(QPath::TypeRelative(_, segment)),\n-                        ..\n-                    })) => span_lint_until_last_segment(cx, hir_ty.span, segment),\n-                    _ => span_lint(cx, hir_ty.span),\n-                }\n+            if !hir.opt_span(id).map_or(false, in_macro);\n+            then {\n+                span_lint(cx, hir_ty.span);\n             }\n         }\n     }\n \n     fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n-        fn expr_ty_matches(cx: &LateContext<'_>, expr: &Expr<'_>, self_ty: Ty<'_>) -> bool {\n-            let def_id = expr.hir_id.owner;\n-            if cx.tcx.has_typeck_results(def_id) {\n-                cx.tcx.typeck(def_id).expr_ty_opt(expr) == Some(self_ty)\n-            } else {\n-                false\n-            }\n-        }\n-\n-        if in_macro(expr.span) || !meets_msrv(self.msrv.as_ref(), &msrvs::TYPE_ALIAS_ENUM_VARIANTS) {\n-            return;\n+        if_chain! {\n+            if !in_macro(expr.span);\n+            if meets_msrv(self.msrv.as_ref(), &msrvs::TYPE_ALIAS_ENUM_VARIANTS);\n+            if let Some(StackItem::Check { hir_id, .. }) = self.stack.last();\n+            if cx.typeck_results().expr_ty(expr) == ty_from_hir_id(cx, *hir_id);\n+            then {} else { return; }\n         }\n-\n-        if let Some(StackItem::Check { hir_id, .. }) = self.stack.last() {\n-            let self_ty = ty_from_hir_id(cx, *hir_id);\n-\n-            match &expr.kind {\n-                ExprKind::Struct(QPath::Resolved(_, path), ..) => {\n-                    if expr_ty_matches(cx, expr, self_ty) {\n-                        match path.res {\n-                            def::Res::SelfTy(..) => (),\n-                            def::Res::Def(DefKind::Variant, _) => span_lint_on_path_until_last_segment(cx, path),\n-                            _ => {\n-                                span_lint(cx, path.span);\n-                            },\n-                        }\n-                    }\n-                },\n-                // tuple struct instantiation (`Foo(arg)` or `Enum::Foo(arg)`)\n-                ExprKind::Call(fun, _) => {\n-                    if let Expr {\n-                        kind: ExprKind::Path(ref qpath),\n-                        ..\n-                    } = fun\n-                    {\n-                        if expr_ty_matches(cx, expr, self_ty) {\n-                            let res = cx.qpath_res(qpath, fun.hir_id);\n-\n-                            if let def::Res::Def(DefKind::Ctor(ctor_of, _), ..) = res {\n-                                match ctor_of {\n-                                    def::CtorOf::Variant => {\n-                                        span_lint_on_qpath_resolved(cx, qpath, true);\n-                                    },\n-                                    def::CtorOf::Struct => {\n-                                        span_lint_on_qpath_resolved(cx, qpath, false);\n-                                    },\n-                                }\n-                            }\n+        match expr.kind {\n+            ExprKind::Struct(QPath::Resolved(_, path), ..) => match path.res {\n+                Res::SelfTy(..) => (),\n+                Res::Def(DefKind::Variant, _) => lint_path_to_variant(cx, path),\n+                _ => span_lint(cx, path.span),\n+            },\n+            // tuple struct instantiation (`Foo(arg)` or `Enum::Foo(arg)`)\n+            ExprKind::Call(fun, _) => {\n+                if let ExprKind::Path(QPath::Resolved(_, path)) = fun.kind {\n+                    if let Res::Def(DefKind::Ctor(ctor_of, _), ..) = path.res {\n+                        match ctor_of {\n+                            CtorOf::Variant => lint_path_to_variant(cx, path),\n+                            CtorOf::Struct => span_lint(cx, path.span),\n                         }\n                     }\n-                },\n-                // unit enum variants (`Enum::A`)\n-                ExprKind::Path(qpath) => {\n-                    if expr_ty_matches(cx, expr, self_ty) {\n-                        span_lint_on_qpath_resolved(cx, qpath, true);\n-                    }\n-                },\n-                _ => (),\n-            }\n+                }\n+            },\n+            // unit enum variants (`Enum::A`)\n+            ExprKind::Path(QPath::Resolved(_, path)) => lint_path_to_variant(cx, path),\n+            _ => (),\n         }\n     }\n \n@@ -405,33 +350,12 @@ fn span_lint(cx: &LateContext<'_>, span: Span) {\n     );\n }\n \n-#[allow(clippy::cast_possible_truncation)]\n-fn span_lint_until_last_segment(cx: &LateContext<'_>, span: Span, segment: &PathSegment<'_>) {\n-    let sp = span.with_hi(segment.ident.span.lo());\n-    // remove the trailing ::\n-    let span_without_last_segment = match snippet_opt(cx, sp) {\n-        Some(snippet) => match snippet.rfind(\"::\") {\n-            Some(bidx) => sp.with_hi(sp.lo() + BytePos(bidx as u32)),\n-            None => sp,\n-        },\n-        None => sp,\n-    };\n-    span_lint(cx, span_without_last_segment);\n-}\n-\n-fn span_lint_on_path_until_last_segment(cx: &LateContext<'_>, path: &Path<'_>) {\n-    if path.segments.len() > 1 {\n-        span_lint_until_last_segment(cx, path.span, path.segments.last().unwrap());\n-    }\n-}\n-\n-fn span_lint_on_qpath_resolved(cx: &LateContext<'_>, qpath: &QPath<'_>, until_last_segment: bool) {\n-    if let QPath::Resolved(_, path) = qpath {\n-        if until_last_segment {\n-            span_lint_on_path_until_last_segment(cx, path);\n-        } else {\n-            span_lint(cx, path.span);\n-        }\n+fn lint_path_to_variant(cx: &LateContext<'_>, path: &Path<'_>) {\n+    if let [.., self_seg, _variant] = path.segments {\n+        let span = path\n+            .span\n+            .with_hi(self_seg.args().span_ext().unwrap_or(self_seg.ident.span).hi());\n+        span_lint(cx, span);\n     }\n }\n \n@@ -462,7 +386,7 @@ fn should_lint_ty(hir_ty: &hir::Ty<'_>, ty: Ty<'_>, self_ty: Ty<'_>) -> bool {\n         if same_type_and_consts(ty, self_ty);\n         if let TyKind::Path(QPath::Resolved(_, path)) = hir_ty.kind;\n         then {\n-            !matches!(path.res, def::Res::SelfTy(..))\n+            !matches!(path.res, Res::SelfTy(..) | Res::Def(DefKind::TyParam, _))\n         } else {\n             false\n         }"}, {"sha": "e2c28542efc76e38c89aec06fc9bf7d670800dd6", "filename": "tests/ui/use_self.fixed", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6379d260e7f75db77b67968aa7b878f4c461a906/tests%2Fui%2Fuse_self.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/6379d260e7f75db77b67968aa7b878f4c461a906/tests%2Fui%2Fuse_self.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuse_self.fixed?ref=6379d260e7f75db77b67968aa7b878f4c461a906", "patch": "@@ -492,3 +492,26 @@ mod issue7206 {\n         }\n     }\n }\n+\n+mod self_is_ty_param {\n+    trait Trait {\n+        type Type;\n+        type Hi;\n+\n+        fn test();\n+    }\n+\n+    impl<I> Trait for I\n+    where\n+        I: Iterator,\n+        I::Item: Trait, // changing this to Self would require <Self as Iterator>\n+    {\n+        type Type = I;\n+        type Hi = I::Item;\n+\n+        fn test() {\n+            let _: I::Item;\n+            let _: I; // this could lint, but is questionable\n+        }\n+    }\n+}"}, {"sha": "3cd99b9f5cd88775aaa07a061c5c8092fd852b96", "filename": "tests/ui/use_self.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6379d260e7f75db77b67968aa7b878f4c461a906/tests%2Fui%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6379d260e7f75db77b67968aa7b878f4c461a906/tests%2Fui%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuse_self.rs?ref=6379d260e7f75db77b67968aa7b878f4c461a906", "patch": "@@ -279,7 +279,7 @@ mod generics {\n     impl<T> Foo<T> {\n         // `Self` is applicable here\n         fn foo(value: T) -> Foo<T> {\n-            Foo { value }\n+            Foo::<T> { value }\n         }\n \n         // `Cannot` use `Self` as a return type as the generic types are different\n@@ -492,3 +492,26 @@ mod issue7206 {\n         }\n     }\n }\n+\n+mod self_is_ty_param {\n+    trait Trait {\n+        type Type;\n+        type Hi;\n+\n+        fn test();\n+    }\n+\n+    impl<I> Trait for I\n+    where\n+        I: Iterator,\n+        I::Item: Trait, // changing this to Self would require <Self as Iterator>\n+    {\n+        type Type = I;\n+        type Hi = I::Item;\n+\n+        fn test() {\n+            let _: I::Item;\n+            let _: I; // this could lint, but is questionable\n+        }\n+    }\n+}"}, {"sha": "6ac26c9e5a9cece3a876924c17595799c6efca9d", "filename": "tests/ui/use_self.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6379d260e7f75db77b67968aa7b878f4c461a906/tests%2Fui%2Fuse_self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6379d260e7f75db77b67968aa7b878f4c461a906/tests%2Fui%2Fuse_self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuse_self.stderr?ref=6379d260e7f75db77b67968aa7b878f4c461a906", "patch": "@@ -153,8 +153,8 @@ LL |         fn foo(value: T) -> Foo<T> {\n error: unnecessary structure name repetition\n   --> $DIR/use_self.rs:282:13\n    |\n-LL |             Foo { value }\n-   |             ^^^ help: use the applicable keyword: `Self`\n+LL |             Foo::<T> { value }\n+   |             ^^^^^^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n   --> $DIR/use_self.rs:454:13"}]}