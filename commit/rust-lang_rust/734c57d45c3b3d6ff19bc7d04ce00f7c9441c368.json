{"sha": "734c57d45c3b3d6ff19bc7d04ce00f7c9441c368", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczNGM1N2Q0NWMzYjNkNmZmMTliYzdkMDRjZTAwZjdjOTQ0MWMzNjg=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-09-28T16:39:39Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-09-28T16:39:39Z"}, "message": "Rollup merge of #76454 - poliorcetics:ui-to-unit-test-1, r=matklad\n\nUI to unit test for those using Cell/RefCell/UnsafeCell\n\nHelps with #76268.\n\nI'm working on all files using `Cell` and moving them to unit tests when possible.\n\nr? @matklad", "tree": {"sha": "c0ea98d03164b650b078e8f50653e99fbbc2ad12", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c0ea98d03164b650b078e8f50653e99fbbc2ad12"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/734c57d45c3b3d6ff19bc7d04ce00f7c9441c368", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfchHLCRBK7hj4Ov3rIwAAdHIIABA3lMUqkna6X5sNijJCm3bc\nC362bCG/wmbLrPECgY3a1iIOaiewFcSVJhh9bv05pNL3WYjxoH0O2gITNAhey1/7\nqoGS0JHmQw0q5kWrhbx+SG60aZb1TwM9FzHOHdZ/AwpBu3iHB0QLveNBtAp5OPx+\not97DnFRyHF4/PHH8nw41kiWytQq5vyWzS/74cSwllUA1Ve7pgKIKn/w54SkA7ee\nsKkJRqsldGt8z+D4V8q6pgHRe7nbaf6P7PHSGDPhWJMGBaT4XebGA0d2s0ct3wXW\nUr79rcCH8fHC51tpJDpgiX4uyGttkMHiUjWAW7a9A15mEQ9nc6jLTcmwxtQCj54=\n=bL8c\n-----END PGP SIGNATURE-----\n", "payload": "tree c0ea98d03164b650b078e8f50653e99fbbc2ad12\nparent 535d27ac9a3d45dd92769f4d4c7b9f454d1077ea\nparent a61b9638bbbb48f9c2fde0ccbbcf03e64494ea0f\nauthor Ralf Jung <post@ralfj.de> 1601311179 +0200\ncommitter GitHub <noreply@github.com> 1601311179 +0200\n\nRollup merge of #76454 - poliorcetics:ui-to-unit-test-1, r=matklad\n\nUI to unit test for those using Cell/RefCell/UnsafeCell\n\nHelps with #76268.\n\nI'm working on all files using `Cell` and moving them to unit tests when possible.\n\nr? @matklad\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/734c57d45c3b3d6ff19bc7d04ce00f7c9441c368", "html_url": "https://github.com/rust-lang/rust/commit/734c57d45c3b3d6ff19bc7d04ce00f7c9441c368", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/734c57d45c3b3d6ff19bc7d04ce00f7c9441c368/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "535d27ac9a3d45dd92769f4d4c7b9f454d1077ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/535d27ac9a3d45dd92769f4d4c7b9f454d1077ea", "html_url": "https://github.com/rust-lang/rust/commit/535d27ac9a3d45dd92769f4d4c7b9f454d1077ea"}, {"sha": "a61b9638bbbb48f9c2fde0ccbbcf03e64494ea0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a61b9638bbbb48f9c2fde0ccbbcf03e64494ea0f", "html_url": "https://github.com/rust-lang/rust/commit/a61b9638bbbb48f9c2fde0ccbbcf03e64494ea0f"}], "stats": {"total": 1354, "additions": 667, "deletions": 687}, "files": [{"sha": "6a83f5da87cc8f413348861bbb80e547cc2c7457", "filename": "library/alloc/tests/boxed.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/734c57d45c3b3d6ff19bc7d04ce00f7c9441c368/library%2Falloc%2Ftests%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734c57d45c3b3d6ff19bc7d04ce00f7c9441c368/library%2Falloc%2Ftests%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fboxed.rs?ref=734c57d45c3b3d6ff19bc7d04ce00f7c9441c368", "patch": "@@ -1,3 +1,4 @@\n+use std::cell::Cell;\n use std::mem::MaybeUninit;\n use std::ptr::NonNull;\n \n@@ -49,3 +50,10 @@ fn box_clone_from_ptr_stability() {\n         assert_eq!(copy.as_ptr() as usize, copy_raw);\n     }\n }\n+\n+#[test]\n+fn box_deref_lval() {\n+    let x = Box::new(Cell::new(5));\n+    x.set(1000);\n+    assert_eq!(x.get(), 1000);\n+}"}, {"sha": "757fddd241857a28d734b9db47652ad08988060d", "filename": "library/alloc/tests/fmt.rs", "status": "modified", "additions": 321, "deletions": 1, "changes": 322, "blob_url": "https://github.com/rust-lang/rust/blob/734c57d45c3b3d6ff19bc7d04ce00f7c9441c368/library%2Falloc%2Ftests%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734c57d45c3b3d6ff19bc7d04ce00f7c9441c368/library%2Falloc%2Ftests%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Ffmt.rs?ref=734c57d45c3b3d6ff19bc7d04ce00f7c9441c368", "patch": "@@ -1,7 +1,327 @@\n-use std::fmt;\n+#![deny(warnings)]\n+\n+use std::cell::RefCell;\n+use std::fmt::{self, Write};\n \n #[test]\n fn test_format() {\n     let s = fmt::format(format_args!(\"Hello, {}!\", \"world\"));\n     assert_eq!(s, \"Hello, world!\");\n }\n+\n+struct A;\n+struct B;\n+struct C;\n+struct D;\n+\n+impl fmt::LowerHex for A {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(\"aloha\")\n+    }\n+}\n+impl fmt::UpperHex for B {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(\"adios\")\n+    }\n+}\n+impl fmt::Display for C {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.pad_integral(true, \"\u2603\", \"123\")\n+    }\n+}\n+impl fmt::Binary for D {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(\"aa\")?;\n+        f.write_char('\u2603')?;\n+        f.write_str(\"bb\")\n+    }\n+}\n+\n+macro_rules! t {\n+    ($a:expr, $b:expr) => {\n+        assert_eq!($a, $b)\n+    };\n+}\n+\n+#[test]\n+fn test_format_macro_interface() {\n+    // Various edge cases without formats\n+    t!(format!(\"\"), \"\");\n+    t!(format!(\"hello\"), \"hello\");\n+    t!(format!(\"hello {{\"), \"hello {\");\n+\n+    // default formatters should work\n+    t!(format!(\"{}\", 1.0f32), \"1\");\n+    t!(format!(\"{}\", 1.0f64), \"1\");\n+    t!(format!(\"{}\", \"a\"), \"a\");\n+    t!(format!(\"{}\", \"a\".to_string()), \"a\");\n+    t!(format!(\"{}\", false), \"false\");\n+    t!(format!(\"{}\", 'a'), \"a\");\n+\n+    // At least exercise all the formats\n+    t!(format!(\"{}\", true), \"true\");\n+    t!(format!(\"{}\", '\u2603'), \"\u2603\");\n+    t!(format!(\"{}\", 10), \"10\");\n+    t!(format!(\"{}\", 10_usize), \"10\");\n+    t!(format!(\"{:?}\", '\u2603'), \"'\u2603'\");\n+    t!(format!(\"{:?}\", 10), \"10\");\n+    t!(format!(\"{:?}\", 10_usize), \"10\");\n+    t!(format!(\"{:?}\", \"true\"), \"\\\"true\\\"\");\n+    t!(format!(\"{:?}\", \"foo\\nbar\"), \"\\\"foo\\\\nbar\\\"\");\n+    t!(\n+        format!(\"{:?}\", \"foo\\n\\\"bar\\\"\\r\\n\\'baz\\'\\t\\\\qux\\\\\"),\n+        r#\"\"foo\\n\\\"bar\\\"\\r\\n\\'baz\\'\\t\\\\qux\\\\\"\"#\n+    );\n+    t!(format!(\"{:?}\", \"foo\\0bar\\x01baz\\u{7f}q\\u{75}x\"), r#\"\"foo\\u{0}bar\\u{1}baz\\u{7f}qux\"\"#);\n+    t!(format!(\"{:o}\", 10_usize), \"12\");\n+    t!(format!(\"{:x}\", 10_usize), \"a\");\n+    t!(format!(\"{:X}\", 10_usize), \"A\");\n+    t!(format!(\"{}\", \"foo\"), \"foo\");\n+    t!(format!(\"{}\", \"foo\".to_string()), \"foo\");\n+    if cfg!(target_pointer_width = \"32\") {\n+        t!(format!(\"{:#p}\", 0x1234 as *const isize), \"0x00001234\");\n+        t!(format!(\"{:#p}\", 0x1234 as *mut isize), \"0x00001234\");\n+    } else {\n+        t!(format!(\"{:#p}\", 0x1234 as *const isize), \"0x0000000000001234\");\n+        t!(format!(\"{:#p}\", 0x1234 as *mut isize), \"0x0000000000001234\");\n+    }\n+    t!(format!(\"{:p}\", 0x1234 as *const isize), \"0x1234\");\n+    t!(format!(\"{:p}\", 0x1234 as *mut isize), \"0x1234\");\n+    t!(format!(\"{:x}\", A), \"aloha\");\n+    t!(format!(\"{:X}\", B), \"adios\");\n+    t!(format!(\"foo {} \u2603\u2603\u2603\u2603\u2603\u2603\", \"bar\"), \"foo bar \u2603\u2603\u2603\u2603\u2603\u2603\");\n+    t!(format!(\"{1} {0}\", 0, 1), \"1 0\");\n+    t!(format!(\"{foo} {bar}\", foo = 0, bar = 1), \"0 1\");\n+    t!(format!(\"{foo} {1} {bar} {0}\", 0, 1, foo = 2, bar = 3), \"2 1 3 0\");\n+    t!(format!(\"{} {0}\", \"a\"), \"a a\");\n+    t!(format!(\"{_foo}\", _foo = 6usize), \"6\");\n+    t!(format!(\"{foo_bar}\", foo_bar = 1), \"1\");\n+    t!(format!(\"{}\", 5 + 5), \"10\");\n+    t!(format!(\"{:#4}\", C), \"\u2603123\");\n+    t!(format!(\"{:b}\", D), \"aa\u2603bb\");\n+\n+    let a: &dyn fmt::Debug = &1;\n+    t!(format!(\"{:?}\", a), \"1\");\n+\n+    // Formatting strings and their arguments\n+    t!(format!(\"{}\", \"a\"), \"a\");\n+    t!(format!(\"{:4}\", \"a\"), \"a   \");\n+    t!(format!(\"{:4}\", \"\u2603\"), \"\u2603   \");\n+    t!(format!(\"{:>4}\", \"a\"), \"   a\");\n+    t!(format!(\"{:<4}\", \"a\"), \"a   \");\n+    t!(format!(\"{:^5}\", \"a\"), \"  a  \");\n+    t!(format!(\"{:^5}\", \"aa\"), \" aa  \");\n+    t!(format!(\"{:^4}\", \"a\"), \" a  \");\n+    t!(format!(\"{:^4}\", \"aa\"), \" aa \");\n+    t!(format!(\"{:.4}\", \"a\"), \"a\");\n+    t!(format!(\"{:4.4}\", \"a\"), \"a   \");\n+    t!(format!(\"{:4.4}\", \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n+    t!(format!(\"{:<4.4}\", \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n+    t!(format!(\"{:>4.4}\", \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n+    t!(format!(\"{:^4.4}\", \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n+    t!(format!(\"{:>10.4}\", \"aaaaaaaaaaaaaaaaaa\"), \"      aaaa\");\n+    t!(format!(\"{:2.4}\", \"aaaaa\"), \"aaaa\");\n+    t!(format!(\"{:2.4}\", \"aaaa\"), \"aaaa\");\n+    t!(format!(\"{:2.4}\", \"aaa\"), \"aaa\");\n+    t!(format!(\"{:2.4}\", \"aa\"), \"aa\");\n+    t!(format!(\"{:2.4}\", \"a\"), \"a \");\n+    t!(format!(\"{:0>2}\", \"a\"), \"0a\");\n+    t!(format!(\"{:.*}\", 4, \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n+    t!(format!(\"{:.1$}\", \"aaaaaaaaaaaaaaaaaa\", 4), \"aaaa\");\n+    t!(format!(\"{:.a$}\", \"aaaaaaaaaaaaaaaaaa\", a = 4), \"aaaa\");\n+    t!(format!(\"{:._a$}\", \"aaaaaaaaaaaaaaaaaa\", _a = 4), \"aaaa\");\n+    t!(format!(\"{:1$}\", \"a\", 4), \"a   \");\n+    t!(format!(\"{1:0$}\", 4, \"a\"), \"a   \");\n+    t!(format!(\"{:a$}\", \"a\", a = 4), \"a   \");\n+    t!(format!(\"{:-#}\", \"a\"), \"a\");\n+    t!(format!(\"{:+#}\", \"a\"), \"a\");\n+    t!(format!(\"{:/^10.8}\", \"1234567890\"), \"/12345678/\");\n+\n+    // Some float stuff\n+    t!(format!(\"{:}\", 1.0f32), \"1\");\n+    t!(format!(\"{:}\", 1.0f64), \"1\");\n+    t!(format!(\"{:.3}\", 1.0f64), \"1.000\");\n+    t!(format!(\"{:10.3}\", 1.0f64), \"     1.000\");\n+    t!(format!(\"{:+10.3}\", 1.0f64), \"    +1.000\");\n+    t!(format!(\"{:+10.3}\", -1.0f64), \"    -1.000\");\n+\n+    t!(format!(\"{:e}\", 1.2345e6f32), \"1.2345e6\");\n+    t!(format!(\"{:e}\", 1.2345e6f64), \"1.2345e6\");\n+    t!(format!(\"{:E}\", 1.2345e6f64), \"1.2345E6\");\n+    t!(format!(\"{:.3e}\", 1.2345e6f64), \"1.234e6\");\n+    t!(format!(\"{:10.3e}\", 1.2345e6f64), \"   1.234e6\");\n+    t!(format!(\"{:+10.3e}\", 1.2345e6f64), \"  +1.234e6\");\n+    t!(format!(\"{:+10.3e}\", -1.2345e6f64), \"  -1.234e6\");\n+\n+    // Float edge cases\n+    t!(format!(\"{}\", -0.0), \"0\");\n+    t!(format!(\"{:?}\", -0.0), \"-0.0\");\n+    t!(format!(\"{:?}\", 0.0), \"0.0\");\n+\n+    // sign aware zero padding\n+    t!(format!(\"{:<3}\", 1), \"1  \");\n+    t!(format!(\"{:>3}\", 1), \"  1\");\n+    t!(format!(\"{:^3}\", 1), \" 1 \");\n+    t!(format!(\"{:03}\", 1), \"001\");\n+    t!(format!(\"{:<03}\", 1), \"001\");\n+    t!(format!(\"{:>03}\", 1), \"001\");\n+    t!(format!(\"{:^03}\", 1), \"001\");\n+    t!(format!(\"{:+03}\", 1), \"+01\");\n+    t!(format!(\"{:<+03}\", 1), \"+01\");\n+    t!(format!(\"{:>+03}\", 1), \"+01\");\n+    t!(format!(\"{:^+03}\", 1), \"+01\");\n+    t!(format!(\"{:#05x}\", 1), \"0x001\");\n+    t!(format!(\"{:<#05x}\", 1), \"0x001\");\n+    t!(format!(\"{:>#05x}\", 1), \"0x001\");\n+    t!(format!(\"{:^#05x}\", 1), \"0x001\");\n+    t!(format!(\"{:05}\", 1.2), \"001.2\");\n+    t!(format!(\"{:<05}\", 1.2), \"001.2\");\n+    t!(format!(\"{:>05}\", 1.2), \"001.2\");\n+    t!(format!(\"{:^05}\", 1.2), \"001.2\");\n+    t!(format!(\"{:05}\", -1.2), \"-01.2\");\n+    t!(format!(\"{:<05}\", -1.2), \"-01.2\");\n+    t!(format!(\"{:>05}\", -1.2), \"-01.2\");\n+    t!(format!(\"{:^05}\", -1.2), \"-01.2\");\n+    t!(format!(\"{:+05}\", 1.2), \"+01.2\");\n+    t!(format!(\"{:<+05}\", 1.2), \"+01.2\");\n+    t!(format!(\"{:>+05}\", 1.2), \"+01.2\");\n+    t!(format!(\"{:^+05}\", 1.2), \"+01.2\");\n+\n+    // Ergonomic format_args!\n+    t!(format!(\"{0:x} {0:X}\", 15), \"f F\");\n+    t!(format!(\"{0:x} {0:X} {}\", 15), \"f F 15\");\n+    t!(format!(\"{:x}{0:X}{a:x}{:X}{1:x}{a:X}\", 13, 14, a = 15), \"dDfEeF\");\n+    t!(format!(\"{a:x} {a:X}\", a = 15), \"f F\");\n+\n+    // And its edge cases\n+    t!(\n+        format!(\n+            \"{a:.0$} {b:.0$} {0:.0$}\\n{a:.c$} {b:.c$} {c:.c$}\",\n+            4,\n+            a = \"abcdefg\",\n+            b = \"hijklmn\",\n+            c = 3\n+        ),\n+        \"abcd hijk 4\\nabc hij 3\"\n+    );\n+    t!(format!(\"{a:.*} {0} {:.*}\", 4, 3, \"efgh\", a = \"abcdef\"), \"abcd 4 efg\");\n+    t!(format!(\"{:.a$} {a} {a:#x}\", \"aaaaaa\", a = 2), \"aa 2 0x2\");\n+\n+    // Test that pointers don't get truncated.\n+    {\n+        let val = usize::MAX;\n+        let exp = format!(\"{:#x}\", val);\n+        t!(format!(\"{:p}\", val as *const isize), exp);\n+    }\n+\n+    // Escaping\n+    t!(format!(\"{{\"), \"{\");\n+    t!(format!(\"}}\"), \"}\");\n+\n+    // make sure that format! doesn't move out of local variables\n+    let a = Box::new(3);\n+    format!(\"{}\", a);\n+    format!(\"{}\", a);\n+\n+    // make sure that format! doesn't cause spurious unused-unsafe warnings when\n+    // it's inside of an outer unsafe block\n+    unsafe {\n+        let a: isize = ::std::mem::transmute(3_usize);\n+        format!(\"{}\", a);\n+    }\n+\n+    // test that trailing commas are acceptable\n+    format!(\"{}\", \"test\",);\n+    format!(\"{foo}\", foo = \"test\",);\n+}\n+\n+// Basic test to make sure that we can invoke the `write!` macro with an\n+// fmt::Write instance.\n+#[test]\n+fn test_write() {\n+    let mut buf = String::new();\n+    let _ = write!(&mut buf, \"{}\", 3);\n+    {\n+        let w = &mut buf;\n+        let _ = write!(w, \"{foo}\", foo = 4);\n+        let _ = write!(w, \"{}\", \"hello\");\n+        let _ = writeln!(w, \"{}\", \"line\");\n+        let _ = writeln!(w, \"{foo}\", foo = \"bar\");\n+        let _ = w.write_char('\u2603');\n+        let _ = w.write_str(\"str\");\n+    }\n+\n+    t!(buf, \"34helloline\\nbar\\n\u2603str\");\n+}\n+\n+// Just make sure that the macros are defined, there's not really a lot that we\n+// can do with them just yet (to test the output)\n+#[test]\n+fn test_print() {\n+    print!(\"hi\");\n+    print!(\"{:?}\", vec![0u8]);\n+    println!(\"hello\");\n+    println!(\"this is a {}\", \"test\");\n+    println!(\"{foo}\", foo = \"bar\");\n+}\n+\n+// Just make sure that the macros are defined, there's not really a lot that we\n+// can do with them just yet (to test the output)\n+#[test]\n+fn test_format_args() {\n+    let mut buf = String::new();\n+    {\n+        let w = &mut buf;\n+        let _ = write!(w, \"{}\", format_args!(\"{}\", 1));\n+        let _ = write!(w, \"{}\", format_args!(\"test\"));\n+        let _ = write!(w, \"{}\", format_args!(\"{test}\", test = 3));\n+    }\n+    let s = buf;\n+    t!(s, \"1test3\");\n+\n+    let s = fmt::format(format_args!(\"hello {}\", \"world\"));\n+    t!(s, \"hello world\");\n+    let s = format!(\"{}: {}\", \"args were\", format_args!(\"hello {}\", \"world\"));\n+    t!(s, \"args were: hello world\");\n+}\n+\n+#[test]\n+fn test_order() {\n+    // Make sure format!() arguments are always evaluated in a left-to-right\n+    // ordering\n+    fn foo() -> isize {\n+        static mut FOO: isize = 0;\n+        unsafe {\n+            FOO += 1;\n+            FOO\n+        }\n+    }\n+    assert_eq!(\n+        format!(\"{} {} {a} {b} {} {c}\", foo(), foo(), foo(), a = foo(), b = foo(), c = foo()),\n+        \"1 2 4 5 3 6\".to_string()\n+    );\n+}\n+\n+#[test]\n+fn test_once() {\n+    // Make sure each argument are evaluated only once even though it may be\n+    // formatted multiple times\n+    fn foo() -> isize {\n+        static mut FOO: isize = 0;\n+        unsafe {\n+            FOO += 1;\n+            FOO\n+        }\n+    }\n+    assert_eq!(format!(\"{0} {0} {0} {a} {a} {a}\", foo(), a = foo()), \"1 1 1 2 2 2\".to_string());\n+}\n+\n+#[test]\n+fn test_refcell() {\n+    let refcell = RefCell::new(5);\n+    assert_eq!(format!(\"{:?}\", refcell), \"RefCell { value: 5 }\");\n+    let borrow = refcell.borrow_mut();\n+    assert_eq!(format!(\"{:?}\", refcell), \"RefCell { value: <borrowed> }\");\n+    drop(borrow);\n+    assert_eq!(format!(\"{:?}\", refcell), \"RefCell { value: 5 }\");\n+}"}, {"sha": "b7c7138db4f522a62b74b9f86489ce96a966e99a", "filename": "library/alloc/tests/vec.rs", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/734c57d45c3b3d6ff19bc7d04ce00f7c9441c368/library%2Falloc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734c57d45c3b3d6ff19bc7d04ce00f7c9441c368/library%2Falloc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec.rs?ref=734c57d45c3b3d6ff19bc7d04ce00f7c9441c368", "patch": "@@ -1,4 +1,5 @@\n use std::borrow::Cow;\n+use std::cell::Cell;\n use std::collections::TryReserveError::*;\n use std::fmt::Debug;\n use std::iter::InPlaceIterable;\n@@ -1831,3 +1832,82 @@ fn partialeq_vec_full() {\n     assert_partial_eq_valid!(vec2,vec3; array2,array3);\n     assert_partial_eq_valid!(vec2,vec3; arrayref2,arrayref3);\n }\n+\n+#[test]\n+fn test_vec_cycle() {\n+    #[derive(Debug)]\n+    struct C<'a> {\n+        v: Vec<Cell<Option<&'a C<'a>>>>,\n+    }\n+\n+    impl<'a> C<'a> {\n+        fn new() -> C<'a> {\n+            C { v: Vec::new() }\n+        }\n+    }\n+\n+    let mut c1 = C::new();\n+    let mut c2 = C::new();\n+    let mut c3 = C::new();\n+\n+    // Push\n+    c1.v.push(Cell::new(None));\n+    c1.v.push(Cell::new(None));\n+\n+    c2.v.push(Cell::new(None));\n+    c2.v.push(Cell::new(None));\n+\n+    c3.v.push(Cell::new(None));\n+    c3.v.push(Cell::new(None));\n+\n+    // Set\n+    c1.v[0].set(Some(&c2));\n+    c1.v[1].set(Some(&c3));\n+\n+    c2.v[0].set(Some(&c2));\n+    c2.v[1].set(Some(&c3));\n+\n+    c3.v[0].set(Some(&c1));\n+    c3.v[1].set(Some(&c2));\n+}\n+\n+#[test]\n+fn test_vec_cycle_wrapped() {\n+    struct Refs<'a> {\n+        v: Vec<Cell<Option<&'a C<'a>>>>,\n+    }\n+\n+    struct C<'a> {\n+        refs: Refs<'a>,\n+    }\n+\n+    impl<'a> Refs<'a> {\n+        fn new() -> Refs<'a> {\n+            Refs { v: Vec::new() }\n+        }\n+    }\n+\n+    impl<'a> C<'a> {\n+        fn new() -> C<'a> {\n+            C { refs: Refs::new() }\n+        }\n+    }\n+\n+    let mut c1 = C::new();\n+    let mut c2 = C::new();\n+    let mut c3 = C::new();\n+\n+    c1.refs.v.push(Cell::new(None));\n+    c1.refs.v.push(Cell::new(None));\n+    c2.refs.v.push(Cell::new(None));\n+    c2.refs.v.push(Cell::new(None));\n+    c3.refs.v.push(Cell::new(None));\n+    c3.refs.v.push(Cell::new(None));\n+\n+    c1.refs.v[0].set(Some(&c2));\n+    c1.refs.v[1].set(Some(&c3));\n+    c2.refs.v[0].set(Some(&c2));\n+    c2.refs.v[1].set(Some(&c3));\n+    c3.refs.v[0].set(Some(&c1));\n+    c3.refs.v[1].set(Some(&c2));\n+}"}, {"sha": "c1038ce4260bc0e8959752e8ad96411624a8bfac", "filename": "library/core/src/fmt/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/734c57d45c3b3d6ff19bc7d04ce00f7c9441c368/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734c57d45c3b3d6ff19bc7d04ce00f7c9441c368/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs?ref=734c57d45c3b3d6ff19bc7d04ce00f7c9441c368", "patch": "@@ -2238,5 +2238,6 @@ impl<T: ?Sized + Debug> Debug for UnsafeCell<T> {\n     }\n }\n \n-// If you expected tests to be here, look instead at the ui/ifmt.rs test,\n+// If you expected tests to be here, look instead at the core/tests/fmt.rs file,\n // it's a lot easier than creating all of the rt::Piece structures here.\n+// There are also tests in the alloc crate, for those that need allocations."}, {"sha": "89c2a969c28bb34af9ccfd5475a7064f4a36ba94", "filename": "library/core/tests/array.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/734c57d45c3b3d6ff19bc7d04ce00f7c9441c368/library%2Fcore%2Ftests%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734c57d45c3b3d6ff19bc7d04ce00f7c9441c368/library%2Fcore%2Ftests%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Farray.rs?ref=734c57d45c3b3d6ff19bc7d04ce00f7c9441c368", "patch": "@@ -345,3 +345,32 @@ fn array_map_drop_safety() {\n     assert_eq!(DROPPED.load(Ordering::SeqCst), num_to_create);\n     panic!(\"test succeeded\")\n }\n+\n+#[test]\n+fn cell_allows_array_cycle() {\n+    use core::cell::Cell;\n+\n+    #[derive(Debug)]\n+    struct B<'a> {\n+        a: [Cell<Option<&'a B<'a>>>; 2],\n+    }\n+\n+    impl<'a> B<'a> {\n+        fn new() -> B<'a> {\n+            B { a: [Cell::new(None), Cell::new(None)] }\n+        }\n+    }\n+\n+    let b1 = B::new();\n+    let b2 = B::new();\n+    let b3 = B::new();\n+\n+    b1.a[0].set(Some(&b2));\n+    b1.a[1].set(Some(&b3));\n+\n+    b2.a[0].set(Some(&b2));\n+    b2.a[1].set(Some(&b3));\n+\n+    b3.a[0].set(Some(&b1));\n+    b3.a[1].set(Some(&b2));\n+}"}, {"sha": "40be01f443931df7b3ad4ff312de170be12e65b1", "filename": "library/core/tests/cell.rs", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/734c57d45c3b3d6ff19bc7d04ce00f7c9441c368/library%2Fcore%2Ftests%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734c57d45c3b3d6ff19bc7d04ce00f7c9441c368/library%2Fcore%2Ftests%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fcell.rs?ref=734c57d45c3b3d6ff19bc7d04ce00f7c9441c368", "patch": "@@ -303,6 +303,53 @@ fn cell_into_inner() {\n     assert_eq!(\"Hello world\".to_owned(), cell.into_inner());\n }\n \n+#[test]\n+fn cell_exterior() {\n+    #[derive(Copy, Clone)]\n+    #[allow(dead_code)]\n+    struct Point {\n+        x: isize,\n+        y: isize,\n+        z: isize,\n+    }\n+\n+    fn f(p: &Cell<Point>) {\n+        assert_eq!(p.get().z, 12);\n+        p.set(Point { x: 10, y: 11, z: 13 });\n+        assert_eq!(p.get().z, 13);\n+    }\n+\n+    let a = Point { x: 10, y: 11, z: 12 };\n+    let b = &Cell::new(a);\n+    assert_eq!(b.get().z, 12);\n+    f(b);\n+    assert_eq!(a.z, 12);\n+    assert_eq!(b.get().z, 13);\n+}\n+\n+#[test]\n+fn cell_does_not_clone() {\n+    #[derive(Copy)]\n+    #[allow(dead_code)]\n+    struct Foo {\n+        x: isize,\n+    }\n+\n+    impl Clone for Foo {\n+        fn clone(&self) -> Foo {\n+            // Using Cell in any way should never cause clone() to be\n+            // invoked -- after all, that would permit evil user code to\n+            // abuse `Cell` and trigger crashes.\n+\n+            panic!();\n+        }\n+    }\n+\n+    let x = Cell::new(Foo { x: 22 });\n+    let _y = x.get();\n+    let _z = x.clone();\n+}\n+\n #[test]\n fn refcell_default() {\n     let cell: RefCell<u64> = Default::default();\n@@ -367,3 +414,11 @@ fn refcell_replace_borrows() {\n     let _b = x.borrow();\n     x.replace(1);\n }\n+\n+#[test]\n+fn refcell_format() {\n+    let name = RefCell::new(\"rust\");\n+    let what = RefCell::new(\"rocks\");\n+    let msg = format!(\"{name} {}\", &*what.borrow(), name = &*name.borrow());\n+    assert_eq!(msg, \"rust rocks\".to_string());\n+}"}, {"sha": "ab97352a806adc3f4638f70005693c830f85251c", "filename": "library/core/tests/iter.rs", "status": "modified", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/734c57d45c3b3d6ff19bc7d04ce00f7c9441c368/library%2Fcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734c57d45c3b3d6ff19bc7d04ce00f7c9441c368/library%2Fcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter.rs?ref=734c57d45c3b3d6ff19bc7d04ce00f7c9441c368", "patch": "@@ -376,6 +376,103 @@ fn test_zip_next_back_side_effects_exhausted() {\n     assert_eq!(b, vec![200, 300, 400]);\n }\n \n+#[derive(Debug)]\n+struct CountClone(Cell<i32>);\n+\n+fn count_clone() -> CountClone {\n+    CountClone(Cell::new(0))\n+}\n+\n+impl PartialEq<i32> for CountClone {\n+    fn eq(&self, rhs: &i32) -> bool {\n+        self.0.get() == *rhs\n+    }\n+}\n+\n+impl Clone for CountClone {\n+    fn clone(&self) -> Self {\n+        let ret = CountClone(self.0.clone());\n+        let n = self.0.get();\n+        self.0.set(n + 1);\n+        ret\n+    }\n+}\n+\n+#[test]\n+fn test_zip_cloned_sideffectful() {\n+    let xs = [count_clone(), count_clone(), count_clone(), count_clone()];\n+    let ys = [count_clone(), count_clone()];\n+\n+    for _ in xs.iter().cloned().zip(ys.iter().cloned()) {}\n+\n+    assert_eq!(&xs, &[1, 1, 1, 0][..]);\n+    assert_eq!(&ys, &[1, 1][..]);\n+\n+    let xs = [count_clone(), count_clone()];\n+    let ys = [count_clone(), count_clone(), count_clone(), count_clone()];\n+\n+    for _ in xs.iter().cloned().zip(ys.iter().cloned()) {}\n+\n+    assert_eq!(&xs, &[1, 1][..]);\n+    assert_eq!(&ys, &[1, 1, 0, 0][..]);\n+}\n+\n+#[test]\n+fn test_zip_map_sideffectful() {\n+    let mut xs = [0; 6];\n+    let mut ys = [0; 4];\n+\n+    for _ in xs.iter_mut().map(|x| *x += 1).zip(ys.iter_mut().map(|y| *y += 1)) {}\n+\n+    assert_eq!(&xs, &[1, 1, 1, 1, 1, 0]);\n+    assert_eq!(&ys, &[1, 1, 1, 1]);\n+\n+    let mut xs = [0; 4];\n+    let mut ys = [0; 6];\n+\n+    for _ in xs.iter_mut().map(|x| *x += 1).zip(ys.iter_mut().map(|y| *y += 1)) {}\n+\n+    assert_eq!(&xs, &[1, 1, 1, 1]);\n+    assert_eq!(&ys, &[1, 1, 1, 1, 0, 0]);\n+}\n+\n+#[test]\n+fn test_zip_map_rev_sideffectful() {\n+    let mut xs = [0; 6];\n+    let mut ys = [0; 4];\n+\n+    {\n+        let mut it = xs.iter_mut().map(|x| *x += 1).zip(ys.iter_mut().map(|y| *y += 1));\n+        it.next_back();\n+    }\n+    assert_eq!(&xs, &[0, 0, 0, 1, 1, 1]);\n+    assert_eq!(&ys, &[0, 0, 0, 1]);\n+\n+    let mut xs = [0; 6];\n+    let mut ys = [0; 4];\n+\n+    {\n+        let mut it = xs.iter_mut().map(|x| *x += 1).zip(ys.iter_mut().map(|y| *y += 1));\n+        (&mut it).take(5).count();\n+        it.next_back();\n+    }\n+    assert_eq!(&xs, &[1, 1, 1, 1, 1, 1]);\n+    assert_eq!(&ys, &[1, 1, 1, 1]);\n+}\n+\n+#[test]\n+fn test_zip_nested_sideffectful() {\n+    let mut xs = [0; 6];\n+    let ys = [0; 4];\n+\n+    {\n+        // test that it has the side effect nested inside enumerate\n+        let it = xs.iter_mut().map(|x| *x = 1).enumerate().zip(&ys);\n+        it.count();\n+    }\n+    assert_eq!(&xs, &[1, 1, 1, 1, 1, 0]);\n+}\n+\n #[test]\n fn test_zip_nth_back_side_effects_exhausted() {\n     let mut a = Vec::new();"}, {"sha": "ae814efec2086ea5966864b90a6e53b3deedafa0", "filename": "library/core/tests/option.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/734c57d45c3b3d6ff19bc7d04ce00f7c9441c368/library%2Fcore%2Ftests%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734c57d45c3b3d6ff19bc7d04ce00f7c9441c368/library%2Fcore%2Ftests%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Foption.rs?ref=734c57d45c3b3d6ff19bc7d04ce00f7c9441c368", "patch": "@@ -1,3 +1,4 @@\n+use core::cell::Cell;\n use core::clone::Clone;\n use core::mem;\n use core::ops::DerefMut;\n@@ -372,3 +373,32 @@ fn option_const() {\n     const IS_NONE: bool = OPTION.is_none();\n     assert!(!IS_NONE);\n }\n+\n+#[test]\n+fn test_unwrap_drop() {\n+    struct Dtor<'a> {\n+        x: &'a Cell<isize>,\n+    }\n+\n+    impl<'a> std::ops::Drop for Dtor<'a> {\n+        fn drop(&mut self) {\n+            self.x.set(self.x.get() - 1);\n+        }\n+    }\n+\n+    fn unwrap<T>(o: Option<T>) -> T {\n+        match o {\n+            Some(v) => v,\n+            None => panic!(),\n+        }\n+    }\n+\n+    let x = &Cell::new(1);\n+\n+    {\n+        let b = Some(Dtor { x });\n+        let _c = unwrap(b);\n+    }\n+\n+    assert_eq!(x.get(), 0);\n+}"}, {"sha": "5ef30b1a8898a563f5a8da9003dba2fee3bbe7be", "filename": "library/core/tests/slice.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/734c57d45c3b3d6ff19bc7d04ce00f7c9441c368/library%2Fcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734c57d45c3b3d6ff19bc7d04ce00f7c9441c368/library%2Fcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fslice.rs?ref=734c57d45c3b3d6ff19bc7d04ce00f7c9441c368", "patch": "@@ -1,3 +1,4 @@\n+use core::cell::Cell;\n use core::result::Result::{Err, Ok};\n \n #[test]\n@@ -1980,3 +1981,30 @@ fn test_is_sorted() {\n     assert!(![\"c\", \"bb\", \"aaa\"].is_sorted());\n     assert!([\"c\", \"bb\", \"aaa\"].is_sorted_by_key(|s| s.len()));\n }\n+\n+#[test]\n+fn test_slice_run_destructors() {\n+    // Make sure that destructors get run on slice literals\n+    struct Foo<'a> {\n+        x: &'a Cell<isize>,\n+    }\n+\n+    impl<'a> Drop for Foo<'a> {\n+        fn drop(&mut self) {\n+            self.x.set(self.x.get() + 1);\n+        }\n+    }\n+\n+    fn foo(x: &Cell<isize>) -> Foo<'_> {\n+        Foo { x }\n+    }\n+\n+    let x = &Cell::new(0);\n+\n+    {\n+        let l = &[foo(x)];\n+        assert_eq!(l[0].x.get(), 0);\n+    }\n+\n+    assert_eq!(x.get(), 1);\n+}"}, {"sha": "4281867314cca7b366db0f0682a1c9e96ccd41c4", "filename": "library/std/src/panic.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/734c57d45c3b3d6ff19bc7d04ce00f7c9441c368/library%2Fstd%2Fsrc%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734c57d45c3b3d6ff19bc7d04ce00f7c9441c368/library%2Fstd%2Fsrc%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpanic.rs?ref=734c57d45c3b3d6ff19bc7d04ce00f7c9441c368", "patch": "@@ -411,3 +411,6 @@ pub fn catch_unwind<F: FnOnce() -> R + UnwindSafe, R>(f: F) -> Result<R> {\n pub fn resume_unwind(payload: Box<dyn Any + Send>) -> ! {\n     panicking::rust_panic_without_hook(payload)\n }\n+\n+#[cfg(test)]\n+mod tests;"}, {"sha": "b37d74011cc671096e38eab8b66c1508516c0102", "filename": "library/std/src/panic/tests.rs", "status": "renamed", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/734c57d45c3b3d6ff19bc7d04ce00f7c9441c368/library%2Fstd%2Fsrc%2Fpanic%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734c57d45c3b3d6ff19bc7d04ce00f7c9441c368/library%2Fstd%2Fsrc%2Fpanic%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpanic%2Ftests.rs?ref=734c57d45c3b3d6ff19bc7d04ce00f7c9441c368", "patch": "@@ -1,16 +1,18 @@\n-// run-pass\n #![allow(dead_code)]\n \n-use std::panic::{UnwindSafe, AssertUnwindSafe};\n-use std::cell::RefCell;\n-use std::sync::{Mutex, RwLock, Arc};\n-use std::rc::Rc;\n+use crate::cell::RefCell;\n+use crate::panic::{AssertUnwindSafe, UnwindSafe};\n+use crate::rc::Rc;\n+use crate::sync::{Arc, Mutex, RwLock};\n \n-struct Foo { a: i32 }\n+struct Foo {\n+    a: i32,\n+}\n \n fn assert<T: UnwindSafe + ?Sized>() {}\n \n-fn main() {\n+#[test]\n+fn panic_safety_traits() {\n     assert::<i32>();\n     assert::<&i32>();\n     assert::<*mut i32>();\n@@ -32,13 +34,16 @@ fn main() {\n     assert::<Arc<i32>>();\n     assert::<Box<[u8]>>();\n \n-    trait Trait: UnwindSafe {}\n-    assert::<Box<dyn Trait>>();\n+    {\n+        trait Trait: UnwindSafe {}\n+        assert::<Box<dyn Trait>>();\n+    }\n \n     fn bar<T>() {\n         assert::<Mutex<T>>();\n         assert::<RwLock<T>>();\n     }\n+\n     fn baz<T: UnwindSafe>() {\n         assert::<Box<T>>();\n         assert::<Vec<T>>();", "previous_filename": "src/test/ui/panics/panic-safe.rs"}, {"sha": "c262b5a1ff09e66896260dad7899f3d1a1bf3cad", "filename": "src/test/ui/array-slice-vec/arr_cycle.rs", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/535d27ac9a3d45dd92769f4d4c7b9f454d1077ea/src%2Ftest%2Fui%2Farray-slice-vec%2Farr_cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/535d27ac9a3d45dd92769f4d4c7b9f454d1077ea/src%2Ftest%2Fui%2Farray-slice-vec%2Farr_cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Farr_cycle.rs?ref=535d27ac9a3d45dd92769f4d4c7b9f454d1077ea", "patch": "@@ -1,31 +0,0 @@\n-// run-pass\n-\n-use std::cell::Cell;\n-\n-#[derive(Debug)]\n-struct B<'a> {\n-    a: [Cell<Option<&'a B<'a>>>; 2]\n-}\n-\n-impl<'a> B<'a> {\n-    fn new() -> B<'a> {\n-        B { a: [Cell::new(None), Cell::new(None)] }\n-    }\n-}\n-\n-fn f() {\n-    let (b1, b2, b3);\n-    b1 = B::new();\n-    b2 = B::new();\n-    b3 = B::new();\n-    b1.a[0].set(Some(&b2));\n-    b1.a[1].set(Some(&b3));\n-    b2.a[0].set(Some(&b2));\n-    b2.a[1].set(Some(&b3));\n-    b3.a[0].set(Some(&b1));\n-    b3.a[1].set(Some(&b2));\n-}\n-\n-fn main() {\n-    f();\n-}"}, {"sha": "3a9ea86af34bbf3098edcce4f24c9b219acc4282", "filename": "src/test/ui/array-slice-vec/vec-slice-drop.rs", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/535d27ac9a3d45dd92769f4d4c7b9f454d1077ea/src%2Ftest%2Fui%2Farray-slice-vec%2Fvec-slice-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/535d27ac9a3d45dd92769f4d4c7b9f454d1077ea/src%2Ftest%2Fui%2Farray-slice-vec%2Fvec-slice-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Fvec-slice-drop.rs?ref=535d27ac9a3d45dd92769f4d4c7b9f454d1077ea", "patch": "@@ -1,31 +0,0 @@\n-// run-pass\n-\n-#![allow(non_camel_case_types)]\n-\n-use std::cell::Cell;\n-\n-// Make sure that destructors get run on slice literals\n-struct foo<'a> {\n-    x: &'a Cell<isize>,\n-}\n-\n-impl<'a> Drop for foo<'a> {\n-    fn drop(&mut self) {\n-        self.x.set(self.x.get() + 1);\n-    }\n-}\n-\n-fn foo(x: &Cell<isize>) -> foo {\n-    foo {\n-        x: x\n-    }\n-}\n-\n-pub fn main() {\n-    let x = &Cell::new(0);\n-    {\n-        let l = &[foo(x)];\n-        assert_eq!(l[0].x.get(), 0);\n-    }\n-    assert_eq!(x.get(), 1);\n-}"}, {"sha": "82bce437282628cf7f41ad34b870006fd94c9e5d", "filename": "src/test/ui/array-slice-vec/vec_cycle.rs", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/535d27ac9a3d45dd92769f4d4c7b9f454d1077ea/src%2Ftest%2Fui%2Farray-slice-vec%2Fvec_cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/535d27ac9a3d45dd92769f4d4c7b9f454d1077ea/src%2Ftest%2Fui%2Farray-slice-vec%2Fvec_cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Fvec_cycle.rs?ref=535d27ac9a3d45dd92769f4d4c7b9f454d1077ea", "patch": "@@ -1,39 +0,0 @@\n-// run-pass\n-\n-use std::cell::Cell;\n-\n-#[derive(Debug)]\n-struct C<'a> {\n-    v: Vec<Cell<Option<&'a C<'a>>>>,\n-}\n-\n-impl<'a> C<'a> {\n-    fn new() -> C<'a> {\n-        C { v: Vec::new() }\n-    }\n-}\n-\n-fn f() {\n-    let (mut c1, mut c2, mut c3);\n-    c1 = C::new();\n-    c2 = C::new();\n-    c3 = C::new();\n-\n-    c1.v.push(Cell::new(None));\n-    c1.v.push(Cell::new(None));\n-    c2.v.push(Cell::new(None));\n-    c2.v.push(Cell::new(None));\n-    c3.v.push(Cell::new(None));\n-    c3.v.push(Cell::new(None));\n-\n-    c1.v[0].set(Some(&c2));\n-    c1.v[1].set(Some(&c3));\n-    c2.v[0].set(Some(&c2));\n-    c2.v[1].set(Some(&c3));\n-    c3.v[0].set(Some(&c1));\n-    c3.v[1].set(Some(&c2));\n-}\n-\n-fn main() {\n-    f();\n-}"}, {"sha": "1a3606d5e8d5af87c0cf5565f8c4dda8ce1abbb3", "filename": "src/test/ui/array-slice-vec/vec_cycle_wrapped.rs", "status": "removed", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/535d27ac9a3d45dd92769f4d4c7b9f454d1077ea/src%2Ftest%2Fui%2Farray-slice-vec%2Fvec_cycle_wrapped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/535d27ac9a3d45dd92769f4d4c7b9f454d1077ea/src%2Ftest%2Fui%2Farray-slice-vec%2Fvec_cycle_wrapped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Fvec_cycle_wrapped.rs?ref=535d27ac9a3d45dd92769f4d4c7b9f454d1077ea", "patch": "@@ -1,50 +0,0 @@\n-// run-pass\n-\n-use std::cell::Cell;\n-\n-#[derive(Debug)]\n-struct Refs<'a> {\n-    v: Vec<Cell<Option<&'a C<'a>>>>,\n-}\n-\n-#[derive(Debug)]\n-struct C<'a> {\n-    refs: Refs<'a>,\n-}\n-\n-impl<'a> Refs<'a> {\n-    fn new() -> Refs<'a> {\n-        Refs { v: Vec::new() }\n-    }\n-}\n-\n-impl<'a> C<'a> {\n-    fn new() -> C<'a> {\n-        C { refs: Refs::new() }\n-    }\n-}\n-\n-fn f() {\n-    let (mut c1, mut c2, mut c3);\n-    c1 = C::new();\n-    c2 = C::new();\n-    c3 = C::new();\n-\n-    c1.refs.v.push(Cell::new(None));\n-    c1.refs.v.push(Cell::new(None));\n-    c2.refs.v.push(Cell::new(None));\n-    c2.refs.v.push(Cell::new(None));\n-    c3.refs.v.push(Cell::new(None));\n-    c3.refs.v.push(Cell::new(None));\n-\n-    c1.refs.v[0].set(Some(&c2));\n-    c1.refs.v[1].set(Some(&c3));\n-    c2.refs.v[0].set(Some(&c2));\n-    c2.refs.v[1].set(Some(&c3));\n-    c3.refs.v[0].set(Some(&c1));\n-    c3.refs.v[1].set(Some(&c2));\n-}\n-\n-fn main() {\n-    f();\n-}"}, {"sha": "587447b54b7fdc038eced045ea862bf0108ed87d", "filename": "src/test/ui/cell-does-not-clone.rs", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/535d27ac9a3d45dd92769f4d4c7b9f454d1077ea/src%2Ftest%2Fui%2Fcell-does-not-clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/535d27ac9a3d45dd92769f4d4c7b9f454d1077ea/src%2Ftest%2Fui%2Fcell-does-not-clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcell-does-not-clone.rs?ref=535d27ac9a3d45dd92769f4d4c7b9f454d1077ea", "patch": "@@ -1,26 +0,0 @@\n-// run-pass\n-\n-#![allow(dead_code)]\n-\n-use std::cell::Cell;\n-\n-#[derive(Copy)]\n-struct Foo {\n-    x: isize\n-}\n-\n-impl Clone for Foo {\n-    fn clone(&self) -> Foo {\n-        // Using Cell in any way should never cause clone() to be\n-        // invoked -- after all, that would permit evil user code to\n-        // abuse `Cell` and trigger crashes.\n-\n-        panic!();\n-    }\n-}\n-\n-pub fn main() {\n-    let x = Cell::new(Foo { x: 22 });\n-    let _y = x.get();\n-    let _z = x.clone();\n-}"}, {"sha": "f57872f80e02504789e94b1deda3f70eea44902b", "filename": "src/test/ui/deref-lval.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/535d27ac9a3d45dd92769f4d4c7b9f454d1077ea/src%2Ftest%2Fui%2Fderef-lval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/535d27ac9a3d45dd92769f4d4c7b9f454d1077ea/src%2Ftest%2Fui%2Fderef-lval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderef-lval.rs?ref=535d27ac9a3d45dd92769f4d4c7b9f454d1077ea", "patch": "@@ -1,11 +0,0 @@\n-// run-pass\n-\n-#![feature(box_syntax)]\n-\n-use std::cell::Cell;\n-\n-pub fn main() {\n-    let x: Box<_> = box Cell::new(5);\n-    x.set(1000);\n-    println!(\"{}\", x.get());\n-}"}, {"sha": "6f2c37926bea65167b0952d2aa3f804df25fa472", "filename": "src/test/ui/exterior.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/535d27ac9a3d45dd92769f4d4c7b9f454d1077ea/src%2Ftest%2Fui%2Fexterior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/535d27ac9a3d45dd92769f4d4c7b9f454d1077ea/src%2Ftest%2Fui%2Fexterior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexterior.rs?ref=535d27ac9a3d45dd92769f4d4c7b9f454d1077ea", "patch": "@@ -1,24 +0,0 @@\n-// run-pass\n-\n-#![allow(dead_code)]\n-\n-\n-use std::cell::Cell;\n-\n-#[derive(Copy, Clone)]\n-struct Point {x: isize, y: isize, z: isize}\n-\n-fn f(p: &Cell<Point>) {\n-    assert_eq!(p.get().z, 12);\n-    p.set(Point {x: 10, y: 11, z: 13});\n-    assert_eq!(p.get().z, 13);\n-}\n-\n-pub fn main() {\n-    let a: Point = Point {x: 10, y: 11, z: 12};\n-    let b: &Cell<Point> = &Cell::new(a);\n-    assert_eq!(b.get().z, 12);\n-    f(b);\n-    assert_eq!(a.z, 12);\n-    assert_eq!(b.get().z, 13);\n-}"}, {"sha": "afb2f8488b82aface3710befbc68562149b5542b", "filename": "src/test/ui/format-ref-cell.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/535d27ac9a3d45dd92769f4d4c7b9f454d1077ea/src%2Ftest%2Fui%2Fformat-ref-cell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/535d27ac9a3d45dd92769f4d4c7b9f454d1077ea/src%2Ftest%2Fui%2Fformat-ref-cell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fformat-ref-cell.rs?ref=535d27ac9a3d45dd92769f4d4c7b9f454d1077ea", "patch": "@@ -1,10 +0,0 @@\n-// run-pass\n-\n-use std::cell::RefCell;\n-\n-pub fn main() {\n-    let name = RefCell::new(\"rust\");\n-    let what = RefCell::new(\"rocks\");\n-    let msg = format!(\"{name} {}\", &*what.borrow(), name=&*name.borrow());\n-    assert_eq!(msg, \"rust rocks\".to_string());\n-}"}, {"sha": "27ab3d6b7abffe921e2a30ad1fc9b74987341b41", "filename": "src/test/ui/ifmt.rs", "status": "removed", "additions": 0, "deletions": 319, "changes": 319, "blob_url": "https://github.com/rust-lang/rust/blob/535d27ac9a3d45dd92769f4d4c7b9f454d1077ea/src%2Ftest%2Fui%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/535d27ac9a3d45dd92769f4d4c7b9f454d1077ea/src%2Ftest%2Fui%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fifmt.rs?ref=535d27ac9a3d45dd92769f4d4c7b9f454d1077ea", "patch": "@@ -1,319 +0,0 @@\n-// run-pass\n-\n-#![deny(warnings)]\n-#![allow(unused_must_use)]\n-#![allow(unused_features)]\n-#![feature(box_syntax)]\n-\n-use std::cell::RefCell;\n-use std::fmt::{self, Write};\n-use std::usize;\n-\n-struct A;\n-struct B;\n-struct C;\n-struct D;\n-\n-impl fmt::LowerHex for A {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.write_str(\"aloha\")\n-    }\n-}\n-impl fmt::UpperHex for B {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.write_str(\"adios\")\n-    }\n-}\n-impl fmt::Display for C {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.pad_integral(true, \"\u2603\", \"123\")\n-    }\n-}\n-impl fmt::Binary for D {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.write_str(\"aa\")?;\n-        f.write_char('\u2603')?;\n-        f.write_str(\"bb\")\n-    }\n-}\n-\n-macro_rules! t {\n-    ($a:expr, $b:expr) => { assert_eq!($a, $b) }\n-}\n-\n-pub fn main() {\n-    // Various edge cases without formats\n-    t!(format!(\"\"), \"\");\n-    t!(format!(\"hello\"), \"hello\");\n-    t!(format!(\"hello {{\"), \"hello {\");\n-\n-    // default formatters should work\n-    t!(format!(\"{}\", 1.0f32), \"1\");\n-    t!(format!(\"{}\", 1.0f64), \"1\");\n-    t!(format!(\"{}\", \"a\"), \"a\");\n-    t!(format!(\"{}\", \"a\".to_string()), \"a\");\n-    t!(format!(\"{}\", false), \"false\");\n-    t!(format!(\"{}\", 'a'), \"a\");\n-\n-    // At least exercise all the formats\n-    t!(format!(\"{}\", true), \"true\");\n-    t!(format!(\"{}\", '\u2603'), \"\u2603\");\n-    t!(format!(\"{}\", 10), \"10\");\n-    t!(format!(\"{}\", 10_usize), \"10\");\n-    t!(format!(\"{:?}\", '\u2603'), \"'\u2603'\");\n-    t!(format!(\"{:?}\", 10), \"10\");\n-    t!(format!(\"{:?}\", 10_usize), \"10\");\n-    t!(format!(\"{:?}\", \"true\"), \"\\\"true\\\"\");\n-    t!(format!(\"{:?}\", \"foo\\nbar\"), \"\\\"foo\\\\nbar\\\"\");\n-    t!(format!(\"{:?}\", \"foo\\n\\\"bar\\\"\\r\\n\\'baz\\'\\t\\\\qux\\\\\"),\n-       r#\"\"foo\\n\\\"bar\\\"\\r\\n\\'baz\\'\\t\\\\qux\\\\\"\"#);\n-    t!(format!(\"{:?}\", \"foo\\0bar\\x01baz\\u{7f}q\\u{75}x\"),\n-       r#\"\"foo\\u{0}bar\\u{1}baz\\u{7f}qux\"\"#);\n-    t!(format!(\"{:o}\", 10_usize), \"12\");\n-    t!(format!(\"{:x}\", 10_usize), \"a\");\n-    t!(format!(\"{:X}\", 10_usize), \"A\");\n-    t!(format!(\"{}\", \"foo\"), \"foo\");\n-    t!(format!(\"{}\", \"foo\".to_string()), \"foo\");\n-    if cfg!(target_pointer_width = \"32\") {\n-        t!(format!(\"{:#p}\", 0x1234 as *const isize), \"0x00001234\");\n-        t!(format!(\"{:#p}\", 0x1234 as *mut isize), \"0x00001234\");\n-    } else {\n-        t!(format!(\"{:#p}\", 0x1234 as *const isize), \"0x0000000000001234\");\n-        t!(format!(\"{:#p}\", 0x1234 as *mut isize), \"0x0000000000001234\");\n-    }\n-    t!(format!(\"{:p}\", 0x1234 as *const isize), \"0x1234\");\n-    t!(format!(\"{:p}\", 0x1234 as *mut isize), \"0x1234\");\n-    t!(format!(\"{:x}\", A), \"aloha\");\n-    t!(format!(\"{:X}\", B), \"adios\");\n-    t!(format!(\"foo {} \u2603\u2603\u2603\u2603\u2603\u2603\", \"bar\"), \"foo bar \u2603\u2603\u2603\u2603\u2603\u2603\");\n-    t!(format!(\"{1} {0}\", 0, 1), \"1 0\");\n-    t!(format!(\"{foo} {bar}\", foo=0, bar=1), \"0 1\");\n-    t!(format!(\"{foo} {1} {bar} {0}\", 0, 1, foo=2, bar=3), \"2 1 3 0\");\n-    t!(format!(\"{} {0}\", \"a\"), \"a a\");\n-    t!(format!(\"{_foo}\", _foo = 6usize), \"6\");\n-    t!(format!(\"{foo_bar}\", foo_bar=1), \"1\");\n-    t!(format!(\"{}\", 5 + 5), \"10\");\n-    t!(format!(\"{:#4}\", C), \"\u2603123\");\n-    t!(format!(\"{:b}\", D), \"aa\u2603bb\");\n-\n-    let a: &dyn fmt::Debug = &1;\n-    t!(format!(\"{:?}\", a), \"1\");\n-\n-    // Formatting strings and their arguments\n-    t!(format!(\"{}\", \"a\"), \"a\");\n-    t!(format!(\"{:4}\", \"a\"), \"a   \");\n-    t!(format!(\"{:4}\", \"\u2603\"), \"\u2603   \");\n-    t!(format!(\"{:>4}\", \"a\"), \"   a\");\n-    t!(format!(\"{:<4}\", \"a\"), \"a   \");\n-    t!(format!(\"{:^5}\", \"a\"),  \"  a  \");\n-    t!(format!(\"{:^5}\", \"aa\"), \" aa  \");\n-    t!(format!(\"{:^4}\", \"a\"),  \" a  \");\n-    t!(format!(\"{:^4}\", \"aa\"), \" aa \");\n-    t!(format!(\"{:.4}\", \"a\"), \"a\");\n-    t!(format!(\"{:4.4}\", \"a\"), \"a   \");\n-    t!(format!(\"{:4.4}\", \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n-    t!(format!(\"{:<4.4}\", \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n-    t!(format!(\"{:>4.4}\", \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n-    t!(format!(\"{:^4.4}\", \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n-    t!(format!(\"{:>10.4}\", \"aaaaaaaaaaaaaaaaaa\"), \"      aaaa\");\n-    t!(format!(\"{:2.4}\", \"aaaaa\"), \"aaaa\");\n-    t!(format!(\"{:2.4}\", \"aaaa\"), \"aaaa\");\n-    t!(format!(\"{:2.4}\", \"aaa\"), \"aaa\");\n-    t!(format!(\"{:2.4}\", \"aa\"), \"aa\");\n-    t!(format!(\"{:2.4}\", \"a\"), \"a \");\n-    t!(format!(\"{:0>2}\", \"a\"), \"0a\");\n-    t!(format!(\"{:.*}\", 4, \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n-    t!(format!(\"{:.1$}\", \"aaaaaaaaaaaaaaaaaa\", 4), \"aaaa\");\n-    t!(format!(\"{:.a$}\", \"aaaaaaaaaaaaaaaaaa\", a=4), \"aaaa\");\n-    t!(format!(\"{:._a$}\", \"aaaaaaaaaaaaaaaaaa\", _a=4), \"aaaa\");\n-    t!(format!(\"{:1$}\", \"a\", 4), \"a   \");\n-    t!(format!(\"{1:0$}\", 4, \"a\"), \"a   \");\n-    t!(format!(\"{:a$}\", \"a\", a=4), \"a   \");\n-    t!(format!(\"{:-#}\", \"a\"), \"a\");\n-    t!(format!(\"{:+#}\", \"a\"), \"a\");\n-    t!(format!(\"{:/^10.8}\", \"1234567890\"), \"/12345678/\");\n-\n-    // Some float stuff\n-    t!(format!(\"{:}\", 1.0f32), \"1\");\n-    t!(format!(\"{:}\", 1.0f64), \"1\");\n-    t!(format!(\"{:.3}\", 1.0f64), \"1.000\");\n-    t!(format!(\"{:10.3}\", 1.0f64),   \"     1.000\");\n-    t!(format!(\"{:+10.3}\", 1.0f64),  \"    +1.000\");\n-    t!(format!(\"{:+10.3}\", -1.0f64), \"    -1.000\");\n-\n-    t!(format!(\"{:e}\", 1.2345e6f32), \"1.2345e6\");\n-    t!(format!(\"{:e}\", 1.2345e6f64), \"1.2345e6\");\n-    t!(format!(\"{:E}\", 1.2345e6f64), \"1.2345E6\");\n-    t!(format!(\"{:.3e}\", 1.2345e6f64), \"1.234e6\");\n-    t!(format!(\"{:10.3e}\", 1.2345e6f64),   \"   1.234e6\");\n-    t!(format!(\"{:+10.3e}\", 1.2345e6f64),  \"  +1.234e6\");\n-    t!(format!(\"{:+10.3e}\", -1.2345e6f64), \"  -1.234e6\");\n-\n-    // Float edge cases\n-    t!(format!(\"{}\", -0.0), \"0\");\n-    t!(format!(\"{:?}\", -0.0), \"-0.0\");\n-    t!(format!(\"{:?}\", 0.0), \"0.0\");\n-\n-    // sign aware zero padding\n-    t!(format!(\"{:<3}\", 1), \"1  \");\n-    t!(format!(\"{:>3}\", 1), \"  1\");\n-    t!(format!(\"{:^3}\", 1), \" 1 \");\n-    t!(format!(\"{:03}\", 1), \"001\");\n-    t!(format!(\"{:<03}\", 1), \"001\");\n-    t!(format!(\"{:>03}\", 1), \"001\");\n-    t!(format!(\"{:^03}\", 1), \"001\");\n-    t!(format!(\"{:+03}\", 1), \"+01\");\n-    t!(format!(\"{:<+03}\", 1), \"+01\");\n-    t!(format!(\"{:>+03}\", 1), \"+01\");\n-    t!(format!(\"{:^+03}\", 1), \"+01\");\n-    t!(format!(\"{:#05x}\", 1), \"0x001\");\n-    t!(format!(\"{:<#05x}\", 1), \"0x001\");\n-    t!(format!(\"{:>#05x}\", 1), \"0x001\");\n-    t!(format!(\"{:^#05x}\", 1), \"0x001\");\n-    t!(format!(\"{:05}\", 1.2), \"001.2\");\n-    t!(format!(\"{:<05}\", 1.2), \"001.2\");\n-    t!(format!(\"{:>05}\", 1.2), \"001.2\");\n-    t!(format!(\"{:^05}\", 1.2), \"001.2\");\n-    t!(format!(\"{:05}\", -1.2), \"-01.2\");\n-    t!(format!(\"{:<05}\", -1.2), \"-01.2\");\n-    t!(format!(\"{:>05}\", -1.2), \"-01.2\");\n-    t!(format!(\"{:^05}\", -1.2), \"-01.2\");\n-    t!(format!(\"{:+05}\", 1.2), \"+01.2\");\n-    t!(format!(\"{:<+05}\", 1.2), \"+01.2\");\n-    t!(format!(\"{:>+05}\", 1.2), \"+01.2\");\n-    t!(format!(\"{:^+05}\", 1.2), \"+01.2\");\n-\n-    // Ergonomic format_args!\n-    t!(format!(\"{0:x} {0:X}\", 15), \"f F\");\n-    t!(format!(\"{0:x} {0:X} {}\", 15), \"f F 15\");\n-    t!(format!(\"{:x}{0:X}{a:x}{:X}{1:x}{a:X}\", 13, 14, a=15), \"dDfEeF\");\n-    t!(format!(\"{a:x} {a:X}\", a=15), \"f F\");\n-\n-    // And its edge cases\n-    t!(format!(\"{a:.0$} {b:.0$} {0:.0$}\\n{a:.c$} {b:.c$} {c:.c$}\",\n-               4, a=\"abcdefg\", b=\"hijklmn\", c=3),\n-               \"abcd hijk 4\\nabc hij 3\");\n-    t!(format!(\"{a:.*} {0} {:.*}\", 4, 3, \"efgh\", a=\"abcdef\"), \"abcd 4 efg\");\n-    t!(format!(\"{:.a$} {a} {a:#x}\", \"aaaaaa\", a=2), \"aa 2 0x2\");\n-\n-    // Test that pointers don't get truncated.\n-    {\n-        let val = usize::MAX;\n-        let exp = format!(\"{:#x}\", val);\n-        t!(format!(\"{:p}\", val as *const isize), exp);\n-    }\n-\n-    // Escaping\n-    t!(format!(\"{{\"), \"{\");\n-    t!(format!(\"}}\"), \"}\");\n-\n-    test_write();\n-    test_print();\n-    test_order();\n-    test_once();\n-\n-    // make sure that format! doesn't move out of local variables\n-    let a: Box<_> = box 3;\n-    format!(\"{}\", a);\n-    format!(\"{}\", a);\n-\n-    // make sure that format! doesn't cause spurious unused-unsafe warnings when\n-    // it's inside of an outer unsafe block\n-    unsafe {\n-        let a: isize = ::std::mem::transmute(3_usize);\n-        format!(\"{}\", a);\n-    }\n-\n-    test_format_args();\n-\n-    // test that trailing commas are acceptable\n-    format!(\"{}\", \"test\",);\n-    format!(\"{foo}\", foo=\"test\",);\n-\n-    test_refcell();\n-}\n-\n-// Basic test to make sure that we can invoke the `write!` macro with an\n-// fmt::Write instance.\n-fn test_write() {\n-    let mut buf = String::new();\n-    write!(&mut buf, \"{}\", 3);\n-    {\n-        let w = &mut buf;\n-        write!(w, \"{foo}\", foo=4);\n-        write!(w, \"{}\", \"hello\");\n-        writeln!(w, \"{}\", \"line\");\n-        writeln!(w, \"{foo}\", foo=\"bar\");\n-        w.write_char('\u2603');\n-        w.write_str(\"str\");\n-    }\n-\n-    t!(buf, \"34helloline\\nbar\\n\u2603str\");\n-}\n-\n-// Just make sure that the macros are defined, there's not really a lot that we\n-// can do with them just yet (to test the output)\n-fn test_print() {\n-    print!(\"hi\");\n-    print!(\"{:?}\", vec![0u8]);\n-    println!(\"hello\");\n-    println!(\"this is a {}\", \"test\");\n-    println!(\"{foo}\", foo=\"bar\");\n-}\n-\n-// Just make sure that the macros are defined, there's not really a lot that we\n-// can do with them just yet (to test the output)\n-fn test_format_args() {\n-    let mut buf = String::new();\n-    {\n-        let w = &mut buf;\n-        write!(w, \"{}\", format_args!(\"{}\", 1));\n-        write!(w, \"{}\", format_args!(\"test\"));\n-        write!(w, \"{}\", format_args!(\"{test}\", test=3));\n-    }\n-    let s = buf;\n-    t!(s, \"1test3\");\n-\n-    let s = fmt::format(format_args!(\"hello {}\", \"world\"));\n-    t!(s, \"hello world\");\n-    let s = format!(\"{}: {}\", \"args were\", format_args!(\"hello {}\", \"world\"));\n-    t!(s, \"args were: hello world\");\n-}\n-\n-fn test_order() {\n-    // Make sure format!() arguments are always evaluated in a left-to-right\n-    // ordering\n-    fn foo() -> isize {\n-        static mut FOO: isize = 0;\n-        unsafe {\n-            FOO += 1;\n-            FOO\n-        }\n-    }\n-    assert_eq!(format!(\"{} {} {a} {b} {} {c}\",\n-                       foo(), foo(), foo(), a=foo(), b=foo(), c=foo()),\n-               \"1 2 4 5 3 6\".to_string());\n-}\n-\n-fn test_once() {\n-    // Make sure each argument are evaluated only once even though it may be\n-    // formatted multiple times\n-    fn foo() -> isize {\n-        static mut FOO: isize = 0;\n-        unsafe {\n-            FOO += 1;\n-            FOO\n-        }\n-    }\n-    assert_eq!(format!(\"{0} {0} {0} {a} {a} {a}\", foo(), a=foo()),\n-               \"1 1 1 2 2 2\".to_string());\n-}\n-\n-fn test_refcell() {\n-    let refcell = RefCell::new(5);\n-    assert_eq!(format!(\"{:?}\", refcell), \"RefCell { value: 5 }\");\n-    let borrow = refcell.borrow_mut();\n-    assert_eq!(format!(\"{:?}\", refcell), \"RefCell { value: <borrowed> }\");\n-    drop(borrow);\n-    assert_eq!(format!(\"{:?}\", refcell), \"RefCell { value: 5 }\");\n-}"}, {"sha": "a76fa2408bb8a4c26caac427f6302ece1d3c17cf", "filename": "src/test/ui/iterators/iter-zip.rs", "status": "removed", "additions": 0, "deletions": 103, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/535d27ac9a3d45dd92769f4d4c7b9f454d1077ea/src%2Ftest%2Fui%2Fiterators%2Fiter-zip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/535d27ac9a3d45dd92769f4d4c7b9f454d1077ea/src%2Ftest%2Fui%2Fiterators%2Fiter-zip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Fiter-zip.rs?ref=535d27ac9a3d45dd92769f4d4c7b9f454d1077ea", "patch": "@@ -1,103 +0,0 @@\n-// run-pass\n-// Test that .zip() specialization preserves side effects\n-// in sideeffectful iterator adaptors.\n-\n-use std::cell::Cell;\n-\n-#[derive(Debug)]\n-struct CountClone(Cell<i32>);\n-\n-fn count_clone() -> CountClone { CountClone(Cell::new(0)) }\n-\n-impl PartialEq<i32> for CountClone {\n-    fn eq(&self, rhs: &i32) -> bool {\n-        self.0.get() == *rhs\n-    }\n-}\n-\n-impl Clone for CountClone {\n-    fn clone(&self) -> Self {\n-        let ret = CountClone(self.0.clone());\n-        let n = self.0.get();\n-        self.0.set(n + 1);\n-        ret\n-    }\n-}\n-\n-fn test_zip_cloned_sideffectful() {\n-    let xs = [count_clone(), count_clone(), count_clone(), count_clone()];\n-    let ys = [count_clone(), count_clone()];\n-\n-    for _ in xs.iter().cloned().zip(ys.iter().cloned()) { }\n-\n-    assert_eq!(&xs, &[1, 1, 1, 0][..]);\n-    assert_eq!(&ys, &[1, 1][..]);\n-\n-    let xs = [count_clone(), count_clone()];\n-    let ys = [count_clone(), count_clone(), count_clone(), count_clone()];\n-\n-    for _ in xs.iter().cloned().zip(ys.iter().cloned()) { }\n-\n-    assert_eq!(&xs, &[1, 1][..]);\n-    assert_eq!(&ys, &[1, 1, 0, 0][..]);\n-}\n-\n-fn test_zip_map_sideffectful() {\n-    let mut xs = [0; 6];\n-    let mut ys = [0; 4];\n-\n-    for _ in xs.iter_mut().map(|x| *x += 1).zip(ys.iter_mut().map(|y| *y += 1)) { }\n-\n-    assert_eq!(&xs, &[1, 1, 1, 1, 1, 0]);\n-    assert_eq!(&ys, &[1, 1, 1, 1]);\n-\n-    let mut xs = [0; 4];\n-    let mut ys = [0; 6];\n-\n-    for _ in xs.iter_mut().map(|x| *x += 1).zip(ys.iter_mut().map(|y| *y += 1)) { }\n-\n-    assert_eq!(&xs, &[1, 1, 1, 1]);\n-    assert_eq!(&ys, &[1, 1, 1, 1, 0, 0]);\n-}\n-\n-fn test_zip_map_rev_sideffectful() {\n-    let mut xs = [0; 6];\n-    let mut ys = [0; 4];\n-\n-    {\n-        let mut it = xs.iter_mut().map(|x| *x += 1).zip(ys.iter_mut().map(|y| *y += 1));\n-        it.next_back();\n-    }\n-    assert_eq!(&xs, &[0, 0, 0, 1, 1, 1]);\n-    assert_eq!(&ys, &[0, 0, 0, 1]);\n-\n-    let mut xs = [0; 6];\n-    let mut ys = [0; 4];\n-\n-    {\n-        let mut it = xs.iter_mut().map(|x| *x += 1).zip(ys.iter_mut().map(|y| *y += 1));\n-        (&mut it).take(5).count();\n-        it.next_back();\n-    }\n-    assert_eq!(&xs, &[1, 1, 1, 1, 1, 1]);\n-    assert_eq!(&ys, &[1, 1, 1, 1]);\n-}\n-\n-fn test_zip_nested_sideffectful() {\n-    let mut xs = [0; 6];\n-    let ys = [0; 4];\n-\n-    {\n-        // test that it has the side effect nested inside enumerate\n-        let it = xs.iter_mut().map(|x| *x = 1).enumerate().zip(&ys);\n-        it.count();\n-    }\n-    assert_eq!(&xs, &[1, 1, 1, 1, 1, 0]);\n-}\n-\n-fn main() {\n-    test_zip_cloned_sideffectful();\n-    test_zip_map_sideffectful();\n-    test_zip_map_rev_sideffectful();\n-    test_zip_nested_sideffectful();\n-}"}, {"sha": "173f803ee24d24941adeb37c8f0830fb0d4d804f", "filename": "src/test/ui/option-unwrap.rs", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/535d27ac9a3d45dd92769f4d4c7b9f454d1077ea/src%2Ftest%2Fui%2Foption-unwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/535d27ac9a3d45dd92769f4d4c7b9f454d1077ea/src%2Ftest%2Fui%2Foption-unwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Foption-unwrap.rs?ref=535d27ac9a3d45dd92769f4d4c7b9f454d1077ea", "patch": "@@ -1,32 +0,0 @@\n-// run-pass\n-\n-#![allow(non_camel_case_types)]\n-use std::cell::Cell;\n-\n-struct dtor<'a> {\n-    x: &'a Cell<isize>,\n-}\n-\n-impl<'a> Drop for dtor<'a> {\n-    fn drop(&mut self) {\n-        self.x.set(self.x.get() - 1);\n-    }\n-}\n-\n-fn unwrap<T>(o: Option<T>) -> T {\n-    match o {\n-      Some(v) => v,\n-      None => panic!()\n-    }\n-}\n-\n-pub fn main() {\n-    let x = &Cell::new(1);\n-\n-    {\n-        let b = Some(dtor { x:x });\n-        let _c = unwrap(b);\n-    }\n-\n-    assert_eq!(x.get(), 0);\n-}"}]}