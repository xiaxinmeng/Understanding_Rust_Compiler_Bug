{"sha": "5dd1677b0a8044097937d507c0f32dbbace80c0a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkZDE2NzdiMGE4MDQ0MDk3OTM3ZDUwN2MwZjMyZGJiYWNlODBjMGE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-04-06T06:42:32Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-04-06T17:58:03Z"}, "message": "rustc: Warn when linking to multiple versions of the same crate\n\nThis is not something most people want to be doing and may\nbe a source of error.", "tree": {"sha": "7be0f9c6e2b4ec1203b78b5f151f4503d53639ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7be0f9c6e2b4ec1203b78b5f151f4503d53639ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5dd1677b0a8044097937d507c0f32dbbace80c0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5dd1677b0a8044097937d507c0f32dbbace80c0a", "html_url": "https://github.com/rust-lang/rust/commit/5dd1677b0a8044097937d507c0f32dbbace80c0a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5dd1677b0a8044097937d507c0f32dbbace80c0a/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "110e02cbc8a2db5e6a5fea94cfc301f3da44b124", "url": "https://api.github.com/repos/rust-lang/rust/commits/110e02cbc8a2db5e6a5fea94cfc301f3da44b124", "html_url": "https://github.com/rust-lang/rust/commit/110e02cbc8a2db5e6a5fea94cfc301f3da44b124"}], "stats": {"total": 90, "additions": 67, "deletions": 23}, "files": [{"sha": "708c4a1ab5c147cfa578b967de2c3b323384cc6a", "filename": "src/rustc/metadata/creader.rs", "status": "modified", "additions": 67, "deletions": 23, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/5dd1677b0a8044097937d507c0f32dbbace80c0a/src%2Frustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd1677b0a8044097937d507c0f32dbbace80c0a/src%2Frustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcreader.rs?ref=5dd1677b0a8044097937d507c0f32dbbace80c0a", "patch": "@@ -28,10 +28,50 @@ fn read_crates(sess: session::session, crate: ast::crate) {\n                                    visit_item: bind visit_item(e, _)\n                                       with *visit::default_simple_visitor()});\n     visit::visit_crate(crate, (), v);\n+    warn_if_multiple_versions(sess, copy e.crate_cache);\n+}\n+\n+type cache_entry = {\n+    cnum: int,\n+    span: span,\n+    metas: @[@ast::meta_item]\n+};\n+\n+fn warn_if_multiple_versions(sess: session::session,\n+                             crate_cache: [cache_entry]) {\n+    import either::*;\n+\n+    if crate_cache.is_not_empty() {\n+        let name = crate_name_from_metas(*crate_cache.last().metas);\n+        let {lefts: matches, rights: non_matches} =\n+            partition(crate_cache.map {|entry|\n+                let othername = crate_name_from_metas(*entry.metas);\n+                if name == othername {\n+                    left(entry)\n+                } else {\n+                    right(entry)\n+                }\n+            });\n+\n+        assert matches.is_not_empty();\n+\n+        if matches.len() != 1u {\n+            sess.warn(#fmt(\"using multiple versions of crate `%s`\", name));\n+            for matches.each {|match|\n+                sess.span_note(match.span, \"used here\");\n+                let attrs = [\n+                    attr::mk_attr(attr::mk_list_item(\"link\", *match.metas))\n+                ];\n+                note_linkage_attrs(sess, attrs);\n+            }\n+        }\n+\n+        warn_if_multiple_versions(sess, non_matches);\n+    }\n }\n \n type env = @{sess: session::session,\n-             mut crate_cache: [(int, @[@ast::meta_item])],\n+             mut crate_cache: [cache_entry],\n              mut next_crate_num: ast::crate_num};\n \n fn visit_view_item(e: env, i: @ast::view_item) {\n@@ -138,28 +178,28 @@ fn default_native_lib_naming(sess: session::session, static: bool) ->\n     }\n }\n \n+fn crate_name_from_metas(metas: [@ast::meta_item]) -> str {\n+    let name_items = attr::find_meta_items_by_name(metas, \"name\");\n+    alt vec::last_opt(name_items) {\n+      some(i) {\n+        alt attr::get_meta_item_value_str(i) {\n+          some(n) { n }\n+          // FIXME: Probably want a warning here since the user\n+          // is using the wrong type of meta item\n+          _ { fail }\n+        }\n+      }\n+      none { fail \"expected to find the crate name\" }\n+    }\n+}\n+\n fn find_library_crate(sess: session::session, span: span,\n                       metas: [@ast::meta_item])\n    -> option<{ident: str, data: @[u8]}> {\n \n     attr::require_unique_names(sess.diagnostic(), metas);\n     let metas = metas;\n-\n-    let crate_name =\n-        {\n-            let name_items = attr::find_meta_items_by_name(metas, \"name\");\n-            alt vec::last_opt(name_items) {\n-              some(i) {\n-                alt attr::get_meta_item_value_str(i) {\n-                  some(n) { n }\n-                  // FIXME: Probably want a warning here since the user\n-                  // is using the wrong type of meta item\n-                  _ { fail }\n-                }\n-              }\n-              none { fail }\n-            }\n-        };\n+    let crate_name = crate_name_from_metas(metas);\n \n     let nn = default_native_lib_naming(sess, sess.opts.static);\n     let x =\n@@ -221,15 +261,19 @@ fn find_library_crate_aux(sess: session::session,\n         for matches.each {|match|\n             sess.note(#fmt(\"path: %s\", match.ident));\n             let attrs = decoder::get_crate_attributes(match.data);\n-            for attr::find_linkage_attrs(attrs).each {|attr|\n-                sess.note(#fmt(\"meta: %s\", pprust::attr_to_str(attr)));\n-            }\n+            note_linkage_attrs(sess, attrs);\n         }\n         sess.abort_if_errors();\n         none\n     }\n }\n \n+fn note_linkage_attrs(sess: session::session, attrs: [ast::attribute]) {\n+    for attr::find_linkage_attrs(attrs).each {|attr|\n+        sess.note(#fmt(\"meta: %s\", pprust::attr_to_str(attr)));\n+    }\n+}\n+\n fn get_metadata_section(sess: session::session,\n                         filename: str) -> option<@[u8]> unsafe {\n     let mb = str::as_c_str(filename, {|buf|\n@@ -282,10 +326,10 @@ fn metas_with_ident(ident: ast::ident,\n \n fn existing_match(e: env, metas: [@ast::meta_item]) -> option<int> {\n     let maybe_entry = e.crate_cache.find {|c|\n-        metadata_matches(*tuple::second(c), metas)\n+        metadata_matches(*c.metas, metas)\n     };\n \n-    maybe_entry.map {|c| tuple::first(c) }\n+    maybe_entry.map {|c| c.cnum }\n }\n \n fn resolve_crate(e: env, ident: ast::ident, metas: [@ast::meta_item],\n@@ -305,7 +349,7 @@ fn resolve_crate(e: env, ident: ast::ident, metas: [@ast::meta_item],\n \n         // Claim this crate number and cache it\n         let cnum = e.next_crate_num;\n-        e.crate_cache += [(cnum, @linkage_metas)];\n+        e.crate_cache += [{cnum: cnum, span: span, metas: @linkage_metas}];\n         e.next_crate_num += 1;\n \n         // Now resolve the crates referenced by this crate"}]}