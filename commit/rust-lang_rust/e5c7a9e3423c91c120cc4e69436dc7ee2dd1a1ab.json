{"sha": "e5c7a9e3423c91c120cc4e69436dc7ee2dd1a1ab", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1YzdhOWUzNDIzYzkxYzEyMGNjNGU2OTQzNmRjN2VlMmRkMWExYWI=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-03-30T00:44:28Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-03-30T00:44:28Z"}, "message": "std: add serialization support for dlist, linearset, triemap, trieset, treemap, and treeset", "tree": {"sha": "a50e87ae70b8e683553442a0a9a81379eee1d5bb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a50e87ae70b8e683553442a0a9a81379eee1d5bb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e5c7a9e3423c91c120cc4e69436dc7ee2dd1a1ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e5c7a9e3423c91c120cc4e69436dc7ee2dd1a1ab", "html_url": "https://github.com/rust-lang/rust/commit/e5c7a9e3423c91c120cc4e69436dc7ee2dd1a1ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e5c7a9e3423c91c120cc4e69436dc7ee2dd1a1ab/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "529ae386056eefdfad04cab8a32d6e88ebbe0e5e", "url": "https://api.github.com/repos/rust-lang/rust/commits/529ae386056eefdfad04cab8a32d6e88ebbe0e5e", "html_url": "https://github.com/rust-lang/rust/commit/529ae386056eefdfad04cab8a32d6e88ebbe0e5e"}], "stats": {"total": 184, "additions": 183, "deletions": 1}, "files": [{"sha": "fb56abc1b643e1f0494801ea8e60bab4da49df63", "filename": "src/libstd/serialize.rs", "status": "modified", "additions": 183, "deletions": 1, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/e5c7a9e3423c91c120cc4e69436dc7ee2dd1a1ab/src%2Flibstd%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5c7a9e3423c91c120cc4e69436dc7ee2dd1a1ab/src%2Flibstd%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialize.rs?ref=e5c7a9e3423c91c120cc4e69436dc7ee2dd1a1ab", "patch": "@@ -17,7 +17,10 @@ Core encoding and decoding interfaces.\n #[forbid(non_camel_case_types)];\n \n use core::prelude::*;\n-use core::hashmap::linear::LinearMap;\n+use core::dlist::DList;\n+use core::hashmap::linear::{LinearMap, LinearSet};\n+use core::trie::{TrieMap, TrieSet};\n+use treemap::{TreeMap, TreeSet};\n \n pub trait Encoder {\n     // Primitive types:\n@@ -531,6 +534,33 @@ impl<\n     }\n }\n \n+impl<\n+    S: Encoder,\n+    T: Encodable<S> + Copy\n+> Encodable<S> for @mut DList<T> {\n+    fn encode(&self, s: &S) {\n+        do s.emit_seq(self.size) {\n+            let mut i = 0;\n+            for self.each |e| {\n+                s.emit_seq_elt(i, || e.encode(s));\n+                i += 1;\n+            }\n+        }\n+    }\n+}\n+\n+impl<D:Decoder,T:Decodable<D>> Decodable<D> for @mut DList<T> {\n+    fn decode(d: &D) -> @mut DList<T> {\n+        let list = DList();\n+        do d.read_seq |len| {\n+            for uint::range(0, len) |i| {\n+                list.push(d.read_seq_elt(i, || Decodable::decode(d)));\n+            }\n+        }\n+        list\n+    }\n+}\n+\n impl<\n     E: Encoder,\n     K: Encodable<E> + Hash + IterBytes + Eq,\n@@ -566,6 +596,158 @@ impl<\n     }\n }\n \n+impl<\n+    S: Encoder,\n+    T: Encodable<S> + Hash + IterBytes + Eq\n+> Encodable<S> for LinearSet<T> {\n+    fn encode(&self, s: &S) {\n+        do s.emit_seq(self.len()) {\n+            let mut i = 0;\n+            for self.each |e| {\n+                s.emit_seq_elt(i, || e.encode(s));\n+                i += 1;\n+            }\n+        }\n+    }\n+}\n+\n+impl<\n+    D: Decoder,\n+    T: Decodable<D> + Hash + IterBytes + Eq\n+> Decodable<D> for LinearSet<T> {\n+    fn decode(d: &D) -> LinearSet<T> {\n+        do d.read_seq |len| {\n+            let mut set = LinearSet::with_capacity(len);\n+            for uint::range(0, len) |i| {\n+                set.insert(d.read_seq_elt(i, || Decodable::decode(d)));\n+            }\n+            set\n+        }\n+    }\n+}\n+\n+impl<\n+    E: Encoder,\n+    V: Encodable<E>\n+> Encodable<E> for TrieMap<V> {\n+    fn encode(&self, e: &E) {\n+        do e.emit_map(self.len()) {\n+            let mut i = 0;\n+            for self.each |&(key, val)| {\n+                e.emit_map_elt_key(i, || key.encode(e));\n+                e.emit_map_elt_val(i, || val.encode(e));\n+                i += 1;\n+            }\n+        }\n+    }\n+}\n+\n+impl<\n+    D: Decoder,\n+    V: Decodable<D>\n+> Decodable<D> for TrieMap<V> {\n+    fn decode(d: &D) -> TrieMap<V> {\n+        do d.read_map |len| {\n+            let mut map = TrieMap::new();\n+            for uint::range(0, len) |i| {\n+                let key = d.read_map_elt_key(i, || Decodable::decode(d));\n+                let val = d.read_map_elt_val(i, || Decodable::decode(d));\n+                map.insert(key, val);\n+            }\n+            map\n+        }\n+    }\n+}\n+\n+impl<S: Encoder> Encodable<S> for TrieSet {\n+    fn encode(&self, s: &S) {\n+        do s.emit_seq(self.len()) {\n+            let mut i = 0;\n+            for self.each |e| {\n+                s.emit_seq_elt(i, || e.encode(s));\n+                i += 1;\n+            }\n+        }\n+    }\n+}\n+\n+impl<D: Decoder> Decodable<D> for TrieSet {\n+    fn decode(d: &D) -> TrieSet {\n+        do d.read_seq |len| {\n+            let mut set = TrieSet::new();\n+            for uint::range(0, len) |i| {\n+                set.insert(d.read_seq_elt(i, || Decodable::decode(d)));\n+            }\n+            set\n+        }\n+    }\n+}\n+\n+impl<\n+    E: Encoder,\n+    K: Encodable<E> + Eq + TotalOrd,\n+    V: Encodable<E> + Eq\n+> Encodable<E> for TreeMap<K, V> {\n+    fn encode(&self, e: &E) {\n+        do e.emit_map(self.len()) {\n+            let mut i = 0;\n+            for self.each |&(key, val)| {\n+                e.emit_map_elt_key(i, || key.encode(e));\n+                e.emit_map_elt_val(i, || val.encode(e));\n+                i += 1;\n+            }\n+        }\n+    }\n+}\n+\n+impl<\n+    D: Decoder,\n+    K: Decodable<D> + Eq + TotalOrd,\n+    V: Decodable<D> + Eq\n+> Decodable<D> for TreeMap<K, V> {\n+    fn decode(d: &D) -> TreeMap<K, V> {\n+        do d.read_map |len| {\n+            let mut map = TreeMap::new();\n+            for uint::range(0, len) |i| {\n+                let key = d.read_map_elt_key(i, || Decodable::decode(d));\n+                let val = d.read_map_elt_val(i, || Decodable::decode(d));\n+                map.insert(key, val);\n+            }\n+            map\n+        }\n+    }\n+}\n+\n+impl<\n+    S: Encoder,\n+    T: Encodable<S> + Eq + TotalOrd\n+> Encodable<S> for TreeSet<T> {\n+    fn encode(&self, s: &S) {\n+        do s.emit_seq(self.len()) {\n+            let mut i = 0;\n+            for self.each |e| {\n+                s.emit_seq_elt(i, || e.encode(s));\n+                i += 1;\n+            }\n+        }\n+    }\n+}\n+\n+impl<\n+    D: Decoder,\n+    T: Decodable<D> + Eq + TotalOrd\n+> Decodable<D> for TreeSet<T> {\n+    fn decode(d: &D) -> TreeSet<T> {\n+        do d.read_seq |len| {\n+            let mut set = TreeSet::new();\n+            for uint::range(0, len) |i| {\n+                set.insert(d.read_seq_elt(i, || Decodable::decode(d)));\n+            }\n+            set\n+        }\n+    }\n+}\n+\n // ___________________________________________________________________________\n // Helper routines\n //"}]}