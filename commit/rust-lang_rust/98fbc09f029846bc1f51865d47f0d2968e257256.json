{"sha": "98fbc09f029846bc1f51865d47f0d2968e257256", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4ZmJjMDlmMDI5ODQ2YmMxZjUxODY1ZDQ3ZjBkMjk2OGUyNTcyNTY=", "commit": {"author": {"name": "\u00d6mer Sinan A\u011facan", "email": "omeragacan@gmail.com", "date": "2021-03-09T10:36:12Z"}, "committer": {"name": "\u00d6mer Sinan A\u011facan", "email": "omeragacan@gmail.com", "date": "2021-03-09T10:40:08Z"}, "message": "Allow calling *const methods on *mut values\n\nFixes #80258", "tree": {"sha": "cf5f9dc76f6d862044653e711448128b4209cda0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf5f9dc76f6d862044653e711448128b4209cda0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98fbc09f029846bc1f51865d47f0d2968e257256", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98fbc09f029846bc1f51865d47f0d2968e257256", "html_url": "https://github.com/rust-lang/rust/commit/98fbc09f029846bc1f51865d47f0d2968e257256", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98fbc09f029846bc1f51865d47f0d2968e257256/comments", "author": {"login": "osa1", "id": 448274, "node_id": "MDQ6VXNlcjQ0ODI3NA==", "avatar_url": "https://avatars.githubusercontent.com/u/448274?v=4", "gravatar_id": "", "url": "https://api.github.com/users/osa1", "html_url": "https://github.com/osa1", "followers_url": "https://api.github.com/users/osa1/followers", "following_url": "https://api.github.com/users/osa1/following{/other_user}", "gists_url": "https://api.github.com/users/osa1/gists{/gist_id}", "starred_url": "https://api.github.com/users/osa1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/osa1/subscriptions", "organizations_url": "https://api.github.com/users/osa1/orgs", "repos_url": "https://api.github.com/users/osa1/repos", "events_url": "https://api.github.com/users/osa1/events{/privacy}", "received_events_url": "https://api.github.com/users/osa1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "osa1", "id": 448274, "node_id": "MDQ6VXNlcjQ0ODI3NA==", "avatar_url": "https://avatars.githubusercontent.com/u/448274?v=4", "gravatar_id": "", "url": "https://api.github.com/users/osa1", "html_url": "https://github.com/osa1", "followers_url": "https://api.github.com/users/osa1/followers", "following_url": "https://api.github.com/users/osa1/following{/other_user}", "gists_url": "https://api.github.com/users/osa1/gists{/gist_id}", "starred_url": "https://api.github.com/users/osa1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/osa1/subscriptions", "organizations_url": "https://api.github.com/users/osa1/orgs", "repos_url": "https://api.github.com/users/osa1/repos", "events_url": "https://api.github.com/users/osa1/events{/privacy}", "received_events_url": "https://api.github.com/users/osa1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b9f5cc4c10a161047475cb9bbe02c4fda57fb07", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b9f5cc4c10a161047475cb9bbe02c4fda57fb07", "html_url": "https://github.com/rust-lang/rust/commit/4b9f5cc4c10a161047475cb9bbe02c4fda57fb07"}], "stats": {"total": 283, "additions": 237, "deletions": 46}, "files": [{"sha": "7a80524f1b79a4b02364d1912df6232777a8f081", "filename": "compiler/rustc_typeck/src/check/method/confirm.rs", "status": "modified", "additions": 39, "deletions": 25, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/98fbc09f029846bc1f51865d47f0d2968e257256/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98fbc09f029846bc1f51865d47f0d2968e257256/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs?ref=98fbc09f029846bc1f51865d47f0d2968e257256", "patch": "@@ -155,32 +155,46 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         let mut target =\n             self.structurally_resolved_type(autoderef.span(), autoderef.final_ty(false));\n \n-        if let Some(mutbl) = pick.autoref {\n-            let region = self.next_region_var(infer::Autoref(self.span, pick.item));\n-            target = self.tcx.mk_ref(region, ty::TypeAndMut { mutbl, ty: target });\n-            let mutbl = match mutbl {\n-                hir::Mutability::Not => AutoBorrowMutability::Not,\n-                hir::Mutability::Mut => AutoBorrowMutability::Mut {\n-                    // Method call receivers are the primary use case\n-                    // for two-phase borrows.\n-                    allow_two_phase_borrow: AllowTwoPhase::Yes,\n-                },\n-            };\n-            adjustments\n-                .push(Adjustment { kind: Adjust::Borrow(AutoBorrow::Ref(region, mutbl)), target });\n-\n-            if let Some(unsize_target) = pick.unsize {\n-                target = self\n-                    .tcx\n-                    .mk_ref(region, ty::TypeAndMut { mutbl: mutbl.into(), ty: unsize_target });\n-                adjustments.push(Adjustment { kind: Adjust::Pointer(PointerCast::Unsize), target });\n+        match &pick.autoref_or_ptr_adjustment {\n+            Some(probe::AutorefOrPtrAdjustment::Autoref { mutbl, unsize }) => {\n+                let region = self.next_region_var(infer::Autoref(self.span, pick.item));\n+                target = self.tcx.mk_ref(region, ty::TypeAndMut { mutbl: *mutbl, ty: target });\n+                let mutbl = match mutbl {\n+                    hir::Mutability::Not => AutoBorrowMutability::Not,\n+                    hir::Mutability::Mut => AutoBorrowMutability::Mut {\n+                        // Method call receivers are the primary use case\n+                        // for two-phase borrows.\n+                        allow_two_phase_borrow: AllowTwoPhase::Yes,\n+                    },\n+                };\n+                adjustments.push(Adjustment {\n+                    kind: Adjust::Borrow(AutoBorrow::Ref(region, mutbl)),\n+                    target,\n+                });\n+\n+                if let Some(unsize_target) = unsize {\n+                    target = self\n+                        .tcx\n+                        .mk_ref(region, ty::TypeAndMut { mutbl: mutbl.into(), ty: unsize_target });\n+                    adjustments\n+                        .push(Adjustment { kind: Adjust::Pointer(PointerCast::Unsize), target });\n+                }\n+            }\n+            Some(probe::AutorefOrPtrAdjustment::ToConstPtr) => {\n+                target = match target.kind() {\n+                    ty::RawPtr(ty::TypeAndMut { ty, mutbl }) => {\n+                        assert_eq!(*mutbl, hir::Mutability::Mut);\n+                        self.tcx.mk_ptr(ty::TypeAndMut { mutbl: hir::Mutability::Not, ty })\n+                    }\n+                    other => panic!(\"Cannot adjust receiver type {:?} to const ptr\", other),\n+                };\n+\n+                adjustments.push(Adjustment {\n+                    kind: Adjust::Pointer(PointerCast::MutToConstPointer),\n+                    target,\n+                });\n             }\n-        } else {\n-            // No unsizing should be performed without autoref (at\n-            // least during method dispach). This is because we\n-            // currently only unsize `[T;N]` to `[T]`, and naturally\n-            // that must occur being a reference.\n-            assert!(pick.unsize.is_none());\n+            None => {}\n         }\n \n         self.register_predicates(autoderef.into_obligations());"}, {"sha": "42d7f4c988db71e7db91eab069f5afec3f849bd6", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 82, "deletions": 21, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/98fbc09f029846bc1f51865d47f0d2968e257256/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98fbc09f029846bc1f51865d47f0d2968e257256/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=98fbc09f029846bc1f51865d47f0d2968e257256", "patch": "@@ -154,6 +154,42 @@ enum ProbeResult {\n     Match,\n }\n \n+/// When adjusting a receiver we often want to do one of\n+///\n+/// - Add a `&` (or `&mut`), converting the recevier from `T` to `&T` (or `&mut T`)\n+/// - If the receiver has type `*mut T`, convert it to `*const T`\n+///\n+/// This type tells us which one to do.\n+///\n+/// Note that in principle we could do both at the same time. For example, when the receiver has\n+/// type `T`, we could autoref it to `&T`, then convert to `*const T`. Or, when it has type `*mut\n+/// T`, we could convert it to `*const T`, then autoref to `&*const T`. However, currently we do\n+/// (at most) one of these. Either the receiver has type `T` and we convert it to `&T` (or with\n+/// `mut`), or it has type `*mut T` and we convert it to `*const T`.\n+#[derive(Debug, PartialEq, Clone)]\n+pub enum AutorefOrPtrAdjustment<'tcx> {\n+    /// Receiver has type `T`, add `&` or `&mut` (it `T` is `mut`), and maybe also \"unsize\" it.\n+    /// Unsizing is used to convert a `[T; N]` to `[T]`, which only makes sense when autorefing.\n+    Autoref {\n+        mutbl: hir::Mutability,\n+\n+        /// Indicates that the source expression should be \"unsized\" to a target type. This should\n+        /// probably eventually go away in favor of just coercing method receivers.\n+        unsize: Option<Ty<'tcx>>,\n+    },\n+    /// Receiver has type `*mut T`, convert to `*const T`\n+    ToConstPtr,\n+}\n+\n+impl<'tcx> AutorefOrPtrAdjustment<'tcx> {\n+    fn get_unsize(&self) -> Option<Ty<'tcx>> {\n+        match self {\n+            AutorefOrPtrAdjustment::Autoref { mutbl: _, unsize } => unsize.clone(),\n+            AutorefOrPtrAdjustment::ToConstPtr => None,\n+        }\n+    }\n+}\n+\n #[derive(Debug, PartialEq, Clone)]\n pub struct Pick<'tcx> {\n     pub item: ty::AssocItem,\n@@ -165,17 +201,9 @@ pub struct Pick<'tcx> {\n     ///     A = expr | *expr | **expr | ...\n     pub autoderefs: usize,\n \n-    /// Indicates that an autoref is applied after the optional autoderefs\n-    ///\n-    ///     B = A | &A | &mut A\n-    pub autoref: Option<hir::Mutability>,\n-\n-    /// Indicates that the source expression should be \"unsized\" to a\n-    /// target type. This should probably eventually go away in favor\n-    /// of just coercing method receivers.\n-    ///\n-    ///     C = B | unsize(B)\n-    pub unsize: Option<Ty<'tcx>>,\n+    /// Indicates that we want to add an autoref (and maybe also unsize it), or if the receiver is\n+    /// `*mut T`, convert it to `*const T`.\n+    pub autoref_or_ptr_adjustment: Option<AutorefOrPtrAdjustment<'tcx>>,\n }\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n@@ -714,16 +742,16 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n \n         debug!(\"assemble_inherent_impl_probe {:?}\", impl_def_id);\n \n+        let (impl_ty, impl_substs) = self.impl_ty_and_substs(impl_def_id);\n+        let impl_ty = impl_ty.subst(self.tcx, impl_substs);\n+\n         for item in self.impl_or_trait_item(impl_def_id) {\n             if !self.has_applicable_self(&item) {\n                 // No receiver declared. Not a candidate.\n                 self.record_static_candidate(ImplSource(impl_def_id));\n                 continue;\n             }\n \n-            let (impl_ty, impl_substs) = self.impl_ty_and_substs(impl_def_id);\n-            let impl_ty = impl_ty.subst(self.tcx, impl_substs);\n-\n             // Determine the receiver type that the method itself expects.\n             let xform_tys = self.xform_self_ty(&item, impl_ty, impl_substs);\n \n@@ -1086,6 +1114,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 self.pick_by_value_method(step, self_ty).or_else(|| {\n                     self.pick_autorefd_method(step, self_ty, hir::Mutability::Not)\n                         .or_else(|| self.pick_autorefd_method(step, self_ty, hir::Mutability::Mut))\n+                        .or_else(|| self.pick_const_ptr_method(step, self_ty))\n                 })\n             })\n             .next()\n@@ -1113,7 +1142,10 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 // Insert a `&*` or `&mut *` if this is a reference type:\n                 if let ty::Ref(_, _, mutbl) = *step.self_ty.value.value.kind() {\n                     pick.autoderefs += 1;\n-                    pick.autoref = Some(mutbl);\n+                    pick.autoref_or_ptr_adjustment = Some(AutorefOrPtrAdjustment::Autoref {\n+                        mutbl,\n+                        unsize: pick.autoref_or_ptr_adjustment.and_then(|a| a.get_unsize()),\n+                    })\n                 }\n \n                 pick\n@@ -1136,8 +1168,39 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         self.pick_method(autoref_ty).map(|r| {\n             r.map(|mut pick| {\n                 pick.autoderefs = step.autoderefs;\n-                pick.autoref = Some(mutbl);\n-                pick.unsize = step.unsize.then_some(self_ty);\n+                pick.autoref_or_ptr_adjustment = Some(AutorefOrPtrAdjustment::Autoref {\n+                    mutbl,\n+                    unsize: step.unsize.then_some(self_ty),\n+                });\n+                pick\n+            })\n+        })\n+    }\n+\n+    /// If `self_ty` is `*mut T` then this picks `*const T` methods. The reason why we have a\n+    /// special case for this is because going from `*mut T` to `*const T` with autoderefs and\n+    /// autorefs would require dereferencing the pointer, which is not safe.\n+    fn pick_const_ptr_method(\n+        &mut self,\n+        step: &CandidateStep<'tcx>,\n+        self_ty: Ty<'tcx>,\n+    ) -> Option<PickResult<'tcx>> {\n+        // Don't convert an unsized reference to ptr\n+        if step.unsize {\n+            return None;\n+        }\n+\n+        let ty = match self_ty.kind() {\n+            ty::RawPtr(ty::TypeAndMut { ty, mutbl: hir::Mutability::Mut }) => ty,\n+            _ => return None,\n+        };\n+\n+        let const_self_ty = ty::TypeAndMut { ty, mutbl: hir::Mutability::Not };\n+        let const_ptr_ty = self.tcx.mk_ptr(const_self_ty);\n+        self.pick_method(const_ptr_ty).map(|r| {\n+            r.map(|mut pick| {\n+                pick.autoderefs = step.autoderefs;\n+                pick.autoref_or_ptr_adjustment = Some(AutorefOrPtrAdjustment::ToConstPtr);\n                 pick\n             })\n         })\n@@ -1510,8 +1573,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             kind: TraitPick,\n             import_ids: probes[0].0.import_ids.clone(),\n             autoderefs: 0,\n-            autoref: None,\n-            unsize: None,\n+            autoref_or_ptr_adjustment: None,\n         })\n     }\n \n@@ -1748,8 +1810,7 @@ impl<'tcx> Candidate<'tcx> {\n             },\n             import_ids: self.import_ids.clone(),\n             autoderefs: 0,\n-            autoref: None,\n-            unsize: None,\n+            autoref_or_ptr_adjustment: None,\n         }\n     }\n }"}, {"sha": "8e2ff0451c63e991020570e28dba08cc86cb9438", "filename": "src/test/mir-opt/receiver-ptr-mutability.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/98fbc09f029846bc1f51865d47f0d2968e257256/src%2Ftest%2Fmir-opt%2Freceiver-ptr-mutability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98fbc09f029846bc1f51865d47f0d2968e257256/src%2Ftest%2Fmir-opt%2Freceiver-ptr-mutability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Freceiver-ptr-mutability.rs?ref=98fbc09f029846bc1f51865d47f0d2968e257256", "patch": "@@ -0,0 +1,20 @@\n+// EMIT_MIR receiver_ptr_mutability.main.mir_map.0.mir\n+\n+#![feature(arbitrary_self_types)]\n+\n+struct Test {}\n+\n+impl Test {\n+    fn x(self: *const Self) {\n+        println!(\"x called\");\n+    }\n+}\n+\n+fn main() {\n+    let ptr: *mut Test = std::ptr::null_mut();\n+    ptr.x();\n+\n+    // Test autoderefs\n+    let ptr_ref: &&&&*mut Test = &&&&ptr;\n+    ptr_ref.x();\n+}"}, {"sha": "d2d96ff468dfc02a8627ece2d9115e87c2be5e35", "filename": "src/test/mir-opt/receiver_ptr_mutability.main.mir_map.0.mir", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/98fbc09f029846bc1f51865d47f0d2968e257256/src%2Ftest%2Fmir-opt%2Freceiver_ptr_mutability.main.mir_map.0.mir", "raw_url": "https://github.com/rust-lang/rust/raw/98fbc09f029846bc1f51865d47f0d2968e257256/src%2Ftest%2Fmir-opt%2Freceiver_ptr_mutability.main.mir_map.0.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Freceiver_ptr_mutability.main.mir_map.0.mir?ref=98fbc09f029846bc1f51865d47f0d2968e257256", "patch": "@@ -0,0 +1,96 @@\n+// MIR for `main` 0 mir_map\n+\n+| User Type Annotations\n+| 0: Canonical { max_universe: U0, variables: [], value: Ty(*mut Test) } at $DIR/receiver-ptr-mutability.rs:14:14: 14:23\n+| 1: Canonical { max_universe: U0, variables: [], value: Ty(*mut Test) } at $DIR/receiver-ptr-mutability.rs:14:14: 14:23\n+| 2: Canonical { max_universe: U0, variables: [CanonicalVarInfo { kind: Region(U0) }, CanonicalVarInfo { kind: Region(U0) }, CanonicalVarInfo { kind: Region(U0) }, CanonicalVarInfo { kind: Region(U0) }], value: Ty(&&&&*mut Test) } at $DIR/receiver-ptr-mutability.rs:18:18: 18:31\n+| 3: Canonical { max_universe: U0, variables: [CanonicalVarInfo { kind: Region(U0) }, CanonicalVarInfo { kind: Region(U0) }, CanonicalVarInfo { kind: Region(U0) }, CanonicalVarInfo { kind: Region(U0) }], value: Ty(&&&&*mut Test) } at $DIR/receiver-ptr-mutability.rs:18:18: 18:31\n+|\n+fn main() -> () {\n+    let mut _0: ();                      // return place in scope 0 at $DIR/receiver-ptr-mutability.rs:13:11: 13:11\n+    let _1: *mut Test as UserTypeProjection { base: UserType(0), projs: [] }; // in scope 0 at $DIR/receiver-ptr-mutability.rs:14:9: 14:12\n+    let _2: ();                          // in scope 0 at $DIR/receiver-ptr-mutability.rs:15:5: 15:12\n+    let mut _3: *const Test;             // in scope 0 at $DIR/receiver-ptr-mutability.rs:15:5: 15:8\n+    let mut _4: *mut Test;               // in scope 0 at $DIR/receiver-ptr-mutability.rs:15:5: 15:8\n+    let _6: &&&&*mut Test;               // in scope 0 at $DIR/receiver-ptr-mutability.rs:18:34: 18:41\n+    let _7: &&&*mut Test;                // in scope 0 at $DIR/receiver-ptr-mutability.rs:18:35: 18:41\n+    let _8: &&*mut Test;                 // in scope 0 at $DIR/receiver-ptr-mutability.rs:18:36: 18:41\n+    let _9: &*mut Test;                  // in scope 0 at $DIR/receiver-ptr-mutability.rs:18:37: 18:41\n+    let _10: ();                         // in scope 0 at $DIR/receiver-ptr-mutability.rs:19:5: 19:16\n+    let mut _11: *const Test;            // in scope 0 at $DIR/receiver-ptr-mutability.rs:19:5: 19:12\n+    let mut _12: *mut Test;              // in scope 0 at $DIR/receiver-ptr-mutability.rs:19:5: 19:12\n+    scope 1 {\n+        debug ptr => _1;                 // in scope 1 at $DIR/receiver-ptr-mutability.rs:14:9: 14:12\n+        let _5: &&&&*mut Test as UserTypeProjection { base: UserType(2), projs: [] }; // in scope 1 at $DIR/receiver-ptr-mutability.rs:18:9: 18:16\n+        scope 2 {\n+            debug ptr_ref => _5;         // in scope 2 at $DIR/receiver-ptr-mutability.rs:18:9: 18:16\n+        }\n+    }\n+\n+    bb0: {\n+        StorageLive(_1);                 // scope 0 at $DIR/receiver-ptr-mutability.rs:14:9: 14:12\n+        _1 = null_mut::<Test>() -> [return: bb1, unwind: bb4]; // scope 0 at $DIR/receiver-ptr-mutability.rs:14:26: 14:46\n+                                         // mir::Constant\n+                                         // + span: $DIR/receiver-ptr-mutability.rs:14:26: 14:44\n+                                         // + literal: Const { ty: fn() -> *mut Test {std::ptr::null_mut::<Test>}, val: Value(Scalar(<ZST>)) }\n+    }\n+\n+    bb1: {\n+        FakeRead(ForLet, _1);            // scope 0 at $DIR/receiver-ptr-mutability.rs:14:9: 14:12\n+        AscribeUserType(_1, o, UserTypeProjection { base: UserType(1), projs: [] }); // scope 0 at $DIR/receiver-ptr-mutability.rs:14:14: 14:23\n+        StorageLive(_2);                 // scope 1 at $DIR/receiver-ptr-mutability.rs:15:5: 15:12\n+        StorageLive(_3);                 // scope 1 at $DIR/receiver-ptr-mutability.rs:15:5: 15:8\n+        StorageLive(_4);                 // scope 1 at $DIR/receiver-ptr-mutability.rs:15:5: 15:8\n+        _4 = _1;                         // scope 1 at $DIR/receiver-ptr-mutability.rs:15:5: 15:8\n+        _3 = move _4 as *const Test (Pointer(MutToConstPointer)); // scope 1 at $DIR/receiver-ptr-mutability.rs:15:5: 15:8\n+        StorageDead(_4);                 // scope 1 at $DIR/receiver-ptr-mutability.rs:15:7: 15:8\n+        _2 = Test::x(move _3) -> [return: bb2, unwind: bb4]; // scope 1 at $DIR/receiver-ptr-mutability.rs:15:5: 15:12\n+                                         // mir::Constant\n+                                         // + span: $DIR/receiver-ptr-mutability.rs:15:9: 15:10\n+                                         // + literal: Const { ty: fn(*const Test) {Test::x}, val: Value(Scalar(<ZST>)) }\n+    }\n+\n+    bb2: {\n+        StorageDead(_3);                 // scope 1 at $DIR/receiver-ptr-mutability.rs:15:11: 15:12\n+        StorageDead(_2);                 // scope 1 at $DIR/receiver-ptr-mutability.rs:15:12: 15:13\n+        StorageLive(_5);                 // scope 1 at $DIR/receiver-ptr-mutability.rs:18:9: 18:16\n+        StorageLive(_6);                 // scope 1 at $DIR/receiver-ptr-mutability.rs:18:34: 18:41\n+        StorageLive(_7);                 // scope 1 at $DIR/receiver-ptr-mutability.rs:18:35: 18:41\n+        StorageLive(_8);                 // scope 1 at $DIR/receiver-ptr-mutability.rs:18:36: 18:41\n+        StorageLive(_9);                 // scope 1 at $DIR/receiver-ptr-mutability.rs:18:37: 18:41\n+        _9 = &_1;                        // scope 1 at $DIR/receiver-ptr-mutability.rs:18:37: 18:41\n+        _8 = &_9;                        // scope 1 at $DIR/receiver-ptr-mutability.rs:18:36: 18:41\n+        _7 = &_8;                        // scope 1 at $DIR/receiver-ptr-mutability.rs:18:35: 18:41\n+        _6 = &_7;                        // scope 1 at $DIR/receiver-ptr-mutability.rs:18:34: 18:41\n+        _5 = &(*_6);                     // scope 1 at $DIR/receiver-ptr-mutability.rs:18:34: 18:41\n+        FakeRead(ForLet, _5);            // scope 1 at $DIR/receiver-ptr-mutability.rs:18:9: 18:16\n+        AscribeUserType(_5, o, UserTypeProjection { base: UserType(3), projs: [] }); // scope 1 at $DIR/receiver-ptr-mutability.rs:18:18: 18:31\n+        StorageDead(_6);                 // scope 1 at $DIR/receiver-ptr-mutability.rs:18:41: 18:42\n+        StorageLive(_10);                // scope 2 at $DIR/receiver-ptr-mutability.rs:19:5: 19:16\n+        StorageLive(_11);                // scope 2 at $DIR/receiver-ptr-mutability.rs:19:5: 19:12\n+        StorageLive(_12);                // scope 2 at $DIR/receiver-ptr-mutability.rs:19:5: 19:12\n+        _12 = (*(*(*(*_5))));            // scope 2 at $DIR/receiver-ptr-mutability.rs:19:5: 19:12\n+        _11 = move _12 as *const Test (Pointer(MutToConstPointer)); // scope 2 at $DIR/receiver-ptr-mutability.rs:19:5: 19:12\n+        StorageDead(_12);                // scope 2 at $DIR/receiver-ptr-mutability.rs:19:11: 19:12\n+        _10 = Test::x(move _11) -> [return: bb3, unwind: bb4]; // scope 2 at $DIR/receiver-ptr-mutability.rs:19:5: 19:16\n+                                         // mir::Constant\n+                                         // + span: $DIR/receiver-ptr-mutability.rs:19:13: 19:14\n+                                         // + literal: Const { ty: fn(*const Test) {Test::x}, val: Value(Scalar(<ZST>)) }\n+    }\n+\n+    bb3: {\n+        StorageDead(_11);                // scope 2 at $DIR/receiver-ptr-mutability.rs:19:15: 19:16\n+        StorageDead(_10);                // scope 2 at $DIR/receiver-ptr-mutability.rs:19:16: 19:17\n+        _0 = const ();                   // scope 0 at $DIR/receiver-ptr-mutability.rs:13:11: 20:2\n+        StorageDead(_9);                 // scope 1 at $DIR/receiver-ptr-mutability.rs:20:1: 20:2\n+        StorageDead(_8);                 // scope 1 at $DIR/receiver-ptr-mutability.rs:20:1: 20:2\n+        StorageDead(_7);                 // scope 1 at $DIR/receiver-ptr-mutability.rs:20:1: 20:2\n+        StorageDead(_5);                 // scope 1 at $DIR/receiver-ptr-mutability.rs:20:1: 20:2\n+        StorageDead(_1);                 // scope 0 at $DIR/receiver-ptr-mutability.rs:20:1: 20:2\n+        return;                          // scope 0 at $DIR/receiver-ptr-mutability.rs:20:2: 20:2\n+    }\n+\n+    bb4 (cleanup): {\n+        resume;                          // scope 0 at $DIR/receiver-ptr-mutability.rs:13:1: 20:2\n+    }\n+}"}]}