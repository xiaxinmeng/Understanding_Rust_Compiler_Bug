{"sha": "b0722c55f8205a43a0b8124ca179dada766c23ed", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwNzIyYzU1ZjgyMDVhNDNhMGI4MTI0Y2ExNzlkYWRhNzY2YzIzZWQ=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-19T08:04:01Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-20T22:20:49Z"}, "message": "core:rt:: Rename LocalServices to Task", "tree": {"sha": "5c2a4120822ff96b2f51b3b078cda03a9b2d85ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c2a4120822ff96b2f51b3b078cda03a9b2d85ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b0722c55f8205a43a0b8124ca179dada766c23ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b0722c55f8205a43a0b8124ca179dada766c23ed", "html_url": "https://github.com/rust-lang/rust/commit/b0722c55f8205a43a0b8124ca179dada766c23ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b0722c55f8205a43a0b8124ca179dada766c23ed/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa18a861fbd934c295990e59b20c7a0498b88f08", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa18a861fbd934c295990e59b20c7a0498b88f08", "html_url": "https://github.com/rust-lang/rust/commit/fa18a861fbd934c295990e59b20c7a0498b88f08"}], "stats": {"total": 145, "additions": 67, "deletions": 78}, "files": [{"sha": "16a80866cf1ab0b08fb5ea1461d49cda70cf55d1", "filename": "src/libcore/logging.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0722c55f8205a43a0b8124ca179dada766c23ed/src%2Flibcore%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0722c55f8205a43a0b8124ca179dada766c23ed/src%2Flibcore%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flogging.rs?ref=b0722c55f8205a43a0b8124ca179dada766c23ed", "patch": "@@ -67,7 +67,7 @@ pub fn log_type<T>(level: u32, object: &T) {\n \n fn newsched_log_str(msg: ~str) {\n     unsafe {\n-        match rt::local_services::unsafe_try_borrow_local_services() {\n+        match rt::task::unsafe_try_borrow_local_task() {\n             Some(local) => {\n                 // Use the available logger\n                 (*local).logger.log(Left(msg));"}, {"sha": "208a6de46e822b3698cd8037ad8eceec4191a53d", "filename": "src/libcore/rt/mod.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b0722c55f8205a43a0b8124ca179dada766c23ed/src%2Flibcore%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0722c55f8205a43a0b8124ca179dada766c23ed/src%2Flibcore%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fmod.rs?ref=b0722c55f8205a43a0b8124ca179dada766c23ed", "patch": "@@ -31,14 +31,8 @@ access to the global heap. Unlike most of `rt` the global heap is\n truly a global resource and generally operates independently of the\n rest of the runtime.\n \n-All other runtime features are 'local', either thread-local or\n-task-local.  Those critical to the functioning of the language are\n-defined in the module `local_services`. Local services are those which\n-are expected to be available to Rust code generally but rely on\n-thread- or task-local state. These currently include the local heap,\n+All other runtime features are task-local, including the local heap,\n the garbage collector, local storage, logging and the stack unwinder.\n-Local services are primarily implemented for tasks, but may also\n-be implemented for use outside of tasks.\n \n The relationship between `rt` and the rest of the core library is\n not entirely clear yet and some modules will be moving into or\n@@ -67,7 +61,10 @@ use ptr::Ptr;\n /// The global (exchange) heap.\n pub mod global_heap;\n \n-/// The Scheduler and Coroutine types.\n+/// Implementations of language-critical runtime features like @.\n+pub mod task;\n+\n+/// The coroutine task scheduler, built on the `io` event loop.\n mod sched;\n \n /// Thread-local access to the current Scheduler.\n@@ -77,9 +74,6 @@ pub mod local_sched;\n #[path = \"io/mod.rs\"]\n pub mod io;\n \n-/// Thread-local implementations of language-critical runtime features like @.\n-pub mod local_services;\n-\n /// The EventLoop and internal synchronous I/O interface.\n mod rtio;\n "}, {"sha": "4b2165b4d2ae3af6b535d4e295567ed067aa2b1b", "filename": "src/libcore/rt/sched.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b0722c55f8205a43a0b8124ca179dada766c23ed/src%2Flibcore%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0722c55f8205a43a0b8124ca179dada766c23ed/src%2Flibcore%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fsched.rs?ref=b0722c55f8205a43a0b8124ca179dada766c23ed", "patch": "@@ -16,7 +16,7 @@ use super::work_queue::WorkQueue;\n use super::stack::{StackPool, StackSegment};\n use super::rtio::{EventLoop, EventLoopObject};\n use super::context::Context;\n-use super::local_services::LocalServices;\n+use super::task::Task;\n use cell::Cell;\n \n // A more convenient name for external callers, e.g. `local_sched::take()`\n@@ -350,16 +350,16 @@ pub struct Coroutine {\n     /// the task is dead\n     priv saved_context: Context,\n     /// The heap, GC, unwinding, local storage, logging\n-    local_services: LocalServices\n+    task: Task\n }\n \n pub impl Coroutine {\n     fn new(stack_pool: &mut StackPool, start: ~fn()) -> Coroutine {\n-        Coroutine::with_local(stack_pool, LocalServices::new(), start)\n+        Coroutine::with_task(stack_pool, Task::new(), start)\n     }\n \n-    fn with_local(stack_pool: &mut StackPool,\n-                  local_services: LocalServices,\n+    fn with_task(stack_pool: &mut StackPool,\n+                  task: Task,\n                   start: ~fn()) -> Coroutine {\n         let start = Coroutine::build_start_wrapper(start);\n         let mut stack = stack_pool.take_segment(MIN_STACK_SIZE);\n@@ -368,7 +368,7 @@ pub impl Coroutine {\n         return Coroutine {\n             current_stack_segment: stack,\n             saved_context: initial_context,\n-            local_services: local_services\n+            task: task\n         };\n     }\n \n@@ -385,7 +385,7 @@ pub impl Coroutine {\n                 let sched = local_sched::unsafe_borrow();\n                 let task = (*sched).current_task.get_mut_ref();\n                 // FIXME #6141: shouldn't neet to put `start()` in another closure\n-                task.local_services.run(||start());\n+                task.task.run(||start());\n             }\n \n             let sched = local_sched::take();"}, {"sha": "c3832d1338ad0a4113b71e880dd3b172f693aa1f", "filename": "src/libcore/rt/task.rs", "status": "renamed", "additions": 21, "deletions": 26, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/b0722c55f8205a43a0b8124ca179dada766c23ed/src%2Flibcore%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0722c55f8205a43a0b8124ca179dada766c23ed/src%2Flibcore%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Ftask.rs?ref=b0722c55f8205a43a0b8124ca179dada766c23ed", "patch": "@@ -13,19 +13,14 @@\n //! local storage, and logging. Even a 'freestanding' Rust would likely want\n //! to implement this.\n \n-//! Local services may exist in at least three different contexts:\n-//! when running as a task, when running in the scheduler's context,\n-//! or when running outside of a scheduler but with local services\n-//! (freestanding rust with local services?).\n-\n use prelude::*;\n use libc::{c_void, uintptr_t};\n use cast::transmute;\n use super::sched::local_sched;\n use super::local_heap::LocalHeap;\n use rt::logging::StdErrLogger;\n \n-pub struct LocalServices {\n+pub struct Task {\n     heap: LocalHeap,\n     gc: GarbageCollector,\n     storage: LocalStorage,\n@@ -41,9 +36,9 @@ pub struct Unwinder {\n     unwinding: bool,\n }\n \n-impl LocalServices {\n-    pub fn new() -> LocalServices {\n-        LocalServices {\n+impl Task {\n+    pub fn new() -> Task {\n+        Task {\n             heap: LocalHeap::new(),\n             gc: GarbageCollector,\n             storage: LocalStorage(ptr::null(), None),\n@@ -53,8 +48,8 @@ impl LocalServices {\n         }\n     }\n \n-    pub fn without_unwinding() -> LocalServices {\n-        LocalServices {\n+    pub fn without_unwinding() -> Task {\n+        Task {\n             heap: LocalHeap::new(),\n             gc: GarbageCollector,\n             storage: LocalStorage(ptr::null(), None),\n@@ -66,9 +61,9 @@ impl LocalServices {\n \n     pub fn run(&mut self, f: &fn()) {\n         // This is just an assertion that `run` was called unsafely\n-        // and this instance of LocalServices is still accessible.\n-        do borrow_local_services |sched| {\n-            assert!(ptr::ref_eq(sched, self));\n+        // and this instance of Task is still accessible.\n+        do borrow_local_task |task| {\n+            assert!(ptr::ref_eq(task, self));\n         }\n \n         match self.unwinder {\n@@ -86,14 +81,14 @@ impl LocalServices {\n \n     /// Must be called manually before finalization to clean up\n     /// thread-local resources. Some of the routines here expect\n-    /// LocalServices to be available recursively so this must be\n-    /// called unsafely, without removing LocalServices from\n+    /// Task to be available recursively so this must be\n+    /// called unsafely, without removing Task from\n     /// thread-local-storage.\n     fn destroy(&mut self) {\n         // This is just an assertion that `destroy` was called unsafely\n-        // and this instance of LocalServices is still accessible.\n-        do borrow_local_services |sched| {\n-            assert!(ptr::ref_eq(sched, self));\n+        // and this instance of Task is still accessible.\n+        do borrow_local_task |task| {\n+            assert!(ptr::ref_eq(task, self));\n         }\n         match self.storage {\n             LocalStorage(ptr, Some(ref dtor)) => {\n@@ -105,7 +100,7 @@ impl LocalServices {\n     }\n }\n \n-impl Drop for LocalServices {\n+impl Drop for Task {\n     fn finalize(&self) { assert!(self.destroyed) }\n }\n \n@@ -156,11 +151,11 @@ impl Unwinder {\n \n /// Borrow a pointer to the installed local services.\n /// Fails (likely aborting the process) if local services are not available.\n-pub fn borrow_local_services(f: &fn(&mut LocalServices)) {\n+pub fn borrow_local_task(f: &fn(&mut Task)) {\n     do local_sched::borrow |sched| {\n         match sched.current_task {\n             Some(~ref mut task) => {\n-                f(&mut task.local_services)\n+                f(&mut task.task)\n             }\n             None => {\n                 fail!(\"no local services for schedulers yet\")\n@@ -169,10 +164,10 @@ pub fn borrow_local_services(f: &fn(&mut LocalServices)) {\n     }\n }\n \n-pub unsafe fn unsafe_borrow_local_services() -> *mut LocalServices {\n+pub unsafe fn unsafe_borrow_local_task() -> *mut Task {\n     match (*local_sched::unsafe_borrow()).current_task {\n         Some(~ref mut task) => {\n-            let s: *mut LocalServices = &mut task.local_services;\n+            let s: *mut Task = &mut task.task;\n             return s;\n         }\n         None => {\n@@ -182,9 +177,9 @@ pub unsafe fn unsafe_borrow_local_services() -> *mut LocalServices {\n     }\n }\n \n-pub unsafe fn unsafe_try_borrow_local_services() -> Option<*mut LocalServices> {\n+pub unsafe fn unsafe_try_borrow_local_task() -> Option<*mut Task> {\n     if local_sched::exists() {\n-        Some(unsafe_borrow_local_services())\n+        Some(unsafe_borrow_local_task())\n     } else {\n         None\n     }", "previous_filename": "src/libcore/rt/local_services.rs"}, {"sha": "c3e52594d6e77cf7cd06d3c72384bef20c9804f7", "filename": "src/libcore/rt/test.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b0722c55f8205a43a0b8124ca179dada766c23ed/src%2Flibcore%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0722c55f8205a43a0b8124ca179dada766c23ed/src%2Flibcore%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Ftest.rs?ref=b0722c55f8205a43a0b8124ca179dada766c23ed", "patch": "@@ -13,7 +13,7 @@ use option::*;\n use cell::Cell;\n use result::{Result, Ok, Err};\n use super::io::net::ip::{IpAddr, Ipv4};\n-use rt::local_services::LocalServices;\n+use rt::task::Task;\n use rt::thread::Thread;\n \n /// Creates a new scheduler in a new thread and runs a task in it,\n@@ -28,9 +28,9 @@ pub fn run_in_newsched_task(f: ~fn()) {\n \n     do run_in_bare_thread {\n         let mut sched = ~UvEventLoop::new_scheduler();\n-        let task = ~Coroutine::with_local(&mut sched.stack_pool,\n-                                          LocalServices::without_unwinding(),\n-                                          f.take());\n+        let task = ~Coroutine::with_task(&mut sched.stack_pool,\n+                                         Task::without_unwinding(),\n+                                         f.take());\n         sched.enqueue_task(task);\n         sched.run();\n     }\n@@ -41,9 +41,9 @@ pub fn spawntask(f: ~fn()) {\n     use super::sched::*;\n \n     let mut sched = local_sched::take();\n-    let task = ~Coroutine::with_local(&mut sched.stack_pool,\n-                                      LocalServices::without_unwinding(),\n-                                      f);\n+    let task = ~Coroutine::with_task(&mut sched.stack_pool,\n+                                     Task::without_unwinding(),\n+                                     f);\n     do sched.switch_running_tasks_and_then(task) |task| {\n         let task = Cell(task);\n         let sched = local_sched::take();\n@@ -56,9 +56,9 @@ pub fn spawntask_immediately(f: ~fn()) {\n     use super::sched::*;\n \n     let mut sched = local_sched::take();\n-    let task = ~Coroutine::with_local(&mut sched.stack_pool,\n-                                      LocalServices::without_unwinding(),\n-                                      f);\n+    let task = ~Coroutine::with_task(&mut sched.stack_pool,\n+                                     Task::without_unwinding(),\n+                                     f);\n     do sched.switch_running_tasks_and_then(task) |task| {\n         let task = Cell(task);\n         do local_sched::borrow |sched| {\n@@ -72,9 +72,9 @@ pub fn spawntask_later(f: ~fn()) {\n     use super::sched::*;\n \n     let mut sched = local_sched::take();\n-    let task = ~Coroutine::with_local(&mut sched.stack_pool,\n-                                      LocalServices::without_unwinding(),\n-                                      f);\n+    let task = ~Coroutine::with_task(&mut sched.stack_pool,\n+                                     Task::without_unwinding(),\n+                                     f);\n \n     sched.enqueue_task(task);\n     local_sched::put(sched);\n@@ -89,9 +89,9 @@ pub fn spawntask_random(f: ~fn()) {\n     let run_now: bool = Rand::rand(&mut rng);\n \n     let mut sched = local_sched::take();\n-    let task = ~Coroutine::with_local(&mut sched.stack_pool,\n-                                      LocalServices::without_unwinding(),\n-                                      f);\n+    let task = ~Coroutine::with_task(&mut sched.stack_pool,\n+                                     Task::without_unwinding(),\n+                                     f);\n \n     if run_now {\n         do sched.switch_running_tasks_and_then(task) |task| {\n@@ -155,9 +155,9 @@ pub fn spawntask_thread(f: ~fn()) -> Thread {\n     let f = Cell(f);\n     let thread = do Thread::start {\n         let mut sched = ~UvEventLoop::new_scheduler();\n-        let task = ~Coroutine::with_local(&mut sched.stack_pool,\n-                                          LocalServices::without_unwinding(),\n-                                          f.take());\n+        let task = ~Coroutine::with_task(&mut sched.stack_pool,\n+                                         Task::without_unwinding(),\n+                                         f.take());\n         sched.enqueue_task(task);\n         sched.run();\n     };"}, {"sha": "c21ce5213142b41f70cb7affef53156c89cccecf", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b0722c55f8205a43a0b8124ca179dada766c23ed/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0722c55f8205a43a0b8124ca179dada766c23ed/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=b0722c55f8205a43a0b8124ca179dada766c23ed", "patch": "@@ -204,7 +204,7 @@ impl FailWithCause for &'static str {\n pub fn begin_unwind_(msg: *c_char, file: *c_char, line: size_t) -> ! {\n     use option::Option;\n     use rt::{context, OldTaskContext, TaskContext};\n-    use rt::local_services::{unsafe_borrow_local_services, Unwinder};\n+    use rt::task::{unsafe_borrow_local_task, Unwinder};\n \n     let context = context();\n     match context {\n@@ -233,8 +233,8 @@ pub fn begin_unwind_(msg: *c_char, file: *c_char, line: size_t) -> ! {\n \n                 gc::cleanup_stack_for_failure();\n \n-                let local_services = unsafe_borrow_local_services();\n-                let unwinder: &mut Option<Unwinder> = &mut (*local_services).unwinder;\n+                let task = unsafe_borrow_local_task();\n+                let unwinder: &mut Option<Unwinder> = &mut (*task).unwinder;\n                 match *unwinder {\n                     Some(ref mut unwinder) => unwinder.begin_unwind(),\n                     None => abort!(\"failure without unwinder. aborting process\")"}, {"sha": "6871dd3aecd88988c7af1fd61f64d6a70266a09d", "filename": "src/libcore/task/local_data_priv.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b0722c55f8205a43a0b8124ca179dada766c23ed/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0722c55f8205a43a0b8124ca179dada766c23ed/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data_priv.rs?ref=b0722c55f8205a43a0b8124ca179dada766c23ed", "patch": "@@ -18,7 +18,7 @@ use task::rt;\n use local_data::LocalDataKey;\n \n use super::rt::rust_task;\n-use rt::local_services::LocalStorage;\n+use rt::task::LocalStorage;\n \n pub enum Handle {\n     OldHandle(*rust_task),\n@@ -28,15 +28,15 @@ pub enum Handle {\n impl Handle {\n     pub fn new() -> Handle {\n         use rt::{context, OldTaskContext};\n-        use rt::local_services::unsafe_borrow_local_services;\n+        use rt::task::unsafe_borrow_local_task;\n         unsafe {\n             match context() {\n                 OldTaskContext => {\n                     OldHandle(rt::rust_get_task())\n                 }\n                 _ => {\n-                    let local_services = unsafe_borrow_local_services();\n-                    NewHandle(&mut (*local_services).storage)\n+                    let task = unsafe_borrow_local_task();\n+                    NewHandle(&mut (*task).storage)\n                 }\n             }\n         }"}, {"sha": "372a9f6defaff2a8d9613c7a2b15451d28072807", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0722c55f8205a43a0b8124ca179dada766c23ed/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0722c55f8205a43a0b8124ca179dada766c23ed/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=b0722c55f8205a43a0b8124ca179dada766c23ed", "patch": "@@ -504,7 +504,7 @@ pub fn failing() -> bool {\n     //! True if the running task has failed\n \n     use rt::{context, OldTaskContext};\n-    use rt::local_services::borrow_local_services;\n+    use rt::task::borrow_local_task;\n \n     match context() {\n         OldTaskContext => {\n@@ -514,7 +514,7 @@ pub fn failing() -> bool {\n         }\n         _ => {\n             let mut unwinding = false;\n-            do borrow_local_services |local| {\n+            do borrow_local_task |local| {\n                 unwinding = match local.unwinder {\n                     Some(unwinder) => {\n                         unwinder.unwinding"}, {"sha": "1efe5d0d1a41d5a44ef9446c24a23746df187fcc", "filename": "src/libcore/unstable/lang.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b0722c55f8205a43a0b8124ca179dada766c23ed/src%2Flibcore%2Funstable%2Flang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0722c55f8205a43a0b8124ca179dada766c23ed/src%2Flibcore%2Funstable%2Flang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Flang.rs?ref=b0722c55f8205a43a0b8124ca179dada766c23ed", "patch": "@@ -17,7 +17,7 @@ use managed::raw::BoxRepr;\n use str;\n use sys;\n use rt::{context, OldTaskContext};\n-use rt::local_services::borrow_local_services;\n+use rt::task::borrow_local_task;\n use option::{Option, Some, None};\n use io;\n use rt::global_heap;\n@@ -243,8 +243,8 @@ pub unsafe fn local_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n         }\n         _ => {\n             let mut alloc = ::ptr::null();\n-            do borrow_local_services |srv| {\n-                alloc = srv.heap.alloc(td as *c_void, size as uint) as *c_char;\n+            do borrow_local_task |task| {\n+                alloc = task.heap.alloc(td as *c_void, size as uint) as *c_char;\n             }\n             return alloc;\n         }\n@@ -261,8 +261,8 @@ pub unsafe fn local_free(ptr: *c_char) {\n             rustrt::rust_upcall_free_noswitch(ptr);\n         }\n         _ => {\n-            do borrow_local_services |srv| {\n-                srv.heap.free(ptr as *c_void);\n+            do borrow_local_task |task| {\n+                task.heap.free(ptr as *c_void);\n             }\n         }\n     }"}]}