{"sha": "4f49fff019c50d70240116090a2720a8a2dd5c34", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmNDlmZmYwMTljNTBkNzAyNDAxMTYwOTBhMjcyMGE4YTJkZDVjMzQ=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2019-03-18T07:19:23Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2019-03-18T07:20:10Z"}, "message": "Clean up parsing code and split out codegen for the QueryDescription impl", "tree": {"sha": "8c462ab2ad7f5c5130f01cc10ec2d08e22e31576", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c462ab2ad7f5c5130f01cc10ec2d08e22e31576"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f49fff019c50d70240116090a2720a8a2dd5c34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f49fff019c50d70240116090a2720a8a2dd5c34", "html_url": "https://github.com/rust-lang/rust/commit/4f49fff019c50d70240116090a2720a8a2dd5c34", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f49fff019c50d70240116090a2720a8a2dd5c34/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9e9d03fd66f2fa0eb04b5381f491d6139fab94ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e9d03fd66f2fa0eb04b5381f491d6139fab94ff", "html_url": "https://github.com/rust-lang/rust/commit/9e9d03fd66f2fa0eb04b5381f491d6139fab94ff"}], "stats": {"total": 327, "additions": 142, "deletions": 185}, "files": [{"sha": "e99ceb1b0c79bd0aad583abda9afe3190742ad24", "filename": "src/librustc_macros/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f49fff019c50d70240116090a2720a8a2dd5c34/src%2Flibrustc_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f49fff019c50d70240116090a2720a8a2dd5c34/src%2Flibrustc_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Flib.rs?ref=4f49fff019c50d70240116090a2720a8a2dd5c34", "patch": "@@ -9,7 +9,6 @@ use proc_macro::TokenStream;\n \n mod hash_stable;\n mod query;\n-mod tt;\n \n #[proc_macro]\n pub fn rustc_queries(input: TokenStream) -> TokenStream {"}, {"sha": "2f9fdacdd71ca35e2580312fe9079a0d46469947", "filename": "src/librustc_macros/src/query.rs", "status": "modified", "additions": 142, "deletions": 119, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/4f49fff019c50d70240116090a2720a8a2dd5c34/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f49fff019c50d70240116090a2720a8a2dd5c34/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Fquery.rs?ref=4f49fff019c50d70240116090a2720a8a2dd5c34", "patch": "@@ -1,14 +1,21 @@\n use proc_macro::TokenStream;\n use proc_macro2::Span;\n use syn::{\n-    Token, Ident, Type, Attribute, ReturnType, Expr, Block,\n+    Token, Ident, Type, Attribute, ReturnType, Expr, Block, Error,\n     braced, parenthesized, parse_macro_input,\n };\n+use syn::spanned::Spanned;\n use syn::parse::{Result, Parse, ParseStream};\n use syn::punctuated::Punctuated;\n+use syn;\n use quote::quote;\n-use crate::tt::TS;\n \n+#[allow(non_camel_case_types)]\n+mod kw {\n+    syn::custom_keyword!(query);\n+}\n+\n+/// Ident or a wildcard `_`.\n struct IdentOrWild(Ident);\n \n impl Parse for IdentOrWild {\n@@ -22,17 +29,27 @@ impl Parse for IdentOrWild {\n     }\n }\n \n-enum QueryAttribute {\n+/// A modifier for a query\n+enum QueryModifier {\n+    /// The description of the query\n     Desc(Option<Ident>, Punctuated<Expr, Token![,]>),\n+\n+    /// Cache the query to disk if the `Expr` returns true.\n     Cache(Option<Ident>, Expr),\n+\n+    /// Custom code to load the query from disk.\n     LoadCached(Ident, Ident, Block),\n+\n+    /// A cycle error for this query aborting the compilation with a fatal error.\n     FatalCycle,\n }\n \n-impl Parse for QueryAttribute {\n+impl Parse for QueryModifier {\n     fn parse(input: ParseStream<'_>) -> Result<Self> {\n-        let attr: Ident = input.parse()?;\n-        if attr == \"desc\" {\n+        let modifier: Ident = input.parse()?;\n+        if modifier == \"desc\" {\n+            // Parse a description modifier like:\n+            // `desc { |tcx| \"foo {}\", tcx.item_path(key) }`\n             let attr_content;\n             braced!(attr_content in input);\n             let tcx = if attr_content.peek(Token![|]) {\n@@ -44,11 +61,10 @@ impl Parse for QueryAttribute {\n                 None\n             };\n             let desc = attr_content.parse_terminated(Expr::parse)?;\n-            if !attr_content.is_empty() {\n-                panic!(\"unexpected tokens in block\");\n-            };\n-            Ok(QueryAttribute::Desc(tcx, desc))\n-        } else if attr == \"cache\" {\n+            Ok(QueryModifier::Desc(tcx, desc))\n+        } else if modifier == \"cache\" {\n+            // Parse a cache modifier like:\n+            // `cache { |tcx| key.is_local() }`\n             let attr_content;\n             braced!(attr_content in input);\n             let tcx = if attr_content.peek(Token![|]) {\n@@ -60,68 +76,59 @@ impl Parse for QueryAttribute {\n                 None\n             };\n             let expr = attr_content.parse()?;\n-            if !attr_content.is_empty() {\n-                panic!(\"unexpected tokens in block\");\n-            };\n-            Ok(QueryAttribute::Cache(tcx, expr))\n-        } else if attr == \"load_cached\" {\n+            Ok(QueryModifier::Cache(tcx, expr))\n+        } else if modifier == \"load_cached\" {\n+            // Parse a load_cached modifier like:\n+            // `load_cached(tcx, id) { tcx.queries.on_disk_cache.try_load_query_result(tcx, id) }`\n             let args;\n             parenthesized!(args in input);\n             let tcx = args.parse()?;\n             args.parse::<Token![,]>()?;\n             let id = args.parse()?;\n-            if !args.is_empty() {\n-                panic!(\"unexpected tokens in arguments\");\n-            };\n             let block = input.parse()?;\n-            Ok(QueryAttribute::LoadCached(tcx, id, block))\n-        } else if attr == \"fatal_cycle\" {\n-            Ok(QueryAttribute::FatalCycle)\n+            Ok(QueryModifier::LoadCached(tcx, id, block))\n+        } else if modifier == \"fatal_cycle\" {\n+            Ok(QueryModifier::FatalCycle)\n         } else {\n-            panic!(\"unknown query modifier {}\", attr)\n+            Err(Error::new(modifier.span(), \"unknown query modifier\"))\n         }\n     }\n }\n \n+/// Ensures only doc comment attributes are used\n+fn check_attributes(attrs: Vec<Attribute>) -> Result<()> {\n+    for attr in attrs {\n+        if !attr.path.is_ident(\"doc\") {\n+            return Err(Error::new(attr.span(), \"attributes not supported on queries\"));\n+        }\n+    }\n+    Ok(())\n+}\n+\n+/// A compiler query. `query ... { ... }`\n struct Query {\n-    attrs: List<QueryAttribute>,\n+    attrs: List<QueryModifier>,\n     name: Ident,\n     key: IdentOrWild,\n     arg: Type,\n     result: ReturnType,\n }\n \n-fn check_attributes(attrs: Vec<Attribute>) {\n-    for attr in attrs {\n-        let path = attr.path;\n-        let path = quote! { #path };\n-        let path = TS(&path);\n-\n-        if path != TS(&quote! { doc }) {\n-            panic!(\"attribute `{}` not supported on queries\", path.0)\n-        }\n-    }\n-}\n-\n impl Parse for Query {\n     fn parse(input: ParseStream<'_>) -> Result<Self> {\n-        check_attributes(input.call(Attribute::parse_outer)?);\n+        check_attributes(input.call(Attribute::parse_outer)?)?;\n \n-        let query: Ident = input.parse()?;\n-        if query != \"query\" {\n-            panic!(\"expected `query`\");\n-        }\n+        // Parse the query declaration. Like `query type_of(key: DefId) -> Ty<'tcx>`\n+        input.parse::<kw::query>()?;\n         let name: Ident = input.parse()?;\n         let arg_content;\n         parenthesized!(arg_content in input);\n         let key = arg_content.parse()?;\n         arg_content.parse::<Token![:]>()?;\n         let arg = arg_content.parse()?;\n-        if !arg_content.is_empty() {\n-            panic!(\"expected only one query argument\");\n-        };\n         let result = input.parse()?;\n \n+        // Parse the query modifiers\n         let content;\n         braced!(content in input);\n         let attrs = content.parse()?;\n@@ -136,6 +143,7 @@ impl Parse for Query {\n     }\n }\n \n+/// A type used to greedily parse another type until the input is empty.\n struct List<T>(Vec<T>);\n \n impl<T: Parse> Parse for List<T> {\n@@ -148,6 +156,7 @@ impl<T: Parse> Parse for List<T> {\n     }\n }\n \n+/// A named group containing queries.\n struct Group {\n     name: Ident,\n     queries: List<Query>,\n@@ -165,6 +174,88 @@ impl Parse for Group {\n     }\n }\n \n+/// Add the impl of QueryDescription for the query to `impls` if one is requested\n+fn add_query_description_impl(query: &Query, impls: &mut proc_macro2::TokenStream) {\n+    let name = &query.name;\n+    let arg = &query.arg;\n+    let key = &query.key.0;\n+\n+    // Find custom code to load the query from disk\n+    let load_cached = query.attrs.0.iter().find_map(|attr| match attr {\n+        QueryModifier::LoadCached(tcx, id, block) => Some((tcx, id, block)),\n+        _ => None,\n+    });\n+\n+    // Find out if we should cache the query on disk\n+    let cache = query.attrs.0.iter().find_map(|attr| match attr {\n+        QueryModifier::Cache(tcx, expr) => Some((tcx, expr)),\n+        _ => None,\n+    }).map(|(tcx, expr)| {\n+        let try_load_from_disk = if let Some((tcx, id, block)) = load_cached {\n+            quote! {\n+                #[inline]\n+                fn try_load_from_disk(\n+                    #tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+                    #id: SerializedDepNodeIndex\n+                ) -> Option<Self::Value> {\n+                    #block\n+                }\n+            }\n+        } else {\n+            quote! {\n+                #[inline]\n+                fn try_load_from_disk(\n+                    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+                    id: SerializedDepNodeIndex\n+                ) -> Option<Self::Value> {\n+                    tcx.queries.on_disk_cache.try_load_query_result(tcx, id)\n+                }\n+            }\n+        };\n+\n+        let tcx = tcx.as_ref().map(|t| quote! { #t }).unwrap_or(quote! { _ });\n+        quote! {\n+            #[inline]\n+            fn cache_on_disk(#tcx: TyCtxt<'_, 'tcx, 'tcx>, #key: Self::Key) -> bool {\n+                #expr\n+            }\n+\n+            #try_load_from_disk\n+        }\n+    });\n+\n+    if cache.is_none() && load_cached.is_some() {\n+        panic!(\"load_cached modifier on query `{}` without a cache modifier\", name);\n+    }\n+\n+    let desc = query.attrs.0.iter().find_map(|attr| match attr {\n+        QueryModifier::Desc(tcx, desc) => Some((tcx, desc)),\n+        _ => None,\n+    }).map(|(tcx, desc)| {\n+        let tcx = tcx.as_ref().map(|t| quote! { #t }).unwrap_or(quote! { _ });\n+        quote! {\n+            fn describe(\n+                #tcx: TyCtxt<'_, '_, '_>,\n+                #key: #arg,\n+            ) -> Cow<'static, str> {\n+                format!(#desc).into()\n+            }\n+        }\n+    });\n+\n+    if desc.is_some() || cache.is_some() {\n+        let cache = cache.unwrap_or(quote! {});\n+        let desc = desc.unwrap_or(quote! {});\n+\n+        impls.extend(quote! {\n+            impl<'tcx> QueryDescription<'tcx> for queries::#name<'tcx> {\n+                #desc\n+                #cache\n+            }\n+        });\n+    }\n+}\n+\n pub fn rustc_queries(input: TokenStream) -> TokenStream {\n     let groups = parse_macro_input!(input as List<Group>);\n \n@@ -178,99 +269,31 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n         for query in &group.queries.0 {\n             let name = &query.name;\n             let arg = &query.arg;\n-            let key = &query.key.0;\n             let result_full = &query.result;\n             let result = match query.result {\n                 ReturnType::Default => quote! { -> () },\n                 _ => quote! { #result_full },\n             };\n \n-            let load_cached = query.attrs.0.iter().find_map(|attr| match attr {\n-                QueryAttribute::LoadCached(tcx, id, block) => Some((tcx, id, block)),\n-                _ => None,\n-            });\n-\n-            // Find out if we should cache the query on disk\n-            let cache = query.attrs.0.iter().find_map(|attr| match attr {\n-                QueryAttribute::Cache(tcx, expr) => Some((tcx, expr)),\n-                _ => None,\n-            }).map(|(tcx, expr)| {\n-                let try_load_from_disk = if let Some((tcx, id, block)) = load_cached {\n-                    quote! {\n-                        #[inline]\n-                        fn try_load_from_disk(\n-                            #tcx: TyCtxt<'_, 'tcx, 'tcx>,\n-                            #id: SerializedDepNodeIndex\n-                        ) -> Option<Self::Value> {\n-                            #block\n-                        }\n-                    }\n-                } else {\n-                    quote! {\n-                        #[inline]\n-                        fn try_load_from_disk(\n-                            tcx: TyCtxt<'_, 'tcx, 'tcx>,\n-                            id: SerializedDepNodeIndex\n-                        ) -> Option<Self::Value> {\n-                            tcx.queries.on_disk_cache.try_load_query_result(tcx, id)\n-                        }\n-                    }\n-                };\n-\n-                let tcx = tcx.as_ref().map(|t| quote! { #t }).unwrap_or(quote! { _ });\n-                quote! {\n-                    #[inline]\n-                    fn cache_on_disk(#tcx: TyCtxt<'_, 'tcx, 'tcx>, #key: Self::Key) -> bool {\n-                        #expr\n-                    }\n-\n-                    #try_load_from_disk\n-                }\n-            });\n-\n-            if cache.is_none() && load_cached.is_some() {\n-                panic!(\"load_cached modifier on query `{}` without a cache modifier\", name);\n-            }\n-\n+            // Look for a fatal_cycle modifier to pass on\n             let fatal_cycle = query.attrs.0.iter().find_map(|attr| match attr {\n-                QueryAttribute::FatalCycle => Some(()),\n+                QueryModifier::FatalCycle => Some(()),\n                 _ => None,\n             }).map(|_| quote! { fatal_cycle }).unwrap_or(quote! {});\n \n+            // Add the query to the group\n             group_stream.extend(quote! {\n                 [#fatal_cycle] fn #name: #name(#arg) #result,\n             });\n \n-            let desc = query.attrs.0.iter().find_map(|attr| match attr {\n-                QueryAttribute::Desc(tcx, desc) => Some((tcx, desc)),\n-                _ => None,\n-            }).map(|(tcx, desc)| {\n-                let tcx = tcx.as_ref().map(|t| quote! { #t }).unwrap_or(quote! { _ });\n-                quote! {\n-                    fn describe(\n-                        #tcx: TyCtxt<'_, '_, '_>,\n-                        #key: #arg,\n-                    ) -> Cow<'static, str> {\n-                        format!(#desc).into()\n-                    }\n-                }\n-            });\n-\n-            if desc.is_some() || cache.is_some() {\n-                let cache = cache.unwrap_or(quote! {});\n-                let desc = desc.unwrap_or(quote! {});\n-\n-                query_description_stream.extend(quote! {\n-                    impl<'tcx> QueryDescription<'tcx> for queries::#name<'tcx> {\n-                        #desc\n-                        #cache\n-                    }\n-                });\n-            }\n+            add_query_description_impl(query, &mut query_description_stream);\n \n+            // Create a dep node for the query\n             dep_node_def_stream.extend(quote! {\n                 [] #name(#arg),\n             });\n+\n+            // Add a match arm to force the query given the dep node\n             dep_node_force_stream.extend(quote! {\n                 DepKind::#name => {\n                     if let Some(key) = RecoverKey::recover($tcx, $dep_node) {"}, {"sha": "66180ec8ad373ae62ae38fc4d7a2ffb785deb430", "filename": "src/librustc_macros/src/tt.rs", "status": "removed", "additions": 0, "deletions": 65, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/9e9d03fd66f2fa0eb04b5381f491d6139fab94ff/src%2Flibrustc_macros%2Fsrc%2Ftt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9d03fd66f2fa0eb04b5381f491d6139fab94ff/src%2Flibrustc_macros%2Fsrc%2Ftt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Ftt.rs?ref=9e9d03fd66f2fa0eb04b5381f491d6139fab94ff", "patch": "@@ -1,65 +0,0 @@\n-use proc_macro2::{Delimiter, TokenStream, TokenTree};\n-\n-pub struct TT<'a>(pub &'a TokenTree);\n-\n-impl<'a> PartialEq for TT<'a> {\n-    fn eq(&self, other: &Self) -> bool {\n-        use proc_macro2::Spacing;\n-\n-        match (self.0, other.0) {\n-            (&TokenTree::Group(ref g1), &TokenTree::Group(ref g2)) => {\n-                match (g1.delimiter(), g2.delimiter()) {\n-                    (Delimiter::Parenthesis, Delimiter::Parenthesis)\n-                    | (Delimiter::Brace, Delimiter::Brace)\n-                    | (Delimiter::Bracket, Delimiter::Bracket)\n-                    | (Delimiter::None, Delimiter::None) => {}\n-                    _ => return false,\n-                }\n-\n-                let s1 = g1.stream().clone().into_iter();\n-                let mut s2 = g2.stream().clone().into_iter();\n-\n-                for item1 in s1 {\n-                    let item2 = match s2.next() {\n-                        Some(item) => item,\n-                        None => return false,\n-                    };\n-                    if TT(&item1) != TT(&item2) {\n-                        return false;\n-                    }\n-                }\n-                s2.next().is_none()\n-            }\n-            (&TokenTree::Punct(ref o1), &TokenTree::Punct(ref o2)) => {\n-                o1.as_char() == o2.as_char()\n-                    && match (o1.spacing(), o2.spacing()) {\n-                        (Spacing::Alone, Spacing::Alone) | (Spacing::Joint, Spacing::Joint) => true,\n-                        _ => false,\n-                    }\n-            }\n-            (&TokenTree::Literal(ref l1), &TokenTree::Literal(ref l2)) => {\n-                l1.to_string() == l2.to_string()\n-            }\n-            (&TokenTree::Ident(ref s1), &TokenTree::Ident(ref s2)) => s1 == s2,\n-            _ => false,\n-        }\n-    }\n-}\n-\n-pub struct TS<'a>(pub &'a TokenStream);\n-\n-impl<'a> PartialEq for TS<'a> {\n-    fn eq(&self, other: &Self) -> bool {\n-        let left = self.0.clone().into_iter().collect::<Vec<_>>();\n-        let right = other.0.clone().into_iter().collect::<Vec<_>>();\n-        if left.len() != right.len() {\n-            return false;\n-        }\n-        for (a, b) in left.into_iter().zip(right) {\n-            if TT(&a) != TT(&b) {\n-                return false;\n-            }\n-        }\n-        true\n-    }\n-}"}]}