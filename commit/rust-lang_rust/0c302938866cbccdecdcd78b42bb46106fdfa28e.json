{"sha": "0c302938866cbccdecdcd78b42bb46106fdfa28e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjMzAyOTM4ODY2Y2JjY2RlY2RjZDc4YjQyYmI0NjEwNmZkZmEyOGU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-01T05:14:22Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-07T15:15:58Z"}, "message": "core: Inherit what's possible from the num module\n\nThis strips out all string-related functionality from the num module. The\ninherited functionality is all that will be implemented in libcore (for now).\nPrimarily, libcore will not implement the Float trait or any string-related\nfunctionality.\n\nIt may be possible to migrate string parsing functionality into libcore in the\nfuture, but for now it will remain in libstd.\n\nAll functionality in core::num is reexported in std::num.", "tree": {"sha": "b31c4f42be17d210b18df6772098fdbdd0b53fce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b31c4f42be17d210b18df6772098fdbdd0b53fce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c302938866cbccdecdcd78b42bb46106fdfa28e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c302938866cbccdecdcd78b42bb46106fdfa28e", "html_url": "https://github.com/rust-lang/rust/commit/0c302938866cbccdecdcd78b42bb46106fdfa28e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c302938866cbccdecdcd78b42bb46106fdfa28e/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5229e5d2ea6168ec80a7feeea1a513b2b3176c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5229e5d2ea6168ec80a7feeea1a513b2b3176c0", "html_url": "https://github.com/rust-lang/rust/commit/c5229e5d2ea6168ec80a7feeea1a513b2b3176c0"}], "stats": {"total": 1726, "additions": 877, "deletions": 849}, "files": [{"sha": "fbc38fa1e5c9167d8666341d6433ee322889e859", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c302938866cbccdecdcd78b42bb46106fdfa28e/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c302938866cbccdecdcd78b42bb46106fdfa28e/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=0c302938866cbccdecdcd78b42bb46106fdfa28e", "patch": "@@ -21,6 +21,8 @@\n #![feature(globs, macro_rules, managed_boxes)]\n #![deny(missing_doc)]\n \n+pub mod num;\n+\n /* Core modules for ownership management */\n \n pub mod cast;"}, {"sha": "c91b0f5918d29c8b49c841a6b36c4ded94a8504d", "filename": "src/libcore/num/mod.rs", "status": "added", "additions": 860, "deletions": 0, "changes": 860, "blob_url": "https://github.com/rust-lang/rust/blob/0c302938866cbccdecdcd78b42bb46106fdfa28e/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c302938866cbccdecdcd78b42bb46106fdfa28e/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=0c302938866cbccdecdcd78b42bb46106fdfa28e", "patch": "@@ -0,0 +1,860 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Numeric traits and functions for generic mathematics\n+//!\n+//! These are implemented for the primitive numeric types in `std::{u8, u16,\n+//! u32, u64, uint, i8, i16, i32, i64, int, f32, f64, float}`.\n+\n+#![allow(missing_doc)]\n+\n+use clone::Clone;\n+use cmp::{Eq, Ord};\n+use kinds::Copy;\n+use mem::size_of;\n+use ops::{Add, Sub, Mul, Div, Rem, Neg};\n+use ops::{Not, BitAnd, BitOr, BitXor, Shl, Shr};\n+use option::{Option, Some, None};\n+\n+/// The base trait for numeric types\n+pub trait Num: Eq + Zero + One\n+             + Neg<Self>\n+             + Add<Self,Self>\n+             + Sub<Self,Self>\n+             + Mul<Self,Self>\n+             + Div<Self,Self>\n+             + Rem<Self,Self> {}\n+\n+/// Simultaneous division and remainder\n+#[inline]\n+pub fn div_rem<T: Div<T, T> + Rem<T, T>>(x: T, y: T) -> (T, T) {\n+    (x / y, x % y)\n+}\n+\n+/// Defines an additive identity element for `Self`.\n+///\n+/// # Deriving\n+///\n+/// This trait can be automatically be derived using `#[deriving(Zero)]`\n+/// attribute. If you choose to use this, make sure that the laws outlined in\n+/// the documentation for `Zero::zero` still hold.\n+pub trait Zero: Add<Self, Self> {\n+    /// Returns the additive identity element of `Self`, `0`.\n+    ///\n+    /// # Laws\n+    ///\n+    /// ~~~notrust\n+    /// a + 0 = a       \u2200 a \u2208 Self\n+    /// 0 + a = a       \u2200 a \u2208 Self\n+    /// ~~~\n+    ///\n+    /// # Purity\n+    ///\n+    /// This function should return the same result at all times regardless of\n+    /// external mutable state, for example values stored in TLS or in\n+    /// `static mut`s.\n+    // FIXME (#5527): This should be an associated constant\n+    fn zero() -> Self;\n+\n+    /// Returns `true` if `self` is equal to the additive identity.\n+    fn is_zero(&self) -> bool;\n+}\n+\n+/// Returns the additive identity, `0`.\n+#[inline(always)] pub fn zero<T: Zero>() -> T { Zero::zero() }\n+\n+/// Defines a multiplicative identity element for `Self`.\n+pub trait One: Mul<Self, Self> {\n+    /// Returns the multiplicative identity element of `Self`, `1`.\n+    ///\n+    /// # Laws\n+    ///\n+    /// ~~~notrust\n+    /// a * 1 = a       \u2200 a \u2208 Self\n+    /// 1 * a = a       \u2200 a \u2208 Self\n+    /// ~~~\n+    ///\n+    /// # Purity\n+    ///\n+    /// This function should return the same result at all times regardless of\n+    /// external mutable state, for example values stored in TLS or in\n+    /// `static mut`s.\n+    // FIXME (#5527): This should be an associated constant\n+    fn one() -> Self;\n+}\n+\n+/// Returns the multiplicative identity, `1`.\n+#[inline(always)] pub fn one<T: One>() -> T { One::one() }\n+\n+/// Useful functions for signed numbers (i.e. numbers that can be negative).\n+pub trait Signed: Num + Neg<Self> {\n+    /// Computes the absolute value.\n+    ///\n+    /// For float, f32, and f64, `NaN` will be returned if the number is `NaN`.\n+    fn abs(&self) -> Self;\n+\n+    /// The positive difference of two numbers.\n+    ///\n+    /// Returns `zero` if the number is less than or equal to `other`, otherwise the difference\n+    /// between `self` and `other` is returned.\n+    fn abs_sub(&self, other: &Self) -> Self;\n+\n+    /// Returns the sign of the number.\n+    ///\n+    /// For `float`, `f32`, `f64`:\n+    ///   * `1.0` if the number is positive, `+0.0` or `INFINITY`\n+    ///   * `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n+    ///   * `NaN` if the number is `NaN`\n+    ///\n+    /// For `int`:\n+    ///   * `0` if the number is zero\n+    ///   * `1` if the number is positive\n+    ///   * `-1` if the number is negative\n+    fn signum(&self) -> Self;\n+\n+    /// Returns true if the number is positive and false if the number is zero or negative.\n+    fn is_positive(&self) -> bool;\n+\n+    /// Returns true if the number is negative and false if the number is zero or positive.\n+    fn is_negative(&self) -> bool;\n+}\n+\n+/// Computes the absolute value.\n+///\n+/// For float, f32, and f64, `NaN` will be returned if the number is `NaN`\n+#[inline(always)]\n+pub fn abs<T: Signed>(value: T) -> T {\n+    value.abs()\n+}\n+\n+/// The positive difference of two numbers.\n+///\n+/// Returns `zero` if the number is less than or equal to `other`,\n+/// otherwise the difference between `self` and `other` is returned.\n+#[inline(always)]\n+pub fn abs_sub<T: Signed>(x: T, y: T) -> T {\n+    x.abs_sub(&y)\n+}\n+\n+/// Returns the sign of the number.\n+///\n+/// For float, f32, f64:\n+/// - `1.0` if the number is positive, `+0.0` or `INFINITY`\n+/// - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n+/// - `NAN` if the number is `NAN`\n+///\n+/// For int:\n+/// - `0` if the number is zero\n+/// - `1` if the number is positive\n+/// - `-1` if the number is negative\n+#[inline(always)] pub fn signum<T: Signed>(value: T) -> T { value.signum() }\n+\n+/// A trait for values which cannot be negative\n+pub trait Unsigned: Num {}\n+\n+/// Raises a value to the power of exp, using exponentiation by squaring.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::num;\n+///\n+/// assert_eq!(num::pow(2, 4), 16);\n+/// ```\n+#[inline]\n+pub fn pow<T: One + Mul<T, T>>(mut base: T, mut exp: uint) -> T {\n+    if exp == 1 { base }\n+    else {\n+        let mut acc = one::<T>();\n+        while exp > 0 {\n+            if (exp & 1) == 1 {\n+                acc = acc * base;\n+            }\n+            base = base * base;\n+            exp = exp >> 1;\n+        }\n+        acc\n+    }\n+}\n+\n+/// Numbers which have upper and lower bounds\n+pub trait Bounded {\n+    // FIXME (#5527): These should be associated constants\n+    /// returns the smallest finite number this type can represent\n+    fn min_value() -> Self;\n+    /// returns the largest finite number this type can represent\n+    fn max_value() -> Self;\n+}\n+\n+/// Numbers with a fixed binary representation.\n+pub trait Bitwise: Bounded\n+                 + Not<Self>\n+                 + BitAnd<Self,Self>\n+                 + BitOr<Self,Self>\n+                 + BitXor<Self,Self>\n+                 + Shl<Self,Self>\n+                 + Shr<Self,Self> {\n+    /// Returns the number of ones in the binary representation of the number.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::num::Bitwise;\n+    ///\n+    /// let n = 0b01001100u8;\n+    /// assert_eq!(n.count_ones(), 3);\n+    /// ```\n+    fn count_ones(&self) -> Self;\n+\n+    /// Returns the number of zeros in the binary representation of the number.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::num::Bitwise;\n+    ///\n+    /// let n = 0b01001100u8;\n+    /// assert_eq!(n.count_zeros(), 5);\n+    /// ```\n+    #[inline]\n+    fn count_zeros(&self) -> Self {\n+        (!*self).count_ones()\n+    }\n+\n+    /// Returns the number of leading zeros in the in the binary representation\n+    /// of the number.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::num::Bitwise;\n+    ///\n+    /// let n = 0b0101000u16;\n+    /// assert_eq!(n.leading_zeros(), 10);\n+    /// ```\n+    fn leading_zeros(&self) -> Self;\n+\n+    /// Returns the number of trailing zeros in the in the binary representation\n+    /// of the number.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::num::Bitwise;\n+    ///\n+    /// let n = 0b0101000u16;\n+    /// assert_eq!(n.trailing_zeros(), 3);\n+    /// ```\n+    fn trailing_zeros(&self) -> Self;\n+}\n+\n+/// Specifies the available operations common to all of Rust's core numeric primitives.\n+/// These may not always make sense from a purely mathematical point of view, but\n+/// may be useful for systems programming.\n+pub trait Primitive: Copy\n+                   + Clone\n+                   + Num\n+                   + NumCast\n+                   + Ord\n+                   + Bounded {}\n+\n+/// A collection of traits relevant to primitive signed and unsigned integers\n+pub trait Int: Primitive\n+             + Bitwise\n+             + CheckedAdd\n+             + CheckedSub\n+             + CheckedMul\n+             + CheckedDiv {}\n+\n+/// Returns the smallest power of 2 greater than or equal to `n`.\n+#[inline]\n+pub fn next_power_of_two<T: Unsigned + Int>(n: T) -> T {\n+    let halfbits: T = cast(size_of::<T>() * 4).unwrap();\n+    let mut tmp: T = n - one();\n+    let mut shift: T = one();\n+    while shift <= halfbits {\n+        tmp = tmp | (tmp >> shift);\n+        shift = shift << one();\n+    }\n+    tmp + one()\n+}\n+\n+// Returns `true` iff `n == 2^k` for some k.\n+#[inline]\n+pub fn is_power_of_two<T: Unsigned + Int>(n: T) -> bool {\n+    (n - one()) & n == zero()\n+}\n+\n+/// Returns the smallest power of 2 greater than or equal to `n`. If the next\n+/// power of two is greater than the type's maximum value, `None` is returned,\n+/// otherwise the power of 2 is wrapped in `Some`.\n+#[inline]\n+pub fn checked_next_power_of_two<T: Unsigned + Int>(n: T) -> Option<T> {\n+    let halfbits: T = cast(size_of::<T>() * 4).unwrap();\n+    let mut tmp: T = n - one();\n+    let mut shift: T = one();\n+    while shift <= halfbits {\n+        tmp = tmp | (tmp >> shift);\n+        shift = shift << one();\n+    }\n+    tmp.checked_add(&one())\n+}\n+\n+/// A generic trait for converting a value to a number.\n+pub trait ToPrimitive {\n+    /// Converts the value of `self` to an `int`.\n+    #[inline]\n+    fn to_int(&self) -> Option<int> {\n+        self.to_i64().and_then(|x| x.to_int())\n+    }\n+\n+    /// Converts the value of `self` to an `i8`.\n+    #[inline]\n+    fn to_i8(&self) -> Option<i8> {\n+        self.to_i64().and_then(|x| x.to_i8())\n+    }\n+\n+    /// Converts the value of `self` to an `i16`.\n+    #[inline]\n+    fn to_i16(&self) -> Option<i16> {\n+        self.to_i64().and_then(|x| x.to_i16())\n+    }\n+\n+    /// Converts the value of `self` to an `i32`.\n+    #[inline]\n+    fn to_i32(&self) -> Option<i32> {\n+        self.to_i64().and_then(|x| x.to_i32())\n+    }\n+\n+    /// Converts the value of `self` to an `i64`.\n+    fn to_i64(&self) -> Option<i64>;\n+\n+    /// Converts the value of `self` to an `uint`.\n+    #[inline]\n+    fn to_uint(&self) -> Option<uint> {\n+        self.to_u64().and_then(|x| x.to_uint())\n+    }\n+\n+    /// Converts the value of `self` to an `u8`.\n+    #[inline]\n+    fn to_u8(&self) -> Option<u8> {\n+        self.to_u64().and_then(|x| x.to_u8())\n+    }\n+\n+    /// Converts the value of `self` to an `u16`.\n+    #[inline]\n+    fn to_u16(&self) -> Option<u16> {\n+        self.to_u64().and_then(|x| x.to_u16())\n+    }\n+\n+    /// Converts the value of `self` to an `u32`.\n+    #[inline]\n+    fn to_u32(&self) -> Option<u32> {\n+        self.to_u64().and_then(|x| x.to_u32())\n+    }\n+\n+    /// Converts the value of `self` to an `u64`.\n+    #[inline]\n+    fn to_u64(&self) -> Option<u64>;\n+\n+    /// Converts the value of `self` to an `f32`.\n+    #[inline]\n+    fn to_f32(&self) -> Option<f32> {\n+        self.to_f64().and_then(|x| x.to_f32())\n+    }\n+\n+    /// Converts the value of `self` to an `f64`.\n+    #[inline]\n+    fn to_f64(&self) -> Option<f64> {\n+        self.to_i64().and_then(|x| x.to_f64())\n+    }\n+}\n+\n+macro_rules! impl_to_primitive_int_to_int(\n+    ($SrcT:ty, $DstT:ty) => (\n+        {\n+            if size_of::<$SrcT>() <= size_of::<$DstT>() {\n+                Some(*self as $DstT)\n+            } else {\n+                let n = *self as i64;\n+                let min_value: $DstT = Bounded::min_value();\n+                let max_value: $DstT = Bounded::max_value();\n+                if min_value as i64 <= n && n <= max_value as i64 {\n+                    Some(*self as $DstT)\n+                } else {\n+                    None\n+                }\n+            }\n+        }\n+    )\n+)\n+\n+macro_rules! impl_to_primitive_int_to_uint(\n+    ($SrcT:ty, $DstT:ty) => (\n+        {\n+            let zero: $SrcT = Zero::zero();\n+            let max_value: $DstT = Bounded::max_value();\n+            if zero <= *self && *self as u64 <= max_value as u64 {\n+                Some(*self as $DstT)\n+            } else {\n+                None\n+            }\n+        }\n+    )\n+)\n+\n+macro_rules! impl_to_primitive_int(\n+    ($T:ty) => (\n+        impl ToPrimitive for $T {\n+            #[inline]\n+            fn to_int(&self) -> Option<int> { impl_to_primitive_int_to_int!($T, int) }\n+            #[inline]\n+            fn to_i8(&self) -> Option<i8> { impl_to_primitive_int_to_int!($T, i8) }\n+            #[inline]\n+            fn to_i16(&self) -> Option<i16> { impl_to_primitive_int_to_int!($T, i16) }\n+            #[inline]\n+            fn to_i32(&self) -> Option<i32> { impl_to_primitive_int_to_int!($T, i32) }\n+            #[inline]\n+            fn to_i64(&self) -> Option<i64> { impl_to_primitive_int_to_int!($T, i64) }\n+\n+            #[inline]\n+            fn to_uint(&self) -> Option<uint> { impl_to_primitive_int_to_uint!($T, uint) }\n+            #[inline]\n+            fn to_u8(&self) -> Option<u8> { impl_to_primitive_int_to_uint!($T, u8) }\n+            #[inline]\n+            fn to_u16(&self) -> Option<u16> { impl_to_primitive_int_to_uint!($T, u16) }\n+            #[inline]\n+            fn to_u32(&self) -> Option<u32> { impl_to_primitive_int_to_uint!($T, u32) }\n+            #[inline]\n+            fn to_u64(&self) -> Option<u64> { impl_to_primitive_int_to_uint!($T, u64) }\n+\n+            #[inline]\n+            fn to_f32(&self) -> Option<f32> { Some(*self as f32) }\n+            #[inline]\n+            fn to_f64(&self) -> Option<f64> { Some(*self as f64) }\n+        }\n+    )\n+)\n+\n+impl_to_primitive_int!(int)\n+impl_to_primitive_int!(i8)\n+impl_to_primitive_int!(i16)\n+impl_to_primitive_int!(i32)\n+impl_to_primitive_int!(i64)\n+\n+macro_rules! impl_to_primitive_uint_to_int(\n+    ($DstT:ty) => (\n+        {\n+            let max_value: $DstT = Bounded::max_value();\n+            if *self as u64 <= max_value as u64 {\n+                Some(*self as $DstT)\n+            } else {\n+                None\n+            }\n+        }\n+    )\n+)\n+\n+macro_rules! impl_to_primitive_uint_to_uint(\n+    ($SrcT:ty, $DstT:ty) => (\n+        {\n+            if size_of::<$SrcT>() <= size_of::<$DstT>() {\n+                Some(*self as $DstT)\n+            } else {\n+                let zero: $SrcT = Zero::zero();\n+                let max_value: $DstT = Bounded::max_value();\n+                if zero <= *self && *self as u64 <= max_value as u64 {\n+                    Some(*self as $DstT)\n+                } else {\n+                    None\n+                }\n+            }\n+        }\n+    )\n+)\n+\n+macro_rules! impl_to_primitive_uint(\n+    ($T:ty) => (\n+        impl ToPrimitive for $T {\n+            #[inline]\n+            fn to_int(&self) -> Option<int> { impl_to_primitive_uint_to_int!(int) }\n+            #[inline]\n+            fn to_i8(&self) -> Option<i8> { impl_to_primitive_uint_to_int!(i8) }\n+            #[inline]\n+            fn to_i16(&self) -> Option<i16> { impl_to_primitive_uint_to_int!(i16) }\n+            #[inline]\n+            fn to_i32(&self) -> Option<i32> { impl_to_primitive_uint_to_int!(i32) }\n+            #[inline]\n+            fn to_i64(&self) -> Option<i64> { impl_to_primitive_uint_to_int!(i64) }\n+\n+            #[inline]\n+            fn to_uint(&self) -> Option<uint> { impl_to_primitive_uint_to_uint!($T, uint) }\n+            #[inline]\n+            fn to_u8(&self) -> Option<u8> { impl_to_primitive_uint_to_uint!($T, u8) }\n+            #[inline]\n+            fn to_u16(&self) -> Option<u16> { impl_to_primitive_uint_to_uint!($T, u16) }\n+            #[inline]\n+            fn to_u32(&self) -> Option<u32> { impl_to_primitive_uint_to_uint!($T, u32) }\n+            #[inline]\n+            fn to_u64(&self) -> Option<u64> { impl_to_primitive_uint_to_uint!($T, u64) }\n+\n+            #[inline]\n+            fn to_f32(&self) -> Option<f32> { Some(*self as f32) }\n+            #[inline]\n+            fn to_f64(&self) -> Option<f64> { Some(*self as f64) }\n+        }\n+    )\n+)\n+\n+impl_to_primitive_uint!(uint)\n+impl_to_primitive_uint!(u8)\n+impl_to_primitive_uint!(u16)\n+impl_to_primitive_uint!(u32)\n+impl_to_primitive_uint!(u64)\n+\n+macro_rules! impl_to_primitive_float_to_float(\n+    ($SrcT:ty, $DstT:ty) => (\n+        if size_of::<$SrcT>() <= size_of::<$DstT>() {\n+            Some(*self as $DstT)\n+        } else {\n+            let n = *self as f64;\n+            let max_value: $SrcT = Bounded::max_value();\n+            if -max_value as f64 <= n && n <= max_value as f64 {\n+                Some(*self as $DstT)\n+            } else {\n+                None\n+            }\n+        }\n+    )\n+)\n+\n+macro_rules! impl_to_primitive_float(\n+    ($T:ty) => (\n+        impl ToPrimitive for $T {\n+            #[inline]\n+            fn to_int(&self) -> Option<int> { Some(*self as int) }\n+            #[inline]\n+            fn to_i8(&self) -> Option<i8> { Some(*self as i8) }\n+            #[inline]\n+            fn to_i16(&self) -> Option<i16> { Some(*self as i16) }\n+            #[inline]\n+            fn to_i32(&self) -> Option<i32> { Some(*self as i32) }\n+            #[inline]\n+            fn to_i64(&self) -> Option<i64> { Some(*self as i64) }\n+\n+            #[inline]\n+            fn to_uint(&self) -> Option<uint> { Some(*self as uint) }\n+            #[inline]\n+            fn to_u8(&self) -> Option<u8> { Some(*self as u8) }\n+            #[inline]\n+            fn to_u16(&self) -> Option<u16> { Some(*self as u16) }\n+            #[inline]\n+            fn to_u32(&self) -> Option<u32> { Some(*self as u32) }\n+            #[inline]\n+            fn to_u64(&self) -> Option<u64> { Some(*self as u64) }\n+\n+            #[inline]\n+            fn to_f32(&self) -> Option<f32> { impl_to_primitive_float_to_float!($T, f32) }\n+            #[inline]\n+            fn to_f64(&self) -> Option<f64> { impl_to_primitive_float_to_float!($T, f64) }\n+        }\n+    )\n+)\n+\n+impl_to_primitive_float!(f32)\n+impl_to_primitive_float!(f64)\n+\n+/// A generic trait for converting a number to a value.\n+pub trait FromPrimitive {\n+    /// Convert an `int` to return an optional value of this type. If the\n+    /// value cannot be represented by this value, the `None` is returned.\n+    #[inline]\n+    fn from_int(n: int) -> Option<Self> {\n+        FromPrimitive::from_i64(n as i64)\n+    }\n+\n+    /// Convert an `i8` to return an optional value of this type. If the\n+    /// type cannot be represented by this value, the `None` is returned.\n+    #[inline]\n+    fn from_i8(n: i8) -> Option<Self> {\n+        FromPrimitive::from_i64(n as i64)\n+    }\n+\n+    /// Convert an `i16` to return an optional value of this type. If the\n+    /// type cannot be represented by this value, the `None` is returned.\n+    #[inline]\n+    fn from_i16(n: i16) -> Option<Self> {\n+        FromPrimitive::from_i64(n as i64)\n+    }\n+\n+    /// Convert an `i32` to return an optional value of this type. If the\n+    /// type cannot be represented by this value, the `None` is returned.\n+    #[inline]\n+    fn from_i32(n: i32) -> Option<Self> {\n+        FromPrimitive::from_i64(n as i64)\n+    }\n+\n+    /// Convert an `i64` to return an optional value of this type. If the\n+    /// type cannot be represented by this value, the `None` is returned.\n+    fn from_i64(n: i64) -> Option<Self>;\n+\n+    /// Convert an `uint` to return an optional value of this type. If the\n+    /// type cannot be represented by this value, the `None` is returned.\n+    #[inline]\n+    fn from_uint(n: uint) -> Option<Self> {\n+        FromPrimitive::from_u64(n as u64)\n+    }\n+\n+    /// Convert an `u8` to return an optional value of this type. If the\n+    /// type cannot be represented by this value, the `None` is returned.\n+    #[inline]\n+    fn from_u8(n: u8) -> Option<Self> {\n+        FromPrimitive::from_u64(n as u64)\n+    }\n+\n+    /// Convert an `u16` to return an optional value of this type. If the\n+    /// type cannot be represented by this value, the `None` is returned.\n+    #[inline]\n+    fn from_u16(n: u16) -> Option<Self> {\n+        FromPrimitive::from_u64(n as u64)\n+    }\n+\n+    /// Convert an `u32` to return an optional value of this type. If the\n+    /// type cannot be represented by this value, the `None` is returned.\n+    #[inline]\n+    fn from_u32(n: u32) -> Option<Self> {\n+        FromPrimitive::from_u64(n as u64)\n+    }\n+\n+    /// Convert an `u64` to return an optional value of this type. If the\n+    /// type cannot be represented by this value, the `None` is returned.\n+    fn from_u64(n: u64) -> Option<Self>;\n+\n+    /// Convert a `f32` to return an optional value of this type. If the\n+    /// type cannot be represented by this value, the `None` is returned.\n+    #[inline]\n+    fn from_f32(n: f32) -> Option<Self> {\n+        FromPrimitive::from_f64(n as f64)\n+    }\n+\n+    /// Convert a `f64` to return an optional value of this type. If the\n+    /// type cannot be represented by this value, the `None` is returned.\n+    #[inline]\n+    fn from_f64(n: f64) -> Option<Self> {\n+        FromPrimitive::from_i64(n as i64)\n+    }\n+}\n+\n+/// A utility function that just calls `FromPrimitive::from_int`.\n+pub fn from_int<A: FromPrimitive>(n: int) -> Option<A> {\n+    FromPrimitive::from_int(n)\n+}\n+\n+/// A utility function that just calls `FromPrimitive::from_i8`.\n+pub fn from_i8<A: FromPrimitive>(n: i8) -> Option<A> {\n+    FromPrimitive::from_i8(n)\n+}\n+\n+/// A utility function that just calls `FromPrimitive::from_i16`.\n+pub fn from_i16<A: FromPrimitive>(n: i16) -> Option<A> {\n+    FromPrimitive::from_i16(n)\n+}\n+\n+/// A utility function that just calls `FromPrimitive::from_i32`.\n+pub fn from_i32<A: FromPrimitive>(n: i32) -> Option<A> {\n+    FromPrimitive::from_i32(n)\n+}\n+\n+/// A utility function that just calls `FromPrimitive::from_i64`.\n+pub fn from_i64<A: FromPrimitive>(n: i64) -> Option<A> {\n+    FromPrimitive::from_i64(n)\n+}\n+\n+/// A utility function that just calls `FromPrimitive::from_uint`.\n+pub fn from_uint<A: FromPrimitive>(n: uint) -> Option<A> {\n+    FromPrimitive::from_uint(n)\n+}\n+\n+/// A utility function that just calls `FromPrimitive::from_u8`.\n+pub fn from_u8<A: FromPrimitive>(n: u8) -> Option<A> {\n+    FromPrimitive::from_u8(n)\n+}\n+\n+/// A utility function that just calls `FromPrimitive::from_u16`.\n+pub fn from_u16<A: FromPrimitive>(n: u16) -> Option<A> {\n+    FromPrimitive::from_u16(n)\n+}\n+\n+/// A utility function that just calls `FromPrimitive::from_u32`.\n+pub fn from_u32<A: FromPrimitive>(n: u32) -> Option<A> {\n+    FromPrimitive::from_u32(n)\n+}\n+\n+/// A utility function that just calls `FromPrimitive::from_u64`.\n+pub fn from_u64<A: FromPrimitive>(n: u64) -> Option<A> {\n+    FromPrimitive::from_u64(n)\n+}\n+\n+/// A utility function that just calls `FromPrimitive::from_f32`.\n+pub fn from_f32<A: FromPrimitive>(n: f32) -> Option<A> {\n+    FromPrimitive::from_f32(n)\n+}\n+\n+/// A utility function that just calls `FromPrimitive::from_f64`.\n+pub fn from_f64<A: FromPrimitive>(n: f64) -> Option<A> {\n+    FromPrimitive::from_f64(n)\n+}\n+\n+macro_rules! impl_from_primitive(\n+    ($T:ty, $to_ty:expr) => (\n+        impl FromPrimitive for $T {\n+            #[inline] fn from_int(n: int) -> Option<$T> { $to_ty }\n+            #[inline] fn from_i8(n: i8) -> Option<$T> { $to_ty }\n+            #[inline] fn from_i16(n: i16) -> Option<$T> { $to_ty }\n+            #[inline] fn from_i32(n: i32) -> Option<$T> { $to_ty }\n+            #[inline] fn from_i64(n: i64) -> Option<$T> { $to_ty }\n+\n+            #[inline] fn from_uint(n: uint) -> Option<$T> { $to_ty }\n+            #[inline] fn from_u8(n: u8) -> Option<$T> { $to_ty }\n+            #[inline] fn from_u16(n: u16) -> Option<$T> { $to_ty }\n+            #[inline] fn from_u32(n: u32) -> Option<$T> { $to_ty }\n+            #[inline] fn from_u64(n: u64) -> Option<$T> { $to_ty }\n+\n+            #[inline] fn from_f32(n: f32) -> Option<$T> { $to_ty }\n+            #[inline] fn from_f64(n: f64) -> Option<$T> { $to_ty }\n+        }\n+    )\n+)\n+\n+impl_from_primitive!(int, n.to_int())\n+impl_from_primitive!(i8, n.to_i8())\n+impl_from_primitive!(i16, n.to_i16())\n+impl_from_primitive!(i32, n.to_i32())\n+impl_from_primitive!(i64, n.to_i64())\n+impl_from_primitive!(uint, n.to_uint())\n+impl_from_primitive!(u8, n.to_u8())\n+impl_from_primitive!(u16, n.to_u16())\n+impl_from_primitive!(u32, n.to_u32())\n+impl_from_primitive!(u64, n.to_u64())\n+impl_from_primitive!(f32, n.to_f32())\n+impl_from_primitive!(f64, n.to_f64())\n+\n+/// Cast from one machine scalar to another.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use std::num;\n+///\n+/// let twenty: f32 = num::cast(0x14).unwrap();\n+/// assert_eq!(twenty, 20f32);\n+/// ```\n+///\n+#[inline]\n+pub fn cast<T: NumCast,U: NumCast>(n: T) -> Option<U> {\n+    NumCast::from(n)\n+}\n+\n+/// An interface for casting between machine scalars.\n+pub trait NumCast: ToPrimitive {\n+    /// Creates a number from another value that can be converted into a primitive via the\n+    /// `ToPrimitive` trait.\n+    fn from<T: ToPrimitive>(n: T) -> Option<Self>;\n+}\n+\n+macro_rules! impl_num_cast(\n+    ($T:ty, $conv:ident) => (\n+        impl NumCast for $T {\n+            #[inline]\n+            fn from<N: ToPrimitive>(n: N) -> Option<$T> {\n+                // `$conv` could be generated using `concat_idents!`, but that\n+                // macro seems to be broken at the moment\n+                n.$conv()\n+            }\n+        }\n+    )\n+)\n+\n+impl_num_cast!(u8,    to_u8)\n+impl_num_cast!(u16,   to_u16)\n+impl_num_cast!(u32,   to_u32)\n+impl_num_cast!(u64,   to_u64)\n+impl_num_cast!(uint,  to_uint)\n+impl_num_cast!(i8,    to_i8)\n+impl_num_cast!(i16,   to_i16)\n+impl_num_cast!(i32,   to_i32)\n+impl_num_cast!(i64,   to_i64)\n+impl_num_cast!(int,   to_int)\n+impl_num_cast!(f32,   to_f32)\n+impl_num_cast!(f64,   to_f64)\n+\n+/// Saturating math operations\n+pub trait Saturating {\n+    /// Saturating addition operator.\n+    /// Returns a+b, saturating at the numeric bounds instead of overflowing.\n+    fn saturating_add(self, v: Self) -> Self;\n+\n+    /// Saturating subtraction operator.\n+    /// Returns a-b, saturating at the numeric bounds instead of overflowing.\n+    fn saturating_sub(self, v: Self) -> Self;\n+}\n+\n+impl<T: CheckedAdd + CheckedSub + Zero + Ord + Bounded> Saturating for T {\n+    #[inline]\n+    fn saturating_add(self, v: T) -> T {\n+        match self.checked_add(&v) {\n+            Some(x) => x,\n+            None => if v >= Zero::zero() {\n+                Bounded::max_value()\n+            } else {\n+                Bounded::min_value()\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn saturating_sub(self, v: T) -> T {\n+        match self.checked_sub(&v) {\n+            Some(x) => x,\n+            None => if v >= Zero::zero() {\n+                Bounded::min_value()\n+            } else {\n+                Bounded::max_value()\n+            }\n+        }\n+    }\n+}\n+\n+/// Performs addition that returns `None` instead of wrapping around on overflow.\n+pub trait CheckedAdd: Add<Self, Self> {\n+    /// Adds two numbers, checking for overflow. If overflow happens, `None` is returned.\n+    fn checked_add(&self, v: &Self) -> Option<Self>;\n+}\n+\n+/// Performs subtraction that returns `None` instead of wrapping around on underflow.\n+pub trait CheckedSub: Sub<Self, Self> {\n+    /// Subtracts two numbers, checking for underflow. If underflow happens, `None` is returned.\n+    fn checked_sub(&self, v: &Self) -> Option<Self>;\n+}\n+\n+/// Performs multiplication that returns `None` instead of wrapping around on underflow or\n+/// overflow.\n+pub trait CheckedMul: Mul<Self, Self> {\n+    /// Multiplies two numbers, checking for underflow or overflow. If underflow or overflow\n+    /// happens, `None` is returned.\n+    fn checked_mul(&self, v: &Self) -> Option<Self>;\n+}\n+\n+/// Performs division that returns `None` instead of wrapping around on underflow or overflow.\n+pub trait CheckedDiv: Div<Self, Self> {\n+    /// Divides two numbers, checking for underflow or overflow. If underflow or overflow happens,\n+    /// `None` is returned.\n+    fn checked_div(&self, v: &Self) -> Option<Self>;\n+}"}, {"sha": "1efd7cad300bfca9b0144c0ba89ee4bfa11a58fe", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 15, "deletions": 849, "changes": 864, "blob_url": "https://github.com/rust-lang/rust/blob/0c302938866cbccdecdcd78b42bb46106fdfa28e/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c302938866cbccdecdcd78b42bb46106fdfa28e/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=0c302938866cbccdecdcd78b42bb46106fdfa28e", "patch": "@@ -15,306 +15,24 @@\n \n #![allow(missing_doc)]\n \n-use clone::Clone;\n-use cmp::{Eq, Ord};\n-use kinds::Copy;\n-use mem::size_of;\n-use ops::{Add, Sub, Mul, Div, Rem, Neg};\n-use ops::{Not, BitAnd, BitOr, BitXor, Shl, Shr};\n-use option::{Option, Some, None};\n-use fmt::{Show, Binary, Octal, LowerHex, UpperHex};\n+use option::{Option};\n+\n+#[cfg(test)] use fmt::Show;\n+\n+pub use core::num::{Num, div_rem, Zero, zero, One, one};\n+pub use core::num::{Signed, abs, abs_sub, signum};\n+pub use core::num::{Unsigned, pow, Bounded, Bitwise};\n+pub use core::num::{Primitive, Int, Saturating};\n+pub use core::num::{CheckedAdd, CheckedSub, CheckedMul, CheckedDiv};\n+pub use core::num::{cast, FromPrimitive, NumCast, ToPrimitive};\n+pub use core::num::{next_power_of_two, is_power_of_two};\n+pub use core::num::{checked_next_power_of_two};\n+pub use core::num::{from_int, from_i8, from_i16, from_i32, from_i64};\n+pub use core::num::{from_uint, from_u8, from_u16, from_u32, from_u64};\n+pub use core::num::{from_f32, from_f64};\n \n pub mod strconv;\n \n-/// The base trait for numeric types\n-pub trait Num: Eq + Zero + One\n-             + Neg<Self>\n-             + Add<Self,Self>\n-             + Sub<Self,Self>\n-             + Mul<Self,Self>\n-             + Div<Self,Self>\n-             + Rem<Self,Self> {}\n-\n-/// Simultaneous division and remainder\n-#[inline]\n-pub fn div_rem<T: Div<T, T> + Rem<T, T>>(x: T, y: T) -> (T, T) {\n-    (x / y, x % y)\n-}\n-\n-/// Defines an additive identity element for `Self`.\n-///\n-/// # Deriving\n-///\n-/// This trait can be automatically be derived using `#[deriving(Zero)]`\n-/// attribute. If you choose to use this, make sure that the laws outlined in\n-/// the documentation for `Zero::zero` still hold.\n-pub trait Zero: Add<Self, Self> {\n-    /// Returns the additive identity element of `Self`, `0`.\n-    ///\n-    /// # Laws\n-    ///\n-    /// ~~~notrust\n-    /// a + 0 = a       \u2200 a \u2208 Self\n-    /// 0 + a = a       \u2200 a \u2208 Self\n-    /// ~~~\n-    ///\n-    /// # Purity\n-    ///\n-    /// This function should return the same result at all times regardless of\n-    /// external mutable state, for example values stored in TLS or in\n-    /// `static mut`s.\n-    // FIXME (#5527): This should be an associated constant\n-    fn zero() -> Self;\n-\n-    /// Returns `true` if `self` is equal to the additive identity.\n-    fn is_zero(&self) -> bool;\n-}\n-\n-/// Returns the additive identity, `0`.\n-#[inline(always)] pub fn zero<T: Zero>() -> T { Zero::zero() }\n-\n-/// Defines a multiplicative identity element for `Self`.\n-pub trait One: Mul<Self, Self> {\n-    /// Returns the multiplicative identity element of `Self`, `1`.\n-    ///\n-    /// # Laws\n-    ///\n-    /// ~~~notrust\n-    /// a * 1 = a       \u2200 a \u2208 Self\n-    /// 1 * a = a       \u2200 a \u2208 Self\n-    /// ~~~\n-    ///\n-    /// # Purity\n-    ///\n-    /// This function should return the same result at all times regardless of\n-    /// external mutable state, for example values stored in TLS or in\n-    /// `static mut`s.\n-    // FIXME (#5527): This should be an associated constant\n-    fn one() -> Self;\n-}\n-\n-/// Returns the multiplicative identity, `1`.\n-#[inline(always)] pub fn one<T: One>() -> T { One::one() }\n-\n-/// Useful functions for signed numbers (i.e. numbers that can be negative).\n-pub trait Signed: Num + Neg<Self> {\n-    /// Computes the absolute value.\n-    ///\n-    /// For float, f32, and f64, `NaN` will be returned if the number is `NaN`.\n-    fn abs(&self) -> Self;\n-\n-    /// The positive difference of two numbers.\n-    ///\n-    /// Returns `zero` if the number is less than or equal to `other`, otherwise the difference\n-    /// between `self` and `other` is returned.\n-    fn abs_sub(&self, other: &Self) -> Self;\n-\n-    /// Returns the sign of the number.\n-    ///\n-    /// For `float`, `f32`, `f64`:\n-    ///   * `1.0` if the number is positive, `+0.0` or `INFINITY`\n-    ///   * `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n-    ///   * `NaN` if the number is `NaN`\n-    ///\n-    /// For `int`:\n-    ///   * `0` if the number is zero\n-    ///   * `1` if the number is positive\n-    ///   * `-1` if the number is negative\n-    fn signum(&self) -> Self;\n-\n-    /// Returns true if the number is positive and false if the number is zero or negative.\n-    fn is_positive(&self) -> bool;\n-\n-    /// Returns true if the number is negative and false if the number is zero or positive.\n-    fn is_negative(&self) -> bool;\n-}\n-\n-/// Computes the absolute value.\n-///\n-/// For float, f32, and f64, `NaN` will be returned if the number is `NaN`\n-#[inline(always)]\n-pub fn abs<T: Signed>(value: T) -> T {\n-    value.abs()\n-}\n-\n-/// The positive difference of two numbers.\n-///\n-/// Returns `zero` if the number is less than or equal to `other`,\n-/// otherwise the difference between `self` and `other` is returned.\n-#[inline(always)]\n-pub fn abs_sub<T: Signed>(x: T, y: T) -> T {\n-    x.abs_sub(&y)\n-}\n-\n-/// Returns the sign of the number.\n-///\n-/// For float, f32, f64:\n-/// - `1.0` if the number is positive, `+0.0` or `INFINITY`\n-/// - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n-/// - `NAN` if the number is `NAN`\n-///\n-/// For int:\n-/// - `0` if the number is zero\n-/// - `1` if the number is positive\n-/// - `-1` if the number is negative\n-#[inline(always)] pub fn signum<T: Signed>(value: T) -> T { value.signum() }\n-\n-/// A trait for values which cannot be negative\n-pub trait Unsigned: Num {}\n-\n-/// Raises a value to the power of exp, using exponentiation by squaring.\n-///\n-/// # Example\n-///\n-/// ```rust\n-/// use std::num;\n-///\n-/// assert_eq!(num::pow(2, 4), 16);\n-/// ```\n-#[inline]\n-pub fn pow<T: One + Mul<T, T>>(mut base: T, mut exp: uint) -> T {\n-    if exp == 1 { base }\n-    else {\n-        let mut acc = one::<T>();\n-        while exp > 0 {\n-            if (exp & 1) == 1 {\n-                acc = acc * base;\n-            }\n-            base = base * base;\n-            exp = exp >> 1;\n-        }\n-        acc\n-    }\n-}\n-\n-/// Numbers which have upper and lower bounds\n-pub trait Bounded {\n-    // FIXME (#5527): These should be associated constants\n-    /// returns the smallest finite number this type can represent\n-    fn min_value() -> Self;\n-    /// returns the largest finite number this type can represent\n-    fn max_value() -> Self;\n-}\n-\n-/// Numbers with a fixed binary representation.\n-pub trait Bitwise: Bounded\n-                 + Not<Self>\n-                 + BitAnd<Self,Self>\n-                 + BitOr<Self,Self>\n-                 + BitXor<Self,Self>\n-                 + Shl<Self,Self>\n-                 + Shr<Self,Self> {\n-    /// Returns the number of ones in the binary representation of the number.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// use std::num::Bitwise;\n-    ///\n-    /// let n = 0b01001100u8;\n-    /// assert_eq!(n.count_ones(), 3);\n-    /// ```\n-    fn count_ones(&self) -> Self;\n-\n-    /// Returns the number of zeros in the binary representation of the number.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// use std::num::Bitwise;\n-    ///\n-    /// let n = 0b01001100u8;\n-    /// assert_eq!(n.count_zeros(), 5);\n-    /// ```\n-    #[inline]\n-    fn count_zeros(&self) -> Self {\n-        (!*self).count_ones()\n-    }\n-\n-    /// Returns the number of leading zeros in the in the binary representation\n-    /// of the number.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// use std::num::Bitwise;\n-    ///\n-    /// let n = 0b0101000u16;\n-    /// assert_eq!(n.leading_zeros(), 10);\n-    /// ```\n-    fn leading_zeros(&self) -> Self;\n-\n-    /// Returns the number of trailing zeros in the in the binary representation\n-    /// of the number.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// use std::num::Bitwise;\n-    ///\n-    /// let n = 0b0101000u16;\n-    /// assert_eq!(n.trailing_zeros(), 3);\n-    /// ```\n-    fn trailing_zeros(&self) -> Self;\n-}\n-\n-/// Specifies the available operations common to all of Rust's core numeric primitives.\n-/// These may not always make sense from a purely mathematical point of view, but\n-/// may be useful for systems programming.\n-pub trait Primitive: Copy\n-                   + Clone\n-                   + Num\n-                   + NumCast\n-                   + Ord\n-                   + Bounded {}\n-\n-/// A collection of traits relevant to primitive signed and unsigned integers\n-pub trait Int: Primitive\n-             + Bitwise\n-             + CheckedAdd\n-             + CheckedSub\n-             + CheckedMul\n-             + CheckedDiv\n-             + Show\n-             + Binary\n-             + Octal\n-             + LowerHex\n-             + UpperHex {}\n-\n-/// Returns the smallest power of 2 greater than or equal to `n`.\n-#[inline]\n-pub fn next_power_of_two<T: Unsigned + Int>(n: T) -> T {\n-    let halfbits: T = cast(size_of::<T>() * 4).unwrap();\n-    let mut tmp: T = n - one();\n-    let mut shift: T = one();\n-    while shift <= halfbits {\n-        tmp = tmp | (tmp >> shift);\n-        shift = shift << one();\n-    }\n-    tmp + one()\n-}\n-\n-// Returns `true` iff `n == 2^k` for some k.\n-#[inline]\n-pub fn is_power_of_two<T: Unsigned + Int>(n: T) -> bool {\n-    (n - one()) & n == zero()\n-}\n-\n-/// Returns the smallest power of 2 greater than or equal to `n`. If the next\n-/// power of two is greater than the type's maximum value, `None` is returned,\n-/// otherwise the power of 2 is wrapped in `Some`.\n-#[inline]\n-pub fn checked_next_power_of_two<T: Unsigned + Int>(n: T) -> Option<T> {\n-    let halfbits: T = cast(size_of::<T>() * 4).unwrap();\n-    let mut tmp: T = n - one();\n-    let mut shift: T = one();\n-    while shift <= halfbits {\n-        tmp = tmp | (tmp >> shift);\n-        shift = shift << one();\n-    }\n-    tmp.checked_add(&one())\n-}\n-\n /// Used for representing the classification of floating point numbers\n #[deriving(Eq, Show)]\n pub enum FPCategory {\n@@ -537,494 +255,6 @@ pub trait Float: Signed + Primitive {\n     fn to_radians(self) -> Self;\n }\n \n-/// A generic trait for converting a value to a number.\n-pub trait ToPrimitive {\n-    /// Converts the value of `self` to an `int`.\n-    #[inline]\n-    fn to_int(&self) -> Option<int> {\n-        self.to_i64().and_then(|x| x.to_int())\n-    }\n-\n-    /// Converts the value of `self` to an `i8`.\n-    #[inline]\n-    fn to_i8(&self) -> Option<i8> {\n-        self.to_i64().and_then(|x| x.to_i8())\n-    }\n-\n-    /// Converts the value of `self` to an `i16`.\n-    #[inline]\n-    fn to_i16(&self) -> Option<i16> {\n-        self.to_i64().and_then(|x| x.to_i16())\n-    }\n-\n-    /// Converts the value of `self` to an `i32`.\n-    #[inline]\n-    fn to_i32(&self) -> Option<i32> {\n-        self.to_i64().and_then(|x| x.to_i32())\n-    }\n-\n-    /// Converts the value of `self` to an `i64`.\n-    fn to_i64(&self) -> Option<i64>;\n-\n-    /// Converts the value of `self` to an `uint`.\n-    #[inline]\n-    fn to_uint(&self) -> Option<uint> {\n-        self.to_u64().and_then(|x| x.to_uint())\n-    }\n-\n-    /// Converts the value of `self` to an `u8`.\n-    #[inline]\n-    fn to_u8(&self) -> Option<u8> {\n-        self.to_u64().and_then(|x| x.to_u8())\n-    }\n-\n-    /// Converts the value of `self` to an `u16`.\n-    #[inline]\n-    fn to_u16(&self) -> Option<u16> {\n-        self.to_u64().and_then(|x| x.to_u16())\n-    }\n-\n-    /// Converts the value of `self` to an `u32`.\n-    #[inline]\n-    fn to_u32(&self) -> Option<u32> {\n-        self.to_u64().and_then(|x| x.to_u32())\n-    }\n-\n-    /// Converts the value of `self` to an `u64`.\n-    #[inline]\n-    fn to_u64(&self) -> Option<u64>;\n-\n-    /// Converts the value of `self` to an `f32`.\n-    #[inline]\n-    fn to_f32(&self) -> Option<f32> {\n-        self.to_f64().and_then(|x| x.to_f32())\n-    }\n-\n-    /// Converts the value of `self` to an `f64`.\n-    #[inline]\n-    fn to_f64(&self) -> Option<f64> {\n-        self.to_i64().and_then(|x| x.to_f64())\n-    }\n-}\n-\n-macro_rules! impl_to_primitive_int_to_int(\n-    ($SrcT:ty, $DstT:ty) => (\n-        {\n-            if size_of::<$SrcT>() <= size_of::<$DstT>() {\n-                Some(*self as $DstT)\n-            } else {\n-                let n = *self as i64;\n-                let min_value: $DstT = Bounded::min_value();\n-                let max_value: $DstT = Bounded::max_value();\n-                if min_value as i64 <= n && n <= max_value as i64 {\n-                    Some(*self as $DstT)\n-                } else {\n-                    None\n-                }\n-            }\n-        }\n-    )\n-)\n-\n-macro_rules! impl_to_primitive_int_to_uint(\n-    ($SrcT:ty, $DstT:ty) => (\n-        {\n-            let zero: $SrcT = Zero::zero();\n-            let max_value: $DstT = Bounded::max_value();\n-            if zero <= *self && *self as u64 <= max_value as u64 {\n-                Some(*self as $DstT)\n-            } else {\n-                None\n-            }\n-        }\n-    )\n-)\n-\n-macro_rules! impl_to_primitive_int(\n-    ($T:ty) => (\n-        impl ToPrimitive for $T {\n-            #[inline]\n-            fn to_int(&self) -> Option<int> { impl_to_primitive_int_to_int!($T, int) }\n-            #[inline]\n-            fn to_i8(&self) -> Option<i8> { impl_to_primitive_int_to_int!($T, i8) }\n-            #[inline]\n-            fn to_i16(&self) -> Option<i16> { impl_to_primitive_int_to_int!($T, i16) }\n-            #[inline]\n-            fn to_i32(&self) -> Option<i32> { impl_to_primitive_int_to_int!($T, i32) }\n-            #[inline]\n-            fn to_i64(&self) -> Option<i64> { impl_to_primitive_int_to_int!($T, i64) }\n-\n-            #[inline]\n-            fn to_uint(&self) -> Option<uint> { impl_to_primitive_int_to_uint!($T, uint) }\n-            #[inline]\n-            fn to_u8(&self) -> Option<u8> { impl_to_primitive_int_to_uint!($T, u8) }\n-            #[inline]\n-            fn to_u16(&self) -> Option<u16> { impl_to_primitive_int_to_uint!($T, u16) }\n-            #[inline]\n-            fn to_u32(&self) -> Option<u32> { impl_to_primitive_int_to_uint!($T, u32) }\n-            #[inline]\n-            fn to_u64(&self) -> Option<u64> { impl_to_primitive_int_to_uint!($T, u64) }\n-\n-            #[inline]\n-            fn to_f32(&self) -> Option<f32> { Some(*self as f32) }\n-            #[inline]\n-            fn to_f64(&self) -> Option<f64> { Some(*self as f64) }\n-        }\n-    )\n-)\n-\n-impl_to_primitive_int!(int)\n-impl_to_primitive_int!(i8)\n-impl_to_primitive_int!(i16)\n-impl_to_primitive_int!(i32)\n-impl_to_primitive_int!(i64)\n-\n-macro_rules! impl_to_primitive_uint_to_int(\n-    ($DstT:ty) => (\n-        {\n-            let max_value: $DstT = Bounded::max_value();\n-            if *self as u64 <= max_value as u64 {\n-                Some(*self as $DstT)\n-            } else {\n-                None\n-            }\n-        }\n-    )\n-)\n-\n-macro_rules! impl_to_primitive_uint_to_uint(\n-    ($SrcT:ty, $DstT:ty) => (\n-        {\n-            if size_of::<$SrcT>() <= size_of::<$DstT>() {\n-                Some(*self as $DstT)\n-            } else {\n-                let zero: $SrcT = Zero::zero();\n-                let max_value: $DstT = Bounded::max_value();\n-                if zero <= *self && *self as u64 <= max_value as u64 {\n-                    Some(*self as $DstT)\n-                } else {\n-                    None\n-                }\n-            }\n-        }\n-    )\n-)\n-\n-macro_rules! impl_to_primitive_uint(\n-    ($T:ty) => (\n-        impl ToPrimitive for $T {\n-            #[inline]\n-            fn to_int(&self) -> Option<int> { impl_to_primitive_uint_to_int!(int) }\n-            #[inline]\n-            fn to_i8(&self) -> Option<i8> { impl_to_primitive_uint_to_int!(i8) }\n-            #[inline]\n-            fn to_i16(&self) -> Option<i16> { impl_to_primitive_uint_to_int!(i16) }\n-            #[inline]\n-            fn to_i32(&self) -> Option<i32> { impl_to_primitive_uint_to_int!(i32) }\n-            #[inline]\n-            fn to_i64(&self) -> Option<i64> { impl_to_primitive_uint_to_int!(i64) }\n-\n-            #[inline]\n-            fn to_uint(&self) -> Option<uint> { impl_to_primitive_uint_to_uint!($T, uint) }\n-            #[inline]\n-            fn to_u8(&self) -> Option<u8> { impl_to_primitive_uint_to_uint!($T, u8) }\n-            #[inline]\n-            fn to_u16(&self) -> Option<u16> { impl_to_primitive_uint_to_uint!($T, u16) }\n-            #[inline]\n-            fn to_u32(&self) -> Option<u32> { impl_to_primitive_uint_to_uint!($T, u32) }\n-            #[inline]\n-            fn to_u64(&self) -> Option<u64> { impl_to_primitive_uint_to_uint!($T, u64) }\n-\n-            #[inline]\n-            fn to_f32(&self) -> Option<f32> { Some(*self as f32) }\n-            #[inline]\n-            fn to_f64(&self) -> Option<f64> { Some(*self as f64) }\n-        }\n-    )\n-)\n-\n-impl_to_primitive_uint!(uint)\n-impl_to_primitive_uint!(u8)\n-impl_to_primitive_uint!(u16)\n-impl_to_primitive_uint!(u32)\n-impl_to_primitive_uint!(u64)\n-\n-macro_rules! impl_to_primitive_float_to_float(\n-    ($SrcT:ty, $DstT:ty) => (\n-        if size_of::<$SrcT>() <= size_of::<$DstT>() {\n-            Some(*self as $DstT)\n-        } else {\n-            let n = *self as f64;\n-            let max_value: $SrcT = Bounded::max_value();\n-            if -max_value as f64 <= n && n <= max_value as f64 {\n-                Some(*self as $DstT)\n-            } else {\n-                None\n-            }\n-        }\n-    )\n-)\n-\n-macro_rules! impl_to_primitive_float(\n-    ($T:ty) => (\n-        impl ToPrimitive for $T {\n-            #[inline]\n-            fn to_int(&self) -> Option<int> { Some(*self as int) }\n-            #[inline]\n-            fn to_i8(&self) -> Option<i8> { Some(*self as i8) }\n-            #[inline]\n-            fn to_i16(&self) -> Option<i16> { Some(*self as i16) }\n-            #[inline]\n-            fn to_i32(&self) -> Option<i32> { Some(*self as i32) }\n-            #[inline]\n-            fn to_i64(&self) -> Option<i64> { Some(*self as i64) }\n-\n-            #[inline]\n-            fn to_uint(&self) -> Option<uint> { Some(*self as uint) }\n-            #[inline]\n-            fn to_u8(&self) -> Option<u8> { Some(*self as u8) }\n-            #[inline]\n-            fn to_u16(&self) -> Option<u16> { Some(*self as u16) }\n-            #[inline]\n-            fn to_u32(&self) -> Option<u32> { Some(*self as u32) }\n-            #[inline]\n-            fn to_u64(&self) -> Option<u64> { Some(*self as u64) }\n-\n-            #[inline]\n-            fn to_f32(&self) -> Option<f32> { impl_to_primitive_float_to_float!($T, f32) }\n-            #[inline]\n-            fn to_f64(&self) -> Option<f64> { impl_to_primitive_float_to_float!($T, f64) }\n-        }\n-    )\n-)\n-\n-impl_to_primitive_float!(f32)\n-impl_to_primitive_float!(f64)\n-\n-/// A generic trait for converting a number to a value.\n-pub trait FromPrimitive {\n-    /// Convert an `int` to return an optional value of this type. If the\n-    /// value cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    fn from_int(n: int) -> Option<Self> {\n-        FromPrimitive::from_i64(n as i64)\n-    }\n-\n-    /// Convert an `i8` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    fn from_i8(n: i8) -> Option<Self> {\n-        FromPrimitive::from_i64(n as i64)\n-    }\n-\n-    /// Convert an `i16` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    fn from_i16(n: i16) -> Option<Self> {\n-        FromPrimitive::from_i64(n as i64)\n-    }\n-\n-    /// Convert an `i32` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    fn from_i32(n: i32) -> Option<Self> {\n-        FromPrimitive::from_i64(n as i64)\n-    }\n-\n-    /// Convert an `i64` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    fn from_i64(n: i64) -> Option<Self>;\n-\n-    /// Convert an `uint` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    fn from_uint(n: uint) -> Option<Self> {\n-        FromPrimitive::from_u64(n as u64)\n-    }\n-\n-    /// Convert an `u8` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    fn from_u8(n: u8) -> Option<Self> {\n-        FromPrimitive::from_u64(n as u64)\n-    }\n-\n-    /// Convert an `u16` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    fn from_u16(n: u16) -> Option<Self> {\n-        FromPrimitive::from_u64(n as u64)\n-    }\n-\n-    /// Convert an `u32` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    fn from_u32(n: u32) -> Option<Self> {\n-        FromPrimitive::from_u64(n as u64)\n-    }\n-\n-    /// Convert an `u64` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    fn from_u64(n: u64) -> Option<Self>;\n-\n-    /// Convert a `f32` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    fn from_f32(n: f32) -> Option<Self> {\n-        FromPrimitive::from_f64(n as f64)\n-    }\n-\n-    /// Convert a `f64` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    fn from_f64(n: f64) -> Option<Self> {\n-        FromPrimitive::from_i64(n as i64)\n-    }\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_int`.\n-pub fn from_int<A: FromPrimitive>(n: int) -> Option<A> {\n-    FromPrimitive::from_int(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_i8`.\n-pub fn from_i8<A: FromPrimitive>(n: i8) -> Option<A> {\n-    FromPrimitive::from_i8(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_i16`.\n-pub fn from_i16<A: FromPrimitive>(n: i16) -> Option<A> {\n-    FromPrimitive::from_i16(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_i32`.\n-pub fn from_i32<A: FromPrimitive>(n: i32) -> Option<A> {\n-    FromPrimitive::from_i32(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_i64`.\n-pub fn from_i64<A: FromPrimitive>(n: i64) -> Option<A> {\n-    FromPrimitive::from_i64(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_uint`.\n-pub fn from_uint<A: FromPrimitive>(n: uint) -> Option<A> {\n-    FromPrimitive::from_uint(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_u8`.\n-pub fn from_u8<A: FromPrimitive>(n: u8) -> Option<A> {\n-    FromPrimitive::from_u8(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_u16`.\n-pub fn from_u16<A: FromPrimitive>(n: u16) -> Option<A> {\n-    FromPrimitive::from_u16(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_u32`.\n-pub fn from_u32<A: FromPrimitive>(n: u32) -> Option<A> {\n-    FromPrimitive::from_u32(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_u64`.\n-pub fn from_u64<A: FromPrimitive>(n: u64) -> Option<A> {\n-    FromPrimitive::from_u64(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_f32`.\n-pub fn from_f32<A: FromPrimitive>(n: f32) -> Option<A> {\n-    FromPrimitive::from_f32(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_f64`.\n-pub fn from_f64<A: FromPrimitive>(n: f64) -> Option<A> {\n-    FromPrimitive::from_f64(n)\n-}\n-\n-macro_rules! impl_from_primitive(\n-    ($T:ty, $to_ty:expr) => (\n-        impl FromPrimitive for $T {\n-            #[inline] fn from_int(n: int) -> Option<$T> { $to_ty }\n-            #[inline] fn from_i8(n: i8) -> Option<$T> { $to_ty }\n-            #[inline] fn from_i16(n: i16) -> Option<$T> { $to_ty }\n-            #[inline] fn from_i32(n: i32) -> Option<$T> { $to_ty }\n-            #[inline] fn from_i64(n: i64) -> Option<$T> { $to_ty }\n-\n-            #[inline] fn from_uint(n: uint) -> Option<$T> { $to_ty }\n-            #[inline] fn from_u8(n: u8) -> Option<$T> { $to_ty }\n-            #[inline] fn from_u16(n: u16) -> Option<$T> { $to_ty }\n-            #[inline] fn from_u32(n: u32) -> Option<$T> { $to_ty }\n-            #[inline] fn from_u64(n: u64) -> Option<$T> { $to_ty }\n-\n-            #[inline] fn from_f32(n: f32) -> Option<$T> { $to_ty }\n-            #[inline] fn from_f64(n: f64) -> Option<$T> { $to_ty }\n-        }\n-    )\n-)\n-\n-impl_from_primitive!(int, n.to_int())\n-impl_from_primitive!(i8, n.to_i8())\n-impl_from_primitive!(i16, n.to_i16())\n-impl_from_primitive!(i32, n.to_i32())\n-impl_from_primitive!(i64, n.to_i64())\n-impl_from_primitive!(uint, n.to_uint())\n-impl_from_primitive!(u8, n.to_u8())\n-impl_from_primitive!(u16, n.to_u16())\n-impl_from_primitive!(u32, n.to_u32())\n-impl_from_primitive!(u64, n.to_u64())\n-impl_from_primitive!(f32, n.to_f32())\n-impl_from_primitive!(f64, n.to_f64())\n-\n-/// Cast from one machine scalar to another.\n-///\n-/// # Example\n-///\n-/// ```\n-/// use std::num;\n-///\n-/// let twenty: f32 = num::cast(0x14).unwrap();\n-/// assert_eq!(twenty, 20f32);\n-/// ```\n-///\n-#[inline]\n-pub fn cast<T: NumCast,U: NumCast>(n: T) -> Option<U> {\n-    NumCast::from(n)\n-}\n-\n-/// An interface for casting between machine scalars.\n-pub trait NumCast: ToPrimitive {\n-    /// Creates a number from another value that can be converted into a primitive via the\n-    /// `ToPrimitive` trait.\n-    fn from<T: ToPrimitive>(n: T) -> Option<Self>;\n-}\n-\n-macro_rules! impl_num_cast(\n-    ($T:ty, $conv:ident) => (\n-        impl NumCast for $T {\n-            #[inline]\n-            fn from<N: ToPrimitive>(n: N) -> Option<$T> {\n-                // `$conv` could be generated using `concat_idents!`, but that\n-                // macro seems to be broken at the moment\n-                n.$conv()\n-            }\n-        }\n-    )\n-)\n-\n-impl_num_cast!(u8,    to_u8)\n-impl_num_cast!(u16,   to_u16)\n-impl_num_cast!(u32,   to_u32)\n-impl_num_cast!(u64,   to_u64)\n-impl_num_cast!(uint,  to_uint)\n-impl_num_cast!(i8,    to_i8)\n-impl_num_cast!(i16,   to_i16)\n-impl_num_cast!(i32,   to_i32)\n-impl_num_cast!(i64,   to_i64)\n-impl_num_cast!(int,   to_int)\n-impl_num_cast!(f32,   to_f32)\n-impl_num_cast!(f64,   to_f64)\n-\n /// A generic trait for converting a value to a string with a radix (base)\n pub trait ToStrRadix {\n     fn to_str_radix(&self, radix: uint) -> ~str;\n@@ -1040,70 +270,6 @@ pub fn from_str_radix<T: FromStrRadix>(str: &str, radix: uint) -> Option<T> {\n     FromStrRadix::from_str_radix(str, radix)\n }\n \n-/// Saturating math operations\n-pub trait Saturating {\n-    /// Saturating addition operator.\n-    /// Returns a+b, saturating at the numeric bounds instead of overflowing.\n-    fn saturating_add(self, v: Self) -> Self;\n-\n-    /// Saturating subtraction operator.\n-    /// Returns a-b, saturating at the numeric bounds instead of overflowing.\n-    fn saturating_sub(self, v: Self) -> Self;\n-}\n-\n-impl<T: CheckedAdd + CheckedSub + Zero + Ord + Bounded> Saturating for T {\n-    #[inline]\n-    fn saturating_add(self, v: T) -> T {\n-        match self.checked_add(&v) {\n-            Some(x) => x,\n-            None => if v >= Zero::zero() {\n-                Bounded::max_value()\n-            } else {\n-                Bounded::min_value()\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn saturating_sub(self, v: T) -> T {\n-        match self.checked_sub(&v) {\n-            Some(x) => x,\n-            None => if v >= Zero::zero() {\n-                Bounded::min_value()\n-            } else {\n-                Bounded::max_value()\n-            }\n-        }\n-    }\n-}\n-\n-/// Performs addition that returns `None` instead of wrapping around on overflow.\n-pub trait CheckedAdd: Add<Self, Self> {\n-    /// Adds two numbers, checking for overflow. If overflow happens, `None` is returned.\n-    fn checked_add(&self, v: &Self) -> Option<Self>;\n-}\n-\n-/// Performs subtraction that returns `None` instead of wrapping around on underflow.\n-pub trait CheckedSub: Sub<Self, Self> {\n-    /// Subtracts two numbers, checking for underflow. If underflow happens, `None` is returned.\n-    fn checked_sub(&self, v: &Self) -> Option<Self>;\n-}\n-\n-/// Performs multiplication that returns `None` instead of wrapping around on underflow or\n-/// overflow.\n-pub trait CheckedMul: Mul<Self, Self> {\n-    /// Multiplies two numbers, checking for underflow or overflow. If underflow or overflow\n-    /// happens, `None` is returned.\n-    fn checked_mul(&self, v: &Self) -> Option<Self>;\n-}\n-\n-/// Performs division that returns `None` instead of wrapping around on underflow or overflow.\n-pub trait CheckedDiv: Div<Self, Self> {\n-    /// Divides two numbers, checking for underflow or overflow. If underflow or overflow happens,\n-    /// `None` is returned.\n-    fn checked_div(&self, v: &Self) -> Option<Self>;\n-}\n-\n /// Helper function for testing numeric operations\n #[cfg(test)]\n pub fn test_num<T:Num + NumCast + Show>(ten: T, two: T) {"}]}