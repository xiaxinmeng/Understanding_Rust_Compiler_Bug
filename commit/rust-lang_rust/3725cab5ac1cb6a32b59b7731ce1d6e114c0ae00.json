{"sha": "3725cab5ac1cb6a32b59b7731ce1d6e114c0ae00", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3MjVjYWI1YWMxY2I2YTMyYjU5Yjc3MzFjZTFkNmUxMTRjMGFlMDA=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-04-15T20:59:25Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-04-15T20:59:25Z"}, "message": "rustc_typeck: return InferOk from lookup_method_in_trait_adjusted.", "tree": {"sha": "a6c1e706621a7acc7b572b1d13c29aa2d390852d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a6c1e706621a7acc7b572b1d13c29aa2d390852d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3725cab5ac1cb6a32b59b7731ce1d6e114c0ae00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3725cab5ac1cb6a32b59b7731ce1d6e114c0ae00", "html_url": "https://github.com/rust-lang/rust/commit/3725cab5ac1cb6a32b59b7731ce1d6e114c0ae00", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3725cab5ac1cb6a32b59b7731ce1d6e114c0ae00/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "516570f2d6b2246cf2ae0269a201bd6a62c91881", "url": "https://api.github.com/repos/rust-lang/rust/commits/516570f2d6b2246cf2ae0269a201bd6a62c91881", "html_url": "https://github.com/rust-lang/rust/commit/516570f2d6b2246cf2ae0269a201bd6a62c91881"}], "stats": {"total": 108, "additions": 67, "deletions": 41}, "files": [{"sha": "92fb02c6379dcea41f5507644e7ce53be53f47ea", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3725cab5ac1cb6a32b59b7731ce1d6e114c0ae00/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3725cab5ac1cb6a32b59b7731ce1d6e114c0ae00/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=3725cab5ac1cb6a32b59b7731ce1d6e114c0ae00", "patch": "@@ -158,11 +158,16 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n                                    -> InferOk<'tcx, ()>\n         where E: AsCoercionSite\n     {\n-        let methods: Vec<_> = self.steps\n+        let Autoderef { fcx, span, mut obligations, steps, .. } = self;\n+        let methods: Vec<_> = steps\n             .iter()\n             .map(|&(ty, kind)| {\n                 if let AutoderefKind::Overloaded = kind {\n-                    self.fcx.try_overloaded_deref(self.span, None, ty, pref)\n+                    fcx.try_overloaded_deref(span, None, ty, pref)\n+                        .map(|InferOk { value, obligations: o }| {\n+                            obligations.extend(o);\n+                            value\n+                        })\n                 } else {\n                     None\n                 }\n@@ -172,22 +177,22 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n         debug!(\"finalize({:?}) - {:?},{:?}\",\n                pref,\n                methods,\n-               self.obligations);\n+               obligations);\n \n         for expr in exprs {\n             let expr = expr.as_coercion_site();\n             debug!(\"finalize - finalizing #{} - {:?}\", expr.id, expr);\n             for (n, method) in methods.iter().enumerate() {\n                 if let &Some(method) = method {\n                     let method_call = MethodCall::autoderef(expr.id, n as u32);\n-                    self.fcx.tables.borrow_mut().method_map.insert(method_call, method);\n+                    fcx.tables.borrow_mut().method_map.insert(method_call, method);\n                 }\n             }\n         }\n \n         InferOk {\n             value: (),\n-            obligations: self.obligations\n+            obligations\n         }\n     }\n }\n@@ -209,7 +214,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 base_expr: Option<&hir::Expr>,\n                                 base_ty: Ty<'tcx>,\n                                 lvalue_pref: LvaluePreference)\n-                                -> Option<MethodCallee<'tcx>> {\n+                                -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n         debug!(\"try_overloaded_deref({:?},{:?},{:?},{:?})\",\n                span,\n                base_expr,"}, {"sha": "32f130aca1cb91076725d4f659692fe6f6e9ddc2", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3725cab5ac1cb6a32b59b7731ce1d6e114c0ae00/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3725cab5ac1cb6a32b59b7731ce1d6e114c0ae00/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=3725cab5ac1cb6a32b59b7731ce1d6e114c0ae00", "patch": "@@ -173,7 +173,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                        adjusted_ty,\n                                                        None) {\n                 None => continue,\n-                Some(method_callee) => {\n+                Some(ok) => {\n+                    let method_callee = self.register_infer_ok_obligations(ok);\n                     return Some(method_callee);\n                 }\n             }"}, {"sha": "26ba965fe5cc6b60df81dea366bfa31edc0c1038", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3725cab5ac1cb6a32b59b7731ce1d6e114c0ae00/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3725cab5ac1cb6a32b59b7731ce1d6e114c0ae00/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=3725cab5ac1cb6a32b59b7731ce1d6e114c0ae00", "patch": "@@ -543,7 +543,8 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                                                                Some(&base_expr),\n                                                                self.node_ty(base_expr.id),\n                                                                PreferMutLvalue);\n-                        let method = method.expect(\"re-trying deref failed\");\n+                        let ok = method.expect(\"re-trying deref failed\");\n+                        let method = self.register_infer_ok_obligations(ok);\n                         self.tables.borrow_mut().method_map.insert(method_call, method);\n                     }\n                 }"}, {"sha": "7dd2699a6eaf08b224d7cafdb785178cdde52817", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 29, "deletions": 17, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/3725cab5ac1cb6a32b59b7731ce1d6e114c0ae00/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3725cab5ac1cb6a32b59b7731ce1d6e114c0ae00/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=3725cab5ac1cb6a32b59b7731ce1d6e114c0ae00", "patch": "@@ -17,7 +17,8 @@ use rustc::ty::subst::Substs;\n use rustc::traits;\n use rustc::ty::{self, ToPredicate, ToPolyTraitRef, TraitRef, TypeFoldable};\n use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow};\n-use rustc::infer;\n+use rustc::ty::subst::Subst;\n+use rustc::infer::{self, InferOk};\n \n use syntax::ast;\n use syntax_pos::Span;\n@@ -159,7 +160,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                   trait_def_id: DefId,\n                                   self_ty: ty::Ty<'tcx>,\n                                   opt_input_types: Option<Vec<ty::Ty<'tcx>>>)\n-                                  -> Option<ty::MethodCallee<'tcx>> {\n+                                  -> Option<InferOk<'tcx, ty::MethodCallee<'tcx>>> {\n         self.lookup_method_in_trait_adjusted(span,\n                                              self_expr,\n                                              m_name,\n@@ -190,7 +191,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                            unsize: bool,\n                                            self_ty: ty::Ty<'tcx>,\n                                            opt_input_types: Option<Vec<ty::Ty<'tcx>>>)\n-                                           -> Option<ty::MethodCallee<'tcx>> {\n+                                           -> Option<InferOk<'tcx, ty::MethodCallee<'tcx>>> {\n         debug!(\"lookup_in_trait_adjusted(self_ty={:?}, self_expr={:?}, \\\n                 m_name={}, trait_def_id={:?})\",\n                self_ty,\n@@ -236,6 +237,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         assert_eq!(generics.regions.len(), 0);\n \n         debug!(\"lookup_in_trait_adjusted: method_item={:?}\", method_item);\n+        let mut obligations = vec![];\n \n         // Instantiate late-bound regions and substitute the trait\n         // parameters into the method type to get the actual method type.\n@@ -248,10 +250,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let fn_sig = self.replace_late_bound_regions_with_fresh_var(span,\n                                                                     infer::FnCall,\n                                                                     &fn_sig).0;\n-        let fn_sig = self.instantiate_type_scheme(span, trait_ref.substs, &fn_sig);\n+        let fn_sig = fn_sig.subst(self.tcx, substs);\n+        let fn_sig = match self.normalize_associated_types_in_as_infer_ok(span, &fn_sig) {\n+            InferOk { value, obligations: o } => {\n+                obligations.extend(o);\n+                value\n+            }\n+        };\n         let transformed_self_ty = fn_sig.inputs()[0];\n-        let method_ty = tcx.mk_fn_def(def_id, trait_ref.substs,\n-                                     ty::Binder(fn_sig));\n+        let method_ty = tcx.mk_fn_def(def_id, substs, ty::Binder(fn_sig));\n \n         debug!(\"lookup_in_trait_adjusted: matched method method_ty={:?} obligation={:?}\",\n                method_ty,\n@@ -265,18 +272,20 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         //\n         // Note that as the method comes from a trait, it should not have\n         // any late-bound regions appearing in its bounds.\n-        let method_bounds = self.instantiate_bounds(span, def_id, trait_ref.substs);\n-        assert!(!method_bounds.has_escaping_regions());\n-        self.add_obligations_for_parameters(traits::ObligationCause::misc(span, self.body_id),\n-                                            &method_bounds);\n+        let bounds = self.tcx.item_predicates(def_id).instantiate(self.tcx, substs);\n+        let bounds = match self.normalize_associated_types_in_as_infer_ok(span, &bounds) {\n+            InferOk { value, obligations: o } => {\n+                obligations.extend(o);\n+                value\n+            }\n+        };\n+        assert!(!bounds.has_escaping_regions());\n \n-        // Also register an obligation for the method type being well-formed.\n-        self.register_wf_obligation(method_ty, span, traits::MiscObligation);\n+        let cause = traits::ObligationCause::misc(span, self.body_id);\n+        obligations.extend(traits::predicates_for_generics(cause.clone(), &bounds));\n \n-        // FIXME(#18653) -- Try to resolve obligations, giving us more\n-        // typing information, which can sometimes be needed to avoid\n-        // pathological region inference failures.\n-        self.select_obligations_where_possible();\n+        // Also add an obligation for the method type being well-formed.\n+        obligations.push(traits::Obligation::new(cause, ty::Predicate::WellFormed(method_ty)));\n \n         // Insert any adjustments needed (always an autoref of some mutability).\n         if let Some(self_expr) = self_expr {\n@@ -317,7 +326,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         debug!(\"callee = {:?}\", callee);\n \n-        Some(callee)\n+        Some(InferOk {\n+            obligations,\n+            value: callee\n+        })\n     }\n \n     pub fn resolve_ufcs(&self,"}, {"sha": "8b40cb140ae9dc0c410b5a5cfbc1ae2516dac524", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3725cab5ac1cb6a32b59b7731ce1d6e114c0ae00/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3725cab5ac1cb6a32b59b7731ce1d6e114c0ae00/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=3725cab5ac1cb6a32b59b7731ce1d6e114c0ae00", "patch": "@@ -1749,14 +1749,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                           -> ty::InstantiatedPredicates<'tcx> {\n         let bounds = self.tcx.item_predicates(def_id);\n         let result = bounds.instantiate(self.tcx, substs);\n-        let result = self.normalize_associated_types_in(span, &result.predicates);\n+        let result = self.normalize_associated_types_in(span, &result);\n         debug!(\"instantiate_bounds(bounds={:?}, substs={:?}) = {:?}\",\n                bounds,\n                substs,\n                result);\n-        ty::InstantiatedPredicates {\n-            predicates: result\n-        }\n+        result\n     }\n \n     /// Replace all anonymized types with fresh inference variables\n@@ -1799,7 +1797,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn normalize_associated_types_in<T>(&self, span: Span, value: &T) -> T\n         where T : TypeFoldable<'tcx>\n     {\n-        self.inh.normalize_associated_types_in(span, self.body_id, value)\n+        let ok = self.normalize_associated_types_in_as_infer_ok(span, value);\n+        self.register_infer_ok_obligations(ok)\n+    }\n+\n+    fn normalize_associated_types_in_as_infer_ok<T>(&self, span: Span, value: &T)\n+                                                    -> InferOk<'tcx, T>\n+        where T : TypeFoldable<'tcx>\n+    {\n+        self.inh.normalize_associated_types_in_as_infer_ok(span, self.body_id, value)\n     }\n \n     pub fn write_nil(&self, node_id: ast::NodeId) {\n@@ -2171,8 +2177,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // If some lookup succeeds, write callee into table and extract index/element\n         // type from the method signature.\n         // If some lookup succeeded, install method in table\n-        method.map(|method| {\n+        method.map(|ok| {\n             debug!(\"try_index_step: success, using overloaded indexing\");\n+            let method = self.register_infer_ok_obligations(ok);\n             self.tables.borrow_mut().method_map.insert(method_call, method);\n             (input_ty, self.make_overloaded_lvalue_return_type(method).ty)\n         })\n@@ -3302,8 +3309,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                         if let Some(mt) = oprnd_t.builtin_deref(true, NoPreference) {\n                             oprnd_t = mt.ty;\n-                        } else if let Some(method) = self.try_overloaded_deref(\n+                        } else if let Some(ok) = self.try_overloaded_deref(\n                                 expr.span, Some(&oprnd), oprnd_t, lvalue_pref) {\n+                            let method = self.register_infer_ok_obligations(ok);\n                             oprnd_t = self.make_overloaded_lvalue_return_type(method).ty;\n                             self.tables.borrow_mut().method_map.insert(MethodCall::expr(expr.id),\n                                                                            method);"}, {"sha": "5b174aaf8953b34d9a1c0d77f85f0617e8054fb7", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3725cab5ac1cb6a32b59b7731ce1d6e114c0ae00/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3725cab5ac1cb6a32b59b7731ce1d6e114c0ae00/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=3725cab5ac1cb6a32b59b7731ce1d6e114c0ae00", "patch": "@@ -398,20 +398,19 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let method = match trait_did {\n             Some(trait_did) => {\n-                self.lookup_method_in_trait_adjusted(expr.span,\n-                                                     Some(lhs_expr),\n-                                                     opname,\n-                                                     trait_did,\n-                                                     0,\n-                                                     false,\n-                                                     lhs_ty,\n-                                                     Some(other_tys))\n+                self.lookup_method_in_trait(expr.span,\n+                                            Some(lhs_expr),\n+                                            opname,\n+                                            trait_did,\n+                                            lhs_ty,\n+                                            Some(other_tys))\n             }\n             None => None\n         };\n \n         match method {\n-            Some(method) => {\n+            Some(ok) => {\n+                let method = self.register_infer_ok_obligations(ok);\n                 let method_ty = method.ty;\n \n                 // HACK(eddyb) Fully qualified path to work around a resolve bug."}]}