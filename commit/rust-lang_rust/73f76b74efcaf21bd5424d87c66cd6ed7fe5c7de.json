{"sha": "73f76b74efcaf21bd5424d87c66cd6ed7fe5c7de", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczZjc2Yjc0ZWZjYWYyMWJkNTQyNGQ4N2M2NmNkNmVkN2ZlNWM3ZGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-24T14:00:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-24T14:00:56Z"}, "message": "Auto merge of #68414 - michaelwoerister:share-drop-glue, r=alexcrichton\n\nAlso share drop-glue when compiling with -Zshare-generics (i.e. at opt-level=0)\n\nThis PR adds drop-glue to the set of monomorphizations that can be shared across crates via `-Zshare-generics`.\n\nThis version of the PR might have detrimental effects on performance as it makes lots of stuff dependent on a single query results (`upstream_monomorphizations_for(def_id_of_drop_in_place)`). That should be fixable but let's do a perf run first.\n\nPotentially fixes issue https://github.com/rust-lang/rust/issues/64140. (cc @alexcrichton)\nThe changes here are related to @matthewjasper's https://github.com/rust-lang/rust/pull/67332 but should be mostly orthogonal.\n\nr? @ghost", "tree": {"sha": "984179012855837848c7d3b741234ec45b4ac2bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/984179012855837848c7d3b741234ec45b4ac2bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/73f76b74efcaf21bd5424d87c66cd6ed7fe5c7de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/73f76b74efcaf21bd5424d87c66cd6ed7fe5c7de", "html_url": "https://github.com/rust-lang/rust/commit/73f76b74efcaf21bd5424d87c66cd6ed7fe5c7de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/73f76b74efcaf21bd5424d87c66cd6ed7fe5c7de/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dee12bb2b7d75cce8fc8f21b5d7ea0da920df5e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/dee12bb2b7d75cce8fc8f21b5d7ea0da920df5e5", "html_url": "https://github.com/rust-lang/rust/commit/dee12bb2b7d75cce8fc8f21b5d7ea0da920df5e5"}, {"sha": "197cc1e43afba388a0266a08d2b946a187b766bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/197cc1e43afba388a0266a08d2b946a187b766bb", "html_url": "https://github.com/rust-lang/rust/commit/197cc1e43afba388a0266a08d2b946a187b766bb"}], "stats": {"total": 372, "additions": 212, "deletions": 160}, "files": [{"sha": "1f4318fa537514bf33c0726f49e4db3bb188440a", "filename": "src/librustc/middle/exported_symbols.rs", "status": "modified", "additions": 7, "deletions": 61, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/73f76b74efcaf21bd5424d87c66cd6ed7fe5c7de/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73f76b74efcaf21bd5424d87c66cd6ed7fe5c7de/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs?ref=73f76b74efcaf21bd5424d87c66cd6ed7fe5c7de", "patch": "@@ -1,10 +1,7 @@\n-use crate::ich::StableHashingContext;\n use crate::ty::subst::SubstsRef;\n-use crate::ty::{self, TyCtxt};\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use crate::ty::{self, Ty, TyCtxt};\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n-use std::cmp;\n-use std::mem;\n+use rustc_macros::HashStable;\n \n /// The SymbolExportLevel of a symbols specifies from which kinds of crates\n /// the symbol will be exported. `C` symbols will be exported from any\n@@ -24,10 +21,11 @@ impl SymbolExportLevel {\n     }\n }\n \n-#[derive(Eq, PartialEq, Debug, Copy, Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Eq, PartialEq, Debug, Copy, Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub enum ExportedSymbol<'tcx> {\n     NonGeneric(DefId),\n     Generic(DefId, SubstsRef<'tcx>),\n+    DropGlue(Ty<'tcx>),\n     NoDefId(ty::SymbolName),\n }\n \n@@ -40,46 +38,12 @@ impl<'tcx> ExportedSymbol<'tcx> {\n             ExportedSymbol::Generic(def_id, substs) => {\n                 tcx.symbol_name(ty::Instance::new(def_id, substs))\n             }\n+            ExportedSymbol::DropGlue(ty) => {\n+                tcx.symbol_name(ty::Instance::resolve_drop_in_place(tcx, ty))\n+            }\n             ExportedSymbol::NoDefId(symbol_name) => symbol_name,\n         }\n     }\n-\n-    pub fn compare_stable(&self, tcx: TyCtxt<'tcx>, other: &ExportedSymbol<'tcx>) -> cmp::Ordering {\n-        match *self {\n-            ExportedSymbol::NonGeneric(self_def_id) => match *other {\n-                ExportedSymbol::NonGeneric(other_def_id) => {\n-                    tcx.def_path_hash(self_def_id).cmp(&tcx.def_path_hash(other_def_id))\n-                }\n-                ExportedSymbol::Generic(..) | ExportedSymbol::NoDefId(_) => cmp::Ordering::Less,\n-            },\n-            ExportedSymbol::Generic(self_def_id, self_substs) => match *other {\n-                ExportedSymbol::NonGeneric(_) => cmp::Ordering::Greater,\n-                ExportedSymbol::Generic(other_def_id, other_substs) => {\n-                    // We compare the symbol names because they are cached as query\n-                    // results which makes them relatively cheap to access repeatedly.\n-                    //\n-                    // It might be even faster to build a local cache of stable IDs\n-                    // for sorting. Exported symbols are really only sorted once\n-                    // in order to make the `exported_symbols` query result stable.\n-                    let self_symbol_name =\n-                        tcx.symbol_name(ty::Instance::new(self_def_id, self_substs));\n-                    let other_symbol_name =\n-                        tcx.symbol_name(ty::Instance::new(other_def_id, other_substs));\n-\n-                    self_symbol_name.cmp(&other_symbol_name)\n-                }\n-                ExportedSymbol::NoDefId(_) => cmp::Ordering::Less,\n-            },\n-            ExportedSymbol::NoDefId(self_symbol_name) => match *other {\n-                ExportedSymbol::NonGeneric(_) | ExportedSymbol::Generic(..) => {\n-                    cmp::Ordering::Greater\n-                }\n-                ExportedSymbol::NoDefId(ref other_symbol_name) => {\n-                    self_symbol_name.cmp(other_symbol_name)\n-                }\n-            },\n-        }\n-    }\n }\n \n pub fn metadata_symbol_name(tcx: TyCtxt<'_>) -> String {\n@@ -89,21 +53,3 @@ pub fn metadata_symbol_name(tcx: TyCtxt<'_>) -> String {\n         tcx.crate_disambiguator(LOCAL_CRATE).to_fingerprint().to_hex()\n     )\n }\n-\n-impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for ExportedSymbol<'tcx> {\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            ExportedSymbol::NonGeneric(def_id) => {\n-                def_id.hash_stable(hcx, hasher);\n-            }\n-            ExportedSymbol::Generic(def_id, substs) => {\n-                def_id.hash_stable(hcx, hasher);\n-                substs.hash_stable(hcx, hasher);\n-            }\n-            ExportedSymbol::NoDefId(symbol_name) => {\n-                symbol_name.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}"}, {"sha": "475c77adebd106a98b1e90840fa7edee5bb0527b", "filename": "src/librustc/mir/mono.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/73f76b74efcaf21bd5424d87c66cd6ed7fe5c7de/src%2Flibrustc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73f76b74efcaf21bd5424d87c66cd6ed7fe5c7de/src%2Flibrustc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmono.rs?ref=73f76b74efcaf21bd5424d87c66cd6ed7fe5c7de", "patch": "@@ -79,7 +79,7 @@ impl<'tcx> MonoItem<'tcx> {\n     }\n \n     pub fn instantiation_mode(&self, tcx: TyCtxt<'tcx>) -> InstantiationMode {\n-        let inline_in_all_cgus = tcx\n+        let generate_cgu_internal_copies = tcx\n             .sess\n             .opts\n             .debugging_opts\n@@ -93,7 +93,7 @@ impl<'tcx> MonoItem<'tcx> {\n                 // If this function isn't inlined or otherwise has explicit\n                 // linkage, then we'll be creating a globally shared version.\n                 if self.explicit_linkage(tcx).is_some()\n-                    || !instance.def.requires_local(tcx)\n+                    || !instance.def.generates_cgu_internal_copy(tcx)\n                     || Some(instance.def_id()) == entry_def_id\n                 {\n                     return InstantiationMode::GloballyShared { may_conflict: false };\n@@ -102,7 +102,7 @@ impl<'tcx> MonoItem<'tcx> {\n                 // At this point we don't have explicit linkage and we're an\n                 // inlined function. If we're inlining into all CGUs then we'll\n                 // be creating a local copy per CGU\n-                if inline_in_all_cgus {\n+                if generate_cgu_internal_copies {\n                     return InstantiationMode::LocalCopy;\n                 }\n "}, {"sha": "37d5e23535b817be97008ca94011f886958a8149", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/73f76b74efcaf21bd5424d87c66cd6ed7fe5c7de/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73f76b74efcaf21bd5424d87c66cd6ed7fe5c7de/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=73f76b74efcaf21bd5424d87c66cd6ed7fe5c7de", "patch": "@@ -776,13 +776,47 @@ rustc_queries! {\n     }\n \n     Codegen {\n+        /// The entire set of monomorphizations the local crate can safely link\n+        /// to because they are exported from upstream crates. Do not depend on\n+        /// this directly, as its value changes anytime a monomorphization gets\n+        /// added or removed in any upstream crate. Instead use the narrower\n+        /// `upstream_monomorphizations_for`, `upstream_drop_glue_for`, or, even\n+        /// better, `Instance::upstream_monomorphization()`.\n         query upstream_monomorphizations(\n             k: CrateNum\n         ) -> &'tcx DefIdMap<FxHashMap<SubstsRef<'tcx>, CrateNum>> {\n             desc { \"collecting available upstream monomorphizations `{:?}`\", k }\n         }\n+\n+        /// Returns the set of upstream monomorphizations available for the\n+        /// generic function identified by the given `def_id`. The query makes\n+        /// sure to make a stable selection if the same monomorphization is\n+        /// available in multiple upstream crates.\n+        ///\n+        /// You likely want to call `Instance::upstream_monomorphization()`\n+        /// instead of invoking this query directly.\n         query upstream_monomorphizations_for(_: DefId)\n             -> Option<&'tcx FxHashMap<SubstsRef<'tcx>, CrateNum>> {}\n+\n+        /// Returns the upstream crate that exports drop-glue for the given\n+        /// type (`substs` is expected to be a single-item list containing the\n+        /// type one wants drop-glue for).\n+        ///\n+        /// This is a subset of `upstream_monomorphizations_for` in order to\n+        /// increase dep-tracking granularity. Otherwise adding or removing any\n+        /// type with drop-glue in any upstream crate would invalidate all\n+        /// functions calling drop-glue of an upstream type.\n+        ///\n+        /// You likely want to call `Instance::upstream_monomorphization()`\n+        /// instead of invoking this query directly.\n+        ///\n+        /// NOTE: This query could easily be extended to also support other\n+        ///       common functions that have are large set of monomorphizations\n+        ///       (like `Clone::clone` for example).\n+        query upstream_drop_glue_for(substs: SubstsRef<'tcx>) -> Option<CrateNum> {\n+            desc { \"available upstream drop-glue for `{:?}`\", substs }\n+            no_force\n+        }\n     }\n \n     Other {"}, {"sha": "51a18f8eae2741c418e8d1b56d625bea0886f616", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 50, "deletions": 4, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/73f76b74efcaf21bd5424d87c66cd6ed7fe5c7de/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73f76b74efcaf21bd5424d87c66cd6ed7fe5c7de/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=73f76b74efcaf21bd5424d87c66cd6ed7fe5c7de", "patch": "@@ -4,7 +4,7 @@ use crate::traits;\n use crate::ty::print::{FmtPrinter, Printer};\n use crate::ty::{self, SubstsRef, Ty, TyCtxt, TypeFoldable};\n use rustc_hir::def::Namespace;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{CrateNum, DefId};\n use rustc_macros::HashStable;\n use rustc_target::spec::abi::Abi;\n \n@@ -91,6 +91,40 @@ impl<'tcx> Instance<'tcx> {\n         let ty = tcx.type_of(self.def.def_id());\n         tcx.subst_and_normalize_erasing_regions(self.substs, param_env, &ty)\n     }\n+\n+    /// Finds a crate that contains a monomorphization of this instance that\n+    /// can be linked to from the local crate. A return value of `None` means\n+    /// no upstream crate provides such an exported monomorphization.\n+    ///\n+    /// This method already takes into account the global `-Zshare-generics`\n+    /// setting, always returning `None` if `share-generics` is off.\n+    pub fn upstream_monomorphization(&self, tcx: TyCtxt<'tcx>) -> Option<CrateNum> {\n+        // If we are not in share generics mode, we don't link to upstream\n+        // monomorphizations but always instantiate our own internal versions\n+        // instead.\n+        if !tcx.sess.opts.share_generics() {\n+            return None;\n+        }\n+\n+        // If this is an item that is defined in the local crate, no upstream\n+        // crate can know about it/provide a monomorphization.\n+        if self.def_id().is_local() {\n+            return None;\n+        }\n+\n+        // If this a non-generic instance, it cannot be a shared monomorphization.\n+        if self.substs.non_erasable_generics().next().is_none() {\n+            return None;\n+        }\n+\n+        match self.def {\n+            InstanceDef::Item(def_id) => tcx\n+                .upstream_monomorphizations_for(def_id)\n+                .and_then(|monos| monos.get(&self.substs).cloned()),\n+            InstanceDef::DropGlue(_, Some(_)) => tcx.upstream_drop_glue_for(self.substs),\n+            _ => None,\n+        }\n+    }\n }\n \n impl<'tcx> InstanceDef<'tcx> {\n@@ -114,7 +148,12 @@ impl<'tcx> InstanceDef<'tcx> {\n         tcx.get_attrs(self.def_id())\n     }\n \n-    pub fn is_inline(&self, tcx: TyCtxt<'tcx>) -> bool {\n+    /// Returns `true` if the LLVM version of this instance is unconditionally\n+    /// marked with `inline`. This implies that a copy of this instance is\n+    /// generated in every codegen unit.\n+    /// Note that this is only a hint. See the documentation for\n+    /// `generates_cgu_internal_copy` for more information.\n+    pub fn requires_inline(&self, tcx: TyCtxt<'tcx>) -> bool {\n         use crate::hir::map::DefPathData;\n         let def_id = match *self {\n             ty::InstanceDef::Item(def_id) => def_id,\n@@ -127,8 +166,15 @@ impl<'tcx> InstanceDef<'tcx> {\n         }\n     }\n \n-    pub fn requires_local(&self, tcx: TyCtxt<'tcx>) -> bool {\n-        if self.is_inline(tcx) {\n+    /// Returns `true` if the machine code for this instance is instantiated in\n+    /// each codegen unit that references it.\n+    /// Note that this is only a hint! The compiler can globally decide to *not*\n+    /// do this in order to speed up compilation. CGU-internal copies are\n+    /// only exist to enable inlining. If inlining is not performed (e.g. at\n+    /// `-Copt-level=0`) then the time for generating them is wasted and it's\n+    /// better to create a single copy with external linkage.\n+    pub fn generates_cgu_internal_copy(&self, tcx: TyCtxt<'tcx>) -> bool {\n+        if self.requires_inline(tcx) {\n             return true;\n         }\n         if let ty::InstanceDef::DropGlue(..) = *self {"}, {"sha": "c1c88e96f94b5d3c5c0140a25355bad68e639bac", "filename": "src/librustc/ty/query/keys.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/73f76b74efcaf21bd5424d87c66cd6ed7fe5c7de/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73f76b74efcaf21bd5424d87c66cd6ed7fe5c7de/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs?ref=73f76b74efcaf21bd5424d87c66cd6ed7fe5c7de", "patch": "@@ -116,6 +116,15 @@ impl Key for (DefId, SimplifiedType) {\n     }\n }\n \n+impl<'tcx> Key for SubstsRef<'tcx> {\n+    fn query_crate(&self) -> CrateNum {\n+        LOCAL_CRATE\n+    }\n+    fn default_span(&self, _: TyCtxt<'_>) -> Span {\n+        DUMMY_SP\n+    }\n+}\n+\n impl<'tcx> Key for (DefId, SubstsRef<'tcx>) {\n     fn query_crate(&self) -> CrateNum {\n         self.0.krate"}, {"sha": "fc1b365cf90ce57cfbeaf1a54a3d8ea83e0df4c8", "filename": "src/librustc_codegen_llvm/attributes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73f76b74efcaf21bd5424d87c66cd6ed7fe5c7de/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73f76b74efcaf21bd5424d87c66cd6ed7fe5c7de/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fattributes.rs?ref=73f76b74efcaf21bd5424d87c66cd6ed7fe5c7de", "patch": "@@ -246,7 +246,7 @@ pub fn from_fn_attrs(\n     }\n \n     // FIXME(eddyb) consolidate these two `inline` calls (and avoid overwrites).\n-    if instance.def.is_inline(cx.tcx) {\n+    if instance.def.requires_inline(cx.tcx) {\n         inline(cx, llfn, attributes::InlineAttr::Hint);\n     }\n "}, {"sha": "04d92142266ee03dec42516620484f3d5a984cf0", "filename": "src/librustc_codegen_llvm/callee.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/73f76b74efcaf21bd5424d87c66cd6ed7fe5c7de/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73f76b74efcaf21bd5424d87c66cd6ed7fe5c7de/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcallee.rs?ref=73f76b74efcaf21bd5424d87c66cd6ed7fe5c7de", "patch": "@@ -130,12 +130,7 @@ pub fn get_fn(cx: &CodegenCx<'ll, 'tcx>, instance: Instance<'tcx>) -> &'ll Value\n                     } else {\n                         // This is a monomorphization of a generic function\n                         // defined in an upstream crate.\n-                        if cx\n-                            .tcx\n-                            .upstream_monomorphizations_for(instance_def_id)\n-                            .map(|set| set.contains_key(instance.substs))\n-                            .unwrap_or(false)\n-                        {\n+                        if instance.upstream_monomorphization(tcx).is_some() {\n                             // This is instantiated in another crate. It cannot\n                             // be `hidden`.\n                         } else {"}, {"sha": "a6cd0c09684dddbeb129a923930c051d0f133f2f", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 66, "deletions": 23, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/73f76b74efcaf21bd5424d87c66cd6ed7fe5c7de/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73f76b74efcaf21bd5424d87c66cd6ed7fe5c7de/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=73f76b74efcaf21bd5424d87c66cd6ed7fe5c7de", "patch": "@@ -5,7 +5,7 @@ use rustc::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc::middle::exported_symbols::{metadata_symbol_name, ExportedSymbol, SymbolExportLevel};\n use rustc::session::config::{self, Sanitizer};\n use rustc::ty::query::Providers;\n-use rustc::ty::subst::SubstsRef;\n+use rustc::ty::subst::{GenericArgKind, SubstsRef};\n use rustc::ty::Instance;\n use rustc::ty::{SymbolName, TyCtxt};\n use rustc_codegen_utils::symbol_names;\n@@ -17,8 +17,6 @@ use rustc_hir::Node;\n use rustc_index::vec::IndexVec;\n use syntax::expand::allocator::ALLOCATOR_METHODS;\n \n-pub type ExportedSymbols = FxHashMap<CrateNum, Arc<Vec<(String, SymbolExportLevel)>>>;\n-\n pub fn threshold(tcx: TyCtxt<'_>) -> SymbolExportLevel {\n     crates_export_threshold(&tcx.sess.crate_types.borrow())\n }\n@@ -96,7 +94,7 @@ fn reachable_non_generics_provider(\n                     if !generics.requires_monomorphization(tcx) &&\n                         // Functions marked with #[inline] are only ever codegened\n                         // with \"internal\" linkage and are never exported.\n-                        !Instance::mono(tcx, def_id).def.requires_local(tcx)\n+                        !Instance::mono(tcx, def_id).def.generates_cgu_internal_copy(tcx)\n                     {\n                         Some(def_id)\n                     } else {\n@@ -250,19 +248,30 @@ fn exported_symbols_provider_local(\n                 continue;\n             }\n \n-            if let &MonoItem::Fn(Instance { def: InstanceDef::Item(def_id), substs }) = mono_item {\n-                if substs.non_erasable_generics().next().is_some() {\n-                    symbols\n-                        .push((ExportedSymbol::Generic(def_id, substs), SymbolExportLevel::Rust));\n+            match *mono_item {\n+                MonoItem::Fn(Instance { def: InstanceDef::Item(def_id), substs }) => {\n+                    if substs.non_erasable_generics().next().is_some() {\n+                        let symbol = ExportedSymbol::Generic(def_id, substs);\n+                        symbols.push((symbol, SymbolExportLevel::Rust));\n+                    }\n+                }\n+                MonoItem::Fn(Instance { def: InstanceDef::DropGlue(_, Some(ty)), substs }) => {\n+                    // A little sanity-check\n+                    debug_assert_eq!(\n+                        substs.non_erasable_generics().next(),\n+                        Some(GenericArgKind::Type(ty))\n+                    );\n+                    symbols.push((ExportedSymbol::DropGlue(ty), SymbolExportLevel::Rust));\n+                }\n+                _ => {\n+                    // Any other symbols don't qualify for sharing\n                 }\n             }\n         }\n     }\n \n     // Sort so we get a stable incr. comp. hash.\n-    symbols.sort_unstable_by(|&(ref symbol1, ..), &(ref symbol2, ..)| {\n-        symbol1.compare_stable(tcx, symbol2)\n-    });\n+    symbols.sort_by_cached_key(|s| s.0.symbol_name_for_local_instance(tcx));\n \n     Arc::new(symbols)\n }\n@@ -288,24 +297,41 @@ fn upstream_monomorphizations_provider(\n         cnum_stable_ids\n     };\n \n+    let drop_in_place_fn_def_id = tcx.lang_items().drop_in_place_fn();\n+\n     for &cnum in cnums.iter() {\n         for (exported_symbol, _) in tcx.exported_symbols(cnum).iter() {\n-            if let &ExportedSymbol::Generic(def_id, substs) = exported_symbol {\n-                let substs_map = instances.entry(def_id).or_default();\n-\n-                match substs_map.entry(substs) {\n-                    Occupied(mut e) => {\n-                        // If there are multiple monomorphizations available,\n-                        // we select one deterministically.\n-                        let other_cnum = *e.get();\n-                        if cnum_stable_ids[other_cnum] > cnum_stable_ids[cnum] {\n-                            e.insert(cnum);\n-                        }\n+            let (def_id, substs) = match *exported_symbol {\n+                ExportedSymbol::Generic(def_id, substs) => (def_id, substs),\n+                ExportedSymbol::DropGlue(ty) => {\n+                    if let Some(drop_in_place_fn_def_id) = drop_in_place_fn_def_id {\n+                        (drop_in_place_fn_def_id, tcx.intern_substs(&[ty.into()]))\n+                    } else {\n+                        // `drop_in_place` in place does not exist, don't try\n+                        // to use it.\n+                        continue;\n                     }\n-                    Vacant(e) => {\n+                }\n+                ExportedSymbol::NonGeneric(..) | ExportedSymbol::NoDefId(..) => {\n+                    // These are no monomorphizations\n+                    continue;\n+                }\n+            };\n+\n+            let substs_map = instances.entry(def_id).or_default();\n+\n+            match substs_map.entry(substs) {\n+                Occupied(mut e) => {\n+                    // If there are multiple monomorphizations available,\n+                    // we select one deterministically.\n+                    let other_cnum = *e.get();\n+                    if cnum_stable_ids[other_cnum] > cnum_stable_ids[cnum] {\n                         e.insert(cnum);\n                     }\n                 }\n+                Vacant(e) => {\n+                    e.insert(cnum);\n+                }\n             }\n         }\n     }\n@@ -321,6 +347,17 @@ fn upstream_monomorphizations_for_provider(\n     tcx.upstream_monomorphizations(LOCAL_CRATE).get(&def_id)\n }\n \n+fn upstream_drop_glue_for_provider<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    substs: SubstsRef<'tcx>,\n+) -> Option<CrateNum> {\n+    if let Some(def_id) = tcx.lang_items().drop_in_place_fn() {\n+        tcx.upstream_monomorphizations_for(def_id).and_then(|monos| monos.get(&substs).cloned())\n+    } else {\n+        None\n+    }\n+}\n+\n fn is_unreachable_local_definition_provider(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     if let Some(hir_id) = tcx.hir().as_local_hir_id(def_id) {\n         !tcx.reachable_set(LOCAL_CRATE).contains(&hir_id)\n@@ -335,6 +372,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     providers.exported_symbols = exported_symbols_provider_local;\n     providers.upstream_monomorphizations = upstream_monomorphizations_provider;\n     providers.is_unreachable_local_definition = is_unreachable_local_definition_provider;\n+    providers.upstream_drop_glue_for = upstream_drop_glue_for_provider;\n }\n \n pub fn provide_extern(providers: &mut Providers<'_>) {\n@@ -395,6 +433,11 @@ pub fn symbol_name_for_instance_in_crate<'tcx>(\n             Instance::new(def_id, substs),\n             instantiating_crate,\n         ),\n+        ExportedSymbol::DropGlue(ty) => symbol_names::symbol_name_for_instance_in_crate(\n+            tcx,\n+            Instance::resolve_drop_in_place(tcx, ty),\n+            instantiating_crate,\n+        ),\n         ExportedSymbol::NoDefId(symbol_name) => symbol_name.to_string(),\n     }\n }"}, {"sha": "841827d15fef41c52d37affe57374f3055a447d1", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/73f76b74efcaf21bd5424d87c66cd6ed7fe5c7de/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73f76b74efcaf21bd5424d87c66cd6ed7fe5c7de/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=73f76b74efcaf21bd5424d87c66cd6ed7fe5c7de", "patch": "@@ -2,7 +2,8 @@ use super::command::Command;\n use super::link::{self, get_linker, remove};\n use super::linker::LinkerInfo;\n use super::lto::{self, SerializedModule};\n-use super::symbol_export::{symbol_name_for_instance_in_crate, ExportedSymbols};\n+use super::symbol_export::symbol_name_for_instance_in_crate;\n+\n use crate::{\n     CachedModuleCodegen, CodegenResults, CompiledModule, CrateInfo, ModuleCodegen, ModuleKind,\n     RLIB_BYTECODE_EXTENSION,\n@@ -12,6 +13,7 @@ use crate::traits::*;\n use jobserver::{Acquired, Client};\n use rustc::dep_graph::{WorkProduct, WorkProductFileKind, WorkProductId};\n use rustc::middle::cstore::EncodedMetadata;\n+use rustc::middle::exported_symbols::SymbolExportLevel;\n use rustc::session::config::{\n     self, Lto, OutputFilenames, OutputType, Passes, Sanitizer, SwitchWithOptPath,\n };\n@@ -205,6 +207,8 @@ impl<B: WriteBackendMethods> Clone for TargetMachineFactory<B> {\n     }\n }\n \n+pub type ExportedSymbols = FxHashMap<CrateNum, Arc<Vec<(String, SymbolExportLevel)>>>;\n+\n /// Additional resources used by optimize_and_codegen (not module specific)\n #[derive(Clone)]\n pub struct CodegenContext<B: WriteBackendMethods> {"}, {"sha": "6713459f627ef726823ee4f247a025392112c560", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 3, "deletions": 22, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/73f76b74efcaf21bd5424d87c66cd6ed7fe5c7de/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73f76b74efcaf21bd5424d87c66cd6ed7fe5c7de/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=73f76b74efcaf21bd5424d87c66cd6ed7fe5c7de", "patch": "@@ -126,29 +126,10 @@ fn symbol_name_provider(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) -> ty::Symb\n         // This closure determines the instantiating crate for instances that\n         // need an instantiating-crate-suffix for their symbol name, in order\n         // to differentiate between local copies.\n-        //\n-        // For generics we might find re-usable upstream instances. For anything\n-        // else we rely on their being a local copy available.\n-\n         if is_generic(instance.substs) {\n-            let def_id = instance.def_id();\n-\n-            if !def_id.is_local() && tcx.sess.opts.share_generics() {\n-                // If we are re-using a monomorphization from another crate,\n-                // we have to compute the symbol hash accordingly.\n-                let upstream_monomorphizations = tcx.upstream_monomorphizations_for(def_id);\n-\n-                upstream_monomorphizations\n-                    .and_then(|monos| monos.get(&instance.substs).cloned())\n-                    // If there is no instance available upstream, there'll be\n-                    // one in the current crate.\n-                    .unwrap_or(LOCAL_CRATE)\n-            } else {\n-                // For generic functions defined in the current crate, there\n-                // can be no upstream instances. Also, if we don't share\n-                // generics, we'll instantiate a local copy too.\n-                LOCAL_CRATE\n-            }\n+            // For generics we might find re-usable upstream instances. If there\n+            // is one, we rely on the symbol being instantiated locally.\n+            instance.upstream_monomorphization(tcx).unwrap_or(LOCAL_CRATE)\n         } else {\n             // For non-generic things that need to avoid naming conflicts, we\n             // always instantiate a copy in the local crate."}, {"sha": "dd2071a6c596ae7677a78b8c267b5a5c3ac70be7", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 8, "deletions": 34, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/73f76b74efcaf21bd5424d87c66cd6ed7fe5c7de/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73f76b74efcaf21bd5424d87c66cd6ed7fe5c7de/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=73f76b74efcaf21bd5424d87c66cd6ed7fe5c7de", "patch": "@@ -713,7 +713,8 @@ fn visit_instance_use<'tcx>(\n // need a mono item.\n fn should_monomorphize_locally<'tcx>(tcx: TyCtxt<'tcx>, instance: &Instance<'tcx>) -> bool {\n     let def_id = match instance.def {\n-        ty::InstanceDef::Item(def_id) => def_id,\n+        ty::InstanceDef::Item(def_id) | ty::InstanceDef::DropGlue(def_id, Some(_)) => def_id,\n+\n         ty::InstanceDef::VtableShim(..)\n         | ty::InstanceDef::ReifyShim(..)\n         | ty::InstanceDef::ClosureOnceShim { .. }\n@@ -725,18 +726,18 @@ fn should_monomorphize_locally<'tcx>(tcx: TyCtxt<'tcx>, instance: &Instance<'tcx\n     };\n \n     if tcx.is_foreign_item(def_id) {\n-        // We can always link to foreign items.\n+        // Foreign items are always linked against, there's no way of\n+        // instantiating them.\n         return false;\n     }\n \n     if def_id.is_local() {\n-        // Local items cannot be referred to locally without monomorphizing them locally.\n+        // Local items cannot be referred to locally without\n+        // monomorphizing them locally.\n         return true;\n     }\n \n-    if tcx.is_reachable_non_generic(def_id)\n-        || is_available_upstream_generic(tcx, def_id, instance.substs)\n-    {\n+    if tcx.is_reachable_non_generic(def_id) || instance.upstream_monomorphization(tcx).is_some() {\n         // We can link to the item in question, no instance needed\n         // in this crate.\n         return false;\n@@ -745,35 +746,8 @@ fn should_monomorphize_locally<'tcx>(tcx: TyCtxt<'tcx>, instance: &Instance<'tcx\n     if !tcx.is_mir_available(def_id) {\n         bug!(\"cannot create local mono-item for {:?}\", def_id)\n     }\n-    return true;\n-\n-    fn is_available_upstream_generic<'tcx>(\n-        tcx: TyCtxt<'tcx>,\n-        def_id: DefId,\n-        substs: SubstsRef<'tcx>,\n-    ) -> bool {\n-        debug_assert!(!def_id.is_local());\n-\n-        // If we are not in share generics mode, we don't link to upstream\n-        // monomorphizations but always instantiate our own internal versions\n-        // instead.\n-        if !tcx.sess.opts.share_generics() {\n-            return false;\n-        }\n \n-        // If this instance has non-erasable parameters, it cannot be a shared\n-        // monomorphization. Non-generic instances are already handled above\n-        // by `is_reachable_non_generic()`.\n-        if substs.non_erasable_generics().next().is_none() {\n-            return false;\n-        }\n-\n-        // Take a look at the available monomorphizations listed in the metadata\n-        // of upstream crates.\n-        tcx.upstream_monomorphizations_for(def_id)\n-            .map(|set| set.contains_key(substs))\n-            .unwrap_or(false)\n-    }\n+    return true;\n }\n \n /// For a given pair of source and target type that occur in an unsizing coercion,"}, {"sha": "8bcf420e2aa370feec4f2040f180992a95213f1e", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73f76b74efcaf21bd5424d87c66cd6ed7fe5c7de/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73f76b74efcaf21bd5424d87c66cd6ed7fe5c7de/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=73f76b74efcaf21bd5424d87c66cd6ed7fe5c7de", "patch": "@@ -324,7 +324,7 @@ fn mono_item_visibility(\n     };\n \n     let def_id = match instance.def {\n-        InstanceDef::Item(def_id) => def_id,\n+        InstanceDef::Item(def_id) | InstanceDef::DropGlue(def_id, Some(_)) => def_id,\n \n         // These are all compiler glue and such, never exported, always hidden.\n         InstanceDef::VtableShim(..)"}, {"sha": "ffbd0dc54844913a1f562c5b05c707d8879337c1", "filename": "src/test/codegen-units/partitioning/auxiliary/shared_generics_aux.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/73f76b74efcaf21bd5424d87c66cd6ed7fe5c7de/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fauxiliary%2Fshared_generics_aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73f76b74efcaf21bd5424d87c66cd6ed7fe5c7de/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fauxiliary%2Fshared_generics_aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fauxiliary%2Fshared_generics_aux.rs?ref=73f76b74efcaf21bd5424d87c66cd6ed7fe5c7de", "patch": "@@ -1,4 +1,6 @@\n-// compile-flags:-Zshare-generics=yes\n+// NOTE: We always compile this test with -Copt-level=0 because higher opt-levels\n+//       prevent drop-glue from participating in share-generics.\n+// compile-flags:-Zshare-generics=yes -Copt-level=0\n // no-prefer-dynamic\n \n #![crate_type=\"rlib\"]\n@@ -8,5 +10,17 @@ pub fn generic_fn<T>(x: T, y: T) -> (T, T) {\n }\n \n pub fn use_generic_fn_f32() -> (f32, f32) {\n+    // This line causes drop glue for Foo to be instantiated. We want to make\n+    // sure that this crate exports an instance to be re-used by share-generics.\n+    let _ = Foo(0);\n+\n     generic_fn(0.0f32, 1.0f32)\n }\n+\n+pub struct Foo(pub u32);\n+\n+impl Drop for Foo {\n+    fn drop(&mut self) {\n+        println!(\"foo\");\n+    }\n+}"}, {"sha": "47ff94437ff37a0200b751fdbad0c7949285e0cd", "filename": "src/test/codegen-units/partitioning/shared-generics.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/73f76b74efcaf21bd5424d87c66cd6ed7fe5c7de/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fshared-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73f76b74efcaf21bd5424d87c66cd6ed7fe5c7de/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fshared-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fshared-generics.rs?ref=73f76b74efcaf21bd5424d87c66cd6ed7fe5c7de", "patch": "@@ -1,6 +1,8 @@\n // ignore-tidy-linelength\n // no-prefer-dynamic\n-// compile-flags:-Zprint-mono-items=eager -Zshare-generics=yes -Zincremental=tmp/partitioning-tests/shared-generics-exe\n+// NOTE: We always compile this test with -Copt-level=0 because higher opt-levels\n+//       prevent drop-glue from participating in share-generics.\n+// compile-flags:-Zprint-mono-items=eager -Zshare-generics=yes -Zincremental=tmp/partitioning-tests/shared-generics-exe -Copt-level=0\n \n #![crate_type=\"rlib\"]\n \n@@ -16,6 +18,10 @@ pub fn foo() {\n     // This should not generate a monomorphization because it's already\n     // available in `shared_generics_aux`.\n     let _ = shared_generics_aux::generic_fn(0.0f32, 3.0f32);\n-}\n \n-// MONO_ITEM drop-glue i8\n+    // The following line will drop an instance of `Foo`, generating a call to\n+    // Foo's drop-glue function. However, share-generics should take care of\n+    // reusing the drop-glue from the upstream crate, so we do not expect a\n+    // mono item for the drop-glue\n+    let _ = shared_generics_aux::Foo(1);\n+}"}]}