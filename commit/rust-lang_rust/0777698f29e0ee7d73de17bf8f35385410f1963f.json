{"sha": "0777698f29e0ee7d73de17bf8f35385410f1963f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3Nzc2OThmMjllMGVlN2Q3M2RlMTdiZjhmMzUzODU0MTBmMTk2M2Y=", "commit": {"author": {"name": "hamidreza kalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2021-09-19T11:45:44Z"}, "committer": {"name": "hamidreza kalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2021-09-19T11:45:44Z"}, "message": "internal: definition based hover functions", "tree": {"sha": "5e1f1cfa78bc86f51735e5b044637b540f3ba43d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e1f1cfa78bc86f51735e5b044637b540f3ba43d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0777698f29e0ee7d73de17bf8f35385410f1963f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0777698f29e0ee7d73de17bf8f35385410f1963f", "html_url": "https://github.com/rust-lang/rust/commit/0777698f29e0ee7d73de17bf8f35385410f1963f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0777698f29e0ee7d73de17bf8f35385410f1963f/comments", "author": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7729473dd24d27e55f931dac3b9dd0d11ff291e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/7729473dd24d27e55f931dac3b9dd0d11ff291e4", "html_url": "https://github.com/rust-lang/rust/commit/7729473dd24d27e55f931dac3b9dd0d11ff291e4"}], "stats": {"total": 215, "additions": 123, "deletions": 92}, "files": [{"sha": "49bd6e8b343248012fdb79e9f83cb80566c8526d", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 123, "deletions": 92, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/0777698f29e0ee7d73de17bf8f35385410f1963f/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0777698f29e0ee7d73de17bf8f35385410f1963f/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=0777698f29e0ee7d73de17bf8f35385410f1963f", "patch": "@@ -117,6 +117,26 @@ pub(crate) fn hover(\n     let mut seen = HashSet::default();\n \n     let mut fallback = None;\n+    // attributes, require special machinery as they are mere ident tokens\n+    if token.kind() != COMMENT {\n+        if let Some(attr) = token.ancestors().find_map(ast::Attr::cast) {\n+            // lints\n+            if let Some(res) = try_hover_for_lint(&attr, &token) {\n+                return Some(res);\n+            // derives\n+            } else {\n+                let def = try_resolve_derive_input_at(&sema, &attr, &token).map(Definition::Macro);\n+                if let Some(def) = def {\n+                    if let Some(hover) =\n+                        hover_for_definition(&sema, file_id, def, &token.parent().unwrap(), config)\n+                    {\n+                        return Some(RangeInfo::new(token.text_range(), hover));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     sema.descend_into_macros_many(token.clone())\n         .iter()\n         .filter_map(|token| match token.parent() {\n@@ -169,71 +189,39 @@ fn find_hover_result(\n     // so don't add them to the `seen` duplicate check\n     let mut add_to_seen_definitions = true;\n \n-    let definition = match_ast! {\n-        match node {\n-            ast::Name(name) => NameClass::classify(sema, &name).map(|class| match class {\n-                NameClass::Definition(it) | NameClass::ConstReference(it) => it,\n-                NameClass::PatFieldShorthand { local_def, field_ref: _ } => Definition::Local(local_def),\n-            }),\n-            ast::NameRef(name_ref) => NameRefClass::classify(sema, &name_ref).map(|class| match class {\n-                NameRefClass::Definition(def) => def,\n-                NameRefClass::FieldShorthand { local_ref: _, field_ref } => {\n-                    Definition::Field(field_ref)\n-                }\n-            }),\n-            ast::Lifetime(lifetime) => NameClass::classify_lifetime(&sema, &lifetime).map_or_else(\n-                || {\n-                    NameRefClass::classify_lifetime(&sema, &lifetime).and_then(|class| match class {\n-                        NameRefClass::Definition(it) => Some(it),\n-                        _ => None,\n-                    })\n+    let definition = find_definition(sema, node).or_else(|| {\n+        // intra-doc links\n+        // FIXME: move comment + attribute special cases somewhere else to simplify control flow,\n+        // hopefully simplifying the return type of this function in the process\n+        // (the `Break`/`Continue` distinction is needed to decide whether to use fallback hovers)\n+        //\n+        // FIXME: hovering the intra doc link to `Foo` not working:\n+        //\n+        // #[identity]\n+        // trait Foo {\n+        //    /// [`Foo`]\n+        // fn foo() {}\n+        if token.kind() == COMMENT {\n+            add_to_seen_definitions = false;\n+            cov_mark::hit!(no_highlight_on_comment_hover);\n+            let (attributes, def) = doc_attributes(sema, node)?;\n+            let (docs, doc_mapping) = attributes.docs_with_rangemap(sema.db)?;\n+            let (idl_range, link, ns) = extract_definitions_from_docs(&docs).into_iter().find_map(\n+                |(range, link, ns)| {\n+                    let mapped = doc_mapping.map(range)?;\n+                    (mapped.file_id == file_id.into() && mapped.value.contains(offset))\n+                        .then(|| (mapped.value, link, ns))\n                 },\n-                NameClass::defined,\n-            ),\n-            _ => {\n-                // intra-doc links\n-                // FIXME: move comment + attribute special cases somewhere else to simplify control flow,\n-                // hopefully simplifying the return type of this function in the process\n-                // (the `Break`/`Continue` distinction is needed to decide whether to use fallback hovers)\n-                //\n-                // FIXME: hovering the intra doc link to `Foo` not working:\n-                //\n-                // #[identity]\n-                // trait Foo {\n-                //    /// [`Foo`]\n-                // fn foo() {}\n-                if token.kind() == COMMENT {\n-                    add_to_seen_definitions = false;\n-                    cov_mark::hit!(no_highlight_on_comment_hover);\n-                    let (attributes, def) = doc_attributes(sema, node)?;\n-                    let (docs, doc_mapping) = attributes.docs_with_rangemap(sema.db)?;\n-                    let (idl_range, link, ns) =\n-                        extract_definitions_from_docs(&docs).into_iter().find_map(|(range, link, ns)| {\n-                            let mapped = doc_mapping.map(range)?;\n-                            (mapped.file_id == file_id.into() && mapped.value.contains(offset)).then(||(mapped.value, link, ns))\n-                        })?;\n-                    range_override = Some(idl_range);\n-                    Some(match resolve_doc_path_for_def(sema.db,def, &link,ns)? {\n-                        Either::Left(it) => Definition::ModuleDef(it),\n-                        Either::Right(it) => Definition::Macro(it),\n-                    })\n-                // attributes, require special machinery as they are mere ident tokens\n-                } else if let Some(attr) = token.ancestors().find_map(ast::Attr::cast) {\n-                    add_to_seen_definitions = false;\n-                    // lints\n-                    if let Some(res) = try_hover_for_lint(&attr, &token) {\n-                        return Some(ControlFlow::Break(res));\n-                    // derives\n-                    } else {\n-                        range_override = Some(token.text_range());\n-                        try_resolve_derive_input_at(&sema, &attr, &token).map(Definition::Macro)\n-                    }\n-                } else {\n-                    None\n-                }\n-            },\n+            )?;\n+            range_override = Some(idl_range);\n+            Some(match resolve_doc_path_for_def(sema.db, def, &link, ns)? {\n+                Either::Left(it) => Definition::ModuleDef(it),\n+                Either::Right(it) => Definition::Macro(it),\n+            })\n+        } else {\n+            None\n         }\n-    };\n+    });\n \n     if let Some(definition) = definition {\n         // skip duplicates\n@@ -243,33 +231,7 @@ fn find_hover_result(\n         if add_to_seen_definitions {\n             seen.insert(definition);\n         }\n-        let famous_defs = match &definition {\n-            Definition::ModuleDef(hir::ModuleDef::BuiltinType(_)) => {\n-                Some(FamousDefs(&sema, sema.scope(&node).krate()))\n-            }\n-            _ => None,\n-        };\n-        if let Some(markup) =\n-            hover_for_definition(sema.db, definition, famous_defs.as_ref(), config)\n-        {\n-            let mut res = HoverResult::default();\n-            res.markup = process_markup(sema.db, definition, &markup, config);\n-            if let Some(action) = show_implementations_action(sema.db, definition) {\n-                res.actions.push(action);\n-            }\n-\n-            if let Some(action) = show_fn_references_action(sema.db, definition) {\n-                res.actions.push(action);\n-            }\n-\n-            if let Some(action) = runnable_action(&sema, definition, file_id) {\n-                res.actions.push(action);\n-            }\n-\n-            if let Some(action) = goto_type_action_for_def(sema.db, definition) {\n-                res.actions.push(action);\n-            }\n-\n+        if let Some(res) = hover_for_definition(sema, file_id, definition, &node, config) {\n             let range = range_override.unwrap_or_else(|| sema.original_range(&node).range);\n             return Some(ControlFlow::Break(RangeInfo::new(range, res)));\n         }\n@@ -283,6 +245,9 @@ fn type_hover(\n     config: &HoverConfig,\n     token: &SyntaxToken,\n ) -> Option<RangeInfo<HoverResult>> {\n+    if token.kind() == COMMENT {\n+        return None;\n+    }\n     let node = token\n         .ancestors()\n         .take_while(|it| !ast::Item::can_cast(it.kind()))\n@@ -749,7 +714,73 @@ fn definition_mod_path(db: &RootDatabase, def: &Definition) -> Option<String> {\n     def.module(db).map(|module| render_path(db, module, definition_owner_name(db, def)))\n }\n \n-fn hover_for_definition(\n+pub(crate) fn find_definition(\n+    sema: &Semantics<RootDatabase>,\n+    node: &SyntaxNode,\n+) -> Option<Definition> {\n+    match_ast! {\n+        match node {\n+            ast::Name(name) => NameClass::classify(sema, &name).map(|class| match class {\n+                NameClass::Definition(it) | NameClass::ConstReference(it) => it,\n+                NameClass::PatFieldShorthand { local_def, field_ref: _ } => Definition::Local(local_def),\n+            }),\n+            ast::NameRef(name_ref) => NameRefClass::classify(sema, &name_ref).map(|class| match class {\n+                NameRefClass::Definition(def) => def,\n+                NameRefClass::FieldShorthand { local_ref: _, field_ref } => {\n+                    Definition::Field(field_ref)\n+                }\n+            }),\n+            ast::Lifetime(lifetime) => NameClass::classify_lifetime(&sema, &lifetime).map_or_else(\n+                || {\n+                    NameRefClass::classify_lifetime(&sema, &lifetime).and_then(|class| match class {\n+                        NameRefClass::Definition(it) => Some(it),\n+                        _ => None,\n+                    })\n+                },\n+                NameClass::defined,\n+            ),\n+            _ => None,\n+        }\n+    }\n+}\n+\n+pub(crate) fn hover_for_definition(\n+    sema: &Semantics<RootDatabase>,\n+    file_id: FileId,\n+    definition: Definition,\n+    node: &SyntaxNode,\n+    config: &HoverConfig,\n+) -> Option<HoverResult> {\n+    let famous_defs = match &definition {\n+        Definition::ModuleDef(hir::ModuleDef::BuiltinType(_)) => {\n+            Some(FamousDefs(&sema, sema.scope(&node).krate()))\n+        }\n+        _ => None,\n+    };\n+    if let Some(markup) = markup_for_definition(sema.db, definition, famous_defs.as_ref(), config) {\n+        let mut res = HoverResult::default();\n+        res.markup = process_markup(sema.db, definition, &markup, config);\n+        if let Some(action) = show_implementations_action(sema.db, definition) {\n+            res.actions.push(action);\n+        }\n+\n+        if let Some(action) = show_fn_references_action(sema.db, definition) {\n+            res.actions.push(action);\n+        }\n+\n+        if let Some(action) = runnable_action(&sema, definition, file_id) {\n+            res.actions.push(action);\n+        }\n+\n+        if let Some(action) = goto_type_action_for_def(sema.db, definition) {\n+            res.actions.push(action);\n+        }\n+        return Some(res);\n+    }\n+    None\n+}\n+\n+fn markup_for_definition(\n     db: &RootDatabase,\n     def: Definition,\n     famous_defs: Option<&FamousDefs>,\n@@ -885,7 +916,7 @@ mod tests {\n                 FileRange { file_id: position.file_id, range: TextRange::empty(position.offset) },\n             )\n             .unwrap();\n-        assert!(hover.is_none());\n+        assert!(hover.is_none(), \"hover not expected but found: {:?}\", hover.unwrap());\n     }\n \n     fn check(ra_fixture: &str, expect: Expect) {"}]}