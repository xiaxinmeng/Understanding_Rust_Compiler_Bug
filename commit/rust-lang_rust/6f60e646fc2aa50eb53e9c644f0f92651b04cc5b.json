{"sha": "6f60e646fc2aa50eb53e9c644f0f92651b04cc5b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmNjBlNjQ2ZmMyYWE1MGViNTNlOWM2NDRmMGY5MjY1MWIwNGNjNWI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-04-18T18:42:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-18T18:42:07Z"}, "message": "Merge #3894\n\n3894: Match check enum record r=flodiebold a=JoshMcguigan\n\nThis PR implements match statement exhaustiveness checking for record type enums.\r\n\r\nIt also make a minor addition to the test infrastructure to allow testing against a single diagnostic, so you can be sure your test is triggering (or not) whichever diagnostic you expect.\n\nCo-authored-by: Josh Mcguigan <joshmcg88@gmail.com>", "tree": {"sha": "507f92918f72c37e6ff3adf24b9ddefa83df42e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/507f92918f72c37e6ff3adf24b9ddefa83df42e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6f60e646fc2aa50eb53e9c644f0f92651b04cc5b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJem0n/CRBK7hj4Ov3rIwAAdHIIAEn76jx8WhU+3YUy/YsH1IMe\nVUk/1W59u1IXwu1NMIvCwdzVAyHJunjfm8jrNTqiRmnQDJJznSBMvrLBLqokBsY9\nTiYpQchzsODI4f1r5CZvmWYbgB0T6g9V+uguMXvxli1KUtJ3oD3ClLD7pwBRl7WV\nu63KGKN0k/aakGieUmSc/ISPO8sNgL1h5/QwtMxs2nfH4w6yDcBsAPdCB/IinOUk\nGCP/mG87vthmDvmZokwtBQ1na21sA/B7k9trbcGh4QJAfxJG8CYi/VSBbFIvFsm3\nRL0e7sezHf4bvFMo5LWaNNlEoGgvU3jO756TRURvC21x7s5nO/l8od00XsLouXs=\n=+5s5\n-----END PGP SIGNATURE-----\n", "payload": "tree 507f92918f72c37e6ff3adf24b9ddefa83df42e1\nparent 98819d89199c5138cc5018b036b0ec5d3fade77e\nparent 7adb681b1f8dbdc0205efbe22698c28ab9da6378\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1587235327 +0000\ncommitter GitHub <noreply@github.com> 1587235327 +0000\n\nMerge #3894\n\n3894: Match check enum record r=flodiebold a=JoshMcguigan\n\nThis PR implements match statement exhaustiveness checking for record type enums.\r\n\r\nIt also make a minor addition to the test infrastructure to allow testing against a single diagnostic, so you can be sure your test is triggering (or not) whichever diagnostic you expect.\n\nCo-authored-by: Josh Mcguigan <joshmcg88@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6f60e646fc2aa50eb53e9c644f0f92651b04cc5b", "html_url": "https://github.com/rust-lang/rust/commit/6f60e646fc2aa50eb53e9c644f0f92651b04cc5b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6f60e646fc2aa50eb53e9c644f0f92651b04cc5b/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "98819d89199c5138cc5018b036b0ec5d3fade77e", "url": "https://api.github.com/repos/rust-lang/rust/commits/98819d89199c5138cc5018b036b0ec5d3fade77e", "html_url": "https://github.com/rust-lang/rust/commit/98819d89199c5138cc5018b036b0ec5d3fade77e"}, {"sha": "7adb681b1f8dbdc0205efbe22698c28ab9da6378", "url": "https://api.github.com/repos/rust-lang/rust/commits/7adb681b1f8dbdc0205efbe22698c28ab9da6378", "html_url": "https://github.com/rust-lang/rust/commit/7adb681b1f8dbdc0205efbe22698c28ab9da6378"}], "stats": {"total": 372, "additions": 331, "deletions": 41}, "files": [{"sha": "779e7857458a476a81588821a90b0300e2f46fb2", "filename": "crates/ra_hir_ty/src/_match.rs", "status": "modified", "additions": 304, "deletions": 32, "changes": 336, "blob_url": "https://github.com/rust-lang/rust/blob/6f60e646fc2aa50eb53e9c644f0f92651b04cc5b/crates%2Fra_hir_ty%2Fsrc%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f60e646fc2aa50eb53e9c644f0f92651b04cc5b/crates%2Fra_hir_ty%2Fsrc%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2F_match.rs?ref=6f60e646fc2aa50eb53e9c644f0f92651b04cc5b", "patch": "@@ -235,10 +235,19 @@ impl From<PatId> for PatIdOrWild {\n     }\n }\n \n+impl From<&PatId> for PatIdOrWild {\n+    fn from(pat_id: &PatId) -> Self {\n+        Self::PatId(*pat_id)\n+    }\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq)]\n pub enum MatchCheckErr {\n     NotImplemented,\n     MalformedMatchArm,\n+    /// Used when type inference cannot resolve the type of\n+    /// a pattern or expression.\n+    Unknown,\n }\n \n /// The return type of `is_useful` is either an indication of usefulness\n@@ -290,10 +299,14 @@ impl PatStack {\n         Self::from_slice(&self.0[1..])\n     }\n \n-    fn replace_head_with<T: Into<PatIdOrWild> + Copy>(&self, pat_ids: &[T]) -> PatStack {\n+    fn replace_head_with<I, T>(&self, pats: I) -> PatStack\n+    where\n+        I: Iterator<Item = T>,\n+        T: Into<PatIdOrWild>,\n+    {\n         let mut patterns: PatStackInner = smallvec![];\n-        for pat in pat_ids {\n-            patterns.push((*pat).into());\n+        for pat in pats {\n+            patterns.push(pat.into());\n         }\n         for pat in &self.0[1..] {\n             patterns.push(*pat);\n@@ -330,7 +343,7 @@ impl PatStack {\n                     return Err(MatchCheckErr::NotImplemented);\n                 }\n \n-                Some(self.replace_head_with(pat_ids))\n+                Some(self.replace_head_with(pat_ids.iter()))\n             }\n             (Pat::Lit(lit_expr), Constructor::Bool(constructor_val)) => {\n                 match cx.body.exprs[lit_expr] {\n@@ -382,21 +395,49 @@ impl PatStack {\n                                 new_patterns.push((*pat_id).into());\n                             }\n \n-                            Some(self.replace_head_with(&new_patterns))\n+                            Some(self.replace_head_with(new_patterns.into_iter()))\n                         } else {\n                             return Err(MatchCheckErr::MalformedMatchArm);\n                         }\n                     } else {\n                         // If there is no ellipsis in the tuple pattern, the number\n                         // of patterns must equal the constructor arity.\n                         if pat_ids.len() == constructor_arity {\n-                            Some(self.replace_head_with(pat_ids))\n+                            Some(self.replace_head_with(pat_ids.into_iter()))\n                         } else {\n                             return Err(MatchCheckErr::MalformedMatchArm);\n                         }\n                     }\n                 }\n             }\n+            (Pat::Record { args: ref arg_patterns, .. }, Constructor::Enum(e)) => {\n+                let pat_id = self.head().as_id().expect(\"we know this isn't a wild\");\n+                if !enum_variant_matches(cx, pat_id, *e) {\n+                    None\n+                } else {\n+                    match cx.db.enum_data(e.parent).variants[e.local_id].variant_data.as_ref() {\n+                        VariantData::Record(struct_field_arena) => {\n+                            // Here we treat any missing fields in the record as the wild pattern, as\n+                            // if the record has ellipsis. We want to do this here even if the\n+                            // record does not contain ellipsis, because it allows us to continue\n+                            // enforcing exhaustiveness for the rest of the match statement.\n+                            //\n+                            // Creating the diagnostic for the missing field in the pattern\n+                            // should be done in a different diagnostic.\n+                            let patterns = struct_field_arena.iter().map(|(_, struct_field)| {\n+                                arg_patterns\n+                                    .iter()\n+                                    .find(|pat| pat.name == struct_field.name)\n+                                    .map(|pat| PatIdOrWild::from(pat.pat))\n+                                    .unwrap_or(PatIdOrWild::Wild)\n+                            });\n+\n+                            Some(self.replace_head_with(patterns))\n+                        }\n+                        _ => return Err(MatchCheckErr::Unknown),\n+                    }\n+                }\n+            }\n             (Pat::Or(_), _) => return Err(MatchCheckErr::NotImplemented),\n             (_, _) => return Err(MatchCheckErr::NotImplemented),\n         };\n@@ -655,8 +696,8 @@ impl Constructor {\n             Constructor::Enum(e) => {\n                 match cx.db.enum_data(e.parent).variants[e.local_id].variant_data.as_ref() {\n                     VariantData::Tuple(struct_field_data) => struct_field_data.len(),\n+                    VariantData::Record(struct_field_data) => struct_field_data.len(),\n                     VariantData::Unit => 0,\n-                    _ => return Err(MatchCheckErr::NotImplemented),\n                 }\n             }\n         };\n@@ -695,10 +736,10 @@ fn pat_constructor(cx: &MatchCheckCtx, pat: PatIdOrWild) -> MatchCheckResult<Opt\n             Expr::Literal(Literal::Bool(val)) => Some(Constructor::Bool(val)),\n             _ => return Err(MatchCheckErr::NotImplemented),\n         },\n-        Pat::TupleStruct { .. } | Pat::Path(_) => {\n+        Pat::TupleStruct { .. } | Pat::Path(_) | Pat::Record { .. } => {\n             let pat_id = pat.as_id().expect(\"we already know this pattern is not a wild\");\n             let variant_id =\n-                cx.infer.variant_resolution_for_pat(pat_id).ok_or(MatchCheckErr::NotImplemented)?;\n+                cx.infer.variant_resolution_for_pat(pat_id).ok_or(MatchCheckErr::Unknown)?;\n             match variant_id {\n                 VariantId::EnumVariantId(enum_variant_id) => {\n                     Some(Constructor::Enum(enum_variant_id))\n@@ -759,20 +800,22 @@ mod tests {\n     pub(super) use insta::assert_snapshot;\n     pub(super) use ra_db::fixture::WithFixture;\n \n-    pub(super) use crate::test_db::TestDB;\n+    pub(super) use crate::{diagnostics::MissingMatchArms, test_db::TestDB};\n \n     pub(super) fn check_diagnostic_message(content: &str) -> String {\n-        TestDB::with_single_file(content).0.diagnostics().0\n+        TestDB::with_single_file(content).0.diagnostic::<MissingMatchArms>().0\n     }\n \n     pub(super) fn check_diagnostic(content: &str) {\n-        let diagnostic_count = TestDB::with_single_file(content).0.diagnostics().1;\n+        let diagnostic_count =\n+            TestDB::with_single_file(content).0.diagnostic::<MissingMatchArms>().1;\n \n         assert_eq!(1, diagnostic_count, \"no diagnostic reported\");\n     }\n \n     pub(super) fn check_no_diagnostic(content: &str) {\n-        let diagnostic_count = TestDB::with_single_file(content).0.diagnostics().1;\n+        let diagnostic_count =\n+            TestDB::with_single_file(content).0.diagnostic::<MissingMatchArms>().1;\n \n         assert_eq!(0, diagnostic_count, \"expected no diagnostic, found one\");\n     }\n@@ -1531,6 +1574,236 @@ mod tests {\n         check_no_diagnostic(content);\n     }\n \n+    #[test]\n+    fn enum_record_no_arms() {\n+        let content = r\"\n+            enum Either {\n+                A { foo: bool },\n+                B,\n+            }\n+            fn test_fn() {\n+                let a = Either::A { foo: true };\n+                match a {\n+                }\n+            }\n+        \";\n+\n+        check_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_record_missing_arms() {\n+        let content = r\"\n+            enum Either {\n+                A { foo: bool },\n+                B,\n+            }\n+            fn test_fn() {\n+                let a = Either::A { foo: true };\n+                match a {\n+                    Either::A { foo: true } => (),\n+                }\n+            }\n+        \";\n+\n+        check_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_record_no_diagnostic() {\n+        let content = r\"\n+            enum Either {\n+                A { foo: bool },\n+                B,\n+            }\n+            fn test_fn() {\n+                let a = Either::A { foo: true };\n+                match a {\n+                    Either::A { foo: true } => (),\n+                    Either::A { foo: false } => (),\n+                    Either::B => (),\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_record_missing_field_no_diagnostic() {\n+        let content = r\"\n+            enum Either {\n+                A { foo: bool },\n+                B,\n+            }\n+            fn test_fn() {\n+                let a = Either::B;\n+                match a {\n+                    Either::A { } => (),\n+                    Either::B => (),\n+                }\n+            }\n+        \";\n+\n+        // When `Either::A` is missing a struct member, we don't want\n+        // to fire the missing match arm diagnostic. This should fire\n+        // some other diagnostic.\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_record_missing_field_missing_match_arm() {\n+        let content = r\"\n+            enum Either {\n+                A { foo: bool },\n+                B,\n+            }\n+            fn test_fn() {\n+                let a = Either::B;\n+                match a {\n+                    Either::A { } => (),\n+                }\n+            }\n+        \";\n+\n+        // Even though `Either::A` is missing fields, we still want to fire\n+        // the missing arm diagnostic here, since we know `Either::B` is missing.\n+        check_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_record_no_diagnostic_wild() {\n+        let content = r\"\n+            enum Either {\n+                A { foo: bool },\n+                B,\n+            }\n+            fn test_fn() {\n+                let a = Either::A { foo: true };\n+                match a {\n+                    Either::A { foo: _ } => (),\n+                    Either::B => (),\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_record_fields_out_of_order_missing_arm() {\n+        let content = r\"\n+            enum Either {\n+                A { foo: bool, bar: () },\n+                B,\n+            }\n+            fn test_fn() {\n+                let a = Either::A { foo: true };\n+                match a {\n+                    Either::A { bar: (), foo: false } => (),\n+                    Either::A { foo: true, bar: () } => (),\n+                }\n+            }\n+        \";\n+\n+        check_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_record_fields_out_of_order_no_diagnostic() {\n+        let content = r\"\n+            enum Either {\n+                A { foo: bool, bar: () },\n+                B,\n+            }\n+            fn test_fn() {\n+                let a = Either::A { foo: true };\n+                match a {\n+                    Either::A { bar: (), foo: false } => (),\n+                    Either::A { foo: true, bar: () } => (),\n+                    Either::B => (),\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_record_ellipsis_missing_arm() {\n+        let content = r\"\n+             enum Either {\n+                 A { foo: bool, bar: bool },\n+                 B,\n+             }\n+             fn test_fn() {\n+                 match Either::B {\n+                     Either::A { foo: true, .. } => (),\n+                     Either::B => (),\n+                 }\n+             }\n+         \";\n+\n+        check_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_record_ellipsis_no_diagnostic() {\n+        let content = r\"\n+             enum Either {\n+                 A { foo: bool, bar: bool },\n+                 B,\n+             }\n+             fn test_fn() {\n+                 let a = Either::A { foo: true };\n+                 match a {\n+                     Either::A { foo: true, .. } => (),\n+                     Either::A { foo: false, .. } => (),\n+                     Either::B => (),\n+                 }\n+             }\n+         \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_record_ellipsis_all_fields_missing_arm() {\n+        let content = r\"\n+             enum Either {\n+                 A { foo: bool, bar: bool },\n+                 B,\n+             }\n+             fn test_fn() {\n+                 let a = Either::B;\n+                 match a {\n+                     Either::A { .. } => (),\n+                 }\n+             }\n+         \";\n+\n+        check_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_record_ellipsis_all_fields_no_diagnostic() {\n+        let content = r\"\n+             enum Either {\n+                 A { foo: bool, bar: bool },\n+                 B,\n+             }\n+             fn test_fn() {\n+                 let a = Either::B;\n+                 match a {\n+                     Either::A { .. } => (),\n+                     Either::B => (),\n+                 }\n+             }\n+         \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n     #[test]\n     fn enum_tuple_partial_ellipsis_no_diagnostic() {\n         let content = r\"\n@@ -1688,25 +1961,6 @@ mod false_negatives {\n         check_no_diagnostic(content);\n     }\n \n-    #[test]\n-    fn enum_record() {\n-        let content = r\"\n-            enum Either {\n-                A { foo: u32 },\n-                B,\n-            }\n-            fn test_fn() {\n-                match Either::B {\n-                    Either::A { foo: 5 } => (),\n-                }\n-            }\n-        \";\n-\n-        // This is a false negative.\n-        // We don't currently handle enum record types.\n-        check_no_diagnostic(content);\n-    }\n-\n     #[test]\n     fn internal_or() {\n         let content = r\"\n@@ -1796,4 +2050,22 @@ mod false_negatives {\n         // We don't currently handle tuple patterns with ellipsis.\n         check_no_diagnostic(content);\n     }\n+\n+    #[test]\n+    fn struct_missing_arm() {\n+        let content = r\"\n+            struct Foo {\n+                a: bool,\n+            }\n+            fn test_fn(f: Foo) {\n+                match f {\n+                    Foo { a: true } => {},\n+                }\n+            }\n+        \";\n+\n+        // This is a false negative.\n+        // We don't currently handle structs.\n+        check_no_diagnostic(content);\n+    }\n }"}, {"sha": "8498d3d966d0270e47f764fd3f4527ecf2e9bf2c", "filename": "crates/ra_hir_ty/src/test_db.rs", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6f60e646fc2aa50eb53e9c644f0f92651b04cc5b/crates%2Fra_hir_ty%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f60e646fc2aa50eb53e9c644f0f92651b04cc5b/crates%2Fra_hir_ty%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftest_db.rs?ref=6f60e646fc2aa50eb53e9c644f0f92651b04cc5b", "patch": "@@ -12,7 +12,7 @@ use ra_db::{\n };\n use stdx::format_to;\n \n-use crate::{db::HirDatabase, expr::ExprValidator};\n+use crate::{db::HirDatabase, diagnostics::Diagnostic, expr::ExprValidator};\n \n #[salsa::database(\n     ra_db::SourceDatabaseExtStorage,\n@@ -104,10 +104,7 @@ impl TestDB {\n         panic!(\"Can't find module for file\")\n     }\n \n-    // FIXME: don't duplicate this\n-    pub fn diagnostics(&self) -> (String, u32) {\n-        let mut buf = String::new();\n-        let mut count = 0;\n+    fn diag<F: FnMut(&dyn Diagnostic)>(&self, mut cb: F) {\n         let crate_graph = self.crate_graph();\n         for krate in crate_graph.iter() {\n             let crate_def_map = self.crate_def_map(krate);\n@@ -132,15 +129,36 @@ impl TestDB {\n \n             for f in fns {\n                 let infer = self.infer(f.into());\n-                let mut sink = DiagnosticSink::new(|d| {\n-                    format_to!(buf, \"{:?}: {}\\n\", d.syntax_node(self).text(), d.message());\n-                    count += 1;\n-                });\n+                let mut sink = DiagnosticSink::new(&mut cb);\n                 infer.add_diagnostics(self, f, &mut sink);\n                 let mut validator = ExprValidator::new(f, infer, &mut sink);\n                 validator.validate_body(self);\n             }\n         }\n+    }\n+\n+    pub fn diagnostics(&self) -> (String, u32) {\n+        let mut buf = String::new();\n+        let mut count = 0;\n+        self.diag(|d| {\n+            format_to!(buf, \"{:?}: {}\\n\", d.syntax_node(self).text(), d.message());\n+            count += 1;\n+        });\n+        (buf, count)\n+    }\n+\n+    /// Like `diagnostics`, but filtered for a single diagnostic.\n+    pub fn diagnostic<D: Diagnostic>(&self) -> (String, u32) {\n+        let mut buf = String::new();\n+        let mut count = 0;\n+        self.diag(|d| {\n+            // We want to filter diagnostics by the particular one we are testing for, to\n+            // avoid surprising results in tests.\n+            if d.downcast_ref::<D>().is_some() {\n+                format_to!(buf, \"{:?}: {}\\n\", d.syntax_node(self).text(), d.message());\n+                count += 1;\n+            };\n+        });\n         (buf, count)\n     }\n }"}]}