{"sha": "dec05e9c73fb5590a4f302bdf5426fc0cabe6f17", "node_id": "C_kwDOAAsO6NoAKGRlYzA1ZTljNzNmYjU1OTBhNGYzMDJiZGY1NDI2ZmMwY2FiZTZmMTc", "commit": {"author": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-11-22T12:00:07Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-12-15T16:25:50Z"}, "message": "Factor decorate closure out into a method", "tree": {"sha": "7d566be4d8da998c2cdf5c3d1d5a6443ccc4adf0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d566be4d8da998c2cdf5c3d1d5a6443ccc4adf0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dec05e9c73fb5590a4f302bdf5426fc0cabe6f17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dec05e9c73fb5590a4f302bdf5426fc0cabe6f17", "html_url": "https://github.com/rust-lang/rust/commit/dec05e9c73fb5590a4f302bdf5426fc0cabe6f17", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dec05e9c73fb5590a4f302bdf5426fc0cabe6f17/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "98dc76a374807615a3400995e86237d89df95d35", "url": "https://api.github.com/repos/rust-lang/rust/commits/98dc76a374807615a3400995e86237d89df95d35", "html_url": "https://github.com/rust-lang/rust/commit/98dc76a374807615a3400995e86237d89df95d35"}], "stats": {"total": 135, "additions": 65, "deletions": 70}, "files": [{"sha": "13472cc2bfa0a5c4b8ed7ba81baa6eb3114ac9f9", "filename": "compiler/rustc_const_eval/src/const_eval/error.rs", "status": "modified", "additions": 65, "deletions": 70, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/dec05e9c73fb5590a4f302bdf5426fc0cabe6f17/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dec05e9c73fb5590a4f302bdf5426fc0cabe6f17/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs?ref=dec05e9c73fb5590a4f302bdf5426fc0cabe6f17", "patch": "@@ -86,6 +86,59 @@ impl<'tcx> ConstEvalErr<'tcx> {\n         self.report_decorated(tcx, message, |_| {})\n     }\n \n+    #[instrument(level = \"trace\", skip(self, decorate))]\n+    pub(super) fn decorate(&self, err: &mut Diagnostic, decorate: impl FnOnce(&mut Diagnostic)) {\n+        trace!(\"reporting const eval failure at {:?}\", self.span);\n+        // Add some more context for select error types.\n+        match self.error {\n+            InterpError::Unsupported(\n+                UnsupportedOpInfo::ReadPointerAsBytes\n+                | UnsupportedOpInfo::PartialPointerOverwrite(_)\n+                | UnsupportedOpInfo::PartialPointerCopy(_),\n+            ) => {\n+                err.help(\"this code performed an operation that depends on the underlying bytes representing a pointer\");\n+                err.help(\"the absolute address of a pointer is not known at compile-time, so such operations are not supported\");\n+            }\n+            _ => {}\n+        }\n+        // Add spans for the stacktrace. Don't print a single-line backtrace though.\n+        if self.stacktrace.len() > 1 {\n+            // Helper closure to print duplicated lines.\n+            let mut flush_last_line = |last_frame, times| {\n+                if let Some((line, span)) = last_frame {\n+                    err.span_note(span, &line);\n+                    // Don't print [... additional calls ...] if the number of lines is small\n+                    if times < 3 {\n+                        for _ in 0..times {\n+                            err.span_note(span, &line);\n+                        }\n+                    } else {\n+                        err.span_note(\n+                            span,\n+                            format!(\"[... {} additional calls {} ...]\", times, &line),\n+                        );\n+                    }\n+                }\n+            };\n+\n+            let mut last_frame = None;\n+            let mut times = 0;\n+            for frame_info in &self.stacktrace {\n+                let frame = (frame_info.to_string(), frame_info.span);\n+                if last_frame.as_ref() == Some(&frame) {\n+                    times += 1;\n+                } else {\n+                    flush_last_line(last_frame, times);\n+                    last_frame = Some(frame);\n+                    times = 0;\n+                }\n+            }\n+            flush_last_line(last_frame, times);\n+        }\n+        // Let the caller attach any additional information it wants.\n+        decorate(err);\n+    }\n+\n     /// Create a diagnostic for this const eval error.\n     ///\n     /// Sets the message passed in via `message` and adds span labels with detailed error\n@@ -101,88 +154,30 @@ impl<'tcx> ConstEvalErr<'tcx> {\n         message: &str,\n         decorate: impl FnOnce(&mut Diagnostic),\n     ) -> ErrorHandled {\n-        let finish = |err: &mut Diagnostic, span_msg: Option<String>| {\n-            trace!(\"reporting const eval failure at {:?}\", self.span);\n-            if let Some(span_msg) = span_msg {\n-                err.span_label(self.span, span_msg);\n-            }\n-            // Add some more context for select error types.\n-            match self.error {\n-                InterpError::Unsupported(\n-                    UnsupportedOpInfo::ReadPointerAsBytes\n-                    | UnsupportedOpInfo::PartialPointerOverwrite(_)\n-                    | UnsupportedOpInfo::PartialPointerCopy(_),\n-                ) => {\n-                    err.help(\"this code performed an operation that depends on the underlying bytes representing a pointer\");\n-                    err.help(\"the absolute address of a pointer is not known at compile-time, so such operations are not supported\");\n-                }\n-                _ => {}\n-            }\n-            // Add spans for the stacktrace. Don't print a single-line backtrace though.\n-            if self.stacktrace.len() > 1 {\n-                // Helper closure to print duplicated lines.\n-                let mut flush_last_line = |last_frame, times| {\n-                    if let Some((line, span)) = last_frame {\n-                        err.span_note(span, &line);\n-                        // Don't print [... additional calls ...] if the number of lines is small\n-                        if times < 3 {\n-                            for _ in 0..times {\n-                                err.span_note(span, &line);\n-                            }\n-                        } else {\n-                            err.span_note(\n-                                span,\n-                                format!(\"[... {} additional calls {} ...]\", times, &line),\n-                            );\n-                        }\n-                    }\n-                };\n-\n-                let mut last_frame = None;\n-                let mut times = 0;\n-                for frame_info in &self.stacktrace {\n-                    let frame = (frame_info.to_string(), frame_info.span);\n-                    if last_frame.as_ref() == Some(&frame) {\n-                        times += 1;\n-                    } else {\n-                        flush_last_line(last_frame, times);\n-                        last_frame = Some(frame);\n-                        times = 0;\n-                    }\n-                }\n-                flush_last_line(last_frame, times);\n-            }\n-            // Let the caller attach any additional information it wants.\n-            decorate(err);\n-        };\n-\n         debug!(\"self.error: {:?}\", self.error);\n         // Special handling for certain errors\n         match &self.error {\n             // Don't emit a new diagnostic for these errors\n             err_inval!(Layout(LayoutError::Unknown(_))) | err_inval!(TooGeneric) => {\n-                return ErrorHandled::TooGeneric;\n-            }\n-            err_inval!(AlreadyReported(error_reported)) => {\n-                return ErrorHandled::Reported(*error_reported);\n+                ErrorHandled::TooGeneric\n             }\n+            err_inval!(AlreadyReported(error_reported)) => ErrorHandled::Reported(*error_reported),\n             err_inval!(Layout(LayoutError::SizeOverflow(_))) => {\n                 // We must *always* hard error on these, even if the caller wants just a lint.\n                 // The `message` makes little sense here, this is a more serious error than the\n                 // caller thinks anyway.\n                 // See <https://github.com/rust-lang/rust/pull/63152>.\n                 let mut err = struct_error(tcx, &self.error.to_string());\n-                finish(&mut err, None);\n-                return ErrorHandled::Reported(err.emit());\n+                self.decorate(&mut err, decorate);\n+                ErrorHandled::Reported(err.emit())\n             }\n-            _ => {}\n-        };\n-\n-        let err_msg = self.error.to_string();\n-\n-        // Report as hard error.\n-        let mut err = struct_error(tcx, message);\n-        finish(&mut err, Some(err_msg));\n-        ErrorHandled::Reported(err.emit())\n+            _ => {\n+                // Report as hard error.\n+                let mut err = struct_error(tcx, message);\n+                err.span_label(self.span, self.error.to_string());\n+                self.decorate(&mut err, decorate);\n+                ErrorHandled::Reported(err.emit())\n+            }\n+        }\n     }\n }"}]}