{"sha": "4ff161852016c6c15954d6f30bd637834a2b2b68", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmZjE2MTg1MjAxNmM2YzE1OTU0ZDZmMzBiZDYzNzgzNGEyYjJiNjg=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2018-12-24T19:32:39Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2018-12-25T14:16:42Z"}, "message": "Do name resolution by namespace (types/values)", "tree": {"sha": "7ea2d34a8f58f5a242481e6d6294bef22546fcaf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7ea2d34a8f58f5a242481e6d6294bef22546fcaf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ff161852016c6c15954d6f30bd637834a2b2b68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ff161852016c6c15954d6f30bd637834a2b2b68", "html_url": "https://github.com/rust-lang/rust/commit/4ff161852016c6c15954d6f30bd637834a2b2b68", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ff161852016c6c15954d6f30bd637834a2b2b68/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5b68f2094d49cacde6d7f0c49f521a0b25f34bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5b68f2094d49cacde6d7f0c49f521a0b25f34bd", "html_url": "https://github.com/rust-lang/rust/commit/b5b68f2094d49cacde6d7f0c49f521a0b25f34bd"}], "stats": {"total": 296, "additions": 212, "deletions": 84}, "files": [{"sha": "8c00be499eda28820d4e61fc03807fe7d0d4a1cc", "filename": "crates/ra_analysis/src/completion/complete_path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ff161852016c6c15954d6f30bd637834a2b2b68/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff161852016c6c15954d6f30bd637834a2b2b68/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_path.rs?ref=4ff161852016c6c15954d6f30bd637834a2b2b68", "patch": "@@ -8,7 +8,7 @@ pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) -> C\n         (Some(path), Some(module)) => (path.clone(), module),\n         _ => return Ok(()),\n     };\n-    let def_id = match module.resolve_path(ctx.db, path)? {\n+    let def_id = match module.resolve_path(ctx.db, path)?.take_types() {\n         Some(it) => it,\n         None => return Ok(()),\n     };"}, {"sha": "6d466c8bdd40dfcc897291d271db0809b32f16a5", "filename": "crates/ra_analysis/src/completion/completion_item.rs", "status": "modified", "additions": 25, "deletions": 10, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4ff161852016c6c15954d6f30bd637834a2b2b68/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff161852016c6c15954d6f30bd637834a2b2b68/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcompletion_item.rs?ref=4ff161852016c6c15954d6f30bd637834a2b2b68", "patch": "@@ -1,5 +1,7 @@\n use crate::db;\n \n+use hir::PerNs;\n+\n /// `CompletionItem` describes a single completion variant in the editor pop-up.\n /// It is basically a POD with various properties. To construct a\n /// `CompletionItem`, use `new` method and the `Builder` struct.\n@@ -25,6 +27,8 @@ pub enum CompletionItemKind {\n     Keyword,\n     Module,\n     Function,\n+    Struct,\n+    Enum,\n     Binding,\n }\n \n@@ -117,16 +121,27 @@ impl Builder {\n         db: &db::RootDatabase,\n         resolution: &hir::Resolution,\n     ) -> Builder {\n-        if let Some(def_id) = resolution.def_id {\n-            if let Ok(def) = def_id.resolve(db) {\n-                let kind = match def {\n-                    hir::Def::Module(..) => CompletionItemKind::Module,\n-                    hir::Def::Function(..) => CompletionItemKind::Function,\n-                    _ => return self,\n-                };\n-                self.kind = Some(kind);\n-            }\n-        }\n+        let resolved = resolution.def_id.and_then(|d| d.resolve(db).ok());\n+        let kind = match resolved {\n+            PerNs {\n+                types: Some(hir::Def::Module(..)),\n+                ..\n+            } => CompletionItemKind::Module,\n+            PerNs {\n+                types: Some(hir::Def::Struct(..)),\n+                ..\n+            } => CompletionItemKind::Struct,\n+            PerNs {\n+                types: Some(hir::Def::Enum(..)),\n+                ..\n+            } => CompletionItemKind::Enum,\n+            PerNs {\n+                values: Some(hir::Def::Function(..)),\n+                ..\n+            } => CompletionItemKind::Function,\n+            _ => return self,\n+        };\n+        self.kind = Some(kind);\n         self\n     }\n }"}, {"sha": "677745d57db73e424e43ffff5d009d3e7a3932f5", "filename": "crates/ra_analysis/src/db.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ff161852016c6c15954d6f30bd637834a2b2b68/crates%2Fra_analysis%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff161852016c6c15954d6f30bd637834a2b2b68/crates%2Fra_analysis%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdb.rs?ref=4ff161852016c6c15954d6f30bd637834a2b2b68", "patch": "@@ -95,8 +95,8 @@ salsa::database_storage! {\n             fn submodules() for hir::db::SubmodulesQuery;\n             fn infer() for hir::db::InferQuery;\n             fn type_for_def() for hir::db::TypeForDefQuery;\n-            fn struct_data() for db::StructDataQuery;\n-            fn enum_data() for db::EnumDataQuery;\n+            fn struct_data() for hir::db::StructDataQuery;\n+            fn enum_data() for hir::db::EnumDataQuery;\n         }\n     }\n }"}, {"sha": "81526fe9cab91c3d2662694d803b9a7714bbb0a1", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4ff161852016c6c15954d6f30bd637834a2b2b68/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff161852016c6c15954d6f30bd637834a2b2b68/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=4ff161852016c6c15954d6f30bd637834a2b2b68", "patch": "@@ -41,7 +41,7 @@ use crate::{\n pub use self::{\n     path::{Path, PathKind},\n     krate::Crate,\n-    module::{Module, ModuleId, Problem, nameres::ItemMap, ModuleScope, Resolution},\n+    module::{Module, ModuleId, Problem, nameres::{ItemMap, PerNs, Namespace}, ModuleScope, Resolution},\n     function::{Function, FnScopes},\n     adt::{Struct, Enum},\n };\n@@ -61,6 +61,8 @@ pub(crate) enum DefKind {\n     Struct,\n     Enum,\n     Item,\n+\n+    StructCtor,\n }\n \n #[derive(Clone, Debug, PartialEq, Eq, Hash)]\n@@ -72,18 +74,18 @@ pub struct DefLoc {\n }\n \n impl DefKind {\n-    pub(crate) fn for_syntax_kind(kind: SyntaxKind) -> Option<DefKind> {\n+    pub(crate) fn for_syntax_kind(kind: SyntaxKind) -> PerNs<DefKind> {\n         match kind {\n-            SyntaxKind::FN_DEF => Some(DefKind::Function),\n-            SyntaxKind::MODULE => Some(DefKind::Module),\n+            SyntaxKind::FN_DEF => PerNs::values(DefKind::Function),\n+            SyntaxKind::MODULE => PerNs::types(DefKind::Module),\n+            SyntaxKind::STRUCT_DEF => PerNs::both(DefKind::Struct, DefKind::StructCtor),\n+            SyntaxKind::ENUM_DEF => PerNs::types(DefKind::Enum),\n             // These define items, but don't have their own DefKinds yet:\n-            SyntaxKind::STRUCT_DEF => Some(DefKind::Struct),\n-            SyntaxKind::ENUM_DEF => Some(DefKind::Enum),\n-            SyntaxKind::TRAIT_DEF => Some(DefKind::Item),\n-            SyntaxKind::TYPE_DEF => Some(DefKind::Item),\n-            SyntaxKind::CONST_DEF => Some(DefKind::Item),\n-            SyntaxKind::STATIC_DEF => Some(DefKind::Item),\n-            _ => None,\n+            SyntaxKind::TRAIT_DEF => PerNs::types(DefKind::Item),\n+            SyntaxKind::TYPE_DEF => PerNs::types(DefKind::Item),\n+            SyntaxKind::CONST_DEF => PerNs::values(DefKind::Item),\n+            SyntaxKind::STATIC_DEF => PerNs::values(DefKind::Item),\n+            _ => PerNs::none(),\n         }\n     }\n }\n@@ -128,6 +130,7 @@ impl DefId {\n                 let enum_def = Enum::new(self);\n                 Def::Enum(enum_def)\n             }\n+            DefKind::StructCtor => Def::Item,\n             DefKind::Item => Def::Item,\n         };\n         Ok(res)"}, {"sha": "e1a0e4b59536bbdce485e838d6c12c0b9910500a", "filename": "crates/ra_hir/src/module.rs", "status": "modified", "additions": 30, "deletions": 12, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/4ff161852016c6c15954d6f30bd637834a2b2b68/crates%2Fra_hir%2Fsrc%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff161852016c6c15954d6f30bd637834a2b2b68/crates%2Fra_hir%2Fsrc%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule.rs?ref=4ff161852016c6c15954d6f30bd637834a2b2b68", "patch": "@@ -17,7 +17,7 @@ use crate::{\n     arena::{Arena, Id},\n };\n \n-pub use self::nameres::{ModuleScope, Resolution};\n+pub use self::nameres::{ModuleScope, Resolution, Namespace, PerNs};\n \n /// `Module` is API entry point to get all the information\n /// about a particular module.\n@@ -115,37 +115,55 @@ impl Module {\n         Ok(res)\n     }\n \n-    pub fn resolve_path(&self, db: &impl HirDatabase, path: Path) -> Cancelable<Option<DefId>> {\n-        let mut curr = match path.kind {\n-            PathKind::Crate => self.crate_root(),\n-            PathKind::Self_ | PathKind::Plain => self.clone(),\n-            PathKind::Super => ctry!(self.parent()),\n-        }\n-        .def_id(db);\n+    pub fn resolve_path(&self, db: &impl HirDatabase, path: Path) -> Cancelable<PerNs<DefId>> {\n+        let mut curr_per_ns = PerNs::types(\n+            match path.kind {\n+                PathKind::Crate => self.crate_root(),\n+                PathKind::Self_ | PathKind::Plain => self.clone(),\n+                PathKind::Super => {\n+                    if let Some(p) = self.parent() {\n+                        p\n+                    } else {\n+                        return Ok(PerNs::none());\n+                    }\n+                }\n+            }\n+            .def_id(db),\n+        );\n \n         let segments = path.segments;\n         for name in segments.iter() {\n+            let curr = if let Some(r) = curr_per_ns.as_ref().take(Namespace::Types) {\n+                r\n+            } else {\n+                return Ok(PerNs::none());\n+            };\n             let module = match curr.loc(db) {\n                 DefLoc {\n                     kind: DefKind::Module,\n                     source_root_id,\n                     module_id,\n                     ..\n                 } => Module::new(db, source_root_id, module_id)?,\n-                _ => return Ok(None),\n+                // TODO here would be the place to handle enum variants...\n+                _ => return Ok(PerNs::none()),\n             };\n             let scope = module.scope(db)?;\n-            curr = ctry!(ctry!(scope.get(&name)).def_id);\n+            curr_per_ns = if let Some(r) = scope.get(&name) {\n+                r.def_id\n+            } else {\n+                return Ok(PerNs::none());\n+            };\n         }\n-        Ok(Some(curr))\n+        Ok(curr_per_ns)\n     }\n \n     pub fn problems(&self, db: &impl HirDatabase) -> Vec<(SyntaxNode, Problem)> {\n         self.module_id.problems(&self.tree, db)\n     }\n }\n \n-/// Phisically, rust source is organized as a set of files, but logically it is\n+/// Physically, rust source is organized as a set of files, but logically it is\n /// organized as a tree of modules. Usually, a single file corresponds to a\n /// single module, but it is not nessary the case.\n ///"}, {"sha": "33c9d93c2886e76c3301a550af1be036c903f502", "filename": "crates/ra_hir/src/module/nameres.rs", "status": "modified", "additions": 118, "deletions": 36, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/4ff161852016c6c15954d6f30bd637834a2b2b68/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff161852016c6c15954d6f30bd637834a2b2b68/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres.rs?ref=4ff161852016c6c15954d6f30bd637834a2b2b68", "patch": "@@ -118,22 +118,96 @@ enum ImportKind {\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct Resolution {\n     /// None for unresolved\n-    pub def_id: Option<DefId>,\n+    pub def_id: PerNs<DefId>,\n     /// ident by whitch this is imported into local scope.\n     pub import: Option<NamedImport>,\n }\n \n-// #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-// enum Namespace {\n-//     Types,\n-//     Values,\n-// }\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub enum Namespace {\n+    Types,\n+    Values,\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct PerNs<T> {\n+    pub types: Option<T>,\n+    pub values: Option<T>,\n+}\n+\n+impl<T> PerNs<T> {\n+    pub fn none() -> PerNs<T> {\n+        PerNs {\n+            types: None,\n+            values: None,\n+        }\n+    }\n+\n+    pub fn values(t: T) -> PerNs<T> {\n+        PerNs {\n+            types: None,\n+            values: Some(t),\n+        }\n+    }\n+\n+    pub fn types(t: T) -> PerNs<T> {\n+        PerNs {\n+            types: Some(t),\n+            values: None,\n+        }\n+    }\n+\n+    pub fn both(types: T, values: T) -> PerNs<T> {\n+        PerNs {\n+            types: Some(types),\n+            values: Some(values),\n+        }\n+    }\n+\n+    pub fn is_none(&self) -> bool {\n+        self.types.is_none() && self.values.is_none()\n+    }\n+\n+    pub fn take(self, namespace: Namespace) -> Option<T> {\n+        match namespace {\n+            Namespace::Types => self.types,\n+            Namespace::Values => self.values,\n+        }\n+    }\n+\n+    pub fn take_types(self) -> Option<T> {\n+        self.types\n+    }\n+\n+    pub fn take_values(self) -> Option<T> {\n+        self.values\n+    }\n \n-// #[derive(Debug)]\n-// struct PerNs<T> {\n-//     types: Option<T>,\n-//     values: Option<T>,\n-// }\n+    pub fn get(&self, namespace: Namespace) -> Option<&T> {\n+        self.as_ref().take(namespace)\n+    }\n+\n+    pub fn as_ref(&self) -> PerNs<&T> {\n+        PerNs {\n+            types: self.types.as_ref(),\n+            values: self.values.as_ref(),\n+        }\n+    }\n+\n+    pub fn and_then<U>(self, f: impl Fn(T) -> Option<U>) -> PerNs<U> {\n+        PerNs {\n+            types: self.types.and_then(&f),\n+            values: self.values.and_then(&f),\n+        }\n+    }\n+\n+    pub fn map<U>(self, f: impl Fn(T) -> U) -> PerNs<U> {\n+        PerNs {\n+            types: self.types.map(&f),\n+            values: self.values.map(&f),\n+        }\n+    }\n+}\n \n impl InputModuleItems {\n     pub(crate) fn new<'a>(\n@@ -254,7 +328,7 @@ where\n                 for dep in krate.dependencies(self.db) {\n                     if let Some(module) = dep.krate.root_module(self.db)? {\n                         let def_id = module.def_id(self.db);\n-                        self.add_module_item(&mut module_items, dep.name, def_id);\n+                        self.add_module_item(&mut module_items, dep.name, PerNs::types(def_id));\n                     }\n                 }\n             };\n@@ -265,7 +339,7 @@ where\n                     module_items.items.insert(\n                         name.clone(),\n                         Resolution {\n-                            def_id: None,\n+                            def_id: PerNs::none(),\n                             import: Some(import),\n                         },\n                     );\n@@ -277,18 +351,23 @@ where\n             if item.kind == MODULE {\n                 continue;\n             }\n-            let def_loc = DefLoc {\n-                kind: DefKind::for_syntax_kind(item.kind).unwrap_or(DefKind::Item),\n-                source_root_id: self.source_root,\n-                module_id,\n-                source_item_id: SourceItemId {\n-                    file_id,\n-                    item_id: Some(item.id),\n-                },\n-            };\n-            let def_id = def_loc.id(self.db);\n+            // depending on the item kind, the location can define something in\n+            // the values namespace, the types namespace, or both\n+            let kind = DefKind::for_syntax_kind(item.kind);\n+            let def_id = kind.map(|k| {\n+                let def_loc = DefLoc {\n+                    kind: k,\n+                    source_root_id: self.source_root,\n+                    module_id,\n+                    source_item_id: SourceItemId {\n+                        file_id,\n+                        item_id: Some(item.id),\n+                    },\n+                };\n+                def_loc.id(self.db)\n+            });\n             let resolution = Resolution {\n-                def_id: Some(def_id),\n+                def_id,\n                 import: None,\n             };\n             module_items.items.insert(item.name.clone(), resolution);\n@@ -303,16 +382,16 @@ where\n                 source_item_id: module_id.source(&self.module_tree).0,\n             };\n             let def_id = def_loc.id(self.db);\n-            self.add_module_item(&mut module_items, name, def_id);\n+            self.add_module_item(&mut module_items, name, PerNs::types(def_id));\n         }\n \n         self.result.per_module.insert(module_id, module_items);\n         Ok(())\n     }\n \n-    fn add_module_item(&self, module_items: &mut ModuleScope, name: SmolStr, def_id: DefId) {\n+    fn add_module_item(&self, module_items: &mut ModuleScope, name: SmolStr, def_id: PerNs<DefId>) {\n         let resolution = Resolution {\n-            def_id: Some(def_id),\n+            def_id,\n             import: None,\n         };\n         module_items.items.insert(name, resolution);\n@@ -347,15 +426,17 @@ where\n             let is_last = i == import.path.segments.len() - 1;\n \n             let def_id = match self.result.per_module[&curr].items.get(name) {\n-                None => return Ok(()),\n-                Some(res) => match res.def_id {\n-                    Some(it) => it,\n-                    None => return Ok(()),\n-                },\n+                Some(res) if !res.def_id.is_none() => res.def_id,\n+                _ => return Ok(()),\n             };\n \n             if !is_last {\n-                curr = match def_id.loc(self.db) {\n+                let type_def_id = if let Some(d) = def_id.take(Namespace::Types) {\n+                    d\n+                } else {\n+                    return Ok(());\n+                };\n+                curr = match type_def_id.loc(self.db) {\n                     DefLoc {\n                         kind: DefKind::Module,\n                         module_id: target_module_id,\n@@ -370,10 +451,11 @@ where\n                                 segments: import.path.segments[i + 1..].iter().cloned().collect(),\n                                 kind: PathKind::Crate,\n                             };\n-                            if let Some(def_id) = module.resolve_path(self.db, path)? {\n+                            let def_id = module.resolve_path(self.db, path)?;\n+                            if !def_id.is_none() {\n                                 self.update(module_id, |items| {\n                                     let res = Resolution {\n-                                        def_id: Some(def_id),\n+                                        def_id: def_id,\n                                         import: Some(ptr),\n                                     };\n                                     items.items.insert(name.clone(), res);\n@@ -387,7 +469,7 @@ where\n             } else {\n                 self.update(module_id, |items| {\n                     let res = Resolution {\n-                        def_id: Some(def_id),\n+                        def_id: def_id,\n                         import: Some(ptr),\n                     };\n                     items.items.insert(name.clone(), res);"}, {"sha": "03ea5c1d6c0ee474a07becefcab8a99d22fb7e3b", "filename": "crates/ra_hir/src/module/nameres/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4ff161852016c6c15954d6f30bd637834a2b2b68/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff161852016c6c15954d6f30bd637834a2b2b68/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres%2Ftests.rs?ref=4ff161852016c6c15954d6f30bd637834a2b2b68", "patch": "@@ -40,7 +40,7 @@ fn item_map_smoke_test() {\n     );\n     let name = SmolStr::from(\"Baz\");\n     let resolution = &item_map.per_module[&module_id].items[&name];\n-    assert!(resolution.def_id.is_some());\n+    assert!(resolution.def_id.take_types().is_some());\n }\n \n #[test]\n@@ -59,7 +59,7 @@ fn test_self() {\n     );\n     let name = SmolStr::from(\"Baz\");\n     let resolution = &item_map.per_module[&module_id].items[&name];\n-    assert!(resolution.def_id.is_some());\n+    assert!(resolution.def_id.take_types().is_some());\n }\n \n #[test]\n@@ -92,7 +92,7 @@ fn item_map_across_crates() {\n \n     let name = SmolStr::from(\"Baz\");\n     let resolution = &item_map.per_module[&module_id].items[&name];\n-    assert!(resolution.def_id.is_some());\n+    assert!(resolution.def_id.take_types().is_some());\n }\n \n #[test]"}, {"sha": "429292cfc9460be8745f80fbcc8ef93c17b5abe4", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4ff161852016c6c15954d6f30bd637834a2b2b68/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff161852016c6c15954d6f30bd637834a2b2b68/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=4ff161852016c6c15954d6f30bd637834a2b2b68", "patch": "@@ -15,7 +15,11 @@ use ra_syntax::{\n     SyntaxNodeRef\n };\n \n-use crate::{Def, DefId, FnScopes, Module, Function, Path, db::HirDatabase};\n+use crate::{\n+    Def, DefId, FnScopes, Module, Function,\n+    Path, db::HirDatabase,\n+    module::nameres::Namespace\n+};\n \n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub enum Ty {\n@@ -149,11 +153,12 @@ impl Ty {\n                 }\n \n                 // Resolve in module (in type namespace)\n-                let resolved = if let Some(r) = module.resolve_path(db, path)? {\n-                    r\n-                } else {\n-                    return Ok(Ty::Unknown);\n-                };\n+                let resolved =\n+                    if let Some(r) = module.resolve_path(db, path)?.take(Namespace::Types) {\n+                        r\n+                    } else {\n+                        return Ok(Ty::Unknown);\n+                    };\n                 let ty = db.type_for_def(resolved)?;\n                 ty\n             }\n@@ -325,7 +330,10 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         };\n \n         // resolve in module\n-        let resolved = ctry!(self.module.resolve_path(self.db, path)?);\n+        let resolved = ctry!(self\n+            .module\n+            .resolve_path(self.db, path)?\n+            .take(Namespace::Values));\n         let ty = self.db.type_for_def(resolved)?;\n         // TODO we will need to add type variables for type parameters etc. here\n         Ok(Some(ty))"}, {"sha": "a4371c5a531ad7fb56affb572a51520bab5ffcc8", "filename": "crates/ra_hir/src/ty/tests/data/0004_struct.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ff161852016c6c15954d6f30bd637834a2b2b68/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0004_struct.txt", "raw_url": "https://github.com/rust-lang/rust/raw/4ff161852016c6c15954d6f30bd637834a2b2b68/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0004_struct.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0004_struct.txt?ref=4ff161852016c6c15954d6f30bd637834a2b2b68", "patch": "@@ -1,10 +1,10 @@\n [86; 90) 'C(1)': [unknown]\n [72; 153) '{     ...a.c; }': ()\n-[86; 87) 'C': C\n+[86; 87) 'C': [unknown]\n [107; 108) 'a': A\n [114; 132) 'A { b:... C() }': [unknown]\n [138; 141) 'a.b': [unknown]\n [147; 150) 'a.c': [unknown]\n-[96; 97) 'B': B\n+[96; 97) 'B': [unknown]\n [88; 89) '1': [unknown]\n [82; 83) 'c': [unknown]"}, {"sha": "af52893114c5a01c3d26dabb709d3cdaa80561bf", "filename": "crates/ra_lsp_server/src/conv.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ff161852016c6c15954d6f30bd637834a2b2b68/crates%2Fra_lsp_server%2Fsrc%2Fconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff161852016c6c15954d6f30bd637834a2b2b68/crates%2Fra_lsp_server%2Fsrc%2Fconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fconv.rs?ref=4ff161852016c6c15954d6f30bd637834a2b2b68", "patch": "@@ -55,6 +55,8 @@ impl Conv for CompletionItemKind {\n             CompletionItemKind::Snippet => Snippet,\n             CompletionItemKind::Module => Module,\n             CompletionItemKind::Function => Function,\n+            CompletionItemKind::Struct => Struct,\n+            CompletionItemKind::Enum => Enum,\n             CompletionItemKind::Binding => Variable,\n         }\n     }"}]}