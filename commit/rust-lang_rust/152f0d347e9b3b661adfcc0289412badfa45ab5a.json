{"sha": "152f0d347e9b3b661adfcc0289412badfa45ab5a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1MmYwZDM0N2U5YjNiNjYxYWRmY2MwMjg5NDEyYmFkZmE0NWFiNWE=", "commit": {"author": {"name": "Saleem Jaffer", "email": "ssaleem1992@gmail.com", "date": "2019-07-31T07:18:54Z"}, "committer": {"name": "Saleem Jaffer", "email": "ssaleem1992@gmail.com", "date": "2019-07-31T07:18:54Z"}, "message": "code review fixes", "tree": {"sha": "9b5976131e1423c89803770c6e837e67c4e3dab7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b5976131e1423c89803770c6e837e67c4e3dab7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/152f0d347e9b3b661adfcc0289412badfa45ab5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/152f0d347e9b3b661adfcc0289412badfa45ab5a", "html_url": "https://github.com/rust-lang/rust/commit/152f0d347e9b3b661adfcc0289412badfa45ab5a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/152f0d347e9b3b661adfcc0289412badfa45ab5a/comments", "author": {"login": "saleemjaffer", "id": 19221716, "node_id": "MDQ6VXNlcjE5MjIxNzE2", "avatar_url": "https://avatars.githubusercontent.com/u/19221716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saleemjaffer", "html_url": "https://github.com/saleemjaffer", "followers_url": "https://api.github.com/users/saleemjaffer/followers", "following_url": "https://api.github.com/users/saleemjaffer/following{/other_user}", "gists_url": "https://api.github.com/users/saleemjaffer/gists{/gist_id}", "starred_url": "https://api.github.com/users/saleemjaffer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saleemjaffer/subscriptions", "organizations_url": "https://api.github.com/users/saleemjaffer/orgs", "repos_url": "https://api.github.com/users/saleemjaffer/repos", "events_url": "https://api.github.com/users/saleemjaffer/events{/privacy}", "received_events_url": "https://api.github.com/users/saleemjaffer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "saleemjaffer", "id": 19221716, "node_id": "MDQ6VXNlcjE5MjIxNzE2", "avatar_url": "https://avatars.githubusercontent.com/u/19221716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saleemjaffer", "html_url": "https://github.com/saleemjaffer", "followers_url": "https://api.github.com/users/saleemjaffer/followers", "following_url": "https://api.github.com/users/saleemjaffer/following{/other_user}", "gists_url": "https://api.github.com/users/saleemjaffer/gists{/gist_id}", "starred_url": "https://api.github.com/users/saleemjaffer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saleemjaffer/subscriptions", "organizations_url": "https://api.github.com/users/saleemjaffer/orgs", "repos_url": "https://api.github.com/users/saleemjaffer/repos", "events_url": "https://api.github.com/users/saleemjaffer/events{/privacy}", "received_events_url": "https://api.github.com/users/saleemjaffer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5585445a3359d74c304773e7d5d066409316ba36", "url": "https://api.github.com/repos/rust-lang/rust/commits/5585445a3359d74c304773e7d5d066409316ba36", "html_url": "https://github.com/rust-lang/rust/commit/5585445a3359d74c304773e7d5d066409316ba36"}], "stats": {"total": 214, "additions": 105, "deletions": 109}, "files": [{"sha": "8d41b019c221a4719d578556a47fa74c9398dfcf", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/152f0d347e9b3b661adfcc0289412badfa45ab5a/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/152f0d347e9b3b661adfcc0289412badfa45ab5a/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=152f0d347e9b3b661adfcc0289412badfa45ab5a", "patch": "@@ -137,13 +137,12 @@ impl<'tcx> ConstEvalErr<'tcx> {\n         message: &str,\n         lint_root: Option<hir::HirId>,\n     ) -> Result<DiagnosticBuilder<'tcx>, ErrorHandled> {\n-        use InvalidProgramInfo::*;\n         match self.error {\n-            InterpError::InvalidProgram(Layout(LayoutError::Unknown(_))) |\n-            InterpError::InvalidProgram(TooGeneric) =>\n+            err_inval!(Layout(LayoutError::Unknown(_))) |\n+            err_inval!(TooGeneric) =>\n                 return Err(ErrorHandled::TooGeneric),\n-            InterpError::InvalidProgram(Layout(LayoutError::SizeOverflow(_))) |\n-            InterpError::InvalidProgram(TypeckError) =>\n+            err_inval!(Layout(LayoutError::SizeOverflow(_))) |\n+            err_inval!(TypeckError) =>\n                 return Err(ErrorHandled::Reported),\n             _ => {},\n         }\n@@ -549,7 +548,9 @@ impl fmt::Debug for UnsupportedOpInfo<'tcx> {\n \n #[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub enum ResourceExhaustionInfo {\n+    /// The stack grew too big.\n     StackFrameLimitReached,\n+    /// The program ran into an infinite loop.\n     InfiniteLoop,\n }\n "}, {"sha": "8feb04ffe88dbf37a10c9546337632817af9f240", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/152f0d347e9b3b661adfcc0289412badfa45ab5a/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/152f0d347e9b3b661adfcc0289412badfa45ab5a/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=152f0d347e9b3b661adfcc0289412badfa45ab5a", "patch": "@@ -21,20 +21,12 @@ macro_rules! throw_ub {\n \n #[macro_export]\n macro_rules! throw_panic {\n-    ($($tt:tt)*) => {\n-        return Err($crate::mir::interpret::InterpError::Panic(\n-            $crate::mir::interpret::PanicInfo::$($tt)*\n-        ).into())\n-    };\n+    ($($tt:tt)*) => { return Err(err_panic!($($tt)*).into()) };\n }\n \n #[macro_export]\n macro_rules! throw_exhaust {\n-    ($($tt:tt)*) => {\n-        return Err($crate::mir::interpret::InterpError::ResourceExhaustion(\n-            $crate::mir::interpret::ResourceExhaustionInfo::$($tt)*\n-        ).into())\n-    };\n+    ($($tt:tt)*) => { return Err(err_exhaust!($($tt)*).into()) };\n }\n \n #[macro_export]\n@@ -55,6 +47,24 @@ macro_rules! err_unsup {\n     };\n }\n \n+#[macro_export]\n+macro_rules! err_exhaust {\n+    ($($tt:tt)*) => {\n+        $crate::mir::interpret::InterpError::ResourceExhaustion(\n+            $crate::mir::interpret::ResourceExhaustionInfo::$($tt)*\n+        )\n+    };\n+}\n+\n+#[macro_export]\n+macro_rules! err_panic {\n+    ($($tt:tt)*) => {\n+        $crate::mir::interpret::InterpError::Panic(\n+            $crate::mir::interpret::PanicInfo::$($tt)*\n+        )\n+    };\n+}\n+\n mod error;\n mod value;\n mod allocation;"}, {"sha": "1b92e4992ffb1b90d316afcc99852a25a677de0f", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/152f0d347e9b3b661adfcc0289412badfa45ab5a/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/152f0d347e9b3b661adfcc0289412badfa45ab5a/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=152f0d347e9b3b661adfcc0289412badfa45ab5a", "patch": "@@ -22,9 +22,9 @@ use syntax::source_map::{Span, DUMMY_SP};\n use crate::interpret::{self,\n     PlaceTy, MPlaceTy, OpTy, ImmTy, Immediate, Scalar,\n     RawConst, ConstValue,\n-    InterpResult, InterpErrorInfo, InterpError, GlobalId, InterpCx, StackPopCleanup,\n+    InterpResult, InterpErrorInfo, GlobalId, InterpCx, StackPopCleanup,\n     Allocation, AllocId, MemoryKind,\n-    snapshot, RefTracking, intern_const_alloc_recursive, UnsupportedOpInfo,\n+    snapshot, RefTracking, intern_const_alloc_recursive,\n };\n \n /// Number of steps until the detector even starts doing anything.\n@@ -183,7 +183,7 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n \n impl<'tcx> Into<InterpErrorInfo<'tcx>> for ConstEvalError {\n     fn into(self) -> InterpErrorInfo<'tcx> {\n-        InterpError::Unsupported(UnsupportedOpInfo::MachineError(self.to_string())).into()\n+        err_unsup!(MachineError(self.to_string())).into()\n     }\n }\n \n@@ -360,7 +360,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         Ok(Some(match ecx.load_mir(instance.def) {\n             Ok(body) => body,\n             Err(err) => {\n-                if let InterpError::Unsupported(UnsupportedOpInfo::NoMirFor(ref path)) = err.kind {\n+                if let err_unsup!(NoMirFor(ref path)) = err.kind {\n                     return Err(\n                         ConstEvalError::NeedsRfc(format!(\"calling extern function `{}`\", path))\n                             .into(),\n@@ -697,9 +697,8 @@ pub fn const_eval_raw_provider<'tcx>(\n                 // promoting runtime code is only allowed to error if it references broken constants\n                 // any other kind of error will be reported to the user as a deny-by-default lint\n                 _ => if let Some(p) = cid.promoted {\n-                    use crate::interpret::InvalidProgramInfo::ReferencedConstant;\n                     let span = tcx.promoted_mir(def_id)[p].span;\n-                    if let InterpError::InvalidProgram(ReferencedConstant) = err.error {\n+                    if let err_inval!(ReferencedConstant) = err.error {\n                         err.report_as_error(\n                             tcx.at(span),\n                             \"evaluation of constant expression failed\","}, {"sha": "7ab99976b404b0081f344a34da0bea3a97ca302f", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/152f0d347e9b3b661adfcc0289412badfa45ab5a/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/152f0d347e9b3b661adfcc0289412badfa45ab5a/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=152f0d347e9b3b661adfcc0289412badfa45ab5a", "patch": "@@ -16,8 +16,7 @@ use rustc_data_structures::indexed_vec::IndexVec;\n use rustc::mir::interpret::{\n     ErrorHandled,\n     GlobalId, Scalar, Pointer, FrameInfo, AllocId,\n-    InterpResult, InterpError,\n-    truncate, sign_extend, InvalidProgramInfo,\n+    InterpResult, truncate, sign_extend,\n };\n use rustc_data_structures::fx::FxHashMap;\n \n@@ -193,7 +192,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> LayoutOf for InterpCx<'mir, 'tcx, M> {\n         self.tcx\n             .layout_of(self.param_env.and(ty))\n             .map_err(|layout| {\n-                InterpError::InvalidProgram(InvalidProgramInfo::Layout(layout)).into()\n+                err_inval!(Layout(layout)).into()\n             })\n     }\n }\n@@ -698,9 +697,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let val = self.tcx.const_eval_raw(param_env.and(gid)).map_err(|err| {\n             match err {\n                 ErrorHandled::Reported =>\n-                    InterpError::InvalidProgram(InvalidProgramInfo::ReferencedConstant),\n+                    err_inval!(ReferencedConstant),\n                 ErrorHandled::TooGeneric =>\n-                    InterpError::InvalidProgram(InvalidProgramInfo::TooGeneric),\n+                    err_inval!(TooGeneric),\n             }\n         })?;\n         self.raw_const_to_mplace(val)"}, {"sha": "e9bba7889119a2f6a532f1d5bb0476640f8e7988", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/152f0d347e9b3b661adfcc0289412badfa45ab5a/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/152f0d347e9b3b661adfcc0289412badfa45ab5a/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=152f0d347e9b3b661adfcc0289412badfa45ab5a", "patch": "@@ -4,9 +4,7 @@\n //! memory, we need to extract all memory allocations to the global memory pool so they stay around.\n \n use rustc::ty::{Ty, TyCtxt, ParamEnv, self};\n-use rustc::mir::interpret::{\n-    InterpResult, ErrorHandled, UnsupportedOpInfo,\n-};\n+use rustc::mir::interpret::{InterpResult, ErrorHandled};\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use super::validity::RefTracking;\n@@ -16,7 +14,7 @@ use syntax::ast::Mutability;\n use syntax_pos::Span;\n \n use super::{\n-    ValueVisitor, MemoryKind, Pointer, AllocId, MPlaceTy, InterpError, Scalar,\n+    ValueVisitor, MemoryKind, Pointer, AllocId, MPlaceTy, Scalar,\n };\n use crate::const_eval::{CompileTimeInterpreter, CompileTimeEvalContext};\n \n@@ -293,7 +291,7 @@ pub fn intern_const_alloc_recursive(\n         if let Err(error) = interned {\n             // This can happen when e.g. the tag of an enum is not a valid discriminant. We do have\n             // to read enum discriminants in order to find references in enum variant fields.\n-            if let InterpError::Unsupported(UnsupportedOpInfo::ValidationFailure(_)) = error.kind {\n+            if let err_unsup!(ValidationFailure(_)) = error.kind {\n                 let err = crate::const_eval::error_to_const_error(&ecx, error);\n                 match err.struct_error(ecx.tcx, \"it is undefined behavior to use this value\") {\n                     Ok(mut diag) => {"}, {"sha": "97866adcfa333ed75e35d8103aed46d6a6ac0d71", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/152f0d347e9b3b661adfcc0289412badfa45ab5a/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/152f0d347e9b3b661adfcc0289412badfa45ab5a/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=152f0d347e9b3b661adfcc0289412badfa45ab5a", "patch": "@@ -6,9 +6,7 @@ use syntax::symbol::Symbol;\n use rustc::ty;\n use rustc::ty::layout::{LayoutOf, Primitive, Size};\n use rustc::mir::BinOp;\n-use rustc::mir::interpret::{\n-    InterpResult, InterpError, Scalar, PanicInfo, UnsupportedOpInfo,\n-};\n+use rustc::mir::interpret::{InterpResult, Scalar};\n \n use super::{\n     Machine, PlaceTy, OpTy, InterpCx, Immediate,\n@@ -100,7 +98,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let bits = self.read_scalar(args[0])?.to_bits(layout_of.size)?;\n                 let kind = match layout_of.abi {\n                     ty::layout::Abi::Scalar(ref scalar) => scalar.value,\n-                    _ => Err(InterpError::Unsupported(UnsupportedOpInfo::TypeNotPrimitive(ty)))?,\n+                    _ => Err(err_unsup!(TypeNotPrimitive(ty)))?,\n                 };\n                 let out_val = if intrinsic_name.ends_with(\"_nonzero\") {\n                     if bits == 0 {\n@@ -250,7 +248,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             let file = Symbol::intern(self.read_str(file_place)?);\n             let line = self.read_scalar(line.into())?.to_u32()?;\n             let col = self.read_scalar(col.into())?.to_u32()?;\n-            return Err(InterpError::Panic(PanicInfo::Panic { msg, file, line, col }).into());\n+            throw_panic!(Panic { msg, file, line, col })\n         } else if Some(def_id) == self.tcx.lang_items().begin_panic_fn() {\n             assert!(args.len() == 2);\n             // &'static str, &(&'static str, u32, u32)\n@@ -268,7 +266,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             let file = Symbol::intern(self.read_str(file_place)?);\n             let line = self.read_scalar(line.into())?.to_u32()?;\n             let col = self.read_scalar(col.into())?.to_u32()?;\n-            return Err(InterpError::Panic(PanicInfo::Panic { msg, file, line, col }).into());\n+            throw_panic!(Panic { msg, file, line, col })\n         } else {\n             return Ok(false);\n         }"}, {"sha": "78902b101663416b4af8de19ec5629c4ab83af18", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/152f0d347e9b3b661adfcc0289412badfa45ab5a/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/152f0d347e9b3b661adfcc0289412badfa45ab5a/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=152f0d347e9b3b661adfcc0289412badfa45ab5a", "patch": "@@ -10,8 +10,8 @@ use rustc::mir;\n use rustc::ty::{self, TyCtxt};\n \n use super::{\n-    Allocation, AllocId, InterpResult, InterpError, Scalar, AllocationExtra,\n-    InterpCx, PlaceTy, OpTy, ImmTy, MemoryKind, Pointer, Memory, UnsupportedOpInfo,\n+    Allocation, AllocId, InterpResult, Scalar, AllocationExtra,\n+    InterpCx, PlaceTy, OpTy, ImmTy, MemoryKind, Pointer, Memory,\n };\n \n /// Whether this kind of memory is allowed to leak\n@@ -240,9 +240,9 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         int: u64,\n     ) -> InterpResult<'tcx, Pointer<Self::PointerTag>> {\n         Err((if int == 0 {\n-            InterpError::Unsupported(UnsupportedOpInfo::InvalidNullPointerUsage)\n+            err_unsup!(InvalidNullPointerUsage)\n         } else {\n-            InterpError::Unsupported(UnsupportedOpInfo::ReadBytesAsPointer)\n+            err_unsup!(ReadBytesAsPointer)\n         }).into())\n     }\n "}, {"sha": "85ed3b3efd68c3b4dc454e507b4b75ab6fa95556", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/152f0d347e9b3b661adfcc0289412badfa45ab5a/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/152f0d347e9b3b661adfcc0289412badfa45ab5a/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=152f0d347e9b3b661adfcc0289412badfa45ab5a", "patch": "@@ -18,8 +18,8 @@ use syntax::ast::Mutability;\n \n use super::{\n     Pointer, AllocId, Allocation, GlobalId, AllocationExtra,\n-    InterpResult, Scalar, InterpError, GlobalAlloc, PointerArithmetic,\n-    Machine, AllocMap, MayLeak, ErrorHandled, CheckInAllocMsg, InvalidProgramInfo,\n+    InterpResult, Scalar, GlobalAlloc, PointerArithmetic,\n+    Machine, AllocMap, MayLeak, ErrorHandled, CheckInAllocMsg,\n };\n \n #[derive(Debug, PartialEq, Eq, Copy, Clone, Hash)]\n@@ -250,18 +250,17 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             Some(alloc) => alloc,\n             None => {\n                 // Deallocating static memory -- always an error\n-                match self.tcx.alloc_map.lock().get(ptr.alloc_id) {\n-                    Some(GlobalAlloc::Function(..)) => throw_unsup!(DeallocatedWrongMemoryKind(\n+                return Err(match self.tcx.alloc_map.lock().get(ptr.alloc_id) {\n+                    Some(GlobalAlloc::Function(..)) => err_unsup!(DeallocatedWrongMemoryKind(\n                         \"function\".to_string(),\n                         format!(\"{:?}\", kind),\n                     )),\n-                    Some(GlobalAlloc::Static(..)) |\n-                    Some(GlobalAlloc::Memory(..)) => throw_unsup!(DeallocatedWrongMemoryKind(\n-                        \"static\".to_string(),\n-                        format!(\"{:?}\", kind),\n-                    )),\n-                    None => throw_unsup!(DoubleFree)\n+                    Some(GlobalAlloc::Static(..)) | Some(GlobalAlloc::Memory(..)) => err_unsup!(\n+                        DeallocatedWrongMemoryKind(\"static\".to_string(), format!(\"{:?}\", kind))\n+                    ),\n+                    None => err_unsup!(DoubleFree),\n                 }\n+                .into());\n             }\n         };\n \n@@ -437,11 +436,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                             assert!(tcx.is_static(def_id));\n                             match err {\n                                 ErrorHandled::Reported =>\n-                                    InterpError::InvalidProgram(\n-                                        InvalidProgramInfo::ReferencedConstant\n-                                    ),\n+                                    err_inval!(ReferencedConstant),\n                                 ErrorHandled::TooGeneric =>\n-                                    InterpError::InvalidProgram(InvalidProgramInfo::TooGeneric),\n+                                    err_inval!(TooGeneric),\n                             }\n                         })?;\n                     // Make sure we use the ID of the resolved memory, not the lazy one!"}, {"sha": "e64a474b4ca7171c2a907ffe59b6c5455ec964cd", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/152f0d347e9b3b661adfcc0289412badfa45ab5a/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/152f0d347e9b3b661adfcc0289412badfa45ab5a/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=152f0d347e9b3b661adfcc0289412badfa45ab5a", "patch": "@@ -11,8 +11,7 @@ use rustc::ty::layout::{\n use rustc::mir::interpret::{\n     GlobalId, AllocId,\n     ConstValue, Pointer, Scalar,\n-    InterpResult, InterpError,\n-    sign_extend, truncate, UnsupportedOpInfo,\n+    InterpResult, sign_extend, truncate,\n };\n use super::{\n     InterpCx, Machine,\n@@ -332,7 +331,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let len = mplace.len(self)?;\n         let bytes = self.memory.read_bytes(mplace.ptr, Size::from_bytes(len as u64))?;\n         let str = ::std::str::from_utf8(bytes).map_err(|err| {\n-            InterpError::Unsupported(UnsupportedOpInfo::ValidationFailure(err.to_string()))\n+            err_unsup!(ValidationFailure(err.to_string()))\n         })?;\n         Ok(str)\n     }\n@@ -604,7 +603,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let raw_discr = discr_val.to_scalar_or_undef();\n         trace!(\"discr value: {:?}\", raw_discr);\n         // post-process\n-        use rustc::mir::interpret::UnsupportedOpInfo::InvalidDiscriminant;\n         Ok(match *discr_kind {\n             layout::DiscriminantKind::Tag => {\n                 let bits_discr = match raw_discr.to_bits(discr_val.layout.size) {\n@@ -649,7 +647,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let variants_start = niche_variants.start().as_u32() as u128;\n                 let variants_end = niche_variants.end().as_u32() as u128;\n                 let raw_discr = raw_discr.not_undef().map_err(|_| {\n-                    InterpError::Unsupported(InvalidDiscriminant(ScalarMaybeUndef::Undef))\n+                    err_unsup!(InvalidDiscriminant(ScalarMaybeUndef::Undef))\n                 })?;\n                 match raw_discr.to_bits_or_ptr(discr_val.layout.size, self) {\n                     Err(ptr) => {"}, {"sha": "70a297c866280af83e6b16354bbcaffd3235740f", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/152f0d347e9b3b661adfcc0289412badfa45ab5a/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/152f0d347e9b3b661adfcc0289412badfa45ab5a/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=152f0d347e9b3b661adfcc0289412badfa45ab5a", "patch": "@@ -11,8 +11,7 @@ use rustc::ich::StableHashingContextProvider;\n use rustc::mir;\n use rustc::mir::interpret::{\n     AllocId, Pointer, Scalar,\n-    Relocations, Allocation, UndefMask,\n-    InterpResult, InterpError, ResourceExhaustionInfo,\n+    Relocations, Allocation, UndefMask, InterpResult,\n };\n \n use rustc::ty::{self, TyCtxt};\n@@ -77,7 +76,7 @@ impl<'mir, 'tcx> InfiniteLoopDetector<'mir, 'tcx> {\n         }\n \n         // Second cycle\n-        Err(InterpError::ResourceExhaustion(ResourceExhaustionInfo::InfiniteLoop).into())\n+        throw_exhaust!(InfiniteLoop)\n     }\n }\n "}, {"sha": "d4bc8f460e894d98fa17cc90c34768640358540c", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/152f0d347e9b3b661adfcc0289412badfa45ab5a/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/152f0d347e9b3b661adfcc0289412badfa45ab5a/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=152f0d347e9b3b661adfcc0289412badfa45ab5a", "patch": "@@ -136,31 +136,29 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 } else {\n                     // Compute error message\n                     use rustc::mir::interpret::PanicInfo::*;\n-                    match msg {\n+                    return Err(match msg {\n                         BoundsCheck { ref len, ref index } => {\n-                            let len = self.read_immediate(self.eval_operand(len, None)?)\n-                                .expect(\"can't eval len\").to_scalar()?\n+                            let len = self\n+                                .read_immediate(self.eval_operand(len, None)?)\n+                                .expect(\"can't eval len\")\n+                                .to_scalar()?\n                                 .to_bits(self.memory().pointer_size())? as u64;\n-                            let index = self.read_immediate(self.eval_operand(index, None)?)\n-                                .expect(\"can't eval index\").to_scalar()?\n+                            let index = self\n+                                .read_immediate(self.eval_operand(index, None)?)\n+                                .expect(\"can't eval index\")\n+                                .to_scalar()?\n                                 .to_bits(self.memory().pointer_size())? as u64;\n-                            throw_panic!(BoundsCheck { len, index })\n+                            err_panic!(BoundsCheck { len, index })\n                         }\n-                        Overflow(op) =>\n-                            throw_panic!(Overflow(*op)),\n-                        OverflowNeg =>\n-                            throw_panic!(OverflowNeg),\n-                        DivisionByZero =>\n-                            throw_panic!(DivisionByZero),\n-                        RemainderByZero =>\n-                            throw_panic!(RemainderByZero),\n-                        GeneratorResumedAfterReturn =>\n-                            throw_panic!(GeneratorResumedAfterReturn),\n-                        GeneratorResumedAfterPanic =>\n-                            throw_panic!(GeneratorResumedAfterPanic),\n-                        Panic { .. } =>\n-                            bug!(\"`Panic` variant cannot occur in MIR\"),\n-                    };\n+                        Overflow(op) => err_panic!(Overflow(*op)),\n+                        OverflowNeg => err_panic!(OverflowNeg),\n+                        DivisionByZero => err_panic!(DivisionByZero),\n+                        RemainderByZero => err_panic!(RemainderByZero),\n+                        GeneratorResumedAfterReturn => err_panic!(GeneratorResumedAfterReturn),\n+                        GeneratorResumedAfterPanic => err_panic!(GeneratorResumedAfterPanic),\n+                        Panic { .. } => bug!(\"`Panic` variant cannot occur in MIR\"),\n+                    }\n+                    .into());\n                 }\n             }\n "}, {"sha": "072c9afc50ae024745fa1c2535d0e009379b0e82", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/152f0d347e9b3b661adfcc0289412badfa45ab5a/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/152f0d347e9b3b661adfcc0289412badfa45ab5a/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=152f0d347e9b3b661adfcc0289412badfa45ab5a", "patch": "@@ -10,11 +10,11 @@ use rustc_data_structures::fx::FxHashSet;\n use std::hash::Hash;\n \n use super::{\n-    GlobalAlloc, InterpResult, InterpError,\n-    OpTy, Machine, InterpCx, ValueVisitor, MPlaceTy, UnsupportedOpInfo,\n+    GlobalAlloc, InterpResult,\n+    OpTy, Machine, InterpCx, ValueVisitor, MPlaceTy,\n };\n \n-macro_rules! validation_failure {\n+macro_rules! throw_validation_failure {\n     ($what:expr, $where:expr, $details:expr) => {{\n         let where_ = path_format(&$where);\n         let where_ = if where_.is_empty() {\n@@ -45,14 +45,14 @@ macro_rules! try_validation {\n     ($e:expr, $what:expr, $where:expr, $details:expr) => {{\n         match $e {\n             Ok(x) => x,\n-            Err(_) => validation_failure!($what, $where, $details),\n+            Err(_) => throw_validation_failure!($what, $where, $details),\n         }\n     }};\n \n     ($e:expr, $what:expr, $where:expr) => {{\n         match $e {\n             Ok(x) => x,\n-            Err(_) => validation_failure!($what, $where),\n+            Err(_) => throw_validation_failure!($what, $where),\n         }\n     }}\n }\n@@ -297,12 +297,12 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n         match self.walk_value(op) {\n             Ok(()) => Ok(()),\n             Err(err) => match err.kind {\n-                InterpError::Unsupported(UnsupportedOpInfo::InvalidDiscriminant(val)) =>\n-                    validation_failure!(\n+                err_unsup!(InvalidDiscriminant(val)) =>\n+                    throw_validation_failure!(\n                         val, self.path, \"a valid enum discriminant\"\n                     ),\n-                InterpError::Unsupported(UnsupportedOpInfo::ReadPointerAsBytes) =>\n-                    validation_failure!(\n+                err_unsup!(ReadPointerAsBytes) =>\n+                    throw_validation_failure!(\n                         \"a pointer\", self.path, \"plain (non-pointer) bytes\"\n                     ),\n                 _ => Err(err),\n@@ -405,21 +405,20 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                             \"{:?} did not pass access check for size {:?}, align {:?}\",\n                             ptr, size, align\n                         );\n-                        use super::UnsupportedOpInfo::*;\n                         match err.kind {\n-                            InterpError::Unsupported(InvalidNullPointerUsage) =>\n-                                validation_failure!(\"NULL reference\", self.path),\n-                            InterpError::Unsupported(AlignmentCheckFailed { required, has }) =>\n-                                validation_failure!(format!(\"unaligned reference \\\n+                            err_unsup!(InvalidNullPointerUsage) =>\n+                                throw_validation_failure!(\"NULL reference\", self.path),\n+                            err_unsup!(AlignmentCheckFailed { required, has }) =>\n+                                throw_validation_failure!(format!(\"unaligned reference \\\n                                     (required {} byte alignment but found {})\",\n                                     required.bytes(), has.bytes()), self.path),\n-                            InterpError::Unsupported(ReadBytesAsPointer) =>\n-                                validation_failure!(\n+                            err_unsup!(ReadBytesAsPointer) =>\n+                                throw_validation_failure!(\n                                     \"dangling reference (created from integer)\",\n                                     self.path\n                                 ),\n                             _ =>\n-                                validation_failure!(\n+                                throw_validation_failure!(\n                                     \"dangling reference (not entirely in bounds)\",\n                                     self.path\n                                 ),\n@@ -479,7 +478,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n \n     fn visit_uninhabited(&mut self) -> InterpResult<'tcx>\n     {\n-        validation_failure!(\"a value of an uninhabited type\", self.path)\n+        throw_validation_failure!(\"a value of an uninhabited type\", self.path)\n     }\n \n     fn visit_scalar(\n@@ -512,7 +511,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 if lo == 1 && hi == max_hi {\n                     // Only NULL is the niche.  So make sure the ptr is NOT NULL.\n                     if self.ecx.memory.ptr_may_be_null(ptr) {\n-                        validation_failure!(\n+                        throw_validation_failure!(\n                             \"a potentially NULL pointer\",\n                             self.path,\n                             format!(\n@@ -525,7 +524,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 } else {\n                     // Conservatively, we reject, because the pointer *could* have a bad\n                     // value.\n-                    validation_failure!(\n+                    throw_validation_failure!(\n                         \"a pointer\",\n                         self.path,\n                         format!(\n@@ -542,7 +541,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n         if wrapping_range_contains(&layout.valid_range, bits) {\n             Ok(())\n         } else {\n-            validation_failure!(\n+            throw_validation_failure!(\n                 bits,\n                 self.path,\n                 format!(\"something {}\", wrapping_range_format(&layout.valid_range, max_hi))\n@@ -609,14 +608,14 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                     Err(err) => {\n                         // For some errors we might be able to provide extra information\n                         match err.kind {\n-                            InterpError::Unsupported(UnsupportedOpInfo::ReadUndefBytes(offset)) => {\n+                            err_unsup!(ReadUndefBytes(offset)) => {\n                                 // Some byte was undefined, determine which\n                                 // element that byte belongs to so we can\n                                 // provide an index.\n                                 let i = (offset.bytes() / ty_size.bytes()) as usize;\n                                 self.path.push(PathElem::ArrayElem(i));\n \n-                                validation_failure!(\"undefined bytes\", self.path)\n+                                throw_validation_failure!(\"undefined bytes\", self.path)\n                             },\n                             // Other errors shouldn't be possible\n                             _ => return Err(err),"}, {"sha": "164a268004d2d0a4bc558cff759280d33c0e1859", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/152f0d347e9b3b661adfcc0289412badfa45ab5a/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/152f0d347e9b3b661adfcc0289412badfa45ab5a/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=152f0d347e9b3b661adfcc0289412badfa45ab5a", "patch": "@@ -13,7 +13,7 @@ use rustc::mir::{\n use rustc::mir::visit::{\n     Visitor, PlaceContext, MutatingUseContext, MutVisitor, NonMutatingUseContext,\n };\n-use rustc::mir::interpret::{Scalar, GlobalId, InterpResult, InterpError, PanicInfo};\n+use rustc::mir::interpret::{Scalar, GlobalId, InterpResult, PanicInfo};\n use rustc::ty::{self, Instance, ParamEnv, Ty, TyCtxt};\n use syntax_pos::{Span, DUMMY_SP};\n use rustc::ty::subst::InternalSubsts;\n@@ -519,7 +519,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                     )\n                 } else {\n                     if overflow {\n-                        let err = InterpError::Panic(PanicInfo::Overflow(op)).into();\n+                        let err = err_panic!(Overflow(op)).into();\n                         let _: Option<()> = self.use_ecx(source_info, |_| Err(err));\n                         return None;\n                     }"}]}