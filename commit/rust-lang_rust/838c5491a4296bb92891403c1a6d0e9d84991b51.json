{"sha": "838c5491a4296bb92891403c1a6d0e9d84991b51", "node_id": "C_kwDOAAsO6NoAKDgzOGM1NDkxYTQyOTZiYjkyODkxNDAzYzFhNmQwZTlkODQ5OTFiNTE", "commit": {"author": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2023-04-12T16:21:28Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2023-04-12T16:22:20Z"}, "message": "Document tagged pointers better", "tree": {"sha": "72fb404a9e58fd7dc63b212d7a4d655837542b43", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/72fb404a9e58fd7dc63b212d7a4d655837542b43"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/838c5491a4296bb92891403c1a6d0e9d84991b51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/838c5491a4296bb92891403c1a6d0e9d84991b51", "html_url": "https://github.com/rust-lang/rust/commit/838c5491a4296bb92891403c1a6d0e9d84991b51", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/838c5491a4296bb92891403c1a6d0e9d84991b51/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f9b15c40c909e80acc27aca3118654cb506241e", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f9b15c40c909e80acc27aca3118654cb506241e", "html_url": "https://github.com/rust-lang/rust/commit/6f9b15c40c909e80acc27aca3118654cb506241e"}], "stats": {"total": 161, "additions": 130, "deletions": 31}, "files": [{"sha": "f10c12ceeda8e6e4fec340043dceb755be345795", "filename": "compiler/rustc_data_structures/src/tagged_ptr.rs", "status": "modified", "additions": 59, "deletions": 14, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/838c5491a4296bb92891403c1a6d0e9d84991b51/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/838c5491a4296bb92891403c1a6d0e9d84991b51/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr.rs?ref=838c5491a4296bb92891403c1a6d0e9d84991b51", "patch": "@@ -3,15 +3,17 @@\n //! In order to utilize the pointer packing, you must have two types: a pointer,\n //! and a tag.\n //!\n-//! The pointer must implement the `Pointer` trait, with the primary requirement\n-//! being conversion to and from a usize. Note that the pointer must be\n-//! dereferenceable, so raw pointers generally cannot implement the `Pointer`\n-//! trait. This implies that the pointer must also be nonzero.\n+//! The pointer must implement the [`Pointer`] trait, with the primary\n+//! requirement being convertible to and from a raw pointer. Note that the\n+//! pointer must be dereferenceable, so raw pointers generally cannot implement\n+//! the [`Pointer`] trait. This implies that the pointer must also be non-null.\n //!\n-//! Many common pointer types already implement the `Pointer` trait.\n+//! Many common pointer types already implement the [`Pointer`] trait.\n //!\n-//! The tag must implement the `Tag` trait. We assert that the tag and `Pointer`\n-//! are compatible at compile time.\n+//! The tag must implement the [`Tag`] trait.\n+//!\n+//! We assert that the tag and the [`Pointer`] types are compatible at compile\n+//! time.\n \n use std::ops::Deref;\n use std::ptr::NonNull;\n@@ -71,32 +73,66 @@ pub unsafe trait Pointer: Deref {\n     /// [`Self::Target`]: Deref::Target\n     const BITS: usize;\n \n+    /// Turns this pointer into a raw, non-null pointer.\n+    ///\n+    /// The inverse of this function is [`from_ptr`].\n+    ///\n+    /// This function guarantees that the least-significant [`Self::BITS`] bits\n+    /// are zero.\n+    ///\n+    /// [`from_ptr`]: Pointer::from_ptr\n+    /// [`Self::BITS`]: Pointer::BITS\n     fn into_ptr(self) -> NonNull<Self::Target>;\n \n+    /// Re-creates the original pointer, from a raw pointer returned by [`into_ptr`].\n+    ///\n     /// # Safety\n     ///\n-    /// The passed `ptr` must be returned from `into_usize`.\n+    /// The passed `ptr` must be returned from [`into_ptr`].\n+    ///\n+    /// This acts as [`ptr::read::<Self>()`] semantically, it should not be called more than\n+    /// once on non-[`Copy`] `Pointer`s.\n     ///\n-    /// This acts as `ptr::read` semantically, it should not be called more than\n-    /// once on non-`Copy` `Pointer`s.\n+    /// [`into_ptr`]: Pointer::into_ptr\n+    /// [`ptr::read::<Self>()`]: std::ptr::read\n     unsafe fn from_ptr(ptr: NonNull<Self::Target>) -> Self;\n }\n \n-/// This describes tags that the `TaggedPtr` struct can hold.\n+/// This describes tags that the [`TaggedPtr`] struct can hold.\n ///\n /// # Safety\n ///\n-/// The BITS constant must be correct.\n+/// The [`BITS`] constant must be correct.\n+///\n+/// No more than [`BITS`] least significant bits may be set in the returned usize.\n ///\n-/// No more than `BITS` least significant bits may be set in the returned usize.\n+/// [`BITS`]: Tag::BITS\n pub unsafe trait Tag: Copy {\n+    /// Number of least-significant bits in the return value of [`into_usize`]\n+    /// which may be non-zero. In other words this is the bit width of the\n+    /// value.\n+    ///\n+    /// [`into_usize`]: Tag::into_usize\n     const BITS: usize;\n \n+    /// Turns this tag into an integer.\n+    ///\n+    /// The inverse of this function is [`from_usize`].\n+    ///\n+    /// This function guarantees that only the least-significant [`Self::BITS`]\n+    /// bits can be non-zero.\n+    ///\n+    /// [`from_usize`]: Pointer::from_usize\n+    /// [`Self::BITS`]: Tag::BITS\n     fn into_usize(self) -> usize;\n \n+    /// Re-creates the tag from the integer returned by [`into_usize`].\n+    ///\n     /// # Safety\n     ///\n-    /// The passed `tag` must be returned from `into_usize`.\n+    /// The passed `tag` must be returned from [`into_usize`].\n+    ///\n+    /// [`into_usize`]: Tag::into_usize\n     unsafe fn from_usize(tag: usize) -> Self;\n }\n \n@@ -111,6 +147,7 @@ unsafe impl<T: ?Sized + Aligned> Pointer for Box<T> {\n \n     #[inline]\n     unsafe fn from_ptr(ptr: NonNull<T>) -> Self {\n+        // Safety: `ptr` comes from `into_ptr` which calls `Box::into_raw`\n         Box::from_raw(ptr.as_ptr())\n     }\n }\n@@ -120,11 +157,13 @@ unsafe impl<T: ?Sized + Aligned> Pointer for Rc<T> {\n \n     #[inline]\n     fn into_ptr(self) -> NonNull<T> {\n+        // Safety: pointers from `Rc::into_raw` are valid & non-null\n         unsafe { NonNull::new_unchecked(Rc::into_raw(self).cast_mut()) }\n     }\n \n     #[inline]\n     unsafe fn from_ptr(ptr: NonNull<T>) -> Self {\n+        // Safety: `ptr` comes from `into_ptr` which calls `Rc::into_raw`\n         Rc::from_raw(ptr.as_ptr())\n     }\n }\n@@ -134,11 +173,13 @@ unsafe impl<T: ?Sized + Aligned> Pointer for Arc<T> {\n \n     #[inline]\n     fn into_ptr(self) -> NonNull<T> {\n+        // Safety: pointers from `Arc::into_raw` are valid & non-null\n         unsafe { NonNull::new_unchecked(Arc::into_raw(self).cast_mut()) }\n     }\n \n     #[inline]\n     unsafe fn from_ptr(ptr: NonNull<T>) -> Self {\n+        // Safety: `ptr` comes from `into_ptr` which calls `Arc::into_raw`\n         Arc::from_raw(ptr.as_ptr())\n     }\n }\n@@ -153,6 +194,8 @@ unsafe impl<'a, T: 'a + ?Sized + Aligned> Pointer for &'a T {\n \n     #[inline]\n     unsafe fn from_ptr(ptr: NonNull<T>) -> Self {\n+        // Safety:\n+        // `ptr` comes from `into_ptr` which gets the pointer from a reference\n         ptr.as_ref()\n     }\n }\n@@ -167,6 +210,8 @@ unsafe impl<'a, T: 'a + ?Sized + Aligned> Pointer for &'a mut T {\n \n     #[inline]\n     unsafe fn from_ptr(mut ptr: NonNull<T>) -> Self {\n+        // Safety:\n+        // `ptr` comes from `into_ptr` which gets the pointer from a reference\n         ptr.as_mut()\n     }\n }"}, {"sha": "02dcbd389dfdd1e01c34cbbb2a31264d974173a1", "filename": "compiler/rustc_data_structures/src/tagged_ptr/copy.rs", "status": "modified", "additions": 60, "deletions": 11, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/838c5491a4296bb92891403c1a6d0e9d84991b51/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fcopy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/838c5491a4296bb92891403c1a6d0e9d84991b51/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fcopy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fcopy.rs?ref=838c5491a4296bb92891403c1a6d0e9d84991b51", "patch": "@@ -8,35 +8,75 @@ use std::num::NonZeroUsize;\n use std::ops::{Deref, DerefMut};\n use std::ptr::NonNull;\n \n-/// A `Copy` TaggedPtr.\n+/// A [`Copy`] tagged pointer.\n ///\n-/// You should use this instead of the `TaggedPtr` type in all cases where\n-/// `P: Copy`.\n+/// This is essentially `{ pointer: P, tag: T }` packed in a single pointer.\n+///\n+/// You should use this instead of the [`TaggedPtr`] type in all cases where\n+/// `P` implements [`Copy`].\n ///\n /// If `COMPARE_PACKED` is true, then the pointers will be compared and hashed without\n-/// unpacking. Otherwise we don't implement PartialEq/Eq/Hash; if you want that,\n-/// wrap the TaggedPtr.\n+/// unpacking. Otherwise we don't implement [`PartialEq`], [`Eq`] and [`Hash`];\n+/// if you want that, wrap the [`CopyTaggedPtr`].\n+///\n+/// [`TaggedPtr`]: crate::tagged_ptr::TaggedPtr\n pub struct CopyTaggedPtr<P, T, const COMPARE_PACKED: bool>\n where\n     P: Pointer,\n     T: Tag,\n {\n+    /// This is semantically a pair of `pointer: P` and `tag: T` fields,\n+    /// however we pack them in a single pointer, to save space.\n+    ///\n+    /// We pack the tag into the **most**-significant bits of the pointer to\n+    /// ease retrieval of the value. A left shift is a multiplication and\n+    /// those are embeddable in instruction encoding, for example:\n+    ///\n+    /// ```asm\n+    /// // (https://godbolt.org/z/jqcYPWEr3)\n+    /// example::shift_read3:\n+    ///     mov     eax, dword ptr [8*rdi]\n+    ///     ret\n+    ///\n+    /// example::mask_read3:\n+    ///     and     rdi, -8\n+    ///     mov     eax, dword ptr [rdi]\n+    ///     ret\n+    /// ```\n+    ///\n+    /// This is ASM outputted by rustc for reads of values behind tagged\n+    /// pointers for different approaches of tagging:\n+    /// - `shift_read3` uses `<< 3` (the tag is in the most-significant bits)\n+    /// - `mask_read3` uses `& !0b111` (the tag is in the least-significant bits)\n+    ///\n+    /// The shift approach thus produces less instructions and is likely faster.\n+    ///\n+    /// Encoding diagram:\n+    /// ```text\n+    /// [ packed.addr                     ]\n+    /// [ tag ] [ pointer.addr >> T::BITS ] <-- usize::BITS - T::BITS bits\n+    ///    ^\n+    ///    |\n+    /// T::BITS bits\n+    /// ```\n+    ///\n+    /// The tag can be retrieved by `packed.addr() >> T::BITS` and the pointer\n+    /// can be retrieved by `packed.map_addr(|addr| addr << T::BITS)`.\n     packed: NonNull<P::Target>,\n     tag_ghost: PhantomData<T>,\n }\n \n-// We pack the tag into the *upper* bits of the pointer to ease retrieval of the\n-// value; a left shift is a multiplication and those are embeddable in\n-// instruction encoding.\n impl<P, T, const CP: bool> CopyTaggedPtr<P, T, CP>\n where\n     P: Pointer,\n     T: Tag,\n {\n+    /// Tags `pointer` with `tag`.\n     pub fn new(pointer: P, tag: T) -> Self {\n         Self { packed: Self::pack(P::into_ptr(pointer), tag), tag_ghost: PhantomData }\n     }\n \n+    /// Retrieves the pointer.\n     pub fn pointer(self) -> P\n     where\n         P: Copy,\n@@ -48,11 +88,18 @@ where\n         unsafe { P::from_ptr(self.pointer_raw()) }\n     }\n \n+    /// Retrieves the tag.\n     #[inline]\n     pub fn tag(&self) -> T {\n-        unsafe { T::from_usize(self.packed.addr().get() >> Self::TAG_BIT_SHIFT) }\n+        // Unpack the tag, according to the `self.packed` encoding scheme\n+        let tag = self.packed.addr().get() >> Self::TAG_BIT_SHIFT;\n+\n+        // Safety:\n+        //\n+        unsafe { T::from_usize(tag) }\n     }\n \n+    /// Sets the tag to a new value.\n     #[inline]\n     pub fn set_tag(&mut self, tag: T) {\n         self.packed = Self::pack(self.pointer_raw(), tag);\n@@ -61,7 +108,8 @@ where\n     const TAG_BIT_SHIFT: usize = usize::BITS as usize - T::BITS;\n     const ASSERTION: () = { assert!(T::BITS <= P::BITS) };\n \n-    /// Pack pointer `ptr` that comes from [`P::into_ptr`] with a `tag`.\n+    /// Pack pointer `ptr` that comes from [`P::into_ptr`] with a `tag`,\n+    /// according to `self.packed` encoding scheme.\n     ///\n     /// [`P::into_ptr`]: Pointer::into_ptr\n     fn pack(ptr: NonNull<P::Target>, tag: T) -> NonNull<P::Target> {\n@@ -71,7 +119,7 @@ where\n         let packed_tag = tag.into_usize() << Self::TAG_BIT_SHIFT;\n \n         ptr.map_addr(|addr| {\n-            // SAFETY:\n+            // Safety:\n             // - The pointer is `NonNull` => it's address is `NonZeroUsize`\n             // - `P::BITS` least significant bits are always zero (`Pointer` contract)\n             // - `T::BITS <= P::BITS` (from `Self::ASSERTION`)\n@@ -85,6 +133,7 @@ where\n         })\n     }\n \n+    /// Retrieves the original raw pointer from `self.packed`.\n     pub(super) fn pointer_raw(&self) -> NonNull<P::Target> {\n         self.packed.map_addr(|addr| unsafe { NonZeroUsize::new_unchecked(addr.get() << T::BITS) })\n     }"}, {"sha": "6ca6c7d1283b44e238bae9665ef81dca9df1e1b2", "filename": "compiler/rustc_data_structures/src/tagged_ptr/drop.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/838c5491a4296bb92891403c1a6d0e9d84991b51/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/838c5491a4296bb92891403c1a6d0e9d84991b51/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fdrop.rs?ref=838c5491a4296bb92891403c1a6d0e9d84991b51", "patch": "@@ -6,11 +6,16 @@ use super::CopyTaggedPtr;\n use super::{Pointer, Tag};\n use crate::stable_hasher::{HashStable, StableHasher};\n \n-/// A TaggedPtr implementing `Drop`.\n+/// A tagged pointer that supports pointers that implement [`Drop`].\n+///\n+/// This is essentially `{ pointer: P, tag: T }` packed in a single pointer.\n+///\n+/// You should use [`CopyTaggedPtr`] instead of the this type in all cases\n+/// where `P` implements [`Copy`].\n ///\n /// If `COMPARE_PACKED` is true, then the pointers will be compared and hashed without\n-/// unpacking. Otherwise we don't implement PartialEq/Eq/Hash; if you want that,\n-/// wrap the TaggedPtr.\n+/// unpacking. Otherwise we don't implement [`PartialEq`], [`Eq`] and [`Hash`];\n+/// if you want that, wrap the [`TaggedPtr`].\n pub struct TaggedPtr<P, T, const COMPARE_PACKED: bool>\n where\n     P: Pointer,\n@@ -19,22 +24,22 @@ where\n     raw: CopyTaggedPtr<P, T, COMPARE_PACKED>,\n }\n \n-// We pack the tag into the *upper* bits of the pointer to ease retrieval of the\n-// value; a right shift is a multiplication and those are embeddable in\n-// instruction encoding.\n impl<P, T, const CP: bool> TaggedPtr<P, T, CP>\n where\n     P: Pointer,\n     T: Tag,\n {\n+    /// Tags `pointer` with `tag`.\n     pub fn new(pointer: P, tag: T) -> Self {\n         TaggedPtr { raw: CopyTaggedPtr::new(pointer, tag) }\n     }\n \n+    /// Retrieves the tag.\n     pub fn tag(&self) -> T {\n         self.raw.tag()\n     }\n \n+    /// Sets the tag to a new value.\n     pub fn set_tag(&mut self, tag: T) {\n         self.raw.set_tag(tag)\n     }"}]}