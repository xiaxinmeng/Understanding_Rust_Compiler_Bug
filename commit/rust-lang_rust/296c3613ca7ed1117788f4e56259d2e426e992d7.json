{"sha": "296c3613ca7ed1117788f4e56259d2e426e992d7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5NmMzNjEzY2E3ZWQxMTE3Nzg4ZjRlNTYyNTlkMmU0MjZlOTkyZDc=", "commit": {"author": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2015-11-24T13:56:20Z"}, "committer": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2015-11-26T20:47:44Z"}, "message": "Added stmt_expr_attribute feature gate", "tree": {"sha": "25125bcebe6195c2b1ae6509ef4586bf77fddcd9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/25125bcebe6195c2b1ae6509ef4586bf77fddcd9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/296c3613ca7ed1117788f4e56259d2e426e992d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/296c3613ca7ed1117788f4e56259d2e426e992d7", "html_url": "https://github.com/rust-lang/rust/commit/296c3613ca7ed1117788f4e56259d2e426e992d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/296c3613ca7ed1117788f4e56259d2e426e992d7/comments", "author": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c56b47ab8cd2906e30960f05d51855f9f7f5255b", "url": "https://api.github.com/repos/rust-lang/rust/commits/c56b47ab8cd2906e30960f05d51855f9f7f5255b", "html_url": "https://github.com/rust-lang/rust/commit/c56b47ab8cd2906e30960f05d51855f9f7f5255b"}], "stats": {"total": 532, "additions": 469, "deletions": 63}, "files": [{"sha": "98074f09441c4b0e3a220f14dcdeeca803f21be4", "filename": "src/doc/reference.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/296c3613ca7ed1117788f4e56259d2e426e992d7/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/296c3613ca7ed1117788f4e56259d2e426e992d7/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=296c3613ca7ed1117788f4e56259d2e426e992d7", "patch": "@@ -2368,6 +2368,9 @@ The currently implemented features of the reference compiler are:\n                                         influence type inference.\n * - `braced_empty_structs` - Allows use of empty structs and enum variants with braces.\n \n+* - `stmt_expr_attributes` - Allows attributes on expressions and\n+                             non-item statements.\n+\n If a feature is promoted to a language feature, then all existing programs will\n start to receive compilation warnings about `#![feature]` directives which enabled\n the new feature (because the directive is no longer necessary). However, if a"}, {"sha": "c2b2d00689fbe40ad7bfa012606e7a4138c42cd4", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/296c3613ca7ed1117788f4e56259d2e426e992d7/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/296c3613ca7ed1117788f4e56259d2e426e992d7/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=296c3613ca7ed1117788f4e56259d2e426e992d7", "patch": "@@ -20,8 +20,9 @@ use ast::{Stmt, StmtDecl, StmtExpr, StmtMac, StmtSemi, DeclItem, DeclLocal};\n use ast::{Expr, Item, Local, Decl};\n use codemap::{Span, Spanned, spanned, dummy_spanned};\n use codemap::BytePos;\n+use config::CfgDiag;\n use diagnostic::SpanHandler;\n-use feature_gate::GatedCfg;\n+use feature_gate::{GatedCfg, GatedCfgAttr};\n use parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n use parse::token::{InternedString, intern_and_get_ident};\n use parse::token;\n@@ -358,26 +359,35 @@ pub fn requests_inline(attrs: &[Attribute]) -> bool {\n }\n \n /// Tests if a cfg-pattern matches the cfg set\n-pub fn cfg_matches(diagnostic: &SpanHandler, cfgs: &[P<MetaItem>], cfg: &ast::MetaItem,\n-                   feature_gated_cfgs: &mut Vec<GatedCfg>) -> bool {\n+pub fn cfg_matches<T: CfgDiag>(cfgs: &[P<MetaItem>],\n+                           cfg: &ast::MetaItem,\n+                           diag: &mut T) -> bool {\n     match cfg.node {\n         ast::MetaList(ref pred, ref mis) if &pred[..] == \"any\" =>\n-            mis.iter().any(|mi| cfg_matches(diagnostic, cfgs, &**mi, feature_gated_cfgs)),\n+            mis.iter().any(|mi| cfg_matches(cfgs, &**mi, diag)),\n         ast::MetaList(ref pred, ref mis) if &pred[..] == \"all\" =>\n-            mis.iter().all(|mi| cfg_matches(diagnostic, cfgs, &**mi, feature_gated_cfgs)),\n+            mis.iter().all(|mi| cfg_matches(cfgs, &**mi, diag)),\n         ast::MetaList(ref pred, ref mis) if &pred[..] == \"not\" => {\n             if mis.len() != 1 {\n-                diagnostic.span_err(cfg.span, \"expected 1 cfg-pattern\");\n+                diag.emit_error(|diagnostic| {\n+                    diagnostic.span_err(cfg.span, \"expected 1 cfg-pattern\");\n+                });\n                 return false;\n             }\n-            !cfg_matches(diagnostic, cfgs, &*mis[0], feature_gated_cfgs)\n+            !cfg_matches(cfgs, &*mis[0], diag)\n         }\n         ast::MetaList(ref pred, _) => {\n-            diagnostic.span_err(cfg.span, &format!(\"invalid predicate `{}`\", pred));\n+            diag.emit_error(|diagnostic| {\n+                diagnostic.span_err(cfg.span,\n+                    &format!(\"invalid predicate `{}`\", pred));\n+            });\n             false\n         },\n         ast::MetaWord(_) | ast::MetaNameValue(..) => {\n-            feature_gated_cfgs.extend(GatedCfg::gate(cfg));\n+            diag.flag_gated(|feature_gated_cfgs| {\n+                feature_gated_cfgs.extend(\n+                    GatedCfg::gate(cfg).map(GatedCfgAttr::GatedCfg));\n+            });\n             contains(cfgs, cfg)\n         }\n     }"}, {"sha": "1209c58fd5ed1abf01a440b7e2fa4d56e239f829", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 210, "deletions": 39, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/296c3613ca7ed1117788f4e56259d2e426e992d7/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/296c3613ca7ed1117788f4e56259d2e426e992d7/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=296c3613ca7ed1117788f4e56259d2e426e992d7", "patch": "@@ -10,9 +10,10 @@\n \n use attr::AttrMetaMethods;\n use diagnostic::SpanHandler;\n-use feature_gate::GatedCfg;\n+use feature_gate::GatedCfgAttr;\n use fold::Folder;\n use {ast, fold, attr};\n+use visit;\n use codemap::{Spanned, respan};\n use ptr::P;\n \n@@ -28,20 +29,26 @@ struct Context<'a, F> where F: FnMut(&[ast::Attribute]) -> bool {\n // Support conditional compilation by transforming the AST, stripping out\n // any items that do not belong in the current configuration\n pub fn strip_unconfigured_items(diagnostic: &SpanHandler, krate: ast::Crate,\n-                                feature_gated_cfgs: &mut Vec<GatedCfg>)\n+                                feature_gated_cfgs: &mut Vec<GatedCfgAttr>)\n                                 -> ast::Crate\n {\n+    // Need to do this check here because cfg runs before feature_gates\n+    check_for_gated_stmt_expr_attributes(&krate, feature_gated_cfgs);\n+\n     let krate = process_cfg_attr(diagnostic, krate, feature_gated_cfgs);\n     let config = krate.config.clone();\n     strip_items(diagnostic,\n                 krate,\n-                |attrs| in_cfg(diagnostic, &config, attrs, feature_gated_cfgs))\n+                |attrs| {\n+                    let mut diag = CfgDiagReal {\n+                        diag: diagnostic,\n+                        feature_gated_cfgs: feature_gated_cfgs,\n+                    };\n+                    in_cfg(&config, attrs, &mut diag)\n+                })\n }\n \n impl<'a, F> fold::Folder for Context<'a, F> where F: FnMut(&[ast::Attribute]) -> bool {\n-    fn fold_mod(&mut self, module: ast::Mod) -> ast::Mod {\n-        fold_mod(self, module)\n-    }\n     fn fold_foreign_mod(&mut self, foreign_mod: ast::ForeignMod) -> ast::ForeignMod {\n         fold_foreign_mod(self, foreign_mod)\n     }\n@@ -87,19 +94,6 @@ pub fn strip_items<'a, F>(diagnostic: &'a SpanHandler,\n     ctxt.fold_crate(krate)\n }\n \n-fn fold_mod<F>(cx: &mut Context<F>,\n-               ast::Mod {inner, items}: ast::Mod)\n-               -> ast::Mod where\n-    F: FnMut(&[ast::Attribute]) -> bool\n-{\n-    ast::Mod {\n-        inner: inner,\n-        items: items.into_iter().flat_map(|a| {\n-            cx.fold_item(a).into_iter()\n-        }).collect()\n-    }\n-}\n-\n fn filter_foreign_item<F>(cx: &mut Context<F>,\n                           item: P<ast::ForeignItem>)\n                           -> Option<P<ast::ForeignItem>> where\n@@ -271,44 +265,45 @@ fn is_cfg(attr: &ast::Attribute) -> bool {\n \n // Determine if an item should be translated in the current crate\n // configuration based on the item's attributes\n-fn in_cfg(diagnostic: &SpanHandler,\n-          cfg: &[P<ast::MetaItem>],\n-          attrs: &[ast::Attribute],\n-          feature_gated_cfgs: &mut Vec<GatedCfg>) -> bool {\n+fn in_cfg<T: CfgDiag>(cfg: &[P<ast::MetaItem>],\n+                      attrs: &[ast::Attribute],\n+                      diag: &mut T) -> bool {\n     attrs.iter().all(|attr| {\n         let mis = match attr.node.value.node {\n             ast::MetaList(_, ref mis) if is_cfg(&attr) => mis,\n             _ => return true\n         };\n \n         if mis.len() != 1 {\n-            diagnostic.span_err(attr.span, \"expected 1 cfg-pattern\");\n+            diag.emit_error(|diagnostic| {\n+                diagnostic.span_err(attr.span, \"expected 1 cfg-pattern\");\n+            });\n             return true;\n         }\n \n-        attr::cfg_matches(diagnostic, cfg, &mis[0],\n-                          feature_gated_cfgs)\n+        attr::cfg_matches(cfg, &mis[0], diag)\n     })\n }\n \n-struct CfgAttrFolder<'a, 'b> {\n-    diag: &'a SpanHandler,\n-    config: ast::CrateConfig,\n-    feature_gated_cfgs: &'b mut Vec<GatedCfg>\n+struct CfgAttrFolder<'a, T> {\n+    diag: T,\n+    config: &'a ast::CrateConfig,\n }\n \n // Process `#[cfg_attr]`.\n fn process_cfg_attr(diagnostic: &SpanHandler, krate: ast::Crate,\n-                    feature_gated_cfgs: &mut Vec<GatedCfg>) -> ast::Crate {\n+                    feature_gated_cfgs: &mut Vec<GatedCfgAttr>) -> ast::Crate {\n     let mut fld = CfgAttrFolder {\n-        diag: diagnostic,\n-        config: krate.config.clone(),\n-        feature_gated_cfgs: feature_gated_cfgs,\n+        diag: CfgDiagReal {\n+            diag: diagnostic,\n+            feature_gated_cfgs: feature_gated_cfgs,\n+        },\n+        config: &krate.config.clone(),\n     };\n     fld.fold_crate(krate)\n }\n \n-impl<'a,'b> fold::Folder for CfgAttrFolder<'a,'b> {\n+impl<'a, T: CfgDiag> fold::Folder for CfgAttrFolder<'a, T> {\n     fn fold_attribute(&mut self, attr: ast::Attribute) -> Option<ast::Attribute> {\n         if !attr.check_name(\"cfg_attr\") {\n             return fold::noop_fold_attribute(attr, self);\n@@ -317,20 +312,25 @@ impl<'a,'b> fold::Folder for CfgAttrFolder<'a,'b> {\n         let attr_list = match attr.meta_item_list() {\n             Some(attr_list) => attr_list,\n             None => {\n-                self.diag.span_err(attr.span, \"expected `#[cfg_attr(<cfg pattern>, <attr>)]`\");\n+                self.diag.emit_error(|diag| {\n+                    diag.span_err(attr.span,\n+                        \"expected `#[cfg_attr(<cfg pattern>, <attr>)]`\");\n+                });\n                 return None;\n             }\n         };\n         let (cfg, mi) = match (attr_list.len(), attr_list.get(0), attr_list.get(1)) {\n             (2, Some(cfg), Some(mi)) => (cfg, mi),\n             _ => {\n-                self.diag.span_err(attr.span, \"expected `#[cfg_attr(<cfg pattern>, <attr>)]`\");\n+                self.diag.emit_error(|diag| {\n+                    diag.span_err(attr.span,\n+                        \"expected `#[cfg_attr(<cfg pattern>, <attr>)]`\");\n+                });\n                 return None;\n             }\n         };\n \n-        if attr::cfg_matches(self.diag, &self.config[..], &cfg,\n-                             self.feature_gated_cfgs) {\n+        if attr::cfg_matches(&self.config[..], &cfg, &mut self.diag) {\n             Some(respan(mi.span, ast::Attribute_ {\n                 id: attr::mk_attr_id(),\n                 style: attr.node.style,\n@@ -347,3 +347,174 @@ impl<'a,'b> fold::Folder for CfgAttrFolder<'a,'b> {\n         fold::noop_fold_mac(mac, self)\n     }\n }\n+\n+fn check_for_gated_stmt_expr_attributes(krate: &ast::Crate,\n+                                        discovered: &mut Vec<GatedCfgAttr>) {\n+    let mut v = StmtExprAttrFeatureVisitor {\n+        config: &krate.config,\n+        discovered: discovered,\n+    };\n+    visit::walk_crate(&mut v, krate);\n+}\n+\n+/// To cover this feature, we need to discover all attributes\n+/// so we need to run before cfg.\n+struct StmtExprAttrFeatureVisitor<'a, 'b> {\n+    config: &'a ast::CrateConfig,\n+    discovered: &'b mut Vec<GatedCfgAttr>,\n+}\n+\n+// Runs the cfg_attr and cfg folders locally in \"silent\" mode\n+// to discover attribute use on stmts or expressions ahead of time\n+impl<'v, 'a, 'b> visit::Visitor<'v> for StmtExprAttrFeatureVisitor<'a, 'b> {\n+    fn visit_stmt(&mut self, s: &'v ast::Stmt) {\n+        // check if there even are any attributes on this node\n+        let stmt_attrs = s.node.attrs();\n+        if stmt_attrs.len() > 0 {\n+            // attributes on items are fine\n+            if let ast::StmtDecl(ref decl, _) = s.node {\n+                if let ast::DeclItem(_) = decl.node {\n+                    visit::walk_stmt(self, s);\n+                    return;\n+                }\n+            }\n+\n+            // flag the offending attributes\n+            for attr in stmt_attrs {\n+                self.discovered.push(GatedCfgAttr::GatedAttr(attr.span));\n+            }\n+\n+            // if the node does not end up being cfg-d away, walk down\n+            if node_survives_cfg(stmt_attrs, self.config) {\n+                visit::walk_stmt(self, s);\n+            }\n+        } else {\n+            visit::walk_stmt(self, s);\n+        }\n+    }\n+\n+    fn visit_expr(&mut self, ex: &'v ast::Expr) {\n+        // check if there even are any attributes on this node\n+        let expr_attrs = ex.attrs();\n+        if expr_attrs.len() > 0 {\n+\n+            // flag the offending attributes\n+            for attr in expr_attrs {\n+                self.discovered.push(GatedCfgAttr::GatedAttr(attr.span));\n+            }\n+\n+            // if the node does not end up being cfg-d away, walk down\n+            if node_survives_cfg(expr_attrs, self.config) {\n+                visit::walk_expr(self, ex);\n+            }\n+        } else {\n+            visit::walk_expr(self, ex);\n+        }\n+    }\n+\n+    fn visit_foreign_item(&mut self, i: &'v ast::ForeignItem) {\n+        if node_survives_cfg(&i.attrs, self.config) {\n+            visit::walk_foreign_item(self, i);\n+        }\n+    }\n+\n+    fn visit_item(&mut self, i: &'v ast::Item) {\n+        if node_survives_cfg(&i.attrs, self.config) {\n+            visit::walk_item(self, i);\n+        }\n+    }\n+\n+    fn visit_impl_item(&mut self, ii: &'v ast::ImplItem) {\n+        if node_survives_cfg(&ii.attrs, self.config) {\n+            visit::walk_impl_item(self, ii);\n+        }\n+    }\n+\n+    fn visit_trait_item(&mut self, ti: &'v ast::TraitItem) {\n+        if node_survives_cfg(&ti.attrs, self.config) {\n+            visit::walk_trait_item(self, ti);\n+        }\n+    }\n+\n+    fn visit_struct_field(&mut self, s: &'v ast::StructField) {\n+        if node_survives_cfg(&s.node.attrs, self.config) {\n+            visit::walk_struct_field(self, s);\n+        }\n+    }\n+\n+    fn visit_variant(&mut self, v: &'v ast::Variant,\n+                     g: &'v ast::Generics, item_id: ast::NodeId) {\n+        if node_survives_cfg(&v.node.attrs, self.config) {\n+            visit::walk_variant(self, v, g, item_id);\n+        }\n+    }\n+\n+    fn visit_arm(&mut self, a: &'v ast::Arm) {\n+        if node_survives_cfg(&a.attrs, self.config) {\n+            visit::walk_arm(self, a);\n+        }\n+    }\n+\n+    // This visitor runs pre expansion, so we need to prevent\n+    // the default panic here\n+    fn visit_mac(&mut self, mac: &'v ast::Mac) {\n+        visit::walk_mac(self, mac)\n+    }\n+}\n+\n+pub trait CfgDiag {\n+    fn emit_error<F>(&mut self, f: F) where F: FnMut(&SpanHandler);\n+    fn flag_gated<F>(&mut self, f: F) where F: FnMut(&mut Vec<GatedCfgAttr>);\n+}\n+\n+pub struct CfgDiagReal<'a, 'b> {\n+    pub diag: &'a SpanHandler,\n+    pub feature_gated_cfgs: &'b mut Vec<GatedCfgAttr>,\n+}\n+\n+impl<'a, 'b> CfgDiag for CfgDiagReal<'a, 'b> {\n+    fn emit_error<F>(&mut self, mut f: F) where F: FnMut(&SpanHandler) {\n+        f(self.diag)\n+    }\n+    fn flag_gated<F>(&mut self, mut f: F) where F: FnMut(&mut Vec<GatedCfgAttr>) {\n+        f(self.feature_gated_cfgs)\n+    }\n+}\n+\n+struct CfgDiagSilent {\n+    error: bool,\n+}\n+\n+impl CfgDiag for CfgDiagSilent {\n+    fn emit_error<F>(&mut self, _: F) where F: FnMut(&SpanHandler) {\n+        self.error = true;\n+    }\n+    fn flag_gated<F>(&mut self, _: F) where F: FnMut(&mut Vec<GatedCfgAttr>) {}\n+}\n+\n+fn node_survives_cfg(attrs: &[ast::Attribute],\n+                     config: &ast::CrateConfig) -> bool {\n+    let mut survives_cfg = true;\n+\n+    for attr in attrs {\n+        let mut fld = CfgAttrFolder {\n+            diag: CfgDiagSilent { error: false },\n+            config: config,\n+        };\n+        let attr = fld.fold_attribute(attr.clone());\n+\n+        // In case of error we can just return true,\n+        // since the actual cfg folders will end compilation anyway.\n+\n+        if fld.diag.error { return true; }\n+\n+        survives_cfg &= attr.map(|attr| {\n+            let mut diag = CfgDiagSilent { error: false };\n+            let r = in_cfg(config, &[attr], &mut diag);\n+            if diag.error { return true; }\n+            r\n+        }).unwrap_or(true)\n+    }\n+\n+    survives_cfg\n+}"}, {"sha": "41a4fc9e1dfa44a9bd1c1de198de1edc1e223e5f", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/296c3613ca7ed1117788f4e56259d2e426e992d7/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/296c3613ca7ed1117788f4e56259d2e426e992d7/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=296c3613ca7ed1117788f4e56259d2e426e992d7", "patch": "@@ -17,7 +17,7 @@ use codemap::{CodeMap, Span, ExpnId, ExpnInfo, NO_EXPANSION};\n use ext;\n use ext::expand;\n use ext::tt::macro_rules;\n-use feature_gate::GatedCfg;\n+use feature_gate::GatedCfgAttr;\n use parse;\n use parse::parser;\n use parse::token;\n@@ -572,7 +572,7 @@ pub struct ExtCtxt<'a> {\n     pub backtrace: ExpnId,\n     pub ecfg: expand::ExpansionConfig<'a>,\n     pub crate_root: Option<&'static str>,\n-    pub feature_gated_cfgs: &'a mut Vec<GatedCfg>,\n+    pub feature_gated_cfgs: &'a mut Vec<GatedCfgAttr>,\n \n     pub mod_path: Vec<ast::Ident> ,\n     pub exported_macros: Vec<ast::MacroDef>,\n@@ -584,7 +584,7 @@ pub struct ExtCtxt<'a> {\n impl<'a> ExtCtxt<'a> {\n     pub fn new(parse_sess: &'a parse::ParseSess, cfg: ast::CrateConfig,\n                ecfg: expand::ExpansionConfig<'a>,\n-               feature_gated_cfgs: &'a mut Vec<GatedCfg>) -> ExtCtxt<'a> {\n+               feature_gated_cfgs: &'a mut Vec<GatedCfgAttr>) -> ExtCtxt<'a> {\n         let env = initial_syntax_expander_table(&ecfg);\n         ExtCtxt {\n             parse_sess: parse_sess,"}, {"sha": "e100355e4f8682a2ead0ccbdb7fce1956bab7e5a", "filename": "src/libsyntax/ext/cfg.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/296c3613ca7ed1117788f4e56259d2e426e992d7/src%2Flibsyntax%2Fext%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/296c3613ca7ed1117788f4e56259d2e426e992d7/src%2Flibsyntax%2Fext%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fcfg.rs?ref=296c3613ca7ed1117788f4e56259d2e426e992d7", "patch": "@@ -20,6 +20,7 @@ use ext::build::AstBuilder;\n use attr;\n use attr::*;\n use parse::token;\n+use config::CfgDiagReal;\n \n pub fn expand_cfg<'cx>(cx: &mut ExtCtxt,\n                        sp: Span,\n@@ -33,7 +34,12 @@ pub fn expand_cfg<'cx>(cx: &mut ExtCtxt,\n         return DummyResult::expr(sp);\n     }\n \n-    let matches_cfg = attr::cfg_matches(&cx.parse_sess.span_diagnostic, &cx.cfg, &cfg,\n-                                        cx.feature_gated_cfgs);\n+    let matches_cfg = {\n+        let mut diag = CfgDiagReal {\n+            diag: &cx.parse_sess.span_diagnostic,\n+            feature_gated_cfgs: cx.feature_gated_cfgs,\n+        };\n+        attr::cfg_matches(&cx.cfg, &cfg, &mut diag)\n+    };\n     MacEager::expr(cx.expr_bool(sp, matches_cfg))\n }"}, {"sha": "1512cab9498f00bc54bb7d3d7907673d7880e591", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/296c3613ca7ed1117788f4e56259d2e426e992d7/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/296c3613ca7ed1117788f4e56259d2e426e992d7/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=296c3613ca7ed1117788f4e56259d2e426e992d7", "patch": "@@ -21,7 +21,7 @@ use attr::{AttrMetaMethods, WithAttrs};\n use codemap;\n use codemap::{Span, Spanned, ExpnInfo, NameAndSpan, MacroBang, MacroAttribute};\n use ext::base::*;\n-use feature_gate::{self, Features, GatedCfg};\n+use feature_gate::{self, Features, GatedCfgAttr};\n use fold;\n use fold::*;\n use util::move_map::MoveMap;\n@@ -586,7 +586,7 @@ fn expand_non_macro_stmt(Spanned {node, span: stmt_span}: Stmt, fld: &mut MacroE\n                         // also, don't forget to expand the init:\n                         init: init.map(|e| fld.fold_expr(e)),\n                         span: span,\n-                        attrs: attrs\n+                        attrs: fold::fold_thin_attrs(attrs, fld),\n                     }\n                 });\n                 SmallVector::one(P(Spanned {\n@@ -1280,7 +1280,7 @@ pub fn expand_crate<'feat>(parse_sess: &parse::ParseSess,\n                            // these are the macros being imported to this crate:\n                            imported_macros: Vec<ast::MacroDef>,\n                            user_exts: Vec<NamedSyntaxExtension>,\n-                           feature_gated_cfgs: &mut Vec<GatedCfg>,\n+                           feature_gated_cfgs: &mut Vec<GatedCfgAttr>,\n                            c: Crate) -> (Crate, HashSet<Name>) {\n     let mut cx = ExtCtxt::new(parse_sess, c.config.clone(), cfg,\n                               feature_gated_cfgs);"}, {"sha": "2c1dc638fbc1cb62cd058230b423f89d15f7df61", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 48, "deletions": 7, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/296c3613ca7ed1117788f4e56259d2e426e992d7/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/296c3613ca7ed1117788f4e56259d2e426e992d7/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=296c3613ca7ed1117788f4e56259d2e426e992d7", "patch": "@@ -224,6 +224,9 @@ const KNOWN_FEATURES: &'static [(&'static str, &'static str, Option<u32>, Status\n \n     // Allows cfg(target_vendor = \"...\").\n     (\"cfg_target_vendor\", \"1.5.0\", Some(29718), Active),\n+\n+    // Allow attributes on expressions and non-item statements\n+    (\"stmt_expr_attributes\", \"1.6.0\", Some(15701), Active),\n ];\n // (changing above list without updating src/doc/reference.md makes @cmr sad)\n \n@@ -404,25 +407,57 @@ const GATED_CFGS: &'static [(&'static str, &'static str, fn(&Features) -> bool)]\n     (\"target_vendor\", \"cfg_target_vendor\", cfg_fn!(|x| x.cfg_target_vendor)),\n ];\n \n+#[derive(Debug, Eq, PartialEq)]\n+pub enum GatedCfgAttr {\n+    GatedCfg(GatedCfg),\n+    GatedAttr(Span),\n+}\n+\n #[derive(Debug, Eq, PartialEq)]\n pub struct GatedCfg {\n     span: Span,\n     index: usize,\n }\n \n-impl Ord for GatedCfg {\n-    fn cmp(&self, other: &GatedCfg) -> cmp::Ordering {\n-        (self.span.lo.0, self.span.hi.0, self.index)\n-            .cmp(&(other.span.lo.0, other.span.hi.0, other.index))\n+impl Ord for GatedCfgAttr {\n+    fn cmp(&self, other: &GatedCfgAttr) -> cmp::Ordering {\n+        let to_tup = |s: &GatedCfgAttr| match *s {\n+            GatedCfgAttr::GatedCfg(ref gated_cfg) => {\n+                (gated_cfg.span.lo.0, gated_cfg.span.hi.0, gated_cfg.index)\n+            }\n+            GatedCfgAttr::GatedAttr(ref span) => {\n+                (span.lo.0, span.hi.0, GATED_CFGS.len())\n+            }\n+        };\n+        to_tup(self).cmp(&to_tup(other))\n     }\n }\n \n-impl PartialOrd for GatedCfg {\n-    fn partial_cmp(&self, other: &GatedCfg) -> Option<cmp::Ordering> {\n+impl PartialOrd for GatedCfgAttr {\n+    fn partial_cmp(&self, other: &GatedCfgAttr) -> Option<cmp::Ordering> {\n         Some(self.cmp(other))\n     }\n }\n \n+impl GatedCfgAttr {\n+    pub fn check_and_emit(&self, diagnostic: &SpanHandler, features: &Features) {\n+        match *self {\n+            GatedCfgAttr::GatedCfg(ref cfg) => {\n+                cfg.check_and_emit(diagnostic, features);\n+            }\n+            GatedCfgAttr::GatedAttr(span) => {\n+                if !features.stmt_expr_attributes {\n+                    emit_feature_err(diagnostic,\n+                                     \"stmt_expr_attributes\",\n+                                     span,\n+                                     GateIssue::Language,\n+                                     EXPLAIN_STMT_ATTR_SYNTAX);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n impl GatedCfg {\n     pub fn gate(cfg: &ast::MetaItem) -> Option<GatedCfg> {\n         let name = cfg.name();\n@@ -435,7 +470,7 @@ impl GatedCfg {\n                       }\n                   })\n     }\n-    pub fn check_and_emit(&self, diagnostic: &SpanHandler, features: &Features) {\n+    fn check_and_emit(&self, diagnostic: &SpanHandler, features: &Features) {\n         let (cfg, feature, has_feature) = GATED_CFGS[self.index];\n         if !has_feature(features) {\n             let explain = format!(\"`cfg({})` is experimental and subject to change\", cfg);\n@@ -500,6 +535,7 @@ pub struct Features {\n     pub augmented_assignments: bool,\n     pub braced_empty_structs: bool,\n     pub staged_api: bool,\n+    pub stmt_expr_attributes: bool,\n }\n \n impl Features {\n@@ -532,6 +568,7 @@ impl Features {\n             augmented_assignments: false,\n             braced_empty_structs: false,\n             staged_api: false,\n+            stmt_expr_attributes: false,\n         }\n     }\n }\n@@ -545,6 +582,9 @@ const EXPLAIN_PLACEMENT_IN: &'static str =\n const EXPLAIN_PUSHPOP_UNSAFE: &'static str =\n     \"push/pop_unsafe macros are experimental and subject to change.\";\n \n+const EXPLAIN_STMT_ATTR_SYNTAX: &'static str =\n+    \"attributes on non-item statements and expressions are experimental.\";\n+\n pub fn check_for_box_syntax(f: Option<&Features>, diag: &SpanHandler, span: Span) {\n     if let Some(&Features { allow_box: true, .. }) = f {\n         return;\n@@ -1105,6 +1145,7 @@ fn check_crate_inner<F>(cm: &CodeMap, span_handler: &SpanHandler,\n         augmented_assignments: cx.has_feature(\"augmented_assignments\"),\n         braced_empty_structs: cx.has_feature(\"braced_empty_structs\"),\n         staged_api: cx.has_feature(\"staged_api\"),\n+        stmt_expr_attributes: cx.has_feature(\"stmt_expr_attributes\"),\n     }\n }\n "}, {"sha": "68338b115950c0f901d177a6c01a63530bf8340b", "filename": "src/test/compile-fail/stmt_expr_attrs_no_feature.rs", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/296c3613ca7ed1117788f4e56259d2e426e992d7/src%2Ftest%2Fcompile-fail%2Fstmt_expr_attrs_no_feature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/296c3613ca7ed1117788f4e56259d2e426e992d7/src%2Ftest%2Fcompile-fail%2Fstmt_expr_attrs_no_feature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstmt_expr_attrs_no_feature.rs?ref=296c3613ca7ed1117788f4e56259d2e426e992d7", "patch": "@@ -0,0 +1,151 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(custom_attribute)]\n+#![feature(associated_consts)]\n+\n+macro_rules! stmt_mac {\n+    () => {\n+        fn b() {}\n+    }\n+}\n+\n+fn main() {\n+    #[attr]\n+    fn a() {}\n+\n+    #[attr] //~ ERROR 15701\n+    {\n+\n+    }\n+\n+    #[attr] //~ ERROR 15701\n+    5;\n+\n+    #[attr] //~ ERROR 15701\n+    stmt_mac!();\n+}\n+\n+// Check that cfg works right\n+\n+#[cfg(unset)]\n+fn c() {\n+    #[attr]\n+    5;\n+}\n+\n+#[cfg(not(unset))]\n+fn j() {\n+    #[attr] //~ ERROR 15701\n+    5;\n+}\n+\n+#[cfg_attr(not(unset), cfg(unset))]\n+fn d() {\n+    #[attr]\n+    8;\n+}\n+\n+#[cfg_attr(not(unset), cfg(not(unset)))]\n+fn i() {\n+    #[attr] //~ ERROR 15701\n+    8;\n+}\n+\n+// check that macro expansion and cfg works right\n+\n+macro_rules! item_mac {\n+    ($e:ident) => {\n+        fn $e() {\n+            #[attr] //~ ERROR 15701\n+            42;\n+\n+            #[cfg(unset)]\n+            fn f() {\n+                #[attr]\n+                5;\n+            }\n+\n+            #[cfg(not(unset))]\n+            fn k() {\n+                #[attr] //~ ERROR 15701\n+                5;\n+            }\n+\n+            #[cfg_attr(not(unset), cfg(unset))]\n+            fn g() {\n+                #[attr]\n+                8;\n+            }\n+\n+            #[cfg_attr(not(unset), cfg(not(unset)))]\n+            fn h() {\n+                #[attr] //~ ERROR 15701\n+                8;\n+            }\n+\n+        }\n+    }\n+}\n+\n+item_mac!(e);\n+\n+// check that the gate visitor works right:\n+\n+extern {\n+    #[cfg(unset)]\n+    fn x(a: [u8; #[attr] 5]);\n+    fn y(a: [u8; #[attr] 5]); //~ ERROR 15701\n+}\n+\n+struct Foo;\n+impl Foo {\n+    #[cfg(unset)]\n+    const X: u8 = #[attr] 5;\n+    const Y: u8 = #[attr] 5; //~ ERROR 15701\n+}\n+\n+trait Bar {\n+    #[cfg(unset)]\n+    const X: [u8; #[attr] 5];\n+    const Y: [u8; #[attr] 5]; //~ ERROR 15701\n+}\n+\n+struct Joyce {\n+    #[cfg(unset)]\n+    field: [u8; #[attr] 5],\n+    field2: [u8; #[attr] 5] //~ ERROR 15701\n+}\n+\n+struct Walky(\n+    #[cfg(unset)] [u8; #[attr] 5],\n+    [u8; #[attr] 5] //~ ERROR 15701\n+);\n+\n+enum Mike {\n+    Happy(\n+        #[cfg(unset)] [u8; #[attr] 5],\n+        [u8; #[attr] 5] //~ ERROR 15701\n+    ),\n+    Angry {\n+        #[cfg(unset)]\n+        field: [u8; #[attr] 5],\n+        field2: [u8; #[attr] 5] //~ ERROR 15701\n+    }\n+}\n+\n+fn pat() {\n+    match 5 {\n+        #[cfg(unset)]\n+        5 => #[attr] (),\n+        6 => #[attr] (), //~ ERROR 15701\n+        _ => (),\n+    }\n+}"}, {"sha": "e52932cd7befa32bd391ea2f8bb0b7dd5006b762", "filename": "src/test/pretty/stmt_expr_attributes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/296c3613ca7ed1117788f4e56259d2e426e992d7/src%2Ftest%2Fpretty%2Fstmt_expr_attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/296c3613ca7ed1117788f4e56259d2e426e992d7/src%2Ftest%2Fpretty%2Fstmt_expr_attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fstmt_expr_attributes.rs?ref=296c3613ca7ed1117788f4e56259d2e426e992d7", "patch": "@@ -13,6 +13,7 @@\n #![feature(custom_attribute)]\n #![feature(box_syntax)]\n #![feature(placement_in_syntax)]\n+#![feature(stmt_expr_attributes)]\n \n fn main() { }\n "}, {"sha": "fcc93557665bff538c5980e4a3443e62e40214a8", "filename": "src/test/run-pass/cfg_stmt_expr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/296c3613ca7ed1117788f4e56259d2e426e992d7/src%2Ftest%2Frun-pass%2Fcfg_stmt_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/296c3613ca7ed1117788f4e56259d2e426e992d7/src%2Ftest%2Frun-pass%2Fcfg_stmt_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcfg_stmt_expr.rs?ref=296c3613ca7ed1117788f4e56259d2e426e992d7", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #![deny(non_snake_case)]\n+#![feature(stmt_expr_attributes)]\n \n fn main() {\n     let a = 413;"}, {"sha": "e2d70fc54b22851adb8427d810f588eb7217e9f5", "filename": "src/test/run-pass/stmt_expr_attr_macro_parse.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/296c3613ca7ed1117788f4e56259d2e426e992d7/src%2Ftest%2Frun-pass%2Fstmt_expr_attr_macro_parse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/296c3613ca7ed1117788f4e56259d2e426e992d7/src%2Ftest%2Frun-pass%2Fstmt_expr_attr_macro_parse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstmt_expr_attr_macro_parse.rs?ref=296c3613ca7ed1117788f4e56259d2e426e992d7", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+macro_rules! m {\n+    ($e:expr) => {\n+        \"expr includes attr\"\n+    };\n+    (#[$attr:meta] $e:expr) => {\n+        \"expr excludes attr\"\n+    }\n+}\n+\n+fn main() {\n+    assert_eq!(m!(#[attr] 1 + 1), \"expr includes attr\");\n+}"}]}