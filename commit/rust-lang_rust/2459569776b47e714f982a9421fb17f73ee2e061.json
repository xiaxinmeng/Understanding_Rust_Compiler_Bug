{"sha": "2459569776b47e714f982a9421fb17f73ee2e061", "node_id": "C_kwDOAAsO6NoAKDI0NTk1Njk3NzZiNDdlNzE0Zjk4MmE5NDIxZmIxN2Y3M2VlMmUwNjE", "commit": {"author": {"name": "Nilstrieb", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2022-10-21T10:25:25Z"}, "committer": {"name": "Nilstrieb", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2022-10-23T08:09:44Z"}, "message": "Generate fluent message constant in a flat module for all crates\n\nThis will make it easier to grep for fluent message names.", "tree": {"sha": "e465b3933f1a06347e1b032dcdf3068611b5668b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e465b3933f1a06347e1b032dcdf3068611b5668b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2459569776b47e714f982a9421fb17f73ee2e061", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN SSH SIGNATURE-----\nU1NIU0lHAAAAAQAAADMAAAALc3NoLWVkMjU1MTkAAAAgbSfWKRQb2tiqhuHtakDJeupmrF\nChDbM0msU+PXaBOk8AAAADZ2l0AAAAAAAAAAZzaGE1MTIAAABTAAAAC3NzaC1lZDI1NTE5\nAAAAQB5JirOi3S4M3ZhrExpDhtmrY6NpJjy5gCc70rwYfaGWu2SeFgkxyPqORNiu46B9jn\nZNpj9e6mIfozoGQX1zlwI=\n-----END SSH SIGNATURE-----", "payload": "tree e465b3933f1a06347e1b032dcdf3068611b5668b\nparent 6c9c2d862dd10718ba2b2a320c3390995ad414bc\nauthor Nilstrieb <48135649+Nilstrieb@users.noreply.github.com> 1666347925 +0200\ncommitter Nilstrieb <48135649+Nilstrieb@users.noreply.github.com> 1666512584 +0200\n\nGenerate fluent message constant in a flat module for all crates\n\nThis will make it easier to grep for fluent message names.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2459569776b47e714f982a9421fb17f73ee2e061", "html_url": "https://github.com/rust-lang/rust/commit/2459569776b47e714f982a9421fb17f73ee2e061", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2459569776b47e714f982a9421fb17f73ee2e061/comments", "author": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c9c2d862dd10718ba2b2a320c3390995ad414bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c9c2d862dd10718ba2b2a320c3390995ad414bc", "html_url": "https://github.com/rust-lang/rust/commit/6c9c2d862dd10718ba2b2a320c3390995ad414bc"}], "stats": {"total": 65, "additions": 31, "deletions": 34}, "files": [{"sha": "3e447c94ef1238d3d977356d6ea70e8f3ce9fe3d", "filename": "compiler/rustc_macros/src/diagnostics/fluent.rs", "status": "modified", "additions": 31, "deletions": 34, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/2459569776b47e714f982a9421fb17f73ee2e061/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ffluent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2459569776b47e714f982a9421fb17f73ee2e061/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ffluent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ffluent.rs?ref=2459569776b47e714f982a9421fb17f73ee2e061", "patch": "@@ -25,18 +25,18 @@ use syn::{\n use unic_langid::langid;\n \n struct Resource {\n-    ident: Ident,\n+    krate: Ident,\n     #[allow(dead_code)]\n     fat_arrow_token: token::FatArrow,\n-    resource: LitStr,\n+    resource_path: LitStr,\n }\n \n impl Parse for Resource {\n     fn parse(input: ParseStream<'_>) -> Result<Self> {\n         Ok(Resource {\n-            ident: input.parse()?,\n+            krate: input.parse()?,\n             fat_arrow_token: input.parse()?,\n-            resource: input.parse()?,\n+            resource_path: input.parse()?,\n         })\n     }\n }\n@@ -94,19 +94,20 @@ pub(crate) fn fluent_messages(input: proc_macro::TokenStream) -> proc_macro::Tok\n     // diagnostics.\n     let mut previous_defns = HashMap::new();\n \n+    // Set of Fluent attribute names already output, to avoid duplicate type errors - any given\n+    // constant created for a given attribute is the same.\n+    let mut previous_attrs = HashSet::new();\n+\n     let mut includes = TokenStream::new();\n     let mut generated = TokenStream::new();\n-    for res in resources.0 {\n-        let ident_span = res.ident.span().unwrap();\n-        let path_span = res.resource.span().unwrap();\n \n-        // Set of Fluent attribute names already output, to avoid duplicate type errors - any given\n-        // constant created for a given attribute is the same.\n-        let mut previous_attrs = HashSet::new();\n+    for res in resources.0 {\n+        let krate_span = res.krate.span().unwrap();\n+        let path_span = res.resource_path.span().unwrap();\n \n-        let relative_ftl_path = res.resource.value();\n+        let relative_ftl_path = res.resource_path.value();\n         let absolute_ftl_path =\n-            invocation_relative_path_to_absolute(ident_span, &relative_ftl_path);\n+            invocation_relative_path_to_absolute(krate_span, &relative_ftl_path);\n         // As this macro also outputs an `include_str!` for this file, the macro will always be\n         // re-executed when the file changes.\n         let mut resource_file = match File::open(absolute_ftl_path) {\n@@ -185,7 +186,7 @@ pub(crate) fn fluent_messages(input: proc_macro::TokenStream) -> proc_macro::Tok\n \n         let mut constants = TokenStream::new();\n         for entry in resource.entries() {\n-            let span = res.ident.span();\n+            let span = res.krate.span();\n             if let Entry::Message(Message { id: Identifier { name }, attributes, .. }) = entry {\n                 let _ = previous_defns.entry(name.to_string()).or_insert(path_span);\n \n@@ -199,29 +200,30 @@ pub(crate) fn fluent_messages(input: proc_macro::TokenStream) -> proc_macro::Tok\n                     .emit();\n                 }\n \n-                // `typeck_foo_bar` => `foo_bar` (in `typeck.ftl`)\n-                // `const_eval_baz` => `baz` (in `const_eval.ftl`)\n+                // Require that the message name starts with the crate name\n+                // `hir_typeck_foo_bar` (in `hir_typeck.ftl`)\n+                // `const_eval_baz` (in `const_eval.ftl`)\n                 // `const-eval-hyphen-having` => `hyphen_having` (in `const_eval.ftl`)\n                 // The last case we error about above, but we want to fall back gracefully\n                 // so that only the error is being emitted and not also one about the macro\n                 // failing.\n-                let crate_prefix = format!(\"{}_\", res.ident);\n+                let crate_prefix = format!(\"{}_\", res.krate);\n \n                 let snake_name = name.replace('-', \"_\");\n-                let snake_name = match snake_name.strip_prefix(&crate_prefix) {\n-                    Some(rest) => Ident::new(rest, span),\n-                    None => {\n-                        Diagnostic::spanned(\n-                            path_span,\n-                            Level::Error,\n-                            format!(\"name `{name}` does not start with the crate name\"),\n-                        )\n-                        .help(format!(\"prepend `{crate_prefix}` to the slug name: `{crate_prefix}{snake_name}`\"))\n-                        .emit();\n-                        Ident::new(&snake_name, span)\n-                    }\n+                if !snake_name.starts_with(&crate_prefix) {\n+                    Diagnostic::spanned(\n+                        path_span,\n+                        Level::Error,\n+                        format!(\"name `{name}` does not start with the crate name\"),\n+                    )\n+                    .help(format!(\n+                        \"prepend `{crate_prefix}` to the slug name: `{crate_prefix}{snake_name}`\"\n+                    ))\n+                    .emit();\n                 };\n \n+                let snake_name = Ident::new(&snake_name, span);\n+\n                 constants.extend(quote! {\n                     pub const #snake_name: crate::DiagnosticMessage =\n                         crate::DiagnosticMessage::FluentIdentifier(\n@@ -275,12 +277,7 @@ pub(crate) fn fluent_messages(input: proc_macro::TokenStream) -> proc_macro::Tok\n \n         includes.extend(quote! { include_str!(#relative_ftl_path), });\n \n-        let ident = res.ident;\n-        generated.extend(quote! {\n-            pub mod #ident {\n-                #constants\n-            }\n-        });\n+        generated.extend(constants);\n     }\n \n     quote! {"}]}