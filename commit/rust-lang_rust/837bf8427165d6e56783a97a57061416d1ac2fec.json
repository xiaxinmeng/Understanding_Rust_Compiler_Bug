{"sha": "837bf8427165d6e56783a97a57061416d1ac2fec", "node_id": "C_kwDOAAsO6NoAKDgzN2JmODQyNzE2NWQ2ZTU2NzgzYTk3YTU3MDYxNDE2ZDFhYzJmZWM", "commit": {"author": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-07-13T13:09:23Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-07-13T14:36:03Z"}, "message": "Error patterns can be regexes", "tree": {"sha": "1e0c336209d9aeb5da594a924fcb1113c5429796", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e0c336209d9aeb5da594a924fcb1113c5429796"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/837bf8427165d6e56783a97a57061416d1ac2fec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/837bf8427165d6e56783a97a57061416d1ac2fec", "html_url": "https://github.com/rust-lang/rust/commit/837bf8427165d6e56783a97a57061416d1ac2fec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/837bf8427165d6e56783a97a57061416d1ac2fec/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db5a2b97475166626e4c7680844f47f5347e9bc3", "url": "https://api.github.com/repos/rust-lang/rust/commits/db5a2b97475166626e4c7680844f47f5347e9bc3", "html_url": "https://github.com/rust-lang/rust/commit/db5a2b97475166626e4c7680844f47f5347e9bc3"}], "stats": {"total": 97, "additions": 73, "deletions": 24}, "files": [{"sha": "9b710424c55c4fc1188d3e3d290331c9aaa421b3", "filename": "tests/fail/stacked_borrows/deallocate_against_barrier1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/837bf8427165d6e56783a97a57061416d1ac2fec/tests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_barrier1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837bf8427165d6e56783a97a57061416d1ac2fec/tests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_barrier1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_barrier1.rs?ref=837bf8427165d6e56783a97a57061416d1ac2fec", "patch": "@@ -1,4 +1,4 @@\n-//@error-pattern: deallocating while item\n+//@error-pattern: /deallocating while item \\[Unique for .*\\] is protected/\n \n fn inner(x: &mut i32, f: fn(&mut i32)) {\n     // `f` may mutate, but it may not deallocate!"}, {"sha": "36e133e38365091a506886f2353c7c8786e1529e", "filename": "tests/fail/stacked_borrows/deallocate_against_barrier2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/837bf8427165d6e56783a97a57061416d1ac2fec/tests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_barrier2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837bf8427165d6e56783a97a57061416d1ac2fec/tests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_barrier2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_barrier2.rs?ref=837bf8427165d6e56783a97a57061416d1ac2fec", "patch": "@@ -1,4 +1,4 @@\n-//@error-pattern: deallocating while item\n+//@error-pattern: /deallocating while item \\[SharedReadWrite for .*\\] is protected/\n use std::marker::PhantomPinned;\n \n pub struct NotUnpin(i32, PhantomPinned);"}, {"sha": "55639c9589e100f516b15ec2fda03a5407eff9ab", "filename": "ui_test/README.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/837bf8427165d6e56783a97a57061416d1ac2fec/ui_test%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/837bf8427165d6e56783a97a57061416d1ac2fec/ui_test%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/ui_test%2FREADME.md?ref=837bf8427165d6e56783a97a57061416d1ac2fec", "patch": "@@ -17,6 +17,7 @@ to make sure that the test will always keep failing with a specific message at t\n * If the all caps note is left out, a message of any level is matched. Leaving it out is not allowed for `ERROR` levels.\n * This checks the output *before* normalization, so you can check things that get normalized away, but need to\n     be careful not to accidentally have a pattern that differs between platforms.\n+* if `XXX` is of the form `/XXX/` it is treated as a regex instead of a substring and will succeed if the regex matches.\n \n In order to change how a single test is tested, you can add various `//@` comments to the test.\n Any other comments will be ignored, and all `//@` comments must be formatted precisely as"}, {"sha": "32c04290bca20ff556d3c0c7ed2b03e5f5bfbbc3", "filename": "ui_test/src/lib.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/837bf8427165d6e56783a97a57061416d1ac2fec/ui_test%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837bf8427165d6e56783a97a57061416d1ac2fec/ui_test%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/ui_test%2Fsrc%2Flib.rs?ref=837bf8427165d6e56783a97a57061416d1ac2fec", "patch": "@@ -10,7 +10,7 @@ use std::sync::Mutex;\n pub use color_eyre;\n use color_eyre::eyre::Result;\n use colored::*;\n-use parser::ErrorMatch;\n+use parser::{ErrorMatch, Pattern};\n use regex::Regex;\n use rustc_stderr::{Level, Message};\n \n@@ -177,7 +177,12 @@ pub fn run_tests(config: Config) -> Result<()> {\n                 match error {\n                     Error::ExitStatus(mode, exit_status) => eprintln!(\"{mode:?} got {exit_status}\"),\n                     Error::PatternNotFound { pattern, definition_line } => {\n-                        eprintln!(\"`{pattern}` {} in stderr output\", \"not found\".red());\n+                        match pattern {\n+                            Pattern::SubString(s) =>\n+                                eprintln!(\"substring `{s}` {} in stderr output\", \"not found\".red()),\n+                            Pattern::Regex(r) =>\n+                                eprintln!(\"`/{r}/` does {} stderr output\", \"not match\".red()),\n+                        }\n                         eprintln!(\n                             \"expected because of pattern here: {}:{definition_line}\",\n                             path.display().to_string().bold()\n@@ -257,7 +262,7 @@ enum Error {\n     /// Got an invalid exit status for the given mode.\n     ExitStatus(Mode, ExitStatus),\n     PatternNotFound {\n-        pattern: String,\n+        pattern: Pattern,\n         definition_line: usize,\n     },\n     /// A ui test checking for failure does not have any failure patterns\n@@ -384,22 +389,19 @@ fn check_annotations(\n         // in the messages.\n         if let Some(i) = messages_from_unknown_file_or_line\n             .iter()\n-            .position(|msg| msg.message.contains(error_pattern))\n+            .position(|msg| error_pattern.matches(&msg.message))\n         {\n             messages_from_unknown_file_or_line.remove(i);\n         } else {\n-            errors.push(Error::PatternNotFound {\n-                pattern: error_pattern.to_string(),\n-                definition_line,\n-            });\n+            errors.push(Error::PatternNotFound { pattern: error_pattern.clone(), definition_line });\n         }\n     }\n \n     // The order on `Level` is such that `Error` is the highest level.\n     // We will ensure that *all* diagnostics of level at least `lowest_annotation_level`\n     // are matched.\n     let mut lowest_annotation_level = Level::Error;\n-    for &ErrorMatch { ref matched, revision: ref rev, definition_line, line, level } in\n+    for &ErrorMatch { ref pattern, revision: ref rev, definition_line, line, level } in\n         &comments.error_matches\n     {\n         if let Some(rev) = rev {\n@@ -415,14 +417,14 @@ fn check_annotations(\n \n         if let Some(msgs) = messages.get_mut(line) {\n             let found =\n-                msgs.iter().position(|msg| msg.message.contains(matched) && msg.level == level);\n+                msgs.iter().position(|msg| pattern.matches(&msg.message) && msg.level == level);\n             if let Some(found) = found {\n                 msgs.remove(found);\n                 continue;\n             }\n         }\n \n-        errors.push(Error::PatternNotFound { pattern: matched.to_string(), definition_line });\n+        errors.push(Error::PatternNotFound { pattern: pattern.clone(), definition_line });\n     }\n \n     let filter = |msgs: Vec<Message>| -> Vec<_> {"}, {"sha": "7d810a95e4122a6e2264a03e3190a911f966568d", "filename": "ui_test/src/parser.rs", "status": "modified", "additions": 33, "deletions": 6, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/837bf8427165d6e56783a97a57061416d1ac2fec/ui_test%2Fsrc%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837bf8427165d6e56783a97a57061416d1ac2fec/ui_test%2Fsrc%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/ui_test%2Fsrc%2Fparser.rs?ref=837bf8427165d6e56783a97a57061416d1ac2fec", "patch": "@@ -29,7 +29,7 @@ pub(crate) struct Comments {\n     /// Normalizations to apply to the stderr output before emitting it to disk\n     pub normalize_stderr: Vec<(Regex, String)>,\n     /// An arbitrary pattern to look for in the stderr.\n-    pub error_pattern: Option<(String, usize)>,\n+    pub error_pattern: Option<(Pattern, usize)>,\n     pub error_matches: Vec<ErrorMatch>,\n     /// Ignore diagnostics below this level.\n     /// `None` means pick the lowest level from the `error_pattern`s.\n@@ -45,9 +45,15 @@ pub(crate) enum Condition {\n     Bitwidth(u8),\n }\n \n+#[derive(Debug, Clone)]\n+pub(crate) enum Pattern {\n+    SubString(String),\n+    Regex(Regex),\n+}\n+\n #[derive(Debug)]\n pub(crate) struct ErrorMatch {\n-    pub matched: String,\n+    pub pattern: Pattern,\n     pub revision: Option<String>,\n     pub level: Level,\n     /// The line where the message was defined, for reporting issues with it (e.g. in case it wasn't found).\n@@ -184,7 +190,7 @@ impl Comments {\n                     \"cannot specifiy error_pattern twice, previous: {:?}\",\n                     self.error_pattern\n                 );\n-                self.error_pattern = Some((args.trim().to_string(), l));\n+                self.error_pattern = Some((Pattern::parse(args.trim())?, l));\n             }\n             \"stderr-per-bitwidth\" => {\n                 // args are ignored (can be used as comment)\n@@ -275,14 +281,16 @@ impl Comments {\n         let pattern = &pattern[offset..];\n         let pattern = pattern.strip_prefix(':').ok_or_else(|| eyre!(\"no `:` after level found\"))?;\n \n-        let matched = pattern.trim().to_string();\n+        let pattern = pattern.trim();\n+\n+        ensure!(!pattern.is_empty(), \"no pattern specified\");\n \n-        ensure!(!matched.is_empty(), \"no pattern specified\");\n+        let pattern = Pattern::parse(pattern)?;\n \n         *fallthrough_to = Some(match_line);\n \n         self.error_matches.push(ErrorMatch {\n-            matched,\n+            pattern,\n             revision,\n             level,\n             definition_line: l,\n@@ -292,3 +300,22 @@ impl Comments {\n         Ok(())\n     }\n }\n+\n+impl Pattern {\n+    pub(crate) fn matches(&self, message: &str) -> bool {\n+        match self {\n+            Pattern::SubString(s) => message.contains(s),\n+            Pattern::Regex(r) => r.is_match(message),\n+        }\n+    }\n+\n+    pub(crate) fn parse(pattern: &str) -> Result<Self> {\n+        if let Some(pattern) = pattern.strip_prefix('/') {\n+            let regex =\n+                pattern.strip_suffix('/').ok_or_else(|| eyre!(\"regex must end with `/`\"))?;\n+            Ok(Pattern::Regex(Regex::new(regex)?))\n+        } else {\n+            Ok(Pattern::SubString(pattern.to_string()))\n+        }\n+    }\n+}"}, {"sha": "343857d44bd35d5b87fd95354777c65af8731146", "filename": "ui_test/src/parser/tests.rs", "status": "modified", "additions": 24, "deletions": 5, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/837bf8427165d6e56783a97a57061416d1ac2fec/ui_test%2Fsrc%2Fparser%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837bf8427165d6e56783a97a57061416d1ac2fec/ui_test%2Fsrc%2Fparser%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/ui_test%2Fsrc%2Fparser%2Ftests.rs?ref=837bf8427165d6e56783a97a57061416d1ac2fec", "patch": "@@ -1,5 +1,7 @@\n use std::path::Path;\n \n+use crate::parser::Pattern;\n+\n use super::Comments;\n \n #[test]\n@@ -15,10 +17,11 @@ fn main() {\n     println!(\"parsed comments: {:#?}\", comments);\n     assert_eq!(comments.error_matches[0].definition_line, 5);\n     assert_eq!(comments.error_matches[0].revision, None);\n-    assert_eq!(\n-        comments.error_matches[0].matched,\n-        \"encountered a dangling reference (address $HEX is unallocated)\"\n-    );\n+    match &comments.error_matches[0].pattern {\n+        Pattern::SubString(s) =>\n+            assert_eq!(s, \"encountered a dangling reference (address $HEX is unallocated)\"),\n+        other => panic!(\"expected substring, got {other:?}\"),\n+    }\n }\n \n #[test]\n@@ -42,7 +45,23 @@ use std::mem;\n     \";\n     let comments = Comments::parse(Path::new(\"<dummy>\"), s).unwrap();\n     println!(\"parsed comments: {:#?}\", comments);\n-    assert_eq!(comments.error_pattern, Some((\"foomp\".to_string(), 2)));\n+    let pat = comments.error_pattern.unwrap();\n+    assert_eq!(format!(\"{:?}\", pat.0), r#\"SubString(\"foomp\")\"#);\n+    assert_eq!(pat.1, 2);\n+}\n+\n+#[test]\n+fn parse_regex_error_pattern() {\n+    let s = r\"\n+//@  error-pattern:  /foomp/\n+use std::mem;\n+\n+    \";\n+    let comments = Comments::parse(Path::new(\"<dummy>\"), s).unwrap();\n+    println!(\"parsed comments: {:#?}\", comments);\n+    let pat = comments.error_pattern.unwrap();\n+    assert_eq!(format!(\"{:?}\", pat.0), r#\"Regex(foomp)\"#);\n+    assert_eq!(pat.1, 2);\n }\n \n #[test]"}]}