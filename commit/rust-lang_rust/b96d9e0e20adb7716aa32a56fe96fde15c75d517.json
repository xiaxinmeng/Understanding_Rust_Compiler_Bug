{"sha": "b96d9e0e20adb7716aa32a56fe96fde15c75d517", "node_id": "C_kwDOAAsO6NoAKGI5NmQ5ZTBlMjBhZGI3NzE2YWEzMmE1NmZlOTZmZGUxNWM3NWQ1MTc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-13T00:29:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-13T00:29:28Z"}, "message": "Auto merge of #105644 - matthiaskrgr:rollup-qc6hlzq, r=matthiaskrgr\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #104864 (Account for item-local in inner scope for E0425)\n - #105332 (Point out the type of associated types in every method call of iterator chains)\n - #105620 (Remove unnecessary uses of `clone`)\n - #105625 (minor code cleanups)\n - #105629 (rustdoc: stop treating everything in a trait item as a method)\n - #105636 (Add check for local-storage value when changing \"display line numbers\" settings)\n - #105639 (rustdoc: remove `type=\"text/css\" from stylesheet links)\n - #105640 (Adjust miri to still be optional)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "454f2841806010e5903bce4628eedcc1af27f35c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/454f2841806010e5903bce4628eedcc1af27f35c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b96d9e0e20adb7716aa32a56fe96fde15c75d517", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b96d9e0e20adb7716aa32a56fe96fde15c75d517", "html_url": "https://github.com/rust-lang/rust/commit/b96d9e0e20adb7716aa32a56fe96fde15c75d517", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b96d9e0e20adb7716aa32a56fe96fde15c75d517/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed9749324aed9e97741abf569a022353e269a9df", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed9749324aed9e97741abf569a022353e269a9df", "html_url": "https://github.com/rust-lang/rust/commit/ed9749324aed9e97741abf569a022353e269a9df"}, {"sha": "5af04471aacadf650c23eed54b70fbe04e2230c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/5af04471aacadf650c23eed54b70fbe04e2230c2", "html_url": "https://github.com/rust-lang/rust/commit/5af04471aacadf650c23eed54b70fbe04e2230c2"}], "stats": {"total": 1109, "additions": 865, "deletions": 244}, "files": [{"sha": "8c71332bfabb13d9f45813414978a05c1c9c2fcc", "filename": "compiler/rustc_abi/src/lib.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flib.rs?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -802,12 +802,9 @@ impl Integer {\n     pub fn for_align<C: HasDataLayout>(cx: &C, wanted: Align) -> Option<Integer> {\n         let dl = cx.data_layout();\n \n-        for candidate in [I8, I16, I32, I64, I128] {\n-            if wanted == candidate.align(dl).abi && wanted.bytes() == candidate.size().bytes() {\n-                return Some(candidate);\n-            }\n-        }\n-        None\n+        [I8, I16, I32, I64, I128].into_iter().find(|&candidate| {\n+            wanted == candidate.align(dl).abi && wanted.bytes() == candidate.size().bytes()\n+        })\n     }\n \n     /// Find the largest integer with the given alignment or less."}, {"sha": "7b8c0d79a17e8519f3fc79a3f65149db2f2537dc", "filename": "compiler/rustc_ast/src/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -114,7 +114,7 @@ impl Lit {\n                 if let NtExpr(expr) | NtLiteral(expr) = &**nt\n                 && let ast::ExprKind::Lit(token_lit) = expr.kind =>\n             {\n-                Some(token_lit.clone())\n+                Some(token_lit)\n             }\n             _ => None,\n         }"}, {"sha": "039338f543cc591b19b88055b80f6888d47a9310", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -630,7 +630,7 @@ fn check_incompatible_features(sess: &Session) {\n             {\n                 let spans = vec![f1_span, f2_span];\n                 sess.struct_span_err(\n-                    spans.clone(),\n+                    spans,\n                     &format!(\n                         \"features `{}` and `{}` are incompatible, using them at the same time \\\n                         is not allowed\","}, {"sha": "5fb4dcf09f5df920d9ed096e8dd9a8b517d42056", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -745,7 +745,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             err.span_suggestion_verbose(\n                 span.shrink_to_hi(),\n                 \"consider cloning the value if the performance cost is acceptable\",\n-                \".clone()\".to_string(),\n+                \".clone()\",\n                 Applicability::MachineApplicable,\n             );\n         }"}, {"sha": "dcf500ddbd3c8d9fc576d6eb8de1261a05f129b8", "filename": "compiler/rustc_builtin_macros/src/alloc_error_handler.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -32,7 +32,7 @@ pub fn expand(\n             (item, true, ecx.with_def_site_ctxt(fn_kind.sig.span))\n         } else {\n             ecx.sess.parse_sess.span_diagnostic.span_err(item.span(), \"alloc_error_handler must be a function\");\n-            return vec![orig_item.clone()];\n+            return vec![orig_item];\n         };\n \n     // Generate a bunch of new items using the AllocFnFactory"}, {"sha": "4f1a7d709ff8c276900c255977d478fa9a3bec81", "filename": "compiler/rustc_builtin_macros/src/concat_bytes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -196,7 +196,7 @@ pub fn expand_concat_bytes(\n         }\n     }\n     if !missing_literals.is_empty() {\n-        let mut err = cx.struct_span_err(missing_literals.clone(), \"expected a byte literal\");\n+        let mut err = cx.struct_span_err(missing_literals, \"expected a byte literal\");\n         err.note(\"only byte literals (like `b\\\"foo\\\"`, `b's'`, and `[3, 4, 5]`) can be passed to `concat_bytes!()`\");\n         err.emit();\n         return base::MacEager::expr(DummyResult::raw_expr(sp, true));"}, {"sha": "e20dc906bce9a42bb3c639c27f33d7bfb8db56b2", "filename": "compiler/rustc_codegen_llvm/src/back/lto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -210,7 +210,7 @@ pub(crate) fn run_thin(\n }\n \n pub(crate) fn prepare_thin(module: ModuleCodegen<ModuleLlvm>) -> (String, ThinBuffer) {\n-    let name = module.name.clone();\n+    let name = module.name;\n     let buffer = ThinBuffer::new(module.module_llvm.llmod(), true);\n     (name, buffer)\n }"}, {"sha": "4567759c004dad7140b008d9569fc811c07fe642", "filename": "compiler/rustc_data_structures/src/base_n.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/compiler%2Frustc_data_structures%2Fsrc%2Fbase_n.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/compiler%2Frustc_data_structures%2Fsrc%2Fbase_n.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fbase_n.rs?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -9,7 +9,7 @@ pub const MAX_BASE: usize = 64;\n pub const ALPHANUMERIC_ONLY: usize = 62;\n pub const CASE_INSENSITIVE: usize = 36;\n \n-const BASE_64: &[u8; MAX_BASE as usize] =\n+const BASE_64: &[u8; MAX_BASE] =\n     b\"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ@$\";\n \n #[inline]"}, {"sha": "585a54308c62e1c0bf07ab9c1478bd51ec0fca2c", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -370,7 +370,11 @@ impl Diagnostic {\n         self.set_span(after);\n         for span_label in before.span_labels() {\n             if let Some(label) = span_label.label {\n-                self.span.push_span_label(after, label);\n+                if span_label.is_primary {\n+                    self.span.push_span_label(after, label);\n+                } else {\n+                    self.span.push_span_label(span_label.span, label);\n+                }\n             }\n         }\n         self\n@@ -802,7 +806,7 @@ impl Diagnostic {\n         debug_assert!(\n             !(suggestions\n                 .iter()\n-                .flat_map(|suggs| suggs)\n+                .flatten()\n                 .any(|(sp, suggestion)| sp.is_empty() && suggestion.is_empty())),\n             \"Span must not be empty and have no suggestion\"\n         );"}, {"sha": "aaf0699f0dc41b1b0784ba42670b80a1a899964f", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -1308,7 +1308,7 @@ impl EmitterWriter {\n         //                see how it *looks* with\n         //                very *weird* formats\n         //                see?\n-        for &(ref text, ref style) in msg.iter() {\n+        for (text, style) in msg.iter() {\n             let text = self.translate_message(text, args);\n             let lines = text.split('\\n').collect::<Vec<_>>();\n             if lines.len() > 1 {\n@@ -1370,7 +1370,7 @@ impl EmitterWriter {\n                 buffer.append(0, \": \", header_style);\n                 label_width += 2;\n             }\n-            for &(ref text, _) in msg.iter() {\n+            for (text, _) in msg.iter() {\n                 let text = self.translate_message(text, args);\n                 // Account for newlines to align output to its label.\n                 for (line, text) in normalize_whitespace(&text).lines().enumerate() {"}, {"sha": "91825c29258ac10bd345aedbd19fcf35faa1da72", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -548,12 +548,7 @@ impl<'hir> Generics<'hir> {\n     }\n \n     pub fn get_named(&self, name: Symbol) -> Option<&GenericParam<'hir>> {\n-        for param in self.params {\n-            if name == param.name.ident().name {\n-                return Some(param);\n-            }\n-        }\n-        None\n+        self.params.iter().find(|&param| name == param.name.ident().name)\n     }\n \n     pub fn spans(&self) -> MultiSpan {"}, {"sha": "686cb6dac496224f130d3f08a2f17d685eb30a32", "filename": "compiler/rustc_index/src/bit_set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -209,7 +209,7 @@ impl<T: Idx> BitSet<T> {\n             self.words[start_word_index] |= !(start_mask - 1);\n             // And all trailing bits (i.e. from 0..=end) in the end word,\n             // including the end.\n-            self.words[end_word_index] |= end_mask | end_mask - 1;\n+            self.words[end_word_index] |= end_mask | (end_mask - 1);\n         } else {\n             self.words[start_word_index] |= end_mask | (end_mask - start_mask);\n         }"}, {"sha": "9bd2202d2601e6f54dcb7a7bac0a5c001e2eb325", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -330,7 +330,7 @@ pub fn suggest_new_region_bound(\n                             Applicability::MaybeIncorrect,\n                         );\n                     }\n-                    if let Some((param_span, param_ty)) = param.clone() {\n+                    if let Some((param_span, ref param_ty)) = param {\n                         err.span_suggestion_verbose(\n                             param_span,\n                             add_static_bound,"}, {"sha": "87c44638a8de1918883375cd0d6357dfebd8a16b", "filename": "compiler/rustc_lexer/src/unescape.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -204,14 +204,13 @@ fn scan_escape(chars: &mut Chars<'_>, is_byte: bool) -> Result<char, EscapeError\n                         })?;\n                     }\n                     Some(c) => {\n-                        let digit =\n+                        let digit: u32 =\n                             c.to_digit(16).ok_or(EscapeError::InvalidCharInUnicodeEscape)?;\n                         n_digits += 1;\n                         if n_digits > 6 {\n                             // Stop updating value since we're sure that it's incorrect already.\n                             continue;\n                         }\n-                        let digit = digit as u32;\n                         value = value * 16 + digit;\n                     }\n                 };"}, {"sha": "5b7a00101e9b75b53cd635ec29c1d90da6a9a5be", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -566,6 +566,9 @@ struct LateResolutionVisitor<'a, 'b, 'ast> {\n     /// FIXME #4948: Reuse ribs to avoid allocation.\n     ribs: PerNS<Vec<Rib<'a>>>,\n \n+    /// Previous poped `rib`, only used for diagnostic.\n+    last_block_rib: Option<Rib<'a>>,\n+\n     /// The current set of local scopes, for labels.\n     label_ribs: Vec<Rib<'a, NodeId>>,\n \n@@ -873,6 +876,8 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                             // Ignore errors in function bodies if this is rustdoc\n                             // Be sure not to set this until the function signature has been resolved.\n                             let previous_state = replace(&mut this.in_func_body, true);\n+                            // We only care block in the same function\n+                            this.last_block_rib = None;\n                             // Resolve the function body, potentially inside the body of an async closure\n                             this.with_lifetime_rib(\n                                 LifetimeRibKind::Elided(LifetimeRes::Infer),\n@@ -1168,6 +1173,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 type_ns: vec![Rib::new(start_rib_kind)],\n                 macro_ns: vec![Rib::new(start_rib_kind)],\n             },\n+            last_block_rib: None,\n             label_ribs: Vec::new(),\n             lifetime_ribs: Vec::new(),\n             lifetime_elision_candidates: None,\n@@ -3769,7 +3775,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             self.ribs[ValueNS].pop();\n             self.label_ribs.pop();\n         }\n-        self.ribs[ValueNS].pop();\n+        self.last_block_rib = self.ribs[ValueNS].pop();\n         if anonymous_module.is_some() {\n             self.ribs[TypeNS].pop();\n         }"}, {"sha": "49bbe37ee4328ad5dadd9ae79c87a7ded364dcd0", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -623,6 +623,22 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                 return (true, candidates);\n             }\n         }\n+\n+        // Try to find in last block rib\n+        if let Some(rib) = &self.last_block_rib && let RibKind::NormalRibKind = rib.kind {\n+            for (ident, &res) in &rib.bindings {\n+                if let Res::Local(_) = res && path.len() == 1 &&\n+                    ident.span.eq_ctxt(path[0].ident.span) &&\n+                    ident.name == path[0].ident.name {\n+                    err.span_help(\n+                        ident.span,\n+                        &format!(\"the binding `{}` is available in a different scope in the same function\", path_str),\n+                    );\n+                    return (true, candidates);\n+                }\n+            }\n+        }\n+\n         return (false, candidates);\n     }\n "}, {"sha": "a4e0f54d27670d474a8e96a5db415c25ae090b3d", "filename": "compiler/rustc_span/src/source_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -1150,7 +1150,7 @@ impl FilePathMapping {\n             // NOTE: We are iterating over the mapping entries from last to first\n             //       because entries specified later on the command line should\n             //       take precedence.\n-            for &(ref from, ref to) in mapping.iter().rev() {\n+            for (from, to) in mapping.iter().rev() {\n                 debug!(\"Trying to apply {from:?} => {to:?}\");\n \n                 if let Ok(rest) = path.strip_prefix(from) {"}, {"sha": "cb373d657721bf53758eff0aa91355bf5eaf8b9a", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/method_chain.rs", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmethod_chain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmethod_chain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmethod_chain.rs?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -0,0 +1,74 @@\n+use crate::infer::InferCtxt;\n+\n+use rustc_middle::ty::error::TypeError;\n+use rustc_middle::ty::relate::{self, Relate, RelateResult, TypeRelation};\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n+\n+pub struct CollectAllMismatches<'a, 'tcx> {\n+    pub infcx: &'a InferCtxt<'tcx>,\n+    pub param_env: ty::ParamEnv<'tcx>,\n+    pub errors: Vec<TypeError<'tcx>>,\n+}\n+\n+impl<'a, 'tcx> TypeRelation<'tcx> for CollectAllMismatches<'a, 'tcx> {\n+    fn tag(&self) -> &'static str {\n+        \"CollectAllMismatches\"\n+    }\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.infcx.tcx\n+    }\n+    fn intercrate(&self) -> bool {\n+        false\n+    }\n+    fn param_env(&self) -> ty::ParamEnv<'tcx> {\n+        self.param_env\n+    }\n+    fn a_is_expected(&self) -> bool {\n+        true\n+    } // irrelevant\n+    fn mark_ambiguous(&mut self) {\n+        bug!()\n+    }\n+    fn relate_with_variance<T: Relate<'tcx>>(\n+        &mut self,\n+        _: ty::Variance,\n+        _: ty::VarianceDiagInfo<'tcx>,\n+        a: T,\n+        b: T,\n+    ) -> RelateResult<'tcx, T> {\n+        self.relate(a, b)\n+    }\n+    fn regions(\n+        &mut self,\n+        a: ty::Region<'tcx>,\n+        _b: ty::Region<'tcx>,\n+    ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n+        Ok(a)\n+    }\n+    fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+        if a == b || matches!(a.kind(), ty::Infer(_)) || matches!(b.kind(), ty::Infer(_)) {\n+            return Ok(a);\n+        }\n+        relate::super_relate_tys(self, a, b).or_else(|e| {\n+            self.errors.push(e);\n+            Ok(a)\n+        })\n+    }\n+    fn consts(\n+        &mut self,\n+        a: ty::Const<'tcx>,\n+        b: ty::Const<'tcx>,\n+    ) -> RelateResult<'tcx, ty::Const<'tcx>> {\n+        if a == b {\n+            return Ok(a);\n+        }\n+        relate::super_relate_consts(self, a, b) // could do something similar here for constants!\n+    }\n+    fn binders<T: Relate<'tcx>>(\n+        &mut self,\n+        a: ty::Binder<'tcx, T>,\n+        b: ty::Binder<'tcx, T>,\n+    ) -> RelateResult<'tcx, ty::Binder<'tcx, T>> {\n+        Ok(a.rebind(self.relate(a.skip_binder(), b.skip_binder())?))\n+    }\n+}"}, {"sha": "30ff07ee6c372b6df900d11c4f980d5adefe268f", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -1,4 +1,5 @@\n mod ambiguity;\n+pub mod method_chain;\n pub mod on_unimplemented;\n pub mod suggestions;\n \n@@ -536,7 +537,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             |err| {\n                 self.note_obligation_cause_code(\n                     err,\n-                    &predicate,\n+                    predicate,\n                     obligation.param_env,\n                     obligation.cause.code(),\n                     &mut vec![],\n@@ -1587,7 +1588,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 {\n                     self.note_obligation_cause_code(\n                         &mut diag,\n-                        &error.obligation.predicate,\n+                        error.obligation.predicate,\n                         error.obligation.param_env,\n                         code,\n                         &mut vec![],\n@@ -2602,7 +2603,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         if !self.maybe_note_obligation_cause_for_async_await(err, obligation) {\n             self.note_obligation_cause_code(\n                 err,\n-                &obligation.predicate,\n+                obligation.predicate,\n                 obligation.param_env,\n                 obligation.cause.code(),\n                 &mut vec![],"}, {"sha": "40c8102547112956468b8c18f39e5dc2ce9a85b3", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 342, "deletions": 59, "changes": 401, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -1,8 +1,9 @@\n+// ignore-tidy-filelength\n use super::{DefIdOrName, Obligation, ObligationCause, ObligationCauseCode, PredicateObligation};\n \n use crate::autoderef::Autoderef;\n use crate::infer::InferCtxt;\n-use crate::traits::NormalizeExt;\n+use crate::traits::{NormalizeExt, ObligationCtxt};\n \n use hir::def::CtorOf;\n use hir::HirId;\n@@ -22,17 +23,20 @@ use rustc_infer::infer::error_reporting::TypeErrCtxt;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{InferOk, LateBoundRegionConversionTime};\n use rustc_middle::hir::map;\n+use rustc_middle::ty::error::TypeError::{self, Sorts};\n+use rustc_middle::ty::relate::TypeRelation;\n use rustc_middle::ty::{\n     self, suggest_arbitrary_trait_bound, suggest_constraining_type_param, AdtKind, DefIdTree,\n-    GeneratorDiagnosticData, GeneratorInteriorTypeCause, Infer, InferTy, IsSuggestable,\n-    ToPredicate, Ty, TyCtxt, TypeFoldable, TypeFolder, TypeSuperFoldable, TypeVisitable,\n+    GeneratorDiagnosticData, GeneratorInteriorTypeCause, Infer, InferTy, InternalSubsts,\n+    IsSuggestable, ToPredicate, Ty, TyCtxt, TypeAndMut, TypeFoldable, TypeFolder,\n+    TypeSuperFoldable, TypeVisitable, TypeckResults,\n };\n-use rustc_middle::ty::{TypeAndMut, TypeckResults};\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{BytePos, DesugaringKind, ExpnKind, Span, DUMMY_SP};\n use rustc_target::spec::abi;\n-use std::fmt;\n+use std::ops::Deref;\n \n+use super::method_chain::CollectAllMismatches;\n use super::InferCtxtPrivExt;\n use crate::infer::InferCtxtExt as _;\n use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n@@ -292,13 +296,13 @@ pub trait TypeErrCtxtExt<'tcx> {\n     fn note_obligation_cause_code<T>(\n         &self,\n         err: &mut Diagnostic,\n-        predicate: &T,\n+        predicate: T,\n         param_env: ty::ParamEnv<'tcx>,\n         cause_code: &ObligationCauseCode<'tcx>,\n         obligated_types: &mut Vec<Ty<'tcx>>,\n         seen_requirements: &mut FxHashSet<DefId>,\n     ) where\n-        T: fmt::Display + ToPredicate<'tcx>;\n+        T: ToPredicate<'tcx>;\n \n     /// Suggest to await before try: future? => future.await?\n     fn suggest_await_before_try(\n@@ -329,6 +333,23 @@ pub trait TypeErrCtxtExt<'tcx> {\n         err: &mut Diagnostic,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n     );\n+    fn function_argument_obligation(\n+        &self,\n+        arg_hir_id: HirId,\n+        err: &mut Diagnostic,\n+        parent_code: &ObligationCauseCode<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        predicate: ty::Predicate<'tcx>,\n+        call_hir_id: HirId,\n+    );\n+    fn point_at_chain(\n+        &self,\n+        expr: &hir::Expr<'_>,\n+        typeck_results: &TypeckResults<'tcx>,\n+        type_diffs: Vec<TypeError<'tcx>>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        err: &mut Diagnostic,\n+    );\n }\n \n fn predicate_constraint(generics: &hir::Generics<'_>, pred: ty::Predicate<'_>) -> (Span, String) {\n@@ -2336,7 +2357,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         debug!(?next_code);\n         self.note_obligation_cause_code(\n             err,\n-            &obligation.predicate,\n+            obligation.predicate,\n             obligation.param_env,\n             next_code.unwrap(),\n             &mut Vec::new(),\n@@ -2347,15 +2368,16 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n     fn note_obligation_cause_code<T>(\n         &self,\n         err: &mut Diagnostic,\n-        predicate: &T,\n+        predicate: T,\n         param_env: ty::ParamEnv<'tcx>,\n         cause_code: &ObligationCauseCode<'tcx>,\n         obligated_types: &mut Vec<Ty<'tcx>>,\n         seen_requirements: &mut FxHashSet<DefId>,\n     ) where\n-        T: fmt::Display + ToPredicate<'tcx>,\n+        T: ToPredicate<'tcx>,\n     {\n         let tcx = self.tcx;\n+        let predicate = predicate.to_predicate(tcx);\n         match *cause_code {\n             ObligationCauseCode::ExprAssignable\n             | ObligationCauseCode::MatchExpressionArm { .. }\n@@ -2390,12 +2412,11 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 err.note(\"only the last element of a tuple may have a dynamically sized type\");\n             }\n             ObligationCauseCode::ProjectionWf(data) => {\n-                err.note(&format!(\"required so that the projection `{}` is well-formed\", data,));\n+                err.note(&format!(\"required so that the projection `{data}` is well-formed\"));\n             }\n             ObligationCauseCode::ReferenceOutlivesReferent(ref_ty) => {\n                 err.note(&format!(\n-                    \"required so that reference `{}` does not outlive its referent\",\n-                    ref_ty,\n+                    \"required so that reference `{ref_ty}` does not outlive its referent\"\n                 ));\n             }\n             ObligationCauseCode::ObjectTypeBound(object_ty, region) => {\n@@ -2689,7 +2710,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     ensure_sufficient_stack(|| {\n                         self.note_obligation_cause_code(\n                             err,\n-                            &parent_predicate,\n+                            parent_predicate,\n                             param_env,\n                             &data.parent_code,\n                             obligated_types,\n@@ -2700,7 +2721,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     ensure_sufficient_stack(|| {\n                         self.note_obligation_cause_code(\n                             err,\n-                            &parent_predicate,\n+                            parent_predicate,\n                             param_env,\n                             cause_code.peel_derives(),\n                             obligated_types,\n@@ -2809,7 +2830,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 ensure_sufficient_stack(|| {\n                     self.note_obligation_cause_code(\n                         err,\n-                        &parent_predicate,\n+                        parent_predicate,\n                         param_env,\n                         &data.parent_code,\n                         obligated_types,\n@@ -2824,7 +2845,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 ensure_sufficient_stack(|| {\n                     self.note_obligation_cause_code(\n                         err,\n-                        &parent_predicate,\n+                        parent_predicate,\n                         param_env,\n                         &data.parent_code,\n                         obligated_types,\n@@ -2837,43 +2858,14 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 call_hir_id,\n                 ref parent_code,\n             } => {\n-                let hir = self.tcx.hir();\n-                if let Some(Node::Expr(expr @ hir::Expr { kind: hir::ExprKind::Block(..), .. })) =\n-                    hir.find(arg_hir_id)\n-                {\n-                    let parent_id = hir.get_parent_item(arg_hir_id);\n-                    let typeck_results: &TypeckResults<'tcx> = match &self.typeck_results {\n-                        Some(t) if t.hir_owner == parent_id => t,\n-                        _ => self.tcx.typeck(parent_id.def_id),\n-                    };\n-                    let expr = expr.peel_blocks();\n-                    let ty = typeck_results.expr_ty_adjusted_opt(expr).unwrap_or(tcx.ty_error());\n-                    let span = expr.span;\n-                    if Some(span) != err.span.primary_span() {\n-                        err.span_label(\n-                            span,\n-                            if ty.references_error() {\n-                                String::new()\n-                            } else {\n-                                format!(\"this tail expression is of type `{:?}`\", ty)\n-                            },\n-                        );\n-                    }\n-                }\n-                if let Some(Node::Expr(hir::Expr {\n-                    kind:\n-                        hir::ExprKind::Call(hir::Expr { span, .. }, _)\n-                        | hir::ExprKind::MethodCall(\n-                            hir::PathSegment { ident: Ident { span, .. }, .. },\n-                            ..,\n-                        ),\n-                    ..\n-                })) = hir.find(call_hir_id)\n-                {\n-                    if Some(*span) != err.span.primary_span() {\n-                        err.span_label(*span, \"required by a bound introduced by this call\");\n-                    }\n-                }\n+                self.function_argument_obligation(\n+                    arg_hir_id,\n+                    err,\n+                    parent_code,\n+                    param_env,\n+                    predicate,\n+                    call_hir_id,\n+                );\n                 ensure_sufficient_stack(|| {\n                     self.note_obligation_cause_code(\n                         err,\n@@ -2888,9 +2880,8 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             ObligationCauseCode::CompareImplItemObligation { trait_item_def_id, kind, .. } => {\n                 let item_name = self.tcx.item_name(trait_item_def_id);\n                 let msg = format!(\n-                    \"the requirement `{}` appears on the `impl`'s {kind} `{}` but not on the \\\n-                     corresponding trait's {kind}\",\n-                    predicate, item_name,\n+                    \"the requirement `{predicate}` appears on the `impl`'s {kind} \\\n+                     `{item_name}` but not on the corresponding trait's {kind}\",\n                 );\n                 let sp = self\n                     .tcx\n@@ -2900,7 +2891,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 let mut assoc_span: MultiSpan = sp.into();\n                 assoc_span.push_span_label(\n                     sp,\n-                    format!(\"this trait's {kind} doesn't have the requirement `{}`\", predicate),\n+                    format!(\"this trait's {kind} doesn't have the requirement `{predicate}`\"),\n                 );\n                 if let Some(ident) = self\n                     .tcx\n@@ -2919,7 +2910,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             }\n             ObligationCauseCode::OpaqueReturnType(expr_info) => {\n                 if let Some((expr_ty, expr_span)) = expr_info {\n-                    let expr_ty = self.resolve_vars_if_possible(expr_ty);\n+                    let expr_ty = with_forced_trimmed_paths!(self.ty_to_string(expr_ty));\n                     err.span_label(\n                         expr_span,\n                         format!(\"return type was inferred to be `{expr_ty}` here\"),\n@@ -3099,6 +3090,298 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             );\n         }\n     }\n+    fn function_argument_obligation(\n+        &self,\n+        arg_hir_id: HirId,\n+        err: &mut Diagnostic,\n+        parent_code: &ObligationCauseCode<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        predicate: ty::Predicate<'tcx>,\n+        call_hir_id: HirId,\n+    ) {\n+        let tcx = self.tcx;\n+        let hir = tcx.hir();\n+        if let Some(Node::Expr(expr)) = hir.find(arg_hir_id) {\n+            let parent_id = hir.get_parent_item(arg_hir_id);\n+            let typeck_results: &TypeckResults<'tcx> = match &self.typeck_results {\n+                Some(t) if t.hir_owner == parent_id => t,\n+                _ => self.tcx.typeck(parent_id.def_id),\n+            };\n+            if let hir::Expr { kind: hir::ExprKind::Block(..), .. } = expr {\n+                let expr = expr.peel_blocks();\n+                let ty = typeck_results.expr_ty_adjusted_opt(expr).unwrap_or(tcx.ty_error());\n+                let span = expr.span;\n+                if Some(span) != err.span.primary_span() {\n+                    err.span_label(\n+                        span,\n+                        if ty.references_error() {\n+                            String::new()\n+                        } else {\n+                            let ty = with_forced_trimmed_paths!(self.ty_to_string(ty));\n+                            format!(\"this tail expression is of type `{ty}`\")\n+                        },\n+                    );\n+                }\n+            }\n+\n+            // FIXME: visit the ty to see if there's any closure involved, and if there is,\n+            // check whether its evaluated return type is the same as the one corresponding\n+            // to an associated type (as seen from `trait_pred`) in the predicate. Like in\n+            // trait_pred `S: Sum<<Self as Iterator>::Item>` and predicate `i32: Sum<&()>`\n+            let mut type_diffs = vec![];\n+\n+            if let ObligationCauseCode::ExprBindingObligation(def_id, _, _, idx) = parent_code.deref()\n+                && let predicates = self.tcx.predicates_of(def_id).instantiate_identity(self.tcx)\n+                && let Some(pred) = predicates.predicates.get(*idx)\n+                && let Ok(trait_pred) = pred.kind().try_map_bound(|pred| match pred {\n+                    ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred)) => Ok(trait_pred),\n+                    _ => Err(()),\n+                })\n+            {\n+                let mut c = CollectAllMismatches {\n+                    infcx: self.infcx,\n+                    param_env,\n+                    errors: vec![],\n+                };\n+                if let Ok(trait_predicate) = predicate.kind().try_map_bound(|pred| match pred {\n+                    ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred)) => Ok(trait_pred),\n+                    _ => Err(()),\n+                }) {\n+                    if let Ok(_) = c.relate(trait_pred, trait_predicate) {\n+                        type_diffs = c.errors;\n+                    }\n+                }\n+            }\n+            if let hir::ExprKind::Path(hir::QPath::Resolved(None, path)) = expr.kind\n+                && let hir::Path { res: hir::def::Res::Local(hir_id), .. } = path\n+                && let Some(hir::Node::Pat(binding)) = self.tcx.hir().find(*hir_id)\n+                && let parent_hir_id = self.tcx.hir().get_parent_node(binding.hir_id)\n+                && let Some(hir::Node::Local(local)) = self.tcx.hir().find(parent_hir_id)\n+                && let Some(binding_expr) = local.init\n+            {\n+                // If the expression we're calling on is a binding, we want to point at the\n+                // `let` when talking about the type. Otherwise we'll point at every part\n+                // of the method chain with the type.\n+                self.point_at_chain(binding_expr, typeck_results, type_diffs, param_env, err);\n+            } else {\n+                self.point_at_chain(expr, typeck_results, type_diffs, param_env, err);\n+            }\n+        }\n+        let call_node = hir.find(call_hir_id);\n+        if let Some(Node::Expr(hir::Expr {\n+            kind: hir::ExprKind::MethodCall(path, rcvr, ..), ..\n+        })) = call_node\n+        {\n+            if Some(rcvr.span) == err.span.primary_span() {\n+                err.replace_span_with(path.ident.span);\n+            }\n+        }\n+        if let Some(Node::Expr(hir::Expr {\n+            kind:\n+                hir::ExprKind::Call(hir::Expr { span, .. }, _)\n+                | hir::ExprKind::MethodCall(hir::PathSegment { ident: Ident { span, .. }, .. }, ..),\n+            ..\n+        })) = hir.find(call_hir_id)\n+        {\n+            if Some(*span) != err.span.primary_span() {\n+                err.span_label(*span, \"required by a bound introduced by this call\");\n+            }\n+        }\n+    }\n+\n+    fn point_at_chain(\n+        &self,\n+        expr: &hir::Expr<'_>,\n+        typeck_results: &TypeckResults<'tcx>,\n+        type_diffs: Vec<TypeError<'tcx>>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        err: &mut Diagnostic,\n+    ) {\n+        let mut primary_spans = vec![];\n+        let mut span_labels = vec![];\n+\n+        let tcx = self.tcx;\n+\n+        let mut assocs = vec![];\n+        // We still want to point at the different methods even if there hasn't\n+        // been a change of assoc type.\n+        let mut call_spans = vec![];\n+        let mut expr = expr;\n+        let mut prev_ty = self.resolve_vars_if_possible(\n+            typeck_results.expr_ty_adjusted_opt(expr).unwrap_or(tcx.ty_error()),\n+        );\n+        while let hir::ExprKind::MethodCall(_path_segment, rcvr_expr, _args, span) = expr.kind {\n+            // Point at every method call in the chain with the resulting type.\n+            // vec![1, 2, 3].iter().map(mapper).sum<i32>()\n+            //               ^^^^^^ ^^^^^^^^^^^\n+            expr = rcvr_expr;\n+            let mut assocs_in_this_method = Vec::with_capacity(type_diffs.len());\n+            call_spans.push(span);\n+\n+            let ocx = ObligationCtxt::new_in_snapshot(self.infcx);\n+            for diff in &type_diffs {\n+                let Sorts(expected_found) = diff else { continue; };\n+                let ty::Projection(proj) = expected_found.expected.kind() else { continue; };\n+\n+                let origin =\n+                    TypeVariableOrigin { kind: TypeVariableOriginKind::TypeInference, span };\n+                let trait_def_id = proj.trait_def_id(self.tcx);\n+                // Make `Self` be equivalent to the type of the call chain\n+                // expression we're looking at now, so that we can tell what\n+                // for example `Iterator::Item` is at this point in the chain.\n+                let substs = InternalSubsts::for_item(self.tcx, trait_def_id, |param, _| {\n+                    match param.kind {\n+                        ty::GenericParamDefKind::Type { .. } => {\n+                            if param.index == 0 {\n+                                return prev_ty.into();\n+                            }\n+                        }\n+                        ty::GenericParamDefKind::Lifetime\n+                        | ty::GenericParamDefKind::Const { .. } => {}\n+                    }\n+                    self.var_for_def(span, param)\n+                });\n+                // This will hold the resolved type of the associated type, if the\n+                // current expression implements the trait that associated type is\n+                // in. For example, this would be what `Iterator::Item` is here.\n+                let ty_var = self.infcx.next_ty_var(origin);\n+                // This corresponds to `<ExprTy as Iterator>::Item = _`.\n+                let trait_ref = ty::Binder::dummy(ty::PredicateKind::Clause(\n+                    ty::Clause::Projection(ty::ProjectionPredicate {\n+                        projection_ty: ty::ProjectionTy { substs, item_def_id: proj.item_def_id },\n+                        term: ty_var.into(),\n+                    }),\n+                ));\n+                // Add `<ExprTy as Iterator>::Item = _` obligation.\n+                ocx.register_obligation(Obligation::misc(\n+                    self.tcx,\n+                    span,\n+                    expr.hir_id,\n+                    param_env,\n+                    trait_ref,\n+                ));\n+                if ocx.select_where_possible().is_empty() {\n+                    // `ty_var` now holds the type that `Item` is for `ExprTy`.\n+                    let ty_var = self.resolve_vars_if_possible(ty_var);\n+                    assocs_in_this_method.push(Some((span, (proj.item_def_id, ty_var))));\n+                } else {\n+                    // `<ExprTy as Iterator>` didn't select, so likely we've\n+                    // reached the end of the iterator chain, like the originating\n+                    // `Vec<_>`.\n+                    // Keep the space consistent for later zipping.\n+                    assocs_in_this_method.push(None);\n+                }\n+            }\n+            assocs.push(assocs_in_this_method);\n+            prev_ty = self.resolve_vars_if_possible(\n+                typeck_results.expr_ty_adjusted_opt(expr).unwrap_or(tcx.ty_error()),\n+            );\n+\n+            if let hir::ExprKind::Path(hir::QPath::Resolved(None, path)) = expr.kind\n+                && let hir::Path { res: hir::def::Res::Local(hir_id), .. } = path\n+                && let Some(hir::Node::Pat(binding)) = self.tcx.hir().find(*hir_id)\n+                && let parent_hir_id = self.tcx.hir().get_parent_node(binding.hir_id)\n+                && let Some(hir::Node::Local(local)) = self.tcx.hir().find(parent_hir_id)\n+                && let Some(binding_expr) = local.init\n+            {\n+                // We've reached the root of the method call chain and it is a\n+                // binding. Get the binding creation and try to continue the chain.\n+                expr = binding_expr;\n+            }\n+        }\n+        // We want the type before deref coercions, otherwise we talk about `&[_]`\n+        // instead of `Vec<_>`.\n+        if let Some(ty) = typeck_results.expr_ty_opt(expr) {\n+            let ty = with_forced_trimmed_paths!(self.ty_to_string(ty));\n+            // Point at the root expression\n+            // vec![1, 2, 3].iter().map(mapper).sum<i32>()\n+            // ^^^^^^^^^^^^^\n+            span_labels.push((expr.span, format!(\"this expression has type `{ty}`\")));\n+        };\n+        // Only show this if it is not a \"trivial\" expression (not a method\n+        // chain) and there are associated types to talk about.\n+        let mut assocs = assocs.into_iter().peekable();\n+        while let Some(assocs_in_method) = assocs.next() {\n+            let Some(prev_assoc_in_method) = assocs.peek() else {\n+                for entry in assocs_in_method {\n+                    let Some((span, (assoc, ty))) = entry else { continue; };\n+                    if type_diffs.iter().any(|diff| {\n+                        let Sorts(expected_found) = diff else { return false; };\n+                        self.can_eq(param_env, expected_found.found, ty).is_ok()\n+                    }) {\n+                        // FIXME: this doesn't quite work for `Iterator::collect`\n+                        // because we have `Vec<i32>` and `()`, but we'd want `i32`\n+                        // to point at the `.into_iter()` call, but as long as we\n+                        // still point at the other method calls that might have\n+                        // introduced the issue, this is fine for now.\n+                        primary_spans.push(span);\n+                    }\n+                    span_labels.push((\n+                        span,\n+                        with_forced_trimmed_paths!(format!(\n+                            \"`{}` is `{ty}` here\",\n+                            self.tcx.def_path_str(assoc),\n+                        )),\n+                    ));\n+                }\n+                break;\n+            };\n+            for (entry, prev_entry) in\n+                assocs_in_method.into_iter().zip(prev_assoc_in_method.into_iter())\n+            {\n+                match (entry, prev_entry) {\n+                    (Some((span, (assoc, ty))), Some((_, (_, prev_ty)))) => {\n+                        let ty_str = with_forced_trimmed_paths!(self.ty_to_string(ty));\n+\n+                        let assoc = with_forced_trimmed_paths!(self.tcx.def_path_str(assoc));\n+                        if ty != *prev_ty {\n+                            if type_diffs.iter().any(|diff| {\n+                                let Sorts(expected_found) = diff else { return false; };\n+                                self.can_eq(param_env, expected_found.found, ty).is_ok()\n+                            }) {\n+                                primary_spans.push(span);\n+                            }\n+                            span_labels\n+                                .push((span, format!(\"`{assoc}` changed to `{ty_str}` here\")));\n+                        } else {\n+                            span_labels.push((span, format!(\"`{assoc}` remains `{ty_str}` here\")));\n+                        }\n+                    }\n+                    (Some((span, (assoc, ty))), None) => {\n+                        span_labels.push((\n+                            span,\n+                            with_forced_trimmed_paths!(format!(\n+                                \"`{}` is `{}` here\",\n+                                self.tcx.def_path_str(assoc),\n+                                self.ty_to_string(ty),\n+                            )),\n+                        ));\n+                    }\n+                    (None, Some(_)) | (None, None) => {}\n+                }\n+            }\n+        }\n+        for span in call_spans {\n+            if span_labels.iter().find(|(s, _)| *s == span).is_none() {\n+                // Ensure we are showing the entire chain, even if the assoc types\n+                // haven't changed.\n+                span_labels.push((span, String::new()));\n+            }\n+        }\n+        if !primary_spans.is_empty() {\n+            let mut multi_span: MultiSpan = primary_spans.into();\n+            for (span, label) in span_labels {\n+                multi_span.push_span_label(span, label);\n+            }\n+            err.span_note(\n+                multi_span,\n+                format!(\n+                    \"the method call chain might not have had the expected \\\n+                                     associated types\",\n+                ),\n+            );\n+        }\n+    }\n }\n \n /// Collect all the returned expressions within the input expression."}, {"sha": "3cb0eccd324d42574b082e4c1af721ada6a6bb77", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 31, "deletions": 25, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -1470,7 +1470,7 @@ impl Step for Extended {\n \n         let xform = |p: &Path| {\n             let mut contents = t!(fs::read_to_string(p));\n-            for tool in &[\"rust-demangler\"] {\n+            for tool in &[\"rust-demangler\", \"miri\"] {\n                 if !built_tools.contains(tool) {\n                     contents = filter(&contents, tool);\n                 }\n@@ -1510,9 +1510,8 @@ impl Step for Extended {\n             prepare(\"rust-std\");\n             prepare(\"rust-analysis\");\n             prepare(\"clippy\");\n-            prepare(\"miri\");\n             prepare(\"rust-analyzer\");\n-            for tool in &[\"rust-docs\", \"rust-demangler\"] {\n+            for tool in &[\"rust-docs\", \"rust-demangler\", \"miri\"] {\n                 if built_tools.contains(tool) {\n                     prepare(tool);\n                 }\n@@ -1571,9 +1570,8 @@ impl Step for Extended {\n             prepare(\"rust-docs\");\n             prepare(\"rust-std\");\n             prepare(\"clippy\");\n-            prepare(\"miri\");\n             prepare(\"rust-analyzer\");\n-            for tool in &[\"rust-demangler\"] {\n+            for tool in &[\"rust-demangler\", \"miri\"] {\n                 if built_tools.contains(tool) {\n                     prepare(tool);\n                 }\n@@ -1710,23 +1708,25 @@ impl Step for Extended {\n                         .arg(etc.join(\"msi/remove-duplicates.xsl\")),\n                 );\n             }\n-            builder.run(\n-                Command::new(&heat)\n-                    .current_dir(&exe)\n-                    .arg(\"dir\")\n-                    .arg(\"miri\")\n-                    .args(&heat_flags)\n-                    .arg(\"-cg\")\n-                    .arg(\"MiriGroup\")\n-                    .arg(\"-dr\")\n-                    .arg(\"Miri\")\n-                    .arg(\"-var\")\n-                    .arg(\"var.MiriDir\")\n-                    .arg(\"-out\")\n-                    .arg(exe.join(\"MiriGroup.wxs\"))\n-                    .arg(\"-t\")\n-                    .arg(etc.join(\"msi/remove-duplicates.xsl\")),\n-            );\n+            if built_tools.contains(\"miri\") {\n+                builder.run(\n+                    Command::new(&heat)\n+                        .current_dir(&exe)\n+                        .arg(\"dir\")\n+                        .arg(\"miri\")\n+                        .args(&heat_flags)\n+                        .arg(\"-cg\")\n+                        .arg(\"MiriGroup\")\n+                        .arg(\"-dr\")\n+                        .arg(\"Miri\")\n+                        .arg(\"-var\")\n+                        .arg(\"var.MiriDir\")\n+                        .arg(\"-out\")\n+                        .arg(exe.join(\"MiriGroup.wxs\"))\n+                        .arg(\"-t\")\n+                        .arg(etc.join(\"msi/remove-duplicates.xsl\")),\n+                );\n+            }\n             builder.run(\n                 Command::new(&heat)\n                     .current_dir(&exe)\n@@ -1774,7 +1774,6 @@ impl Step for Extended {\n                     .arg(\"-dStdDir=rust-std\")\n                     .arg(\"-dAnalysisDir=rust-analysis\")\n                     .arg(\"-dClippyDir=clippy\")\n-                    .arg(\"-dMiriDir=miri\")\n                     .arg(\"-arch\")\n                     .arg(&arch)\n                     .arg(\"-out\")\n@@ -1788,6 +1787,9 @@ impl Step for Extended {\n                 if built_tools.contains(\"rust-analyzer\") {\n                     cmd.arg(\"-dRustAnalyzerDir=rust-analyzer\");\n                 }\n+                if built_tools.contains(\"miri\") {\n+                    cmd.arg(\"-dMiriDir=miri\");\n+                }\n                 if target.ends_with(\"windows-gnu\") {\n                     cmd.arg(\"-dGccDir=rust-mingw\");\n                 }\n@@ -1801,7 +1803,9 @@ impl Step for Extended {\n             candle(\"CargoGroup.wxs\".as_ref());\n             candle(\"StdGroup.wxs\".as_ref());\n             candle(\"ClippyGroup.wxs\".as_ref());\n-            candle(\"MiriGroup.wxs\".as_ref());\n+            if built_tools.contains(\"miri\") {\n+                candle(\"MiriGroup.wxs\".as_ref());\n+            }\n             if built_tools.contains(\"rust-demangler\") {\n                 candle(\"RustDemanglerGroup.wxs\".as_ref());\n             }\n@@ -1837,9 +1841,11 @@ impl Step for Extended {\n                 .arg(\"StdGroup.wixobj\")\n                 .arg(\"AnalysisGroup.wixobj\")\n                 .arg(\"ClippyGroup.wixobj\")\n-                .arg(\"MiriGroup.wixobj\")\n                 .current_dir(&exe);\n \n+            if built_tools.contains(\"miri\") {\n+                cmd.arg(\"MiriGroup.wixobj\");\n+            }\n             if built_tools.contains(\"rust-analyzer\") {\n                 cmd.arg(\"RustAnalyzerGroup.wixobj\");\n             }"}, {"sha": "2f1f4cbf3592457e7972dc043e04e6b86f27c3ae", "filename": "src/librustdoc/formats/item_type.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Flibrustdoc%2Fformats%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Flibrustdoc%2Fformats%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fitem_type.rs?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -177,6 +177,9 @@ impl ItemType {\n             ItemType::TraitAlias => \"traitalias\",\n         }\n     }\n+    pub(crate) fn is_method(&self) -> bool {\n+        matches!(*self, ItemType::Method | ItemType::TyMethod)\n+    }\n }\n \n impl fmt::Display for ItemType {"}, {"sha": "d4d3e4f6ea7952c0399ca2c3e5066d361b222e64", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -637,7 +637,7 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n                             You need to enable Javascript be able to update your settings.\\\n                         </section>\\\n                      </noscript>\\\n-                     <link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" \\\n+                     <link rel=\\\"stylesheet\\\" \\\n                          href=\\\"{static_root_path}{settings_css}\\\">\\\n                      <script defer src=\\\"{static_root_path}{settings_js}\\\"></script>\",\n                     static_root_path = page.get_static_root_path(),"}, {"sha": "80fbe9c1f066c6dbc139027e4235475f15318674", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -1512,8 +1512,7 @@ fn render_impl(\n \n         let toggled = !doc_buffer.is_empty();\n         if toggled {\n-            let method_toggle_class =\n-                if item_type == ItemType::Method { \" method-toggle\" } else { \"\" };\n+            let method_toggle_class = if item_type.is_method() { \" method-toggle\" } else { \"\" };\n             write!(w, \"<details class=\\\"rustdoc-toggle{}\\\" open><summary>\", method_toggle_class);\n         }\n         match &*item.kind {"}, {"sha": "a7b57c373e3bec3b4a9219758d8d020f2b1a0642", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -732,7 +732,8 @@ fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean:\n         document(&mut content, cx, m, Some(t), HeadingOffset::H5);\n         let toggled = !content.is_empty();\n         if toggled {\n-            write!(w, \"<details class=\\\"rustdoc-toggle method-toggle\\\" open><summary>\");\n+            let method_toggle_class = if item_type.is_method() { \" method-toggle\" } else { \"\" };\n+            write!(w, \"<details class=\\\"rustdoc-toggle{method_toggle_class}\\\" open><summary>\");\n         }\n         write!(w, \"<section id=\\\"{}\\\" class=\\\"method has-srclink\\\">\", id);\n         render_rightside(w, cx, m, t, RenderMode::Normal);"}, {"sha": "3f97e4e2e39f05ffbcb47f3f4329f952e69bd4e9", "filename": "src/librustdoc/html/static/js/main.js", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -184,7 +184,6 @@ function browserSupportsHistoryApi() {\n function loadCss(cssUrl) {\n     const link = document.createElement(\"link\");\n     link.href = cssUrl;\n-    link.type = \"text/css\";\n     link.rel = \"stylesheet\";\n     document.getElementsByTagName(\"head\")[0].appendChild(link);\n }"}, {"sha": "5f4ad6d2aea345073d79b30dcf5baf38dbfeeda8", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -53,7 +53,7 @@ pub(crate) fn render<P: AsRef<Path>>(\n \n     let mut css = String::new();\n     for name in &options.markdown_css {\n-        write!(css, r#\"<link rel=\"stylesheet\" type=\"text/css\" href=\"{name}\">\"#)\n+        write!(css, r#\"<link rel=\"stylesheet\" href=\"{name}\">\"#)\n             .expect(\"Writing to a String can't fail\");\n     }\n "}, {"sha": "b094c483876410365962462bcc910734c8492814", "filename": "src/test/rustdoc-gui/docblock-code-block-line-number.goml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Frustdoc-gui%2Fdocblock-code-block-line-number.goml", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Frustdoc-gui%2Fdocblock-code-block-line-number.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fdocblock-code-block-line-number.goml?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -33,7 +33,9 @@ assert-css: (\"#settings\", {\"display\": \"block\"})\n click: \"input#line-numbers\"\n wait-for: 100 // wait-for-false does not exist\n assert-false: \"pre.example-line-numbers\"\n+assert-local-storage: {\"rustdoc-line-numbers\": \"false\" }\n \n // Finally, turn it on again.\n click: \"input#line-numbers\"\n wait-for: \"pre.example-line-numbers\"\n+assert-local-storage: {\"rustdoc-line-numbers\": \"true\" }"}, {"sha": "0a1f088b9ab5c8fb830f55120be7a6fb3d6b2f64", "filename": "src/test/rustdoc/toggle-trait-fn.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Frustdoc%2Ftoggle-trait-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Frustdoc%2Ftoggle-trait-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Ftoggle-trait-fn.rs?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -4,13 +4,20 @@\n // summary. Trait methods with no documentation should not be wrapped.\n //\n // @has foo/trait.Foo.html\n+// @has - '//details[@class=\"rustdoc-toggle\"]//summary//h4[@class=\"code-header\"]' 'type Item'\n+// @!has - '//details[@class=\"rustdoc-toggle\"]//summary//h4[@class=\"code-header\"]' 'type Item2'\n // @has -  '//details[@class=\"rustdoc-toggle method-toggle\"]//summary//h4[@class=\"code-header\"]' 'is_documented()'\n // @!has - '//details[@class=\"rustdoc-toggle method-toggle\"]//summary//h4[@class=\"code-header\"]' 'not_documented()'\n // @has -  '//details[@class=\"rustdoc-toggle method-toggle\"]//*[@class=\"docblock\"]' 'is_documented is documented'\n // @has -  '//details[@class=\"rustdoc-toggle method-toggle\"]//summary//h4[@class=\"code-header\"]' 'is_documented_optional()'\n // @!has - '//details[@class=\"rustdoc-toggle method-toggle\"]//summary//h4[@class=\"code-header\"]' 'not_documented_optional()'\n // @has -  '//details[@class=\"rustdoc-toggle method-toggle\"]//*[@class=\"docblock\"]' 'is_documented_optional is documented'\n pub trait Foo {\n+    /// is documented\n+    type Item;\n+\n+    type Item2;\n+\n     fn not_documented();\n \n     /// is_documented is documented"}, {"sha": "c7ed8e0de384ce5eb3655f8b9bc8e2f39e99429a", "filename": "src/test/ui/expr/malformed_closure/ruby_style_closure.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Fexpr%2Fmalformed_closure%2Fruby_style_closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Fexpr%2Fmalformed_closure%2Fruby_style_closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexpr%2Fmalformed_closure%2Fruby_style_closure.stderr?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -14,7 +14,7 @@ LL |       let p = Some(45).and_then({\n LL | |\n LL | |         |x| println!(\"doubling {}\", x);\n LL | |         Some(x * 2)\n-   | |         ----------- this tail expression is of type `std::option::Option<_>`\n+   | |         ----------- this tail expression is of type `Option<_>`\n LL | |\n LL | |     });\n    | |_____^ expected an `FnOnce<({integer},)>` closure, found `Option<_>`"}, {"sha": "422ac5484271d519b82c04d253ef709720b9178a", "filename": "src/test/ui/generic-associated-types/issue-101020.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-101020.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-101020.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-101020.stderr?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -1,10 +1,8 @@\n error[E0277]: the trait bound `for<'a> &'a mut (): Foo<&'a mut ()>` is not satisfied\n-  --> $DIR/issue-101020.rs:31:5\n+  --> $DIR/issue-101020.rs:31:22\n    |\n LL |     (&mut EmptyIter).consume(());\n-   |     ^^^^^^^^^^^^^^^^ ------- required by a bound introduced by this call\n-   |     |\n-   |     the trait `for<'a> Foo<&'a mut ()>` is not implemented for `&'a mut ()`\n+   |                      ^^^^^^^ the trait `for<'a> Foo<&'a mut ()>` is not implemented for `&'a mut ()`\n    |\n note: required for `&'a mut ()` to implement `for<'a> FuncInput<'a, &'a mut ()>`\n   --> $DIR/issue-101020.rs:27:20"}, {"sha": "d70bf6e1d921c3618744544c4763648cd8057d27", "filename": "src/test/ui/issues/issue-20162.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Fissues%2Fissue-20162.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Fissues%2Fissue-20162.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-20162.stderr?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -1,10 +1,8 @@\n error[E0277]: the trait bound `X: Ord` is not satisfied\n-  --> $DIR/issue-20162.rs:5:5\n+  --> $DIR/issue-20162.rs:5:7\n    |\n LL |     b.sort();\n-   |     ^ ---- required by a bound introduced by this call\n-   |     |\n-   |     the trait `Ord` is not implemented for `X`\n+   |       ^^^^ the trait `Ord` is not implemented for `X`\n    |\n note: required by a bound in `slice::<impl [T]>::sort`\n   --> $SRC_DIR/alloc/src/slice.rs:LL:COL"}, {"sha": "f678df5b42b60d927cf4386889a745d7a553e73a", "filename": "src/test/ui/issues/issue-31173.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Fissues%2Fissue-31173.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Fissues%2Fissue-31173.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-31173.rs?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -4,12 +4,11 @@ pub fn get_tok(it: &mut IntoIter<u8>) {\n     let mut found_e = false;\n \n     let temp: Vec<u8> = it\n-        //~^ ERROR to be an iterator that yields `&_`, but it yields `u8`\n         .take_while(|&x| {\n             found_e = true;\n             false\n         })\n-        .cloned()\n+        .cloned() //~ ERROR to be an iterator that yields `&_`, but it yields `u8`\n         .collect(); //~ ERROR the method\n }\n "}, {"sha": "62d841f37893f67f80161657c81bfe4b59179eb9", "filename": "src/test/ui/issues/issue-31173.stderr", "status": "modified", "additions": 12, "deletions": 20, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Fissues%2Fissue-31173.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Fissues%2Fissue-31173.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-31173.stderr?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -1,16 +1,8 @@\n-error[E0271]: expected `TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:8:21: 8:25]>` to be an iterator that yields `&_`, but it yields `u8`\n-  --> $DIR/issue-31173.rs:6:25\n-   |\n-LL |       let temp: Vec<u8> = it\n-   |  _________________________^\n-LL | |\n-LL | |         .take_while(|&x| {\n-LL | |             found_e = true;\n-LL | |             false\n-LL | |         })\n-   | |__________^ expected reference, found `u8`\n-LL |           .cloned()\n-   |            ------ required by a bound introduced by this call\n+error[E0271]: expected `TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:7:21: 7:25]>` to be an iterator that yields `&_`, but it yields `u8`\n+  --> $DIR/issue-31173.rs:11:10\n+   |\n+LL |         .cloned()\n+   |          ^^^^^^ expected reference, found `u8`\n    |\n    = note: expected reference `&_`\n                    found type `u8`\n@@ -20,11 +12,11 @@ note: required by a bound in `cloned`\n LL |         Self: Sized + Iterator<Item = &'a T>,\n    |                                ^^^^^^^^^^^^ required by this bound in `Iterator::cloned`\n \n-error[E0599]: the method `collect` exists for struct `Cloned<TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:8:21: 8:25]>>`, but its trait bounds were not satisfied\n-  --> $DIR/issue-31173.rs:13:10\n+error[E0599]: the method `collect` exists for struct `Cloned<TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:7:21: 7:25]>>`, but its trait bounds were not satisfied\n+  --> $DIR/issue-31173.rs:12:10\n    |\n LL |         .collect();\n-   |          ^^^^^^^ method cannot be called on `Cloned<TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:8:21: 8:25]>>` due to unsatisfied trait bounds\n+   |          ^^^^^^^ method cannot be called on `Cloned<TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:7:21: 7:25]>>` due to unsatisfied trait bounds\n    |\n   ::: $SRC_DIR/core/src/iter/adapters/take_while.rs:LL:COL\n    |\n@@ -37,10 +29,10 @@ LL | pub struct Cloned<I> {\n    | -------------------- doesn't satisfy `_: Iterator`\n    |\n    = note: the following trait bounds were not satisfied:\n-           `<TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:8:21: 8:25]> as Iterator>::Item = &_`\n-           which is required by `Cloned<TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:8:21: 8:25]>>: Iterator`\n-           `Cloned<TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:8:21: 8:25]>>: Iterator`\n-           which is required by `&mut Cloned<TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:8:21: 8:25]>>: Iterator`\n+           `<TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:7:21: 7:25]> as Iterator>::Item = &_`\n+           which is required by `Cloned<TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:7:21: 7:25]>>: Iterator`\n+           `Cloned<TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:7:21: 7:25]>>: Iterator`\n+           which is required by `&mut Cloned<TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:7:21: 7:25]>>: Iterator`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "73a9b786fe2b580d41982b38056ebb58474f42fe", "filename": "src/test/ui/issues/issue-33941.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Fissues%2Fissue-33941.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Fissues%2Fissue-33941.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-33941.stderr?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -1,10 +1,8 @@\n error[E0271]: expected `std::collections::hash_map::Iter<'_, _, _>` to be an iterator that yields `&_`, but it yields `(&_, &_)`\n-  --> $DIR/issue-33941.rs:6:14\n+  --> $DIR/issue-33941.rs:6:36\n    |\n LL |     for _ in HashMap::new().iter().cloned() {}\n-   |              ^^^^^^^^^^^^^^^^^^^^^ ------ required by a bound introduced by this call\n-   |              |\n-   |              expected reference, found tuple\n+   |                                    ^^^^^^ expected reference, found tuple\n    |\n    = note: expected reference `&_`\n                   found tuple `(&_, &_)`"}, {"sha": "b610e5c1366683b2838d0946fe4b01dbdeefdda4", "filename": "src/test/ui/issues/issue-34334.stderr", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Fissues%2Fissue-34334.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Fissues%2Fissue-34334.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-34334.stderr?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -13,15 +13,23 @@ LL |     let sr: Vec<(u32, _, _)> = vec![];\n    |                            +\n \n error[E0277]: a value of type `Vec<(u32, _, _)>` cannot be built from an iterator over elements of type `()`\n-  --> $DIR/issue-34334.rs:5:33\n+  --> $DIR/issue-34334.rs:5:87\n    |\n LL |     let sr2: Vec<(u32, _, _)> = sr.iter().map(|(faction, th_sender, th_receiver)| {}).collect();\n-   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ------- required by a bound introduced by this call\n-   |                                 |\n-   |                                 value of type `Vec<(u32, _, _)>` cannot be built from `std::iter::Iterator<Item=()>`\n+   |                                                                                       ^^^^^^^ value of type `Vec<(u32, _, _)>` cannot be built from `std::iter::Iterator<Item=()>`\n    |\n    = help: the trait `FromIterator<()>` is not implemented for `Vec<(u32, _, _)>`\n    = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n+note: the method call chain might not have had the expected associated types\n+  --> $DIR/issue-34334.rs:5:43\n+   |\n+LL |     let sr: Vec<(u32, _, _) = vec![];\n+   |                               ------ this expression has type `Vec<(_, _, _)>`\n+...\n+LL |     let sr2: Vec<(u32, _, _)> = sr.iter().map(|(faction, th_sender, th_receiver)| {}).collect();\n+   |                                    ------ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `Iterator::Item` changed to `()` here\n+   |                                    |\n+   |                                    `Iterator::Item` is `&(_, _, _)` here\n note: required by a bound in `collect`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n    |"}, {"sha": "c6352978613aa553849af5fb8938b41e80ce9cf9", "filename": "src/test/ui/issues/issue-66923-show-error-for-correct-call.stderr", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Fissues%2Fissue-66923-show-error-for-correct-call.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Fissues%2Fissue-66923-show-error-for-correct-call.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-66923-show-error-for-correct-call.stderr?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -1,29 +1,40 @@\n error[E0277]: a value of type `Vec<f64>` cannot be built from an iterator over elements of type `&f64`\n-  --> $DIR/issue-66923-show-error-for-correct-call.rs:8:24\n+  --> $DIR/issue-66923-show-error-for-correct-call.rs:8:39\n    |\n LL |     let x2: Vec<f64> = x1.into_iter().collect();\n-   |                        ^^^^^^^^^^^^^^ ------- required by a bound introduced by this call\n-   |                        |\n-   |                        value of type `Vec<f64>` cannot be built from `std::iter::Iterator<Item=&f64>`\n+   |                                       ^^^^^^^ value of type `Vec<f64>` cannot be built from `std::iter::Iterator<Item=&f64>`\n    |\n    = help: the trait `FromIterator<&f64>` is not implemented for `Vec<f64>`\n    = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n+note: the method call chain might not have had the expected associated types\n+  --> $DIR/issue-66923-show-error-for-correct-call.rs:8:27\n+   |\n+LL |     let x1: &[f64] = &v;\n+   |                      -- this expression has type `&Vec<f64>`\n+LL |     let x2: Vec<f64> = x1.into_iter().collect();\n+   |                           ^^^^^^^^^^^ `Iterator::Item` is `&f64` here\n note: required by a bound in `collect`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n    |\n LL |     fn collect<B: FromIterator<Self::Item>>(self) -> B\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `Iterator::collect`\n \n error[E0277]: a value of type `Vec<f64>` cannot be built from an iterator over elements of type `&f64`\n-  --> $DIR/issue-66923-show-error-for-correct-call.rs:12:14\n+  --> $DIR/issue-66923-show-error-for-correct-call.rs:12:29\n    |\n LL |     let x3 = x1.into_iter().collect::<Vec<f64>>();\n-   |              ^^^^^^^^^^^^^^ ------- required by a bound introduced by this call\n-   |              |\n-   |              value of type `Vec<f64>` cannot be built from `std::iter::Iterator<Item=&f64>`\n+   |                             ^^^^^^^ value of type `Vec<f64>` cannot be built from `std::iter::Iterator<Item=&f64>`\n    |\n    = help: the trait `FromIterator<&f64>` is not implemented for `Vec<f64>`\n    = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n+note: the method call chain might not have had the expected associated types\n+  --> $DIR/issue-66923-show-error-for-correct-call.rs:12:17\n+   |\n+LL |     let x1: &[f64] = &v;\n+   |                      -- this expression has type `&Vec<f64>`\n+...\n+LL |     let x3 = x1.into_iter().collect::<Vec<f64>>();\n+   |                 ^^^^^^^^^^^ `Iterator::Item` is `&f64` here\n note: required by a bound in `collect`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n    |"}, {"sha": "99d0d9bd735532bfc8a299ba1a7d9cde7a42dc0d", "filename": "src/test/ui/iterators/collect-into-array.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-array.rs?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -3,5 +3,4 @@ fn main() {\n     //~^ ERROR an array of type `[u32; 10]` cannot be built directly from an iterator\n     //~| NOTE try collecting into a `Vec<{integer}>`, then using `.try_into()`\n     //~| NOTE required by a bound in `collect`\n-    //~| NOTE required by a bound introduced by this call\n }"}, {"sha": "7a07fed1fae3af7ec3bdcd4188ed7e89b1454569", "filename": "src/test/ui/iterators/collect-into-array.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-array.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-array.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-array.stderr?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -1,10 +1,8 @@\n error[E0277]: an array of type `[u32; 10]` cannot be built directly from an iterator\n-  --> $DIR/collect-into-array.rs:2:31\n+  --> $DIR/collect-into-array.rs:2:39\n    |\n LL |     let whatever: [u32; 10] = (0..10).collect();\n-   |                               ^^^^^^^ ------- required by a bound introduced by this call\n-   |                               |\n-   |                               try collecting into a `Vec<{integer}>`, then using `.try_into()`\n+   |                                       ^^^^^^^ try collecting into a `Vec<{integer}>`, then using `.try_into()`\n    |\n    = help: the trait `FromIterator<{integer}>` is not implemented for `[u32; 10]`\n note: required by a bound in `collect`"}, {"sha": "5a8aacb1a6df0bc392290c051c300d638525cb7f", "filename": "src/test/ui/iterators/collect-into-slice.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-slice.rs?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -13,6 +13,5 @@ fn main() {\n     //~| NOTE all local variables must have a statically known size\n     //~| NOTE doesn't have a size known at compile-time\n     //~| NOTE doesn't have a size known at compile-time\n-    //~| NOTE required by a bound introduced by this call\n     process_slice(&some_generated_vec);\n }"}, {"sha": "58da222e0397b4172d442f259546c4f0f067e9be", "filename": "src/test/ui/iterators/collect-into-slice.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-slice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-slice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-slice.stderr?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -22,12 +22,10 @@ LL |     fn collect<B: FromIterator<Self::Item>>(self) -> B\n    |                ^ required by this bound in `Iterator::collect`\n \n error[E0277]: a slice of type `[i32]` cannot be built since `[i32]` has no definite size\n-  --> $DIR/collect-into-slice.rs:6:30\n+  --> $DIR/collect-into-slice.rs:6:38\n    |\n LL |     let some_generated_vec = (0..10).collect();\n-   |                              ^^^^^^^ ------- required by a bound introduced by this call\n-   |                              |\n-   |                              try explicitly collecting into a `Vec<{integer}>`\n+   |                                      ^^^^^^^ try explicitly collecting into a `Vec<{integer}>`\n    |\n    = help: the trait `FromIterator<{integer}>` is not implemented for `[i32]`\n note: required by a bound in `collect`"}, {"sha": "87116e49245703805c9867ac9db2dce04c287ac1", "filename": "src/test/ui/iterators/invalid-iterator-chain.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Fiterators%2Finvalid-iterator-chain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Fiterators%2Finvalid-iterator-chain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Finvalid-iterator-chain.rs?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -0,0 +1,41 @@\n+fn main() {\n+    let scores = vec![(0, 0)]\n+        .iter()\n+        .map(|(a, b)| {\n+            a + b;\n+        });\n+    println!(\"{}\", scores.sum::<i32>()); //~ ERROR E0277\n+    println!(\n+        \"{}\",\n+        vec![0, 1]\n+            .iter()\n+            .map(|x| x * 2)\n+            .map(|x| x as f64)\n+            .map(|x| x as i64)\n+            .filter(|x| *x > 0)\n+            .map(|x| { x + 1 })\n+            .map(|x| { x; })\n+            .sum::<i32>(), //~ ERROR E0277\n+    );\n+    println!(\n+        \"{}\",\n+        vec![0, 1]\n+            .iter()\n+            .map(|x| x * 2)\n+            .map(|x| x as f64)\n+            .filter(|x| *x > 0.0)\n+            .map(|x| { x + 1.0 })\n+            .sum::<i32>(), //~ ERROR E0277\n+    );\n+    println!(\"{}\", vec![0, 1].iter().map(|x| { x; }).sum::<i32>()); //~ ERROR E0277\n+    println!(\"{}\", vec![(), ()].iter().sum::<i32>()); //~ ERROR E0277\n+    let a = vec![0];\n+    let b = a.into_iter();\n+    let c = b.map(|x| x + 1);\n+    let d = c.filter(|x| *x > 10 );\n+    let e = d.map(|x| {\n+        x + 1;\n+    });\n+    let f = e.filter(|_| false);\n+    let g: Vec<i32> = f.collect(); //~ ERROR E0277\n+}"}, {"sha": "49651b20fb16db3403dce5bc8e96263475abf338", "filename": "src/test/ui/iterators/invalid-iterator-chain.stderr", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Fiterators%2Finvalid-iterator-chain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Fiterators%2Finvalid-iterator-chain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Finvalid-iterator-chain.stderr?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -0,0 +1,176 @@\n+error[E0277]: a value of type `i32` cannot be made by summing an iterator over elements of type `()`\n+  --> $DIR/invalid-iterator-chain.rs:7:27\n+   |\n+LL |     println!(\"{}\", scores.sum::<i32>());\n+   |                           ^^^ value of type `i32` cannot be made by summing a `std::iter::Iterator<Item=()>`\n+   |\n+   = help: the trait `Sum<()>` is not implemented for `i32`\n+   = help: the following other types implement trait `Sum<A>`:\n+             <i32 as Sum<&'a i32>>\n+             <i32 as Sum>\n+note: the method call chain might not have had the expected associated types\n+  --> $DIR/invalid-iterator-chain.rs:4:10\n+   |\n+LL |       let scores = vec![(0, 0)]\n+   |                    ------------ this expression has type `Vec<({integer}, {integer})>`\n+LL |           .iter()\n+   |            ------ `Iterator::Item` is `&({integer}, {integer})` here\n+LL |           .map(|(a, b)| {\n+   |  __________^\n+LL | |             a + b;\n+LL | |         });\n+   | |__________^ `Iterator::Item` changed to `()` here\n+note: required by a bound in `std::iter::Iterator::sum`\n+  --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n+   |\n+LL |         S: Sum<Self::Item>,\n+   |            ^^^^^^^^^^^^^^^ required by this bound in `Iterator::sum`\n+\n+error[E0277]: a value of type `i32` cannot be made by summing an iterator over elements of type `()`\n+  --> $DIR/invalid-iterator-chain.rs:18:14\n+   |\n+LL |             .sum::<i32>(),\n+   |              ^^^ value of type `i32` cannot be made by summing a `std::iter::Iterator<Item=()>`\n+   |\n+   = help: the trait `Sum<()>` is not implemented for `i32`\n+   = help: the following other types implement trait `Sum<A>`:\n+             <i32 as Sum<&'a i32>>\n+             <i32 as Sum>\n+note: the method call chain might not have had the expected associated types\n+  --> $DIR/invalid-iterator-chain.rs:12:14\n+   |\n+LL |         vec![0, 1]\n+   |         ---------- this expression has type `Vec<{integer}>`\n+LL |             .iter()\n+   |              ------ `Iterator::Item` is `&{integer}` here\n+LL |             .map(|x| x * 2)\n+   |              ^^^^^^^^^^^^^^ `Iterator::Item` changed to `{integer}` here\n+LL |             .map(|x| x as f64)\n+   |              ----------------- `Iterator::Item` changed to `f64` here\n+LL |             .map(|x| x as i64)\n+   |              ----------------- `Iterator::Item` changed to `i64` here\n+LL |             .filter(|x| *x > 0)\n+   |              ------------------ `Iterator::Item` remains `i64` here\n+LL |             .map(|x| { x + 1 })\n+   |              ------------------ `Iterator::Item` remains `i64` here\n+LL |             .map(|x| { x; })\n+   |              ^^^^^^^^^^^^^^^ `Iterator::Item` changed to `()` here\n+note: required by a bound in `std::iter::Iterator::sum`\n+  --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n+   |\n+LL |         S: Sum<Self::Item>,\n+   |            ^^^^^^^^^^^^^^^ required by this bound in `Iterator::sum`\n+\n+error[E0277]: a value of type `i32` cannot be made by summing an iterator over elements of type `f64`\n+  --> $DIR/invalid-iterator-chain.rs:28:14\n+   |\n+LL |             .sum::<i32>(),\n+   |              ^^^ value of type `i32` cannot be made by summing a `std::iter::Iterator<Item=f64>`\n+   |\n+   = help: the trait `Sum<f64>` is not implemented for `i32`\n+   = help: the following other types implement trait `Sum<A>`:\n+             <i32 as Sum<&'a i32>>\n+             <i32 as Sum>\n+note: the method call chain might not have had the expected associated types\n+  --> $DIR/invalid-iterator-chain.rs:24:14\n+   |\n+LL |         vec![0, 1]\n+   |         ---------- this expression has type `Vec<{integer}>`\n+LL |             .iter()\n+   |              ------ `Iterator::Item` is `&{integer}` here\n+LL |             .map(|x| x * 2)\n+   |              ^^^^^^^^^^^^^^ `Iterator::Item` changed to `{integer}` here\n+LL |             .map(|x| x as f64)\n+   |              ^^^^^^^^^^^^^^^^^ `Iterator::Item` changed to `f64` here\n+LL |             .filter(|x| *x > 0.0)\n+   |              -------------------- `Iterator::Item` remains `f64` here\n+LL |             .map(|x| { x + 1.0 })\n+   |              -------------------- `Iterator::Item` remains `f64` here\n+note: required by a bound in `std::iter::Iterator::sum`\n+  --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n+   |\n+LL |         S: Sum<Self::Item>,\n+   |            ^^^^^^^^^^^^^^^ required by this bound in `Iterator::sum`\n+\n+error[E0277]: a value of type `i32` cannot be made by summing an iterator over elements of type `()`\n+  --> $DIR/invalid-iterator-chain.rs:30:54\n+   |\n+LL |     println!(\"{}\", vec![0, 1].iter().map(|x| { x; }).sum::<i32>());\n+   |                                                      ^^^ value of type `i32` cannot be made by summing a `std::iter::Iterator<Item=()>`\n+   |\n+   = help: the trait `Sum<()>` is not implemented for `i32`\n+   = help: the following other types implement trait `Sum<A>`:\n+             <i32 as Sum<&'a i32>>\n+             <i32 as Sum>\n+note: the method call chain might not have had the expected associated types\n+  --> $DIR/invalid-iterator-chain.rs:30:38\n+   |\n+LL |     println!(\"{}\", vec![0, 1].iter().map(|x| { x; }).sum::<i32>());\n+   |                    ---------- ------ ^^^^^^^^^^^^^^^ `Iterator::Item` changed to `()` here\n+   |                    |          |\n+   |                    |          `Iterator::Item` is `&{integer}` here\n+   |                    this expression has type `Vec<{integer}>`\n+note: required by a bound in `std::iter::Iterator::sum`\n+  --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n+   |\n+LL |         S: Sum<Self::Item>,\n+   |            ^^^^^^^^^^^^^^^ required by this bound in `Iterator::sum`\n+\n+error[E0277]: a value of type `i32` cannot be made by summing an iterator over elements of type `&()`\n+  --> $DIR/invalid-iterator-chain.rs:31:40\n+   |\n+LL |     println!(\"{}\", vec![(), ()].iter().sum::<i32>());\n+   |                                        ^^^ value of type `i32` cannot be made by summing a `std::iter::Iterator<Item=&()>`\n+   |\n+   = help: the trait `Sum<&()>` is not implemented for `i32`\n+   = help: the following other types implement trait `Sum<A>`:\n+             <i32 as Sum<&'a i32>>\n+             <i32 as Sum>\n+note: the method call chain might not have had the expected associated types\n+  --> $DIR/invalid-iterator-chain.rs:31:33\n+   |\n+LL |     println!(\"{}\", vec![(), ()].iter().sum::<i32>());\n+   |                    ------------ ^^^^^^ `Iterator::Item` is `&()` here\n+   |                    |\n+   |                    this expression has type `Vec<()>`\n+note: required by a bound in `std::iter::Iterator::sum`\n+  --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n+   |\n+LL |         S: Sum<Self::Item>,\n+   |            ^^^^^^^^^^^^^^^ required by this bound in `Iterator::sum`\n+\n+error[E0277]: a value of type `Vec<i32>` cannot be built from an iterator over elements of type `()`\n+  --> $DIR/invalid-iterator-chain.rs:40:25\n+   |\n+LL |     let g: Vec<i32> = f.collect();\n+   |                         ^^^^^^^ value of type `Vec<i32>` cannot be built from `std::iter::Iterator<Item=()>`\n+   |\n+   = help: the trait `FromIterator<()>` is not implemented for `Vec<i32>`\n+   = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n+note: the method call chain might not have had the expected associated types\n+  --> $DIR/invalid-iterator-chain.rs:36:15\n+   |\n+LL |       let a = vec![0];\n+   |               ------- this expression has type `Vec<{integer}>`\n+LL |       let b = a.into_iter();\n+   |                 ----------- `Iterator::Item` is `{integer}` here\n+LL |       let c = b.map(|x| x + 1);\n+   |                 -------------- `Iterator::Item` remains `{integer}` here\n+LL |       let d = c.filter(|x| *x > 10 );\n+   |                 -------------------- `Iterator::Item` remains `{integer}` here\n+LL |       let e = d.map(|x| {\n+   |  _______________^\n+LL | |         x + 1;\n+LL | |     });\n+   | |______^ `Iterator::Item` changed to `()` here\n+LL |       let f = e.filter(|_| false);\n+   |                 ----------------- `Iterator::Item` remains `()` here\n+note: required by a bound in `collect`\n+  --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n+   |\n+LL |     fn collect<B: FromIterator<Self::Item>>(self) -> B\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `Iterator::collect`\n+\n+error: aborting due to 6 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "c66069c4d2570b7fd3e40d962d53c985215aff40", "filename": "src/test/ui/lazy-type-alias-impl-trait/branches.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Fbranches.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Fbranches.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Fbranches.stderr?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -1,10 +1,8 @@\n error[E0277]: a value of type `Bar` cannot be built from an iterator over elements of type `_`\n-  --> $DIR/branches.rs:19:9\n+  --> $DIR/branches.rs:19:28\n    |\n LL |         std::iter::empty().collect()\n-   |         ^^^^^^^^^^^^^^^^^^ ------- required by a bound introduced by this call\n-   |         |\n-   |         value of type `Bar` cannot be built from `std::iter::Iterator<Item=_>`\n+   |                            ^^^^^^^ value of type `Bar` cannot be built from `std::iter::Iterator<Item=_>`\n    |\n    = help: the trait `FromIterator<_>` is not implemented for `Bar`\n note: required by a bound in `collect`"}, {"sha": "a92c3a6809eae634d0e44c0d5904c3d3230e04a6", "filename": "src/test/ui/lazy-type-alias-impl-trait/recursion4.stderr", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Frecursion4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Frecursion4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Frecursion4.stderr?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -1,10 +1,8 @@\n error[E0277]: a value of type `Foo` cannot be built from an iterator over elements of type `_`\n-  --> $DIR/recursion4.rs:10:9\n+  --> $DIR/recursion4.rs:10:28\n    |\n LL |     x = std::iter::empty().collect();\n-   |         ^^^^^^^^^^^^^^^^^^ ------- required by a bound introduced by this call\n-   |         |\n-   |         value of type `Foo` cannot be built from `std::iter::Iterator<Item=_>`\n+   |                            ^^^^^^^ value of type `Foo` cannot be built from `std::iter::Iterator<Item=_>`\n    |\n    = help: the trait `FromIterator<_>` is not implemented for `Foo`\n note: required by a bound in `collect`\n@@ -14,12 +12,10 @@ LL |     fn collect<B: FromIterator<Self::Item>>(self) -> B\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `Iterator::collect`\n \n error[E0277]: a value of type `impl Debug` cannot be built from an iterator over elements of type `_`\n-  --> $DIR/recursion4.rs:19:9\n+  --> $DIR/recursion4.rs:19:28\n    |\n LL |     x = std::iter::empty().collect();\n-   |         ^^^^^^^^^^^^^^^^^^ ------- required by a bound introduced by this call\n-   |         |\n-   |         value of type `impl Debug` cannot be built from `std::iter::Iterator<Item=_>`\n+   |                            ^^^^^^^ value of type `impl Debug` cannot be built from `std::iter::Iterator<Item=_>`\n    |\n    = help: the trait `FromIterator<_>` is not implemented for `impl Debug`\n note: required by a bound in `collect`"}, {"sha": "c2515c40b1d778373235367e02fdfaefb501fb0b", "filename": "src/test/ui/mismatched_types/method-help-unsatisfied-bound.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Fmismatched_types%2Fmethod-help-unsatisfied-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Fmismatched_types%2Fmethod-help-unsatisfied-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fmethod-help-unsatisfied-bound.stderr?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -1,10 +1,8 @@\n error[E0277]: `Foo` doesn't implement `Debug`\n-  --> $DIR/method-help-unsatisfied-bound.rs:5:5\n+  --> $DIR/method-help-unsatisfied-bound.rs:5:7\n    |\n LL |     a.unwrap();\n-   |     ^ ------ required by a bound introduced by this call\n-   |     |\n-   |     `Foo` cannot be formatted using `{:?}`\n+   |       ^^^^^^ `Foo` cannot be formatted using `{:?}`\n    |\n    = help: the trait `Debug` is not implemented for `Foo`\n    = note: add `#[derive(Debug)]` to `Foo` or manually `impl Debug for Foo`"}, {"sha": "2db1cc4b776905e8fdb3c0086602a1057a91e607", "filename": "src/test/ui/never_type/feature-gate-never_type_fallback.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Fnever_type%2Ffeature-gate-never_type_fallback.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Fnever_type%2Ffeature-gate-never_type_fallback.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Ffeature-gate-never_type_fallback.stderr?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -5,7 +5,7 @@ LL |     foo(panic!())\n    |     --- ^^^^^^^^\n    |     |   |\n    |     |   the trait `T` is not implemented for `()`\n-   |     |   this tail expression is of type `_`\n+   |     |   this tail expression is of type `()`\n    |     required by a bound introduced by this call\n    |\n note: required by a bound in `foo`"}, {"sha": "37d94cf0ebd8c515e7c1d1db7fb7a01ad1276c34", "filename": "src/test/ui/not-clone-closure.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Fnot-clone-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Fnot-clone-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnot-clone-closure.stderr?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -1,13 +1,11 @@\n error[E0277]: the trait bound `S: Clone` is not satisfied in `[closure@$DIR/not-clone-closure.rs:7:17: 7:24]`\n-  --> $DIR/not-clone-closure.rs:11:17\n+  --> $DIR/not-clone-closure.rs:11:23\n    |\n LL |     let hello = move || {\n    |                 ------- within this `[closure@$DIR/not-clone-closure.rs:7:17: 7:24]`\n ...\n LL |     let hello = hello.clone();\n-   |                 ^^^^^ ----- required by a bound introduced by this call\n-   |                 |\n-   |                 within `[closure@$DIR/not-clone-closure.rs:7:17: 7:24]`, the trait `Clone` is not implemented for `S`\n+   |                       ^^^^^ within `[closure@$DIR/not-clone-closure.rs:7:17: 7:24]`, the trait `Clone` is not implemented for `S`\n    |\n note: required because it's used within this closure\n   --> $DIR/not-clone-closure.rs:7:17"}, {"sha": "70706541ad650e83391cd526d65c331802c6537d", "filename": "src/test/ui/on-unimplemented/sum.stderr", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Fon-unimplemented%2Fsum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Fon-unimplemented%2Fsum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fon-unimplemented%2Fsum.stderr?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -1,33 +1,43 @@\n error[E0277]: a value of type `i32` cannot be made by summing an iterator over elements of type `&()`\n-  --> $DIR/sum.rs:4:5\n+  --> $DIR/sum.rs:4:25\n    |\n LL |     vec![(), ()].iter().sum::<i32>();\n-   |     ^^^^^^^^^^^^^^^^^^^ --- required by a bound introduced by this call\n-   |     |\n-   |     value of type `i32` cannot be made by summing a `std::iter::Iterator<Item=&()>`\n+   |                         ^^^ value of type `i32` cannot be made by summing a `std::iter::Iterator<Item=&()>`\n    |\n    = help: the trait `Sum<&()>` is not implemented for `i32`\n    = help: the following other types implement trait `Sum<A>`:\n              <i32 as Sum<&'a i32>>\n              <i32 as Sum>\n+note: the method call chain might not have had the expected associated types\n+  --> $DIR/sum.rs:4:18\n+   |\n+LL |     vec![(), ()].iter().sum::<i32>();\n+   |     ------------ ^^^^^^ `Iterator::Item` is `&()` here\n+   |     |\n+   |     this expression has type `Vec<()>`\n note: required by a bound in `std::iter::Iterator::sum`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n    |\n LL |         S: Sum<Self::Item>,\n    |            ^^^^^^^^^^^^^^^ required by this bound in `Iterator::sum`\n \n error[E0277]: a value of type `i32` cannot be made by multiplying all elements of type `&()` from an iterator\n-  --> $DIR/sum.rs:7:5\n+  --> $DIR/sum.rs:7:25\n    |\n LL |     vec![(), ()].iter().product::<i32>();\n-   |     ^^^^^^^^^^^^^^^^^^^ ------- required by a bound introduced by this call\n-   |     |\n-   |     value of type `i32` cannot be made by multiplying all elements from a `std::iter::Iterator<Item=&()>`\n+   |                         ^^^^^^^ value of type `i32` cannot be made by multiplying all elements from a `std::iter::Iterator<Item=&()>`\n    |\n    = help: the trait `Product<&()>` is not implemented for `i32`\n    = help: the following other types implement trait `Product<A>`:\n              <i32 as Product<&'a i32>>\n              <i32 as Product>\n+note: the method call chain might not have had the expected associated types\n+  --> $DIR/sum.rs:7:18\n+   |\n+LL |     vec![(), ()].iter().product::<i32>();\n+   |     ------------ ^^^^^^ `Iterator::Item` is `&()` here\n+   |     |\n+   |     this expression has type `Vec<()>`\n note: required by a bound in `std::iter::Iterator::product`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n    |"}, {"sha": "e8f28c113e3ad9114d246d0172fee0133f3b3929", "filename": "src/test/ui/resolve/issue-104700-inner_scope.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Fresolve%2Fissue-104700-inner_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Fresolve%2Fissue-104700-inner_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-104700-inner_scope.rs?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -0,0 +1,11 @@\n+fn main() {\n+    let foo = 1;\n+    {\n+        let bar = 2;\n+        let test_func = |x| x > 3;\n+    }\n+    if bar == 2 { //~ ERROR cannot find value\n+        println!(\"yes\");\n+    }\n+    test_func(1); //~ ERROR cannot find function\n+}"}, {"sha": "051b234fc72d8b939201f5bd2297db15d826e01f", "filename": "src/test/ui/resolve/issue-104700-inner_scope.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Fresolve%2Fissue-104700-inner_scope.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Fresolve%2Fissue-104700-inner_scope.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-104700-inner_scope.stderr?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -0,0 +1,21 @@\n+error[E0425]: cannot find value `bar` in this scope\n+  --> $DIR/issue-104700-inner_scope.rs:7:8\n+   |\n+LL |     if bar == 2 {\n+   |        ^^^\n+   |\n+help: the binding `bar` is available in a different scope in the same function\n+  --> $DIR/issue-104700-inner_scope.rs:4:13\n+   |\n+LL |         let bar = 2;\n+   |             ^^^\n+\n+error[E0425]: cannot find function `test_func` in this scope\n+  --> $DIR/issue-104700-inner_scope.rs:10:5\n+   |\n+LL |     test_func(1);\n+   |     ^^^^^^^^^ not found in this scope\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0425`."}, {"sha": "f9d0d1f7875fb891b4016ed2078de369beeecca8", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-default-method-bodies.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-default-method-bodies.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-default-method-bodies.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-default-method-bodies.stderr?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -1,10 +1,8 @@\n error[E0277]: the trait bound `NonConstImpl: ~const ConstDefaultFn` is not satisfied\n-  --> $DIR/const-default-method-bodies.rs:24:5\n+  --> $DIR/const-default-method-bodies.rs:24:18\n    |\n LL |     NonConstImpl.a();\n-   |     ^^^^^^^^^^^^ - required by a bound introduced by this call\n-   |     |\n-   |     the trait `~const ConstDefaultFn` is not implemented for `NonConstImpl`\n+   |                  ^ the trait `~const ConstDefaultFn` is not implemented for `NonConstImpl`\n    |\n note: the trait `ConstDefaultFn` is implemented for `NonConstImpl`, but that implementation is not `const`\n   --> $DIR/const-default-method-bodies.rs:24:5"}, {"sha": "633b7cc255a52a817a20a02d03afbdf079247331", "filename": "src/test/ui/rfc-2632-const-trait-impl/cross-crate.gatednc.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcross-crate.gatednc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcross-crate.gatednc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcross-crate.gatednc.stderr?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -1,10 +1,8 @@\n error[E0277]: the trait bound `cross_crate::NonConst: ~const cross_crate::MyTrait` is not satisfied\n-  --> $DIR/cross-crate.rs:17:5\n+  --> $DIR/cross-crate.rs:17:14\n    |\n LL |     NonConst.func();\n-   |     ^^^^^^^^ ---- required by a bound introduced by this call\n-   |     |\n-   |     the trait `~const cross_crate::MyTrait` is not implemented for `cross_crate::NonConst`\n+   |              ^^^^ the trait `~const cross_crate::MyTrait` is not implemented for `cross_crate::NonConst`\n    |\n note: the trait `cross_crate::MyTrait` is implemented for `cross_crate::NonConst`, but that implementation is not `const`\n   --> $DIR/cross-crate.rs:17:5"}, {"sha": "9e97d3f11376014a3f08bd9eb596d664e70c0e4a", "filename": "src/test/ui/rfc-2632-const-trait-impl/cross-crate.stocknc.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcross-crate.stocknc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcross-crate.stocknc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcross-crate.stocknc.stderr?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -1,10 +1,8 @@\n error[E0277]: the trait bound `cross_crate::NonConst: cross_crate::MyTrait` is not satisfied\n-  --> $DIR/cross-crate.rs:17:5\n+  --> $DIR/cross-crate.rs:17:14\n    |\n LL |     NonConst.func();\n-   |     ^^^^^^^^ ---- required by a bound introduced by this call\n-   |     |\n-   |     the trait `~const cross_crate::MyTrait` is not implemented for `cross_crate::NonConst`\n+   |              ^^^^ the trait `~const cross_crate::MyTrait` is not implemented for `cross_crate::NonConst`\n    |\n note: the trait `cross_crate::MyTrait` is implemented for `cross_crate::NonConst`, but that implementation is not `const`\n   --> $DIR/cross-crate.rs:17:5"}, {"sha": "21ecddaffbb6517c64933d1c5114bed8bd42eb38", "filename": "src/test/ui/rfc-2632-const-trait-impl/default-method-body-is-const-same-trait-ck.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fdefault-method-body-is-const-same-trait-ck.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fdefault-method-body-is-const-same-trait-ck.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fdefault-method-body-is-const-same-trait-ck.stderr?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -1,10 +1,8 @@\n error[E0277]: the trait bound `(): ~const Tr` is not satisfied\n-  --> $DIR/default-method-body-is-const-same-trait-ck.rs:8:9\n+  --> $DIR/default-method-body-is-const-same-trait-ck.rs:8:12\n    |\n LL |         ().a()\n-   |         ^^ - required by a bound introduced by this call\n-   |         |\n-   |         the trait `~const Tr` is not implemented for `()`\n+   |            ^ the trait `~const Tr` is not implemented for `()`\n    |\n note: the trait `Tr` is implemented for `()`, but that implementation is not `const`\n   --> $DIR/default-method-body-is-const-same-trait-ck.rs:8:9"}, {"sha": "13fc719f28c5c2ad681a357c78c1df7170f691d7", "filename": "src/test/ui/rfc-2632-const-trait-impl/super-traits-fail-2.yn.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fsuper-traits-fail-2.yn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fsuper-traits-fail-2.yn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fsuper-traits-fail-2.yn.stderr?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -1,10 +1,8 @@\n error[E0277]: the trait bound `T: ~const Foo` is not satisfied\n-  --> $DIR/super-traits-fail-2.rs:15:5\n+  --> $DIR/super-traits-fail-2.rs:15:7\n    |\n LL |     x.a();\n-   |     ^ - required by a bound introduced by this call\n-   |     |\n-   |     the trait `~const Foo` is not implemented for `T`\n+   |       ^ the trait `~const Foo` is not implemented for `T`\n    |\n note: the trait `Foo` is implemented for `T`, but that implementation is not `const`\n   --> $DIR/super-traits-fail-2.rs:15:5"}, {"sha": "13fc719f28c5c2ad681a357c78c1df7170f691d7", "filename": "src/test/ui/rfc-2632-const-trait-impl/super-traits-fail-2.yy.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fsuper-traits-fail-2.yy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fsuper-traits-fail-2.yy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fsuper-traits-fail-2.yy.stderr?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -1,10 +1,8 @@\n error[E0277]: the trait bound `T: ~const Foo` is not satisfied\n-  --> $DIR/super-traits-fail-2.rs:15:5\n+  --> $DIR/super-traits-fail-2.rs:15:7\n    |\n LL |     x.a();\n-   |     ^ - required by a bound introduced by this call\n-   |     |\n-   |     the trait `~const Foo` is not implemented for `T`\n+   |       ^ the trait `~const Foo` is not implemented for `T`\n    |\n note: the trait `Foo` is implemented for `T`, but that implementation is not `const`\n   --> $DIR/super-traits-fail-2.rs:15:5"}, {"sha": "a5e6f5b5ffcb0a40fa7a4041ea1baff58bdd7042", "filename": "src/test/ui/suggestions/issue-71394-no-from-impl.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Fsuggestions%2Fissue-71394-no-from-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Fsuggestions%2Fissue-71394-no-from-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-71394-no-from-impl.stderr?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -1,10 +1,8 @@\n error[E0277]: the trait bound `&[i8]: From<&[u8]>` is not satisfied\n-  --> $DIR/issue-71394-no-from-impl.rs:3:20\n+  --> $DIR/issue-71394-no-from-impl.rs:3:25\n    |\n LL |     let _: &[i8] = data.into();\n-   |                    ^^^^ ---- required by a bound introduced by this call\n-   |                    |\n-   |                    the trait `From<&[u8]>` is not implemented for `&[i8]`\n+   |                         ^^^^ the trait `From<&[u8]>` is not implemented for `&[i8]`\n    |\n    = help: the following other types implement trait `From<T>`:\n              <[T; LANES] as From<Simd<T, LANES>>>"}, {"sha": "9062a0fab630a3103d5e8ac839e5b1a54dd90b40", "filename": "src/test/ui/traits/issue-97576.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Ftraits%2Fissue-97576.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Ftraits%2Fissue-97576.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fissue-97576.stderr?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -1,10 +1,8 @@\n error[E0277]: the trait bound `String: From<impl ToString>` is not satisfied\n-  --> $DIR/issue-97576.rs:8:18\n+  --> $DIR/issue-97576.rs:8:22\n    |\n LL |             bar: bar.into(),\n-   |                  ^^^ ---- required by a bound introduced by this call\n-   |                  |\n-   |                  the trait `From<impl ToString>` is not implemented for `String`\n+   |                      ^^^^ the trait `From<impl ToString>` is not implemented for `String`\n    |\n    = note: required for `impl ToString` to implement `Into<String>`\n "}, {"sha": "d7b95f55769fdc600f7b37ff9ec22b43e9844215", "filename": "src/test/ui/unsized/issue-71659.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Funsized%2Fissue-71659.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b96d9e0e20adb7716aa32a56fe96fde15c75d517/src%2Ftest%2Fui%2Funsized%2Fissue-71659.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized%2Fissue-71659.stderr?ref=b96d9e0e20adb7716aa32a56fe96fde15c75d517", "patch": "@@ -1,10 +1,8 @@\n error[E0277]: the trait bound `dyn Foo: CastTo<[i32]>` is not satisfied\n-  --> $DIR/issue-71659.rs:30:13\n+  --> $DIR/issue-71659.rs:30:15\n    |\n LL |     let x = x.cast::<[i32]>();\n-   |             ^ ---- required by a bound introduced by this call\n-   |             |\n-   |             the trait `CastTo<[i32]>` is not implemented for `dyn Foo`\n+   |               ^^^^ the trait `CastTo<[i32]>` is not implemented for `dyn Foo`\n    |\n note: required by a bound in `Cast::cast`\n   --> $DIR/issue-71659.rs:19:15"}]}