{"sha": "694be09b7be057aa342e6cfe61815032942e5f95", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5NGJlMDliN2JlMDU3YWEzNDJlNmNmZTYxODE1MDMyOTQyZTVmOTU=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2020-09-16T03:35:08Z"}, "committer": {"name": "Dominik Stolz", "email": "d.stolz@tum.de", "date": "2021-07-21T08:49:11Z"}, "message": "Add Linux-specific pidfd process extensions\n\nBackground:\n\nOver the last year, pidfd support was added to the Linux kernel. This\nallows interacting with other processes. In particular, this allows\nwaiting on a child process with a timeout in a race-free way, bypassing\nall of the awful signal-handler tricks that are usually required.\n\nPidfds can be obtained for a child process (as well as any other\nprocess) via the `pidfd_open` syscall. Unfortunately, this requires\nseveral conditions to hold in order to be race-free (i.e. the pid is not\nreused).\nPer `man pidfd_open`:\n\n```\n\u00b7 the disposition of SIGCHLD has not been explicitly set to SIG_IGN\n (see sigaction(2));\n\n\u00b7 the SA_NOCLDWAIT flag was not specified while establishing a han\u2010\n dler for SIGCHLD or while setting the disposition of that signal to\n SIG_DFL (see sigaction(2)); and\n\n\u00b7 the zombie process was not reaped elsewhere in the program (e.g.,\n either by an asynchronously executed signal handler or by wait(2)\n or similar in another thread).\n\nIf any of these conditions does not hold, then the child process\n(along with a PID file descriptor that refers to it) should instead\nbe created using clone(2) with the CLONE_PIDFD flag.\n```\n\nSadly, these conditions are impossible to guarantee once any libraries\nare used. For example, C code runnng in a different thread could call\n`wait()`, which is impossible to detect from Rust code trying to open a\npidfd.\n\nWhile pid reuse issues should (hopefully) be rare in practice, we can do\nbetter. By passing the `CLONE_PIDFD` flag to `clone()` or `clone3()`, we\ncan obtain a pidfd for the child process in a guaranteed race-free\nmanner.\n\nThis PR:\n\nThis PR adds Linux-specific process extension methods to allow obtaining\npidfds for processes spawned via the standard `Command` API. Other than\nbeing made available to user code, the standard library does not make\nuse of these pidfds in any way. In particular, the implementation of\n`Child::wait` is completely unchanged.\n\nTwo Linux-specific helper methods are added: `CommandExt::create_pidfd`\nand `ChildExt::pidfd`. These methods are intended to serve as a building\nblock for libraries to build higher-level abstractions - in particular,\nwaiting on a process with a timeout.\n\nI've included a basic test, which verifies that pidfds are created iff\nthe `create_pidfd` method is used. This test is somewhat special - it\nshould always succeed on systems with the `clone3` system call\navailable, and always fail on systems without `clone3` available. I'm\nnot sure how to best ensure this programatically.\n\nThis PR relies on the newer `clone3` system call to pass the `CLONE_FD`,\nrather than the older `clone` system call. `clone3` was added to Linux\nin the same release as pidfds, so this shouldn't unnecessarily limit the\nkernel versions that this code supports.\n\nUnresolved questions:\n* What should the name of the feature gate be for these newly added\n  methods?\n* Should the `pidfd` method distinguish between an error occurring\n  and `create_pidfd` not being called?", "tree": {"sha": "eeac4bbd8fce62af7216358f55aaa662c4ea3e16", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eeac4bbd8fce62af7216358f55aaa662c4ea3e16"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/694be09b7be057aa342e6cfe61815032942e5f95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/694be09b7be057aa342e6cfe61815032942e5f95", "html_url": "https://github.com/rust-lang/rust/commit/694be09b7be057aa342e6cfe61815032942e5f95", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/694be09b7be057aa342e6cfe61815032942e5f95/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "voidc", "id": 5302792, "node_id": "MDQ6VXNlcjUzMDI3OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/5302792?v=4", "gravatar_id": "", "url": "https://api.github.com/users/voidc", "html_url": "https://github.com/voidc", "followers_url": "https://api.github.com/users/voidc/followers", "following_url": "https://api.github.com/users/voidc/following{/other_user}", "gists_url": "https://api.github.com/users/voidc/gists{/gist_id}", "starred_url": "https://api.github.com/users/voidc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/voidc/subscriptions", "organizations_url": "https://api.github.com/users/voidc/orgs", "repos_url": "https://api.github.com/users/voidc/repos", "events_url": "https://api.github.com/users/voidc/events{/privacy}", "received_events_url": "https://api.github.com/users/voidc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f2e753b2fd1f614c64ba451ff816f50a3ac2edd", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd", "html_url": "https://github.com/rust-lang/rust/commit/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd"}], "stats": {"total": 193, "additions": 186, "deletions": 7}, "files": [{"sha": "8e7776f6646b58f5b4cee594289568a3426ab9bf", "filename": "library/std/src/os/linux/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/694be09b7be057aa342e6cfe61815032942e5f95/library%2Fstd%2Fsrc%2Fos%2Flinux%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/694be09b7be057aa342e6cfe61815032942e5f95/library%2Fstd%2Fsrc%2Fos%2Flinux%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Flinux%2Fmod.rs?ref=694be09b7be057aa342e6cfe61815032942e5f95", "patch": "@@ -4,4 +4,5 @@\n #![doc(cfg(target_os = \"linux\"))]\n \n pub mod fs;\n+pub mod process;\n pub mod raw;"}, {"sha": "661d3cef7a03a3f77d8e630b7fe3c5164ef6943b", "filename": "library/std/src/os/linux/process.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/694be09b7be057aa342e6cfe61815032942e5f95/library%2Fstd%2Fsrc%2Fos%2Flinux%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/694be09b7be057aa342e6cfe61815032942e5f95/library%2Fstd%2Fsrc%2Fos%2Flinux%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Flinux%2Fprocess.rs?ref=694be09b7be057aa342e6cfe61815032942e5f95", "patch": "@@ -0,0 +1,47 @@\n+//! Linux-specific extensions to primitives in the `std::process` module.\n+\n+#![unstable(feature = \"linux_pidfd\", issue = \"none\")]\n+\n+use crate::process;\n+use crate::sys_common::AsInnerMut;\n+use crate::io::Result;\n+\n+/// Os-specific extensions to [`process::Child`]\n+///\n+/// [`process::Child`]: crate::process::Child\n+pub trait ChildExt {\n+    /// Obtains the pidfd created for this child process, if available.\n+    ///\n+    /// A pidfd will only ever be available if `create_pidfd(true)` was called\n+    /// when the corresponding `Command` was created.\n+    ///\n+    /// Even if `create_pidfd(true)` is called, a pidfd may not be available\n+    /// due to an older version of Linux being in use, or if\n+    /// some other error occured.\n+    ///\n+    /// See `man pidfd_open` for more details about pidfds.\n+    fn pidfd(&self) -> Result<i32>;\n+}\n+\n+/// Os-specific extensions to [`process::Command`]\n+///\n+/// [`process::Command`]: crate::process::Command\n+pub trait CommandExt {\n+    /// Sets whether or this `Command` will attempt to create a pidfd\n+    /// for the child. If this method is never called, a pidfd will\n+    /// not be crated.\n+    ///\n+    /// The pidfd can be retrieved from the child via [`ChildExt::pidfd`]\n+    ///\n+    /// A pidfd will only be created if it is possible to do so\n+    /// in a guaranteed race-free manner (e.g. if the `clone3` system call is\n+    /// supported). Otherwise, [`ChildExit::pidfd`] will return an error.\n+    fn create_pidfd(&mut self, val: bool) -> &mut process::Command;\n+}\n+\n+impl CommandExt for process::Command {\n+    fn create_pidfd(&mut self, val: bool) -> &mut process::Command {\n+        self.as_inner_mut().create_pidfd(val);\n+        self\n+    }\n+}"}, {"sha": "99c3369425b06361c11d96229c08e8600d971141", "filename": "library/std/src/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/694be09b7be057aa342e6cfe61815032942e5f95/library%2Fstd%2Fsrc%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/694be09b7be057aa342e6cfe61815032942e5f95/library%2Fstd%2Fsrc%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprocess.rs?ref=694be09b7be057aa342e6cfe61815032942e5f95", "patch": "@@ -166,7 +166,7 @@ use crate::sys_common::{AsInner, AsInnerMut, FromInner, IntoInner};\n /// [`wait`]: Child::wait\n #[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct Child {\n-    handle: imp::Process,\n+    pub(crate) handle: imp::Process,\n \n     /// The handle for writing to the child's standard input (stdin), if it has\n     /// been captured. To avoid partially moving"}, {"sha": "f7a7a9968b8fd06850a1441ff95418d82c03ba54", "filename": "library/std/src/sys/unix/process/process_common.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/694be09b7be057aa342e6cfe61815032942e5f95/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/694be09b7be057aa342e6cfe61815032942e5f95/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs?ref=694be09b7be057aa342e6cfe61815032942e5f95", "patch": "@@ -79,6 +79,7 @@ pub struct Command {\n     stdin: Option<Stdio>,\n     stdout: Option<Stdio>,\n     stderr: Option<Stdio>,\n+    pub(crate) make_pidfd: bool,\n }\n \n // Create a new type for argv, so that we can make it `Send` and `Sync`\n@@ -141,6 +142,7 @@ impl Command {\n             stdin: None,\n             stdout: None,\n             stderr: None,\n+            make_pidfd: false,\n         }\n     }\n \n@@ -176,6 +178,10 @@ impl Command {\n     pub fn groups(&mut self, groups: &[gid_t]) {\n         self.groups = Some(Box::from(groups));\n     }\n+    \n+    pub fn create_pidfd(&mut self, val: bool) {\n+        self.make_pidfd = val;\n+    }\n \n     pub fn saw_nul(&self) -> bool {\n         self.saw_nul"}, {"sha": "c1605faceb6adab2ce3b0d5c681cdc03557c6305", "filename": "library/std/src/sys/unix/process/process_unix.rs", "status": "modified", "additions": 104, "deletions": 6, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/694be09b7be057aa342e6cfe61815032942e5f95/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/694be09b7be057aa342e6cfe61815032942e5f95/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=694be09b7be057aa342e6cfe61815032942e5f95", "patch": "@@ -8,6 +8,10 @@ use crate::ptr;\n use crate::sys;\n use crate::sys::cvt;\n use crate::sys::process::process_common::*;\n+use crate::sync::atomic::{AtomicBool, Ordering};\n+\n+#[cfg(target_os = \"linux\")]\n+use crate::sys::weak::syscall;\n \n #[cfg(any(\n     target_os = \"macos\",\n@@ -61,7 +65,8 @@ impl Command {\n         // a lock any more because the parent won't do anything and the child is\n         // in its own process. Thus the parent drops the lock guard while the child\n         // forgets it to avoid unlocking it on a new thread, which would be invalid.\n-        let (env_lock, pid) = unsafe { (sys::os::env_read_lock(), cvt(libc::fork())?) };\n+        let env_lock = sys::os::env_read_lock();\n+        let (pid, pidfd) = self.do_fork()?;\n \n         if pid == 0 {\n             crate::panic::always_abort();\n@@ -90,7 +95,7 @@ impl Command {\n         drop(env_lock);\n         drop(output);\n \n-        let mut p = Process { pid, status: None };\n+        let mut p = Process { pid, status: None, pidfd };\n         let mut bytes = [0; 8];\n \n         // loop to handle EINTR\n@@ -122,6 +127,85 @@ impl Command {\n         }\n     }\n \n+    // Attempts to fork the process. If successful, returns\n+    // Ok((0, -1)) in the child, and Ok((child_pid, child_pidfd)) in the parent.\n+    fn do_fork(&mut self) -> Result<(libc::c_long, libc::pid_t), io::Error> {\n+        // If we fail to create a pidfd for any reason, this will\n+        // stay as -1, which indicates an error\n+        let mut pidfd: libc::pid_t = -1;\n+\n+        // On Linux, attempt to use the `clone3` syscall, which\n+        // supports more argument (in prarticular, the ability to create a pidfd).\n+        // If this fails, we will fall through this block to a call to `fork()`\n+        cfg_if::cfg_if! {\n+            if #[cfg(target_os = \"linux\")] {\n+                static HAS_CLONE3: AtomicBool = AtomicBool::new(true);\n+\n+                const CLONE_PIDFD: u64 = 0x00001000;\n+\n+                #[repr(C)]\n+                struct clone_args {\n+                    flags: u64,\n+                    pidfd: u64,\n+                    child_tid: u64,\n+                    parent_tid: u64,\n+                    exit_signal: u64,\n+                    stack: u64,\n+                    stack_size: u64,\n+                    tls: u64,\n+                    set_tid: u64,\n+                    set_tid_size: u64,\n+                    cgroup: u64,\n+                }\n+\n+                syscall! {\n+                    fn clone3(cl_args: *mut clone_args, len: libc::size_t) -> libc::c_long\n+                }\n+\n+                if HAS_CLONE3.load(Ordering::Relaxed) {\n+                    let mut flags = 0;\n+                    if self.make_pidfd {\n+                        flags |= CLONE_PIDFD;\n+                    }\n+\n+                    let mut args = clone_args {\n+                        flags,\n+                        pidfd: &mut pidfd as *mut libc::pid_t as u64,\n+                        child_tid: 0,\n+                        parent_tid: 0,\n+                        exit_signal: libc::SIGCHLD as u64,\n+                        stack: 0,\n+                        stack_size: 0,\n+                        tls: 0,\n+                        set_tid: 0,\n+                        set_tid_size: 0,\n+                        cgroup: 0\n+                    };\n+\n+                    let args_ptr = &mut args as *mut clone_args;\n+                    let args_size = crate::mem::size_of::<clone_args>();\n+\n+                    let res = cvt(unsafe { clone3(args_ptr, args_size) });\n+                    match res {\n+                        Ok(n) => return Ok((n, pidfd)),\n+                        Err(e) => match e.raw_os_error() {\n+                            // Multiple threads can race to execute this store,\n+                            // but that's fine - that just means that multiple threads\n+                            // will have tried and failed to execute the same syscall,\n+                            // with no other side effects.\n+                            Some(libc::ENOSYS) => HAS_CLONE3.store(false, Ordering::Relaxed),\n+                            _ => return Err(e)\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        // If we get here, we are either not on Linux,\n+        // or we are on Linux and the 'clone3' syscall does not exist\n+        cvt(unsafe { libc::fork() }.into()).map(|res| (res, pidfd))\n+    }\n+\n+\n     pub fn exec(&mut self, default: Stdio) -> io::Error {\n         let envp = self.capture_env();\n \n@@ -276,8 +360,6 @@ impl Command {\n     #[cfg(not(any(\n         target_os = \"macos\",\n         target_os = \"freebsd\",\n-        all(target_os = \"linux\", target_env = \"gnu\"),\n-        all(target_os = \"linux\", target_env = \"musl\"),\n     )))]\n     fn posix_spawn(\n         &mut self,\n@@ -292,8 +374,6 @@ impl Command {\n     #[cfg(any(\n         target_os = \"macos\",\n         target_os = \"freebsd\",\n-        all(target_os = \"linux\", target_env = \"gnu\"),\n-        all(target_os = \"linux\", target_env = \"musl\"),\n     ))]\n     fn posix_spawn(\n         &mut self,\n@@ -441,6 +521,12 @@ impl Command {\n pub struct Process {\n     pid: pid_t,\n     status: Option<ExitStatus>,\n+    // On Linux, stores the pidfd created for this child.\n+    // This is -1 if the user did not request pidfd creation,\n+    // or if the pidfd could not be created for some reason\n+    // (e.g. the `clone3` syscall was not available).\n+    #[cfg(target_os = \"linux\")]\n+    pidfd: libc::c_int,\n }\n \n impl Process {\n@@ -580,6 +666,18 @@ impl ExitStatusError {\n     }\n }\n \n+#[cfg(target_os = \"linux\")]\n+#[unstable(feature = \"linux_pidfd\", issue = \"none\")]\n+impl crate::os::linux::process::ChildExt for crate::process::Child {\n+    fn pidfd(&self) -> crate::io::Result<i32> {\n+        if self.handle.pidfd > 0 {\n+            Ok(self.handle.pidfd)\n+        } else {\n+            Err(crate::io::Error::from(crate::io::ErrorKind::Other))\n+        }\n+    }\n+}\n+\n #[cfg(test)]\n #[path = \"process_unix/tests.rs\"]\n mod tests;"}, {"sha": "248ae3457d7155291c4834558f1e97f17447b7f8", "filename": "src/test/ui/command/command-create-pidfd.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/694be09b7be057aa342e6cfe61815032942e5f95/src%2Ftest%2Fui%2Fcommand%2Fcommand-create-pidfd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/694be09b7be057aa342e6cfe61815032942e5f95/src%2Ftest%2Fui%2Fcommand%2Fcommand-create-pidfd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcommand%2Fcommand-create-pidfd.rs?ref=694be09b7be057aa342e6cfe61815032942e5f95", "patch": "@@ -0,0 +1,27 @@\n+// run-pass\n+// linux-only - pidfds are a linux-specific concept\n+\n+#![feature(linux_pidfd)]\n+use std::os::linux::process::{CommandExt, ChildExt};\n+use std::process::Command;\n+\n+fn main() {\n+    // We don't assert the precise value, since the standard libarary\n+    // may be opened other file descriptors before our code ran.\n+    let _ = Command::new(\"echo\")\n+        .create_pidfd(true)\n+        .spawn()\n+        .unwrap()\n+        .pidfd().expect(\"failed to obtain pidfd\");\n+\n+    let _ = Command::new(\"echo\")\n+        .create_pidfd(false)\n+        .spawn()\n+        .unwrap()\n+        .pidfd().expect_err(\"pidfd should not have been created when create_pid(false) is set\");\n+\n+    let _ = Command::new(\"echo\")\n+        .spawn()\n+        .unwrap()\n+        .pidfd().expect_err(\"pidfd should not have been created\");\n+}"}]}