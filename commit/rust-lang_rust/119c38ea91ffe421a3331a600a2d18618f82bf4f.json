{"sha": "119c38ea91ffe421a3331a600a2d18618f82bf4f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExOWMzOGVhOTFmZmU0MjFhMzMzMWE2MDBhMmQxODYxOGY4MmJmNGY=", "commit": {"author": {"name": "Taylor Cramer", "email": "cramertaylorj@gmail.com", "date": "2017-04-05T06:46:59Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-04-30T21:02:58Z"}, "message": "Remove RefCells from RegionMaps", "tree": {"sha": "16817c42e1b9f4137e184e4c1e8d5fbd7a7dd48d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/16817c42e1b9f4137e184e4c1e8d5fbd7a7dd48d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/119c38ea91ffe421a3331a600a2d18618f82bf4f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/119c38ea91ffe421a3331a600a2d18618f82bf4f", "html_url": "https://github.com/rust-lang/rust/commit/119c38ea91ffe421a3331a600a2d18618f82bf4f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/119c38ea91ffe421a3331a600a2d18618f82bf4f/comments", "author": {"login": "cramertj", "id": 5963049, "node_id": "MDQ6VXNlcjU5NjMwNDk=", "avatar_url": "https://avatars.githubusercontent.com/u/5963049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cramertj", "html_url": "https://github.com/cramertj", "followers_url": "https://api.github.com/users/cramertj/followers", "following_url": "https://api.github.com/users/cramertj/following{/other_user}", "gists_url": "https://api.github.com/users/cramertj/gists{/gist_id}", "starred_url": "https://api.github.com/users/cramertj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cramertj/subscriptions", "organizations_url": "https://api.github.com/users/cramertj/orgs", "repos_url": "https://api.github.com/users/cramertj/repos", "events_url": "https://api.github.com/users/cramertj/events{/privacy}", "received_events_url": "https://api.github.com/users/cramertj/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eff39b73d1c50edf58a6b30ad02285ba64528cfe", "url": "https://api.github.com/repos/rust-lang/rust/commits/eff39b73d1c50edf58a6b30ad02285ba64528cfe", "html_url": "https://github.com/rust-lang/rust/commit/eff39b73d1c50edf58a6b30ad02285ba64528cfe"}], "stats": {"total": 104, "additions": 51, "deletions": 53}, "files": [{"sha": "0c35d38d68498037b192b0675041e18a4ae68110", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 51, "deletions": 53, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/119c38ea91ffe421a3331a600a2d18618f82bf4f/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119c38ea91ffe421a3331a600a2d18618f82bf4f/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=119c38ea91ffe421a3331a600a2d18618f82bf4f", "patch": "@@ -21,7 +21,6 @@ use session::Session;\n use util::nodemap::{FxHashMap, NodeMap, NodeSet};\n use ty;\n \n-use std::cell::RefCell;\n use std::collections::hash_map::Entry;\n use std::fmt;\n use std::mem;\n@@ -50,7 +49,7 @@ impl fmt::Debug for CodeExtent {\n                 let region_maps = tcx.region_maps();\n                 {\n                     let code_extents = &region_maps.code_extents;\n-                    if let Some(data) = code_extents.borrow().get(self.0 as usize) {\n+                    if let Some(data) = code_extents.get(self.0 as usize) {\n                         write!(f, \"/{:?}\", data)?;\n                     }\n                     mem::drop(code_extents); // FIXME why is this necessary?\n@@ -258,34 +257,34 @@ impl CodeExtent {\n \n /// The region maps encode information about region relationships.\n pub struct RegionMaps {\n-    code_extents: RefCell<Vec<CodeExtentData>>,\n-    code_extent_interner: RefCell<FxHashMap<CodeExtentData, CodeExtent>>,\n+    code_extents: Vec<CodeExtentData>,\n+    code_extent_interner: FxHashMap<CodeExtentData, CodeExtent>,\n     /// `scope_map` maps from a scope id to the enclosing scope id;\n     /// this is usually corresponding to the lexical nesting, though\n     /// in the case of closures the parent scope is the innermost\n     /// conditional expression or repeating block. (Note that the\n     /// enclosing scope id for the block associated with a closure is\n     /// the closure itself.)\n-    scope_map: RefCell<Vec<CodeExtent>>,\n+    scope_map: Vec<CodeExtent>,\n \n     /// `var_map` maps from a variable or binding id to the block in\n     /// which that variable is declared.\n-    var_map: RefCell<NodeMap<CodeExtent>>,\n+    var_map: NodeMap<CodeExtent>,\n \n     /// `rvalue_scopes` includes entries for those expressions whose cleanup scope is\n     /// larger than the default. The map goes from the expression id\n     /// to the cleanup scope id. For rvalues not present in this\n     /// table, the appropriate cleanup scope is the innermost\n     /// enclosing statement, conditional expression, or repeating\n     /// block (see `terminating_scopes`).\n-    rvalue_scopes: RefCell<NodeMap<CodeExtent>>,\n+    rvalue_scopes: NodeMap<CodeExtent>,\n \n     /// Records the value of rvalue scopes before they were shrunk by\n     /// #36082, for error reporting.\n     ///\n     /// FIXME: this should be temporary. Remove this by 1.18.0 or\n     /// so.\n-    shrunk_rvalue_scopes: RefCell<NodeMap<CodeExtent>>,\n+    shrunk_rvalue_scopes: NodeMap<CodeExtent>,\n \n     /// Encodes the hierarchy of fn bodies. Every fn body (including\n     /// closures) forms its own distinct region hierarchy, rooted in\n@@ -297,7 +296,7 @@ pub struct RegionMaps {\n     /// closure defined by that fn. See the \"Modeling closures\"\n     /// section of the README in infer::region_inference for\n     /// more details.\n-    fn_tree: RefCell<NodeMap<ast::NodeId>>,\n+    fn_tree: NodeMap<ast::NodeId>,\n }\n \n #[derive(Debug, Copy, Clone)]\n@@ -321,7 +320,7 @@ struct RegionResolutionVisitor<'hir: 'a, 'a> {\n     sess: &'a Session,\n \n     // Generated maps:\n-    region_maps: &'a RegionMaps,\n+    region_maps: &'a mut RegionMaps,\n \n     cx: Context,\n \n@@ -354,11 +353,11 @@ struct RegionResolutionVisitor<'hir: 'a, 'a> {\n impl RegionMaps {\n     /// create a bogus code extent for the regions in astencode types. Nobody\n     /// really cares about the contents of these.\n-    pub fn bogus_code_extent(&self, e: CodeExtentData) -> CodeExtent {\n+    pub fn bogus_code_extent(&mut self, e: CodeExtentData) -> CodeExtent {\n         self.intern_code_extent(e, DUMMY_CODE_EXTENT)\n     }\n     pub fn lookup_code_extent(&self, e: CodeExtentData) -> CodeExtent {\n-        match self.code_extent_interner.borrow().get(&e) {\n+        match self.code_extent_interner.get(&e) {\n             Some(&d) => d,\n             None => bug!(\"unknown code extent {:?}\", e)\n         }\n@@ -375,12 +374,12 @@ impl RegionMaps {\n         self.lookup_code_extent(CodeExtentData::CallSiteScope { fn_id: fn_id, body_id: body_id })\n     }\n     pub fn opt_destruction_extent(&self, n: ast::NodeId) -> Option<CodeExtent> {\n-        self.code_extent_interner.borrow().get(&CodeExtentData::DestructionScope(n)).cloned()\n+        self.code_extent_interner.get(&CodeExtentData::DestructionScope(n)).cloned()\n     }\n-    pub fn intern_code_extent(&self,\n+    pub fn intern_code_extent(&mut self,\n                               e: CodeExtentData,\n                               parent: CodeExtent) -> CodeExtent {\n-        match self.code_extent_interner.borrow_mut().entry(e) {\n+        match self.code_extent_interner.entry(e) {\n             Entry::Occupied(o) => {\n                 // this can happen when the bogus code extents from tydecode\n                 // have (bogus) NodeId-s that overlap items created during\n@@ -392,91 +391,90 @@ impl RegionMaps {\n                     info!(\"CodeExtent({}) = {:?} [parent={}] BOGUS!\",\n                           idx.0, e, parent.0);\n                 } else {\n-                    assert_eq!(self.scope_map.borrow()[idx.0 as usize],\n+                    assert_eq!(self.scope_map[idx.0 as usize],\n                                DUMMY_CODE_EXTENT);\n                     info!(\"CodeExtent({}) = {:?} [parent={}] RECLAIMED!\",\n                           idx.0, e, parent.0);\n-                    self.scope_map.borrow_mut()[idx.0 as usize] = parent;\n+                    self.scope_map[idx.0 as usize] = parent;\n                 }\n                 idx\n             }\n             Entry::Vacant(v) => {\n-                if self.code_extents.borrow().len() > 0xffffffffusize {\n+                if self.code_extents.len() > 0xffffffffusize {\n                     bug!() // should pass a sess,\n                            // but this isn't the only place\n                 }\n-                let idx = CodeExtent(self.code_extents.borrow().len() as u32);\n+                let idx = CodeExtent(self.code_extents.len() as u32);\n                 debug!(\"CodeExtent({}) = {:?} [parent={}]\", idx.0, e, parent.0);\n-                self.code_extents.borrow_mut().push(e);\n-                self.scope_map.borrow_mut().push(parent);\n+                self.code_extents.push(e);\n+                self.scope_map.push(parent);\n                 *v.insert(idx)\n             }\n         }\n     }\n-    pub fn intern_node(&self,\n+    pub fn intern_node(&mut self,\n                        n: ast::NodeId,\n                        parent: CodeExtent) -> CodeExtent {\n         self.intern_code_extent(CodeExtentData::Misc(n), parent)\n     }\n     pub fn code_extent_data(&self, e: CodeExtent) -> CodeExtentData {\n-        self.code_extents.borrow()[e.0 as usize]\n+        self.code_extents[e.0 as usize]\n     }\n     pub fn each_encl_scope<E>(&self, mut e:E) where E: FnMut(&CodeExtent, &CodeExtent) {\n-        for child_id in 1..self.code_extents.borrow().len() {\n+        for child_id in 1..self.code_extents.len() {\n             let child = CodeExtent(child_id as u32);\n             if let Some(parent) = self.opt_encl_scope(child) {\n                 e(&child, &parent)\n             }\n         }\n     }\n     pub fn each_var_scope<E>(&self, mut e:E) where E: FnMut(&ast::NodeId, &CodeExtent) {\n-        for (child, parent) in self.var_map.borrow().iter() {\n+        for (child, parent) in self.var_map.iter() {\n             e(child, parent)\n         }\n     }\n \n     /// Records that `sub_fn` is defined within `sup_fn`. These ids\n     /// should be the id of the block that is the fn body, which is\n     /// also the root of the region hierarchy for that fn.\n-    fn record_fn_parent(&self, sub_fn: ast::NodeId, sup_fn: ast::NodeId) {\n+    fn record_fn_parent(&mut self, sub_fn: ast::NodeId, sup_fn: ast::NodeId) {\n         debug!(\"record_fn_parent(sub_fn={:?}, sup_fn={:?})\", sub_fn, sup_fn);\n         assert!(sub_fn != sup_fn);\n-        let previous = self.fn_tree.borrow_mut().insert(sub_fn, sup_fn);\n+        let previous = self.fn_tree.insert(sub_fn, sup_fn);\n         assert!(previous.is_none());\n     }\n \n     fn fn_is_enclosed_by(&self, mut sub_fn: ast::NodeId, sup_fn: ast::NodeId) -> bool {\n-        let fn_tree = self.fn_tree.borrow();\n         loop {\n             if sub_fn == sup_fn { return true; }\n-            match fn_tree.get(&sub_fn) {\n+            match self.fn_tree.get(&sub_fn) {\n                 Some(&s) => { sub_fn = s; }\n                 None => { return false; }\n             }\n         }\n     }\n \n-    fn record_var_scope(&self, var: ast::NodeId, lifetime: CodeExtent) {\n+    fn record_var_scope(&mut self, var: ast::NodeId, lifetime: CodeExtent) {\n         debug!(\"record_var_scope(sub={:?}, sup={:?})\", var, lifetime);\n         assert!(var != lifetime.node_id(self));\n-        self.var_map.borrow_mut().insert(var, lifetime);\n+        self.var_map.insert(var, lifetime);\n     }\n \n-    fn record_rvalue_scope(&self, var: ast::NodeId, lifetime: CodeExtent) {\n+    fn record_rvalue_scope(&mut self, var: ast::NodeId, lifetime: CodeExtent) {\n         debug!(\"record_rvalue_scope(sub={:?}, sup={:?})\", var, lifetime);\n         assert!(var != lifetime.node_id(self));\n-        self.rvalue_scopes.borrow_mut().insert(var, lifetime);\n+        self.rvalue_scopes.insert(var, lifetime);\n     }\n \n-    fn record_shrunk_rvalue_scope(&self, var: ast::NodeId, lifetime: CodeExtent) {\n+    fn record_shrunk_rvalue_scope(&mut self, var: ast::NodeId, lifetime: CodeExtent) {\n         debug!(\"record_rvalue_scope(sub={:?}, sup={:?})\", var, lifetime);\n         assert!(var != lifetime.node_id(self));\n-        self.shrunk_rvalue_scopes.borrow_mut().insert(var, lifetime);\n+        self.shrunk_rvalue_scopes.insert(var, lifetime);\n     }\n \n     pub fn opt_encl_scope(&self, id: CodeExtent) -> Option<CodeExtent> {\n         //! Returns the narrowest scope that encloses `id`, if any.\n-        self.scope_map.borrow()[id.0 as usize].into_option()\n+        self.scope_map[id.0 as usize].into_option()\n     }\n \n     #[allow(dead_code)] // used in cfg\n@@ -487,15 +485,15 @@ impl RegionMaps {\n \n     /// Returns the lifetime of the local variable `var_id`\n     pub fn var_scope(&self, var_id: ast::NodeId) -> CodeExtent {\n-        match self.var_map.borrow().get(&var_id) {\n+        match self.var_map.get(&var_id) {\n             Some(&r) => r,\n             None => { bug!(\"no enclosing scope for id {:?}\", var_id); }\n         }\n     }\n \n     pub fn temporary_scope2(&self, expr_id: ast::NodeId) -> (Option<CodeExtent>, bool) {\n         let temporary_scope = self.temporary_scope(expr_id);\n-        let was_shrunk = match self.shrunk_rvalue_scopes.borrow().get(&expr_id) {\n+        let was_shrunk = match self.shrunk_rvalue_scopes.get(&expr_id) {\n             Some(&s) => {\n                 info!(\"temporary_scope2({:?}, scope={:?}, shrunk={:?})\",\n                       expr_id, temporary_scope, s);\n@@ -513,21 +511,21 @@ impl RegionMaps {\n         let temporary_scope = self.temporary_scope(expr_id);\n         (temporary_scope,\n          self.shrunk_rvalue_scopes\n-             .borrow().get(&expr_id).cloned()\n+             .get(&expr_id).cloned()\n              .or(temporary_scope))\n     }\n \n     pub fn temporary_scope(&self, expr_id: ast::NodeId) -> Option<CodeExtent> {\n         //! Returns the scope when temp created by expr_id will be cleaned up\n \n         // check for a designated rvalue scope\n-        if let Some(&s) = self.rvalue_scopes.borrow().get(&expr_id) {\n+        if let Some(&s) = self.rvalue_scopes.get(&expr_id) {\n             debug!(\"temporary_scope({:?}) = {:?} [custom]\", expr_id, s);\n             return Some(s);\n         }\n \n-        let scope_map : &[CodeExtent] = &self.scope_map.borrow();\n-        let code_extents: &[CodeExtentData] = &self.code_extents.borrow();\n+        let scope_map : &[CodeExtent] = &self.scope_map;\n+        let code_extents: &[CodeExtentData] = &self.code_extents;\n \n         // else, locate the innermost terminating scope\n         // if there's one. Static items, for instance, won't\n@@ -601,7 +599,7 @@ impl RegionMaps {\n         let mut a_vec: Vec<CodeExtent> = vec![];\n         let mut b_buf: [CodeExtent; 32] = [ROOT_CODE_EXTENT; 32];\n         let mut b_vec: Vec<CodeExtent> = vec![];\n-        let scope_map : &[CodeExtent] = &self.scope_map.borrow();\n+        let scope_map : &[CodeExtent] = &self.scope_map;\n         let a_ancestors = ancestors_of(scope_map,\n                                        scope_a, &mut a_buf, &mut a_vec);\n         let b_ancestors = ancestors_of(scope_map,\n@@ -1216,7 +1214,7 @@ impl<'hir, 'a> RegionResolutionVisitor<'hir, 'a> {\n         // functions put their destruction scopes *inside* their parameter\n         // scopes.\n         let scope = CodeExtentData::DestructionScope(id);\n-        if !self.region_maps.code_extent_interner.borrow().contains_key(&scope) {\n+        if !self.region_maps.code_extent_interner.contains_key(&scope) {\n             self.region_maps.intern_code_extent(scope, ROOT_CODE_EXTENT);\n         }\n     }\n@@ -1278,14 +1276,14 @@ fn region_resolve_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateN\n \n     let krate = hir_map.krate();\n \n-    let maps = RegionMaps {\n-        code_extents: RefCell::new(vec![]),\n-        code_extent_interner: RefCell::new(FxHashMap()),\n-        scope_map: RefCell::new(vec![]),\n-        var_map: RefCell::new(NodeMap()),\n-        rvalue_scopes: RefCell::new(NodeMap()),\n-        shrunk_rvalue_scopes: RefCell::new(NodeMap()),\n-        fn_tree: RefCell::new(NodeMap()),\n+    let mut maps = RegionMaps {\n+        code_extents: vec![],\n+        code_extent_interner: FxHashMap(),\n+        scope_map: vec![],\n+        var_map: NodeMap(),\n+        rvalue_scopes: NodeMap(),\n+        shrunk_rvalue_scopes: NodeMap(),\n+        fn_tree: NodeMap(),\n     };\n     let root_extent = maps.bogus_code_extent(\n         CodeExtentData::DestructionScope(ast::DUMMY_NODE_ID));\n@@ -1296,7 +1294,7 @@ fn region_resolve_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateN\n     {\n         let mut visitor = RegionResolutionVisitor {\n             sess: sess,\n-            region_maps: &maps,\n+            region_maps: &mut maps,\n             map: hir_map,\n             cx: Context {\n                 root_id: None,"}]}