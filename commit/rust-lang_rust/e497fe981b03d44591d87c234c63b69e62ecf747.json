{"sha": "e497fe981b03d44591d87c234c63b69e62ecf747", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0OTdmZTk4MWIwM2Q0NDU5MWQ4N2MyMzRjNjNiNjllNjJlY2Y3NDc=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-10-19T20:10:39Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-10-19T20:10:39Z"}, "message": "Partial work on adding types to the AST", "tree": {"sha": "4f01f36566f477d0eb0e516f2803c18ec5937546", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f01f36566f477d0eb0e516f2803c18ec5937546"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e497fe981b03d44591d87c234c63b69e62ecf747", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e497fe981b03d44591d87c234c63b69e62ecf747", "html_url": "https://github.com/rust-lang/rust/commit/e497fe981b03d44591d87c234c63b69e62ecf747", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e497fe981b03d44591d87c234c63b69e62ecf747/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a3edb320dd515fd98431997d4bdb1ffa31446bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a3edb320dd515fd98431997d4bdb1ffa31446bd", "html_url": "https://github.com/rust-lang/rust/commit/4a3edb320dd515fd98431997d4bdb1ffa31446bd"}], "stats": {"total": 125, "additions": 71, "deletions": 54}, "files": [{"sha": "e2dcf15963fe8be5477667a164c5a25517af1786", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e497fe981b03d44591d87c234c63b69e62ecf747/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e497fe981b03d44591d87c234c63b69e62ecf747/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=e497fe981b03d44591d87c234c63b69e62ecf747", "patch": "@@ -84,20 +84,20 @@ tag decl_ {\n \n type expr = spanned[expr_];\n tag expr_ {\n-    expr_vec(vec[@expr]);\n-    expr_tup(vec[tup(bool /* mutability */, @expr)]);\n-    expr_rec(vec[tup(ident,@expr)]);\n-    expr_call(@expr, vec[@expr]);\n-    expr_binary(binop, @expr, @expr);\n-    expr_unary(unop, @expr);\n-    expr_lit(@lit);\n+    expr_vec(vec[@expr], option[@ty]);\n+    expr_tup(vec[tup(bool /* mutability */, @expr)], option[@ty]);\n+    expr_rec(vec[tup(ident,@expr)], option[@ty]);\n+    expr_call(@expr, vec[@expr], option[@ty]);\n+    expr_binary(binop, @expr, @expr, option[@ty]);\n+    expr_unary(unop, @expr, option[@ty]);\n+    expr_lit(@lit, option[@ty]);\n     expr_cast(@expr, @ty);\n-    expr_if(@expr, block, option[block]);\n-    expr_block(block);\n-    expr_assign(@expr /* TODO: @expr : is_lval(@expr) */, @expr);\n-    expr_field(@expr, ident);\n-    expr_index(@expr, @expr);\n-    expr_name(name, option[def]);\n+    expr_if(@expr, block, option[block], option[@ty]);\n+    expr_block(block, option[@ty]);\n+    expr_assign(@expr /* TODO: @expr|is_lval */, @expr, option[@ty]);\n+    expr_field(@expr, ident, option[@ty]);\n+    expr_index(@expr, @expr, option[@ty]);\n+    expr_name(name, option[def], option[@ty]);\n }\n \n type lit = spanned[lit_];"}, {"sha": "a3a356912a9e914ad694ac8b66fad7fcd2c44862", "filename": "src/comp/middle/fold.rs", "status": "modified", "additions": 58, "deletions": 41, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/e497fe981b03d44591d87c234c63b69e62ecf747/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e497fe981b03d44591d87c234c63b69e62ecf747/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=e497fe981b03d44591d87c234c63b69e62ecf747", "patch": "@@ -50,53 +50,63 @@ type ast_fold[ENV] =\n \n      // Expr folds.\n      (fn(&ENV e, &span sp,\n-         vec[@expr] es) -> @expr)                 fold_expr_vec,\n+         vec[@expr] es, option[@ty] ty) -> @expr) fold_expr_vec,\n \n      (fn(&ENV e, &span sp,\n-         vec[tup(bool,@expr)] es) -> @expr)       fold_expr_tup,\n+         vec[tup(bool,@expr)] es,\n+         option[@ty] ty) -> @expr)                fold_expr_tup,\n \n      (fn(&ENV e, &span sp,\n-         vec[tup(ident,@expr)] fields) -> @expr)  fold_expr_rec,\n+         vec[tup(ident,@expr)] fields,\n+         option[@ty] ty) -> @expr)                fold_expr_rec,\n \n      (fn(&ENV e, &span sp,\n-         @expr f, vec[@expr] args) -> @expr)      fold_expr_call,\n+         @expr f, vec[@expr] args,\n+         option[@ty] ty) -> @expr)                fold_expr_call,\n \n      (fn(&ENV e, &span sp,\n          ast.binop,\n-         @expr lhs, @expr rhs) -> @expr)          fold_expr_binary,\n+         @expr lhs, @expr rhs,\n+         option[@ty] ty) -> @expr)                fold_expr_binary,\n \n      (fn(&ENV e, &span sp,\n-         ast.unop, @expr e) -> @expr)             fold_expr_unary,\n+         ast.unop, @expr e,\n+         option[@ty] ty) -> @expr)                fold_expr_unary,\n \n      (fn(&ENV e, &span sp,\n-         @ast.lit) -> @expr)                      fold_expr_lit,\n+         @ast.lit, option[@ty] ty) -> @expr)      fold_expr_lit,\n \n      (fn(&ENV e, &span sp,\n          @expr cond, &block thn,\n-         &option[block] els) -> @expr)            fold_expr_if,\n+         &option[block] els,\n+         option[@ty] ty) -> @expr)                fold_expr_if,\n \n      (fn(&ENV e, &span sp,\n-         &block blk) -> @expr)                    fold_expr_block,\n+         &block blk, option[@ty] ty) -> @expr)    fold_expr_block,\n \n      (fn(&ENV e, &span sp,\n-         @expr lhs, @expr rhs) -> @expr)          fold_expr_assign,\n+         @expr lhs, @expr rhs,\n+         option[@ty] ty) -> @expr)                fold_expr_assign,\n \n      (fn(&ENV e, &span sp,\n-         @expr e, ident i) -> @expr)              fold_expr_field,\n+         @expr e, ident i,\n+         option[@ty] ty) -> @expr)                fold_expr_field,\n \n      (fn(&ENV e, &span sp,\n-         @expr e, @expr ix) -> @expr)             fold_expr_index,\n+         @expr e, @expr ix,\n+         option[@ty] ty) -> @expr)                fold_expr_index,\n \n      (fn(&ENV e, &span sp,\n          &name n,\n-         &option[def] d) -> @expr)                fold_expr_name,\n+         &option[def] d,\n+         option[@ty] ty) -> @expr)                fold_expr_name,\n \n      // Decl folds.\n      (fn(&ENV e, &span sp,\n          &ast.local local) -> @decl)              fold_decl_local,\n \n      (fn(&ENV e, &span sp,\n-         @item item) -> @decl)                    fold_decl_item,\n+         @item item, option[@ty] ty) -> @decl)    fold_decl_item,\n \n \n      // Stmt folds.\n@@ -536,68 +546,75 @@ fn identity_fold_ty_path[ENV](&ENV env, &span sp, ast.path p,\n \n // Expr identities.\n \n-fn identity_fold_expr_vec[ENV](&ENV env, &span sp, vec[@expr] es) -> @expr {\n-    ret @respan(sp, ast.expr_vec(es));\n+fn identity_fold_expr_vec[ENV](&ENV env, &span sp, vec[@expr] es,\n+                               option[@ty] ty) -> @expr {\n+    ret @respan(sp, ast.expr_vec(es, ty));\n }\n \n-fn identity_fold_expr_tup[ENV](&ENV env, &span sp, vec[tup(bool, @expr)] es)\n-        -> @expr {\n-    ret @respan(sp, ast.expr_tup(es));\n+fn identity_fold_expr_tup[ENV](&ENV env, &span sp, vec[tup(bool, @expr)] es,\n+                               option[@ty] ty) -> @expr {\n+    ret @respan(sp, ast.expr_tup(es, ty));\n }\n \n fn identity_fold_expr_rec[ENV](&ENV env, &span sp,\n-                               vec[tup(ident,@expr)] fields)\n+                               vec[tup(ident,@expr)] fields, option[@ty] ty)\n     -> @expr {\n-    ret @respan(sp, ast.expr_rec(fields));\n+    ret @respan(sp, ast.expr_rec(fields, ty));\n }\n \n fn identity_fold_expr_call[ENV](&ENV env, &span sp, @expr f,\n-                                vec[@expr] args) -> @expr {\n-    ret @respan(sp, ast.expr_call(f, args));\n+                                vec[@expr] args, option[@ty] ty) -> @expr {\n+    ret @respan(sp, ast.expr_call(f, args, ty));\n }\n \n fn identity_fold_expr_binary[ENV](&ENV env, &span sp, ast.binop b,\n-                                  @expr lhs, @expr rhs) -> @expr {\n-    ret @respan(sp, ast.expr_binary(b, lhs, rhs));\n+                                  @expr lhs, @expr rhs,\n+                                  option[@ty] ty) -> @expr {\n+    ret @respan(sp, ast.expr_binary(b, lhs, rhs, ty));\n }\n \n fn identity_fold_expr_unary[ENV](&ENV env, &span sp,\n-                                 ast.unop u, @expr e) -> @expr {\n-    ret @respan(sp, ast.expr_unary(u, e));\n+                                 ast.unop u, @expr e, option[@ty] ty)\n+        -> @expr {\n+    ret @respan(sp, ast.expr_unary(u, e, ty));\n }\n \n-fn identity_fold_expr_lit[ENV](&ENV env, &span sp, @ast.lit lit) -> @expr {\n-    ret @respan(sp, ast.expr_lit(lit));\n+fn identity_fold_expr_lit[ENV](&ENV env, &span sp, @ast.lit lit,\n+                               option[@ty] ty) -> @expr {\n+    ret @respan(sp, ast.expr_lit(lit, ty));\n }\n \n fn identity_fold_expr_if[ENV](&ENV env, &span sp,\n                               @expr cond, &block thn,\n-                              &option[block] els) -> @expr {\n-    ret @respan(sp, ast.expr_if(cond, thn, els));\n+                              &option[block] els, option[@ty] ty) -> @expr {\n+    ret @respan(sp, ast.expr_if(cond, thn, els, ty));\n }\n \n-fn identity_fold_expr_block[ENV](&ENV env, &span sp, &block blk) -> @expr {\n-    ret @respan(sp, ast.expr_block(blk));\n+fn identity_fold_expr_block[ENV](&ENV env, &span sp, &block blk,\n+                                 option[@ty] ty) -> @expr {\n+    ret @respan(sp, ast.expr_block(blk, ty));\n }\n \n fn identity_fold_expr_assign[ENV](&ENV env, &span sp,\n-                                  @expr lhs, @expr rhs) -> @expr {\n-    ret @respan(sp, ast.expr_assign(lhs, rhs));\n+                                  @expr lhs, @expr rhs, option[@ty] ty)\n+        -> @expr {\n+    ret @respan(sp, ast.expr_assign(lhs, rhs, ty));\n }\n \n fn identity_fold_expr_field[ENV](&ENV env, &span sp,\n-                                 @expr e, ident i) -> @expr {\n-    ret @respan(sp, ast.expr_field(e, i));\n+                                 @expr e, ident i, option[@ty] ty) -> @expr {\n+    ret @respan(sp, ast.expr_field(e, i, ty));\n }\n \n fn identity_fold_expr_index[ENV](&ENV env, &span sp,\n-                                 @expr e, @expr ix) -> @expr {\n-    ret @respan(sp, ast.expr_index(e, ix));\n+                                 @expr e, @expr ix, option[@ty] ty) -> @expr {\n+    ret @respan(sp, ast.expr_index(e, ix, ty));\n }\n \n fn identity_fold_expr_name[ENV](&ENV env, &span sp,\n-                                &name n, &option[def] d) -> @expr {\n-    ret @respan(sp, ast.expr_name(n, d));\n+                                &name n, &option[def] d,\n+                                option[@ty] ty) -> @expr {\n+    ret @respan(sp, ast.expr_name(n, d, ty));\n }\n \n "}]}