{"sha": "24172084e1ebd750de9adc0b65456b660d7c8c8b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0MTcyMDg0ZTFlYmQ3NTBkZTlhZGMwYjY1NDU2YjY2MGQ3YzhjOGI=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-08T10:11:56Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-08T10:11:56Z"}, "message": "Rollup merge of #64152 - cramertj:update-backtrace, r=alexcrichton\n\nUse backtrace formatting from the backtrace crate\n\nr? @alexcrichton", "tree": {"sha": "b42d856467b80db88acb2fc6a18ddf5b47fe0b80", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b42d856467b80db88acb2fc6a18ddf5b47fe0b80"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/24172084e1ebd750de9adc0b65456b660d7c8c8b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJddNPsCRBK7hj4Ov3rIwAAdHIIADv0msTEr0pC6nSzLFtlCUYT\npi+1Rpg1E7VbOK1Pc1a9OPwWoUlMinOVmcldt2XQBY6hyn9wLcKH7vlvayNWVipv\nxquNXFCpcW5c5m3abMtMAPy7Y1dtx1ZKVifItMEcxhOZl6tE/BpS7kbjpsoUzfas\nH0vmcxOvnq8Vudi7u3zCw8tCQGs9jYoxF366AG9/zYhqY1/cP9SQE7JCc1FxlWFL\n+nVQfGvvEkBkZ82Kdpq4ppa3H8VG2kWb+pemOKh9Zkwo2hE4GfdxNdre/F5rVdz5\nAiWN4XATrD9AyhAPUZwx0hctNP+aDhTWamv67zw1DroItIH7hLTP2xIfUqbMqow=\n=NV1c\n-----END PGP SIGNATURE-----\n", "payload": "tree b42d856467b80db88acb2fc6a18ddf5b47fe0b80\nparent 0ac09aef84b40fe4d1efc9580f49215ea8c94b2a\nparent 290f5b22752f98071bbc25530fc10a7169e671a3\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1567937516 +0200\ncommitter GitHub <noreply@github.com> 1567937516 +0200\n\nRollup merge of #64152 - cramertj:update-backtrace, r=alexcrichton\n\nUse backtrace formatting from the backtrace crate\n\nr? @alexcrichton\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/24172084e1ebd750de9adc0b65456b660d7c8c8b", "html_url": "https://github.com/rust-lang/rust/commit/24172084e1ebd750de9adc0b65456b660d7c8c8b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/24172084e1ebd750de9adc0b65456b660d7c8c8b/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ac09aef84b40fe4d1efc9580f49215ea8c94b2a", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ac09aef84b40fe4d1efc9580f49215ea8c94b2a", "html_url": "https://github.com/rust-lang/rust/commit/0ac09aef84b40fe4d1efc9580f49215ea8c94b2a"}, {"sha": "290f5b22752f98071bbc25530fc10a7169e671a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/290f5b22752f98071bbc25530fc10a7169e671a3", "html_url": "https://github.com/rust-lang/rust/commit/290f5b22752f98071bbc25530fc10a7169e671a3"}], "stats": {"total": 249, "additions": 96, "deletions": 153}, "files": [{"sha": "328d96023bc1f776410157e2a192fe137fea197b", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24172084e1ebd750de9adc0b65456b660d7c8c8b/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/24172084e1ebd750de9adc0b65456b660d7c8c8b/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=24172084e1ebd750de9adc0b65456b660d7c8c8b", "patch": "@@ -109,9 +109,9 @@ dependencies = [\n \n [[package]]\n name = \"backtrace\"\n-version = \"0.3.35\"\n+version = \"0.3.37\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1371048253fa3bac6704bfd6bbfc922ee9bdcee8881330d40f308b81cc5adc55\"\n+checksum = \"5180c5a20655b14a819b652fd2378fa5f1697b6c9ddad3e695c2f9cedf6df4e2\"\n dependencies = [\n  \"backtrace-sys\",\n  \"cfg-if\","}, {"sha": "b5cbec7b0fadcd3e3a338d88c36d5bcf98aac908", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24172084e1ebd750de9adc0b65456b660d7c8c8b/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/24172084e1ebd750de9adc0b65456b660d7c8c8b/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=24172084e1ebd750de9adc0b65456b660d7c8c8b", "patch": "@@ -26,7 +26,7 @@ unwind = { path = \"../libunwind\" }\n hashbrown = { version = \"0.5.0\", features = ['rustc-dep-of-std'] }\n \n [dependencies.backtrace]\n-version = \"0.3.35\"\n+version = \"0.3.37\"\n default-features = false # don't use coresymbolication on OSX\n features = [\n   \"rustc-dep-of-std\", # enable build support for integrating into libstd"}, {"sha": "db4089c294812d99e43f838e66621fcbf27507b6", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/24172084e1ebd750de9adc0b65456b660d7c8c8b/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24172084e1ebd750de9adc0b65456b660d7c8c8b/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=24172084e1ebd750de9adc0b65456b660d7c8c8b", "patch": "@@ -158,7 +158,7 @@ pub fn take_hook() -> Box<dyn Fn(&PanicInfo<'_>) + 'static + Sync + Send> {\n \n fn default_hook(info: &PanicInfo<'_>) {\n     #[cfg(feature = \"backtrace\")]\n-    use crate::sys_common::backtrace;\n+    use crate::sys_common::{backtrace as backtrace_mod};\n \n     // If this is a double panic, make sure that we print a backtrace\n     // for this panic. Otherwise only print it if logging is enabled.\n@@ -167,9 +167,9 @@ fn default_hook(info: &PanicInfo<'_>) {\n         let panics = update_panic_count(0);\n \n         if panics >= 2 {\n-            Some(backtrace::PrintFormat::Full)\n+            Some(backtrace::PrintFmt::Full)\n         } else {\n-            backtrace::log_enabled()\n+            backtrace_mod::log_enabled()\n         }\n     };\n \n@@ -197,7 +197,7 @@ fn default_hook(info: &PanicInfo<'_>) {\n             static FIRST_PANIC: AtomicBool = AtomicBool::new(true);\n \n             if let Some(format) = log_backtrace {\n-                let _ = backtrace::print(err, format);\n+                let _ = backtrace_mod::print(err, format);\n             } else if FIRST_PANIC.compare_and_swap(true, false, Ordering::SeqCst) {\n                 let _ = writeln!(err, \"note: run with `RUST_BACKTRACE=1` \\\n                                        environment variable to display a backtrace.\");"}, {"sha": "f434b62aced678075c584e06bb3f62c595305dd3", "filename": "src/libstd/sys_common/backtrace.rs", "status": "modified", "additions": 89, "deletions": 146, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/24172084e1ebd750de9adc0b65456b660d7c8c8b/src%2Flibstd%2Fsys_common%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24172084e1ebd750de9adc0b65456b660d7c8c8b/src%2Flibstd%2Fsys_common%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fbacktrace.rs?ref=24172084e1ebd750de9adc0b65456b660d7c8c8b", "patch": "@@ -2,23 +2,20 @@\n /// supported platforms.\n \n use crate::env;\n+use crate::fmt;\n use crate::io;\n use crate::io::prelude::*;\n-use crate::mem;\n use crate::path::{self, Path};\n-use crate::ptr;\n use crate::sync::atomic::{self, Ordering};\n use crate::sys::mutex::Mutex;\n \n-use backtrace::{BytesOrWideString, Frame, Symbol};\n-\n-pub const HEX_WIDTH: usize = 2 + 2 * mem::size_of::<usize>();\n+use backtrace::{BacktraceFmt, BytesOrWideString, PrintFmt};\n \n /// Max number of frames to print.\n const MAX_NB_FRAMES: usize = 100;\n \n /// Prints the current backtrace.\n-pub fn print(w: &mut dyn Write, format: PrintFormat) -> io::Result<()> {\n+pub fn print(w: &mut dyn Write, format: PrintFmt) -> io::Result<()> {\n     static LOCK: Mutex = Mutex::new();\n \n     // There are issues currently linking libbacktrace into tests, and in\n@@ -39,26 +36,66 @@ pub fn print(w: &mut dyn Write, format: PrintFormat) -> io::Result<()> {\n     }\n }\n \n-fn _print(w: &mut dyn Write, format: PrintFormat) -> io::Result<()> {\n-    writeln!(w, \"stack backtrace:\")?;\n+fn _print(w: &mut dyn Write, format: PrintFmt) -> io::Result<()> {\n+    struct DisplayBacktrace {\n+        format: PrintFmt,\n+    }\n+    impl fmt::Display for DisplayBacktrace {\n+        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            _print_fmt(fmt, self.format)\n+        }\n+    }\n+    write!(w, \"{}\", DisplayBacktrace { format })\n+}\n \n-    let mut printer = Printer::new(format, w);\n+fn _print_fmt(fmt: &mut fmt::Formatter<'_>, print_fmt: PrintFmt) -> fmt::Result {\n+    let mut print_path = move |fmt: &mut fmt::Formatter<'_>, bows: BytesOrWideString<'_>| {\n+        output_filename(fmt, bows, print_fmt)\n+    };\n+    let mut bt_fmt = BacktraceFmt::new(fmt, print_fmt, &mut print_path);\n+    bt_fmt.add_context()?;\n+    let mut skipped = false;\n     unsafe {\n+        let mut idx = 0;\n+        let mut res = Ok(());\n         backtrace::trace_unsynchronized(|frame| {\n+            if print_fmt == PrintFmt::Short && idx > MAX_NB_FRAMES {\n+                skipped = true;\n+                return false;\n+            }\n+\n             let mut hit = false;\n+            let mut stop = false;\n             backtrace::resolve_frame_unsynchronized(frame, |symbol| {\n                 hit = true;\n-                printer.output(frame, Some(symbol));\n+                if print_fmt == PrintFmt::Short {\n+                    if let Some(sym) = symbol.name().and_then(|s| s.as_str()) {\n+                        if sym.contains(\"__rust_begin_short_backtrace\") {\n+                            skipped = true;\n+                            stop = true;\n+                            return;\n+                        }\n+                    }\n+                }\n+\n+                res = bt_fmt.frame().symbol(frame, symbol);\n             });\n+            if stop {\n+                return false;\n+            }\n             if !hit {\n-                printer.output(frame, None);\n+                res = bt_fmt.frame().print_raw(frame.ip(), None, None, None);\n             }\n-            !printer.done\n+\n+            idx += 1;\n+            res.is_ok()\n         });\n+        res?;\n     }\n-    if printer.skipped {\n+    bt_fmt.finish()?;\n+    if skipped {\n         writeln!(\n-            w,\n+            fmt,\n             \"note: Some details are omitted, \\\n              run with `RUST_BACKTRACE=full` for a verbose backtrace.\"\n         )?;\n@@ -77,33 +114,24 @@ where\n     f()\n }\n \n-/// Controls how the backtrace should be formatted.\n-#[derive(Debug, Copy, Clone, Eq, PartialEq)]\n-pub enum PrintFormat {\n-    /// Show only relevant data from the backtrace.\n-    Short = 2,\n-    /// Show all the frames with absolute path for files.\n-    Full = 3,\n-}\n-\n // For now logging is turned off by default, and this function checks to see\n // whether the magical environment variable is present to see if it's turned on.\n-pub fn log_enabled() -> Option<PrintFormat> {\n+pub fn log_enabled() -> Option<PrintFmt> {\n     static ENABLED: atomic::AtomicIsize = atomic::AtomicIsize::new(0);\n     match ENABLED.load(Ordering::SeqCst) {\n         0 => {}\n         1 => return None,\n-        2 => return Some(PrintFormat::Short),\n-        _ => return Some(PrintFormat::Full),\n+        2 => return Some(PrintFmt::Short),\n+        _ => return Some(PrintFmt::Full),\n     }\n \n     let val = env::var_os(\"RUST_BACKTRACE\").and_then(|x| {\n         if &x == \"0\" {\n             None\n         } else if &x == \"full\" {\n-            Some(PrintFormat::Full)\n+            Some(PrintFmt::Full)\n         } else {\n-            Some(PrintFormat::Short)\n+            Some(PrintFmt::Short)\n         }\n     });\n     ENABLED.store(\n@@ -116,130 +144,45 @@ pub fn log_enabled() -> Option<PrintFormat> {\n     val\n }\n \n-struct Printer<'a, 'b> {\n-    format: PrintFormat,\n-    done: bool,\n-    skipped: bool,\n-    idx: usize,\n-    out: &'a mut (dyn Write + 'b),\n-}\n-\n-impl<'a, 'b> Printer<'a, 'b> {\n-    fn new(format: PrintFormat, out: &'a mut (dyn Write + 'b)) -> Printer<'a, 'b> {\n-        Printer { format, done: false, skipped: false, idx: 0, out }\n-    }\n-\n-    /// Prints the symbol of the backtrace frame.\n-    ///\n-    /// These output functions should now be used everywhere to ensure consistency.\n-    /// You may want to also use `output_fileline`.\n-    fn output(&mut self, frame: &Frame, symbol: Option<&Symbol>) {\n-        if self.idx > MAX_NB_FRAMES {\n-            self.done = true;\n-            self.skipped = true;\n-            return;\n-        }\n-        if self._output(frame, symbol).is_err() {\n-            self.done = true;\n-        }\n-        self.idx += 1;\n-    }\n-\n-    fn _output(&mut self, frame: &Frame, symbol: Option<&Symbol>) -> io::Result<()> {\n-        if self.format == PrintFormat::Short {\n-            if let Some(sym) = symbol.and_then(|s| s.name()).and_then(|s| s.as_str()) {\n-                if sym.contains(\"__rust_begin_short_backtrace\") {\n-                    self.skipped = true;\n-                    self.done = true;\n-                    return Ok(());\n-                }\n-            }\n-\n-            // Remove the `17: 0x0 - <unknown>` line.\n-            if self.format == PrintFormat::Short && frame.ip() == ptr::null_mut() {\n-                self.skipped = true;\n-                return Ok(());\n-            }\n-        }\n-\n-        match self.format {\n-            PrintFormat::Full => {\n-                write!(self.out, \"  {:2}: {:2$?} - \", self.idx, frame.ip(), HEX_WIDTH)?\n-            }\n-            PrintFormat::Short => write!(self.out, \"  {:2}: \", self.idx)?,\n-        }\n-\n-        match symbol.and_then(|s| s.name()) {\n-            Some(symbol) => {\n-                match self.format {\n-                    PrintFormat::Full => write!(self.out, \"{}\", symbol)?,\n-                    // Strip the trailing hash if short mode.\n-                    PrintFormat::Short => write!(self.out, \"{:#}\", symbol)?,\n-                }\n-            }\n-            None => self.out.write_all(b\"<unknown>\")?,\n+/// Prints the filename of the backtrace frame.\n+///\n+/// See also `output`.\n+fn output_filename(\n+    fmt: &mut fmt::Formatter<'_>,\n+    bows: BytesOrWideString<'_>,\n+    print_fmt: PrintFmt,\n+) -> fmt::Result {\n+    #[cfg(windows)]\n+    let path_buf;\n+    let file = match bows {\n+        #[cfg(unix)]\n+        BytesOrWideString::Bytes(bytes) => {\n+            use crate::os::unix::prelude::*;\n+            Path::new(crate::ffi::OsStr::from_bytes(bytes))\n         }\n-        self.out.write_all(b\"\\n\")?;\n-        if let Some(sym) = symbol {\n-            self.output_fileline(sym)?;\n+        #[cfg(not(unix))]\n+        BytesOrWideString::Bytes(bytes) => {\n+            Path::new(crate::str::from_utf8(bytes).unwrap_or(\"<unknown>\"))\n         }\n-        Ok(())\n-    }\n-\n-    /// Prints the filename and line number of the backtrace frame.\n-    ///\n-    /// See also `output`.\n-    fn output_fileline(&mut self, symbol: &Symbol) -> io::Result<()> {\n         #[cfg(windows)]\n-        let path_buf;\n-        let file = match symbol.filename_raw() {\n-            #[cfg(unix)]\n-            Some(BytesOrWideString::Bytes(bytes)) => {\n-                use crate::os::unix::prelude::*;\n-                Path::new(crate::ffi::OsStr::from_bytes(bytes))\n-            }\n-            #[cfg(not(unix))]\n-            Some(BytesOrWideString::Bytes(bytes)) => {\n-                Path::new(crate::str::from_utf8(bytes).unwrap_or(\"<unknown>\"))\n-            }\n-            #[cfg(windows)]\n-            Some(BytesOrWideString::Wide(wide)) => {\n-                use crate::os::windows::prelude::*;\n-                path_buf = crate::ffi::OsString::from_wide(wide);\n-                Path::new(&path_buf)\n-            }\n-            #[cfg(not(windows))]\n-            Some(BytesOrWideString::Wide(_wide)) => {\n-                Path::new(\"<unknown>\")\n-            }\n-            None => return Ok(()),\n-        };\n-        let line = match symbol.lineno() {\n-            Some(line) => line,\n-            None => return Ok(()),\n-        };\n-        // prior line: \"  ##: {:2$} - func\"\n-        self.out.write_all(b\"\")?;\n-        match self.format {\n-            PrintFormat::Full => write!(self.out, \"           {:1$}\", \"\", HEX_WIDTH)?,\n-            PrintFormat::Short => write!(self.out, \"           \")?,\n+        BytesOrWideString::Wide(wide) => {\n+            use crate::os::windows::prelude::*;\n+            path_buf = crate::ffi::OsString::from_wide(wide);\n+            Path::new(&path_buf)\n         }\n-\n-        let mut already_printed = false;\n-        if self.format == PrintFormat::Short && file.is_absolute() {\n-            if let Ok(cwd) = env::current_dir() {\n-                if let Ok(stripped) = file.strip_prefix(&cwd) {\n-                    if let Some(s) = stripped.to_str() {\n-                        write!(self.out, \"  at .{}{}:{}\", path::MAIN_SEPARATOR, s, line)?;\n-                        already_printed = true;\n-                    }\n+        #[cfg(not(windows))]\n+        BytesOrWideString::Wide(_wide) => {\n+            Path::new(\"<unknown>\")\n+        }\n+    };\n+    if print_fmt == PrintFmt::Short && file.is_absolute() {\n+        if let Ok(cwd) = env::current_dir() {\n+            if let Ok(stripped) = file.strip_prefix(&cwd) {\n+                if let Some(s) = stripped.to_str() {\n+                    return write!(fmt, \".{}{}\", path::MAIN_SEPARATOR, s);\n                 }\n             }\n         }\n-        if !already_printed {\n-            write!(self.out, \"  at {}:{}\", file.display(), line)?;\n-        }\n-\n-        self.out.write_all(b\"\\n\")\n     }\n+    fmt::Display::fmt(&file.display(), fmt)\n }"}]}