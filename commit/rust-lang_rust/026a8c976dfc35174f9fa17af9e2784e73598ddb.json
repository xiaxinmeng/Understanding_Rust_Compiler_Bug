{"sha": "026a8c976dfc35174f9fa17af9e2784e73598ddb", "node_id": "C_kwDOAAsO6NoAKDAyNmE4Yzk3NmRmYzM1MTc0ZjlmYTE3YWY5ZTI3ODRlNzM1OThkZGI", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-02-15T12:38:42Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-02-15T12:38:42Z"}, "message": "Simplify", "tree": {"sha": "7330774b7b9190b2d3575e90e38dbfcfaa60dcfe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7330774b7b9190b2d3575e90e38dbfcfaa60dcfe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/026a8c976dfc35174f9fa17af9e2784e73598ddb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/026a8c976dfc35174f9fa17af9e2784e73598ddb", "html_url": "https://github.com/rust-lang/rust/commit/026a8c976dfc35174f9fa17af9e2784e73598ddb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/026a8c976dfc35174f9fa17af9e2784e73598ddb/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89b994049147e6ed947c8ee5a29547be448874a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/89b994049147e6ed947c8ee5a29547be448874a0", "html_url": "https://github.com/rust-lang/rust/commit/89b994049147e6ed947c8ee5a29547be448874a0"}], "stats": {"total": 198, "additions": 91, "deletions": 107}, "files": [{"sha": "9bc1c54a3c6412eb4531a9aa48decadbf2448bf4", "filename": "crates/hir-def/src/adt.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/026a8c976dfc35174f9fa17af9e2784e73598ddb/crates%2Fhir-def%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026a8c976dfc35174f9fa17af9e2784e73598ddb/crates%2Fhir-def%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fadt.rs?ref=026a8c976dfc35174f9fa17af9e2784e73598ddb", "patch": "@@ -2,9 +2,10 @@\n \n use std::sync::Arc;\n \n-use crate::tt::{Delimiter, DelimiterKind, Leaf, Subtree, TokenTree};\n use base_db::CrateId;\n+use cfg::CfgOptions;\n use either::Either;\n+\n use hir_expand::{\n     name::{AsName, Name},\n     HirFileId, InFile,\n@@ -24,12 +25,12 @@ use crate::{\n     src::HasChildSource,\n     src::HasSource,\n     trace::Trace,\n+    tt::{Delimiter, DelimiterKind, Leaf, Subtree, TokenTree},\n     type_ref::TypeRef,\n     visibility::RawVisibility,\n     EnumId, LocalEnumVariantId, LocalFieldId, LocalModuleId, Lookup, ModuleId, StructId, UnionId,\n     VariantId,\n };\n-use cfg::CfgOptions;\n \n /// Note that we use `StructData` for unions as well!\n #[derive(Debug, Clone, PartialEq, Eq)]"}, {"sha": "ea54068b0f8bf811089e155c078f38a0223b14e8", "filename": "crates/ide-completion/src/context.rs", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/026a8c976dfc35174f9fa17af9e2784e73598ddb/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026a8c976dfc35174f9fa17af9e2784e73598ddb/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext.rs?ref=026a8c976dfc35174f9fa17af9e2784e73598ddb", "patch": "@@ -571,28 +571,25 @@ impl<'a> CompletionContext<'a> {\n \n         // try to skip completions on path with invalid colons\n         // this approach works in normal path and inside token tree\n-        match original_token.kind() {\n-            T![:] => {\n-                // return if no prev token before colon\n-                let prev_token = original_token.prev_token()?;\n-\n-                // only has a single colon\n-                if prev_token.kind() != T![:] {\n-                    return None;\n-                }\n+        if original_token.kind() == T![:] {\n+            // return if no prev token before colon\n+            let prev_token = original_token.prev_token()?;\n \n-                // has 3 colon or 2 coloncolon in a row\n-                // special casing this as per discussion in https://github.com/rust-lang/rust-analyzer/pull/13611#discussion_r1031845205\n-                // and https://github.com/rust-lang/rust-analyzer/pull/13611#discussion_r1032812751\n-                if prev_token\n-                    .prev_token()\n-                    .map(|t| t.kind() == T![:] || t.kind() == T![::])\n-                    .unwrap_or(false)\n-                {\n-                    return None;\n-                }\n+            // only has a single colon\n+            if prev_token.kind() != T![:] {\n+                return None;\n+            }\n+\n+            // has 3 colon or 2 coloncolon in a row\n+            // special casing this as per discussion in https://github.com/rust-lang/rust-analyzer/pull/13611#discussion_r1031845205\n+            // and https://github.com/rust-lang/rust-analyzer/pull/13611#discussion_r1032812751\n+            if prev_token\n+                .prev_token()\n+                .map(|t| t.kind() == T![:] || t.kind() == T![::])\n+                .unwrap_or(false)\n+            {\n+                return None;\n             }\n-            _ => {}\n         }\n \n         let AnalysisResult {"}, {"sha": "db0045aef6e0b23b77b31e3eef799a8e0f83b9ac", "filename": "crates/ide-completion/src/context/analysis.rs", "status": "modified", "additions": 58, "deletions": 65, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/026a8c976dfc35174f9fa17af9e2784e73598ddb/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026a8c976dfc35174f9fa17af9e2784e73598ddb/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs?ref=026a8c976dfc35174f9fa17af9e2784e73598ddb", "patch": "@@ -29,6 +29,7 @@ pub(super) struct AnalysisResult {\n     pub(super) analysis: CompletionAnalysis,\n     pub(super) expected: (Option<Type>, Option<ast::NameOrNameRef>),\n     pub(super) qualifier_ctx: QualifierCtx,\n+    /// the original token of the expanded file\n     pub(super) token: SyntaxToken,\n     pub(super) offset: TextSize,\n }\n@@ -213,15 +214,6 @@ fn analyze(\n     let _p = profile::span(\"CompletionContext::analyze\");\n     let ExpansionResult { original_file, speculative_file, offset, fake_ident_token, derive_ctx } =\n         expansion_result;\n-    let syntax_element = NodeOrToken::Token(fake_ident_token);\n-    if is_in_token_of_for_loop(syntax_element.clone()) {\n-        // for pat $0\n-        // there is nothing to complete here except `in` keyword\n-        // don't bother populating the context\n-        // FIXME: the completion calculations should end up good enough\n-        // such that this special case becomes unnecessary\n-        return None;\n-    }\n \n     // Overwrite the path kind for derives\n     if let Some((original_file, file_with_fake_ident, offset, origin_attr)) = derive_ctx {\n@@ -249,37 +241,35 @@ fn analyze(\n         return None;\n     }\n \n-    let name_like = match find_node_at_offset(&speculative_file, offset) {\n-        Some(it) => it,\n-        None => {\n-            let analysis = if let Some(original) = ast::String::cast(original_token.clone()) {\n-                CompletionAnalysis::String {\n-                    original,\n-                    expanded: ast::String::cast(self_token.clone()),\n+    let Some(name_like) = find_node_at_offset(&speculative_file, offset) else {\n+        let analysis = if let Some(original) = ast::String::cast(original_token.clone()) {\n+            CompletionAnalysis::String {\n+                original,\n+                expanded: ast::String::cast(self_token.clone()),\n+            }\n+        } else {\n+            // Fix up trailing whitespace problem\n+            // #[attr(foo = $0\n+            let token = syntax::algo::skip_trivia_token(self_token.clone(), Direction::Prev)?;\n+            let p = token.parent()?;\n+            if p.kind() == SyntaxKind::TOKEN_TREE\n+                && p.ancestors().any(|it| it.kind() == SyntaxKind::META)\n+            {\n+                let colon_prefix = previous_non_trivia_token(self_token.clone())\n+                    .map_or(false, |it| T![:] == it.kind());\n+                CompletionAnalysis::UnexpandedAttrTT {\n+                    fake_attribute_under_caret: fake_ident_token\n+                        .parent_ancestors()\n+                        .find_map(ast::Attr::cast),\n+                    colon_prefix,\n                 }\n             } else {\n-                // Fix up trailing whitespace problem\n-                // #[attr(foo = $0\n-                let token = syntax::algo::skip_trivia_token(self_token.clone(), Direction::Prev)?;\n-                let p = token.parent()?;\n-                if p.kind() == SyntaxKind::TOKEN_TREE\n-                    && p.ancestors().any(|it| it.kind() == SyntaxKind::META)\n-                {\n-                    let colon_prefix = previous_non_trivia_token(self_token.clone())\n-                        .map_or(false, |it| T![:] == it.kind());\n-                    CompletionAnalysis::UnexpandedAttrTT {\n-                        fake_attribute_under_caret: syntax_element\n-                            .ancestors()\n-                            .find_map(ast::Attr::cast),\n-                        colon_prefix,\n-                    }\n-                } else {\n-                    return None;\n-                }\n-            };\n-            return Some((analysis, (None, None), QualifierCtx::default()));\n-        }\n+                return None;\n+            }\n+        };\n+        return Some((analysis, (None, None), QualifierCtx::default()));\n     };\n+\n     let expected = expected_type_and_name(sema, self_token, &name_like);\n     let mut qual_ctx = QualifierCtx::default();\n     let analysis = match name_like {\n@@ -290,6 +280,22 @@ fn analyze(\n             let parent = name_ref.syntax().parent()?;\n             let (nameref_ctx, qualifier_ctx) =\n                 classify_name_ref(sema, &original_file, name_ref, parent)?;\n+\n+            if let NameRefContext {\n+                kind:\n+                    NameRefKind::Path(PathCompletionCtx { kind: PathKind::Expr { .. }, path, .. }, ..),\n+                ..\n+            } = &nameref_ctx\n+            {\n+                if is_in_token_of_for_loop(path) {\n+                    // for pat $0\n+                    // there is nothing to complete here except `in` keyword\n+                    // don't bother populating the context\n+                    // Ideally this special casing wouldn't be needed, but the parser recovers\n+                    return None;\n+                }\n+            }\n+\n             qual_ctx = qualifier_ctx;\n             CompletionAnalysis::NameRef(nameref_ctx)\n         }\n@@ -323,16 +329,14 @@ fn expected_type_and_name(\n                     ast::FieldExpr(e) => e\n                         .syntax()\n                         .ancestors()\n-                        .map_while(ast::FieldExpr::cast)\n-                        .last()\n-                        .map(|it| it.syntax().clone()),\n+                        .take_while(|it| ast::FieldExpr::can_cast(it.kind()))\n+                        .last(),\n                     ast::PathSegment(e) => e\n                         .syntax()\n                         .ancestors()\n                         .skip(1)\n                         .take_while(|it| ast::Path::can_cast(it.kind()) || ast::PathExpr::can_cast(it.kind()))\n-                        .find_map(ast::PathExpr::cast)\n-                        .map(|it| it.syntax().clone()),\n+                        .find(|it| ast::PathExpr::can_cast(it.kind())),\n                     _ => None\n                 }\n             };\n@@ -1270,40 +1274,29 @@ fn path_or_use_tree_qualifier(path: &ast::Path) -> Option<(ast::Path, bool)> {\n     Some((use_tree.path()?, true))\n }\n \n-pub(crate) fn is_in_token_of_for_loop(element: SyntaxElement) -> bool {\n+fn is_in_token_of_for_loop(path: &ast::Path) -> bool {\n     // oh my ...\n     (|| {\n-        let syntax_token = element.into_token()?;\n-        let range = syntax_token.text_range();\n-        let for_expr = syntax_token.parent_ancestors().find_map(ast::ForExpr::cast)?;\n-\n-        // check if the current token is the `in` token of a for loop\n-        if let Some(token) = for_expr.in_token() {\n-            return Some(syntax_token == token);\n+        let expr = path.syntax().parent().and_then(ast::PathExpr::cast)?;\n+        let for_expr = expr.syntax().parent().and_then(ast::ForExpr::cast)?;\n+        if for_expr.in_token().is_some() {\n+            return Some(false);\n         }\n         let pat = for_expr.pat()?;\n-        if range.end() < pat.syntax().text_range().end() {\n-            // if we are inside or before the pattern we can't be at the `in` token position\n-            return None;\n-        }\n         let next_sibl = next_non_trivia_sibling(pat.syntax().clone().into())?;\n         Some(match next_sibl {\n-            // the loop body is some node, if our token is at the start we are at the `in` position,\n-            // otherwise we could be in a recovered expression, we don't wanna ruin completions there\n-            syntax::NodeOrToken::Node(n) => n.text_range().start() == range.start(),\n-            // the loop body consists of a single token, if we are this we are certainly at the `in` token position\n-            syntax::NodeOrToken::Token(t) => t == syntax_token,\n+            syntax::NodeOrToken::Node(n) => {\n+                n.text_range().start() == path.syntax().text_range().start()\n+            }\n+            syntax::NodeOrToken::Token(t) => {\n+                t.text_range().start() == path.syntax().text_range().start()\n+            }\n         })\n     })()\n     .unwrap_or(false)\n }\n \n-#[test]\n-fn test_for_is_prev2() {\n-    crate::tests::check_pattern_is_applicable(r\"fn __() { for i i$0 }\", is_in_token_of_for_loop);\n-}\n-\n-pub(crate) fn is_in_loop_body(node: &SyntaxNode) -> bool {\n+fn is_in_loop_body(node: &SyntaxNode) -> bool {\n     node.ancestors()\n         .take_while(|it| it.kind() != SyntaxKind::FN && it.kind() != SyntaxKind::CLOSURE_EXPR)\n         .find_map(|it| {"}, {"sha": "6fe781114039921d1376418f46a39c561089eed4", "filename": "crates/ide-completion/src/lib.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/026a8c976dfc35174f9fa17af9e2784e73598ddb/crates%2Fide-completion%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026a8c976dfc35174f9fa17af9e2784e73598ddb/crates%2Fide-completion%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Flib.rs?ref=026a8c976dfc35174f9fa17af9e2784e73598ddb", "patch": "@@ -156,21 +156,23 @@ pub fn completions(\n \n     // prevent `(` from triggering unwanted completion noise\n     if trigger_character == Some('(') {\n-        if let CompletionAnalysis::NameRef(NameRefContext { kind, .. }) = &analysis {\n-            if let NameRefKind::Path(\n-                path_ctx @ PathCompletionCtx { kind: PathKind::Vis { has_in_token }, .. },\n-            ) = kind\n-            {\n-                completions::vis::complete_vis_path(&mut completions, ctx, path_ctx, has_in_token);\n-            }\n+        if let CompletionAnalysis::NameRef(NameRefContext {\n+            kind:\n+                NameRefKind::Path(\n+                    path_ctx @ PathCompletionCtx { kind: PathKind::Vis { has_in_token }, .. },\n+                ),\n+            ..\n+        }) = analysis\n+        {\n+            completions::vis::complete_vis_path(&mut completions, ctx, path_ctx, has_in_token);\n         }\n         return Some(completions.into());\n     }\n \n     {\n         let acc = &mut completions;\n \n-        match &analysis {\n+        match analysis {\n             CompletionAnalysis::Name(name_ctx) => completions::complete_name(acc, ctx, name_ctx),\n             CompletionAnalysis::NameRef(name_ref_ctx) => {\n                 completions::complete_name_ref(acc, ctx, name_ref_ctx)"}, {"sha": "578edcbaba35bce58f16b744cfab0e7903f3be50", "filename": "crates/ide-completion/src/tests.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/026a8c976dfc35174f9fa17af9e2784e73598ddb/crates%2Fide-completion%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026a8c976dfc35174f9fa17af9e2784e73598ddb/crates%2Fide-completion%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests.rs?ref=026a8c976dfc35174f9fa17af9e2784e73598ddb", "patch": "@@ -23,15 +23,14 @@ mod type_pos;\n mod use_tree;\n mod visibility;\n \n-use hir::{db::DefDatabase, PrefixKind, Semantics};\n+use hir::{db::DefDatabase, PrefixKind};\n use ide_db::{\n     base_db::{fixture::ChangeFixture, FileLoader, FilePosition},\n     imports::insert_use::{ImportGranularity, InsertUseConfig},\n     RootDatabase, SnippetCap,\n };\n use itertools::Itertools;\n use stdx::{format_to, trim_indent};\n-use syntax::{AstNode, NodeOrToken, SyntaxElement};\n use test_utils::assert_eq_text;\n \n use crate::{\n@@ -216,15 +215,6 @@ pub(crate) fn check_edit_with_config(\n     assert_eq_text!(&ra_fixture_after, &actual)\n }\n \n-pub(crate) fn check_pattern_is_applicable(code: &str, check: impl FnOnce(SyntaxElement) -> bool) {\n-    let (db, pos) = position(code);\n-\n-    let sema = Semantics::new(&db);\n-    let original_file = sema.parse(pos.file_id);\n-    let token = original_file.syntax().token_at_offset(pos.offset).left_biased().unwrap();\n-    assert!(check(NodeOrToken::Token(token)));\n-}\n-\n pub(crate) fn get_all_items(\n     config: CompletionConfig,\n     code: &str,\n@@ -246,8 +236,9 @@ pub(crate) fn get_all_items(\n }\n \n #[test]\n-fn test_no_completions_required() {\n+fn test_no_completions_in_for_loop_in_kw_pos() {\n     assert_eq!(completion_list(r#\"fn foo() { for i i$0 }\"#), String::new());\n+    assert_eq!(completion_list(r#\"fn foo() { for i in$0 }\"#), String::new());\n }\n \n #[test]"}]}