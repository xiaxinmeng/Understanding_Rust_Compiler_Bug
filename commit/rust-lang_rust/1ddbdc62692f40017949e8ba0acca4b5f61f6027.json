{"sha": "1ddbdc62692f40017949e8ba0acca4b5f61f6027", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkZGJkYzYyNjkyZjQwMDE3OTQ5ZThiYTBhY2NhNGI1ZjYxZjYwMjc=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-03-21T12:49:02Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-03-25T14:53:52Z"}, "message": "use checked casts and arithmetic in Miri engine", "tree": {"sha": "61e679e34bde1d0e04494dec990714410a2565d0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/61e679e34bde1d0e04494dec990714410a2565d0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ddbdc62692f40017949e8ba0acca4b5f61f6027", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ddbdc62692f40017949e8ba0acca4b5f61f6027", "html_url": "https://github.com/rust-lang/rust/commit/1ddbdc62692f40017949e8ba0acca4b5f61f6027", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ddbdc62692f40017949e8ba0acca4b5f61f6027/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5be304b0b411af49e4f0e7196a35c034f430cc85", "url": "https://api.github.com/repos/rust-lang/rust/commits/5be304b0b411af49e4f0e7196a35c034f430cc85", "html_url": "https://github.com/rust-lang/rust/commit/5be304b0b411af49e4f0e7196a35c034f430cc85"}], "stats": {"total": 339, "additions": 186, "deletions": 153}, "files": [{"sha": "4d42e796d10e509f45b012fb8b0e0ec7640833ef", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 38, "deletions": 40, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/1ddbdc62692f40017949e8ba0acca4b5f61f6027/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ddbdc62692f40017949e8ba0acca4b5f61f6027/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=1ddbdc62692f40017949e8ba0acca4b5f61f6027", "patch": "@@ -1,18 +1,20 @@\n //! The virtual memory representation of the MIR interpreter.\n \n+use std::borrow::Cow;\n+use std::convert::TryFrom;\n+use std::iter;\n+use std::ops::{Add, Deref, DerefMut, Mul, Range, Sub};\n+\n+use rustc_ast::ast::Mutability;\n+use rustc_data_structures::sorted_map::SortedMap;\n+use rustc_target::abi::HasDataLayout;\n+\n use super::{\n     read_target_uint, write_target_uint, AllocId, InterpResult, Pointer, Scalar, ScalarMaybeUndef,\n };\n \n use crate::ty::layout::{Align, Size};\n \n-use rustc_ast::ast::Mutability;\n-use rustc_data_structures::sorted_map::SortedMap;\n-use rustc_target::abi::HasDataLayout;\n-use std::borrow::Cow;\n-use std::iter;\n-use std::ops::{Deref, DerefMut, Range};\n-\n // NOTE: When adding new fields, make sure to adjust the `Snapshot` impl in\n // `src/librustc_mir/interpret/snapshot.rs`.\n #[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n@@ -90,7 +92,7 @@ impl<Tag> Allocation<Tag> {\n     /// Creates a read-only allocation initialized by the given bytes\n     pub fn from_bytes<'a>(slice: impl Into<Cow<'a, [u8]>>, align: Align) -> Self {\n         let bytes = slice.into().into_owned();\n-        let size = Size::from_bytes(bytes.len() as u64);\n+        let size = Size::from_bytes(u64::try_from(bytes.len()).unwrap());\n         Self {\n             bytes,\n             relocations: Relocations::new(),\n@@ -107,9 +109,8 @@ impl<Tag> Allocation<Tag> {\n     }\n \n     pub fn undef(size: Size, align: Align) -> Self {\n-        assert_eq!(size.bytes() as usize as u64, size.bytes());\n         Allocation {\n-            bytes: vec![0; size.bytes() as usize],\n+            bytes: vec![0; usize::try_from(size.bytes()).unwrap()],\n             relocations: Relocations::new(),\n             undef_mask: UndefMask::new(size, false),\n             size,\n@@ -152,7 +153,7 @@ impl Allocation<(), ()> {\n /// Raw accessors. Provide access to otherwise private bytes.\n impl<Tag, Extra> Allocation<Tag, Extra> {\n     pub fn len(&self) -> usize {\n-        self.size.bytes() as usize\n+        usize::try_from(self.size.bytes()).unwrap()\n     }\n \n     /// Looks at a slice which may describe undefined bytes or describe a relocation. This differs\n@@ -182,21 +183,16 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     /// Returns the range of this allocation that was meant.\n     #[inline]\n     fn check_bounds(&self, offset: Size, size: Size) -> Range<usize> {\n-        let end = offset + size; // This does overflow checking.\n-        assert_eq!(\n-            end.bytes() as usize as u64,\n-            end.bytes(),\n-            \"cannot handle this access on this host architecture\"\n-        );\n-        let end = end.bytes() as usize;\n+        let end = Size::add(offset, size); // This does overflow checking.\n+        let end = usize::try_from(end.bytes()).expect(\"access too big for this host architecture\");\n         assert!(\n             end <= self.len(),\n             \"Out-of-bounds access at offset {}, size {} in allocation of size {}\",\n             offset.bytes(),\n             size.bytes(),\n             self.len()\n         );\n-        (offset.bytes() as usize)..end\n+        usize::try_from(offset.bytes()).unwrap()..end\n     }\n \n     /// The last argument controls whether we error out when there are undefined\n@@ -294,11 +290,11 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n     ) -> InterpResult<'tcx, &[u8]> {\n-        assert_eq!(ptr.offset.bytes() as usize as u64, ptr.offset.bytes());\n-        let offset = ptr.offset.bytes() as usize;\n+        let offset = usize::try_from(ptr.offset.bytes()).unwrap();\n         Ok(match self.bytes[offset..].iter().position(|&c| c == 0) {\n             Some(size) => {\n-                let size_with_null = Size::from_bytes((size + 1) as u64);\n+                let size_with_null =\n+                    Size::from_bytes(u64::try_from(size.checked_add(1).unwrap()).unwrap());\n                 // Go through `get_bytes` for checks and AllocationExtra hooks.\n                 // We read the null, so we include it in the request, but we want it removed\n                 // from the result, so we do subslicing.\n@@ -343,7 +339,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         let (lower, upper) = src.size_hint();\n         let len = upper.expect(\"can only write bounded iterators\");\n         assert_eq!(lower, len, \"can only write iterators with a precise length\");\n-        let bytes = self.get_bytes_mut(cx, ptr, Size::from_bytes(len as u64))?;\n+        let bytes = self.get_bytes_mut(cx, ptr, Size::from_bytes(u64::try_from(len).unwrap()))?;\n         // `zip` would stop when the first iterator ends; we want to definitely\n         // cover all of `bytes`.\n         for dest in bytes {\n@@ -386,7 +382,11 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         } else {\n             match self.relocations.get(&ptr.offset) {\n                 Some(&(tag, alloc_id)) => {\n-                    let ptr = Pointer::new_with_tag(alloc_id, Size::from_bytes(bits as u64), tag);\n+                    let ptr = Pointer::new_with_tag(\n+                        alloc_id,\n+                        Size::from_bytes(u64::try_from(bits).unwrap()),\n+                        tag,\n+                    );\n                     return Ok(ScalarMaybeUndef::Scalar(ptr.into()));\n                 }\n                 None => {}\n@@ -433,7 +433,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         };\n \n         let bytes = match val.to_bits_or_ptr(type_size, cx) {\n-            Err(val) => val.offset.bytes() as u128,\n+            Err(val) => u128::from(val.offset.bytes()),\n             Ok(data) => data,\n         };\n \n@@ -479,7 +479,7 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n         // We have to go back `pointer_size - 1` bytes, as that one would still overlap with\n         // the beginning of this range.\n         let start = ptr.offset.bytes().saturating_sub(cx.data_layout().pointer_size.bytes() - 1);\n-        let end = ptr.offset + size; // This does overflow checking.\n+        let end = Size::add(ptr.offset, size); // This does overflow checking.\n         self.relocations.range(Size::from_bytes(start)..end)\n     }\n \n@@ -524,7 +524,7 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n             )\n         };\n         let start = ptr.offset;\n-        let end = start + size;\n+        let end = Size::add(start, size);\n \n         // Mark parts of the outermost relocations as undefined if they partially fall outside the\n         // given range.\n@@ -563,15 +563,15 @@ impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n     #[inline]\n     fn check_defined(&self, ptr: Pointer<Tag>, size: Size) -> InterpResult<'tcx> {\n         self.undef_mask\n-            .is_range_defined(ptr.offset, ptr.offset + size)\n+            .is_range_defined(ptr.offset, Size::add(ptr.offset, size))\n             .or_else(|idx| throw_ub!(InvalidUndefBytes(Some(Pointer::new(ptr.alloc_id, idx)))))\n     }\n \n     pub fn mark_definedness(&mut self, ptr: Pointer<Tag>, size: Size, new_state: bool) {\n         if size.bytes() == 0 {\n             return;\n         }\n-        self.undef_mask.set_range(ptr.offset, ptr.offset + size, new_state);\n+        self.undef_mask.set_range(ptr.offset, Size::add(ptr.offset, size), new_state);\n     }\n }\n \n@@ -616,7 +616,7 @@ impl<Tag, Extra> Allocation<Tag, Extra> {\n \n         for i in 1..size.bytes() {\n             // FIXME: optimize to bitshift the current undef block's bits and read the top bit.\n-            if self.undef_mask.get(src.offset + Size::from_bytes(i)) == cur {\n+            if self.undef_mask.get(Size::add(src.offset, Size::from_bytes(i))) == cur {\n                 cur_len += 1;\n             } else {\n                 ranges.push(cur_len);\n@@ -643,7 +643,7 @@ impl<Tag, Extra> Allocation<Tag, Extra> {\n         if defined.ranges.len() <= 1 {\n             self.undef_mask.set_range_inbounds(\n                 dest.offset,\n-                dest.offset + size * repeat,\n+                Size::add(dest.offset, Size::mul(size, repeat)),\n                 defined.initial,\n             );\n             return;\n@@ -721,10 +721,10 @@ impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n         for i in 0..length {\n             new_relocations.extend(relocations.iter().map(|&(offset, reloc)| {\n                 // compute offset for current repetition\n-                let dest_offset = dest.offset + (i * size);\n+                let dest_offset = Size::add(dest.offset, Size::mul(size, i));\n                 (\n                     // shift offsets from source allocation to destination allocation\n-                    offset + dest_offset - src.offset,\n+                    Size::sub(Size::add(offset, dest_offset), src.offset),\n                     reloc,\n                 )\n             }));\n@@ -861,18 +861,18 @@ impl UndefMask {\n         if amount.bytes() == 0 {\n             return;\n         }\n-        let unused_trailing_bits = self.blocks.len() as u64 * Self::BLOCK_SIZE - self.len.bytes();\n+        let unused_trailing_bits =\n+            u64::try_from(self.blocks.len()).unwrap() * Self::BLOCK_SIZE - self.len.bytes();\n         if amount.bytes() > unused_trailing_bits {\n             let additional_blocks = amount.bytes() / Self::BLOCK_SIZE + 1;\n-            assert_eq!(additional_blocks as usize as u64, additional_blocks);\n             self.blocks.extend(\n                 // FIXME(oli-obk): optimize this by repeating `new_state as Block`.\n-                iter::repeat(0).take(additional_blocks as usize),\n+                iter::repeat(0).take(usize::try_from(additional_blocks).unwrap()),\n             );\n         }\n         let start = self.len;\n         self.len += amount;\n-        self.set_range_inbounds(start, start + amount, new_state);\n+        self.set_range_inbounds(start, Size::add(start, amount), new_state);\n     }\n }\n \n@@ -881,7 +881,5 @@ fn bit_index(bits: Size) -> (usize, usize) {\n     let bits = bits.bytes();\n     let a = bits / UndefMask::BLOCK_SIZE;\n     let b = bits % UndefMask::BLOCK_SIZE;\n-    assert_eq!(a as usize as u64, a);\n-    assert_eq!(b as usize as u64, b);\n-    (a as usize, b as usize)\n+    (usize::try_from(a).unwrap(), usize::try_from(b).unwrap())\n }"}, {"sha": "10c3a06da081063be927307c4606c897325c08b2", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/1ddbdc62692f40017949e8ba0acca4b5f61f6027/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ddbdc62692f40017949e8ba0acca4b5f61f6027/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=1ddbdc62692f40017949e8ba0acca4b5f61f6027", "patch": "@@ -95,6 +95,27 @@ mod pointer;\n mod queries;\n mod value;\n \n+use std::convert::TryFrom;\n+use std::fmt;\n+use std::io;\n+use std::num::NonZeroU32;\n+use std::sync::atomic::{AtomicU32, Ordering};\n+\n+use byteorder::{BigEndian, LittleEndian, ReadBytesExt, WriteBytesExt};\n+use rustc_ast::ast::LitKind;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::sync::{HashMapExt, Lock};\n+use rustc_data_structures::tiny_list::TinyList;\n+use rustc_hir::def_id::DefId;\n+use rustc_macros::HashStable;\n+use rustc_serialize::{Decodable, Encodable, Encoder};\n+\n+use crate::mir;\n+use crate::ty::codec::TyDecoder;\n+use crate::ty::layout::{self, Size};\n+use crate::ty::subst::GenericArgKind;\n+use crate::ty::{self, Instance, Ty, TyCtxt};\n+\n pub use self::error::{\n     struct_error, ConstEvalErr, ConstEvalRawResult, ConstEvalResult, ErrorHandled, FrameInfo,\n     InterpError, InterpErrorInfo, InterpResult, InvalidProgramInfo, MachineStopType,\n@@ -107,24 +128,6 @@ pub use self::allocation::{Allocation, AllocationExtra, Relocations, UndefMask};\n \n pub use self::pointer::{CheckInAllocMsg, Pointer, PointerArithmetic};\n \n-use crate::mir;\n-use crate::ty::codec::TyDecoder;\n-use crate::ty::layout::{self, Size};\n-use crate::ty::subst::GenericArgKind;\n-use crate::ty::{self, Instance, Ty, TyCtxt};\n-use byteorder::{BigEndian, LittleEndian, ReadBytesExt, WriteBytesExt};\n-use rustc_ast::ast::LitKind;\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::sync::{HashMapExt, Lock};\n-use rustc_data_structures::tiny_list::TinyList;\n-use rustc_hir::def_id::DefId;\n-use rustc_macros::HashStable;\n-use rustc_serialize::{Decodable, Encodable, Encoder};\n-use std::fmt;\n-use std::io;\n-use std::num::NonZeroU32;\n-use std::sync::atomic::{AtomicU32, Ordering};\n-\n /// Uniquely identifies one of the following:\n /// - A constant\n /// - A static\n@@ -264,8 +267,8 @@ impl<'s> AllocDecodingSession<'s> {\n         D: TyDecoder<'tcx>,\n     {\n         // Read the index of the allocation.\n-        let idx = decoder.read_u32()? as usize;\n-        let pos = self.state.data_offsets[idx] as usize;\n+        let idx = usize::try_from(decoder.read_u32()?).unwrap();\n+        let pos = usize::try_from(self.state.data_offsets[idx]).unwrap();\n \n         // Decode the `AllocDiscriminant` now so that we know if we have to reserve an\n         // `AllocId`."}, {"sha": "ff479aee4e0a93d5bdb49f0af378aebae431676c", "filename": "src/librustc/mir/interpret/pointer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1ddbdc62692f40017949e8ba0acca4b5f61f6027/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ddbdc62692f40017949e8ba0acca4b5f61f6027/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs?ref=1ddbdc62692f40017949e8ba0acca4b5f61f6027", "patch": "@@ -62,9 +62,9 @@ pub trait PointerArithmetic: layout::HasDataLayout {\n     /// This should be called by all the other methods before returning!\n     #[inline]\n     fn truncate_to_ptr(&self, (val, over): (u64, bool)) -> (u64, bool) {\n-        let val = val as u128;\n+        let val = u128::from(val);\n         let max_ptr_plus_1 = 1u128 << self.pointer_size().bits();\n-        ((val % max_ptr_plus_1) as u64, over || val >= max_ptr_plus_1)\n+        (u64::try_from(val % max_ptr_plus_1).unwrap(), over || val >= max_ptr_plus_1)\n     }\n \n     #[inline]"}, {"sha": "4474fcd19188bbf3319607d6e468d89c3b595672", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 44, "deletions": 29, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/1ddbdc62692f40017949e8ba0acca4b5f61f6027/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ddbdc62692f40017949e8ba0acca4b5f61f6027/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=1ddbdc62692f40017949e8ba0acca4b5f61f6027", "patch": "@@ -1,3 +1,5 @@\n+use std::convert::TryFrom;\n+\n use rustc_apfloat::{\n     ieee::{Double, Single},\n     Float,\n@@ -156,7 +158,7 @@ impl Scalar<()> {\n     #[inline(always)]\n     fn check_data(data: u128, size: u8) {\n         debug_assert_eq!(\n-            truncate(data, Size::from_bytes(size as u64)),\n+            truncate(data, Size::from_bytes(u64::from(size))),\n             data,\n             \"Scalar value {:#x} exceeds size of {} bytes\",\n             data,\n@@ -203,8 +205,11 @@ impl<'tcx, Tag> Scalar<Tag> {\n         let dl = cx.data_layout();\n         match self {\n             Scalar::Raw { data, size } => {\n-                assert_eq!(size as u64, dl.pointer_size.bytes());\n-                Ok(Scalar::Raw { data: dl.offset(data as u64, i.bytes())? as u128, size })\n+                assert_eq!(u64::from(size), dl.pointer_size.bytes());\n+                Ok(Scalar::Raw {\n+                    data: u128::from(dl.offset(u64::try_from(data).unwrap(), i.bytes())?),\n+                    size,\n+                })\n             }\n             Scalar::Ptr(ptr) => ptr.offset(i, dl).map(Scalar::Ptr),\n         }\n@@ -215,8 +220,13 @@ impl<'tcx, Tag> Scalar<Tag> {\n         let dl = cx.data_layout();\n         match self {\n             Scalar::Raw { data, size } => {\n-                assert_eq!(size as u64, dl.pointer_size.bytes());\n-                Scalar::Raw { data: dl.overflowing_offset(data as u64, i.bytes()).0 as u128, size }\n+                assert_eq!(u64::from(size), dl.pointer_size.bytes());\n+                Scalar::Raw {\n+                    data: u128::from(\n+                        dl.overflowing_offset(u64::try_from(data).unwrap(), i.bytes()).0,\n+                    ),\n+                    size,\n+                }\n             }\n             Scalar::Ptr(ptr) => Scalar::Ptr(ptr.wrapping_offset(i, dl)),\n         }\n@@ -227,8 +237,11 @@ impl<'tcx, Tag> Scalar<Tag> {\n         let dl = cx.data_layout();\n         match self {\n             Scalar::Raw { data, size } => {\n-                assert_eq!(size as u64, dl.pointer_size().bytes());\n-                Ok(Scalar::Raw { data: dl.signed_offset(data as u64, i)? as u128, size })\n+                assert_eq!(u64::from(size), dl.pointer_size.bytes());\n+                Ok(Scalar::Raw {\n+                    data: u128::from(dl.signed_offset(u64::try_from(data).unwrap(), i)?),\n+                    size,\n+                })\n             }\n             Scalar::Ptr(ptr) => ptr.signed_offset(i, dl).map(Scalar::Ptr),\n         }\n@@ -239,9 +252,11 @@ impl<'tcx, Tag> Scalar<Tag> {\n         let dl = cx.data_layout();\n         match self {\n             Scalar::Raw { data, size } => {\n-                assert_eq!(size as u64, dl.pointer_size.bytes());\n+                assert_eq!(u64::from(size), dl.pointer_size.bytes());\n                 Scalar::Raw {\n-                    data: dl.overflowing_signed_offset(data as u64, i128::from(i)).0 as u128,\n+                    data: u128::from(\n+                        dl.overflowing_signed_offset(u64::try_from(data).unwrap(), i128::from(i)).0,\n+                    ),\n                     size,\n                 }\n             }\n@@ -281,25 +296,25 @@ impl<'tcx, Tag> Scalar<Tag> {\n     #[inline]\n     pub fn from_u8(i: u8) -> Self {\n         // Guaranteed to be truncated and does not need sign extension.\n-        Scalar::Raw { data: i as u128, size: 1 }\n+        Scalar::Raw { data: i.into(), size: 1 }\n     }\n \n     #[inline]\n     pub fn from_u16(i: u16) -> Self {\n         // Guaranteed to be truncated and does not need sign extension.\n-        Scalar::Raw { data: i as u128, size: 2 }\n+        Scalar::Raw { data: i.into(), size: 2 }\n     }\n \n     #[inline]\n     pub fn from_u32(i: u32) -> Self {\n         // Guaranteed to be truncated and does not need sign extension.\n-        Scalar::Raw { data: i as u128, size: 4 }\n+        Scalar::Raw { data: i.into(), size: 4 }\n     }\n \n     #[inline]\n     pub fn from_u64(i: u64) -> Self {\n         // Guaranteed to be truncated and does not need sign extension.\n-        Scalar::Raw { data: i as u128, size: 8 }\n+        Scalar::Raw { data: i.into(), size: 8 }\n     }\n \n     #[inline]\n@@ -376,7 +391,7 @@ impl<'tcx, Tag> Scalar<Tag> {\n         assert_ne!(target_size.bytes(), 0, \"you should never look at the bits of a ZST\");\n         match self {\n             Scalar::Raw { data, size } => {\n-                assert_eq!(target_size.bytes(), size as u64);\n+                assert_eq!(target_size.bytes(), u64::from(size));\n                 Scalar::check_data(data, size);\n                 Ok(data)\n             }\n@@ -394,7 +409,7 @@ impl<'tcx, Tag> Scalar<Tag> {\n         assert_ne!(target_size.bytes(), 0, \"you should never look at the bits of a ZST\");\n         match self {\n             Scalar::Raw { data, size } => {\n-                assert_eq!(target_size.bytes(), size as u64);\n+                assert_eq!(target_size.bytes(), u64::from(size));\n                 Scalar::check_data(data, size);\n                 Ok(data)\n             }\n@@ -458,27 +473,27 @@ impl<'tcx, Tag> Scalar<Tag> {\n \n     /// Converts the scalar to produce an `u8`. Fails if the scalar is a pointer.\n     pub fn to_u8(self) -> InterpResult<'static, u8> {\n-        self.to_unsigned_with_bit_width(8).map(|v| v as u8)\n+        self.to_unsigned_with_bit_width(8).map(|v| u8::try_from(v).unwrap())\n     }\n \n     /// Converts the scalar to produce an `u16`. Fails if the scalar is a pointer.\n     pub fn to_u16(self) -> InterpResult<'static, u16> {\n-        self.to_unsigned_with_bit_width(16).map(|v| v as u16)\n+        self.to_unsigned_with_bit_width(16).map(|v| u16::try_from(v).unwrap())\n     }\n \n     /// Converts the scalar to produce an `u32`. Fails if the scalar is a pointer.\n     pub fn to_u32(self) -> InterpResult<'static, u32> {\n-        self.to_unsigned_with_bit_width(32).map(|v| v as u32)\n+        self.to_unsigned_with_bit_width(32).map(|v| u32::try_from(v).unwrap())\n     }\n \n     /// Converts the scalar to produce an `u64`. Fails if the scalar is a pointer.\n     pub fn to_u64(self) -> InterpResult<'static, u64> {\n-        self.to_unsigned_with_bit_width(64).map(|v| v as u64)\n+        self.to_unsigned_with_bit_width(64).map(|v| u64::try_from(v).unwrap())\n     }\n \n     pub fn to_machine_usize(self, cx: &impl HasDataLayout) -> InterpResult<'static, u64> {\n         let b = self.to_bits(cx.data_layout().pointer_size)?;\n-        Ok(b as u64)\n+        Ok(u64::try_from(b).unwrap())\n     }\n \n     #[inline]\n@@ -490,41 +505,41 @@ impl<'tcx, Tag> Scalar<Tag> {\n \n     /// Converts the scalar to produce an `i8`. Fails if the scalar is a pointer.\n     pub fn to_i8(self) -> InterpResult<'static, i8> {\n-        self.to_signed_with_bit_width(8).map(|v| v as i8)\n+        self.to_signed_with_bit_width(8).map(|v| i8::try_from(v).unwrap())\n     }\n \n     /// Converts the scalar to produce an `i16`. Fails if the scalar is a pointer.\n     pub fn to_i16(self) -> InterpResult<'static, i16> {\n-        self.to_signed_with_bit_width(16).map(|v| v as i16)\n+        self.to_signed_with_bit_width(16).map(|v| i16::try_from(v).unwrap())\n     }\n \n     /// Converts the scalar to produce an `i32`. Fails if the scalar is a pointer.\n     pub fn to_i32(self) -> InterpResult<'static, i32> {\n-        self.to_signed_with_bit_width(32).map(|v| v as i32)\n+        self.to_signed_with_bit_width(32).map(|v| i32::try_from(v).unwrap())\n     }\n \n     /// Converts the scalar to produce an `i64`. Fails if the scalar is a pointer.\n     pub fn to_i64(self) -> InterpResult<'static, i64> {\n-        self.to_signed_with_bit_width(64).map(|v| v as i64)\n+        self.to_signed_with_bit_width(64).map(|v| i64::try_from(v).unwrap())\n     }\n \n     pub fn to_machine_isize(self, cx: &impl HasDataLayout) -> InterpResult<'static, i64> {\n         let sz = cx.data_layout().pointer_size;\n         let b = self.to_bits(sz)?;\n         let b = sign_extend(b, sz) as i128;\n-        Ok(b as i64)\n+        Ok(i64::try_from(b).unwrap())\n     }\n \n     #[inline]\n     pub fn to_f32(self) -> InterpResult<'static, Single> {\n         // Going through `u32` to check size and truncation.\n-        Ok(Single::from_bits(self.to_u32()? as u128))\n+        Ok(Single::from_bits(self.to_u32()?.into()))\n     }\n \n     #[inline]\n     pub fn to_f64(self) -> InterpResult<'static, Double> {\n         // Going through `u64` to check size and truncation.\n-        Ok(Double::from_bits(self.to_u64()? as u128))\n+        Ok(Double::from_bits(self.to_u64()?.into()))\n     }\n }\n \n@@ -671,8 +686,8 @@ pub fn get_slice_bytes<'tcx>(cx: &impl HasDataLayout, val: ConstValue<'tcx>) ->\n         data.get_bytes(\n             cx,\n             // invent a pointer, only the offset is relevant anyway\n-            Pointer::new(AllocId(0), Size::from_bytes(start as u64)),\n-            Size::from_bytes(len as u64),\n+            Pointer::new(AllocId(0), Size::from_bytes(u64::try_from(start).unwrap())),\n+            Size::from_bytes(u64::try_from(len).unwrap()),\n         )\n         .unwrap_or_else(|err| bug!(\"const slice is invalid: {:?}\", err))\n     } else {"}, {"sha": "e24312155835503f8c8853c9e09b816c811e4c95", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1ddbdc62692f40017949e8ba0acca4b5f61f6027/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ddbdc62692f40017949e8ba0acca4b5f61f6027/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=1ddbdc62692f40017949e8ba0acca4b5f61f6027", "patch": "@@ -1,3 +1,5 @@\n+use std::convert::TryFrom;\n+\n use rustc::ty::adjustment::PointerCast;\n use rustc::ty::layout::{self, Size, TyLayout};\n use rustc::ty::{self, Ty, TypeAndMut, TypeFoldable};\n@@ -206,8 +208,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n             Char => {\n                 // `u8` to `char` cast\n-                assert_eq!(v as u8 as u128, v);\n-                Ok(Scalar::from_uint(v, Size::from_bytes(4)))\n+                Ok(Scalar::from_uint(u8::try_from(v).unwrap(), Size::from_bytes(4)))\n             }\n \n             // Casts to bool are not permitted by rustc, no need to handle them here.\n@@ -227,6 +228,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         match dest_ty.kind {\n             // float -> uint\n             Uint(t) => {\n+                // FIXME: can we make `bit_width` return a type more compatible with `Size::bits`?\n                 let width = t.bit_width().unwrap_or_else(|| self.pointer_size().bits() as usize);\n                 let v = f.to_u128(width).value;\n                 // This should already fit the bit width"}, {"sha": "0d0f4daa85ef75822638615b0d96f66061778cbd", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1ddbdc62692f40017949e8ba0acca4b5f61f6027/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ddbdc62692f40017949e8ba0acca4b5f61f6027/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=1ddbdc62692f40017949e8ba0acca4b5f61f6027", "patch": "@@ -1,6 +1,7 @@\n use std::cell::Cell;\n use std::fmt::Write;\n use std::mem;\n+use std::ops::Add;\n \n use rustc::ich::StableHashingContext;\n use rustc::mir;\n@@ -413,6 +414,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // and it also rounds up to alignment, which we want to avoid,\n                 // as the unsized field's alignment could be smaller.\n                 assert!(!layout.ty.is_simd());\n+                assert!(layout.fields.count() > 0);\n                 trace!(\"DST layout: {:?}\", layout);\n \n                 let sized_size = layout.fields.offset(layout.fields.count() - 1);\n@@ -452,7 +454,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // here. But this is where the add would go.)\n \n                 // Return the sum of sizes and max of aligns.\n-                let size = sized_size + unsized_size;\n+                let size = Size::add(sized_size, unsized_size);\n \n                 // Choose max of two known alignments (combined value must\n                 // be aligned according to more restrictive of the two)."}, {"sha": "13bfb9895cb00611971896fe5c194ce647ae0adf", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ddbdc62692f40017949e8ba0acca4b5f61f6027/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ddbdc62692f40017949e8ba0acca4b5f61f6027/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=1ddbdc62692f40017949e8ba0acca4b5f61f6027", "patch": "@@ -29,11 +29,11 @@ fn numeric_intrinsic<'tcx, Tag>(\n         Primitive::Int(integer, _) => integer.size(),\n         _ => bug!(\"invalid `{}` argument: {:?}\", name, bits),\n     };\n-    let extra = 128 - size.bits() as u128;\n+    let extra = 128 - u128::from(size.bits());\n     let bits_out = match name {\n-        sym::ctpop => bits.count_ones() as u128,\n-        sym::ctlz => bits.leading_zeros() as u128 - extra,\n-        sym::cttz => (bits << extra).trailing_zeros() as u128 - extra,\n+        sym::ctpop => u128::from(bits.count_ones()),\n+        sym::ctlz => u128::from(bits.leading_zeros()) - extra,\n+        sym::cttz => u128::from((bits << extra).trailing_zeros()) - extra,\n         sym::bswap => (bits << extra).swap_bytes(),\n         sym::bitreverse => (bits << extra).reverse_bits(),\n         _ => bug!(\"not a numeric intrinsic: {}\", name),\n@@ -261,7 +261,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let val_bits = self.force_bits(val, layout.size)?;\n                 let raw_shift = self.read_scalar(args[1])?.not_undef()?;\n                 let raw_shift_bits = self.force_bits(raw_shift, layout.size)?;\n-                let width_bits = layout.size.bits() as u128;\n+                let width_bits = u128::from(layout.size.bits());\n                 let shift_bits = raw_shift_bits % width_bits;\n                 let inv_shift_bits = (width_bits - shift_bits) % width_bits;\n                 let result_bits = if intrinsic_name == sym::rotate_left {"}, {"sha": "01f9cdea0f0d3a7ff22f6599213bd175a67dd1fb", "filename": "src/librustc_mir/interpret/intrinsics/caller_location.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1ddbdc62692f40017949e8ba0acca4b5f61f6027/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ddbdc62692f40017949e8ba0acca4b5f61f6027/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs?ref=1ddbdc62692f40017949e8ba0acca4b5f61f6027", "patch": "@@ -1,3 +1,5 @@\n+use std::convert::TryFrom;\n+\n use rustc::middle::lang_items::PanicLocationLangItem;\n use rustc::ty::subst::Subst;\n use rustc_span::{Span, Symbol};\n@@ -59,8 +61,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let caller = self.tcx.sess.source_map().lookup_char_pos(topmost.lo());\n         (\n             Symbol::intern(&caller.file.name.to_string()),\n-            caller.line as u32,\n-            caller.col_display as u32 + 1,\n+            u32::try_from(caller.line).unwrap(),\n+            u32::try_from(caller.col_display).unwrap().checked_add(1).unwrap(),\n         )\n     }\n "}, {"sha": "f51e38eb1ea5ce7d622181cb39f945ff0c7e40b3", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1ddbdc62692f40017949e8ba0acca4b5f61f6027/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ddbdc62692f40017949e8ba0acca4b5f61f6027/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=1ddbdc62692f40017949e8ba0acca4b5f61f6027", "patch": "@@ -8,6 +8,8 @@\n \n use std::borrow::Cow;\n use std::collections::VecDeque;\n+use std::convert::TryFrom;\n+use std::ops::{Add, Mul};\n use std::ptr;\n \n use rustc::ty::layout::{Align, HasDataLayout, Size, TargetDataLayout};\n@@ -346,7 +348,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         };\n         Ok(match normalized.to_bits_or_ptr(self.pointer_size(), self) {\n             Ok(bits) => {\n-                let bits = bits as u64; // it's ptr-sized\n+                let bits = u64::try_from(bits).unwrap(); // it's ptr-sized\n                 assert!(size.bytes() == 0);\n                 // Must be non-NULL.\n                 if bits == 0 {\n@@ -667,7 +669,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             }\n             if alloc.undef_mask().is_range_defined(i, i + Size::from_bytes(1)).is_ok() {\n                 // this `as usize` is fine, since `i` came from a `usize`\n-                let i = i.bytes() as usize;\n+                let i = usize::try_from(i.bytes()).unwrap();\n \n                 // Checked definedness (and thus range) and relocations. This access also doesn't\n                 // influence interpreter execution but is only for debugging.\n@@ -835,7 +837,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     ) -> InterpResult<'tcx> {\n         let src = src.into_iter();\n         let size = Size::from_bytes(src.size_hint().0 as u64);\n-        // `write_bytes` checks that this lower bound matches the upper bound matches reality.\n+        // `write_bytes` checks that this lower bound `size` matches the upper bound and reality.\n         let ptr = match self.check_ptr_access(ptr, size, Align::from_bytes(1).unwrap())? {\n             Some(ptr) => ptr,\n             None => return Ok(()), // zero-sized access\n@@ -874,14 +876,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n \n         let tcx = self.tcx.tcx;\n \n-        // The bits have to be saved locally before writing to dest in case src and dest overlap.\n-        assert_eq!(size.bytes() as usize as u64, size.bytes());\n-\n         // This checks relocation edges on the src.\n         let src_bytes =\n             self.get_raw(src.alloc_id)?.get_bytes_with_undef_and_ptr(&tcx, src, size)?.as_ptr();\n         let dest_bytes =\n-            self.get_raw_mut(dest.alloc_id)?.get_bytes_mut(&tcx, dest, size * length)?;\n+            self.get_raw_mut(dest.alloc_id)?.get_bytes_mut(&tcx, dest, Size::mul(size, length))?;\n \n         // If `dest_bytes` is empty we just optimize to not run anything for zsts.\n         // See #67539\n@@ -902,7 +901,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             // touched if the bytes stay undef for the whole interpreter execution. On contemporary\n             // operating system this can avoid physically allocating the page.\n             let dest_alloc = self.get_raw_mut(dest.alloc_id)?;\n-            dest_alloc.mark_definedness(dest, size * length, false);\n+            dest_alloc.mark_definedness(dest, Size::mul(size, length), false);\n             dest_alloc.mark_relocation_range(relocations);\n             return Ok(());\n         }\n@@ -913,11 +912,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         // The pointers above remain valid even if the `HashMap` table is moved around because they\n         // point into the `Vec` storing the bytes.\n         unsafe {\n-            assert_eq!(size.bytes() as usize as u64, size.bytes());\n             if src.alloc_id == dest.alloc_id {\n                 if nonoverlapping {\n-                    if (src.offset <= dest.offset && src.offset + size > dest.offset)\n-                        || (dest.offset <= src.offset && dest.offset + size > src.offset)\n+                    if (src.offset <= dest.offset && Size::add(src.offset, size) > dest.offset)\n+                        || (dest.offset <= src.offset && Size::add(dest.offset, size) > src.offset)\n                     {\n                         throw_ub_format!(\"copy_nonoverlapping called on overlapping ranges\")\n                     }\n@@ -926,16 +924,16 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 for i in 0..length {\n                     ptr::copy(\n                         src_bytes,\n-                        dest_bytes.offset((size.bytes() * i) as isize),\n-                        size.bytes() as usize,\n+                        dest_bytes.offset(isize::try_from(Size::mul(size, i).bytes()).unwrap()),\n+                        usize::try_from(size.bytes()).unwrap(),\n                     );\n                 }\n             } else {\n                 for i in 0..length {\n                     ptr::copy_nonoverlapping(\n                         src_bytes,\n-                        dest_bytes.offset((size.bytes() * i) as isize),\n-                        size.bytes() as usize,\n+                        dest_bytes.offset(isize::try_from(Size::mul(size, i).bytes()).unwrap()),\n+                        usize::try_from(size.bytes()).unwrap(),\n                     );\n                 }\n             }\n@@ -975,7 +973,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     ) -> InterpResult<'tcx, u128> {\n         match scalar.to_bits_or_ptr(size, self) {\n             Ok(bits) => Ok(bits),\n-            Err(ptr) => Ok(M::ptr_to_int(&self, ptr)? as u128),\n+            Err(ptr) => Ok(M::ptr_to_int(&self, ptr)?.into()),\n         }\n     }\n }"}, {"sha": "9ab4e198db01d9b427b4e0ab15351cedb01f7e10", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1ddbdc62692f40017949e8ba0acca4b5f61f6027/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ddbdc62692f40017949e8ba0acca4b5f61f6027/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=1ddbdc62692f40017949e8ba0acca4b5f61f6027", "patch": "@@ -341,7 +341,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     // Turn the wide MPlace into a string (must already be dereferenced!)\n     pub fn read_str(&self, mplace: MPlaceTy<'tcx, M::PointerTag>) -> InterpResult<'tcx, &str> {\n         let len = mplace.len(self)?;\n-        let bytes = self.memory.read_bytes(mplace.ptr, Size::from_bytes(len as u64))?;\n+        let bytes = self.memory.read_bytes(mplace.ptr, Size::from_bytes(u64::from(len)))?;\n         let str = ::std::str::from_utf8(bytes)\n             .map_err(|err| err_ub_format!(\"this string is not valid UTF-8: {}\", err))?;\n         Ok(str)\n@@ -406,7 +406,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         use rustc::mir::ProjectionElem::*;\n         Ok(match *proj_elem {\n-            Field(field, _) => self.operand_field(base, field.index() as u64)?,\n+            Field(field, _) => self.operand_field(base, u64::try_from(field.index()).unwrap())?,\n             Downcast(_, variant) => self.operand_downcast(base, variant)?,\n             Deref => self.deref_operand(base)?.into(),\n             Subslice { .. } | ConstantIndex { .. } | Index(_) => {\n@@ -556,11 +556,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // where none should happen.\n                 let ptr = Pointer::new(\n                     self.tcx.alloc_map.lock().create_memory_alloc(data),\n-                    Size::from_bytes(start as u64), // offset: `start`\n+                    Size::from_bytes(start.try_into().unwrap()), // offset: `start`\n                 );\n                 Operand::Immediate(Immediate::new_slice(\n                     self.tag_global_base_pointer(ptr).into(),\n-                    (end - start) as u64, // len: `end - start`\n+                    u64::try_from(end.checked_sub(start).unwrap()).unwrap(), // len: `end - start`\n                     self,\n                 ))\n             }\n@@ -581,7 +581,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     .layout\n                     .ty\n                     .discriminant_for_variant(*self.tcx, index)\n-                    .map_or(index.as_u32() as u128, |discr| discr.val);\n+                    .map_or(u128::from(index.as_u32()), |discr| discr.val);\n                 return Ok((discr_val, index));\n             }\n             layout::Variants::Multiple {\n@@ -593,7 +593,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         };\n \n         // read raw discriminant value\n-        let discr_op = self.operand_field(rval, discr_index as u64)?;\n+        let discr_op = self.operand_field(rval, u64::try_from(discr_index).unwrap())?;\n         let discr_val = self.read_immediate(discr_op)?;\n         let raw_discr = discr_val.to_scalar_or_undef();\n         trace!(\"discr value: {:?}\", raw_discr);\n@@ -657,7 +657,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         if !ptr_valid {\n                             throw_ub!(InvalidDiscriminant(raw_discr.erase_tag().into()))\n                         }\n-                        (dataful_variant.as_u32() as u128, dataful_variant)\n+                        (u128::from(dataful_variant.as_u32()), dataful_variant)\n                     }\n                     Ok(raw_discr) => {\n                         // We need to use machine arithmetic to get the relative variant idx:\n@@ -686,7 +686,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                                 .expect(\"tagged layout for non adt\")\n                                 .variants\n                                 .len();\n-                            assert!((variant_index as usize) < variants_len);\n+                            assert!(usize::try_from(variant_index).unwrap() < variants_len);\n                             (u128::from(variant_index), VariantIdx::from_u32(variant_index))\n                         } else {\n                             (u128::from(dataful_variant.as_u32()), dataful_variant)"}, {"sha": "7bea5357cdf08b0b66cd3254aac4e4117d589fbb", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/1ddbdc62692f40017949e8ba0acca4b5f61f6027/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ddbdc62692f40017949e8ba0acca4b5f61f6027/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=1ddbdc62692f40017949e8ba0acca4b5f61f6027", "patch": "@@ -4,6 +4,7 @@\n \n use std::convert::TryFrom;\n use std::hash::Hash;\n+use std::ops::Mul;\n \n use rustc::mir;\n use rustc::mir::interpret::truncate;\n@@ -405,11 +406,11 @@ where\n                     // This can only be reached in ConstProp and non-rustc-MIR.\n                     throw_ub!(BoundsCheckFailed { len, index: field });\n                 }\n-                stride * field\n+                Size::mul(stride, field) // `Size` multiplication is checked\n             }\n             layout::FieldPlacement::Union(count) => {\n                 assert!(\n-                    field < count as u64,\n+                    field < u64::try_from(count).unwrap(),\n                     \"Tried to access field {} of union {:#?} with {} fields\",\n                     field,\n                     base.layout,\n@@ -420,7 +421,7 @@ where\n             }\n         };\n         // the only way conversion can fail if is this is an array (otherwise we already panicked\n-        // above). In that case, all fields are equal.\n+        // above). In that case, all fields have the same layout.\n         let field_layout = base.layout.field(self, usize::try_from(field).unwrap_or(0))?;\n \n         // Offset may need adjustment for unsized fields.\n@@ -465,7 +466,7 @@ where\n         };\n         let layout = base.layout.field(self, 0)?;\n         let dl = &self.tcx.data_layout;\n-        Ok((0..len).map(move |i| base.offset(i * stride, MemPlaceMeta::None, layout, dl)))\n+        Ok((0..len).map(move |i| base.offset(Size::mul(stride, i), MemPlaceMeta::None, layout, dl)))\n     }\n \n     fn mplace_subslice(\n@@ -477,24 +478,24 @@ where\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         let len = base.len(self)?; // also asserts that we have a type where this makes sense\n         let actual_to = if from_end {\n-            if from + to > len {\n+            if from.checked_add(to).map_or(true, |to| to > len) {\n                 // This can only be reached in ConstProp and non-rustc-MIR.\n-                throw_ub!(BoundsCheckFailed { len: len as u64, index: from as u64 + to as u64 });\n+                throw_ub!(BoundsCheckFailed { len: len, index: from.saturating_add(to) });\n             }\n-            len - to\n+            len.checked_sub(to).unwrap()\n         } else {\n             to\n         };\n \n         // Not using layout method because that works with usize, and does not work with slices\n         // (that have count 0 in their layout).\n         let from_offset = match base.layout.fields {\n-            layout::FieldPlacement::Array { stride, .. } => stride * from,\n+            layout::FieldPlacement::Array { stride, .. } => Size::mul(stride, from), // `Size` multiplication is checked\n             _ => bug!(\"Unexpected layout of index access: {:#?}\", base.layout),\n         };\n \n         // Compute meta and new layout\n-        let inner_len = actual_to - from;\n+        let inner_len = actual_to.checked_sub(from).unwrap();\n         let (meta, ty) = match base.layout.ty.kind {\n             // It is not nice to match on the type, but that seems to be the only way to\n             // implement this.\n@@ -527,7 +528,7 @@ where\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         use rustc::mir::ProjectionElem::*;\n         Ok(match *proj_elem {\n-            Field(field, _) => self.mplace_field(base, field.index() as u64)?,\n+            Field(field, _) => self.mplace_field(base, u64::try_from(field.index()).unwrap())?,\n             Downcast(_, variant) => self.mplace_downcast(base, variant)?,\n             Deref => self.deref_operand(base.into())?,\n \n@@ -541,14 +542,14 @@ where\n \n             ConstantIndex { offset, min_length, from_end } => {\n                 let n = base.len(self)?;\n-                if n < min_length as u64 {\n+                if n < u64::from(min_length) {\n                     // This can only be reached in ConstProp and non-rustc-MIR.\n-                    throw_ub!(BoundsCheckFailed { len: min_length as u64, index: n as u64 });\n+                    throw_ub!(BoundsCheckFailed { len: min_length.into(), index: n.into() });\n                 }\n \n                 let index = if from_end {\n-                    assert!(0 < offset && offset - 1 < min_length);\n-                    n - u64::from(offset)\n+                    assert!(0 < offset && offset <= min_length);\n+                    n.checked_sub(u64::from(offset)).unwrap()\n                 } else {\n                     assert!(offset < min_length);\n                     u64::from(offset)\n@@ -603,7 +604,7 @@ where\n     ) -> InterpResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n         use rustc::mir::ProjectionElem::*;\n         Ok(match *proj_elem {\n-            Field(field, _) => self.place_field(base, field.index() as u64)?,\n+            Field(field, _) => self.place_field(base, u64::try_from(field.index()).unwrap())?,\n             Downcast(_, variant) => self.place_downcast(base, variant)?,\n             Deref => self.deref_operand(self.place_to_op(base)?)?.into(),\n             // For the other variants, we have to force an allocation.\n@@ -1028,7 +1029,7 @@ where\n         kind: MemoryKind<M::MemoryKind>,\n     ) -> MPlaceTy<'tcx, M::PointerTag> {\n         let ptr = self.memory.allocate_bytes(str.as_bytes(), kind);\n-        let meta = Scalar::from_uint(str.len() as u128, self.pointer_size());\n+        let meta = Scalar::from_uint(u128::try_from(str.len()).unwrap(), self.pointer_size());\n         let mplace = MemPlace {\n             ptr: ptr.into(),\n             align: Align::from_bytes(1).unwrap(),\n@@ -1072,7 +1073,7 @@ where\n                 let size = discr_layout.value.size(self);\n                 let discr_val = truncate(discr_val, size);\n \n-                let discr_dest = self.place_field(dest, discr_index as u64)?;\n+                let discr_dest = self.place_field(dest, u64::try_from(discr_index).unwrap())?;\n                 self.write_scalar(Scalar::from_uint(discr_val, size), discr_dest)?;\n             }\n             layout::Variants::Multiple {\n@@ -1103,7 +1104,7 @@ where\n                         niche_start_val,\n                     )?;\n                     // Write result.\n-                    let niche_dest = self.place_field(dest, discr_index as u64)?;\n+                    let niche_dest = self.place_field(dest, u64::try_from(discr_index).unwrap())?;\n                     self.write_immediate(*discr_val, niche_dest)?;\n                 }\n             }"}, {"sha": "eb33a8700f33bb399ec6d21df454ecd971aff320", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1ddbdc62692f40017949e8ba0acca4b5f61f6027/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ddbdc62692f40017949e8ba0acca4b5f61f6027/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=1ddbdc62692f40017949e8ba0acca4b5f61f6027", "patch": "@@ -2,6 +2,8 @@\n //!\n //! The main entry point is the `step` method.\n \n+use std::convert::TryFrom;\n+\n use rustc::mir;\n use rustc::mir::interpret::{InterpResult, PointerArithmetic, Scalar};\n use rustc::ty::layout::LayoutOf;\n@@ -192,7 +194,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     // Ignore zero-sized fields.\n                     if !op.layout.is_zst() {\n                         let field_index = active_field_index.unwrap_or(i);\n-                        let field_dest = self.place_field(dest, field_index as u64)?;\n+                        let field_dest =\n+                            self.place_field(dest, u64::try_from(field_index).unwrap())?;\n                         self.copy_op(op, field_dest)?;\n                     }\n                 }"}, {"sha": "9c52af41272e30cb37ba09409d477f0f0ee58d62", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1ddbdc62692f40017949e8ba0acca4b5f61f6027/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ddbdc62692f40017949e8ba0acca4b5f61f6027/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=1ddbdc62692f40017949e8ba0acca4b5f61f6027", "patch": "@@ -1,4 +1,5 @@\n use std::borrow::Cow;\n+use std::convert::TryFrom;\n \n use rustc::ty::layout::{self, LayoutOf, TyLayout};\n use rustc::ty::Instance;\n@@ -29,6 +30,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 trace!(\"SwitchInt({:?})\", *discr);\n \n                 // Branch to the `otherwise` case by default, if no match is found.\n+                assert!(targets.len() > 0);\n                 let mut target_block = targets[targets.len() - 1];\n \n                 for (index, &const_int) in values.iter().enumerate() {\n@@ -392,7 +394,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 };\n                 // Find and consult vtable\n                 let vtable = receiver_place.vtable();\n-                let drop_fn = self.get_vtable_slot(vtable, idx)?;\n+                let drop_fn = self.get_vtable_slot(vtable, u64::try_from(idx).unwrap())?;\n \n                 // `*mut receiver_place.layout.ty` is almost the layout that we\n                 // want for args[0]: We have to project to field 0 because we want"}, {"sha": "10f746e135aa9c738ba6f533eb1b735b6f4b6747", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1ddbdc62692f40017949e8ba0acca4b5f61f6027/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ddbdc62692f40017949e8ba0acca4b5f61f6027/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=1ddbdc62692f40017949e8ba0acca4b5f61f6027", "patch": "@@ -1,9 +1,11 @@\n-use super::{FnVal, InterpCx, Machine, MemoryKind};\n+use std::ops::Mul;\n \n use rustc::mir::interpret::{InterpResult, Pointer, PointerArithmetic, Scalar};\n use rustc::ty::layout::{Align, HasDataLayout, LayoutOf, Size};\n use rustc::ty::{self, Instance, Ty, TypeFoldable};\n \n+use super::{FnVal, InterpCx, Machine, MemoryKind};\n+\n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Creates a dynamic vtable for the given type and vtable origin. This is used only for\n     /// objects.\n@@ -103,11 +105,12 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn get_vtable_slot(\n         &self,\n         vtable: Scalar<M::PointerTag>,\n-        idx: usize,\n+        idx: u64,\n     ) -> InterpResult<'tcx, FnVal<'tcx, M::ExtraFnVal>> {\n         let ptr_size = self.pointer_size();\n         // Skip over the 'drop_ptr', 'size', and 'align' fields.\n-        let vtable_slot = vtable.ptr_offset(ptr_size * (idx as u64 + 3), self)?;\n+        let vtable_slot =\n+            vtable.ptr_offset(Size::mul(ptr_size, idx.checked_add(3).unwrap()), self)?;\n         let vtable_slot = self\n             .memory\n             .check_ptr_access(vtable_slot, ptr_size, self.tcx.data_layout.pointer_align.abi)?"}, {"sha": "164478362bf561c89ba2a6f61cdf5582743c6285", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ddbdc62692f40017949e8ba0acca4b5f61f6027/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ddbdc62692f40017949e8ba0acca4b5f61f6027/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=1ddbdc62692f40017949e8ba0acca4b5f61f6027", "patch": "@@ -4,11 +4,12 @@\n //! That's useful because it means other passes (e.g. promotion) can rely on `const`s\n //! to be const-safe.\n \n+use std::convert::TryFrom;\n use std::fmt::Write;\n-use std::ops::RangeInclusive;\n+use std::ops::{Mul, RangeInclusive};\n \n use rustc::ty;\n-use rustc::ty::layout::{self, LayoutOf, TyLayout, VariantIdx};\n+use rustc::ty::layout::{self, LayoutOf, Size, TyLayout, VariantIdx};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_span::symbol::{sym, Symbol};\n@@ -747,7 +748,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 // This is the element type size.\n                 let layout = self.ecx.layout_of(tys)?;\n                 // This is the size in bytes of the whole array.\n-                let size = layout.size * len;\n+                let size = Size::mul(layout.size, len);\n                 // Size is not 0, get a pointer.\n                 let ptr = self.ecx.force_ptr(mplace.ptr)?;\n \n@@ -777,7 +778,8 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                                 // Some byte was undefined, determine which\n                                 // element that byte belongs to so we can\n                                 // provide an index.\n-                                let i = (ptr.offset.bytes() / layout.size.bytes()) as usize;\n+                                let i = usize::try_from(ptr.offset.bytes() / layout.size.bytes())\n+                                    .unwrap();\n                                 self.path.push(PathElem::ArrayElem(i));\n \n                                 throw_validation_failure!(\"undefined bytes\", self.path)"}, {"sha": "f80ca3d4b874b775b189fa52075cba429cb87546", "filename": "src/librustc_mir/interpret/visitor.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1ddbdc62692f40017949e8ba0acca4b5f61f6027/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ddbdc62692f40017949e8ba0acca4b5f61f6027/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs?ref=1ddbdc62692f40017949e8ba0acca4b5f61f6027", "patch": "@@ -1,6 +1,8 @@\n //! Visitor for a run-time value with a given layout: Traverse enums, structs and other compound\n //! types until we arrive at the leaves, with custom handling for primitive types.\n \n+use std::convert::TryFrom;\n+\n use rustc::mir::interpret::InterpResult;\n use rustc::ty;\n use rustc::ty::layout::{self, TyLayout, VariantIdx};\n@@ -206,7 +208,7 @@ macro_rules! make_value_visitor {\n                         // errors: Projecting to a field needs access to `ecx`.\n                         let fields: Vec<InterpResult<'tcx, Self::V>> =\n                             (0..offsets.len()).map(|i| {\n-                                v.project_field(self.ecx(), i as u64)\n+                                v.project_field(self.ecx(), u64::try_from(i).unwrap())\n                             })\n                             .collect();\n                         self.visit_aggregate(v, fields.into_iter())?;"}]}