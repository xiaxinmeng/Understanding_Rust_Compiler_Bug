{"sha": "46111c1901cc94c5233e3d5141cb0fc68063552b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2MTExYzE5MDFjYzk0YzUyMzNlM2Q1MTQxY2IwZmM2ODA2MzU1MmI=", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-12-30T20:56:52Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-12-30T20:56:52Z"}, "message": "Rollup merge of #80458 - RalfJung:promotion-refactor, r=oli-obk\n\nSome Promotion Refactoring\n\nClean up promotion a bit:\n* factor out some common code\n* more exhaustive matches\n\nThis *should* not break anything... the only potentially-breaking change is that `BorrowKind::Shallow | BorrowKind::Unique` are now rejected for internal references.\n\nr? ``@oli-obk``", "tree": {"sha": "963b8f0ed0f7fcc68a632a4ffe70ee0bc7ace1de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/963b8f0ed0f7fcc68a632a4ffe70ee0bc7ace1de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/46111c1901cc94c5233e3d5141cb0fc68063552b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJf7OmVCRBK7hj4Ov3rIwAAdHIIAIBiGxDq53DsDUF8raJB0Dyc\npuw7apqp+iXi3Wg/rjGkU4FCWPJvSKrkFVZmYKUu3hWPjq1m4kX/lSj5Xa+WUR7D\nK9s0PFdspl/xNNnSN+EJBZLJyaeYt0B9VWkBwpuDDsG2UjQPsQpR8CeZ8JIzxF/g\nUisM73dg8z7Hv2CINrHJ7AnQ7xvZB9E9MClt7Pd9eB4Q8CbD0Z3pPYXiMBhgb3GX\nhP8XD6sw7ojiHdQFD/fLPm+scdDWPvj4FFKMpTpIXEs1E7y+N5QACvh/jCQ0g9KC\n2ovvQBY0nf7AU8QGLaPBR1g7hC7zHLZlg5qsjdaO3OjJ0sqhAFA8fn+4rleqfUA=\n=fy6C\n-----END PGP SIGNATURE-----\n", "payload": "tree 963b8f0ed0f7fcc68a632a4ffe70ee0bc7ace1de\nparent 1975142c9792bc8488fa5768f40ef53ad8301fbf\nparent 51cec58040780975903e42fee6d30427b3f2cd15\nauthor Mara Bos <m-ou.se@m-ou.se> 1609361812 +0000\ncommitter GitHub <noreply@github.com> 1609361812 +0000\n\nRollup merge of #80458 - RalfJung:promotion-refactor, r=oli-obk\n\nSome Promotion Refactoring\n\nClean up promotion a bit:\n* factor out some common code\n* more exhaustive matches\n\nThis *should* not break anything... the only potentially-breaking change is that `BorrowKind::Shallow | BorrowKind::Unique` are now rejected for internal references.\n\nr? ``@oli-obk``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/46111c1901cc94c5233e3d5141cb0fc68063552b", "html_url": "https://github.com/rust-lang/rust/commit/46111c1901cc94c5233e3d5141cb0fc68063552b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/46111c1901cc94c5233e3d5141cb0fc68063552b/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1975142c9792bc8488fa5768f40ef53ad8301fbf", "url": "https://api.github.com/repos/rust-lang/rust/commits/1975142c9792bc8488fa5768f40ef53ad8301fbf", "html_url": "https://github.com/rust-lang/rust/commit/1975142c9792bc8488fa5768f40ef53ad8301fbf"}, {"sha": "51cec58040780975903e42fee6d30427b3f2cd15", "url": "https://api.github.com/repos/rust-lang/rust/commits/51cec58040780975903e42fee6d30427b3f2cd15", "html_url": "https://github.com/rust-lang/rust/commit/51cec58040780975903e42fee6d30427b3f2cd15"}], "stats": {"total": 214, "additions": 115, "deletions": 99}, "files": [{"sha": "ea92e23e9bffb6e03fe4a59ec07964720c39a425", "filename": "compiler/rustc_mir/src/transform/promote_consts.rs", "status": "modified", "additions": 115, "deletions": 99, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/46111c1901cc94c5233e3d5141cb0fc68063552b/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46111c1901cc94c5233e3d5141cb0fc68063552b/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=46111c1901cc94c5233e3d5141cb0fc68063552b", "patch": "@@ -90,7 +90,7 @@ pub enum TempState {\n impl TempState {\n     pub fn is_promotable(&self) -> bool {\n         debug!(\"is_promotable: self={:?}\", self);\n-        matches!(self, TempState::Defined { .. } )\n+        matches!(self, TempState::Defined { .. })\n     }\n }\n \n@@ -309,50 +309,26 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 let statement = &self.body[loc.block].statements[loc.statement_index];\n                 match &statement.kind {\n                     StatementKind::Assign(box (_, Rvalue::Ref(_, kind, place))) => {\n-                        match kind {\n-                            BorrowKind::Shared | BorrowKind::Mut { .. } => {}\n-\n-                            // FIXME(eddyb) these aren't promoted here but *could*\n-                            // be promoted as part of a larger value because\n-                            // `validate_rvalue`  doesn't check them, need to\n-                            // figure out what is the intended behavior.\n-                            BorrowKind::Shallow | BorrowKind::Unique => return Err(Unpromotable),\n-                        }\n-\n                         // We can only promote interior borrows of promotable temps (non-temps\n                         // don't get promoted anyway).\n                         self.validate_local(place.local)?;\n \n+                        // The reference operation itself must be promotable.\n+                        // (Needs to come after `validate_local` to avoid ICEs.)\n+                        self.validate_ref(*kind, place)?;\n+\n+                        // We do not check all the projections (they do not get promoted anyway),\n+                        // but we do stay away from promoting anything involving a dereference.\n                         if place.projection.contains(&ProjectionElem::Deref) {\n                             return Err(Unpromotable);\n                         }\n-                        if self.qualif_local::<qualifs::NeedsDrop>(place.local) {\n-                            return Err(Unpromotable);\n-                        }\n \n-                        // FIXME(eddyb) this duplicates part of `validate_rvalue`.\n-                        let has_mut_interior =\n-                            self.qualif_local::<qualifs::HasMutInterior>(place.local);\n-                        if has_mut_interior {\n+                        // We cannot promote things that need dropping, since the promoted value\n+                        // would not get dropped.\n+                        if self.qualif_local::<qualifs::NeedsDrop>(place.local) {\n                             return Err(Unpromotable);\n                         }\n \n-                        if let BorrowKind::Mut { .. } = kind {\n-                            let ty = place.ty(self.body, self.tcx).ty;\n-\n-                            // In theory, any zero-sized value could be borrowed\n-                            // mutably without consequences. However, only &mut []\n-                            // is allowed right now.\n-                            if let ty::Array(_, len) = ty.kind() {\n-                                match len.try_eval_usize(self.tcx, self.param_env) {\n-                                    Some(0) => {}\n-                                    _ => return Err(Unpromotable),\n-                                }\n-                            } else {\n-                                return Err(Unpromotable);\n-                            }\n-                        }\n-\n                         Ok(())\n                     }\n                     _ => bug!(),\n@@ -572,58 +548,115 @@ impl<'tcx> Validator<'_, 'tcx> {\n         }\n     }\n \n-    fn validate_rvalue(&self, rvalue: &Rvalue<'tcx>) -> Result<(), Unpromotable> {\n-        match *rvalue {\n-            Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) => {\n-                let operand_ty = operand.ty(self.body, self.tcx);\n-                let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n-                let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n-                if let (CastTy::Ptr(_) | CastTy::FnPtr, CastTy::Int(_)) = (cast_in, cast_out) {\n-                    // ptr-to-int casts are not possible in consts and thus not promotable\n+    fn validate_ref(&self, kind: BorrowKind, place: &Place<'tcx>) -> Result<(), Unpromotable> {\n+        match kind {\n+            // Reject these borrow types just to be safe.\n+            // FIXME(RalfJung): could we allow them? Should we? No point in it until we have a usecase.\n+            BorrowKind::Shallow | BorrowKind::Unique => return Err(Unpromotable),\n+\n+            BorrowKind::Shared => {\n+                let has_mut_interior = self.qualif_local::<qualifs::HasMutInterior>(place.local);\n+                if has_mut_interior {\n                     return Err(Unpromotable);\n                 }\n             }\n \n-            Rvalue::BinaryOp(op, ref lhs, _) => {\n-                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(self.body, self.tcx).kind() {\n-                    assert!(\n-                        op == BinOp::Eq\n-                            || op == BinOp::Ne\n-                            || op == BinOp::Le\n-                            || op == BinOp::Lt\n-                            || op == BinOp::Ge\n-                            || op == BinOp::Gt\n-                            || op == BinOp::Offset\n-                    );\n+            BorrowKind::Mut { .. } => {\n+                let ty = place.ty(self.body, self.tcx).ty;\n \n-                    // raw pointer operations are not allowed inside consts and thus not promotable\n+                // In theory, any zero-sized value could be borrowed\n+                // mutably without consequences. However, only &mut []\n+                // is allowed right now.\n+                if let ty::Array(_, len) = ty.kind() {\n+                    match len.try_eval_usize(self.tcx, self.param_env) {\n+                        Some(0) => {}\n+                        _ => return Err(Unpromotable),\n+                    }\n+                } else {\n                     return Err(Unpromotable);\n                 }\n             }\n-\n-            Rvalue::NullaryOp(NullOp::Box, _) => return Err(Unpromotable),\n-\n-            // FIXME(RalfJung): the rest is *implicitly considered promotable*... that seems dangerous.\n-            _ => {}\n         }\n \n+        Ok(())\n+    }\n+\n+    fn validate_rvalue(&self, rvalue: &Rvalue<'tcx>) -> Result<(), Unpromotable> {\n         match rvalue {\n-            Rvalue::ThreadLocalRef(_) => Err(Unpromotable),\n+            Rvalue::Use(operand)\n+            | Rvalue::Repeat(operand, _)\n+            | Rvalue::UnaryOp(UnOp::Not | UnOp::Neg, operand) => {\n+                self.validate_operand(operand)?;\n+            }\n \n-            Rvalue::NullaryOp(..) => Ok(()),\n+            Rvalue::Discriminant(place) | Rvalue::Len(place) => {\n+                self.validate_place(place.as_ref())?\n+            }\n \n-            Rvalue::Discriminant(place) | Rvalue::Len(place) => self.validate_place(place.as_ref()),\n+            Rvalue::ThreadLocalRef(_) => return Err(Unpromotable),\n \n-            Rvalue::Use(operand)\n-            | Rvalue::Repeat(operand, _)\n-            | Rvalue::UnaryOp(_, operand)\n-            | Rvalue::Cast(_, operand, _) => self.validate_operand(operand),\n+            Rvalue::Cast(kind, operand, cast_ty) => {\n+                if matches!(kind, CastKind::Misc) {\n+                    let operand_ty = operand.ty(self.body, self.tcx);\n+                    let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n+                    let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n+                    if let (CastTy::Ptr(_) | CastTy::FnPtr, CastTy::Int(_)) = (cast_in, cast_out) {\n+                        // ptr-to-int casts are not possible in consts and thus not promotable\n+                        return Err(Unpromotable);\n+                    }\n+                    // int-to-ptr casts are fine, they just use the integer value at pointer type.\n+                }\n+\n+                self.validate_operand(operand)?;\n+            }\n+\n+            Rvalue::BinaryOp(op, lhs, rhs) | Rvalue::CheckedBinaryOp(op, lhs, rhs) => {\n+                let op = *op;\n+                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(self.body, self.tcx).kind() {\n+                    // raw pointer operations are not allowed inside consts and thus not promotable\n+                    assert!(matches!(\n+                        op,\n+                        BinOp::Eq\n+                            | BinOp::Ne\n+                            | BinOp::Le\n+                            | BinOp::Lt\n+                            | BinOp::Ge\n+                            | BinOp::Gt\n+                            | BinOp::Offset\n+                    ));\n+                    return Err(Unpromotable);\n+                }\n+\n+                match op {\n+                    // FIXME: reject operations that can fail -- namely, division and modulo.\n+                    BinOp::Eq\n+                    | BinOp::Ne\n+                    | BinOp::Le\n+                    | BinOp::Lt\n+                    | BinOp::Ge\n+                    | BinOp::Gt\n+                    | BinOp::Offset\n+                    | BinOp::Add\n+                    | BinOp::Sub\n+                    | BinOp::Mul\n+                    | BinOp::Div\n+                    | BinOp::Rem\n+                    | BinOp::BitXor\n+                    | BinOp::BitAnd\n+                    | BinOp::BitOr\n+                    | BinOp::Shl\n+                    | BinOp::Shr => {}\n+                }\n \n-            Rvalue::BinaryOp(_, lhs, rhs) | Rvalue::CheckedBinaryOp(_, lhs, rhs) => {\n                 self.validate_operand(lhs)?;\n-                self.validate_operand(rhs)\n+                self.validate_operand(rhs)?;\n             }\n \n+            Rvalue::NullaryOp(op, _) => match op {\n+                NullOp::Box => return Err(Unpromotable),\n+                NullOp::SizeOf => {}\n+            },\n+\n             Rvalue::AddressOf(_, place) => {\n                 // We accept `&raw *`, i.e., raw reborrows -- creating a raw pointer is\n                 // no problem, only using it is.\n@@ -636,53 +669,36 @@ impl<'tcx> Validator<'_, 'tcx> {\n                         });\n                     }\n                 }\n-                Err(Unpromotable)\n+                return Err(Unpromotable);\n             }\n \n             Rvalue::Ref(_, kind, place) => {\n-                if let BorrowKind::Mut { .. } = kind {\n-                    let ty = place.ty(self.body, self.tcx).ty;\n-\n-                    // In theory, any zero-sized value could be borrowed\n-                    // mutably without consequences. However, only &mut []\n-                    // is allowed right now.\n-                    if let ty::Array(_, len) = ty.kind() {\n-                        match len.try_eval_usize(self.tcx, self.param_env) {\n-                            Some(0) => {}\n-                            _ => return Err(Unpromotable),\n-                        }\n-                    } else {\n-                        return Err(Unpromotable);\n-                    }\n-                }\n-\n                 // Special-case reborrows to be more like a copy of the reference.\n-                let mut place = place.as_ref();\n-                if let [proj_base @ .., ProjectionElem::Deref] = &place.projection {\n-                    let base_ty = Place::ty_from(place.local, proj_base, self.body, self.tcx).ty;\n+                let mut place_simplified = place.as_ref();\n+                if let [proj_base @ .., ProjectionElem::Deref] = &place_simplified.projection {\n+                    let base_ty =\n+                        Place::ty_from(place_simplified.local, proj_base, self.body, self.tcx).ty;\n                     if let ty::Ref(..) = base_ty.kind() {\n-                        place = PlaceRef { local: place.local, projection: proj_base };\n+                        place_simplified =\n+                            PlaceRef { local: place_simplified.local, projection: proj_base };\n                     }\n                 }\n \n-                self.validate_place(place)?;\n-\n-                let has_mut_interior = self.qualif_local::<qualifs::HasMutInterior>(place.local);\n-                if has_mut_interior {\n-                    return Err(Unpromotable);\n-                }\n+                self.validate_place(place_simplified)?;\n \n-                Ok(())\n+                // Check that the reference is fine (using the original place!).\n+                // (Needs to come after `validate_place` to avoid ICEs.)\n+                self.validate_ref(*kind, place)?;\n             }\n \n-            Rvalue::Aggregate(_, ref operands) => {\n+            Rvalue::Aggregate(_, operands) => {\n                 for o in operands {\n                     self.validate_operand(o)?;\n                 }\n-\n-                Ok(())\n             }\n         }\n+\n+        Ok(())\n     }\n \n     fn validate_call("}]}