{"sha": "29003c799f41cce948bc043cdd1350ca4bee949e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5MDAzYzc5OWY0MWNjZTk0OGJjMDQzY2RkMTM1MGNhNGJlZTk0OWU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-09-10T23:34:31Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-09-10T23:50:07Z"}, "message": "Rename the poorly named Managed<T> type to Mut<T>.\n\nThe Mut<T> type is intended to allow freezable data stuctures to be stored in\n`@mut` boxes. Currently this causes borrowck to be very conserivative since it\ncannot prove that you are not modifying such a structure while iterating over\nit, for example.  But if you do `@Mut<T>` instead of `@mut T`, you will\neffectively convert borrowck's static checks into dynamic ones.  This lets\nyou use the e.g. send_map just like a Java Map or something else.", "tree": {"sha": "0e879812117977b10d42558588f952b792fa5f99", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e879812117977b10d42558588f952b792fa5f99"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/29003c799f41cce948bc043cdd1350ca4bee949e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/29003c799f41cce948bc043cdd1350ca4bee949e", "html_url": "https://github.com/rust-lang/rust/commit/29003c799f41cce948bc043cdd1350ca4bee949e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/29003c799f41cce948bc043cdd1350ca4bee949e/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "20263595185590c8c2705b92bddbd00e3fc56713", "url": "https://api.github.com/repos/rust-lang/rust/commits/20263595185590c8c2705b92bddbd00e3fc56713", "html_url": "https://github.com/rust-lang/rust/commit/20263595185590c8c2705b92bddbd00e3fc56713"}], "stats": {"total": 54, "additions": 31, "deletions": 23}, "files": [{"sha": "c0c9cf5f9b68b7b8e313e48421adfd64680666d3", "filename": "src/libcore/core.rc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29003c799f41cce948bc043cdd1350ca4bee949e/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/29003c799f41cce948bc043cdd1350ca4bee949e/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=29003c799f41cce948bc043cdd1350ca4bee949e", "patch": "@@ -57,7 +57,7 @@ export hash;\n export cmp;\n export num;\n export path;\n-export managed;\n+export mutable;\n export flate;\n export unit;\n export uniq;\n@@ -225,7 +225,7 @@ mod run;\n mod sys;\n mod unsafe;\n \n-mod managed;\n+mod mutable;\n \n mod flate;\n "}, {"sha": "eca9ff6fadaca7f300fce567771d9dc2845a107f", "filename": "src/libcore/mutable.rs", "status": "renamed", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/29003c799f41cce948bc043cdd1350ca4bee949e/src%2Flibcore%2Fmutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29003c799f41cce948bc043cdd1350ca4bee949e/src%2Flibcore%2Fmutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmutable.rs?ref=29003c799f41cce948bc043cdd1350ca4bee949e", "patch": "@@ -15,7 +15,7 @@ mutation when the data structure should be immutable.\n use util::with;\n use unsafe::transmute_immut;\n \n-export Managed;\n+export Mut;\n \n enum Mode { ReadOnly, Mutable, Immutable }\n \n@@ -24,18 +24,26 @@ struct Data<T> {\n     priv mut mode: Mode\n }\n \n-type Managed<T> = @Data<T>;\n+type Mut<T> = Data<T>;\n \n-fn Managed<T>(+t: T) -> Managed<T> {\n-    @Data {value: t, mode: ReadOnly}\n+fn Mut<T>(+t: T) -> Mut<T> {\n+    Data {value: t, mode: ReadOnly}\n+}\n+\n+fn unwrap<T>(+m: Mut<T>) -> T {\n+    // Borrowck should prevent us from calling unwrap while the value\n+    // is in use, as that would be a move from a borrowed value.\n+    assert (m.mode as uint) == (ReadOnly as uint);\n+    let Data {value, mode: _} = m;\n+    return move value;\n }\n \n impl<T> Data<T> {\n     fn borrow_mut<R>(op: &fn(t: &mut T) -> R) -> R {\n         match self.mode {\n-          Immutable => fail fmt!(\"%? currently immutable\",\n-                                 self.value),\n-          ReadOnly | Mutable => {}\n+            Immutable => fail fmt!(\"%? currently immutable\",\n+                                   self.value),\n+            ReadOnly | Mutable => {}\n         }\n \n         do with(&mut self.mode, Mutable) {\n@@ -64,7 +72,7 @@ impl<T> Data<T> {\n #[ignore(cfg(windows))]\n #[should_fail]\n fn test_mut_in_imm() {\n-    let m = Managed(1);\n+    let m = @Mut(1);\n     do m.borrow_imm |_p| {\n         do m.borrow_mut |_q| {\n             // should not be permitted\n@@ -76,7 +84,7 @@ fn test_mut_in_imm() {\n #[ignore(cfg(windows))]\n #[should_fail]\n fn test_imm_in_mut() {\n-    let m = Managed(1);\n+    let m = @Mut(1);\n     do m.borrow_mut |_p| {\n         do m.borrow_imm |_q| {\n             // should not be permitted\n@@ -86,7 +94,7 @@ fn test_imm_in_mut() {\n \n #[test]\n fn test_const_in_mut() {\n-    let m = Managed(1);\n+    let m = @Mut(1);\n     do m.borrow_mut |p| {\n         do m.borrow_const |q| {\n             assert *p == *q;\n@@ -98,7 +106,7 @@ fn test_const_in_mut() {\n \n #[test]\n fn test_mut_in_const() {\n-    let m = Managed(1);\n+    let m = @Mut(1);\n     do m.borrow_const |p| {\n         do m.borrow_mut |q| {\n             assert *p == *q;\n@@ -110,7 +118,7 @@ fn test_mut_in_const() {\n \n #[test]\n fn test_imm_in_const() {\n-    let m = Managed(1);\n+    let m = @Mut(1);\n     do m.borrow_const |p| {\n         do m.borrow_imm |q| {\n             assert *p == *q;\n@@ -120,7 +128,7 @@ fn test_imm_in_const() {\n \n #[test]\n fn test_const_in_imm() {\n-    let m = Managed(1);\n+    let m = @Mut(1);\n     do m.borrow_imm |p| {\n         do m.borrow_const |q| {\n             assert *p == *q;\n@@ -133,7 +141,7 @@ fn test_const_in_imm() {\n #[ignore(cfg(windows))]\n #[should_fail]\n fn test_mut_in_imm_in_const() {\n-    let m = Managed(1);\n+    let m = @Mut(1);\n     do m.borrow_const |_p| {\n         do m.borrow_imm |_q| {\n             do m.borrow_mut |_r| {", "previous_filename": "src/libcore/managed.rs"}, {"sha": "cd19da61ab69fc7a9e222bab3426f4d29f46c102", "filename": "src/libstd/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29003c799f41cce948bc043cdd1350ca4bee949e/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29003c799f41cce948bc043cdd1350ca4bee949e/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=29003c799f41cce948bc043cdd1350ca4bee949e", "patch": "@@ -5,7 +5,7 @@\n \n use io::WriterUtil;\n use to_str::ToStr;\n-use managed::Managed;\n+use mutable::Mut;\n use send_map::linear::LinearMap;\n \n use core::cmp::Eq;\n@@ -463,7 +463,7 @@ fn hash_from_uints<V: Copy>(items: &[(uint, V)]) -> hashmap<uint, V> {\n }\n \n // XXX Transitional\n-impl<K: Eq IterBytes Hash Copy, V: Copy> Managed<LinearMap<K, V>>:\n+impl<K: Eq IterBytes Hash Copy, V: Copy> @Mut<LinearMap<K, V>>:\n     map<K, V> {\n     pure fn size() -> uint {\n         unchecked {"}, {"sha": "112c25d5146f5eab372a01545e828fa14ea2573a", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/29003c799f41cce948bc043cdd1350ca4bee949e/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29003c799f41cce948bc043cdd1350ca4bee949e/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=29003c799f41cce948bc043cdd1350ca4bee949e", "patch": "@@ -6,7 +6,7 @@\n \n use std;\n use std::map;\n-use managed::Managed;\n+use mutable::Mut;\n use send_map::linear::*;\n use io::WriterUtil;\n \n@@ -166,11 +166,11 @@ fn main(args: ~[~str]) {\n     {\n         let rng = rand::seeded_rng(copy seed);\n         let mut results = empty_results();\n-        int_benchmarks::<Managed<LinearMap<uint, uint>>>(\n-            || Managed(LinearMap()),\n+        int_benchmarks::<@Mut<LinearMap<uint, uint>>>(\n+            || @Mut(LinearMap()),\n             rng, num_keys, &mut results);\n-        str_benchmarks::<Managed<LinearMap<~str, uint>>>(\n-            || Managed(LinearMap()),\n+        str_benchmarks::<@Mut<LinearMap<~str, uint>>>(\n+            || @Mut(LinearMap()),\n             rng, num_keys, &mut results);\n         write_results(\"libstd::map::hashmap\", &results);\n     }"}]}