{"sha": "af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmM2M0YzBjMjNjODY5NWUyY2JkMzk0MTBhMzRkZDZkYjEwZGU1YzY=", "commit": {"author": {"name": "Tim Diekmann", "email": "21277928+TimDiekmann@users.noreply.github.com", "date": "2019-04-18T10:22:58Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-04-18T10:22:58Z"}, "message": "Merge branch 'master' into realloc", "tree": {"sha": "baf96a3738aa181b2adcef039b22fe7784805259", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/baf96a3738aa181b2adcef039b22fe7784805259"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcuFACCRBK7hj4Ov3rIwAAdHIIAGSIsdRkfLT7xIxi0UhNNV+U\nv+5gZw/ACTfwjp9uF8/P3EXfUOSVBrg+W84XuC78vz5qU/3vDSpPbGKZ6JoRqEuX\nOZQav+X1OMOZCVbkgBATYfXnFq0X5VL3Uj9bt10z70yfiIdVHx28cuvUZpGeIffp\n7y8IgsDWxAsHbYfZZcjafIbQymhfKjEyYEJ0hP/Cz4YPmm5us0MoUN86zBs576dx\nBC7ttE5crL4qmjMdOO1d3o+Cekl2Cq18u1nTeH77xFeQFtcs//ITwv2NRdeOfRro\nwXAb83OaEb7x0Rn0MrxLMN9+eBWWLav5zu2Rf5KmWcXV98XVMYPHL1iRFT8SKg0=\n=OICj\n-----END PGP SIGNATURE-----\n", "payload": "tree baf96a3738aa181b2adcef039b22fe7784805259\nparent 0e6deee76ef49e44d1089d6f2b8f9966a1c2db0a\nparent ae9e9cb47c7b79d8bb29fab90929bd9b3606348a\nauthor Tim Diekmann <21277928+TimDiekmann@users.noreply.github.com> 1555582978 +0200\ncommitter GitHub <noreply@github.com> 1555582978 +0200\n\nMerge branch 'master' into realloc"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "html_url": "https://github.com/rust-lang/rust/commit/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/comments", "author": {"login": "TimDiekmann", "id": 21277928, "node_id": "MDQ6VXNlcjIxMjc3OTI4", "avatar_url": "https://avatars.githubusercontent.com/u/21277928?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TimDiekmann", "html_url": "https://github.com/TimDiekmann", "followers_url": "https://api.github.com/users/TimDiekmann/followers", "following_url": "https://api.github.com/users/TimDiekmann/following{/other_user}", "gists_url": "https://api.github.com/users/TimDiekmann/gists{/gist_id}", "starred_url": "https://api.github.com/users/TimDiekmann/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TimDiekmann/subscriptions", "organizations_url": "https://api.github.com/users/TimDiekmann/orgs", "repos_url": "https://api.github.com/users/TimDiekmann/repos", "events_url": "https://api.github.com/users/TimDiekmann/events{/privacy}", "received_events_url": "https://api.github.com/users/TimDiekmann/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e6deee76ef49e44d1089d6f2b8f9966a1c2db0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e6deee76ef49e44d1089d6f2b8f9966a1c2db0a", "html_url": "https://github.com/rust-lang/rust/commit/0e6deee76ef49e44d1089d6f2b8f9966a1c2db0a"}, {"sha": "ae9e9cb47c7b79d8bb29fab90929bd9b3606348a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae9e9cb47c7b79d8bb29fab90929bd9b3606348a", "html_url": "https://github.com/rust-lang/rust/commit/ae9e9cb47c7b79d8bb29fab90929bd9b3606348a"}], "stats": {"total": 1491, "additions": 763, "deletions": 728}, "files": [{"sha": "40e42e6886472d054dc3ad4f8df07de756d10f20", "filename": "rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/rust-version", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/rust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-version?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -1 +1 @@\n-ee621f42329069c296b4c2066b3743cc4ff0f369\n+efe2f32a6b8217425f361ec7c206910c611c03ee"}, {"sha": "7b1ea73eb80f2083bd2df7782c72c5caa5cc659d", "filename": "src/fn_call.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/src%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/src%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffn_call.rs?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -13,8 +13,8 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a + 'mir>: crate::MiriEvalContextExt<'\n     fn find_fn(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n-        args: &[OpTy<'tcx, Borrow>],\n-        dest: Option<PlaceTy<'tcx, Borrow>>,\n+        args: &[OpTy<'tcx, Tag>],\n+        dest: Option<PlaceTy<'tcx, Tag>>,\n         ret: Option<mir::BasicBlock>,\n     ) -> EvalResult<'tcx, Option<&'mir mir::Mir<'tcx>>> {\n         let this = self.eval_context_mut();\n@@ -55,8 +55,8 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a + 'mir>: crate::MiriEvalContextExt<'\n     fn emulate_foreign_item(\n         &mut self,\n         def_id: DefId,\n-        args: &[OpTy<'tcx, Borrow>],\n-        dest: Option<PlaceTy<'tcx, Borrow>>,\n+        args: &[OpTy<'tcx, Tag>],\n+        dest: Option<PlaceTy<'tcx, Tag>>,\n         ret: Option<mir::BasicBlock>,\n     ) -> EvalResult<'tcx> {\n         let this = self.eval_context_mut();\n@@ -92,7 +92,7 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a + 'mir>: crate::MiriEvalContextExt<'\n                 } else {\n                     let align = this.tcx.data_layout.pointer_align.abi;\n                     let ptr = this.memory_mut().allocate(Size::from_bytes(size), align, MiriMemoryKind::C.into());\n-                    this.write_scalar(Scalar::Ptr(ptr.with_default_tag()), dest)?;\n+                    this.write_scalar(Scalar::Ptr(ptr), dest)?;\n                 }\n             }\n             \"calloc\" => {\n@@ -105,7 +105,7 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a + 'mir>: crate::MiriEvalContextExt<'\n                 } else {\n                     let size = Size::from_bytes(bytes);\n                     let align = this.tcx.data_layout.pointer_align.abi;\n-                    let ptr = this.memory_mut().allocate(size, align, MiriMemoryKind::C.into()).with_default_tag();\n+                    let ptr = this.memory_mut().allocate(size, align, MiriMemoryKind::C.into());\n                     this.memory_mut().get_mut(ptr.alloc_id)?.write_repeat(tcx, ptr, 0, size)?;\n                     this.write_scalar(Scalar::Ptr(ptr), dest)?;\n                 }\n@@ -132,7 +132,7 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a + 'mir>: crate::MiriEvalContextExt<'\n                         Align::from_bytes(align).unwrap(),\n                         MiriMemoryKind::C.into()\n                     );\n-                    this.write_scalar(Scalar::Ptr(ptr.with_default_tag()), ret.into())?;\n+                    this.write_scalar(Scalar::Ptr(ptr), ret.into())?;\n                 }\n                 this.write_null(dest)?;\n             }\n@@ -179,8 +179,7 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a + 'mir>: crate::MiriEvalContextExt<'\n                         Size::from_bytes(size),\n                         Align::from_bytes(align).unwrap(),\n                         MiriMemoryKind::Rust.into()\n-                    )\n-                    .with_default_tag();\n+                    );\n                 this.write_scalar(Scalar::Ptr(ptr), dest)?;\n             }\n             \"__rust_alloc_zeroed\" => {\n@@ -197,8 +196,7 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a + 'mir>: crate::MiriEvalContextExt<'\n                         Size::from_bytes(size),\n                         Align::from_bytes(align).unwrap(),\n                         MiriMemoryKind::Rust.into()\n-                    )\n-                    .with_default_tag();\n+                    );\n                 this.memory_mut()\n                     .get_mut(ptr.alloc_id)?\n                     .write_repeat(tcx, ptr, 0, Size::from_bytes(size))?;\n@@ -239,7 +237,7 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a + 'mir>: crate::MiriEvalContextExt<'\n                     Align::from_bytes(align).unwrap(),\n                     MiriMemoryKind::Rust.into(),\n                 )?;\n-                this.write_scalar(Scalar::Ptr(new_ptr.with_default_tag()), dest)?;\n+                this.write_scalar(Scalar::Ptr(new_ptr), dest)?;\n             }\n \n             \"syscall\" => {\n@@ -445,7 +443,7 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a + 'mir>: crate::MiriEvalContextExt<'\n                         Size::from_bytes((value.len() + 1) as u64),\n                         Align::from_bytes(1).unwrap(),\n                         MiriMemoryKind::Env.into(),\n-                    ).with_default_tag();\n+                    );\n                     {\n                         let alloc = this.memory_mut().get_mut(value_copy.alloc_id)?;\n                         alloc.write_bytes(tcx, value_copy, &value)?;\n@@ -815,13 +813,13 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a + 'mir>: crate::MiriEvalContextExt<'\n         Ok(())\n     }\n \n-    fn write_null(&mut self, dest: PlaceTy<'tcx, Borrow>) -> EvalResult<'tcx> {\n+    fn write_null(&mut self, dest: PlaceTy<'tcx, Tag>) -> EvalResult<'tcx> {\n         self.eval_context_mut().write_scalar(Scalar::from_int(0, dest.layout.size), dest)\n     }\n \n     /// Evaluates the scalar at the specified path. Returns Some(val)\n     /// if the path could be resolved, and None otherwise\n-    fn eval_path_scalar(&mut self, path: &[&str]) -> EvalResult<'tcx, Option<ScalarMaybeUndef<stacked_borrows::Borrow>>> {\n+    fn eval_path_scalar(&mut self, path: &[&str]) -> EvalResult<'tcx, Option<ScalarMaybeUndef<Tag>>> {\n         let this = self.eval_context_mut();\n         if let Ok(instance) = this.resolve_path(path) {\n             let cid = GlobalId {"}, {"sha": "f468d256031ca0e395e58278bb72cc91378d9be8", "filename": "src/helpers.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -47,9 +47,9 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a + 'mir>: crate::MiriEvalContextExt<'\n     /// will be true if this is frozen, false if this is in an `UnsafeCell`.\n     fn visit_freeze_sensitive(\n         &self,\n-        place: MPlaceTy<'tcx, Borrow>,\n+        place: MPlaceTy<'tcx, Tag>,\n         size: Size,\n-        mut action: impl FnMut(Pointer<Borrow>, Size, bool) -> EvalResult<'tcx>,\n+        mut action: impl FnMut(Pointer<Tag>, Size, bool) -> EvalResult<'tcx>,\n     ) -> EvalResult<'tcx> {\n         let this = self.eval_context_ref();\n         trace!(\"visit_frozen(place={:?}, size={:?})\", *place, size);\n@@ -64,7 +64,7 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a + 'mir>: crate::MiriEvalContextExt<'\n         let mut end_ptr = place.ptr;\n         // Called when we detected an `UnsafeCell` at the given offset and size.\n         // Calls `action` and advances `end_ptr`.\n-        let mut unsafe_cell_action = |unsafe_cell_ptr: Scalar<Borrow>, unsafe_cell_size: Size| {\n+        let mut unsafe_cell_action = |unsafe_cell_ptr: Scalar<Tag>, unsafe_cell_size: Size| {\n             if unsafe_cell_size != Size::ZERO {\n                 debug_assert_eq!(unsafe_cell_ptr.to_ptr().unwrap().alloc_id,\n                     end_ptr.to_ptr().unwrap().alloc_id);\n@@ -120,7 +120,7 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a + 'mir>: crate::MiriEvalContextExt<'\n         /// Visiting the memory covered by a `MemPlace`, being aware of\n         /// whether we are inside an `UnsafeCell` or not.\n         struct UnsafeCellVisitor<'ecx, 'a, 'mir, 'tcx, F>\n-            where F: FnMut(MPlaceTy<'tcx, Borrow>) -> EvalResult<'tcx>\n+            where F: FnMut(MPlaceTy<'tcx, Tag>) -> EvalResult<'tcx>\n         {\n             ecx: &'ecx MiriEvalContext<'a, 'mir, 'tcx>,\n             unsafe_cell_action: F,\n@@ -131,17 +131,17 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a + 'mir>: crate::MiriEvalContextExt<'\n         for\n             UnsafeCellVisitor<'ecx, 'a, 'mir, 'tcx, F>\n         where\n-            F: FnMut(MPlaceTy<'tcx, Borrow>) -> EvalResult<'tcx>\n+            F: FnMut(MPlaceTy<'tcx, Tag>) -> EvalResult<'tcx>\n         {\n-            type V = MPlaceTy<'tcx, Borrow>;\n+            type V = MPlaceTy<'tcx, Tag>;\n \n             #[inline(always)]\n             fn ecx(&self) -> &MiriEvalContext<'a, 'mir, 'tcx> {\n                 &self.ecx\n             }\n \n             // Hook to detect `UnsafeCell`.\n-            fn visit_value(&mut self, v: MPlaceTy<'tcx, Borrow>) -> EvalResult<'tcx>\n+            fn visit_value(&mut self, v: MPlaceTy<'tcx, Tag>) -> EvalResult<'tcx>\n             {\n                 trace!(\"UnsafeCellVisitor: {:?} {:?}\", *v, v.layout.ty);\n                 let is_unsafe_cell = match v.layout.ty.sty {\n@@ -163,8 +163,8 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a + 'mir>: crate::MiriEvalContextExt<'\n             // Make sure we visit aggregrates in increasing offset order.\n             fn visit_aggregate(\n                 &mut self,\n-                place: MPlaceTy<'tcx, Borrow>,\n-                fields: impl Iterator<Item=EvalResult<'tcx, MPlaceTy<'tcx, Borrow>>>,\n+                place: MPlaceTy<'tcx, Tag>,\n+                fields: impl Iterator<Item=EvalResult<'tcx, MPlaceTy<'tcx, Tag>>>,\n             ) -> EvalResult<'tcx> {\n                 match place.layout.fields {\n                     layout::FieldPlacement::Array { .. } => {\n@@ -174,7 +174,7 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a + 'mir>: crate::MiriEvalContextExt<'\n                     }\n                     layout::FieldPlacement::Arbitrary { .. } => {\n                         // Gather the subplaces and sort them before visiting.\n-                        let mut places = fields.collect::<EvalResult<'tcx, Vec<MPlaceTy<'tcx, Borrow>>>>()?;\n+                        let mut places = fields.collect::<EvalResult<'tcx, Vec<MPlaceTy<'tcx, Tag>>>>()?;\n                         places.sort_by_key(|place| place.ptr.get_ptr_offset(self.ecx()));\n                         self.walk_aggregate(place, places.into_iter().map(Ok))\n                     }\n@@ -186,7 +186,7 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a + 'mir>: crate::MiriEvalContextExt<'\n             }\n \n             // We have to do *something* for unions.\n-            fn visit_union(&mut self, v: MPlaceTy<'tcx, Borrow>) -> EvalResult<'tcx>\n+            fn visit_union(&mut self, v: MPlaceTy<'tcx, Tag>) -> EvalResult<'tcx>\n             {\n                 // With unions, we fall back to whatever the type says, to hopefully be consistent\n                 // with LLVM IR.\n@@ -200,7 +200,7 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a + 'mir>: crate::MiriEvalContextExt<'\n             }\n \n             // We should never get to a primitive, but always short-circuit somewhere above.\n-            fn visit_primitive(&mut self, _v: MPlaceTy<'tcx, Borrow>) -> EvalResult<'tcx>\n+            fn visit_primitive(&mut self, _v: MPlaceTy<'tcx, Tag>) -> EvalResult<'tcx>\n             {\n                 bug!(\"we should always short-circuit before coming to a primitive\")\n             }"}, {"sha": "a17f576b43b7f3e3105fa601d5c64996121e42e0", "filename": "src/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/src%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/src%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic.rs?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -4,7 +4,7 @@ use rustc::ty::layout::{self, LayoutOf, Size};\n use rustc::ty;\n \n use crate::{\n-    PlaceTy, OpTy, ImmTy, Immediate, Scalar, ScalarMaybeUndef, Borrow,\n+    PlaceTy, OpTy, ImmTy, Immediate, Scalar, ScalarMaybeUndef, Tag,\n     OperatorEvalContextExt\n };\n \n@@ -13,8 +13,8 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n     fn call_intrinsic(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n-        args: &[OpTy<'tcx, Borrow>],\n-        dest: PlaceTy<'tcx, Borrow>,\n+        args: &[OpTy<'tcx, Tag>],\n+        dest: PlaceTy<'tcx, Tag>,\n     ) -> EvalResult<'tcx> {\n         let this = self.eval_context_mut();\n         if this.emulate_intrinsic(instance, args, dest)? {"}, {"sha": "3dbe922999dabcc77a2be19bc4a407ec77243be5", "filename": "src/lib.rs", "status": "modified", "additions": 48, "deletions": 60, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -23,6 +23,7 @@ mod stacked_borrows;\n \n use std::collections::HashMap;\n use std::borrow::Cow;\n+use std::rc::Rc;\n \n use rand::rngs::StdRng;\n use rand::SeedableRng;\n@@ -48,7 +49,7 @@ use crate::mono_hash_map::MonoHashMap;\n pub use crate::stacked_borrows::{EvalContextExt as StackedBorEvalContextExt};\n \n // Used by priroda.\n-pub use crate::stacked_borrows::{Borrow, Stack, Stacks, BorStackItem};\n+pub use crate::stacked_borrows::{Tag, Permission, Stack, Stacks, Item};\n \n /// Insert rustc arguments at the beginning of the argument list that Miri wants to be\n /// set per default, for maximal validation power.\n@@ -155,7 +156,7 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n     // Don't forget `0` terminator.\n     cmd.push(std::char::from_u32(0).unwrap());\n     // Collect the pointers to the individual strings.\n-    let mut argvs = Vec::<Pointer<Borrow>>::new();\n+    let mut argvs = Vec::<Pointer<Tag>>::new();\n     for arg in config.args {\n         // Add `0` terminator.\n         let mut arg = arg.into_bytes();\n@@ -187,7 +188,7 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n             Size::from_bytes(cmd_utf16.len() as u64 * 2),\n             Align::from_bytes(2).unwrap(),\n             MiriMemoryKind::Env.into(),\n-        ).with_default_tag();\n+        );\n         ecx.machine.cmd_line = Some(cmd_ptr);\n         // Store the UTF-16 string.\n         let char_size = Size::from_bytes(2);\n@@ -214,7 +215,13 @@ pub fn eval_main<'a, 'tcx: 'a>(\n     main_id: DefId,\n     config: MiriConfig,\n ) {\n-    let mut ecx = create_ecx(tcx, main_id, config).expect(\"couldn't create ecx\");\n+    let mut ecx = match create_ecx(tcx, main_id, config) {\n+        Ok(ecx) => ecx,\n+        Err(mut err) => {\n+            err.print_backtrace();\n+            panic!(\"Miri initialziation error: {}\", err.kind)\n+        }\n+    };\n \n     // Perform the main execution.\n     let res: EvalResult = (|| {\n@@ -310,14 +317,14 @@ impl MayLeak for MiriMemoryKind {\n pub struct Evaluator<'tcx> {\n     /// Environment variables set by `setenv`.\n     /// Miri does not expose env vars from the host to the emulated program.\n-    pub(crate) env_vars: HashMap<Vec<u8>, Pointer<Borrow>>,\n+    pub(crate) env_vars: HashMap<Vec<u8>, Pointer<Tag>>,\n \n     /// Program arguments (`Option` because we can only initialize them after creating the ecx).\n     /// These are *pointers* to argc/argv because macOS.\n     /// We also need the full command line as one string because of Windows.\n-    pub(crate) argc: Option<Pointer<Borrow>>,\n-    pub(crate) argv: Option<Pointer<Borrow>>,\n-    pub(crate) cmd_line: Option<Pointer<Borrow>>,\n+    pub(crate) argc: Option<Pointer<Tag>>,\n+    pub(crate) argv: Option<Pointer<Tag>>,\n+    pub(crate) cmd_line: Option<Pointer<Tag>>,\n \n     /// Last OS error.\n     pub(crate) last_error: u32,\n@@ -328,9 +335,6 @@ pub struct Evaluator<'tcx> {\n     /// Whether to enforce the validity invariant.\n     pub(crate) validate: bool,\n \n-    /// Stacked Borrows state.\n-    pub(crate) stacked_borrows: stacked_borrows::State,\n-\n     /// The random number generator to use if Miri\n     /// is running in non-deterministic mode\n     pub(crate) rng: Option<StdRng>\n@@ -346,7 +350,6 @@ impl<'tcx> Evaluator<'tcx> {\n             last_error: 0,\n             tls: TlsData::default(),\n             validate,\n-            stacked_borrows: stacked_borrows::State::default(),\n             rng: seed.map(|s| StdRng::seed_from_u64(s))\n         }\n     }\n@@ -378,9 +381,9 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n     type FrameExtra = stacked_borrows::CallId;\n     type MemoryExtra = stacked_borrows::MemoryState;\n     type AllocExtra = stacked_borrows::Stacks;\n-    type PointerTag = Borrow;\n+    type PointerTag = Tag;\n \n-    type MemoryMap = MonoHashMap<AllocId, (MemoryKind<MiriMemoryKind>, Allocation<Borrow, Self::AllocExtra>)>;\n+    type MemoryMap = MonoHashMap<AllocId, (MemoryKind<MiriMemoryKind>, Allocation<Tag, Self::AllocExtra>)>;\n \n     const STATIC_KIND: Option<MiriMemoryKind> = Some(MiriMemoryKind::MutStatic);\n \n@@ -394,8 +397,8 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n     fn find_fn(\n         ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n-        args: &[OpTy<'tcx, Borrow>],\n-        dest: Option<PlaceTy<'tcx, Borrow>>,\n+        args: &[OpTy<'tcx, Tag>],\n+        dest: Option<PlaceTy<'tcx, Tag>>,\n         ret: Option<mir::BasicBlock>,\n     ) -> EvalResult<'tcx, Option<&'mir mir::Mir<'tcx>>> {\n         ecx.find_fn(instance, args, dest, ret)\n@@ -405,8 +408,8 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n     fn call_intrinsic(\n         ecx: &mut rustc_mir::interpret::InterpretCx<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n-        args: &[OpTy<'tcx, Borrow>],\n-        dest: PlaceTy<'tcx, Borrow>,\n+        args: &[OpTy<'tcx, Tag>],\n+        dest: PlaceTy<'tcx, Tag>,\n     ) -> EvalResult<'tcx> {\n         ecx.call_intrinsic(instance, args, dest)\n     }\n@@ -415,15 +418,15 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n     fn ptr_op(\n         ecx: &rustc_mir::interpret::InterpretCx<'a, 'mir, 'tcx, Self>,\n         bin_op: mir::BinOp,\n-        left: ImmTy<'tcx, Borrow>,\n-        right: ImmTy<'tcx, Borrow>,\n-    ) -> EvalResult<'tcx, (Scalar<Borrow>, bool)> {\n+        left: ImmTy<'tcx, Tag>,\n+        right: ImmTy<'tcx, Tag>,\n+    ) -> EvalResult<'tcx, (Scalar<Tag>, bool)> {\n         ecx.ptr_op(bin_op, left, right)\n     }\n \n     fn box_alloc(\n         ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n-        dest: PlaceTy<'tcx, Borrow>,\n+        dest: PlaceTy<'tcx, Tag>,\n     ) -> EvalResult<'tcx> {\n         trace!(\"box_alloc for {:?}\", dest.layout.ty);\n         // Call the `exchange_malloc` lang item.\n@@ -467,7 +470,7 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n         def_id: DefId,\n         tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n         memory_extra: &Self::MemoryExtra,\n-    ) -> EvalResult<'tcx, Cow<'tcx, Allocation<Borrow, Self::AllocExtra>>> {\n+    ) -> EvalResult<'tcx, Cow<'tcx, Allocation<Tag, Self::AllocExtra>>> {\n         let attrs = tcx.get_attrs(def_id);\n         let link_name = match attr::first_attr_value_str_by_name(&attrs, \"link_name\") {\n             Some(name) => name.as_str(),\n@@ -479,7 +482,7 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n                 // This should be all-zero, pointer-sized.\n                 let size = tcx.data_layout.pointer_size;\n                 let data = vec![0; size.bytes() as usize];\n-                let extra = AllocationExtra::memory_allocated(size, memory_extra);\n+                let extra = Stacks::new(size, Tag::default(), Rc::clone(memory_extra));\n                 Allocation::from_bytes(&data, tcx.data_layout.pointer_align.abi, extra)\n             }\n             _ => return err!(Unimplemented(\n@@ -499,16 +502,17 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n     fn adjust_static_allocation<'b>(\n         alloc: &'b Allocation,\n         memory_extra: &Self::MemoryExtra,\n-    ) -> Cow<'b, Allocation<Borrow, Self::AllocExtra>> {\n-        let extra = AllocationExtra::memory_allocated(\n+    ) -> Cow<'b, Allocation<Tag, Self::AllocExtra>> {\n+        let extra = Stacks::new(\n             Size::from_bytes(alloc.bytes.len() as u64),\n-            memory_extra,\n+            Tag::default(),\n+            Rc::clone(memory_extra),\n         );\n-        let alloc: Allocation<Borrow, Self::AllocExtra> = Allocation {\n+        let alloc: Allocation<Tag, Self::AllocExtra> = Allocation {\n             bytes: alloc.bytes.clone(),\n             relocations: Relocations::from_presorted(\n                 alloc.relocations.iter()\n-                    .map(|&(offset, ((), alloc))| (offset, (Borrow::default(), alloc)))\n+                    .map(|&(offset, ((), alloc))| (offset, (Tag::default(), alloc)))\n                     .collect()\n             ),\n             undef_mask: alloc.undef_mask.clone(),\n@@ -519,46 +523,30 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n         Cow::Owned(alloc)\n     }\n \n-    fn tag_dereference(\n-        ecx: &InterpretCx<'a, 'mir, 'tcx, Self>,\n-        place: MPlaceTy<'tcx, Borrow>,\n-        mutability: Option<hir::Mutability>,\n-    ) -> EvalResult<'tcx, Scalar<Borrow>> {\n-        let size = ecx.size_and_align_of_mplace(place)?.map(|(size, _)| size)\n-            // For extern types, just cover what we can.\n-            .unwrap_or_else(|| place.layout.size);\n-        if !ecx.tcx.sess.opts.debugging_opts.mir_emit_retag ||\n-            !Self::enforce_validity(ecx) || size == Size::ZERO\n-        {\n-            // No tracking.\n-            Ok(place.ptr)\n-        } else {\n-            ecx.ptr_dereference(place, size, mutability.into())?;\n-            // We never change the pointer.\n-            Ok(place.ptr)\n-        }\n+    #[inline(always)]\n+    fn new_allocation(\n+        size: Size,\n+        extra: &Self::MemoryExtra,\n+        kind: MemoryKind<MiriMemoryKind>,\n+    ) -> (Self::AllocExtra, Self::PointerTag) {\n+        Stacks::new_allocation(size, extra, kind)\n     }\n \n     #[inline(always)]\n-    fn tag_new_allocation(\n-        ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n-        ptr: Pointer,\n-        kind: MemoryKind<Self::MemoryKinds>,\n-    ) -> Pointer<Borrow> {\n-        if !ecx.machine.validate {\n-            // No tracking.\n-            ptr.with_default_tag()\n-        } else {\n-            let tag = ecx.tag_new_allocation(ptr.alloc_id, kind);\n-            Pointer::new_with_tag(ptr.alloc_id, ptr.offset, tag)\n-        }\n+    fn tag_dereference(\n+        _ecx: &InterpretCx<'a, 'mir, 'tcx, Self>,\n+        place: MPlaceTy<'tcx, Tag>,\n+        _mutability: Option<hir::Mutability>,\n+    ) -> EvalResult<'tcx, Scalar<Tag>> {\n+        // Nothing happens.\n+        Ok(place.ptr)\n     }\n \n     #[inline(always)]\n     fn retag(\n         ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n         kind: mir::RetagKind,\n-        place: PlaceTy<'tcx, Borrow>,\n+        place: PlaceTy<'tcx, Tag>,\n     ) -> EvalResult<'tcx> {\n         if !ecx.tcx.sess.opts.debugging_opts.mir_emit_retag || !Self::enforce_validity(ecx) {\n             // No tracking, or no retagging. The latter is possible because a dependency of ours"}, {"sha": "386fc4307b87f4cfcc787252dc711711748991fb", "filename": "src/operator.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -7,39 +7,39 @@ pub trait EvalContextExt<'tcx> {\n     fn ptr_op(\n         &self,\n         bin_op: mir::BinOp,\n-        left: ImmTy<'tcx, Borrow>,\n-        right: ImmTy<'tcx, Borrow>,\n-    ) -> EvalResult<'tcx, (Scalar<Borrow>, bool)>;\n+        left: ImmTy<'tcx, Tag>,\n+        right: ImmTy<'tcx, Tag>,\n+    ) -> EvalResult<'tcx, (Scalar<Tag>, bool)>;\n \n     fn ptr_int_arithmetic(\n         &self,\n         bin_op: mir::BinOp,\n-        left: Pointer<Borrow>,\n+        left: Pointer<Tag>,\n         right: u128,\n         signed: bool,\n-    ) -> EvalResult<'tcx, (Scalar<Borrow>, bool)>;\n+    ) -> EvalResult<'tcx, (Scalar<Tag>, bool)>;\n \n     fn ptr_eq(\n         &self,\n-        left: Scalar<Borrow>,\n-        right: Scalar<Borrow>,\n+        left: Scalar<Tag>,\n+        right: Scalar<Tag>,\n     ) -> EvalResult<'tcx, bool>;\n \n     fn pointer_offset_inbounds(\n         &self,\n-        ptr: Scalar<Borrow>,\n+        ptr: Scalar<Tag>,\n         pointee_ty: Ty<'tcx>,\n         offset: i64,\n-    ) -> EvalResult<'tcx, Scalar<Borrow>>;\n+    ) -> EvalResult<'tcx, Scalar<Tag>>;\n }\n \n impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, 'tcx> {\n     fn ptr_op(\n         &self,\n         bin_op: mir::BinOp,\n-        left: ImmTy<'tcx, Borrow>,\n-        right: ImmTy<'tcx, Borrow>,\n-    ) -> EvalResult<'tcx, (Scalar<Borrow>, bool)> {\n+        left: ImmTy<'tcx, Tag>,\n+        right: ImmTy<'tcx, Tag>,\n+    ) -> EvalResult<'tcx, (Scalar<Tag>, bool)> {\n         use rustc::mir::BinOp::*;\n \n         trace!(\"ptr_op: {:?} {:?} {:?}\", *left, bin_op, *right);\n@@ -136,8 +136,8 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n \n     fn ptr_eq(\n         &self,\n-        left: Scalar<Borrow>,\n-        right: Scalar<Borrow>,\n+        left: Scalar<Tag>,\n+        right: Scalar<Tag>,\n     ) -> EvalResult<'tcx, bool> {\n         let size = self.pointer_size();\n         Ok(match (left, right) {\n@@ -233,13 +233,13 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n     fn ptr_int_arithmetic(\n         &self,\n         bin_op: mir::BinOp,\n-        left: Pointer<Borrow>,\n+        left: Pointer<Tag>,\n         right: u128,\n         signed: bool,\n-    ) -> EvalResult<'tcx, (Scalar<Borrow>, bool)> {\n+    ) -> EvalResult<'tcx, (Scalar<Tag>, bool)> {\n         use rustc::mir::BinOp::*;\n \n-        fn map_to_primval((res, over): (Pointer<Borrow>, bool)) -> (Scalar<Borrow>, bool) {\n+        fn map_to_primval((res, over): (Pointer<Tag>, bool)) -> (Scalar<Tag>, bool) {\n             (Scalar::Ptr(res), over)\n         }\n \n@@ -327,10 +327,10 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n     /// allocation, and all the remaining integers pointers their own allocation.\n     fn pointer_offset_inbounds(\n         &self,\n-        ptr: Scalar<Borrow>,\n+        ptr: Scalar<Tag>,\n         pointee_ty: Ty<'tcx>,\n         offset: i64,\n-    ) -> EvalResult<'tcx, Scalar<Borrow>> {\n+    ) -> EvalResult<'tcx, Scalar<Tag>> {\n         // FIXME: assuming here that type size is less than `i64::max_value()`.\n         let pointee_size = self.layout_of(pointee_ty)?.size.bytes() as i64;\n         let offset = offset"}, {"sha": "250def0c7ce6b59f60e02651afba15d97e44324a", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 477, "deletions": 516, "changes": 993, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -1,127 +1,164 @@\n use std::cell::RefCell;\n use std::collections::HashSet;\n use std::rc::Rc;\n+use std::fmt;\n+use std::num::NonZeroU64;\n \n use rustc::ty::{self, layout::Size};\n-use rustc::hir::{Mutability, MutMutable, MutImmutable};\n+use rustc::hir::{MutMutable, MutImmutable};\n use rustc::mir::RetagKind;\n \n use crate::{\n     EvalResult, InterpError, MiriEvalContext, HelpersEvalContextExt, Evaluator, MutValueVisitor,\n-    MemoryKind, MiriMemoryKind, RangeMap, AllocId, Allocation, AllocationExtra,\n+    MemoryKind, MiriMemoryKind, RangeMap, Allocation, AllocationExtra,\n     Pointer, Immediate, ImmTy, PlaceTy, MPlaceTy,\n };\n \n-pub type Timestamp = u64;\n-pub type CallId = u64;\n+pub type PtrId = NonZeroU64;\n+pub type CallId = NonZeroU64;\n \n-/// Information about which kind of borrow was used to create the reference this is tagged with.\n+/// Tracking pointer provenance\n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n-pub enum Borrow {\n-    /// A unique (mutable) reference.\n-    Uniq(Timestamp),\n-    /// An aliasing reference. This is also used by raw pointers, which do not track details\n-    /// of how or when they were created, hence the timestamp is optional.\n-    /// `Shr(Some(_))` does *not* mean that the destination of this reference is frozen;\n-    /// that depends on the type! Only those parts outside of an `UnsafeCell` are actually\n-    /// frozen.\n-    Alias(Option<Timestamp>),\n+pub enum Tag {\n+    Tagged(PtrId),\n+    Untagged,\n }\n \n-impl Borrow {\n-    #[inline(always)]\n-    pub fn is_aliasing(self) -> bool {\n+impl fmt::Display for Tag {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self {\n-            Borrow::Alias(_) => true,\n-            _ => false,\n-        }\n-    }\n-\n-    #[inline(always)]\n-    pub fn is_unique(self) -> bool {\n-        match self {\n-            Borrow::Uniq(_) => true,\n-            _ => false,\n+            Tag::Tagged(id) => write!(f, \"{}\", id),\n+            Tag::Untagged => write!(f, \"<untagged>\"),\n         }\n     }\n }\n \n-impl Default for Borrow {\n-    fn default() -> Self {\n-        Borrow::Alias(None)\n-    }\n+/// Indicates which permission is granted (by this item to some pointers)\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+pub enum Permission {\n+    /// Grants unique mutable access.\n+    Unique,\n+    /// Grants shared mutable access.\n+    SharedReadWrite,\n+    /// Greants shared read-only access.\n+    SharedReadOnly,\n }\n \n /// An item in the per-location borrow stack.\n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n-pub enum BorStackItem {\n-    /// Indicates the unique reference that may mutate.\n-    Uniq(Timestamp),\n-    /// Indicates that the location has been mutably shared. Used for raw pointers as\n-    /// well as for unfrozen shared references.\n-    Raw,\n-    /// A barrier, tracking the function it belongs to by its index on the call stack.\n-    FnBarrier(CallId)\n+pub struct Item {\n+    /// The permission this item grants.\n+    perm: Permission,\n+    /// The pointers the permission is granted to.\n+    tag: Tag,\n+    /// An optional protector, ensuring the item cannot get popped until `CallId` is over.\n+    protector: Option<CallId>,\n+}\n+\n+impl fmt::Display for Item {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"[{:?} for {}\", self.perm, self.tag)?;\n+        if let Some(call) = self.protector {\n+            write!(f, \" (call {})\", call)?;\n+        }\n+        write!(f, \"]\")?;\n+        Ok(())\n+    }\n }\n \n /// Extra per-location state.\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub struct Stack {\n-    /// Used as the stack; never empty.\n-    borrows: Vec<BorStackItem>,\n-    /// A virtual frozen \"item\" on top of the stack.\n-    frozen_since: Option<Timestamp>,\n+    /// Used *mostly* as a stack; never empty.\n+    /// We sometimes push into the middle but never remove from the middle.\n+    /// The same tag may occur multiple times, e.g. from a two-phase borrow.\n+    /// Invariants:\n+    /// * Above a `SharedReadOnly` there can only be more `SharedReadOnly`.\n+    borrows: Vec<Item>,\n }\n \n-impl Stack {\n-    #[inline(always)]\n-    pub fn is_frozen(&self) -> bool {\n-        self.frozen_since.is_some()\n-    }\n+\n+/// Extra per-allocation state.\n+#[derive(Clone, Debug)]\n+pub struct Stacks {\n+    // Even reading memory can have effects on the stack, so we need a `RefCell` here.\n+    stacks: RefCell<RangeMap<Stack>>,\n+    // Pointer to global state\n+    global: MemoryState,\n }\n \n-/// Indicates which kind of reference is being used.\n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n-pub enum RefKind {\n-    /// `&mut`.\n-    Unique,\n-    /// `&` without interior mutability.\n-    Frozen,\n-    /// `*` (raw pointer) or `&` to `UnsafeCell`.\n-    Raw,\n+/// Extra global state, available to the memory access hooks.\n+#[derive(Debug)]\n+pub struct GlobalState {\n+    next_ptr_id: PtrId,\n+    next_call_id: CallId,\n+    active_calls: HashSet<CallId>,\n }\n+pub type MemoryState = Rc<RefCell<GlobalState>>;\n \n /// Indicates which kind of access is being performed.\n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n pub enum AccessKind {\n     Read,\n     Write,\n-    Dealloc,\n }\n \n-/// Extra global state in the memory, available to the memory access hooks.\n-#[derive(Debug)]\n-pub struct BarrierTracking {\n-    next_id: CallId,\n-    active_calls: HashSet<CallId>,\n+impl fmt::Display for AccessKind {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match self {\n+            AccessKind::Read => write!(f, \"read\"),\n+            AccessKind::Write => write!(f, \"write\"),\n+        }\n+    }\n+}\n+\n+/// Indicates which kind of reference is being created.\n+/// Used by high-level `reborrow` to compute which permissions to grant to the\n+/// new pointer.\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+pub enum RefKind {\n+    /// `&mut` and `Box`.\n+    Unique,\n+    /// `&` with or without interior mutability.\n+    Shared,\n+    /// `*mut`/`*const` (raw pointers).\n+    Raw { mutable: bool },\n+}\n+\n+impl fmt::Display for RefKind {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match self {\n+            RefKind::Unique => write!(f, \"unique\"),\n+            RefKind::Shared => write!(f, \"shared\"),\n+            RefKind::Raw { mutable: true } => write!(f, \"raw (mutable)\"),\n+            RefKind::Raw { mutable: false } => write!(f, \"raw (constant)\"),\n+        }\n+    }\n }\n-pub type MemoryState = Rc<RefCell<BarrierTracking>>;\n \n-impl Default for BarrierTracking {\n+/// Utilities for initialization and ID generation\n+impl Default for GlobalState {\n     fn default() -> Self {\n-        BarrierTracking {\n-            next_id: 0,\n+        GlobalState {\n+            next_ptr_id: NonZeroU64::new(1).unwrap(),\n+            next_call_id: NonZeroU64::new(1).unwrap(),\n             active_calls: HashSet::default(),\n         }\n     }\n }\n \n-impl BarrierTracking {\n+impl GlobalState {\n+    pub fn new_ptr(&mut self) -> PtrId {\n+        let id = self.next_ptr_id;\n+        self.next_ptr_id = NonZeroU64::new(id.get() + 1).unwrap();\n+        id\n+    }\n+\n     pub fn new_call(&mut self) -> CallId {\n-        let id = self.next_id;\n+        let id = self.next_call_id;\n         trace!(\"new_call: Assigning ID {}\", id);\n         self.active_calls.insert(id);\n-        self.next_id += 1;\n+        self.next_call_id = NonZeroU64::new(id.get() + 1).unwrap();\n         id\n     }\n \n@@ -134,441 +171,442 @@ impl BarrierTracking {\n     }\n }\n \n-/// Extra global machine state.\n-#[derive(Clone, Debug)]\n-pub struct State {\n-    clock: Timestamp\n-}\n+// # Stacked Borrows Core Begin\n \n-impl Default for State {\n-    fn default() -> Self {\n-        State { clock: 0 }\n+/// We need to make at least the following things true:\n+///\n+/// U1: After creating a `Uniq`, it is at the top.\n+/// U2: If the top is `Uniq`, accesses must be through that `Uniq` or remove it it.\n+/// U3: If an access happens with a `Uniq`, it requires the `Uniq` to be in the stack.\n+///\n+/// F1: After creating a `&`, the parts outside `UnsafeCell` have our `SharedReadOnly` on top.\n+/// F2: If a write access happens, it pops the `SharedReadOnly`.  This has three pieces:\n+///     F2a: If a write happens granted by an item below our `SharedReadOnly`, the `SharedReadOnly`\n+///          gets popped.\n+///     F2b: No `SharedReadWrite` or `Unique` will ever be added on top of our `SharedReadOnly`.\n+/// F3: If an access happens with an `&` outside `UnsafeCell`,\n+///     it requires the `SharedReadOnly` to still be in the stack.\n+\n+impl Default for Tag {\n+    #[inline(always)]\n+    fn default() -> Tag {\n+        Tag::Untagged\n     }\n }\n \n-impl State {\n-    fn increment_clock(&mut self) -> Timestamp {\n-        let val = self.clock;\n-        self.clock = val + 1;\n-        val\n+/// Core relations on `Permission` define which accesses are allowed:\n+/// On every access, we try to find a *granting* item, and then we remove all\n+/// *incompatible* items above it.\n+impl Permission {\n+    /// This defines for a given permission, whether it permits the given kind of access.\n+    fn grants(self, access: AccessKind) -> bool {\n+        match (self, access) {\n+            // Unique and SharedReadWrite allow any kind of access.\n+            (Permission::Unique, _) |\n+            (Permission::SharedReadWrite, _) =>\n+                true,\n+            // SharedReadOnly only permits read access.\n+            (Permission::SharedReadOnly, AccessKind::Read) =>\n+                true,\n+            (Permission::SharedReadOnly, AccessKind::Write) =>\n+                false,\n+        }\n     }\n-}\n \n-/// Extra per-allocation state.\n-#[derive(Clone, Debug)]\n-pub struct Stacks {\n-    // Even reading memory can have effects on the stack, so we need a `RefCell` here.\n-    stacks: RefCell<RangeMap<Stack>>,\n-    barrier_tracking: MemoryState,\n+    /// This defines for a given permission, which other permissions it can tolerate \"above\" itself\n+    /// for which kinds of accesses.\n+    /// If true, then `other` is allowed to remain on top of `self` when `access` happens.\n+    fn compatible_with(self, access: AccessKind, other: Permission) -> bool {\n+        use self::Permission::*;\n+\n+        match (self, access, other) {\n+            // Some cases are impossible.\n+            (SharedReadOnly, _, SharedReadWrite) |\n+            (SharedReadOnly, _, Unique) =>\n+                bug!(\"There can never be a SharedReadWrite or a Unique on top of a SharedReadOnly\"),\n+            // When `other` is `SharedReadOnly`, that is NEVER compatible with\n+            // write accesses.\n+            // This makes sure read-only pointers become invalid on write accesses (ensures F2a).\n+            (_, AccessKind::Write, SharedReadOnly) =>\n+                false,\n+            // When `other` is `Unique`, that is compatible with nothing.\n+            // This makes sure unique pointers become invalid on incompatible accesses (ensures U2).\n+            (_, _, Unique) =>\n+                false,\n+            // When we are unique and this is a write/dealloc, we tolerate nothing.\n+            // This makes sure we re-assert uniqueness (\"being on top\") on write accesses.\n+            // (This is particularily important such that when a new mutable ref gets created, it gets\n+            // pushed onto the right item -- this behaves like a write and we assert uniqueness of the\n+            // pointer from which this comes, *if* it was a unique pointer.)\n+            (Unique, AccessKind::Write, _) =>\n+                false,\n+            // `SharedReadWrite` items can tolerate any other akin items for any kind of access.\n+            (SharedReadWrite, _, SharedReadWrite) =>\n+                true,\n+            // Any item can tolerate read accesses for shared items.\n+            // This includes unique items!  Reads from unique pointers do not invalidate\n+            // other pointers.\n+            (_, AccessKind::Read, SharedReadWrite) |\n+            (_, AccessKind::Read, SharedReadOnly) =>\n+                true,\n+            // That's it.\n+        }\n+    }\n }\n \n-/// Core per-location operations: deref, access, create.\n-/// We need to make at least the following things true:\n-///\n-/// U1: After creating a `Uniq`, it is at the top (and unfrozen).\n-/// U2: If the top is `Uniq` (and unfrozen), accesses must be through that `Uniq` or pop it.\n-/// U3: If an access (deref sufficient?) happens with a `Uniq`, it requires the `Uniq` to be in the stack.\n-///\n-/// F1: After creating a `&`, the parts outside `UnsafeCell` are frozen.\n-/// F2: If a write access happens, it unfreezes.\n-/// F3: If an access (well, a deref) happens with an `&` outside `UnsafeCell`,\n-///     it requires the location to still be frozen.\n+/// Core per-location operations: access, dealloc, reborrow.\n impl<'tcx> Stack {\n-    /// Deref `bor`: check if the location is frozen and the tag in the stack.\n-    /// This dos *not* constitute an access! \"Deref\" refers to the `*` operator\n-    /// in Rust, and includs cases like `&*x` or `(*x).foo` where no or only part\n-    /// of the memory actually gets accessed. Also we cannot know if we are\n-    /// going to read or write.\n-    /// Returns the index of the item we matched, `None` if it was the frozen one.\n-    /// `kind` indicates which kind of reference is being dereferenced.\n-    fn deref(\n-        &self,\n-        bor: Borrow,\n-        kind: RefKind,\n-    ) -> Result<Option<usize>, String> {\n-        // Exclude unique ref with frozen tag.\n-        if let (RefKind::Unique, Borrow::Alias(Some(_))) = (kind, bor) {\n-            return Err(format!(\"encountered mutable reference with frozen tag ({:?})\", bor));\n-        }\n-        // Checks related to freezing.\n-        match bor {\n-            Borrow::Alias(Some(bor_t)) if kind == RefKind::Frozen => {\n-                // We need the location to be frozen. This ensures F3.\n-                let frozen = self.frozen_since.map_or(false, |itm_t| itm_t <= bor_t);\n-                return if frozen { Ok(None) } else {\n-                    Err(format!(\"location is not frozen long enough\"))\n+    /// Find the item granting the given kind of access to the given tag, and where that item is in the stack.\n+    fn find_granting(&self, access: AccessKind, tag: Tag) -> Option<(usize, Permission)> {\n+        self.borrows.iter()\n+            .enumerate() // we also need to know *where* in the stack\n+            .rev() // search top-to-bottom\n+            // Return permission of first item that grants access.\n+            // We require a permission with the right tag, ensuring U3 and F3.\n+            .find_map(|(idx, item)|\n+                if item.perm.grants(access) && tag == item.tag {\n+                    Some((idx, item.perm))\n+                } else {\n+                    None\n                 }\n-            }\n-            Borrow::Alias(_) if self.frozen_since.is_some() => {\n-                // Shared deref to frozen location; looking good.\n-                return Ok(None)\n-            }\n-            // Not sufficient; go on looking.\n-            _ => {}\n-        }\n-        // If we got here, we have to look for our item in the stack.\n-        for (idx, &itm) in self.borrows.iter().enumerate().rev() {\n-            match (itm, bor) {\n-                (BorStackItem::Uniq(itm_t), Borrow::Uniq(bor_t)) if itm_t == bor_t => {\n-                    // Found matching unique item. This satisfies U3.\n-                    return Ok(Some(idx))\n-                }\n-                (BorStackItem::Raw, Borrow::Alias(_)) => {\n-                    // Found matching aliasing/raw item.\n-                    return Ok(Some(idx))\n+            )\n+    }\n+\n+    /// Test if a memory `access` using pointer tagged `tag` is granted.\n+    /// If yes, return the index of the item that granted it.\n+    fn access(\n+        &mut self,\n+        access: AccessKind,\n+        tag: Tag,\n+        global: &GlobalState,\n+    ) -> EvalResult<'tcx, usize> {\n+        // Two main steps: Find granting item, remove all incompatible items above.\n+\n+        // Step 1: Find granting item.\n+        let (granting_idx, granting_perm) = self.find_granting(access, tag)\n+            .ok_or_else(|| InterpError::MachineError(format!(\n+                \"no item granting {} access to tag {} found in borrow stack\",\n+                access, tag,\n+            )))?;\n+\n+        // Step 2: Remove everything incompatible above them.  Make sure we do not remove protected\n+        // items.\n+        // We do *not* maintain a stack discipline here.  We could, in principle, decide to only\n+        // keep the items immediately above `granting_idx` that are compatible, and then pop the rest.\n+        // However, that kills off entire \"branches\" of pointer derivation too easily:\n+        // in `let raw = &mut *x as *mut _; let _val = *x;`, the second statement would pop the `Unique`\n+        // from the reborrow of the first statement, and subsequently also pop the `SharedReadWrite` for `raw`.\n+        // This pattern occurs a lot in the standard library: create a raw pointer, then also create a shared\n+        // reference and use that.\n+        {\n+            // Implemented with indices because there does not seem to be a nice iterator and range-based\n+            // API for this.\n+            let mut cur = granting_idx + 1;\n+            while let Some(item) = self.borrows.get(cur) {\n+                if granting_perm.compatible_with(access, item.perm) {\n+                    // Keep this, check next.\n+                    cur += 1;\n+                } else {\n+                    // Aha! This is a bad one, remove it, and make sure it is not protected.\n+                    let item = self.borrows.remove(cur);\n+                    if let Some(call) = item.protector {\n+                        if global.is_active(call) {\n+                            return err!(MachineError(format!(\n+                                \"not granting {} access to tag {} because incompatible item {} is protected\",\n+                                access, tag, item\n+                            )));\n+                        }\n+                    }\n+                    trace!(\"access: removing item {}\", item);\n                 }\n-                // Go on looking. We ignore barriers! When an `&mut` and an `&` alias,\n-                // dereferencing the `&` is still possible (to reborrow), but doing\n-                // an access is not.\n-                _ => {}\n             }\n         }\n-        // If we got here, we did not find our item. We have to error to satisfy U3.\n-        Err(format!(\"Borrow being dereferenced ({:?}) does not exist on the borrow stack\", bor))\n+\n+        // Done.\n+        return Ok(granting_idx);\n     }\n \n-    /// Performs an actual memory access using `bor`. We do not know any types here\n-    /// or whether things should be frozen, but we *do* know if this is reading\n-    /// or writing.\n-    fn access(\n+    /// Deallocate a location: Like a write access, but also there must be no\n+    /// active protectors at all.\n+    fn dealloc(\n         &mut self,\n-        bor: Borrow,\n-        kind: AccessKind,\n-        barrier_tracking: &BarrierTracking,\n+        tag: Tag,\n+        global: &GlobalState,\n     ) -> EvalResult<'tcx> {\n-        // Check if we can match the frozen \"item\".\n-        // Not possible on writes!\n-        if self.is_frozen() {\n-            if kind == AccessKind::Read {\n-                // When we are frozen, we just accept all reads. No harm in this.\n-                // The deref already checked that `Uniq` items are in the stack, and that\n-                // the location is frozen if it should be.\n-                return Ok(());\n-            }\n-            trace!(\"access: unfreezing\");\n-        }\n-        // Unfreeze on writes. This ensures F2.\n-        self.frozen_since = None;\n-        // Pop the stack until we have something matching.\n-        while let Some(&itm) = self.borrows.last() {\n-            match (itm, bor) {\n-                (BorStackItem::FnBarrier(call), _) if barrier_tracking.is_active(call) => {\n+        // Step 1: Find granting item.\n+        self.find_granting(AccessKind::Write, tag)\n+            .ok_or_else(|| InterpError::MachineError(format!(\n+                \"no item granting write access for deallocation to tag {} found in borrow stack\",\n+                tag,\n+            )))?;\n+\n+        // We must make sure there are no protected items remaining on the stack.\n+        // Also clear the stack, no more accesses are possible.\n+        for item in self.borrows.drain(..) {\n+            if let Some(call) = item.protector {\n+                if global.is_active(call) {\n                     return err!(MachineError(format!(\n-                        \"stopping looking for borrow being accessed ({:?}) because of barrier ({})\",\n-                        bor, call\n+                        \"deallocating with active protector ({})\", call\n                     )))\n                 }\n-                (BorStackItem::Uniq(itm_t), Borrow::Uniq(bor_t)) if itm_t == bor_t => {\n-                    // Found matching unique item. Continue after the match.\n-                }\n-                (BorStackItem::Raw, _) if kind == AccessKind::Read => {\n-                    // When reading, everything can use a raw item!\n-                    // We do not want to do this when writing: Writing to an `&mut`\n-                    // should reaffirm its exclusivity (i.e., make sure it is\n-                    // on top of the stack). Continue after the match.\n-                }\n-                (BorStackItem::Raw, Borrow::Alias(_)) => {\n-                    // Found matching raw item. Continue after the match.\n-                }\n-                _ => {\n-                    // Pop this, go on. This ensures U2.\n-                    let itm = self.borrows.pop().unwrap();\n-                    trace!(\"access: Popping {:?}\", itm);\n-                    continue\n-                }\n-            }\n-            // If we got here, we found a matching item. Congratulations!\n-            // However, we are not done yet: If this access is deallocating, we must make sure\n-            // there are no active barriers remaining on the stack.\n-            if kind == AccessKind::Dealloc {\n-                for &itm in self.borrows.iter().rev() {\n-                    match itm {\n-                        BorStackItem::FnBarrier(call) if barrier_tracking.is_active(call) => {\n-                            return err!(MachineError(format!(\n-                                \"deallocating with active barrier ({})\", call\n-                            )))\n-                        }\n-                        _ => {},\n-                    }\n-                }\n             }\n-            // Now we are done.\n-            return Ok(())\n         }\n-        // If we got here, we did not find our item.\n-        err!(MachineError(format!(\n-            \"borrow being accessed ({:?}) does not exist on the borrow stack\",\n-            bor\n-        )))\n+\n+        Ok(())\n     }\n \n-    /// Initiate `bor`; mostly this means pushing.\n-    /// This operation cannot fail; it is up to the caller to ensure that the precondition\n-    /// is met: We cannot push `Uniq` onto frozen stacks.\n-    /// `kind` indicates which kind of reference is being created.\n-    fn create(&mut self, bor: Borrow, kind: RefKind) {\n-        // When creating a frozen reference, freeze. This ensures F1.\n-        // We also do *not* push anything else to the stack, making sure that no nother kind\n-        // of access (like writing through raw pointers) is permitted.\n-        if kind == RefKind::Frozen {\n-            let bor_t = match bor {\n-                Borrow::Alias(Some(t)) => t,\n-                _ => bug!(\"Creating illegal borrow {:?} for frozen ref\", bor),\n-            };\n-            // It is possible that we already are frozen (e.g., if we just pushed a barrier,\n-            // the redundancy check would not have kicked in).\n-            match self.frozen_since {\n-                Some(loc_t) => assert!(\n-                    loc_t <= bor_t,\n-                    \"trying to freeze location for longer than it was already frozen\"\n-                ),\n-                None => {\n-                    trace!(\"create: Freezing\");\n-                    self.frozen_since = Some(bor_t);\n+    /// `reborrow` helper function: test that the stack invariants are still maintained.\n+    fn test_invariants(&self) {\n+        let mut saw_shared_read_only = false;\n+        for item in self.borrows.iter() {\n+            match item.perm {\n+                Permission::SharedReadOnly => {\n+                    saw_shared_read_only = true;\n+                }\n+                // Otherwise, if we saw one before, that's a bug.\n+                perm if saw_shared_read_only => {\n+                    bug!(\"Found {:?} on top of a SharedReadOnly!\", perm);\n                 }\n+                _ => {}\n             }\n-            return;\n         }\n-        assert!(\n-            self.frozen_since.is_none(),\n-            \"trying to create non-frozen reference to frozen location\"\n-        );\n-\n-        // Push new item to the stack.\n-        let itm = match bor {\n-            Borrow::Uniq(t) => BorStackItem::Uniq(t),\n-            Borrow::Alias(_) => BorStackItem::Raw,\n+    }\n+\n+    /// Derived a new pointer from one with the given tag.\n+    /// `weak` controls whether this is a weak reborrow: weak reborrows do not act as\n+    /// accesses, and they add the new item directly on top of the one it is derived\n+    /// from instead of all the way at the top of the stack.\n+    fn reborrow(\n+        &mut self,\n+        derived_from: Tag,\n+        weak: bool,\n+        new: Item,\n+        global: &GlobalState,\n+    ) -> EvalResult<'tcx> {\n+        // Figure out which access `perm` corresponds to.\n+        let access = if new.perm.grants(AccessKind::Write) {\n+            AccessKind::Write\n+        } else {\n+            AccessKind::Read\n         };\n-        if *self.borrows.last().unwrap() == itm {\n-            // This is just an optimization, no functional change: Avoid stacking\n-            // multiple `Shr` on top of each other.\n-            assert!(bor.is_aliasing());\n-            trace!(\"create: sharing a shared location is a NOP\");\n+        // Now we figure out which item grants our parent (`derived_from`) this kind of access.\n+        // We use that to determine where to put the new item.\n+        let (derived_from_idx, _) = self.find_granting(access, derived_from)\n+            .ok_or_else(|| InterpError::MachineError(format!(\n+                \"no item to reborrow for {:?} from tag {} found in borrow stack\", new.perm, derived_from,\n+            )))?;\n+\n+        // Compute where to put the new item.\n+        // Either way, we ensure that we insert the new item in a way that between\n+        // `derived_from` and the new one, there are only items *compatible with* `derived_from`.\n+        let new_idx = if weak {\n+            // A very liberal reborrow because the new pointer does not expect any kind of aliasing guarantee.\n+            // Just insert new permission as child of old permission, and maintain everything else.\n+            // This inserts \"as far down as possible\", which is good because it makes this pointer as\n+            // long-lived as possible *and* we want all the items that are incompatible with this\n+            // to actually get removed from the stack.  If we pushed a `SharedReadWrite` on top of\n+            // a `SharedReadOnly`, we'd violate the invariant that `SaredReadOnly` are at the top\n+            // and we'd allow write access without invalidating frozen shared references!\n+            // This ensures F2b for `SharedReadWrite` by adding the new item below any\n+            // potentially existing `SharedReadOnly`.\n+            derived_from_idx + 1\n         } else {\n-            // This ensures U1.\n-            trace!(\"create: pushing {:?}\", itm);\n-            self.borrows.push(itm);\n-        }\n-    }\n+            // A \"safe\" reborrow for a pointer that actually expects some aliasing guarantees.\n+            // Here, creating a reference actually counts as an access, and pops incompatible\n+            // stuff off the stack.\n+            // This ensures F2b for `Unique`, by removing offending `SharedReadOnly`.\n+            let check_idx = self.access(access, derived_from, global)?;\n+            assert_eq!(check_idx, derived_from_idx, \"somehow we saw different items??\");\n+\n+            // We insert \"as far up as possible\": We know only compatible items are remaining\n+            // on top of `derived_from`, and we want the new item at the top so that we\n+            // get the strongest possible guarantees.\n+            // This ensures U1 and F1.\n+            self.borrows.len()\n+        };\n \n-    /// Adds a barrier.\n-    fn barrier(&mut self, call: CallId) {\n-        let itm = BorStackItem::FnBarrier(call);\n-        if *self.borrows.last().unwrap() == itm {\n-            // This is just an optimization, no functional change: Avoid stacking\n-            // multiple identical barriers on top of each other.\n-            // This can happen when a function receives several shared references\n-            // that overlap.\n-            trace!(\"barrier: avoiding redundant extra barrier\");\n+        // Put the new item there. As an optimization, deduplicate if it is equal to one of its new neighbors.\n+        if self.borrows[new_idx-1] == new || self.borrows.get(new_idx) == Some(&new) {\n+            // Optimization applies, done.\n+            trace!(\"reborrow: avoiding adding redundant item {}\", new);\n         } else {\n-            trace!(\"barrier: pushing barrier for call {}\", call);\n-            self.borrows.push(itm);\n+            trace!(\"reborrow: adding item {}\", new);\n+            self.borrows.insert(new_idx, new);\n+        }\n+\n+        // Make sure that after all this, the stack's invariant is still maintained.\n+        if cfg!(debug_assertions) {\n+            self.test_invariants();\n         }\n+\n+        Ok(())\n     }\n }\n+// # Stacked Borrows Core End\n \n-/// Higher-level per-location operations: deref, access, reborrow.\n+/// Map per-stack operations to higher-level per-location-range operations.\n impl<'tcx> Stacks {\n-    /// Checks that this stack is fine with being dereferenced.\n-    fn deref(\n-        &self,\n-        ptr: Pointer<Borrow>,\n+    /// Creates new stack with initial tag.\n+    pub(crate) fn new(\n         size: Size,\n-        kind: RefKind,\n-    ) -> EvalResult<'tcx> {\n-        trace!(\"deref for tag {:?} as {:?}: {:?}, size {}\",\n-            ptr.tag, kind, ptr, size.bytes());\n-        let stacks = self.stacks.borrow();\n-        for stack in stacks.iter(ptr.offset, size) {\n-            stack.deref(ptr.tag, kind).map_err(InterpError::MachineError)?;\n+        tag: Tag,\n+        extra: MemoryState,\n+    ) -> Self {\n+        let item = Item { perm: Permission::Unique, tag, protector: None };\n+        let stack = Stack {\n+            borrows: vec![item],\n+        };\n+        Stacks {\n+            stacks: RefCell::new(RangeMap::new(size, stack)),\n+            global: extra,\n         }\n-        Ok(())\n     }\n \n-    /// `ptr` got used, reflect that in the stack.\n-    fn access(\n+    /// Call `f` on every stack in the range.\n+    fn for_each(\n         &self,\n-        ptr: Pointer<Borrow>,\n+        ptr: Pointer<Tag>,\n         size: Size,\n-        kind: AccessKind,\n+        f: impl Fn(&mut Stack, &GlobalState) -> EvalResult<'tcx>,\n     ) -> EvalResult<'tcx> {\n-        trace!(\"{:?} access of tag {:?}: {:?}, size {}\", kind, ptr.tag, ptr, size.bytes());\n-        // Even reads can have a side-effect, by invalidating other references.\n-        // This is fundamentally necessary since `&mut` asserts that there\n-        // are no accesses through other references, not even reads.\n-        let barrier_tracking = self.barrier_tracking.borrow();\n+        let global = self.global.borrow();\n         let mut stacks = self.stacks.borrow_mut();\n         for stack in stacks.iter_mut(ptr.offset, size) {\n-            stack.access(ptr.tag, kind, &*barrier_tracking)?;\n+            f(stack, &*global)?;\n         }\n         Ok(())\n     }\n+}\n \n-    /// Reborrow the given pointer to the new tag for the given kind of reference.\n-    /// This works on `&self` because we might encounter references to constant memory.\n-    fn reborrow(\n-        &self,\n-        ptr: Pointer<Borrow>,\n+/// Glue code to connect with Miri Machine Hooks\n+impl Stacks {\n+    pub fn new_allocation(\n         size: Size,\n-        mut barrier: Option<CallId>,\n-        new_bor: Borrow,\n-        new_kind: RefKind,\n-    ) -> EvalResult<'tcx> {\n-        assert_eq!(new_bor.is_unique(), new_kind == RefKind::Unique);\n-        trace!(\n-            \"reborrow for tag {:?} to {:?} as {:?}: {:?}, size {}\",\n-            ptr.tag, new_bor, new_kind, ptr, size.bytes(),\n-        );\n-        if new_kind == RefKind::Raw {\n-            // No barrier for raw, including `&UnsafeCell`. They can rightfully alias with `&mut`.\n-            // FIXME: This means that the `dereferencable` attribute on non-frozen shared references\n-            // is incorrect! They are dereferencable when the function is called, but might become\n-            // non-dereferencable during the course of execution.\n-            // Also see [1], [2].\n-            //\n-            // [1]: <https://internals.rust-lang.org/t/\n-            //       is-it-possible-to-be-memory-safe-with-deallocated-self/8457/8>,\n-            // [2]: <https://lists.llvm.org/pipermail/llvm-dev/2018-July/124555.html>\n-            barrier = None;\n-        }\n-        let barrier_tracking = self.barrier_tracking.borrow();\n-        let mut stacks = self.stacks.borrow_mut();\n-        for stack in stacks.iter_mut(ptr.offset, size) {\n-            // Access source `ptr`, create new ref.\n-            let ptr_idx = stack.deref(ptr.tag, new_kind).map_err(InterpError::MachineError)?;\n-            // If we can deref the new tag already, and if that tag lives higher on\n-            // the stack than the one we come from, just use that.\n-            // That is, we check if `new_bor` *already* is \"derived from\" `ptr.tag`.\n-            // This also checks frozenness, if required.\n-            let bor_redundant = barrier.is_none() &&\n-                match (ptr_idx, stack.deref(new_bor, new_kind)) {\n-                    // If the new borrow works with the frozen item, or else if it lives\n-                    // above the old one in the stack, our job here is done.\n-                    (_, Ok(None)) => true,\n-                    (Some(ptr_idx), Ok(Some(new_idx))) if new_idx >= ptr_idx => true,\n-                    // Otherwise, we need to create a new borrow.\n-                    _ => false,\n-                };\n-            if bor_redundant {\n-                assert!(new_bor.is_aliasing(), \"a unique reborrow can never be redundant\");\n-                trace!(\"reborrow is redundant\");\n-                continue;\n+        extra: &MemoryState,\n+        kind: MemoryKind<MiriMemoryKind>,\n+    ) -> (Self, Tag) {\n+        let tag = match kind {\n+            MemoryKind::Stack => {\n+                // New unique borrow. This `Uniq` is not accessible by the program,\n+                // so it will only ever be used when using the local directly (i.e.,\n+                // not through a pointer). That is, whenever we directly use a local, this will pop\n+                // everything else off the stack, invalidating all previous pointers,\n+                // and in particular, *all* raw pointers. This subsumes the explicit\n+                // `reset` which the blog post [1] says to perform when accessing a local.\n+                //\n+                // [1]: <https://www.ralfj.de/blog/2018/08/07/stacked-borrows.html>\n+                Tag::Tagged(extra.borrow_mut().new_ptr())\n             }\n-            // We need to do some actual work.\n-            let access_kind = if new_kind == RefKind::Unique {\n-                AccessKind::Write\n-            } else {\n-                AccessKind::Read\n-            };\n-            stack.access(ptr.tag, access_kind, &*barrier_tracking)?;\n-            if let Some(call) = barrier {\n-                stack.barrier(call);\n+            _ => {\n+                Tag::Untagged\n             }\n-            stack.create(new_bor, new_kind);\n-        }\n-        Ok(())\n-    }\n-}\n-\n-/// Hooks and glue.\n-impl AllocationExtra<Borrow, MemoryState> for Stacks {\n-    #[inline(always)]\n-    fn memory_allocated<'tcx>(size: Size, extra: &MemoryState) -> Self {\n-        let stack = Stack {\n-            borrows: vec![BorStackItem::Raw],\n-            frozen_since: None,\n         };\n-        Stacks {\n-            stacks: RefCell::new(RangeMap::new(size, stack)),\n-            barrier_tracking: Rc::clone(extra),\n-        }\n+        let stack = Stacks::new(size, tag, Rc::clone(extra));\n+        (stack, tag)\n     }\n+}\n \n+impl AllocationExtra<Tag> for Stacks {\n     #[inline(always)]\n     fn memory_read<'tcx>(\n-        alloc: &Allocation<Borrow, Stacks>,\n-        ptr: Pointer<Borrow>,\n+        alloc: &Allocation<Tag, Stacks>,\n+        ptr: Pointer<Tag>,\n         size: Size,\n     ) -> EvalResult<'tcx> {\n-        alloc.extra.access(ptr, size, AccessKind::Read)\n+        trace!(\"read access with tag {}: {:?}, size {}\", ptr.tag, ptr, size.bytes());\n+        alloc.extra.for_each(ptr, size, |stack, global| {\n+            stack.access(AccessKind::Read, ptr.tag, global)?;\n+            Ok(())\n+        })\n     }\n \n     #[inline(always)]\n     fn memory_written<'tcx>(\n-        alloc: &mut Allocation<Borrow, Stacks>,\n-        ptr: Pointer<Borrow>,\n+        alloc: &mut Allocation<Tag, Stacks>,\n+        ptr: Pointer<Tag>,\n         size: Size,\n     ) -> EvalResult<'tcx> {\n-        alloc.extra.access(ptr, size, AccessKind::Write)\n+        trace!(\"write access with tag {}: {:?}, size {}\", ptr.tag, ptr, size.bytes());\n+        alloc.extra.for_each(ptr, size, |stack, global| {\n+            stack.access(AccessKind::Write, ptr.tag, global)?;\n+            Ok(())\n+        })\n     }\n \n     #[inline(always)]\n     fn memory_deallocated<'tcx>(\n-        alloc: &mut Allocation<Borrow, Stacks>,\n-        ptr: Pointer<Borrow>,\n+        alloc: &mut Allocation<Tag, Stacks>,\n+        ptr: Pointer<Tag>,\n         size: Size,\n     ) -> EvalResult<'tcx> {\n-        alloc.extra.access(ptr, size, AccessKind::Dealloc)\n-    }\n-}\n-\n-impl<'tcx> Stacks {\n-    /// Pushes the first item to the stacks.\n-    pub(crate) fn first_item(\n-        &mut self,\n-        itm: BorStackItem,\n-        size: Size\n-    ) {\n-        for stack in self.stacks.get_mut().iter_mut(Size::ZERO, size) {\n-            assert!(stack.borrows.len() == 1);\n-            assert_eq!(stack.borrows.pop().unwrap(), BorStackItem::Raw);\n-            stack.borrows.push(itm);\n-        }\n+        trace!(\"deallocation with tag {}: {:?}, size {}\", ptr.tag, ptr, size.bytes());\n+        alloc.extra.for_each(ptr, size, |stack, global| {\n+            stack.dealloc(ptr.tag, global)\n+        })\n     }\n }\n \n+/// Retagging/reborrowing.  There is some policy in here, such as which permissions\n+/// to grant for which references, when to add protectors, and how to realize two-phase\n+/// borrows in terms of the primitives above.\n impl<'a, 'mir, 'tcx> EvalContextPrivExt<'a, 'mir, 'tcx> for crate::MiriEvalContext<'a, 'mir, 'tcx> {}\n trait EvalContextPrivExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a, 'mir, 'tcx> {\n     fn reborrow(\n         &mut self,\n-        place: MPlaceTy<'tcx, Borrow>,\n+        place: MPlaceTy<'tcx, Tag>,\n         size: Size,\n-        fn_barrier: bool,\n-        new_bor: Borrow\n+        kind: RefKind,\n+        new_tag: Tag,\n+        force_weak: bool,\n+        protect: bool,\n     ) -> EvalResult<'tcx> {\n         let this = self.eval_context_mut();\n+        let protector = if protect { Some(this.frame().extra) } else { None };\n         let ptr = place.ptr.to_ptr()?;\n-        let barrier = if fn_barrier { Some(this.frame().extra) } else { None };\n-        trace!(\"reborrow: creating new reference for {:?} (pointee {}): {:?}\",\n-            ptr, place.layout.ty, new_bor);\n+        trace!(\"reborrow: {:?} reference {} derived from {} (pointee {}): {:?}, size {}\",\n+            kind, new_tag, ptr.tag, place.layout.ty, ptr, size.bytes());\n \n         // Get the allocation. It might not be mutable, so we cannot use `get_mut`.\n         let alloc = this.memory().get(ptr.alloc_id)?;\n         alloc.check_bounds(this, ptr, size)?;\n         // Update the stacks.\n-        if let Borrow::Alias(Some(_)) = new_bor {\n-            // Reference that cares about freezing. We need a frozen-sensitive reborrow.\n-            this.visit_freeze_sensitive(place, size, |cur_ptr, size, frozen| {\n-                let kind = if frozen { RefKind::Frozen } else { RefKind::Raw };\n-                alloc.extra.reborrow(cur_ptr, size, barrier, new_bor, kind)\n-            })?;\n-        } else {\n-            // Just treat this as one big chunk.\n-            let kind = if new_bor.is_unique() { RefKind::Unique } else { RefKind::Raw };\n-            alloc.extra.reborrow(ptr, size, barrier, new_bor, kind)?;\n-        }\n-        Ok(())\n+        // Make sure that raw pointers and mutable shared references are reborrowed \"weak\":\n+        // There could be existing unique pointers reborrowed from them that should remain valid!\n+        let perm = match kind {\n+            RefKind::Unique => Permission::Unique,\n+            RefKind::Raw { mutable: true } => Permission::SharedReadWrite,\n+            RefKind::Shared | RefKind::Raw { mutable: false } => {\n+                // Shared references and *const are a whole different kind of game, the\n+                // permission is not uniform across the entire range!\n+                // We need a frozen-sensitive reborrow.\n+                return this.visit_freeze_sensitive(place, size, |cur_ptr, size, frozen| {\n+                    // We are only ever `SharedReadOnly` inside the frozen bits.\n+                    let weak = !frozen || kind != RefKind::Shared; // `RefKind::Raw` is always weak, as is `SharedReadWrite`.\n+                    let perm = if frozen { Permission::SharedReadOnly } else { Permission::SharedReadWrite };\n+                    let item = Item { perm, tag: new_tag, protector };\n+                    alloc.extra.for_each(cur_ptr, size, |stack, global| {\n+                        stack.reborrow(cur_ptr.tag, force_weak || weak, item, global)\n+                    })\n+                });\n+            }\n+        };\n+        debug_assert_ne!(perm, Permission::SharedReadOnly, \"SharedReadOnly must be used frozen-sensitive\");\n+        let weak = perm == Permission::SharedReadWrite;\n+        let item = Item { perm, tag: new_tag, protector };\n+        alloc.extra.for_each(ptr, size, |stack, global| {\n+            stack.reborrow(ptr.tag, force_weak || weak, item, global)\n+        })\n     }\n \n     /// Retags an indidual pointer, returning the retagged version.\n     /// `mutbl` can be `None` to make this a raw pointer.\n     fn retag_reference(\n         &mut self,\n-        val: ImmTy<'tcx, Borrow>,\n-        mutbl: Option<Mutability>,\n-        fn_barrier: bool,\n+        val: ImmTy<'tcx, Tag>,\n+        kind: RefKind,\n+        protect: bool,\n         two_phase: bool,\n-    ) -> EvalResult<'tcx, Immediate<Borrow>> {\n+    ) -> EvalResult<'tcx, Immediate<Tag>> {\n         let this = self.eval_context_mut();\n         // We want a place for where the ptr *points to*, so we get one.\n         let place = this.ref_to_mplace(val)?;\n@@ -581,23 +619,22 @@ trait EvalContextPrivExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n         }\n \n         // Compute new borrow.\n-        let time = this.machine.stacked_borrows.increment_clock();\n-        let new_bor = match mutbl {\n-            Some(MutMutable) => Borrow::Uniq(time),\n-            Some(MutImmutable) => Borrow::Alias(Some(time)),\n-            None => Borrow::default(),\n+        let new_tag = match kind {\n+            RefKind::Raw { .. } => Tag::Untagged,\n+            _ => Tag::Tagged(this.memory().extra.borrow_mut().new_ptr()),\n         };\n \n         // Reborrow.\n-        this.reborrow(place, size, fn_barrier, new_bor)?;\n-        let new_place = place.with_tag(new_bor);\n+        this.reborrow(place, size, kind, new_tag, /*force_weak:*/ two_phase, protect)?;\n+        let new_place = place.replace_tag(new_tag);\n         // Handle two-phase borrows.\n         if two_phase {\n-            assert!(mutbl == Some(MutMutable), \"two-phase shared borrows make no sense\");\n-            // We immediately share it, to allow read accesses\n-            let two_phase_time = this.machine.stacked_borrows.increment_clock();\n-            let two_phase_bor = Borrow::Alias(Some(two_phase_time));\n-            this.reborrow(new_place, size, false /* fn_barrier */, two_phase_bor)?;\n+            assert!(kind == RefKind::Unique, \"two-phase shared borrows make no sense\");\n+            // Grant read access *to the parent pointer* with the old tag *derived from the new tag* (`new_place`). \n+            // This means the old pointer has multiple items in the stack now, which otherwise cannot happen\n+            // for unique references -- but in this case it precisely expresses the semantics we want.\n+            let old_tag = place.ptr.to_ptr().unwrap().tag;\n+            this.reborrow(new_place, size, RefKind::Shared, old_tag, /*force_weak:*/ false, /*protect:*/ false)?;\n         }\n \n         // Return new pointer.\n@@ -607,115 +644,39 @@ trait EvalContextPrivExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n \n impl<'a, 'mir, 'tcx> EvalContextExt<'a, 'mir, 'tcx> for crate::MiriEvalContext<'a, 'mir, 'tcx> {}\n pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a, 'mir, 'tcx> {\n-    fn tag_new_allocation(\n-        &mut self,\n-        id: AllocId,\n-        kind: MemoryKind<MiriMemoryKind>,\n-    ) -> Borrow {\n-        let this = self.eval_context_mut();\n-        let time = match kind {\n-            MemoryKind::Stack => {\n-                // New unique borrow. This `Uniq` is not accessible by the program,\n-                // so it will only ever be used when using the local directly (i.e.,\n-                // not through a pointer). That is, whenever we directly use a local, this will pop\n-                // everything else off the stack, invalidating all previous pointers,\n-                // and in particular, *all* raw pointers. This subsumes the explicit\n-                // `reset` which the blog post [1] says to perform when accessing a local.\n-                //\n-                // [1]: <https://www.ralfj.de/blog/2018/08/07/stacked-borrows.html>\n-                this.machine.stacked_borrows.increment_clock()\n-            }\n-            _ => {\n-                // Nothing to do for everything else.\n-                return Borrow::default()\n-            }\n-        };\n-        // Make this the active borrow for this allocation.\n-        let alloc = this\n-            .memory_mut()\n-            .get_mut(id)\n-            .expect(\"this is a new allocation; it must still exist\");\n-        let size = Size::from_bytes(alloc.bytes.len() as u64);\n-        alloc.extra.first_item(BorStackItem::Uniq(time), size);\n-        Borrow::Uniq(time)\n-    }\n-\n-    /// Called for value-to-place conversion. `mutability` is `None` for raw pointers.\n-    ///\n-    /// Note that this does *not* mean that all this memory will actually get accessed/referenced!\n-    /// We could be in the middle of `&(*var).1`.\n-    fn ptr_dereference(\n-        &self,\n-        place: MPlaceTy<'tcx, Borrow>,\n-        size: Size,\n-        mutability: Option<Mutability>,\n-    ) -> EvalResult<'tcx> {\n-        let this = self.eval_context_ref();\n-        trace!(\n-            \"ptr_dereference: Accessing {} reference for {:?} (pointee {})\",\n-            if let Some(mutability) = mutability {\n-                format!(\"{:?}\", mutability)\n-            } else {\n-                format!(\"raw\")\n-            },\n-            place.ptr, place.layout.ty\n-        );\n-        let ptr = place.ptr.to_ptr()?;\n-        if mutability.is_none() {\n-            // No further checks on raw derefs -- only the access itself will be checked.\n-            return Ok(());\n-        }\n-\n-        // Get the allocation\n-        let alloc = this.memory().get(ptr.alloc_id)?;\n-        alloc.check_bounds(this, ptr, size)?;\n-        // If we got here, we do some checking, *but* we leave the tag unchanged.\n-        if let Borrow::Alias(Some(_)) = ptr.tag {\n-            assert_eq!(mutability, Some(MutImmutable));\n-            // We need a frozen-sensitive check.\n-            this.visit_freeze_sensitive(place, size, |cur_ptr, size, frozen| {\n-                let kind = if frozen { RefKind::Frozen } else { RefKind::Raw };\n-                alloc.extra.deref(cur_ptr, size, kind)\n-            })?;\n-        } else {\n-            // Just treat this as one big chunk.\n-            let kind = if mutability == Some(MutMutable) { RefKind::Unique } else { RefKind::Raw };\n-            alloc.extra.deref(ptr, size, kind)?;\n-        }\n-\n-        // All is good.\n-        Ok(())\n-    }\n-\n     fn retag(\n         &mut self,\n         kind: RetagKind,\n-        place: PlaceTy<'tcx, Borrow>\n+        place: PlaceTy<'tcx, Tag>\n     ) -> EvalResult<'tcx> {\n         let this = self.eval_context_mut();\n-        // Determine mutability and whether to add a barrier.\n+        // Determine mutability and whether to add a protector.\n         // Cannot use `builtin_deref` because that reports *immutable* for `Box`,\n         // making it useless.\n-        fn qualify(ty: ty::Ty<'_>, kind: RetagKind) -> Option<(Option<Mutability>, bool)> {\n+        fn qualify(ty: ty::Ty<'_>, kind: RetagKind) -> Option<(RefKind, bool)> {\n             match ty.sty {\n                 // References are simple.\n-                ty::Ref(_, _, mutbl) => Some((Some(mutbl), kind == RetagKind::FnEntry)),\n+                ty::Ref(_, _, MutMutable) =>\n+                    Some((RefKind::Unique, kind == RetagKind::FnEntry)),\n+                ty::Ref(_, _, MutImmutable) =>\n+                    Some((RefKind::Shared, kind == RetagKind::FnEntry)),\n                 // Raw pointers need to be enabled.\n-                ty::RawPtr(..) if kind == RetagKind::Raw => Some((None, false)),\n-                // Boxes do not get a barrier: barriers reflect that references outlive the call\n+                ty::RawPtr(tym) if kind == RetagKind::Raw =>\n+                    Some((RefKind::Raw { mutable: tym.mutbl == MutMutable }, false)),\n+                // Boxes do not get a protector: protectors reflect that references outlive the call\n                 // they were passed in to; that's just not the case for boxes.\n-                ty::Adt(..) if ty.is_box() => Some((Some(MutMutable), false)),\n+                ty::Adt(..) if ty.is_box() => Some((RefKind::Unique, false)),\n                 _ => None,\n             }\n         }\n \n         // We need a visitor to visit all references. However, that requires\n         // a `MemPlace`, so we have a fast path for reference types that\n         // avoids allocating.\n-        if let Some((mutbl, barrier)) = qualify(place.layout.ty, kind) {\n+        if let Some((mutbl, protector)) = qualify(place.layout.ty, kind) {\n             // Fast path.\n             let val = this.read_immediate(this.place_to_op(place)?)?;\n-            let val = this.retag_reference(val, mutbl, barrier, kind == RetagKind::TwoPhase)?;\n+            let val = this.retag_reference(val, mutbl, protector, kind == RetagKind::TwoPhase)?;\n             this.write_immediate(val, place)?;\n             return Ok(());\n         }\n@@ -734,24 +695,24 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n         for\n             RetagVisitor<'ecx, 'a, 'mir, 'tcx>\n         {\n-            type V = MPlaceTy<'tcx, Borrow>;\n+            type V = MPlaceTy<'tcx, Tag>;\n \n             #[inline(always)]\n             fn ecx(&mut self) -> &mut MiriEvalContext<'a, 'mir, 'tcx> {\n                 &mut self.ecx\n             }\n \n             // Primitives of reference type, that is the one thing we are interested in.\n-            fn visit_primitive(&mut self, place: MPlaceTy<'tcx, Borrow>) -> EvalResult<'tcx>\n+            fn visit_primitive(&mut self, place: MPlaceTy<'tcx, Tag>) -> EvalResult<'tcx>\n             {\n                 // Cannot use `builtin_deref` because that reports *immutable* for `Box`,\n                 // making it useless.\n-                if let Some((mutbl, barrier)) = qualify(place.layout.ty, self.kind) {\n+                if let Some((mutbl, protector)) = qualify(place.layout.ty, self.kind) {\n                     let val = self.ecx.read_immediate(place.into())?;\n                     let val = self.ecx.retag_reference(\n                         val,\n                         mutbl,\n-                        barrier,\n+                        protector,\n                         self.kind == RetagKind::TwoPhase\n                     )?;\n                     self.ecx.write_immediate(val, place.into())?;"}, {"sha": "9346fba0dcc4b18036cc21576bbb8a98e6870231", "filename": "src/tls.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/src%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/src%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftls.rs?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -5,14 +5,14 @@ use rustc::{ty, ty::layout::HasDataLayout, mir};\n \n use crate::{\n     EvalResult, InterpError, StackPopCleanup,\n-    MPlaceTy, Scalar, Borrow,\n+    MPlaceTy, Scalar, Tag,\n };\n \n pub type TlsKey = u128;\n \n #[derive(Copy, Clone, Debug)]\n pub struct TlsEntry<'tcx> {\n-    pub(crate) data: Scalar<Borrow>, // Will eventually become a map from thread IDs to `Scalar`s, if we ever support more than one thread.\n+    pub(crate) data: Scalar<Tag>, // Will eventually become a map from thread IDs to `Scalar`s, if we ever support more than one thread.\n     pub(crate) dtor: Option<ty::Instance<'tcx>>,\n }\n \n@@ -63,7 +63,7 @@ impl<'tcx> TlsData<'tcx> {\n         }\n     }\n \n-    pub fn load_tls(&mut self, key: TlsKey) -> EvalResult<'tcx, Scalar<Borrow>> {\n+    pub fn load_tls(&mut self, key: TlsKey) -> EvalResult<'tcx, Scalar<Tag>> {\n         match self.keys.get(&key) {\n             Some(&TlsEntry { data, .. }) => {\n                 trace!(\"TLS key {} loaded: {:?}\", key, data);\n@@ -73,7 +73,7 @@ impl<'tcx> TlsData<'tcx> {\n         }\n     }\n \n-    pub fn store_tls(&mut self, key: TlsKey, new_data: Scalar<Borrow>) -> EvalResult<'tcx> {\n+    pub fn store_tls(&mut self, key: TlsKey, new_data: Scalar<Tag>) -> EvalResult<'tcx> {\n         match self.keys.get_mut(&key) {\n             Some(&mut TlsEntry { ref mut data, .. }) => {\n                 trace!(\"TLS key {} stored: {:?}\", key, new_data);\n@@ -106,7 +106,7 @@ impl<'tcx> TlsData<'tcx> {\n         &mut self,\n         key: Option<TlsKey>,\n         cx: &impl HasDataLayout,\n-    ) -> Option<(ty::Instance<'tcx>, Scalar<Borrow>, TlsKey)> {\n+    ) -> Option<(ty::Instance<'tcx>, Scalar<Tag>, TlsKey)> {\n         use std::collections::Bound::*;\n \n         let thread_local = &mut self.keys;"}, {"sha": "4a153d74ffb0b35a1eabd18ec0d6e03dfdcb1580", "filename": "tests/compile-fail/stacked_borrows/alias_through_mutation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Falias_through_mutation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Falias_through_mutation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Falias_through_mutation.rs?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -9,5 +9,5 @@ fn main() {\n     retarget(&mut target_alias, target);\n     // now `target_alias` points to the same thing as `target`\n     *target = 13;\n-    let _val = *target_alias; //~ ERROR does not exist on the borrow stack\n+    let _val = *target_alias; //~ ERROR borrow stack\n }"}, {"sha": "d047925163bd62ceef7bbb30e7da642e8a3b0208", "filename": "tests/compile-fail/stacked_borrows/aliasing_mut1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Faliasing_mut1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Faliasing_mut1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Faliasing_mut1.rs?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -1,6 +1,6 @@\n use std::mem;\n \n-pub fn safe(_x: &mut i32, _y: &mut i32) {} //~ ERROR barrier\n+pub fn safe(_x: &mut i32, _y: &mut i32) {} //~ ERROR protect\n \n fn main() {\n     let mut x = 0;"}, {"sha": "c679e01677eb5ea5be27bd9ff70d3f85b00e2beb", "filename": "tests/compile-fail/stacked_borrows/aliasing_mut2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Faliasing_mut2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Faliasing_mut2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Faliasing_mut2.rs?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -1,6 +1,6 @@\n use std::mem;\n \n-pub fn safe(_x: &i32, _y: &mut i32) {} //~ ERROR barrier\n+pub fn safe(_x: &i32, _y: &mut i32) {} //~ ERROR protect\n \n fn main() {\n     let mut x = 0;"}, {"sha": "3943e9576158cf9bd7e90a03848ef4e7160586a8", "filename": "tests/compile-fail/stacked_borrows/aliasing_mut3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Faliasing_mut3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Faliasing_mut3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Faliasing_mut3.rs?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -1,6 +1,6 @@\n use std::mem;\n \n-pub fn safe(_x: &mut i32, _y: &i32) {} //~ ERROR does not exist on the borrow stack\n+pub fn safe(_x: &mut i32, _y: &i32) {} //~ ERROR borrow stack\n \n fn main() {\n     let mut x = 0;"}, {"sha": "778935a6d0b0dcdf03595b1659f359e9c74b50e9", "filename": "tests/compile-fail/stacked_borrows/aliasing_mut4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Faliasing_mut4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Faliasing_mut4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Faliasing_mut4.rs?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -2,7 +2,7 @@ use std::mem;\n use std::cell::Cell;\n \n // Make sure &mut UnsafeCell also is exclusive\n-pub fn safe(_x: &i32, _y: &mut Cell<i32>) {} //~ ERROR barrier\n+pub fn safe(_x: &i32, _y: &mut Cell<i32>) {} //~ ERROR protect\n \n fn main() {\n     let mut x = 0;"}, {"sha": "7d7f5e24e2b0b06bc807b3a23300755ffd493e3d", "filename": "tests/compile-fail/stacked_borrows/box_exclusive_violation1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Fbox_exclusive_violation1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Fbox_exclusive_violation1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fbox_exclusive_violation1.rs?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -8,7 +8,7 @@ fn demo_mut_advanced_unique(mut our: Box<i32>) -> i32 {\n   unknown_code_2();\n \n   // We know this will return 5\n-  *our //~ ERROR does not exist on the borrow stack\n+  *our //~ ERROR borrow stack\n }\n \n // Now comes the evil context"}, {"sha": "9ff67ae354220c6e005d2f1eaf9124f92ae94d83", "filename": "tests/compile-fail/stacked_borrows/buggy_as_mut_slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_as_mut_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_as_mut_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_as_mut_slice.rs?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -13,5 +13,5 @@ fn main() {\n     let v1 = safe::as_mut_slice(&v);\n     let _v2 = safe::as_mut_slice(&v);\n     v1[1] = 5;\n-    //~^ ERROR does not exist on the borrow stack\n+    //~^ ERROR borrow stack\n }"}, {"sha": "812dd47ef1d9068fb7aa15585eaa5a4d66df7493", "filename": "tests/compile-fail/stacked_borrows/buggy_split_at_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_split_at_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_split_at_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_split_at_mut.rs?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -9,7 +9,7 @@ mod safe {\n             assert!(mid <= len);\n \n             (from_raw_parts_mut(ptr, len - mid), // BUG: should be \"mid\" instead of \"len - mid\"\n-            //~^ ERROR does not exist on the borrow stack\n+            //~^ ERROR borrow stack\n             from_raw_parts_mut(ptr.offset(mid as isize), len - mid))\n         }\n     }"}, {"sha": "49e376c0287e89810f576647125f9e70f6880333", "filename": "tests/compile-fail/stacked_borrows/deallocate_against_barrier.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Fdeallocate_against_barrier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Fdeallocate_against_barrier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fdeallocate_against_barrier.rs?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern: deallocating with active barrier\n+// error-pattern: deallocating with active protect\n \n fn inner(x: &mut i32, f: fn(&mut i32)) {\n     // `f` may mutate, but it may not deallocate!"}, {"sha": "d942d2b27b999ac6b2438b74ae242156a7aa5255", "filename": "tests/compile-fail/stacked_borrows/illegal_read1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read1.rs?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -7,7 +7,7 @@ fn main() {\n     let xref = unsafe { &mut *xraw }; // derived from raw, so using raw is still ok...\n     callee(xraw);\n     let _val = *xref; // ...but any use of raw will invalidate our ref.\n-    //~^ ERROR: does not exist on the borrow stack\n+    //~^ ERROR: borrow stack\n }\n \n fn callee(xraw: *mut i32) {"}, {"sha": "c50c88d48f8c9383c30067df4a7b0d374698908e", "filename": "tests/compile-fail/stacked_borrows/illegal_read2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read2.rs?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -7,7 +7,7 @@ fn main() {\n     let xref = unsafe { &mut *xraw }; // derived from raw, so using raw is still ok...\n     callee(xraw);\n     let _val = *xref; // ...but any use of raw will invalidate our ref.\n-    //~^ ERROR: does not exist on the borrow stack\n+    //~^ ERROR: borrow stack\n }\n \n fn callee(xraw: *mut i32) {"}, {"sha": "09fd5d534cf7d988986ade107de12b99b2894654", "filename": "tests/compile-fail/stacked_borrows/illegal_read3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read3.rs?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -15,7 +15,7 @@ fn main() {\n     callee(xref1_sneaky);\n     // ... though any use of it will invalidate our ref.\n     let _val = *xref2;\n-    //~^ ERROR: does not exist on the borrow stack\n+    //~^ ERROR: borrow stack\n }\n \n fn callee(xref1: usize) {"}, {"sha": "d7e281e3ffe5c7de1a9d94937d1b315964732245", "filename": "tests/compile-fail/stacked_borrows/illegal_read4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read4.rs?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -5,5 +5,5 @@ fn main() {\n     let xraw = xref1 as *mut _;\n     let xref2 = unsafe { &mut *xraw };\n     let _val = unsafe { *xraw }; // use the raw again, this invalidates xref2 *even* with the special read except for uniq refs\n-    let _illegal = *xref2; //~ ERROR does not exist on the borrow stack\n+    let _illegal = *xref2; //~ ERROR borrow stack\n }"}, {"sha": "d6120cd64ad0075c70a4438607312f530d626231", "filename": "tests/compile-fail/stacked_borrows/illegal_read5.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read5.rs?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -12,5 +12,5 @@ fn main() {\n     let _val = *xref; // we can even still use our mutable reference\n     mem::forget(unsafe { ptr::read(xshr) }); // but after reading through the shared ref\n     let _val = *xref; // the mutable one is dead and gone\n-    //~^ ERROR does not exist on the borrow stack\n+    //~^ ERROR borrow stack\n }"}, {"sha": "dc37814729000eca6459924be5fdbccc9f9a86a5", "filename": "tests/compile-fail/stacked_borrows/illegal_read6.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read6.rs?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -0,0 +1,8 @@\n+// Creating a shared reference does not leak the data to raw pointers.\n+fn main() { unsafe {\n+    let x = &mut 0;\n+    let raw = x as *mut _;\n+    let x = &mut *x; // kill `raw`\n+    let _y = &*x; // this should not activate `raw` again\n+    let _val = *raw; //~ ERROR borrow stack\n+} }"}, {"sha": "dd262a341ed2df1d2101352459288f4fa3b3c9af", "filename": "tests/compile-fail/stacked_borrows/illegal_write1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write1.rs?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -5,5 +5,5 @@ fn main() {\n         let x : *mut u32 = xref as *const _ as *mut _;\n         unsafe { *x = 42; } // invalidates shared ref, activates raw\n     }\n-    let _x = *xref; //~ ERROR is not frozen\n+    let _x = *xref; //~ ERROR borrow stack\n }"}, {"sha": "62ea05e1811e717d60c1636449e9592369c5b714", "filename": "tests/compile-fail/stacked_borrows/illegal_write2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write2.rs?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -3,6 +3,6 @@ fn main() {\n     let target2 = target as *mut _;\n     drop(&mut *target); // reborrow\n     // Now make sure our ref is still the only one.\n-    unsafe { *target2 = 13; } //~ ERROR does not exist on the borrow stack\n+    unsafe { *target2 = 13; } //~ ERROR borrow stack\n     let _val = *target;\n }"}, {"sha": "d2d8528d9078683334fc43bc3d62a778dc00012c", "filename": "tests/compile-fail/stacked_borrows/illegal_write3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write3.rs?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -3,6 +3,6 @@ fn main() {\n     // Make sure raw ptr with raw tag cannot mutate frozen location without breaking the shared ref.\n     let r#ref = &target; // freeze\n     let ptr = r#ref as *const _ as *mut _; // raw ptr, with raw tag\n-    unsafe { *ptr = 42; } //~ ERROR does not exist on the borrow stack\n+    unsafe { *ptr = 42; } //~ ERROR borrow stack\n     let _val = *r#ref;\n }"}, {"sha": "be4f89ba289a14542e37b2aa0122a855f90396e4", "filename": "tests/compile-fail/stacked_borrows/illegal_write4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write4.rs?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -9,5 +9,5 @@ fn main() {\n     let ptr = reference as *const _ as *mut i32; // raw ptr, with raw tag\n     let _mut_ref: &mut i32 = unsafe { mem::transmute(ptr) }; // &mut, with raw tag\n     // Now we retag, making our ref top-of-stack -- and, in particular, unfreezing.\n-    let _val = *reference; //~ ERROR is not frozen\n+    let _val = *reference; //~ ERROR borrow stack\n }"}, {"sha": "c60fe90fe05c7e798093cbb8dc6ba8e46934c687", "filename": "tests/compile-fail/stacked_borrows/illegal_write5.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write5.rs?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -8,7 +8,7 @@ fn main() {\n     callee(xraw);\n     // ... though any use of raw value will invalidate our ref.\n     let _val = *xref;\n-    //~^ ERROR: does not exist on the borrow stack\n+    //~^ ERROR: borrow stack\n }\n \n fn callee(xraw: *mut i32) {"}, {"sha": "3a214a75b50595d621d95ad3b016c9418c76071c", "filename": "tests/compile-fail/stacked_borrows/invalidate_against_barrier1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Finvalidate_against_barrier1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Finvalidate_against_barrier1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Finvalidate_against_barrier1.rs?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -2,7 +2,7 @@ fn inner(x: *mut i32, _y: &mut i32) {\n     // If `x` and `y` alias, retagging is fine with this... but we really\n     // shouldn't be allowed to use `x` at all because `y` was assumed to be\n     // unique for the duration of this call.\n-    let _val = unsafe { *x }; //~ ERROR barrier\n+    let _val = unsafe { *x }; //~ ERROR protect\n }\n \n fn main() {"}, {"sha": "86e4a84287ec114c5a51a3b29e86bf3b969da15e", "filename": "tests/compile-fail/stacked_borrows/invalidate_against_barrier2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Finvalidate_against_barrier2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Finvalidate_against_barrier2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Finvalidate_against_barrier2.rs?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -2,7 +2,7 @@ fn inner(x: *mut i32, _y: &i32) {\n     // If `x` and `y` alias, retagging is fine with this... but we really\n     // shouldn't be allowed to write to `x` at all because `y` was assumed to be\n     // immutable for the duration of this call.\n-    unsafe { *x = 0 }; //~ ERROR barrier\n+    unsafe { *x = 0 }; //~ ERROR protect\n }\n \n fn main() {"}, {"sha": "1704b7fe19b2ed4be5ab1bf0a0507ca7763d60ea", "filename": "tests/compile-fail/stacked_borrows/load_invalid_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Fload_invalid_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Fload_invalid_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fload_invalid_mut.rs?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -5,5 +5,5 @@ fn main() {\n     let xref = unsafe { &mut *xraw };\n     let xref_in_mem = Box::new(xref);\n     let _val = unsafe { *xraw }; // invalidate xref\n-    let _val = *xref_in_mem; //~ ERROR does not exist on the borrow stack\n+    let _val = *xref_in_mem; //~ ERROR borrow stack\n }"}, {"sha": "4757a2c1e58942f1d93444509cbeb480cce47461", "filename": "tests/compile-fail/stacked_borrows/load_invalid_shr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Fload_invalid_shr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Fload_invalid_shr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fload_invalid_shr.rs?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -5,5 +5,5 @@ fn main() {\n     let xref = unsafe { &*xraw };\n     let xref_in_mem = Box::new(xref);\n     unsafe { *xraw = 42 }; // unfreeze\n-    let _val = *xref_in_mem; //~ ERROR is not frozen\n+    let _val = *xref_in_mem; //~ ERROR borrow stack\n }"}, {"sha": "03343b985a0219b63402dd20340757ab2cbfa001", "filename": "tests/compile-fail/stacked_borrows/mut_exclusive_violation1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Fmut_exclusive_violation1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Fmut_exclusive_violation1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fmut_exclusive_violation1.rs?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -21,7 +21,7 @@ fn unknown_code_1(x: &i32) { unsafe {\n } }\n \n fn unknown_code_2() { unsafe {\n-    *LEAK = 7; //~ ERROR barrier\n+    *LEAK = 7; //~ ERROR borrow stack\n } }\n \n fn main() {"}, {"sha": "4cb655366ef1fc220f33827293ff322f478594db", "filename": "tests/compile-fail/stacked_borrows/outdated_local.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Foutdated_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Foutdated_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Foutdated_local.rs?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -3,7 +3,7 @@ fn main() {\n     let y: *const i32 = &x;\n     x = 1; // this invalidates y by reactivating the lowermost uniq borrow for this local\n \n-    assert_eq!(unsafe { *y }, 1); //~ ERROR does not exist on the borrow stack\n+    assert_eq!(unsafe { *y }, 1); //~ ERROR borrow stack\n \n     assert_eq!(x, 1);\n }"}, {"sha": "d8a53b7a96309ecc249344b4f38a096763ff586c", "filename": "tests/compile-fail/stacked_borrows/pass_invalid_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Fpass_invalid_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Fpass_invalid_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fpass_invalid_mut.rs?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -6,5 +6,5 @@ fn main() {\n     let xraw = x as *mut _;\n     let xref = unsafe { &mut *xraw };\n     let _val = unsafe { *xraw }; // invalidate xref\n-    foo(xref); //~ ERROR does not exist on the borrow stack\n+    foo(xref); //~ ERROR borrow stack\n }"}, {"sha": "091604a283b9cd8ed6d64b6244d3152ce5c41b13", "filename": "tests/compile-fail/stacked_borrows/pass_invalid_shr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Fpass_invalid_shr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Fpass_invalid_shr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fpass_invalid_shr.rs?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -6,5 +6,5 @@ fn main() {\n     let xraw = x as *mut _;\n     let xref = unsafe { &*xraw };\n     unsafe { *xraw = 42 }; // unfreeze\n-    foo(xref); //~ ERROR is not frozen\n+    foo(xref); //~ ERROR borrow stack\n }"}, {"sha": "f724cdd2a7694e7f2261b1c061eec1ca95e99b16", "filename": "tests/compile-fail/stacked_borrows/pointer_smuggling.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Fpointer_smuggling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Fpointer_smuggling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fpointer_smuggling.rs?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -8,7 +8,7 @@ fn fun1(x: &mut u8) {\n \n fn fun2() {\n     // Now we use a pointer we are not allowed to use\n-    let _x = unsafe { *PTR }; //~ ERROR does not exist on the borrow stack\n+    let _x = unsafe { *PTR }; //~ ERROR borrow stack\n }\n \n fn main() {"}, {"sha": "54004ec43882311e2e6d0ebb6c5fec655628101c", "filename": "tests/compile-fail/stacked_borrows/return_invalid_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut.rs?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -3,7 +3,7 @@ fn foo(x: &mut (i32, i32)) -> &mut i32 {\n     let xraw = x as *mut (i32, i32);\n     let ret = unsafe { &mut (*xraw).1 };\n     let _val = unsafe { *xraw }; // invalidate xref\n-    ret //~ ERROR does not exist on the borrow stack\n+    ret //~ ERROR borrow stack\n }\n \n fn main() {"}, {"sha": "2eb2df81f5f16dc0d2fa02b5a4aea4b2e4265abf", "filename": "tests/compile-fail/stacked_borrows/return_invalid_mut_option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut_option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut_option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut_option.rs?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -3,7 +3,7 @@ fn foo(x: &mut (i32, i32)) -> Option<&mut i32> {\n     let xraw = x as *mut (i32, i32);\n     let ret = Some(unsafe { &mut (*xraw).1 });\n     let _val = unsafe { *xraw }; // invalidate xref\n-    ret //~ ERROR does not exist on the borrow stack\n+    ret //~ ERROR borrow stack\n }\n \n fn main() {"}, {"sha": "8b73df4bd1ac343fd7e6644bb1fea8587f344243", "filename": "tests/compile-fail/stacked_borrows/return_invalid_mut_tuple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut_tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut_tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut_tuple.rs?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -3,7 +3,7 @@ fn foo(x: &mut (i32, i32)) -> (&mut i32,) {\n     let xraw = x as *mut (i32, i32);\n     let ret = (unsafe { &mut (*xraw).1 },);\n     let _val = unsafe { *xraw }; // invalidate xref\n-    ret //~ ERROR does not exist on the borrow stack\n+    ret //~ ERROR borrow stack\n }\n \n fn main() {"}, {"sha": "eab026f9a47c60a13681fda27cb4d122b456049d", "filename": "tests/compile-fail/stacked_borrows/return_invalid_shr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_shr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_shr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_shr.rs?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -3,7 +3,7 @@ fn foo(x: &mut (i32, i32)) -> &i32 {\n     let xraw = x as *mut (i32, i32);\n     let ret = unsafe { &(*xraw).1 };\n     unsafe { *xraw = (42, 23) }; // unfreeze\n-    ret //~ ERROR is not frozen\n+    ret //~ ERROR borrow stack\n }\n \n fn main() {"}, {"sha": "f3a35ca266c6bcfc570ac863095a2565773b83b4", "filename": "tests/compile-fail/stacked_borrows/return_invalid_shr_option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_shr_option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_shr_option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_shr_option.rs?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -3,7 +3,7 @@ fn foo(x: &mut (i32, i32)) -> Option<&i32> {\n     let xraw = x as *mut (i32, i32);\n     let ret = Some(unsafe { &(*xraw).1 });\n     unsafe { *xraw = (42, 23) }; // unfreeze\n-    ret //~ ERROR is not frozen\n+    ret //~ ERROR borrow stack\n }\n \n fn main() {"}, {"sha": "82723bade27d7b362489fe38f847353466398493", "filename": "tests/compile-fail/stacked_borrows/return_invalid_shr_tuple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_shr_tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_shr_tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_shr_tuple.rs?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -3,7 +3,7 @@ fn foo(x: &mut (i32, i32)) -> (&i32,) {\n     let xraw = x as *mut (i32, i32);\n     let ret = (unsafe { &(*xraw).1 },);\n     unsafe { *xraw = (42, 23) }; // unfreeze\n-    ret //~ ERROR is not frozen\n+    ret //~ ERROR borrow stack\n }\n \n fn main() {"}, {"sha": "d734caf1d97aebe05e7440f4c77775fca0b6e8f4", "filename": "tests/compile-fail/stacked_borrows/shared_rw_borrows_are_weak1.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Fshared_rw_borrows_are_weak1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Fshared_rw_borrows_are_weak1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fshared_rw_borrows_are_weak1.rs?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -0,0 +1,14 @@\n+// We want to test that granting a SharedReadWrite will be added\n+// *below* an already granted Unique -- so writing to\n+// the SharedReadWrite will invalidate the Unique.\n+\n+use std::mem;\n+use std::cell::Cell;\n+\n+fn main() { unsafe {\n+    let x = &mut Cell::new(0);\n+    let y: &mut Cell<i32> = mem::transmute(&mut *x); // launder lifetime\n+    let shr_rw = &*x; // thanks to interior mutability this will be a SharedReadWrite\n+    shr_rw.set(1);\n+    y.get_mut(); //~ ERROR borrow stack\n+} }"}, {"sha": "942bb503db02753ca74ce8f02afc9d082c68139b", "filename": "tests/compile-fail/stacked_borrows/shared_rw_borrows_are_weak2.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Fshared_rw_borrows_are_weak2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Fshared_rw_borrows_are_weak2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fshared_rw_borrows_are_weak2.rs?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -0,0 +1,14 @@\n+// We want to test that granting a SharedReadWrite will be added\n+// *below* an already granted SharedReadWrite -- so writing to\n+// the SharedReadWrite will invalidate the SharedReadWrite.\n+\n+use std::mem;\n+use std::cell::RefCell;\n+\n+fn main() { unsafe {\n+    let x = &mut RefCell::new(0);\n+    let y: &i32 = mem::transmute(&*x.borrow()); // launder lifetime\n+    let shr_rw = &*x; // thanks to interior mutability this will be a SharedReadWrite\n+    shr_rw.replace(1);\n+    let _val = *y; //~ ERROR borrow stack\n+} }"}, {"sha": "5031210c547b1c890174a4e73a39d0435a19bdab", "filename": "tests/compile-fail/stacked_borrows/shr_frozen_violation1.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Fshr_frozen_violation1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Fshr_frozen_violation1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fshr_frozen_violation1.rs?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -8,9 +8,6 @@ fn main() {\n     println!(\"{}\", foo(&mut 0));\n }\n \n-// If we replace the `*const` by `&`, my current dev version of miri\n-// *does* find the problem, but not for a good reason: It finds it because\n-// of barriers, and we shouldn't rely on unknown code using barriers.\n-fn unknown_code(x: *const i32) {\n-    unsafe { *(x as *mut i32) = 7; } //~ ERROR barrier\n+fn unknown_code(x: &i32) {\n+    unsafe { *(x as *const i32 as *mut i32) = 7; } //~ ERROR borrow stack\n }"}, {"sha": "88ac164947660d8beeab7df3f7223a6c01ce2f94", "filename": "tests/compile-fail/stacked_borrows/static_memory_modification.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Fstatic_memory_modification.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Fstatic_memory_modification.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fstatic_memory_modification.rs?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -3,6 +3,6 @@ static X: usize = 5;\n #[allow(mutable_transmutes)]\n fn main() {\n     let _x = unsafe {\n-        std::mem::transmute::<&usize, &mut usize>(&X) //~ ERROR mutable reference with frozen tag\n+        std::mem::transmute::<&usize, &mut usize>(&X) //~ ERROR borrow stack\n     };\n }"}, {"sha": "e9282c5ba8f27e2ce9a2111d7fcb34bd820fb0ff", "filename": "tests/compile-fail/stacked_borrows/transmute-is-no-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Ftransmute-is-no-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Ftransmute-is-no-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Ftransmute-is-no-escape.rs?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -10,5 +10,5 @@ fn main() {\n     let _raw: *mut i32 = unsafe { mem::transmute(&mut x[0]) };\n     // `raw` still carries a tag, so we get another pointer to the same location that does not carry a tag\n     let raw = (&mut x[1] as *mut i32).wrapping_offset(-1);\n-    unsafe { *raw = 13; } //~ ERROR does not exist on the borrow stack\n+    unsafe { *raw = 13; } //~ ERROR borrow stack\n }"}, {"sha": "b49e6cce63bc3fc32108d0143a27e8df8361517e", "filename": "tests/compile-fail/stacked_borrows/unescaped_local.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Funescaped_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Fcompile-fail%2Fstacked_borrows%2Funescaped_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Funescaped_local.rs?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -4,5 +4,5 @@ fn main() {\n     let mut x = 42;\n     let raw = &mut x as *mut i32 as usize as *mut i32;\n     let _ptr = &mut x;\n-    unsafe { *raw = 13; } //~ ERROR does not exist on the borrow stack\n+    unsafe { *raw = 13; } //~ ERROR borrow stack\n }"}, {"sha": "a6ee151e3e13bbfa2c3dfed49463f1840a4e6467", "filename": "tests/run-pass/ptr_arith_offset.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Frun-pass%2Fptr_arith_offset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Frun-pass%2Fptr_arith_offset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fptr_arith_offset.rs?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -1,6 +1,6 @@\n fn main() {\n     let v = [1i16, 2];\n-    let x = &v as *const i16;\n+    let x = &v as *const [i16] as *const i16;\n     let x = x.wrapping_offset(1);\n     assert_eq!(unsafe { *x }, 2);\n }"}, {"sha": "1c7f0eb717974b1b72d2390e38c7678440757578", "filename": "tests/run-pass/ptr_offset.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Frun-pass%2Fptr_offset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Frun-pass%2Fptr_offset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fptr_offset.rs?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -2,7 +2,7 @@ fn f() -> i32 { 42 }\n \n fn main() {\n     let v = [1i16, 2];\n-    let x = &v as *const i16;\n+    let x = &v as *const [i16; 2] as *const i16;\n     let x = unsafe { x.offset(1) };\n     assert_eq!(unsafe { *x }, 2);\n "}, {"sha": "93cef1572a3e13d5c88b4e1315ecfe0357c2ec7e", "filename": "tests/run-pass/refcell.rs", "status": "modified", "additions": 1, "deletions": 45, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Frun-pass%2Frefcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Frun-pass%2Frefcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Frefcell.rs?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -1,6 +1,6 @@\n use std::cell::RefCell;\n \n-fn lots_of_funny_borrows() {\n+fn main() {\n     let c = RefCell::new(42);\n     {\n         let s1 = c.borrow();\n@@ -31,47 +31,3 @@ fn lots_of_funny_borrows() {\n         let _y: i32 = *s2;\n     }\n }\n-\n-fn aliasing_mut_and_shr() {\n-    fn inner(rc: &RefCell<i32>, aliasing: &mut i32) {\n-        *aliasing += 4;\n-        let _escape_to_raw = rc as *const _;\n-        *aliasing += 4;\n-        let _shr = &*rc;\n-        *aliasing += 4;\n-        // also turning this into a frozen ref now must work\n-        let aliasing = &*aliasing;\n-        let _val = *aliasing;\n-        let _escape_to_raw = rc as *const _; // this must NOT unfreeze\n-        let _val = *aliasing;\n-        let _shr = &*rc; // this must NOT unfreeze\n-        let _val = *aliasing;\n-    }\n-\n-    let rc = RefCell::new(23);\n-    let mut bmut = rc.borrow_mut();\n-    inner(&rc, &mut *bmut);\n-    drop(bmut);\n-    assert_eq!(*rc.borrow(), 23+12);\n-}\n-\n-fn aliasing_frz_and_shr() {\n-    fn inner(rc: &RefCell<i32>, aliasing: &i32) {\n-        let _val = *aliasing;\n-        let _escape_to_raw = rc as *const _; // this must NOT unfreeze\n-        let _val = *aliasing;\n-        let _shr = &*rc; // this must NOT unfreeze\n-        let _val = *aliasing;\n-    }\n-\n-    let rc = RefCell::new(23);\n-    let bshr = rc.borrow();\n-    inner(&rc, &*bshr);\n-    assert_eq!(*rc.borrow(), 23);\n-}\n-\n-fn main() {\n-    lots_of_funny_borrows();\n-    aliasing_mut_and_shr();\n-    aliasing_frz_and_shr();\n-}"}, {"sha": "020ed4927a88b0f759bd1666e2ee753fc02cda6c", "filename": "tests/run-pass/regions-mock-trans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Frun-pass%2Fregions-mock-trans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Frun-pass%2Fregions-mock-trans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fregions-mock-trans.rs?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -22,14 +22,14 @@ struct Ccx {\n     x: isize\n }\n \n-fn alloc<'a>(_bcx : &'a Arena) -> &'a Bcx<'a> {\n+fn alloc<'a>(_bcx : &'a Arena) -> &'a mut Bcx<'a> {\n     unsafe {\n         mem::transmute(libc::malloc(mem::size_of::<Bcx<'a>>()\n             as libc::size_t))\n     }\n }\n \n-fn h<'a>(bcx : &'a Bcx<'a>) -> &'a Bcx<'a> {\n+fn h<'a>(bcx : &'a Bcx<'a>) -> &'a mut Bcx<'a> {\n     return alloc(bcx.fcx.arena);\n }\n "}, {"sha": "97f435472e30045f5d4598df24805038d1f3e83b", "filename": "tests/run-pass/stacked-borrows/2phase.rs", "status": "renamed", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Frun-pass%2Fstacked-borrows%2F2phase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Frun-pass%2Fstacked-borrows%2F2phase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fstacked-borrows%2F2phase.rs?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -1,3 +1,5 @@\n+#![allow(mutable_borrow_reservation_conflict)]\n+\n trait S: Sized {\n     fn tpb(&mut self, _s: Self) {}\n }\n@@ -26,7 +28,21 @@ fn two_phase3(b: bool) {\n     ));\n }\n \n-/*\n+#[allow(unreachable_code)]\n+fn two_phase_raw() {\n+    let x: &mut Vec<i32> = &mut vec![];\n+    x.push(\n+        {\n+            // Unfortunately this does not trigger the problem of creating a\n+            // raw ponter from a pointer that had a two-phase borrow derived from\n+            // it because of the implicit &mut reborrow.\n+            let raw = x as *mut _;\n+            unsafe { *raw = vec![1]; }\n+            return\n+        }\n+    );\n+}\n+\n fn two_phase_overlapping1() {\n     let mut x = vec![];\n     let p = &x;\n@@ -39,7 +55,6 @@ fn two_phase_overlapping2() {\n     let l = &x;\n     x.add_assign(x + *l);\n }\n-*/\n \n fn with_interior_mutability() {\n     use std::cell::Cell;\n@@ -53,7 +68,6 @@ fn with_interior_mutability() {\n     let mut x = Cell::new(1);\n     let l = &x;\n \n-    #[allow(unknown_lints, mutable_borrow_reservation_conflict)]\n     x\n         .do_the_thing({\n             x.set(3);\n@@ -68,8 +82,8 @@ fn main() {\n     two_phase2();\n     two_phase3(false);\n     two_phase3(true);\n+    two_phase_raw();\n     with_interior_mutability();\n-    //FIXME: enable these, or remove them, depending on how https://github.com/rust-lang/rust/issues/56254 gets resolved\n-    //two_phase_overlapping1();\n-    //two_phase_overlapping2();\n+    two_phase_overlapping1();\n+    two_phase_overlapping2();\n }", "previous_filename": "tests/run-pass/2phase.rs"}, {"sha": "33f44d0093ed4d4886961dab416ef15d796d25a4", "filename": "tests/run-pass/stacked-borrows/interior_mutability.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Frun-pass%2Fstacked-borrows%2Finterior_mutability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Frun-pass%2Fstacked-borrows%2Finterior_mutability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fstacked-borrows%2Finterior_mutability.rs?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -0,0 +1,59 @@\n+#![feature(maybe_uninit, maybe_uninit_ref)]\n+use std::mem::MaybeUninit;\n+use std::cell::Cell;\n+use std::cell::RefCell;\n+\n+fn main() {\n+    aliasing_mut_and_shr();\n+    aliasing_frz_and_shr();\n+    into_interior_mutability();\n+}\n+\n+fn aliasing_mut_and_shr() {\n+    fn inner(rc: &RefCell<i32>, aliasing: &mut i32) {\n+        *aliasing += 4;\n+        let _escape_to_raw = rc as *const _;\n+        *aliasing += 4;\n+        let _shr = &*rc;\n+        *aliasing += 4;\n+        // also turning this into a frozen ref now must work\n+        let aliasing = &*aliasing;\n+        let _val = *aliasing;\n+        let _escape_to_raw = rc as *const _; // this must NOT unfreeze\n+        let _val = *aliasing;\n+        let _shr = &*rc; // this must NOT unfreeze\n+        let _val = *aliasing;\n+    }\n+\n+    let rc = RefCell::new(23);\n+    let mut bmut = rc.borrow_mut();\n+    inner(&rc, &mut *bmut);\n+    drop(bmut);\n+    assert_eq!(*rc.borrow(), 23+12);\n+}\n+\n+fn aliasing_frz_and_shr() {\n+    fn inner(rc: &RefCell<i32>, aliasing: &i32) {\n+        let _val = *aliasing;\n+        let _escape_to_raw = rc as *const _; // this must NOT unfreeze\n+        let _val = *aliasing;\n+        let _shr = &*rc; // this must NOT unfreeze\n+        let _val = *aliasing;\n+    }\n+\n+    let rc = RefCell::new(23);\n+    let bshr = rc.borrow();\n+    inner(&rc, &*bshr);\n+    assert_eq!(*rc.borrow(), 23);\n+}\n+\n+// Getting a pointer into a union with interior mutability used to be tricky\n+// business (https://github.com/rust-lang/miri/issues/615), but it should work\n+// now.\n+fn into_interior_mutability() {\n+    let mut x: MaybeUninit<(Cell<u32>, u32)> = MaybeUninit::uninit();\n+    x.as_ptr();\n+    x.write((Cell::new(0), 1));\n+    let ptr = unsafe { x.get_ref() };\n+    assert_eq!(ptr.1, 1);\n+}"}, {"sha": "7d84e33b3d6b3ff7dafea2f6263bec3bedb0bff1", "filename": "tests/run-pass/stacked-borrows/stacked-borrows.rs", "status": "renamed", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Frun-pass%2Fstacked-borrows%2Fstacked-borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c4c0c23c8695e2cbd39410a34dd6db10de5c6/tests%2Frun-pass%2Fstacked-borrows%2Fstacked-borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fstacked-borrows%2Fstacked-borrows.rs?ref=af3c4c0c23c8695e2cbd39410a34dd6db10de5c6", "patch": "@@ -10,6 +10,8 @@ fn main() {\n     partially_invalidate_mut();\n     drop_after_sharing();\n     direct_mut_to_const_raw();\n+    two_raw();\n+    shr_and_raw();\n }\n \n // Deref a raw ptr to access a field of a large struct, where the field\n@@ -123,3 +125,27 @@ fn direct_mut_to_const_raw() {\n     assert_eq!(*x, 1);\n     */\n }\n+\n+// Make sure that we can create two raw pointers from a mutable reference and use them both.\n+fn two_raw() { unsafe {\n+    let x = &mut 0;\n+    // Given the implicit reborrows, the only reason this currently works is that we\n+    // do not track raw pointers: The creation of `y2` reborrows `x` and thus pops\n+    // `y1` off the stack.\n+    let y1 = x as *mut _;\n+    let y2 = x as *mut _;\n+    *y1 += 2;\n+    *y2 += 1;\n+} }\n+\n+// Make sure that creating a *mut does not invalidate existing shared references.\n+fn shr_and_raw() { /* unsafe {\n+    use std::mem;\n+    // FIXME: This is currently disabled because \"as *mut _\" incurs a reborrow.\n+    let x = &mut 0;\n+    let y1: &i32 = mem::transmute(&*x); // launder lifetimes\n+    let y2 = x as *mut _;\n+    let _val = *y1;\n+    *y2 += 1;\n+    // TODO: Once this works, add compile-fail test that tries to read from y1 again.\n+} */ }", "previous_filename": "tests/run-pass/stacked-borrows.rs"}]}