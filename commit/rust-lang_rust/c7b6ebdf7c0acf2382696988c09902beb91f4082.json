{"sha": "c7b6ebdf7c0acf2382696988c09902beb91f4082", "node_id": "C_kwDOAAsO6NoAKGM3YjZlYmRmN2MwYWNmMjM4MjY5Njk4OGMwOTkwMmJlYjkxZjQwODI", "commit": {"author": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-10-04T09:43:34Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-10-04T14:10:44Z"}, "message": "It's not about types or consts, but the lack of regions", "tree": {"sha": "78c0f1ced5e643521bb63f979c3b7190fa3930cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/78c0f1ced5e643521bb63f979c3b7190fa3930cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c7b6ebdf7c0acf2382696988c09902beb91f4082", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c7b6ebdf7c0acf2382696988c09902beb91f4082", "html_url": "https://github.com/rust-lang/rust/commit/c7b6ebdf7c0acf2382696988c09902beb91f4082", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c7b6ebdf7c0acf2382696988c09902beb91f4082/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ead49f0beb7e36007aeed59f862f10f72b889c59", "url": "https://api.github.com/repos/rust-lang/rust/commits/ead49f0beb7e36007aeed59f862f10f72b889c59", "html_url": "https://github.com/rust-lang/rust/commit/ead49f0beb7e36007aeed59f862f10f72b889c59"}], "stats": {"total": 148, "additions": 71, "deletions": 77}, "files": [{"sha": "28ed88e8345c4cb53f946154844a0a183a246d40", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=c7b6ebdf7c0acf2382696988c09902beb91f4082", "patch": "@@ -236,7 +236,7 @@ pub(crate) fn type_check<'mir, 'tcx>(\n                 .unwrap();\n             let mut hidden_type = infcx.resolve_vars_if_possible(decl.hidden_type);\n             trace!(\"finalized opaque type {:?} to {:#?}\", opaque_type_key, hidden_type.ty.kind());\n-            if hidden_type.has_infer_types_or_consts() {\n+            if hidden_type.has_non_region_infer() {\n                 infcx.tcx.sess.delay_span_bug(\n                     decl.hidden_type.span,\n                     &format!(\"could not resolve {:#?}\", hidden_type.ty.kind()),"}, {"sha": "e51e528062094f5d6087fc53800af98612ab1618", "filename": "compiler/rustc_hir_analysis/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=c7b6ebdf7c0acf2382696988c09902beb91f4082", "patch": "@@ -91,14 +91,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         mutate_fulfillment_errors: impl Fn(&mut Vec<traits::FulfillmentError<'tcx>>),\n     ) -> Ty<'tcx> {\n         // No Infer()? Nothing needs doing.\n-        if !ty.has_infer_types_or_consts() {\n+        if !ty.has_non_region_infer() {\n             debug!(\"no inference var, nothing needs doing\");\n             return ty;\n         }\n \n         // If `ty` is a type variable, see whether we already know what it is.\n         ty = self.resolve_vars_if_possible(ty);\n-        if !ty.has_infer_types_or_consts() {\n+        if !ty.has_non_region_infer() {\n             debug!(?ty);\n             return ty;\n         }"}, {"sha": "13e74021b9e0a3903dd8fb2072c20da548d01834", "filename": "compiler/rustc_hir_analysis/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=c7b6ebdf7c0acf2382696988c09902beb91f4082", "patch": "@@ -63,7 +63,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let get_operand_ty = |expr| {\n                 let ty = self.typeck_results.borrow().expr_ty_adjusted(expr);\n                 let ty = self.resolve_vars_if_possible(ty);\n-                if ty.has_infer_types_or_consts() {\n+                if ty.has_non_region_infer() {\n                     assert!(self.is_tainted_by_errors());\n                     self.tcx.ty_error()\n                 } else {"}, {"sha": "4abc00cefb68f29ffa18741c38fcad7a07cf688a", "filename": "compiler/rustc_hir_analysis/src/check/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs?ref=c7b6ebdf7c0acf2382696988c09902beb91f4082", "patch": "@@ -149,7 +149,7 @@ impl<'a, 'tcx> InlineAsmCtxt<'a, 'tcx> {\n         target_features: &FxHashSet<Symbol>,\n     ) -> Option<InlineAsmType> {\n         let ty = (self.get_operand_ty)(expr);\n-        if ty.has_infer_types_or_consts() {\n+        if ty.has_non_region_infer() {\n             bug!(\"inference variable in asm operand ty: {:?} {:?}\", expr, ty);\n         }\n         let asm_ty_isize = match self.tcx.sess.target.pointer_width {"}, {"sha": "d876b1d20fe22c5674f7d8b1bba523c4e199618f", "filename": "compiler/rustc_hir_analysis/src/check/op.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fop.rs?ref=c7b6ebdf7c0acf2382696988c09902beb91f4082", "patch": "@@ -471,7 +471,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         // This has nothing here because it means we did string\n                         // concatenation (e.g., \"Hello \" + \"World!\"). This means\n                         // we don't want the note in the else clause to be emitted\n-                    } else if lhs_ty.has_param_types_or_consts() {\n+                    } else if lhs_ty.has_non_region_param() {\n                         // Look for a TraitPredicate in the Fulfillment errors,\n                         // and use it to generate a suggestion.\n                         //\n@@ -657,7 +657,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         format!(\"cannot apply unary operator `{}`\", op.as_str()),\n                     );\n \n-                    if operand_ty.has_param_types_or_consts() {\n+                    if operand_ty.has_non_region_param() {\n                         let predicates = errors.iter().filter_map(|error| {\n                             error.obligation.predicate.to_opt_poly_trait_pred()\n                         });"}, {"sha": "d607f9014200eda4cf2fb8f514114f99d25161e2", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=c7b6ebdf7c0acf2382696988c09902beb91f4082", "patch": "@@ -1428,9 +1428,7 @@ fn check_where_clauses<'tcx>(wfcx: &WfCheckingCtxt<'_, 'tcx>, span: Span, def_id\n             let substituted_pred = predicates.rebind(pred).subst(tcx, substs);\n             // Don't check non-defaulted params, dependent defaults (including lifetimes)\n             // or preds with multiple params.\n-            if substituted_pred.has_param_types_or_consts()\n-                || param_count.params.len() > 1\n-                || has_region\n+            if substituted_pred.has_non_region_param() || param_count.params.len() > 1 || has_region\n             {\n                 None\n             } else if predicates.0.predicates.iter().any(|&(p, _)| p == substituted_pred) {"}, {"sha": "70edcd10f5f32f884f56a12b7af01d453146918f", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=c7b6ebdf7c0acf2382696988c09902beb91f4082", "patch": "@@ -712,9 +712,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     ) -> bool {\n         // Reject any attempt to unify two unevaluated constants that contain inference\n         // variables, since inference variables in queries lead to ICEs.\n-        if a.substs.has_infer_types_or_consts()\n-            || b.substs.has_infer_types_or_consts()\n-            || param_env.has_infer_types_or_consts()\n+        if a.substs.has_non_region_infer()\n+            || b.substs.has_non_region_infer()\n+            || param_env.has_non_region_infer()\n         {\n             debug!(\"a or b or param_env contain infer vars in its substs -> cannot unify\");\n             return false;\n@@ -1734,7 +1734,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n         // Postpone the evaluation of constants whose substs depend on inference\n         // variables\n-        if substs.has_infer_types_or_consts() {\n+        if substs.has_non_region_infer() {\n             let ac = AbstractConst::new(self.tcx, unevaluated);\n             match ac {\n                 Ok(None) => {\n@@ -2072,21 +2072,17 @@ fn replace_param_and_infer_substs_with_placeholder<'tcx>(\n ) -> SubstsRef<'tcx> {\n     tcx.mk_substs(substs.iter().enumerate().map(|(idx, arg)| {\n         match arg.unpack() {\n-            GenericArgKind::Type(_)\n-                if arg.has_param_types_or_consts() || arg.has_infer_types_or_consts() =>\n-            {\n+            GenericArgKind::Type(_) if arg.has_non_region_param() || arg.has_non_region_infer() => {\n                 tcx.mk_ty(ty::Placeholder(ty::PlaceholderType {\n                     universe: ty::UniverseIndex::ROOT,\n                     name: ty::BoundVar::from_usize(idx),\n                 }))\n                 .into()\n             }\n-            GenericArgKind::Const(ct)\n-                if ct.has_infer_types_or_consts() || ct.has_param_types_or_consts() =>\n-            {\n+            GenericArgKind::Const(ct) if ct.has_non_region_infer() || ct.has_non_region_param() => {\n                 let ty = ct.ty();\n                 // If the type references param or infer, replace that too...\n-                if ty.has_param_types_or_consts() || ty.has_infer_types_or_consts() {\n+                if ty.has_non_region_param() || ty.has_non_region_infer() {\n                     bug!(\"const `{ct}`'s type should not reference params or types\");\n                 }\n                 tcx.mk_const(ty::ConstS {"}, {"sha": "91e73451a0fd35eda107e9adc8402e9052bd0cd0", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=c7b6ebdf7c0acf2382696988c09902beb91f4082", "patch": "@@ -357,7 +357,7 @@ where\n             // In NLL, we don't have type inference variables\n             // floating around, so we can do this rather imprecise\n             // variant of the occurs-check.\n-            assert!(!generalized_ty.has_infer_types_or_consts());\n+            assert!(!generalized_ty.has_non_region_infer());\n         }\n \n         self.infcx.inner.borrow_mut().type_variables().instantiate(vid, generalized_ty);"}, {"sha": "bb188496caa0d6fd02ee0430f9f95ef573f3dd11", "filename": "compiler/rustc_infer/src/infer/resolve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs?ref=c7b6ebdf7c0acf2382696988c09902beb91f4082", "patch": "@@ -32,7 +32,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for OpportunisticVarResolver<'a, 'tcx> {\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        if !t.has_infer_types_or_consts() {\n+        if !t.has_non_region_infer() {\n             t // micro-optimize -- if there is nothing in this type that this fold affects...\n         } else {\n             let t = self.infcx.shallow_resolve(t);\n@@ -41,7 +41,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for OpportunisticVarResolver<'a, 'tcx> {\n     }\n \n     fn fold_const(&mut self, ct: Const<'tcx>) -> Const<'tcx> {\n-        if !ct.has_infer_types_or_consts() {\n+        if !ct.has_non_region_infer() {\n             ct // micro-optimize -- if there is nothing in this const that this fold affects...\n         } else {\n             let ct = self.infcx.shallow_resolve(ct);"}, {"sha": "8f67161420dad95ae4063eae999e81da397adf4c", "filename": "compiler/rustc_middle/src/mir/interpret/queries.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fqueries.rs?ref=c7b6ebdf7c0acf2382696988c09902beb91f4082", "patch": "@@ -45,7 +45,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         //\n         // When trying to evaluate constants containing inference variables,\n         // use `Infcx::const_eval_resolve` instead.\n-        if ct.substs.has_infer_types_or_consts() {\n+        if ct.substs.has_non_region_infer() {\n             bug!(\"did not expect inference variables here\");\n         }\n \n@@ -76,7 +76,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         //\n         // When trying to evaluate constants containing inference variables,\n         // use `Infcx::const_eval_resolve` instead.\n-        if ct.substs.has_infer_types_or_consts() {\n+        if ct.substs.has_non_region_infer() {\n             bug!(\"did not expect inference variables here\");\n         }\n "}, {"sha": "a9ebd7834033171eb38f2071943281c46db147ad", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=c7b6ebdf7c0acf2382696988c09902beb91f4082", "patch": "@@ -313,7 +313,7 @@ impl<'tcx> Body<'tcx> {\n             is_polymorphic: false,\n             tainted_by_errors,\n         };\n-        body.is_polymorphic = body.has_param_types_or_consts();\n+        body.is_polymorphic = body.has_non_region_param();\n         body\n     }\n \n@@ -339,7 +339,7 @@ impl<'tcx> Body<'tcx> {\n             is_polymorphic: false,\n             tainted_by_errors: None,\n         };\n-        body.is_polymorphic = body.has_param_types_or_consts();\n+        body.is_polymorphic = body.has_non_region_param();\n         body\n     }\n \n@@ -2760,15 +2760,15 @@ fn pretty_print_const_value<'tcx>(\n             }\n             // Aggregates, printed as array/tuple/struct/variant construction syntax.\n             //\n-            // NB: the `has_param_types_or_consts` check ensures that we can use\n+            // NB: the `has_non_region_param` check ensures that we can use\n             // the `destructure_const` query with an empty `ty::ParamEnv` without\n             // introducing ICEs (e.g. via `layout_of`) from missing bounds.\n             // E.g. `transmute([0usize; 2]): (u8, *mut T)` needs to know `T: Sized`\n             // to be able to destructure the tuple into `(0u8, *mut T)\n             //\n             // FIXME(eddyb) for `--emit=mir`/`-Z dump-mir`, we should provide the\n             // correct `ty::ParamEnv` to allow printing *all* constant values.\n-            (_, ty::Array(..) | ty::Tuple(..) | ty::Adt(..)) if !ty.has_param_types_or_consts() => {\n+            (_, ty::Array(..) | ty::Tuple(..) | ty::Adt(..)) if !ty.has_non_region_param() => {\n                 let ct = tcx.lift(ct).unwrap();\n                 let ty = tcx.lift(ty).unwrap();\n                 if let Some(contents) = tcx.try_destructure_mir_constant("}, {"sha": "1aa4df778008444cd12cdc6bfb2960ec5a667acd", "filename": "compiler/rustc_middle/src/ty/abstract_const.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_middle%2Fsrc%2Fty%2Fabstract_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_middle%2Fsrc%2Fty%2Fabstract_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fabstract_const.rs?ref=c7b6ebdf7c0acf2382696988c09902beb91f4082", "patch": "@@ -71,16 +71,16 @@ impl<'tcx> AbstractConst<'tcx> {\n         walk_abstract_const::<!, _>(tcx, self, |node| {\n             match node.root(tcx) {\n                 Node::Leaf(leaf) => {\n-                    if leaf.has_infer_types_or_consts() {\n+                    if leaf.has_non_region_infer() {\n                         failure_kind = FailureKind::MentionsInfer;\n-                    } else if leaf.has_param_types_or_consts() {\n+                    } else if leaf.has_non_region_param() {\n                         failure_kind = cmp::min(failure_kind, FailureKind::MentionsParam);\n                     }\n                 }\n                 Node::Cast(_, _, ty) => {\n-                    if ty.has_infer_types_or_consts() {\n+                    if ty.has_non_region_infer() {\n                         failure_kind = FailureKind::MentionsInfer;\n-                    } else if ty.has_param_types_or_consts() {\n+                    } else if ty.has_non_region_param() {\n                         failure_kind = cmp::min(failure_kind, FailureKind::MentionsParam);\n                     }\n                 }"}, {"sha": "3be0bc4defc5cacc1e039a5838c1f007c3e2560d", "filename": "compiler/rustc_middle/src/ty/fast_reject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs?ref=c7b6ebdf7c0acf2382696988c09902beb91f4082", "patch": "@@ -132,7 +132,7 @@ pub fn simplify_type<'tcx>(\n             // don't unify with anything else as long as they are fully normalized.\n             //\n             // We will have to be careful with lazy normalization here.\n-            TreatParams::AsPlaceholder if !ty.has_infer_types_or_consts() => {\n+            TreatParams::AsPlaceholder if !ty.has_non_region_infer() => {\n                 debug!(\"treating `{}` as a placeholder\", ty);\n                 Some(PlaceholderSimplifiedType)\n             }"}, {"sha": "5f8729a8ddf3caadd4cbb33b5e3c7a27c150340a", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=c7b6ebdf7c0acf2382696988c09902beb91f4082", "patch": "@@ -244,7 +244,7 @@ impl<'tcx> SizeSkeleton<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> Result<SizeSkeleton<'tcx>, LayoutError<'tcx>> {\n-        debug_assert!(!ty.has_infer_types_or_consts());\n+        debug_assert!(!ty.has_non_region_infer());\n \n         // First try computing a static layout.\n         let err = match tcx.layout_of(param_env.and(ty)) {\n@@ -260,7 +260,7 @@ impl<'tcx> SizeSkeleton<'tcx> {\n                 let tail = tcx.struct_tail_erasing_lifetimes(pointee, param_env);\n                 match tail.kind() {\n                     ty::Param(_) | ty::Projection(_) => {\n-                        debug_assert!(tail.has_param_types_or_consts());\n+                        debug_assert!(tail.has_non_region_param());\n                         Ok(SizeSkeleton::Pointer { non_zero, tail: tcx.erase_regions(tail) })\n                     }\n                     _ => bug!("}, {"sha": "44efb93a53bfc799d2783f334cdbbf17ef2307e9", "filename": "compiler/rustc_middle/src/ty/visit.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs?ref=c7b6ebdf7c0acf2382696988c09902beb91f4082", "patch": "@@ -104,17 +104,17 @@ pub trait TypeVisitable<'tcx>: fmt::Debug + Clone {\n             None\n         }\n     }\n-    fn has_param_types_or_consts(&self) -> bool {\n-        self.has_type_flags(TypeFlags::HAS_TY_PARAM | TypeFlags::HAS_CT_PARAM)\n+    fn has_non_region_param(&self) -> bool {\n+        self.has_type_flags(TypeFlags::NEEDS_SUBST - TypeFlags::HAS_RE_PARAM)\n     }\n     fn has_infer_regions(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_RE_INFER)\n     }\n     fn has_infer_types(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_TY_INFER)\n     }\n-    fn has_infer_types_or_consts(&self) -> bool {\n-        self.has_type_flags(TypeFlags::HAS_TY_INFER | TypeFlags::HAS_CT_INFER)\n+    fn has_non_region_infer(&self) -> bool {\n+        self.has_type_flags(TypeFlags::NEEDS_INFER - TypeFlags::HAS_RE_INFER)\n     }\n     fn needs_infer(&self) -> bool {\n         self.has_type_flags(TypeFlags::NEEDS_INFER)"}, {"sha": "a93f6a60114a6a106eeed73c7dcb776cc932eb21", "filename": "compiler/rustc_monomorphize/src/polymorphize.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_monomorphize%2Fsrc%2Fpolymorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_monomorphize%2Fsrc%2Fpolymorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpolymorphize.rs?ref=c7b6ebdf7c0acf2382696988c09902beb91f4082", "patch": "@@ -290,7 +290,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkUsedGenericParams<'a, 'tcx> {\n impl<'a, 'tcx> TypeVisitor<'tcx> for MarkUsedGenericParams<'a, 'tcx> {\n     #[instrument(level = \"debug\", skip(self))]\n     fn visit_const(&mut self, c: Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        if !c.has_param_types_or_consts() {\n+        if !c.has_non_region_param() {\n             return ControlFlow::CONTINUE;\n         }\n \n@@ -311,7 +311,7 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for MarkUsedGenericParams<'a, 'tcx> {\n     }\n \n     fn visit_mir_const(&mut self, constant: ConstantKind<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        if !constant.has_param_types_or_consts() {\n+        if !constant.has_non_region_param() {\n             return ControlFlow::CONTINUE;\n         }\n \n@@ -336,7 +336,7 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for MarkUsedGenericParams<'a, 'tcx> {\n \n     #[instrument(level = \"debug\", skip(self))]\n     fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        if !ty.has_param_types_or_consts() {\n+        if !ty.has_non_region_param() {\n             return ControlFlow::CONTINUE;\n         }\n \n@@ -373,7 +373,7 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for HasUsedGenericParams<'a> {\n \n     #[instrument(level = \"debug\", skip(self))]\n     fn visit_const(&mut self, c: Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        if !c.has_param_types_or_consts() {\n+        if !c.has_non_region_param() {\n             return ControlFlow::CONTINUE;\n         }\n \n@@ -391,7 +391,7 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for HasUsedGenericParams<'a> {\n \n     #[instrument(level = \"debug\", skip(self))]\n     fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        if !ty.has_param_types_or_consts() {\n+        if !ty.has_non_region_param() {\n             return ControlFlow::CONTINUE;\n         }\n "}, {"sha": "ecfe6861e84cb5a6f4d57745765321954af513f5", "filename": "compiler/rustc_symbol_mangling/src/v0.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs?ref=c7b6ebdf7c0acf2382696988c09902beb91f4082", "patch": "@@ -301,7 +301,7 @@ impl<'tcx> Printer<'tcx> for &mut SymbolMangler<'tcx> {\n \n         // Encode impl generic params if the substitutions contain parameters (implying\n         // polymorphization is enabled) and this isn't an inherent impl.\n-        if impl_trait_ref.is_some() && substs.iter().any(|a| a.has_param_types_or_consts()) {\n+        if impl_trait_ref.is_some() && substs.iter().any(|a| a.has_non_region_param()) {\n             self = self.path_generic_args(\n                 |this| {\n                     this.path_append_ns("}, {"sha": "911d1cf8bdf6b9f48967894a00107031f4183df0", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=c7b6ebdf7c0acf2382696988c09902beb91f4082", "patch": "@@ -236,9 +236,9 @@ pub fn is_const_evaluatable<'cx, 'tcx>(\n             }\n \n             Err(ErrorHandled::TooGeneric) => {\n-                let err = if uv.has_infer_types_or_consts() {\n+                let err = if uv.has_non_region_infer() {\n                     NotConstEvaluatable::MentionsInfer\n-                } else if uv.has_param_types_or_consts() {\n+                } else if uv.has_non_region_param() {\n                     NotConstEvaluatable::MentionsParam\n                 } else {\n                     let guar = infcx.tcx.sess.delay_span_bug(span, format!(\"Missing value for constant, but no error reported?\"));\n@@ -254,7 +254,7 @@ pub fn is_const_evaluatable<'cx, 'tcx>(\n             }\n             Err(ErrorHandled::Reported(e)) => Err(NotConstEvaluatable::Error(e)),\n             Ok(_) => {\n-                if uv.substs.has_param_types_or_consts() {\n+                if uv.substs.has_non_region_param() {\n                     assert!(matches!(infcx.tcx.def_kind(uv.def.did), DefKind::AnonConst));\n                     let mir_body = infcx.tcx.mir_for_ctfe_opt_const_arg(uv.def);\n "}, {"sha": "4398d71a89d4265e4c0f1334838be17f5c807904", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=c7b6ebdf7c0acf2382696988c09902beb91f4082", "patch": "@@ -661,7 +661,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                                     );\n                                 }\n                             }\n-                        } else if !trait_ref.has_infer_types_or_consts()\n+                        } else if !trait_ref.has_non_region_infer()\n                             && self.predicate_can_apply(obligation.param_env, trait_ref)\n                         {\n                             // If a where-clause may be useful, remind the\n@@ -2093,7 +2093,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n                 // Pick the first substitution that still contains inference variables as the one\n                 // we're going to emit an error for. If there are none (see above), fall back to\n                 // a more general error.\n-                let subst = data.trait_ref.substs.iter().find(|s| s.has_infer_types_or_consts());\n+                let subst = data.trait_ref.substs.iter().find(|s| s.has_non_region_infer());\n \n                 let mut err = if let Some(subst) = subst {\n                     self.emit_inference_failure_err(body_id, span, subst, ErrorCode::E0283, true)\n@@ -2323,7 +2323,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n                     .substs\n                     .iter()\n                     .chain(Some(data.term.into_arg()))\n-                    .find(|g| g.has_infer_types_or_consts());\n+                    .find(|g| g.has_non_region_infer());\n                 if let Some(subst) = subst {\n                     let mut err = self.emit_inference_failure_err(\n                         body_id,\n@@ -2352,7 +2352,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n                 if predicate.references_error() || self.is_tainted_by_errors() {\n                     return;\n                 }\n-                let subst = data.substs.iter().find(|g| g.has_infer_types_or_consts());\n+                let subst = data.substs.iter().find(|g| g.has_non_region_infer());\n                 if let Some(subst) = subst {\n                     let err = self.emit_inference_failure_err(\n                         body_id,"}, {"sha": "7aae014af6044cee85677b21b99b9ffc332ed957", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=c7b6ebdf7c0acf2382696988c09902beb91f4082", "patch": "@@ -1231,7 +1231,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 return;\n             }\n             let trait_pred = self.resolve_vars_if_possible(trait_pred);\n-            if trait_pred.has_infer_types_or_consts() {\n+            if trait_pred.has_non_region_infer() {\n                 // Do not ICE while trying to find if a reborrow would succeed on a trait with\n                 // unresolved bindings.\n                 return;"}, {"sha": "5802f038e893c691c87da6cd1cc592268fab0bb4", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=c7b6ebdf7c0acf2382696988c09902beb91f4082", "patch": "@@ -279,7 +279,7 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n \n         debug!(?obligation, \"pre-resolve\");\n \n-        if obligation.predicate.has_infer_types_or_consts() {\n+        if obligation.predicate.has_non_region_infer() {\n             obligation.predicate =\n                 self.selcx.infcx().resolve_vars_if_possible(obligation.predicate);\n         }\n@@ -569,7 +569,7 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n                             )\n                         }\n                         (Err(ErrorHandled::TooGeneric), _) | (_, Err(ErrorHandled::TooGeneric)) => {\n-                            if c1.has_infer_types_or_consts() || c2.has_infer_types_or_consts() {\n+                            if c1.has_non_region_infer() || c2.has_non_region_infer() {\n                                 ProcessResult::Unchanged\n                             } else {\n                                 // Two different constants using generic parameters ~> error.\n@@ -726,11 +726,11 @@ fn substs_infer_vars<'a, 'tcx>(\n         .resolve_vars_if_possible(substs)\n         .skip_binder() // ok because this check doesn't care about regions\n         .iter()\n-        .filter(|arg| arg.has_infer_types_or_consts())\n+        .filter(|arg| arg.has_non_region_infer())\n         .flat_map(|arg| {\n             let mut walker = arg.walk();\n             while let Some(c) = walker.next() {\n-                if !c.has_infer_types_or_consts() {\n+                if !c.has_non_region_infer() {\n                     walker.visited.remove(&c);\n                     walker.skip_current_subtree();\n                 }"}, {"sha": "41b742734cd8d410f3aecf4e0a0ab8425904efa9", "filename": "compiler/rustc_trait_selection/src/traits/misc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs?ref=c7b6ebdf7c0acf2382696988c09902beb91f4082", "patch": "@@ -57,7 +57,7 @@ pub fn can_type_implement_copy<'tcx>(\n                 // to begin with, and point to the bad field's span instead.\n                 let cause = if field\n                     .ty(tcx, traits::InternalSubsts::identity_for_item(tcx, adt.did()))\n-                    .has_param_types_or_consts()\n+                    .has_non_region_param()\n                 {\n                     parent_cause.clone()\n                 } else {"}, {"sha": "659ffc178aa547741c47eafa3d807b37f7b0a3d7", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=c7b6ebdf7c0acf2382696988c09902beb91f4082", "patch": "@@ -170,7 +170,7 @@ pub fn type_known_to_meet_bound_modulo_regions<'a, 'tcx>(\n         result\n     );\n \n-    if result && ty.has_infer_types_or_consts() {\n+    if result && ty.has_non_region_infer() {\n         // Because of inference \"guessing\", selection can sometimes claim\n         // to succeed while the success requires a guess. To ensure\n         // this function's result remains infallible, we must confirm"}, {"sha": "7db96c0cef01cde92d6ca548807da289bb6520da", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=c7b6ebdf7c0acf2382696988c09902beb91f4082", "patch": "@@ -1488,7 +1488,7 @@ fn assemble_candidates_from_predicates<'cx, 'tcx>(\n                     candidate_set.push_candidate(ctor(data));\n \n                     if potentially_unnormalized_candidates\n-                        && !obligation.predicate.has_infer_types_or_consts()\n+                        && !obligation.predicate.has_non_region_infer()\n                     {\n                         // HACK: Pick the first trait def candidate for a fully\n                         // inferred predicate. This is to allow duplicates that"}, {"sha": "9a8331614b0e805d11fea1b3f3902ad5f9ce261b", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=c7b6ebdf7c0acf2382696988c09902beb91f4082", "patch": "@@ -174,7 +174,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         debug!(?stack, ?candidates, \"winnowed to {} candidates\", candidates.len());\n \n-        let needs_infer = stack.obligation.predicate.has_infer_types_or_consts();\n+        let needs_infer = stack.obligation.predicate.has_non_region_infer();\n \n         // If there are STILL multiple candidates, we can further\n         // reduce the list by dropping duplicates -- including\n@@ -889,11 +889,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         obligation: &TraitObligation<'tcx>,\n         candidates: &mut SelectionCandidateSet<'tcx>,\n     ) {\n-        if obligation.has_param_types_or_consts() {\n+        if obligation.has_non_region_param() {\n             return;\n         }\n \n-        if obligation.has_infer_types_or_consts() {\n+        if obligation.has_non_region_infer() {\n             candidates.ambiguous = true;\n             return;\n         }"}, {"sha": "8f2a6f337baad7dd11655d43ec11e2025675a6ed", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=c7b6ebdf7c0acf2382696988c09902beb91f4082", "patch": "@@ -728,7 +728,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             )\n                         }\n                         (Err(ErrorHandled::TooGeneric), _) | (_, Err(ErrorHandled::TooGeneric)) => {\n-                            if c1.has_infer_types_or_consts() || c2.has_infer_types_or_consts() {\n+                            if c1.has_non_region_infer() || c2.has_non_region_infer() {\n                                 Ok(EvaluatedToAmbig)\n                             } else {\n                                 // Two different constants using generic parameters ~> error.\n@@ -1520,7 +1520,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             if !generics.params.is_empty()\n                 && obligation.predicate.substs[generics.parent_count..]\n                     .iter()\n-                    .any(|&p| p.has_infer_types_or_consts() && self.infcx.shallow_resolve(p) != p)\n+                    .any(|&p| p.has_non_region_infer() && self.infcx.shallow_resolve(p) != p)\n             {\n                 ProjectionMatchesProjection::Ambiguous\n             } else {"}, {"sha": "e540ee1664d1d4459256f372bc43c79a4759fc7f", "filename": "compiler/rustc_traits/src/implied_outlives_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs?ref=c7b6ebdf7c0acf2382696988c09902beb91f4082", "patch": "@@ -79,7 +79,7 @@ fn compute_implied_outlives_bounds<'tcx>(\n         // implied bounds in some cases, mostly when dealing with projections.\n         fulfill_cx.register_predicate_obligations(\n             infcx,\n-            obligations.iter().filter(|o| o.predicate.has_infer_types_or_consts()).cloned(),\n+            obligations.iter().filter(|o| o.predicate.has_non_region_infer()).cloned(),\n         );\n \n         // From the full set of obligations, just filter down to the"}, {"sha": "e057bb668250192a2999a9b1070634b0ac61b7ae", "filename": "compiler/rustc_ty_utils/src/consts.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs?ref=c7b6ebdf7c0acf2382696988c09902beb91f4082", "patch": "@@ -135,30 +135,30 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n \n         impl<'a, 'tcx> IsThirPolymorphic<'a, 'tcx> {\n             fn expr_is_poly(&mut self, expr: &thir::Expr<'tcx>) -> bool {\n-                if expr.ty.has_param_types_or_consts() {\n+                if expr.ty.has_non_region_param() {\n                     return true;\n                 }\n \n                 match expr.kind {\n-                    thir::ExprKind::NamedConst { substs, .. } => substs.has_param_types_or_consts(),\n+                    thir::ExprKind::NamedConst { substs, .. } => substs.has_non_region_param(),\n                     thir::ExprKind::ConstParam { .. } => true,\n                     thir::ExprKind::Repeat { value, count } => {\n                         self.visit_expr(&self.thir()[value]);\n-                        count.has_param_types_or_consts()\n+                        count.has_non_region_param()\n                     }\n                     _ => false,\n                 }\n             }\n \n             fn pat_is_poly(&mut self, pat: &thir::Pat<'tcx>) -> bool {\n-                if pat.ty.has_param_types_or_consts() {\n+                if pat.ty.has_non_region_param() {\n                     return true;\n                 }\n \n                 match pat.kind {\n-                    thir::PatKind::Constant { value } => value.has_param_types_or_consts(),\n+                    thir::PatKind::Constant { value } => value.has_non_region_param(),\n                     thir::PatKind::Range(box thir::PatRange { lo, hi, .. }) => {\n-                        lo.has_param_types_or_consts() || hi.has_param_types_or_consts()\n+                        lo.has_non_region_param() || hi.has_non_region_param()\n                     }\n                     _ => false,\n                 }"}, {"sha": "345911f4309ae49286b416518dc8de3980038c41", "filename": "compiler/rustc_ty_utils/src/layout.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7b6ebdf7c0acf2382696988c09902beb91f4082/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs?ref=c7b6ebdf7c0acf2382696988c09902beb91f4082", "patch": "@@ -351,7 +351,7 @@ fn layout_of_uncached<'tcx>(\n     let univariant = |fields: &[TyAndLayout<'_>], repr: &ReprOptions, kind| {\n         Ok(tcx.intern_layout(univariant_uninterned(cx, ty, fields, repr, kind)?))\n     };\n-    debug_assert!(!ty.has_infer_types_or_consts());\n+    debug_assert!(!ty.has_non_region_infer());\n \n     Ok(match *ty.kind() {\n         // Basic scalars.\n@@ -1688,7 +1688,7 @@ fn record_layout_for_printing_outlined<'tcx>(\n     // Ignore layouts that are done with non-empty environments or\n     // non-monomorphic layouts, as the user only wants to see the stuff\n     // resulting from the final codegen session.\n-    if layout.ty.has_param_types_or_consts() || !cx.param_env.caller_bounds().is_empty() {\n+    if layout.ty.has_non_region_param() || !cx.param_env.caller_bounds().is_empty() {\n         return;\n     }\n "}, {"sha": "f0d5ed6f594bdd601c84b7a8fd4fa1f5084d88a5", "filename": "src/tools/clippy/clippy_lints/src/dereference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7b6ebdf7c0acf2382696988c09902beb91f4082/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7b6ebdf7c0acf2382696988c09902beb91f4082/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs?ref=c7b6ebdf7c0acf2382696988c09902beb91f4082", "patch": "@@ -1238,7 +1238,7 @@ fn ty_auto_deref_stability<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, precedenc\n             ty::Adt(..) if ty.has_placeholders() || ty.has_opaque_types() => {\n                 Position::ReborrowStable(precedence).into()\n             },\n-            ty::Adt(_, substs) if substs.has_param_types_or_consts() => {\n+            ty::Adt(_, substs) if substs.has_non_region_param() => {\n                 TyPosition::new_deref_stable_for_result(precedence, ty)\n             },\n             ty::Bool"}]}