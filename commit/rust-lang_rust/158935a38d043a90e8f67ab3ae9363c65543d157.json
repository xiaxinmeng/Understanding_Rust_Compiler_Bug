{"sha": "158935a38d043a90e8f67ab3ae9363c65543d157", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1ODkzNWEzOGQwNDNhOTBlOGY2N2FiM2FlOTM2M2M2NTU0M2QxNTc=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-05-21T13:59:38Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-05-21T13:59:58Z"}, "message": "refactored Option usage and fn argument types, improved formatting", "tree": {"sha": "8c6d8bbf460c234bc6ecade02646bbdf0c003dfe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c6d8bbf460c234bc6ecade02646bbdf0c003dfe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/158935a38d043a90e8f67ab3ae9363c65543d157", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/158935a38d043a90e8f67ab3ae9363c65543d157", "html_url": "https://github.com/rust-lang/rust/commit/158935a38d043a90e8f67ab3ae9363c65543d157", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/158935a38d043a90e8f67ab3ae9363c65543d157/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b1287f017beac4609486a24fb0cc8c02d63c8ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b1287f017beac4609486a24fb0cc8c02d63c8ed", "html_url": "https://github.com/rust-lang/rust/commit/5b1287f017beac4609486a24fb0cc8c02d63c8ed"}], "stats": {"total": 190, "additions": 112, "deletions": 78}, "files": [{"sha": "d84da654eb45bc1250b608445e0cbc92f2337a5b", "filename": "src/bit_mask.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/158935a38d043a90e8f67ab3ae9363c65543d157/src%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158935a38d043a90e8f67ab3ae9363c65543d157/src%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbit_mask.rs?ref=158935a38d043a90e8f67ab3ae9363c65543d157", "patch": "@@ -49,13 +49,11 @@ impl LintPass for BitMask {\n     fn check_expr(&mut self, cx: &Context, e: &Expr) {\n         if let ExprBinary(ref cmp, ref left, ref right) = e.node {\n \t\t\tif is_comparison_binop(cmp.node) {\n-\t\t\t\tlet cmp_opt = fetch_int_literal(cx, right);\n-\t\t\t\tif cmp_opt.is_some() {\n-\t\t\t\t\tcheck_compare(cx, left, cmp.node, cmp_opt.unwrap(), &e.span);\n-\t\t\t\t} else {\n-\t\t\t\t\tfetch_int_literal(cx, left).map(|cmp_val| \n-\t\t\t\t\t\tcheck_compare(cx, right, invert_cmp(cmp.node), cmp_val, &e.span));\n-\t\t\t\t}\n+\t\t\t\tfetch_int_literal(cx, right).map(|cmp_opt| \n+\t\t\t\t\tcheck_compare(cx, left, cmp.node, cmp_opt, &e.span))\n+\t\t\t\t\t.unwrap_or_else(|| fetch_int_literal(cx, left).map(|cmp_val| \n+\t\t\t\t\t\tcheck_compare(cx, right, invert_cmp(cmp.node), cmp_val,\n+\t\t\t\t\t\t &e.span)).unwrap_or(()))\n \t\t\t}\n \t\t}\n     }"}, {"sha": "0223820447d2b38b6073a9730d7dc98a8cbf6125", "filename": "src/eq_op.rs", "status": "modified", "additions": 85, "deletions": 50, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/158935a38d043a90e8f67ab3ae9363c65543d157/src%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158935a38d043a90e8f67ab3ae9363c65543d157/src%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feq_op.rs?ref=158935a38d043a90e8f67ab3ae9363c65543d157", "patch": "@@ -21,40 +21,49 @@ impl LintPass for EqOp {\n     fn check_expr(&mut self, cx: &Context, e: &Expr) {\n         if let ExprBinary(ref op, ref left, ref right) = e.node {\n             if is_cmp_or_bit(op) && is_exp_equal(left, right) {\n-                cx.span_lint(EQ_OP, e.span, &format!(\"equal expressions as operands to {}\", ast_util::binop_to_string(op.node)));\n+                cx.span_lint(EQ_OP, e.span, &format!(\n+\t\t\t\t\t\"equal expressions as operands to {}\", \n+\t\t\t\t\t\tast_util::binop_to_string(op.node)));\n             }\n         }\n     }\n }\n \n fn is_exp_equal(left : &Expr, right : &Expr) -> bool {\n \tmatch (&left.node, &right.node) {\n-\t\t(&ExprBinary(ref lop, ref ll, ref lr), &ExprBinary(ref rop, ref rl, ref rr)) => \n+\t\t(&ExprBinary(ref lop, ref ll, ref lr), \n+\t\t\t\t&ExprBinary(ref rop, ref rl, ref rr)) => \n \t\t\tlop.node == rop.node && is_exp_equal(ll, rl) && is_exp_equal(lr, rr),\n \t\t(&ExprBox(ref lpl, ref lboxedpl), &ExprBox(ref rpl, ref rboxedpl)) => \n-\t\t\tboth(lpl, rpl, |l, r| is_exp_equal(l, r)) && is_exp_equal(lboxedpl, rboxedpl),\n+\t\t\tboth(lpl, rpl, |l, r| is_exp_equal(l, r)) && \n+\t\t\t\tis_exp_equal(lboxedpl, rboxedpl),\n \t\t(&ExprCall(ref lcallee, ref largs), &ExprCall(ref rcallee, ref rargs)) => \n-\t\t\tis_exp_equal(lcallee, rcallee) && is_exp_vec_equal(largs, rargs),\n+\t\t\tis_exp_equal(lcallee, rcallee) && is_exps_equal(largs, rargs),\n \t\t(&ExprCast(ref lcast, ref lty), &ExprCast(ref rcast, ref rty)) => \n \t\t\tis_ty_equal(lty, rty) && is_exp_equal(lcast, rcast),\n-\t\t(&ExprField(ref lfexp, ref lfident), &ExprField(ref rfexp, ref rfident)) => \n+\t\t(&ExprField(ref lfexp, ref lfident), \n+\t\t\t\t&ExprField(ref rfexp, ref rfident)) => \n \t\t\tlfident.node == rfident.node && is_exp_equal(lfexp, rfexp),\n \t\t(&ExprLit(ref llit), &ExprLit(ref rlit)) => llit.node == rlit.node,\n-\t\t(&ExprMethodCall(ref lident, ref lcty, ref lmargs), &ExprMethodCall(ref rident, ref rcty, ref rmargs)) => \n-\t\t\tlident.node == rident.node && is_ty_vec_equal(lcty, rcty) && is_exp_vec_equal(lmargs, rmargs),\n-\t\t(&ExprParen(ref lparen), &ExprParen(ref rparen)) => is_exp_equal(lparen, rparen),\n+\t\t(&ExprMethodCall(ref lident, ref lcty, ref lmargs), \n+\t\t\t\t&ExprMethodCall(ref rident, ref rcty, ref rmargs)) => \n+\t\t\tlident.node == rident.node && is_tys_equal(lcty, rcty) && \n+\t\t\t\tis_exps_equal(lmargs, rmargs),\n \t\t(&ExprParen(ref lparen), _) => is_exp_equal(lparen, right),\n \t\t(_, &ExprParen(ref rparen)) => is_exp_equal(left, rparen),\n-\t\t(&ExprPath(ref lqself, ref lsubpath), &ExprPath(ref rqself, ref rsubpath)) => \n-\t\t\tboth(lqself, rqself, |l, r| is_qself_equal(l, r)) && is_path_equal(lsubpath, rsubpath),\t\t\n-\t\t(&ExprTup(ref ltup), &ExprTup(ref rtup)) => is_exp_vec_equal(ltup, rtup),\n-\t\t(&ExprUnary(lunop, ref lparam), &ExprUnary(runop, ref rparam)) => lunop == runop && is_exp_equal(lparam, rparam), \n-\t\t(&ExprVec(ref lvec), &ExprVec(ref rvec)) => is_exp_vec_equal(lvec, rvec),\n+\t\t(&ExprPath(ref lqself, ref lsubpath), \n+\t\t\t\t&ExprPath(ref rqself, ref rsubpath)) => \n+\t\t\tboth(lqself, rqself, |l, r| is_qself_equal(l, r)) && \n+\t\t\t\tis_path_equal(lsubpath, rsubpath),\t\t\n+\t\t(&ExprTup(ref ltup), &ExprTup(ref rtup)) => is_exps_equal(ltup, rtup),\n+\t\t(&ExprUnary(lunop, ref lparam), &ExprUnary(runop, ref rparam)) => \n+\t\t\tlunop == runop && is_exp_equal(lparam, rparam), \n+\t\t(&ExprVec(ref lvec), &ExprVec(ref rvec)) => is_exps_equal(lvec, rvec),\n \t\t_ => false\n \t}\n }\n \n-fn is_exp_vec_equal(left : &Vec<P<Expr>>, right : &Vec<P<Expr>>) -> bool {\n+fn is_exps_equal(left : &[P<Expr>], right : &[P<Expr>]) -> bool {\n \tover(left, right, |l, r| is_exp_equal(l, r))\n }\n \n@@ -69,19 +78,25 @@ fn is_qself_equal(left : &QSelf, right : &QSelf) -> bool {\n fn is_ty_equal(left : &Ty, right : &Ty) -> bool {\n \tmatch (&left.node, &right.node) {\n \t(&TyVec(ref lvec), &TyVec(ref rvec)) => is_ty_equal(lvec, rvec),\n-\t(&TyFixedLengthVec(ref lfvty, ref lfvexp), &TyFixedLengthVec(ref rfvty, ref rfvexp)) => \n+\t(&TyFixedLengthVec(ref lfvty, ref lfvexp), \n+\t\t\t&TyFixedLengthVec(ref rfvty, ref rfvexp)) => \n \t\tis_ty_equal(lfvty, rfvty) && is_exp_equal(lfvexp, rfvexp),\n \t(&TyPtr(ref lmut), &TyPtr(ref rmut)) => is_mut_ty_equal(lmut, rmut),\n \t(&TyRptr(ref ltime, ref lrmut), &TyRptr(ref rtime, ref rrmut)) => \n \t\tboth(ltime, rtime, is_lifetime_equal) && is_mut_ty_equal(lrmut, rrmut),\n-\t(&TyBareFn(ref lbare), &TyBareFn(ref rbare)) => is_bare_fn_ty_equal(lbare, rbare),\n-    (&TyTup(ref ltup), &TyTup(ref rtup)) => is_ty_vec_equal(ltup, rtup),\n-\t(&TyPath(Option::None, ref lpath), &TyPath(Option::None, ref rpath)) => is_path_equal(lpath, rpath),\n-\t(&TyPath(Option::Some(ref lqself), ref lsubpath), &TyPath(Option::Some(ref rqself), ref rsubpath)) =>\n+\t(&TyBareFn(ref lbare), &TyBareFn(ref rbare)) => \n+\t\tis_bare_fn_ty_equal(lbare, rbare),\n+    (&TyTup(ref ltup), &TyTup(ref rtup)) => is_tys_equal(ltup, rtup),\n+\t(&TyPath(Option::None, ref lpath), &TyPath(Option::None, ref rpath)) => \n+\t\tis_path_equal(lpath, rpath),\n+\t(&TyPath(Option::Some(ref lqself), ref lsubpath),\n+\t\t\t&TyPath(Option::Some(ref rqself), ref rsubpath)) =>\n \t\tis_qself_equal(lqself, rqself) && is_path_equal(lsubpath, rsubpath),\n-    (&TyObjectSum(ref lsumty, ref lobounds), &TyObjectSum(ref rsumty, ref robounds)) => \n+    (&TyObjectSum(ref lsumty, ref lobounds), \n+\t\t\t&TyObjectSum(ref rsumty, ref robounds)) => \n \t\tis_ty_equal(lsumty, rsumty) && is_param_bounds_equal(lobounds, robounds),\n-\t(&TyPolyTraitRef(ref ltbounds), &TyPolyTraitRef(ref rtbounds)) => is_param_bounds_equal(ltbounds, rtbounds),\n+\t(&TyPolyTraitRef(ref ltbounds), &TyPolyTraitRef(ref rtbounds)) => \n+\t\tis_param_bounds_equal(ltbounds, rtbounds),\n     (&TyParen(ref lty), &TyParen(ref rty)) => is_ty_equal(lty, rty),\n     (&TyTypeof(ref lof), &TyTypeof(ref rof)) => is_exp_equal(lof, rof),\n \t(&TyInfer, &TyInfer) => true,\n@@ -91,15 +106,17 @@ fn is_ty_equal(left : &Ty, right : &Ty) -> bool {\n \n fn is_param_bound_equal(left : &TyParamBound, right : &TyParamBound) -> bool {\n \tmatch(left, right) {\n-\t(&TraitTyParamBound(ref lpoly, ref lmod), &TraitTyParamBound(ref rpoly, ref rmod)) => \n+\t(&TraitTyParamBound(ref lpoly, ref lmod), \n+\t\t\t&TraitTyParamBound(ref rpoly, ref rmod)) => \n \t\tlmod == rmod && is_poly_traitref_equal(lpoly, rpoly),\n-    (&RegionTyParamBound(ref ltime), &RegionTyParamBound(ref rtime)) => is_lifetime_equal(ltime, rtime),\n+    (&RegionTyParamBound(ref ltime), &RegionTyParamBound(ref rtime)) => \n+\t\tis_lifetime_equal(ltime, rtime),\n     _ => false\n \t}\n }\n \n fn is_poly_traitref_equal(left : &PolyTraitRef, right : &PolyTraitRef) -> bool {\n-\tis_lifetimedef_vec_equal(&left.bound_lifetimes, &right.bound_lifetimes) && \n+\tis_lifetimedefs_equal(&left.bound_lifetimes, &right.bound_lifetimes) && \n \t\tis_path_equal(&left.trait_ref.path, &right.trait_ref.path)\n }\n \n@@ -113,11 +130,12 @@ fn is_mut_ty_equal(left : &MutTy, right : &MutTy) -> bool {\n \n fn is_bare_fn_ty_equal(left : &BareFnTy, right : &BareFnTy) -> bool {\n \tleft.unsafety == right.unsafety && left.abi == right.abi && \n-\t\tis_lifetimedef_vec_equal(&left.lifetimes, &right.lifetimes) && is_fndecl_equal(&left.decl, &right.decl)\n+\t\tis_lifetimedefs_equal(&left.lifetimes, &right.lifetimes) && \n+\t\t\tis_fndecl_equal(&left.decl, &right.decl)\n } \n \n fn is_fndecl_equal(left : &P<FnDecl>, right : &P<FnDecl>) -> bool {\n-\tleft.variadic == right.variadic && is_arg_vec_equal(&left.inputs, &right.inputs) && \n+\tleft.variadic == right.variadic && is_args_equal(&left.inputs, &right.inputs) && \n \t\tis_fnret_ty_equal(&left.output, &right.output)\n }\n \n@@ -133,82 +151,99 @@ fn is_arg_equal(left : &Arg, right : &Arg) -> bool {\n \tis_ty_equal(&left.ty, &right.ty) && is_pat_equal(&left.pat, &right.pat)\n }\n \n-fn is_arg_vec_equal(left : &Vec<Arg>, right : &Vec<Arg>) -> bool {\n+fn is_args_equal(left : &[Arg], right : &[Arg]) -> bool {\n \tover(left, right, is_arg_equal)\n }\n \n fn is_pat_equal(left : &Pat, right : &Pat) -> bool {\n \tmatch(&left.node, &right.node) {\n \t(&PatWild(lwild), &PatWild(rwild)) => lwild == rwild,\n-\t(&PatIdent(ref lmode, ref lident, Option::None), &PatIdent(ref rmode, ref rident, Option::None)) =>\n+\t(&PatIdent(ref lmode, ref lident, Option::None), \n+\t\t\t&PatIdent(ref rmode, ref rident, Option::None)) =>\n \t\tlmode == rmode && is_ident_equal(&lident.node, &rident.node),\n \t(&PatIdent(ref lmode, ref lident, Option::Some(ref lpat)), \n \t\t\t&PatIdent(ref rmode, ref rident, Option::Some(ref rpat))) =>\n-\t\tlmode == rmode && is_ident_equal(&lident.node, &rident.node) && is_pat_equal(lpat, rpat),\n-    (&PatEnum(ref lpath, Option::None), &PatEnum(ref rpath, Option::None)) => is_path_equal(lpath, rpath),\n-    (&PatEnum(ref lpath, Option::Some(ref lenum)), &PatEnum(ref rpath, Option::Some(ref renum))) => \n-\t\tis_path_equal(lpath, rpath) && is_pat_vec_equal(lenum, renum),  \n-    (&PatStruct(ref lpath, ref lfieldpat, lbool), &PatStruct(ref rpath, ref rfieldpat, rbool)) =>\n-\t\tlbool == rbool && is_path_equal(lpath, rpath) && is_spanned_fieldpat_vec_equal(lfieldpat, rfieldpat),\n-    (&PatTup(ref ltup), &PatTup(ref rtup)) => is_pat_vec_equal(ltup, rtup), \n+\t\tlmode == rmode && is_ident_equal(&lident.node, &rident.node) && \n+\t\t\tis_pat_equal(lpat, rpat),\n+    (&PatEnum(ref lpath, Option::None), &PatEnum(ref rpath, Option::None)) => \n+\t\tis_path_equal(lpath, rpath),\n+    (&PatEnum(ref lpath, Option::Some(ref lenum)), \n+\t\t\t&PatEnum(ref rpath, Option::Some(ref renum))) => \n+\t\tis_path_equal(lpath, rpath) && is_pats_equal(lenum, renum),  \n+    (&PatStruct(ref lpath, ref lfieldpat, lbool), \n+\t\t\t&PatStruct(ref rpath, ref rfieldpat, rbool)) =>\n+\t\tlbool == rbool && is_path_equal(lpath, rpath) && \n+\t\t\tis_spanned_fieldpats_equal(lfieldpat, rfieldpat),\n+    (&PatTup(ref ltup), &PatTup(ref rtup)) => is_pats_equal(ltup, rtup), \n     (&PatBox(ref lboxed), &PatBox(ref rboxed)) => is_pat_equal(lboxed, rboxed),\n-    (&PatRegion(ref lpat, ref lmut), &PatRegion(ref rpat, ref rmut)) => is_pat_equal(lpat, rpat) && lmut == rmut,\n+    (&PatRegion(ref lpat, ref lmut), &PatRegion(ref rpat, ref rmut)) => \n+\t\tis_pat_equal(lpat, rpat) && lmut == rmut,\n \t(&PatLit(ref llit), &PatLit(ref rlit)) => is_exp_equal(llit, rlit),\n     (&PatRange(ref lfrom, ref lto), &PatRange(ref rfrom, ref rto)) =>\n \t\tis_exp_equal(lfrom, rfrom) && is_exp_equal(lto, rto),\n-    (&PatVec(ref lfirst, Option::None, ref llast), &PatVec(ref rfirst, Option::None, ref rlast)) =>\n-\t\tis_pat_vec_equal(lfirst, rfirst) && is_pat_vec_equal(llast, rlast),\n-    (&PatVec(ref lfirst, Option::Some(ref lpat), ref llast), &PatVec(ref rfirst, Option::Some(ref rpat), ref rlast)) =>\n-\t\tis_pat_vec_equal(lfirst, rfirst) && is_pat_equal(lpat, rpat) && is_pat_vec_equal(llast, rlast),\n+    (&PatVec(ref lfirst, Option::None, ref llast), \n+\t\t\t&PatVec(ref rfirst, Option::None, ref rlast)) =>\n+\t\tis_pats_equal(lfirst, rfirst) && is_pats_equal(llast, rlast),\n+    (&PatVec(ref lfirst, Option::Some(ref lpat), ref llast), \n+\t\t\t&PatVec(ref rfirst, Option::Some(ref rpat), ref rlast)) =>\n+\t\tis_pats_equal(lfirst, rfirst) && is_pat_equal(lpat, rpat) && \n+\t\t\tis_pats_equal(llast, rlast),\n \t// I don't match macros for now, the code is slow enough as is ;-)\n \t_ => false\n \t}\n }\n \n-fn is_spanned_fieldpat_vec_equal(left : &Vec<code::Spanned<FieldPat>>, right : &Vec<code::Spanned<FieldPat>>) -> bool {\n+fn is_spanned_fieldpats_equal(left : &[code::Spanned<FieldPat>], \n+\t\tright : &[code::Spanned<FieldPat>]) -> bool {\n \tover(left, right, |l, r| is_fieldpat_equal(&l.node, &r.node))\n }\n \n fn is_fieldpat_equal(left : &FieldPat, right : &FieldPat) -> bool {\n-\tleft.is_shorthand == right.is_shorthand && is_ident_equal(&left.ident, &right.ident) && \n+\tleft.is_shorthand == right.is_shorthand && \n+\t\tis_ident_equal(&left.ident, &right.ident) && \n \t\tis_pat_equal(&left.pat, &right.pat) \n }\n \n fn is_ident_equal(left : &Ident, right : &Ident) -> bool {\n \t&left.name == &right.name && left.ctxt == right.ctxt\n }\n \n-fn is_pat_vec_equal(left : &Vec<P<Pat>>, right : &Vec<P<Pat>>) -> bool {\n+fn is_pats_equal(left : &[P<Pat>], right : &[P<Pat>]) -> bool {\n \tover(left, right, |l, r| is_pat_equal(l, r))\n }\n \n fn is_lifetimedef_equal(left : &LifetimeDef, right : &LifetimeDef) -> bool {\n-\tis_lifetime_equal(&left.lifetime, &right.lifetime) && over(&left.bounds, &right.bounds, is_lifetime_equal)\n+\tis_lifetime_equal(&left.lifetime, &right.lifetime) && \n+\t\tover(&left.bounds, &right.bounds, is_lifetime_equal)\n }\n \n-fn is_lifetimedef_vec_equal(left : &Vec<LifetimeDef>, right : &Vec<LifetimeDef>) -> bool {\n+fn is_lifetimedefs_equal(left : &[LifetimeDef], right : &[LifetimeDef]) -> bool {\n \tover(left, right, is_lifetimedef_equal)\n }\n \n fn is_lifetime_equal(left : &Lifetime, right : &Lifetime) -> bool {\n \tleft.name == right.name\n }\n \n-fn is_ty_vec_equal(left : &Vec<P<Ty>>, right : &Vec<P<Ty>>) -> bool {\n+fn is_tys_equal(left : &[P<Ty>], right : &[P<Ty>]) -> bool {\n \tover(left, right, |l, r| is_ty_equal(l, r))\n }\n \n-fn over<X, F>(left: &[X], right: &[X], mut eq_fn: F) -> bool where F: FnMut(&X, &X) -> bool {\n+fn over<X, F>(left: &[X], right: &[X], mut eq_fn: F) -> bool \n+\t\twhere F: FnMut(&X, &X) -> bool {\n     left.len() == right.len() && left.iter().zip(right).all(|(x, y)| eq_fn(x, y))\n }\n \n-fn both<X, F>(l: &Option<X>, r: &Option<X>, mut eq_fn : F) -> bool where F: FnMut(&X, &X) -> bool {\n-\tif l.is_none() { r.is_none() } else { r.is_some() && eq_fn(l.as_ref().unwrap(), &r.as_ref().unwrap()) }\n+fn both<X, F>(l: &Option<X>, r: &Option<X>, mut eq_fn : F) -> bool \n+\t\twhere F: FnMut(&X, &X) -> bool {\n+\tl.as_ref().map(|x| r.as_ref().map(|y| eq_fn(x, y)).unwrap_or(false))\n+\t\t.unwrap_or_else(|| r.is_none())\n }\n \n fn is_cmp_or_bit(op : &BinOp) -> bool {\n     match op.node {\n-        BiEq | BiLt | BiLe | BiGt | BiGe | BiNe | BiAnd | BiOr | BiBitXor | BiBitAnd | BiBitOr => true,\n+        BiEq | BiLt | BiLe | BiGt | BiGe | BiNe | BiAnd | BiOr | BiBitXor | \n+\t\tBiBitAnd | BiBitOr => true,\n         _ => false\n     }\n }"}, {"sha": "c225c83bae27839ca27b370b195bfc7dc626c016", "filename": "src/misc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/158935a38d043a90e8f67ab3ae9363c65543d157/src%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158935a38d043a90e8f67ab3ae9363c65543d157/src%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmisc.rs?ref=158935a38d043a90e8f67ab3ae9363c65543d157", "patch": "@@ -239,7 +239,7 @@ fn check_to_owned(cx: &Context, expr: &Expr, other_span: Span) {\n \t\t\tlet name = ident.as_str();\n \t\t\tif name == \"to_string\" || name == \"to_owned\" {\n \t\t\t\tcx.span_lint(CMP_OWNED, expr.span, &format!(\n-\t\t\t\t\t\"this creates an owned instance just for comparison.\n+\t\t\t\t\t\"this creates an owned instance just for comparison. \\\n \t\t\t\t\tConsider using {}.as_slice() to compare without allocation\",\n \t\t\t\t\tcx.sess().codemap().span_to_snippet(other_span).unwrap_or(\n \t\t\t\t\t\t\"..\".to_string())))\n@@ -250,7 +250,7 @@ fn check_to_owned(cx: &Context, expr: &Expr, other_span: Span) {\n \t\t\t\tif path.segments.iter().zip([\"String\", \"from_str\"].iter()).all(\n \t\t\t\t\t\t|(seg, name)| &seg.identifier.as_str() == name) {\n \t\t\t\t\tcx.span_lint(CMP_OWNED, expr.span, &format!(\n-\t\t\t\t\t\"this creates an owned instance just for comparison.\n+\t\t\t\t\t\"this creates an owned instance just for comparison. \\\n \t\t\t\t\tConsider using {}.as_slice() to compare without allocation\",\n \t\t\t\t\tcx.sess().codemap().span_to_snippet(other_span).unwrap_or(\n \t\t\t\t\t\t\"..\".to_string())))"}, {"sha": "569f7b813444c936ce660bebdccfcabb47c62de1", "filename": "src/mut_mut.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/158935a38d043a90e8f67ab3ae9363c65543d157/src%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158935a38d043a90e8f67ab3ae9363c65543d157/src%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmut_mut.rs?ref=158935a38d043a90e8f67ab3ae9363c65543d157", "patch": "@@ -24,23 +24,24 @@ impl LintPass for MutMut {\n \t\t}\n \t\t\n \t\tunwrap_addr(expr).map(|e| {\n-\t\t\tif unwrap_addr(e).is_some() {\n+\t\t\tunwrap_addr(e).map(|_| {\n \t\t\t\tcx.span_lint(MUT_MUT, expr.span, \n \t\t\t\t\t\"Generally you want to avoid &mut &mut _ if possible.\")\n-\t\t\t} else {\n-\t\t\t\tif let ty_rptr(_, mt{ty: _, mutbl: MutMutable}) = expr_ty(cx.tcx, e).sty {\n+\t\t\t}).unwrap_or_else(|| {\n+\t\t\t\tif let ty_rptr(_, mt{ty: _, mutbl: MutMutable}) = \n+\t\t\t\t\t\texpr_ty(cx.tcx, e).sty {\n \t\t\t\t\tcx.span_lint(MUT_MUT, expr.span,\n-\t\t\t\t\t\t\"This expression mutably borrows a mutable reference. Consider reborrowing\")\n+\t\t\t\t\t\t\"This expression mutably borrows a mutable reference. \\\n+\t\t\t\t\t\tConsider reborrowing\")\n \t\t\t\t}\n-\t\t\t}\n-\t\t});\n+\t\t\t})\n+\t\t}).unwrap_or(())\n \t}\n \t\n \tfn check_ty(&mut self, cx: &Context, ty: &Ty) {\n-\t\tif unwrap_mut(ty).and_then(unwrap_mut).is_some() {\n-\t\t\tcx.span_lint(MUT_MUT, ty.span, \n-\t\t\t\t\"Generally you want to avoid &mut &mut _ if possible.\")\n-\t\t}\n+\t\tunwrap_mut(ty).and_then(unwrap_mut).map(|_| cx.span_lint(MUT_MUT, \n+\t\t\tty.span, \"Generally you want to avoid &mut &mut _ if possible.\")).\n+\t\t\tunwrap_or(())\n \t}\n }\n "}, {"sha": "f8f056e792816d8b78d84c08602387f93998d79d", "filename": "src/ptr_arg.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/158935a38d043a90e8f67ab3ae9363c65543d157/src%2Fptr_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158935a38d043a90e8f67ab3ae9363c65543d157/src%2Fptr_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fptr_arg.rs?ref=158935a38d043a90e8f67ab3ae9363c65543d157", "patch": "@@ -18,7 +18,6 @@ declare_lint! {\n     \"Warn on declaration of a &Vec- or &String-typed method argument\"\n }\n \n-\n #[derive(Copy,Clone)]\n pub struct PtrArg;\n \n@@ -58,12 +57,13 @@ fn check_fn(cx: &Context, decl: &FnDecl) {\n }\n \n fn check_ptr_subtype(cx: &Context, span: Span, ty: &Ty) {\n-\tif match_ty_unwrap(ty, &[\"Vec\"]).is_some() { \n-\t\tcx.span_lint(PTR_ARG, span, \n-\t\t\t\"Writing '&Vec<_>' instead of '&[_]' involves one more reference and cannot be used with non-vec-based slices. Consider changing the type to &[...]\");\n-\t} else { if match_ty_unwrap(ty, &[\"String\"]).is_some() {\n-\t\t\tcx.span_lint(PTR_ARG, span,\n-\t\t\t\t\"Writing '&String' instead of '&str' involves a new Object where a slices will do. Consider changing the type to &str\");\n-\t\t}\n-\t}\n+\tmatch_ty_unwrap(ty, &[\"Vec\"]).map(|_| { \n+\t\tcx.span_lint(PTR_ARG, span, \"Writing '&Vec<_>' instead of '&[_]' \\\n+\t\t\tinvolves one more reference and cannot be used with non-vec-based \\\n+\t\t\tslices. Consider changing the type to &[...]\")\n+\t}).unwrap_or_else(|| match_ty_unwrap(ty, &[\"String\"]).map(|_| {\n+\t\tcx.span_lint(PTR_ARG, span,\n+\t\t\t\"Writing '&String' instead of '&str' involves a new Object \\\n+\t\t\twhere a slices will do. Consider changing the type to &str\")\n+\t}).unwrap_or(()));\n }"}]}