{"sha": "c234009fddf3a58c486a06f1c40980149df114f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyMzQwMDlmZGRmM2E1OGM0ODZhMDZmMWM0MDk4MDE0OWRmMTE0Zjc=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-11-13T12:39:03Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-11-15T08:35:40Z"}, "message": "generalize reborrow-to-raw exception to a general redundancy check", "tree": {"sha": "61f31f041d43c81de39324b3bb5d42b8efc6da9e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/61f31f041d43c81de39324b3bb5d42b8efc6da9e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c234009fddf3a58c486a06f1c40980149df114f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c234009fddf3a58c486a06f1c40980149df114f7", "html_url": "https://github.com/rust-lang/rust/commit/c234009fddf3a58c486a06f1c40980149df114f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c234009fddf3a58c486a06f1c40980149df114f7/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ba8eb7608ea6520238a1d587197a795e9dc7147a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba8eb7608ea6520238a1d587197a795e9dc7147a", "html_url": "https://github.com/rust-lang/rust/commit/ba8eb7608ea6520238a1d587197a795e9dc7147a"}], "stats": {"total": 38, "additions": 17, "deletions": 21}, "files": [{"sha": "d2abfbc9dfcb336aec545d206296c80b1e0f2c63", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 17, "deletions": 21, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c234009fddf3a58c486a06f1c40980149df114f7/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c234009fddf3a58c486a06f1c40980149df114f7/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=c234009fddf3a58c486a06f1c40980149df114f7", "patch": "@@ -333,28 +333,24 @@ impl<'tcx> Stacks {\n         for stack in stacks.iter_mut(ptr.offset, size) {\n             // Access source `ptr`, create new ref.\n             let ptr_idx = stack.deref(ptr.tag, new_kind).map_err(EvalErrorKind::MachineError)?;\n-            if new_kind == RefKind::Raw {\n-                assert!(new_bor.is_shared());\n-                // Raw references do not get quite as many guarantees as the other kinds:\n-                // If we can deref the new tag already, and if that tag lives higher on\n-                // the stack than the one we come from, just use that.\n-                // IOW, we check if `new_bor` *already* is \"derived from\" `ptr.tag`.\n-                match (ptr_idx, stack.deref(new_bor, new_kind)) {\n-                    // If the new borrow works with the forzen item, or else if it lives\n-                    // above the old one in the stack, our job here is done.\n-                    (_, Ok(None)) => {\n-                        trace!(\"reborrow-to-raw on a frozen location is a NOP\");\n-                        continue\n-                    },\n-                    (Some(ptr_idx), Ok(Some(new_idx))) if new_idx >= ptr_idx => {\n-                        trace!(\"reborrow-to-raw is a NOP because the src ptr already got reborrowed-to-raw\");\n-                        continue\n-                    },\n-                    _ => {},\n-                }\n+            // If we can deref the new tag already, and if that tag lives higher on\n+            // the stack than the one we come from, just use that.\n+            // IOW, we check if `new_bor` *already* is \"derived from\" `ptr.tag`.\n+            // This also checks frozenness, if required.\n+            let bor_already_happened = match (ptr_idx, stack.deref(new_bor, new_kind)) {\n+                // If the new borrow works with the frozen item, or else if it lives\n+                // above the old one in the stack, our job here is done.\n+                (_, Ok(None)) => true,\n+                (Some(ptr_idx), Ok(Some(new_idx))) if new_idx >= ptr_idx => true,\n+                // Otherwise we need to create a new borrow.\n+                _ => false,\n+            };\n+            if bor_already_happened {\n+                assert!(new_bor.is_shared(), \"A unique reborrow can never be redundant\");\n+                trace!(\"Reborrow is a NOP\");\n+                continue;\n             }\n-            // Non-raw reborrows should behave exactly as if we also did a\n-            // read/write to the given location.\n+            // We need to do some actual work.\n             stack.access(ptr.tag, new_kind == RefKind::Unique)?;\n             stack.create(new_bor, new_kind);\n         }"}]}