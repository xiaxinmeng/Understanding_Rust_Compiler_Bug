{"sha": "a3d9cac69057db700c4f6e01b84dc59529ea6dfd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzZDljYWM2OTA1N2RiNzAwYzRmNmUwMWI4NGRjNTk1MjllYTZkZmQ=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-05-15T21:09:18Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-05-21T15:48:34Z"}, "message": "Fix another panic", "tree": {"sha": "5918958fbf6799a9403f4f11340e32ea6714f95d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5918958fbf6799a9403f4f11340e32ea6714f95d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a3d9cac69057db700c4f6e01b84dc59529ea6dfd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a3d9cac69057db700c4f6e01b84dc59529ea6dfd", "html_url": "https://github.com/rust-lang/rust/commit/a3d9cac69057db700c4f6e01b84dc59529ea6dfd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a3d9cac69057db700c4f6e01b84dc59529ea6dfd/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29266ada0469440d69fd3f3532121a7e8ff5379d", "url": "https://api.github.com/repos/rust-lang/rust/commits/29266ada0469440d69fd3f3532121a7e8ff5379d", "html_url": "https://github.com/rust-lang/rust/commit/29266ada0469440d69fd3f3532121a7e8ff5379d"}], "stats": {"total": 32, "additions": 15, "deletions": 17}, "files": [{"sha": "93cd54f0d96b8d6a6982812ca8dde7865954bab1", "filename": "crates/hir_ty/src/infer/unify.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a3d9cac69057db700c4f6e01b84dc59529ea6dfd/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d9cac69057db700c4f6e01b84dc59529ea6dfd/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs?ref=a3d9cac69057db700c4f6e01b84dc59529ea6dfd", "patch": "@@ -3,7 +3,8 @@\n use std::{borrow::Cow, fmt, sync::Arc};\n \n use chalk_ir::{\n-    cast::Cast, fold::Fold, interner::HasInterner, FloatTy, IntTy, TyVariableKind, UniverseIndex,\n+    cast::Cast, fold::Fold, interner::HasInterner, zip::Zip, FloatTy, IntTy, TyVariableKind,\n+    UniverseIndex,\n };\n use chalk_solve::infer::ParameterEnaVariableExt;\n use ena::unify::UnifyKey;\n@@ -43,10 +44,7 @@ where\n \n impl<T: HasInterner<Interner = Interner>> Canonicalized<T> {\n     pub(super) fn decanonicalize_ty(&self, ty: Ty) -> Ty {\n-        crate::fold_free_vars(ty, |bound, _binders| {\n-            let var = self.free_vars[bound.index].clone();\n-            var.assert_ty_ref(&Interner).clone()\n-        })\n+        chalk_ir::Substitute::apply(&self.free_vars, ty, &Interner)\n     }\n \n     pub(super) fn apply_solution(\n@@ -72,16 +70,16 @@ impl<T: HasInterner<Interner = Interner>> Canonicalized<T> {\n                 _ => panic!(\"const variable in solution\"),\n             }),\n         );\n-        for (i, ty) in solution.value.iter(&Interner).enumerate() {\n-            // FIXME: deal with non-type vars here -- the only problematic part is the normalization\n-            // and maybe we don't need that with lazy normalization?\n+        for (i, v) in solution.value.iter(&Interner).enumerate() {\n             let var = self.free_vars[i].clone();\n-            // eagerly replace projections in the type; we may be getting types\n-            // e.g. from where clauses where this hasn't happened yet\n-            let ty = ctx.normalize_associated_types_in(\n-                new_vars.apply(ty.assert_ty_ref(&Interner).clone(), &Interner),\n-            );\n-            ctx.table.unify(var.assert_ty_ref(&Interner), &ty);\n+            if let Some(ty) = v.ty(&Interner) {\n+                // eagerly replace projections in the type; we may be getting types\n+                // e.g. from where clauses where this hasn't happened yet\n+                let ty = ctx.normalize_associated_types_in(new_vars.apply(ty.clone(), &Interner));\n+                ctx.table.unify(var.assert_ty_ref(&Interner), &ty);\n+            } else {\n+                let _ = ctx.table.unify_inner(&var, &new_vars.apply(v.clone(), &Interner));\n+            }\n         }\n     }\n }\n@@ -288,14 +286,14 @@ impl<'a> InferenceTable<'a> {\n \n     /// Unify two types and return new trait goals arising from it, so the\n     /// caller needs to deal with them.\n-    pub(crate) fn unify_inner(&mut self, ty1: &Ty, ty2: &Ty) -> InferResult {\n+    pub(crate) fn unify_inner<T: Zip<Interner>>(&mut self, t1: &T, t2: &T) -> InferResult {\n         match self.var_unification_table.relate(\n             &Interner,\n             &self.db,\n             &self.trait_env.env,\n             chalk_ir::Variance::Invariant,\n-            ty1,\n-            ty2,\n+            t1,\n+            t2,\n         ) {\n             Ok(_result) => {\n                 // TODO deal with new goals"}]}