{"sha": "638dcac092c130aa817d3ca94d3ed743a6d42938", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzOGRjYWMwOTJjMTMwYWE4MTdkM2NhOTRkM2VkNzQzYTZkNDI5Mzg=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-03-23T15:50:36Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-03-23T15:54:21Z"}, "message": "Make more use of the HIR in rename::rename_to_self", "tree": {"sha": "18c813e15a53f96d8a10527ca0c3263b50307879", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/18c813e15a53f96d8a10527ca0c3263b50307879"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/638dcac092c130aa817d3ca94d3ed743a6d42938", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/638dcac092c130aa817d3ca94d3ed743a6d42938", "html_url": "https://github.com/rust-lang/rust/commit/638dcac092c130aa817d3ca94d3ed743a6d42938", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/638dcac092c130aa817d3ca94d3ed743a6d42938/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0469280c8affdc6bdb96ad5bf02073725c5cfd06", "url": "https://api.github.com/repos/rust-lang/rust/commits/0469280c8affdc6bdb96ad5bf02073725c5cfd06", "html_url": "https://github.com/rust-lang/rust/commit/0469280c8affdc6bdb96ad5bf02073725c5cfd06"}], "stats": {"total": 92, "additions": 48, "deletions": 44}, "files": [{"sha": "bdc1ad852c224945d77d17d90b4c2e4f926ab66a", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/638dcac092c130aa817d3ca94d3ed743a6d42938/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/638dcac092c130aa817d3ca94d3ed743a6d42938/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=638dcac092c130aa817d3ca94d3ed743a6d42938", "patch": "@@ -852,6 +852,7 @@ impl Function {\n             })\n             .collect()\n     }\n+\n     pub fn method_params(self, db: &dyn HirDatabase) -> Option<Vec<Param>> {\n         if self.self_param(db).is_none() {\n             return None;\n@@ -909,7 +910,7 @@ impl From<hir_ty::Mutability> for Access {\n     }\n }\n \n-#[derive(Debug)]\n+#[derive(Clone, Debug)]\n pub struct Param {\n     func: Function,\n     /// The index in parameter list, including self parameter.\n@@ -922,13 +923,25 @@ impl Param {\n         &self.ty\n     }\n \n+    pub fn as_local(&self, db: &dyn HirDatabase) -> Local {\n+        let parent = DefWithBodyId::FunctionId(self.func.into());\n+        let body = db.body(parent);\n+        Local { parent, pat_id: body.params[self.idx] }\n+    }\n+\n     pub fn pattern_source(&self, db: &dyn HirDatabase) -> Option<ast::Pat> {\n-        let params = self.func.source(db)?.value.param_list()?;\n+        self.source(db).and_then(|p| p.value.pat())\n+    }\n+\n+    pub fn source(&self, db: &dyn HirDatabase) -> Option<InFile<ast::Param>> {\n+        let InFile { file_id, value } = self.func.source(db)?;\n+        let params = value.param_list()?;\n         if params.self_param().is_some() {\n-            params.params().nth(self.idx.checked_sub(1)?)?.pat()\n+            params.params().nth(self.idx.checked_sub(1)?)\n         } else {\n-            params.params().nth(self.idx)?.pat()\n+            params.params().nth(self.idx)\n         }\n+        .map(|value| InFile { file_id, value })\n     }\n }\n "}, {"sha": "b1ca6d50f1d4081df4eb542b1659139936ee1f26", "filename": "crates/ide/src/references/rename.rs", "status": "modified", "additions": 31, "deletions": 40, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/638dcac092c130aa817d3ca94d3ed743a6d42938/crates%2Fide%2Fsrc%2Freferences%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/638dcac092c130aa817d3ca94d3ed743a6d42938/crates%2Fide%2Fsrc%2Freferences%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences%2Frename.rs?ref=638dcac092c130aa817d3ca94d3ed743a6d42938", "patch": "@@ -1,8 +1,11 @@\n-//! FIXME: write short doc here\n+//! Renaming functionality\n+//!\n+//! All reference and file rename requests go through here where the corresponding [`SourceChange`]s\n+//! will be calculated.\n use std::fmt::{self, Display};\n \n use either::Either;\n-use hir::{HasSource, InFile, Module, ModuleDef, ModuleSource, Semantics};\n+use hir::{AsAssocItem, InFile, Module, ModuleDef, ModuleSource, Semantics};\n use ide_db::{\n     base_db::{AnchoredPathBuf, FileId},\n     defs::{Definition, NameClass, NameRefClass},\n@@ -196,7 +199,7 @@ fn rename_mod(\n                 file_id,\n                 TextEdit::replace(name.syntax().text_range(), new_name.to_string()),\n             ),\n-            _ => unreachable!(),\n+            _ => never!(\"Module source node is missing a name\"),\n         }\n     }\n     let def = Definition::ModuleDef(ModuleDef::Module(module));\n@@ -275,46 +278,32 @@ fn rename_to_self(sema: &Semantics<RootDatabase>, local: hir::Local) -> RenameRe\n \n     let fn_def = match local.parent(sema.db) {\n         hir::DefWithBody::Function(func) => func,\n-        _ => bail!(\"Cannot rename non-param local to self\"),\n+        _ => bail!(\"Cannot rename local to self outside of function\"),\n     };\n \n-    // FIXME: reimplement this on the hir instead\n-    // as of the time of this writing params in hir don't keep their names\n-    let fn_ast = fn_def\n-        .source(sema.db)\n-        .ok_or_else(|| format_err!(\"Cannot rename non-param local to self\"))?\n-        .value;\n-\n-    let first_param_range = fn_ast\n-        .param_list()\n-        .and_then(|p| p.params().next())\n-        .ok_or_else(|| format_err!(\"Method has no parameters\"))?\n-        .syntax()\n-        .text_range();\n-    let InFile { file_id, value: local_source } = local.source(sema.db);\n-    match local_source {\n-        either::Either::Left(pat)\n-            if !first_param_range.contains_range(pat.syntax().text_range()) =>\n-        {\n-            bail!(\"Only the first parameter can be self\");\n-        }\n-        _ => (),\n-    }\n-\n-    let impl_block = fn_ast\n-        .syntax()\n-        .ancestors()\n-        .find_map(|node| ast::Impl::cast(node))\n-        .and_then(|def| sema.to_def(&def))\n-        .ok_or_else(|| format_err!(\"No impl block found for function\"))?;\n-    if fn_def.self_param(sema.db).is_some() {\n+    if let Some(_) = fn_def.self_param(sema.db) {\n         bail!(\"Method already has a self parameter\");\n     }\n \n     let params = fn_def.assoc_fn_params(sema.db);\n-    let first_param = params.first().ok_or_else(|| format_err!(\"Method has no parameters\"))?;\n+    let first_param = params\n+        .first()\n+        .ok_or_else(|| format_err!(\"Cannot rename local to self unless it is a parameter\"))?;\n+    if first_param.as_local(sema.db) != local {\n+        bail!(\"Only the first parameter may be renamed to self\");\n+    }\n+\n+    let assoc_item = fn_def\n+        .as_assoc_item(sema.db)\n+        .ok_or_else(|| format_err!(\"Cannot rename parameter to self for free function\"))?;\n+    let impl_ = match assoc_item.container(sema.db) {\n+        hir::AssocItemContainer::Trait(_) => {\n+            bail!(\"Cannot rename parameter to self for trait functions\");\n+        }\n+        hir::AssocItemContainer::Impl(impl_) => impl_,\n+    };\n     let first_param_ty = first_param.ty();\n-    let impl_ty = impl_block.target_ty(sema.db);\n+    let impl_ty = impl_.target_ty(sema.db);\n     let (ty, self_param) = if impl_ty.remove_ref().is_some() {\n         // if the impl is a ref to the type we can just match the `&T` with self directly\n         (first_param_ty.clone(), \"self\")\n@@ -328,6 +317,9 @@ fn rename_to_self(sema: &Semantics<RootDatabase>, local: hir::Local) -> RenameRe\n         bail!(\"Parameter type differs from impl block type\");\n     }\n \n+    let InFile { file_id, value: param_source } =\n+        first_param.source(sema.db).ok_or_else(|| format_err!(\"No source for parameter found\"))?;\n+\n     let def = Definition::Local(local);\n     let usages = def.usages(sema).all();\n     let mut source_change = SourceChange::default();\n@@ -336,9 +328,8 @@ fn rename_to_self(sema: &Semantics<RootDatabase>, local: hir::Local) -> RenameRe\n     }));\n     source_change.insert_source_edit(\n         file_id.original_file(sema.db),\n-        TextEdit::replace(first_param_range, String::from(self_param)),\n+        TextEdit::replace(param_source.syntax().text_range(), String::from(self_param)),\n     );\n-\n     Ok(source_change)\n }\n \n@@ -1361,7 +1352,7 @@ fn f(foo$0: &mut Foo) -> i32 {\n     foo.i\n }\n \"#,\n-            \"error: No impl block found for function\",\n+            \"error: Cannot rename parameter to self for free function\",\n         );\n         check(\n             \"self\",\n@@ -1391,7 +1382,7 @@ impl Foo {\n     }\n }\n \"#,\n-            \"error: Only the first parameter can be self\",\n+            \"error: Only the first parameter may be renamed to self\",\n         );\n     }\n "}]}