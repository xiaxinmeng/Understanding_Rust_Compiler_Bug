{"sha": "a7159be24a9c81517a46e09c7ff62cadc72759b6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3MTU5YmUyNGE5YzgxNTE3YTQ2ZTA5YzdmZjYyY2FkYzcyNzU5YjY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-12-12T00:41:43Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-12-12T02:11:14Z"}, "message": "Remove old deriving", "tree": {"sha": "8d87181be697125f50b873f33a3efe065e104933", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8d87181be697125f50b873f33a3efe065e104933"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a7159be24a9c81517a46e09c7ff62cadc72759b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a7159be24a9c81517a46e09c7ff62cadc72759b6", "html_url": "https://github.com/rust-lang/rust/commit/a7159be24a9c81517a46e09c7ff62cadc72759b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a7159be24a9c81517a46e09c7ff62cadc72759b6/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6439f2d54645915ce57f4c229811719e8e498151", "url": "https://api.github.com/repos/rust-lang/rust/commits/6439f2d54645915ce57f4c229811719e8e498151", "html_url": "https://github.com/rust-lang/rust/commit/6439f2d54645915ce57f4c229811719e8e498151"}], "stats": {"total": 1319, "additions": 17, "deletions": 1302}, "files": [{"sha": "cf6207dee588a4d4cd39415b7cb2f92559c13519", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/a7159be24a9c81517a46e09c7ff62cadc72759b6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7159be24a9c81517a46e09c7ff62cadc72759b6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=a7159be24a9c81517a46e09c7ff62cadc72759b6", "patch": "@@ -52,7 +52,6 @@ use util::ppaux;\n use util::ppaux::{ty_to_str, ty_to_short_str};\n use syntax::diagnostic::expect;\n use util::common::indenter;\n-use ty::DerivedMethodInfo;\n \n use build::*;\n use shape::*;\n@@ -1878,10 +1877,6 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n         }\n       }\n       ast::item_impl(tps, _, _, ms) => {\n-        // This call will do nothing if there are no derivable methods.\n-        deriving::trans_deriving_impl(ccx, *path, item.ident, tps,\n-                                      item.id);\n-\n         meth::trans_impl(ccx, *path, item.ident, ms, tps, None,\n                          item.id);\n       }\n@@ -2112,20 +2107,7 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n     match ccx.item_vals.find(id) {\n       Some(v) => v,\n       None => {\n-        // First, check whether we need to automatically generate a method\n-        // via the deriving mechanism.\n-        match ccx.tcx.automatically_derived_methods.find(local_def(id)) {\n-            None => {}  // Continue.\n-            Some(ref derived_method_info) => {\n-                // XXX: Mark as internal if necessary.\n-                let llfn = register_deriving_method(\n-                    ccx, id, derived_method_info);\n-                ccx.item_vals.insert(id, llfn);\n-                return llfn;\n-            }\n-        }\n \n-        // Failing that, look for an item.\n         let mut exprt = false;\n         let val = match ccx.tcx.items.get(id) {\n           ast_map::node_item(i, pth) => {\n@@ -2273,34 +2255,6 @@ fn register_method(ccx: @crate_ctxt, id: ast::node_id, pth: @ast_map::path,\n     llfn\n }\n \n-fn register_deriving_method(ccx: @crate_ctxt,\n-                            id: ast::node_id,\n-                            derived_method_info: &DerivedMethodInfo) ->\n-                            ValueRef {\n-    // Find the path of the item.\n-    let path, span;\n-    match ccx.tcx.items.get(derived_method_info.containing_impl.node) {\n-        ast_map::node_item(item, found_path) => {\n-            path = found_path;\n-            span = item.span;\n-        }\n-        _ => {\n-            ccx.tcx.sess.bug(~\"derived method info containing impl didn't \\\n-                               refer to an item\");\n-        }\n-    }\n-\n-    let path = vec::append(*path, ~[\n-        ast_map::path_mod(\n-            ccx.sess.parse_sess.interner.intern(@fmt!(\"__derived%d__\", id))),\n-        ast_map::path_name(derived_method_info.method_info.ident)\n-    ]);\n-    let mty = ty::lookup_item_type(ccx.tcx, local_def(id)).ty;\n-    let llfn = register_fn_full(ccx, span, path, id, mty);\n-    // XXX: Inline hint.\n-    llfn\n-}\n-\n // The constant translation pass.\n fn trans_constant(ccx: @crate_ctxt, it: @ast::item) {\n     let _icx = ccx.insn_ctxt(\"trans_constant\");"}, {"sha": "50bf0cf39c889a59e03dcf23293bd7f5027c7abb", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7159be24a9c81517a46e09c7ff62cadc72759b6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7159be24a9c81517a46e09c7ff62cadc72759b6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=a7159be24a9c81517a46e09c7ff62cadc72759b6", "patch": "@@ -223,8 +223,6 @@ fn trans_fn_ref_with_vtables(\n     let must_monomorphise;\n     if type_params.len() > 0 || opt_impl_did.is_some() {\n         must_monomorphise = true;\n-    } else if ccx.tcx.automatically_derived_methods.contains_key(def_id) {\n-        must_monomorphise = false;\n     } else if def_id.crate == ast::local_crate {\n         let map_node = session::expect(\n             ccx.sess,"}, {"sha": "1259ab6ccf7412a2813eb004dfdba41f5d15726b", "filename": "src/librustc/middle/trans/deriving.rs", "status": "removed", "additions": 0, "deletions": 473, "changes": 473, "blob_url": "https://github.com/rust-lang/rust/blob/6439f2d54645915ce57f4c229811719e8e498151/src%2Flibrustc%2Fmiddle%2Ftrans%2Fderiving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6439f2d54645915ce57f4c229811719e8e498151/src%2Flibrustc%2Fmiddle%2Ftrans%2Fderiving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fderiving.rs?ref=6439f2d54645915ce57f4c229811719e8e498151", "patch": "@@ -1,473 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Translation of automatically-derived trait implementations. This handles\n-// enums and structs only; other types cannot be automatically derived.\n-\n-use lib::llvm::llvm::{LLVMCountParams, LLVMGetParam};\n-use middle::trans::base::{GEP_enum, finish_fn, get_insn_ctxt, get_item_val};\n-use middle::trans::base::{new_fn_ctxt, sub_block, top_scope_block};\n-use middle::trans::base;\n-use middle::trans::build::{AddCase, Br, CondBr, GEPi, Load, PointerCast};\n-use middle::trans::build::{Store, Switch, Unreachable, ValueRef};\n-use middle::trans::callee;\n-use middle::trans::callee::{ArgVals, Callee, DontAutorefArg, Method};\n-use middle::trans::callee::{MethodData};\n-use middle::trans::common;\n-use middle::trans::common::{C_bool, C_int, T_ptr, block, crate_ctxt};\n-use middle::trans::common::{fn_ctxt};\n-use middle::trans::expr::SaveIn;\n-use middle::trans::type_of::type_of;\n-use middle::ty::{DerivedFieldInfo, re_static};\n-use middle::typeck::check::method;\n-use middle::typeck::method_static;\n-use syntax::ast;\n-use syntax::ast::{def_id, ident, node_id, ty_param};\n-use syntax::ast_map::path;\n-use syntax::ast_util;\n-use syntax::ast_util::local_def;\n-\n-use core::dvec::DVec;\n-use core::dvec;\n-use core::libc::c_uint;\n-\n-/// The kind of deriving method this is.\n-enum DerivingKind {\n-    BoolKind,   // fn f(&self, other: &other) -> bool\n-    UnitKind,   // fn f(&self) -> ()\n-}\n-\n-impl DerivingKind {\n-    static fn of_item(ccx: @crate_ctxt, method_did: ast::def_id)\n-                   -> DerivingKind {\n-        let item_type = ty::lookup_item_type(ccx.tcx, method_did).ty;\n-        match ty::get(item_type).sty {\n-            ty::ty_fn(ref f) => {\n-                match ty::get(f.sig.output).sty {\n-                    ty::ty_bool => BoolKind,\n-                    ty::ty_nil => UnitKind,\n-                    _ => {\n-                        // FIXME (#3957): Report this earlier.\n-                        ccx.tcx.sess.fatal(~\"attempt to automatically derive \\\n-                                             derive an implementation of a \\\n-                                             function returning something \\\n-                                             other than bool or ()\");\n-                    }\n-                }\n-            }\n-            _ => {\n-                ccx.tcx.sess.bug(~\"DerivingKind::of_item(): method def ID \\\n-                                   didn't have a function type\");\n-            }\n-        }\n-    }\n-}\n-\n-/// The main \"translation\" pass for the automatically-derived methods in\n-/// an impl. Generates code for monomorphic methods only. Other methods will\n-/// be generated when they are invoked with specific type parameters; see\n-/// `trans::base::lval_static_fn()` or `trans::base::monomorphic_fn()`.\n-pub fn trans_deriving_impl(ccx: @crate_ctxt,\n-                           _path: path,\n-                           _name: ident,\n-                           tps: ~[ty_param],\n-                           id: node_id) {\n-    let _icx = ccx.insn_ctxt(\"deriving::trans_deriving_impl\");\n-    if tps.len() > 0 { return; }\n-\n-    let impl_def_id = local_def(id);\n-    let self_ty = ty::lookup_item_type(ccx.tcx, impl_def_id);\n-\n-    match ccx.tcx.automatically_derived_methods_for_impl.find(impl_def_id) {\n-        Some(copy method_dids) => {\n-            for method_dids.each |method_did| {\n-                let kind = DerivingKind::of_item(ccx, *method_did);\n-                let llfn = get_item_val(ccx, method_did.node);\n-\n-                // Transform the self type as appropriate.\n-                let derived_method_info =\n-                    ccx.tcx.automatically_derived_methods.get(*method_did);\n-                let transformed_self_ty =\n-                    method::transform_self_type_for_method(\n-                        ccx.tcx,\n-                        Some(re_static),\n-                        self_ty.ty,\n-                        derived_method_info.method_info.self_type);\n-\n-                match ty::get(self_ty.ty).sty {\n-                    ty::ty_struct(*) => {\n-                        trans_deriving_struct_method(ccx,\n-                                                     llfn,\n-                                                     impl_def_id,\n-                                                     self_ty.ty,\n-                                                     transformed_self_ty,\n-                                                     kind);\n-                    }\n-                    ty::ty_enum(*) => {\n-                        trans_deriving_enum_method(ccx,\n-                                                   llfn,\n-                                                   impl_def_id,\n-                                                   self_ty.ty,\n-                                                   transformed_self_ty,\n-                                                   kind);\n-                    }\n-                    _ => {\n-                        ccx.tcx.sess.bug(~\"translation of non-struct \\\n-                                           deriving method\");\n-                    }\n-                }\n-            }\n-        }\n-        None => {}  // Nothing to do.\n-    }\n-}\n-\n-fn get_extra_params(llfn: ValueRef, kind: DerivingKind) -> ~[ValueRef] {\n-    let n_params = LLVMCountParams(llfn) as uint;\n-\n-    let initial_extra_param;\n-    match kind {\n-        BoolKind => initial_extra_param = 3,\n-        UnitKind => initial_extra_param = 2,\n-    }\n-\n-    let extra_params = DVec();\n-    for uint::range(initial_extra_param, n_params) |i| {\n-        extra_params.push(LLVMGetParam(llfn, i as c_uint));\n-    }\n-\n-    return dvec::unwrap(move extra_params);\n-}\n-\n-fn trans_deriving_struct_method(ccx: @crate_ctxt,\n-                                llfn: ValueRef,\n-                                impl_did: def_id,\n-                                self_ty: ty::t,\n-                                transformed_self_ty: ty::t,\n-                                kind: DerivingKind) {\n-    let _icx = ccx.insn_ctxt(\"trans_deriving_struct_method\");\n-    let fcx = new_fn_ctxt(ccx, ~[], llfn, None);\n-    let top_bcx = top_scope_block(fcx, None);\n-    let lltop = top_bcx.llbb;\n-    let mut bcx = top_bcx;\n-\n-    let llextraparams = get_extra_params(llfn, kind);\n-\n-    let lltransformedselfty = type_of(ccx, transformed_self_ty);\n-    let lltransformedselfval =\n-        PointerCast(bcx, fcx.llenv, T_ptr(lltransformedselfty));\n-    let llselfval = Load(bcx, lltransformedselfval);\n-\n-    // If there is an \"other\" value, then get it. The \"other\" value is the\n-    // value we're comparing against in the case of Eq and Ord.\n-    let llotherval_opt;\n-    match kind {\n-        BoolKind => llotherval_opt = Some(LLVMGetParam(llfn, 2)),\n-        UnitKind => llotherval_opt = None\n-    }\n-\n-    let struct_field_tys;\n-    match ty::get(self_ty).sty {\n-        ty::ty_struct(struct_id, ref struct_substs) => {\n-            struct_field_tys = ty::struct_fields(\n-                ccx.tcx, struct_id, struct_substs);\n-        }\n-        _ => {\n-            ccx.tcx.sess.bug(~\"passed non-struct to \\\n-                               trans_deriving_struct_method\");\n-        }\n-    }\n-\n-    // Iterate over every element of the struct.\n-    for ccx.tcx.deriving_struct_methods.get(impl_did).eachi\n-            |i, derived_method_info| {\n-        let llselfval = GEPi(bcx, llselfval, [0, 0, i]);\n-        let llselfallocaty = common::val_ty(llselfval);\n-        let llselfalloca = base::alloca(bcx, llselfallocaty);\n-        Store(bcx, llselfval, llselfalloca);\n-\n-        let llotherval_opt = llotherval_opt.map(\n-            |llotherval| GEPi(bcx, *llotherval, [0, 0, i]));\n-\n-        let self_ty = struct_field_tys[i].mt.ty;\n-        bcx = call_substructure_method(bcx,\n-                                       derived_method_info,\n-                                       self_ty,\n-                                       llselfalloca,\n-                                       llotherval_opt,\n-                                       llextraparams);\n-\n-        // If this derived method is of boolean kind, return immediately if\n-        // the call to the substructure method returned false.\n-        match kind {\n-            BoolKind => {\n-                let next_block = sub_block(top_bcx, ~\"next\");\n-                let llcond = Load(bcx, fcx.llretptr);\n-                CondBr(bcx, llcond, next_block.llbb, fcx.llreturn);\n-                bcx = next_block;\n-            }\n-            UnitKind => {}  // Unconditionally continue.\n-        }\n-    }\n-\n-    // Store true if necessary.\n-    match kind {\n-        BoolKind => Store(bcx, C_bool(true), fcx.llretptr),\n-        UnitKind => {}\n-    }\n-\n-    Br(bcx, fcx.llreturn);\n-\n-    finish_fn(fcx, lltop);\n-}\n-\n-// This could have been combined with trans_deriving_struct_method, but it\n-// would probably be too big and hard to understand.\n-fn trans_deriving_enum_method(ccx: @crate_ctxt,\n-                              llfn: ValueRef,\n-                              impl_did: def_id,\n-                              self_ty: ty::t,\n-                              transformed_self_ty: ty::t,\n-                              kind: DerivingKind) {\n-    let _icx = ccx.insn_ctxt(\"trans_deriving_enum_method\");\n-    let fcx = new_fn_ctxt(ccx, ~[], llfn, None);\n-    let top_bcx = top_scope_block(fcx, None);\n-    let lltop = top_bcx.llbb;\n-    let mut bcx = top_bcx;\n-\n-    let llextraparams = get_extra_params(llfn, kind);\n-\n-    let lltransformedselfty = type_of(ccx, transformed_self_ty);\n-    let lltransformedselfval =\n-        PointerCast(bcx, fcx.llenv, T_ptr(lltransformedselfty));\n-    let llselfval = Load(bcx, lltransformedselfval);\n-\n-    let llotherval_opt;\n-    match kind {\n-        UnitKind => llotherval_opt = None,\n-        BoolKind => llotherval_opt = Some(LLVMGetParam(llfn, 2))\n-    }\n-\n-    let enum_id, enum_substs, enum_variant_infos;\n-    match ty::get(self_ty).sty {\n-        ty::ty_enum(found_enum_id, ref found_enum_substs) => {\n-            enum_id = found_enum_id;\n-            enum_substs = copy *found_enum_substs;\n-            enum_variant_infos = ty::substd_enum_variants(\n-                ccx.tcx, enum_id, &enum_substs);\n-        }\n-        _ => {\n-            ccx.tcx.sess.bug(~\"passed non-enum to \\\n-                               trans_deriving_enum_method\");\n-        }\n-    }\n-\n-    // Create the \"no match\" basic block, if necessary. This is a basic block\n-    // that does nothing more than return false.\n-    let nomatch_bcx_opt;\n-    match kind {\n-        BoolKind => {\n-            let nomatch_bcx = sub_block(top_bcx, ~\"no_match\");\n-            Store(nomatch_bcx, C_bool(false), fcx.llretptr);\n-            Br(nomatch_bcx, fcx.llreturn);\n-            nomatch_bcx_opt = Some(nomatch_bcx);\n-        }\n-        UnitKind => nomatch_bcx_opt = None\n-    }\n-\n-    // Create the \"unreachable\" basic block.\n-    let unreachable_bcx = sub_block(top_bcx, ~\"unreachable\");\n-    Unreachable(unreachable_bcx);\n-\n-    // Get the deriving enum method info.\n-    let deriving_enum_methods = ccx.tcx.deriving_enum_methods.get(impl_did);\n-    let n_variants = deriving_enum_methods.len();\n-\n-    if n_variants != 1 {\n-        // Grab the two discriminants.\n-        let llselfdiscrim = Load(bcx, GEPi(bcx, llselfval, [0, 0]));\n-        let llotherdiscrim_opt = llotherval_opt.map(\n-            |llotherval| Load(bcx, GEPi(bcx, *llotherval, [0, 0])));\n-\n-        // Skip over the discriminants and compute the address of the payload.\n-        let llselfpayload = GEPi(bcx, llselfval, [0, 1]);\n-        let llotherpayload_opt = llotherval_opt.map(\n-            |llotherval| GEPi(bcx, *llotherval, [0, 1]));\n-\n-        // Create basic blocks for the outer switch.\n-        let outer_bcxs = vec::from_fn(\n-            deriving_enum_methods.len(),\n-            |i| sub_block(top_bcx, fmt!(\"outer_%u\", i)));\n-\n-        // For each basic block in the outer switch...\n-        for outer_bcxs.eachi |self_variant_index, bcx| {\n-            // Create the matching basic block for the inner switch.\n-            let top_match_bcx = sub_block(top_bcx, fmt!(\"maybe_match_%u\",\n-                                                        self_variant_index));\n-            let mut match_bcx = top_match_bcx;\n-\n-            // Compare each variant.\n-            for deriving_enum_methods[self_variant_index].eachi\n-                    |i, derived_method_info| {\n-                let variant_def_id =\n-                        enum_variant_infos[self_variant_index].id;\n-                let llselfval = GEP_enum(match_bcx, llselfpayload, enum_id,\n-                                         variant_def_id, enum_substs.tps, i);\n-                let llselfallocaty = common::val_ty(llselfval);\n-                let llselfalloca = base::alloca(match_bcx, llselfallocaty);\n-                Store(match_bcx, llselfval, llselfalloca);\n-\n-                let llotherval_opt = llotherpayload_opt.map(|llotherpayload|\n-                    GEP_enum(match_bcx, *llotherpayload, enum_id,\n-                             variant_def_id, enum_substs.tps, i));\n-\n-                let self_ty = enum_variant_infos[self_variant_index].args[i];\n-                match_bcx = call_substructure_method(match_bcx,\n-                                                     derived_method_info,\n-                                                     self_ty,\n-                                                     llselfalloca,\n-                                                     llotherval_opt,\n-                                                     llextraparams);\n-\n-                // If this is a boolean-kind deriving method, then return\n-                // immediately if the call to the substructure returned false.\n-                match kind {\n-                    BoolKind => {\n-                        let next_bcx = sub_block(top_bcx,\n-                                                 fmt!(\"next_%u_%u\",\n-                                                      self_variant_index,\n-                                                      i));\n-                        let llcond = Load(match_bcx, fcx.llretptr);\n-                        CondBr(match_bcx,\n-                               llcond,\n-                               next_bcx.llbb,\n-                               fcx.llreturn);\n-                        match_bcx = next_bcx;\n-                    }\n-                    UnitKind => {}\n-                }\n-            }\n-\n-            // Store true in the return pointer if this is a boolean-kind\n-            // deriving method.\n-            match kind {\n-                BoolKind => Store(match_bcx, C_bool(true), fcx.llretptr),\n-                UnitKind => {}\n-            }\n-\n-            // Finish up the matching block.\n-            Br(match_bcx, fcx.llreturn);\n-\n-            // If this is a boolean-kind derived method, build the inner\n-            // switch. Otherwise, just jump to the matching case.\n-            match llotherdiscrim_opt {\n-                None => Br(*bcx, top_match_bcx.llbb),\n-                Some(copy llotherdiscrim) => {\n-                    let llswitch = Switch(*bcx,\n-                                          llotherdiscrim,\n-                                          unreachable_bcx.llbb,\n-                                          n_variants);\n-                    for uint::range(0, n_variants) |other_variant_index| {\n-                        let discriminant =\n-                            enum_variant_infos[other_variant_index].disr_val;\n-                        if self_variant_index == other_variant_index {\n-                            // This is the potentially-matching case.\n-                            AddCase(llswitch,\n-                                    C_int(ccx, discriminant),\n-                                    top_match_bcx.llbb);\n-                        } else {\n-                            // This is always a non-matching case.\n-                            AddCase(llswitch,\n-                                    C_int(ccx, discriminant),\n-                                    nomatch_bcx_opt.get().llbb);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        // Now build the outer switch.\n-        let llswitch = Switch(top_bcx, llselfdiscrim, unreachable_bcx.llbb,\n-                              n_variants);\n-        for outer_bcxs.eachi |self_variant_index, outer_bcx| {\n-            let discriminant =\n-                enum_variant_infos[self_variant_index].disr_val;\n-            AddCase(llswitch, C_int(ccx, discriminant), outer_bcx.llbb);\n-        }\n-    } else {\n-        ccx.tcx.sess.unimpl(~\"degenerate enum deriving\");\n-    }\n-\n-    // Finish up the function.\n-    finish_fn(fcx, lltop);\n-}\n-\n-fn call_substructure_method(bcx: block,\n-                            derived_field_info: &DerivedFieldInfo,\n-                            self_ty: ty::t,\n-                            llselfval: ValueRef,\n-                            llotherval_opt: Option<ValueRef>,\n-                            llextraparams: &[ValueRef]) -> block {\n-    let fcx = bcx.fcx;\n-    let ccx = fcx.ccx;\n-\n-    let target_method_def_id;\n-    match derived_field_info.method_origin {\n-        method_static(did) => target_method_def_id = did,\n-        _ => fail ~\"derived method didn't resolve to a static method\"\n-    }\n-\n-    let fn_expr_tpbt = ty::lookup_item_type(ccx.tcx, target_method_def_id);\n-    debug!(\"(calling substructure method) substructure method has %u \\\n-            parameter(s), vtable result is %?\",\n-           fn_expr_tpbt.bounds.len(),\n-           derived_field_info.vtable_result);\n-\n-    // Get the substructure method we need to call. This may involve\n-    // code generation in the case of generics, default methods, or cross-\n-    // crate inlining.\n-    let fn_data = callee::trans_fn_ref_with_vtables(bcx,\n-                                                    target_method_def_id,\n-                                                    0,     // ref id\n-                                                    *derived_field_info.\n-                                                 type_parameter_substitutions,\n-                                                    derived_field_info.\n-                                                        vtable_result);\n-    let llfn = fn_data.llfn;\n-\n-    // Create the callee.\n-    let cb: &fn(block) -> Callee = |bloc| {\n-        Callee {\n-            bcx: bloc,\n-            data: Method(MethodData {\n-                llfn: llfn,\n-                llself: llselfval,\n-                self_ty: self_ty,\n-                self_mode: ast::by_copy\n-            })\n-        }\n-    };\n-\n-    // Build up the argument list.\n-    let llargvals = DVec();\n-    for llotherval_opt.each |llotherval| { llargvals.push(*llotherval); }\n-    for llextraparams.each |llextraparam| { llargvals.push(*llextraparam); }\n-\n-    // And perform the call.\n-    callee::trans_call_inner(bcx,\n-                             None,\n-                             fn_expr_tpbt.ty,\n-                             ty::mk_bool(ccx.tcx),\n-                             cb,\n-                             ArgVals(dvec::unwrap(move llargvals)),\n-                             SaveIn(fcx.llretptr),\n-                             DontAutorefArg)\n-}\n-"}, {"sha": "1ef91bfda880e6d232b24493858feac1761d5fd1", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a7159be24a9c81517a46e09c7ff62cadc72759b6/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7159be24a9c81517a46e09c7ff62cadc72759b6/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=a7159be24a9c81517a46e09c7ff62cadc72759b6", "patch": "@@ -213,8 +213,6 @@ export opt_region_variance;\n export determine_inherited_purity;\n export provided_trait_methods;\n export trait_supertraits;\n-export DerivedMethodInfo;\n-export DerivedFieldInfo;\n export AutoAdjustment;\n export AutoRef;\n export AutoRefKind, AutoPtr, AutoBorrowVec, AutoBorrowVecRef, AutoBorrowFn;\n@@ -383,17 +381,6 @@ struct InstantiatedTraitRef {\n     tpt: ty_param_substs_and_ty\n }\n \n-struct DerivedMethodInfo {\n-    method_info: @middle::resolve::MethodInfo,\n-    containing_impl: ast::def_id\n-}\n-\n-struct DerivedFieldInfo {\n-    method_origin: typeck::method_origin,\n-    type_parameter_substitutions: @~[ty::t],\n-    vtable_result: Option<typeck::vtable_res>\n-}\n-\n type ctxt =\n     @{diag: syntax::diagnostic::span_handler,\n       interner: HashMap<intern_key, t_box>,\n@@ -443,20 +430,6 @@ type ctxt =\n       provided_methods: ProvidedMethodsMap,\n       provided_method_sources: HashMap<ast::def_id, ProvidedMethodSource>,\n       supertraits: HashMap<ast::def_id, @~[InstantiatedTraitRef]>,\n-      deriving_struct_methods: HashMap<ast::def_id, @~[DerivedFieldInfo]>,\n-\n-      // The outer vector here describes each enum variant, while the inner\n-      // nested vector describes each enum variant argument.\n-      deriving_enum_methods: HashMap<ast::def_id, @~[@~[DerivedFieldInfo]]>,\n-\n-      // A mapping from the def ID of a method that was automatically derived\n-      // to information about it.\n-      automatically_derived_methods: HashMap<ast::def_id, DerivedMethodInfo>,\n-\n-      // A mapping from the def ID of an impl to the IDs of the derived\n-      // methods within it.\n-      automatically_derived_methods_for_impl:\n-            HashMap<ast::def_id, @~[ast::def_id]>,\n \n       // A mapping from the def ID of an enum or struct type to the def ID\n       // of the method that implements its destructor. If the type is not\n@@ -1003,10 +976,6 @@ fn mk_ctxt(s: session::Session,\n       provided_methods: HashMap(),\n       provided_method_sources: HashMap(),\n       supertraits: HashMap(),\n-      deriving_struct_methods: HashMap(),\n-      deriving_enum_methods: HashMap(),\n-      automatically_derived_methods: HashMap(),\n-      automatically_derived_methods_for_impl: HashMap(),\n       destructor_for_type: HashMap(),\n       destructors: HashMap(),\n       value_modes: HashMap()}"}, {"sha": "3e5986f5236e62f4c4a13595676af0f89ba2c650", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 17, "deletions": 96, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/a7159be24a9c81517a46e09c7ff62cadc72759b6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7159be24a9c81517a46e09c7ff62cadc72759b6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=a7159be24a9c81517a46e09c7ff62cadc72759b6", "patch": "@@ -19,7 +19,7 @@ use metadata::csearch::{get_impls_for_mod};\n use metadata::cstore::{CStore, iter_crate_data};\n use metadata::decoder::{dl_def, dl_field, dl_impl};\n use middle::resolve::{Impl, MethodInfo};\n-use middle::ty::{DerivedMethodInfo, ProvidedMethodSource,\n+use middle::ty::{ProvidedMethodSource,\n                  ProvidedMethodInfo, get};\n use middle::ty::{lookup_item_type, subst, t, ty_bot, ty_box, ty_struct};\n use middle::ty::{ty_bool, ty_enum, ty_int, ty_nil, ty_ptr, ty_rptr, ty_uint};\n@@ -598,105 +598,31 @@ impl CoherenceChecker {\n         return trait_id;\n     }\n \n-    /// Returns true if the method has been marked with the #[derivable]\n-    /// attribute and false otherwise.\n-    fn method_is_derivable(method_def_id: ast::def_id) -> bool {\n-        if method_def_id.crate == local_crate {\n-            match self.crate_context.tcx.items.find(method_def_id.node) {\n-                Some(ast_map::node_trait_method(trait_method, _, _)) => {\n-                    match *trait_method {\n-                        ast::required(ref ty_method) => {\n-                            attr::attrs_contains_name((*ty_method).attrs,\n-                                                      ~\"derivable\")\n-                        }\n-                        ast::provided(method) => {\n-                            attr::attrs_contains_name(method.attrs,\n-                                                      ~\"derivable\")\n-                        }\n-                    }\n-                }\n-                _ => {\n-                    self.crate_context.tcx.sess.bug(~\"method_is_derivable(): \\\n-                                                      def ID passed in \\\n-                                                      wasn't a trait method\")\n-                }\n-            }\n-        } else {\n-            false   // XXX: Unimplemented.\n-        }\n-    }\n+    // This check doesn't really have anything to do with coherence. It's\n+    // here for historical reasons\n+    fn please_check_that_trait_methods_are_implemented(\n+        all_methods: &mut ~[@MethodInfo],\n+        trait_did: def_id,\n+        trait_ref_span: span) {\n \n-    fn add_automatically_derived_methods_from_trait(\n-            all_methods: &mut ~[@MethodInfo],\n-            trait_did: def_id,\n-            self_ty: ty::t,\n-            impl_did: def_id,\n-            trait_ref_span: span) {\n         let tcx = self.crate_context.tcx;\n \n-        // Make a set of all the method names that this implementation and\n-        // trait provided so that we don't try to automatically derive\n-        // implementations for them.\n         let mut provided_names = send_map::linear::LinearMap();\n+        // Implemented methods\n         for uint::range(0, all_methods.len()) |i| {\n             provided_names.insert(all_methods[i].ident, ());\n         }\n+        // Default methods\n         for ty::provided_trait_methods(tcx, trait_did).each |ident| {\n             provided_names.insert(*ident, ());\n         }\n \n-        let new_method_dids = dvec::DVec();\n         for (*ty::trait_methods(tcx, trait_did)).each |method| {\n-            // Check to see whether we need to derive this method. We need to\n-            // derive a method only if and only if neither the trait nor the\n-            // implementation we're considering provided a body.\n             if provided_names.contains_key(&method.ident) { loop; }\n \n-            if !self.method_is_derivable(method.def_id) {\n-                tcx.sess.span_err(trait_ref_span,\n-                                  fmt!(\"missing method `%s`\",\n-                                       tcx.sess.str_of(method.ident)));\n-                loop;\n-            }\n-\n-            // Generate a def ID for each node.\n-            let new_def_id = local_def(tcx.sess.next_node_id());\n-            let method_info = @{\n-                did: new_def_id,\n-                n_tps: method.tps.len(),\n-                ident: method.ident,\n-                self_type: method.self_ty\n-            };\n-            all_methods.push(method_info);\n-\n-            // Note that this method was automatically derived so that trans\n-            // can handle it differently.\n-            let derived_method_info = DerivedMethodInfo {\n-                method_info: method_info,\n-                containing_impl: impl_did\n-            };\n-\n-            tcx.automatically_derived_methods.insert(new_def_id,\n-                                                     derived_method_info);\n-\n-            new_method_dids.push(new_def_id);\n-\n-            // Additionally, generate the type for the derived method and add\n-            // it to the type cache.\n-            //\n-            // XXX: Handle generics correctly.\n-            let substs = { self_r: None, self_ty: Some(self_ty), tps: ~[] };\n-            tcx.tcache.insert(new_def_id, {\n-                bounds: @~[],\n-                region_param: None,\n-                ty: ty::subst(tcx, &substs, ty::mk_fn(tcx, method.fty))\n-            });\n-        }\n-\n-        let new_method_dids = @dvec::unwrap(move new_method_dids);\n-        if new_method_dids.len() > 0 {\n-            tcx.automatically_derived_methods_for_impl.insert(\n-                impl_did, new_method_dids);\n+            tcx.sess.span_err(trait_ref_span,\n+                              fmt!(\"missing method `%s`\",\n+                                   tcx.sess.str_of(method.ident)));\n         }\n     }\n \n@@ -720,19 +646,14 @@ impl CoherenceChecker {\n                     methods.push(method_to_MethodInfo(*ast_method));\n                 }\n \n-                // Now search for methods that need to be automatically\n-                // derived.\n-                let tcx = self.crate_context.tcx;\n-                let self_ty = ty::lookup_item_type(tcx, local_def(item.id));\n+                // Check that we have implementations of every trait method\n                 for trait_refs.each |trait_ref| {\n                     let trait_did =\n                         self.trait_ref_to_trait_def_id(*trait_ref);\n-                    self.add_automatically_derived_methods_from_trait(\n-                            &mut methods,\n-                            trait_did,\n-                            self_ty.ty,\n-                            local_def(item.id),\n-                            trait_ref.path.span);\n+                    self.please_check_that_trait_methods_are_implemented(\n+                        &mut methods,\n+                        trait_did,\n+                        trait_ref.path.span);\n                 }\n \n                 // For each trait that the impl implements, see which"}, {"sha": "bdd286dd484bda35cbc1beeec45a637284ed820a", "filename": "src/librustc/middle/typeck/deriving.rs", "status": "removed", "additions": 0, "deletions": 322, "changes": 322, "blob_url": "https://github.com/rust-lang/rust/blob/6439f2d54645915ce57f4c229811719e8e498151/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fderiving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6439f2d54645915ce57f4c229811719e8e498151/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fderiving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fderiving.rs?ref=6439f2d54645915ce57f4c229811719e8e498151", "patch": "@@ -1,322 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Deriving phase\n-//\n-// The purpose of the deriving phase of typechecking is to ensure that, for\n-// each automatically derived implementation of an automatically-derivable\n-// trait (for example, Eq), all the subcomponents of the type in question\n-// also implement the trait. This phase runs after coherence.\n-\n-use syntax::ast::crate;\n-use syntax::ast::{def_id, ident};\n-use syntax::ast::item_impl;\n-use syntax::ast::node_id;\n-use syntax::ast::self_ty_;\n-use syntax::ast::trait_ref;\n-use syntax::ast_util::{def_id_of_def, dummy_sp};\n-use syntax::codemap::span;\n-use syntax::print::pprust;\n-use syntax::visit::{default_simple_visitor, mk_simple_visitor, visit_crate};\n-use middle::resolve::{Impl, MethodInfo};\n-use middle::ty;\n-use middle::ty::{DerivedFieldInfo, ReVar, re_infer, re_static, substs};\n-use middle::ty::{ty_struct, ty_enum, ty_param_bounds_and_ty};\n-use /*middle::typeck::*/check::method;\n-use /*middle::typeck::*/check::vtable;\n-use /*middle::typeck::*/infer::infer_ctxt;\n-use /*middle::typeck::*/vtable::{LocationInfo, VtableContext};\n-use util::ppaux;\n-\n-struct MethodMatch {\n-    method_def_id: def_id,\n-    type_parameter_substitutions: @~[ty::t],\n-    vtable_result: Option<vtable_res>\n-}\n-\n-struct DerivingChecker {\n-    crate_context: @crate_ctxt\n-}\n-\n-fn DerivingChecker_new(crate_context: @crate_ctxt) -> DerivingChecker {\n-    DerivingChecker {\n-        crate_context: crate_context,\n-    }\n-}\n-\n-struct TyParamSubstsAndVtableResult {\n-    type_parameter_substitutions: @~[ty::t],\n-    vtable_result: Option<vtable_res>\n-}\n-\n-impl DerivingChecker {\n-    /// Matches one substructure type against an implementation.\n-    fn match_impl_method(impl_info: @Impl,\n-                         substructure_type: ty::t,\n-                         method_info: @MethodInfo,\n-                         span: span) ->\n-                         Option<TyParamSubstsAndVtableResult> {\n-        let tcx = self.crate_context.tcx;\n-\n-        let impl_self_tpbt = ty::lookup_item_type(tcx, impl_info.did);\n-\n-        let inference_context = infer::new_infer_ctxt(self.crate_context.tcx);\n-        let region = inference_context.next_region_var_nb(span);\n-        let transformed_type = method::transform_self_type_for_method(\n-            tcx, Some(region), impl_self_tpbt.ty, method_info.self_type);\n-\n-        let substs = {\n-            self_r: None,\n-            self_ty: None,\n-            tps: inference_context.next_ty_vars(impl_self_tpbt.bounds.len())\n-        };\n-        let transformed_type = ty::subst(\n-            self.crate_context.tcx, &substs, transformed_type);\n-\n-        // Automatically reference the substructure type.\n-        let region = inference_context.next_region_var_nb(span);\n-        let substructure_type = ty::mk_rptr(\n-            self.crate_context.tcx,\n-            region,\n-            { ty: substructure_type, mutbl: ast::m_imm });\n-\n-        debug!(\"(matching impl method) substructure type %s, transformed \\\n-                type %s, subst tps %u\",\n-               ppaux::ty_to_str(self.crate_context.tcx, substructure_type),\n-               ppaux::ty_to_str(self.crate_context.tcx, transformed_type),\n-               substs.tps.len());\n-\n-        if !infer::mk_subty(inference_context,\n-                            true,\n-                            ast_util::dummy_sp(),\n-                            substructure_type,\n-                            transformed_type).is_ok() {\n-            return None;\n-        }\n-\n-        // Get the vtables.\n-        let vtable_result;\n-        if substs.tps.len() == 0 {\n-            vtable_result = None;\n-        } else {\n-            let vcx = VtableContext {\n-                ccx: self.crate_context,\n-                infcx: inference_context\n-            };\n-            let location_info = LocationInfo {\n-                span: span,\n-                id: impl_info.did.node\n-            };\n-            vtable_result = Some(vtable::lookup_vtables(&vcx,\n-                                                        &location_info,\n-                                                        impl_self_tpbt.bounds,\n-                                                        &substs,\n-                                                        false,\n-                                                        false));\n-        }\n-\n-        // Extract the type parameter substitutions.\n-        let type_parameter_substitutions = @substs.tps.map(|ty_var|\n-            inference_context.resolve_type_vars_if_possible(*ty_var));\n-\n-        Some(TyParamSubstsAndVtableResult {\n-            type_parameter_substitutions: type_parameter_substitutions,\n-            vtable_result: vtable_result\n-        })\n-    }\n-\n-    fn check_deriving_for_substructure_type(substructure_type: ty::t,\n-                                            trait_ref: @trait_ref,\n-                                            impl_span: span) ->\n-                                            Option<MethodMatch> {\n-        let tcx = self.crate_context.tcx;\n-        let sess = tcx.sess;\n-        let coherence_info = self.crate_context.coherence_info;\n-        let trait_id = def_id_of_def(tcx.def_map.get(trait_ref.ref_id));\n-        match coherence_info.extension_methods.find(trait_id) {\n-            None => {\n-                sess.span_bug(impl_span, ~\"no extension method info found \\\n-                                           for this trait\");\n-            }\n-            Some(impls) => {\n-                // Try to unify each of these impls with the substructure\n-                // type.\n-                //\n-                // NB: Using range to avoid a recursive-use-of-dvec error.\n-                for uint::range(0, impls.len()) |i| {\n-                    let impl_info = impls[i];\n-                    for uint::range(0, impl_info.methods.len()) |j| {\n-                        let method_info = impl_info.methods[j];\n-                        match self.match_impl_method(impl_info,\n-                                                     substructure_type,\n-                                                     method_info,\n-                                                     trait_ref.path.span) {\n-                            Some(move result) => {\n-                                return Some(MethodMatch {\n-                                    method_def_id: method_info.did,\n-                                    type_parameter_substitutions:\n-                                        result.type_parameter_substitutions,\n-                                    vtable_result: result.vtable_result\n-                                });\n-                            }\n-                            None => {}  // Continue.\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        return None;\n-    }\n-\n-    fn check_deriving_for_struct(struct_def_id: def_id,\n-                                 struct_substs: &substs,\n-                                 trait_ref: @trait_ref,\n-                                 impl_id: node_id,\n-                                 impl_span: span) {\n-        let tcx = self.crate_context.tcx;\n-        let field_info = dvec::DVec();\n-        for ty::lookup_struct_fields(tcx, struct_def_id).each |field| {\n-            let field_type = ty::lookup_field_type(\n-                tcx, struct_def_id, field.id, struct_substs);\n-            match self.check_deriving_for_substructure_type(field_type,\n-                                                            trait_ref,\n-                                                            impl_span) {\n-                Some(method_match) => {\n-                    field_info.push(DerivedFieldInfo {\n-                        method_origin:\n-                            method_static(method_match.method_def_id),\n-                        type_parameter_substitutions:\n-                            method_match.type_parameter_substitutions,\n-                        vtable_result:\n-                            method_match.vtable_result\n-                    });\n-                }\n-                None => {\n-                    let trait_str = pprust::path_to_str(\n-                        trait_ref.path, tcx.sess.parse_sess.interner);\n-                    tcx.sess.span_err(impl_span,\n-                                      fmt!(\"cannot automatically derive an \\\n-                                            implementation for `%s`: field \\\n-                                            `%s` does not implement the \\\n-                                            trait `%s`\",\n-                                           trait_str,\n-                                           tcx.sess.str_of(field.ident),\n-                                           trait_str));\n-                }\n-            }\n-        }\n-\n-        let field_info = @dvec::unwrap(move field_info);\n-        tcx.deriving_struct_methods.insert(local_def(impl_id), field_info);\n-    }\n-\n-    fn check_deriving_for_enum(enum_def_id: def_id,\n-                               enum_substs: &substs,\n-                               trait_ref: @trait_ref,\n-                               impl_id: node_id,\n-                               impl_span: span) {\n-        let tcx = self.crate_context.tcx;\n-        let enum_methods = dvec::DVec();\n-        let variants = ty::substd_enum_variants(\n-            tcx, enum_def_id, enum_substs);\n-        for variants.each |enum_variant_info| {\n-            let variant_methods = dvec::DVec();\n-            for enum_variant_info.args.eachi |i, variant_arg_type| {\n-                match self.check_deriving_for_substructure_type(\n-                        *variant_arg_type, trait_ref, impl_span) {\n-                    Some(method_match) => {\n-                        variant_methods.push(DerivedFieldInfo {\n-                            method_origin:\n-                                method_static(method_match.method_def_id),\n-                            type_parameter_substitutions:\n-                                method_match.type_parameter_substitutions,\n-                            vtable_result:\n-                                method_match.vtable_result\n-                        });\n-                    }\n-                    None => {\n-                        let trait_str = pprust::path_to_str(\n-                            trait_ref.path, tcx.sess.parse_sess.interner);\n-                        tcx.sess.span_err(impl_span,\n-                                          fmt!(\"cannot automatically derive \\\n-                                                an implementation for `%s`: \\\n-                                                argument %u of variant `%s` \\\n-                                                does not implement the trait \\\n-                                                `%s`\",\n-                                               trait_str,\n-                                               i + 1,\n-                                               tcx.sess.str_of(\n-                                                    enum_variant_info.name),\n-                                               trait_str));\n-                    }\n-                }\n-            }\n-            enum_methods.push(@dvec::unwrap(move variant_methods));\n-        }\n-\n-        let enum_methods = @dvec::unwrap(move enum_methods);\n-        tcx.deriving_enum_methods.insert(local_def(impl_id), enum_methods);\n-    }\n-\n-    fn check_deriving(crate: @crate) {\n-        let tcx = self.crate_context.tcx;\n-        visit_crate(*crate, (), mk_simple_visitor(@{\n-            visit_item: |item| {\n-                match item.node {\n-                    item_impl(_, Some(trait_ref), _, _) => {\n-                        // Determine whether there were any automatically-\n-                        // derived methods in this implementation.\n-                        let impl_did = local_def(item.id);\n-                        if tcx.automatically_derived_methods_for_impl.\n-                                contains_key(impl_did) {\n-                            // XXX: This does not handle generic impls.\n-                            let superty = ty::lookup_item_type(\n-                                tcx, local_def(item.id)).ty;\n-                            match ty::get(superty).sty {\n-                                ty_enum(def_id, ref substs) => {\n-                                    self.check_deriving_for_enum(\n-                                        def_id,\n-                                        substs,\n-                                        trait_ref,\n-                                        item.id,\n-                                        item.span);\n-                                }\n-                                ty_struct(def_id, ref substs) => {\n-                                    self.check_deriving_for_struct(\n-                                        def_id,\n-                                        substs,\n-                                        trait_ref,\n-                                        item.id,\n-                                        item.span);\n-                                }\n-                                _ => {\n-                                    tcx.sess.span_err(item.span,\n-                                                      ~\"only enums and \\\n-                                                        structs may have \\\n-                                                        implementations \\\n-                                                        automatically \\\n-                                                        derived for them\");\n-                                }\n-                            }\n-                        }\n-                    }\n-                    _ => {}\n-                }\n-            },\n-            ..*default_simple_visitor()\n-        }));\n-    }\n-}\n-\n-pub fn check_deriving(crate_context: @crate_ctxt, crate: @crate) {\n-    let deriving_checker = @DerivingChecker_new(crate_context);\n-    deriving_checker.check_deriving(crate);\n-}\n-"}, {"sha": "e128f6a03fb5945e9531029619c6e4728fc9043a", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7159be24a9c81517a46e09c7ff62cadc72759b6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7159be24a9c81517a46e09c7ff62cadc72759b6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=a7159be24a9c81517a46e09c7ff62cadc72759b6", "patch": "@@ -103,7 +103,6 @@ mod infer;\n mod collect;\n #[legacy_exports]\n mod coherence;\n-mod deriving;\n \n #[auto_serialize]\n #[auto_deserialize]\n@@ -391,7 +390,6 @@ fn check_crate(tcx: ty::ctxt,\n                            });\n     collect::collect_item_types(ccx, crate);\n     coherence::check_coherence(ccx, crate);\n-    deriving::check_deriving(ccx, crate);\n \n     check::check_item_types(ccx, crate);\n     check_for_main_fn(ccx);"}, {"sha": "584f165b75dafa2a45a16ff9a3f1c1af18290792", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7159be24a9c81517a46e09c7ff62cadc72759b6/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/a7159be24a9c81517a46e09c7ff62cadc72759b6/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=a7159be24a9c81517a46e09c7ff62cadc72759b6", "patch": "@@ -123,8 +123,6 @@ mod middle {\n         mod reachable;\n         #[path = \"middle/trans/machine.rs\"]\n         mod machine;\n-        #[path = \"middle/trans/deriving.rs\"]\n-        mod deriving;\n     }\n     #[legacy_exports]\n     #[path = \"middle/ty.rs\"]"}, {"sha": "131a0ed653bfc4bed945a501de30717a7027a590", "filename": "src/test/compile-fail/enum-deriving-incomplete.rs", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/6439f2d54645915ce57f4c229811719e8e498151/src%2Ftest%2Fcompile-fail%2Fenum-deriving-incomplete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6439f2d54645915ce57f4c229811719e8e498151/src%2Ftest%2Fcompile-fail%2Fenum-deriving-incomplete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fenum-deriving-incomplete.rs?ref=6439f2d54645915ce57f4c229811719e8e498151", "patch": "@@ -1,35 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-trait MyEq {\n-    #[derivable]\n-    pure fn eq(&self, other: &self) -> bool;\n-}\n-\n-struct A {\n-    x: int\n-}\n-\n-enum B {\n-    C(A),\n-    D(A),\n-    E(A)\n-}\n-\n-impl B : MyEq;\n-//~^ ERROR cannot automatically derive\n-//~^^ ERROR cannot automatically derive\n-//~^^^ ERROR cannot automatically derive\n-\n-fn main() {\n-    let c = C(A { x: 15 });\n-    assert c.eq(&c);\n-}\n-"}, {"sha": "38c4fd1fc073e5ce036feca3ccd554e76e3edcd9", "filename": "src/test/run-pass/deriving-generic-bounded.rs", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/6439f2d54645915ce57f4c229811719e8e498151/src%2Ftest%2Frun-pass%2Fderiving-generic-bounded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6439f2d54645915ce57f4c229811719e8e498151/src%2Ftest%2Frun-pass%2Fderiving-generic-bounded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-generic-bounded.rs?ref=6439f2d54645915ce57f4c229811719e8e498151", "patch": "@@ -1,44 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-trait MyEq {\n-    #[derivable]\n-    pure fn eq(&self, other: &self) -> bool;\n-}\n-\n-impl int : MyEq {\n-    pure fn eq(&self, other: &int) -> bool {\n-        *self == *other\n-    }\n-}\n-\n-impl<T:MyEq> @T : MyEq {\n-    pure fn eq(&self, other: &@T) -> bool {\n-        unsafe {\n-            io::println(\"@T\");\n-        }\n-        (**self).eq(&**other)\n-    }\n-}\n-\n-struct A {\n-    x: @int,\n-    y: @int\n-}\n-\n-impl A : MyEq;\n-\n-fn main() {\n-    let a = A { x: @3, y: @5 };\n-    let b = A { x: @10, y: @20 };\n-    assert a.eq(&a);\n-    assert !a.eq(&b);\n-}\n-"}, {"sha": "9ec29088c101fda4bb2fe02348f2351235d3a9c8", "filename": "src/test/run-pass/deriving-one-method.rs", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/6439f2d54645915ce57f4c229811719e8e498151/src%2Ftest%2Frun-pass%2Fderiving-one-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6439f2d54645915ce57f4c229811719e8e498151/src%2Ftest%2Frun-pass%2Fderiving-one-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-one-method.rs?ref=6439f2d54645915ce57f4c229811719e8e498151", "patch": "@@ -1,35 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-trait MyEq {\n-    #[derivable]\n-    pure fn eq(&self, other: &self) -> bool;\n-    pure fn ne(&self, other: &self) -> bool;\n-}\n-\n-struct A {\n-    x: int\n-}\n-\n-impl int : MyEq {\n-    pure fn eq(&self, other: &int) -> bool { *self == *other }\n-    pure fn ne(&self, other: &int) -> bool { *self != *other }\n-}\n-\n-impl A : MyEq {\n-    pure fn ne(&self, other: &A) -> bool { !self.eq(other) }\n-}\n-\n-fn main() {\n-    let a = A { x: 1 };\n-    assert a.eq(&a);\n-    assert !a.ne(&a);\n-}\n-"}, {"sha": "04a7d2aa6e97cf8dc7f6ae51ee1739b46700e0ab", "filename": "src/test/run-pass/deriving-override.rs", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6439f2d54645915ce57f4c229811719e8e498151/src%2Ftest%2Frun-pass%2Fderiving-override.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6439f2d54645915ce57f4c229811719e8e498151/src%2Ftest%2Frun-pass%2Fderiving-override.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-override.rs?ref=6439f2d54645915ce57f4c229811719e8e498151", "patch": "@@ -1,36 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-trait MyEq {\n-    #[derivable]\n-    pure fn eq(&self, other: &self) -> bool;\n-    #[derivable]\n-    pure fn ne(&self, other: &self) -> bool;\n-}\n-\n-struct A {\n-    x: int\n-}\n-\n-impl int : MyEq {\n-    pure fn eq(&self, other: &int) -> bool { *self == *other }\n-    pure fn ne(&self, other: &int) -> bool { *self != *other }\n-}\n-\n-impl A : MyEq {\n-    pure fn ne(&self, other: &A) -> bool { !self.eq(other) }\n-}\n-\n-fn main() {\n-    let a = A { x: 1 };\n-    assert a.eq(&a);\n-    assert !a.ne(&a);\n-}\n-"}, {"sha": "f3be94ee9a7ac120433c059f24266406efd53fc0", "filename": "src/test/run-pass/deriving-param-pass-through.rs", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/6439f2d54645915ce57f4c229811719e8e498151/src%2Ftest%2Frun-pass%2Fderiving-param-pass-through.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6439f2d54645915ce57f4c229811719e8e498151/src%2Ftest%2Frun-pass%2Fderiving-param-pass-through.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-param-pass-through.rs?ref=6439f2d54645915ce57f4c229811719e8e498151", "patch": "@@ -1,41 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-trait Trait {\n-    #[derivable]\n-    fn f(&self, x: int, y: &str);\n-}\n-\n-impl int : Trait {\n-    fn f(&self, x: int, y: &str) {\n-        assert x == 42;\n-        assert y == \"hello\";\n-    }\n-}\n-\n-impl float : Trait {\n-    fn f(&self, x: int, y: &str) {\n-        assert x == 42;\n-        assert y == \"hello\";\n-    }\n-}\n-\n-struct Foo {\n-    x: int,\n-    y: float\n-}\n-\n-impl Foo : Trait;\n-\n-fn main() {\n-    let a: Foo = Foo { x: 1, y: 2.0 };\n-    a.f(42, \"hello\");\n-}\n-"}, {"sha": "50ce0529b5323abfe1357b168f9ed749e3bcc904", "filename": "src/test/run-pass/deriving-returning-nil.rs", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/6439f2d54645915ce57f4c229811719e8e498151/src%2Ftest%2Frun-pass%2Fderiving-returning-nil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6439f2d54645915ce57f4c229811719e8e498151/src%2Ftest%2Frun-pass%2Fderiving-returning-nil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-returning-nil.rs?ref=6439f2d54645915ce57f4c229811719e8e498151", "patch": "@@ -1,51 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-trait Show {\n-    #[derivable]\n-    fn show(&self);\n-}\n-\n-impl int : Show {\n-    fn show(&self) {\n-        io::println(self.to_str());\n-    }\n-}\n-\n-struct Foo {\n-    x: int,\n-    y: int,\n-    z: int,\n-}\n-\n-impl Foo : Show;\n-\n-enum Bar {\n-    Baz(int, int),\n-    Boo(Foo),\n-}\n-\n-impl Bar : Show;\n-\n-fn main() {\n-    let foo = Foo { x: 1, y: 2, z: 3 };\n-    foo.show();\n-\n-    io::println(\"---\");\n-\n-    let baz = Baz(4, 5);\n-    baz.show();\n-\n-    io::println(\"---\");\n-\n-    let boo = Boo(Foo { x: 6, y: 7, z: 8 });\n-    boo.show();\n-}\n-"}, {"sha": "1ed17e56351a321cbc58b7bed9f558e12d558c03", "filename": "src/test/run-pass/deriving-simple.rs", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/6439f2d54645915ce57f4c229811719e8e498151/src%2Ftest%2Frun-pass%2Fderiving-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6439f2d54645915ce57f4c229811719e8e498151/src%2Ftest%2Frun-pass%2Fderiving-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-simple.rs?ref=6439f2d54645915ce57f4c229811719e8e498151", "patch": "@@ -1,43 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-trait MyEq {\n-    #[derivable]\n-    pure fn eq(&self, other: &self) -> bool;\n-}\n-\n-struct A {\n-    x: int\n-}\n-\n-struct B {\n-    x: A,\n-    y: A,\n-    z: A\n-}\n-\n-impl A : MyEq {\n-    pure fn eq(&self, other: &A) -> bool {\n-        unsafe { io::println(fmt!(\"eq %d %d\", self.x, other.x)); }\n-        self.x == other.x\n-    }\n-}\n-\n-impl B : MyEq;\n-\n-fn main() {\n-    let b = B { x: A { x: 1 }, y: A { x: 2 }, z: A { x: 3 } };\n-    let c = B { x: A { x: 1 }, y: A { x: 3 }, z: A { x: 4 } };\n-    assert b.eq(&b);\n-    assert c.eq(&c);\n-    assert !b.eq(&c);\n-    assert !c.eq(&b);\n-}\n-"}, {"sha": "2fdd79d4dcf3cb3aa21bd6a5e63047854030446f", "filename": "src/test/run-pass/enum-deriving-simple.rs", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/6439f2d54645915ce57f4c229811719e8e498151/src%2Ftest%2Frun-pass%2Fenum-deriving-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6439f2d54645915ce57f4c229811719e8e498151/src%2Ftest%2Frun-pass%2Fenum-deriving-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-deriving-simple.rs?ref=6439f2d54645915ce57f4c229811719e8e498151", "patch": "@@ -1,43 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-trait MyEq {\n-    #[derivable]\n-    pure fn eq(&self, other: &self) -> bool;\n-}\n-\n-struct A {\n-    x: int\n-}\n-\n-enum B {\n-    C(A),\n-    D(A),\n-    E(A)\n-}\n-\n-impl A : MyEq {\n-    pure fn eq(&self, other: &A) -> bool {\n-        unsafe { io::println(\"in eq\"); }\n-        self.x == other.x\n-    }\n-}\n-\n-impl B : MyEq;\n-\n-fn main() {\n-    let c = C(A { x: 15 });\n-    let d = D(A { x: 30 });\n-    let e = C(A { x: 30 });\n-    assert c.eq(&c);\n-    assert !c.eq(&d);\n-    assert !c.eq(&e);\n-}\n-"}]}