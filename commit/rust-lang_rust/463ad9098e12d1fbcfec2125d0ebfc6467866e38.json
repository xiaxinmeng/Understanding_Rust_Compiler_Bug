{"sha": "463ad9098e12d1fbcfec2125d0ebfc6467866e38", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2M2FkOTA5OGUxMmQxZmJjZmVjMjEyNWQwZWJmYzY0Njc4NjZlMzg=", "commit": {"author": {"name": "Nikita Popov", "email": "nikita.ppv@gmail.com", "date": "2018-11-02T22:38:16Z"}, "committer": {"name": "Nikita Popov", "email": "nikita.ppv@gmail.com", "date": "2018-11-04T17:54:37Z"}, "message": "Support memcpy/memmove with differing src/dst alignment\n\nIf LLVM 7 is used, generate memcpy/memmove with differing\nsrc/dst alignment. I've added new FFI functions to construct\nthese through the builder API, which is more convenient than\ndealing with differing intrinsic signatures depending on the\nLLVM version.", "tree": {"sha": "0c82c5b2b35aeb14a9daaa9125adcbf5dbf03f29", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c82c5b2b35aeb14a9daaa9125adcbf5dbf03f29"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/463ad9098e12d1fbcfec2125d0ebfc6467866e38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/463ad9098e12d1fbcfec2125d0ebfc6467866e38", "html_url": "https://github.com/rust-lang/rust/commit/463ad9098e12d1fbcfec2125d0ebfc6467866e38", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/463ad9098e12d1fbcfec2125d0ebfc6467866e38/comments", "author": {"login": "nikic", "id": 216080, "node_id": "MDQ6VXNlcjIxNjA4MA==", "avatar_url": "https://avatars.githubusercontent.com/u/216080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikic", "html_url": "https://github.com/nikic", "followers_url": "https://api.github.com/users/nikic/followers", "following_url": "https://api.github.com/users/nikic/following{/other_user}", "gists_url": "https://api.github.com/users/nikic/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikic/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikic/subscriptions", "organizations_url": "https://api.github.com/users/nikic/orgs", "repos_url": "https://api.github.com/users/nikic/repos", "events_url": "https://api.github.com/users/nikic/events{/privacy}", "received_events_url": "https://api.github.com/users/nikic/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikic", "id": 216080, "node_id": "MDQ6VXNlcjIxNjA4MA==", "avatar_url": "https://avatars.githubusercontent.com/u/216080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikic", "html_url": "https://github.com/nikic", "followers_url": "https://api.github.com/users/nikic/followers", "following_url": "https://api.github.com/users/nikic/following{/other_user}", "gists_url": "https://api.github.com/users/nikic/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikic/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikic/subscriptions", "organizations_url": "https://api.github.com/users/nikic/orgs", "repos_url": "https://api.github.com/users/nikic/repos", "events_url": "https://api.github.com/users/nikic/events{/privacy}", "received_events_url": "https://api.github.com/users/nikic/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac708826b0d97e105f91a4cde41bfe14cff032f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac708826b0d97e105f91a4cde41bfe14cff032f2", "html_url": "https://github.com/rust-lang/rust/commit/ac708826b0d97e105f91a4cde41bfe14cff032f2"}], "stats": {"total": 149, "additions": 98, "deletions": 51}, "files": [{"sha": "bd7a1c2c3293eb28194d3b8e4f2af54d56580d46", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/463ad9098e12d1fbcfec2125d0ebfc6467866e38/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/463ad9098e12d1fbcfec2125d0ebfc6467866e38/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=463ad9098e12d1fbcfec2125d0ebfc6467866e38", "patch": "@@ -225,9 +225,10 @@ impl ArgTypeExt<'ll, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n                 // ...and then memcpy it to the intended destination.\n                 base::call_memcpy(bx,\n                                   bx.pointercast(dst.llval, Type::i8p(cx)),\n+                                  self.layout.align,\n                                   bx.pointercast(llscratch, Type::i8p(cx)),\n+                                  scratch_align,\n                                   C_usize(cx, self.layout.size.bytes()),\n-                                  self.layout.align.min(scratch_align),\n                                   MemFlags::empty());\n \n                 bx.lifetime_end(llscratch, scratch_size);"}, {"sha": "dd1348cdf2b6a84fa45f1eda122b16416924f1cb", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/463ad9098e12d1fbcfec2125d0ebfc6467866e38/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/463ad9098e12d1fbcfec2125d0ebfc6467866e38/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=463ad9098e12d1fbcfec2125d0ebfc6467866e38", "patch": "@@ -53,7 +53,7 @@ use mir::place::PlaceRef;\n use attributes;\n use builder::{Builder, MemFlags};\n use callee;\n-use common::{C_bool, C_bytes_in_context, C_i32, C_usize};\n+use common::{C_bool, C_bytes_in_context, C_usize};\n use rustc_mir::monomorphize::item::DefPathBasedNames;\n use common::{C_struct_in_context, C_array, val_ty};\n use consts;\n@@ -77,7 +77,6 @@ use rustc_data_structures::sync::Lrc;\n use std::any::Any;\n use std::cmp;\n use std::ffi::CString;\n-use std::i32;\n use std::ops::{Deref, DerefMut};\n use std::sync::mpsc;\n use std::time::{Instant, Duration};\n@@ -319,8 +318,8 @@ pub fn coerce_unsized_into(\n                 }\n \n                 if src_f.layout.ty == dst_f.layout.ty {\n-                    memcpy_ty(bx, dst_f.llval, src_f.llval, src_f.layout,\n-                              src_f.align.min(dst_f.align), MemFlags::empty());\n+                    memcpy_ty(bx, dst_f.llval, dst_f.align, src_f.llval, src_f.align,\n+                              src_f.layout, MemFlags::empty());\n                 } else {\n                     coerce_unsized_into(bx, src_f, dst_f);\n                 }\n@@ -420,44 +419,42 @@ pub fn to_immediate_scalar(\n pub fn call_memcpy(\n     bx: &Builder<'_, 'll, '_>,\n     dst: &'ll Value,\n+    dst_align: Align,\n     src: &'ll Value,\n+    src_align: Align,\n     n_bytes: &'ll Value,\n-    align: Align,\n     flags: MemFlags,\n ) {\n     if flags.contains(MemFlags::NONTEMPORAL) {\n         // HACK(nox): This is inefficient but there is no nontemporal memcpy.\n-        let val = bx.load(src, align);\n+        let val = bx.load(src, src_align);\n         let ptr = bx.pointercast(dst, val_ty(val).ptr_to());\n-        bx.store_with_flags(val, ptr, align, flags);\n+        bx.store_with_flags(val, ptr, dst_align, flags);\n         return;\n     }\n     let cx = bx.cx;\n-    let ptr_width = &cx.sess().target.target.target_pointer_width;\n-    let key = format!(\"llvm.memcpy.p0i8.p0i8.i{}\", ptr_width);\n-    let memcpy = cx.get_intrinsic(&key);\n     let src_ptr = bx.pointercast(src, Type::i8p(cx));\n     let dst_ptr = bx.pointercast(dst, Type::i8p(cx));\n     let size = bx.intcast(n_bytes, cx.isize_ty, false);\n-    let align = C_i32(cx, align.abi() as i32);\n-    let volatile = C_bool(cx, flags.contains(MemFlags::VOLATILE));\n-    bx.call(memcpy, &[dst_ptr, src_ptr, size, align, volatile], None);\n+    let volatile = flags.contains(MemFlags::VOLATILE);\n+    bx.memcpy(dst_ptr, dst_align.abi(), src_ptr, src_align.abi(), size, volatile);\n }\n \n pub fn memcpy_ty(\n     bx: &Builder<'_, 'll, 'tcx>,\n     dst: &'ll Value,\n+    dst_align: Align,\n     src: &'ll Value,\n+    src_align: Align,\n     layout: TyLayout<'tcx>,\n-    align: Align,\n     flags: MemFlags,\n ) {\n     let size = layout.size.bytes();\n     if size == 0 {\n         return;\n     }\n \n-    call_memcpy(bx, dst, src, C_usize(bx.cx, size), align, flags);\n+    call_memcpy(bx, dst, dst_align, src, src_align, C_usize(bx.cx, size), flags);\n }\n \n pub fn call_memset("}, {"sha": "eaaa450fbf419d9f5f22c62fd4682939ea1293d0", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/463ad9098e12d1fbcfec2125d0ebfc6467866e38/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/463ad9098e12d1fbcfec2125d0ebfc6467866e38/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=463ad9098e12d1fbcfec2125d0ebfc6467866e38", "patch": "@@ -784,6 +784,24 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n+    pub fn memcpy(&self, dst: &'ll Value, dst_align: u64,\n+                  src: &'ll Value, src_align: u64,\n+                  size: &'ll Value, is_volatile: bool) -> &'ll Value {\n+        unsafe {\n+            llvm::LLVMRustBuildMemCpy(self.llbuilder, dst, dst_align as c_uint,\n+                                      src, src_align as c_uint, size, is_volatile)\n+        }\n+    }\n+\n+    pub fn memmove(&self, dst: &'ll Value, dst_align: u64,\n+                  src: &'ll Value, src_align: u64,\n+                  size: &'ll Value, is_volatile: bool) -> &'ll Value {\n+        unsafe {\n+            llvm::LLVMRustBuildMemMove(self.llbuilder, dst, dst_align as c_uint,\n+                                      src, src_align as c_uint, size, is_volatile)\n+        }\n+    }\n+\n     pub fn minnum(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"minnum\");\n         unsafe {"}, {"sha": "59dc0f61ecccdbe58197aceb13c23160ba612b07", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/463ad9098e12d1fbcfec2125d0ebfc6467866e38/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/463ad9098e12d1fbcfec2125d0ebfc6467866e38/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=463ad9098e12d1fbcfec2125d0ebfc6467866e38", "patch": "@@ -530,12 +530,6 @@ fn declare_intrinsic(cx: &CodegenCx<'ll, '_>, key: &str) -> Option<&'ll Value> {\n     let t_v4f64 = Type::vector(t_f64, 4);\n     let t_v8f64 = Type::vector(t_f64, 8);\n \n-    ifn!(\"llvm.memcpy.p0i8.p0i8.i16\", fn(i8p, i8p, t_i16, t_i32, i1) -> void);\n-    ifn!(\"llvm.memcpy.p0i8.p0i8.i32\", fn(i8p, i8p, t_i32, t_i32, i1) -> void);\n-    ifn!(\"llvm.memcpy.p0i8.p0i8.i64\", fn(i8p, i8p, t_i64, t_i32, i1) -> void);\n-    ifn!(\"llvm.memmove.p0i8.p0i8.i16\", fn(i8p, i8p, t_i16, t_i32, i1) -> void);\n-    ifn!(\"llvm.memmove.p0i8.p0i8.i32\", fn(i8p, i8p, t_i32, t_i32, i1) -> void);\n-    ifn!(\"llvm.memmove.p0i8.p0i8.i64\", fn(i8p, i8p, t_i64, t_i32, i1) -> void);\n     ifn!(\"llvm.memset.p0i8.i16\", fn(i8p, t_i8, t_i16, t_i32, i1) -> void);\n     ifn!(\"llvm.memset.p0i8.i32\", fn(i8p, t_i8, t_i32, t_i32, i1) -> void);\n     ifn!(\"llvm.memset.p0i8.i64\", fn(i8p, t_i8, t_i64, t_i32, i1) -> void);"}, {"sha": "f7cef6be5b52925510bbc59683ff9e57c1563f38", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 7, "deletions": 21, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/463ad9098e12d1fbcfec2125d0ebfc6467866e38/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/463ad9098e12d1fbcfec2125d0ebfc6467866e38/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=463ad9098e12d1fbcfec2125d0ebfc6467866e38", "patch": "@@ -23,7 +23,7 @@ use glue;\n use type_::Type;\n use type_of::LayoutLlvmExt;\n use rustc::ty::{self, Ty};\n-use rustc::ty::layout::{HasDataLayout, LayoutOf};\n+use rustc::ty::layout::LayoutOf;\n use rustc::hir;\n use syntax::ast;\n use syntax::symbol::Symbol;\n@@ -690,28 +690,14 @@ fn copy_intrinsic(\n     let cx = bx.cx;\n     let (size, align) = cx.size_and_align_of(ty);\n     let size = C_usize(cx, size.bytes());\n-    let align = C_i32(cx, align.abi() as i32);\n-\n-    let operation = if allow_overlap {\n-        \"memmove\"\n-    } else {\n-        \"memcpy\"\n-    };\n-\n-    let name = format!(\"llvm.{}.p0i8.p0i8.i{}\", operation,\n-                       cx.data_layout().pointer_size.bits());\n-\n+    let align = align.abi();\n     let dst_ptr = bx.pointercast(dst, Type::i8p(cx));\n     let src_ptr = bx.pointercast(src, Type::i8p(cx));\n-    let llfn = cx.get_intrinsic(&name);\n-\n-    bx.call(llfn,\n-        &[dst_ptr,\n-        src_ptr,\n-        bx.mul(size, count),\n-        align,\n-        C_bool(cx, volatile)],\n-        None)\n+    if allow_overlap {\n+        bx.memmove(dst_ptr, align, src_ptr, align, bx.mul(size, count), volatile)\n+    } else {\n+        bx.memcpy(dst_ptr, align, src_ptr, align, bx.mul(size, count), volatile)\n+    }\n }\n \n fn memset_intrinsic("}, {"sha": "64066d4d786a53e7530a9625a96cac6b74a7df38", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/463ad9098e12d1fbcfec2125d0ebfc6467866e38/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/463ad9098e12d1fbcfec2125d0ebfc6467866e38/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=463ad9098e12d1fbcfec2125d0ebfc6467866e38", "patch": "@@ -998,6 +998,22 @@ extern \"C\" {\n                              Bundle: Option<&OperandBundleDef<'a>>,\n                              Name: *const c_char)\n                              -> &'a Value;\n+    pub fn LLVMRustBuildMemCpy(B: &Builder<'a>,\n+                               Dst: &'a Value,\n+                               DstAlign: c_uint,\n+                               Src: &'a Value,\n+                               SrcAlign: c_uint,\n+                               Size: &'a Value,\n+                               IsVolatile: bool)\n+                               -> &'a Value;\n+    pub fn LLVMRustBuildMemMove(B: &Builder<'a>,\n+                                Dst: &'a Value,\n+                                DstAlign: c_uint,\n+                                Src: &'a Value,\n+                                SrcAlign: c_uint,\n+                                Size: &'a Value,\n+                                IsVolatile: bool)\n+                                -> &'a Value;\n     pub fn LLVMBuildSelect(B: &Builder<'a>,\n                            If: &'a Value,\n                            Then: &'a Value,"}, {"sha": "3f9921a5cf930b68372a3584a17f6b725727d6f4", "filename": "src/librustc_codegen_llvm/mir/block.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/463ad9098e12d1fbcfec2125d0ebfc6467866e38/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/463ad9098e12d1fbcfec2125d0ebfc6467866e38/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs?ref=463ad9098e12d1fbcfec2125d0ebfc6467866e38", "patch": "@@ -784,7 +784,8 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                     // have scary latent bugs around.\n \n                     let scratch = PlaceRef::alloca(bx, arg.layout, \"arg\");\n-                    base::memcpy_ty(bx, scratch.llval, llval, op.layout, align, MemFlags::empty());\n+                    base::memcpy_ty(bx, scratch.llval, scratch.align, llval, align,\n+                                    op.layout, MemFlags::empty());\n                     (scratch.llval, scratch.align, true)\n                 } else {\n                     (llval, align, true)"}, {"sha": "c76cbfcd9717711e244a7a3b6e1421be3dfd0e2c", "filename": "src/librustc_codegen_llvm/mir/operand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/463ad9098e12d1fbcfec2125d0ebfc6467866e38/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/463ad9098e12d1fbcfec2125d0ebfc6467866e38/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs?ref=463ad9098e12d1fbcfec2125d0ebfc6467866e38", "patch": "@@ -282,8 +282,8 @@ impl OperandValue<'ll> {\n         }\n         match self {\n             OperandValue::Ref(r, None, source_align) => {\n-                base::memcpy_ty(bx, dest.llval, r, dest.layout,\n-                                source_align.min(dest.align), flags)\n+                base::memcpy_ty(bx, dest.llval, dest.align, r, source_align,\n+                                dest.layout, flags)\n             }\n             OperandValue::Ref(_, Some(_), _) => {\n                 bug!(\"cannot directly store unsized values\");\n@@ -324,7 +324,7 @@ impl OperandValue<'ll> {\n         // Allocate an appropriate region on the stack, and copy the value into it\n         let (llsize, _) = glue::size_and_align_of_dst(&bx, unsized_ty, Some(llextra));\n         let lldst = bx.array_alloca(Type::i8(bx.cx), llsize, \"unsized_tmp\", max_align);\n-        base::call_memcpy(&bx, lldst, llptr, llsize, min_align, flags);\n+        base::call_memcpy(&bx, lldst, max_align, llptr, min_align, llsize, flags);\n \n         // Store the allocated region and the extra to the indirect place.\n         let indirect_operand = OperandValue::Pair(lldst, llextra);"}, {"sha": "3a1e082b7550d7fb7eee244ef12549d506552580", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/463ad9098e12d1fbcfec2125d0ebfc6467866e38/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/463ad9098e12d1fbcfec2125d0ebfc6467866e38/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=463ad9098e12d1fbcfec2125d0ebfc6467866e38", "patch": "@@ -1239,6 +1239,40 @@ extern \"C\" LLVMValueRef LLVMRustBuildCall(LLVMBuilderRef B, LLVMValueRef Fn,\n       unwrap(Fn), makeArrayRef(unwrap(Args), NumArgs), Bundles, Name));\n }\n \n+extern \"C\" LLVMValueRef LLVMRustBuildMemCpy(LLVMBuilderRef B,\n+                                            LLVMValueRef Dst, unsigned DstAlign,\n+                                            LLVMValueRef Src, unsigned SrcAlign,\n+                                            LLVMValueRef Size, bool IsVolatile) {\n+#if LLVM_VERSION_GE(7, 0)\n+  return wrap(unwrap(B)->CreateMemCpy(\n+      unwrap(Dst), DstAlign,\n+      unwrap(Src), SrcAlign,\n+      unwrap(Size), IsVolatile));\n+#else\n+  unsigned Align = std::min(DstAlign, SrcAlign);\n+  return wrap(unwrap(B)->CreateMemCpy(\n+      unwrap(Dst), unwrap(Src),\n+      unwrap(Size), Align, IsVolatile));\n+#endif\n+}\n+\n+extern \"C\" LLVMValueRef LLVMRustBuildMemMove(LLVMBuilderRef B,\n+                                             LLVMValueRef Dst, unsigned DstAlign,\n+                                             LLVMValueRef Src, unsigned SrcAlign,\n+                                             LLVMValueRef Size, bool IsVolatile) {\n+#if LLVM_VERSION_GE(7, 0)\n+  return wrap(unwrap(B)->CreateMemMove(\n+      unwrap(Dst), DstAlign,\n+      unwrap(Src), SrcAlign,\n+      unwrap(Size), IsVolatile));\n+#else\n+  unsigned Align = std::min(DstAlign, SrcAlign);\n+  return wrap(unwrap(B)->CreateMemMove(\n+      unwrap(Dst), unwrap(Src),\n+      unwrap(Size), Align, IsVolatile));\n+#endif\n+}\n+\n extern \"C\" LLVMValueRef\n LLVMRustBuildInvoke(LLVMBuilderRef B, LLVMValueRef Fn, LLVMValueRef *Args,\n                     unsigned NumArgs, LLVMBasicBlockRef Then,"}, {"sha": "b50f5b6f16fedad9743b5be8b2be36fea7a6eb7b", "filename": "src/test/codegen/packed.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/463ad9098e12d1fbcfec2125d0ebfc6467866e38/src%2Ftest%2Fcodegen%2Fpacked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/463ad9098e12d1fbcfec2125d0ebfc6467866e38/src%2Ftest%2Fcodegen%2Fpacked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fpacked.rs?ref=463ad9098e12d1fbcfec2125d0ebfc6467866e38", "patch": "@@ -65,7 +65,7 @@ pub struct BigPacked2 {\n pub fn call_pkd1(f: fn() -> Array) -> BigPacked1 {\n // CHECK: [[ALLOCA:%[_a-z0-9]+]] = alloca %Array\n // CHECK: call void %{{.*}}(%Array* noalias nocapture sret dereferenceable(32) [[ALLOCA]])\n-// CHECK: call void @llvm.memcpy.{{.*}}(i8* align 1 %{{.*}}, i8* align 1 %{{.*}}, i{{[0-9]+}} 32, i1 false)\n+// CHECK: call void @llvm.memcpy.{{.*}}(i8* align 1 %{{.*}}, i8* align 4 %{{.*}}, i{{[0-9]+}} 32, i1 false)\n     // check that calls whose destination is a field of a packed struct\n     // go through an alloca rather than calling the function with an\n     // unaligned destination.\n@@ -77,7 +77,7 @@ pub fn call_pkd1(f: fn() -> Array) -> BigPacked1 {\n pub fn call_pkd2(f: fn() -> Array) -> BigPacked2 {\n // CHECK: [[ALLOCA:%[_a-z0-9]+]] = alloca %Array\n // CHECK: call void %{{.*}}(%Array* noalias nocapture sret dereferenceable(32) [[ALLOCA]])\n-// CHECK: call void @llvm.memcpy.{{.*}}(i8* align 2 %{{.*}}, i8* align 2 %{{.*}}, i{{[0-9]+}} 32, i1 false)\n+// CHECK: call void @llvm.memcpy.{{.*}}(i8* align 2 %{{.*}}, i8* align 4 %{{.*}}, i{{[0-9]+}} 32, i1 false)\n     // check that calls whose destination is a field of a packed struct\n     // go through an alloca rather than calling the function with an\n     // unaligned destination."}, {"sha": "871bee13b1931eddf04b259ad387f3bd2cb70f08", "filename": "src/test/codegen/stores.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/463ad9098e12d1fbcfec2125d0ebfc6467866e38/src%2Ftest%2Fcodegen%2Fstores.rs", "raw_url": "https://github.com/rust-lang/rust/raw/463ad9098e12d1fbcfec2125d0ebfc6467866e38/src%2Ftest%2Fcodegen%2Fstores.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fstores.rs?ref=463ad9098e12d1fbcfec2125d0ebfc6467866e38", "patch": "@@ -31,7 +31,7 @@ pub fn small_array_alignment(x: &mut [i8; 4], y: [i8; 4]) {\n // CHECK: store i32 %0, i32* [[TMP]]\n // CHECK: [[Y8:%[0-9]+]] = bitcast [4 x i8]* %y to i8*\n // CHECK: [[TMP8:%[0-9]+]] = bitcast i32* [[TMP]] to i8*\n-// CHECK: call void @llvm.memcpy.{{.*}}(i8* align 1 [[Y8]], i8* align 1 [[TMP8]], i{{[0-9]+}} 4, i1 false)\n+// CHECK: call void @llvm.memcpy.{{.*}}(i8* align 1 [[Y8]], i8* align 4 [[TMP8]], i{{[0-9]+}} 4, i1 false)\n     *x = y;\n }\n \n@@ -45,6 +45,6 @@ pub fn small_struct_alignment(x: &mut Bytes, y: Bytes) {\n // CHECK: store i32 %0, i32* [[TMP]]\n // CHECK: [[Y8:%[0-9]+]] = bitcast %Bytes* %y to i8*\n // CHECK: [[TMP8:%[0-9]+]] = bitcast i32* [[TMP]] to i8*\n-// CHECK: call void @llvm.memcpy.{{.*}}(i8* align 1 [[Y8]], i8* align 1 [[TMP8]], i{{[0-9]+}} 4, i1 false)\n+// CHECK: call void @llvm.memcpy.{{.*}}(i8* align 1 [[Y8]], i8* align 4 [[TMP8]], i{{[0-9]+}} 4, i1 false)\n     *x = y;\n }"}]}