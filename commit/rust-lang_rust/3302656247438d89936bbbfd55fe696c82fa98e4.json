{"sha": "3302656247438d89936bbbfd55fe696c82fa98e4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzMDI2NTYyNDc0MzhkODk5MzZiYmJmZDU1ZmU2OTZjODJmYTk4ZTQ=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-30T12:56:19Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-11-01T07:58:03Z"}, "message": "More extensive slice and vec tests\n\nNot all of them pass validation...", "tree": {"sha": "7d9588b57330e3f1d84ac3011a0e139e551a3d50", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d9588b57330e3f1d84ac3011a0e139e551a3d50"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3302656247438d89936bbbfd55fe696c82fa98e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3302656247438d89936bbbfd55fe696c82fa98e4", "html_url": "https://github.com/rust-lang/rust/commit/3302656247438d89936bbbfd55fe696c82fa98e4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3302656247438d89936bbbfd55fe696c82fa98e4/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "430e047a6f2364f9c6d7d950816eef09f3db0428", "url": "https://api.github.com/repos/rust-lang/rust/commits/430e047a6f2364f9c6d7d950816eef09f3db0428", "html_url": "https://github.com/rust-lang/rust/commit/430e047a6f2364f9c6d7d950816eef09f3db0428"}], "stats": {"total": 272, "additions": 216, "deletions": 56}, "files": [{"sha": "aa9d117d726f16a1b8a8c51bc4144ba07c136dc6", "filename": "tests/run-pass/slice-of-zero-size-elements.rs", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/430e047a6f2364f9c6d7d950816eef09f3db0428/tests%2Frun-pass%2Fslice-of-zero-size-elements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/430e047a6f2364f9c6d7d950816eef09f3db0428/tests%2Frun-pass%2Fslice-of-zero-size-elements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fslice-of-zero-size-elements.rs?ref=430e047a6f2364f9c6d7d950816eef09f3db0428", "patch": "@@ -1,56 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::slice;\n-\n-fn foo<T>(v: &[T]) -> Option<&[T]> {\n-    let mut it = v.iter();\n-    for _ in 0..5 {\n-        let _ = it.next();\n-    }\n-    Some(it.as_slice())\n-}\n-\n-fn foo_mut<T>(v: &mut [T]) -> Option<&mut [T]> {\n-    let mut it = v.iter_mut();\n-    for _ in 0..5 {\n-        let _ = it.next();\n-    }\n-    Some(it.into_slice())\n-}\n-\n-pub fn main() {\n-    // In a slice of zero-size elements the pointer is meaningless.\n-    // Ensure iteration still works even if the pointer is at the end of the address space.\n-    let slice: &[()] = unsafe { slice::from_raw_parts(-5isize as *const (), 10) };\n-    assert_eq!(slice.len(), 10);\n-    assert_eq!(slice.iter().count(), 10);\n-\n-    // .nth() on the iterator should also behave correctly\n-    let mut it = slice.iter();\n-    assert!(it.nth(5).is_some());\n-    assert_eq!(it.count(), 4);\n-\n-    // Converting Iter to a slice should never have a null pointer\n-    assert!(foo(slice).is_some());\n-\n-    // Test mutable iterators as well\n-    let slice: &mut [()] = unsafe { slice::from_raw_parts_mut(-5isize as *mut (), 10) };\n-    assert_eq!(slice.len(), 10);\n-    assert_eq!(slice.iter_mut().count(), 10);\n-\n-    {\n-        let mut it = slice.iter_mut();\n-        assert!(it.nth(5).is_some());\n-        assert_eq!(it.count(), 4);\n-    }\n-\n-    assert!(foo_mut(slice).is_some())\n-}"}, {"sha": "119c9b90a05c16a601fa96e96dda8915be99d252", "filename": "tests/run-pass/slices.rs", "status": "added", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/3302656247438d89936bbbfd55fe696c82fa98e4/tests%2Frun-pass%2Fslices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3302656247438d89936bbbfd55fe696c82fa98e4/tests%2Frun-pass%2Fslices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fslices.rs?ref=3302656247438d89936bbbfd55fe696c82fa98e4", "patch": "@@ -0,0 +1,178 @@\n+// FIXME: Still investigating whether there is UB here\n+// compile-flags: -Zmiri-disable-validation\n+\n+use std::slice;\n+\n+fn slice_of_zst() {\n+    fn foo<T>(v: &[T]) -> Option<&[T]> {\n+        let mut it = v.iter();\n+        for _ in 0..5 {\n+            let _ = it.next();\n+        }\n+        Some(it.as_slice())\n+    }\n+\n+    fn foo_mut<T>(v: &mut [T]) -> Option<&mut [T]> {\n+        let mut it = v.iter_mut();\n+        for _ in 0..5 {\n+            let _ = it.next();\n+        }\n+        Some(it.into_slice())\n+    }\n+\n+    // In a slice of zero-size elements the pointer is meaningless.\n+    // Ensure iteration still works even if the pointer is at the end of the address space.\n+    let slice: &[()] = unsafe { slice::from_raw_parts(-5isize as *const (), 10) };\n+    assert_eq!(slice.len(), 10);\n+    assert_eq!(slice.iter().count(), 10);\n+\n+    // .nth() on the iterator should also behave correctly\n+    let mut it = slice.iter();\n+    assert!(it.nth(5).is_some());\n+    assert_eq!(it.count(), 4);\n+\n+    // Converting Iter to a slice should never have a null pointer\n+    assert!(foo(slice).is_some());\n+\n+    // Test mutable iterators as well\n+    let slice: &mut [()] = unsafe { slice::from_raw_parts_mut(-5isize as *mut (), 10) };\n+    assert_eq!(slice.len(), 10);\n+    assert_eq!(slice.iter_mut().count(), 10);\n+\n+    {\n+        let mut it = slice.iter_mut();\n+        assert!(it.nth(5).is_some());\n+        assert_eq!(it.count(), 4);\n+    }\n+\n+    assert!(foo_mut(slice).is_some())\n+}\n+\n+fn test_iter_ref_consistency() {\n+    use std::fmt::Debug;\n+\n+    fn test<T : Copy + Debug + PartialEq>(x : T) {\n+        let v : &[T] = &[x, x, x];\n+        let v_ptrs : [*const T; 3] = match v {\n+            [ref v1, ref v2, ref v3] => [v1 as *const _, v2 as *const _, v3 as *const _],\n+            _ => unreachable!()\n+        };\n+        let len = v.len();\n+\n+        // nth(i)\n+        for i in 0..len {\n+            assert_eq!(&v[i] as *const _, v_ptrs[i]); // check the v_ptrs array, just to be sure\n+            let nth = v.iter().nth(i).unwrap();\n+            assert_eq!(nth as *const _, v_ptrs[i]);\n+        }\n+        assert_eq!(v.iter().nth(len), None, \"nth(len) should return None\");\n+\n+        // stepping through with nth(0)\n+        {\n+            let mut it = v.iter();\n+            for i in 0..len {\n+                let next = it.nth(0).unwrap();\n+                assert_eq!(next as *const _, v_ptrs[i]);\n+            }\n+            assert_eq!(it.nth(0), None);\n+        }\n+\n+        // next()\n+        {\n+            let mut it = v.iter();\n+            for i in 0..len {\n+                let remaining = len - i;\n+                assert_eq!(it.size_hint(), (remaining, Some(remaining)));\n+\n+                let next = it.next().unwrap();\n+                assert_eq!(next as *const _, v_ptrs[i]);\n+            }\n+            assert_eq!(it.size_hint(), (0, Some(0)));\n+            assert_eq!(it.next(), None, \"The final call to next() should return None\");\n+        }\n+\n+        // next_back()\n+        {\n+            let mut it = v.iter();\n+            for i in 0..len {\n+                let remaining = len - i;\n+                assert_eq!(it.size_hint(), (remaining, Some(remaining)));\n+\n+                let prev = it.next_back().unwrap();\n+                assert_eq!(prev as *const _, v_ptrs[remaining-1]);\n+            }\n+            assert_eq!(it.size_hint(), (0, Some(0)));\n+            assert_eq!(it.next_back(), None, \"The final call to next_back() should return None\");\n+        }\n+    }\n+\n+    fn test_mut<T : Copy + Debug + PartialEq>(x : T) {\n+        let v : &mut [T] = &mut [x, x, x];\n+        let v_ptrs : [*mut T; 3] = match v {\n+            [ref v1, ref v2, ref v3] =>\n+              [v1 as *const _ as *mut _, v2 as *const _ as *mut _, v3 as *const _ as *mut _],\n+            _ => unreachable!()\n+        };\n+        let len = v.len();\n+\n+        // nth(i)\n+        for i in 0..len {\n+            assert_eq!(&mut v[i] as *mut _, v_ptrs[i]); // check the v_ptrs array, just to be sure\n+            let nth = v.iter_mut().nth(i).unwrap();\n+            assert_eq!(nth as *mut _, v_ptrs[i]);\n+        }\n+        assert_eq!(v.iter().nth(len), None, \"nth(len) should return None\");\n+\n+        // stepping through with nth(0)\n+        {\n+            let mut it = v.iter();\n+            for i in 0..len {\n+                let next = it.nth(0).unwrap();\n+                assert_eq!(next as *const _, v_ptrs[i]);\n+            }\n+            assert_eq!(it.nth(0), None);\n+        }\n+\n+        // next()\n+        {\n+            let mut it = v.iter_mut();\n+            for i in 0..len {\n+                let remaining = len - i;\n+                assert_eq!(it.size_hint(), (remaining, Some(remaining)));\n+\n+                let next = it.next().unwrap();\n+                assert_eq!(next as *mut _, v_ptrs[i]);\n+            }\n+            assert_eq!(it.size_hint(), (0, Some(0)));\n+            assert_eq!(it.next(), None, \"The final call to next() should return None\");\n+        }\n+\n+        // next_back()\n+        {\n+            let mut it = v.iter_mut();\n+            for i in 0..len {\n+                let remaining = len - i;\n+                assert_eq!(it.size_hint(), (remaining, Some(remaining)));\n+\n+                let prev = it.next_back().unwrap();\n+                assert_eq!(prev as *mut _, v_ptrs[remaining-1]);\n+            }\n+            assert_eq!(it.size_hint(), (0, Some(0)));\n+            assert_eq!(it.next_back(), None, \"The final call to next_back() should return None\");\n+        }\n+    }\n+\n+    // Make sure iterators and slice patterns yield consistent addresses for various types,\n+    // including ZSTs.\n+    test(0u32);\n+    test(());\n+    test([0u32; 0]); // ZST with alignment > 0\n+    test_mut(0u32);\n+    test_mut(());\n+    test_mut([0u32; 0]); // ZST with alignment > 0\n+}\n+\n+fn main() {\n+    slice_of_zst();\n+    test_iter_ref_consistency();\n+}"}, {"sha": "bb9e5068f91e8e5932f0cf4d422ff46b50b852df", "filename": "tests/run-pass/vecs.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/3302656247438d89936bbbfd55fe696c82fa98e4/tests%2Frun-pass%2Fvecs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3302656247438d89936bbbfd55fe696c82fa98e4/tests%2Frun-pass%2Fvecs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fvecs.rs?ref=3302656247438d89936bbbfd55fe696c82fa98e4", "patch": "@@ -24,13 +24,45 @@ fn vec_into_iter() -> u8 {\n         .fold(0, |x, y| x + y)\n }\n \n+fn vec_into_iter_rev() -> u8 {\n+    vec![1, 2, 3, 4]\n+        .into_iter()\n+        .map(|x| x * x)\n+        .fold(0, |x, y| x + y)\n+}\n+\n fn vec_into_iter_zst() -> usize {\n     vec![[0u64; 0], [0u64; 0]]\n         .into_iter()\n+        .rev()\n+        .map(|x| x.len())\n+        .sum()\n+}\n+\n+fn vec_into_iter_rev_zst() -> usize {\n+    vec![[0u64; 0], [0u64; 0]]\n+        .into_iter()\n+        .rev()\n         .map(|x| x.len())\n         .sum()\n }\n \n+fn vec_iter_and_mut() {\n+    let mut v = vec![1,2,3,4];\n+    for i in v.iter_mut() {\n+        *i += 1;\n+    }\n+    assert_eq!(v.iter().sum::<i32>(), 2+3+4+5);\n+}\n+\n+fn vec_iter_and_mut_rev() {\n+    let mut v = vec![1,2,3,4];\n+    for i in v.iter_mut().rev() {\n+        *i += 1;\n+    }\n+    assert_eq!(v.iter().sum::<i32>(), 2+3+4+5);\n+}\n+\n fn vec_reallocate() -> Vec<u8> {\n     let mut v = vec![1, 2];\n     v.push(3);\n@@ -41,8 +73,14 @@ fn vec_reallocate() -> Vec<u8> {\n \n fn main() {\n     assert_eq!(vec_reallocate().len(), 5);\n+\n     assert_eq!(vec_into_iter(), 30);\n+    assert_eq!(vec_into_iter_rev(), 30);\n+    vec_iter_and_mut();\n     assert_eq!(vec_into_iter_zst(), 0);\n+    assert_eq!(vec_into_iter_rev_zst(), 0);\n+    vec_iter_and_mut_rev();\n+\n     assert_eq!(make_vec().capacity(), 4);\n     assert_eq!(make_vec_macro(), [1, 2]);\n     assert_eq!(make_vec_macro_repeat(), [42; 5]);"}]}