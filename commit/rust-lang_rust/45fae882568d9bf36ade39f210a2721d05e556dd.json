{"sha": "45fae882568d9bf36ade39f210a2721d05e556dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1ZmFlODgyNTY4ZDliZjM2YWRlMzlmMjEwYTI3MjFkMDVlNTU2ZGQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-03-06T15:14:12Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-03-23T09:30:43Z"}, "message": "When matching against a pattern (either via `match` or `let`) that\ncontains ref-bindings, do not permit any upcasting from the type of\nthe value being matched. Similarly, do not permit coercion in a `let`.\n\nThis is a [breaking-change] in that it closes a type hole that\npreviously existed, and in that coercion is not performed. You should\nbe able to work around the latter by converting:\n\n```rust\nlet ref mut x: T = expr;\n```\n\ninto\n\n```rust\nlet x: T = expr;\nlet ref mut x = x;\n```\n\nRestricting coercion not to apply in the case of `let ref` or `let ref mut` is sort\nof unexciting to me, but seems the best solution:\n\n1. Mixing coercion and `let ref` or `let ref mut` is a bit odd, because you are taking\n   the address of a (coerced) temporary, but only sometimes. It's not syntactically evident,\n   in other words, what's going on. When you're doing a coercion, you're kind of\n\n2. Put another way, I would like to preserve the relationship that\n   `equality <= subtyping <= coercion <= as-coercion`, where this is\n   an indication of the number of `(T1,T2)` pairs that are accepted by\n   the various relations. Trying to mix `let ref mut` and coercion\n   would create another kind of relation that is like coercion, but\n   acts differently in the case where a precise match is needed.\n\n3. In any case, this is strictly more conservative than what we had\n   before and we can undo it in the future if we find a way to make\n   coercion mix with type equality.\n\nThe change to match I feel ok about but similarly unthrilled. There is\nsome subtle text already concerning whether to use eqtype or subtype\nfor identifier bindings. The best fix I think would be to always have\nmatch use strict equality but use subtyping on identifier bindings,\nbut the comment `(*)` explains why that's not working at the moment.\nAs above, I think we can change this as we clean up the code there.", "tree": {"sha": "6f8d8d31843e3239b827013024a0d35d2d4f05e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f8d8d31843e3239b827013024a0d35d2d4f05e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/45fae882568d9bf36ade39f210a2721d05e556dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/45fae882568d9bf36ade39f210a2721d05e556dd", "html_url": "https://github.com/rust-lang/rust/commit/45fae882568d9bf36ade39f210a2721d05e556dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/45fae882568d9bf36ade39f210a2721d05e556dd/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b0aad7dd4fad8d7e2e2f877a511a637258949597", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0aad7dd4fad8d7e2e2f877a511a637258949597", "html_url": "https://github.com/rust-lang/rust/commit/b0aad7dd4fad8d7e2e2f877a511a637258949597"}], "stats": {"total": 126, "additions": 116, "deletions": 10}, "files": [{"sha": "4f365beed213f2a44f57d238779cb69d84cebcd7", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/45fae882568d9bf36ade39f210a2721d05e556dd/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45fae882568d9bf36ade39f210a2721d05e556dd/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=45fae882568d9bf36ade39f210a2721d05e556dd", "patch": "@@ -119,6 +119,24 @@ pub fn pat_contains_bindings(dm: &DefMap, pat: &ast::Pat) -> bool {\n     contains_bindings\n }\n \n+/// Checks if the pattern contains any `ref` or `ref mut` bindings.\n+pub fn pat_contains_ref_binding(dm: &DefMap, pat: &ast::Pat) -> bool {\n+    let mut result = false;\n+    pat_bindings(dm, pat, |mode, _, _, _| {\n+        match mode {\n+            ast::BindingMode::BindByRef(_) => { result = true; }\n+            ast::BindingMode::BindByValue(_) => { }\n+        }\n+    });\n+    result\n+}\n+\n+/// Checks if the patterns for this arm contain any `ref` or `ref mut`\n+/// bindings.\n+pub fn arm_contains_ref_binding(dm: &DefMap, arm: &ast::Arm) -> bool {\n+    arm.pats.iter().any(|pat| pat_contains_ref_binding(dm, pat))\n+}\n+\n /// Checks if the pattern contains any patterns that bind something to\n /// an ident or wildcard, e.g. `foo`, or `Foo(_)`, `foo @ Bar(..)`,\n pub fn pat_contains_bindings_or_wild(dm: &DefMap, pat: &ast::Pat) -> bool {"}, {"sha": "b490de335c5a06ec15518235dc568c8fabb629f6", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/45fae882568d9bf36ade39f210a2721d05e556dd/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45fae882568d9bf36ade39f210a2721d05e556dd/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=45fae882568d9bf36ade39f210a2721d05e556dd", "patch": "@@ -52,6 +52,7 @@ use middle::mem_categorization as mc;\n use middle::region;\n use middle::resolve_lifetime;\n use middle::infer;\n+use middle::pat_util;\n use middle::stability;\n use middle::subst::{self, ParamSpace, Subst, Substs, VecPerParamSpace};\n use middle::traits;\n@@ -2684,6 +2685,14 @@ impl<'tcx> ctxt<'tcx> {\n     {\n         self.ty_param_defs.borrow()[node_id].clone()\n     }\n+\n+    pub fn pat_contains_ref_binding(&self, pat: &ast::Pat) -> bool {\n+        pat_util::pat_contains_ref_binding(&self.def_map, pat)\n+    }\n+\n+    pub fn arm_contains_ref_binding(&self, arm: &ast::Arm) -> bool {\n+        pat_util::arm_contains_ref_binding(&self.def_map, arm)\n+    }\n }\n \n // Interns a type/name combination, stores the resulting box in cx.interner,"}, {"sha": "a66c0f351bf496e26b6a7dfcbdbcc30dde6968a9", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/45fae882568d9bf36ade39f210a2721d05e556dd/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45fae882568d9bf36ade39f210a2721d05e556dd/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=45fae882568d9bf36ade39f210a2721d05e556dd", "patch": "@@ -287,10 +287,11 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n     // (nmatsakis) an hour or two debugging to remember, so I thought\n     // I'd write them down this time.\n     //\n-    // 1. Most importantly, there is no loss of expressiveness\n-    // here. What we are saying is that the type of `x`\n-    // becomes *exactly* what is expected. This might seem\n-    // like it will cause errors in a case like this:\n+    // 1. There is no loss of expressiveness here, though it does\n+    // cause some inconvenience. What we are saying is that the type\n+    // of `x` becomes *exactly* what is expected. This can cause unnecessary\n+    // errors in some cases, such as this one:\n+    // it will cause errors in a case like this:\n     //\n     // ```\n     // fn foo<'x>(x: &'x int) {\n@@ -361,8 +362,21 @@ pub fn check_match<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                              match_src: ast::MatchSource) {\n     let tcx = fcx.ccx.tcx;\n \n-    let discrim_ty = fcx.infcx().next_ty_var();\n-    check_expr_has_type(fcx, discrim, discrim_ty);\n+    // Not entirely obvious: if matches may create ref bindings, we\n+    // want to use the *precise* type of the discriminant, *not* some\n+    // supertype, as the \"discriminant type\" (issue #23116).\n+    let contains_ref_bindings = arms.iter().any(|a| tcx.arm_contains_ref_binding(a));\n+    let discrim_ty;\n+    if contains_ref_bindings {\n+        check_expr(fcx, discrim);\n+        discrim_ty = fcx.expr_ty(discrim);\n+    } else {\n+        // ...but otherwise we want to use any supertype of the\n+        // discriminant. This is sort of a workaround, see note (*) in\n+        // `check_pat` for some details.\n+        discrim_ty = fcx.infcx().next_ty_var();\n+        check_expr_has_type(fcx, discrim, discrim_ty);\n+    };\n \n     // Typecheck the patterns first, so that we get types for all the\n     // bindings."}, {"sha": "09309c7bbeb88eb5ca2638bbe7a62565f0258b64", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/45fae882568d9bf36ade39f210a2721d05e556dd/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45fae882568d9bf36ade39f210a2721d05e556dd/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=45fae882568d9bf36ade39f210a2721d05e556dd", "patch": "@@ -4242,11 +4242,27 @@ impl<'tcx> Repr<'tcx> for Expectation<'tcx> {\n }\n \n pub fn check_decl_initializer<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n-                                       nid: ast::NodeId,\n+                                       local: &'tcx ast::Local,\n                                        init: &'tcx ast::Expr)\n {\n-    let local_ty = fcx.local_ty(init.span, nid);\n-    check_expr_coercable_to_type(fcx, init, local_ty)\n+    let ref_bindings = fcx.tcx().pat_contains_ref_binding(&local.pat);\n+\n+    let local_ty = fcx.local_ty(init.span, local.id);\n+    if !ref_bindings {\n+        check_expr_coercable_to_type(fcx, init, local_ty)\n+    } else {\n+        // Somewhat subtle: if we have a `ref` binding in the pattern,\n+        // we want to avoid introducing coercions for the RHS. This is\n+        // both because it helps preserve sanity and, in the case of\n+        // ref mut, for soundness (issue #23116). In particular, in\n+        // the latter case, we need to be clear that the type of the\n+        // referent for the reference that results is *equal to* the\n+        // type of the lvalue it is referencing, and not some\n+        // supertype thereof.\n+        check_expr(fcx, init);\n+        let init_ty = fcx.expr_ty(init);\n+        demand::eqtype(fcx, init.span, init_ty, local_ty);\n+    };\n }\n \n pub fn check_decl_local<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>, local: &'tcx ast::Local)  {\n@@ -4256,7 +4272,7 @@ pub fn check_decl_local<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>, local: &'tcx ast::Local)\n     fcx.write_ty(local.id, t);\n \n     if let Some(ref init) = local.init {\n-        check_decl_initializer(fcx, local.id, &**init);\n+        check_decl_initializer(fcx, local, &**init);\n         let init_ty = fcx.expr_ty(&**init);\n         if ty::type_is_error(init_ty) {\n             fcx.write_ty(local.id, init_ty);"}, {"sha": "c2b54a972bdc0dcace0d3ef459c68037e1041141", "filename": "src/test/compile-fail/match-ref-mut-invariance.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/45fae882568d9bf36ade39f210a2721d05e556dd/src%2Ftest%2Fcompile-fail%2Fmatch-ref-mut-invariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45fae882568d9bf36ade39f210a2721d05e556dd/src%2Ftest%2Fcompile-fail%2Fmatch-ref-mut-invariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-ref-mut-invariance.rs?ref=45fae882568d9bf36ade39f210a2721d05e556dd", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that when making a ref mut binding with type `&mut T`, the\n+// type `T` must match precisely the type `U` of the value being\n+// matched, and in particular cannot be some supertype of `U`. Issue\n+// #23116. This test focuses on a `match`.\n+\n+#![allow(dead_code)]\n+struct S<'b>(&'b i32);\n+impl<'b> S<'b> {\n+    fn bar<'a>(&'a mut self) -> &'a mut &'a i32 {\n+        match self.0 { ref mut x => x } //~ ERROR mismatched types\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "ea16c61dfd4d1648d0f71302fb66fd0430a713bd", "filename": "src/test/compile-fail/match-ref-mut-let-invariance.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/45fae882568d9bf36ade39f210a2721d05e556dd/src%2Ftest%2Fcompile-fail%2Fmatch-ref-mut-let-invariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45fae882568d9bf36ade39f210a2721d05e556dd/src%2Ftest%2Fcompile-fail%2Fmatch-ref-mut-let-invariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-ref-mut-let-invariance.rs?ref=45fae882568d9bf36ade39f210a2721d05e556dd", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that when making a ref mut binding with type `&mut T`, the\n+// type `T` must match precisely the type `U` of the value being\n+// matched, and in particular cannot be some supertype of `U`. Issue\n+// #23116. This test focuses on a `let`.\n+\n+#![allow(dead_code)]\n+struct S<'b>(&'b i32);\n+impl<'b> S<'b> {\n+    fn bar<'a>(&'a mut self) -> &'a mut &'a i32 {\n+        let ref mut x = self.0;\n+        x //~ ERROR mismatched types\n+    }\n+}\n+\n+fn main() {}"}]}