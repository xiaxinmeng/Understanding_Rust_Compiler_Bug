{"sha": "62267470f630c6bf8553feb65d5c130e6890ba70", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyMjY3NDcwZjYzMGM2YmY4NTUzZmViNjVkNWMxMzBlNjg5MGJhNzA=", "commit": {"author": {"name": "mitaa", "email": "mitaa.ceb@gmail.com", "date": "2016-02-27T06:35:05Z"}, "committer": {"name": "mitaa", "email": "mitaa.ceb@gmail.com", "date": "2016-03-03T15:11:10Z"}, "message": "Refactor src-link creation for local sources\n\nSince we emit the sources beforhand we actually **know** whether we\ncan safely create src-links to these files and where they are stored.", "tree": {"sha": "42aafaae9b1d1f7b3db5c973d0b37b96a8e7f218", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/42aafaae9b1d1f7b3db5c973d0b37b96a8e7f218"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/62267470f630c6bf8553feb65d5c130e6890ba70", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/62267470f630c6bf8553feb65d5c130e6890ba70", "html_url": "https://github.com/rust-lang/rust/commit/62267470f630c6bf8553feb65d5c130e6890ba70", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/62267470f630c6bf8553feb65d5c130e6890ba70/comments", "author": {"login": "mitaa", "id": 6785936, "node_id": "MDQ6VXNlcjY3ODU5MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/6785936?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mitaa", "html_url": "https://github.com/mitaa", "followers_url": "https://api.github.com/users/mitaa/followers", "following_url": "https://api.github.com/users/mitaa/following{/other_user}", "gists_url": "https://api.github.com/users/mitaa/gists{/gist_id}", "starred_url": "https://api.github.com/users/mitaa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mitaa/subscriptions", "organizations_url": "https://api.github.com/users/mitaa/orgs", "repos_url": "https://api.github.com/users/mitaa/repos", "events_url": "https://api.github.com/users/mitaa/events{/privacy}", "received_events_url": "https://api.github.com/users/mitaa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mitaa", "id": 6785936, "node_id": "MDQ6VXNlcjY3ODU5MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/6785936?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mitaa", "html_url": "https://github.com/mitaa", "followers_url": "https://api.github.com/users/mitaa/followers", "following_url": "https://api.github.com/users/mitaa/following{/other_user}", "gists_url": "https://api.github.com/users/mitaa/gists{/gist_id}", "starred_url": "https://api.github.com/users/mitaa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mitaa/subscriptions", "organizations_url": "https://api.github.com/users/mitaa/orgs", "repos_url": "https://api.github.com/users/mitaa/repos", "events_url": "https://api.github.com/users/mitaa/events{/privacy}", "received_events_url": "https://api.github.com/users/mitaa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6e125f04a54ec65eac0ecd3cb68e180210a06fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6e125f04a54ec65eac0ecd3cb68e180210a06fa", "html_url": "https://github.com/rust-lang/rust/commit/f6e125f04a54ec65eac0ecd3cb68e180210a06fa"}], "stats": {"total": 73, "additions": 32, "deletions": 41}, "files": [{"sha": "c9c9f1968133ee5789d01f99aad5af70e5fe3c91", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 32, "deletions": 41, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/62267470f630c6bf8553feb65d5c130e6890ba70/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62267470f630c6bf8553feb65d5c130e6890ba70/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=62267470f630c6bf8553feb65d5c130e6890ba70", "patch": "@@ -104,6 +104,8 @@ pub struct Context {\n     /// the source files are present in the html rendering, then this will be\n     /// `true`.\n     pub include_sources: bool,\n+    /// The local file sources we've emitted and their respective url-paths.\n+    pub local_sources: HashMap<PathBuf, String>,\n     /// A flag, which when turned off, will render pages which redirect to the\n     /// real location of an item. This is used to allow external links to\n     /// publicly reused items to redirect to the right location.\n@@ -262,8 +264,6 @@ pub struct Cache {\n struct SourceCollector<'a> {\n     cx: &'a mut Context,\n \n-    /// Processed source-file paths\n-    seen: HashSet<String>,\n     /// Root destination to place all HTML output into\n     dst: PathBuf,\n }\n@@ -423,6 +423,7 @@ pub fn run(mut krate: clean::Crate,\n             playground_url: \"\".to_string(),\n         },\n         include_sources: true,\n+        local_sources: HashMap::new(),\n         render_redirect_pages: false,\n         issue_tracker_base_url: None,\n     };\n@@ -770,11 +771,8 @@ fn render_sources(cx: &mut Context,\n     try_err!(mkdir(&dst), &dst);\n     let mut folder = SourceCollector {\n         dst: dst,\n-        seen: HashSet::new(),\n         cx: cx,\n     };\n-    // skip all invalid spans\n-    folder.seen.insert(\"\".to_string());\n     Ok(folder.fold_crate(krate))\n }\n \n@@ -866,7 +864,13 @@ impl<'a> DocFolder for SourceCollector<'a> {\n     fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n         // If we're including source files, and we haven't seen this file yet,\n         // then we need to render it out to the filesystem\n-        if self.cx.include_sources && !self.seen.contains(&item.source.filename) {\n+        if self.cx.include_sources\n+            // skip all invalid spans\n+            && item.source.filename != \"\"\n+            // macros from other libraries get special filenames which we can\n+            // safely ignore\n+            && !(item.source.filename.starts_with(\"<\")\n+                && item.source.filename.ends_with(\"macros>\")) {\n \n             // If it turns out that we couldn't read this file, then we probably\n             // can't read any of the files (generating html output from json or\n@@ -884,7 +888,6 @@ impl<'a> DocFolder for SourceCollector<'a> {\n                     false\n                 }\n             };\n-            self.seen.insert(item.source.filename.clone());\n         }\n \n         self.fold_item_recur(item)\n@@ -895,19 +898,14 @@ impl<'a> SourceCollector<'a> {\n     /// Renders the given filename into its corresponding HTML source file.\n     fn emit_source(&mut self, filename: &str) -> io::Result<()> {\n         let p = PathBuf::from(filename);\n+        if self.cx.local_sources.contains_key(&p) {\n+            // We've already emitted this source\n+            return Ok(());\n+        }\n \n-        // If we couldn't open this file, then just returns because it\n-        // probably means that it's some standard library macro thing and we\n-        // can't have the source to it anyway.\n         let mut contents = Vec::new();\n-        match File::open(&p).and_then(|mut f| f.read_to_end(&mut contents)) {\n-            Ok(r) => r,\n-            // macros from other libraries get special filenames which we can\n-            // safely ignore\n-            Err(..) if filename.starts_with(\"<\") &&\n-                       filename.ends_with(\"macros>\") => return Ok(()),\n-            Err(e) => return Err(e)\n-        };\n+        try!(File::open(&p).and_then(|mut f| f.read_to_end(&mut contents)));\n+\n         let contents = str::from_utf8(&contents).unwrap();\n \n         // Remove the utf-8 BOM if any\n@@ -920,16 +918,20 @@ impl<'a> SourceCollector<'a> {\n         // Create the intermediate directories\n         let mut cur = self.dst.clone();\n         let mut root_path = String::from(\"../../\");\n+        let mut href = String::new();\n         clean_srcpath(&self.cx.src_root, &p, false, |component| {\n             cur.push(component);\n             mkdir(&cur).unwrap();\n             root_path.push_str(\"../\");\n+            href.push_str(component);\n+            href.push('/');\n         });\n-\n         let mut fname = p.file_name().expect(\"source has no filename\")\n                          .to_os_string();\n         fname.push(\".html\");\n         cur.push(&fname[..]);\n+        href.push_str(&fname.to_string_lossy());\n+\n         let mut w = BufWriter::new(try!(File::create(&cur)));\n         let title = format!(\"{} -- source\", cur.file_name().unwrap()\n                                                .to_string_lossy());\n@@ -944,7 +946,8 @@ impl<'a> SourceCollector<'a> {\n         try!(layout::render(&mut w, &self.cx.layout,\n                             &page, &(\"\"), &Source(contents)));\n         try!(w.flush());\n-        return Ok(());\n+        self.cx.local_sources.insert(p, href);\n+        Ok(())\n     }\n }\n \n@@ -1459,7 +1462,7 @@ impl<'a> Item<'a> {\n     /// If `None` is returned, then a source link couldn't be generated. This\n     /// may happen, for example, with externally inlined items where the source\n     /// of their crate documentation isn't known.\n-    fn href(&self, cx: &Context) -> Option<String> {\n+    fn href(&self) -> Option<String> {\n         let href = if self.item.source.loline == self.item.source.hiline {\n             format!(\"{}\", self.item.source.loline)\n         } else {\n@@ -1492,25 +1495,13 @@ impl<'a> Item<'a> {\n         // know the span, so we plow forward and generate a proper url. The url\n         // has anchors for the line numbers that we're linking to.\n         } else if self.item.def_id.is_local() {\n-            let mut path = Vec::new();\n-            clean_srcpath(&cx.src_root, Path::new(&self.item.source.filename),\n-                          true, |component| {\n-                path.push(component.to_string());\n-            });\n-\n-            // If the span points into an external macro the\n-            // source-file will be bogus, i.e `<foo macros>`\n-            let filename = &self.item.source.filename;\n-            if !(filename.starts_with(\"<\") && filename.ends_with(\"macros>\")) {\n-                Some(format!(\"{root}src/{krate}/{path}.html#{href}\",\n-                             root = self.cx.root_path,\n-                             krate = self.cx.layout.krate,\n-                             path = path.join(\"/\"),\n-                             href = href))\n-            } else {\n-                None\n-            }\n-\n+            self.cx.local_sources.get(&PathBuf::from(&self.item.source.filename)).map(|path| {\n+                format!(\"{root}src/{krate}/{path}.html#{href}\",\n+                        root = self.cx.root_path,\n+                        krate = self.cx.layout.krate,\n+                        path = path,\n+                        href = href)\n+            })\n         // If this item is not part of the local crate, then things get a little\n         // trickier. We don't actually know the span of the external item, but\n         // we know that the documentation on the other end knows the span!\n@@ -1590,7 +1581,7 @@ impl<'a> fmt::Display for Item<'a> {\n         // this page, and this link will be auto-clicked. The `id` attribute is\n         // used to find the link to auto-click.\n         if self.cx.include_sources && !is_primitive {\n-            match self.href(self.cx) {\n+            match self.href() {\n                 Some(l) => {\n                     try!(write!(fmt, \"<a id='src-{}' class='srclink' \\\n                                        href='{}' title='{}'>[src]</a>\","}]}