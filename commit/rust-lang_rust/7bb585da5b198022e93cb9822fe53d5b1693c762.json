{"sha": "7bb585da5b198022e93cb9822fe53d5b1693c762", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiYjU4NWRhNWIxOTgwMjJlOTNjYjk4MjJmZTUzZDViMTY5M2M3NjI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-07-23T23:10:04Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-07-24T18:14:50Z"}, "message": "trans: Try to detect the Universal CRT on MSVC\n\nVisual Studio 2015, recently released, includes the Universal CRT, a different\nflavor than was provided before. The binaries and header files for this library\nare included in new locations not previously known about by gcc-rs, and this\ncommit adds support for the necessary probing to find these.\n\nUnfortunately there are no prior examples of this probing to be found in\nframeworks like CMake or clang, so this is done is a bit of a sketchy method\ntoday. It assumes that the installation is in a relatively standard format and\nthen blindly looks for the location of the UCRT. I'd love to switch this over to\nusing registry keys for probing, but I was currently unable to find such keys.\n\nThis should enable the compiler to work outside VS 2015 dev tools prompts.", "tree": {"sha": "64cb5b7ff30edebfde39978b343a342384df5663", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/64cb5b7ff30edebfde39978b343a342384df5663"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7bb585da5b198022e93cb9822fe53d5b1693c762", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7bb585da5b198022e93cb9822fe53d5b1693c762", "html_url": "https://github.com/rust-lang/rust/commit/7bb585da5b198022e93cb9822fe53d5b1693c762", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7bb585da5b198022e93cb9822fe53d5b1693c762/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "95ec4be02b72982246cf3b84133d1e5b1c44f3f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/95ec4be02b72982246cf3b84133d1e5b1c44f3f6", "html_url": "https://github.com/rust-lang/rust/commit/95ec4be02b72982246cf3b84133d1e5b1c44f3f6"}], "stats": {"total": 88, "additions": 76, "deletions": 12}, "files": [{"sha": "bc0573d8281d872d13086fa4d31ccacb2df6f126", "filename": "src/librustc_trans/back/msvc/mod.rs", "status": "modified", "additions": 76, "deletions": 12, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/7bb585da5b198022e93cb9822fe53d5b1693c762/src%2Flibrustc_trans%2Fback%2Fmsvc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bb585da5b198022e93cb9822fe53d5b1693c762/src%2Flibrustc_trans%2Fback%2Fmsvc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fmsvc%2Fmod.rs?ref=7bb585da5b198022e93cb9822fe53d5b1693c762", "patch": "@@ -42,7 +42,8 @@ pub fn link_exe_cmd(sess: &Session) -> Command {\n     use std::env;\n     use std::ffi::OsString;\n     use std::fs;\n-    use std::path::PathBuf;\n+    use std::io;\n+    use std::path::{Path, PathBuf};\n     use self::registry::{RegistryKey, LOCAL_MACHINE};\n \n     // When finding the link.exe binary the 32-bit version is at the top level\n@@ -103,16 +104,32 @@ pub fn link_exe_cmd(sess: &Session) -> Command {\n     // VS shells, so we only want to start adding our own pieces if it's not\n     // set.\n     //\n-    // If we're adding our own pieces, then we need to add two primary\n+    // If we're adding our own pieces, then we need to add a few primary\n     // directories to the default search path for the linker. The first is in\n-    // the VS install direcotry and the next is the Windows SDK directory.\n+    // the VS install direcotry, the next is the Windows SDK directory, and the\n+    // last is the possible UCRT installation directory.\n+    //\n+    // The UCRT is a recent addition to Visual Studio installs (2015 at the time\n+    // of this writing), and it's in the normal windows SDK folder, but there\n+    // apparently aren't registry keys pointing to it. As a result we detect the\n+    // installation and then add it manually. This logic will probably need to\n+    // be tweaked over time...\n     if env::var_os(\"LIB\").is_none() {\n         if let Some(mut vs_install_dir) = vs_install_dir {\n             vs_install_dir.push(\"VC/lib\");\n             vs_install_dir.push(extra);\n             let mut arg = OsString::from(\"/LIBPATH:\");\n             arg.push(&vs_install_dir);\n             cmd.arg(arg);\n+\n+            if let Some((ucrt_root, vers)) = ucrt_install_dir(&vs_install_dir) {\n+                if let Some(arch) = windows_sdk_v8_subdir(sess) {\n+                    let mut arg = OsString::from(\"/LIBPATH:\");\n+                    arg.push(ucrt_root.join(\"Lib\").join(vers)\n+                                      .join(\"ucrt\").join(arch));\n+                    cmd.arg(arg);\n+                }\n+            }\n         }\n         if let Some(path) = get_windows_sdk_lib_path(sess) {\n             let mut arg = OsString::from(\"/LIBPATH:\");\n@@ -189,7 +206,7 @@ pub fn link_exe_cmd(sess: &Session) -> Command {\n         return max_key\n     }\n \n-    fn get_windows_sdk_lib_path(sess: &Session) -> Option<PathBuf> {\n+    fn get_windows_sdk_path() -> Option<(PathBuf, usize)> {\n         let key = r\"SOFTWARE\\Microsoft\\Microsoft SDKs\\Windows\";\n         let key = LOCAL_MACHINE.open(key.as_ref());\n         let (n, k) = match key.ok().as_ref().and_then(max_version) {\n@@ -199,10 +216,17 @@ pub fn link_exe_cmd(sess: &Session) -> Command {\n         let mut parts = n.to_str().unwrap().trim_left_matches(\"v\").splitn(2, \".\");\n         let major = parts.next().unwrap().parse::<usize>().unwrap();\n         let _minor = parts.next().unwrap().parse::<usize>().unwrap();\n-        let path = match k.query_str(\"InstallationFolder\") {\n-            Ok(p) => PathBuf::from(p).join(\"Lib\"),\n-            Err(..) => return None,\n+        k.query_str(\"InstallationFolder\").ok().map(|folder| {\n+            (PathBuf::from(folder), major)\n+        })\n+    }\n+\n+    fn get_windows_sdk_lib_path(sess: &Session) -> Option<PathBuf> {\n+        let (mut path, major) = match get_windows_sdk_path() {\n+            Some(p) => p,\n+            None => return None,\n         };\n+        path.push(\"Lib\");\n         if major <= 7 {\n             // In Windows SDK 7.x, x86 libraries are directly in the Lib folder,\n             // x64 libraries are inside, and it's not necessary to link agains\n@@ -218,11 +242,9 @@ pub fn link_exe_cmd(sess: &Session) -> Command {\n             // depend on the version of the OS you're targeting. By default\n             // choose the newest, which usually corresponds to the version of\n             // the OS you've installed the SDK on.\n-            let extra = match &sess.target.target.arch[..] {\n-                \"x86\" => \"x86\",\n-                \"x86_64\" => \"x64\",\n-                \"arm\" => \"arm\",\n-                _ => return None,\n+            let extra = match windows_sdk_v8_subdir(sess) {\n+                Some(e) => e,\n+                None => return None,\n             };\n             [\"winv6.3\", \"win8\", \"win7\"].iter().map(|p| path.join(p)).find(|part| {\n                 fs::metadata(part).is_ok()\n@@ -231,6 +253,48 @@ pub fn link_exe_cmd(sess: &Session) -> Command {\n             })\n         }\n     }\n+\n+    fn windows_sdk_v8_subdir(sess: &Session) -> Option<&'static str> {\n+        match &sess.target.target.arch[..] {\n+            \"x86\" => Some(\"x86\"),\n+            \"x86_64\" => Some(\"x64\"),\n+            \"arm\" => Some(\"arm\"),\n+            _ => return None,\n+        }\n+    }\n+\n+    fn ucrt_install_dir(vs_install_dir: &Path) -> Option<(PathBuf, String)> {\n+        let is_vs_14 = vs_install_dir.iter().filter_map(|p| p.to_str()).any(|s| {\n+            s == \"Microsoft Visual Studio 14.0\"\n+        });\n+        if !is_vs_14 {\n+            return None\n+        }\n+        let key = r\"SOFTWARE\\Microsoft\\Windows Kits\\Installed Roots\";\n+        let sdk_dir = LOCAL_MACHINE.open(key.as_ref()).and_then(|p| {\n+            p.query_str(\"KitsRoot10\")\n+        }).map(PathBuf::from);\n+        let sdk_dir = match sdk_dir {\n+            Ok(p) => p,\n+            Err(..) => return None,\n+        };\n+        (move || -> io::Result<_> {\n+            let mut max = None;\n+            let mut max_s = None;\n+            for entry in try!(fs::read_dir(&sdk_dir.join(\"Lib\"))) {\n+                let entry = try!(entry);\n+                if let Ok(s) = entry.file_name().into_string() {\n+                    if let Ok(u) = s.replace(\".\", \"\").parse::<usize>() {\n+                        if Some(u) > max {\n+                            max = Some(u);\n+                            max_s = Some(s);\n+                        }\n+                    }\n+                }\n+            }\n+            Ok(max_s.map(|m| (sdk_dir, m)))\n+        })().ok().and_then(|x| x)\n+    }\n }\n \n #[cfg(not(windows))]"}]}