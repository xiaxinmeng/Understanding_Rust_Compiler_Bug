{"sha": "397b66e77b279de5006facf87979f9ecff5c7f87", "node_id": "C_kwDOAAsO6NoAKDM5N2I2NmU3N2IyNzlkZTUwMDZmYWNmODc5NzlmOWVjZmY1YzdmODc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-15T11:11:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-15T11:11:49Z"}, "message": "Auto merge of #105285 - compiler-errors:conflicting-param-env-2, r=estebank\n\nHighlight conflicting param-env candidates, again\n\nUn-reverts #98794 (i.e. reverts #99290).\n\nThe previous time I attempted to land this PR, it was because of an incremental issue (#99233). The repro instructions in the issue is no longer manifest the ICE -- I think it's because this ambiguity code was refactored (I think by `@lcnr)` to no longer store the ambiguities in the fulfillment error, but instead recompute them on the fly.\n\nThe main motivation for trying to re-land this is that it fixes #105131 by highlighting the root-cause of the issue, which is conflicting param-env candidates:\n\n```\nerror[E0283]: type annotations needed: cannot satisfy `Self: Gen<'source>`\n   |\nnote: multiple `impl`s or `where` clauses satisfying `Self: Gen<'source>` found\n  --> $DIR/conflicting-bounds.rs:3:1\n   |\nLL | pub trait Gen<'source> {\n   | ^^^^^^^^^^^^^^^^^^^^^^\n...\nLL |         Self: for<'s> Gen<'s, Output = T>;\n   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0283`.\n```\n\nFixes #105131.\nFixes (again) #98786", "tree": {"sha": "5ab37d8577f6e34c7976464f39bc3bbe6a7d14d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ab37d8577f6e34c7976464f39bc3bbe6a7d14d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/397b66e77b279de5006facf87979f9ecff5c7f87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/397b66e77b279de5006facf87979f9ecff5c7f87", "html_url": "https://github.com/rust-lang/rust/commit/397b66e77b279de5006facf87979f9ecff5c7f87", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/397b66e77b279de5006facf87979f9ecff5c7f87/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d67000e44e1b9908c81fc4d5de875608f1b80ae9", "url": "https://api.github.com/repos/rust-lang/rust/commits/d67000e44e1b9908c81fc4d5de875608f1b80ae9", "html_url": "https://github.com/rust-lang/rust/commit/d67000e44e1b9908c81fc4d5de875608f1b80ae9"}, {"sha": "d10f6b44e1243bf4d68ed4f0f5038049330a047e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d10f6b44e1243bf4d68ed4f0f5038049330a047e", "html_url": "https://github.com/rust-lang/rust/commit/d10f6b44e1243bf4d68ed4f0f5038049330a047e"}], "stats": {"total": 224, "additions": 183, "deletions": 41}, "files": [{"sha": "0c1717cff332c40e79bede7a633994be3c054155", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/ambiguity.rs", "status": "modified", "additions": 64, "deletions": 15, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/397b66e77b279de5006facf87979f9ecff5c7f87/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fambiguity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/397b66e77b279de5006facf87979f9ecff5c7f87/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fambiguity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fambiguity.rs?ref=397b66e77b279de5006facf87979f9ecff5c7f87", "patch": "@@ -1,52 +1,101 @@\n use rustc_hir::def_id::DefId;\n-use rustc_infer::infer::InferCtxt;\n+use rustc_infer::infer::{InferCtxt, LateBoundRegionConversionTime};\n+use rustc_infer::traits::util::elaborate_predicates_with_span;\n use rustc_infer::traits::{Obligation, ObligationCause, TraitObligation};\n-use rustc_span::DUMMY_SP;\n+use rustc_middle::ty;\n+use rustc_span::{Span, DUMMY_SP};\n \n use crate::traits::ObligationCtxt;\n \n+pub enum Ambiguity {\n+    DefId(DefId),\n+    ParamEnv(Span),\n+}\n+\n pub fn recompute_applicable_impls<'tcx>(\n     infcx: &InferCtxt<'tcx>,\n     obligation: &TraitObligation<'tcx>,\n-) -> Vec<DefId> {\n+) -> Vec<Ambiguity> {\n     let tcx = infcx.tcx;\n     let param_env = obligation.param_env;\n-    let dummy_cause = ObligationCause::dummy();\n+\n     let impl_may_apply = |impl_def_id| {\n         let ocx = ObligationCtxt::new_in_snapshot(infcx);\n         let placeholder_obligation =\n             infcx.replace_bound_vars_with_placeholders(obligation.predicate);\n         let obligation_trait_ref =\n-            ocx.normalize(&dummy_cause, param_env, placeholder_obligation.trait_ref);\n+            ocx.normalize(&ObligationCause::dummy(), param_env, placeholder_obligation.trait_ref);\n \n         let impl_substs = infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n         let impl_trait_ref = tcx.bound_impl_trait_ref(impl_def_id).unwrap().subst(tcx, impl_substs);\n         let impl_trait_ref = ocx.normalize(&ObligationCause::dummy(), param_env, impl_trait_ref);\n \n-        if let Err(_) = ocx.eq(&dummy_cause, param_env, obligation_trait_ref, impl_trait_ref) {\n+        if let Err(_) =\n+            ocx.eq(&ObligationCause::dummy(), param_env, obligation_trait_ref, impl_trait_ref)\n+        {\n             return false;\n         }\n \n         let impl_predicates = tcx.predicates_of(impl_def_id).instantiate(tcx, impl_substs);\n-        ocx.register_obligations(\n-            impl_predicates\n-                .predicates\n-                .iter()\n-                .map(|&predicate| Obligation::new(tcx, dummy_cause.clone(), param_env, predicate)),\n+        ocx.register_obligations(impl_predicates.predicates.iter().map(|&predicate| {\n+            Obligation::new(tcx, ObligationCause::dummy(), param_env, predicate)\n+        }));\n+\n+        ocx.select_where_possible().is_empty()\n+    };\n+\n+    let param_env_candidate_may_apply = |poly_trait_predicate: ty::PolyTraitPredicate<'tcx>| {\n+        let ocx = ObligationCtxt::new_in_snapshot(infcx);\n+        let placeholder_obligation =\n+            infcx.replace_bound_vars_with_placeholders(obligation.predicate);\n+        let obligation_trait_ref =\n+            ocx.normalize(&ObligationCause::dummy(), param_env, placeholder_obligation.trait_ref);\n+\n+        let param_env_predicate = infcx.replace_bound_vars_with_fresh_vars(\n+            DUMMY_SP,\n+            LateBoundRegionConversionTime::HigherRankedType,\n+            poly_trait_predicate,\n         );\n+        let param_env_trait_ref =\n+            ocx.normalize(&ObligationCause::dummy(), param_env, param_env_predicate.trait_ref);\n+\n+        if let Err(_) =\n+            ocx.eq(&ObligationCause::dummy(), param_env, obligation_trait_ref, param_env_trait_ref)\n+        {\n+            return false;\n+        }\n \n         ocx.select_where_possible().is_empty()\n     };\n \n-    let mut impls = Vec::new();\n+    let mut ambiguities = Vec::new();\n+\n     tcx.for_each_relevant_impl(\n         obligation.predicate.def_id(),\n         obligation.predicate.skip_binder().trait_ref.self_ty(),\n         |impl_def_id| {\n-            if infcx.probe(move |_snapshot| impl_may_apply(impl_def_id)) {\n-                impls.push(impl_def_id)\n+            if infcx.probe(|_| impl_may_apply(impl_def_id)) {\n+                ambiguities.push(Ambiguity::DefId(impl_def_id))\n             }\n         },\n     );\n-    impls\n+\n+    let predicates =\n+        tcx.predicates_of(obligation.cause.body_id.owner.to_def_id()).instantiate_identity(tcx);\n+    for obligation in\n+        elaborate_predicates_with_span(tcx, std::iter::zip(predicates.predicates, predicates.spans))\n+    {\n+        let kind = obligation.predicate.kind();\n+        if let ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred)) = kind.skip_binder()\n+            && param_env_candidate_may_apply(kind.rebind(trait_pred))\n+        {\n+            if kind.rebind(trait_pred.trait_ref) == ty::TraitRef::identity(tcx, trait_pred.def_id()) {\n+                ambiguities.push(Ambiguity::ParamEnv(tcx.def_span(trait_pred.def_id())))\n+            } else {\n+                ambiguities.push(Ambiguity::ParamEnv(obligation.cause.span))\n+            }\n+        }\n+    }\n+\n+    ambiguities\n }"}, {"sha": "654346bfa7141537ac868130128fa2cadf2b4c6e", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 35, "deletions": 13, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/397b66e77b279de5006facf87979f9ecff5c7f87/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/397b66e77b279de5006facf87979f9ecff5c7f87/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=397b66e77b279de5006facf87979f9ecff5c7f87", "patch": "@@ -1487,7 +1487,7 @@ trait InferCtxtPrivExt<'tcx> {\n     fn annotate_source_of_ambiguity(\n         &self,\n         err: &mut Diagnostic,\n-        impls: &[DefId],\n+        impls: &[ambiguity::Ambiguity],\n         predicate: ty::Predicate<'tcx>,\n     );\n \n@@ -2180,13 +2180,22 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 let mut selcx = SelectionContext::new(&self);\n                 match selcx.select_from_obligation(&obligation) {\n                     Ok(None) => {\n-                        let impls = ambiguity::recompute_applicable_impls(self.infcx, &obligation);\n+                        let ambiguities =\n+                            ambiguity::recompute_applicable_impls(self.infcx, &obligation);\n                         let has_non_region_infer =\n                             trait_ref.skip_binder().substs.types().any(|t| !t.is_ty_infer());\n                         // It doesn't make sense to talk about applicable impls if there are more\n                         // than a handful of them.\n-                        if impls.len() > 1 && impls.len() < 10 && has_non_region_infer {\n-                            self.annotate_source_of_ambiguity(&mut err, &impls, predicate);\n+                        if ambiguities.len() > 1 && ambiguities.len() < 10 && has_non_region_infer {\n+                            if self.tainted_by_errors().is_some() && subst.is_none() {\n+                                // If `subst.is_none()`, then this is probably two param-env\n+                                // candidates or impl candidates that are equal modulo lifetimes.\n+                                // Therefore, if we've already emitted an error, just skip this\n+                                // one, since it's not particularly actionable.\n+                                err.cancel();\n+                                return;\n+                            }\n+                            self.annotate_source_of_ambiguity(&mut err, &ambiguities, predicate);\n                         } else {\n                             if self.tainted_by_errors().is_some() {\n                                 err.cancel();\n@@ -2434,21 +2443,30 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n     fn annotate_source_of_ambiguity(\n         &self,\n         err: &mut Diagnostic,\n-        impls: &[DefId],\n+        ambiguities: &[ambiguity::Ambiguity],\n         predicate: ty::Predicate<'tcx>,\n     ) {\n         let mut spans = vec![];\n         let mut crates = vec![];\n         let mut post = vec![];\n-        for def_id in impls {\n-            match self.tcx.span_of_impl(*def_id) {\n-                Ok(span) => spans.push(span),\n-                Err(name) => {\n-                    crates.push(name);\n-                    if let Some(header) = to_pretty_impl_header(self.tcx, *def_id) {\n-                        post.push(header);\n+        let mut has_param_env = false;\n+        for ambiguity in ambiguities {\n+            match ambiguity {\n+                ambiguity::Ambiguity::DefId(impl_def_id) => {\n+                    match self.tcx.span_of_impl(*impl_def_id) {\n+                        Ok(span) => spans.push(span),\n+                        Err(name) => {\n+                            crates.push(name);\n+                            if let Some(header) = to_pretty_impl_header(self.tcx, *impl_def_id) {\n+                                post.push(header);\n+                            }\n+                        }\n                     }\n                 }\n+                ambiguity::Ambiguity::ParamEnv(span) => {\n+                    has_param_env = true;\n+                    spans.push(*span);\n+                }\n             }\n         }\n         let mut crate_names: Vec<_> = crates.iter().map(|n| format!(\"`{}`\", n)).collect();\n@@ -2472,7 +2490,11 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             return;\n         }\n \n-        let msg = format!(\"multiple `impl`s satisfying `{}` found\", predicate);\n+        let msg = format!(\n+            \"multiple `impl`s{} satisfying `{}` found\",\n+            if has_param_env { \" or `where` clauses\" } else { \"\" },\n+            predicate\n+        );\n         let post = if post.len() > 1 || (post.len() == 1 && post[0].contains('\\n')) {\n             format!(\":\\n{}\", post.iter().map(|p| format!(\"- {}\", p)).collect::<Vec<_>>().join(\"\\n\"),)\n         } else if post.len() == 1 {"}, {"sha": "0af5493f81675502ced616895b8f4bf9b1ccc503", "filename": "src/test/ui/const-generics/generic_const_exprs/issue-72787.min.stderr", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/397b66e77b279de5006facf87979f9ecff5c7f87/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-72787.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/397b66e77b279de5006facf87979f9ecff5c7f87/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-72787.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-72787.min.stderr?ref=397b66e77b279de5006facf87979f9ecff5c7f87", "patch": "@@ -40,17 +40,35 @@ error[E0283]: type annotations needed: cannot satisfy `IsLessOrEqual<I, 8>: True\n LL |     IsLessOrEqual<I, 8>: True,\n    |                          ^^^^\n    |\n-   = note: cannot satisfy `IsLessOrEqual<I, 8>: True`\n-   = help: the trait `True` is implemented for `IsLessOrEqual<LHS, RHS>`\n+note: multiple `impl`s or `where` clauses satisfying `IsLessOrEqual<I, 8>: True` found\n+  --> $DIR/issue-72787.rs:10:1\n+   |\n+LL | impl<const LHS: u32, const RHS: u32> True for IsLessOrEqual<LHS, RHS> where\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL |     IsLessOrEqual<I, 8>: True,\n+   |                          ^^^^\n+...\n+LL |     IsLessOrEqual<{ 8 - I }, { 8 - J }>: True,\n+   |                                          ^^^^\n \n error[E0283]: type annotations needed: cannot satisfy `IsLessOrEqual<I, 8>: True`\n   --> $DIR/issue-72787.rs:21:26\n    |\n LL |     IsLessOrEqual<I, 8>: True,\n    |                          ^^^^\n    |\n-   = note: cannot satisfy `IsLessOrEqual<I, 8>: True`\n-   = help: the trait `True` is implemented for `IsLessOrEqual<LHS, RHS>`\n+note: multiple `impl`s or `where` clauses satisfying `IsLessOrEqual<I, 8>: True` found\n+  --> $DIR/issue-72787.rs:10:1\n+   |\n+LL | impl<const LHS: u32, const RHS: u32> True for IsLessOrEqual<LHS, RHS> where\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL |     IsLessOrEqual<I, 8>: True,\n+   |                          ^^^^\n+...\n+LL |     IsLessOrEqual<{ 8 - I }, { 8 - J }>: True,\n+   |                                          ^^^^\n \n error: aborting due to 6 previous errors\n "}, {"sha": "2d60b18b1f208eae86ab14800e0e4053f93304d4", "filename": "src/test/ui/issues/issue-21974.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/397b66e77b279de5006facf87979f9ecff5c7f87/src%2Ftest%2Fui%2Fissues%2Fissue-21974.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/397b66e77b279de5006facf87979f9ecff5c7f87/src%2Ftest%2Fui%2Fissues%2Fissue-21974.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-21974.stderr?ref=397b66e77b279de5006facf87979f9ecff5c7f87", "patch": "@@ -4,7 +4,13 @@ error[E0283]: type annotations needed: cannot satisfy `&'a T: Foo`\n LL |     where &'a T : Foo,\n    |                   ^^^\n    |\n-   = note: cannot satisfy `&'a T: Foo`\n+note: multiple `impl`s or `where` clauses satisfying `&'a T: Foo` found\n+  --> $DIR/issue-21974.rs:11:19\n+   |\n+LL |     where &'a T : Foo,\n+   |                   ^^^\n+LL |           &'b T : Foo\n+   |                   ^^^\n \n error: aborting due to previous error\n "}, {"sha": "50d7f988e194cdcd30d2fc72c9dd6a639eaebcd4", "filename": "src/test/ui/issues/issue-24424.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/397b66e77b279de5006facf87979f9ecff5c7f87/src%2Ftest%2Fui%2Fissues%2Fissue-24424.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/397b66e77b279de5006facf87979f9ecff5c7f87/src%2Ftest%2Fui%2Fissues%2Fissue-24424.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-24424.stderr?ref=397b66e77b279de5006facf87979f9ecff5c7f87", "patch": "@@ -4,7 +4,11 @@ error[E0283]: type annotations needed: cannot satisfy `T0: Trait0<'l0>`\n LL | impl <'l0, 'l1, T0> Trait1<'l0, T0> for bool where T0 : Trait0<'l0>, T0 : Trait0<'l1> {}\n    |                                                         ^^^^^^^^^^^\n    |\n-   = note: cannot satisfy `T0: Trait0<'l0>`\n+note: multiple `impl`s or `where` clauses satisfying `T0: Trait0<'l0>` found\n+  --> $DIR/issue-24424.rs:4:57\n+   |\n+LL | impl <'l0, 'l1, T0> Trait1<'l0, T0> for bool where T0 : Trait0<'l0>, T0 : Trait0<'l1> {}\n+   |                                                         ^^^^^^^^^^^       ^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "f37f163dbb6392eae958b3dacf86dab0dce2c514", "filename": "src/test/ui/lifetimes/conflicting-bounds.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/397b66e77b279de5006facf87979f9ecff5c7f87/src%2Ftest%2Fui%2Flifetimes%2Fconflicting-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/397b66e77b279de5006facf87979f9ecff5c7f87/src%2Ftest%2Fui%2Flifetimes%2Fconflicting-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Fconflicting-bounds.rs?ref=397b66e77b279de5006facf87979f9ecff5c7f87", "patch": "@@ -0,0 +1,11 @@\n+//~ type annotations needed: cannot satisfy `Self: Gen<'source>`\n+\n+pub trait Gen<'source> {\n+    type Output;\n+\n+    fn gen<T>(&self) -> T\n+    where\n+        Self: for<'s> Gen<'s, Output = T>;\n+}\n+\n+fn main() {}"}, {"sha": "42aa393667dc2a260f1267e77226dd7329ffc0dc", "filename": "src/test/ui/lifetimes/conflicting-bounds.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/397b66e77b279de5006facf87979f9ecff5c7f87/src%2Ftest%2Fui%2Flifetimes%2Fconflicting-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/397b66e77b279de5006facf87979f9ecff5c7f87/src%2Ftest%2Fui%2Flifetimes%2Fconflicting-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Fconflicting-bounds.stderr?ref=397b66e77b279de5006facf87979f9ecff5c7f87", "patch": "@@ -0,0 +1,14 @@\n+error[E0283]: type annotations needed: cannot satisfy `Self: Gen<'source>`\n+   |\n+note: multiple `impl`s or `where` clauses satisfying `Self: Gen<'source>` found\n+  --> $DIR/conflicting-bounds.rs:3:1\n+   |\n+LL | pub trait Gen<'source> {\n+   | ^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL |         Self: for<'s> Gen<'s, Output = T>;\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0283`."}, {"sha": "3d4208031cd06b9879de3326b066a2b0a81bec8a", "filename": "src/test/ui/lifetimes/issue-34979.stderr", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/397b66e77b279de5006facf87979f9ecff5c7f87/src%2Ftest%2Fui%2Flifetimes%2Fissue-34979.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/397b66e77b279de5006facf87979f9ecff5c7f87/src%2Ftest%2Fui%2Flifetimes%2Fissue-34979.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Fissue-34979.stderr?ref=397b66e77b279de5006facf87979f9ecff5c7f87", "patch": "@@ -4,8 +4,16 @@ error[E0283]: type annotations needed: cannot satisfy `&'a (): Foo`\n LL |     &'a (): Foo,\n    |             ^^^\n    |\n-   = note: cannot satisfy `&'a (): Foo`\n-   = help: the trait `Foo` is implemented for `&'a T`\n+note: multiple `impl`s or `where` clauses satisfying `&'a (): Foo` found\n+  --> $DIR/issue-34979.rs:2:1\n+   |\n+LL | impl<'a, T> Foo for &'a T {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL |     &'a (): Foo,\n+   |             ^^^\n+LL |     &'static (): Foo;\n+   |                  ^^^\n \n error: aborting due to previous error\n "}, {"sha": "9e80497ca6e92a1cf95c3f58df7ca752a728e388", "filename": "src/test/ui/traits/issue-85735.stderr", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/397b66e77b279de5006facf87979f9ecff5c7f87/src%2Ftest%2Fui%2Ftraits%2Fissue-85735.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/397b66e77b279de5006facf87979f9ecff5c7f87/src%2Ftest%2Fui%2Ftraits%2Fissue-85735.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fissue-85735.stderr?ref=397b66e77b279de5006facf87979f9ecff5c7f87", "patch": "@@ -4,10 +4,14 @@ error[E0283]: type annotations needed: cannot satisfy `T: FnMut<(&'a (),)>`\n LL |     T: FnMut(&'a ()),\n    |        ^^^^^^^^^^^^^\n    |\n-   = note: cannot satisfy `T: FnMut<(&'a (),)>`\n-   = help: the following types implement trait `FnMut<Args>`:\n-             &F\n-             &mut F\n+note: multiple `impl`s or `where` clauses satisfying `T: FnMut<(&'a (),)>` found\n+  --> $DIR/issue-85735.rs:7:8\n+   |\n+LL |     T: FnMut(&'a ()),\n+   |        ^^^^^^^^^^^^^\n+LL |\n+LL |     T: FnMut(&'b ()),\n+   |        ^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "d15fd23418bb0be17020759ab5df157b6891b0b3", "filename": "src/test/ui/type/type-check/issue-40294.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/397b66e77b279de5006facf87979f9ecff5c7f87/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fissue-40294.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/397b66e77b279de5006facf87979f9ecff5c7f87/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fissue-40294.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fissue-40294.stderr?ref=397b66e77b279de5006facf87979f9ecff5c7f87", "patch": "@@ -4,7 +4,13 @@ error[E0283]: type annotations needed: cannot satisfy `&'a T: Foo`\n LL |     where &'a T : Foo,\n    |                   ^^^\n    |\n-   = note: cannot satisfy `&'a T: Foo`\n+note: multiple `impl`s or `where` clauses satisfying `&'a T: Foo` found\n+  --> $DIR/issue-40294.rs:6:19\n+   |\n+LL |     where &'a T : Foo,\n+   |                   ^^^\n+LL |           &'b T : Foo\n+   |                   ^^^\n \n error: aborting due to previous error\n "}]}