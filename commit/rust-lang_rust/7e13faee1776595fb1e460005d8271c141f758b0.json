{"sha": "7e13faee1776595fb1e460005d8271c141f758b0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlMTNmYWVlMTc3NjU5NWZiMWU0NjAwMDVkODI3MWMxNDFmNzU4YjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-19T00:54:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-19T00:54:38Z"}, "message": "Auto merge of #27849 - jonas-schievink:macro-errors, r=nikomatsakis\n\nAnd some small indentation/code style fixes in the macro parser.", "tree": {"sha": "3ba8c59f77a6af29a591a8d85fa56ccf9e111536", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3ba8c59f77a6af29a591a8d85fa56ccf9e111536"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7e13faee1776595fb1e460005d8271c141f758b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7e13faee1776595fb1e460005d8271c141f758b0", "html_url": "https://github.com/rust-lang/rust/commit/7e13faee1776595fb1e460005d8271c141f758b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7e13faee1776595fb1e460005d8271c141f758b0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c1daeb7adc200f9dda17de78bdc599644910c4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c1daeb7adc200f9dda17de78bdc599644910c4b", "html_url": "https://github.com/rust-lang/rust/commit/4c1daeb7adc200f9dda17de78bdc599644910c4b"}, {"sha": "5e8d39ebfd0353b0912fbdbe9763977f8fb72fb3", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e8d39ebfd0353b0912fbdbe9763977f8fb72fb3", "html_url": "https://github.com/rust-lang/rust/commit/5e8d39ebfd0353b0912fbdbe9763977f8fb72fb3"}], "stats": {"total": 98, "additions": 51, "deletions": 47}, "files": [{"sha": "f6513cc3e255297d279dae08d18274302c62fb09", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 50, "deletions": 46, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/7e13faee1776595fb1e460005d8271c141f758b0/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e13faee1776595fb1e460005d8271c141f758b0/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=7e13faee1776595fb1e460005d8271c141f758b0", "patch": "@@ -401,7 +401,7 @@ pub fn parse(sess: &ParseSess,\n                         }\n                     }\n                     TtToken(sp, SubstNt(..)) => {\n-                        return Error(sp, \"Cannot transcribe in macro LHS\".to_string())\n+                        return Error(sp, \"missing fragment specifier\".to_string())\n                     }\n                     seq @ TtDelimited(..) | seq @ TtToken(_, DocComment(..)) => {\n                         let lower_elts = mem::replace(&mut ei.top_elts, Tt(seq));\n@@ -440,20 +440,24 @@ pub fn parse(sess: &ParseSess,\n         } else {\n             if (!bb_eis.is_empty() && !next_eis.is_empty())\n                 || bb_eis.len() > 1 {\n-                let nts = bb_eis.iter().map(|ei| {\n-                    match ei.top_elts.get_tt(ei.idx) {\n-                      TtToken(_, MatchNt(bind, name, _, _)) => {\n+                let nts = bb_eis.iter().map(|ei| match ei.top_elts.get_tt(ei.idx) {\n+                    TtToken(_, MatchNt(bind, name, _, _)) => {\n                         format!(\"{} ('{}')\", name, bind)\n-                      }\n-                      _ => panic!()\n-                    } }).collect::<Vec<String>>().join(\" or \");\n+                    }\n+                    _ => panic!()\n+                }).collect::<Vec<String>>().join(\" or \");\n+\n                 return Error(sp, format!(\n-                    \"local ambiguity: multiple parsing options: \\\n-                     built-in NTs {} or {} other options.\",\n-                    nts, next_eis.len()).to_string());\n+                    \"local ambiguity: multiple parsing options: {}\",\n+                    match next_eis.len() {\n+                        0 => format!(\"built-in NTs {}.\", nts),\n+                        1 => format!(\"built-in NTs {} or 1 other option.\", nts),\n+                        n => format!(\"built-in NTs {} or {} other options.\", nts, n),\n+                    }\n+                ))\n             } else if bb_eis.is_empty() && next_eis.is_empty() {\n                 return Failure(sp, format!(\"no rules expected the token `{}`\",\n-                            pprust::token_to_string(&tok)).to_string());\n+                            pprust::token_to_string(&tok)));\n             } else if !next_eis.is_empty() {\n                 /* Now process the next token */\n                 while !next_eis.is_empty() {\n@@ -465,14 +469,14 @@ pub fn parse(sess: &ParseSess,\n \n                 let mut ei = bb_eis.pop().unwrap();\n                 match ei.top_elts.get_tt(ei.idx) {\n-                  TtToken(span, MatchNt(_, ident, _, _)) => {\n-                    let match_cur = ei.match_cur;\n-                    (&mut ei.matches[match_cur]).push(Rc::new(MatchedNonterminal(\n-                        parse_nt(&mut rust_parser, span, &ident.name.as_str()))));\n-                    ei.idx += 1;\n-                    ei.match_cur += 1;\n-                  }\n-                  _ => panic!()\n+                    TtToken(span, MatchNt(_, ident, _, _)) => {\n+                        let match_cur = ei.match_cur;\n+                        (&mut ei.matches[match_cur]).push(Rc::new(MatchedNonterminal(\n+                            parse_nt(&mut rust_parser, span, &ident.name.as_str()))));\n+                        ei.idx += 1;\n+                        ei.match_cur += 1;\n+                    }\n+                    _ => panic!()\n                 }\n                 cur_eis.push(ei);\n \n@@ -499,37 +503,37 @@ pub fn parse_nt(p: &mut Parser, sp: Span, name: &str) -> Nonterminal {\n     // check at the beginning and the parser checks after each bump\n     panictry!(p.check_unknown_macro_variable());\n     match name {\n-      \"item\" => match p.parse_item() {\n-        Some(i) => token::NtItem(i),\n-        None => panic!(p.fatal(\"expected an item keyword\"))\n-      },\n-      \"block\" => token::NtBlock(panictry!(p.parse_block())),\n-      \"stmt\" => match p.parse_stmt() {\n-        Some(s) => token::NtStmt(s),\n-        None => panic!(p.fatal(\"expected a statement\"))\n-      },\n-      \"pat\" => token::NtPat(p.parse_pat()),\n-      \"expr\" => token::NtExpr(p.parse_expr()),\n-      \"ty\" => token::NtTy(p.parse_ty()),\n-      // this could be handled like a token, since it is one\n-      \"ident\" => match p.token {\n-        token::Ident(sn,b) => { panictry!(p.bump()); token::NtIdent(Box::new(sn),b) }\n+        \"item\" => match p.parse_item() {\n+            Some(i) => token::NtItem(i),\n+            None => panic!(p.fatal(\"expected an item keyword\"))\n+        },\n+        \"block\" => token::NtBlock(panictry!(p.parse_block())),\n+        \"stmt\" => match p.parse_stmt() {\n+            Some(s) => token::NtStmt(s),\n+            None => panic!(p.fatal(\"expected a statement\"))\n+        },\n+        \"pat\" => token::NtPat(p.parse_pat()),\n+        \"expr\" => token::NtExpr(p.parse_expr()),\n+        \"ty\" => token::NtTy(p.parse_ty()),\n+        // this could be handled like a token, since it is one\n+        \"ident\" => match p.token {\n+            token::Ident(sn,b) => { panictry!(p.bump()); token::NtIdent(Box::new(sn),b) }\n+            _ => {\n+                let token_str = pprust::token_to_string(&p.token);\n+                panic!(p.fatal(&format!(\"expected ident, found {}\",\n+                                 &token_str[..])))\n+            }\n+        },\n+        \"path\" => {\n+            token::NtPath(Box::new(panictry!(p.parse_path(LifetimeAndTypesWithoutColons))))\n+        },\n+        \"meta\" => token::NtMeta(p.parse_meta_item()),\n         _ => {\n-            let token_str = pprust::token_to_string(&p.token);\n-            panic!(p.fatal(&format!(\"expected ident, found {}\",\n-                             &token_str[..])))\n-        }\n-      },\n-      \"path\" => {\n-        token::NtPath(Box::new(panictry!(p.parse_path(LifetimeAndTypesWithoutColons))))\n-      }\n-      \"meta\" => token::NtMeta(p.parse_meta_item()),\n-      _ => {\n-          panic!(p.span_fatal_help(sp,\n+            panic!(p.span_fatal_help(sp,\n                             &format!(\"invalid fragment specifier `{}`\", name),\n                             \"valid fragment specifiers are `ident`, `block`, \\\n                              `stmt`, `expr`, `pat`, `ty`, `path`, `meta`, `tt` \\\n                              and `item`\"))\n-      }\n+        }\n     }\n }"}, {"sha": "6cca729e2c28683d53503754867207786c41e35e", "filename": "src/test/compile-fail/macro-match-nonterminal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e13faee1776595fb1e460005d8271c141f758b0/src%2Ftest%2Fcompile-fail%2Fmacro-match-nonterminal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e13faee1776595fb1e460005d8271c141f758b0/src%2Ftest%2Fcompile-fail%2Fmacro-match-nonterminal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-match-nonterminal.rs?ref=7e13faee1776595fb1e460005d8271c141f758b0", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-macro_rules! test { ($a, $b) => (()); } //~ ERROR Cannot transcribe\n+macro_rules! test { ($a, $b) => (()); } //~ ERROR missing fragment\n \n fn main() {\n     test!()"}]}