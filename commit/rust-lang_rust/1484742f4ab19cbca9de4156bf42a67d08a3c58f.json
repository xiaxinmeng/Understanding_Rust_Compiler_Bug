{"sha": "1484742f4ab19cbca9de4156bf42a67d08a3c58f", "node_id": "C_kwDOAAsO6NoAKDE0ODQ3NDJmNGFiMTljYmNhOWRlNDE1NmJmNDJhNjdkMDhhM2M1OGY", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-08-31T05:57:56Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-31T05:57:56Z"}, "message": "Rollup merge of #101011 - BlackHoleFox:apple-random-improvements, r=thomcc\n\nUse getentropy when possible on all Apple platforms\n\nAs the current code comments say, `SecRandomCopyBytes` is very heavyweight (regardless of purpose) compared to just asking the kernel directly for bytes from its own CSPRNG. We were not previously making an attempt to use the more efficient `getentropy` call on other Apple targets, instead solely using it on macOS. As the function is available on newer versions of Apple's different OSes, this changes the random filling to always attempt it first everywhere, only falling back to the less ideal alternatives after. This also cleans up the multiple Apple `imp` blocks into one.\n\nIt also should give a perf improvement, even if its likely unnoticeably small.\n\nRefed XCode header for `getentropy` in the SDK:\n```h\nint getentropy(void* buffer, size_t size) __OSX_AVAILABLE(10.12) __IOS_AVAILABLE(10.0) __TVOS_AVAILABLE(10.0) __WATCHOS_AVAILABLE(3.0);\n```\n\nr? ``@thomcc``", "tree": {"sha": "97128860ff00b0b31396b3927b8ad8099d08d255", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/97128860ff00b0b31396b3927b8ad8099d08d255"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1484742f4ab19cbca9de4156bf42a67d08a3c58f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjDvhkCRBK7hj4Ov3rIwAAZ1MIAE7J0yCITXS+OuC4GfTbzq+Y\nAURqQSFi8X414WSBn/cY8ONovti3CsudsSiLKGip7ocYeW93cNQloMaGg4GbFsP/\nlF3ZLqB9e+hBMh951MLuw0aXirY0Fk1rBYhWbF/9atE0teK21yiHjYhyDlACWxON\n8LThqccpjOzmqAlz1keUsdRUNDvTy+ALRnD8ISMQH4sFboFCl6lRisn62bhkQFvn\n2FUGaV1U5ZK1boypRdp7XIMCpMyg3ZvJaSYOuEMqZ/4HszA3X3ejsczDBAzEeQUF\nJnZtci0uYh/o336KlbKBODM+JtyPlq5NVMyeMxI3PDjB/de7F+OctbFoKRzUNvE=\n=5cll\n-----END PGP SIGNATURE-----\n", "payload": "tree 97128860ff00b0b31396b3927b8ad8099d08d255\nparent b2a8d9d86c02eb0a248cdeed0ca77da589e05572\nparent 3fc35b5b935e390c61ea2bbf744838b2632b2df1\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1661925476 +0200\ncommitter GitHub <noreply@github.com> 1661925476 +0200\n\nRollup merge of #101011 - BlackHoleFox:apple-random-improvements, r=thomcc\n\nUse getentropy when possible on all Apple platforms\n\nAs the current code comments say, `SecRandomCopyBytes` is very heavyweight (regardless of purpose) compared to just asking the kernel directly for bytes from its own CSPRNG. We were not previously making an attempt to use the more efficient `getentropy` call on other Apple targets, instead solely using it on macOS. As the function is available on newer versions of Apple's different OSes, this changes the random filling to always attempt it first everywhere, only falling back to the less ideal alternatives after. This also cleans up the multiple Apple `imp` blocks into one.\n\nIt also should give a perf improvement, even if its likely unnoticeably small.\n\nRefed XCode header for `getentropy` in the SDK:\n```h\nint getentropy(void* buffer, size_t size) __OSX_AVAILABLE(10.12) __IOS_AVAILABLE(10.0) __TVOS_AVAILABLE(10.0) __WATCHOS_AVAILABLE(3.0);\n```\n\nr? ``@thomcc``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1484742f4ab19cbca9de4156bf42a67d08a3c58f", "html_url": "https://github.com/rust-lang/rust/commit/1484742f4ab19cbca9de4156bf42a67d08a3c58f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1484742f4ab19cbca9de4156bf42a67d08a3c58f/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b2a8d9d86c02eb0a248cdeed0ca77da589e05572", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2a8d9d86c02eb0a248cdeed0ca77da589e05572", "html_url": "https://github.com/rust-lang/rust/commit/b2a8d9d86c02eb0a248cdeed0ca77da589e05572"}, {"sha": "3fc35b5b935e390c61ea2bbf744838b2632b2df1", "url": "https://api.github.com/repos/rust-lang/rust/commits/3fc35b5b935e390c61ea2bbf744838b2632b2df1", "html_url": "https://github.com/rust-lang/rust/commit/3fc35b5b935e390c61ea2bbf744838b2632b2df1"}], "stats": {"total": 94, "additions": 56, "deletions": 38}, "files": [{"sha": "40885417308b80a2007591f17af0984a44215831", "filename": "library/std/src/sys/unix/rand.rs", "status": "modified", "additions": 56, "deletions": 38, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/1484742f4ab19cbca9de4156bf42a67d08a3c58f/library%2Fstd%2Fsrc%2Fsys%2Funix%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1484742f4ab19cbca9de4156bf42a67d08a3c58f/library%2Fstd%2Fsrc%2Fsys%2Funix%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Frand.rs?ref=1484742f4ab19cbca9de4156bf42a67d08a3c58f", "patch": "@@ -137,11 +137,9 @@ mod imp {\n     }\n }\n \n-#[cfg(target_os = \"macos\")]\n+#[cfg(any(target_os = \"macos\", target_os = \"ios\", target_os = \"watchos\"))]\n mod imp {\n-    use crate::fs::File;\n-    use crate::io::Read;\n-    use crate::sys::os::errno;\n+    use crate::io;\n     use crate::sys::weak::weak;\n     use libc::{c_int, c_void, size_t};\n \n@@ -155,22 +153,72 @@ mod imp {\n                 for s in v.chunks_mut(256) {\n                     let ret = unsafe { f(s.as_mut_ptr() as *mut c_void, s.len()) };\n                     if ret == -1 {\n-                        panic!(\"unexpected getentropy error: {}\", errno());\n+                        panic!(\"unexpected getentropy error: {}\", io::Error::last_os_error());\n                     }\n                 }\n                 true\n             })\n             .unwrap_or(false)\n     }\n \n+    #[cfg(target_os = \"macos\")]\n+    fn fallback_fill_bytes(v: &mut [u8]) {\n+        use crate::fs::File;\n+        use crate::io::Read;\n+\n+        let mut file = File::open(\"/dev/urandom\").expect(\"failed to open /dev/urandom\");\n+        file.read_exact(v).expect(\"failed to read /dev/urandom\")\n+    }\n+\n+    // On iOS and MacOS `SecRandomCopyBytes` calls `CCRandomCopyBytes` with\n+    // `kCCRandomDefault`. `CCRandomCopyBytes` manages a CSPRNG which is seeded\n+    // from `/dev/random` and which runs on its own thread accessed via GCD.\n+    //\n+    // This is very heavyweight compared to the alternatives, but they may not be usable:\n+    // - `getentropy` was added in iOS 10, but we support a minimum of iOS 7\n+    // - `/dev/urandom` is not accessible inside the iOS app sandbox.\n+    //\n+    // Therefore `SecRandomCopyBytes` is only used on older iOS versions where no\n+    // better options are present.\n+    #[cfg(target_os = \"ios\")]\n+    fn fallback_fill_bytes(v: &mut [u8]) {\n+        use crate::ptr;\n+\n+        enum SecRandom {}\n+\n+        #[allow(non_upper_case_globals)]\n+        const kSecRandomDefault: *const SecRandom = ptr::null();\n+\n+        extern \"C\" {\n+            fn SecRandomCopyBytes(rnd: *const SecRandom, count: size_t, bytes: *mut u8) -> c_int;\n+        }\n+\n+        let ret = unsafe { SecRandomCopyBytes(kSecRandomDefault, v.len(), v.as_mut_ptr()) };\n+        if ret == -1 {\n+            panic!(\"couldn't generate random bytes: {}\", io::Error::last_os_error());\n+        }\n+    }\n+\n+    // All supported versions of watchOS (>= 5) have support for `getentropy`.\n+    #[cfg(target_os = \"watchos\")]\n+    #[cold]\n+    fn fallback_fill_bytes(_: &mut [u8]) {\n+        unreachable!()\n+    }\n+\n     pub fn fill_bytes(v: &mut [u8]) {\n         if getentropy_fill_bytes(v) {\n             return;\n         }\n \n-        // for older macos which doesn't support getentropy\n-        let mut file = File::open(\"/dev/urandom\").expect(\"failed to open /dev/urandom\");\n-        file.read_exact(v).expect(\"failed to read /dev/urandom\")\n+        // Older macOS versions (< 10.12) don't support `getentropy`. Fallback to\n+        // reading from `/dev/urandom` on these systems.\n+        //\n+        // Older iOS versions (< 10) don't support it either. Fallback to\n+        // `SecRandomCopyBytes` on these systems. On watchOS, this is unreachable\n+        // because the minimum supported version is 5 while `getentropy` became accessible\n+        // in 3.\n+        fallback_fill_bytes(v)\n     }\n }\n \n@@ -189,36 +237,6 @@ mod imp {\n     }\n }\n \n-// On iOS and MacOS `SecRandomCopyBytes` calls `CCRandomCopyBytes` with\n-// `kCCRandomDefault`. `CCRandomCopyBytes` manages a CSPRNG which is seeded\n-// from `/dev/random` and which runs on its own thread accessed via GCD.\n-// This seems needlessly heavyweight for the purposes of generating two u64s\n-// once per thread in `hashmap_random_keys`. Therefore `SecRandomCopyBytes` is\n-// only used on iOS where direct access to `/dev/urandom` is blocked by the\n-// sandbox.\n-#[cfg(any(target_os = \"ios\", target_os = \"watchos\"))]\n-mod imp {\n-    use crate::io;\n-    use crate::ptr;\n-    use libc::{c_int, size_t};\n-\n-    enum SecRandom {}\n-\n-    #[allow(non_upper_case_globals)]\n-    const kSecRandomDefault: *const SecRandom = ptr::null();\n-\n-    extern \"C\" {\n-        fn SecRandomCopyBytes(rnd: *const SecRandom, count: size_t, bytes: *mut u8) -> c_int;\n-    }\n-\n-    pub fn fill_bytes(v: &mut [u8]) {\n-        let ret = unsafe { SecRandomCopyBytes(kSecRandomDefault, v.len(), v.as_mut_ptr()) };\n-        if ret == -1 {\n-            panic!(\"couldn't generate random bytes: {}\", io::Error::last_os_error());\n-        }\n-    }\n-}\n-\n #[cfg(any(target_os = \"freebsd\", target_os = \"netbsd\"))]\n mod imp {\n     use crate::ptr;"}]}