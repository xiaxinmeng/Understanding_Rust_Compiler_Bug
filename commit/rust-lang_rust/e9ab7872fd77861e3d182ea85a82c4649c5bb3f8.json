{"sha": "e9ab7872fd77861e3d182ea85a82c4649c5bb3f8", "node_id": "C_kwDOAAsO6NoAKGU5YWI3ODcyZmQ3Nzg2MWUzZDE4MmVhODVhODJjNDY0OWM1YmIzZjg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-14T05:59:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-14T05:59:44Z"}, "message": "Auto merge of #107765 - petrochenkov:nomoclone, r=oli-obk\n\nrustc/rustdoc: Perform name resolver cleanups enabled by #94857\n\nUnblocks https://github.com/rust-lang/rust/pull/105462.\nr? `@oli-obk`", "tree": {"sha": "a2cf6a8a3b698ee2bf1c589b84696d047483e6b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a2cf6a8a3b698ee2bf1c589b84696d047483e6b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e9ab7872fd77861e3d182ea85a82c4649c5bb3f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e9ab7872fd77861e3d182ea85a82c4649c5bb3f8", "html_url": "https://github.com/rust-lang/rust/commit/e9ab7872fd77861e3d182ea85a82c4649c5bb3f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e9ab7872fd77861e3d182ea85a82c4649c5bb3f8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3c6d73b04a718aceabc314bf231a20c90ccd601", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3c6d73b04a718aceabc314bf231a20c90ccd601", "html_url": "https://github.com/rust-lang/rust/commit/c3c6d73b04a718aceabc314bf231a20c90ccd601"}, {"sha": "fd73d01c98adb2adb570ab300ee0d5c4dc0eafca", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd73d01c98adb2adb570ab300ee0d5c4dc0eafca", "html_url": "https://github.com/rust-lang/rust/commit/fd73d01c98adb2adb570ab300ee0d5c4dc0eafca"}], "stats": {"total": 427, "additions": 102, "deletions": 325}, "files": [{"sha": "cd3c620cbb768b482a87efa65e06a2f416050a1d", "filename": "compiler/rustc_hir/src/definitions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9ab7872fd77861e3d182ea85a82c4649c5bb3f8/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9ab7872fd77861e3d182ea85a82c4649c5bb3f8/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs?ref=e9ab7872fd77861e3d182ea85a82c4649c5bb3f8", "patch": "@@ -92,7 +92,7 @@ impl DefPathTable {\n /// The definition table containing node definitions.\n /// It holds the `DefPathTable` for `LocalDefId`s/`DefPath`s.\n /// It also stores mappings to convert `LocalDefId`s to/from `HirId`s.\n-#[derive(Clone, Debug)]\n+#[derive(Debug)]\n pub struct Definitions {\n     table: DefPathTable,\n     next_disambiguator: FxHashMap<(LocalDefId, DefPathData), u32>,"}, {"sha": "7cb3b6e1525b2bc476034645f73e73fc1b668415", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9ab7872fd77861e3d182ea85a82c4649c5bb3f8/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9ab7872fd77861e3d182ea85a82c4649c5bb3f8/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=e9ab7872fd77861e3d182ea85a82c4649c5bb3f8", "patch": "@@ -3460,7 +3460,7 @@ pub struct Upvar {\n // The TraitCandidate's import_ids is empty if the trait is defined in the same module, and\n // has length > 0 if the trait is found through an chain of imports, starting with the\n // import/use statement in the scope where the trait is used.\n-#[derive(Encodable, Decodable, Clone, Debug, HashStable_Generic)]\n+#[derive(Encodable, Decodable, Debug, HashStable_Generic)]\n pub struct TraitCandidate {\n     pub def_id: DefId,\n     pub import_ids: SmallVec<[LocalDefId; 1]>,"}, {"sha": "c8d8afae39e0ad1c88ba3d11110897df40ac2c2f", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e9ab7872fd77861e3d182ea85a82c4649c5bb3f8/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9ab7872fd77861e3d182ea85a82c4649c5bb3f8/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=e9ab7872fd77861e3d182ea85a82c4649c5bb3f8", "patch": "@@ -35,13 +35,11 @@ use rustc_target::spec::PanicStrategy;\n use rustc_trait_selection::traits;\n \n use std::any::Any;\n-use std::cell::RefCell;\n use std::ffi::OsString;\n use std::io::{self, BufWriter, Write};\n use std::marker::PhantomPinned;\n use std::path::{Path, PathBuf};\n use std::pin::Pin;\n-use std::rc::Rc;\n use std::sync::{Arc, LazyLock};\n use std::{env, fs, iter};\n \n@@ -131,21 +129,12 @@ mod boxed_resolver {\n             f((&mut *resolver).as_mut().unwrap())\n         }\n \n-        pub fn to_resolver_outputs(resolver: Rc<RefCell<BoxedResolver>>) -> ty::ResolverOutputs {\n-            match Rc::try_unwrap(resolver) {\n-                Ok(resolver) => {\n-                    let mut resolver = resolver.into_inner();\n-                    // SAFETY: The resolver doesn't need to be pinned.\n-                    let mut resolver = unsafe {\n-                        resolver\n-                            .0\n-                            .as_mut()\n-                            .map_unchecked_mut(|boxed_resolver| &mut boxed_resolver.resolver)\n-                    };\n-                    resolver.take().unwrap().into_outputs()\n-                }\n-                Err(resolver) => resolver.borrow_mut().access(|resolver| resolver.clone_outputs()),\n-            }\n+        pub fn into_outputs(mut self) -> ty::ResolverOutputs {\n+            // SAFETY: The resolver doesn't need to be pinned.\n+            let mut resolver = unsafe {\n+                self.0.as_mut().map_unchecked_mut(|boxed_resolver| &mut boxed_resolver.resolver)\n+            };\n+            resolver.take().unwrap().into_outputs()\n         }\n     }\n }"}, {"sha": "67886b6b9896e17e7ac64aa9d49586dd69ce6541", "filename": "compiler/rustc_interface/src/queries.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e9ab7872fd77861e3d182ea85a82c4649c5bb3f8/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9ab7872fd77861e3d182ea85a82c4649c5bb3f8/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs?ref=e9ab7872fd77861e3d182ea85a82c4649c5bb3f8", "patch": "@@ -21,7 +21,6 @@ use rustc_span::symbol::sym;\n use rustc_span::Symbol;\n use std::any::Any;\n use std::cell::{RefCell, RefMut};\n-use std::rc::Rc;\n use std::sync::Arc;\n \n /// Represent the result of a query.\n@@ -88,7 +87,7 @@ pub struct Queries<'tcx> {\n     parse: Query<ast::Crate>,\n     crate_name: Query<Symbol>,\n     register_plugins: Query<(ast::Crate, Lrc<LintStore>)>,\n-    expansion: Query<(Lrc<ast::Crate>, Rc<RefCell<BoxedResolver>>, Lrc<LintStore>)>,\n+    expansion: Query<(Lrc<ast::Crate>, BoxedResolver, Lrc<LintStore>)>,\n     dep_graph: Query<DepGraph>,\n     // This just points to what's in `gcx_cell`.\n     gcx: Query<&'tcx GlobalCtxt<'tcx>>,\n@@ -171,8 +170,7 @@ impl<'tcx> Queries<'tcx> {\n \n     pub fn expansion(\n         &self,\n-    ) -> Result<QueryResult<'_, (Lrc<ast::Crate>, Rc<RefCell<BoxedResolver>>, Lrc<LintStore>)>>\n-    {\n+    ) -> Result<QueryResult<'_, (Lrc<ast::Crate>, BoxedResolver, Lrc<LintStore>)>> {\n         trace!(\"expansion\");\n         self.expansion.compute(|| {\n             let crate_name = *self.crate_name()?.borrow();\n@@ -188,7 +186,7 @@ impl<'tcx> Queries<'tcx> {\n             let krate = resolver.access(|resolver| {\n                 passes::configure_and_expand(sess, &lint_store, krate, crate_name, resolver)\n             })?;\n-            Ok((Lrc::new(krate), Rc::new(RefCell::new(resolver)), lint_store))\n+            Ok((Lrc::new(krate), resolver, lint_store))\n         })\n     }\n \n@@ -217,7 +215,7 @@ impl<'tcx> Queries<'tcx> {\n                 untracked,\n                 global_ctxt: untracked_resolutions,\n                 ast_lowering: untracked_resolver_for_lowering,\n-            } = BoxedResolver::to_resolver_outputs(resolver);\n+            } = resolver.into_outputs();\n \n             let gcx = passes::create_global_ctxt(\n                 self.compiler,"}, {"sha": "c357f294279fb0edfab60fd00c0a1ffcda24c3f5", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e9ab7872fd77861e3d182ea85a82c4649c5bb3f8/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9ab7872fd77861e3d182ea85a82c4649c5bb3f8/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=e9ab7872fd77861e3d182ea85a82c4649c5bb3f8", "patch": "@@ -8,7 +8,7 @@ use rustc_ast::expand::allocator::AllocatorKind;\n use rustc_ast::{self as ast, *};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::svh::Svh;\n-use rustc_data_structures::sync::{Lrc, ReadGuard};\n+use rustc_data_structures::sync::ReadGuard;\n use rustc_expand::base::SyntaxExtension;\n use rustc_hir::def_id::{CrateNum, LocalDefId, StableCrateId, LOCAL_CRATE};\n use rustc_hir::definitions::Definitions;\n@@ -30,11 +30,10 @@ use proc_macro::bridge::client::ProcMacro;\n use std::ops::Fn;\n use std::path::Path;\n use std::time::Duration;\n-use std::{cmp, env};\n+use std::{cmp, env, iter};\n \n-#[derive(Clone)]\n pub struct CStore {\n-    metas: IndexVec<CrateNum, Option<Lrc<CrateMetadata>>>,\n+    metas: IndexVec<CrateNum, Option<Box<CrateMetadata>>>,\n     injected_panic_runtime: Option<CrateNum>,\n     /// This crate needs an allocator and either provides it itself, or finds it in a dependency.\n     /// If the above is true, then this field denotes the kind of the found allocator.\n@@ -153,7 +152,7 @@ impl CStore {\n \n     fn set_crate_data(&mut self, cnum: CrateNum, data: CrateMetadata) {\n         assert!(self.metas[cnum].is_none(), \"Overwriting crate metadata entry\");\n-        self.metas[cnum] = Some(Lrc::new(data));\n+        self.metas[cnum] = Some(Box::new(data));\n     }\n \n     pub(crate) fn iter_crate_data(&self) -> impl Iterator<Item = (CrateNum, &CrateMetadata)> {\n@@ -245,7 +244,7 @@ impl CStore {\n             // order to make array indices in `metas` match with the\n             // corresponding `CrateNum`. This first entry will always remain\n             // `None`.\n-            metas: IndexVec::from_elem_n(None, 1),\n+            metas: IndexVec::from_iter(iter::once(None)),\n             injected_panic_runtime: None,\n             allocator_kind: None,\n             alloc_error_handler_kind: None,"}, {"sha": "3457e51f8e6e9c18478621d6e2d9bd646e28c17f", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e9ab7872fd77861e3d182ea85a82c4649c5bb3f8/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9ab7872fd77861e3d182ea85a82c4649c5bb3f8/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=e9ab7872fd77861e3d182ea85a82c4649c5bb3f8", "patch": "@@ -1169,15 +1169,9 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     /// Decodes all trait impls in the crate (for rustdoc).\n-    fn get_trait_impls(self) -> impl Iterator<Item = (DefId, DefId, Option<SimplifiedType>)> + 'a {\n-        self.cdata.trait_impls.iter().flat_map(move |(&(trait_cnum_raw, trait_index), impls)| {\n-            let trait_def_id = DefId {\n-                krate: self.cnum_map[CrateNum::from_u32(trait_cnum_raw)],\n-                index: trait_index,\n-            };\n-            impls.decode(self).map(move |(impl_index, simplified_self_ty)| {\n-                (trait_def_id, self.local_def_id(impl_index), simplified_self_ty)\n-            })\n+    fn get_trait_impls(self) -> impl Iterator<Item = DefId> + 'a {\n+        self.cdata.trait_impls.values().flat_map(move |impls| {\n+            impls.decode(self).map(move |(impl_index, _)| self.local_def_id(impl_index))\n         })\n     }\n "}, {"sha": "8082a8903204779f66ac8e30943d240554358572", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e9ab7872fd77861e3d182ea85a82c4649c5bb3f8/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9ab7872fd77861e3d182ea85a82c4649c5bb3f8/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=e9ab7872fd77861e3d182ea85a82c4649c5bb3f8", "patch": "@@ -304,6 +304,7 @@ provide! { tcx, def_id, other, cdata,\n     extra_filename => { cdata.root.extra_filename.clone() }\n \n     traits_in_crate => { tcx.arena.alloc_from_iter(cdata.get_traits()) }\n+    trait_impls_in_crate => { tcx.arena.alloc_from_iter(cdata.get_trait_impls()) }\n     implementations_of_trait => { cdata.get_implementations_of_trait(tcx, other) }\n     crate_incoherent_impls => { cdata.get_incoherent_impls(tcx, other) }\n \n@@ -608,20 +609,6 @@ impl CStore {\n     ) -> Span {\n         self.get_crate_data(cnum).get_proc_macro_quoted_span(id, sess)\n     }\n-\n-    /// Decodes all trait impls in the crate (for rustdoc).\n-    pub fn trait_impls_in_crate_untracked(\n-        &self,\n-        cnum: CrateNum,\n-    ) -> impl Iterator<Item = (DefId, DefId, Option<SimplifiedType>)> + '_ {\n-        self.get_crate_data(cnum).get_trait_impls()\n-    }\n-\n-    pub fn is_doc_hidden_untracked(&self, def_id: DefId) -> bool {\n-        self.get_crate_data(def_id.krate)\n-            .get_attr_flags(def_id.index)\n-            .contains(AttrFlags::IS_DOC_HIDDEN)\n-    }\n }\n \n impl CrateStore for CStore {"}, {"sha": "060ade8a42f71c5262bbd196208040091b4ac8f7", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e9ab7872fd77861e3d182ea85a82c4649c5bb3f8/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9ab7872fd77861e3d182ea85a82c4649c5bb3f8/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=e9ab7872fd77861e3d182ea85a82c4649c5bb3f8", "patch": "@@ -2256,6 +2256,22 @@ pub fn provide(providers: &mut Providers) {\n             traits.sort_by_cached_key(|&def_id| tcx.def_path_hash(def_id));\n             tcx.arena.alloc_slice(&traits)\n         },\n+        trait_impls_in_crate: |tcx, cnum| {\n+            assert_eq!(cnum, LOCAL_CRATE);\n+\n+            let mut trait_impls = Vec::new();\n+            for id in tcx.hir().items() {\n+                if matches!(tcx.def_kind(id.owner_id), DefKind::Impl)\n+                    && tcx.impl_trait_ref(id.owner_id).is_some()\n+                {\n+                    trait_impls.push(id.owner_id.to_def_id())\n+                }\n+            }\n+\n+            // Bring everything into deterministic order.\n+            trait_impls.sort_by_cached_key(|&def_id| tcx.def_path_hash(def_id));\n+            tcx.arena.alloc_slice(&trait_impls)\n+        },\n \n         ..*providers\n     }"}, {"sha": "71c9058a696f1186967bb3fd09f1e8014ae8dd95", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e9ab7872fd77861e3d182ea85a82c4649c5bb3f8/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9ab7872fd77861e3d182ea85a82c4649c5bb3f8/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=e9ab7872fd77861e3d182ea85a82c4649c5bb3f8", "patch": "@@ -1836,6 +1836,11 @@ rustc_queries! {\n         separate_provide_extern\n     }\n \n+    query trait_impls_in_crate(_: CrateNum) -> &'tcx [DefId] {\n+        desc { \"fetching all trait impls in a crate\" }\n+        separate_provide_extern\n+    }\n+\n     /// The list of symbols exported from the given crate.\n     ///\n     /// - All names contained in `exported_symbols(cnum)` are guaranteed to"}, {"sha": "6d8c9d737633344c99a24a124a8934b1eebc0b91", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e9ab7872fd77861e3d182ea85a82c4649c5bb3f8/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9ab7872fd77861e3d182ea85a82c4649c5bb3f8/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=e9ab7872fd77861e3d182ea85a82c4649c5bb3f8", "patch": "@@ -187,6 +187,7 @@ pub struct ResolverGlobalCtxt {\n     pub registered_tools: RegisteredTools,\n     pub doc_link_resolutions: FxHashMap<LocalDefId, DocLinkResMap>,\n     pub doc_link_traits_in_scope: FxHashMap<LocalDefId, Vec<DefId>>,\n+    pub all_macro_rules: FxHashMap<Symbol, Res<ast::NodeId>>,\n }\n \n /// Resolutions that should only be used for lowering."}, {"sha": "44f3bf1be055d7a6954e546bbb5a27ff0699a752", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e9ab7872fd77861e3d182ea85a82c4649c5bb3f8/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9ab7872fd77861e3d182ea85a82c4649c5bb3f8/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=e9ab7872fd77861e3d182ea85a82c4649c5bb3f8", "patch": "@@ -1251,6 +1251,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             };\n             let binding = (res, vis, span, expansion).to_name_binding(self.r.arenas);\n             self.r.set_binding_parent_module(binding, parent_scope.module);\n+            self.r.all_macro_rules.insert(ident.name, res);\n             if is_macro_export {\n                 let import = self.r.arenas.alloc_import(Import {\n                     kind: ImportKind::MacroExport,"}, {"sha": "ab68f25a886fe67bc9638feb52cd1b1c2a5fbf44", "filename": "compiler/rustc_resolve/src/effective_visibilities.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9ab7872fd77861e3d182ea85a82c4649c5bb3f8/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9ab7872fd77861e3d182ea85a82c4649c5bb3f8/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs?ref=e9ab7872fd77861e3d182ea85a82c4649c5bb3f8", "patch": "@@ -29,7 +29,7 @@ impl ParentId<'_> {\n     }\n }\n \n-pub struct EffectiveVisibilitiesVisitor<'r, 'a> {\n+pub(crate) struct EffectiveVisibilitiesVisitor<'r, 'a> {\n     r: &'r mut Resolver<'a>,\n     def_effective_visibilities: EffectiveVisibilities,\n     /// While walking import chains we need to track effective visibilities per-binding, and def id\n@@ -78,7 +78,7 @@ impl<'r, 'a> EffectiveVisibilitiesVisitor<'r, 'a> {\n     /// Fills the `Resolver::effective_visibilities` table with public & exported items\n     /// For now, this doesn't resolve macros (FIXME) and cannot resolve Impl, as we\n     /// need access to a TyCtxt for that.\n-    pub fn compute_effective_visibilities<'c>(r: &'r mut Resolver<'a>, krate: &'c Crate) {\n+    pub(crate) fn compute_effective_visibilities<'c>(r: &'r mut Resolver<'a>, krate: &'c Crate) {\n         let mut visitor = EffectiveVisibilitiesVisitor {\n             r,\n             def_effective_visibilities: Default::default(),"}, {"sha": "8d1c789dea7c517e2cf64aa1cbcf81db75f0c8d6", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e9ab7872fd77861e3d182ea85a82c4649c5bb3f8/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9ab7872fd77861e3d182ea85a82c4649c5bb3f8/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=e9ab7872fd77861e3d182ea85a82c4649c5bb3f8", "patch": "@@ -33,7 +33,7 @@ type Res = def::Res<NodeId>;\n \n /// Contains data for specific kinds of imports.\n #[derive(Clone)]\n-pub enum ImportKind<'a> {\n+pub(crate) enum ImportKind<'a> {\n     Single {\n         /// `source` in `use prefix::source as target`.\n         source: Ident,\n@@ -157,11 +157,11 @@ pub(crate) struct Import<'a> {\n }\n \n impl<'a> Import<'a> {\n-    pub fn is_glob(&self) -> bool {\n+    pub(crate) fn is_glob(&self) -> bool {\n         matches!(self.kind, ImportKind::Glob { .. })\n     }\n \n-    pub fn is_nested(&self) -> bool {\n+    pub(crate) fn is_nested(&self) -> bool {\n         match self.kind {\n             ImportKind::Single { nested, .. } => nested,\n             _ => false,\n@@ -405,7 +405,7 @@ struct UnresolvedImportError {\n     candidates: Option<Vec<ImportSuggestion>>,\n }\n \n-pub struct ImportResolver<'a, 'b> {\n+pub(crate) struct ImportResolver<'a, 'b> {\n     pub r: &'a mut Resolver<'b>,\n }\n \n@@ -420,7 +420,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n \n     /// Resolves all imports for the crate. This method performs the fixed-\n     /// point iteration.\n-    pub fn resolve_imports(&mut self) {\n+    pub(crate) fn resolve_imports(&mut self) {\n         let mut prev_num_indeterminates = self.r.indeterminate_imports.len() + 1;\n         while self.r.indeterminate_imports.len() < prev_num_indeterminates {\n             prev_num_indeterminates = self.r.indeterminate_imports.len();\n@@ -433,7 +433,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         }\n     }\n \n-    pub fn finalize_imports(&mut self) {\n+    pub(crate) fn finalize_imports(&mut self) {\n         for module in self.r.arenas.local_modules().iter() {\n             self.finalize_resolutions_in(module);\n         }"}, {"sha": "d4c056f12f62b0897a54793f782d660ccc68b667", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e9ab7872fd77861e3d182ea85a82c4649c5bb3f8/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9ab7872fd77861e3d182ea85a82c4649c5bb3f8/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=e9ab7872fd77861e3d182ea85a82c4649c5bb3f8", "patch": "@@ -56,7 +56,7 @@ struct BindingInfo {\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub enum PatternSource {\n+pub(crate) enum PatternSource {\n     Match,\n     Let,\n     For,\n@@ -70,7 +70,7 @@ enum IsRepeatExpr {\n }\n \n impl PatternSource {\n-    pub fn descr(self) -> &'static str {\n+    fn descr(self) -> &'static str {\n         match self {\n             PatternSource::Match => \"match binding\",\n             PatternSource::Let => \"let binding\",\n@@ -2374,9 +2374,8 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 // Maintain macro_rules scopes in the same way as during early resolution\n                 // for diagnostics and doc links.\n                 if macro_def.macro_rules {\n-                    let (macro_rules_scope, _) =\n-                        self.r.macro_rules_scope(self.r.local_def_id(item.id));\n-                    self.parent_scope.macro_rules = macro_rules_scope;\n+                    let def_id = self.r.local_def_id(item.id);\n+                    self.parent_scope.macro_rules = self.r.macro_rules_scopes[&def_id];\n                 }\n             }\n "}, {"sha": "c6d27ec69c512e9327045c6d2f6846af3b2f8ea9", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9ab7872fd77861e3d182ea85a82c4649c5bb3f8/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9ab7872fd77861e3d182ea85a82c4649c5bb3f8/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=e9ab7872fd77861e3d182ea85a82c4649c5bb3f8", "patch": "@@ -2626,7 +2626,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n }\n \n /// Report lifetime/lifetime shadowing as an error.\n-pub fn signal_lifetime_shadowing(sess: &Session, orig: Ident, shadower: Ident) {\n+pub(super) fn signal_lifetime_shadowing(sess: &Session, orig: Ident, shadower: Ident) {\n     let mut err = struct_span_err!(\n         sess,\n         shadower.span,\n@@ -2641,7 +2641,7 @@ pub fn signal_lifetime_shadowing(sess: &Session, orig: Ident, shadower: Ident) {\n \n /// Shadowing involving a label is only a warning for historical reasons.\n //FIXME: make this a proper lint.\n-pub fn signal_label_shadowing(sess: &Session, orig: Span, shadower: Ident) {\n+pub(super) fn signal_label_shadowing(sess: &Session, orig: Span, shadower: Ident) {\n     let name = shadower.name;\n     let shadower = shadower.span;\n     let mut err = sess.struct_span_warn("}, {"sha": "3c70e9c93e364104be9b4b95b098c038bd7d89f9", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 23, "deletions": 81, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/e9ab7872fd77861e3d182ea85a82c4649c5bb3f8/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9ab7872fd77861e3d182ea85a82c4649c5bb3f8/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=e9ab7872fd77861e3d182ea85a82c4649c5bb3f8", "patch": "@@ -21,8 +21,6 @@\n #[macro_use]\n extern crate tracing;\n \n-pub use rustc_hir::def::{Namespace, PerNS};\n-\n use rustc_arena::{DroplessArena, TypedArena};\n use rustc_ast::node_id::NodeMap;\n use rustc_ast::{self as ast, NodeId, CRATE_NODE_ID};\n@@ -32,8 +30,8 @@ use rustc_data_structures::intern::Interned;\n use rustc_data_structures::sync::{Lrc, RwLock};\n use rustc_errors::{Applicability, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_expand::base::{DeriveResolutions, SyntaxExtension, SyntaxExtensionKind};\n-use rustc_hir::def::Namespace::*;\n-use rustc_hir::def::{self, CtorOf, DefKind, DocLinkResMap, LifetimeRes, PartialRes};\n+use rustc_hir::def::Namespace::{self, *};\n+use rustc_hir::def::{self, CtorOf, DefKind, DocLinkResMap, LifetimeRes, PartialRes, PerNS};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, LocalDefId};\n use rustc_hir::def_id::{CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_hir::definitions::{DefPathData, Definitions};\n@@ -86,7 +84,7 @@ enum Weak {\n }\n \n #[derive(Copy, Clone, PartialEq, Debug)]\n-pub enum Determinacy {\n+enum Determinacy {\n     Determined,\n     Undetermined,\n }\n@@ -257,7 +255,7 @@ enum VisResolutionError<'a> {\n /// A minimal representation of a path segment. We use this in resolve because we synthesize 'path\n /// segments' which don't have the rest of an AST or HIR `PathSegment`.\n #[derive(Clone, Copy, Debug)]\n-pub struct Segment {\n+struct Segment {\n     ident: Ident,\n     id: Option<NodeId>,\n     /// Signals whether this `PathSegment` has generic arguments. Used to avoid providing\n@@ -380,7 +378,7 @@ impl ModuleOrUniformRoot<'_> {\n     }\n }\n \n-#[derive(Clone, Debug)]\n+#[derive(Debug)]\n enum PathResult<'a> {\n     Module(ModuleOrUniformRoot<'a>),\n     NonModule(PartialRes),\n@@ -435,7 +433,7 @@ enum ModuleKind {\n \n impl ModuleKind {\n     /// Get name of the module.\n-    pub fn name(&self) -> Option<Symbol> {\n+    fn name(&self) -> Option<Symbol> {\n         match self {\n             ModuleKind::Block => None,\n             ModuleKind::Def(.., name) => Some(*name),\n@@ -471,7 +469,7 @@ type Resolutions<'a> = RefCell<FxIndexMap<BindingKey, &'a RefCell<NameResolution\n /// * curly-braced block with statements\n ///\n /// You can use [`ModuleData::kind`] to determine the kind of module this is.\n-pub struct ModuleData<'a> {\n+struct ModuleData<'a> {\n     /// The direct parent module (it may not be a `mod`, however).\n     parent: Option<Module<'a>>,\n     /// What kind of module this is, because this may not be a `mod`.\n@@ -570,7 +568,7 @@ impl<'a> ModuleData<'a> {\n     }\n \n     // Public for rustdoc.\n-    pub fn def_id(&self) -> DefId {\n+    fn def_id(&self) -> DefId {\n         self.opt_def_id().expect(\"`ModuleData::def_id` is called on a block module\")\n     }\n \n@@ -628,15 +626,15 @@ impl<'a> fmt::Debug for ModuleData<'a> {\n \n /// Records a possibly-private value, type, or module definition.\n #[derive(Clone, Debug)]\n-pub struct NameBinding<'a> {\n+struct NameBinding<'a> {\n     kind: NameBindingKind<'a>,\n     ambiguity: Option<(&'a NameBinding<'a>, AmbiguityKind)>,\n     expansion: LocalExpnId,\n     span: Span,\n     vis: ty::Visibility<DefId>,\n }\n \n-pub trait ToNameBinding<'a> {\n+trait ToNameBinding<'a> {\n     fn to_name_binding(self, arenas: &'a ResolverArenas<'a>) -> &'a NameBinding<'a>;\n }\n \n@@ -840,9 +838,9 @@ impl<'a> NameBinding<'a> {\n }\n \n #[derive(Default, Clone)]\n-pub struct ExternPreludeEntry<'a> {\n+struct ExternPreludeEntry<'a> {\n     extern_crate_item: Option<&'a NameBinding<'a>>,\n-    pub introduced_by_item: bool,\n+    introduced_by_item: bool,\n }\n \n /// Used for better errors for E0773\n@@ -1049,6 +1047,7 @@ pub struct Resolver<'a> {\n     effective_visibilities: EffectiveVisibilities,\n     doc_link_resolutions: FxHashMap<LocalDefId, DocLinkResMap>,\n     doc_link_traits_in_scope: FxHashMap<LocalDefId, Vec<DefId>>,\n+    all_macro_rules: FxHashMap<Symbol, Res>,\n }\n \n /// Nothing really interesting here; it just provides memory for the rest of the crate.\n@@ -1147,7 +1146,7 @@ impl<'a> Resolver<'a> {\n         self.node_id_to_def_id.get(&node).copied()\n     }\n \n-    pub fn local_def_id(&self, node: NodeId) -> LocalDefId {\n+    fn local_def_id(&self, node: NodeId) -> LocalDefId {\n         self.opt_local_def_id(node).unwrap_or_else(|| panic!(\"no entry for node id: `{:?}`\", node))\n     }\n \n@@ -1199,10 +1198,6 @@ impl<'a> Resolver<'a> {\n             self.cstore().item_generics_num_lifetimes(def_id, self.session)\n         }\n     }\n-\n-    pub fn sess(&self) -> &'a Session {\n-        self.session\n-    }\n }\n \n impl<'a> Resolver<'a> {\n@@ -1379,6 +1374,7 @@ impl<'a> Resolver<'a> {\n             effective_visibilities: Default::default(),\n             doc_link_resolutions: Default::default(),\n             doc_link_traits_in_scope: Default::default(),\n+            all_macro_rules: Default::default(),\n         };\n \n         let root_parent_scope = ParentScope::module(graph_root, &resolver);\n@@ -1399,14 +1395,14 @@ impl<'a> Resolver<'a> {\n         self.arenas.new_module(parent, kind, expn_id, span, no_implicit_prelude, module_map)\n     }\n \n-    pub fn next_node_id(&mut self) -> NodeId {\n+    fn next_node_id(&mut self) -> NodeId {\n         let start = self.next_node_id;\n         let next = start.as_u32().checked_add(1).expect(\"input too large; ran out of NodeIds\");\n         self.next_node_id = ast::NodeId::from_u32(next);\n         start\n     }\n \n-    pub fn next_node_ids(&mut self, count: usize) -> std::ops::Range<NodeId> {\n+    fn next_node_ids(&mut self, count: usize) -> std::ops::Range<NodeId> {\n         let start = self.next_node_id;\n         let end = start.as_usize().checked_add(count).expect(\"input too large; ran out of NodeIds\");\n         self.next_node_id = ast::NodeId::from_usize(end);\n@@ -1457,6 +1453,7 @@ impl<'a> Resolver<'a> {\n             registered_tools: self.registered_tools,\n             doc_link_resolutions: self.doc_link_resolutions,\n             doc_link_traits_in_scope: self.doc_link_traits_in_scope,\n+            all_macro_rules: self.all_macro_rules,\n         };\n         let ast_lowering = ty::ResolverAstLowering {\n             legacy_const_generic_args: self.legacy_const_generic_args,\n@@ -1475,57 +1472,11 @@ impl<'a> Resolver<'a> {\n         ResolverOutputs { global_ctxt, ast_lowering, untracked }\n     }\n \n-    pub fn clone_outputs(&self) -> ResolverOutputs {\n-        let proc_macros = self.proc_macros.iter().map(|id| self.local_def_id(*id)).collect();\n-        let definitions = self.untracked.definitions.clone();\n-        let cstore = Box::new(self.cstore().clone());\n-        let untracked =\n-            Untracked { cstore, source_span: self.untracked.source_span.clone(), definitions };\n-        let global_ctxt = ResolverGlobalCtxt {\n-            expn_that_defined: self.expn_that_defined.clone(),\n-            visibilities: self.visibilities.clone(),\n-            has_pub_restricted: self.has_pub_restricted,\n-            extern_crate_map: self.extern_crate_map.clone(),\n-            reexport_map: self.reexport_map.clone(),\n-            glob_map: self.glob_map.clone(),\n-            maybe_unused_trait_imports: self.maybe_unused_trait_imports.clone(),\n-            maybe_unused_extern_crates: self.maybe_unused_extern_crates.clone(),\n-            extern_prelude: self\n-                .extern_prelude\n-                .iter()\n-                .map(|(ident, entry)| (ident.name, entry.introduced_by_item))\n-                .collect(),\n-            main_def: self.main_def,\n-            trait_impls: self.trait_impls.clone(),\n-            proc_macros,\n-            confused_type_with_std_module: self.confused_type_with_std_module.clone(),\n-            registered_tools: self.registered_tools.clone(),\n-            effective_visibilities: self.effective_visibilities.clone(),\n-            doc_link_resolutions: self.doc_link_resolutions.clone(),\n-            doc_link_traits_in_scope: self.doc_link_traits_in_scope.clone(),\n-        };\n-        let ast_lowering = ty::ResolverAstLowering {\n-            legacy_const_generic_args: self.legacy_const_generic_args.clone(),\n-            partial_res_map: self.partial_res_map.clone(),\n-            import_res_map: self.import_res_map.clone(),\n-            label_res_map: self.label_res_map.clone(),\n-            lifetimes_res_map: self.lifetimes_res_map.clone(),\n-            extra_lifetime_params_map: self.extra_lifetime_params_map.clone(),\n-            next_node_id: self.next_node_id,\n-            node_id_to_def_id: self.node_id_to_def_id.clone(),\n-            def_id_to_node_id: self.def_id_to_node_id.clone(),\n-            trait_map: self.trait_map.clone(),\n-            builtin_macro_kinds: self.builtin_macro_kinds.clone(),\n-            lifetime_elision_allowed: self.lifetime_elision_allowed.clone(),\n-        };\n-        ResolverOutputs { global_ctxt, ast_lowering, untracked }\n-    }\n-\n     fn create_stable_hashing_context(&self) -> StableHashingContext<'_> {\n         StableHashingContext::new(self.session, &self.untracked)\n     }\n \n-    pub fn crate_loader(&mut self) -> CrateLoader<'_> {\n+    fn crate_loader(&mut self) -> CrateLoader<'_> {\n         CrateLoader::new(\n             &self.session,\n             &*self.metadata_loader,\n@@ -1536,7 +1487,7 @@ impl<'a> Resolver<'a> {\n         )\n     }\n \n-    pub fn cstore(&self) -> &CStore {\n+    fn cstore(&self) -> &CStore {\n         self.untracked.cstore.as_any().downcast_ref().unwrap()\n     }\n \n@@ -1968,24 +1919,15 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    /// For rustdoc.\n-    pub fn macro_rules_scope(&self, def_id: LocalDefId) -> (MacroRulesScopeRef<'a>, Res) {\n-        let scope = *self.macro_rules_scopes.get(&def_id).expect(\"not a `macro_rules` item\");\n-        match scope.get() {\n-            MacroRulesScope::Binding(mb) => (scope, mb.binding.res()),\n-            _ => unreachable!(),\n-        }\n-    }\n-\n     /// Retrieves the span of the given `DefId` if `DefId` is in the local crate.\n     #[inline]\n-    pub fn opt_span(&self, def_id: DefId) -> Option<Span> {\n+    fn opt_span(&self, def_id: DefId) -> Option<Span> {\n         def_id.as_local().map(|def_id| self.untracked.source_span[def_id])\n     }\n \n     /// Retrieves the name of the given `DefId`.\n     #[inline]\n-    pub fn opt_name(&self, def_id: DefId) -> Option<Symbol> {\n+    fn opt_name(&self, def_id: DefId) -> Option<Symbol> {\n         let def_key = match def_id.as_local() {\n             Some(def_id) => self.untracked.definitions.read().def_key(def_id),\n             None => self.cstore().def_key(def_id),\n@@ -1996,7 +1938,7 @@ impl<'a> Resolver<'a> {\n     /// Checks if an expression refers to a function marked with\n     /// `#[rustc_legacy_const_generics]` and returns the argument index list\n     /// from the attribute.\n-    pub fn legacy_const_generic_args(&mut self, expr: &Expr) -> Option<Vec<usize>> {\n+    fn legacy_const_generic_args(&mut self, expr: &Expr) -> Option<Vec<usize>> {\n         if let ExprKind::Path(None, path) = &expr.kind {\n             // Don't perform legacy const generics rewriting if the path already\n             // has generic arguments."}, {"sha": "96ad6e96fac1282417a7a129e1e4605402b00bd8", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9ab7872fd77861e3d182ea85a82c4649c5bb3f8/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9ab7872fd77861e3d182ea85a82c4649c5bb3f8/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=e9ab7872fd77861e3d182ea85a82c4649c5bb3f8", "patch": "@@ -39,7 +39,7 @@ type Res = def::Res<NodeId>;\n /// Binding produced by a `macro_rules` item.\n /// Not modularized, can shadow previous `macro_rules` bindings, etc.\n #[derive(Debug)]\n-pub struct MacroRulesBinding<'a> {\n+pub(crate) struct MacroRulesBinding<'a> {\n     pub(crate) binding: &'a NameBinding<'a>,\n     /// `macro_rules` scope into which the `macro_rules` item was planted.\n     pub(crate) parent_macro_rules_scope: MacroRulesScopeRef<'a>,\n@@ -52,7 +52,7 @@ pub struct MacroRulesBinding<'a> {\n /// Some macro invocations need to introduce `macro_rules` scopes too because they\n /// can potentially expand into macro definitions.\n #[derive(Copy, Clone, Debug)]\n-pub enum MacroRulesScope<'a> {\n+pub(crate) enum MacroRulesScope<'a> {\n     /// Empty \"root\" scope at the crate start containing no names.\n     Empty,\n     /// The scope introduced by a `macro_rules!` macro definition."}, {"sha": "5ab7056be442a47004aa0f974bf6fbe8dcf9d114", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 4, "deletions": 20, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e9ab7872fd77861e3d182ea85a82c4649c5bb3f8/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9ab7872fd77861e3d182ea85a82c4649c5bb3f8/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=e9ab7872fd77861e3d182ea85a82c4649c5bb3f8", "patch": "@@ -1,4 +1,3 @@\n-use rustc_ast::NodeId;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::{self, Lrc};\n use rustc_data_structures::unord::UnordSet;\n@@ -17,7 +16,7 @@ use rustc_session::config::{self, CrateType, ErrorOutputType, ResolveDocLinks};\n use rustc_session::lint;\n use rustc_session::Session;\n use rustc_span::symbol::sym;\n-use rustc_span::{source_map, Span, Symbol};\n+use rustc_span::{source_map, Span};\n \n use std::cell::RefCell;\n use std::mem;\n@@ -32,15 +31,8 @@ use crate::passes::{self, Condition::*};\n \n pub(crate) use rustc_session::config::{Input, Options, UnstableOptions};\n \n-pub(crate) struct ResolverCaches {\n-    pub(crate) all_trait_impls: Option<Vec<DefId>>,\n-    pub(crate) all_macro_rules: FxHashMap<Symbol, Res<NodeId>>,\n-    pub(crate) extern_doc_reachable: DefIdSet,\n-}\n-\n pub(crate) struct DocContext<'tcx> {\n     pub(crate) tcx: TyCtxt<'tcx>,\n-    pub(crate) resolver_caches: ResolverCaches,\n     /// Used for normalization.\n     ///\n     /// Most of this logic is copied from rustc_lint::late.\n@@ -111,12 +103,6 @@ impl<'tcx> DocContext<'tcx> {\n             _ => None,\n         }\n     }\n-\n-    pub(crate) fn with_all_trait_impls(&mut self, f: impl FnOnce(&mut Self, &[DefId])) {\n-        let all_trait_impls = self.resolver_caches.all_trait_impls.take();\n-        f(self, all_trait_impls.as_ref().expect(\"`all_trait_impls` are already borrowed\"));\n-        self.resolver_caches.all_trait_impls = all_trait_impls;\n-    }\n }\n \n /// Creates a new diagnostic `Handler` that can be used to emit warnings and errors.\n@@ -305,7 +291,6 @@ pub(crate) fn create_config(\n \n pub(crate) fn run_global_ctxt(\n     tcx: TyCtxt<'_>,\n-    resolver_caches: ResolverCaches,\n     show_coverage: bool,\n     render_options: RenderOptions,\n     output_format: OutputFormat,\n@@ -339,7 +324,6 @@ pub(crate) fn run_global_ctxt(\n \n     let mut ctxt = DocContext {\n         tcx,\n-        resolver_caches,\n         param_env: ParamEnv::empty(),\n         external_traits: Default::default(),\n         active_extern_traits: Default::default(),\n@@ -354,9 +338,9 @@ pub(crate) fn run_global_ctxt(\n         show_coverage,\n     };\n \n-    ctxt.cache\n-        .effective_visibilities\n-        .init(mem::take(&mut ctxt.resolver_caches.extern_doc_reachable));\n+    for cnum in tcx.crates(()) {\n+        crate::visit_lib::lib_embargo_visit_item(&mut ctxt, cnum.as_def_id());\n+    }\n \n     // Small hack to force the Sized trait to be present.\n     //"}, {"sha": "910a7190b5842999aab154dbdd83dc478850b07d", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 2, "deletions": 19, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e9ab7872fd77861e3d182ea85a82c4649c5bb3f8/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9ab7872fd77861e3d182ea85a82c4649c5bb3f8/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=e9ab7872fd77861e3d182ea85a82c4649c5bb3f8", "patch": "@@ -82,7 +82,6 @@ use rustc_session::getopts;\n use rustc_session::{early_error, early_warn};\n \n use crate::clean::utils::DOC_RUST_LANG_ORG_CHANNEL;\n-use crate::passes::collect_intra_doc_links;\n \n /// A macro to create a FxHashMap.\n ///\n@@ -793,30 +792,14 @@ fn main_args(at_args: &[String]) -> MainResult {\n         }\n \n         compiler.enter(|queries| {\n-            let resolver_caches = {\n-                let expansion = abort_on_err(queries.expansion(), sess);\n-                let (krate, resolver, _) = &*expansion.borrow();\n-                let resolver_caches = resolver.borrow_mut().access(|resolver| {\n-                    collect_intra_doc_links::early_resolve_intra_doc_links(resolver, krate)\n-                });\n-                resolver_caches\n-            };\n-\n+            let mut gcx = abort_on_err(queries.global_ctxt(), sess);\n             if sess.diagnostic().has_errors_or_lint_errors().is_some() {\n                 sess.fatal(\"Compilation failed, aborting rustdoc\");\n             }\n \n-            let mut gcx = abort_on_err(queries.global_ctxt(), sess);\n-\n             gcx.enter(|tcx| {\n                 let (krate, render_opts, mut cache) = sess.time(\"run_global_ctxt\", || {\n-                    core::run_global_ctxt(\n-                        tcx,\n-                        resolver_caches,\n-                        show_coverage,\n-                        render_options,\n-                        output_format,\n-                    )\n+                    core::run_global_ctxt(tcx, show_coverage, render_options, output_format)\n                 });\n                 info!(\"finished with rustc\");\n "}, {"sha": "7e3149a59e3afd590d96f188dc2148ede219963f", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9ab7872fd77861e3d182ea85a82c4649c5bb3f8/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9ab7872fd77861e3d182ea85a82c4649c5bb3f8/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=e9ab7872fd77861e3d182ea85a82c4649c5bb3f8", "patch": "@@ -24,6 +24,7 @@ use rustc_span::BytePos;\n use smallvec::{smallvec, SmallVec};\n \n use std::borrow::Cow;\n+use std::mem;\n use std::ops::Range;\n \n use crate::clean::{self, utils::find_nearest_parent_module};\n@@ -34,9 +35,6 @@ use crate::lint::{BROKEN_INTRA_DOC_LINKS, PRIVATE_INTRA_DOC_LINKS};\n use crate::passes::Pass;\n use crate::visit::DocVisitor;\n \n-mod early;\n-pub(crate) use early::early_resolve_intra_doc_links;\n-\n pub(crate) const COLLECT_INTRA_DOC_LINKS: Pass = Pass {\n     name: \"collect-intra-doc-links\",\n     run: collect_intra_doc_links,\n@@ -1616,7 +1614,7 @@ fn resolution_failure(\n             // ignore duplicates\n             let mut variants_seen = SmallVec::<[_; 3]>::new();\n             for mut failure in kinds {\n-                let variant = std::mem::discriminant(&failure);\n+                let variant = mem::discriminant(&failure);\n                 if variants_seen.contains(&variant) {\n                     continue;\n                 }\n@@ -1686,7 +1684,7 @@ fn resolution_failure(\n \n                         if !path_str.contains(\"::\") {\n                             if disambiguator.map_or(true, |d| d.ns() == MacroNS)\n-                                && let Some(&res) = collector.cx.resolver_caches.all_macro_rules\n+                                && let Some(&res) = collector.cx.tcx.resolutions(()).all_macro_rules\n                                                              .get(&Symbol::intern(path_str))\n                             {\n                                 diag.note(format!("}, {"sha": "ec449e94ce587612be11ddbd4c768af6e9b55e81", "filename": "src/librustdoc/passes/collect_intra_doc_links/early.rs", "status": "removed", "additions": 0, "deletions": 72, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/c3c6d73b04a718aceabc314bf231a20c90ccd601/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3c6d73b04a718aceabc314bf231a20c90ccd601/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs?ref=c3c6d73b04a718aceabc314bf231a20c90ccd601", "patch": "@@ -1,72 +0,0 @@\n-use crate::core::ResolverCaches;\n-use crate::visit_lib::early_lib_embargo_visit_item;\n-\n-use rustc_ast::visit::{self, Visitor};\n-use rustc_ast::{self as ast, ItemKind};\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_hir::def::Res;\n-use rustc_hir::def_id::{DefId, DefIdSet};\n-use rustc_resolve::Resolver;\n-use rustc_span::Symbol;\n-\n-pub(crate) fn early_resolve_intra_doc_links(\n-    resolver: &mut Resolver<'_>,\n-    krate: &ast::Crate,\n-) -> ResolverCaches {\n-    let mut link_resolver = EarlyDocLinkResolver {\n-        resolver,\n-        all_trait_impls: Default::default(),\n-        all_macro_rules: Default::default(),\n-        extern_doc_reachable: Default::default(),\n-    };\n-\n-    visit::walk_crate(&mut link_resolver, krate);\n-    link_resolver.process_extern_impls();\n-\n-    ResolverCaches {\n-        all_trait_impls: Some(link_resolver.all_trait_impls),\n-        all_macro_rules: link_resolver.all_macro_rules,\n-        extern_doc_reachable: link_resolver.extern_doc_reachable,\n-    }\n-}\n-\n-struct EarlyDocLinkResolver<'r, 'ra> {\n-    resolver: &'r mut Resolver<'ra>,\n-    all_trait_impls: Vec<DefId>,\n-    all_macro_rules: FxHashMap<Symbol, Res<ast::NodeId>>,\n-    /// This set is used as a seed for `effective_visibilities`, which are then extended by some\n-    /// more items using `lib_embargo_visit_item` during doc inlining.\n-    extern_doc_reachable: DefIdSet,\n-}\n-\n-impl<'ra> EarlyDocLinkResolver<'_, 'ra> {\n-    fn process_extern_impls(&mut self) {\n-        for cnum in self.resolver.cstore().crates_untracked() {\n-            early_lib_embargo_visit_item(\n-                self.resolver,\n-                &mut self.extern_doc_reachable,\n-                cnum.as_def_id(),\n-                true,\n-            );\n-            for (_, impl_def_id, _) in self.resolver.cstore().trait_impls_in_crate_untracked(cnum) {\n-                self.all_trait_impls.push(impl_def_id);\n-            }\n-        }\n-    }\n-}\n-\n-impl Visitor<'_> for EarlyDocLinkResolver<'_, '_> {\n-    fn visit_item(&mut self, item: &ast::Item) {\n-        match &item.kind {\n-            ItemKind::Impl(impl_) if impl_.of_trait.is_some() => {\n-                self.all_trait_impls.push(self.resolver.local_def_id(item.id).to_def_id());\n-            }\n-            ItemKind::MacroDef(macro_def) if macro_def.macro_rules => {\n-                let (_, res) = self.resolver.macro_rules_scope(self.resolver.local_def_id(item.id));\n-                self.all_macro_rules.insert(item.ident.name, res);\n-            }\n-            _ => {}\n-        }\n-        visit::walk_item(self, item);\n-    }\n-}"}, {"sha": "878e738fe508c3ceef0c33d5f1fb486d65dc8343", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e9ab7872fd77861e3d182ea85a82c4649c5bb3f8/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9ab7872fd77861e3d182ea85a82c4649c5bb3f8/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=e9ab7872fd77861e3d182ea85a82c4649c5bb3f8", "patch": "@@ -45,18 +45,20 @@ pub(crate) fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) ->\n     let mut new_items_local = Vec::new();\n \n     // External trait impls.\n-    cx.with_all_trait_impls(|cx, all_trait_impls| {\n+    {\n         let _prof_timer = cx.tcx.sess.prof.generic_activity(\"build_extern_trait_impls\");\n-        for &impl_def_id in all_trait_impls.iter().skip_while(|def_id| def_id.is_local()) {\n-            inline::build_impl(cx, None, impl_def_id, None, &mut new_items_external);\n+        for &cnum in cx.tcx.crates(()) {\n+            for &impl_def_id in cx.tcx.trait_impls_in_crate(cnum) {\n+                inline::build_impl(cx, None, impl_def_id, None, &mut new_items_external);\n+            }\n         }\n-    });\n+    }\n \n     // Local trait impls.\n-    cx.with_all_trait_impls(|cx, all_trait_impls| {\n+    {\n         let _prof_timer = cx.tcx.sess.prof.generic_activity(\"build_local_trait_impls\");\n         let mut attr_buf = Vec::new();\n-        for &impl_def_id in all_trait_impls.iter().take_while(|def_id| def_id.is_local()) {\n+        for &impl_def_id in cx.tcx.trait_impls_in_crate(LOCAL_CRATE) {\n             let mut parent = Some(cx.tcx.parent(impl_def_id));\n             while let Some(did) = parent {\n                 attr_buf.extend(\n@@ -76,7 +78,7 @@ pub(crate) fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) ->\n             inline::build_impl(cx, None, impl_def_id, Some(&attr_buf), &mut new_items_local);\n             attr_buf.clear();\n         }\n-    });\n+    }\n \n     cx.tcx.sess.prof.generic_activity(\"build_primitive_trait_impls\").run(|| {\n         for def_id in PrimitiveType::all_impls(cx.tcx) {"}, {"sha": "fd4f9254107caee8baa3b9837b7260f115a1737b", "filename": "src/librustdoc/visit_lib.rs", "status": "modified", "additions": 1, "deletions": 50, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/e9ab7872fd77861e3d182ea85a82c4649c5bb3f8/src%2Flibrustdoc%2Fvisit_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9ab7872fd77861e3d182ea85a82c4649c5bb3f8/src%2Flibrustdoc%2Fvisit_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_lib.rs?ref=e9ab7872fd77861e3d182ea85a82c4649c5bb3f8", "patch": "@@ -1,8 +1,7 @@\n use crate::core::DocContext;\n-use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{DefId, DefIdSet};\n use rustc_middle::ty::TyCtxt;\n-use rustc_resolve::Resolver;\n \n // FIXME: this may not be exhaustive, but is sufficient for rustdocs current uses\n \n@@ -26,10 +25,6 @@ impl RustdocEffectiveVisibilities {\n     define_method!(is_directly_public);\n     define_method!(is_exported);\n     define_method!(is_reachable);\n-\n-    pub(crate) fn init(&mut self, extern_public: DefIdSet) {\n-        self.extern_public = extern_public;\n-    }\n }\n \n pub(crate) fn lib_embargo_visit_item(cx: &mut DocContext<'_>, def_id: DefId) {\n@@ -42,17 +37,6 @@ pub(crate) fn lib_embargo_visit_item(cx: &mut DocContext<'_>, def_id: DefId) {\n     .visit_item(def_id)\n }\n \n-pub(crate) fn early_lib_embargo_visit_item(\n-    resolver: &Resolver<'_>,\n-    extern_public: &mut DefIdSet,\n-    def_id: DefId,\n-    is_mod: bool,\n-) {\n-    assert!(!def_id.is_local());\n-    EarlyLibEmbargoVisitor { resolver, extern_public, visited_mods: Default::default() }\n-        .visit_item(def_id, is_mod)\n-}\n-\n /// Similar to `librustc_privacy::EmbargoVisitor`, but also takes\n /// specific rustdoc annotations into account (i.e., `doc(hidden)`)\n struct LibEmbargoVisitor<'a, 'tcx> {\n@@ -63,14 +47,6 @@ struct LibEmbargoVisitor<'a, 'tcx> {\n     visited_mods: DefIdSet,\n }\n \n-struct EarlyLibEmbargoVisitor<'r, 'ra> {\n-    resolver: &'r Resolver<'ra>,\n-    // Effective visibilities for reachable nodes\n-    extern_public: &'r mut DefIdSet,\n-    // Keeps track of already visited modules, in case a module re-exports its parent\n-    visited_mods: DefIdSet,\n-}\n-\n impl LibEmbargoVisitor<'_, '_> {\n     fn visit_mod(&mut self, def_id: DefId) {\n         if !self.visited_mods.insert(def_id) {\n@@ -95,28 +71,3 @@ impl LibEmbargoVisitor<'_, '_> {\n         }\n     }\n }\n-\n-impl EarlyLibEmbargoVisitor<'_, '_> {\n-    fn visit_mod(&mut self, def_id: DefId) {\n-        if !self.visited_mods.insert(def_id) {\n-            return;\n-        }\n-\n-        for item in self.resolver.cstore().module_children_untracked(def_id, self.resolver.sess()) {\n-            if let Some(def_id) = item.res.opt_def_id() {\n-                if item.vis.is_public() {\n-                    self.visit_item(def_id, matches!(item.res, Res::Def(DefKind::Mod, _)));\n-                }\n-            }\n-        }\n-    }\n-\n-    fn visit_item(&mut self, def_id: DefId, is_mod: bool) {\n-        if !self.resolver.cstore().is_doc_hidden_untracked(def_id) {\n-            self.extern_public.insert(def_id);\n-            if is_mod {\n-                self.visit_mod(def_id);\n-            }\n-        }\n-    }\n-}"}]}