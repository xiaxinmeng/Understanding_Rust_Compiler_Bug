{"sha": "fe5de6bfffee3c277f540517b5766547f34e81c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlNWRlNmJmZmZlZTNjMjc3ZjU0MDUxN2I1NzY2NTQ3ZjM0ZTgxYzc=", "commit": {"author": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2011-02-27T19:30:44Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-03-02T18:28:14Z"}, "message": "Parse parameter types for fmt extension", "tree": {"sha": "0c93def17b39f88ac2dca3e83fe5fb7416cfd058", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c93def17b39f88ac2dca3e83fe5fb7416cfd058"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe5de6bfffee3c277f540517b5766547f34e81c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe5de6bfffee3c277f540517b5766547f34e81c7", "html_url": "https://github.com/rust-lang/rust/commit/fe5de6bfffee3c277f540517b5766547f34e81c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe5de6bfffee3c277f540517b5766547f34e81c7/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1500e5872d03e3ec3b140060641136a2ff5a15a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1500e5872d03e3ec3b140060641136a2ff5a15a", "html_url": "https://github.com/rust-lang/rust/commit/f1500e5872d03e3ec3b140060641136a2ff5a15a"}], "stats": {"total": 165, "additions": 126, "deletions": 39}, "files": [{"sha": "998bfa4de433cbf68874f3f107522a79c7e8759a", "filename": "src/comp/front/extfmt.rs", "status": "modified", "additions": 120, "deletions": 28, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/fe5de6bfffee3c277f540517b5766547f34e81c7/src%2Fcomp%2Ffront%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5de6bfffee3c277f540517b5766547f34e81c7/src%2Fcomp%2Ffront%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fextfmt.rs?ref=fe5de6bfffee3c277f540517b5766547f34e81c7", "patch": "@@ -18,6 +18,8 @@ import front.parser;\n import std._str;\n import std._vec;\n import std.option;\n+import std.option.none;\n+import std.option.some;\n \n tag signedness {\n     signed;\n@@ -55,13 +57,11 @@ tag count {\n }\n \n // A formatted conversion from an expression to a string\n-tag conv {\n-    conv_param(option.t[int]);\n-    conv_flags(vec[flag]);\n-    conv_width(count);\n-    conv_precision(count);\n-    conv_ty(ty);\n-}\n+type conv = rec(option.t[int] param,\n+                vec[flag] flags,\n+                count width,\n+                count precision,\n+                ty typ);\n \n // A fragment of the output sequence\n tag piece {\n@@ -84,6 +84,18 @@ fn expand_syntax_ext(vec[@ast.expr] args,\n     auto fmt = expr_to_str(args.(0));\n     log fmt;\n     auto pieces = parse_fmt_string(fmt);\n+    log \"printing all pieces\";\n+    for (piece p in pieces) {\n+        alt (p) {\n+            case (piece_string(?s)) {\n+                log s;\n+            }\n+            case (piece_conv(_)) {\n+                log \"conv\";\n+            }\n+        }\n+    }\n+    log \"done printing all pieces\";\n     ret pieces_to_expr(pieces, args);\n }\n \n@@ -107,33 +119,16 @@ fn parse_fmt_string(str s) -> vec[piece] {\n     auto lim = _str.byte_len(s);\n     auto buf = \"\";\n \n-    // TODO: This is super ugly\n-    fn flush_buf(str buf, vec[piece] pieces) -> str {\n-        log \"flushing\";\n+    fn flush_buf(str buf, &vec[piece] pieces) -> str {\n         if (_str.byte_len(buf) > 0u) {\n             auto piece = piece_string(buf);\n             pieces += piece;\n         }\n-        log \"buf:\";\n-        log buf;\n-        log \"pieces:\";\n-        for (piece p in pieces) {\n-            alt (p) {\n-                case (piece_string(?s)) {\n-                    log s;\n-                }\n-                case (piece_conv(_)) {\n-                    log \"conv\";\n-                }\n-            }\n-        }\n         ret \"\";\n     }\n \n     auto i = 0u;\n     while (i < lim) {\n-        log \"step:\";\n-        log i;\n         auto curr = _str.substr(s, i, 1u);\n         if (_str.eq(curr, \"%\")) {\n             i += 1u;\n@@ -146,18 +141,115 @@ fn parse_fmt_string(str s) -> vec[piece] {\n                 i += 1u;\n             } else {\n                 buf = flush_buf(buf, pieces);\n+                auto res = parse_conversion(s, i, lim);\n+                pieces += res._0;\n+                i = res._1;\n             }\n         } else {\n             buf += curr;\n-            log \"buf:\";\n-            log buf;\n             i += 1u;\n         }\n     }\n-\n+    buf = flush_buf(buf, pieces);\n     ret pieces;\n }\n \n+fn peek_num(str s, uint i, uint lim) -> option.t[tup(int, int)] {\n+    if (i >= lim) {\n+        ret none[tup(int, int)];\n+    } else {\n+        ret none[tup(int, int)];\n+        /*if ('0' <= c && c <= '9') {\n+            log c;\n+            fail;\n+        } else {\n+            ret option.none[tup(int, int)];\n+        }\n+        */\n+    }\n+}\n+\n+fn parse_conversion(str s, uint i, uint lim) -> tup(piece, uint) {\n+    auto parm = parse_parameter(s, i, lim);\n+    auto flags = parse_flags(s, parm._1, lim);\n+    auto width = parse_width(s, flags._1, lim);\n+    auto prec = parse_precision(s, width._1, lim);\n+    auto ty = parse_type(s, prec._1, lim);\n+    ret tup(piece_conv(rec(param = parm._0,\n+                           flags = flags._0,\n+                           width = width._0,\n+                           precision = prec._0,\n+                           typ = ty._0)),\n+            ty._1);\n+}\n+\n+fn parse_parameter(str s, uint i, uint lim) -> tup(option.t[int], uint) {\n+    if (i >= lim) {\n+        ret tup(none[int], i);\n+    }\n+\n+    auto num = peek_num(s, i, lim);\n+    alt (num) {\n+        case (none[tup(int, int)]) {\n+            ret tup(none[int], i);\n+        }\n+        case (some[tup(int, int)](?t)) {\n+            fail;\n+        }\n+    }\n+}\n+\n+fn parse_flags(str s, uint i, uint lim) -> tup(vec[flag], uint) {\n+    let vec[flag] flags = vec();\n+    ret tup(flags, i);\n+}\n+\n+fn parse_width(str s, uint i, uint lim) -> tup(count, uint) {\n+    ret tup(count_implied, i);\n+}\n+\n+fn parse_precision(str s, uint i, uint lim) -> tup(count, uint) {\n+    ret tup(count_implied, i);\n+}\n+\n+fn parse_type(str s, uint i, uint lim) -> tup(ty, uint) {\n+    if (i >= lim) {\n+        log \"missing type in conversion\";\n+        fail;\n+    }\n+\n+    auto t;\n+    auto tstr = _str.substr(s, i, 1u);\n+    if (_str.eq(tstr, \"b\")) {\n+        t = ty_bool;\n+    } else if (_str.eq(tstr, \"s\")) {\n+        t = ty_str;\n+    } else if (_str.eq(tstr, \"c\")) {\n+        t = ty_char;\n+    } else if (_str.eq(tstr, \"d\")\n+               || _str.eq(tstr, \"i\")) {\n+        // TODO: Do we really want two signed types here?\n+        // How important is it to be printf compatible?\n+        t = ty_int(signed);\n+    } else if (_str.eq(tstr, \"u\")) {\n+        t = ty_int(unsigned);\n+    } else if (_str.eq(tstr, \"x\")) {\n+        t = ty_hex(case_lower);\n+    } else if (_str.eq(tstr, \"X\")) {\n+        t = ty_hex(case_upper);\n+    } else if (_str.eq(tstr, \"t\")) {\n+        t = ty_bits;\n+    } else {\n+        // FIXME: This is a hack to avoid 'unsatisfied precondition\n+        // constraint' on uninitialized variable t below\n+        t = ty_bool;\n+        log \"unknown type in conversion\";\n+        fail;\n+    }\n+\n+    ret tup(t, i + 1u);\n+}\n+\n fn pieces_to_expr(vec[piece] pieces, vec[@ast.expr] args) -> @ast.expr {\n     auto lo = args.(0).span;\n     auto hi = args.(0).span;"}, {"sha": "9fee3dab4a0b718773531b52428c231e81c8f822", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe5de6bfffee3c277f540517b5766547f34e81c7/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5de6bfffee3c277f540517b5766547f34e81c7/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=fe5de6bfffee3c277f540517b5766547f34e81c7", "patch": "@@ -1957,8 +1957,6 @@ fn trans_lit(@crate_ctxt cx, &ast.lit lit, &ast.ann ann) -> ValueRef {\n             ret C_nil();\n         }\n         case (ast.lit_str(?s)) {\n-            log \"translating literal:\";\n-            log s;\n             ret C_str(cx, s);\n         }\n     }\n@@ -3601,7 +3599,6 @@ fn trans_rec(@block_ctxt cx, vec[ast.field] fields,\n fn trans_expr(@block_ctxt cx, @ast.expr e) -> result {\n     alt (e.node) {\n         case (ast.expr_lit(?lit, ?ann)) {\n-            log \"translating literal\";\n             ret res(cx, trans_lit(cx.fcx.ccx, *lit, ann));\n         }\n \n@@ -3697,7 +3694,6 @@ fn trans_expr(@block_ctxt cx, @ast.expr e) -> result {\n         }\n \n         case (ast.expr_ext(_, _, _, ?expanded, _)) {\n-            log \"translating extension\";\n             ret trans_expr(cx, option.get[@ast.expr](expanded));\n         }\n "}, {"sha": "fb19620f8b9512323d2647055c2b2689e5b4817d", "filename": "src/rt/memory_region.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe5de6bfffee3c277f540517b5766547f34e81c7/src%2Frt%2Fmemory_region.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/fe5de6bfffee3c277f540517b5766547f34e81c7/src%2Frt%2Fmemory_region.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fmemory_region.cpp?ref=fe5de6bfffee3c277f540517b5766547f34e81c7", "patch": "@@ -1,7 +1,7 @@\n #include \"rust_internal.h\"\n #include \"memory_region.h\"\n \n-// #define TRACK_ALLOCATIONS\n+#define TRACK_ALLOCATIONS\n \n memory_region::memory_region(rust_srv *srv, bool synchronized) :\n     _srv(srv), _parent(NULL), _live_allocations(0),"}, {"sha": "b7076c8176d3cc5b73b0721f52e7096f041974f8", "filename": "src/test/run-pass/syntax-extension-fmt.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fe5de6bfffee3c277f540517b5766547f34e81c7/src%2Ftest%2Frun-pass%2Fsyntax-extension-fmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5de6bfffee3c277f540517b5766547f34e81c7/src%2Ftest%2Frun-pass%2Fsyntax-extension-fmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsyntax-extension-fmt.rs?ref=fe5de6bfffee3c277f540517b5766547f34e81c7", "patch": "@@ -1,14 +1,13 @@\n-//use std;\n-//import std._str;\n+use std;\n+import std._str;\n \n fn test(str actual, str expected) {\n   log actual;\n   log expected;\n-  //check (_str.eq(actual, expected));\n+  check (_str.eq(actual, expected));\n }\n \n fn main() {\n-  /*test(#fmt(\"hello %d friends and %s things\", 10, \"formatted\"),\n-    \"hello 10 friends and formatted things\");*/\n-  log #fmt(\"test\");\n+  test(#fmt(\"hello %d friends and %s things\", 10, \"formatted\"),\n+    \"hello 10 friends and formatted things\");\n }"}]}