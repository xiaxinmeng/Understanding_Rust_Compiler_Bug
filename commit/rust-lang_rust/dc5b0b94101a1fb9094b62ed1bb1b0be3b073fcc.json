{"sha": "dc5b0b94101a1fb9094b62ed1bb1b0be3b073fcc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjNWIwYjk0MTAxYTFmYjkwOTRiNjJlZDFiYjFiMGJlM2IwNzNmY2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-05T01:10:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-05T01:10:53Z"}, "message": "auto merge of #8282 : brson/rust/more-newsched-fixes, r=brson", "tree": {"sha": "9213742ffdd773b77d3d31bd42304a71d876ad61", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9213742ffdd773b77d3d31bd42304a71d876ad61"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc5b0b94101a1fb9094b62ed1bb1b0be3b073fcc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc5b0b94101a1fb9094b62ed1bb1b0be3b073fcc", "html_url": "https://github.com/rust-lang/rust/commit/dc5b0b94101a1fb9094b62ed1bb1b0be3b073fcc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc5b0b94101a1fb9094b62ed1bb1b0be3b073fcc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "77bc6c59556cd13f88e18a53387b780bb1b6182d", "url": "https://api.github.com/repos/rust-lang/rust/commits/77bc6c59556cd13f88e18a53387b780bb1b6182d", "html_url": "https://github.com/rust-lang/rust/commit/77bc6c59556cd13f88e18a53387b780bb1b6182d"}, {"sha": "3f4c6cead67cedea5042d5ba84fb490dfee5462a", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f4c6cead67cedea5042d5ba84fb490dfee5462a", "html_url": "https://github.com/rust-lang/rust/commit/3f4c6cead67cedea5042d5ba84fb490dfee5462a"}], "stats": {"total": 333, "additions": 75, "deletions": 258}, "files": [{"sha": "776e25cac8908447988c204aca86bea7c717db87", "filename": "src/libextra/comm.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dc5b0b94101a1fb9094b62ed1bb1b0be3b073fcc/src%2Flibextra%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5b0b94101a1fb9094b62ed1bb1b0be3b073fcc/src%2Flibextra%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcomm.rs?ref=dc5b0b94101a1fb9094b62ed1bb1b0be3b073fcc", "patch": "@@ -18,9 +18,8 @@ Higher level communication abstractions.\n \n \n use std::comm::{GenericChan, GenericSmartChan, GenericPort};\n-use std::comm::{Chan, Port, Selectable, Peekable};\n+use std::comm::{Chan, Port, Peekable};\n use std::comm;\n-use std::pipes;\n \n /// An extension of `pipes::stream` that allows both sending and receiving.\n pub struct DuplexStream<T, U> {\n@@ -75,12 +74,6 @@ impl<T:Send,U:Send> Peekable<U> for DuplexStream<T, U> {\n     }\n }\n \n-impl<T:Send,U:Send> Selectable for DuplexStream<T, U> {\n-    fn header(&mut self) -> *mut pipes::PacketHeader {\n-        self.port.header()\n-    }\n-}\n-\n /// Creates a bidirectional stream.\n pub fn DuplexStream<T:Send,U:Send>()\n     -> (DuplexStream<T, U>, DuplexStream<U, T>)"}, {"sha": "4356f1143da4668f760d598aa1f1d34d50cb8120", "filename": "src/libstd/comm.rs", "status": "modified", "additions": 2, "deletions": 108, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/dc5b0b94101a1fb9094b62ed1bb1b0be3b073fcc/src%2Flibstd%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5b0b94101a1fb9094b62ed1bb1b0be3b073fcc/src%2Flibstd%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm.rs?ref=dc5b0b94101a1fb9094b62ed1bb1b0be3b073fcc", "patch": "@@ -14,7 +14,6 @@ Message passing\n \n #[allow(missing_doc)];\n \n-use cast::transmute;\n use either::{Either, Left, Right};\n use kinds::Send;\n use option::{Option, Some};\n@@ -23,12 +22,6 @@ pub use rt::comm::SendDeferred;\n use rtcomm = rt::comm;\n use rt;\n \n-use pipes::{wait_many, PacketHeader};\n-\n-// FIXME #5160: Making this public exposes some plumbing from\n-// pipes. Needs some refactoring\n-pub use pipes::Selectable;\n-\n /// A trait for things that can send multiple messages.\n pub trait GenericChan<T> {\n     /// Sends a message.\n@@ -146,15 +139,6 @@ impl<T: Send> Peekable<T> for Port<T> {\n     }\n }\n \n-impl<T: Send> Selectable for Port<T> {\n-    fn header(&mut self) -> *mut PacketHeader {\n-        match self.inner {\n-            Left(ref mut port) => port.header(),\n-            Right(_) => fail!(\"can't select on newsched ports\")\n-        }\n-    }\n-}\n-\n /// A channel that can be shared between many senders.\n pub struct SharedChan<T> {\n     inner: Either<Exclusive<pipesy::Chan<T>>, rtcomm::SharedChan<T>>\n@@ -318,8 +302,8 @@ mod pipesy {\n \n     use kinds::Send;\n     use option::{Option, Some, None};\n-    use pipes::{recv, try_recv, peek, PacketHeader};\n-    use super::{GenericChan, GenericSmartChan, GenericPort, Peekable, Selectable};\n+    use pipes::{recv, try_recv, peek};\n+    use super::{GenericChan, GenericSmartChan, GenericPort, Peekable};\n     use cast::transmute_mut;\n \n     /*proto! oneshot (\n@@ -651,103 +635,13 @@ mod pipesy {\n         }\n     }\n \n-    impl<T: Send> Selectable for Port<T> {\n-        fn header(&mut self) -> *mut PacketHeader {\n-            match self.endp {\n-                Some(ref mut endp) => endp.header(),\n-                None => fail!(\"peeking empty stream\")\n-            }\n-    }\n-}\n-\n-}\n-\n-/// Returns the index of an endpoint that is ready to receive.\n-pub fn selecti<T: Selectable>(endpoints: &mut [T]) -> uint {\n-    wait_many(endpoints)\n-}\n-\n-/// Returns 0 or 1 depending on which endpoint is ready to receive\n-pub fn select2i<A:Selectable, B:Selectable>(a: &mut A, b: &mut B)\n-                                            -> Either<(), ()> {\n-    let mut endpoints = [ a.header(), b.header() ];\n-    match wait_many(endpoints) {\n-        0 => Left(()),\n-        1 => Right(()),\n-        _ => fail!(\"wait returned unexpected index\"),\n-    }\n-}\n-\n-/// Receive a message from one of two endpoints.\n-pub trait Select2<T: Send, U: Send> {\n-    /// Receive a message or return `None` if a connection closes.\n-    fn try_select(&mut self) -> Either<Option<T>, Option<U>>;\n-    /// Receive a message or fail if a connection closes.\n-    fn select(&mut self) -> Either<T, U>;\n-}\n-\n-impl<T:Send,\n-     U:Send,\n-     Left:Selectable + GenericPort<T>,\n-     Right:Selectable + GenericPort<U>>\n-     Select2<T, U>\n-     for (Left, Right) {\n-    fn select(&mut self) -> Either<T, U> {\n-        // XXX: Bad borrow check workaround.\n-        unsafe {\n-            let this: &(Left, Right) = transmute(self);\n-            match *this {\n-                (ref lp, ref rp) => {\n-                    let lp: &mut Left = transmute(lp);\n-                    let rp: &mut Right = transmute(rp);\n-                    match select2i(lp, rp) {\n-                        Left(()) => Left(lp.recv()),\n-                        Right(()) => Right(rp.recv()),\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    fn try_select(&mut self) -> Either<Option<T>, Option<U>> {\n-        // XXX: Bad borrow check workaround.\n-        unsafe {\n-            let this: &(Left, Right) = transmute(self);\n-            match *this {\n-                (ref lp, ref rp) => {\n-                    let lp: &mut Left = transmute(lp);\n-                    let rp: &mut Right = transmute(rp);\n-                    match select2i(lp, rp) {\n-                        Left(()) => Left (lp.try_recv()),\n-                        Right(()) => Right(rp.try_recv()),\n-                    }\n-                }\n-            }\n-        }\n-    }\n }\n \n #[cfg(test)]\n mod test {\n     use either::Right;\n     use super::{Chan, Port, oneshot, stream};\n \n-    #[test]\n-    fn test_select2() {\n-        let (p1, c1) = stream();\n-        let (p2, c2) = stream();\n-\n-        c1.send(~\"abc\");\n-\n-        let mut tuple = (p1, p2);\n-        match tuple.select() {\n-            Right(_) => fail!(),\n-            _ => (),\n-        }\n-\n-        c2.send(123);\n-    }\n-\n     #[test]\n     fn test_oneshot() {\n         let (p, c) = oneshot();"}, {"sha": "78f937e058a41bb43bbd19d075f072c91ac2fb73", "filename": "src/libstd/pipes.rs", "status": "modified", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/dc5b0b94101a1fb9094b62ed1bb1b0be3b073fcc/src%2Flibstd%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5b0b94101a1fb9094b62ed1bb1b0be3b073fcc/src%2Flibstd%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpipes.rs?ref=dc5b0b94101a1fb9094b62ed1bb1b0be3b073fcc", "patch": "@@ -868,47 +868,3 @@ pub mod rt {\n     pub fn make_some<T>(val: T) -> Option<T> { Some(val) }\n     pub fn make_none<T>() -> Option<T> { None }\n }\n-\n-#[cfg(test)]\n-mod test {\n-    use either::Right;\n-    use comm::{Chan, Port, oneshot, recv_one, stream, Select2,\n-               GenericChan, Peekable};\n-\n-    #[test]\n-    fn test_select2() {\n-        let (p1, c1) = stream();\n-        let (p2, c2) = stream();\n-\n-        c1.send(~\"abc\");\n-\n-        let mut tuple = (p1, p2);\n-        match tuple.select() {\n-            Right(_) => fail!(),\n-            _ => (),\n-        }\n-\n-        c2.send(123);\n-    }\n-\n-    #[test]\n-    fn test_oneshot() {\n-        let (p, c) = oneshot();\n-\n-        c.send(());\n-\n-        recv_one(p)\n-    }\n-\n-    #[test]\n-    fn test_peek_terminated() {\n-        let (port, chan): (Port<int>, Chan<int>) = stream();\n-\n-        {\n-            // Destroy the channel\n-            let _chan = chan;\n-        }\n-\n-        assert!(!port.peek());\n-    }\n-}"}, {"sha": "131507196b1f2558e61d6d7276ba1ca613f827c3", "filename": "src/libstd/rt/local.rs", "status": "modified", "additions": 45, "deletions": 36, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/dc5b0b94101a1fb9094b62ed1bb1b0be3b073fcc/src%2Flibstd%2Frt%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5b0b94101a1fb9094b62ed1bb1b0be3b073fcc/src%2Flibstd%2Frt%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal.rs?ref=dc5b0b94101a1fb9094b62ed1bb1b0be3b073fcc", "patch": "@@ -126,63 +126,72 @@ impl Local for IoFactoryObject {\n \n #[cfg(test)]\n mod test {\n+    use unstable::run_in_bare_thread;\n     use rt::test::*;\n     use super::*;\n     use rt::task::Task;\n     use rt::local_ptr;\n \n     #[test]\n     fn thread_local_task_smoke_test() {\n-        local_ptr::init_tls_key();\n-        let mut sched = ~new_test_uv_sched();\n-        let task = ~Task::new_root(&mut sched.stack_pool, || {});\n-        Local::put(task);\n-        let task: ~Task = Local::take();\n-        cleanup_task(task);\n+        do run_in_bare_thread {\n+            local_ptr::init_tls_key();\n+            let mut sched = ~new_test_uv_sched();\n+            let task = ~Task::new_root(&mut sched.stack_pool, || {});\n+            Local::put(task);\n+            let task: ~Task = Local::take();\n+            cleanup_task(task);\n+        }\n     }\n \n     #[test]\n     fn thread_local_task_two_instances() {\n-        local_ptr::init_tls_key();\n-        let mut sched = ~new_test_uv_sched();\n-        let task = ~Task::new_root(&mut sched.stack_pool, || {});\n-        Local::put(task);\n-        let task: ~Task = Local::take();\n-        cleanup_task(task);\n-        let task = ~Task::new_root(&mut sched.stack_pool, || {});\n-        Local::put(task);\n-        let task: ~Task = Local::take();\n-        cleanup_task(task);\n+        do run_in_bare_thread {\n+            local_ptr::init_tls_key();\n+            let mut sched = ~new_test_uv_sched();\n+            let task = ~Task::new_root(&mut sched.stack_pool, || {});\n+            Local::put(task);\n+            let task: ~Task = Local::take();\n+            cleanup_task(task);\n+            let task = ~Task::new_root(&mut sched.stack_pool, || {});\n+            Local::put(task);\n+            let task: ~Task = Local::take();\n+            cleanup_task(task);\n+        }\n \n     }\n \n     #[test]\n     fn borrow_smoke_test() {\n-        local_ptr::init_tls_key();\n-        let mut sched = ~new_test_uv_sched();\n-        let task = ~Task::new_root(&mut sched.stack_pool, || {});\n-        Local::put(task);\n-\n-        unsafe {\n-            let _task: *mut Task = Local::unsafe_borrow();\n+        do run_in_bare_thread {\n+            local_ptr::init_tls_key();\n+            let mut sched = ~new_test_uv_sched();\n+            let task = ~Task::new_root(&mut sched.stack_pool, || {});\n+            Local::put(task);\n+\n+            unsafe {\n+                let _task: *mut Task = Local::unsafe_borrow();\n+            }\n+            let task: ~Task = Local::take();\n+            cleanup_task(task);\n         }\n-        let task: ~Task = Local::take();\n-        cleanup_task(task);\n     }\n \n     #[test]\n     fn borrow_with_return() {\n-        local_ptr::init_tls_key();\n-        let mut sched = ~new_test_uv_sched();\n-        let task = ~Task::new_root(&mut sched.stack_pool, || {});\n-        Local::put(task);\n-\n-        let res = do Local::borrow::<Task,bool> |_task| {\n-            true\n-        };\n-        assert!(res)\n-        let task: ~Task = Local::take();\n-        cleanup_task(task);\n+        do run_in_bare_thread {\n+            local_ptr::init_tls_key();\n+            let mut sched = ~new_test_uv_sched();\n+            let task = ~Task::new_root(&mut sched.stack_pool, || {});\n+            Local::put(task);\n+\n+            let res = do Local::borrow::<Task,bool> |_task| {\n+                true\n+            };\n+            assert!(res)\n+                let task: ~Task = Local::take();\n+            cleanup_task(task);\n+        }\n     }\n \n }"}, {"sha": "652e39b05c7e0eb15e18a5ac1368d9697195ccc1", "filename": "src/libstd/rt/local_ptr.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/dc5b0b94101a1fb9094b62ed1bb1b0be3b073fcc/src%2Flibstd%2Frt%2Flocal_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5b0b94101a1fb9094b62ed1bb1b0be3b073fcc/src%2Flibstd%2Frt%2Flocal_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_ptr.rs?ref=dc5b0b94101a1fb9094b62ed1bb1b0be3b073fcc", "patch": "@@ -52,7 +52,9 @@ pub unsafe fn put<T>(sched: ~T) {\n pub unsafe fn take<T>() -> ~T {\n     let key = tls_key();\n     let void_ptr: *mut c_void = tls::get(key);\n-    rtassert!(void_ptr.is_not_null());\n+    if void_ptr.is_null() {\n+        rtabort!(\"thread-local pointer is null. bogus!\");\n+    }\n     let ptr: ~T = cast::transmute(void_ptr);\n     tls::set(key, ptr::mut_null());\n     return ptr;\n@@ -68,8 +70,8 @@ pub fn exists() -> bool {\n     }\n }\n \n-/// Borrow the thread-local scheduler from thread-local storage.\n-/// While the scheduler is borrowed it is not available in TLS.\n+/// Borrow the thread-local value from thread-local storage.\n+/// While the value is borrowed it is not available in TLS.\n ///\n /// # Safety note\n ///\n@@ -88,21 +90,23 @@ pub unsafe fn borrow<T>(f: &fn(&mut T)) {\n     }\n }\n \n-/// Borrow a mutable reference to the thread-local Scheduler\n+/// Borrow a mutable reference to the thread-local value\n ///\n /// # Safety Note\n ///\n-/// Because this leaves the Scheduler in thread-local storage it is possible\n+/// Because this leaves the value in thread-local storage it is possible\n /// For the Scheduler pointer to be aliased\n pub unsafe fn unsafe_borrow<T>() -> *mut T {\n     let key = tls_key();\n-    let mut void_sched: *mut c_void = tls::get(key);\n-    rtassert!(void_sched.is_not_null());\n+    let mut void_ptr: *mut c_void = tls::get(key);\n+    if void_ptr.is_null() {\n+        rtabort!(\"thread-local pointer is null. bogus!\");\n+    }\n     {\n-        let sched: *mut *mut c_void = &mut void_sched;\n-        let sched: *mut ~T = sched as *mut ~T;\n-        let sched: *mut T = &mut **sched;\n-        return sched;\n+        let ptr: *mut *mut c_void = &mut void_ptr;\n+        let ptr: *mut ~T = ptr as *mut ~T;\n+        let ptr: *mut T = &mut **ptr;\n+        return ptr;\n     }\n }\n "}, {"sha": "33e83fd9040412936dc0d28db05a3d7709f6e22a", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dc5b0b94101a1fb9094b62ed1bb1b0be3b073fcc/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5b0b94101a1fb9094b62ed1bb1b0be3b073fcc/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=dc5b0b94101a1fb9094b62ed1bb1b0be3b073fcc", "patch": "@@ -432,13 +432,3 @@ pub fn context() -> RuntimeContext {\n         pub fn rust_try_get_task() -> *rust_task;\n     }\n }\n-\n-#[test]\n-fn test_context() {\n-    use unstable::run_in_bare_thread;\n-\n-    assert_eq!(context(), OldTaskContext);\n-    do run_in_bare_thread {\n-        assert_eq!(context(), GlobalContext);\n-    }\n-}"}, {"sha": "a5c8abc2a6c0e2951ff523aa568608279286c32f", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dc5b0b94101a1fb9094b62ed1bb1b0be3b073fcc/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5b0b94101a1fb9094b62ed1bb1b0be3b073fcc/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=dc5b0b94101a1fb9094b62ed1bb1b0be3b073fcc", "patch": "@@ -172,6 +172,10 @@ impl Scheduler {\n \n         rtdebug!(\"stopping scheduler %u\", stask.sched.get_ref().sched_id());\n \n+        // Should not have any messages\n+        let message = stask.sched.get_mut_ref().message_queue.pop();\n+        assert!(message.is_none());\n+\n         stask.destroyed = true;\n     }\n \n@@ -336,11 +340,14 @@ impl Scheduler {\n         match this.message_queue.pop() {\n             Some(PinnedTask(task)) => {\n                 let mut task = task;\n+                this.event_loop.callback(Scheduler::run_sched_once);\n                 task.give_home(Sched(this.make_handle()));\n                 this.resume_task_immediately(task);\n                 return None;\n             }\n             Some(TaskFromFriend(task)) => {\n+                this.event_loop.callback(Scheduler::run_sched_once);\n+                rtdebug!(\"got a task from a friend. lovely!\");\n                 return this.sched_schedule_task(task);\n             }\n             Some(Wake) => {\n@@ -395,6 +402,7 @@ impl Scheduler {\n     /// Take a non-homed task we aren't allowed to run here and send\n     /// it to the designated friend scheduler to execute.\n     fn send_to_friend(&mut self, task: ~Task) {\n+        rtdebug!(\"sending a task to friend\");\n         match self.friend_handle {\n             Some(ref mut handle) => {\n                 handle.send(TaskFromFriend(task));\n@@ -426,12 +434,14 @@ impl Scheduler {\n                             Scheduler::send_task_home(task);\n                             return Some(this);\n                         } else {\n+                            this.event_loop.callback(Scheduler::run_sched_once);\n                             task.give_home(Sched(home_handle));\n                             this.resume_task_immediately(task);\n                             return None;\n                         }\n                     }\n                     AnySched if this.run_anything => {\n+                        this.event_loop.callback(Scheduler::run_sched_once);\n                         task.give_home(AnySched);\n                         this.resume_task_immediately(task);\n                         return None;"}, {"sha": "ffe9f118b477cbe90548dddd485092122776c783", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc5b0b94101a1fb9094b62ed1bb1b0be3b073fcc/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5b0b94101a1fb9094b62ed1bb1b0be3b073fcc/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=dc5b0b94101a1fb9094b62ed1bb1b0be3b073fcc", "patch": "@@ -303,7 +303,7 @@ impl Task {\n impl Drop for Task {\n     fn drop(&self) {\n         rtdebug!(\"called drop for a task: %u\", borrow::to_uint(self));\n-        assert!(self.destroyed)\n+        rtassert!(self.destroyed)\n     }\n }\n \n@@ -313,7 +313,7 @@ impl Drop for Task {\n impl Coroutine {\n \n     pub fn new(stack_pool: &mut StackPool, start: ~fn()) -> Coroutine {\n-        static MIN_STACK_SIZE: uint = 2000000; // XXX: Too much stack\n+        static MIN_STACK_SIZE: uint = 3000000; // XXX: Too much stack\n \n         let start = Coroutine::build_start_wrapper(start);\n         let mut stack = stack_pool.take_segment(MIN_STACK_SIZE);"}, {"sha": "df242ee3d3059613093a971667f100ea3ca798de", "filename": "src/test/run-pass/issue-3176.rs", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/77bc6c59556cd13f88e18a53387b780bb1b6182d/src%2Ftest%2Frun-pass%2Fissue-3176.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77bc6c59556cd13f88e18a53387b780bb1b6182d/src%2Ftest%2Frun-pass%2Fissue-3176.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3176.rs?ref=77bc6c59556cd13f88e18a53387b780bb1b6182d", "patch": "@@ -1,39 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// xfail-fast\n-// xfail-win32 #7999\n-\n-use std::comm::{Select2, Selectable};\n-use std::comm;\n-use std::task;\n-\n-pub fn main() {\n-    let (p,c) = comm::stream();\n-    do task::try || {\n-        let (p2,c2) = comm::stream();\n-        do task::spawn || {\n-            p2.recv();\n-            error!(\"sibling fails\");\n-            fail!();\n-        }\n-        let (p3,c3) = comm::stream();\n-        c.send(c3);\n-        c2.send(());\n-        error!(\"child blocks\");\n-        let (p, c) = comm::stream();\n-        let mut tuple = (p, p3);\n-        tuple.select();\n-        c.send(());\n-    };\n-    error!(\"parent tries\");\n-    assert!(!p.recv().try_send(()));\n-    error!(\"all done!\");\n-}"}]}