{"sha": "90df86f474e9214fe3337181db8e88b9b785e6fe", "node_id": "C_kwDOAAsO6NoAKDkwZGY4NmY0NzRlOTIxNGZlMzMzNzE4MWRiOGU4OGI5Yjc4NWU2ZmU", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-01-03T05:01:17Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-01-15T15:36:06Z"}, "message": "Remove bound_{explicit,}_item_bounds", "tree": {"sha": "8a0f07120c45d364cbe3b6d58ad22e8f6518342a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a0f07120c45d364cbe3b6d58ad22e8f6518342a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/90df86f474e9214fe3337181db8e88b9b785e6fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/90df86f474e9214fe3337181db8e88b9b785e6fe", "html_url": "https://github.com/rust-lang/rust/commit/90df86f474e9214fe3337181db8e88b9b785e6fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/90df86f474e9214fe3337181db8e88b9b785e6fe/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1533a26f77000b6e22195987ef45d0aae3c710a", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1533a26f77000b6e22195987ef45d0aae3c710a", "html_url": "https://github.com/rust-lang/rust/commit/e1533a26f77000b6e22195987ef45d0aae3c710a"}], "stats": {"total": 104, "additions": 40, "deletions": 64}, "files": [{"sha": "e512099b93b136b4478d56517246867fc94833ec", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 21, "deletions": 27, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/90df86f474e9214fe3337181db8e88b9b785e6fe/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90df86f474e9214fe3337181db8e88b9b785e6fe/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=90df86f474e9214fe3337181db8e88b9b785e6fe", "patch": "@@ -673,40 +673,34 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let tcx = self.infcx.tcx;\n \n         // Find out if the predicates show that the type is a Fn or FnMut\n-        let find_fn_kind_from_did = |predicates: ty::EarlyBinder<\n-            &[(ty::Predicate<'tcx>, Span)],\n-        >,\n-                                     substs| {\n-            predicates.0.iter().find_map(|(pred, _)| {\n-                    let pred = if let Some(substs) = substs {\n-                        predicates.rebind(*pred).subst(tcx, substs).kind().skip_binder()\n-                    } else {\n-                        pred.kind().skip_binder()\n-                    };\n-                    if let ty::PredicateKind::Clause(ty::Clause::Trait(pred)) = pred && pred.self_ty() == ty {\n-                    if Some(pred.def_id()) == tcx.lang_items().fn_trait() {\n-                        return Some(hir::Mutability::Not);\n-                    } else if Some(pred.def_id()) == tcx.lang_items().fn_mut_trait() {\n-                        return Some(hir::Mutability::Mut);\n-                    }\n+        let find_fn_kind_from_did = |(pred, _): (ty::Predicate<'tcx>, _)| {\n+            if let ty::PredicateKind::Clause(ty::Clause::Trait(pred)) = pred.kind().skip_binder()\n+                && pred.self_ty() == ty\n+            {\n+                if Some(pred.def_id()) == tcx.lang_items().fn_trait() {\n+                    return Some(hir::Mutability::Not);\n+                } else if Some(pred.def_id()) == tcx.lang_items().fn_mut_trait() {\n+                    return Some(hir::Mutability::Mut);\n                 }\n-                    None\n-                })\n+            }\n+            None\n         };\n \n         // If the type is opaque/param/closure, and it is Fn or FnMut, let's suggest (mutably)\n         // borrowing the type, since `&mut F: FnMut` iff `F: FnMut` and similarly for `Fn`.\n         // These types seem reasonably opaque enough that they could be substituted with their\n         // borrowed variants in a function body when we see a move error.\n-        let borrow_level = match ty.kind() {\n-            ty::Param(_) => find_fn_kind_from_did(\n-                tcx.bound_explicit_predicates_of(self.mir_def_id().to_def_id())\n-                    .map_bound(|p| p.predicates),\n-                None,\n-            ),\n-            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) => {\n-                find_fn_kind_from_did(tcx.bound_explicit_item_bounds(*def_id), Some(*substs))\n-            }\n+        let borrow_level = match *ty.kind() {\n+            ty::Param(_) => tcx\n+                .explicit_predicates_of(self.mir_def_id().to_def_id())\n+                .predicates\n+                .iter()\n+                .copied()\n+                .find_map(find_fn_kind_from_did),\n+            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) => tcx\n+                .bound_explicit_item_bounds(def_id)\n+                .subst_iter_copied(tcx, substs)\n+                .find_map(find_fn_kind_from_did),\n             ty::Closure(_, substs) => match substs.as_closure().kind() {\n                 ty::ClosureKind::Fn => Some(hir::Mutability::Not),\n                 ty::ClosureKind::FnMut => Some(hir::Mutability::Mut),"}, {"sha": "49dd1eb22f7fe16ebd9d97ba5b4aef83d3da612e", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/90df86f474e9214fe3337181db8e88b9b785e6fe/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90df86f474e9214fe3337181db8e88b9b785e6fe/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=90df86f474e9214fe3337181db8e88b9b785e6fe", "patch": "@@ -1309,7 +1309,7 @@ fn check_where_clauses<'tcx>(wfcx: &WfCheckingCtxt<'_, 'tcx>, span: Span, def_id\n     let infcx = wfcx.infcx;\n     let tcx = wfcx.tcx();\n \n-    let predicates = tcx.bound_predicates_of(def_id.to_def_id());\n+    let predicates = tcx.predicates_of(def_id.to_def_id());\n     let generics = tcx.generics_of(def_id);\n \n     let is_our_default = |def: &ty::GenericParamDef| match def.kind {\n@@ -1410,7 +1410,6 @@ fn check_where_clauses<'tcx>(wfcx: &WfCheckingCtxt<'_, 'tcx>, span: Span, def_id\n \n     // Now we build the substituted predicates.\n     let default_obligations = predicates\n-        .0\n         .predicates\n         .iter()\n         .flat_map(|&(pred, sp)| {\n@@ -1441,13 +1440,13 @@ fn check_where_clauses<'tcx>(wfcx: &WfCheckingCtxt<'_, 'tcx>, span: Span, def_id\n             }\n             let mut param_count = CountParams::default();\n             let has_region = pred.visit_with(&mut param_count).is_break();\n-            let substituted_pred = predicates.rebind(pred).subst(tcx, substs);\n+            let substituted_pred = ty::EarlyBinder(pred).subst(tcx, substs);\n             // Don't check non-defaulted params, dependent defaults (including lifetimes)\n             // or preds with multiple params.\n             if substituted_pred.has_non_region_param() || param_count.params.len() > 1 || has_region\n             {\n                 None\n-            } else if predicates.0.predicates.iter().any(|&(p, _)| p == substituted_pred) {\n+            } else if predicates.predicates.iter().any(|&(p, _)| p == substituted_pred) {\n                 // Avoid duplication of predicates that contain no parameters, for example.\n                 None\n             } else {\n@@ -1473,7 +1472,7 @@ fn check_where_clauses<'tcx>(wfcx: &WfCheckingCtxt<'_, 'tcx>, span: Span, def_id\n             traits::Obligation::new(tcx, cause, wfcx.param_env, pred)\n         });\n \n-    let predicates = predicates.0.instantiate_identity(tcx);\n+    let predicates = predicates.instantiate_identity(tcx);\n \n     let predicates = wfcx.normalize(span, None, predicates);\n "}, {"sha": "b18cbd404d47f8c03895ef5db759d18f4f722077", "filename": "compiler/rustc_infer/src/infer/error_reporting/note.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/90df86f474e9214fe3337181db8e88b9b785e6fe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90df86f474e9214fe3337181db8e88b9b785e6fe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=90df86f474e9214fe3337181db8e88b9b785e6fe", "patch": "@@ -330,9 +330,8 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n \n         let Ok(trait_predicates) = self\n             .tcx\n-            .bound_explicit_predicates_of(trait_item_def_id)\n-            .map_bound(|p| p.predicates)\n-            .subst_iter_copied(self.tcx, trait_item_substs)\n+            .explicit_predicates_of(trait_item_def_id)\n+            .instantiate_own(self.tcx, trait_item_substs)\n             .map(|(pred, _)| {\n                 if pred.is_suggestable(self.tcx, false) {\n                     Ok(pred.to_string())"}, {"sha": "37d3e12a667637e2726e1934c10810d996349e0f", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/90df86f474e9214fe3337181db8e88b9b785e6fe/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90df86f474e9214fe3337181db8e88b9b785e6fe/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=90df86f474e9214fe3337181db8e88b9b785e6fe", "patch": "@@ -666,20 +666,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         ty::EarlyBinder(self.item_bounds(def_id))\n     }\n \n-    pub fn bound_predicates_of(\n-        self,\n-        def_id: DefId,\n-    ) -> ty::EarlyBinder<ty::generics::GenericPredicates<'tcx>> {\n-        ty::EarlyBinder(self.predicates_of(def_id))\n-    }\n-\n-    pub fn bound_explicit_predicates_of(\n-        self,\n-        def_id: DefId,\n-    ) -> ty::EarlyBinder<ty::generics::GenericPredicates<'tcx>> {\n-        ty::EarlyBinder(self.explicit_predicates_of(def_id))\n-    }\n-\n     pub fn bound_impl_subject(self, def_id: DefId) -> ty::EarlyBinder<ty::ImplSubject<'tcx>> {\n         ty::EarlyBinder(self.impl_subject(def_id))\n     }"}, {"sha": "95c269d1b78538eace45ef2bdb44d9ae699983c4", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/90df86f474e9214fe3337181db8e88b9b785e6fe/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90df86f474e9214fe3337181db8e88b9b785e6fe/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=90df86f474e9214fe3337181db8e88b9b785e6fe", "patch": "@@ -2558,12 +2558,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // obligation will normalize to `<$0 as Iterator>::Item = $1` and\n         // `$1: Copy`, so we must ensure the obligations are emitted in\n         // that order.\n-        let predicates = tcx.bound_predicates_of(def_id);\n-        debug!(?predicates);\n-        assert_eq!(predicates.0.parent, None);\n-        let mut obligations = Vec::with_capacity(predicates.0.predicates.len());\n-        for (predicate, span) in predicates.0.predicates {\n-            let span = *span;\n+        let predicates = tcx.predicates_of(def_id);\n+        assert_eq!(predicates.parent, None);\n+        let predicates = predicates.instantiate_own(tcx, substs);\n+        let mut obligations = Vec::with_capacity(predicates.len());\n+        for (predicate, span) in predicates {\n             let cause = cause.clone().derived_cause(parent_trait_pred, |derived| {\n                 ImplDerivedObligation(Box::new(ImplDerivedObligationCause {\n                     derived,\n@@ -2576,7 +2575,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 param_env,\n                 cause.clone(),\n                 recursion_depth,\n-                predicates.rebind(*predicate).subst(tcx, substs),\n+                predicate,\n                 &mut obligations,\n             );\n             obligations.push(Obligation { cause, recursion_depth, param_env, predicate });"}, {"sha": "f146de3966ba107865068631c9328f88fe2bd885", "filename": "compiler/rustc_traits/src/chalk/db.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/90df86f474e9214fe3337181db8e88b9b785e6fe/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90df86f474e9214fe3337181db8e88b9b785e6fe/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs?ref=90df86f474e9214fe3337181db8e88b9b785e6fe", "patch": "@@ -7,7 +7,7 @@\n //! `crate::chalk::lowering` (to lower rustc types into Chalk types).\n \n use rustc_middle::traits::ChalkRustInterner as RustInterner;\n-use rustc_middle::ty::{self, AssocKind, EarlyBinder, Ty, TyCtxt, TypeFoldable, TypeSuperFoldable};\n+use rustc_middle::ty::{self, AssocKind, Ty, TyCtxt, TypeFoldable, TypeSuperFoldable};\n use rustc_middle::ty::{InternalSubsts, SubstsRef};\n use rustc_target::abi::{Integer, IntegerType};\n \n@@ -38,13 +38,12 @@ impl<'tcx> RustIrDatabase<'tcx> {\n         def_id: DefId,\n         bound_vars: SubstsRef<'tcx>,\n     ) -> Vec<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>> {\n-        let predicates = self.interner.tcx.predicates_defined_on(def_id).predicates;\n-        predicates\n-            .iter()\n-            .map(|(wc, _)| EarlyBinder(*wc).subst(self.interner.tcx, bound_vars))\n-            .filter_map(|wc| LowerInto::<\n-                    Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>>\n-                    >::lower_into(wc, self.interner)).collect()\n+        self.interner\n+            .tcx\n+            .predicates_defined_on(def_id)\n+            .instantiate_own(self.interner.tcx, bound_vars)\n+            .filter_map(|(wc, _)| LowerInto::lower_into(wc, self.interner))\n+            .collect()\n     }\n \n     fn bounds_for<T>(&self, def_id: DefId, bound_vars: SubstsRef<'tcx>) -> Vec<T>"}]}