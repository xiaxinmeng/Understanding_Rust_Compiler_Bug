{"sha": "be3808108e15d84881f07af85b3145bcdd626e48", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlMzgwODEwOGUxNWQ4NDg4MWYwN2FmODViMzE0NWJjZGQ2MjZlNDg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-02T17:20:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-02T17:20:13Z"}, "message": "Auto merge of #77369 - jonas-schievink:validate-storage-liveness, r=wesleywiser\n\n-Zvalidate-mir: Assert that storage is allocated on local use\n\nThis extends the MIR validator to check that locals are only used when their backing storage is currently allocated via `StorageLive`.\n\nThe result of this is that miscompilations such as https://github.com/rust-lang/rust/issues/77359 are caught and turned into ICEs.\n\nThe PR currently fails tests because miscompilations such as https://github.com/rust-lang/rust/issues/77359 are caught and turned into ICEs.\n\nI have confirmed that tests pass (even with `-Zvalidate-mir`) once `SimplifyArmIdentity` is turned into a no-op (except mir-opt tests, of course).", "tree": {"sha": "210b76957c422465c98f67c02a6b30c4f98aaab8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/210b76957c422465c98f67c02a6b30c4f98aaab8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be3808108e15d84881f07af85b3145bcdd626e48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be3808108e15d84881f07af85b3145bcdd626e48", "html_url": "https://github.com/rust-lang/rust/commit/be3808108e15d84881f07af85b3145bcdd626e48", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be3808108e15d84881f07af85b3145bcdd626e48/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a585aaefb662ae26f8675955f26fad9be4fea96b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a585aaefb662ae26f8675955f26fad9be4fea96b", "html_url": "https://github.com/rust-lang/rust/commit/a585aaefb662ae26f8675955f26fad9be4fea96b"}, {"sha": "c47011f66971010039aa4b83e16a9f9c017f69f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/c47011f66971010039aa4b83e16a9f9c017f69f3", "html_url": "https://github.com/rust-lang/rust/commit/c47011f66971010039aa4b83e16a9f9c017f69f3"}], "stats": {"total": 56, "additions": 42, "deletions": 14}, "files": [{"sha": "ba7554cf02bdee83f193d10ff5cf071b2aa32c55", "filename": "compiler/rustc_mir/src/transform/validate.rs", "status": "modified", "additions": 38, "deletions": 13, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/be3808108e15d84881f07af85b3145bcdd626e48/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be3808108e15d84881f07af85b3145bcdd626e48/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fvalidate.rs?ref=be3808108e15d84881f07af85b3145bcdd626e48", "patch": "@@ -1,18 +1,17 @@\n //! Validates the MIR to ensure that invariants are upheld.\n \n+use crate::dataflow::impls::MaybeStorageLive;\n+use crate::dataflow::{Analysis, ResultsCursor};\n+use crate::util::storage::AlwaysLiveLocals;\n+\n use super::{MirPass, MirSource};\n-use rustc_middle::mir::visit::Visitor;\n-use rustc_middle::{\n-    mir::{\n-        AggregateKind, BasicBlock, Body, BorrowKind, Location, MirPhase, Operand, Rvalue,\n-        Statement, StatementKind, Terminator, TerminatorKind,\n-    },\n-    ty::{\n-        self,\n-        relate::{Relate, RelateResult, TypeRelation},\n-        ParamEnv, Ty, TyCtxt,\n-    },\n+use rustc_middle::mir::visit::{PlaceContext, Visitor};\n+use rustc_middle::mir::{\n+    AggregateKind, BasicBlock, Body, BorrowKind, Local, Location, MirPhase, Operand, Rvalue,\n+    Statement, StatementKind, Terminator, TerminatorKind, VarDebugInfo,\n };\n+use rustc_middle::ty::relate::{Relate, RelateResult, TypeRelation};\n+use rustc_middle::ty::{self, ParamEnv, Ty, TyCtxt};\n \n #[derive(Copy, Clone, Debug)]\n enum EdgeKind {\n@@ -33,9 +32,18 @@ pub struct Validator {\n \n impl<'tcx> MirPass<'tcx> for Validator {\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n-        let param_env = tcx.param_env(source.def_id());\n+        let def_id = source.def_id();\n+        let param_env = tcx.param_env(def_id);\n         let mir_phase = self.mir_phase;\n-        TypeChecker { when: &self.when, source, body, tcx, param_env, mir_phase }.visit_body(body);\n+\n+        let always_live_locals = AlwaysLiveLocals::new(body);\n+        let storage_liveness = MaybeStorageLive::new(always_live_locals)\n+            .into_engine(tcx, body, def_id)\n+            .iterate_to_fixpoint()\n+            .into_results_cursor(body);\n+\n+        TypeChecker { when: &self.when, source, body, tcx, param_env, mir_phase, storage_liveness }\n+            .visit_body(body);\n     }\n }\n \n@@ -138,6 +146,7 @@ struct TypeChecker<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     param_env: ParamEnv<'tcx>,\n     mir_phase: MirPhase,\n+    storage_liveness: ResultsCursor<'a, 'tcx, MaybeStorageLive>,\n }\n \n impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n@@ -210,6 +219,22 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n+    fn visit_local(&mut self, local: &Local, context: PlaceContext, location: Location) {\n+        if context.is_use() {\n+            // Uses of locals must occur while the local's storage is allocated.\n+            self.storage_liveness.seek_after_primary_effect(location);\n+            let locals_with_storage = self.storage_liveness.get();\n+            if !locals_with_storage.contains(*local) {\n+                self.fail(location, format!(\"use of local {:?}, which has no storage here\", local));\n+            }\n+        }\n+    }\n+\n+    fn visit_var_debug_info(&mut self, _var_debug_info: &VarDebugInfo<'tcx>) {\n+        // Debuginfo can contain field projections, which count as a use of the base local. Skip\n+        // debuginfo so that we avoid the storage liveness assertion in that case.\n+    }\n+\n     fn visit_operand(&mut self, operand: &Operand<'tcx>, location: Location) {\n         // `Operand::Copy` is only supposed to be used with `Copy` types.\n         if let Operand::Copy(place) = operand {"}, {"sha": "fba67de4033d9f484bc222d5db1d2a26649d04cd", "filename": "src/test/mir-opt/simplify_try_if_let.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/be3808108e15d84881f07af85b3145bcdd626e48/src%2Ftest%2Fmir-opt%2Fsimplify_try_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be3808108e15d84881f07af85b3145bcdd626e48/src%2Ftest%2Fmir-opt%2Fsimplify_try_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify_try_if_let.rs?ref=be3808108e15d84881f07af85b3145bcdd626e48", "patch": "@@ -1,4 +1,7 @@\n // compile-flags: -Zmir-opt-level=1 -Zunsound-mir-opts\n+// ignore-test\n+// FIXME: the pass is unsound and causes ICEs in the MIR validator\n+\n // EMIT_MIR simplify_try_if_let.{impl#0}-append.SimplifyArmIdentity.diff\n \n use std::ptr::NonNull;\n@@ -19,7 +22,7 @@ impl LinkedList {\n \n     pub fn append(&mut self, other: &mut Self) {\n         match self.tail {\n-            None => { },\n+            None => {}\n             Some(mut tail) => {\n                 // `as_mut` is okay here because we have exclusive access to the entirety\n                 // of both lists."}]}