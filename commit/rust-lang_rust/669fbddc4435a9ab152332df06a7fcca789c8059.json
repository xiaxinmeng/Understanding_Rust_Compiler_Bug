{"sha": "669fbddc4435a9ab152332df06a7fcca789c8059", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2OWZiZGRjNDQzNWE5YWIxNTIzMzJkZjA2YTdmY2NhNzg5YzgwNTk=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-11-28T19:36:04Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-11-28T19:36:04Z"}, "message": "librustc: Add explicit self to IterBytes. r=nmatsakis", "tree": {"sha": "df3bf0ffa9a9a77d538d6050a183275e3cd3e5c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df3bf0ffa9a9a77d538d6050a183275e3cd3e5c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/669fbddc4435a9ab152332df06a7fcca789c8059", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/669fbddc4435a9ab152332df06a7fcca789c8059", "html_url": "https://github.com/rust-lang/rust/commit/669fbddc4435a9ab152332df06a7fcca789c8059", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/669fbddc4435a9ab152332df06a7fcca789c8059/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "430583c8b4efdccb19e87b2f312fc22118c6685c", "url": "https://api.github.com/repos/rust-lang/rust/commits/430583c8b4efdccb19e87b2f312fc22118c6685c", "html_url": "https://github.com/rust-lang/rust/commit/430583c8b4efdccb19e87b2f312fc22118c6685c"}], "stats": {"total": 917, "additions": 903, "deletions": 14}, "files": [{"sha": "8fad77ff812dee3597ff606f49df85646b7aeaa3", "filename": "src/libcore/to_bytes.rs", "status": "modified", "additions": 350, "deletions": 12, "changes": 362, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Flibcore%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Flibcore%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_bytes.rs?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -19,6 +19,7 @@ pub type Cb = fn(buf: &[const u8]) -> bool;\n  * modified when default methods and trait inheritence are\n  * completed.\n  */\n+#[cfg(stage0)]\n pub trait IterBytes {\n     /**\n      * Call the provided callback `f` one or more times with\n@@ -37,6 +38,13 @@ pub trait IterBytes {\n     pure fn iter_bytes(lsb0: bool, f: Cb);\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub trait IterBytes {\n+    pure fn iter_bytes(&self, lsb0: bool, f: Cb);\n+}\n+\n+#[cfg(stage0)]\n impl bool: IterBytes {\n     #[inline(always)]\n     pure fn iter_bytes(_lsb0: bool, f: Cb) {\n@@ -46,6 +54,18 @@ impl bool: IterBytes {\n     }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl bool: IterBytes {\n+    #[inline(always)]\n+    pure fn iter_bytes(&self, _lsb0: bool, f: Cb) {\n+        f([\n+            *self as u8\n+        ]);\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl u8: IterBytes {\n     #[inline(always)]\n     pure fn iter_bytes(_lsb0: bool, f: Cb) {\n@@ -55,6 +75,18 @@ impl u8: IterBytes {\n     }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl u8: IterBytes {\n+    #[inline(always)]\n+    pure fn iter_bytes(&self, _lsb0: bool, f: Cb) {\n+        f([\n+            *self\n+        ]);\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl u16: IterBytes {\n     #[inline(always)]\n     pure fn iter_bytes(lsb0: bool, f: Cb) {\n@@ -72,6 +104,26 @@ impl u16: IterBytes {\n     }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl u16: IterBytes {\n+    #[inline(always)]\n+    pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+        if lsb0 {\n+            f([\n+                *self as u8,\n+                (*self >> 8) as u8\n+            ]);\n+        } else {\n+            f([\n+                (*self >> 8) as u8,\n+                *self as u8\n+            ]);\n+        }\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl u32: IterBytes {\n     #[inline(always)]\n     pure fn iter_bytes(lsb0: bool, f: Cb) {\n@@ -93,6 +145,30 @@ impl u32: IterBytes {\n     }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl u32: IterBytes {\n+    #[inline(always)]\n+    pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+        if lsb0 {\n+            f([\n+                *self as u8,\n+                (*self >> 8) as u8,\n+                (*self >> 16) as u8,\n+                (*self >> 24) as u8,\n+            ]);\n+        } else {\n+            f([\n+                (*self >> 24) as u8,\n+                (*self >> 16) as u8,\n+                (*self >> 8) as u8,\n+                *self as u8\n+            ]);\n+        }\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl u64: IterBytes {\n     #[inline(always)]\n     pure fn iter_bytes(lsb0: bool, f: Cb) {\n@@ -122,64 +198,180 @@ impl u64: IterBytes {\n     }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl u64: IterBytes {\n+    #[inline(always)]\n+    pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+        if lsb0 {\n+            f([\n+                *self as u8,\n+                (*self >> 8) as u8,\n+                (*self >> 16) as u8,\n+                (*self >> 24) as u8,\n+                (*self >> 32) as u8,\n+                (*self >> 40) as u8,\n+                (*self >> 48) as u8,\n+                (*self >> 56) as u8\n+            ]);\n+        } else {\n+            f([\n+                (*self >> 56) as u8,\n+                (*self >> 48) as u8,\n+                (*self >> 40) as u8,\n+                (*self >> 32) as u8,\n+                (*self >> 24) as u8,\n+                (*self >> 16) as u8,\n+                (*self >> 8) as u8,\n+                *self as u8\n+            ]);\n+        }\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl i8: IterBytes {\n     #[inline(always)]\n     pure fn iter_bytes(lsb0: bool, f: Cb) {\n         (self as u8).iter_bytes(lsb0, f)\n     }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl i8: IterBytes {\n+    #[inline(always)]\n+    pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+        (*self as u8).iter_bytes(lsb0, f)\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl i16: IterBytes {\n     #[inline(always)]\n     pure fn iter_bytes(lsb0: bool, f: Cb) {\n         (self as u16).iter_bytes(lsb0, f)\n     }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl i16: IterBytes {\n+    #[inline(always)]\n+    pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+        (*self as u16).iter_bytes(lsb0, f)\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl i32: IterBytes {\n     #[inline(always)]\n     pure fn iter_bytes(lsb0: bool, f: Cb) {\n         (self as u32).iter_bytes(lsb0, f)\n     }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl i32: IterBytes {\n+    #[inline(always)]\n+    pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+        (*self as u32).iter_bytes(lsb0, f)\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl i64: IterBytes {\n     #[inline(always)]\n     pure fn iter_bytes(lsb0: bool, f: Cb) {\n         (self as u64).iter_bytes(lsb0, f)\n     }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl i64: IterBytes {\n+    #[inline(always)]\n+    pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+        (*self as u64).iter_bytes(lsb0, f)\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl char: IterBytes {\n     #[inline(always)]\n     pure fn iter_bytes(lsb0: bool, f: Cb) {\n         (self as u32).iter_bytes(lsb0, f)\n     }\n }\n \n-#[cfg(target_word_size = \"32\")]\n-impl uint: IterBytes {\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl char: IterBytes {\n     #[inline(always)]\n-    pure fn iter_bytes(lsb0: bool, f: Cb) {\n-        (self as u32).iter_bytes(lsb0, f)\n+    pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+        (*self as u32).iter_bytes(lsb0, f)\n+    }\n+}\n+\n+#[cfg(target_word_size = \"32\")]\n+pub mod x32 {\n+    #[cfg(stage0)]\n+    pub impl uint: IterBytes {\n+        #[inline(always)]\n+        pure fn iter_bytes(lsb0: bool, f: Cb) {\n+            (self as u32).iter_bytes(lsb0, f)\n+        }\n+    }\n+\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pub impl uint: IterBytes {\n+        #[inline(always)]\n+        pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+            (*self as u32).iter_bytes(lsb0, f)\n+        }\n     }\n }\n \n #[cfg(target_word_size = \"64\")]\n-impl uint: IterBytes {\n-    #[inline(always)]\n-    pure fn iter_bytes(lsb0: bool, f: Cb) {\n-        (self as u64).iter_bytes(lsb0, f)\n+pub mod x64 {\n+    #[cfg(stage0)]\n+    pub impl uint: IterBytes {\n+        #[inline(always)]\n+        pure fn iter_bytes(lsb0: bool, f: Cb) {\n+            (self as u64).iter_bytes(lsb0, f)\n+        }\n+    }\n+\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pub impl uint: IterBytes {\n+        #[inline(always)]\n+        pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+            (*self as u64).iter_bytes(lsb0, f)\n+        }\n     }\n }\n \n+#[cfg(stage0)]\n impl int: IterBytes {\n     #[inline(always)]\n     pure fn iter_bytes(lsb0: bool, f: Cb) {\n         (self as uint).iter_bytes(lsb0, f)\n     }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl int: IterBytes {\n+    #[inline(always)]\n+    pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+        (*self as uint).iter_bytes(lsb0, f)\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<A: IterBytes> &[A]: IterBytes {\n     #[inline(always)]\n     pure fn iter_bytes(lsb0: bool, f: Cb) {\n@@ -191,6 +383,20 @@ impl<A: IterBytes> &[A]: IterBytes {\n     }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl<A: IterBytes> &[A]: IterBytes {\n+    #[inline(always)]\n+    pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+        for (*self).each |elt| {\n+            do elt.iter_bytes(lsb0) |bytes| {\n+                f(bytes)\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<A: IterBytes, B: IterBytes> (A,B): IterBytes {\n   #[inline(always)]\n   pure fn iter_bytes(lsb0: bool, f: Cb) {\n@@ -200,6 +406,18 @@ impl<A: IterBytes, B: IterBytes> (A,B): IterBytes {\n   }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl<A: IterBytes, B: IterBytes> (A,B): IterBytes {\n+  #[inline(always)]\n+  pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+    let &(ref a, ref b) = self;\n+    a.iter_bytes(lsb0, f);\n+    b.iter_bytes(lsb0, f);\n+  }\n+}\n+\n+#[cfg(stage0)]\n impl<A: IterBytes, B: IterBytes, C: IterBytes> (A,B,C): IterBytes {\n   #[inline(always)]\n   pure fn iter_bytes(lsb0: bool, f: Cb) {\n@@ -210,26 +428,57 @@ impl<A: IterBytes, B: IterBytes, C: IterBytes> (A,B,C): IterBytes {\n   }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl<A: IterBytes, B: IterBytes, C: IterBytes> (A,B,C): IterBytes {\n+  #[inline(always)]\n+  pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+    let &(ref a, ref b, ref c) = self;\n+    a.iter_bytes(lsb0, f);\n+    b.iter_bytes(lsb0, f);\n+    c.iter_bytes(lsb0, f);\n+  }\n+}\n+\n // Move this to vec, probably.\n pure fn borrow<A>(a: &x/[A]) -> &x/[A] {\n     a\n }\n \n+#[cfg(stage0)]\n impl<A: IterBytes> ~[A]: IterBytes {\n     #[inline(always)]\n     pure fn iter_bytes(lsb0: bool, f: Cb) {\n         borrow(self).iter_bytes(lsb0, f)\n     }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl<A: IterBytes> ~[A]: IterBytes {\n+    #[inline(always)]\n+    pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+        borrow(*self).iter_bytes(lsb0, f)\n+    }\n+}\n \n+#[cfg(stage0)]\n impl<A: IterBytes> @[A]: IterBytes {\n     #[inline(always)]\n     pure fn iter_bytes(lsb0: bool, f: Cb) {\n         borrow(self).iter_bytes(lsb0, f)\n     }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl<A: IterBytes> @[A]: IterBytes {\n+    #[inline(always)]\n+    pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+        borrow(*self).iter_bytes(lsb0, f)\n+    }\n+}\n+\n pub pure fn iter_bytes_2<A: IterBytes, B: IterBytes>(a: &A, b: &B,\n                                             lsb0: bool, z: Cb) {\n     let mut flag = true;\n@@ -333,6 +582,7 @@ pub pure fn iter_bytes_7<A: IterBytes,\n     g.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n }\n \n+#[cfg(stage0)]\n impl &str: IterBytes {\n     #[inline(always)]\n     pure fn iter_bytes(_lsb0: bool, f: Cb) {\n@@ -342,6 +592,18 @@ impl &str: IterBytes {\n     }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl &str: IterBytes {\n+    #[inline(always)]\n+    pure fn iter_bytes(&self, _lsb0: bool, f: Cb) {\n+        do str::byte_slice(*self) |bytes| {\n+            f(bytes);\n+        }\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl ~str: IterBytes {\n     #[inline(always)]\n     pure fn iter_bytes(_lsb0: bool, f: Cb) {\n@@ -351,6 +613,18 @@ impl ~str: IterBytes {\n     }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl ~str: IterBytes {\n+    #[inline(always)]\n+    pure fn iter_bytes(&self, _lsb0: bool, f: Cb) {\n+        do str::byte_slice(*self) |bytes| {\n+            f(bytes);\n+        }\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl @str: IterBytes {\n     #[inline(always)]\n     pure fn iter_bytes(_lsb0: bool, f: Cb) {\n@@ -360,6 +634,18 @@ impl @str: IterBytes {\n     }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl @str: IterBytes {\n+    #[inline(always)]\n+    pure fn iter_bytes(&self, _lsb0: bool, f: Cb) {\n+        do str::byte_slice(*self) |bytes| {\n+            f(bytes);\n+        }\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<A: IterBytes> Option<A>: IterBytes {\n     #[inline(always)]\n     pure fn iter_bytes(lsb0: bool, f: Cb) {\n@@ -370,43 +656,95 @@ impl<A: IterBytes> Option<A>: IterBytes {\n     }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl<A: IterBytes> Option<A>: IterBytes {\n+    #[inline(always)]\n+    pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+        match *self {\n+          Some(ref a) => iter_bytes_2(&0u8, a, lsb0, f),\n+          None => 1u8.iter_bytes(lsb0, f)\n+        }\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<A: IterBytes> &A: IterBytes {\n     #[inline(always)]\n     pure fn iter_bytes(lsb0: bool, f: Cb) {\n         (*self).iter_bytes(lsb0, f);\n     }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl<A: IterBytes> &A: IterBytes {\n+    #[inline(always)]\n+    pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+        (**self).iter_bytes(lsb0, f);\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<A: IterBytes> @A: IterBytes {\n     #[inline(always)]\n     pure fn iter_bytes(lsb0: bool, f: Cb) {\n         (*self).iter_bytes(lsb0, f);\n     }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl<A: IterBytes> @A: IterBytes {\n+    #[inline(always)]\n+    pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+        (**self).iter_bytes(lsb0, f);\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<A: IterBytes> ~A: IterBytes {\n     #[inline(always)]\n     pure fn iter_bytes(lsb0: bool, f: Cb) {\n         (*self).iter_bytes(lsb0, f);\n     }\n }\n \n-// NB: raw-pointer IterBytes does _not_ dereference\n-// to the target; it just gives you the pointer-bytes.\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl<A: IterBytes> ~A: IterBytes {\n+    #[inline(always)]\n+    pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+        (**self).iter_bytes(lsb0, f);\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<A> *const A: IterBytes {\n     #[inline(always)]\n     pure fn iter_bytes(lsb0: bool, f: Cb) {\n         (self as uint).iter_bytes(lsb0, f);\n     }\n }\n \n+// NB: raw-pointer IterBytes does _not_ dereference\n+// to the target; it just gives you the pointer-bytes.\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl<A> *const A: IterBytes {\n+    #[inline(always)]\n+    pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+        (*self as uint).iter_bytes(lsb0, f);\n+    }\n+}\n+\n \n trait ToBytes {\n-    fn to_bytes(lsb0: bool) -> ~[u8];\n+    fn to_bytes(&self, lsb0: bool) -> ~[u8];\n }\n \n impl<A: IterBytes> A: ToBytes {\n-    fn to_bytes(lsb0: bool) -> ~[u8] {\n+    fn to_bytes(&self, lsb0: bool) -> ~[u8] {\n         do io::with_bytes_writer |wr| {\n             for self.iter_bytes(lsb0) |bytes| {\n                 wr.write(bytes)"}, {"sha": "7e6dcbf824779350ad46ba34148d4aea2832a97e", "filename": "src/librustc/middle/borrowck.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Flibrustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Flibrustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck.rs?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -483,11 +483,19 @@ impl root_map_key : cmp::Eq {\n     }\n }\n \n+#[cfg(stage0)]\n impl root_map_key : to_bytes::IterBytes {\n     pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.id, &self.derefs, lsb0, f);\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl root_map_key : to_bytes::IterBytes {\n+    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+        to_bytes::iter_bytes_2(&self.id, &self.derefs, lsb0, f);\n+    }\n+}\n \n fn root_map() -> root_map {\n     return HashMap();"}, {"sha": "3c30f07c748641af8f587ae9e77536896ab9005f", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -1226,6 +1226,7 @@ impl mono_id_ : cmp::Eq {\n     pure fn ne(&self, other: &mono_id_) -> bool { !(*self).eq(other) }\n }\n \n+#[cfg(stage0)]\n impl mono_param_id : to_bytes::IterBytes {\n     pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n         match self {\n@@ -1239,12 +1240,35 @@ impl mono_param_id : to_bytes::IterBytes {\n         }\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl mono_param_id : to_bytes::IterBytes {\n+    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+        match *self {\n+          mono_precise(t, mids) =>\n+          to_bytes::iter_bytes_3(&0u8, &ty::type_id(t), &mids, lsb0, f),\n+\n+          mono_any => 1u8.iter_bytes(lsb0, f),\n \n+          mono_repr(ref a, ref b, ref c, ref d) =>\n+          to_bytes::iter_bytes_5(&2u8, a, b, c, d, lsb0, f)\n+        }\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl mono_id_ : core::to_bytes::IterBytes {\n     pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.def, &self.params, lsb0, f);\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl mono_id_ : core::to_bytes::IterBytes {\n+    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+        to_bytes::iter_bytes_2(&self.def, &self.params, lsb0, f);\n+    }\n+}\n \n fn umax(cx: block, a: ValueRef, b: ValueRef) -> ValueRef {\n     let cond = build::ICmp(cx, lib::llvm::IntULT, a, b);"}, {"sha": "255598a3fb4f6a218542c1497ccae64940b517eb", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -155,11 +155,19 @@ impl DatumMode: cmp::Eq {\n     pure fn ne(&self, other: &DatumMode) -> bool { !(*self).eq(other) }\n }\n \n+#[cfg(stage0)]\n impl DatumMode: to_bytes::IterBytes {\n     pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n         (self as uint).iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl DatumMode: to_bytes::IterBytes {\n+    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+        (*self as uint).iter_bytes(lsb0, f)\n+    }\n+}\n \n /// See `Datum Sources` section at the head of this module.\n enum DatumSource {"}, {"sha": "3f46189b3dae60845e12fd62f11bbf354423c009", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 300, "deletions": 0, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -269,11 +269,19 @@ impl creader_cache_key : cmp::Eq {\n     }\n }\n \n+#[cfg(stage0)]\n impl creader_cache_key : to_bytes::IterBytes {\n     pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_3(&self.cnum, &self.pos, &self.len, lsb0, f);\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl creader_cache_key : to_bytes::IterBytes {\n+    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+        to_bytes::iter_bytes_3(&self.cnum, &self.pos, &self.len, lsb0, f);\n+    }\n+}\n \n type intern_key = {sty: sty, o_def_id: Option<ast::def_id>};\n \n@@ -294,11 +302,19 @@ impl intern_key : cmp::Eq {\n     pure fn ne(&self, other: &intern_key) -> bool { !(*self).eq(other) }\n }\n \n+#[cfg(stage0)]\n impl intern_key : to_bytes::IterBytes {\n     pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.sty, &self.o_def_id, lsb0, f);\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl intern_key : to_bytes::IterBytes {\n+    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+        to_bytes::iter_bytes_2(&self.sty, &self.o_def_id, lsb0, f);\n+    }\n+}\n \n enum ast_ty_to_ty_cache_entry {\n     atttce_unresolved,  /* not resolved yet */\n@@ -563,11 +579,19 @@ impl param_ty : cmp::Eq {\n     pure fn ne(&self, other: &param_ty) -> bool { !(*self).eq(other) }\n }\n \n+#[cfg(stage0)]\n impl param_ty : to_bytes::IterBytes {\n     pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.idx, &self.def_id, lsb0, f)\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl param_ty : to_bytes::IterBytes {\n+    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+        to_bytes::iter_bytes_2(&self.idx, &self.def_id, lsb0, f)\n+    }\n+}\n \n \n /// Representation of regions:\n@@ -749,6 +773,7 @@ enum InferTy {\n     FloatVar(FloatVid)\n }\n \n+#[cfg(stage0)]\n impl InferTy : to_bytes::IterBytes {\n     pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n         match self {\n@@ -758,6 +783,17 @@ impl InferTy : to_bytes::IterBytes {\n         }\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl InferTy : to_bytes::IterBytes {\n+    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+        match *self {\n+          TyVar(ref tv) => to_bytes::iter_bytes_2(&0u8, tv, lsb0, f),\n+          IntVar(ref iv) => to_bytes::iter_bytes_2(&1u8, iv, lsb0, f),\n+          FloatVar(ref fv) => to_bytes::iter_bytes_2(&2u8, fv, lsb0, f)\n+        }\n+    }\n+}\n \n #[auto_serialize]\n #[auto_deserialize]\n@@ -766,6 +802,7 @@ enum InferRegion {\n     ReSkolemized(uint, bound_region)\n }\n \n+#[cfg(stage0)]\n impl InferRegion : to_bytes::IterBytes {\n     pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n         match self {\n@@ -774,6 +811,16 @@ impl InferRegion : to_bytes::IterBytes {\n         }\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl InferRegion : to_bytes::IterBytes {\n+    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+        match *self {\n+            ReVar(ref rv) => to_bytes::iter_bytes_2(&0u8, rv, lsb0, f),\n+            ReSkolemized(ref v, _) => to_bytes::iter_bytes_2(&1u8, v, lsb0, f)\n+        }\n+    }\n+}\n \n impl InferRegion : cmp::Eq {\n     #[cfg(stage0)]\n@@ -812,6 +859,7 @@ impl InferRegion : cmp::Eq {\n     }\n }\n \n+#[cfg(stage0)]\n impl param_bound : to_bytes::IterBytes {\n     pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n         match self {\n@@ -824,6 +872,20 @@ impl param_bound : to_bytes::IterBytes {\n         }\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl param_bound : to_bytes::IterBytes {\n+    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+        match *self {\n+          bound_copy => 0u8.iter_bytes(lsb0, f),\n+          bound_owned => 1u8.iter_bytes(lsb0, f),\n+          bound_send => 2u8.iter_bytes(lsb0, f),\n+          bound_const => 3u8.iter_bytes(lsb0, f),\n+          bound_trait(ref t) =>\n+          to_bytes::iter_bytes_2(&4u8, t, lsb0, f)\n+        }\n+    }\n+}\n \n trait vid {\n     pure fn to_uint() -> uint;\n@@ -883,35 +945,75 @@ impl purity: purity_to_str {\n     }\n }\n \n+#[cfg(stage0)]\n impl RegionVid : to_bytes::IterBytes {\n     pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n         (*self).iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl RegionVid : to_bytes::IterBytes {\n+    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+        (**self).iter_bytes(lsb0, f)\n+    }\n+}\n \n+#[cfg(stage0)]\n impl TyVid : to_bytes::IterBytes {\n     pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n         (*self).iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl TyVid : to_bytes::IterBytes {\n+    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+        (**self).iter_bytes(lsb0, f)\n+    }\n+}\n \n+#[cfg(stage0)]\n impl IntVid : to_bytes::IterBytes {\n     pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n         (*self).iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl IntVid : to_bytes::IterBytes {\n+    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+        (**self).iter_bytes(lsb0, f)\n+    }\n+}\n \n+#[cfg(stage0)]\n impl FloatVid : to_bytes::IterBytes {\n     pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n         (*self).iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl FloatVid : to_bytes::IterBytes {\n+    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+        (**self).iter_bytes(lsb0, f)\n+    }\n+}\n \n+#[cfg(stage0)]\n impl FnVid : to_bytes::IterBytes {\n     pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n         (*self).iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl FnVid : to_bytes::IterBytes {\n+    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+        (**self).iter_bytes(lsb0, f)\n+    }\n+}\n \n fn param_bounds_to_kind(bounds: param_bounds) -> Kind {\n     let mut kind = kind_noncopyable();\n@@ -2722,6 +2824,7 @@ fn index_sty(cx: ctxt, sty: &sty) -> Option<mt> {\n     }\n }\n \n+#[cfg(stage0)]\n impl bound_region : to_bytes::IterBytes {\n     pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n         match self {\n@@ -2738,7 +2841,26 @@ impl bound_region : to_bytes::IterBytes {\n         }\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl bound_region : to_bytes::IterBytes {\n+    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+        match *self {\n+          ty::br_self => 0u8.iter_bytes(lsb0, f),\n+\n+          ty::br_anon(ref idx) =>\n+          to_bytes::iter_bytes_2(&1u8, idx, lsb0, f),\n+\n+          ty::br_named(ref ident) =>\n+          to_bytes::iter_bytes_2(&2u8, ident, lsb0, f),\n+\n+          ty::br_cap_avoid(ref id, ref br) =>\n+          to_bytes::iter_bytes_3(&3u8, id, br, lsb0, f)\n+        }\n+    }\n+}\n \n+#[cfg(stage0)]\n impl Region : to_bytes::IterBytes {\n     pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n         match self {\n@@ -2758,7 +2880,29 @@ impl Region : to_bytes::IterBytes {\n         }\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl Region : to_bytes::IterBytes {\n+    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+        match *self {\n+          re_bound(ref br) =>\n+          to_bytes::iter_bytes_2(&0u8, br, lsb0, f),\n \n+          re_free(ref id, ref br) =>\n+          to_bytes::iter_bytes_3(&1u8, id, br, lsb0, f),\n+\n+          re_scope(ref id) =>\n+          to_bytes::iter_bytes_2(&2u8, id, lsb0, f),\n+\n+          re_infer(ref id) =>\n+          to_bytes::iter_bytes_2(&3u8, id, lsb0, f),\n+\n+          re_static => 4u8.iter_bytes(lsb0, f)\n+        }\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl vstore : to_bytes::IterBytes {\n     pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n         match self {\n@@ -2773,36 +2917,90 @@ impl vstore : to_bytes::IterBytes {\n         }\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl vstore : to_bytes::IterBytes {\n+    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+        match *self {\n+          vstore_fixed(ref u) =>\n+          to_bytes::iter_bytes_2(&0u8, u, lsb0, f),\n \n+          vstore_uniq => 1u8.iter_bytes(lsb0, f),\n+          vstore_box => 2u8.iter_bytes(lsb0, f),\n+\n+          vstore_slice(ref r) =>\n+          to_bytes::iter_bytes_2(&3u8, r, lsb0, f),\n+        }\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl substs : to_bytes::IterBytes {\n     pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n           to_bytes::iter_bytes_3(&self.self_r,\n                                  &self.self_ty,\n                                  &self.tps, lsb0, f)\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl substs : to_bytes::IterBytes {\n+    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+          to_bytes::iter_bytes_3(&self.self_r,\n+                                 &self.self_ty,\n+                                 &self.tps, lsb0, f)\n+    }\n+}\n \n+#[cfg(stage0)]\n impl mt : to_bytes::IterBytes {\n     pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n           to_bytes::iter_bytes_2(&self.ty,\n                                  &self.mutbl, lsb0, f)\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl mt : to_bytes::IterBytes {\n+    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+          to_bytes::iter_bytes_2(&self.ty,\n+                                 &self.mutbl, lsb0, f)\n+    }\n+}\n \n+#[cfg(stage0)]\n impl field : to_bytes::IterBytes {\n     pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n           to_bytes::iter_bytes_2(&self.ident,\n                                  &self.mt, lsb0, f)\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl field : to_bytes::IterBytes {\n+    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+          to_bytes::iter_bytes_2(&self.ident,\n+                                 &self.mt, lsb0, f)\n+    }\n+}\n \n+#[cfg(stage0)]\n impl arg : to_bytes::IterBytes {\n     pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.mode,\n                                &self.ty, lsb0, f)\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl arg : to_bytes::IterBytes {\n+    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+        to_bytes::iter_bytes_2(&self.mode,\n+                               &self.ty, lsb0, f)\n+    }\n+}\n \n+#[cfg(stage0)]\n impl FnMeta : to_bytes::IterBytes {\n     pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_5(&self.purity,\n@@ -2813,15 +3011,38 @@ impl FnMeta : to_bytes::IterBytes {\n                                lsb0, f);\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl FnMeta : to_bytes::IterBytes {\n+    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+        to_bytes::iter_bytes_5(&self.purity,\n+                               &self.proto,\n+                               &self.region,\n+                               &self.bounds,\n+                               &self.ret_style,\n+                               lsb0, f);\n+    }\n+}\n \n+#[cfg(stage0)]\n impl FnSig : to_bytes::IterBytes {\n     pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.inputs,\n                                &self.output,\n                                lsb0, f);\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl FnSig : to_bytes::IterBytes {\n+    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+        to_bytes::iter_bytes_2(&self.inputs,\n+                               &self.output,\n+                               lsb0, f);\n+    }\n+}\n \n+#[cfg(stage0)]\n impl sty : to_bytes::IterBytes {\n     pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n         match self {\n@@ -2899,6 +3120,85 @@ impl sty : to_bytes::IterBytes {\n         }\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl sty : to_bytes::IterBytes {\n+    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+        match *self {\n+          ty_nil => 0u8.iter_bytes(lsb0, f),\n+          ty_bool => 1u8.iter_bytes(lsb0, f),\n+\n+          ty_int(ref t) =>\n+          to_bytes::iter_bytes_2(&2u8, t, lsb0, f),\n+\n+          ty_uint(ref t) =>\n+          to_bytes::iter_bytes_2(&3u8, t, lsb0, f),\n+\n+          ty_float(ref t) =>\n+          to_bytes::iter_bytes_2(&4u8, t, lsb0, f),\n+\n+          ty_estr(ref v) =>\n+          to_bytes::iter_bytes_2(&5u8, v, lsb0, f),\n+\n+          ty_enum(ref did, ref substs) =>\n+          to_bytes::iter_bytes_3(&6u8, did, substs, lsb0, f),\n+\n+          ty_box(ref mt) =>\n+          to_bytes::iter_bytes_2(&7u8, mt, lsb0, f),\n+\n+          ty_evec(ref mt, ref v) =>\n+          to_bytes::iter_bytes_3(&8u8, mt, v, lsb0, f),\n+\n+          ty_unboxed_vec(ref mt) =>\n+          to_bytes::iter_bytes_2(&9u8, mt, lsb0, f),\n+\n+          ty_tup(ref ts) =>\n+          to_bytes::iter_bytes_2(&10u8, ts, lsb0, f),\n+\n+          ty_rec(ref fs) =>\n+          to_bytes::iter_bytes_2(&11u8, fs, lsb0, f),\n+\n+          ty_fn(ref ft) =>\n+          to_bytes::iter_bytes_3(&12u8,\n+                                 &ft.meta,\n+                                 &ft.sig,\n+                                 lsb0, f),\n+\n+          ty_self => 13u8.iter_bytes(lsb0, f),\n+\n+          ty_infer(ref v) =>\n+          to_bytes::iter_bytes_2(&14u8, v, lsb0, f),\n+\n+          ty_param(ref p) =>\n+          to_bytes::iter_bytes_2(&15u8, p, lsb0, f),\n+\n+          ty_type => 16u8.iter_bytes(lsb0, f),\n+          ty_bot => 17u8.iter_bytes(lsb0, f),\n+\n+          ty_ptr(ref mt) =>\n+          to_bytes::iter_bytes_2(&18u8, mt, lsb0, f),\n+\n+          ty_uniq(ref mt) =>\n+          to_bytes::iter_bytes_2(&19u8, mt, lsb0, f),\n+\n+          ty_trait(ref did, ref substs, ref v) =>\n+          to_bytes::iter_bytes_4(&20u8, did, substs, v, lsb0, f),\n+\n+          ty_opaque_closure_ptr(ref ck) =>\n+          to_bytes::iter_bytes_2(&21u8, ck, lsb0, f),\n+\n+          ty_opaque_box => 22u8.iter_bytes(lsb0, f),\n+\n+          ty_class(ref did, ref substs) =>\n+          to_bytes::iter_bytes_3(&23u8, did, substs, lsb0, f),\n+\n+          ty_rptr(ref r, ref mt) =>\n+          to_bytes::iter_bytes_3(&24u8, r, mt, lsb0, f),\n+\n+          ty_err => 25u8.iter_bytes(lsb0, f)\n+        }\n+    }\n+}\n \n fn br_hashmap<V:Copy>() -> HashMap<bound_region, V> {\n     map::HashMap()"}, {"sha": "da0d12cd3b2121a206b2b36da3b416979d7a77ec", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -511,6 +511,7 @@ impl Constraint : cmp::Eq {\n     pure fn ne(&self, other: &Constraint) -> bool { !(*self).eq(other) }\n }\n \n+#[cfg(stage0)]\n impl Constraint : to_bytes::IterBytes {\n    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n         match self {\n@@ -525,6 +526,22 @@ impl Constraint : to_bytes::IterBytes {\n         }\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl Constraint : to_bytes::IterBytes {\n+   pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+        match *self {\n+          ConstrainVarSubVar(ref v0, ref v1) =>\n+          to_bytes::iter_bytes_3(&0u8, v0, v1, lsb0, f),\n+\n+          ConstrainRegSubVar(ref ra, ref va) =>\n+          to_bytes::iter_bytes_3(&1u8, ra, va, lsb0, f),\n+\n+          ConstrainVarSubReg(ref va, ref ra) =>\n+          to_bytes::iter_bytes_3(&2u8, va, ra, lsb0, f)\n+        }\n+    }\n+}\n \n struct TwoRegions {\n     a: Region,\n@@ -548,11 +565,19 @@ impl TwoRegions : cmp::Eq {\n     pure fn ne(&self, other: &TwoRegions) -> bool { !(*self).eq(other) }\n }\n \n+#[cfg(stage0)]\n impl TwoRegions : to_bytes::IterBytes {\n     pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.a, &self.b, lsb0, f)\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl TwoRegions : to_bytes::IterBytes {\n+    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+        to_bytes::iter_bytes_2(&self.a, &self.b, lsb0, f)\n+    }\n+}\n \n enum UndoLogEntry {\n     Snapshot,"}, {"sha": "946c49b40f742ee29149a86b9882365259ecc48e", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -782,12 +782,21 @@ impl Url : Eq {\n     }\n }\n \n+#[cfg(stage0)]\n impl Url: IterBytes {\n     pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n         unsafe { self.to_str() }.iter_bytes(lsb0, f)\n     }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl Url: IterBytes {\n+    pure fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n+        unsafe { self.to_str() }.iter_bytes(lsb0, f)\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     #[legacy_exports];"}, {"sha": "5bf90ef29c8173a09f516a71cedef566b069d749", "filename": "src/libstd/workcache.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Flibstd%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Flibstd%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fworkcache.rs?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -74,9 +74,22 @@ struct WorkKey {\n     name: ~str\n }\n \n+#[cfg(stage0)]\n impl WorkKey: to_bytes::IterBytes {\n     #[inline(always)]\n-    pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+    pure fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n+        let mut flag = true;\n+        self.kind.iter_bytes(lsb0, |bytes| {flag = f(bytes); flag});\n+        if !flag { return; }\n+        self.name.iter_bytes(lsb0, f);\n+    }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl WorkKey: to_bytes::IterBytes {\n+    #[inline(always)]\n+    pure fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         let mut flag = true;\n         self.kind.iter_bytes(lsb0, |bytes| {flag = f(bytes); flag});\n         if !flag { return; }"}, {"sha": "d09dd6f7bd17b7ca9ecdc1c615b0fbef0f424eb0", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -62,12 +62,21 @@ impl ident: cmp::Eq {\n     pure fn ne(&self, other: &ident) -> bool { !(*self).eq(other) }\n }\n \n+#[cfg(stage0)]\n impl ident: to_bytes::IterBytes {\n     pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n         self.repr.iter_bytes(lsb0, f)\n     }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl ident: to_bytes::IterBytes {\n+    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+        self.repr.iter_bytes(lsb0, f)\n+    }\n+}\n+\n // Functions may or may not have names.\n type fn_ident = Option<ident>;\n \n@@ -462,6 +471,7 @@ enum binding_mode {\n     bind_by_implicit_ref\n }\n \n+#[cfg(stage0)]\n impl binding_mode : to_bytes::IterBytes {\n     pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n         match self {\n@@ -478,6 +488,24 @@ impl binding_mode : to_bytes::IterBytes {\n     }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl binding_mode : to_bytes::IterBytes {\n+    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+        match *self {\n+          bind_by_value => 0u8.iter_bytes(lsb0, f),\n+\n+          bind_by_move => 1u8.iter_bytes(lsb0, f),\n+\n+          bind_by_ref(ref m) =>\n+          to_bytes::iter_bytes_2(&2u8, m, lsb0, f),\n+\n+          bind_by_implicit_ref =>\n+          3u8.iter_bytes(lsb0, f),\n+        }\n+    }\n+}\n+\n impl binding_mode : cmp::Eq {\n     #[cfg(stage0)]\n     pure fn eq(other: &binding_mode) -> bool {\n@@ -573,12 +601,21 @@ enum pat_ {\n #[auto_deserialize]\n enum mutability { m_mutbl, m_imm, m_const, }\n \n+#[cfg(stage0)]\n impl mutability : to_bytes::IterBytes {\n     pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n         (self as u8).iter_bytes(lsb0, f)\n     }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl mutability : to_bytes::IterBytes {\n+    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+        (*self as u8).iter_bytes(lsb0, f)\n+    }\n+}\n+\n impl mutability : cmp::Eq {\n     #[cfg(stage0)]\n     pure fn eq(other: &mutability) -> bool {\n@@ -622,12 +659,21 @@ impl Proto : cmp::Eq {\n     pure fn ne(&self, other: &Proto) -> bool { !(*self).eq(other) }\n }\n \n+#[cfg(stage0)]\n impl Proto : to_bytes::IterBytes {\n     pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n         (self as uint).iter_bytes(lsb0, f);\n     }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl Proto : to_bytes::IterBytes {\n+    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+        (*self as uint).iter_bytes(lsb0, f);\n+    }\n+}\n+\n #[auto_serialize]\n #[auto_deserialize]\n enum vstore {\n@@ -798,6 +844,7 @@ enum inferable<T> {\n     infer(node_id)\n }\n \n+#[cfg(stage0)]\n impl<T: to_bytes::IterBytes> inferable<T> : to_bytes::IterBytes {\n     pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n         match self {\n@@ -810,6 +857,20 @@ impl<T: to_bytes::IterBytes> inferable<T> : to_bytes::IterBytes {\n     }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl<T: to_bytes::IterBytes> inferable<T> : to_bytes::IterBytes {\n+    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+        match *self {\n+          expl(ref t) =>\n+          to_bytes::iter_bytes_2(&0u8, t, lsb0, f),\n+\n+          infer(ref n) =>\n+          to_bytes::iter_bytes_2(&1u8, n, lsb0, f),\n+        }\n+    }\n+}\n+\n impl<T:cmp::Eq> inferable<T> : cmp::Eq {\n     #[cfg(stage0)]\n     pure fn eq(other: &inferable<T>) -> bool {\n@@ -858,11 +919,19 @@ impl<T:cmp::Eq> inferable<T> : cmp::Eq {\n #[auto_deserialize]\n enum rmode { by_ref, by_val, by_move, by_copy }\n \n+#[cfg(stage0)]\n impl rmode : to_bytes::IterBytes {\n     pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n         (self as u8).iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl rmode : to_bytes::IterBytes {\n+    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+        (*self as u8).iter_bytes(lsb0, f)\n+    }\n+}\n \n \n impl rmode : cmp::Eq {\n@@ -1262,11 +1331,19 @@ enum trait_method {\n #[auto_deserialize]\n enum int_ty { ty_i, ty_char, ty_i8, ty_i16, ty_i32, ty_i64, }\n \n+#[cfg(stage0)]\n impl int_ty : to_bytes::IterBytes {\n     pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n         (self as u8).iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl int_ty : to_bytes::IterBytes {\n+    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+        (*self as u8).iter_bytes(lsb0, f)\n+    }\n+}\n \n impl int_ty : cmp::Eq {\n     #[cfg(stage0)]\n@@ -1315,11 +1392,19 @@ impl int_ty : cmp::Eq {\n #[auto_deserialize]\n enum uint_ty { ty_u, ty_u8, ty_u16, ty_u32, ty_u64, }\n \n+#[cfg(stage0)]\n impl uint_ty : to_bytes::IterBytes {\n     pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n         (self as u8).iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl uint_ty : to_bytes::IterBytes {\n+    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+        (*self as u8).iter_bytes(lsb0, f)\n+    }\n+}\n \n impl uint_ty : cmp::Eq {\n     #[cfg(stage0)]\n@@ -1364,11 +1449,20 @@ impl uint_ty : cmp::Eq {\n #[auto_deserialize]\n enum float_ty { ty_f, ty_f32, ty_f64, }\n \n+#[cfg(stage0)]\n impl float_ty : to_bytes::IterBytes {\n     pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n         (self as u8).iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl float_ty : to_bytes::IterBytes {\n+    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+        (*self as u8).iter_bytes(lsb0, f)\n+    }\n+}\n+\n impl float_ty : cmp::Eq {\n     #[cfg(stage0)]\n     pure fn eq(other: &float_ty) -> bool {\n@@ -1589,12 +1683,21 @@ impl Ty : cmp::Eq {\n     }\n }\n \n+#[cfg(stage0)]\n impl Ty : to_bytes::IterBytes {\n     pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.span.lo, &self.span.hi, lsb0, f);\n     }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl Ty : to_bytes::IterBytes {\n+    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+        to_bytes::iter_bytes_2(&self.span.lo, &self.span.hi, lsb0, f);\n+    }\n+}\n+\n \n #[auto_serialize]\n #[auto_deserialize]\n@@ -1616,12 +1719,21 @@ enum purity {\n     extern_fn, // declared with \"extern fn\"\n }\n \n+#[cfg(stage0)]\n impl purity : to_bytes::IterBytes {\n     pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n         (self as u8).iter_bytes(lsb0, f)\n     }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl purity : to_bytes::IterBytes {\n+    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+        (*self as u8).iter_bytes(lsb0, f)\n+    }\n+}\n+\n impl purity : cmp::Eq {\n     #[cfg(stage0)]\n     pure fn eq(other: &purity) -> bool {\n@@ -1647,11 +1759,19 @@ enum ret_style {\n     return_val, // everything else\n }\n \n+#[cfg(stage0)]\n impl ret_style : to_bytes::IterBytes {\n     pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n         (self as u8).iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl ret_style : to_bytes::IterBytes {\n+    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+        (*self as u8).iter_bytes(lsb0, f)\n+    }\n+}\n \n impl ret_style : cmp::Eq {\n     #[cfg(stage0)]\n@@ -2152,11 +2272,19 @@ enum item_ {\n #[auto_deserialize]\n enum class_mutability { class_mutable, class_immutable }\n \n+#[cfg(stage0)]\n impl class_mutability : to_bytes::IterBytes {\n     pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n         (self as u8).iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl class_mutability : to_bytes::IterBytes {\n+    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+        (*self as u8).iter_bytes(lsb0, f)\n+    }\n+}\n \n impl class_mutability : cmp::Eq {\n     #[cfg(stage0)]"}, {"sha": "12ebca87a80f8b2807b6347456d0f540c928892d", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -251,12 +251,21 @@ pure fn is_call_expr(e: @expr) -> bool {\n }\n \n // This makes def_id hashable\n+#[cfg(stage0)]\n impl def_id : core::to_bytes::IterBytes {\n     #[inline(always)]\n     pure fn iter_bytes(+lsb0: bool, f: core::to_bytes::Cb) {\n         core::to_bytes::iter_bytes_2(&self.crate, &self.node, lsb0, f);\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl def_id : core::to_bytes::IterBytes {\n+    #[inline(always)]\n+    pure fn iter_bytes(&self, +lsb0: bool, f: core::to_bytes::Cb) {\n+        core::to_bytes::iter_bytes_2(&self.crate, &self.node, lsb0, f);\n+    }\n+}\n \n fn block_from_expr(e: @expr) -> blk {\n     let blk_ = default_block(~[], option::Some::<@expr>(e), e.id);"}, {"sha": "2280986ab94abdca773eabfbb33552badb661794", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -90,12 +90,21 @@ impl BytePos: Num {\n     static pure fn from_int(+n: int) -> BytePos { BytePos(n as uint) }\n }\n \n+#[cfg(stage0)]\n impl BytePos: to_bytes::IterBytes {\n     pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n         (*self).iter_bytes(lsb0, f)\n     }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl BytePos: to_bytes::IterBytes {\n+    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+        (**self).iter_bytes(lsb0, f)\n+    }\n+}\n+\n impl CharPos: Pos {\n     static pure fn from_uint(n: uint) -> CharPos { CharPos(n) }\n     pure fn to_uint(&self) -> uint { **self }\n@@ -154,11 +163,19 @@ impl CharPos: Num {\n     static pure fn from_int(+n: int) -> CharPos { CharPos(n as uint) }\n }\n \n+#[cfg(stage0)]\n impl CharPos: to_bytes::IterBytes {\n     pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n         (*self).iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl CharPos: to_bytes::IterBytes {\n+    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+        (**self).iter_bytes(lsb0, f)\n+    }\n+}\n \n /**\n Spans represent a region of code, used for error reporting. Positions in spans"}, {"sha": "829b53ae22a948bfd8913f8a8e7aca6cbc899ee8", "filename": "src/libsyntax/ext/deriving.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Flibsyntax%2Fext%2Fderiving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Flibsyntax%2Fext%2Fderiving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving.rs?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -292,7 +292,7 @@ fn create_iter_bytes_method(cx: ext_ctxt,\n     let body_block = build::mk_block_(cx, span, move statements);\n \n     // Create the method.\n-    let self_ty = { node: sty_by_ref, span: span };\n+    let self_ty = { node: sty_region(m_imm), span: span };\n     let method_ident = cx.ident_of(~\"iter_bytes\");\n     return @{\n         ident: method_ident,\n@@ -806,6 +806,7 @@ fn expand_deriving_iter_bytes_enum_method(cx: ext_ctxt,\n     // Create the method body.\n     let self_ident = cx.ident_of(~\"self\");\n     let self_expr = build::mk_path(cx, span, ~[ self_ident ]);\n+    let self_expr = build::mk_unary(cx, span, deref, self_expr);\n     let arms = dvec::unwrap(move arms);\n     let self_match_expr = expr_match(self_expr, move arms);\n     let self_match_expr = build::mk_expr(cx, span, move self_match_expr);"}, {"sha": "a6a7736e3d03236b7ed684aa2a4a949d14b2b348", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -49,12 +49,21 @@ impl ObsoleteSyntax : cmp::Eq {\n     }\n }\n \n+#[cfg(stage0)]\n impl ObsoleteSyntax: to_bytes::IterBytes {\n     #[inline(always)]\n     pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n         (self as uint).iter_bytes(lsb0, f);\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl ObsoleteSyntax: to_bytes::IterBytes {\n+    #[inline(always)]\n+    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+        (*self as uint).iter_bytes(lsb0, f);\n+    }\n+}\n \n pub trait ObsoleteReporter {\n     fn obsolete(sp: span, kind: ObsoleteSyntax);"}]}