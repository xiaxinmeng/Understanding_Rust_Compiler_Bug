{"sha": "3828fa2852bf5e622267b24c4eda74e4fa6cb5f9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4MjhmYTI4NTJiZjVlNjIyMjY3YjI0YzRlZGE3NGU0ZmE2Y2I1Zjk=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-02-28T16:17:26Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-02-28T16:17:26Z"}, "message": "Rollup merge of #69384 - petrochenkov:nounnorm, r=Centril\n\nparser: `token` -> `normalized_token`, `nonnormalized_token` -> `token`\n\nSo, after https://github.com/rust-lang/rust/pull/69006, its follow-ups and an attempt to remove `Parser::prev_span` I came to the conclusion that the unnormalized token and its span is what you want in most cases, so it should be default.\n\nNormalization only makes difference in few cases where we are checking against `token::Ident` or `token::Lifetime` specifically.\nThis PR uses `normalized_token` for those cases.\n\nUsing normalization explicitly means that people writing code should remember about `NtIdent` and `NtLifetime` in general. (That is alleviated by the fact that `token.ident()` and `fn parse_ident_*` are already written.)\nRemembering about `NtIdent`, was, however, already the case, kind of, because the implicit normalization was performed only for the current/previous token, but not for things like `look_ahead`.\nAs a result, most of token classification methods in `token.rs` already take `NtIdent` into account (this PR fixes a few pre-existing minor mistakes though).\n\nThe next step is removing `normalized(_prev)_token` entirely and replacing it with `token.ident()` (mostly) and `token.normalize()` (occasionally).\nI want to make it a separate PR for that and run it though perf.\n`normalized_token` filled on every bump has both a potential to avoid repeated normalization, and to do unnecessary work in advance (it probably doesn't matter anyway, the normalization is very cheap).\n\nr? @Centril", "tree": {"sha": "942eb14f5b56c674c718599132032347e61c4d04", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/942eb14f5b56c674c718599132032347e61c4d04"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3828fa2852bf5e622267b24c4eda74e4fa6cb5f9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeWT0WCRBK7hj4Ov3rIwAAdHIIADgnkOUkZJOvPkdDXUETSQDr\nlIsPjc7qFVfofAnqHiswyRK7zVmJz2K0azLYAMrMjSL8W+vpVYyHypyUJc6Z9sUO\n+OWjp5joLMd293KQnJ1arlyYJaAslEr2i05iMtXz2QmftR6Ftr12rw24prZIMSgK\npA4Sb9+Du/eZ4dWl692Ck+zT3U981NtBQh/HmBc6G8m+IUd81b8BPg/peL2tNEM7\n+Ihc/ufkPg+lYmGMGVdMfiDAaHS0D6WxLVAWBhDQT0bMDsL28TCf07bDaglpP45W\nACq6NHAJm09lRmn7godpJinbLThWodC2/Ypj2haSYpfgkzQ20zEFSlNqxQzYwa4=\n=iqQ2\n-----END PGP SIGNATURE-----\n", "payload": "tree 942eb14f5b56c674c718599132032347e61c4d04\nparent 76fe44928281ae6f1ffe881712e02fb2358a4883\nparent b2605c118de31db9d61a9f7d0d158b9bf35f7a4a\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1582906646 +0100\ncommitter GitHub <noreply@github.com> 1582906646 +0100\n\nRollup merge of #69384 - petrochenkov:nounnorm, r=Centril\n\nparser: `token` -> `normalized_token`, `nonnormalized_token` -> `token`\n\nSo, after https://github.com/rust-lang/rust/pull/69006, its follow-ups and an attempt to remove `Parser::prev_span` I came to the conclusion that the unnormalized token and its span is what you want in most cases, so it should be default.\n\nNormalization only makes difference in few cases where we are checking against `token::Ident` or `token::Lifetime` specifically.\nThis PR uses `normalized_token` for those cases.\n\nUsing normalization explicitly means that people writing code should remember about `NtIdent` and `NtLifetime` in general. (That is alleviated by the fact that `token.ident()` and `fn parse_ident_*` are already written.)\nRemembering about `NtIdent`, was, however, already the case, kind of, because the implicit normalization was performed only for the current/previous token, but not for things like `look_ahead`.\nAs a result, most of token classification methods in `token.rs` already take `NtIdent` into account (this PR fixes a few pre-existing minor mistakes though).\n\nThe next step is removing `normalized(_prev)_token` entirely and replacing it with `token.ident()` (mostly) and `token.normalize()` (occasionally).\nI want to make it a separate PR for that and run it though perf.\n`normalized_token` filled on every bump has both a potential to avoid repeated normalization, and to do unnecessary work in advance (it probably doesn't matter anyway, the normalization is very cheap).\n\nr? @Centril\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3828fa2852bf5e622267b24c4eda74e4fa6cb5f9", "html_url": "https://github.com/rust-lang/rust/commit/3828fa2852bf5e622267b24c4eda74e4fa6cb5f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3828fa2852bf5e622267b24c4eda74e4fa6cb5f9/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76fe44928281ae6f1ffe881712e02fb2358a4883", "url": "https://api.github.com/repos/rust-lang/rust/commits/76fe44928281ae6f1ffe881712e02fb2358a4883", "html_url": "https://github.com/rust-lang/rust/commit/76fe44928281ae6f1ffe881712e02fb2358a4883"}, {"sha": "b2605c118de31db9d61a9f7d0d158b9bf35f7a4a", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2605c118de31db9d61a9f7d0d158b9bf35f7a4a", "html_url": "https://github.com/rust-lang/rust/commit/b2605c118de31db9d61a9f7d0d158b9bf35f7a4a"}], "stats": {"total": 257, "additions": 132, "deletions": 125}, "files": [{"sha": "072c987a5230e7474012a1162f1bd87ec4e0e967", "filename": "src/librustc_builtin_macros/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3828fa2852bf5e622267b24c4eda74e4fa6cb5f9/src%2Flibrustc_builtin_macros%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3828fa2852bf5e622267b24c4eda74e4fa6cb5f9/src%2Flibrustc_builtin_macros%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fformat.rs?ref=3828fa2852bf5e622267b24c4eda74e4fa6cb5f9", "patch": "@@ -158,7 +158,7 @@ fn parse_args<'a>(\n         } // accept trailing commas\n         if p.token.is_ident() && p.look_ahead(1, |t| *t == token::Eq) {\n             named = true;\n-            let name = if let token::Ident(name, _) = p.token.kind {\n+            let name = if let token::Ident(name, _) = p.normalized_token.kind {\n                 p.bump();\n                 name\n             } else {"}, {"sha": "2a53d600c5bcf729355af25f3066e4b702f37f3d", "filename": "src/librustc_expand/mbe/macro_parser.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3828fa2852bf5e622267b24c4eda74e4fa6cb5f9/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3828fa2852bf5e622267b24c4eda74e4fa6cb5f9/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs?ref=3828fa2852bf5e622267b24c4eda74e4fa6cb5f9", "patch": "@@ -753,6 +753,12 @@ pub(super) fn parse_tt(parser: &mut Cow<'_, Parser<'_>>, ms: &[TokenTree]) -> Na\n fn get_macro_name(token: &Token) -> Option<(Name, bool)> {\n     match token.kind {\n         token::Ident(name, is_raw) if name != kw::Underscore => Some((name, is_raw)),\n+        token::Interpolated(ref nt) => match **nt {\n+            token::NtIdent(ident, is_raw) if ident.name != kw::Underscore => {\n+                Some((ident.name, is_raw))\n+            }\n+            _ => None,\n+        },\n         _ => None,\n     }\n }\n@@ -883,9 +889,8 @@ fn parse_nt_inner<'a>(p: &mut Parser<'a>, sp: Span, name: Symbol) -> PResult<'a,\n         // this could be handled like a token, since it is one\n         sym::ident => {\n             if let Some((name, is_raw)) = get_macro_name(&p.token) {\n-                let span = p.token.span;\n                 p.bump();\n-                token::NtIdent(Ident::new(name, span), is_raw)\n+                token::NtIdent(Ident::new(name, p.normalized_prev_token.span), is_raw)\n             } else {\n                 let token_str = pprust::token_to_string(&p.token);\n                 let msg = &format!(\"expected ident, found {}\", &token_str);"}, {"sha": "00f5fb9705286e2a9641bac0d136a681b381c2d7", "filename": "src/librustc_parse/parser/diagnostics.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3828fa2852bf5e622267b24c4eda74e4fa6cb5f9/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3828fa2852bf5e622267b24c4eda74e4fa6cb5f9/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs?ref=3828fa2852bf5e622267b24c4eda74e4fa6cb5f9", "patch": "@@ -13,7 +13,7 @@ use syntax::ast::{\n };\n use syntax::ast::{AttrVec, ItemKind, Mutability, Pat, PatKind, PathSegment, QSelf, Ty, TyKind};\n use syntax::ptr::P;\n-use syntax::token::{self, token_can_begin_expr, TokenKind};\n+use syntax::token::{self, TokenKind};\n use syntax::util::parser::AssocOp;\n \n use log::{debug, trace};\n@@ -192,12 +192,12 @@ impl<'a> Parser<'a> {\n             TokenKind::CloseDelim(token::DelimToken::Brace),\n             TokenKind::CloseDelim(token::DelimToken::Paren),\n         ];\n-        if let token::Ident(name, false) = self.token.kind {\n-            if Ident::new(name, self.token.span).is_raw_guess()\n+        if let token::Ident(name, false) = self.normalized_token.kind {\n+            if Ident::new(name, self.normalized_token.span).is_raw_guess()\n                 && self.look_ahead(1, |t| valid_follow.contains(&t.kind))\n             {\n                 err.span_suggestion(\n-                    self.token.span,\n+                    self.normalized_token.span,\n                     \"you can escape reserved keywords to use them as identifiers\",\n                     format!(\"r#{}\", name),\n                     Applicability::MaybeIncorrect,\n@@ -900,8 +900,7 @@ impl<'a> Parser<'a> {\n         } else if !sm.is_multiline(self.prev_span.until(self.token.span)) {\n             // The current token is in the same line as the prior token, not recoverable.\n         } else if self.look_ahead(1, |t| {\n-            t == &token::CloseDelim(token::Brace)\n-                || token_can_begin_expr(t) && t.kind != token::Colon\n+            t == &token::CloseDelim(token::Brace) || t.can_begin_expr() && t.kind != token::Colon\n         }) && [token::Comma, token::Colon].contains(&self.token.kind)\n         {\n             // Likely typo: `,` \u2192 `;` or `:` \u2192 `;`. This is triggered if the current token is\n@@ -919,7 +918,7 @@ impl<'a> Parser<'a> {\n         } else if self.look_ahead(0, |t| {\n             t == &token::CloseDelim(token::Brace)\n                 || (\n-                    token_can_begin_expr(t) && t != &token::Semi && t != &token::Pound\n+                    t.can_begin_expr() && t != &token::Semi && t != &token::Pound\n                     // Avoid triggering with too many trailing `#` in raw string.\n                 )\n         }) {"}, {"sha": "2d5223f210246d5a53d7c931faf018fd4e5a0d2c", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/3828fa2852bf5e622267b24c4eda74e4fa6cb5f9/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3828fa2852bf5e622267b24c4eda74e4fa6cb5f9/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=3828fa2852bf5e622267b24c4eda74e4fa6cb5f9", "patch": "@@ -97,15 +97,14 @@ impl<'a> Parser<'a> {\n     fn parse_expr_catch_underscore(&mut self) -> PResult<'a, P<Expr>> {\n         match self.parse_expr() {\n             Ok(expr) => Ok(expr),\n-            Err(mut err) => match self.token.kind {\n+            Err(mut err) => match self.normalized_token.kind {\n                 token::Ident(name, false)\n                     if name == kw::Underscore && self.look_ahead(1, |t| t == &token::Comma) =>\n                 {\n                     // Special-case handling of `foo(_, _, _)`\n                     err.emit();\n-                    let sp = self.token.span;\n                     self.bump();\n-                    Ok(self.mk_expr(sp, ExprKind::Err, AttrVec::new()))\n+                    Ok(self.mk_expr(self.prev_token.span, ExprKind::Err, AttrVec::new()))\n                 }\n                 _ => Err(err),\n             },\n@@ -166,7 +165,7 @@ impl<'a> Parser<'a> {\n         while let Some(op) = self.check_assoc_op() {\n             // Adjust the span for interpolated LHS to point to the `$lhs` token\n             // and not to what it refers to.\n-            let lhs_span = match self.unnormalized_prev_token.kind {\n+            let lhs_span = match self.prev_token.kind {\n                 TokenKind::Interpolated(..) => self.prev_span,\n                 _ => lhs.span,\n             };\n@@ -333,7 +332,7 @@ impl<'a> Parser<'a> {\n     /// Also performs recovery for `and` / `or` which are mistaken for `&&` and `||` respectively.\n     fn check_assoc_op(&self) -> Option<Spanned<AssocOp>> {\n         Some(Spanned {\n-            node: match (AssocOp::from_token(&self.token), &self.token.kind) {\n+            node: match (AssocOp::from_token(&self.token), &self.normalized_token.kind) {\n                 (Some(op), _) => op,\n                 (None, token::Ident(sym::and, false)) => {\n                     self.error_bad_logical_op(\"and\", \"&&\", \"conjunction\");\n@@ -345,7 +344,7 @@ impl<'a> Parser<'a> {\n                 }\n                 _ => return None,\n             },\n-            span: self.token.span,\n+            span: self.normalized_token.span,\n         })\n     }\n \n@@ -437,7 +436,7 @@ impl<'a> Parser<'a> {\n         let attrs = self.parse_or_use_outer_attributes(attrs)?;\n         let lo = self.token.span;\n         // Note: when adding new unary operators, don't forget to adjust TokenKind::can_begin_expr()\n-        let (hi, ex) = match self.token.kind {\n+        let (hi, ex) = match self.normalized_token.kind {\n             token::Not => self.parse_unary_expr(lo, UnOp::Not), // `!expr`\n             token::Tilde => self.recover_tilde_expr(lo),        // `~expr`\n             token::BinOp(token::Minus) => self.parse_unary_expr(lo, UnOp::Neg), // `-expr`\n@@ -523,7 +522,7 @@ impl<'a> Parser<'a> {\n     ) -> PResult<'a, (Span, P<Expr>)> {\n         expr.map(|e| {\n             (\n-                match self.unnormalized_prev_token.kind {\n+                match self.prev_token.kind {\n                     TokenKind::Interpolated(..) => self.prev_span,\n                     _ => e.span,\n                 },\n@@ -704,7 +703,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn parse_dot_suffix_expr(&mut self, lo: Span, base: P<Expr>) -> PResult<'a, P<Expr>> {\n-        match self.token.kind {\n+        match self.normalized_token.kind {\n             token::Ident(..) => self.parse_dot_suffix(base, lo),\n             token::Literal(token::Lit { kind: token::Integer, symbol, suffix }) => {\n                 Ok(self.parse_tuple_field_access_expr(lo, base, symbol, suffix))\n@@ -773,8 +772,8 @@ impl<'a> Parser<'a> {\n         field: Symbol,\n         suffix: Option<Symbol>,\n     ) -> P<Expr> {\n-        let span = self.token.span;\n         self.bump();\n+        let span = self.prev_token.span;\n         let field = ExprKind::Field(base, Ident::new(field, span));\n         self.expect_no_suffix(span, \"a tuple index\", suffix);\n         self.mk_expr(lo.to(span), field, AttrVec::new())\n@@ -798,7 +797,7 @@ impl<'a> Parser<'a> {\n \n     /// Assuming we have just parsed `.`, continue parsing into an expression.\n     fn parse_dot_suffix(&mut self, self_arg: P<Expr>, lo: Span) -> PResult<'a, P<Expr>> {\n-        if self.token.span.rust_2018() && self.eat_keyword(kw::Await) {\n+        if self.normalized_token.span.rust_2018() && self.eat_keyword(kw::Await) {\n             return self.mk_await_expr(self_arg, lo);\n         }\n \n@@ -912,7 +911,7 @@ impl<'a> Parser<'a> {\n             //       |             ^ expected expression\n             self.bump();\n             Ok(self.mk_expr_err(self.token.span))\n-        } else if self.token.span.rust_2018() {\n+        } else if self.normalized_token.span.rust_2018() {\n             // `Span::rust_2018()` is somewhat expensive; don't get it repeatedly.\n             if self.check_keyword(kw::Async) {\n                 if self.is_async_block() {\n@@ -1342,7 +1341,7 @@ impl<'a> Parser<'a> {\n             if self.eat_keyword(kw::Static) { Movability::Static } else { Movability::Movable };\n \n         let asyncness =\n-            if self.token.span.rust_2018() { self.parse_asyncness() } else { Async::No };\n+            if self.normalized_token.span.rust_2018() { self.parse_asyncness() } else { Async::No };\n         if asyncness.is_async() {\n             // Feature-gate `async ||` closures.\n             self.sess.gated_spans.gate(sym::async_closure, self.prev_span);\n@@ -1556,9 +1555,8 @@ impl<'a> Parser<'a> {\n \n     fn eat_label(&mut self) -> Option<Label> {\n         self.token.lifetime().map(|ident| {\n-            let span = self.token.span;\n             self.bump();\n-            Label { ident: Ident::new(ident.name, span) }\n+            Label { ident }\n         })\n     }\n \n@@ -1700,7 +1698,7 @@ impl<'a> Parser<'a> {\n     fn is_try_block(&self) -> bool {\n         self.token.is_keyword(kw::Try) &&\n         self.look_ahead(1, |t| *t == token::OpenDelim(token::Brace)) &&\n-        self.token.span.rust_2018() &&\n+        self.normalized_token.span.rust_2018() &&\n         // Prevent `while try {} {}`, `if try {} {} else {}`, etc.\n         !self.restrictions.contains(Restrictions::NO_STRUCT_LITERAL)\n     }\n@@ -1850,13 +1848,12 @@ impl<'a> Parser<'a> {\n \n     /// Use in case of error after field-looking code: `S { foo: () with a }`.\n     fn find_struct_error_after_field_looking_code(&self) -> Option<Field> {\n-        if let token::Ident(name, _) = self.token.kind {\n+        if let token::Ident(name, _) = self.normalized_token.kind {\n             if !self.token.is_reserved_ident() && self.look_ahead(1, |t| *t == token::Colon) {\n-                let span = self.token.span;\n                 return Some(ast::Field {\n-                    ident: Ident::new(name, span),\n-                    span,\n-                    expr: self.mk_expr_err(span),\n+                    ident: Ident::new(name, self.normalized_token.span),\n+                    span: self.token.span,\n+                    expr: self.mk_expr_err(self.token.span),\n                     is_shorthand: false,\n                     attrs: AttrVec::new(),\n                     id: DUMMY_NODE_ID,"}, {"sha": "ef4246609da9a403cd86110282841c70aeb2e632", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3828fa2852bf5e622267b24c4eda74e4fa6cb5f9/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3828fa2852bf5e622267b24c4eda74e4fa6cb5f9/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=3828fa2852bf5e622267b24c4eda74e4fa6cb5f9", "patch": "@@ -741,11 +741,10 @@ impl<'a> Parser<'a> {\n     }\n \n     fn parse_ident_or_underscore(&mut self) -> PResult<'a, ast::Ident> {\n-        match self.token.kind {\n+        match self.normalized_token.kind {\n             token::Ident(name @ kw::Underscore, false) => {\n-                let span = self.token.span;\n                 self.bump();\n-                Ok(Ident::new(name, span))\n+                Ok(Ident::new(name, self.normalized_prev_token.span))\n             }\n             _ => self.parse_ident(),\n         }\n@@ -1537,7 +1536,7 @@ impl<'a> Parser<'a> {\n \n         let is_name_required = match self.token.kind {\n             token::DotDotDot => false,\n-            _ => req_name(&self.token),\n+            _ => req_name(&self.normalized_token),\n         };\n         let (pat, ty) = if is_name_required || self.is_named_param() {\n             debug!(\"parse_param_general parse_pat (is_name_required:{})\", is_name_required);\n@@ -1603,12 +1602,11 @@ impl<'a> Parser<'a> {\n     fn parse_self_param(&mut self) -> PResult<'a, Option<Param>> {\n         // Extract an identifier *after* having confirmed that the token is one.\n         let expect_self_ident = |this: &mut Self| {\n-            match this.token.kind {\n+            match this.normalized_token.kind {\n                 // Preserve hygienic context.\n                 token::Ident(name, _) => {\n-                    let span = this.token.span;\n                     this.bump();\n-                    Ident::new(name, span)\n+                    Ident::new(name, this.normalized_prev_token.span)\n                 }\n                 _ => unreachable!(),\n             }\n@@ -1645,7 +1643,7 @@ impl<'a> Parser<'a> {\n         // Only a limited set of initial token sequences is considered `self` parameters; anything\n         // else is parsed as a normal function parameter list, so some lookahead is required.\n         let eself_lo = self.token.span;\n-        let (eself, eself_ident, eself_hi) = match self.token.kind {\n+        let (eself, eself_ident, eself_hi) = match self.normalized_token.kind {\n             token::BinOp(token::And) => {\n                 let eself = if is_isolated_self(self, 1) {\n                     // `&self`"}, {"sha": "58a03ee2a74b49c8e952cbdee9f433fc27494ba3", "filename": "src/librustc_parse/parser/mod.rs", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/3828fa2852bf5e622267b24c4eda74e4fa6cb5f9/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3828fa2852bf5e622267b24c4eda74e4fa6cb5f9/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmod.rs?ref=3828fa2852bf5e622267b24c4eda74e4fa6cb5f9", "patch": "@@ -86,23 +86,22 @@ macro_rules! maybe_recover_from_interpolated_ty_qpath {\n #[derive(Clone)]\n pub struct Parser<'a> {\n     pub sess: &'a ParseSess,\n+    /// The current non-normalized token.\n+    pub token: Token,\n     /// The current normalized token.\n     /// \"Normalized\" means that some interpolated tokens\n     /// (`$i: ident` and `$l: lifetime` meta-variables) are replaced\n     /// with non-interpolated identifier and lifetime tokens they refer to.\n-    /// Use span from this token if you need an isolated span.\n-    pub token: Token,\n-    /// The current non-normalized token if it's different from `token`.\n-    /// Use span from this token if you need to concatenate it with some neighbouring spans.\n-    unnormalized_token: Token,\n+    /// Use this if you need to check for `token::Ident` or `token::Lifetime` specifically,\n+    /// this also includes edition checks for edition-specific keyword identifiers.\n+    pub normalized_token: Token,\n+    /// The previous non-normalized token.\n+    pub prev_token: Token,\n     /// The previous normalized token.\n-    /// Use span from this token if you need an isolated span.\n-    prev_token: Token,\n-    /// The previous non-normalized token if it's different from `prev_token`.\n-    /// Use span from this token if you need to concatenate it with some neighbouring spans.\n-    unnormalized_prev_token: Token,\n-    /// Equivalent to `unnormalized_prev_token.span`.\n-    /// FIXME: Remove in favor of `(unnormalized_)prev_token.span`.\n+    /// Use this if you need to check for `token::Ident` or `token::Lifetime` specifically,\n+    /// this also includes edition checks for edition-specific keyword identifiers.\n+    pub normalized_prev_token: Token,\n+    /// FIXME: Remove in favor of the equivalent `prev_token.span`.\n     pub prev_span: Span,\n     restrictions: Restrictions,\n     /// Used to determine the path to externally loaded source files.\n@@ -375,9 +374,9 @@ impl<'a> Parser<'a> {\n         let mut parser = Parser {\n             sess,\n             token: Token::dummy(),\n-            unnormalized_token: Token::dummy(),\n+            normalized_token: Token::dummy(),\n             prev_token: Token::dummy(),\n-            unnormalized_prev_token: Token::dummy(),\n+            normalized_prev_token: Token::dummy(),\n             prev_span: DUMMY_SP,\n             restrictions: Restrictions::empty(),\n             recurse_into_file_modules,\n@@ -482,7 +481,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn parse_ident_common(&mut self, recover: bool) -> PResult<'a, ast::Ident> {\n-        match self.token.kind {\n+        match self.normalized_token.kind {\n             token::Ident(name, _) => {\n                 if self.token.is_reserved_ident() {\n                     let mut err = self.expected_ident_found();\n@@ -492,9 +491,8 @@ impl<'a> Parser<'a> {\n                         return Err(err);\n                     }\n                 }\n-                let span = self.token.span;\n                 self.bump();\n-                Ok(Ident::new(name, span))\n+                Ok(Ident::new(name, self.normalized_prev_token.span))\n             }\n             _ => Err(match self.prev_token.kind {\n                 TokenKind::DocComment(..) => {\n@@ -824,16 +822,16 @@ impl<'a> Parser<'a> {\n     // tokens are replaced with usual identifier and lifetime tokens,\n     // so the former are never encountered during normal parsing.\n     crate fn set_token(&mut self, token: Token) {\n-        self.unnormalized_token = token;\n-        self.token = match &self.unnormalized_token.kind {\n+        self.token = token;\n+        self.normalized_token = match &self.token.kind {\n             token::Interpolated(nt) => match **nt {\n                 token::NtIdent(ident, is_raw) => {\n                     Token::new(token::Ident(ident.name, is_raw), ident.span)\n                 }\n                 token::NtLifetime(ident) => Token::new(token::Lifetime(ident.name), ident.span),\n-                _ => self.unnormalized_token.clone(),\n+                _ => self.token.clone(),\n             },\n-            _ => self.unnormalized_token.clone(),\n+            _ => self.token.clone(),\n         }\n     }\n \n@@ -847,19 +845,19 @@ impl<'a> Parser<'a> {\n \n         // Update the current and previous tokens.\n         self.prev_token = self.token.take();\n-        self.unnormalized_prev_token = self.unnormalized_token.take();\n+        self.normalized_prev_token = self.normalized_token.take();\n         self.set_token(next_token);\n \n         // Update fields derived from the previous token.\n-        self.prev_span = self.unnormalized_prev_token.span;\n+        self.prev_span = self.prev_token.span;\n \n         // Diagnostics.\n         self.expected_tokens.clear();\n     }\n \n     /// Advance the parser by one token.\n     pub fn bump(&mut self) {\n-        let next_token = self.next_tok(self.unnormalized_token.span);\n+        let next_token = self.next_tok(self.token.span);\n         self.bump_with(next_token);\n     }\n \n@@ -890,7 +888,7 @@ impl<'a> Parser<'a> {\n     /// Parses asyncness: `async` or nothing.\n     fn parse_asyncness(&mut self) -> Async {\n         if self.eat_keyword(kw::Async) {\n-            let span = self.prev_span;\n+            let span = self.normalized_prev_token.span;\n             Async::Yes { span, closure_id: DUMMY_NODE_ID, return_impl_trait_id: DUMMY_NODE_ID }\n         } else {\n             Async::No"}, {"sha": "f3a61ad4419785e18d41f3569230a3f95a63cf41", "filename": "src/librustc_parse/parser/path.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3828fa2852bf5e622267b24c4eda74e4fa6cb5f9/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3828fa2852bf5e622267b24c4eda74e4fa6cb5f9/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpath.rs?ref=3828fa2852bf5e622267b24c4eda74e4fa6cb5f9", "patch": "@@ -134,7 +134,7 @@ impl<'a> Parser<'a> {\n             path\n         });\n \n-        let lo = self.unnormalized_token.span;\n+        let lo = self.token.span;\n         let mut segments = Vec::new();\n         let mod_sep_ctxt = self.token.span.ctxt();\n         if self.eat(&token::ModSep) {\n@@ -238,11 +238,10 @@ impl<'a> Parser<'a> {\n     }\n \n     pub(super) fn parse_path_segment_ident(&mut self) -> PResult<'a, Ident> {\n-        match self.token.kind {\n+        match self.normalized_token.kind {\n             token::Ident(name, _) if name.is_path_segment_keyword() => {\n-                let span = self.token.span;\n                 self.bump();\n-                Ok(Ident::new(name, span))\n+                Ok(Ident::new(name, self.normalized_prev_token.span))\n             }\n             _ => self.parse_ident(),\n         }"}, {"sha": "7b2fdebcfb91051f58995418a0817c366fe6a302", "filename": "src/librustc_parse/parser/ty.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3828fa2852bf5e622267b24c4eda74e4fa6cb5f9/src%2Flibrustc_parse%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3828fa2852bf5e622267b24c4eda74e4fa6cb5f9/src%2Flibrustc_parse%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fty.rs?ref=3828fa2852bf5e622267b24c4eda74e4fa6cb5f9", "patch": "@@ -5,7 +5,7 @@ use crate::{maybe_recover_from_interpolated_ty_qpath, maybe_whole};\n use rustc_errors::{pluralize, struct_span_err, Applicability, PResult};\n use rustc_span::source_map::Span;\n use rustc_span::symbol::{kw, sym};\n-use syntax::ast::{self, BareFnTy, FnRetTy, GenericParam, Ident, Lifetime, MutTy, Ty, TyKind};\n+use syntax::ast::{self, BareFnTy, FnRetTy, GenericParam, Lifetime, MutTy, Ty, TyKind};\n use syntax::ast::{\n     GenericBound, GenericBounds, PolyTraitRef, TraitBoundModifier, TraitObjectSyntax,\n };\n@@ -323,7 +323,7 @@ impl<'a> Parser<'a> {\n     /// Is a `dyn B0 + ... + Bn` type allowed here?\n     fn is_explicit_dyn_type(&mut self) -> bool {\n         self.check_keyword(kw::Dyn)\n-            && (self.token.span.rust_2018()\n+            && (self.normalized_token.span.rust_2018()\n                 || self.look_ahead(1, |t| {\n                     t.can_begin_bound() && !can_continue_type_after_non_fn_ident(t)\n                 }))\n@@ -604,9 +604,8 @@ impl<'a> Parser<'a> {\n     /// Parses a single lifetime `'a` or panics.\n     pub fn expect_lifetime(&mut self) -> Lifetime {\n         if let Some(ident) = self.token.lifetime() {\n-            let span = self.token.span;\n             self.bump();\n-            Lifetime { ident: Ident::new(ident.name, span), id: ast::DUMMY_NODE_ID }\n+            Lifetime { ident, id: ast::DUMMY_NODE_ID }\n         } else {\n             self.span_bug(self.token.span, \"not a lifetime\")\n         }"}, {"sha": "a8a2c9b2fb3187dccfd197c43c506dd8354a9d50", "filename": "src/libsyntax/token.rs", "status": "modified", "additions": 25, "deletions": 29, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/3828fa2852bf5e622267b24c4eda74e4fa6cb5f9/src%2Flibsyntax%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3828fa2852bf5e622267b24c4eda74e4fa6cb5f9/src%2Flibsyntax%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftoken.rs?ref=3828fa2852bf5e622267b24c4eda74e4fa6cb5f9", "patch": "@@ -147,36 +147,30 @@ impl Lit {\n \n pub fn ident_can_begin_expr(name: ast::Name, span: Span, is_raw: bool) -> bool {\n     let ident_token = Token::new(Ident(name, is_raw), span);\n-    token_can_begin_expr(&ident_token)\n-}\n \n-pub fn token_can_begin_expr(ident_token: &Token) -> bool {\n     !ident_token.is_reserved_ident()\n         || ident_token.is_path_segment_keyword()\n-        || match ident_token.kind {\n-            TokenKind::Ident(ident, _) => [\n-                kw::Async,\n-                kw::Do,\n-                kw::Box,\n-                kw::Break,\n-                kw::Continue,\n-                kw::False,\n-                kw::For,\n-                kw::If,\n-                kw::Let,\n-                kw::Loop,\n-                kw::Match,\n-                kw::Move,\n-                kw::Return,\n-                kw::True,\n-                kw::Unsafe,\n-                kw::While,\n-                kw::Yield,\n-                kw::Static,\n-            ]\n-            .contains(&ident),\n-            _ => false,\n-        }\n+        || [\n+            kw::Async,\n+            kw::Do,\n+            kw::Box,\n+            kw::Break,\n+            kw::Continue,\n+            kw::False,\n+            kw::For,\n+            kw::If,\n+            kw::Let,\n+            kw::Loop,\n+            kw::Match,\n+            kw::Move,\n+            kw::Return,\n+            kw::True,\n+            kw::Unsafe,\n+            kw::While,\n+            kw::Yield,\n+            kw::Static,\n+        ]\n+        .contains(&name)\n }\n \n fn ident_can_begin_type(name: ast::Name, span: Span, is_raw: bool) -> bool {\n@@ -369,8 +363,8 @@ impl Token {\n             Lifetime(..)                      | // labeled loop\n             Pound                             => true, // expression attributes\n             Interpolated(ref nt) => match **nt {\n+                NtIdent(ident, is_raw) => ident_can_begin_expr(ident.name, ident.span, is_raw),\n                 NtLiteral(..) |\n-                NtIdent(..)   |\n                 NtExpr(..)    |\n                 NtBlock(..)   |\n                 NtPath(..)    |\n@@ -397,7 +391,8 @@ impl Token {\n             Lt | BinOp(Shl)             | // associated path\n             ModSep                      => true, // global path\n             Interpolated(ref nt) => match **nt {\n-                NtIdent(..) | NtTy(..) | NtPath(..) | NtLifetime(..) => true,\n+                NtIdent(ident, is_raw) => ident_can_begin_type(ident.name, ident.span, is_raw),\n+                NtTy(..) | NtPath(..) | NtLifetime(..) => true,\n                 _ => false,\n             },\n             _ => false,\n@@ -442,6 +437,7 @@ impl Token {\n             Literal(..) | BinOp(Minus) => true,\n             Ident(name, false) if name.is_bool_lit() => true,\n             Interpolated(ref nt) => match &**nt {\n+                NtIdent(ident, false) if ident.name.is_bool_lit() => true,\n                 NtExpr(e) | NtLiteral(e) => matches!(e.kind, ast::ExprKind::Lit(_)),\n                 _ => false,\n             },"}, {"sha": "ecf17efc4e0d1ba605215719ca729fb72e1d45cc", "filename": "src/libsyntax/util/literal.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3828fa2852bf5e622267b24c4eda74e4fa6cb5f9/src%2Flibsyntax%2Futil%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3828fa2852bf5e622267b24c4eda74e4fa6cb5f9/src%2Flibsyntax%2Futil%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fliteral.rs?ref=3828fa2852bf5e622267b24c4eda74e4fa6cb5f9", "patch": "@@ -197,10 +197,17 @@ impl Lit {\n             }\n             token::Literal(lit) => lit,\n             token::Interpolated(ref nt) => {\n-                if let token::NtExpr(expr) | token::NtLiteral(expr) = &**nt {\n-                    if let ast::ExprKind::Lit(lit) = &expr.kind {\n-                        return Ok(lit.clone());\n+                match &**nt {\n+                    token::NtIdent(ident, false) if ident.name.is_bool_lit() => {\n+                        let lit = token::Lit::new(token::Bool, ident.name, None);\n+                        return Lit::from_lit_token(lit, ident.span);\n                     }\n+                    token::NtExpr(expr) | token::NtLiteral(expr) => {\n+                        if let ast::ExprKind::Lit(lit) = &expr.kind {\n+                            return Ok(lit.clone());\n+                        }\n+                    }\n+                    _ => {}\n                 }\n                 return Err(LitError::NotLiteral);\n             }"}, {"sha": "58a90b2fca2ca9b4b94044c0c56d32b7d1e2db72", "filename": "src/test/ui/borrowck/move-error-snippets.stderr", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3828fa2852bf5e622267b24c4eda74e4fa6cb5f9/src%2Ftest%2Fui%2Fborrowck%2Fmove-error-snippets.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3828fa2852bf5e622267b24c4eda74e4fa6cb5f9/src%2Ftest%2Fui%2Fborrowck%2Fmove-error-snippets.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fmove-error-snippets.stderr?ref=3828fa2852bf5e622267b24c4eda74e4fa6cb5f9", "patch": "@@ -1,14 +1,16 @@\n error[E0507]: cannot move out of static item `D`\n-  --> $DIR/move-error-snippets.rs:16:18\n+  --> $DIR/move-error-snippets-ext.rs:5:17\n    |\n-LL | | #[macro_use]\n-   | |__________________^ move occurs because `D` has type `A`, which does not implement the `Copy` trait\n-...\n-LL |               aaa!(D);\n-   |  __________________^\n-...\n-LL |   sss!();\n-   |   ------- in this macro invocation\n+LL |         let a = $c;\n+   |                 ^^\n+   |                 |\n+   |                 move occurs because `D` has type `A`, which does not implement the `Copy` trait\n+   |                 help: consider borrowing here: `&$c`\n+   | \n+  ::: $DIR/move-error-snippets.rs:21:1\n+   |\n+LL | sss!();\n+   | ------- in this macro invocation\n    |\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n "}, {"sha": "376c1a9cd66277f94a5936af6559aac8bc0a305e", "filename": "src/test/ui/directory_ownership/macro-expanded-mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3828fa2852bf5e622267b24c4eda74e4fa6cb5f9/src%2Ftest%2Fui%2Fdirectory_ownership%2Fmacro-expanded-mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3828fa2852bf5e622267b24c4eda74e4fa6cb5f9/src%2Ftest%2Fui%2Fdirectory_ownership%2Fmacro-expanded-mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdirectory_ownership%2Fmacro-expanded-mod.rs?ref=3828fa2852bf5e622267b24c4eda74e4fa6cb5f9", "patch": "@@ -1,7 +1,7 @@\n // Test that macro-expanded non-inline modules behave correctly\n \n macro_rules! mod_decl {\n-    ($i:ident) => { mod $i; }\n+    ($i:ident) => { mod $i; } //~ ERROR Cannot declare a non-inline module inside a block\n }\n \n mod macro_expanded_mod_helper {\n@@ -10,5 +10,4 @@ mod macro_expanded_mod_helper {\n \n fn main() {\n     mod_decl!(foo);\n-    //~^ ERROR Cannot declare a non-inline module inside a block\n }"}, {"sha": "c7780c869d635c55c9800240145e52c2502b2cf9", "filename": "src/test/ui/directory_ownership/macro-expanded-mod.stderr", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3828fa2852bf5e622267b24c4eda74e4fa6cb5f9/src%2Ftest%2Fui%2Fdirectory_ownership%2Fmacro-expanded-mod.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3828fa2852bf5e622267b24c4eda74e4fa6cb5f9/src%2Ftest%2Fui%2Fdirectory_ownership%2Fmacro-expanded-mod.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdirectory_ownership%2Fmacro-expanded-mod.stderr?ref=3828fa2852bf5e622267b24c4eda74e4fa6cb5f9", "patch": "@@ -1,8 +1,13 @@\n error: Cannot declare a non-inline module inside a block unless it has a path attribute\n-  --> $DIR/macro-expanded-mod.rs:12:15\n+  --> $DIR/macro-expanded-mod.rs:4:25\n    |\n+LL |     ($i:ident) => { mod $i; }\n+   |                         ^^\n+...\n LL |     mod_decl!(foo);\n-   |               ^^^\n+   |     --------------- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "fd8846bb13c88de3193341b760e7645e9f12a021", "filename": "src/test/ui/hygiene/fields-definition.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3828fa2852bf5e622267b24c4eda74e4fa6cb5f9/src%2Ftest%2Fui%2Fhygiene%2Ffields-definition.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3828fa2852bf5e622267b24c4eda74e4fa6cb5f9/src%2Ftest%2Fui%2Fhygiene%2Ffields-definition.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Ffields-definition.stderr?ref=3828fa2852bf5e622267b24c4eda74e4fa6cb5f9", "patch": "@@ -1,10 +1,10 @@\n error[E0124]: field `a` is already declared\n-  --> $DIR/fields-definition.rs:14:17\n+  --> $DIR/fields-definition.rs:14:13\n    |\n LL |             a: u8,\n    |             ----- `a` first declared here\n LL |             $a: u8,\n-   |                 ^^ field already declared\n+   |             ^^^^^^ field already declared\n ...\n LL | legacy!(a);\n    | ----------- in this macro invocation"}, {"sha": "1964d739989ebafa57eb8094b8d341813a005eb1", "filename": "src/test/ui/issues/issue-39848.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3828fa2852bf5e622267b24c4eda74e4fa6cb5f9/src%2Ftest%2Fui%2Fissues%2Fissue-39848.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3828fa2852bf5e622267b24c4eda74e4fa6cb5f9/src%2Ftest%2Fui%2Fissues%2Fissue-39848.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-39848.rs?ref=3828fa2852bf5e622267b24c4eda74e4fa6cb5f9", "patch": "@@ -1,10 +1,9 @@\n macro_rules! get_opt {\n     ($tgt:expr, $field:ident) => {\n-        if $tgt.has_$field() {}\n+        if $tgt.has_$field() {} //~ ERROR expected `{`, found `foo`\n     }\n }\n \n fn main() {\n     get_opt!(bar, foo);\n-    //~^ ERROR expected `{`, found `foo`\n }"}, {"sha": "0250c6b1fdd0f16aa040e8b6972c5a752d46c03f", "filename": "src/test/ui/issues/issue-39848.stderr", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3828fa2852bf5e622267b24c4eda74e4fa6cb5f9/src%2Ftest%2Fui%2Fissues%2Fissue-39848.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3828fa2852bf5e622267b24c4eda74e4fa6cb5f9/src%2Ftest%2Fui%2Fissues%2Fissue-39848.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-39848.stderr?ref=3828fa2852bf5e622267b24c4eda74e4fa6cb5f9", "patch": "@@ -1,13 +1,17 @@\n error: expected `{`, found `foo`\n-  --> $DIR/issue-39848.rs:8:19\n+  --> $DIR/issue-39848.rs:3:21\n    |\n LL |         if $tgt.has_$field() {}\n-   |         --                -- help: try placing this code inside a block: `{ () }`\n-   |         |\n+   |         --          ^^^^^^--\n+   |         |           |\n+   |         |           expected `{`\n+   |         |           help: try placing this code inside a block: `{ $field() }`\n    |         this `if` expression has a condition, but no block\n ...\n LL |     get_opt!(bar, foo);\n-   |                   ^^^ expected `{`\n+   |     ------------------- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}]}