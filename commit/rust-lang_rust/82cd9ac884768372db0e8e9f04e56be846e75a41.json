{"sha": "82cd9ac884768372db0e8e9f04e56be846e75a41", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyY2Q5YWM4ODQ3NjgzNzJkYjBlOGU5ZjA0ZTU2YmU4NDZlNzVhNDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-12T21:46:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-12T21:46:59Z"}, "message": "auto merge of #13459 : alexcrichton/rust/stop-ignoring-ffi, r=sfackler\n\nUsing some strategically-placed `#` markers most of the examples are testable\r\n(and their contents are nontrivial).\r\n\r\nCloses #13445", "tree": {"sha": "38cef67c7716bca81bad86f666a35829b758cd5b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/38cef67c7716bca81bad86f666a35829b758cd5b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/82cd9ac884768372db0e8e9f04e56be846e75a41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/82cd9ac884768372db0e8e9f04e56be846e75a41", "html_url": "https://github.com/rust-lang/rust/commit/82cd9ac884768372db0e8e9f04e56be846e75a41", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/82cd9ac884768372db0e8e9f04e56be846e75a41/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ab0d8472777d2359492dfdee1d21230fbf144f70", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab0d8472777d2359492dfdee1d21230fbf144f70", "html_url": "https://github.com/rust-lang/rust/commit/ab0d8472777d2359492dfdee1d21230fbf144f70"}, {"sha": "f862e1256d846e235b749358ab6fe3a324c1b25c", "url": "https://api.github.com/repos/rust-lang/rust/commits/f862e1256d846e235b749358ab6fe3a324c1b25c", "html_url": "https://github.com/rust-lang/rust/commit/f862e1256d846e235b749358ab6fe3a324c1b25c"}], "stats": {"total": 81, "additions": 58, "deletions": 23}, "files": [{"sha": "f64d8205982f8d5a4ab3bba66bff1ed93ecefef7", "filename": "src/doc/guide-ffi.md", "status": "modified", "additions": 58, "deletions": 23, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/82cd9ac884768372db0e8e9f04e56be846e75a41/src%2Fdoc%2Fguide-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cd9ac884768372db0e8e9f04e56be846e75a41/src%2Fdoc%2Fguide-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-ffi.md?ref=82cd9ac884768372db0e8e9f04e56be846e75a41", "patch": "@@ -11,14 +11,16 @@ snappy includes a C interface (documented in\n The following is a minimal example of calling a foreign function which will\n compile if snappy is installed:\n \n-~~~~ {.ignore}\n+~~~~\n extern crate libc;\n use libc::size_t;\n \n #[link(name = \"snappy\")]\n+# #[cfg(ignore_this)]\n extern {\n     fn snappy_max_compressed_length(source_length: size_t) -> size_t;\n }\n+# unsafe fn snappy_max_compressed_length(a: size_t) -> size_t { a }\n \n fn main() {\n     let x = unsafe { snappy_max_compressed_length(100) };\n@@ -78,7 +80,11 @@ vectors as pointers to memory. Rust's vectors are guaranteed to be a contiguous\n length is number of elements currently contained, and the capacity is the total size in elements of\n the allocated memory. The length is less than or equal to the capacity.\n \n-~~~~ {.ignore}\n+~~~~\n+# extern crate libc;\n+# use libc::{c_int, size_t};\n+# unsafe fn snappy_validate_compressed_buffer(_: *u8, _: size_t) -> c_int { 0 }\n+# fn main() {}\n pub fn validate_compressed_buffer(src: &[u8]) -> bool {\n     unsafe {\n         snappy_validate_compressed_buffer(src.as_ptr(), src.len() as size_t) == 0\n@@ -98,14 +104,20 @@ required capacity to hold the compressed output. The vector can then be passed t\n `snappy_compress` function as an output parameter. An output parameter is also passed to retrieve\n the true length after compression for setting the length.\n \n-~~~~ {.ignore}\n-pub fn compress(src: &[u8]) -> ~[u8] {\n+~~~~\n+# extern crate libc;\n+# use libc::{size_t, c_int};\n+# unsafe fn snappy_compress(a: *u8, b: size_t, c: *mut u8,\n+#                           d: *mut size_t) -> c_int { 0 }\n+# unsafe fn snappy_max_compressed_length(a: size_t) -> size_t { a }\n+# fn main() {}\n+pub fn compress(src: &[u8]) -> Vec<u8> {\n     unsafe {\n         let srclen = src.len() as size_t;\n         let psrc = src.as_ptr();\n \n         let mut dstlen = snappy_max_compressed_length(srclen);\n-        let mut dst = slice::with_capacity(dstlen as uint);\n+        let mut dst = Vec::with_capacity(dstlen as uint);\n         let pdst = dst.as_mut_ptr();\n \n         snappy_compress(psrc, srclen, pdst, &mut dstlen);\n@@ -118,16 +130,26 @@ pub fn compress(src: &[u8]) -> ~[u8] {\n Decompression is similar, because snappy stores the uncompressed size as part of the compression\n format and `snappy_uncompressed_length` will retrieve the exact buffer size required.\n \n-~~~~ {.ignore}\n-pub fn uncompress(src: &[u8]) -> Option<~[u8]> {\n+~~~~\n+# extern crate libc;\n+# use libc::{size_t, c_int};\n+# unsafe fn snappy_uncompress(compressed: *u8,\n+#                             compressed_length: size_t,\n+#                             uncompressed: *mut u8,\n+#                             uncompressed_length: *mut size_t) -> c_int { 0 }\n+# unsafe fn snappy_uncompressed_length(compressed: *u8,\n+#                                      compressed_length: size_t,\n+#                                      result: *mut size_t) -> c_int { 0 }\n+# fn main() {}\n+pub fn uncompress(src: &[u8]) -> Option<Vec<u8>> {\n     unsafe {\n         let srclen = src.len() as size_t;\n         let psrc = src.as_ptr();\n \n         let mut dstlen: size_t = 0;\n         snappy_uncompressed_length(psrc, srclen, &mut dstlen);\n \n-        let mut dst = slice::with_capacity(dstlen as uint);\n+        let mut dst = Vec::with_capacity(dstlen as uint);\n         let pdst = dst.as_mut_ptr();\n \n         if snappy_uncompress(psrc, srclen, pdst, &mut dstlen) == 0 {\n@@ -187,16 +209,19 @@ A basic example is:\n \n Rust code:\n \n-~~~~ {.ignore}\n+~~~~\n extern fn callback(a:i32) {\n     println!(\"I'm called from C with value {0}\", a);\n }\n \n #[link(name = \"extlib\")]\n+# #[cfg(ignore)]\n extern {\n-   fn register_callback(cb: extern \"C\" fn(i32)) -> i32;\n+   fn register_callback(cb: extern fn(i32)) -> i32;\n    fn trigger_callback();\n }\n+# unsafe fn register_callback(cb: extern fn(i32)) -> i32 { 0 }\n+# unsafe fn trigger_callback() { }\n \n fn main() {\n     unsafe {\n@@ -240,33 +265,39 @@ referenced Rust object.\n \n Rust code:\n \n-~~~~ {.ignore}\n+~~~~\n \n struct RustObject {\n     a: i32,\n     // other members\n }\n \n-extern fn callback(target: *RustObject, a:i32) {\n+extern fn callback(target: *mut RustObject, a:i32) {\n     println!(\"I'm called from C with value {0}\", a);\n-    (*target).a = a; // Update the value in RustObject with the value received from the callback\n+    unsafe {\n+        // Update the value in RustObject with the value received from the callback\n+        (*target).a = a;\n+    }\n }\n \n #[link(name = \"extlib\")]\n+# #[cfg(ignore)]\n extern {\n-   fn register_callback(target: *RustObject, cb: extern \"C\" fn(*RustObject, i32)) -> i32;\n+   fn register_callback(target: *mut RustObject,\n+                        cb: extern fn(*mut RustObject, i32)) -> i32;\n    fn trigger_callback();\n }\n+# unsafe fn register_callback(a: *mut RustObject,\n+#                             b: extern fn(*mut RustObject, i32)) -> i32 { 0 }\n+# unsafe fn trigger_callback() {}\n \n fn main() {\n     // Create the object that will be referenced in the callback\n-    let rust_object = ~RustObject{a: 5, ...};\n+    let mut rust_object = ~RustObject{ a: 5 };\n \n     unsafe {\n-        // Gets a raw pointer to the object\n-        let target_addr:*RustObject = ptr::to_unsafe_ptr(rust_object);\n-        register_callback(target_addr, callback);\n-        trigger_callback(); // Triggers the callback\n+        register_callback(&mut *rust_object, callback);\n+        trigger_callback();\n     }\n }\n ~~~~\n@@ -403,13 +434,15 @@ Foreign APIs often export a global variable which could do something like track\n global state. In order to access these variables, you declare them in `extern`\n blocks with the `static` keyword:\n \n-~~~{.ignore}\n+~~~\n extern crate libc;\n \n #[link(name = \"readline\")]\n+# #[cfg(ignore)]\n extern {\n     static rl_readline_version: libc::c_int;\n }\n+# static rl_readline_version: libc::c_int = 0;\n \n fn main() {\n     println!(\"You have readline version {} installed.\",\n@@ -421,21 +454,23 @@ Alternatively, you may need to alter global state provided by a foreign\n interface. To do this, statics can be declared with `mut` so rust can mutate\n them.\n \n-~~~{.ignore}\n+~~~\n extern crate libc;\n use std::ptr;\n \n #[link(name = \"readline\")]\n+# #[cfg(ignore)]\n extern {\n     static mut rl_prompt: *libc::c_char;\n }\n+# static mut rl_prompt: *libc::c_char = 0 as *libc::c_char;\n \n fn main() {\n-    do \"[my-awesome-shell] $\".as_c_str |buf| {\n+    \"[my-awesome-shell] $\".with_c_str(|buf| {\n         unsafe { rl_prompt = buf; }\n         // get a line, process it\n         unsafe { rl_prompt = ptr::null(); }\n-    }\n+    });\n }\n ~~~\n "}]}