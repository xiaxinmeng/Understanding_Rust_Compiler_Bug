{"sha": "fa7660440b2581c4c57d896d50e76da1515de6df", "node_id": "C_kwDOAAsO6NoAKGZhNzY2MDQ0MGIyNTgxYzRjNTdkODk2ZDUwZTc2ZGExNTE1ZGU2ZGY", "commit": {"author": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2022-09-09T07:11:41Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-09-09T07:11:41Z"}, "message": "Merge pull request #1277 from bjorn3/simd_improvements\n\nImplement a couple of portable simd intrinsics", "tree": {"sha": "1a700e58468b3ec3846c36e7e5293d5c8487758f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1a700e58468b3ec3846c36e7e5293d5c8487758f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa7660440b2581c4c57d896d50e76da1515de6df", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjGuctCRBK7hj4Ov3rIwAAAikIAKLgVGKgikP/38AM9PJYvHoP\nlmLCpI1cDv5xidUCxDS92h7YruJi9HphX1EgfhMZ78ewOAbc4MGlsiFUYjrWDvUu\n+EMeYnKvaQS9uEgMmRGT5ef16S/43u9x+s93W5sJEjgPd+jGHQd0A61e0MPfsgsy\nfFwTeb4uHVhclpLnY4Ki7njL50j1/oJLeI4FfUuRkZBbV5TTzWQwj2+1upiULomT\nzuC2K1+k2ueOr3ujsYhCCHjDwhPhUjzkFWhsfoer+BBEXiCX5w+cA+M6/APbgdl1\np2FeopA9iVbpklDLKc+ajdBReSPaIvev1ybjzxW3ybqQJkl/dpMEzdxff0tKHgU=\n=JU0m\n-----END PGP SIGNATURE-----\n", "payload": "tree 1a700e58468b3ec3846c36e7e5293d5c8487758f\nparent c4c393c78ede150fbdf693e23689d472fc54bfa6\nparent 13fcf476001ff511103d9bec44e5be4e24eb0c96\nauthor bjorn3 <17426603+bjorn3@users.noreply.github.com> 1662707501 +0200\ncommitter GitHub <noreply@github.com> 1662707501 +0200\n\nMerge pull request #1277 from bjorn3/simd_improvements\n\nImplement a couple of portable simd intrinsics"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa7660440b2581c4c57d896d50e76da1515de6df", "html_url": "https://github.com/rust-lang/rust/commit/fa7660440b2581c4c57d896d50e76da1515de6df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa7660440b2581c4c57d896d50e76da1515de6df/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c4c393c78ede150fbdf693e23689d472fc54bfa6", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4c393c78ede150fbdf693e23689d472fc54bfa6", "html_url": "https://github.com/rust-lang/rust/commit/c4c393c78ede150fbdf693e23689d472fc54bfa6"}, {"sha": "13fcf476001ff511103d9bec44e5be4e24eb0c96", "url": "https://api.github.com/repos/rust-lang/rust/commits/13fcf476001ff511103d9bec44e5be4e24eb0c96", "html_url": "https://github.com/rust-lang/rust/commit/13fcf476001ff511103d9bec44e5be4e24eb0c96"}], "stats": {"total": 408, "additions": 190, "deletions": 218}, "files": [{"sha": "89e2b61c1fc8553be9c7668525c66e97d5fdcd52", "filename": "patches/0001-portable-simd-Disable-unsupported-tests.patch", "status": "modified", "additions": 4, "deletions": 183, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/fa7660440b2581c4c57d896d50e76da1515de6df/patches%2F0001-portable-simd-Disable-unsupported-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/fa7660440b2581c4c57d896d50e76da1515de6df/patches%2F0001-portable-simd-Disable-unsupported-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/patches%2F0001-portable-simd-Disable-unsupported-tests.patch?ref=fa7660440b2581c4c57d896d50e76da1515de6df", "patch": "@@ -1,175 +1,16 @@\n-From 82f597cf81b169b0e72a576ac8751f598c059c48 Mon Sep 17 00:00:00 2001\n+From b742f03694b920cc14400727d54424e8e1b60928 Mon Sep 17 00:00:00 2001\n From: bjorn3 <bjorn3@users.noreply.github.com>\n Date: Thu, 18 Nov 2021 19:28:40 +0100\n Subject: [PATCH] Disable unsupported tests\n \n ---\n  crates/core_simd/src/elements/int.rs     | 8 ++++++++\n  crates/core_simd/src/elements/uint.rs    | 4 ++++\n- crates/core_simd/src/masks/full_masks.rs | 9 +++++++++\n+ crates/core_simd/src/masks/full_masks.rs | 6 ++++++\n  crates/core_simd/src/vector.rs           | 2 ++\n- crates/core_simd/tests/masks.rs          | 2 ++\n- 5 files changed, 25 insertions(+)\n+ crates/core_simd/tests/masks.rs          | 3 ---\n+ 5 files changed, 20 insertions(+), 3 deletions(-)\n \n-diff --git a/crates/core_simd/src/elements/int.rs b/crates/core_simd/src/elements/int.rs\n-index 9b8c37e..ea95f08 100644\n---- a/crates/core_simd/src/elements/int.rs\n-+++ b/crates/core_simd/src/elements/int.rs\n-@@ -11,6 +11,7 @@ pub trait SimdInt: Copy + Sealed {\n-     /// Scalar type contained by this SIMD vector type.\n-     type Scalar;\n- \n-+    /*\n-     /// Lanewise saturating add.\n-     ///\n-     /// # Examples\n-@@ -45,6 +46,7 @@ pub trait SimdInt: Copy + Sealed {\n-     /// assert_eq!(unsat, Simd::from_array([1, MAX, MIN, 0]));\n-     /// assert_eq!(sat, Simd::from_array([MIN, MIN, MIN, 0]));\n-     fn saturating_sub(self, second: Self) -> Self;\n-+    */\n- \n-     /// Lanewise absolute value, implemented in Rust.\n-     /// Every lane becomes its absolute value.\n-@@ -61,6 +63,7 @@ pub trait SimdInt: Copy + Sealed {\n-     /// ```\n-     fn abs(self) -> Self;\n- \n-+    /*\n-     /// Lanewise saturating absolute value, implemented in Rust.\n-     /// As abs(), except the MIN value becomes MAX instead of itself.\n-     ///\n-@@ -96,6 +99,7 @@ pub trait SimdInt: Copy + Sealed {\n-     /// assert_eq!(sat, Simd::from_array([MAX, 2, -3, MIN + 1]));\n-     /// ```\n-     fn saturating_neg(self) -> Self;\n-+    */\n- \n-     /// Returns true for each positive lane and false if it is zero or negative.\n-     fn is_positive(self) -> Self::Mask;\n-@@ -199,6 +203,7 @@ macro_rules! impl_trait {\n-             type Mask = Mask<<$ty as SimdElement>::Mask, LANES>;\n-             type Scalar = $ty;\n- \n-+            /*\n-             #[inline]\n-             fn saturating_add(self, second: Self) -> Self {\n-                 // Safety: `self` is a vector\n-@@ -210,6 +215,7 @@ macro_rules! impl_trait {\n-                 // Safety: `self` is a vector\n-                 unsafe { intrinsics::simd_saturating_sub(self, second) }\n-             }\n-+            */\n- \n-             #[inline]\n-             fn abs(self) -> Self {\n-@@ -218,6 +224,7 @@ macro_rules! impl_trait {\n-                 (self^m) - m\n-             }\n- \n-+            /*\n-             #[inline]\n-             fn saturating_abs(self) -> Self {\n-                 // arith shift for -1 or 0 mask based on sign bit, giving 2s complement\n-@@ -230,6 +237,7 @@ macro_rules! impl_trait {\n-             fn saturating_neg(self) -> Self {\n-                 Self::splat(0).saturating_sub(self)\n-             }\n-+            */\n- \n-             #[inline]\n-             fn is_positive(self) -> Self::Mask {\n-diff --git a/crates/core_simd/src/elements/uint.rs b/crates/core_simd/src/elements/uint.rs\n-index 21e7e76..0d6dee2 100644\n---- a/crates/core_simd/src/elements/uint.rs\n-+++ b/crates/core_simd/src/elements/uint.rs\n-@@ -6,6 +6,7 @@ pub trait SimdUint: Copy + Sealed {\n-     /// Scalar type contained by this SIMD vector type.\n-     type Scalar;\n- \n-+    /*\n-     /// Lanewise saturating add.\n-     ///\n-     /// # Examples\n-@@ -40,6 +41,7 @@ pub trait SimdUint: Copy + Sealed {\n-     /// assert_eq!(unsat, Simd::from_array([3, 2, 1, 0]));\n-     /// assert_eq!(sat, Simd::splat(0));\n-     fn saturating_sub(self, second: Self) -> Self;\n-+    */\n- \n-     /// Returns the sum of the lanes of the vector, with wrapping addition.\n-     fn reduce_sum(self) -> Self::Scalar;\n-@@ -78,6 +80,7 @@ macro_rules! impl_trait {\n-         {\n-             type Scalar = $ty;\n- \n-+            /*\n-             #[inline]\n-             fn saturating_add(self, second: Self) -> Self {\n-                 // Safety: `self` is a vector\n-@@ -89,6 +92,7 @@ macro_rules! impl_trait {\n-                 // Safety: `self` is a vector\n-                 unsafe { intrinsics::simd_saturating_sub(self, second) }\n-             }\n-+            */\n- \n-             #[inline]\n-             fn reduce_sum(self) -> Self::Scalar {\n-diff --git a/crates/core_simd/src/masks/full_masks.rs b/crates/core_simd/src/masks/full_masks.rs\n-index adf0fcb..5b10292 100644\n---- a/crates/core_simd/src/masks/full_masks.rs\n-+++ b/crates/core_simd/src/masks/full_masks.rs\n-@@ -150,6 +150,7 @@ where\n-         super::Mask<T, LANES>: ToBitMaskArray,\n-         [(); <super::Mask<T, LANES> as ToBitMaskArray>::BYTES]: Sized,\n-     {\n-+        /*\n-         assert_eq!(<super::Mask<T, LANES> as ToBitMaskArray>::BYTES, N);\n- \n-         // Safety: N is the correct bitmask size\n-@@ -170,6 +171,8 @@ where\n- \n-             bitmask\n-         }\n-+        */\n-+        panic!();\n-     }\n- \n-     #[cfg(feature = \"generic_const_exprs\")]\n-@@ -209,6 +212,7 @@ where\n-     where\n-         super::Mask<T, LANES>: ToBitMask<BitMask = U>,\n-     {\n-+        /*\n-         // Safety: U is required to be the appropriate bitmask type\n-         let bitmask: U = unsafe { intrinsics::simd_bitmask(self.0) };\n- \n-@@ -218,6 +222,8 @@ where\n-         } else {\n-             bitmask\n-         }\n-+        */\n-+        panic!();\n-     }\n- \n-     #[inline]\n-@@ -225,6 +231,7 @@ where\n-     where\n-         super::Mask<T, LANES>: ToBitMask<BitMask = U>,\n-     {\n-+        /*\n-         // LLVM assumes bit order should match endianness\n-         let bitmask = if cfg!(target_endian = \"big\") {\n-             bitmask.reverse_bits(LANES)\n-@@ -240,6 +247,8 @@ where\n-                 Self::splat(false).to_int(),\n-             ))\n-         }\n-+        */\n-+        panic!();\n-     }\n- \n-     #[inline]\n diff --git a/crates/core_simd/src/vector.rs b/crates/core_simd/src/vector.rs\n index e8e8f68..7173c24 100644\n --- a/crates/core_simd/src/vector.rs\n@@ -190,25 +31,5 @@ index e8e8f68..7173c24 100644\n  }\n  \n  impl<T, const LANES: usize> Copy for Simd<T, LANES>\n-diff --git a/crates/core_simd/tests/masks.rs b/crates/core_simd/tests/masks.rs\n-index 673d0db..0d68b01 100644\n---- a/crates/core_simd/tests/masks.rs\n-+++ b/crates/core_simd/tests/masks.rs\n-@@ -59,6 +59,7 @@ macro_rules! test_mask_api {\n-                 assert!(!v.all());\n-             }\n- \n-+            /*\n-             #[test]\n-             fn roundtrip_int_conversion() {\n-                 let values = [true, false, false, true, false, false, true, false];\n-@@ -99,6 +100,7 @@ macro_rules! test_mask_api {\n-                 assert_eq!(bitmask, 0b01);\n-                 assert_eq!(core_simd::Mask::<$type, 2>::from_bitmask(bitmask), mask);\n-             }\n-+            */\n- \n-             #[test]\n-             fn cast() {\n -- \n 2.25.1"}, {"sha": "783d426c30bcc0d14cf94bb658b854e1e4b337fb", "filename": "src/intrinsics/llvm.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fa7660440b2581c4c57d896d50e76da1515de6df/src%2Fintrinsics%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa7660440b2581c4c57d896d50e76da1515de6df/src%2Fintrinsics%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fllvm.rs?ref=fa7660440b2581c4c57d896d50e76da1515de6df", "patch": "@@ -29,8 +29,7 @@ pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n             let mut res = fx.bcx.ins().iconst(types::I32, 0);\n \n             for lane in (0..lane_count).rev() {\n-                let a_lane =\n-                    a.value_field(fx, mir::Field::new(lane.try_into().unwrap())).load_scalar(fx);\n+                let a_lane = a.value_lane(fx, lane).load_scalar(fx);\n \n                 // cast float to int\n                 let a_lane = match lane_ty {"}, {"sha": "1e47ccbd49fa861253b9de6f06ca85c6ae922b98", "filename": "src/intrinsics/mod.rs", "status": "modified", "additions": 25, "deletions": 31, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/fa7660440b2581c4c57d896d50e76da1515de6df/src%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa7660440b2581c4c57d896d50e76da1515de6df/src%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fmod.rs?ref=fa7660440b2581c4c57d896d50e76da1515de6df", "patch": "@@ -84,6 +84,30 @@ fn simd_for_each_lane<'tcx>(\n     }\n }\n \n+fn simd_pair_for_each_lane_typed<'tcx>(\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n+    x: CValue<'tcx>,\n+    y: CValue<'tcx>,\n+    ret: CPlace<'tcx>,\n+    f: &dyn Fn(&mut FunctionCx<'_, '_, 'tcx>, CValue<'tcx>, CValue<'tcx>) -> CValue<'tcx>,\n+) {\n+    assert_eq!(x.layout(), y.layout());\n+    let layout = x.layout();\n+\n+    let (lane_count, _lane_ty) = layout.ty.simd_size_and_type(fx.tcx);\n+    let (ret_lane_count, _ret_lane_ty) = ret.layout().ty.simd_size_and_type(fx.tcx);\n+    assert_eq!(lane_count, ret_lane_count);\n+\n+    for lane_idx in 0..lane_count {\n+        let x_lane = x.value_lane(fx, lane_idx);\n+        let y_lane = y.value_lane(fx, lane_idx);\n+\n+        let res_lane = f(fx, x_lane, y_lane);\n+\n+        ret.place_lane(fx, lane_idx).write_cvalue(fx, res_lane);\n+    }\n+}\n+\n fn simd_pair_for_each_lane<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     x: CValue<'tcx>,\n@@ -507,37 +531,7 @@ fn codegen_regular_intrinsic_call<'tcx>(\n                 _ => unreachable!(),\n             };\n \n-            let signed = type_sign(lhs.layout().ty);\n-\n-            let checked_res = crate::num::codegen_checked_int_binop(fx, bin_op, lhs, rhs);\n-\n-            let (val, has_overflow) = checked_res.load_scalar_pair(fx);\n-            let clif_ty = fx.clif_type(lhs.layout().ty).unwrap();\n-\n-            let (min, max) = type_min_max_value(&mut fx.bcx, clif_ty, signed);\n-\n-            let val = match (intrinsic, signed) {\n-                (sym::saturating_add, false) => fx.bcx.ins().select(has_overflow, max, val),\n-                (sym::saturating_sub, false) => fx.bcx.ins().select(has_overflow, min, val),\n-                (sym::saturating_add, true) => {\n-                    let rhs = rhs.load_scalar(fx);\n-                    let rhs_ge_zero =\n-                        fx.bcx.ins().icmp_imm(IntCC::SignedGreaterThanOrEqual, rhs, 0);\n-                    let sat_val = fx.bcx.ins().select(rhs_ge_zero, max, min);\n-                    fx.bcx.ins().select(has_overflow, sat_val, val)\n-                }\n-                (sym::saturating_sub, true) => {\n-                    let rhs = rhs.load_scalar(fx);\n-                    let rhs_ge_zero =\n-                        fx.bcx.ins().icmp_imm(IntCC::SignedGreaterThanOrEqual, rhs, 0);\n-                    let sat_val = fx.bcx.ins().select(rhs_ge_zero, min, max);\n-                    fx.bcx.ins().select(has_overflow, sat_val, val)\n-                }\n-                _ => unreachable!(),\n-            };\n-\n-            let res = CValue::by_val(val, lhs.layout());\n-\n+            let res = crate::num::codegen_saturating_int_binop(fx, bin_op, lhs, rhs);\n             ret.write_cvalue(fx, res);\n         }\n         sym::rotate_left => {"}, {"sha": "51fce8c854bdb5307149680f288fa590ed8a8b53", "filename": "src/intrinsics/simd.rs", "status": "modified", "additions": 124, "deletions": 2, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/fa7660440b2581c4c57d896d50e76da1515de6df/src%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa7660440b2581c4c57d896d50e76da1515de6df/src%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fsimd.rs?ref=fa7660440b2581c4c57d896d50e76da1515de6df", "patch": "@@ -2,6 +2,7 @@\n \n use rustc_middle::ty::subst::SubstsRef;\n use rustc_span::Symbol;\n+use rustc_target::abi::Endian;\n \n use super::*;\n use crate::prelude::*;\n@@ -162,6 +163,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n                     }\n                 }\n             } else {\n+                // FIXME remove this case\n                 intrinsic.as_str()[\"simd_shuffle\".len()..].parse().unwrap()\n             };\n \n@@ -650,8 +652,128 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n             }\n         }\n \n-        // simd_saturating_*\n-        // simd_bitmask\n+        sym::simd_select_bitmask => {\n+            intrinsic_args!(fx, args => (m, a, b); intrinsic);\n+\n+            if !a.layout().ty.is_simd() {\n+                report_simd_type_validation_error(fx, intrinsic, span, a.layout().ty);\n+                return;\n+            }\n+            assert_eq!(a.layout(), b.layout());\n+\n+            let (lane_count, lane_ty) = a.layout().ty.simd_size_and_type(fx.tcx);\n+            let lane_layout = fx.layout_of(lane_ty);\n+\n+            let m = m.load_scalar(fx);\n+\n+            for lane in 0..lane_count {\n+                let m_lane = fx.bcx.ins().ushr_imm(m, u64::from(lane) as i64);\n+                let m_lane = fx.bcx.ins().band_imm(m_lane, 1);\n+                let a_lane = a.value_lane(fx, lane).load_scalar(fx);\n+                let b_lane = b.value_lane(fx, lane).load_scalar(fx);\n+\n+                let m_lane = fx.bcx.ins().icmp_imm(IntCC::Equal, m_lane, 0);\n+                let res_lane =\n+                    CValue::by_val(fx.bcx.ins().select(m_lane, b_lane, a_lane), lane_layout);\n+\n+                ret.place_lane(fx, lane).write_cvalue(fx, res_lane);\n+            }\n+        }\n+\n+        sym::simd_bitmask => {\n+            intrinsic_args!(fx, args => (a); intrinsic);\n+\n+            let (lane_count, lane_ty) = a.layout().ty.simd_size_and_type(fx.tcx);\n+            let lane_clif_ty = fx.clif_type(lane_ty).unwrap();\n+\n+            // The `fn simd_bitmask(vector) -> unsigned integer` intrinsic takes a\n+            // vector mask and returns the most significant bit (MSB) of each lane in the form\n+            // of either:\n+            // * an unsigned integer\n+            // * an array of `u8`\n+            // If the vector has less than 8 lanes, a u8 is returned with zeroed trailing bits.\n+            //\n+            // The bit order of the result depends on the byte endianness, LSB-first for little\n+            // endian and MSB-first for big endian.\n+            let expected_int_bits = lane_count.max(8);\n+            let expected_bytes = expected_int_bits / 8 + ((expected_int_bits % 8 > 0) as u64);\n+\n+            match lane_ty.kind() {\n+                ty::Int(_) | ty::Uint(_) => {}\n+                _ => {\n+                    fx.tcx.sess.span_fatal(\n+                        span,\n+                        &format!(\n+                            \"invalid monomorphization of `simd_bitmask` intrinsic: \\\n+                            vector argument `{}`'s element type `{}`, expected integer element \\\n+                            type\",\n+                            a.layout().ty,\n+                            lane_ty\n+                        ),\n+                    );\n+                }\n+            }\n+\n+            let res_type =\n+                Type::int_with_byte_size(u16::try_from(expected_bytes).unwrap()).unwrap();\n+            let mut res = fx.bcx.ins().iconst(res_type, 0);\n+\n+            let lanes = match fx.tcx.sess.target.endian {\n+                Endian::Big => Box::new(0..lane_count) as Box<dyn Iterator<Item = u64>>,\n+                Endian::Little => Box::new((0..lane_count).rev()) as Box<dyn Iterator<Item = u64>>,\n+            };\n+            for lane in lanes {\n+                let a_lane = a.value_lane(fx, lane).load_scalar(fx);\n+\n+                // extract sign bit of an int\n+                let a_lane_sign = fx.bcx.ins().ushr_imm(a_lane, i64::from(lane_clif_ty.bits() - 1));\n+\n+                // shift sign bit into result\n+                let a_lane_sign = clif_intcast(fx, a_lane_sign, res_type, false);\n+                res = fx.bcx.ins().ishl_imm(res, 1);\n+                res = fx.bcx.ins().bor(res, a_lane_sign);\n+            }\n+\n+            match ret.layout().ty.kind() {\n+                ty::Uint(i) if i.bit_width() == Some(expected_int_bits) => {}\n+                ty::Array(elem, len)\n+                    if matches!(elem.kind(), ty::Uint(ty::UintTy::U8))\n+                        && len.try_eval_usize(fx.tcx, ty::ParamEnv::reveal_all())\n+                            == Some(expected_bytes) => {}\n+                _ => {\n+                    fx.tcx.sess.span_fatal(\n+                        span,\n+                        &format!(\n+                            \"invalid monomorphization of `simd_bitmask` intrinsic: \\\n+                            cannot return `{}`, expected `u{}` or `[u8; {}]`\",\n+                            ret.layout().ty,\n+                            expected_int_bits,\n+                            expected_bytes\n+                        ),\n+                    );\n+                }\n+            }\n+\n+            let res = CValue::by_val(res, ret.layout());\n+            ret.write_cvalue(fx, res);\n+        }\n+\n+        sym::simd_saturating_add | sym::simd_saturating_sub => {\n+            intrinsic_args!(fx, args => (x, y); intrinsic);\n+\n+            let bin_op = match intrinsic {\n+                sym::simd_saturating_add => BinOp::Add,\n+                sym::simd_saturating_sub => BinOp::Sub,\n+                _ => unreachable!(),\n+            };\n+\n+            // FIXME use vector instructions when possible\n+            simd_pair_for_each_lane_typed(fx, x, y, ret, &|fx, x_lane, y_lane| {\n+                crate::num::codegen_saturating_int_binop(fx, bin_op, x_lane, y_lane)\n+            });\n+        }\n+\n+        // simd_arith_offset\n         // simd_scatter\n         // simd_gather\n         _ => {"}, {"sha": "4fadbf24d8a83ae50657d44b08726ef2726a18f4", "filename": "src/num.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/fa7660440b2581c4c57d896d50e76da1515de6df/src%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa7660440b2581c4c57d896d50e76da1515de6df/src%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fnum.rs?ref=fa7660440b2581c4c57d896d50e76da1515de6df", "patch": "@@ -309,6 +309,42 @@ pub(crate) fn codegen_checked_int_binop<'tcx>(\n     CValue::by_val_pair(res, has_overflow, out_layout)\n }\n \n+pub(crate) fn codegen_saturating_int_binop<'tcx>(\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n+    bin_op: BinOp,\n+    lhs: CValue<'tcx>,\n+    rhs: CValue<'tcx>,\n+) -> CValue<'tcx> {\n+    assert_eq!(lhs.layout().ty, rhs.layout().ty);\n+\n+    let signed = type_sign(lhs.layout().ty);\n+    let clif_ty = fx.clif_type(lhs.layout().ty).unwrap();\n+    let (min, max) = type_min_max_value(&mut fx.bcx, clif_ty, signed);\n+\n+    let checked_res = crate::num::codegen_checked_int_binop(fx, bin_op, lhs, rhs);\n+    let (val, has_overflow) = checked_res.load_scalar_pair(fx);\n+\n+    let val = match (bin_op, signed) {\n+        (BinOp::Add, false) => fx.bcx.ins().select(has_overflow, max, val),\n+        (BinOp::Sub, false) => fx.bcx.ins().select(has_overflow, min, val),\n+        (BinOp::Add, true) => {\n+            let rhs = rhs.load_scalar(fx);\n+            let rhs_ge_zero = fx.bcx.ins().icmp_imm(IntCC::SignedGreaterThanOrEqual, rhs, 0);\n+            let sat_val = fx.bcx.ins().select(rhs_ge_zero, max, min);\n+            fx.bcx.ins().select(has_overflow, sat_val, val)\n+        }\n+        (BinOp::Sub, true) => {\n+            let rhs = rhs.load_scalar(fx);\n+            let rhs_ge_zero = fx.bcx.ins().icmp_imm(IntCC::SignedGreaterThanOrEqual, rhs, 0);\n+            let sat_val = fx.bcx.ins().select(rhs_ge_zero, min, max);\n+            fx.bcx.ins().select(has_overflow, sat_val, val)\n+        }\n+        _ => unreachable!(),\n+    };\n+\n+    CValue::by_val(val, lhs.layout())\n+}\n+\n pub(crate) fn codegen_float_binop<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     bin_op: BinOp,"}]}