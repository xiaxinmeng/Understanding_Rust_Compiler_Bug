{"sha": "33e924d38347db97f403fc775dfb3a31cd3e0c37", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzZTkyNGQzODM0N2RiOTdmNDAzZmM3NzVkZmIzYTMxY2QzZTBjMzc=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-03-27T04:25:08Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-03-27T04:25:08Z"}, "message": "Add undefined byte tracking.", "tree": {"sha": "4ec05394d0639c62489c534545f222cedd28fc3f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ec05394d0639c62489c534545f222cedd28fc3f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/33e924d38347db97f403fc775dfb3a31cd3e0c37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/33e924d38347db97f403fc775dfb3a31cd3e0c37", "html_url": "https://github.com/rust-lang/rust/commit/33e924d38347db97f403fc775dfb3a31cd3e0c37", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/33e924d38347db97f403fc775dfb3a31cd3e0c37/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5451b6115b77fd13c68c43316086e9db0b9748d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/5451b6115b77fd13c68c43316086e9db0b9748d7", "html_url": "https://github.com/rust-lang/rust/commit/5451b6115b77fd13c68c43316086e9db0b9748d7"}], "stats": {"total": 220, "additions": 219, "deletions": 1}, "files": [{"sha": "f1ad5d66e1abc623b7ab92eb5ea442025b9b8e0a", "filename": "src/memory.rs", "status": "modified", "additions": 219, "deletions": 1, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/33e924d38347db97f403fc775dfb3a31cd3e0c37/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33e924d38347db97f403fc775dfb3a31cd3e0c37/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=33e924d38347db97f403fc775dfb3a31cd3e0c37", "patch": "@@ -14,7 +14,21 @@ pub struct AllocId(u64);\n pub struct Allocation {\n     pub bytes: Box<[u8]>,\n     pub relocations: BTreeMap<usize, AllocId>,\n-    // TODO(tsion): undef mask\n+\n+    /// Stores a list of indices `[a_0, a_1, ..., a_n]`. Bytes in the range `0..a_0` are considered\n+    /// defined, `a_0..a_1` are undefined, `a_1..a_2` are defined and so on until\n+    /// `a_n..bytes.len()`. These ranges are all end-exclusive.\n+    ///\n+    /// In general a byte's definedness can be found by binary searching this list of indices,\n+    /// finding where the byte would fall, and taking the position of nearest index mod 2. This\n+    /// yields 0 for defined and 1 for undefined.\n+    ///\n+    /// Some noteworthy cases:\n+    ///   * `[]` represents a fully-defined allocation.\n+    ///   * `[0]` represents a fully-undefined allocation. (The empty `0..0` is defined and\n+    ///     `0..bytes.len()` is undefined.)\n+    ///   * However, to avoid allocation, fully-undefined allocations can be represented as `None`.\n+    pub undef_mask: Option<Vec<usize>>,\n }\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n@@ -95,6 +109,7 @@ impl Memory {\n         let alloc = Allocation {\n             bytes: vec![0; size].into_boxed_slice(),\n             relocations: BTreeMap::new(),\n+            undef_mask: None,\n         };\n         self.alloc_map.insert(self.next_id, alloc);\n         self.next_id += 1;\n@@ -146,6 +161,7 @@ impl Memory {\n \n     fn get_bytes_mut(&mut self, ptr: Pointer, size: usize) -> EvalResult<&mut [u8]> {\n         try!(self.clear_relocations(ptr, size));\n+        try!(self.mark_definedness(ptr, size, true));\n         self.get_bytes_unchecked_mut(ptr, size)\n     }\n \n@@ -303,4 +319,206 @@ impl Memory {\n         try!(self.get_mut(dest.alloc_id)).relocations.extend(relocations);\n         Ok(())\n     }\n+\n+    ////////////////////////////////////////////////////////////////////////////////\n+    // Undefined bytes\n+    ////////////////////////////////////////////////////////////////////////////////\n+\n+    fn mark_definedness(&mut self, ptr: Pointer, size: usize, new_state: bool) -> EvalResult<()> {\n+        let mut alloc = try!(self.get_mut(ptr.alloc_id));\n+        alloc.mark_definedness(ptr.offset, ptr.offset + size, new_state);\n+        Ok(())\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Undefined byte tracking\n+////////////////////////////////////////////////////////////////////////////////\n+\n+impl Allocation {\n+    /// Mark the range `start..end` (end-exclusive) as defined or undefined, depending on\n+    /// `new_state`.\n+    fn mark_definedness(&mut self, start: usize, end: usize, new_state: bool) {\n+        // There is no need to track undef masks for zero-sized allocations.\n+        let len = self.bytes.len();\n+        if len == 0 {\n+            return;\n+        }\n+\n+        // Returns whether the new state matches the state of a given undef mask index. The way\n+        // undef masks are represented, boundaries at even indices are undefined and those at odd\n+        // indices are defined.\n+        let index_matches_new_state = |i| i % 2 == new_state as usize;\n+\n+        // Lookup the undef mask index where the given endpoint `i` is or should be inserted.\n+        let lookup_endpoint = |undef_mask: &[usize], i: usize| -> (usize, bool) {\n+            let (index, should_insert);\n+            match undef_mask.binary_search(&i) {\n+                // Region endpoint is on an undef mask boundary.\n+                Ok(j) => {\n+                    // This endpoint's index must be incremented if the boundary's state matches\n+                    // the region's new state so that the boundary is:\n+                    //   1. Excluded from deletion when handling the inclusive left-hand endpoint.\n+                    //   2. Included for deletion when handling the exclusive right-hand endpoint.\n+                    index = j + index_matches_new_state(j) as usize;\n+\n+                    // Don't insert a new mask boundary; simply reuse or delete the matched one.\n+                    should_insert = false;\n+                }\n+\n+                // Region endpoint is not on a mask boundary.\n+                Err(j) => {\n+                    // This is the index after the nearest mask boundary which has the same state.\n+                    index = j;\n+\n+                    // Insert a new boundary if this endpoint's state doesn't match the state of\n+                    // this position.\n+                    should_insert = index_matches_new_state(j);\n+                }\n+            }\n+            (index, should_insert)\n+        };\n+\n+        match self.undef_mask {\n+            // There is an existing undef mask, with arbitrary existing boundaries.\n+            Some(ref mut undef_mask) => {\n+                // Determine where the new range's endpoints fall within the current undef mask.\n+                let (start_index, insert_start) = lookup_endpoint(undef_mask, start);\n+                let (end_index, insert_end) = lookup_endpoint(undef_mask, end);\n+\n+                // Delete all the undef mask boundaries overwritten by the new range.\n+                undef_mask.drain(start_index..end_index);\n+\n+                // Insert any new boundaries deemed necessary with two exceptions:\n+                //   1. Never insert an endpoint equal to the allocation length; it's implicit.\n+                //   2. Never insert a start boundary equal to the end boundary.\n+                if insert_end && end != len {\n+                    undef_mask.insert(start_index, end);\n+                }\n+                if insert_start && start != end {\n+                    undef_mask.insert(start_index, start);\n+                }\n+            }\n+\n+            // There is no existing undef mask. This is taken as meaning the entire allocation is\n+            // currently undefined. If the new state is false, meaning undefined, do nothing.\n+            None => if new_state {\n+                let mut mask = if start == 0 {\n+                    // 0..end is defined.\n+                    Vec::new()\n+                } else {\n+                    // 0..0 is defined, 0..start is undefined, start..end is defined.\n+                    vec![0, start]\n+                };\n+\n+                // Don't insert the end boundary if it's equal to the allocation length; that\n+                // boundary is implicit.\n+                if end != len {\n+                    mask.push(end);\n+                }\n+                self.undef_mask = Some(mask);\n+            },\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use memory::Allocation;\n+    use std::collections::BTreeMap;\n+\n+    fn alloc_with_mask(len: usize, undef_mask: Option<Vec<usize>>) -> Allocation {\n+        Allocation {\n+            bytes: vec![0; len].into_boxed_slice(),\n+            relocations: BTreeMap::new(),\n+            undef_mask: undef_mask,\n+        }\n+    }\n+\n+    #[test]\n+    fn large_undef_mask() {\n+        let mut alloc = alloc_with_mask(20, Some(vec![4, 8, 12, 16]));\n+\n+        alloc.mark_definedness(8, 11, false);\n+        assert_eq!(alloc.undef_mask, Some(vec![4, 11, 12, 16]));\n+\n+        alloc.mark_definedness(8, 11, true);\n+        assert_eq!(alloc.undef_mask, Some(vec![4, 8, 12, 16]));\n+\n+        alloc.mark_definedness(8, 12, false);\n+        assert_eq!(alloc.undef_mask, Some(vec![4, 16]));\n+\n+        alloc.mark_definedness(8, 12, true);\n+        assert_eq!(alloc.undef_mask, Some(vec![4, 8, 12, 16]));\n+\n+        alloc.mark_definedness(9, 11, true);\n+        assert_eq!(alloc.undef_mask, Some(vec![4, 8, 12, 16]));\n+\n+        alloc.mark_definedness(9, 11, false);\n+        assert_eq!(alloc.undef_mask, Some(vec![4, 8, 9, 11, 12, 16]));\n+\n+        alloc.mark_definedness(9, 10, true);\n+        assert_eq!(alloc.undef_mask, Some(vec![4, 8, 10, 11, 12, 16]));\n+\n+        alloc.mark_definedness(8, 12, true);\n+        assert_eq!(alloc.undef_mask, Some(vec![4, 8, 12, 16]));\n+    }\n+\n+    #[test]\n+    fn empty_undef_mask() {\n+        let mut alloc = alloc_with_mask(0, None);\n+\n+        alloc.mark_definedness(0, 0, false);\n+        assert_eq!(alloc.undef_mask, None);\n+\n+        alloc.mark_definedness(0, 0, true);\n+        assert_eq!(alloc.undef_mask, None);\n+    }\n+\n+    #[test]\n+    fn small_undef_mask() {\n+        let mut alloc = alloc_with_mask(8, None);\n+\n+        alloc.mark_definedness(0, 4, false);\n+        assert_eq!(alloc.undef_mask, None);\n+\n+        alloc.mark_definedness(0, 4, true);\n+        assert_eq!(alloc.undef_mask, Some(vec![4]));\n+\n+        alloc.mark_definedness(4, 8, false);\n+        assert_eq!(alloc.undef_mask, Some(vec![4]));\n+\n+        alloc.mark_definedness(4, 8, true);\n+        assert_eq!(alloc.undef_mask, Some(vec![]));\n+\n+        alloc.mark_definedness(0, 8, true);\n+        assert_eq!(alloc.undef_mask, Some(vec![]));\n+\n+        alloc.mark_definedness(0, 8, false);\n+        assert_eq!(alloc.undef_mask, Some(vec![0]));\n+\n+        alloc.mark_definedness(0, 8, true);\n+        assert_eq!(alloc.undef_mask, Some(vec![]));\n+\n+        alloc.mark_definedness(4, 8, false);\n+        assert_eq!(alloc.undef_mask, Some(vec![4]));\n+\n+        alloc.mark_definedness(0, 8, false);\n+        assert_eq!(alloc.undef_mask, Some(vec![0]));\n+\n+        alloc.mark_definedness(2, 5, true);\n+        assert_eq!(alloc.undef_mask, Some(vec![0, 2, 5]));\n+\n+        alloc.mark_definedness(4, 6, false);\n+        assert_eq!(alloc.undef_mask, Some(vec![0, 2, 4]));\n+\n+        alloc.mark_definedness(0, 3, true);\n+        assert_eq!(alloc.undef_mask, Some(vec![4]));\n+\n+        alloc.mark_definedness(2, 6, true);\n+        assert_eq!(alloc.undef_mask, Some(vec![6]));\n+\n+        alloc.mark_definedness(3, 7, false);\n+        assert_eq!(alloc.undef_mask, Some(vec![3]));\n+    }\n }"}]}