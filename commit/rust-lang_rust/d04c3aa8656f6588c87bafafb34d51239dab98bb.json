{"sha": "d04c3aa8656f6588c87bafafb34d51239dab98bb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwNGMzYWE4NjU2ZjY1ODhjODdiYWZhZmIzNGQ1MTIzOWRhYjk4YmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-22T12:18:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-22T12:18:57Z"}, "message": "Auto merge of #83273 - cjgillot:endecode, r=michaelwoerister\n\nSimplify encoder and decoder\n\nExtracted from https://github.com/rust-lang/rust/pull/83036 and https://github.com/rust-lang/rust/pull/82780.", "tree": {"sha": "2ed631041ec6d3169be121484d4d66f61edeca2c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2ed631041ec6d3169be121484d4d66f61edeca2c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d04c3aa8656f6588c87bafafb34d51239dab98bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d04c3aa8656f6588c87bafafb34d51239dab98bb", "html_url": "https://github.com/rust-lang/rust/commit/d04c3aa8656f6588c87bafafb34d51239dab98bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d04c3aa8656f6588c87bafafb34d51239dab98bb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f82ddb8750aef7c48173b84ec5a3d713edce263", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f82ddb8750aef7c48173b84ec5a3d713edce263", "html_url": "https://github.com/rust-lang/rust/commit/7f82ddb8750aef7c48173b84ec5a3d713edce263"}, {"sha": "11b3409b5d927079f945d24d848c6e8d20cff8ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/11b3409b5d927079f945d24d848c6e8d20cff8ac", "html_url": "https://github.com/rust-lang/rust/commit/11b3409b5d927079f945d24d848c6e8d20cff8ac"}], "stats": {"total": 282, "additions": 125, "deletions": 157}, "files": [{"sha": "81b115fac0d0e0ebc6cabfecc1de483f413f8edc", "filename": "compiler/rustc_data_structures/src/fingerprint.rs", "status": "modified", "additions": 10, "deletions": 56, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/d04c3aa8656f6588c87bafafb34d51239dab98bb/compiler%2Frustc_data_structures%2Fsrc%2Ffingerprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04c3aa8656f6588c87bafafb34d51239dab98bb/compiler%2Frustc_data_structures%2Fsrc%2Ffingerprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ffingerprint.rs?ref=d04c3aa8656f6588c87bafafb34d51239dab98bb", "patch": "@@ -1,8 +1,5 @@\n use crate::stable_hasher;\n-use rustc_serialize::{\n-    opaque::{self, EncodeResult, FileEncodeResult},\n-    Decodable, Encodable,\n-};\n+use rustc_serialize::{Decodable, Encodable};\n use std::hash::{Hash, Hasher};\n use std::mem::{self, MaybeUninit};\n \n@@ -63,16 +60,6 @@ impl Fingerprint {\n     pub fn to_hex(&self) -> String {\n         format!(\"{:x}{:x}\", self.0, self.1)\n     }\n-\n-    pub fn decode_opaque(decoder: &mut opaque::Decoder<'_>) -> Result<Fingerprint, String> {\n-        let mut bytes: [MaybeUninit<u8>; 16] = MaybeUninit::uninit_array();\n-\n-        decoder.read_raw_bytes(&mut bytes)?;\n-\n-        let [l, r]: [u64; 2] = unsafe { mem::transmute(bytes) };\n-\n-        Ok(Fingerprint(u64::from_le(l), u64::from_le(r)))\n-    }\n }\n \n impl std::fmt::Display for Fingerprint {\n@@ -130,55 +117,22 @@ impl stable_hasher::StableHasherResult for Fingerprint {\n impl_stable_hash_via_hash!(Fingerprint);\n \n impl<E: rustc_serialize::Encoder> Encodable<E> for Fingerprint {\n+    #[inline]\n     fn encode(&self, s: &mut E) -> Result<(), E::Error> {\n-        s.encode_fingerprint(self)\n+        let bytes: [u8; 16] = unsafe { mem::transmute([self.0.to_le(), self.1.to_le()]) };\n+        s.emit_raw_bytes(&bytes)?;\n+        Ok(())\n     }\n }\n \n impl<D: rustc_serialize::Decoder> Decodable<D> for Fingerprint {\n+    #[inline]\n     fn decode(d: &mut D) -> Result<Self, D::Error> {\n-        d.decode_fingerprint()\n-    }\n-}\n-\n-pub trait FingerprintEncoder: rustc_serialize::Encoder {\n-    fn encode_fingerprint(&mut self, f: &Fingerprint) -> Result<(), Self::Error>;\n-}\n-\n-pub trait FingerprintDecoder: rustc_serialize::Decoder {\n-    fn decode_fingerprint(&mut self) -> Result<Fingerprint, Self::Error>;\n-}\n-\n-impl<E: rustc_serialize::Encoder> FingerprintEncoder for E {\n-    default fn encode_fingerprint(&mut self, _: &Fingerprint) -> Result<(), E::Error> {\n-        panic!(\"Cannot encode `Fingerprint` with `{}`\", std::any::type_name::<E>());\n-    }\n-}\n-\n-impl FingerprintEncoder for opaque::Encoder {\n-    fn encode_fingerprint(&mut self, f: &Fingerprint) -> EncodeResult {\n-        let bytes: [u8; 16] = unsafe { mem::transmute([f.0.to_le(), f.1.to_le()]) };\n-        self.emit_raw_bytes(&bytes);\n-        Ok(())\n-    }\n-}\n-\n-impl FingerprintEncoder for opaque::FileEncoder {\n-    fn encode_fingerprint(&mut self, f: &Fingerprint) -> FileEncodeResult {\n-        let bytes: [u8; 16] = unsafe { mem::transmute([f.0.to_le(), f.1.to_le()]) };\n-        self.emit_raw_bytes(&bytes)\n-    }\n-}\n-\n-impl<D: rustc_serialize::Decoder> FingerprintDecoder for D {\n-    default fn decode_fingerprint(&mut self) -> Result<Fingerprint, D::Error> {\n-        panic!(\"Cannot decode `Fingerprint` with `{}`\", std::any::type_name::<D>());\n-    }\n-}\n+        let mut bytes: [MaybeUninit<u8>; 16] = MaybeUninit::uninit_array();\n+        d.read_raw_bytes(&mut bytes)?;\n \n-impl FingerprintDecoder for opaque::Decoder<'_> {\n-    fn decode_fingerprint(&mut self) -> Result<Fingerprint, String> {\n-        Fingerprint::decode_opaque(self)\n+        let [l, r]: [u64; 2] = unsafe { mem::transmute(bytes) };\n+        Ok(Fingerprint(u64::from_le(l), u64::from_le(r)))\n     }\n }\n "}, {"sha": "b821ed6cff9f83f2706f378f8ef953e823a323f9", "filename": "compiler/rustc_incremental/src/persist/file_format.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d04c3aa8656f6588c87bafafb34d51239dab98bb/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffile_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04c3aa8656f6588c87bafafb34d51239dab98bb/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffile_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffile_format.rs?ref=d04c3aa8656f6588c87bafafb34d51239dab98bb", "patch": "@@ -15,6 +15,7 @@ use std::io::{self, Read};\n use std::path::Path;\n \n use rustc_serialize::opaque::{FileEncodeResult, FileEncoder};\n+use rustc_serialize::Encoder;\n \n /// The first few bytes of files generated by incremental compilation.\n const FILE_MAGIC: &[u8] = b\"RSIC\";"}, {"sha": "e8891e471f9dafa3289789a02e02a4cbf102b8f7", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d04c3aa8656f6588c87bafafb34d51239dab98bb/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04c3aa8656f6588c87bafafb34d51239dab98bb/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=d04c3aa8656f6588c87bafafb34d51239dab98bb", "patch": "@@ -7,7 +7,6 @@ use crate::rmeta::*;\n use rustc_ast as ast;\n use rustc_attr as attr;\n use rustc_data_structures::captures::Captures;\n-use rustc_data_structures::fingerprint::{Fingerprint, FingerprintDecoder};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::{Lock, LockGuard, Lrc, OnceCell};\n@@ -351,12 +350,6 @@ impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for DefIndex {\n     }\n }\n \n-impl<'a, 'tcx> FingerprintDecoder for DecodeContext<'a, 'tcx> {\n-    fn decode_fingerprint(&mut self) -> Result<Fingerprint, String> {\n-        Fingerprint::decode_opaque(&mut self.opaque)\n-    }\n-}\n-\n impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for SyntaxContext {\n     fn decode(decoder: &mut DecodeContext<'a, 'tcx>) -> Result<SyntaxContext, String> {\n         let cdata = decoder.cdata();"}, {"sha": "ff8ec1d551323bfcd74e4fa1b4bae22255c7a7ef", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d04c3aa8656f6588c87bafafb34d51239dab98bb/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04c3aa8656f6588c87bafafb34d51239dab98bb/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=d04c3aa8656f6588c87bafafb34d51239dab98bb", "patch": "@@ -1,7 +1,6 @@\n use crate::rmeta::table::{FixedSizeEncoding, TableBuilder};\n use crate::rmeta::*;\n \n-use rustc_data_structures::fingerprint::{Fingerprint, FingerprintEncoder};\n use rustc_data_structures::fx::{FxHashMap, FxIndexSet};\n use rustc_data_structures::stable_hasher::StableHasher;\n use rustc_data_structures::sync::{join, par_iter, Lrc, ParallelIterator};\n@@ -116,6 +115,7 @@ impl<'a, 'tcx> Encoder for EncodeContext<'a, 'tcx> {\n         emit_f32(f32);\n         emit_char(char);\n         emit_str(&str);\n+        emit_raw_bytes(&[u8]);\n     }\n }\n \n@@ -307,12 +307,6 @@ impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for Span {\n     }\n }\n \n-impl<'a, 'tcx> FingerprintEncoder for EncodeContext<'a, 'tcx> {\n-    fn encode_fingerprint(&mut self, f: &Fingerprint) -> Result<(), Self::Error> {\n-        self.opaque.encode_fingerprint(f)\n-    }\n-}\n-\n impl<'a, 'tcx> TyEncoder<'tcx> for EncodeContext<'a, 'tcx> {\n     const CLEAR_CROSS_CRATE: bool = true;\n \n@@ -2064,10 +2058,10 @@ pub(super) fn encode_metadata(tcx: TyCtxt<'_>) -> EncodedMetadata {\n \n fn encode_metadata_impl(tcx: TyCtxt<'_>) -> EncodedMetadata {\n     let mut encoder = opaque::Encoder::new(vec![]);\n-    encoder.emit_raw_bytes(METADATA_HEADER);\n+    encoder.emit_raw_bytes(METADATA_HEADER).unwrap();\n \n     // Will be filled with the root position after encoding everything.\n-    encoder.emit_raw_bytes(&[0, 0, 0, 0]);\n+    encoder.emit_raw_bytes(&[0, 0, 0, 0]).unwrap();\n \n     let source_map_files = tcx.sess.source_map().files();\n     let source_file_cache = (source_map_files[0].clone(), 0);"}, {"sha": "62c0ce1584594afdb3d85d9b5b57bd2d15adc941", "filename": "compiler/rustc_metadata/src/rmeta/table.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d04c3aa8656f6588c87bafafb34d51239dab98bb/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04c3aa8656f6588c87bafafb34d51239dab98bb/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs?ref=d04c3aa8656f6588c87bafafb34d51239dab98bb", "patch": "@@ -2,6 +2,7 @@ use crate::rmeta::*;\n \n use rustc_index::vec::Idx;\n use rustc_serialize::opaque::Encoder;\n+use rustc_serialize::Encoder as _;\n use std::convert::TryInto;\n use std::marker::PhantomData;\n use std::num::NonZeroUsize;\n@@ -172,7 +173,7 @@ where\n \n     pub(crate) fn encode(&self, buf: &mut Encoder) -> Lazy<Table<I, T>> {\n         let pos = buf.position();\n-        buf.emit_raw_bytes(&self.bytes);\n+        buf.emit_raw_bytes(&self.bytes).unwrap();\n         Lazy::from_position_and_meta(NonZeroUsize::new(pos as usize).unwrap(), self.bytes.len())\n     }\n }"}, {"sha": "ea1caf58d780ff0e530d1279fb8d0b3503698113", "filename": "compiler/rustc_middle/src/ty/codec.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d04c3aa8656f6588c87bafafb34d51239dab98bb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04c3aa8656f6588c87bafafb34d51239dab98bb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs?ref=d04c3aa8656f6588c87bafafb34d51239dab98bb", "patch": "@@ -472,6 +472,11 @@ macro_rules! implement_ty_decoder {\n                     read_str -> Cow<'_, str>;\n                 }\n \n+                #[inline]\n+                fn read_raw_bytes(&mut self, bytes: &mut [std::mem::MaybeUninit<u8>]) -> Result<(), Self::Error> {\n+                    self.opaque.read_raw_bytes(bytes)\n+                }\n+\n                 fn error(&mut self, err: &str) -> Self::Error {\n                     self.opaque.error(err)\n                 }"}, {"sha": "ff11314d2ffd1c82e62ed6a08ae78b62cf8ce2d0", "filename": "compiler/rustc_middle/src/ty/query/on_disk_cache.rs", "status": "modified", "additions": 2, "deletions": 50, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/d04c3aa8656f6588c87bafafb34d51239dab98bb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04c3aa8656f6588c87bafafb34d51239dab98bb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=d04c3aa8656f6588c87bafafb34d51239dab98bb", "patch": "@@ -4,7 +4,6 @@ use crate::mir::{self, interpret};\n use crate::ty::codec::{RefDecodable, TyDecoder, TyEncoder};\n use crate::ty::context::TyCtxt;\n use crate::ty::{self, Ty};\n-use rustc_data_structures::fingerprint::{Fingerprint, FingerprintDecoder, FingerprintEncoder};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexSet};\n use rustc_data_structures::sync::{HashMapExt, Lock, Lrc, OnceCell};\n use rustc_data_structures::thin_vec::ThinVec;\n@@ -17,7 +16,7 @@ use rustc_index::vec::{Idx, IndexVec};\n use rustc_query_system::dep_graph::DepContext;\n use rustc_query_system::query::QueryContext;\n use rustc_serialize::{\n-    opaque::{self, FileEncodeResult, FileEncoder},\n+    opaque::{self, FileEncodeResult, FileEncoder, IntEncodedWithFixedSize},\n     Decodable, Decoder, Encodable, Encoder,\n };\n use rustc_session::{CrateDisambiguator, Session};\n@@ -913,12 +912,6 @@ impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for DefId {\n     }\n }\n \n-impl<'a, 'tcx> FingerprintDecoder for CacheDecoder<'a, 'tcx> {\n-    fn decode_fingerprint(&mut self) -> Result<Fingerprint, Self::Error> {\n-        Fingerprint::decode_opaque(&mut self.opaque)\n-    }\n-}\n-\n impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for &'tcx FxHashSet<LocalDefId> {\n     fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Result<Self, String> {\n         RefDecodable::decode(d)\n@@ -1011,12 +1004,6 @@ where\n     }\n }\n \n-impl<'a, 'tcx, E: OpaqueEncoder> FingerprintEncoder for CacheEncoder<'a, 'tcx, E> {\n-    fn encode_fingerprint(&mut self, f: &Fingerprint) -> Result<(), E::Error> {\n-        self.encoder.encode_fingerprint(f)\n-    }\n-}\n-\n impl<'a, 'tcx, E> Encodable<CacheEncoder<'a, 'tcx, E>> for SyntaxContext\n where\n     E: 'a + OpaqueEncoder,\n@@ -1167,6 +1154,7 @@ where\n         emit_f32(f32);\n         emit_char(char);\n         emit_str(&str);\n+        emit_raw_bytes(&[u8]);\n     }\n }\n \n@@ -1180,42 +1168,6 @@ impl<'a, 'tcx> Encodable<CacheEncoder<'a, 'tcx, FileEncoder>> for [u8] {\n     }\n }\n \n-// An integer that will always encode to 8 bytes.\n-struct IntEncodedWithFixedSize(u64);\n-\n-impl IntEncodedWithFixedSize {\n-    pub const ENCODED_SIZE: usize = 8;\n-}\n-\n-impl<E: OpaqueEncoder> Encodable<E> for IntEncodedWithFixedSize {\n-    fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n-        let start_pos = e.position();\n-        for i in 0..IntEncodedWithFixedSize::ENCODED_SIZE {\n-            ((self.0 >> (i * 8)) as u8).encode(e)?;\n-        }\n-        let end_pos = e.position();\n-        assert_eq!((end_pos - start_pos), IntEncodedWithFixedSize::ENCODED_SIZE);\n-        Ok(())\n-    }\n-}\n-\n-impl<'a> Decodable<opaque::Decoder<'a>> for IntEncodedWithFixedSize {\n-    fn decode(decoder: &mut opaque::Decoder<'a>) -> Result<IntEncodedWithFixedSize, String> {\n-        let mut value: u64 = 0;\n-        let start_pos = decoder.position();\n-\n-        for i in 0..IntEncodedWithFixedSize::ENCODED_SIZE {\n-            let byte: u8 = Decodable::decode(decoder)?;\n-            value |= (byte as u64) << (i * 8);\n-        }\n-\n-        let end_pos = decoder.position();\n-        assert_eq!((end_pos - start_pos), IntEncodedWithFixedSize::ENCODED_SIZE);\n-\n-        Ok(IntEncodedWithFixedSize(value))\n-    }\n-}\n-\n pub fn encode_query_results<'a, 'tcx, CTX, Q>(\n     tcx: CTX,\n     encoder: &mut CacheEncoder<'a, 'tcx, FileEncoder>,"}, {"sha": "51945ab435eab164cd17befb99a94508bdf6b066", "filename": "compiler/rustc_serialize/src/json.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d04c3aa8656f6588c87bafafb34d51239dab98bb/compiler%2Frustc_serialize%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04c3aa8656f6588c87bafafb34d51239dab98bb/compiler%2Frustc_serialize%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fjson.rs?ref=d04c3aa8656f6588c87bafafb34d51239dab98bb", "patch": "@@ -188,6 +188,7 @@ use std::collections::{BTreeMap, HashMap};\n use std::io;\n use std::io::prelude::*;\n use std::mem::swap;\n+use std::mem::MaybeUninit;\n use std::num::FpCategory as Fp;\n use std::ops::Index;\n use std::str::FromStr;\n@@ -553,6 +554,12 @@ impl<'a> crate::Encoder for Encoder<'a> {\n     fn emit_str(&mut self, v: &str) -> EncodeResult {\n         escape_str(self.writer, v)\n     }\n+    fn emit_raw_bytes(&mut self, s: &[u8]) -> Result<(), Self::Error> {\n+        for &c in s.iter() {\n+            self.emit_u8(c)?;\n+        }\n+        Ok(())\n+    }\n \n     fn emit_enum<F>(&mut self, _name: &str, f: F) -> EncodeResult\n     where\n@@ -879,6 +886,12 @@ impl<'a> crate::Encoder for PrettyEncoder<'a> {\n     fn emit_str(&mut self, v: &str) -> EncodeResult {\n         escape_str(self.writer, v)\n     }\n+    fn emit_raw_bytes(&mut self, s: &[u8]) -> Result<(), Self::Error> {\n+        for &c in s.iter() {\n+            self.emit_u8(c)?;\n+        }\n+        Ok(())\n+    }\n \n     fn emit_enum<F>(&mut self, _name: &str, f: F) -> EncodeResult\n     where\n@@ -2354,6 +2367,14 @@ impl crate::Decoder for Decoder {\n         expect!(self.pop(), String).map(Cow::Owned)\n     }\n \n+    fn read_raw_bytes(&mut self, s: &mut [MaybeUninit<u8>]) -> Result<(), Self::Error> {\n+        for c in s.iter_mut() {\n+            let h = self.read_u8()?;\n+            unsafe { *c.as_mut_ptr() = h };\n+        }\n+        Ok(())\n+    }\n+\n     fn read_enum<T, F>(&mut self, _name: &str, f: F) -> DecodeResult<T>\n     where\n         F: FnOnce(&mut Decoder) -> DecodeResult<T>,"}, {"sha": "40b9522949d01c30e594b5e1b83b9a30a3c5780c", "filename": "compiler/rustc_serialize/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d04c3aa8656f6588c87bafafb34d51239dab98bb/compiler%2Frustc_serialize%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04c3aa8656f6588c87bafafb34d51239dab98bb/compiler%2Frustc_serialize%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Flib.rs?ref=d04c3aa8656f6588c87bafafb34d51239dab98bb", "patch": "@@ -17,6 +17,8 @@ Core encoding and decoding interfaces.\n #![feature(vec_spare_capacity)]\n #![feature(core_intrinsics)]\n #![feature(int_bits_const)]\n+#![feature(maybe_uninit_array_assume_init)]\n+#![feature(maybe_uninit_uninit_array)]\n #![feature(maybe_uninit_slice)]\n #![feature(new_uninit)]\n #![cfg_attr(test, feature(test))]"}, {"sha": "c171593ebdca604c96cc19d7d3a35de3df0981c0", "filename": "compiler/rustc_serialize/src/opaque.rs", "status": "modified", "additions": 76, "deletions": 34, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/d04c3aa8656f6588c87bafafb34d51239dab98bb/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04c3aa8656f6588c87bafafb34d51239dab98bb/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs?ref=d04c3aa8656f6588c87bafafb34d51239dab98bb", "patch": "@@ -1,5 +1,5 @@\n use crate::leb128::{self, max_leb128_len};\n-use crate::serialize;\n+use crate::serialize::{self, Decoder as _, Encoder as _};\n use std::borrow::Cow;\n use std::fs::File;\n use std::io::{self, Write};\n@@ -30,11 +30,6 @@ impl Encoder {\n     pub fn position(&self) -> usize {\n         self.data.len()\n     }\n-\n-    #[inline]\n-    pub fn emit_raw_bytes(&mut self, s: &[u8]) {\n-        self.data.extend_from_slice(s);\n-    }\n }\n \n macro_rules! write_leb128 {\n@@ -154,7 +149,12 @@ impl serialize::Encoder for Encoder {\n     #[inline]\n     fn emit_str(&mut self, v: &str) -> EncodeResult {\n         self.emit_usize(v.len())?;\n-        self.emit_raw_bytes(v.as_bytes());\n+        self.emit_raw_bytes(v.as_bytes())\n+    }\n+\n+    #[inline]\n+    fn emit_raw_bytes(&mut self, s: &[u8]) -> EncodeResult {\n+        self.data.extend_from_slice(s);\n         Ok(())\n     }\n }\n@@ -208,11 +208,6 @@ impl FileEncoder {\n         self.flushed + self.buffered\n     }\n \n-    #[inline]\n-    pub fn emit_raw_bytes(&mut self, s: &[u8]) -> FileEncodeResult {\n-        self.write_all(s)\n-    }\n-\n     pub fn flush(&mut self) -> FileEncodeResult {\n         // This is basically a copy of `BufWriter::flush`. If `BufWriter` ever\n         // offers a raw buffer access API, we can use it, and remove this.\n@@ -508,6 +503,11 @@ impl serialize::Encoder for FileEncoder {\n         self.emit_usize(v.len())?;\n         self.emit_raw_bytes(v.as_bytes())\n     }\n+\n+    #[inline]\n+    fn emit_raw_bytes(&mut self, s: &[u8]) -> FileEncodeResult {\n+        self.write_all(s)\n+    }\n }\n \n // -----------------------------------------------------------------------------\n@@ -539,26 +539,6 @@ impl<'a> Decoder<'a> {\n     pub fn advance(&mut self, bytes: usize) {\n         self.position += bytes;\n     }\n-\n-    #[inline]\n-    pub fn read_raw_bytes(&mut self, s: &mut [MaybeUninit<u8>]) -> Result<(), String> {\n-        let start = self.position;\n-        let end = start + s.len();\n-        assert!(end <= self.data.len());\n-\n-        // SAFETY: Both `src` and `dst` point to at least `s.len()` elements:\n-        // `src` points to at least `s.len()` elements by above assert, and\n-        // `dst` points to `s.len()` elements by derivation from `s`.\n-        unsafe {\n-            let src = self.data.as_ptr().add(start);\n-            let dst = s.as_mut_ptr() as *mut u8;\n-            ptr::copy_nonoverlapping(src, dst, s.len());\n-        }\n-\n-        self.position = end;\n-\n-        Ok(())\n-    }\n }\n \n macro_rules! read_leb128 {\n@@ -677,6 +657,26 @@ impl<'a> serialize::Decoder for Decoder<'a> {\n     fn error(&mut self, err: &str) -> Self::Error {\n         err.to_string()\n     }\n+\n+    #[inline]\n+    fn read_raw_bytes(&mut self, s: &mut [MaybeUninit<u8>]) -> Result<(), String> {\n+        let start = self.position;\n+        let end = start + s.len();\n+        assert!(end <= self.data.len());\n+\n+        // SAFETY: Both `src` and `dst` point to at least `s.len()` elements:\n+        // `src` points to at least `s.len()` elements by above assert, and\n+        // `dst` points to `s.len()` elements by derivation from `s`.\n+        unsafe {\n+            let src = self.data.as_ptr().add(start);\n+            let dst = s.as_mut_ptr() as *mut u8;\n+            ptr::copy_nonoverlapping(src, dst, s.len());\n+        }\n+\n+        self.position = end;\n+\n+        Ok(())\n+    }\n }\n \n // Specializations for contiguous byte sequences follow. The default implementations for slices\n@@ -689,8 +689,7 @@ impl<'a> serialize::Decoder for Decoder<'a> {\n impl serialize::Encodable<Encoder> for [u8] {\n     fn encode(&self, e: &mut Encoder) -> EncodeResult {\n         serialize::Encoder::emit_usize(e, self.len())?;\n-        e.emit_raw_bytes(self);\n-        Ok(())\n+        e.emit_raw_bytes(self)\n     }\n }\n \n@@ -718,3 +717,46 @@ impl<'a> serialize::Decodable<Decoder<'a>> for Vec<u8> {\n         Ok(v)\n     }\n }\n+\n+// An integer that will always encode to 8 bytes.\n+pub struct IntEncodedWithFixedSize(pub u64);\n+\n+impl IntEncodedWithFixedSize {\n+    pub const ENCODED_SIZE: usize = 8;\n+}\n+\n+impl serialize::Encodable<Encoder> for IntEncodedWithFixedSize {\n+    #[inline]\n+    fn encode(&self, e: &mut Encoder) -> EncodeResult {\n+        let _start_pos = e.position();\n+        e.emit_raw_bytes(&self.0.to_le_bytes())?;\n+        let _end_pos = e.position();\n+        debug_assert_eq!((_end_pos - _start_pos), IntEncodedWithFixedSize::ENCODED_SIZE);\n+        Ok(())\n+    }\n+}\n+\n+impl serialize::Encodable<FileEncoder> for IntEncodedWithFixedSize {\n+    #[inline]\n+    fn encode(&self, e: &mut FileEncoder) -> FileEncodeResult {\n+        let _start_pos = e.position();\n+        e.emit_raw_bytes(&self.0.to_le_bytes())?;\n+        let _end_pos = e.position();\n+        debug_assert_eq!((_end_pos - _start_pos), IntEncodedWithFixedSize::ENCODED_SIZE);\n+        Ok(())\n+    }\n+}\n+\n+impl<'a> serialize::Decodable<Decoder<'a>> for IntEncodedWithFixedSize {\n+    #[inline]\n+    fn decode(decoder: &mut Decoder<'a>) -> Result<IntEncodedWithFixedSize, String> {\n+        let mut bytes = MaybeUninit::uninit_array();\n+        let _start_pos = decoder.position();\n+        decoder.read_raw_bytes(&mut bytes)?;\n+        let _end_pos = decoder.position();\n+        debug_assert_eq!((_end_pos - _start_pos), IntEncodedWithFixedSize::ENCODED_SIZE);\n+\n+        let value = u64::from_le_bytes(unsafe { MaybeUninit::array_assume_init(bytes) });\n+        Ok(IntEncodedWithFixedSize(value))\n+    }\n+}"}, {"sha": "a3b02b7c34abab1d8e37160d305f1436401fb68b", "filename": "compiler/rustc_serialize/src/serialize.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d04c3aa8656f6588c87bafafb34d51239dab98bb/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04c3aa8656f6588c87bafafb34d51239dab98bb/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs?ref=d04c3aa8656f6588c87bafafb34d51239dab98bb", "patch": "@@ -7,6 +7,7 @@ Core encoding and decoding interfaces.\n use std::borrow::Cow;\n use std::cell::{Cell, RefCell};\n use std::marker::PhantomData;\n+use std::mem::MaybeUninit;\n use std::path;\n use std::rc::Rc;\n use std::sync::Arc;\n@@ -33,6 +34,7 @@ pub trait Encoder {\n     fn emit_f32(&mut self, v: f32) -> Result<(), Self::Error>;\n     fn emit_char(&mut self, v: char) -> Result<(), Self::Error>;\n     fn emit_str(&mut self, v: &str) -> Result<(), Self::Error>;\n+    fn emit_raw_bytes(&mut self, s: &[u8]) -> Result<(), Self::Error>;\n \n     // Compound types:\n     #[inline]\n@@ -224,6 +226,7 @@ pub trait Decoder {\n     fn read_f32(&mut self) -> Result<f32, Self::Error>;\n     fn read_char(&mut self) -> Result<char, Self::Error>;\n     fn read_str(&mut self) -> Result<Cow<'_, str>, Self::Error>;\n+    fn read_raw_bytes(&mut self, s: &mut [MaybeUninit<u8>]) -> Result<(), Self::Error>;\n \n     // Compound types:\n     #[inline]"}]}