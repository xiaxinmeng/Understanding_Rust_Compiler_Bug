{"sha": "48ba50e10c275c55d5480a5102e53bdb5a977ad7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4YmE1MGUxMGMyNzVjNTVkNTQ4MGE1MTAyZTUzYmRiNWE5NzdhZDc=", "commit": {"author": {"name": "Basile Desloges", "email": "basile.desloges@gmail.com", "date": "2018-02-07T10:50:11Z"}, "committer": {"name": "Basile Desloges", "email": "basile.desloges@gmail.com", "date": "2018-03-08T21:28:51Z"}, "message": "Update \"type parameters from outer function\" error messages", "tree": {"sha": "df5a7ec569956136596ecb205278f805be443f5c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df5a7ec569956136596ecb205278f805be443f5c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/48ba50e10c275c55d5480a5102e53bdb5a977ad7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/48ba50e10c275c55d5480a5102e53bdb5a977ad7", "html_url": "https://github.com/rust-lang/rust/commit/48ba50e10c275c55d5480a5102e53bdb5a977ad7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/48ba50e10c275c55d5480a5102e53bdb5a977ad7/comments", "author": {"login": "zilbuz", "id": 434964, "node_id": "MDQ6VXNlcjQzNDk2NA==", "avatar_url": "https://avatars.githubusercontent.com/u/434964?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zilbuz", "html_url": "https://github.com/zilbuz", "followers_url": "https://api.github.com/users/zilbuz/followers", "following_url": "https://api.github.com/users/zilbuz/following{/other_user}", "gists_url": "https://api.github.com/users/zilbuz/gists{/gist_id}", "starred_url": "https://api.github.com/users/zilbuz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zilbuz/subscriptions", "organizations_url": "https://api.github.com/users/zilbuz/orgs", "repos_url": "https://api.github.com/users/zilbuz/repos", "events_url": "https://api.github.com/users/zilbuz/events{/privacy}", "received_events_url": "https://api.github.com/users/zilbuz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "zilbuz", "id": 434964, "node_id": "MDQ6VXNlcjQzNDk2NA==", "avatar_url": "https://avatars.githubusercontent.com/u/434964?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zilbuz", "html_url": "https://github.com/zilbuz", "followers_url": "https://api.github.com/users/zilbuz/followers", "following_url": "https://api.github.com/users/zilbuz/following{/other_user}", "gists_url": "https://api.github.com/users/zilbuz/gists{/gist_id}", "starred_url": "https://api.github.com/users/zilbuz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zilbuz/subscriptions", "organizations_url": "https://api.github.com/users/zilbuz/orgs", "repos_url": "https://api.github.com/users/zilbuz/repos", "events_url": "https://api.github.com/users/zilbuz/events{/privacy}", "received_events_url": "https://api.github.com/users/zilbuz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b3164f3ab4720c6596c7e789c0281489c62347e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3164f3ab4720c6596c7e789c0281489c62347e7", "html_url": "https://github.com/rust-lang/rust/commit/b3164f3ab4720c6596c7e789c0281489c62347e7"}], "stats": {"total": 128, "additions": 122, "deletions": 6}, "files": [{"sha": "a6b776125ae97491b25cd7545750ef99a5f911b5", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 122, "deletions": 6, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/48ba50e10c275c55d5480a5102e53bdb5a977ad7/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ba50e10c275c55d5480a5102e53bdb5a977ad7/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=48ba50e10c275c55d5480a5102e53bdb5a977ad7", "patch": "@@ -41,7 +41,7 @@ use rustc::ty;\n use rustc::hir::{Freevar, FreevarMap, TraitCandidate, TraitMap, GlobMap};\n use rustc::util::nodemap::{NodeMap, NodeSet, FxHashMap, FxHashSet, DefIdMap};\n \n-use syntax::codemap::{dummy_spanned, respan};\n+use syntax::codemap::{dummy_spanned, respan, CodeMap};\n use syntax::ext::hygiene::{Mark, MarkKind, SyntaxContext};\n use syntax::ast::{self, Name, NodeId, Ident, SpannedIdent, FloatTy, IntTy, UintTy};\n use syntax::ext::base::SyntaxExtension;\n@@ -123,7 +123,7 @@ impl Ord for BindingError {\n \n enum ResolutionError<'a> {\n     /// error E0401: can't use type parameters from outer function\n-    TypeParametersFromOuterFunction,\n+    TypeParametersFromOuterFunction(Def),\n     /// error E0403: the name is already used for a type parameter in this type parameter list\n     NameAlreadyUsedInTypeParameterList(Name, &'a Span),\n     /// error E0407: method is not a member of trait\n@@ -173,13 +173,49 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n                                    resolution_error: ResolutionError<'a>)\n                                    -> DiagnosticBuilder<'sess> {\n     match resolution_error {\n-        ResolutionError::TypeParametersFromOuterFunction => {\n+        ResolutionError::TypeParametersFromOuterFunction(outer_def) => {\n             let mut err = struct_span_err!(resolver.session,\n                                            span,\n                                            E0401,\n-                                           \"can't use type parameters from outer function; \\\n-                                           try using a local type parameter instead\");\n+                                           \"can't use type parameters from outer function\");\n             err.span_label(span, \"use of type variable from outer function\");\n+            match outer_def {\n+                Def::SelfTy(_, maybe_impl_defid) => {\n+                    if let Some(impl_span) = maybe_impl_defid.map_or(None,\n+                            |def_id| resolver.definitions.opt_span(def_id)) {\n+                        let cm = resolver.session.codemap();\n+                        err.span_label(reduce_impl_span_to_impl_keyword(cm, impl_span),\n+                                    \"`Self` type implicitely declared here, on the `impl`\");\n+                    }\n+                },\n+                Def::TyParam(typaram_defid) => {\n+                    if let Some(typaram_span) = resolver.definitions.opt_span(typaram_defid) {\n+                        err.span_label(typaram_span, \"type variable from outer function\");\n+                    }\n+                },\n+                Def::Mod(..) | Def::Struct(..) | Def::Union(..) | Def::Enum(..) | Def::Variant(..) |\n+                Def::Trait(..) | Def::TyAlias(..) | Def::TyForeign(..) | Def::TraitAlias(..) |\n+                Def::AssociatedTy(..) | Def::PrimTy(..) | Def::Fn(..) | Def::Const(..) |\n+                Def::Static(..) | Def::StructCtor(..) | Def::VariantCtor(..) | Def::Method(..) |\n+                Def::AssociatedConst(..) | Def::Local(..) | Def::Upvar(..) | Def::Label(..) |\n+                Def::Macro(..) | Def::GlobalAsm(..) | Def::Err =>\n+                    bug!(\"TypeParametersFromOuterFunction should only be used with Def::SelfTy or \\\n+                         Def::TyParam\")\n+            }\n+\n+            // Try to retrieve the span of the function signature and generate a new message with\n+            // a local type parameter\n+            let sugg_msg = \"try using a local type parameter instead\";\n+            if let Some((sugg_span, new_snippet)) = generate_local_type_param_snippet(\n+                                                        resolver.session.codemap(), span) {\n+                // Suggest the modification to the user\n+                err.span_suggestion(sugg_span,\n+                                    sugg_msg,\n+                                    new_snippet);\n+            } else {\n+                err.help(\"try using a local type parameter instead\");\n+            }\n+\n             err\n         }\n         ResolutionError::NameAlreadyUsedInTypeParameterList(name, first_use_span) => {\n@@ -358,6 +394,86 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n     }\n }\n \n+/// Adjust the impl span so that just the `impl` keyword is taken by removing\n+/// everything after `<` (`\"impl<T> Iterator for A<T> {}\" -> \"impl\"`) and\n+/// everything after the first whitespace (`\"impl Iterator for A\" -> \"impl\"`)\n+///\n+/// Attention: The method used is very fragile since it essentially duplicates the work of the\n+/// parser. If you need to use this function or something similar, please consider updating the\n+/// codemap functions and this function to something more robust.\n+fn reduce_impl_span_to_impl_keyword(cm: &CodeMap, impl_span: Span) -> Span {\n+    let impl_span = cm.span_until_char(impl_span, '<');\n+    let impl_span = cm.span_until_whitespace(impl_span);\n+    impl_span\n+}\n+\n+/// Take the span of a type parameter in a function signature and try to generate a span for the\n+/// function name (with generics) and a new snippet for this span with the pointed type parameter as\n+/// a new local type parameter.\n+///\n+/// For instance:\n+/// ```\n+/// // Given span\n+/// fn my_function(param: T)\n+///                       ^ Original span\n+///\n+/// // Result\n+/// fn my_function(param: T)\n+///    ^^^^^^^^^^^ Generated span with snippet `my_function<T>`\n+/// ```\n+///\n+/// Attention: The method used is very fragile since it essentially duplicates the work of the\n+/// parser. If you need to use this function or something similar, please consider updating the\n+/// codemap functions and this function to something more robust.\n+fn generate_local_type_param_snippet(cm: &CodeMap, span: Span) -> Option<(Span, String)> {\n+    // Try to extend the span to the previous \"fn\" keyword to retrieve the function\n+    // signature\n+    let sugg_span = cm.span_extend_to_prev_str(span, \"fn\");\n+    if sugg_span != span {\n+        if let Ok(snippet) = cm.span_to_snippet(sugg_span) {\n+            use syntax::codemap::BytePos;\n+\n+            // Consume the function name\n+            let mut offset = 0;\n+            for c in snippet.chars().take_while(|c| c.is_ascii_alphanumeric() ||\n+                                                    *c == '_') {\n+                offset += c.len_utf8();\n+            }\n+\n+            // Consume the generics part of the function signature\n+            let mut bracket_counter = 0;\n+            let mut last_char = None;\n+            for c in snippet[offset..].chars() {\n+                match c {\n+                    '<' => bracket_counter += 1,\n+                    '>' => bracket_counter -= 1,\n+                    '(' => if bracket_counter == 0 { break; }\n+                    _ => {}\n+                }\n+                offset += c.len_utf8();\n+                last_char = Some(c);\n+            }\n+\n+            // Adjust the suggestion span to encompass the function name with its generics\n+            let sugg_span = sugg_span.with_hi(BytePos(sugg_span.lo().0 + offset as u32));\n+\n+            // Prepare the new suggested snippet to append the type parameter that triggered\n+            // the error in the generics of the function signature\n+            let mut new_snippet = if last_char == Some('>') {\n+                format!(\"{}, \", &snippet[..(offset - '>'.len_utf8())])\n+            } else {\n+                format!(\"{}<\", &snippet[..offset])\n+            };\n+            new_snippet.push_str(&cm.span_to_snippet(span).unwrap_or(\"T\".to_string()));\n+            new_snippet.push('>');\n+\n+            return Some((sugg_span, new_snippet));\n+        }\n+    }\n+\n+    None\n+}\n+\n #[derive(Copy, Clone, Debug)]\n struct BindingInfo {\n     span: Span,\n@@ -3280,7 +3396,7 @@ impl<'a> Resolver<'a> {\n                             // its scope.\n                             if record_used {\n                                 resolve_error(self, span,\n-                                              ResolutionError::TypeParametersFromOuterFunction);\n+                                    ResolutionError::TypeParametersFromOuterFunction(def));\n                             }\n                             return Def::Err;\n                         }"}]}