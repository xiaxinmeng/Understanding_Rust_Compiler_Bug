{"sha": "4e82f35492ea5c78e19609bf4468f0a686d9a756", "node_id": "C_kwDOAAsO6NoAKDRlODJmMzU0OTJlYTVjNzhlMTk2MDliZjQ0NjhmMGE2ODZkOWE3NTY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-24T22:29:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-24T22:29:14Z"}, "message": "Auto merge of #94333 - Dylan-DPC:rollup-7yxtywp, r=Dylan-DPC\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #91795 (resolve/metadata: Stop encoding macros as reexports)\n - #93714 (better ObligationCause for normalization errors in `can_type_implement_copy`)\n - #94175 (Improve `--check-cfg` implementation)\n - #94212 (Stop manually SIMDing in `swap_nonoverlapping`)\n - #94242 (properly handle fat pointers to uninhabitable types)\n - #94308 (Normalize main return type during mono item collection & codegen)\n - #94315 (update auto trait lint for `PhantomData`)\n - #94316 (Improve string literal unescaping)\n - #94327 (Avoid emitting full macro body into JSON errors)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "23fbd4cd23c587684432375a288e303b80be8051", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23fbd4cd23c587684432375a288e303b80be8051"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e82f35492ea5c78e19609bf4468f0a686d9a756", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e82f35492ea5c78e19609bf4468f0a686d9a756", "html_url": "https://github.com/rust-lang/rust/commit/4e82f35492ea5c78e19609bf4468f0a686d9a756", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e82f35492ea5c78e19609bf4468f0a686d9a756/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b043faba34ccc053a4d0110634c323f6c03765e", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b043faba34ccc053a4d0110634c323f6c03765e", "html_url": "https://github.com/rust-lang/rust/commit/4b043faba34ccc053a4d0110634c323f6c03765e"}, {"sha": "3bd163f4e8422db4c0de384b2b21bfaaecd2e5c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bd163f4e8422db4c0de384b2b21bfaaecd2e5c1", "html_url": "https://github.com/rust-lang/rust/commit/3bd163f4e8422db4c0de384b2b21bfaaecd2e5c1"}], "stats": {"total": 1346, "additions": 1078, "deletions": 268}, "files": [{"sha": "21183121e15a0df25ed56a4dc1943d28d3b1ffab", "filename": "compiler/rustc_ast/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Flib.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -16,6 +16,7 @@\n #![feature(min_specialization)]\n #![recursion_limit = \"256\"]\n #![feature(slice_internals)]\n+#![feature(stmt_expr_attributes)]\n \n #[macro_use]\n extern crate rustc_macros;"}, {"sha": "224afbd553fb8eca0d5fd9efe15f4f7372bfea92", "filename": "compiler/rustc_ast/src/util/literal.rs", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -56,25 +56,30 @@ impl LitKind {\n                 // new symbol because the string in the LitKind is different to the\n                 // string in the token.\n                 let s = symbol.as_str();\n-                let symbol =\n-                    if s.contains(&['\\\\', '\\r']) {\n-                        let mut buf = String::with_capacity(s.len());\n-                        let mut error = Ok(());\n-                        unescape_literal(&s, Mode::Str, &mut |_, unescaped_char| {\n-                            match unescaped_char {\n-                                Ok(c) => buf.push(c),\n-                                Err(err) => {\n-                                    if err.is_fatal() {\n-                                        error = Err(LitError::LexerError);\n-                                    }\n+                let symbol = if s.contains(&['\\\\', '\\r']) {\n+                    let mut buf = String::with_capacity(s.len());\n+                    let mut error = Ok(());\n+                    // Force-inlining here is aggressive but the closure is\n+                    // called on every char in the string, so it can be\n+                    // hot in programs with many long strings.\n+                    unescape_literal(\n+                        &s,\n+                        Mode::Str,\n+                        &mut #[inline(always)]\n+                        |_, unescaped_char| match unescaped_char {\n+                            Ok(c) => buf.push(c),\n+                            Err(err) => {\n+                                if err.is_fatal() {\n+                                    error = Err(LitError::LexerError);\n                                 }\n                             }\n-                        });\n-                        error?;\n-                        Symbol::intern(&buf)\n-                    } else {\n-                        symbol\n-                    };\n+                        },\n+                    );\n+                    error?;\n+                    Symbol::intern(&buf)\n+                } else {\n+                    symbol\n+                };\n                 LitKind::Str(symbol, ast::StrStyle::Cooked)\n             }\n             token::StrRaw(n) => {"}, {"sha": "3ddc7fce1b770aee791d317d493e8778288f4521", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -444,8 +444,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             ),\n             ItemKind::MacroDef(MacroDef { ref body, macro_rules }) => {\n                 let body = P(self.lower_mac_args(body));\n-\n-                hir::ItemKind::Macro(ast::MacroDef { body, macro_rules })\n+                let macro_kind = self.resolver.decl_macro_kind(self.resolver.local_def_id(id));\n+                hir::ItemKind::Macro(ast::MacroDef { body, macro_rules }, macro_kind)\n             }\n             ItemKind::MacCall(..) => {\n                 panic!(\"`TyMac` should have been expanded by now\")"}, {"sha": "0156c5016acd1cd3cc8366de1493b08d9ca593b9", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -61,7 +61,7 @@ use rustc_session::lint::LintBuffer;\n use rustc_session::parse::feature_err;\n use rustc_session::utils::{FlattenNonterminals, NtToTokenstream};\n use rustc_session::Session;\n-use rustc_span::hygiene::ExpnId;\n+use rustc_span::hygiene::{ExpnId, MacroKind};\n use rustc_span::source_map::{respan, DesugaringKind};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n@@ -210,6 +210,8 @@ pub trait ResolverAstLowering {\n         expn_id: ExpnId,\n         span: Span,\n     ) -> LocalDefId;\n+\n+    fn decl_macro_kind(&self, def_id: LocalDefId) -> MacroKind;\n }\n \n /// Context of `impl Trait` in code, which determines whether it is allowed in an HIR subtree,"}, {"sha": "68b536da9f70f7b4119ff5c86716fe3156da6cd2", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -8,6 +8,7 @@ use rustc_errors::{struct_span_err, Applicability};\n use rustc_feature::{find_gated_cfg, is_builtin_attr_name, Features, GatedCfg};\n use rustc_macros::HashStable_Generic;\n use rustc_session::lint::builtin::UNEXPECTED_CFGS;\n+use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_session::parse::{feature_err, ParseSess};\n use rustc_session::Session;\n use rustc_span::hygiene::Transparency;\n@@ -461,29 +462,37 @@ pub fn cfg_matches(cfg: &ast::MetaItem, sess: &ParseSess, features: Option<&Feat\n                 true\n             }\n             MetaItemKind::NameValue(..) | MetaItemKind::Word => {\n-                let name = cfg.ident().expect(\"multi-segment cfg predicate\").name;\n+                let ident = cfg.ident().expect(\"multi-segment cfg predicate\");\n+                let name = ident.name;\n                 let value = cfg.value_str();\n-                if sess.check_config.names_checked && !sess.check_config.names_valid.contains(&name)\n-                {\n-                    sess.buffer_lint(\n-                        UNEXPECTED_CFGS,\n-                        cfg.span,\n-                        CRATE_NODE_ID,\n-                        \"unexpected `cfg` condition name\",\n-                    );\n-                }\n-                if let Some(val) = value {\n-                    if sess.check_config.values_checked.contains(&name)\n-                        && !sess.check_config.values_valid.contains(&(name, val))\n-                    {\n-                        sess.buffer_lint(\n+                if let Some(names_valid) = &sess.check_config.names_valid {\n+                    if !names_valid.contains(&name) {\n+                        sess.buffer_lint_with_diagnostic(\n                             UNEXPECTED_CFGS,\n                             cfg.span,\n                             CRATE_NODE_ID,\n-                            \"unexpected `cfg` condition value\",\n+                            \"unexpected `cfg` condition name\",\n+                            BuiltinLintDiagnostics::UnexpectedCfg(ident.span, name, None),\n                         );\n                     }\n                 }\n+                if let Some(value) = value {\n+                    if let Some(values) = &sess.check_config.values_valid.get(&name) {\n+                        if !values.contains(&value) {\n+                            sess.buffer_lint_with_diagnostic(\n+                                UNEXPECTED_CFGS,\n+                                cfg.span,\n+                                CRATE_NODE_ID,\n+                                \"unexpected `cfg` condition value\",\n+                                BuiltinLintDiagnostics::UnexpectedCfg(\n+                                    cfg.name_value_literal_span().unwrap(),\n+                                    name,\n+                                    Some(value),\n+                                ),\n+                            );\n+                        }\n+                    }\n+                }\n                 sess.config.contains(&(name, value))\n             }\n         }"}, {"sha": "2f71a70a4494615529fd859c4d86c3178a5fe0c0", "filename": "compiler/rustc_codegen_cranelift/src/main_shim.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -51,7 +51,10 @@ pub(crate) fn maybe_create_entry_wrapper(\n         // late-bound regions, since late-bound\n         // regions must appear in the argument\n         // listing.\n-        let main_ret_ty = tcx.erase_regions(main_ret_ty.no_bound_vars().unwrap());\n+        let main_ret_ty = tcx.normalize_erasing_regions(\n+            ty::ParamEnv::reveal_all(),\n+            main_ret_ty.no_bound_vars().unwrap(),\n+        );\n \n         let cmain_sig = Signature {\n             params: vec!["}, {"sha": "d515502d445a9050b55a7ab0ba396c4495f3a0eb", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -449,7 +449,10 @@ fn pointer_or_reference_metadata<'ll, 'tcx>(\n             // This is a thin pointer. Create a regular pointer type and give it the correct name.\n             debug_assert_eq!(\n                 (thin_pointer_size, thin_pointer_align),\n-                cx.size_and_align_of(ptr_type)\n+                cx.size_and_align_of(ptr_type),\n+                \"ptr_type={}, pointee_type={}\",\n+                ptr_type,\n+                pointee_type,\n             );\n \n             unsafe {"}, {"sha": "fa75463067f4766f16a6aed0f63c709252d1a986", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/utils.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Futils.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -4,9 +4,9 @@ use super::namespace::item_namespace;\n use super::CrateDebugContext;\n \n use rustc_hir::def_id::DefId;\n-use rustc_middle::ty::layout::LayoutOf;\n+use rustc_middle::ty::layout::{HasParamEnv, LayoutOf};\n use rustc_middle::ty::{self, DefIdTree, Ty};\n-use rustc_target::abi::Variants;\n+use tracing::trace;\n \n use crate::common::CodegenCx;\n use crate::llvm;\n@@ -63,38 +63,37 @@ pub(crate) fn fat_pointer_kind<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     pointee_ty: Ty<'tcx>,\n ) -> Option<FatPtrKind> {\n-    let layout = cx.layout_of(pointee_ty);\n+    let pointee_tail_ty = cx.tcx.struct_tail_erasing_lifetimes(pointee_ty, cx.param_env());\n+    let layout = cx.layout_of(pointee_tail_ty);\n+    trace!(\n+        \"fat_pointer_kind: {:?} has layout {:?} (is_unsized? {})\",\n+        pointee_tail_ty,\n+        layout,\n+        layout.is_unsized()\n+    );\n \n     if !layout.is_unsized() {\n         return None;\n     }\n \n-    match *pointee_ty.kind() {\n+    match *pointee_tail_ty.kind() {\n         ty::Str | ty::Slice(_) => Some(FatPtrKind::Slice),\n         ty::Dynamic(..) => Some(FatPtrKind::Dyn),\n-        ty::Adt(..) | ty::Tuple(..) if matches!(layout.variants, Variants::Single { .. }) => {\n-            let last_field_index = layout.fields.count() - 1;\n-            debug_assert!(\n-                (0..last_field_index)\n-                    .all(|field_index| { !layout.field(cx, field_index).is_unsized() })\n-            );\n-\n-            let unsized_field = layout.field(cx, last_field_index);\n-            debug_assert!(unsized_field.is_unsized());\n-            fat_pointer_kind(cx, unsized_field.ty)\n-        }\n         ty::Foreign(_) => {\n             // Assert that pointers to foreign types really are thin:\n             debug_assert_eq!(\n-                cx.size_of(cx.tcx.mk_imm_ptr(pointee_ty)),\n+                cx.size_of(cx.tcx.mk_imm_ptr(pointee_tail_ty)),\n                 cx.size_of(cx.tcx.mk_imm_ptr(cx.tcx.types.u8))\n             );\n             None\n         }\n         _ => {\n             // For all other pointee types we should already have returned None\n             // at the beginning of the function.\n-            panic!(\"fat_pointer_kind() - Encountered unexpected `pointee_ty`: {:?}\", pointee_ty)\n+            panic!(\n+                \"fat_pointer_kind() - Encountered unexpected `pointee_tail_ty`: {:?}\",\n+                pointee_tail_ty\n+            )\n         }\n     }\n }"}, {"sha": "11f32d92e44cd0bf45181e8f8fbd2ee925e702ea", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -407,7 +407,10 @@ pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         // late-bound regions, since late-bound\n         // regions must appear in the argument\n         // listing.\n-        let main_ret_ty = cx.tcx().erase_regions(main_ret_ty.no_bound_vars().unwrap());\n+        let main_ret_ty = cx.tcx().normalize_erasing_regions(\n+            ty::ParamEnv::reveal_all(),\n+            main_ret_ty.no_bound_vars().unwrap(),\n+        );\n \n         let Some(llfn) = cx.declare_c_main(llfty) else {\n             // FIXME: We should be smart and show a better diagnostic here."}, {"sha": "dc28d1bb4523496cf09107f8310fb658c6ae6565", "filename": "compiler/rustc_errors/src/json.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fjson.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -454,8 +454,14 @@ impl DiagnosticSpan {\n         let end = je.sm.lookup_char_pos(span.hi());\n         let backtrace_step = backtrace.next().map(|bt| {\n             let call_site = Self::from_span_full(bt.call_site, false, None, None, backtrace, je);\n-            let def_site_span =\n-                Self::from_span_full(bt.def_site, false, None, None, [].into_iter(), je);\n+            let def_site_span = Self::from_span_full(\n+                je.sm.guess_head_span(bt.def_site),\n+                false,\n+                None,\n+                None,\n+                [].into_iter(),\n+                je,\n+            );\n             Box::new(DiagnosticSpanMacroExpansion {\n                 span: call_site,\n                 macro_decl_name: bt.kind.descr(),"}, {"sha": "72c02932945ca063329ab10a3166aa0b03e17604", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -15,6 +15,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sorted_map::SortedMap;\n use rustc_index::vec::IndexVec;\n use rustc_macros::HashStable_Generic;\n+use rustc_span::hygiene::MacroKind;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{def_id::LocalDefId, BytePos, MultiSpan, Span, DUMMY_SP};\n@@ -2803,7 +2804,7 @@ pub enum ItemKind<'hir> {\n     /// A function declaration.\n     Fn(FnSig<'hir>, Generics<'hir>, BodyId),\n     /// A MBE macro definition (`macro_rules!` or `macro`).\n-    Macro(ast::MacroDef),\n+    Macro(ast::MacroDef, MacroKind),\n     /// A module.\n     Mod(Mod<'hir>),\n     /// An external module, e.g. `extern { .. }`."}, {"sha": "1b40f3d390ee59dedaaa266035821931afb96594", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -575,7 +575,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item<'v>) {\n             item.span,\n             item.hir_id(),\n         ),\n-        ItemKind::Macro(_) => {\n+        ItemKind::Macro(..) => {\n             visitor.visit_id(item.hir_id());\n         }\n         ItemKind::Mod(ref module) => {"}, {"sha": "b3042c61002c4fae7f129ea618ece77c66bffea3", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -570,7 +570,7 @@ impl<'a> State<'a> {\n                 self.end(); // need to close a box\n                 self.ann.nested(self, Nested::Body(body));\n             }\n-            hir::ItemKind::Macro(ref macro_def) => {\n+            hir::ItemKind::Macro(ref macro_def, _) => {\n                 self.print_mac_def(macro_def, &item.ident, item.span, |state| {\n                     state.print_visibility(&item.vis)\n                 });"}, {"sha": "91ced2a2d90e21e4f83fdf141a7e552a2aa5991b", "filename": "compiler/rustc_interface/src/interface.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Finterface.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -169,11 +169,12 @@ pub fn parse_check_cfg(specs: Vec<String>) -> CheckCfg {\n                     Ok(meta_item) if parser.token == token::Eof => {\n                         if let Some(args) = meta_item.meta_item_list() {\n                             if meta_item.has_name(sym::names) {\n-                                cfg.names_checked = true;\n+                                let names_valid =\n+                                    cfg.names_valid.get_or_insert_with(|| FxHashSet::default());\n                                 for arg in args {\n                                     if arg.is_word() && arg.ident().is_some() {\n                                         let ident = arg.ident().expect(\"multi-segment cfg key\");\n-                                        cfg.names_valid.insert(ident.name.to_string());\n+                                        names_valid.insert(ident.name.to_string());\n                                     } else {\n                                         error!(\"`names()` arguments must be simple identifers\");\n                                     }\n@@ -183,13 +184,16 @@ pub fn parse_check_cfg(specs: Vec<String>) -> CheckCfg {\n                                 if let Some((name, values)) = args.split_first() {\n                                     if name.is_word() && name.ident().is_some() {\n                                         let ident = name.ident().expect(\"multi-segment cfg key\");\n-                                        cfg.values_checked.insert(ident.to_string());\n+                                        let ident_values = cfg\n+                                            .values_valid\n+                                            .entry(ident.name.to_string())\n+                                            .or_insert_with(|| FxHashSet::default());\n+\n                                         for val in values {\n                                             if let Some(LitKind::Str(s, _)) =\n                                                 val.literal().map(|lit| &lit.kind)\n                                             {\n-                                                cfg.values_valid\n-                                                    .insert((ident.to_string(), s.to_string()));\n+                                                ident_values.insert(s.to_string());\n                                             } else {\n                                                 error!(\n                                                     \"`values()` arguments must be string literals\"\n@@ -219,7 +223,9 @@ pub fn parse_check_cfg(specs: Vec<String>) -> CheckCfg {\n             );\n         }\n \n-        cfg.names_valid.extend(cfg.values_checked.iter().cloned());\n+        if let Some(names_valid) = &mut cfg.names_valid {\n+            names_valid.extend(cfg.values_valid.keys().cloned());\n+        }\n         cfg\n     })\n }"}, {"sha": "97f9588ae1ef557a280a1cf1c93234c8d3b0c2ee", "filename": "compiler/rustc_lexer/src/unescape.rs", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -159,26 +159,8 @@ impl Mode {\n     }\n }\n \n-fn scan_escape(first_char: char, chars: &mut Chars<'_>, mode: Mode) -> Result<char, EscapeError> {\n-    if first_char != '\\\\' {\n-        // Previous character was not a slash, and we don't expect it to be\n-        // an escape-only character.\n-        return match first_char {\n-            '\\t' | '\\n' => Err(EscapeError::EscapeOnlyChar),\n-            '\\r' => Err(EscapeError::BareCarriageReturn),\n-            '\\'' if mode.in_single_quotes() => Err(EscapeError::EscapeOnlyChar),\n-            '\"' if mode.in_double_quotes() => Err(EscapeError::EscapeOnlyChar),\n-            _ => {\n-                if mode.is_bytes() && !first_char.is_ascii() {\n-                    // Byte literal can't be a non-ascii character.\n-                    return Err(EscapeError::NonAsciiCharInByte);\n-                }\n-                Ok(first_char)\n-            }\n-        };\n-    }\n-\n-    // Previous character is '\\\\', try to unescape it.\n+fn scan_escape(chars: &mut Chars<'_>, mode: Mode) -> Result<char, EscapeError> {\n+    // Previous character was '\\\\', unescape what follows.\n \n     let second_char = chars.next().ok_or(EscapeError::LoneSlash)?;\n \n@@ -270,9 +252,24 @@ fn scan_escape(first_char: char, chars: &mut Chars<'_>, mode: Mode) -> Result<ch\n     Ok(res)\n }\n \n+#[inline]\n+fn ascii_check(first_char: char, mode: Mode) -> Result<char, EscapeError> {\n+    if mode.is_bytes() && !first_char.is_ascii() {\n+        // Byte literal can't be a non-ascii character.\n+        Err(EscapeError::NonAsciiCharInByte)\n+    } else {\n+        Ok(first_char)\n+    }\n+}\n+\n fn unescape_char_or_byte(chars: &mut Chars<'_>, mode: Mode) -> Result<char, EscapeError> {\n     let first_char = chars.next().ok_or(EscapeError::ZeroChars)?;\n-    let res = scan_escape(first_char, chars, mode)?;\n+    let res = match first_char {\n+        '\\\\' => scan_escape(chars, mode),\n+        '\\n' | '\\t' | '\\'' => Err(EscapeError::EscapeOnlyChar),\n+        '\\r' => Err(EscapeError::BareCarriageReturn),\n+        _ => ascii_check(first_char, mode),\n+    }?;\n     if chars.next().is_some() {\n         return Err(EscapeError::MoreThanOneChar);\n     }\n@@ -303,12 +300,14 @@ where\n                         skip_ascii_whitespace(&mut chars, start, callback);\n                         continue;\n                     }\n-                    _ => scan_escape(first_char, &mut chars, mode),\n+                    _ => scan_escape(&mut chars, mode),\n                 }\n             }\n             '\\n' => Ok('\\n'),\n             '\\t' => Ok('\\t'),\n-            _ => scan_escape(first_char, &mut chars, mode),\n+            '\"' => Err(EscapeError::EscapeOnlyChar),\n+            '\\r' => Err(EscapeError::BareCarriageReturn),\n+            _ => ascii_check(first_char, mode),\n         };\n         let end = initial_len - chars.as_str().len();\n         callback(start..end, unescaped_char);"}, {"sha": "0a218c2d2558487a3a57dcb674435d833c9e61d6", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -51,7 +51,7 @@ use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{BytePos, InnerSpan, MultiSpan, Span};\n use rustc_target::abi::VariantIdx;\n-use rustc_trait_selection::traits::misc::can_type_implement_copy;\n+use rustc_trait_selection::traits::{self, misc::can_type_implement_copy};\n \n use crate::nonstandard_style::{method_context, MethodLateContext};\n \n@@ -764,7 +764,14 @@ impl<'tcx> LateLintPass<'tcx> for MissingCopyImplementations {\n         if ty.is_copy_modulo_regions(cx.tcx.at(item.span), param_env) {\n             return;\n         }\n-        if can_type_implement_copy(cx.tcx, param_env, ty).is_ok() {\n+        if can_type_implement_copy(\n+            cx.tcx,\n+            param_env,\n+            ty,\n+            traits::ObligationCause::misc(item.span, item.hir_id()),\n+        )\n+        .is_ok()\n+        {\n             cx.struct_span_lint(MISSING_COPY_IMPLEMENTATIONS, item.span, |lint| {\n                 lint.build(\n                     \"type could implement `Copy`; consider adding `impl \\"}, {"sha": "0c9defc4ceac41594cbe23a907840f1b262eba5c", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -765,7 +765,40 @@ pub trait LintContext: Sized {\n                 BuiltinLintDiagnostics::NamedAsmLabel(help) => {\n                     db.help(&help);\n                     db.note(\"see the asm section of Rust By Example <https://doc.rust-lang.org/nightly/rust-by-example/unsafe/asm.html#labels> for more information\");\n-                }\n+                },\n+                BuiltinLintDiagnostics::UnexpectedCfg(span, name, value) => {\n+                    let possibilities: Vec<Symbol> = if value.is_some() {\n+                        let Some(values) = &sess.parse_sess.check_config.values_valid.get(&name) else {\n+                            bug!(\"it shouldn't be possible to have a diagnostic on a value whose name is not in values\");\n+                        };\n+                        values.iter().map(|&s| s).collect()\n+                    } else {\n+                        let Some(names_valid) = &sess.parse_sess.check_config.names_valid else {\n+                            bug!(\"it shouldn't be possible to have a diagnostic on a name if name checking is not enabled\");\n+                        };\n+                        names_valid.iter().map(|s| *s).collect()\n+                    };\n+\n+                    // Show the full list if all possible values for a given name, but don't do it\n+                    // for names as the possibilities could be very long\n+                    if value.is_some() {\n+                        if !possibilities.is_empty() {\n+                            let mut possibilities = possibilities.iter().map(Symbol::as_str).collect::<Vec<_>>();\n+                            possibilities.sort();\n+\n+                            let possibilities = possibilities.join(\", \");\n+                            db.note(&format!(\"expected values for `{name}` are: {possibilities}\"));\n+                        } else {\n+                            db.note(&format!(\"no expected value for `{name}`\"));\n+                        }\n+                    }\n+\n+                    // Suggest the most probable if we found one\n+                    if let Some(best_match) = find_best_match_for_name(&possibilities, value.unwrap_or(name), None) {\n+                        let punctuation = if value.is_some() { \"\\\"\" } else { \"\" };\n+                        db.span_suggestion(span, \"did you mean\", format!(\"{punctuation}{best_match}{punctuation}\"), Applicability::MaybeIncorrect);\n+                    }\n+                },\n             }\n             // Rewrap `db`, and pass control to the user.\n             decorate(LintDiagnosticBuilder::new(db));"}, {"sha": "7182022d2529817d5f7bf9163e3d21289adccb6a", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -31,6 +31,7 @@\n #![feature(box_patterns)]\n #![feature(crate_visibility_modifier)]\n #![feature(if_let_guard)]\n+#![feature(iter_intersperse)]\n #![feature(iter_order_by)]\n #![feature(let_else)]\n #![feature(never_type)]"}, {"sha": "e9c62fc40065158ee61d38e29eec72663a17a6f5", "filename": "compiler/rustc_lint_defs/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -310,6 +310,7 @@ pub enum BuiltinLintDiagnostics {\n     BreakWithLabelAndLoop(Span),\n     NamedAsmLabel(String),\n     UnicodeTextFlow(Span, String),\n+    UnexpectedCfg(Span, Symbol, Option<Symbol>),\n }\n \n /// Lints that are buffered up early on in the `Session` before the"}, {"sha": "e5e0cce198f46078eb208d511b947e04e575008f", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -5,6 +5,7 @@ use crate::rmeta::table::{FixedSizeEncoding, Table};\n use crate::rmeta::*;\n \n use rustc_ast as ast;\n+use rustc_ast::ptr::P;\n use rustc_attr as attr;\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxHashMap;\n@@ -1076,6 +1077,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                         res,\n                         vis: ty::Visibility::Public,\n                         span: ident.span,\n+                        macro_rules: false,\n                     });\n                 }\n             }\n@@ -1087,17 +1089,19 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             for child_index in children.decode((self, sess)) {\n                 if let Some(ident) = self.opt_item_ident(child_index, sess) {\n                     let kind = self.def_kind(child_index);\n-                    if matches!(kind, DefKind::Macro(..)) {\n-                        // FIXME: Macros are currently encoded twice, once as items and once as\n-                        // reexports. We ignore the items here and only use the reexports.\n-                        continue;\n-                    }\n                     let def_id = self.local_def_id(child_index);\n                     let res = Res::Def(kind, def_id);\n                     let vis = self.get_visibility(child_index);\n                     let span = self.get_span(child_index, sess);\n+                    let macro_rules = match kind {\n+                        DefKind::Macro(..) => match self.kind(child_index) {\n+                            EntryKind::MacroDef(_, macro_rules) => macro_rules,\n+                            _ => unreachable!(),\n+                        },\n+                        _ => false,\n+                    };\n \n-                    callback(ModChild { ident, res, vis, span });\n+                    callback(ModChild { ident, res, vis, span, macro_rules });\n \n                     // For non-re-export structs and variants add their constructors to children.\n                     // Re-export lists automatically contain constructors when necessary.\n@@ -1109,7 +1113,13 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                                 let ctor_res =\n                                     Res::Def(DefKind::Ctor(CtorOf::Struct, ctor_kind), ctor_def_id);\n                                 let vis = self.get_visibility(ctor_def_id.index);\n-                                callback(ModChild { ident, res: ctor_res, vis, span });\n+                                callback(ModChild {\n+                                    ident,\n+                                    res: ctor_res,\n+                                    vis,\n+                                    span,\n+                                    macro_rules: false,\n+                                });\n                             }\n                         }\n                         DefKind::Variant => {\n@@ -1134,7 +1144,13 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                                     vis = ty::Visibility::Restricted(crate_def_id);\n                                 }\n                             }\n-                            callback(ModChild { ident, res: ctor_res, vis, span });\n+                            callback(ModChild {\n+                                ident,\n+                                res: ctor_res,\n+                                vis,\n+                                span,\n+                                macro_rules: false,\n+                            });\n                         }\n                         _ => {}\n                     }\n@@ -1402,9 +1418,11 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         tcx.arena.alloc_from_iter(self.root.exported_symbols.decode((self, tcx)))\n     }\n \n-    fn get_macro(self, id: DefIndex, sess: &Session) -> MacroDef {\n+    fn get_macro(self, id: DefIndex, sess: &Session) -> ast::MacroDef {\n         match self.kind(id) {\n-            EntryKind::MacroDef(macro_def) => macro_def.decode((self, sess)),\n+            EntryKind::MacroDef(mac_args, macro_rules) => {\n+                ast::MacroDef { body: P(mac_args.decode((self, sess))), macro_rules }\n+            }\n             _ => bug!(),\n         }\n     }"}, {"sha": "fae76f80c4bdebc794f804f4d3cd934981681bcb", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -1406,8 +1406,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n                 EntryKind::Fn(self.lazy(data))\n             }\n-            hir::ItemKind::Macro(ref macro_def) => {\n-                EntryKind::MacroDef(self.lazy(macro_def.clone()))\n+            hir::ItemKind::Macro(ref macro_def, _) => {\n+                EntryKind::MacroDef(self.lazy(&*macro_def.body), macro_def.macro_rules)\n             }\n             hir::ItemKind::Mod(ref m) => {\n                 return self.encode_info_for_mod(item.def_id, m);"}, {"sha": "a30cc034c4a969cd7dccb5a4c7b0195a51f3474c", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -2,7 +2,7 @@ use decoder::Metadata;\n use def_path_hash_map::DefPathHashMapRef;\n use table::{Table, TableBuilder};\n \n-use rustc_ast::{self as ast, MacroDef};\n+use rustc_ast as ast;\n use rustc_attr as attr;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::MetadataRef;\n@@ -350,7 +350,7 @@ enum EntryKind {\n     Fn(Lazy<FnData>),\n     ForeignFn(Lazy<FnData>),\n     Mod(Lazy<[ModChild]>),\n-    MacroDef(Lazy<MacroDef>),\n+    MacroDef(Lazy<ast::MacArgs>, /*macro_rules*/ bool),\n     ProcMacro(MacroKind),\n     Closure,\n     Generator,"}, {"sha": "ec20e888333dae68e6776a84936b678a045dd192", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -14,7 +14,6 @@ use rustc_hir::*;\n use rustc_index::vec::Idx;\n use rustc_middle::hir::nested_filter;\n use rustc_span::def_id::StableCrateId;\n-use rustc_span::hygiene::MacroKind;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n@@ -232,7 +231,7 @@ impl<'hir> Map<'hir> {\n                 ItemKind::Static(..) => DefKind::Static,\n                 ItemKind::Const(..) => DefKind::Const,\n                 ItemKind::Fn(..) => DefKind::Fn,\n-                ItemKind::Macro(..) => DefKind::Macro(MacroKind::Bang),\n+                ItemKind::Macro(_, macro_kind) => DefKind::Macro(macro_kind),\n                 ItemKind::Mod(..) => DefKind::Mod,\n                 ItemKind::OpaqueTy(..) => DefKind::OpaqueTy,\n                 ItemKind::TyAlias(..) => DefKind::TyAlias,"}, {"sha": "c8e78747d8e7b3a74ac53afb841bef9b9bd047dd", "filename": "compiler/rustc_middle/src/metadata.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_middle%2Fsrc%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_middle%2Fsrc%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmetadata.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -21,4 +21,6 @@ pub struct ModChild {\n     pub vis: ty::Visibility,\n     /// Span of the item.\n     pub span: Span,\n+    /// A proper `macro_rules` item (not a reexport).\n+    pub macro_rules: bool,\n }"}, {"sha": "2f88c45a2a38983915e53fd39257b6a58aa9d7f6", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -1270,7 +1270,10 @@ impl<'v> RootCollector<'_, 'v> {\n         // late-bound regions, since late-bound\n         // regions must appear in the argument\n         // listing.\n-        let main_ret_ty = self.tcx.erase_regions(main_ret_ty.no_bound_vars().unwrap());\n+        let main_ret_ty = self.tcx.normalize_erasing_regions(\n+            ty::ParamEnv::reveal_all(),\n+            main_ret_ty.no_bound_vars().unwrap(),\n+        );\n \n         let start_instance = Instance::resolve(\n             self.tcx,"}, {"sha": "b545961245ad707b850bf17803c7744d9b5c4c61", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -1951,7 +1951,7 @@ impl<'tcx> Visitor<'tcx> for CheckAttrVisitor<'tcx> {\n         // Historically we've run more checks on non-exported than exported macros,\n         // so this lets us continue to run them while maintaining backwards compatibility.\n         // In the long run, the checks should be harmonized.\n-        if let ItemKind::Macro(ref macro_def) = item.kind {\n+        if let ItemKind::Macro(ref macro_def, _) = item.kind {\n             let def_id = item.def_id.to_def_id();\n             if macro_def.macro_rules && !self.tcx.has_attr(def_id, sym::macro_export) {\n                 check_non_exported_macro_for_invalid_attrs(self.tcx, item);"}, {"sha": "3dd9995fa0081e7dc1d320db14d7aa7f27778d69", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -564,7 +564,7 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n             // privacy and mark them reachable.\n             DefKind::Macro(_) => {\n                 let item = self.tcx.hir().expect_item(def_id);\n-                if let hir::ItemKind::Macro(MacroDef { macro_rules: false, .. }) = item.kind {\n+                if let hir::ItemKind::Macro(MacroDef { macro_rules: false, .. }, _) = item.kind {\n                     if vis.is_accessible_from(module.to_def_id(), self.tcx) {\n                         self.update(def_id, level);\n                     }\n@@ -686,7 +686,7 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                     }\n                 }\n             }\n-            hir::ItemKind::Macro(ref macro_def) => {\n+            hir::ItemKind::Macro(ref macro_def, _) => {\n                 self.update_reachability_from_macro(item.def_id, macro_def);\n             }\n             hir::ItemKind::ForeignMod { items, .. } => {"}, {"sha": "61a9b644cb8f50069f89c2359f52c8cab9f81472", "filename": "compiler/rustc_resolve/src/access_levels.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_resolve%2Fsrc%2Faccess_levels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_resolve%2Fsrc%2Faccess_levels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Faccess_levels.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -133,7 +133,7 @@ impl<'r, 'ast> Visitor<'ast> for AccessLevelsVisitor<'ast, 'r> {\n             ast::ItemKind::Impl(..) => return,\n \n             // Only exported `macro_rules!` items are public, but they always are\n-            ast::ItemKind::MacroDef(..) => {\n+            ast::ItemKind::MacroDef(ref macro_def) if macro_def.macro_rules => {\n                 let is_macro_export =\n                     item.attrs.iter().any(|attr| attr.has_name(sym::macro_export));\n                 if is_macro_export { Some(AccessLevel::Public) } else { None }\n@@ -155,7 +155,8 @@ impl<'r, 'ast> Visitor<'ast> for AccessLevelsVisitor<'ast, 'r> {\n             | ast::ItemKind::Struct(..)\n             | ast::ItemKind::Union(..)\n             | ast::ItemKind::Trait(..)\n-            | ast::ItemKind::TraitAlias(..) => {\n+            | ast::ItemKind::TraitAlias(..)\n+            | ast::ItemKind::MacroDef(..) => {\n                 if item.vis.kind.is_pub() {\n                     self.prev_level\n                 } else {"}, {"sha": "6b70c9833448399c7b66251d0405bc48c1370059", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -940,7 +940,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n     /// Builds the reduced graph for a single item in an external crate.\n     fn build_reduced_graph_for_external_crate_res(&mut self, child: ModChild) {\n         let parent = self.parent_scope.module;\n-        let ModChild { ident, res, vis, span } = child;\n+        let ModChild { ident, res, vis, span, macro_rules } = child;\n         let res = res.expect_non_local();\n         let expansion = self.parent_scope.expansion;\n         // Record primary definitions.\n@@ -972,7 +972,9 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 _,\n             ) => self.r.define(parent, ident, ValueNS, (res, vis, span, expansion)),\n             Res::Def(DefKind::Macro(..), _) | Res::NonMacroAttr(..) => {\n-                self.r.define(parent, ident, MacroNS, (res, vis, span, expansion))\n+                if !macro_rules {\n+                    self.r.define(parent, ident, MacroNS, (res, vis, span, expansion))\n+                }\n             }\n             Res::Def(\n                 DefKind::TyParam"}, {"sha": "bf570fb0f80b00a75279c3b439dc22fad545bd24", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -1399,14 +1399,22 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         let mut reexports = Vec::new();\n \n         module.for_each_child(self.r, |_, ident, _, binding| {\n-            // Filter away ambiguous imports and anything that has def-site hygiene.\n-            // FIXME: Implement actual cross-crate hygiene.\n-            let is_good_import =\n-                binding.is_import() && !binding.is_ambiguity() && !ident.span.from_expansion();\n-            if is_good_import || binding.is_macro_def() {\n+            // FIXME: Consider changing the binding inserted by `#[macro_export] macro_rules`\n+            // into the crate root to actual `NameBindingKind::Import`.\n+            if binding.is_import()\n+                || matches!(binding.kind, NameBindingKind::Res(_, _is_macro_export @ true))\n+            {\n                 let res = binding.res().expect_non_local();\n-                if res != def::Res::Err {\n-                    reexports.push(ModChild { ident, res, vis: binding.vis, span: binding.span });\n+                // Ambiguous imports are treated as errors at this point and are\n+                // not exposed to other crates (see #36837 for more details).\n+                if res != def::Res::Err && !binding.is_ambiguity() {\n+                    reexports.push(ModChild {\n+                        ident,\n+                        res,\n+                        vis: binding.vis,\n+                        span: binding.span,\n+                        macro_rules: false,\n+                    });\n                 }\n             }\n         });"}, {"sha": "eed8aaed4ee09089e3b0c4fe749fec0ac42cec0a", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -845,10 +845,6 @@ impl<'a> NameBinding<'a> {\n         )\n     }\n \n-    fn is_macro_def(&self) -> bool {\n-        matches!(self.kind, NameBindingKind::Res(Res::Def(DefKind::Macro(..), _), _))\n-    }\n-\n     fn macro_kind(&self) -> Option<MacroKind> {\n         self.res().macro_kind()\n     }\n@@ -990,6 +986,9 @@ pub struct Resolver<'a> {\n     crate_loader: CrateLoader<'a>,\n     macro_names: FxHashSet<Ident>,\n     builtin_macros: FxHashMap<Symbol, BuiltinMacroState>,\n+    /// A small map keeping true kinds of built-in macros that appear to be fn-like on\n+    /// the surface (`macro` items in libcore), but are actually attributes or derives.\n+    builtin_macro_kinds: FxHashMap<LocalDefId, MacroKind>,\n     registered_attrs: FxHashSet<Ident>,\n     registered_tools: RegisteredTools,\n     macro_use_prelude: FxHashMap<Symbol, &'a NameBinding<'a>>,\n@@ -1261,6 +1260,10 @@ impl ResolverAstLowering for Resolver<'_> {\n \n         def_id\n     }\n+\n+    fn decl_macro_kind(&self, def_id: LocalDefId) -> MacroKind {\n+        self.builtin_macro_kinds.get(&def_id).copied().unwrap_or(MacroKind::Bang)\n+    }\n }\n \n impl<'a> Resolver<'a> {\n@@ -1381,6 +1384,7 @@ impl<'a> Resolver<'a> {\n             crate_loader: CrateLoader::new(session, metadata_loader, crate_name),\n             macro_names: FxHashSet::default(),\n             builtin_macros: Default::default(),\n+            builtin_macro_kinds: Default::default(),\n             registered_attrs,\n             registered_tools,\n             macro_use_prelude: FxHashMap::default(),"}, {"sha": "e34d3e605ecdf37653a3cdb3f28aa6b4c7d29005", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -1209,7 +1209,13 @@ impl<'a> Resolver<'a> {\n                 // while still taking everything else from the source code.\n                 // If we already loaded this builtin macro, give a better error message than 'no such builtin macro'.\n                 match mem::replace(builtin_macro, BuiltinMacroState::AlreadySeen(item.span)) {\n-                    BuiltinMacroState::NotYetSeen(ext) => result.kind = ext,\n+                    BuiltinMacroState::NotYetSeen(ext) => {\n+                        result.kind = ext;\n+                        if item.id != ast::DUMMY_NODE_ID {\n+                            self.builtin_macro_kinds\n+                                .insert(self.local_def_id(item.id), result.macro_kind());\n+                        }\n+                    }\n                     BuiltinMacroState::AlreadySeen(span) => {\n                         struct_span_err!(\n                             self.session,"}, {"sha": "8f50f44571953fb0b7a89ae8f2c6bbec6d00eab6", "filename": "compiler/rustc_save_analysis/src/sig.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_save_analysis%2Fsrc%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_save_analysis%2Fsrc%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fsig.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -416,7 +416,7 @@ impl<'hir> Sig for hir::Item<'hir> {\n \n                 Ok(sig)\n             }\n-            hir::ItemKind::Macro(_) => {\n+            hir::ItemKind::Macro(..) => {\n                 let mut text = \"macro\".to_owned();\n                 let name = self.ident.to_string();\n                 text.push_str(&name);"}, {"sha": "f9b75690e375fd253c97632dfe61ebb302486813", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -8,7 +8,7 @@ use crate::search_paths::SearchPath;\n use crate::utils::{CanonicalizedPath, NativeLib, NativeLibKind};\n use crate::{early_error, early_warn, Session};\n \n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::impl_stable_hash_via_hash;\n \n use rustc_target::abi::{Align, TargetDataLayout};\n@@ -1023,34 +1023,30 @@ pub fn to_crate_config(cfg: FxHashSet<(String, Option<String>)>) -> CrateConfig\n \n /// The parsed `--check-cfg` options\n pub struct CheckCfg<T = String> {\n-    /// Set if `names()` checking is enabled\n-    pub names_checked: bool,\n-    /// The union of all `names()`\n-    pub names_valid: FxHashSet<T>,\n-    /// The set of names for which `values()` was used\n-    pub values_checked: FxHashSet<T>,\n-    /// The set of all (name, value) pairs passed in `values()`\n-    pub values_valid: FxHashSet<(T, T)>,\n+    /// The set of all `names()`, if None no name checking is performed\n+    pub names_valid: Option<FxHashSet<T>>,\n+    /// The set of all `values()`\n+    pub values_valid: FxHashMap<T, FxHashSet<T>>,\n }\n \n impl<T> Default for CheckCfg<T> {\n     fn default() -> Self {\n-        CheckCfg {\n-            names_checked: false,\n-            names_valid: FxHashSet::default(),\n-            values_checked: FxHashSet::default(),\n-            values_valid: FxHashSet::default(),\n-        }\n+        CheckCfg { names_valid: Default::default(), values_valid: Default::default() }\n     }\n }\n \n impl<T> CheckCfg<T> {\n     fn map_data<O: Eq + Hash>(&self, f: impl Fn(&T) -> O) -> CheckCfg<O> {\n         CheckCfg {\n-            names_checked: self.names_checked,\n-            names_valid: self.names_valid.iter().map(|a| f(a)).collect(),\n-            values_checked: self.values_checked.iter().map(|a| f(a)).collect(),\n-            values_valid: self.values_valid.iter().map(|(a, b)| (f(a), f(b))).collect(),\n+            names_valid: self\n+                .names_valid\n+                .as_ref()\n+                .map(|names_valid| names_valid.iter().map(|a| f(a)).collect()),\n+            values_valid: self\n+                .values_valid\n+                .iter()\n+                .map(|(a, b)| (f(a), b.iter().map(|b| f(b)).collect()))\n+                .collect(),\n         }\n     }\n }\n@@ -1090,17 +1086,23 @@ impl CrateCheckConfig {\n             sym::doctest,\n             sym::feature,\n         ];\n-        for &name in WELL_KNOWN_NAMES {\n-            self.names_valid.insert(name);\n+        if let Some(names_valid) = &mut self.names_valid {\n+            for &name in WELL_KNOWN_NAMES {\n+                names_valid.insert(name);\n+            }\n         }\n     }\n \n     /// Fills a `CrateCheckConfig` with configuration names and values that are actually active.\n     pub fn fill_actual(&mut self, cfg: &CrateConfig) {\n         for &(k, v) in cfg {\n-            self.names_valid.insert(k);\n+            if let Some(names_valid) = &mut self.names_valid {\n+                names_valid.insert(k);\n+            }\n             if let Some(v) = v {\n-                self.values_valid.insert((k, v));\n+                self.values_valid.entry(k).and_modify(|values| {\n+                    values.insert(v);\n+                });\n             }\n         }\n     }"}, {"sha": "c293708dcc9296017383fca25f247c334f6a12f1", "filename": "compiler/rustc_trait_selection/src/traits/misc.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -20,6 +20,7 @@ pub fn can_type_implement_copy<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     self_type: Ty<'tcx>,\n+    cause: ObligationCause<'tcx>,\n ) -> Result<(), CopyImplementationError<'tcx>> {\n     // FIXME: (@jroesch) float this code up\n     tcx.infer_ctxt().enter(|infcx| {\n@@ -49,7 +50,19 @@ pub fn can_type_implement_copy<'tcx>(\n                     continue;\n                 }\n                 let span = tcx.def_span(field.did);\n-                let cause = ObligationCause::dummy_with_span(span);\n+                // FIXME(compiler-errors): This gives us better spans for bad\n+                // projection types like in issue-50480.\n+                // If the ADT has substs, point to the cause we are given.\n+                // If it does not, then this field probably doesn't normalize\n+                // to begin with, and point to the bad field's span instead.\n+                let cause = if field\n+                    .ty(tcx, traits::InternalSubsts::identity_for_item(tcx, adt.did))\n+                    .has_param_types_or_consts()\n+                {\n+                    cause.clone()\n+                } else {\n+                    ObligationCause::dummy_with_span(span)\n+                };\n                 let ctx = traits::FulfillmentContext::new();\n                 match traits::fully_normalize(&infcx, ctx, cause, param_env, ty) {\n                     Ok(ty) => {"}, {"sha": "a43f7f871167e27fb25217d874f5fb07d8bc6292", "filename": "compiler/rustc_typeck/src/coherence/builtin.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -74,7 +74,8 @@ fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n \n     debug!(\"visit_implementation_of_copy: self_type={:?} (free)\", self_type);\n \n-    match can_type_implement_copy(tcx, param_env, self_type) {\n+    let cause = traits::ObligationCause::misc(span, impl_hir_id);\n+    match can_type_implement_copy(tcx, param_env, self_type, cause) {\n         Ok(()) => {}\n         Err(CopyImplementationError::InfrigingFields(fields)) => {\n             let item = tcx.hir().expect_item(impl_did);"}, {"sha": "811136a7eb4ee573aeb6237f2592fef392e387de", "filename": "compiler/rustc_typeck/src/coherence/orphan.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -439,6 +439,7 @@ fn fast_reject_auto_impl<'tcx>(tcx: TyCtxt<'tcx>, trait_def_id: DefId, self_ty:\n             }\n \n             match t.kind() {\n+                ty::Adt(def, substs) if def.is_phantom_data() => substs.super_visit_with(self),\n                 ty::Adt(def, substs) => {\n                     // @lcnr: This is the only place where cycles can happen. We avoid this\n                     // by only visiting each `DefId` once."}, {"sha": "4a25b49eb2ddac6155263fca67094e5d9631c0ac", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -730,7 +730,7 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::ItemId) {\n         // These don't define types.\n         hir::ItemKind::ExternCrate(_)\n         | hir::ItemKind::Use(..)\n-        | hir::ItemKind::Macro(_)\n+        | hir::ItemKind::Macro(..)\n         | hir::ItemKind::Mod(_)\n         | hir::ItemKind::GlobalAsm(_) => {}\n         hir::ItemKind::ForeignMod { items, .. } => {"}, {"sha": "9b86a0ca97c09e266ea89b1c2b80e12078e2ecf7", "filename": "library/core/benches/slice.rs", "status": "modified", "additions": 39, "deletions": 4, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/library%2Fcore%2Fbenches%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/library%2Fcore%2Fbenches%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fbenches%2Fslice.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -89,6 +89,15 @@ fn binary_search_l3_worst_case(b: &mut Bencher) {\n     binary_search_worst_case(b, Cache::L3);\n }\n \n+#[derive(Clone)]\n+struct Rgb(u8, u8, u8);\n+\n+impl Rgb {\n+    fn gen(i: usize) -> Self {\n+        Rgb(i as u8, (i as u8).wrapping_add(7), (i as u8).wrapping_add(42))\n+    }\n+}\n+\n macro_rules! rotate {\n     ($fn:ident, $n:expr, $mapper:expr) => {\n         #[bench]\n@@ -104,17 +113,43 @@ macro_rules! rotate {\n     };\n }\n \n-#[derive(Clone)]\n-struct Rgb(u8, u8, u8);\n-\n rotate!(rotate_u8, 32, |i| i as u8);\n-rotate!(rotate_rgb, 32, |i| Rgb(i as u8, (i as u8).wrapping_add(7), (i as u8).wrapping_add(42)));\n+rotate!(rotate_rgb, 32, Rgb::gen);\n rotate!(rotate_usize, 32, |i| i);\n rotate!(rotate_16_usize_4, 16, |i| [i; 4]);\n rotate!(rotate_16_usize_5, 16, |i| [i; 5]);\n rotate!(rotate_64_usize_4, 64, |i| [i; 4]);\n rotate!(rotate_64_usize_5, 64, |i| [i; 5]);\n \n+macro_rules! swap_with_slice {\n+    ($fn:ident, $n:expr, $mapper:expr) => {\n+        #[bench]\n+        fn $fn(b: &mut Bencher) {\n+            let mut x = (0usize..$n).map(&$mapper).collect::<Vec<_>>();\n+            let mut y = ($n..($n * 2)).map(&$mapper).collect::<Vec<_>>();\n+            let mut skip = 0;\n+            b.iter(|| {\n+                for _ in 0..32 {\n+                    x[skip..].swap_with_slice(&mut y[..($n - skip)]);\n+                    skip = black_box(skip + 1) % 8;\n+                }\n+                black_box((x[$n / 3].clone(), y[$n * 2 / 3].clone()))\n+            })\n+        }\n+    };\n+}\n+\n+swap_with_slice!(swap_with_slice_u8_30, 30, |i| i as u8);\n+swap_with_slice!(swap_with_slice_u8_3000, 3000, |i| i as u8);\n+swap_with_slice!(swap_with_slice_rgb_30, 30, Rgb::gen);\n+swap_with_slice!(swap_with_slice_rgb_3000, 3000, Rgb::gen);\n+swap_with_slice!(swap_with_slice_usize_30, 30, |i| i);\n+swap_with_slice!(swap_with_slice_usize_3000, 3000, |i| i);\n+swap_with_slice!(swap_with_slice_4x_usize_30, 30, |i| [i; 4]);\n+swap_with_slice!(swap_with_slice_4x_usize_3000, 3000, |i| [i; 4]);\n+swap_with_slice!(swap_with_slice_5x_usize_30, 30, |i| [i; 5]);\n+swap_with_slice!(swap_with_slice_5x_usize_3000, 3000, |i| [i; 5]);\n+\n #[bench]\n fn fill_byte_sized(b: &mut Bencher) {\n     #[derive(Copy, Clone)]"}, {"sha": "b5c1ae37e5e89091047e583cd43217697c50c275", "filename": "library/core/src/mem/mod.rs", "status": "modified", "additions": 42, "deletions": 3, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -700,10 +700,49 @@ pub unsafe fn uninitialized<T>() -> T {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_const_unstable(feature = \"const_swap\", issue = \"83163\")]\n pub const fn swap<T>(x: &mut T, y: &mut T) {\n-    // SAFETY: the raw pointers have been created from safe mutable references satisfying all the\n-    // constraints on `ptr::swap_nonoverlapping_one`\n+    // NOTE(eddyb) SPIR-V's Logical addressing model doesn't allow for arbitrary\n+    // reinterpretation of values as (chunkable) byte arrays, and the loop in the\n+    // block optimization in `swap_slice` is hard to rewrite back\n+    // into the (unoptimized) direct swapping implementation, so we disable it.\n+    // FIXME(eddyb) the block optimization also prevents MIR optimizations from\n+    // understanding `mem::replace`, `Option::take`, etc. - a better overall\n+    // solution might be to make `ptr::swap_nonoverlapping` into an intrinsic, which\n+    // a backend can choose to implement using the block optimization, or not.\n+    #[cfg(not(target_arch = \"spirv\"))]\n+    {\n+        // For types that are larger multiples of their alignment, the simple way\n+        // tends to copy the whole thing to stack rather than doing it one part\n+        // at a time, so instead treat them as one-element slices and piggy-back\n+        // the slice optimizations that will split up the swaps.\n+        if size_of::<T>() / align_of::<T>() > 4 {\n+            // SAFETY: exclusive references always point to one non-overlapping\n+            // element and are non-null and properly aligned.\n+            return unsafe { ptr::swap_nonoverlapping(x, y, 1) };\n+        }\n+    }\n+\n+    // If a scalar consists of just a small number of alignment units, let\n+    // the codegen just swap those pieces directly, as it's likely just a\n+    // few instructions and anything else is probably overcomplicated.\n+    //\n+    // Most importantly, this covers primitives and simd types that tend to\n+    // have size=align where doing anything else can be a pessimization.\n+    // (This will also be used for ZSTs, though any solution works for them.)\n+    swap_simple(x, y);\n+}\n+\n+/// Same as [`swap`] semantically, but always uses the simple implementation.\n+///\n+/// Used elsewhere in `mem` and `ptr` at the bottom layer of calls.\n+#[rustc_const_unstable(feature = \"const_swap\", issue = \"83163\")]\n+#[inline]\n+pub(crate) const fn swap_simple<T>(x: &mut T, y: &mut T) {\n+    // SAFETY: exclusive references are always valid to read/write,\n+    // are non-overlapping, and nothing here panics so it's drop-safe.\n     unsafe {\n-        ptr::swap_nonoverlapping_one(x, y);\n+        let z = ptr::read(x);\n+        ptr::copy_nonoverlapping(y, x, 1);\n+        ptr::write(y, z);\n     }\n }\n "}, {"sha": "ff71fadb614182e942ce9a2d1a93a4916c211ecb", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 42, "deletions": 90, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -419,106 +419,58 @@ pub const unsafe fn swap<T>(x: *mut T, y: *mut T) {\n #[stable(feature = \"swap_nonoverlapping\", since = \"1.27.0\")]\n #[rustc_const_unstable(feature = \"const_swap\", issue = \"83163\")]\n pub const unsafe fn swap_nonoverlapping<T>(x: *mut T, y: *mut T, count: usize) {\n-    let x = x as *mut u8;\n-    let y = y as *mut u8;\n-    let len = mem::size_of::<T>() * count;\n-    // SAFETY: the caller must guarantee that `x` and `y` are\n-    // valid for writes and properly aligned.\n-    unsafe { swap_nonoverlapping_bytes(x, y, len) }\n-}\n+    macro_rules! attempt_swap_as_chunks {\n+        ($ChunkTy:ty) => {\n+            if mem::align_of::<T>() >= mem::align_of::<$ChunkTy>()\n+                && mem::size_of::<T>() % mem::size_of::<$ChunkTy>() == 0\n+            {\n+                let x: *mut MaybeUninit<$ChunkTy> = x.cast();\n+                let y: *mut MaybeUninit<$ChunkTy> = y.cast();\n+                let count = count * (mem::size_of::<T>() / mem::size_of::<$ChunkTy>());\n+                // SAFETY: these are the same bytes that the caller promised were\n+                // ok, just typed as `MaybeUninit<ChunkTy>`s instead of as `T`s.\n+                // The `if` condition above ensures that we're not violating\n+                // alignment requirements, and that the division is exact so\n+                // that we don't lose any bytes off the end.\n+                return unsafe { swap_nonoverlapping_simple(x, y, count) };\n+            }\n+        };\n+    }\n \n-#[inline]\n-#[rustc_const_unstable(feature = \"const_swap\", issue = \"83163\")]\n-pub(crate) const unsafe fn swap_nonoverlapping_one<T>(x: *mut T, y: *mut T) {\n-    // NOTE(eddyb) SPIR-V's Logical addressing model doesn't allow for arbitrary\n-    // reinterpretation of values as (chunkable) byte arrays, and the loop in the\n-    // block optimization in `swap_nonoverlapping_bytes` is hard to rewrite back\n-    // into the (unoptimized) direct swapping implementation, so we disable it.\n-    // FIXME(eddyb) the block optimization also prevents MIR optimizations from\n-    // understanding `mem::replace`, `Option::take`, etc. - a better overall\n-    // solution might be to make `swap_nonoverlapping` into an intrinsic, which\n-    // a backend can choose to implement using the block optimization, or not.\n-    #[cfg(not(target_arch = \"spirv\"))]\n+    // Split up the slice into small power-of-two-sized chunks that LLVM is able\n+    // to vectorize (unless it's a special type with more-than-pointer alignment,\n+    // because we don't want to pessimize things like slices of SIMD vectors.)\n+    if mem::align_of::<T>() <= mem::size_of::<usize>()\n+        && (!mem::size_of::<T>().is_power_of_two()\n+            || mem::size_of::<T>() > mem::size_of::<usize>() * 2)\n     {\n-        // Only apply the block optimization in `swap_nonoverlapping_bytes` for types\n-        // at least as large as the block size, to avoid pessimizing codegen.\n-        if mem::size_of::<T>() >= 32 {\n-            // SAFETY: the caller must uphold the safety contract for `swap_nonoverlapping`.\n-            unsafe { swap_nonoverlapping(x, y, 1) };\n-            return;\n-        }\n+        attempt_swap_as_chunks!(usize);\n+        attempt_swap_as_chunks!(u8);\n     }\n \n-    // Direct swapping, for the cases not going through the block optimization.\n-    // SAFETY: the caller must guarantee that `x` and `y` are valid\n-    // for writes, properly aligned, and non-overlapping.\n-    unsafe {\n-        let z = read(x);\n-        copy_nonoverlapping(y, x, 1);\n-        write(y, z);\n-    }\n+    // SAFETY: Same preconditions as this function\n+    unsafe { swap_nonoverlapping_simple(x, y, count) }\n }\n \n+/// Same behaviour and safety conditions as [`swap_nonoverlapping`]\n+///\n+/// LLVM can vectorize this (at least it can for the power-of-two-sized types\n+/// `swap_nonoverlapping` tries to use) so no need to manually SIMD it.\n #[inline]\n #[rustc_const_unstable(feature = \"const_swap\", issue = \"83163\")]\n-const unsafe fn swap_nonoverlapping_bytes(x: *mut u8, y: *mut u8, len: usize) {\n-    // The approach here is to utilize simd to swap x & y efficiently. Testing reveals\n-    // that swapping either 32 bytes or 64 bytes at a time is most efficient for Intel\n-    // Haswell E processors. LLVM is more able to optimize if we give a struct a\n-    // #[repr(simd)], even if we don't actually use this struct directly.\n-    //\n-    // FIXME repr(simd) broken on emscripten and redox\n-    #[cfg_attr(not(any(target_os = \"emscripten\", target_os = \"redox\")), repr(simd))]\n-    struct Block(u64, u64, u64, u64);\n-    struct UnalignedBlock(u64, u64, u64, u64);\n-\n-    let block_size = mem::size_of::<Block>();\n-\n-    // Loop through x & y, copying them `Block` at a time\n-    // The optimizer should unroll the loop fully for most types\n-    // N.B. We can't use a for loop as the `range` impl calls `mem::swap` recursively\n+const unsafe fn swap_nonoverlapping_simple<T>(x: *mut T, y: *mut T, count: usize) {\n     let mut i = 0;\n-    while i + block_size <= len {\n-        // Create some uninitialized memory as scratch space\n-        // Declaring `t` here avoids aligning the stack when this loop is unused\n-        let mut t = mem::MaybeUninit::<Block>::uninit();\n-        let t = t.as_mut_ptr() as *mut u8;\n-\n-        // SAFETY: As `i < len`, and as the caller must guarantee that `x` and `y` are valid\n-        // for `len` bytes, `x + i` and `y + i` must be valid addresses, which fulfills the\n-        // safety contract for `add`.\n-        //\n-        // Also, the caller must guarantee that `x` and `y` are valid for writes, properly aligned,\n-        // and non-overlapping, which fulfills the safety contract for `copy_nonoverlapping`.\n-        unsafe {\n-            let x = x.add(i);\n-            let y = y.add(i);\n+    while i < count {\n+        let x: &mut T =\n+            // SAFETY: By precondition, `i` is in-bounds because it's below `n`\n+            unsafe { &mut *x.add(i) };\n+        let y: &mut T =\n+            // SAFETY: By precondition, `i` is in-bounds because it's below `n`\n+            // and it's distinct from `x` since the ranges are non-overlapping\n+            unsafe { &mut *y.add(i) };\n+        mem::swap_simple(x, y);\n \n-            // Swap a block of bytes of x & y, using t as a temporary buffer\n-            // This should be optimized into efficient SIMD operations where available\n-            copy_nonoverlapping(x, t, block_size);\n-            copy_nonoverlapping(y, x, block_size);\n-            copy_nonoverlapping(t, y, block_size);\n-        }\n-        i += block_size;\n-    }\n-\n-    if i < len {\n-        // Swap any remaining bytes\n-        let mut t = mem::MaybeUninit::<UnalignedBlock>::uninit();\n-        let rem = len - i;\n-\n-        let t = t.as_mut_ptr() as *mut u8;\n-\n-        // SAFETY: see previous safety comment.\n-        unsafe {\n-            let x = x.add(i);\n-            let y = y.add(i);\n-\n-            copy_nonoverlapping(x, t, rem);\n-            copy_nonoverlapping(y, x, rem);\n-            copy_nonoverlapping(t, y, rem);\n-        }\n+        i += 1;\n     }\n }\n "}, {"sha": "d7345ad0c33f2ad0a13d52df6662dd1dc2f3ea8e", "filename": "src/doc/unstable-book/src/compiler-flags/check-cfg.md", "status": "added", "additions": 221, "deletions": 0, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fcheck-cfg.md", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fcheck-cfg.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fcheck-cfg.md?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -0,0 +1,221 @@\n+# `check-cfg`\n+\n+The tracking issue for this feature is: [#82450](https://github.com/rust-lang/rust/issues/82450).\n+\n+------------------------\n+\n+This feature allows you to enable complete or partial checking of configuration.\n+\n+`rustc` accepts the `--check-cfg` option, which specifies whether to check conditions and how to\n+check them. The `--check-cfg` option takes a value, called the _check cfg specification_. The\n+check cfg specification is parsed using the Rust metadata syntax, just as the `--cfg` option is.\n+\n+`--check-cfg` option can take one of two forms:\n+\n+1. `--check-cfg names(...)` enables checking condition names.\n+2. `--check-cfg values(...)` enables checking the values within list-valued conditions.\n+\n+These two options are independent. `names` checks only the namespace of condition names\n+while `values` checks only the namespace of the values of list-valued conditions.\n+\n+## The `names(...)` form\n+\n+The `names(...)` form enables checking the names. This form uses a named list:\n+\n+```bash\n+rustc --check-cfg 'names(name1, name2, ... nameN)'\n+```\n+\n+where each `name` is a bare identifier (has no quotes). The order of the names is not significant.\n+\n+If `--check-cfg names(...)` is specified at least once, then `rustc` will check all references to\n+condition names. `rustc` will check every `#[cfg]` attribute, `#[cfg_attr]` attribute, `cfg` clause\n+inside `#[link]` attribute and `cfg!(...)` call against the provided list of expected condition\n+names. If a name is not present in this list, then `rustc` will report an `unexpected_cfgs` lint\n+diagnostic. The default diagnostic level for this lint is `Warn`.\n+\n+If `--check-cfg names(...)` is not specified, then `rustc` will not check references to condition\n+names.\n+\n+`--check-cfg names(...)` may be specified more than once. The result is that the list of valid\n+condition names is merged across all options. It is legal for a condition name to be specified\n+more than once; redundantly specifying a condition name has no effect.\n+\n+To enable checking condition names with an empty set of valid condition names, use the following\n+form. The parentheses are required.\n+\n+```bash\n+rustc --check-cfg 'names()'\n+```\n+\n+Note that `--check-cfg 'names()'` is _not_ equivalent to omitting the option entirely.\n+The first form enables checking condition names, while specifying that there are no valid\n+condition names (outside of the set of well-known names defined by `rustc`). Omitting the\n+`--check-cfg 'names(...)'` option does not enable checking condition names.\n+\n+Conditions that are enabled are implicitly valid; it is unnecessary (but legal) to specify a\n+condition name as both enabled and valid. For example, the following invocations are equivalent:\n+\n+```bash\n+# condition names will be checked, and 'has_time_travel' is valid\n+rustc --cfg 'has_time_travel' --check-cfg 'names()'\n+\n+# condition names will be checked, and 'has_time_travel' is valid\n+rustc --cfg 'has_time_travel' --check-cfg 'names(has_time_travel)'\n+```\n+\n+In contrast, the following two invocations are _not_ equivalent:\n+\n+```bash\n+# condition names will not be checked (because there is no --check-cfg names(...))\n+rustc --cfg 'has_time_travel'\n+\n+# condition names will be checked, and 'has_time_travel' is both valid and enabled.\n+rustc --cfg 'has_time_travel' --check-cfg 'names(has_time_travel)'\n+```\n+\n+## The `values(...)` form\n+\n+The `values(...)` form enables checking the values within list-valued conditions. It has this\n+form:\n+\n+```bash\n+rustc --check-cfg `values(name, \"value1\", \"value2\", ... \"valueN\")'\n+```\n+\n+where `name` is a bare identifier (has no quotes) and each `\"value\"` term is a quoted literal\n+string. `name` specifies the name of the condition, such as `feature` or `target_os`.\n+\n+When the `values(...)` option is specified, `rustc` will check every `#[cfg(name = \"value\")]`\n+attribute, `#[cfg_attr(name = \"value\")]` attribute, `#[link(name = \"a\", cfg(name = \"value\"))]`\n+and `cfg!(name = \"value\")` call. It will check that the `\"value\"` specified is present in the\n+list of expected values. If `\"value\"` is not in it, then `rustc` will report an `unexpected_cfgs`\n+lint diagnostic. The default diagnostic level for this lint is `Warn`.\n+\n+The form `values()` is an error, because it does not specify a condition name.\n+\n+To enable checking of values, but to provide an empty set of valid values, use this form:\n+\n+```bash\n+rustc --check-cfg `values(name)`\n+```\n+\n+The `--check-cfg values(...)` option can be repeated, both for the same condition name and for\n+different names. If it is repeated for the same condition name, then the sets of values for that\n+condition are merged together.\n+\n+## Examples\n+\n+Consider this command line:\n+\n+```bash\n+rustc --check-cfg 'names(feature)' \\\n+      --check-cfg 'values(feature,\"lion\",\"zebra\")' \\\n+      --cfg 'feature=\"lion\"' -Z unstable-options \\\n+      example.rs\n+```\n+\n+This command line indicates that this crate has two features: `lion` and `zebra`. The `lion`\n+feature is enabled, while the `zebra` feature is disabled. Consider compiling this code:\n+\n+```rust\n+// This is expected, and tame_lion() will be compiled\n+#[cfg(feature = \"lion\")]\n+fn tame_lion(lion: Lion) {}\n+\n+// This is expected, and ride_zebra() will NOT be compiled.\n+#[cfg(feature = \"zebra\")]\n+fn ride_zebra(zebra: Zebra) {}\n+\n+// This is UNEXPECTED, and will cause a compiler warning (by default).\n+#[cfg(feature = \"platypus\")]\n+fn poke_platypus() {}\n+\n+// This is UNEXPECTED, because 'feechure' is not a known condition name,\n+// and will cause a compiler warning (by default).\n+#[cfg(feechure = \"lion\")]\n+fn tame_lion() {}\n+```\n+\n+> Note: The `--check-cfg names(feature)` option is necessary only to enable checking the condition\n+> name, as in the last example. `feature` is a well-known (always-expected) condition name, and so\n+> it is not necessary to specify it in a `--check-cfg 'names(...)'` option. That option can be\n+> shortened to > `--check-cfg names()` in order to enable checking well-known condition names.\n+\n+### Example: Checking condition names, but not values\n+\n+```bash\n+# This turns on checking for condition names, but not values, such as 'feature' values.\n+rustc --check-cfg 'names(is_embedded, has_feathers)' \\\n+      --cfg has_feathers --cfg 'feature = \"zapping\"' -Z unstable-options\n+```\n+\n+```rust\n+#[cfg(is_embedded)]         // This is expected as \"is_embedded\" was provided in names()\n+fn do_embedded() {}\n+\n+#[cfg(has_feathers)]        // This is expected as \"has_feathers\" was provided in names()\n+fn do_features() {}\n+\n+#[cfg(has_mumble_frotz)]    // This is UNEXPECTED because names checking is enable and\n+                            // \"has_mumble_frotz\" was not provided in names()\n+fn do_mumble_frotz() {}\n+\n+#[cfg(feature = \"lasers\")]  // This doesn't raise a warning, because values checking for \"feature\"\n+                            // was never used\n+fn shoot_lasers() {}\n+```\n+\n+### Example: Checking feature values, but not condition names\n+\n+```bash\n+# This turns on checking for feature values, but not for condition names.\n+rustc --check-cfg 'values(feature, \"zapping\", \"lasers\")' \\\n+      --cfg 'feature=\"zapping\"' -Z unstable-options\n+```\n+\n+```rust\n+#[cfg(is_embedded)]         // This is doesn't raise a warning, because names checking was not\n+                            // enable (ie not names())\n+fn do_embedded() {}\n+\n+#[cfg(has_feathers)]        // Same as above, --check-cfg names(...) was never used so no name\n+                            // checking is performed\n+fn do_features() {}\n+\n+\n+#[cfg(feature = \"lasers\")]  // This is expected, \"lasers\" is in the values(feature) list\n+fn shoot_lasers() {}\n+\n+#[cfg(feature = \"monkeys\")] // This is UNEXPECTED, because \"monkeys\" is not in the\n+                            // --check-cfg values(feature) list\n+fn write_shakespeare() {}\n+```\n+\n+### Example: Checking both condition names and feature values\n+\n+```bash\n+# This turns on checking for feature values and for condition names.\n+rustc --check-cfg 'names(is_embedded, has_feathers)' \\\n+      --check-cfg 'values(feature, \"zapping\", \"lasers\")' \\\n+      --cfg has_feathers --cfg 'feature=\"zapping\"' -Z unstable-options\n+```\n+\n+```rust\n+#[cfg(is_embedded)]         // This is expected because \"is_embedded\" was provided in names()\n+fn do_embedded() {}\n+\n+#[cfg(has_feathers)]        // This is expected because \"has_feathers\" was provided in names()\n+fn do_features() {}\n+\n+#[cfg(has_mumble_frotz)]    // This is UNEXPECTED, because has_mumble_frotz is not in the\n+                            // --check-cfg names(...) list\n+fn do_mumble_frotz() {}\n+\n+#[cfg(feature = \"lasers\")]  // This is expected, \"lasers\" is in the values(feature) list\n+fn shoot_lasers() {}\n+\n+#[cfg(feature = \"monkeys\")] // This is UNEXPECTED, because \"monkeys\" is not in\n+                            // the values(feature) list\n+fn write_shakespear() {}\n+```"}, {"sha": "1e0c1e8f1f356b7624ec44056f70f14cad4e2181", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -1855,7 +1855,7 @@ fn clean_maybe_renamed_item(\n             ItemKind::Fn(ref sig, ref generics, body_id) => {\n                 clean_fn_or_proc_macro(item, sig, generics, body_id, &mut name, cx)\n             }\n-            ItemKind::Macro(ref macro_def) => {\n+            ItemKind::Macro(ref macro_def, _) => {\n                 let ty_vis = cx.tcx.visibility(def_id).clean(cx);\n                 MacroItem(Macro {\n                     source: display_macro_source(cx, name, macro_def, def_id, ty_vis),"}, {"sha": "5ccc3dabe83b71c4693df1aff2b89f6edf7057dd", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -1164,7 +1164,7 @@ impl<'a, 'hir, 'tcx> intravisit::Visitor<'hir> for HirCollector<'a, 'hir, 'tcx>\n \n     fn visit_item(&mut self, item: &'hir hir::Item<'_>) {\n         let name = match &item.kind {\n-            hir::ItemKind::Macro(ref macro_def) => {\n+            hir::ItemKind::Macro(ref macro_def, _) => {\n                 // FIXME(#88038): Non exported macros have historically not been tested,\n                 // but we really ought to start testing them.\n                 let def_id = item.def_id.to_def_id();"}, {"sha": "1693034db0e82a49f0e3fc714064b5ec4c9856e6", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -325,7 +325,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n \n                 om.items.push((item, renamed))\n             }\n-            hir::ItemKind::Macro(ref macro_def) => {\n+            hir::ItemKind::Macro(ref macro_def, _) => {\n                 // `#[macro_export] macro_rules!` items are handled seperately in `visit()`,\n                 // above, since they need to be documented at the module top level. Accordingly,\n                 // we only want to handle macros if one of three conditions holds:"}, {"sha": "535d301a3d27b0be6185fac195eba70c78954f2f", "filename": "src/test/codegen/swap-large-types.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/src%2Ftest%2Fcodegen%2Fswap-large-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/src%2Ftest%2Fcodegen%2Fswap-large-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fswap-large-types.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -0,0 +1,64 @@\n+// compile-flags: -O\n+// only-x86_64\n+// ignore-debug: the debug assertions get in the way\n+\n+#![crate_type = \"lib\"]\n+\n+use std::mem::swap;\n+use std::ptr::{read, copy_nonoverlapping, write};\n+\n+type KeccakBuffer = [[u64; 5]; 5];\n+\n+// A basic read+copy+write swap implementation ends up copying one of the values\n+// to stack for large types, which is completely unnecessary as the lack of\n+// overlap means we can just do whatever fits in registers at a time.\n+\n+// CHECK-LABEL: @swap_basic\n+#[no_mangle]\n+pub fn swap_basic(x: &mut KeccakBuffer, y: &mut KeccakBuffer) {\n+// CHECK: alloca [5 x [5 x i64]]\n+\n+    // SAFETY: exclusive references are always valid to read/write,\n+    // are non-overlapping, and nothing here panics so it's drop-safe.\n+    unsafe {\n+        let z = read(x);\n+        copy_nonoverlapping(y, x, 1);\n+        write(y, z);\n+    }\n+}\n+\n+// This test verifies that the library does something smarter, and thus\n+// doesn't need any scratch space on the stack.\n+\n+// CHECK-LABEL: @swap_std\n+#[no_mangle]\n+pub fn swap_std(x: &mut KeccakBuffer, y: &mut KeccakBuffer) {\n+// CHECK-NOT: alloca\n+// CHECK: load <{{[0-9]+}} x i64>\n+// CHECK: store <{{[0-9]+}} x i64>\n+    swap(x, y)\n+}\n+\n+// CHECK-LABEL: @swap_slice\n+#[no_mangle]\n+pub fn swap_slice(x: &mut [KeccakBuffer], y: &mut [KeccakBuffer]) {\n+// CHECK-NOT: alloca\n+// CHECK: load <{{[0-9]+}} x i64>\n+// CHECK: store <{{[0-9]+}} x i64>\n+    if x.len() == y.len() {\n+        x.swap_with_slice(y);\n+    }\n+}\n+\n+type OneKilobyteBuffer = [u8; 1024];\n+\n+// CHECK-LABEL: @swap_1kb_slices\n+#[no_mangle]\n+pub fn swap_1kb_slices(x: &mut [OneKilobyteBuffer], y: &mut [OneKilobyteBuffer]) {\n+// CHECK-NOT: alloca\n+// CHECK: load <{{[0-9]+}} x i8>\n+// CHECK: store <{{[0-9]+}} x i8>\n+    if x.len() == y.len() {\n+        x.swap_with_slice(y);\n+    }\n+}"}, {"sha": "c90b277eb44876fc4954399093401661f423f3b0", "filename": "src/test/codegen/swap-simd-types.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/src%2Ftest%2Fcodegen%2Fswap-simd-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/src%2Ftest%2Fcodegen%2Fswap-simd-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fswap-simd-types.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -0,0 +1,32 @@\n+// compile-flags: -O -C target-feature=+avx\n+// only-x86_64\n+// ignore-debug: the debug assertions get in the way\n+\n+#![crate_type = \"lib\"]\n+\n+use std::mem::swap;\n+\n+// SIMD types are highly-aligned already, so make sure the swap code leaves their\n+// types alone and doesn't pessimize them (such as by swapping them as `usize`s).\n+extern crate core;\n+use core::arch::x86_64::__m256;\n+\n+// CHECK-LABEL: @swap_single_m256\n+#[no_mangle]\n+pub fn swap_single_m256(x: &mut __m256, y: &mut __m256) {\n+// CHECK-NOT: alloca\n+// CHECK: load <8 x float>{{.+}}align 32\n+// CHECK: store <8 x float>{{.+}}align 32\n+    swap(x, y)\n+}\n+\n+// CHECK-LABEL: @swap_m256_slice\n+#[no_mangle]\n+pub fn swap_m256_slice(x: &mut [__m256], y: &mut [__m256]) {\n+// CHECK-NOT: alloca\n+// CHECK: load <8 x float>{{.+}}align 32\n+// CHECK: store <8 x float>{{.+}}align 32\n+    if x.len() == y.len() {\n+        x.swap_with_slice(y);\n+    }\n+}"}, {"sha": "2f375844cc7166dfcb725d0020684dd5e5093698", "filename": "src/test/codegen/swap-small-types.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/src%2Ftest%2Fcodegen%2Fswap-small-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/src%2Ftest%2Fcodegen%2Fswap-small-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fswap-small-types.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -16,3 +16,47 @@ pub fn swap_rgb48(x: &mut RGB48, y: &mut RGB48) {\n // CHECK: store i48\n     swap(x, y)\n }\n+\n+// LLVM doesn't vectorize a loop over 3-byte elements,\n+// so we chunk it down to bytes and loop over those instead.\n+type RGB24 = [u8; 3];\n+\n+// CHECK-LABEL: @swap_rgb24_slices\n+#[no_mangle]\n+pub fn swap_rgb24_slices(x: &mut [RGB24], y: &mut [RGB24]) {\n+// CHECK-NOT: alloca\n+// CHECK: load <{{[0-9]+}} x i8>\n+// CHECK: store <{{[0-9]+}} x i8>\n+    if x.len() == y.len() {\n+        x.swap_with_slice(y);\n+    }\n+}\n+\n+// This one has a power-of-two size, so we iterate over it directly\n+type RGBA32 = [u8; 4];\n+\n+// CHECK-LABEL: @swap_rgba32_slices\n+#[no_mangle]\n+pub fn swap_rgba32_slices(x: &mut [RGBA32], y: &mut [RGBA32]) {\n+// CHECK-NOT: alloca\n+// CHECK: load <{{[0-9]+}} x i32>\n+// CHECK: store <{{[0-9]+}} x i32>\n+    if x.len() == y.len() {\n+        x.swap_with_slice(y);\n+    }\n+}\n+\n+// Strings have a non-power-of-two size, but have pointer alignment,\n+// so we swap usizes instead of dropping all the way down to bytes.\n+const _: () = assert!(!std::mem::size_of::<String>().is_power_of_two());\n+\n+// CHECK-LABEL: @swap_string_slices\n+#[no_mangle]\n+pub fn swap_string_slices(x: &mut [String], y: &mut [String]) {\n+// CHECK-NOT: alloca\n+// CHECK: load <{{[0-9]+}} x i64>\n+// CHECK: store <{{[0-9]+}} x i64>\n+    if x.len() == y.len() {\n+        x.swap_with_slice(y);\n+    }\n+}"}, {"sha": "1574a7e02e97fd7b5548217d8491ab86543e53eb", "filename": "src/test/ui/auto-traits/suspicious-impls-lint.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/src%2Ftest%2Fui%2Fauto-traits%2Fsuspicious-impls-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/src%2Ftest%2Fui%2Fauto-traits%2Fsuspicious-impls-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fauto-traits%2Fsuspicious-impls-lint.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -1,5 +1,7 @@\n #![deny(suspicious_auto_trait_impls)]\n \n+use std::marker::PhantomData;\n+\n struct MayImplementSendOk<T>(T);\n unsafe impl<T: Send> Send for MayImplementSendOk<T> {} // ok\n \n@@ -31,4 +33,12 @@ unsafe impl<T: Send> Send for TwoParamsSame<T, T> {}\n //~^ ERROR\n //~| WARNING this will change its meaning\n \n+pub struct WithPhantomDataNonSend<T, U>(PhantomData<*const T>, U);\n+unsafe impl<T> Send for WithPhantomDataNonSend<T, i8> {} // ok\n+\n+pub struct WithPhantomDataSend<T, U>(PhantomData<T>, U);\n+unsafe impl<T> Send for WithPhantomDataSend<*const T, i8> {}\n+//~^ ERROR\n+//~| WARNING this will change its meaning\n+\n fn main() {}"}, {"sha": "084bfef49c029f5727cc3cdad9605df8de37491e", "filename": "src/test/ui/auto-traits/suspicious-impls-lint.stderr", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/src%2Ftest%2Fui%2Fauto-traits%2Fsuspicious-impls-lint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/src%2Ftest%2Fui%2Fauto-traits%2Fsuspicious-impls-lint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fauto-traits%2Fsuspicious-impls-lint.stderr?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -1,5 +1,5 @@\n error: cross-crate traits with a default impl, like `Send`, should not be specialized\n-  --> $DIR/suspicious-impls-lint.rs:7:1\n+  --> $DIR/suspicious-impls-lint.rs:9:1\n    |\n LL | unsafe impl<T: Send> Send for MayImplementSendErr<&T> {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -12,41 +12,56 @@ LL | #![deny(suspicious_auto_trait_impls)]\n    = warning: this will change its meaning in a future release!\n    = note: for more information, see issue #93367 <https://github.com/rust-lang/rust/issues/93367>\n note: try using the same sequence of generic parameters as the struct definition\n-  --> $DIR/suspicious-impls-lint.rs:6:1\n+  --> $DIR/suspicious-impls-lint.rs:8:1\n    |\n LL | struct MayImplementSendErr<T>(T);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: `&T` is not a generic parameter\n \n error: cross-crate traits with a default impl, like `Send`, should not be specialized\n-  --> $DIR/suspicious-impls-lint.rs:19:1\n+  --> $DIR/suspicious-impls-lint.rs:21:1\n    |\n LL | unsafe impl Send for ContainsVec<i32> {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this will change its meaning in a future release!\n    = note: for more information, see issue #93367 <https://github.com/rust-lang/rust/issues/93367>\n note: try using the same sequence of generic parameters as the struct definition\n-  --> $DIR/suspicious-impls-lint.rs:18:1\n+  --> $DIR/suspicious-impls-lint.rs:20:1\n    |\n LL | struct ContainsVec<T>(Vec<T>);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: `i32` is not a generic parameter\n \n error: cross-crate traits with a default impl, like `Send`, should not be specialized\n-  --> $DIR/suspicious-impls-lint.rs:30:1\n+  --> $DIR/suspicious-impls-lint.rs:32:1\n    |\n LL | unsafe impl<T: Send> Send for TwoParamsSame<T, T> {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this will change its meaning in a future release!\n    = note: for more information, see issue #93367 <https://github.com/rust-lang/rust/issues/93367>\n note: try using the same sequence of generic parameters as the struct definition\n-  --> $DIR/suspicious-impls-lint.rs:29:1\n+  --> $DIR/suspicious-impls-lint.rs:31:1\n    |\n LL | struct TwoParamsSame<T, U>(T, U);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: `T` is mentioned multiple times\n \n-error: aborting due to 3 previous errors\n+error: cross-crate traits with a default impl, like `Send`, should not be specialized\n+  --> $DIR/suspicious-impls-lint.rs:40:1\n+   |\n+LL | unsafe impl<T> Send for WithPhantomDataSend<*const T, i8> {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = warning: this will change its meaning in a future release!\n+   = note: for more information, see issue #93367 <https://github.com/rust-lang/rust/issues/93367>\n+note: try using the same sequence of generic parameters as the struct definition\n+  --> $DIR/suspicious-impls-lint.rs:39:1\n+   |\n+LL | pub struct WithPhantomDataSend<T, U>(PhantomData<T>, U);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: `*const T` is not a generic parameter\n+\n+error: aborting due to 4 previous errors\n "}, {"sha": "2bd1821c9422b79ae60e1e631dfce6329f31b0b0", "filename": "src/test/ui/check-cfg/invalid-cfg-name.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/src%2Ftest%2Fui%2Fcheck-cfg%2Finvalid-cfg-name.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/src%2Ftest%2Fui%2Fcheck-cfg%2Finvalid-cfg-name.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcheck-cfg%2Finvalid-cfg-name.stderr?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -2,7 +2,7 @@ warning: unexpected `cfg` condition name\n   --> $DIR/invalid-cfg-name.rs:7:7\n    |\n LL | #[cfg(widnows)]\n-   |       ^^^^^^^\n+   |       ^^^^^^^ help: did you mean: `windows`\n    |\n    = note: `#[warn(unexpected_cfgs)]` on by default\n "}, {"sha": "bc2c053fed65a7efe775289b476008995feea887", "filename": "src/test/ui/check-cfg/invalid-cfg-value.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/src%2Ftest%2Fui%2Fcheck-cfg%2Finvalid-cfg-value.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/src%2Ftest%2Fui%2Fcheck-cfg%2Finvalid-cfg-value.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcheck-cfg%2Finvalid-cfg-value.stderr?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -5,6 +5,7 @@ LL | #[cfg(feature = \"sedre\")]\n    |       ^^^^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unexpected_cfgs)]` on by default\n+   = note: expected values for `feature` are: full, rand, serde\n \n warning: 1 warning emitted\n "}, {"sha": "26c735c4a10bd72df1797a7a73f79a1ec500cfc2", "filename": "src/test/ui/check-cfg/mix.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/src%2Ftest%2Fui%2Fcheck-cfg%2Fmix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/src%2Ftest%2Fui%2Fcheck-cfg%2Fmix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcheck-cfg%2Fmix.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -0,0 +1,50 @@\n+// This test checks the combination of well known names, their activation via names(), the usage of\n+// partial values() with a --cfg and test that we also correctly lint on the `cfg!` macro and\n+// `cfg_attr` attribute.\n+//\n+// check-pass\n+// compile-flags: --check-cfg=names() --check-cfg=values(feature,\"foo\") --cfg feature=\"bar\" -Z unstable-options\n+\n+#[cfg(windows)]\n+fn do_windows_stuff() {}\n+\n+#[cfg(widnows)]\n+//~^ WARNING unexpected `cfg` condition name\n+fn do_windows_stuff() {}\n+\n+#[cfg(feature = \"foo\")]\n+fn use_foo() {}\n+\n+#[cfg(feature = \"bar\")]\n+fn use_bar() {}\n+\n+#[cfg(feature = \"zebra\")]\n+//~^ WARNING unexpected `cfg` condition value\n+fn use_zebra() {}\n+\n+#[cfg_attr(uu, test)]\n+//~^ WARNING unexpected `cfg` condition name\n+fn do_test() {}\n+\n+#[cfg_attr(feature = \"foo\", no_mangle)]\n+fn do_test_foo() {}\n+\n+fn test_cfg_macro() {\n+    cfg!(windows);\n+    cfg!(widnows);\n+    //~^ WARNING unexpected `cfg` condition name\n+    cfg!(feature = \"foo\");\n+    cfg!(feature = \"bar\");\n+    cfg!(feature = \"zebra\");\n+    //~^ WARNING unexpected `cfg` condition value\n+    cfg!(xxx = \"foo\");\n+    //~^ WARNING unexpected `cfg` condition name\n+    cfg!(xxx);\n+    //~^ WARNING unexpected `cfg` condition name\n+    cfg!(any(xxx, windows));\n+    //~^ WARNING unexpected `cfg` condition name\n+    cfg!(any(feature = \"bad\", windows));\n+    //~^ WARNING unexpected `cfg` condition value\n+}\n+\n+fn main() {}"}, {"sha": "b273be774224d24b212b9384393159f91adabee6", "filename": "src/test/ui/check-cfg/mix.stderr", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/src%2Ftest%2Fui%2Fcheck-cfg%2Fmix.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/src%2Ftest%2Fui%2Fcheck-cfg%2Fmix.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcheck-cfg%2Fmix.stderr?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -0,0 +1,66 @@\n+warning: unexpected `cfg` condition name\n+  --> $DIR/mix.rs:11:7\n+   |\n+LL | #[cfg(widnows)]\n+   |       ^^^^^^^ help: did you mean: `windows`\n+   |\n+   = note: `#[warn(unexpected_cfgs)]` on by default\n+\n+warning: unexpected `cfg` condition value\n+  --> $DIR/mix.rs:21:7\n+   |\n+LL | #[cfg(feature = \"zebra\")]\n+   |       ^^^^^^^^^^^^^^^^^\n+   |\n+   = note: expected values for `feature` are: bar, foo\n+\n+warning: unexpected `cfg` condition name\n+  --> $DIR/mix.rs:25:12\n+   |\n+LL | #[cfg_attr(uu, test)]\n+   |            ^^\n+\n+warning: unexpected `cfg` condition name\n+  --> $DIR/mix.rs:34:10\n+   |\n+LL |     cfg!(widnows);\n+   |          ^^^^^^^ help: did you mean: `windows`\n+\n+warning: unexpected `cfg` condition value\n+  --> $DIR/mix.rs:38:10\n+   |\n+LL |     cfg!(feature = \"zebra\");\n+   |          ^^^^^^^^^^^^^^^^^\n+   |\n+   = note: expected values for `feature` are: bar, foo\n+\n+warning: unexpected `cfg` condition name\n+  --> $DIR/mix.rs:40:10\n+   |\n+LL |     cfg!(xxx = \"foo\");\n+   |          ^^^^^^^^^^^\n+\n+warning: unexpected `cfg` condition name\n+  --> $DIR/mix.rs:42:10\n+   |\n+LL |     cfg!(xxx);\n+   |          ^^^\n+\n+warning: unexpected `cfg` condition name\n+  --> $DIR/mix.rs:44:14\n+   |\n+LL |     cfg!(any(xxx, windows));\n+   |              ^^^\n+\n+warning: unexpected `cfg` condition value\n+  --> $DIR/mix.rs:46:14\n+   |\n+LL |     cfg!(any(feature = \"bad\", windows));\n+   |              ^^^^^^^^^^-----\n+   |                        |\n+   |                        help: did you mean: `\"bar\"`\n+   |\n+   = note: expected values for `feature` are: bar, foo\n+\n+warning: 9 warnings emitted\n+"}, {"sha": "2440757e52da994e1c516c3b434b8c212310105a", "filename": "src/test/ui/check-cfg/no-values.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/src%2Ftest%2Fui%2Fcheck-cfg%2Fno-values.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/src%2Ftest%2Fui%2Fcheck-cfg%2Fno-values.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcheck-cfg%2Fno-values.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -0,0 +1,10 @@\n+// Check that we detect unexpected value when none are allowed\n+//\n+// check-pass\n+// compile-flags: --check-cfg=values(feature) -Z unstable-options\n+\n+#[cfg(feature = \"foo\")]\n+//~^ WARNING unexpected `cfg` condition value\n+fn do_foo() {}\n+\n+fn main() {}"}, {"sha": "ea1c9107d4c2ffb1137e5c67411c7c4ce90f3334", "filename": "src/test/ui/check-cfg/no-values.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/src%2Ftest%2Fui%2Fcheck-cfg%2Fno-values.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/src%2Ftest%2Fui%2Fcheck-cfg%2Fno-values.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcheck-cfg%2Fno-values.stderr?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -0,0 +1,11 @@\n+warning: unexpected `cfg` condition value\n+  --> $DIR/no-values.rs:6:7\n+   |\n+LL | #[cfg(feature = \"foo\")]\n+   |       ^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(unexpected_cfgs)]` on by default\n+   = note: no expected value for `feature`\n+\n+warning: 1 warning emitted\n+"}, {"sha": "a66568a2ffdc98efe62dc3830e52eab824e49fe2", "filename": "src/test/ui/check-cfg/well-known-names.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/src%2Ftest%2Fui%2Fcheck-cfg%2Fwell-known-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/src%2Ftest%2Fui%2Fcheck-cfg%2Fwell-known-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcheck-cfg%2Fwell-known-names.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -0,0 +1,27 @@\n+// This test checks that we lint on non well known names and that we don't lint on well known names\n+//\n+// check-pass\n+// compile-flags: --check-cfg=names() -Z unstable-options\n+\n+#[cfg(target_oz = \"linux\")]\n+//~^ WARNING unexpected `cfg` condition name\n+fn target_os_misspell() {}\n+\n+#[cfg(target_os = \"linux\")]\n+fn target_os() {}\n+\n+#[cfg(features = \"foo\")]\n+//~^ WARNING unexpected `cfg` condition name\n+fn feature_misspell() {}\n+\n+#[cfg(feature = \"foo\")]\n+fn feature() {}\n+\n+#[cfg(uniw)]\n+//~^ WARNING unexpected `cfg` condition name\n+fn unix_misspell() {}\n+\n+#[cfg(unix)]\n+fn unix() {}\n+\n+fn main() {}"}, {"sha": "bdbe4d29d30feb07d00579bb4149581fdcd70f84", "filename": "src/test/ui/check-cfg/well-known-names.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/src%2Ftest%2Fui%2Fcheck-cfg%2Fwell-known-names.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/src%2Ftest%2Fui%2Fcheck-cfg%2Fwell-known-names.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcheck-cfg%2Fwell-known-names.stderr?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -0,0 +1,26 @@\n+warning: unexpected `cfg` condition name\n+  --> $DIR/well-known-names.rs:6:7\n+   |\n+LL | #[cfg(target_oz = \"linux\")]\n+   |       ---------^^^^^^^^^^\n+   |       |\n+   |       help: did you mean: `target_os`\n+   |\n+   = note: `#[warn(unexpected_cfgs)]` on by default\n+\n+warning: unexpected `cfg` condition name\n+  --> $DIR/well-known-names.rs:13:7\n+   |\n+LL | #[cfg(features = \"foo\")]\n+   |       --------^^^^^^^^\n+   |       |\n+   |       help: did you mean: `feature`\n+\n+warning: unexpected `cfg` condition name\n+  --> $DIR/well-known-names.rs:20:7\n+   |\n+LL | #[cfg(uniw)]\n+   |       ^^^^ help: did you mean: `unix`\n+\n+warning: 3 warnings emitted\n+"}, {"sha": "043011b3316a7c195f3e8817df0de3fc73f8e45a", "filename": "src/test/ui/debuginfo/debuginfo-emit-llvm-ir-and-split-debuginfo.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/src%2Ftest%2Fui%2Fdebuginfo%2Fdebuginfo-emit-llvm-ir-and-split-debuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/src%2Ftest%2Fui%2Fdebuginfo%2Fdebuginfo-emit-llvm-ir-and-split-debuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdebuginfo%2Fdebuginfo-emit-llvm-ir-and-split-debuginfo.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "previous_filename": "src/test/ui/debuginfo-emit-llvm-ir-and-split-debuginfo.rs"}, {"sha": "833a4726acb0fb20a6e375448b08054ca62b553f", "filename": "src/test/ui/debuginfo/debuginfo_with_uninhabitable_field_and_unsized.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/src%2Ftest%2Fui%2Fdebuginfo%2Fdebuginfo_with_uninhabitable_field_and_unsized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/src%2Ftest%2Fui%2Fdebuginfo%2Fdebuginfo_with_uninhabitable_field_and_unsized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdebuginfo%2Fdebuginfo_with_uninhabitable_field_and_unsized.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -0,0 +1,29 @@\n+// check-pass\n+// compile-flags: -Cdebuginfo=2\n+// fixes issue #94149\n+\n+#![allow(dead_code)]\n+\n+pub fn main() {\n+    let _ = Foo::<dyn FooTrait>::new();\n+}\n+\n+pub struct Foo<T: FooTrait + ?Sized> {\n+    base: FooBase,\n+    value: T,\n+}\n+\n+impl<T: FooTrait + ?Sized> Foo<T> {\n+    pub fn new() -> Box<Foo<T>> {\n+        todo!()\n+    }\n+}\n+\n+pub trait FooTrait {}\n+\n+pub struct FooBase {\n+    cls: Bar,\n+}\n+\n+// Bar *must* be a fieldless enum\n+pub enum Bar {}"}, {"sha": "a78ff046e97f976f9150f774fa754fc6baec3ff3", "filename": "src/test/ui/traits/copy-impl-cannot-normalize.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/src%2Ftest%2Fui%2Ftraits%2Fcopy-impl-cannot-normalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/src%2Ftest%2Fui%2Ftraits%2Fcopy-impl-cannot-normalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fcopy-impl-cannot-normalize.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -0,0 +1,25 @@\n+trait TraitFoo {\n+    type Bar;\n+}\n+\n+struct Foo<T>\n+where\n+    T: TraitFoo,\n+{\n+    inner: T::Bar,\n+}\n+\n+impl<T> Clone for Foo<T>\n+where\n+    T: TraitFoo,\n+    T::Bar: Clone,\n+{\n+    fn clone(&self) -> Self {\n+        Self { inner: self.inner.clone() }\n+    }\n+}\n+\n+impl<T> Copy for Foo<T> {}\n+//~^ ERROR the trait bound `T: TraitFoo` is not satisfied\n+\n+fn main() {}"}, {"sha": "cc540ea905a10da10d66e659b83178b237d1e05f", "filename": "src/test/ui/traits/copy-impl-cannot-normalize.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/src%2Ftest%2Fui%2Ftraits%2Fcopy-impl-cannot-normalize.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/src%2Ftest%2Fui%2Ftraits%2Fcopy-impl-cannot-normalize.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fcopy-impl-cannot-normalize.stderr?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -0,0 +1,14 @@\n+error[E0277]: the trait bound `T: TraitFoo` is not satisfied\n+  --> $DIR/copy-impl-cannot-normalize.rs:22:1\n+   |\n+LL | impl<T> Copy for Foo<T> {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `TraitFoo` is not implemented for `T`\n+   |\n+help: consider restricting type parameter `T`\n+   |\n+LL | impl<T: TraitFoo> Copy for Foo<T> {}\n+   |       ++++++++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "d27e1383d012b7aa71e2541d79ed5a4fc28558b1", "filename": "src/tools/clippy/clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -199,7 +199,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n                     let sugg = |diag: &mut DiagnosticBuilder<'_>| {\n                         if let ty::Adt(def, ..) = ty.kind() {\n                             if let Some(span) = cx.tcx.hir().span_if_local(def.did) {\n-                                if can_type_implement_copy(cx.tcx, cx.param_env, ty).is_ok() {\n+                                if can_type_implement_copy(cx.tcx, cx.param_env, ty, traits::ObligationCause::dummy_with_span(span)).is_ok() {\n                                     diag.span_help(span, \"consider marking this type as `Copy`\");\n                                 }\n                             }"}, {"sha": "dc48ea3f4f99d77612cfcb3a4e48fab6dabf8f5a", "filename": "src/tools/clippy/clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -373,7 +373,7 @@ fn print_item(cx: &LateContext<'_>, item: &hir::Item<'_>) {\n             let item_ty = cx.tcx.type_of(did);\n             println!(\"function of type {:#?}\", item_ty);\n         },\n-        hir::ItemKind::Macro(ref macro_def) => {\n+        hir::ItemKind::Macro(ref macro_def, _) => {\n             if macro_def.macro_rules {\n                 println!(\"macro introduced by `macro_rules!`\");\n             } else {"}, {"sha": "a83c8ba0b6428d8345b26c65c6086e67463d1242", "filename": "src/tools/clippy/tests/ui/macro_use_imports.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmacro_use_imports.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmacro_use_imports.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmacro_use_imports.fixed?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -15,7 +15,7 @@ extern crate macro_use_helper as mac;\n extern crate proc_macro_derive as mini_mac;\n \n mod a {\n-    use mac::{pub_macro, inner_mod_macro, function_macro, ty_macro, pub_in_private_macro};\n+    use mac::{pub_macro, function_macro, ty_macro, inner_mod_macro, pub_in_private_macro};\n     use mac;\n     use mini_mac::ClippyMiniMacroTest;\n     use mini_mac;"}, {"sha": "9028a636e7f7a5d064e8c8b3417b979cd6a54eba", "filename": "src/tools/clippy/tests/ui/macro_use_imports.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e82f35492ea5c78e19609bf4468f0a686d9a756/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmacro_use_imports.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4e82f35492ea5c78e19609bf4468f0a686d9a756/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmacro_use_imports.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmacro_use_imports.stderr?ref=4e82f35492ea5c78e19609bf4468f0a686d9a756", "patch": "@@ -2,7 +2,7 @@ error: `macro_use` attributes are no longer needed in the Rust 2018 edition\n   --> $DIR/macro_use_imports.rs:18:5\n    |\n LL |     #[macro_use]\n-   |     ^^^^^^^^^^^^ help: remove the attribute and import the macro directly, try: `use mac::{pub_macro, inner_mod_macro, function_macro, ty_macro, pub_in_private_macro};`\n+   |     ^^^^^^^^^^^^ help: remove the attribute and import the macro directly, try: `use mac::{pub_macro, function_macro, ty_macro, inner_mod_macro, pub_in_private_macro};`\n    |\n    = note: `-D clippy::macro-use-imports` implied by `-D warnings`\n "}]}