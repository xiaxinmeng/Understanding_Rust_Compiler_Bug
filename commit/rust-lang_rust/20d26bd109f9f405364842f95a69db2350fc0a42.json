{"sha": "20d26bd109f9f405364842f95a69db2350fc0a42", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwZDI2YmQxMDlmOWY0MDUzNjQ4NDJmOTVhNjlkYjIzNTBmYzBhNDI=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-06-09T21:43:22Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-06-09T21:45:12Z"}, "message": "Simplify", "tree": {"sha": "97c0993aacd1027efe3b15fe114f222b75f3c60f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/97c0993aacd1027efe3b15fe114f222b75f3c60f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/20d26bd109f9f405364842f95a69db2350fc0a42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/20d26bd109f9f405364842f95a69db2350fc0a42", "html_url": "https://github.com/rust-lang/rust/commit/20d26bd109f9f405364842f95a69db2350fc0a42", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/20d26bd109f9f405364842f95a69db2350fc0a42/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f592f4f58a6e1e1db0f920af34a2f569b65017c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f592f4f58a6e1e1db0f920af34a2f569b65017c", "html_url": "https://github.com/rust-lang/rust/commit/5f592f4f58a6e1e1db0f920af34a2f569b65017c"}], "stats": {"total": 386, "additions": 178, "deletions": 208}, "files": [{"sha": "902df46ca16e94cc16ab8d871ff24e4bca32bd9d", "filename": "crates/ide_completion/src/render.rs", "status": "modified", "additions": 178, "deletions": 208, "changes": 386, "blob_url": "https://github.com/rust-lang/rust/blob/20d26bd109f9f405364842f95a69db2350fc0a42/crates%2Fide_completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20d26bd109f9f405364842f95a69db2350fc0a42/crates%2Fide_completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender.rs?ref=20d26bd109f9f405364842f95a69db2350fc0a42", "patch": "@@ -24,34 +24,34 @@ use crate::{\n     CompletionContext, CompletionItem, CompletionItemKind, CompletionKind, CompletionRelevance,\n };\n \n-pub(crate) fn render_field<'a>(\n-    ctx: RenderContext<'a>,\n+pub(crate) fn render_field(\n+    ctx: RenderContext<'_>,\n     receiver: Option<hir::Name>,\n     field: hir::Field,\n     ty: &hir::Type,\n ) -> CompletionItem {\n-    Render::new(ctx).render_field(receiver, field, ty)\n+    render_field_(ctx, receiver, field, ty)\n }\n \n-pub(crate) fn render_tuple_field<'a>(\n-    ctx: RenderContext<'a>,\n+pub(crate) fn render_tuple_field(\n+    ctx: RenderContext<'_>,\n     receiver: Option<hir::Name>,\n     field: usize,\n     ty: &hir::Type,\n ) -> CompletionItem {\n-    Render::new(ctx).render_tuple_field(receiver, field, ty)\n+    render_tuple_field_(ctx, receiver, field, ty)\n }\n \n-pub(crate) fn render_resolution<'a>(\n-    ctx: RenderContext<'a>,\n+pub(crate) fn render_resolution(\n+    ctx: RenderContext<'_>,\n     local_name: hir::Name,\n     resolution: &hir::ScopeDef,\n ) -> Option<CompletionItem> {\n-    Render::new(ctx).render_resolution(local_name, None, resolution)\n+    render_resolution_(ctx, local_name, None, resolution)\n }\n \n-pub(crate) fn render_resolution_with_import<'a>(\n-    ctx: RenderContext<'a>,\n+pub(crate) fn render_resolution_with_import(\n+    ctx: RenderContext<'_>,\n     import_edit: ImportEdit,\n ) -> Option<CompletionItem> {\n     let resolution = hir::ScopeDef::from(import_edit.import.original_item);\n@@ -64,12 +64,10 @@ pub(crate) fn render_resolution_with_import<'a>(\n         hir::ScopeDef::ModuleDef(hir::ModuleDef::TypeAlias(t)) => t.name(ctx.completion.db),\n         _ => item_name(ctx.db(), import_edit.import.original_item)?,\n     };\n-    Render::new(ctx).render_resolution(local_name, Some(import_edit), &resolution).map(\n-        |mut item| {\n-            item.completion_kind = CompletionKind::Magic;\n-            item\n-        },\n-    )\n+    render_resolution_(ctx, local_name, Some(import_edit), &resolution).map(|mut item| {\n+        item.completion_kind = CompletionKind::Magic;\n+        item\n+    })\n }\n \n /// Interface for data and methods required for items rendering.\n@@ -121,216 +119,188 @@ impl<'a> RenderContext<'a> {\n     }\n }\n \n-/// Generic renderer for completion items.\n-#[derive(Debug)]\n-struct Render<'a> {\n-    ctx: RenderContext<'a>,\n-}\n-\n-impl<'a> Render<'a> {\n-    fn new(ctx: RenderContext<'a>) -> Render<'a> {\n-        Render { ctx }\n+fn render_field_(\n+    ctx: RenderContext<'_>,\n+    receiver: Option<hir::Name>,\n+    field: hir::Field,\n+    ty: &hir::Type,\n+) -> CompletionItem {\n+    let is_deprecated = ctx.is_deprecated(field);\n+    let name = field.name(ctx.db()).to_string();\n+    let mut item = CompletionItem::new(\n+        CompletionKind::Reference,\n+        ctx.source_range(),\n+        receiver.map_or_else(|| name.clone(), |receiver| format!(\"{}.{}\", receiver, name)),\n+    );\n+    item.kind(SymbolKind::Field)\n+        .detail(ty.display(ctx.db()).to_string())\n+        .set_documentation(field.docs(ctx.db()))\n+        .set_deprecated(is_deprecated);\n+\n+    item.set_relevance(CompletionRelevance {\n+        type_match: compute_type_match(ctx.completion, ty),\n+        exact_name_match: compute_exact_name_match(ctx.completion, &name),\n+        ..CompletionRelevance::default()\n+    });\n+\n+    if let Some(_ref_match) = compute_ref_match(ctx.completion, ty) {\n+        // FIXME\n+        // For now we don't properly calculate the edits for ref match\n+        // completions on struct fields, so we've disabled them. See #8058.\n     }\n \n-    fn render_field(\n-        &self,\n-        receiver: Option<hir::Name>,\n-        field: hir::Field,\n-        ty: &hir::Type,\n-    ) -> CompletionItem {\n-        let is_deprecated = self.ctx.is_deprecated(field);\n-        let name = field.name(self.ctx.db()).to_string();\n-        let mut item = CompletionItem::new(\n-            CompletionKind::Reference,\n-            self.ctx.source_range(),\n-            receiver.map_or_else(|| name.clone(), |receiver| format!(\"{}.{}\", receiver, name)),\n-        );\n-        item.kind(SymbolKind::Field)\n-            .detail(ty.display(self.ctx.db()).to_string())\n-            .set_documentation(field.docs(self.ctx.db()))\n-            .set_deprecated(is_deprecated);\n-\n-        item.set_relevance(CompletionRelevance {\n-            type_match: compute_type_match(self.ctx.completion, ty),\n-            exact_name_match: compute_exact_name_match(self.ctx.completion, &name),\n-            ..CompletionRelevance::default()\n-        });\n-\n-        if let Some(_ref_match) = compute_ref_match(self.ctx.completion, ty) {\n-            // FIXME\n-            // For now we don't properly calculate the edits for ref match\n-            // completions on struct fields, so we've disabled them. See #8058.\n-        }\n+    item.build()\n+}\n \n-        item.build()\n-    }\n+fn render_tuple_field_(\n+    ctx: RenderContext<'_>,\n+    receiver: Option<hir::Name>,\n+    field: usize,\n+    ty: &hir::Type,\n+) -> CompletionItem {\n+    let mut item = CompletionItem::new(\n+        CompletionKind::Reference,\n+        ctx.source_range(),\n+        receiver.map_or_else(|| field.to_string(), |receiver| format!(\"{}.{}\", receiver, field)),\n+    );\n \n-    fn render_tuple_field(\n-        &self,\n-        receiver: Option<hir::Name>,\n-        field: usize,\n-        ty: &hir::Type,\n-    ) -> CompletionItem {\n-        let mut item = CompletionItem::new(\n-            CompletionKind::Reference,\n-            self.ctx.source_range(),\n-            receiver\n-                .map_or_else(|| field.to_string(), |receiver| format!(\"{}.{}\", receiver, field)),\n-        );\n+    item.kind(SymbolKind::Field).detail(ty.display(ctx.db()).to_string());\n \n-        item.kind(SymbolKind::Field).detail(ty.display(self.ctx.db()).to_string());\n+    item.build()\n+}\n \n-        item.build()\n-    }\n+fn render_resolution_(\n+    ctx: RenderContext<'_>,\n+    local_name: hir::Name,\n+    import_to_add: Option<ImportEdit>,\n+    resolution: &hir::ScopeDef,\n+) -> Option<CompletionItem> {\n+    let _p = profile::span(\"render_resolution\");\n+    use hir::ModuleDef::*;\n \n-    fn render_resolution(\n-        self,\n-        local_name: hir::Name,\n-        import_to_add: Option<ImportEdit>,\n-        resolution: &hir::ScopeDef,\n-    ) -> Option<CompletionItem> {\n-        let _p = profile::span(\"render_resolution\");\n-        use hir::ModuleDef::*;\n-\n-        let completion_kind = match resolution {\n-            hir::ScopeDef::ModuleDef(BuiltinType(..)) => CompletionKind::BuiltinType,\n-            _ => CompletionKind::Reference,\n-        };\n+    let completion_kind = match resolution {\n+        hir::ScopeDef::ModuleDef(BuiltinType(..)) => CompletionKind::BuiltinType,\n+        _ => CompletionKind::Reference,\n+    };\n \n-        let kind = match resolution {\n-            hir::ScopeDef::ModuleDef(Function(func)) => {\n-                return render_fn(self.ctx, import_to_add, Some(local_name), *func);\n-            }\n-            hir::ScopeDef::ModuleDef(Variant(_))\n-                if self.ctx.completion.is_pat_or_const.is_some() =>\n-            {\n-                CompletionItemKind::SymbolKind(SymbolKind::Variant)\n-            }\n-            hir::ScopeDef::ModuleDef(Variant(var)) => {\n-                let item = render_variant(self.ctx, import_to_add, Some(local_name), *var, None);\n-                return Some(item);\n-            }\n-            hir::ScopeDef::MacroDef(mac) => {\n-                let item = render_macro(self.ctx, import_to_add, local_name, *mac);\n-                return item;\n-            }\n+    let kind = match resolution {\n+        hir::ScopeDef::ModuleDef(Function(func)) => {\n+            return render_fn(ctx, import_to_add, Some(local_name), *func);\n+        }\n+        hir::ScopeDef::ModuleDef(Variant(_)) if ctx.completion.is_pat_or_const.is_some() => {\n+            CompletionItemKind::SymbolKind(SymbolKind::Variant)\n+        }\n+        hir::ScopeDef::ModuleDef(Variant(var)) => {\n+            let item = render_variant(ctx, import_to_add, Some(local_name), *var, None);\n+            return Some(item);\n+        }\n+        hir::ScopeDef::MacroDef(mac) => {\n+            let item = render_macro(ctx, import_to_add, local_name, *mac);\n+            return item;\n+        }\n \n-            hir::ScopeDef::ModuleDef(Module(..)) => {\n-                CompletionItemKind::SymbolKind(SymbolKind::Module)\n-            }\n-            hir::ScopeDef::ModuleDef(Adt(adt)) => CompletionItemKind::SymbolKind(match adt {\n-                hir::Adt::Struct(_) => SymbolKind::Struct,\n-                hir::Adt::Union(_) => SymbolKind::Union,\n-                hir::Adt::Enum(_) => SymbolKind::Enum,\n-            }),\n-            hir::ScopeDef::ModuleDef(Const(..)) => {\n-                CompletionItemKind::SymbolKind(SymbolKind::Const)\n-            }\n-            hir::ScopeDef::ModuleDef(Static(..)) => {\n-                CompletionItemKind::SymbolKind(SymbolKind::Static)\n-            }\n-            hir::ScopeDef::ModuleDef(Trait(..)) => {\n-                CompletionItemKind::SymbolKind(SymbolKind::Trait)\n-            }\n-            hir::ScopeDef::ModuleDef(TypeAlias(..)) => {\n-                CompletionItemKind::SymbolKind(SymbolKind::TypeAlias)\n-            }\n-            hir::ScopeDef::ModuleDef(BuiltinType(..)) => CompletionItemKind::BuiltinType,\n-            hir::ScopeDef::GenericParam(param) => CompletionItemKind::SymbolKind(match param {\n-                hir::GenericParam::TypeParam(_) => SymbolKind::TypeParam,\n-                hir::GenericParam::LifetimeParam(_) => SymbolKind::LifetimeParam,\n-                hir::GenericParam::ConstParam(_) => SymbolKind::ConstParam,\n-            }),\n-            hir::ScopeDef::Local(..) => CompletionItemKind::SymbolKind(SymbolKind::Local),\n-            hir::ScopeDef::Label(..) => CompletionItemKind::SymbolKind(SymbolKind::Label),\n-            hir::ScopeDef::AdtSelfType(..) | hir::ScopeDef::ImplSelfType(..) => {\n-                CompletionItemKind::SymbolKind(SymbolKind::SelfParam)\n-            }\n-            hir::ScopeDef::Unknown => {\n-                let mut item = CompletionItem::new(\n-                    CompletionKind::Reference,\n-                    self.ctx.source_range(),\n-                    local_name.to_string(),\n-                );\n-                item.kind(CompletionItemKind::UnresolvedReference).add_import(import_to_add);\n-                return Some(item.build());\n-            }\n-        };\n+        hir::ScopeDef::ModuleDef(Module(..)) => CompletionItemKind::SymbolKind(SymbolKind::Module),\n+        hir::ScopeDef::ModuleDef(Adt(adt)) => CompletionItemKind::SymbolKind(match adt {\n+            hir::Adt::Struct(_) => SymbolKind::Struct,\n+            hir::Adt::Union(_) => SymbolKind::Union,\n+            hir::Adt::Enum(_) => SymbolKind::Enum,\n+        }),\n+        hir::ScopeDef::ModuleDef(Const(..)) => CompletionItemKind::SymbolKind(SymbolKind::Const),\n+        hir::ScopeDef::ModuleDef(Static(..)) => CompletionItemKind::SymbolKind(SymbolKind::Static),\n+        hir::ScopeDef::ModuleDef(Trait(..)) => CompletionItemKind::SymbolKind(SymbolKind::Trait),\n+        hir::ScopeDef::ModuleDef(TypeAlias(..)) => {\n+            CompletionItemKind::SymbolKind(SymbolKind::TypeAlias)\n+        }\n+        hir::ScopeDef::ModuleDef(BuiltinType(..)) => CompletionItemKind::BuiltinType,\n+        hir::ScopeDef::GenericParam(param) => CompletionItemKind::SymbolKind(match param {\n+            hir::GenericParam::TypeParam(_) => SymbolKind::TypeParam,\n+            hir::GenericParam::LifetimeParam(_) => SymbolKind::LifetimeParam,\n+            hir::GenericParam::ConstParam(_) => SymbolKind::ConstParam,\n+        }),\n+        hir::ScopeDef::Local(..) => CompletionItemKind::SymbolKind(SymbolKind::Local),\n+        hir::ScopeDef::Label(..) => CompletionItemKind::SymbolKind(SymbolKind::Label),\n+        hir::ScopeDef::AdtSelfType(..) | hir::ScopeDef::ImplSelfType(..) => {\n+            CompletionItemKind::SymbolKind(SymbolKind::SelfParam)\n+        }\n+        hir::ScopeDef::Unknown => {\n+            let mut item = CompletionItem::new(\n+                CompletionKind::Reference,\n+                ctx.source_range(),\n+                local_name.to_string(),\n+            );\n+            item.kind(CompletionItemKind::UnresolvedReference).add_import(import_to_add);\n+            return Some(item.build());\n+        }\n+    };\n \n-        let local_name = local_name.to_string();\n-        let mut item =\n-            CompletionItem::new(completion_kind, self.ctx.source_range(), local_name.clone());\n-        if let hir::ScopeDef::Local(local) = resolution {\n-            let ty = local.ty(self.ctx.db());\n-            if !ty.is_unknown() {\n-                item.detail(ty.display(self.ctx.db()).to_string());\n-            }\n+    let local_name = local_name.to_string();\n+    let mut item = CompletionItem::new(completion_kind, ctx.source_range(), local_name.clone());\n+    if let hir::ScopeDef::Local(local) = resolution {\n+        let ty = local.ty(ctx.db());\n+        if !ty.is_unknown() {\n+            item.detail(ty.display(ctx.db()).to_string());\n+        }\n \n-            item.set_relevance(CompletionRelevance {\n-                type_match: compute_type_match(self.ctx.completion, &ty),\n-                exact_name_match: compute_exact_name_match(self.ctx.completion, &local_name),\n-                is_local: true,\n-                ..CompletionRelevance::default()\n-            });\n+        item.set_relevance(CompletionRelevance {\n+            type_match: compute_type_match(ctx.completion, &ty),\n+            exact_name_match: compute_exact_name_match(ctx.completion, &local_name),\n+            is_local: true,\n+            ..CompletionRelevance::default()\n+        });\n \n-            if let Some(ref_match) = compute_ref_match(self.ctx.completion, &ty) {\n-                item.ref_match(ref_match);\n-            }\n-        };\n+        if let Some(ref_match) = compute_ref_match(ctx.completion, &ty) {\n+            item.ref_match(ref_match);\n+        }\n+    };\n \n-        // Add `<>` for generic types\n-        if matches!(\n-            self.ctx.completion.path_context,\n-            Some(PathCompletionContext { kind: Some(PathKind::Type), has_type_args: false, .. })\n-        ) && self.ctx.completion.config.add_call_parenthesis\n-        {\n-            if let Some(cap) = self.ctx.snippet_cap() {\n-                let has_non_default_type_params = match resolution {\n-                    hir::ScopeDef::ModuleDef(Adt(it)) => {\n-                        it.has_non_default_type_params(self.ctx.db())\n-                    }\n-                    hir::ScopeDef::ModuleDef(TypeAlias(it)) => {\n-                        it.has_non_default_type_params(self.ctx.db())\n-                    }\n-                    _ => false,\n-                };\n-                if has_non_default_type_params {\n-                    cov_mark::hit!(inserts_angle_brackets_for_generics);\n-                    item.lookup_by(local_name.clone())\n-                        .label(format!(\"{}<\u2026>\", local_name))\n-                        .insert_snippet(cap, format!(\"{}<$0>\", local_name));\n-                }\n+    // Add `<>` for generic types\n+    if matches!(\n+        ctx.completion.path_context,\n+        Some(PathCompletionContext { kind: Some(PathKind::Type), has_type_args: false, .. })\n+    ) && ctx.completion.config.add_call_parenthesis\n+    {\n+        if let Some(cap) = ctx.snippet_cap() {\n+            let has_non_default_type_params = match resolution {\n+                hir::ScopeDef::ModuleDef(Adt(it)) => it.has_non_default_type_params(ctx.db()),\n+                hir::ScopeDef::ModuleDef(TypeAlias(it)) => it.has_non_default_type_params(ctx.db()),\n+                _ => false,\n+            };\n+            if has_non_default_type_params {\n+                cov_mark::hit!(inserts_angle_brackets_for_generics);\n+                item.lookup_by(local_name.clone())\n+                    .label(format!(\"{}<\u2026>\", local_name))\n+                    .insert_snippet(cap, format!(\"{}<$0>\", local_name));\n             }\n         }\n-        item.kind(kind)\n-            .add_import(import_to_add)\n-            .set_documentation(self.docs(resolution))\n-            .set_deprecated(self.is_deprecated(resolution));\n-        Some(item.build())\n     }\n+    item.kind(kind)\n+        .add_import(import_to_add)\n+        .set_documentation(scope_def_docs(ctx.db(), resolution))\n+        .set_deprecated(scope_def_is_deprecated(&ctx, resolution));\n+    Some(item.build())\n+}\n \n-    fn docs(&self, resolution: &hir::ScopeDef) -> Option<hir::Documentation> {\n-        use hir::ModuleDef::*;\n-        match resolution {\n-            hir::ScopeDef::ModuleDef(Module(it)) => it.docs(self.ctx.db()),\n-            hir::ScopeDef::ModuleDef(Adt(it)) => it.docs(self.ctx.db()),\n-            hir::ScopeDef::ModuleDef(Variant(it)) => it.docs(self.ctx.db()),\n-            hir::ScopeDef::ModuleDef(Const(it)) => it.docs(self.ctx.db()),\n-            hir::ScopeDef::ModuleDef(Static(it)) => it.docs(self.ctx.db()),\n-            hir::ScopeDef::ModuleDef(Trait(it)) => it.docs(self.ctx.db()),\n-            hir::ScopeDef::ModuleDef(TypeAlias(it)) => it.docs(self.ctx.db()),\n-            _ => None,\n-        }\n+fn scope_def_docs(db: &RootDatabase, resolution: &hir::ScopeDef) -> Option<hir::Documentation> {\n+    use hir::ModuleDef::*;\n+    match resolution {\n+        hir::ScopeDef::ModuleDef(Module(it)) => it.docs(db),\n+        hir::ScopeDef::ModuleDef(Adt(it)) => it.docs(db),\n+        hir::ScopeDef::ModuleDef(Variant(it)) => it.docs(db),\n+        hir::ScopeDef::ModuleDef(Const(it)) => it.docs(db),\n+        hir::ScopeDef::ModuleDef(Static(it)) => it.docs(db),\n+        hir::ScopeDef::ModuleDef(Trait(it)) => it.docs(db),\n+        hir::ScopeDef::ModuleDef(TypeAlias(it)) => it.docs(db),\n+        _ => None,\n     }\n+}\n \n-    fn is_deprecated(&self, resolution: &hir::ScopeDef) -> bool {\n-        match resolution {\n-            hir::ScopeDef::ModuleDef(it) => self.ctx.is_deprecated_assoc_item(*it),\n-            hir::ScopeDef::MacroDef(it) => self.ctx.is_deprecated(*it),\n-            hir::ScopeDef::GenericParam(it) => self.ctx.is_deprecated(*it),\n-            hir::ScopeDef::AdtSelfType(it) => self.ctx.is_deprecated(*it),\n-            _ => false,\n-        }\n+fn scope_def_is_deprecated(ctx: &RenderContext<'_>, resolution: &hir::ScopeDef) -> bool {\n+    match resolution {\n+        hir::ScopeDef::ModuleDef(it) => ctx.is_deprecated_assoc_item(*it),\n+        hir::ScopeDef::MacroDef(it) => ctx.is_deprecated(*it),\n+        hir::ScopeDef::GenericParam(it) => ctx.is_deprecated(*it),\n+        hir::ScopeDef::AdtSelfType(it) => ctx.is_deprecated(*it),\n+        _ => false,\n     }\n }\n "}]}