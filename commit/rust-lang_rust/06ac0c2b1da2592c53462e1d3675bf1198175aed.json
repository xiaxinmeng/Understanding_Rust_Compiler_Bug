{"sha": "06ac0c2b1da2592c53462e1d3675bf1198175aed", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2YWMwYzJiMWRhMjU5MmM1MzQ2MmUxZDM2NzViZjExOTgxNzVhZWQ=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2012-07-21T04:49:20Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-07-24T00:15:30Z"}, "message": "Switch reader to work with preallocated vecs\n\nThis closes #2901.", "tree": {"sha": "bbc762c42c7fa64c8dd4c413d6bae9bd7fd1727b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bbc762c42c7fa64c8dd4c413d6bae9bd7fd1727b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/06ac0c2b1da2592c53462e1d3675bf1198175aed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/06ac0c2b1da2592c53462e1d3675bf1198175aed", "html_url": "https://github.com/rust-lang/rust/commit/06ac0c2b1da2592c53462e1d3675bf1198175aed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/06ac0c2b1da2592c53462e1d3675bf1198175aed/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d042c0f2d9fa56d7286a8f3d2fa2f5427128ea5", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d042c0f2d9fa56d7286a8f3d2fa2f5427128ea5", "html_url": "https://github.com/rust-lang/rust/commit/6d042c0f2d9fa56d7286a8f3d2fa2f5427128ea5"}], "stats": {"total": 98, "additions": 60, "deletions": 38}, "files": [{"sha": "4da7044e48b135e6fa1990d8c5d42eef948322ca", "filename": "src/libcore/io.rs", "status": "modified", "additions": 31, "deletions": 17, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/06ac0c2b1da2592c53462e1d3675bf1198175aed/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06ac0c2b1da2592c53462e1d3675bf1198175aed/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=06ac0c2b1da2592c53462e1d3675bf1198175aed", "patch": "@@ -30,7 +30,9 @@ enum seek_style { seek_set, seek_end, seek_cur, }\n // The raw underlying reader iface. All readers must implement this.\n iface reader {\n     // FIXME (#2004): Seekable really should be orthogonal.\n-    fn read_bytes(uint) -> ~[u8];\n+\n+    // FIXME (#2982): This should probably return an error.\n+    fn read(buf: &[mut u8], len: uint) -> uint;\n     fn read_byte() -> int;\n     fn unread_byte(int);\n     fn eof() -> bool;\n@@ -41,6 +43,16 @@ iface reader {\n // Generic utility functions defined on readers\n \n impl reader_util for reader {\n+    fn read_bytes(len: uint) -> ~[u8] {\n+        let mut buf = ~[mut];\n+        vec::reserve(buf, len);\n+        unsafe { vec::unsafe::set_len(buf, len); }\n+\n+        let count = self.read(buf, len);\n+\n+        unsafe { vec::unsafe::set_len(buf, count); }\n+        vec::from_mut(buf)\n+    }\n     fn read_chars(n: uint) -> ~[char] {\n         // returns the (consumed offset, n_req), appends characters to &chars\n         fn chars_from_buf(buf: ~[u8], &chars: ~[char]) -> (uint, uint) {\n@@ -192,15 +204,15 @@ fn convert_whence(whence: seek_style) -> i32 {\n }\n \n impl of reader for *libc::FILE {\n-    fn read_bytes(len: uint) -> ~[u8] {\n-        let mut buf : ~[mut u8] = ~[mut];\n-        vec::reserve(buf, len);\n-        do vec::as_mut_buf(buf) |b| {\n-            let read = libc::fread(b as *mut c_void, 1u as size_t,\n-                                   len as size_t, self);\n-            unsafe { vec::unsafe::set_len(buf, read as uint) };\n+    fn read(buf: &[mut u8], len: uint) -> uint {\n+        do vec::unpack_slice(buf) |buf_p, buf_len| {\n+            assert buf_len <= len;\n+\n+            let count = libc::fread(buf_p as *mut c_void, 1u as size_t,\n+                                    len as size_t, self);\n+\n+            count as uint\n         }\n-        ret vec::from_mut(buf);\n     }\n     fn read_byte() -> int { ret libc::fgetc(self) as int; }\n     fn unread_byte(byte: int) { libc::ungetc(byte as c_int, self); }\n@@ -216,7 +228,7 @@ impl of reader for *libc::FILE {\n // duration of its lifetime.\n // FIXME there really should be a better way to do this // #2004\n impl <T: reader, C> of reader for {base: T, cleanup: C} {\n-    fn read_bytes(len: uint) -> ~[u8] { self.base.read_bytes(len) }\n+    fn read(buf: &[mut u8], len: uint) -> uint { self.base.read(buf, len) }\n     fn read_byte() -> int { self.base.read_byte() }\n     fn unread_byte(byte: int) { self.base.unread_byte(byte); }\n     fn eof() -> bool { self.base.eof() }\n@@ -262,13 +274,15 @@ fn file_reader(path: ~str) -> result<reader, ~str> {\n type byte_buf = {buf: ~[const u8], mut pos: uint, len: uint};\n \n impl of reader for byte_buf {\n-    fn read_bytes(len: uint) -> ~[u8] {\n-        let rest = self.len - self.pos;\n-        let mut to_read = len;\n-        if rest < to_read { to_read = rest; }\n-        let range = vec::slice(self.buf, self.pos, self.pos + to_read);\n-        self.pos += to_read;\n-        ret range;\n+    fn read(buf: &[mut u8], len: uint) -> uint {\n+        let count = uint::min(len, self.len - self.pos);\n+\n+        vec::u8::memcpy(buf, vec::const_view(self.buf, self.pos, self.len),\n+                        count);\n+\n+        self.pos += count;\n+\n+        count\n     }\n     fn read_byte() -> int {\n         if self.pos == self.len { ret -1; }"}, {"sha": "1229d0724de79133e34dda2e9a631327459940ef", "filename": "src/libcore/run.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06ac0c2b1da2592c53462e1d3675bf1198175aed/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06ac0c2b1da2592c53462e1d3675bf1198175aed/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=06ac0c2b1da2592c53462e1d3675bf1198175aed", "patch": "@@ -1,6 +1,7 @@\n //! Process spawning\n import option::{some, none};\n import libc::{pid_t, c_void, c_int};\n+import io::reader_util;\n \n export program;\n export run_program;"}, {"sha": "4826bc760c23762d90b5d3ff3210a9be7d9c4d30", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 28, "deletions": 21, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/06ac0c2b1da2592c53462e1d3675bf1198175aed/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06ac0c2b1da2592c53462e1d3675bf1198175aed/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=06ac0c2b1da2592c53462e1d3675bf1198175aed", "patch": "@@ -11,7 +11,7 @@ import future::extensions;\n import result::*;\n import libc::size_t;\n import str::extensions;\n-import io::{reader, writer};\n+import io::{reader, reader_util, writer};\n \n // tcp interfaces\n export tcp_socket;\n@@ -766,34 +766,41 @@ impl tcp_socket for tcp_socket {\n \n /// Implementation of `io::reader` iface for a buffered `net::tcp::tcp_socket`\n impl tcp_socket_buf of io::reader for @tcp_socket_buf {\n-    fn read_bytes(amt: uint) -> ~[u8] {\n-        let has_amt_available =\n-            vec::len((*(self.data)).buf) >= amt;\n-        if has_amt_available {\n-            // no arbitrary-length shift in vec::?\n-            let mut ret_buf = ~[];\n-            while vec::len(ret_buf) < amt {\n-                ret_buf += ~[vec::shift((*(self.data)).buf)];\n-            }\n-            ret_buf\n-        }\n-        else {\n-            let read_result = read((*(self.data)).sock, 0u);\n+    fn read(buf: &[mut u8], len: uint) -> uint {\n+        // Loop until our buffer has enough data in it for us to read from.\n+        while self.data.buf.len() < len {\n+            let read_result = read(self.data.sock, 0u);\n             if read_result.is_err() {\n                 let err_data = read_result.get_err();\n-                log(debug, #fmt(\"ERROR sock_buf as io::reader.read err %? %?\",\n-                                 err_data.err_name, err_data.err_msg));\n-                ~[]\n+\n+                if err_data.err_name == ~\"EOF\" {\n+                    break;\n+                } else {\n+                    #debug(\"ERROR sock_buf as io::reader.read err %? %?\",\n+                           err_data.err_name, err_data.err_msg);\n+\n+                    ret 0;\n+                }\n             }\n             else {\n-                let new_chunk = result::unwrap(read_result);\n-                (*(self.data)).buf += new_chunk;\n-                self.read_bytes(amt)\n+                vec::push_all(self.data.buf, result::unwrap(read_result));\n             }\n         }\n+\n+        let count = uint::min(len, self.data.buf.len());\n+\n+        let mut data = ~[];\n+        self.data.buf <-> data;\n+\n+        vec::u8::memcpy(buf, vec::view(data, 0, data.len()), count);\n+\n+        vec::push_all(self.data.buf, vec::view(data, count, data.len()));\n+\n+        count\n     }\n     fn read_byte() -> int {\n-        self.read_bytes(1u)[0] as int\n+        let bytes = ~[0];\n+        if self.read(bytes, 1u) == 0 { fail } else { bytes[0] as int }\n     }\n     fn unread_byte(amt: int) {\n         vec::unshift((*(self.data)).buf, amt as u8);"}]}