{"sha": "1064c7513a9cbe8a9d891a8ab20567b6649744d7", "node_id": "C_kwDOAAsO6NoAKDEwNjRjNzUxM2E5Y2JlOGE5ZDg5MWE4YWIyMDU2N2I2NjQ5NzQ0ZDc", "commit": {"author": {"name": "bitgaoshu", "email": "bitgaoshu@gmail.com", "date": "2022-06-21T12:05:49Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2022-06-23T12:01:22Z"}, "message": "reformat code", "tree": {"sha": "a5378009f61a2dd375677ae1acb2ea0e102939b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a5378009f61a2dd375677ae1acb2ea0e102939b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1064c7513a9cbe8a9d891a8ab20567b6649744d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1064c7513a9cbe8a9d891a8ab20567b6649744d7", "html_url": "https://github.com/rust-lang/rust/commit/1064c7513a9cbe8a9d891a8ab20567b6649744d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1064c7513a9cbe8a9d891a8ab20567b6649744d7/comments", "author": {"login": "bitgaoshu", "id": 7943146, "node_id": "MDQ6VXNlcjc5NDMxNDY=", "avatar_url": "https://avatars.githubusercontent.com/u/7943146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bitgaoshu", "html_url": "https://github.com/bitgaoshu", "followers_url": "https://api.github.com/users/bitgaoshu/followers", "following_url": "https://api.github.com/users/bitgaoshu/following{/other_user}", "gists_url": "https://api.github.com/users/bitgaoshu/gists{/gist_id}", "starred_url": "https://api.github.com/users/bitgaoshu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bitgaoshu/subscriptions", "organizations_url": "https://api.github.com/users/bitgaoshu/orgs", "repos_url": "https://api.github.com/users/bitgaoshu/repos", "events_url": "https://api.github.com/users/bitgaoshu/events{/privacy}", "received_events_url": "https://api.github.com/users/bitgaoshu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ef5e14c2c072fca9792d3da7c6443850790d779", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ef5e14c2c072fca9792d3da7c6443850790d779", "html_url": "https://github.com/rust-lang/rust/commit/1ef5e14c2c072fca9792d3da7c6443850790d779"}], "stats": {"total": 87, "additions": 43, "deletions": 44}, "files": [{"sha": "b61febe3a68d0c4248984279f9a4a2af9c3758c7", "filename": "crates/hir-ty/src/method_resolution.rs", "status": "modified", "additions": 26, "deletions": 21, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/1064c7513a9cbe8a9d891a8ab20567b6649744d7/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1064c7513a9cbe8a9d891a8ab20567b6649744d7/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=1064c7513a9cbe8a9d891a8ab20567b6649744d7", "patch": "@@ -997,33 +997,38 @@ pub fn resolve_indexing_op(\n struct Valid;\n impl Valid {\n     fn valid_impl(\n-        impls: impl Iterator<Item = ImplId>,\n+        mut impls: impl Iterator<Item = ImplId>,\n         table: &mut InferenceTable,\n         self_ty: &Ty,\n     ) -> Option<Arc<ImplData>> {\n         let db = table.db;\n-        for impl_ in impls {\n-            let impl_data = db.impl_data(impl_);\n-            let substs =\n-                TyBuilder::subst_for_def(db, impl_).fill_with_inference_vars(table).build();\n-            let impl_ty =\n-                substs.apply(db.impl_self_ty(impl_).into_value_and_skipped_binders().0, Interner);\n-\n-            if !table.unify(self_ty, &impl_ty) {\n-                continue;\n-            }\n-\n-            let wh_goals = crate::chalk_db::convert_where_clauses(db, impl_.into(), &substs)\n-                .into_iter()\n-                .map(|b| b.into_well_formed_goal(Interner).cast(Interner));\n-\n-            let goal = crate::Goal::all(Interner, wh_goals);\n-\n-            if table.try_obligation(goal).is_some() {\n-                return Some(impl_data);\n+        loop {\n+            let impl_ = impls.next()?;\n+            let r = table.run_in_snapshot(|table| {\n+                let impl_data = db.impl_data(impl_);\n+                let substs =\n+                    TyBuilder::subst_for_def(db, impl_).fill_with_inference_vars(table).build();\n+                let impl_ty = substs\n+                    .apply(db.impl_self_ty(impl_).into_value_and_skipped_binders().0, Interner);\n+\n+                table\n+                    .unify(self_ty, &impl_ty)\n+                    .then(|| {\n+                        let wh_goals =\n+                            crate::chalk_db::convert_where_clauses(db, impl_.into(), &substs)\n+                                .into_iter()\n+                                .map(|b| b.into_well_formed_goal(Interner).cast(Interner));\n+\n+                        let goal = crate::Goal::all(Interner, wh_goals);\n+\n+                        table.try_obligation(goal).map(|_| impl_data)\n+                    })\n+                    .flatten()\n+            });\n+            if r.is_some() {\n+                break r;\n             }\n         }\n-        None\n     }\n \n     fn is_valid_item("}, {"sha": "2b1e8e325e4af8becf428a297efc9354e03d4c41", "filename": "crates/ide-db/src/defs.rs", "status": "modified", "additions": 17, "deletions": 23, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/1064c7513a9cbe8a9d891a8ab20567b6649744d7/crates%2Fide-db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1064c7513a9cbe8a9d891a8ab20567b6649744d7/crates%2Fide-db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fdefs.rs?ref=1064c7513a9cbe8a9d891a8ab20567b6649744d7", "patch": "@@ -438,29 +438,23 @@ impl NameRefClass {\n         name_ref: ast::NameRef,\n     ) -> Option<NameRefClass> {\n         let parent = name_ref.syntax().parent()?;\n-        match_ast! {\n-           match parent {\n-               ast::MethodCallExpr(method_call) => {\n-                   sema.resolve_impl_method(&ast::Expr::MethodCallExpr(method_call))\n-                       .map(Definition::Function)\n-                       .map(NameRefClass::Definition)\n-               },\n-               ast::PathSegment(ps) => {\n-                   ps.syntax().parent().and_then(ast::Path::cast)\n-                   .map(|p|\n-                       p.syntax()\n-                       .parent()\n-                       .and_then(ast::PathExpr::cast)\n-                       .map(|pe|\n-                           sema.resolve_impl_method(&ast::Expr::PathExpr(pe))\n-                           .map(Definition::Function)\n-                           .map(NameRefClass::Definition)\n-                       ).flatten()\n-                   ).flatten()\n-               },\n-               _=> None\n-           }\n-        }\n+        let expr = match_ast! {\n+            match parent {\n+                ast::MethodCallExpr(method_call) => {\n+                    Some(ast::Expr::MethodCallExpr(method_call))\n+                },\n+                ast::PathSegment(..) => {\n+                    parent.ancestors()\n+                    .find_map(ast::PathExpr::cast)\n+                    .map(ast::Expr::PathExpr)\n+                },\n+                _=> None\n+            }\n+        };\n+        expr.as_ref()\n+            .and_then(|e| sema.resolve_impl_method(e))\n+            .map(Definition::Function)\n+            .map(NameRefClass::Definition)\n     }\n     pub fn classify_lifetime(\n         sema: &Semantics<RootDatabase>,"}]}