{"sha": "660cf34d8c905d96ad47b5107d58931203d68a35", "node_id": "C_kwDOAAsO6NoAKDY2MGNmMzRkOGM5MDVkOTZhZDQ3YjUxMDdkNTg5MzEyMDNkNjhhMzU", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-12-28T16:13:30Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-12-28T16:13:30Z"}, "message": "dead code", "tree": {"sha": "cdf1b2d4f06c474e0862b155864460b7ef31162b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cdf1b2d4f06c474e0862b155864460b7ef31162b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/660cf34d8c905d96ad47b5107d58931203d68a35", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/660cf34d8c905d96ad47b5107d58931203d68a35", "html_url": "https://github.com/rust-lang/rust/commit/660cf34d8c905d96ad47b5107d58931203d68a35", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/660cf34d8c905d96ad47b5107d58931203d68a35/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bfc263f1f98aece963a4b103d787005346f0c1c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/bfc263f1f98aece963a4b103d787005346f0c1c7", "html_url": "https://github.com/rust-lang/rust/commit/bfc263f1f98aece963a4b103d787005346f0c1c7"}], "stats": {"total": 79, "additions": 9, "deletions": 70}, "files": [{"sha": "07dcfd967177e72d539d5fa8ac801d4c831f0793", "filename": "crates/ide_assists/src/handlers/remove_dbg.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/660cf34d8c905d96ad47b5107d58931203d68a35/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/660cf34d8c905d96ad47b5107d58931203d68a35/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs?ref=660cf34d8c905d96ad47b5107d58931203d68a35", "patch": "@@ -36,9 +36,8 @@ pub(crate) fn remove_dbg(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let input_expressions = input_expressions\n         .into_iter()\n         .filter_map(|(is_sep, group)| (!is_sep).then(|| group))\n-        .map(|mut tokens| ast::Expr::parse(&tokens.join(\"\")))\n-        .collect::<Result<Vec<ast::Expr>, _>>()\n-        .ok()?;\n+        .map(|mut tokens| syntax::hacks::parse_expr_from_str(&tokens.join(\"\")))\n+        .collect::<Option<Vec<ast::Expr>>>()?;\n \n     let parent = macro_call.syntax().parent()?;\n     let (range, text) = match &*input_expressions {"}, {"sha": "42426a1df285871ffa2a134cd698a7e6cdf41023", "filename": "crates/parser/src/grammar.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/660cf34d8c905d96ad47b5107d58931203d68a35/crates%2Fparser%2Fsrc%2Fgrammar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/660cf34d8c905d96ad47b5107d58931203d68a35/crates%2Fparser%2Fsrc%2Fgrammar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar.rs?ref=660cf34d8c905d96ad47b5107d58931203d68a35", "patch": "@@ -117,18 +117,6 @@ pub(crate) mod entry {\n     }\n }\n \n-pub(crate) mod entry_points {\n-    use super::*;\n-\n-    pub(crate) fn stmt_optional_semi(p: &mut Parser) {\n-        expressions::stmt(p, expressions::StmtWithSemi::Optional, false);\n-    }\n-\n-    pub(crate) fn attr(p: &mut Parser) {\n-        attributes::outer_attrs(p);\n-    }\n-}\n-\n pub(crate) fn reparser(\n     node: SyntaxKind,\n     first_child: Option<SyntaxKind>,"}, {"sha": "c5014be6c33668f90dc6577771187b1bbbaa1e64", "filename": "crates/parser/src/lib.rs", "status": "modified", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/660cf34d8c905d96ad47b5107d58931203d68a35/crates%2Fparser%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/660cf34d8c905d96ad47b5107d58931203d68a35/crates%2Fparser%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Flib.rs?ref=660cf34d8c905d96ad47b5107d58931203d68a35", "patch": "@@ -132,47 +132,6 @@ impl TopEntryPoint {\n     }\n }\n \n-/// rust-analyzer parser allows you to choose one of the possible entry points.\n-///\n-/// The primary consumer of this API are declarative macros, `$x:expr` matchers\n-/// are implemented by calling into the parser with non-standard entry point.\n-#[derive(Debug, Clone, Copy, Eq, PartialEq, Hash)]\n-pub enum ParserEntryPoint {\n-    Path,\n-    Expr,\n-    StatementOptionalSemi,\n-    Pattern,\n-    Attr,\n-}\n-\n-/// Parse given tokens into the given sink as a rust file.\n-pub fn parse_source_file(input: &Input) -> Output {\n-    TopEntryPoint::SourceFile.parse(input)\n-}\n-\n-/// Parses the given [`Input`] into [`Output`] assuming that the top-level\n-/// syntactic construct is the given [`ParserEntryPoint`].\n-///\n-/// Both input and output here are fairly abstract. The overall flow is that the\n-/// caller has some \"real\" tokens, converts them to [`Input`], parses them to\n-/// [`Output`], and then converts that into a \"real\" tree. The \"real\" tree is\n-/// made of \"real\" tokens, so this all hinges on rather tight coordination of\n-/// indices between the four stages.\n-pub fn parse(inp: &Input, entry_point: ParserEntryPoint) -> Output {\n-    let entry_point: fn(&'_ mut parser::Parser) = match entry_point {\n-        ParserEntryPoint::Path => grammar::entry::prefix::path,\n-        ParserEntryPoint::Expr => grammar::entry::prefix::expr,\n-        ParserEntryPoint::Pattern => grammar::entry::prefix::pat,\n-        ParserEntryPoint::StatementOptionalSemi => grammar::entry_points::stmt_optional_semi,\n-        ParserEntryPoint::Attr => grammar::entry_points::attr,\n-    };\n-\n-    let mut p = parser::Parser::new(inp);\n-    entry_point(&mut p);\n-    let events = p.finish();\n-    event::process(events)\n-}\n-\n /// A parsing function for a specific braced-block.\n pub struct Reparser(fn(&mut parser::Parser));\n "}, {"sha": "3d28f814c9f2ece9e953f7995da5940c9db22557", "filename": "crates/parser/src/shortcuts.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/660cf34d8c905d96ad47b5107d58931203d68a35/crates%2Fparser%2Fsrc%2Fshortcuts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/660cf34d8c905d96ad47b5107d58931203d68a35/crates%2Fparser%2Fsrc%2Fshortcuts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fshortcuts.rs?ref=660cf34d8c905d96ad47b5107d58931203d68a35", "patch": "@@ -52,14 +52,10 @@ impl<'a> LexedStr<'a> {\n     pub fn intersperse_trivia(\n         &self,\n         output: &crate::Output,\n-        synthetic_root: bool,\n         sink: &mut dyn FnMut(StrStep),\n     ) -> bool {\n         let mut builder = Builder { lexed: self, pos: 0, state: State::PendingEnter, sink };\n \n-        if synthetic_root {\n-            builder.enter(SyntaxKind::SOURCE_FILE);\n-        }\n         for event in output.iter() {\n             match event {\n                 Step::Token { kind, n_input_tokens: n_raw_tokens } => {\n@@ -73,9 +69,6 @@ impl<'a> LexedStr<'a> {\n                 }\n             }\n         }\n-        if synthetic_root {\n-            builder.exit();\n-        }\n \n         match mem::replace(&mut builder.state, State::Normal) {\n             State::PendingExit => {"}, {"sha": "512f7ddb95bbc05ab63478f0006d6963027c2408", "filename": "crates/parser/src/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/660cf34d8c905d96ad47b5107d58931203d68a35/crates%2Fparser%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/660cf34d8c905d96ad47b5107d58931203d68a35/crates%2Fparser%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Ftests.rs?ref=660cf34d8c905d96ad47b5107d58931203d68a35", "patch": "@@ -80,12 +80,12 @@ fn parse_inline_err() {\n fn parse(text: &str) -> (String, bool) {\n     let lexed = LexedStr::new(text);\n     let input = lexed.to_input();\n-    let output = crate::parse_source_file(&input);\n+    let output = crate::TopEntryPoint::SourceFile.parse(&input);\n \n     let mut buf = String::new();\n     let mut errors = Vec::new();\n     let mut indent = String::new();\n-    lexed.intersperse_trivia(&output, false, &mut |step| match step {\n+    lexed.intersperse_trivia(&output, &mut |step| match step {\n         crate::StrStep::Token { kind, text } => {\n             write!(buf, \"{}\", indent).unwrap();\n             write!(buf, \"{:?} {:?}\\n\", kind, text).unwrap();"}, {"sha": "a047f61fa03cbc177de53a1eaab12ca2b96b02fd", "filename": "crates/syntax/src/hacks.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/660cf34d8c905d96ad47b5107d58931203d68a35/crates%2Fsyntax%2Fsrc%2Fhacks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/660cf34d8c905d96ad47b5107d58931203d68a35/crates%2Fsyntax%2Fsrc%2Fhacks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fhacks.rs?ref=660cf34d8c905d96ad47b5107d58931203d68a35", "patch": "@@ -5,6 +5,7 @@\n use crate::{ast, AstNode};\n \n pub fn parse_expr_from_str(s: &str) -> Option<ast::Expr> {\n+    let s = s.trim();\n     let file = ast::SourceFile::parse(&format!(\"const _: () = {};\", s));\n     let expr = file.syntax_node().descendants().find_map(ast::Expr::cast)?;\n     if expr.syntax().text() != s {"}, {"sha": "047e670c9f45eb0d7b32b9e40f8c5b14d8dec152", "filename": "crates/syntax/src/parsing.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/660cf34d8c905d96ad47b5107d58931203d68a35/crates%2Fsyntax%2Fsrc%2Fparsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/660cf34d8c905d96ad47b5107d58931203d68a35/crates%2Fsyntax%2Fsrc%2Fparsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fparsing.rs?ref=660cf34d8c905d96ad47b5107d58931203d68a35", "patch": "@@ -12,19 +12,18 @@ pub(crate) use crate::parsing::reparsing::incremental_reparse;\n pub(crate) fn parse_text(text: &str) -> (GreenNode, Vec<SyntaxError>) {\n     let lexed = parser::LexedStr::new(text);\n     let parser_input = lexed.to_input();\n-    let parser_output = parser::parse_source_file(&parser_input);\n-    let (node, errors, _eof) = build_tree(lexed, parser_output, false);\n+    let parser_output = parser::TopEntryPoint::SourceFile.parse(&parser_input);\n+    let (node, errors, _eof) = build_tree(lexed, parser_output);\n     (node, errors)\n }\n \n pub(crate) fn build_tree(\n     lexed: parser::LexedStr<'_>,\n     parser_output: parser::Output,\n-    synthetic_root: bool,\n ) -> (GreenNode, Vec<SyntaxError>, bool) {\n     let mut builder = SyntaxTreeBuilder::default();\n \n-    let is_eof = lexed.intersperse_trivia(&parser_output, synthetic_root, &mut |step| match step {\n+    let is_eof = lexed.intersperse_trivia(&parser_output, &mut |step| match step {\n         parser::StrStep::Token { kind, text } => builder.token(kind, text),\n         parser::StrStep::Enter { kind } => builder.start_node(kind),\n         parser::StrStep::Exit => builder.finish_node(),"}, {"sha": "701e6232d5898ba0e9976d72d03ddfbe59acf42e", "filename": "crates/syntax/src/parsing/reparsing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/660cf34d8c905d96ad47b5107d58931203d68a35/crates%2Fsyntax%2Fsrc%2Fparsing%2Freparsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/660cf34d8c905d96ad47b5107d58931203d68a35/crates%2Fsyntax%2Fsrc%2Fparsing%2Freparsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fparsing%2Freparsing.rs?ref=660cf34d8c905d96ad47b5107d58931203d68a35", "patch": "@@ -96,7 +96,7 @@ fn reparse_block(\n \n     let tree_traversal = reparser.parse(&parser_input);\n \n-    let (green, new_parser_errors, _eof) = build_tree(lexed, tree_traversal, false);\n+    let (green, new_parser_errors, _eof) = build_tree(lexed, tree_traversal);\n \n     Some((node.replace_with(green), new_parser_errors, node.text_range()))\n }"}]}