{"sha": "b20eb970e18377191465cb37f2074f467dfd61b1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyMGViOTcwZTE4Mzc3MTkxNDY1Y2IzN2YyMDc0ZjQ2N2RmZDYxYjE=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-05-06T15:23:51Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-05-06T15:33:54Z"}, "message": "libsyntax: extend generic deriving code to handle almost all possible traits.\n\nThis adds support for static methods, and arguments of most types, traits with\ntype parameters, methods with type parameters (and lifetimes for both), as well\nas making the code more robust to support deriving on types with lifetimes (i.e.\n'self).", "tree": {"sha": "11ac991d67a5bfef9022d90bc2715406e925d8c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/11ac991d67a5bfef9022d90bc2715406e925d8c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b20eb970e18377191465cb37f2074f467dfd61b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b20eb970e18377191465cb37f2074f467dfd61b1", "html_url": "https://github.com/rust-lang/rust/commit/b20eb970e18377191465cb37f2074f467dfd61b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b20eb970e18377191465cb37f2074f467dfd61b1/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e6a4be19d8e6a2cedc66be6cc602db8a1e71acd", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e6a4be19d8e6a2cedc66be6cc602db8a1e71acd", "html_url": "https://github.com/rust-lang/rust/commit/6e6a4be19d8e6a2cedc66be6cc602db8a1e71acd"}], "stats": {"total": 1490, "additions": 936, "deletions": 554}, "files": [{"sha": "c1163fda844f6e102113d3e1e35d18ff57769ef1", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 59, "deletions": 25, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/b20eb970e18377191465cb37f2074f467dfd61b1/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b20eb970e18377191465cb37f2074f467dfd61b1/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=b20eb970e18377191465cb37f2074f467dfd61b1", "patch": "@@ -54,43 +54,52 @@ pub fn mk_binary(cx: @ext_ctxt, sp: span, op: ast::binop,\n     cx.next_id(); // see ast_util::op_expr_callee_id\n     mk_expr(cx, sp, ast::expr_binary(op, lhs, rhs))\n }\n+\n+pub fn mk_deref(cx: @ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n+    mk_unary(cx, sp, ast::deref, e)\n+}\n pub fn mk_unary(cx: @ext_ctxt, sp: span, op: ast::unop, e: @ast::expr)\n              -> @ast::expr {\n     cx.next_id(); // see ast_util::op_expr_callee_id\n     mk_expr(cx, sp, ast::expr_unary(op, e))\n }\n pub fn mk_raw_path(sp: span, idents: ~[ast::ident]) -> @ast::Path {\n-    mk_raw_path_(sp, idents, ~[])\n+    mk_raw_path_(sp, idents, None, ~[])\n }\n pub fn mk_raw_path_(sp: span,\n                     idents: ~[ast::ident],\n+                    rp: Option<@ast::Lifetime>,\n                     types: ~[@ast::Ty])\n                  -> @ast::Path {\n     @ast::Path { span: sp,\n                  global: false,\n                  idents: idents,\n-                 rp: None,\n+                 rp: rp,\n                  types: types }\n }\n pub fn mk_raw_path_global(sp: span, idents: ~[ast::ident]) -> @ast::Path {\n-    mk_raw_path_global_(sp, idents, ~[])\n+    mk_raw_path_global_(sp, idents, None, ~[])\n }\n pub fn mk_raw_path_global_(sp: span,\n                            idents: ~[ast::ident],\n+                           rp: Option<@ast::Lifetime>,\n                            types: ~[@ast::Ty]) -> @ast::Path {\n     @ast::Path { span: sp,\n                  global: true,\n                  idents: idents,\n-                 rp: None,\n+                 rp: rp,\n                  types: types }\n }\n+pub fn mk_path_raw(cx: @ext_ctxt, sp: span, path: @ast::Path)-> @ast::expr {\n+    mk_expr(cx, sp, ast::expr_path(path))\n+}\n pub fn mk_path(cx: @ext_ctxt, sp: span, idents: ~[ast::ident])\n             -> @ast::expr {\n-    mk_expr(cx, sp, ast::expr_path(mk_raw_path(sp, idents)))\n+    mk_path_raw(cx, sp, mk_raw_path(sp, idents))\n }\n pub fn mk_path_global(cx: @ext_ctxt, sp: span, idents: ~[ast::ident])\n                    -> @ast::expr {\n-    mk_expr(cx, sp, ast::expr_path(mk_raw_path_global(sp, idents)))\n+    mk_path_raw(cx, sp, mk_raw_path_global(sp, idents))\n }\n pub fn mk_access_(cx: @ext_ctxt, sp: span, p: @ast::expr, m: ast::ident)\n                -> @ast::expr {\n@@ -354,44 +363,69 @@ pub fn mk_stmt(cx: @ext_ctxt, span: span, expr: @ast::expr) -> @ast::stmt {\n     let stmt_ = ast::stmt_semi(expr, cx.next_id());\n     @codemap::spanned { node: stmt_, span: span }\n }\n+\n+pub fn mk_ty_mt(ty: @ast::Ty, mutbl: ast::mutability) -> ast::mt {\n+    ast::mt {\n+        ty: ty,\n+        mutbl: mutbl\n+    }\n+}\n+\n+pub fn mk_ty(cx: @ext_ctxt,\n+             span: span,\n+             ty: ast::ty_) -> @ast::Ty {\n+    @ast::Ty {\n+        id: cx.next_id(),\n+        span: span,\n+        node: ty\n+    }\n+}\n+\n pub fn mk_ty_path(cx: @ext_ctxt,\n                   span: span,\n                   idents: ~[ ast::ident ])\n                -> @ast::Ty {\n     let ty = build::mk_raw_path(span, idents);\n-    let ty = ast::ty_path(ty, cx.next_id());\n-    let ty = @ast::Ty { id: cx.next_id(), node: ty, span: span };\n-    ty\n+    mk_ty_path_path(cx, span, ty)\n }\n+\n pub fn mk_ty_path_global(cx: @ext_ctxt,\n                          span: span,\n                          idents: ~[ ast::ident ])\n                       -> @ast::Ty {\n     let ty = build::mk_raw_path_global(span, idents);\n-    let ty = ast::ty_path(ty, cx.next_id());\n-    let ty = @ast::Ty { id: cx.next_id(), node: ty, span: span };\n-    ty\n+    mk_ty_path_path(cx, span, ty)\n }\n+\n+pub fn mk_ty_path_path(cx: @ext_ctxt,\n+                       span: span,\n+                       path: @ast::Path)\n+                      -> @ast::Ty {\n+    let ty = ast::ty_path(path, cx.next_id());\n+    mk_ty(cx, span, ty)\n+}\n+\n pub fn mk_ty_rptr(cx: @ext_ctxt,\n                   span: span,\n                   ty: @ast::Ty,\n+                  lifetime: Option<@ast::Lifetime>,\n                   mutbl: ast::mutability)\n                -> @ast::Ty {\n-    @ast::Ty {\n-        id: cx.next_id(),\n-        span: span,\n-        node: ast::ty_rptr(\n-            None,\n-            ast::mt { ty: ty, mutbl: mutbl }\n-        ),\n-    }\n+    mk_ty(cx, span,\n+          ast::ty_rptr(lifetime, mk_ty_mt(ty, mutbl)))\n+}\n+pub fn mk_ty_uniq(cx: @ext_ctxt, span: span, ty: @ast::Ty) -> @ast::Ty {\n+    mk_ty(cx, span, ast::ty_uniq(mk_ty_mt(ty, ast::m_imm)))\n }\n+pub fn mk_ty_box(cx: @ext_ctxt, span: span,\n+                 ty: @ast::Ty, mutbl: ast::mutability) -> @ast::Ty {\n+    mk_ty(cx, span, ast::ty_box(mk_ty_mt(ty, mutbl)))\n+}\n+\n+\n+\n pub fn mk_ty_infer(cx: @ext_ctxt, span: span) -> @ast::Ty {\n-    @ast::Ty {\n-        id: cx.next_id(),\n-        node: ast::ty_infer,\n-        span: span,\n-    }\n+    mk_ty(cx, span, ast::ty_infer)\n }\n pub fn mk_trait_ref_global(cx: @ext_ctxt,\n                            span: span,"}, {"sha": "1c33fe3507076dd7425c8bcfd1d00573ad059b0a", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b20eb970e18377191465cb37f2074f467dfd61b1/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b20eb970e18377191465cb37f2074f467dfd61b1/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=b20eb970e18377191465cb37f2074f467dfd61b1", "patch": "@@ -13,7 +13,6 @@ use codemap::span;\n use ext::base::ext_ctxt;\n use ext::build;\n use ext::deriving::generic::*;\n-use core::option::{None,Some};\n \n \n pub fn expand_deriving_clone(cx: @ext_ctxt,\n@@ -22,13 +21,16 @@ pub fn expand_deriving_clone(cx: @ext_ctxt,\n                              in_items: ~[@item])\n                           -> ~[@item] {\n     let trait_def = TraitDef {\n-        path: ~[~\"core\", ~\"clone\", ~\"Clone\"],\n+        path: Path::new(~[~\"core\", ~\"clone\", ~\"Clone\"]),\n         additional_bounds: ~[],\n+        generics: LifetimeBounds::empty(),\n         methods: ~[\n             MethodDef {\n                 name: ~\"clone\",\n-                nargs: 0,\n-                output_type: None, // return Self\n+                generics: LifetimeBounds::empty(),\n+                self_ty: borrowed_explicit_self(),\n+                args: ~[],\n+                ret_ty: Self,\n                 const_nonmatching: false,\n                 combine_substructure: cs_clone\n             }\n@@ -66,7 +68,8 @@ fn cs_clone(cx: @ext_ctxt, span: span,\n             ctor_ident = ~[ variant.node.name ];\n             all_fields = af;\n         },\n-        EnumNonMatching(*) => cx.bug(\"Non-matching enum variants in `deriving(Clone)`\")\n+        EnumNonMatching(*) => cx.span_bug(span, \"Non-matching enum variants in `deriving(Clone)`\"),\n+        StaticEnum(*) | StaticStruct(*) => cx.span_bug(span, \"Static method in `deriving(Clone)`\")\n     }\n \n     match all_fields {"}, {"sha": "e431e1f78bff93743c5c608e7048e5cfc6a7562d", "filename": "src/libsyntax/ext/deriving/cmp/eq.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b20eb970e18377191465cb37f2074f467dfd61b1/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b20eb970e18377191465cb37f2074f467dfd61b1/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs?ref=b20eb970e18377191465cb37f2074f467dfd61b1", "patch": "@@ -8,44 +8,45 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use ast::{meta_item, item, expr};\n use codemap::span;\n use ext::base::ext_ctxt;\n use ext::build;\n use ext::deriving::generic::*;\n \n-use core::option::Some;\n-\n pub fn expand_deriving_eq(cx: @ext_ctxt,\n                           span: span,\n                           mitem: @meta_item,\n                           in_items: ~[@item]) -> ~[@item] {\n     // structures are equal if all fields are equal, and non equal, if\n     // any fields are not equal or if the enum variants are different\n     fn cs_eq(cx: @ext_ctxt, span: span, substr: &Substructure) -> @expr {\n-        cs_and(|cx, span, _| build::mk_bool(cx, span, false),\n+        cs_and(|cx, span, _, _| build::mk_bool(cx, span, false),\n                                  cx, span, substr)\n     }\n     fn cs_ne(cx: @ext_ctxt, span: span, substr: &Substructure) -> @expr {\n-        cs_or(|cx, span, _| build::mk_bool(cx, span, true),\n+        cs_or(|cx, span, _, _| build::mk_bool(cx, span, true),\n               cx, span, substr)\n     }\n+\n     macro_rules! md (\n         ($name:expr, $f:ident) => {\n             MethodDef {\n                 name: $name,\n-                output_type: Some(~[~\"bool\"]),\n-                nargs: 1,\n+                generics: LifetimeBounds::empty(),\n+                self_ty: borrowed_explicit_self(),\n+                args: ~[borrowed_self()],\n+                ret_ty: Literal(Path::new(~[~\"bool\"])),\n                 const_nonmatching: true,\n                 combine_substructure: $f\n             },\n         }\n-    )\n+    );\n \n     let trait_def = TraitDef {\n-        path: ~[~\"core\", ~\"cmp\", ~\"Eq\"],\n+        path: Path::new(~[~\"core\", ~\"cmp\", ~\"Eq\"]),\n         additional_bounds: ~[],\n+        generics: LifetimeBounds::empty(),\n         methods: ~[\n             md!(~\"eq\", cs_eq),\n             md!(~\"ne\", cs_ne)"}, {"sha": "5998fc7145df335dcc138c8b08ab316c22ffdd80", "filename": "src/libsyntax/ext/deriving/cmp/ord.rs", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b20eb970e18377191465cb37f2074f467dfd61b1/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b20eb970e18377191465cb37f2074f467dfd61b1/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs?ref=b20eb970e18377191465cb37f2074f467dfd61b1", "patch": "@@ -14,29 +14,33 @@ use codemap::span;\n use ext::base::ext_ctxt;\n use ext::build;\n use ext::deriving::generic::*;\n-use core::option::Some;\n-\n-macro_rules! md {\n-    ($name:expr, $less:expr, $equal:expr) => {\n-        MethodDef {\n-            name: $name,\n-            output_type: Some(~[~\"bool\"]),\n-            nargs: 1,\n-            const_nonmatching: false,\n-            combine_substructure: |cx, span, substr|\n-                    cs_ord($less, $equal, cx, span, substr)\n-        }\n-    }\n-}\n \n pub fn expand_deriving_ord(cx: @ext_ctxt,\n                            span: span,\n                            mitem: @meta_item,\n                            in_items: ~[@item]) -> ~[@item] {\n+    macro_rules! md (\n+        ($name:expr, $less:expr, $equal:expr) => {\n+            MethodDef {\n+                name: $name,\n+                generics: LifetimeBounds::empty(),\n+                self_ty: borrowed_explicit_self(),\n+                args: ~[borrowed_self()],\n+                ret_ty: Literal(Path::new(~[~\"bool\"])),\n+                const_nonmatching: false,\n+                combine_substructure: |cx, span, substr|\n+                    cs_ord($less, $equal, cx, span, substr)\n+            }\n+        }\n+    );\n+\n+\n+\n     let trait_def = TraitDef {\n-        path: ~[~\"core\", ~\"cmp\", ~\"Ord\"],\n+        path: Path::new(~[~\"core\", ~\"cmp\", ~\"Ord\"]),\n         // XXX: Ord doesn't imply Eq yet\n-        additional_bounds: ~[~[~\"core\", ~\"cmp\", ~\"Eq\"]],\n+        additional_bounds: ~[Literal(Path::new(~[~\"core\", ~\"cmp\", ~\"Eq\"]))],\n+        generics: LifetimeBounds::empty(),\n         methods: ~[\n             md!(~\"lt\", true,  false),\n             md!(~\"le\", true,  true),\n@@ -97,19 +101,19 @@ fn cs_ord(less: bool, equal: bool,\n             }\n \n             let cmp = build::mk_method_call(cx, span,\n-                                            self_f, cx.ident_of(~\"eq\"), other_fs);\n+                                            self_f, cx.ident_of(~\"eq\"), other_fs.to_owned());\n             let subexpr = build::mk_simple_block(cx, span, subexpr);\n             let elseif = expr_if(cmp, subexpr, Some(false_blk_expr));\n             let elseif = build::mk_expr(cx, span, elseif);\n \n             let cmp = build::mk_method_call(cx, span,\n-                                            self_f, binop, other_fs);\n+                                            self_f, binop, other_fs.to_owned());\n             let if_ = expr_if(cmp, true_blk, Some(elseif));\n \n             build::mk_expr(cx, span, if_)\n         },\n         base,\n-        |cx, span, args| {\n+        |cx, span, args, _| {\n             // nonmatching enums, order by the order the variants are\n             // written\n             match args {"}, {"sha": "068a7bc06b1e5e09cdbe6a5799d1caa47ec55937", "filename": "src/libsyntax/ext/deriving/cmp/totaleq.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b20eb970e18377191465cb37f2074f467dfd61b1/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b20eb970e18377191465cb37f2074f467dfd61b1/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs?ref=b20eb970e18377191465cb37f2074f467dfd61b1", "patch": "@@ -15,26 +15,27 @@ use ext::base::ext_ctxt;\n use ext::build;\n use ext::deriving::generic::*;\n \n-use core::option::Some;\n-\n pub fn expand_deriving_totaleq(cx: @ext_ctxt,\n                           span: span,\n                           mitem: @meta_item,\n                           in_items: ~[@item]) -> ~[@item] {\n \n     fn cs_equals(cx: @ext_ctxt, span: span, substr: &Substructure) -> @expr {\n-        cs_and(|cx, span, _| build::mk_bool(cx, span, false),\n+        cs_and(|cx, span, _, _| build::mk_bool(cx, span, false),\n                cx, span, substr)\n     }\n \n     let trait_def = TraitDef {\n-        path: ~[~\"core\", ~\"cmp\", ~\"TotalEq\"],\n+        path: Path::new(~[~\"core\", ~\"cmp\", ~\"TotalEq\"]),\n         additional_bounds: ~[],\n+        generics: LifetimeBounds::empty(),\n         methods: ~[\n             MethodDef {\n                 name: ~\"equals\",\n-                output_type: Some(~[~\"bool\"]),\n-                nargs: 1,\n+                generics: LifetimeBounds::empty(),\n+                self_ty: borrowed_explicit_self(),\n+                args: ~[borrowed_self()],\n+                ret_ty: Literal(Path::new(~[~\"bool\"])),\n                 const_nonmatching: true,\n                 combine_substructure: cs_equals\n             }"}, {"sha": "ac873c5bd123c782490e0f25395f24dc13db7e24", "filename": "src/libsyntax/ext/deriving/cmp/totalord.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b20eb970e18377191465cb37f2074f467dfd61b1/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b20eb970e18377191465cb37f2074f467dfd61b1/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs?ref=b20eb970e18377191465cb37f2074f467dfd61b1", "patch": "@@ -14,20 +14,22 @@ use ext::base::ext_ctxt;\n use ext::build;\n use ext::deriving::generic::*;\n use core::cmp::{Ordering, Equal, Less, Greater};\n-use core::option::Some;\n \n pub fn expand_deriving_totalord(cx: @ext_ctxt,\n                                 span: span,\n                                 mitem: @meta_item,\n                                 in_items: ~[@item]) -> ~[@item] {\n     let trait_def = TraitDef {\n-        path: ~[~\"core\", ~\"cmp\", ~\"TotalOrd\"],\n+        path: Path::new(~[~\"core\", ~\"cmp\", ~\"TotalOrd\"]),\n         additional_bounds: ~[],\n+        generics: LifetimeBounds::empty(),\n         methods: ~[\n             MethodDef {\n                 name: ~\"cmp\",\n-                output_type: Some(~[~\"core\", ~\"cmp\", ~\"Ordering\"]),\n-                nargs: 1,\n+                generics: LifetimeBounds::empty(),\n+                self_ty: borrowed_explicit_self(),\n+                args: ~[borrowed_self()],\n+                ret_ty: Literal(Path::new(~[~\"core\", ~\"cmp\", ~\"Ordering\"])),\n                 const_nonmatching: false,\n                 combine_substructure: cs_cmp\n             }\n@@ -64,7 +66,7 @@ pub fn cs_cmp(cx: @ext_ctxt, span: span,\n             build::mk_call_global(cx, span, lexical_ord, ~[old, new])\n         },\n         ordering_const(cx, span, Equal),\n-        |cx, span, list| {\n+        |cx, span, list, _| {\n             match list {\n                 // an earlier nonmatching variant is Less than a\n                 // later one"}, {"sha": "79cc4a3bda84f4a09e64128dd1d051faae02770b", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b20eb970e18377191465cb37f2074f467dfd61b1/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b20eb970e18377191465cb37f2074f467dfd61b1/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=b20eb970e18377191465cb37f2074f467dfd61b1", "patch": "@@ -66,6 +66,7 @@ fn create_derived_decodable_impl(\n             cx.ident_of(~\"serialize\"),\n             cx.ident_of(~\"Decodable\")\n         ],\n+        None,\n         ~[\n             build::mk_simple_ty_path(cx, span, cx.ident_of(~\"__D\"))\n         ]\n@@ -77,7 +78,7 @@ fn create_derived_decodable_impl(\n         generics,\n         methods,\n         trait_path,\n-        generic_ty_params,\n+        Generics { ty_params: generic_ty_params, lifetimes: opt_vec::Empty },\n         opt_vec::Empty\n     )\n }\n@@ -96,6 +97,7 @@ fn create_decode_method(\n         cx,\n         span,\n         build::mk_simple_ty_path(cx, span, cx.ident_of(~\"__D\")),\n+        None,\n         ast::m_mutbl\n     );\n     let d_ident = cx.ident_of(~\"__d\");"}, {"sha": "8b86173dc24e7e4dfdd7f566b8de361d47faff42", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b20eb970e18377191465cb37f2074f467dfd61b1/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b20eb970e18377191465cb37f2074f467dfd61b1/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=b20eb970e18377191465cb37f2074f467dfd61b1", "patch": "@@ -66,6 +66,7 @@ fn create_derived_encodable_impl(\n             cx.ident_of(~\"serialize\"),\n             cx.ident_of(~\"Encodable\")\n         ],\n+        None,\n         ~[\n             build::mk_simple_ty_path(cx, span, cx.ident_of(~\"__E\"))\n         ]\n@@ -77,7 +78,7 @@ fn create_derived_encodable_impl(\n         generics,\n         methods,\n         trait_path,\n-        generic_ty_params,\n+        Generics { ty_params: generic_ty_params, lifetimes: opt_vec::Empty },\n         opt_vec::Empty\n     )\n }\n@@ -94,6 +95,7 @@ fn create_encode_method(\n         cx,\n         span,\n         build::mk_simple_ty_path(cx, span, cx.ident_of(~\"__E\")),\n+        None,\n         ast::m_mutbl\n     );\n     let e_arg = build::mk_arg(cx, span, cx.ident_of(~\"__e\"), e_arg_type);\n@@ -303,19 +305,15 @@ fn expand_deriving_encodable_enum_method(\n     // Create the arms of the match in the method body.\n     let arms = do enum_definition.variants.mapi |i, variant| {\n         // Create the matching pattern.\n-        let pat = create_enum_variant_pattern(cx, span, variant, ~\"__self\");\n+        let (pat, fields) = create_enum_variant_pattern(cx, span, variant, ~\"__self\", ast::m_imm);\n \n         // Feed the discriminant to the encode function.\n         let mut stmts = ~[];\n \n         // Feed each argument in this variant to the encode function\n         // as well.\n         let variant_arg_len = variant_arg_count(cx, span, variant);\n-        for uint::range(0, variant_arg_len) |j| {\n-            // Create the expression for this field.\n-            let field_ident = cx.ident_of(~\"__self_\" + j.to_str());\n-            let field = build::mk_path(cx, span, ~[ field_ident ]);\n-\n+        for fields.eachi |j, &(_, field)| {\n             // Call the substructure method.\n             let expr = call_substructure_encode_method(cx, span, field);\n "}, {"sha": "565d6dd59baac533fb72371ebe3ffafe99e76d2f", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 430, "deletions": 355, "changes": 785, "blob_url": "https://github.com/rust-lang/rust/blob/b20eb970e18377191465cb37f2074f467dfd61b1/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b20eb970e18377191465cb37f2074f467dfd61b1/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=b20eb970e18377191465cb37f2074f467dfd61b1", "patch": "@@ -16,23 +16,22 @@ access to the fields of the 4 different sorts of structs and enum\n variants, as well as creating the method and impl ast instances.\n \n Supported features (fairly exhaustive):\n-- Methods taking any number of parameters of type `&Self`, including\n-  none other than `self`. (`MethodDef.nargs`)\n-- Methods returning `Self` or a non-parameterised type\n-  (e.g. `bool` or `core::cmp::Ordering`). (`MethodDef.output_type`)\n-- Generating `impl`s for types with type parameters\n+- Methods taking any number of parameters of any type, and returning\n+  any type, other than vectors, bottom and closures.\n+- Generating `impl`s for types with type parameters and lifetimes\n   (e.g. `Option<T>`), the parameters are automatically given the\n-  current trait as a bound.\n+  current trait as a bound. (This includes separate type parameters\n+  and lifetimes for methods.)\n - Additional bounds on the type parameters, e.g. the `Ord` instance\n   requires an explicit `Eq` bound at the\n   moment. (`TraitDef.additional_bounds`)\n \n-(Key unsupported things: methods with arguments of non-`&Self` type,\n-traits with parameters, methods returning parameterised types, static\n-methods.)\n+Unsupported: FIXME #6257: calling methods on borrowed pointer fields,\n+e.g. deriving TotalEq/TotalOrd/Clone don't work on `struct A(&int)`,\n+because of how the auto-dereferencing happens.\n \n The most important thing for implementers is the `Substructure` and\n-`SubstructureFields` objects. The latter groups 3 possibilities of the\n+`SubstructureFields` objects. The latter groups 5 possibilities of the\n arguments:\n \n - `Struct`, when `Self` is a struct (including tuple structs, e.g\n@@ -42,42 +41,57 @@ arguments:\n - `EnumNonMatching` when `Self` is an enum and the arguments are not\n   the same variant (e.g. `None`, `Some(1)` and `None`). If\n   `const_nonmatching` is true, this will contain an empty list.\n+- `StaticEnum` and `StaticStruct` for static methods, where the type\n+  being derived upon is either a enum or struct respectively. (Any\n+  argument with type Self is just grouped among the non-self\n+  arguments.)\n \n In the first two cases, the values from the corresponding fields in\n all the arguments are grouped together. In the `EnumNonMatching` case\n this isn't possible (different variants have different fields), so the\n-fields are grouped by which argument they come from.\n+fields are grouped by which argument they come from. There are no\n+fields with values in the static cases, so these are treated entirely\n+differently.\n \n-All of the cases have `Option<ident>` in several places associated\n+The non-static cases have `Option<ident>` in several places associated\n with field `expr`s. This represents the name of the field it is\n associated with. It is only not `None` when the associated field has\n an identifier in the source code. For example, the `x`s in the\n following snippet\n \n-    struct A { x : int }\n+~~~\n+struct A { x : int }\n \n-    struct B(int);\n+struct B(int);\n \n-    enum C {\n-        C0(int),\n-        C1 { x: int }\n-    }\n+enum C {\n+    C0(int),\n+    C1 { x: int }\n+}\n \n The `int`s in `B` and `C0` don't have an identifier, so the\n `Option<ident>`s would be `None` for them.\n \n+In the static cases, the structure is summarised, either into the\n+number of fields or a list of field idents (for tuple structs and\n+record structs, respectively), or a list of these, for enums (one for\n+each variant). For empty struct and empty enum variants, it is\n+represented as a count of 0.\n+\n # Examples\n \n The following simplified `Eq` is used for in-code examples:\n \n-    trait Eq {\n-        fn eq(&self, other: &Self);\n-    }\n-    impl Eq for int {\n-        fn eq(&self, other: &int) -> bool {\n-            *self == *other\n-        }\n+~~~\n+trait Eq {\n+    fn eq(&self, other: &Self);\n+}\n+impl Eq for int {\n+    fn eq(&self, other: &int) -> bool {\n+        *self == *other\n     }\n+}\n+~~~\n \n Some examples of the values of `SubstructureFields` follow, using the\n above `Eq`, `A`, `B` and `C`.\n@@ -86,65 +100,85 @@ above `Eq`, `A`, `B` and `C`.\n \n When generating the `expr` for the `A` impl, the `SubstructureFields` is\n \n-    Struct(~[(Some(<ident of x>),\n-             <expr for self.x>,\n-             ~[<expr for other.x])])\n+~~~\n+Struct(~[(Some(<ident of x>),\n+         <expr for &self.x>,\n+         ~[<expr for &other.x])])\n+~~~\n \n For the `B` impl, called with `B(a)` and `B(b)`,\n \n-    Struct(~[(None,\n-              <expr for a>\n-              ~[<expr for b>])])\n+~~~\n+Struct(~[(None,\n+          <expr for &a>\n+          ~[<expr for &b>])])\n+~~~\n \n ## Enums\n \n When generating the `expr` for a call with `self == C0(a)` and `other\n == C0(b)`, the SubstructureFields is\n \n-    EnumMatching(0, <ast::variant for C0>,\n-                 ~[None,\n-                   <expr for a>,\n-                   ~[<expr for b>]])\n+~~~\n+EnumMatching(0, <ast::variant for C0>,\n+             ~[None,\n+               <expr for &a>,\n+               ~[<expr for &b>]])\n+~~~\n \n For `C1 {x}` and `C1 {x}`,\n \n-    EnumMatching(1, <ast::variant for C1>,\n-                 ~[Some(<ident of x>),\n-                   <expr for self.x>,\n-                   ~[<expr for other.x>]])\n+~~~\n+EnumMatching(1, <ast::variant for C1>,\n+             ~[Some(<ident of x>),\n+               <expr for &self.x>,\n+               ~[<expr for &other.x>]])\n+~~~\n \n For `C0(a)` and `C1 {x}` ,\n \n-    EnumNonMatching(~[(0, <ast::variant for B0>,\n-                       ~[(None, <expr for a>)]),\n-                      (1, <ast::variant for B1>,\n-                       ~[(Some(<ident of x>),\n-                          <expr for other.x>)])])\n+~~~\n+EnumNonMatching(~[(0, <ast::variant for B0>,\n+                   ~[(None, <expr for &a>)]),\n+                  (1, <ast::variant for B1>,\n+                   ~[(Some(<ident of x>),\n+                      <expr for &other.x>)])])\n+~~~\n+\n+(and vice versa, but with the order of the outermost list flipped.)\n \n-(and vice verse, but with the order of the outermost list flipped.)\n+## Static\n+\n+A static method on the above would result in,\n+\n+~~~~\n+StaticStruct(<ast::struct_def of A>, Right(~[<ident of x>]))\n+\n+StaticStruct(<ast::struct_def of B>, Left(1))\n+\n+StaticEnum(<ast::enum_def of C>, ~[(<ident of C0>, Left(1)),\n+                                   (<ident of C1>, Right(~[<ident of x>]))])\n+~~~\n \n */\n \n use ast;\n+use ast::{enum_def, expr, ident, Generics, struct_def};\n \n-use ast::{\n-    and, binop, deref, enum_def, expr, expr_match, ident, impure_fn,\n-    item, Generics, m_imm, meta_item, method, named_field, or,\n-    pat_wild, public, struct_def, sty_region, ty_rptr, ty_path,\n-    variant};\n-\n-use ast_util;\n use ext::base::ext_ctxt;\n use ext::build;\n use ext::deriving::*;\n use codemap::{span,respan};\n use opt_vec;\n \n+pub use self::ty::*;\n+mod ty;\n+\n pub fn expand_deriving_generic(cx: @ext_ctxt,\n                                span: span,\n-                               _mitem: @meta_item,\n-                               in_items: ~[@item],\n-                               trait_def: &TraitDef) -> ~[@item] {\n+                               _mitem: @ast::meta_item,\n+                               in_items: ~[@ast::item],\n+                               trait_def: &TraitDef) -> ~[@ast::item] {\n     let expand_enum: ExpandDerivingEnumDefFn =\n         |cx, span, enum_def, type_ident, generics| {\n         trait_def.expand_enum_def(cx, span, enum_def, type_ident, generics)\n@@ -160,44 +194,63 @@ pub fn expand_deriving_generic(cx: @ext_ctxt,\n }\n \n pub struct TraitDef<'self> {\n-    /// Path of the trait\n-    path: ~[~str],\n-    /// Additional bounds required of any type parameters, other than\n-    /// the current trait\n-    additional_bounds: ~[~[~str]],\n+    /// Path of the trait, including any type parameters\n+    path: Path,\n+    /// Additional bounds required of any type parameters of the type,\n+    /// other than the current trait\n+    additional_bounds: ~[Ty],\n+\n+    /// Any extra lifetimes and/or bounds, e.g. `D: std::serialize::Decoder`\n+    generics: LifetimeBounds,\n+\n     methods: ~[MethodDef<'self>]\n }\n \n+\n pub struct MethodDef<'self> {\n     /// name of the method\n     name: ~str,\n-    /// The path of return type of the method, e.g. `~[~\"core\",\n-    /// ~\"cmp\", ~\"Eq\"]`. `None` for `Self`.\n-    output_type: Option<~[~str]>,\n-    /// Number of arguments other than `self` (all of type `&Self`)\n-    nargs: uint,\n+    /// List of generics, e.g. `R: core::rand::Rng`\n+    generics: LifetimeBounds,\n+\n+    /// Whether there is a self argument (outer Option) i.e. whether\n+    /// this is a static function, and whether it is a pointer (inner\n+    /// Option)\n+    self_ty: Option<Option<PtrTy>>,\n+\n+    /// Arguments other than the self argument\n+    args: ~[Ty],\n+\n+    /// Return type\n+    ret_ty: Ty,\n \n     /// if the value of the nonmatching enums is independent of the\n-    /// actual enums, i.e. can use _ => .. match.\n+    /// actual enum variants, i.e. can use _ => .. match.\n     const_nonmatching: bool,\n \n     combine_substructure: CombineSubstructureFunc<'self>\n }\n \n /// All the data about the data structure/method being derived upon.\n pub struct Substructure<'self> {\n+    /// ident of self\n     type_ident: ident,\n+    /// ident of the method\n     method_ident: ident,\n-    fields: &'self SubstructureFields\n+    /// dereferenced access to any Self or Ptr(Self, _) arguments\n+    self_args: &'self [@expr],\n+    /// verbatim access to any other arguments\n+    nonself_args: &'self [@expr],\n+    fields: &'self SubstructureFields<'self>\n }\n \n /// A summary of the possible sets of fields. See above for details\n /// and examples\n-pub enum SubstructureFields {\n+pub enum SubstructureFields<'self> {\n     /**\n-    Vec of `(field ident, self, [others])` where the field ident is\n-    the ident of the current field (`None` for all fields in tuple\n-    structs)\n+    Vec of `(field ident, self_or_other)` where the field\n+    ident is the ident of the current field (`None` for all fields in tuple\n+    structs).\n     */\n     Struct(~[(Option<ident>, @expr, ~[@expr])]),\n \n@@ -206,17 +259,23 @@ pub enum SubstructureFields {\n     fields: `(field ident, self, [others])`, where the field ident is\n     only non-`None` in the case of a struct variant.\n     */\n-    EnumMatching(uint, variant, ~[(Option<ident>, @expr, ~[@expr])]),\n+    EnumMatching(uint, ast::variant, ~[(Option<ident>, @expr, ~[@expr])]),\n \n     /**\n     non-matching variants of the enum, [(variant index, ast::variant,\n     [field ident, fields])] (i.e. all fields for self are in the\n     first tuple, for other1 are in the second tuple, etc.)\n     */\n-    EnumNonMatching(~[(uint, variant, ~[(Option<ident>, @expr)])])\n+    EnumNonMatching(~[(uint, ast::variant, ~[(Option<ident>, @expr)])]),\n+\n+    /// A static method where Self is a struct\n+    StaticStruct(&'self ast::struct_def, Either<uint, ~[ident]>),\n+    /// A static method where Self is an enum\n+    StaticEnum(&'self ast::enum_def, ~[(ident, Either<uint, ~[ident]>)])\n }\n \n \n+\n /**\n Combine the values of all the fields together. The last argument is\n all the fields of all the structures, see above for details.\n@@ -225,54 +284,63 @@ pub type CombineSubstructureFunc<'self> =\n     &'self fn(@ext_ctxt, span, &Substructure) -> @expr;\n \n /**\n-Deal with non-matching enum variants, the argument is a list\n+Deal with non-matching enum variants, the arguments are a list\n representing each variant: (variant index, ast::variant instance,\n-[variant fields])\n+[variant fields]), and a list of the nonself args of the type\n */\n pub type EnumNonMatchFunc<'self> =\n-    &'self fn(@ext_ctxt, span, ~[(uint, variant, ~[(Option<ident>, @expr)])]) -> @expr;\n-\n+    &'self fn(@ext_ctxt, span,\n+              ~[(uint, ast::variant,\n+                 ~[(Option<ident>, @expr)])],\n+              &[@expr]) -> @expr;\n \n \n impl<'self> TraitDef<'self> {\n     fn create_derived_impl(&self, cx: @ext_ctxt, span: span,\n                            type_ident: ident, generics: &Generics,\n-                           methods: ~[@method]) -> @item {\n-        let trait_path = build::mk_raw_path_global(\n-            span,\n-            do self.path.map |&s| { cx.ident_of(s) });\n+                           methods: ~[@ast::method]) -> @ast::item {\n+        let trait_path = self.path.to_path(cx, span, type_ident, generics);\n+\n+        let trait_generics = self.generics.to_generics(cx, span, type_ident, generics);\n \n         let additional_bounds = opt_vec::from(\n-            do self.additional_bounds.map |v| {\n-                do v.map |&s| { cx.ident_of(s) }\n+            do self.additional_bounds.map |p| {\n+                p.to_path(cx, span, type_ident, generics)\n             });\n+\n         create_derived_impl(cx, span,\n                             type_ident, generics,\n                             methods, trait_path,\n-                            opt_vec::Empty,\n+                            trait_generics,\n                             additional_bounds)\n     }\n \n     fn expand_struct_def(&self, cx: @ext_ctxt,\n                          span: span,\n                          struct_def: &struct_def,\n                          type_ident: ident,\n-                         generics: &Generics)\n-    -> @item {\n-        let is_tuple = is_struct_tuple(struct_def);\n-\n+                         generics: &Generics) -> @ast::item {\n         let methods = do self.methods.map |method_def| {\n-            let body = if is_tuple {\n-                method_def.expand_struct_tuple_method_body(cx, span,\n-                                                           struct_def,\n-                                                           type_ident)\n+            let (self_ty, self_args, nonself_args, tys) =\n+                method_def.split_self_nonself_args(cx, span, type_ident, generics);\n+\n+            let body = if method_def.is_static() {\n+                method_def.expand_static_struct_method_body(\n+                    cx, span,\n+                    struct_def,\n+                    type_ident,\n+                    self_args, nonself_args)\n             } else {\n                 method_def.expand_struct_method_body(cx, span,\n                                                      struct_def,\n-                                                     type_ident)\n+                                                     type_ident,\n+                                                     self_args, nonself_args)\n             };\n \n-            method_def.create_method(cx, span, type_ident, generics, body)\n+            method_def.create_method(cx, span,\n+                                     type_ident, generics,\n+                                     self_ty, tys,\n+                                     body)\n         };\n \n         self.create_derived_impl(cx, span, type_ident, generics, methods)\n@@ -282,13 +350,28 @@ impl<'self> TraitDef<'self> {\n                        cx: @ext_ctxt, span: span,\n                        enum_def: &enum_def,\n                        type_ident: ident,\n-                       generics: &Generics) -> @item {\n+                       generics: &Generics) -> @ast::item {\n         let methods = do self.methods.map |method_def| {\n-            let body = method_def.expand_enum_method_body(cx, span,\n-                                                          enum_def,\n-                                                          type_ident);\n+            let (self_ty, self_args, nonself_args, tys) =\n+                method_def.split_self_nonself_args(cx, span, type_ident, generics);\n+\n+            let body = if method_def.is_static() {\n+                method_def.expand_static_enum_method_body(\n+                    cx, span,\n+                    enum_def,\n+                    type_ident,\n+                    self_args, nonself_args)\n+            } else {\n+                method_def.expand_enum_method_body(cx, span,\n+                                                   enum_def,\n+                                                   type_ident,\n+                                                   self_args, nonself_args)\n+            };\n \n-            method_def.create_method(cx, span, type_ident, generics, body)\n+            method_def.create_method(cx, span,\n+                                     type_ident, generics,\n+                                     self_ty, tys,\n+                                     body)\n         };\n \n         self.create_derived_impl(cx, span, type_ident, generics, methods)\n@@ -300,280 +383,255 @@ impl<'self> MethodDef<'self> {\n                                 cx: @ext_ctxt,\n                                 span: span,\n                                 type_ident: ident,\n+                                self_args: &[@expr],\n+                                nonself_args: &[@expr],\n                                 fields: &SubstructureFields)\n         -> @expr {\n         let substructure = Substructure {\n             type_ident: type_ident,\n             method_ident: cx.ident_of(self.name),\n+            self_args: self_args,\n+            nonself_args: nonself_args,\n             fields: fields\n         };\n         (self.combine_substructure)(cx, span,\n                                     &substructure)\n     }\n \n-    fn get_output_type_path(&self, cx: @ext_ctxt, span: span,\n-                              generics: &Generics, type_ident: ident) -> @ast::Path {\n-        match self.output_type {\n-            None => { // Self, add any type parameters\n-                let out_ty_params = do vec::build |push| {\n-                    for generics.ty_params.each |ty_param| {\n-                        push(build::mk_ty_path(cx, span, ~[ ty_param.ident ]));\n-                    }\n-                };\n+    fn get_ret_ty(&self, cx: @ext_ctxt, span: span,\n+                     generics: &Generics, type_ident: ident) -> @ast::Ty {\n+        self.ret_ty.to_ty(cx, span, type_ident, generics)\n+    }\n+\n+    fn is_static(&self) -> bool {\n+        self.self_ty.is_none()\n+    }\n \n-                build::mk_raw_path_(span, ~[ type_ident ], out_ty_params)\n+    fn split_self_nonself_args(&self, cx: @ext_ctxt, span: span,\n+                             type_ident: ident, generics: &Generics)\n+        -> (ast::self_ty, ~[@expr], ~[@expr], ~[(ident, @ast::Ty)]) {\n+\n+        let mut self_args = ~[], nonself_args = ~[], arg_tys = ~[];\n+        let mut ast_self_ty = respan(span, ast::sty_static);\n+        let mut nonstatic = false;\n+\n+        match self.self_ty {\n+            Some(self_ptr) => {\n+                let (self_expr, self_ty) = ty::get_explicit_self(cx, span, self_ptr);\n+\n+                ast_self_ty = self_ty;\n+                self_args.push(self_expr);\n+                nonstatic = true;\n             }\n-            Some(str_path) => {\n-                let p = do str_path.map |&s| { cx.ident_of(s) };\n-                build::mk_raw_path_global(span, p)\n+            _ => {}\n+        }\n+\n+        for self.args.eachi |i, ty| {\n+            let ast_ty = ty.to_ty(cx, span, type_ident, generics);\n+            let ident = cx.ident_of(fmt!(\"__arg_%u\", i));\n+            arg_tys.push((ident, ast_ty));\n+\n+            let arg_expr = build::mk_path(cx, span, ~[ident]);\n+\n+            match *ty {\n+                // for static methods, just treat any Self\n+                // arguments as a normal arg\n+                Self if nonstatic  => {\n+                    self_args.push(arg_expr);\n+                }\n+                Ptr(~Self, _) if nonstatic => {\n+                    self_args.push(build::mk_deref(cx, span, arg_expr))\n+                }\n+                _ => {\n+                    nonself_args.push(arg_expr);\n+                }\n             }\n         }\n+\n+        (ast_self_ty, self_args, nonself_args, arg_tys)\n     }\n \n     fn create_method(&self, cx: @ext_ctxt, span: span,\n                      type_ident: ident,\n-                     generics: &Generics, body: @expr) -> @method {\n-        // Create the `Self` type of the `other` parameters.\n-        let arg_path_type = create_self_type_with_params(cx,\n-                                                         span,\n-                                                         type_ident,\n-                                                         generics);\n-        let arg_type = ty_rptr(\n-            None,\n-            ast::mt { ty: arg_path_type, mutbl: m_imm }\n-        );\n-        let arg_type = @ast::Ty {\n-            id: cx.next_id(),\n-            node: arg_type,\n-            span: span,\n+                     generics: &Generics,\n+                     self_ty: ast::self_ty,\n+                     arg_types: ~[(ident, @ast::Ty)],\n+                     body: @expr) -> @ast::method {\n+        // create the generics that aren't for Self\n+        let fn_generics = self.generics.to_generics(cx, span, type_ident, generics);\n+\n+        let args = do arg_types.map |&(id, ty)| {\n+            build::mk_arg(cx, span, id, ty)\n         };\n \n-        // create the arguments\n-        let other_idents = create_other_idents(cx, self.nargs);\n-        let args = do other_idents.map |&id| {\n-            build::mk_arg(cx, span, id, arg_type)\n-        };\n-\n-        let output_type = self.get_output_type_path(cx, span, generics, type_ident);\n-        let output_type = ty_path(output_type, cx.next_id());\n-        let output_type = @ast::Ty {\n-            id: cx.next_id(),\n-            node: output_type,\n-            span: span,\n-        };\n+        let ret_type = self.get_ret_ty(cx, span, generics, type_ident);\n \n         let method_ident = cx.ident_of(self.name);\n-        let fn_decl = build::mk_fn_decl(args, output_type);\n+        let fn_decl = build::mk_fn_decl(args, ret_type);\n         let body_block = build::mk_simple_block(cx, span, body);\n \n+\n         // Create the method.\n-        let self_ty = respan(span, sty_region(None, m_imm));\n         @ast::method {\n             ident: method_ident,\n             attrs: ~[],\n-            generics: ast_util::empty_generics(),\n+            generics: fn_generics,\n             self_ty: self_ty,\n-            purity: impure_fn,\n+            purity: ast::impure_fn,\n             decl: fn_decl,\n             body: body_block,\n             id: cx.next_id(),\n             span: span,\n             self_id: cx.next_id(),\n-            vis: public\n+            vis: ast::public\n         }\n     }\n \n     /**\n-    ```\n+    ~~~\n     #[deriving(Eq)]\n-    struct A(int, int);\n+    struct A { x: int, y: int }\n \n     // equivalent to:\n-\n     impl Eq for A {\n-        fn eq(&self, __other_1: &A) -> bool {\n+        fn eq(&self, __arg_1: &A) -> bool {\n             match *self {\n-                (ref self_1, ref self_2) => {\n-                    match *__other_1 {\n-                        (ref __other_1_1, ref __other_1_2) => {\n-                            self_1.eq(__other_1_1) && self_2.eq(__other_1_2)\n+                A {x: ref __self_0_0, y: ref __self_0_1} => {\n+                    match *__arg_1 {\n+                        A {x: ref __self_1_0, y: ref __self_1_1} => {\n+                            __self_0_0.eq(__self_1_0) && __self_0_1.eq(__self_1_1)\n                         }\n                     }\n                 }\n             }\n         }\n     }\n-    ```\n+    ~~~\n     */\n-    fn expand_struct_tuple_method_body(&self,\n-                                           cx: @ext_ctxt,\n-                                               span: span,\n-                                               struct_def: &struct_def,\n-                                           type_ident: ident) -> @expr {\n-        let self_str = ~\"self\";\n-        let other_strs = create_other_strs(self.nargs);\n-        let num_fields = struct_def.fields.len();\n-\n-\n-        let fields = do struct_def.fields.mapi |i, _| {\n-            let other_fields = do other_strs.map |&other_str| {\n-                let other_field_ident = cx.ident_of(fmt!(\"%s_%u\", other_str, i));\n-                build::mk_path(cx, span, ~[ other_field_ident ])\n-            };\n-\n-            let self_field_ident = cx.ident_of(fmt!(\"%s_%u\", self_str, i));\n-            let self_field = build::mk_path(cx, span, ~[ self_field_ident ]);\n+    fn expand_struct_method_body(&self,\n+                                 cx: @ext_ctxt,\n+                                 span: span,\n+                                 struct_def: &struct_def,\n+                                 type_ident: ident,\n+                                 self_args: &[@expr],\n+                                 nonself_args: &[@expr])\n+        -> @expr {\n \n-            (None, self_field, other_fields)\n+        let mut raw_fields = ~[], // ~[[fields of self], [fields of next Self arg], [etc]]\n+                patterns = ~[];\n+        for uint::range(0, self_args.len()) |i| {\n+            let (pat, ident_expr) = create_struct_pattern(cx, span,\n+                                                          type_ident, struct_def,\n+                                                          fmt!(\"__self_%u\", i), ast::m_imm);\n+            patterns.push(pat);\n+            raw_fields.push(ident_expr);\n         };\n \n-        let mut match_body = self.call_substructure_method(cx, span, type_ident, &Struct(fields));\n-\n-        let type_path = build::mk_raw_path(span, ~[type_ident]);\n-\n-        // create the matches from inside to out (i.e. other_{self.nargs} to other_1)\n-        for other_strs.each_reverse |&other_str| {\n-            match_body = create_deref_match(cx, span, type_path,\n-                                            other_str, num_fields,\n-                                            match_body)\n-        }\n-\n-        // create the match on self\n-        return create_deref_match(cx, span, type_path,\n-                                  ~\"self\", num_fields, match_body);\n-\n-        /**\n-        Creates a match expression against a tuple that needs to\n-        be dereferenced, but nothing else\n+        // transpose raw_fields\n+        let fields = match raw_fields {\n+            [self_arg, .. rest] => {\n+                do self_arg.mapi |i, &(opt_id, field)| {\n+                    let other_fields = do rest.map |l| {\n+                        match &l[i] {\n+                            &(_, ex) => ex\n+                        }\n+                    };\n+                    (opt_id, field, other_fields)\n+                }\n+            }\n+            [] => { cx.span_bug(span, ~\"No self arguments to non-static \\\n+                                        method in generic `deriving`\") }\n+        };\n \n-        ```\n-        match *`to_match` {\n-            (`to_match`_1, ..., `to_match`_`num_fields`) => `match_body`\n-        }\n-        ```\n-        */\n-        fn create_deref_match(cx: @ext_ctxt,\n-                              span: span,\n-                              type_path: @ast::Path,\n-                              to_match: ~str,\n-                              num_fields: uint,\n-                              match_body: @expr) -> @expr {\n-            let match_subpats = create_subpatterns(cx, span, to_match, num_fields);\n+        // body of the inner most destructuring match\n+        let mut body = self.call_substructure_method(\n+            cx, span,\n+            type_ident,\n+            self_args,\n+            nonself_args,\n+            &Struct(fields));\n+\n+        // make a series of nested matches, to destructure the\n+        // structs. This is actually right-to-left, but it shoudn't\n+        // matter.\n+        for vec::each2(self_args, patterns) |&arg_expr, &pat| {\n             let match_arm = ast::arm {\n-                pats: ~[ build::mk_pat_enum(cx, span, type_path, match_subpats) ],\n+                pats: ~[ pat ],\n                 guard: None,\n-                body: build::mk_simple_block(cx, span, match_body),\n+                body: build::mk_simple_block(cx, span, body)\n             };\n \n-            let deref_expr = build::mk_unary(cx, span, deref,\n-                                             build::mk_path(cx, span,\n-                                                            ~[ cx.ident_of(to_match)]));\n-            let match_expr = build::mk_expr(cx, span, expr_match(deref_expr, ~[match_arm]));\n-\n-            match_expr\n+            body = build::mk_expr(cx, span, ast::expr_match(arg_expr, ~[match_arm]))\n         }\n+        body\n     }\n \n-    /**\n-    ```\n-    #[deriving(Eq)]\n-    struct A { x: int, y: int }\n-\n-    // equivalent to:\n-\n-    impl Eq for A {\n-        fn eq(&self, __other_1: &A) -> bool {\n-            self.x.eq(&__other_1.x) &&\n-                self.y.eq(&__other_1.y)\n-        }\n-    }\n-    ```\n-    */\n-    fn expand_struct_method_body(&self,\n-                                     cx: @ext_ctxt,\n-                                     span: span,\n-                                     struct_def: &struct_def,\n-                                     type_ident: ident)\n+    fn expand_static_struct_method_body(&self,\n+                                        cx: @ext_ctxt,\n+                                        span: span,\n+                                        struct_def: &struct_def,\n+                                        type_ident: ident,\n+                                        self_args: &[@expr],\n+                                        nonself_args: &[@expr])\n         -> @expr {\n-        let self_ident = cx.ident_of(~\"self\");\n-        let other_idents = create_other_idents(cx, self.nargs);\n-\n-        let fields = do struct_def.fields.map |struct_field| {\n-            match struct_field.node.kind {\n-                named_field(ident, _, _) => {\n-                    // Create the accessor for this field in the other args.\n-                    let other_fields = do other_idents.map |&id| {\n-                        build::mk_access(cx, span, ~[id], ident)\n-                    };\n-                    let other_field_refs = do other_fields.map |&other_field| {\n-                        build::mk_addr_of(cx, span, other_field)\n-                    };\n+        let summary = summarise_struct(cx, span, struct_def);\n \n-                    // Create the accessor for this field in self.\n-                    let self_field =\n-                        build::mk_access(\n-                            cx, span,\n-                            ~[ self_ident ],\n-                            ident);\n-\n-                    (Some(ident), self_field, other_field_refs)\n-                }\n-                unnamed_field => {\n-                    cx.span_unimpl(span, ~\"unnamed fields with `deriving_generic`\");\n-                }\n-            }\n-        };\n-\n-        self.call_substructure_method(cx, span, type_ident, &Struct(fields))\n+        self.call_substructure_method(cx, span,\n+                                      type_ident,\n+                                      self_args, nonself_args,\n+                                      &StaticStruct(struct_def, summary))\n     }\n \n     /**\n-    ```\n+    ~~~\n     #[deriving(Eq)]\n     enum A {\n         A1\n         A2(int)\n     }\n \n-    // is equivalent to\n+    // is equivalent to (with const_nonmatching == false)\n \n     impl Eq for A {\n-        fn eq(&self, __other_1: &A) {\n+        fn eq(&self, __arg_1: &A) {\n             match *self {\n-                A1 => match *__other_1 {\n-                    A1 => true,\n-                    A2(ref __other_1_1) => false\n+                A1 => match *__arg_1 {\n+                    A1 => true\n+                    A2(ref __arg_1_1) => false\n                 },\n-                A2(self_1) => match *__other_1 {\n+                A2(self_1) => match *__arg_1 {\n                     A1 => false,\n-                    A2(ref __other_1_1) => self_1.eq(__other_1_1)\n+                    A2(ref __arg_1_1) => self_1.eq(__arg_1_1)\n                 }\n             }\n         }\n     }\n-    ```\n+    ~~~\n     */\n     fn expand_enum_method_body(&self,\n                                cx: @ext_ctxt,\n                                span: span,\n                                enum_def: &enum_def,\n-                               type_ident: ident)\n+                               type_ident: ident,\n+                               self_args: &[@expr],\n+                               nonself_args: &[@expr])\n         -> @expr {\n         self.build_enum_match(cx, span, enum_def, type_ident,\n+                              self_args, nonself_args,\n                               None, ~[], 0)\n     }\n \n \n     /**\n     Creates the nested matches for an enum definition recursively, i.e.\n \n-    ```\n+    ~~~\n     match self {\n        Variant1 => match other { Variant1 => matching, Variant2 => nonmatching, ... },\n        Variant2 => match other { Variant1 => nonmatching, Variant2 => matching, ... },\n        ...\n     }\n-    ```\n+    ~~~\n \n     It acts in the most naive way, so every branch (and subbranch,\n     subsubbranch, etc) exists, not just the ones where all the variants in\n@@ -589,15 +647,17 @@ impl<'self> MethodDef<'self> {\n                         cx: @ext_ctxt, span: span,\n                         enum_def: &enum_def,\n                         type_ident: ident,\n+                        self_args: &[@expr],\n+                        nonself_args: &[@expr],\n                         matching: Option<uint>,\n-                        matches_so_far: ~[(uint, variant,\n+                        matches_so_far: ~[(uint, ast::variant,\n                                            ~[(Option<ident>, @expr)])],\n                         match_count: uint) -> @expr {\n-        if match_count == self.nargs + 1 {\n+        if match_count == self_args.len() {\n             // we've matched against all arguments, so make the final\n             // expression at the bottom of the match tree\n             match matches_so_far {\n-                [] => cx.bug(~\"no self match on an enum in `deriving_generic`\"),\n+                [] => cx.span_bug(span, ~\"no self match on an enum in generic `deriving`\"),\n                 _ => {\n                     // we currently have a vec of vecs, where each\n                     // subvec is the fields of one of the arguments,\n@@ -637,97 +697,68 @@ impl<'self> MethodDef<'self> {\n                             substructure = EnumNonMatching(matches_so_far);\n                         }\n                     }\n-                    self.call_substructure_method(cx, span, type_ident, &substructure)\n+                    self.call_substructure_method(cx, span, type_ident,\n+                                                  self_args, nonself_args,\n+                                                  &substructure)\n                 }\n             }\n \n         } else {  // there are still matches to create\n-            let (current_match_ident, current_match_str) = if match_count == 0 {\n-                (cx.ident_of(~\"self\"), ~\"__self\")\n+            let current_match_str = if match_count == 0 {\n+                ~\"__self\"\n             } else {\n-                let s = fmt!(\"__other_%u\", matches_so_far.len() - 1);\n-                (cx.ident_of(s), s)\n+                fmt!(\"__arg_%u\", match_count)\n             };\n \n             let mut arms = ~[];\n \n             // this is used as a stack\n             let mut matches_so_far = matches_so_far;\n \n-            macro_rules! mk_arm(\n-                ($pat:expr, $expr:expr) => {\n-                    {\n-                        let blk = build::mk_simple_block(cx, span, $expr);\n-                        let arm = ast::arm {\n-                            pats: ~[$ pat ],\n-                            guard: None,\n-                            body: blk\n-                        };\n-                        arm\n-                    }\n-                }\n-            )\n-\n             // the code for nonmatching variants only matters when\n             // we've seen at least one other variant already\n             if self.const_nonmatching && match_count > 0 {\n                 // make a matching-variant match, and a _ match.\n                 let index = match matching {\n                     Some(i) => i,\n-                    None => cx.span_bug(span, ~\"Non-matching variants when required to\\\n-                                                be matching in `deriving_generic`\")\n+                    None => cx.span_bug(span, ~\"Non-matching variants when required to \\\n+                                                be matching in generic `deriving`\")\n                 };\n \n                 // matching-variant match\n                 let variant = &enum_def.variants[index];\n-                let pattern = create_enum_variant_pattern(cx, span,\n-                                                          variant,\n-                                                          current_match_str);\n-\n-                let idents = do vec::build |push| {\n-                    for each_variant_arg_ident(cx, span, variant) |i, field_id| {\n-                        let id = cx.ident_of(fmt!(\"%s_%u\", current_match_str, i));\n-                        push((field_id, build::mk_path(cx, span, ~[ id ])));\n-                    }\n-                };\n+                let (pattern, idents) = create_enum_variant_pattern(cx, span,\n+                                                                    variant,\n+                                                                    current_match_str,\n+                                                                    ast::m_imm);\n \n                 matches_so_far.push((index, *variant, idents));\n                 let arm_expr = self.build_enum_match(cx, span,\n                                                      enum_def,\n                                                      type_ident,\n+                                                     self_args, nonself_args,\n                                                      matching,\n                                                      matches_so_far,\n                                                      match_count + 1);\n                 matches_so_far.pop();\n-                let arm = mk_arm!(pattern, arm_expr);\n-                arms.push(arm);\n+                arms.push(build::mk_arm(cx, span, ~[ pattern ], arm_expr));\n \n                 if enum_def.variants.len() > 1 {\n-                    // _ match, if necessary\n-                    let wild_pat = @ast::pat {\n-                        id: cx.next_id(),\n-                        node: pat_wild,\n-                        span: span\n-                    };\n-\n                     let wild_expr = self.call_substructure_method(cx, span, type_ident,\n+                                                                  self_args, nonself_args,\n                                                                   &EnumNonMatching(~[]));\n-                    let wild_arm = mk_arm!(wild_pat, wild_expr);\n+                    let wild_arm = build::mk_arm(cx, span,\n+                                                 ~[ build::mk_pat_wild(cx, span) ],\n+                                                 wild_expr);\n                     arms.push(wild_arm);\n                 }\n             } else {\n                 // create an arm matching on each variant\n                 for enum_def.variants.eachi |index, variant| {\n-                    let pattern = create_enum_variant_pattern(cx, span,\n-                                                              variant,\n-                                                              current_match_str);\n-\n-                    let idents = do vec::build |push| {\n-                        for each_variant_arg_ident(cx, span, variant) |i, field_id| {\n-                            let id = cx.ident_of(fmt!(\"%s_%u\", current_match_str, i));\n-                            push((field_id, build::mk_path(cx, span, ~[ id ])));\n-                        }\n-                    };\n+                    let (pattern, idents) = create_enum_variant_pattern(cx, span,\n+                                                                       variant,\n+                                                                       current_match_str,\n+                                                                       ast::m_imm);\n \n                     matches_so_far.push((index, *variant, idents));\n                     let new_matching =\n@@ -739,44 +770,75 @@ impl<'self> MethodDef<'self> {\n                     let arm_expr = self.build_enum_match(cx, span,\n                                                          enum_def,\n                                                          type_ident,\n+                                                         self_args, nonself_args,\n                                                          new_matching,\n                                                          matches_so_far,\n                                                          match_count + 1);\n                     matches_so_far.pop();\n \n-                    let arm = mk_arm!(pattern, arm_expr);\n+                    let arm = build::mk_arm(cx, span, ~[ pattern ], arm_expr);\n                     arms.push(arm);\n                 }\n             }\n-            let deref_expr = build::mk_unary(cx, span, deref,\n-                                             build::mk_path(cx, span,\n-                                                            ~[ current_match_ident ]));\n-            let match_expr = build::mk_expr(cx, span,\n-                                            expr_match(deref_expr, arms));\n \n-            match_expr\n+            // match foo { arm, arm, arm, ... }\n+            build::mk_expr(cx, span,\n+                           ast::expr_match(self_args[match_count], arms))\n         }\n     }\n+\n+    fn expand_static_enum_method_body(&self,\n+                               cx: @ext_ctxt,\n+                               span: span,\n+                               enum_def: &enum_def,\n+                               type_ident: ident,\n+                               self_args: &[@expr],\n+                               nonself_args: &[@expr])\n+        -> @expr {\n+        let summary = do enum_def.variants.map |v| {\n+            let ident = v.node.name;\n+            let summary = match v.node.kind {\n+                ast::tuple_variant_kind(ref args) => Left(args.len()),\n+                ast::struct_variant_kind(struct_def) => {\n+                    summarise_struct(cx, span, struct_def)\n+                }\n+            };\n+            (ident, summary)\n+        };\n+        self.call_substructure_method(cx,\n+                                      span, type_ident,\n+                                      self_args, nonself_args,\n+                                      &StaticEnum(enum_def, summary))\n+    }\n }\n \n-/// Create variable names (as strings) to refer to the non-self\n-/// parameters\n-fn create_other_strs(n: uint) -> ~[~str] {\n-    do vec::build |push| {\n-        for uint::range(0, n) |i| {\n-            push(fmt!(\"__other_%u\", i));\n+fn summarise_struct(cx: @ext_ctxt, span: span,\n+                    struct_def: &struct_def) -> Either<uint, ~[ident]> {\n+    let mut named_idents = ~[];\n+    let mut unnamed_count = 0;\n+    for struct_def.fields.each |field| {\n+        match field.node.kind {\n+            ast::named_field(ident, _, _) => {\n+                named_idents.push(ident)\n+            }\n+            ast::unnamed_field => {\n+                unnamed_count += 1;\n+            }\n         }\n     }\n-}\n-/// Like `create_other_strs`, but returns idents for the strings\n-fn create_other_idents(cx: @ext_ctxt, n: uint) -> ~[ident] {\n-    do create_other_strs(n).map |&s| {\n-        cx.ident_of(s)\n+\n+    match (unnamed_count > 0, named_idents.is_empty()) {\n+        (true, false) => cx.span_bug(span,\n+                                     \"A struct with named and unnamed \\\n+                                      fields in generic `deriving`\"),\n+        // named fields\n+        (_, false) => Right(named_idents),\n+        // tuple structs (includes empty structs)\n+        (_, _)     => Left(unnamed_count)\n     }\n }\n \n \n-\n /* helpful premade recipes */\n \n /**\n@@ -786,7 +848,7 @@ left-to-right (`true`) or right-to-left (`false`).\n pub fn cs_fold(use_foldl: bool,\n                f: &fn(@ext_ctxt, span,\n                       old: @expr,\n-                      self_f: @expr, other_fs: ~[@expr]) -> @expr,\n+                      self_f: @expr, other_fs: &[@expr]) -> @expr,\n                base: @expr,\n                enum_nonmatch_f: EnumNonMatchFunc,\n                cx: @ext_ctxt, span: span,\n@@ -803,7 +865,11 @@ pub fn cs_fold(use_foldl: bool,\n                 }\n             }\n         },\n-        EnumNonMatching(all_enums) => enum_nonmatch_f(cx, span, all_enums)\n+        EnumNonMatching(all_enums) => enum_nonmatch_f(cx, span,\n+                                                      all_enums, substructure.nonself_args),\n+        StaticEnum(*) | StaticStruct(*) => {\n+            cx.span_bug(span, \"Static function in `deriving`\")\n+        }\n     }\n }\n \n@@ -812,11 +878,12 @@ pub fn cs_fold(use_foldl: bool,\n Call the method that is being derived on all the fields, and then\n process the collected results. i.e.\n \n-```\n-f(cx, span, ~[self_1.method(__other_1_1, __other_2_1),\n-              self_2.method(__other_1_2, __other_2_2)])\n-```\n+~~~\n+f(cx, span, ~[self_1.method(__arg_1_1, __arg_2_1),\n+              self_2.method(__arg_1_2, __arg_2_2)])\n+~~~\n */\n+#[inline(always)]\n pub fn cs_same_method(f: &fn(@ext_ctxt, span, ~[@expr]) -> @expr,\n                       enum_nonmatch_f: EnumNonMatchFunc,\n                       cx: @ext_ctxt, span: span,\n@@ -833,7 +900,11 @@ pub fn cs_same_method(f: &fn(@ext_ctxt, span, ~[@expr]) -> @expr,\n \n             f(cx, span, called)\n         },\n-        EnumNonMatching(all_enums) => enum_nonmatch_f(cx, span, all_enums)\n+        EnumNonMatching(all_enums) => enum_nonmatch_f(cx, span,\n+                                                      all_enums, substructure.nonself_args),\n+        StaticEnum(*) | StaticStruct(*) => {\n+            cx.span_bug(span, \"Static function in `deriving`\")\n+        }\n     }\n }\n \n@@ -842,6 +913,7 @@ Fold together the results of calling the derived method on all the\n fields. `use_foldl` controls whether this is done left-to-right\n (`true`) or right-to-left (`false`).\n */\n+#[inline(always)]\n pub fn cs_same_method_fold(use_foldl: bool,\n                            f: &fn(@ext_ctxt, span, @expr, @expr) -> @expr,\n                            base: @expr,\n@@ -869,7 +941,8 @@ pub fn cs_same_method_fold(use_foldl: bool,\n Use a given binop to combine the result of calling the derived method\n on all the fields.\n */\n-pub fn cs_binop(binop: binop, base: @expr,\n+#[inline(always)]\n+pub fn cs_binop(binop: ast::binop, base: @expr,\n                 enum_nonmatch_f: EnumNonMatchFunc,\n                 cx: @ext_ctxt, span: span,\n                 substructure: &Substructure) -> @expr {\n@@ -887,18 +960,20 @@ pub fn cs_binop(binop: binop, base: @expr,\n }\n \n /// cs_binop with binop == or\n+#[inline(always)]\n pub fn cs_or(enum_nonmatch_f: EnumNonMatchFunc,\n              cx: @ext_ctxt, span: span,\n              substructure: &Substructure) -> @expr {\n-    cs_binop(or, build::mk_bool(cx, span, false),\n+    cs_binop(ast::or, build::mk_bool(cx, span, false),\n              enum_nonmatch_f,\n              cx, span, substructure)\n }\n /// cs_binop with binop == and\n+#[inline(always)]\n pub fn cs_and(enum_nonmatch_f: EnumNonMatchFunc,\n               cx: @ext_ctxt, span: span,\n               substructure: &Substructure) -> @expr {\n-    cs_binop(and, build::mk_bool(cx, span, true),\n+    cs_binop(ast::and, build::mk_bool(cx, span, true),\n              enum_nonmatch_f,\n              cx, span, substructure)\n }"}, {"sha": "9f3972e71ac8a075ab26ead1066d800a70965137", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 142, "deletions": 122, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/b20eb970e18377191465cb37f2074f467dfd61b1/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b20eb970e18377191465cb37f2074f467dfd61b1/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=b20eb970e18377191465cb37f2074f467dfd61b1", "patch": "@@ -12,14 +12,7 @@\n /// #[deriving(IterBytes)] extensions.\n \n use ast;\n-use ast::{Ty, bind_by_ref, deref, enum_def};\n-use ast::{expr, expr_match, ident, item, item_};\n-use ast::{item_enum, item_impl, item_struct, Generics};\n-use ast::{m_imm, meta_item, method};\n-use ast::{named_field, pat, pat_ident, public};\n-use ast::{struct_def, struct_variant_kind};\n-use ast::{tuple_variant_kind};\n-use ast::{ty_path, unnamed_field, variant};\n+use ast::{Ty, enum_def, expr, ident, item, Generics, meta_item, struct_def};\n use ext::base::ext_ctxt;\n use ext::build;\n use codemap::{span, respan};\n@@ -78,23 +71,21 @@ pub fn expand_meta_deriving(cx: @ext_ctxt,\n                     meta_name_value(tname, _) |\n                     meta_list(tname, _) |\n                     meta_word(tname) => {\n+                        macro_rules! expand(($func:path) => ($func(cx, titem.span,\n+                                                                   titem, in_items)));\n                         match *tname {\n-                            ~\"Clone\" => clone::expand_deriving_clone(cx,\n-                                titem.span, titem, in_items),\n-                            ~\"IterBytes\" => iter_bytes::expand_deriving_iter_bytes(cx,\n-                                titem.span, titem, in_items),\n-                            ~\"Encodable\" => encodable::expand_deriving_encodable(cx,\n-                                titem.span, titem, in_items),\n-                            ~\"Decodable\" => decodable::expand_deriving_decodable(cx,\n-                                titem.span, titem, in_items),\n-                            ~\"Eq\" => eq::expand_deriving_eq(cx, titem.span,\n-                                                             titem, in_items),\n-                            ~\"TotalEq\" => totaleq::expand_deriving_totaleq(cx, titem.span,\n-                                                                           titem, in_items),\n-                            ~\"Ord\" => ord::expand_deriving_ord(cx, titem.span,\n-                                                               titem, in_items),\n-                            ~\"TotalOrd\" => totalord::expand_deriving_totalord(cx, titem.span,\n-                                                                              titem, in_items),\n+                            ~\"Clone\" => expand!(clone::expand_deriving_clone),\n+\n+                            ~\"IterBytes\" => expand!(iter_bytes::expand_deriving_iter_bytes),\n+\n+                            ~\"Encodable\" => expand!(encodable::expand_deriving_encodable),\n+                            ~\"Decodable\" => expand!(decodable::expand_deriving_decodable),\n+\n+                            ~\"Eq\" => expand!(eq::expand_deriving_eq),\n+                            ~\"TotalEq\" => expand!(totaleq::expand_deriving_totaleq),\n+                            ~\"Ord\" => expand!(ord::expand_deriving_ord),\n+                            ~\"TotalOrd\" => expand!(totalord::expand_deriving_totalord),\n+\n                             tname => {\n                                 cx.span_err(titem.span, fmt!(\"unknown \\\n                                     `deriving` trait: `%s`\", tname));\n@@ -118,14 +109,14 @@ pub fn expand_deriving(cx: @ext_ctxt,\n     for in_items.each |item| {\n         result.push(copy *item);\n         match item.node {\n-            item_struct(struct_def, ref generics) => {\n+            ast::item_struct(struct_def, ref generics) => {\n                 result.push(expand_deriving_struct_def(cx,\n                                                        span,\n                                                        struct_def,\n                                                        item.ident,\n                                                        generics));\n             }\n-            item_enum(ref enum_definition, ref generics) => {\n+            ast::item_enum(ref enum_definition, ref generics) => {\n                 result.push(expand_deriving_enum_def(cx,\n                                                      span,\n                                                      enum_definition,\n@@ -138,7 +129,7 @@ pub fn expand_deriving(cx: @ext_ctxt,\n     result\n }\n \n-fn create_impl_item(cx: @ext_ctxt, span: span, item: item_) -> @item {\n+fn create_impl_item(cx: @ext_ctxt, span: span, item: ast::item_) -> @item {\n     let doc_attr = respan(span,\n                           ast::lit_str(@~\"Automatically derived.\"));\n     let doc_attr = respan(span, ast::meta_name_value(@~\"doc\", doc_attr));\n@@ -154,7 +145,7 @@ fn create_impl_item(cx: @ext_ctxt, span: span, item: item_) -> @item {\n         attrs: ~[doc_attr],\n         id: cx.next_id(),\n         node: item,\n-        vis: public,\n+        vis: ast::public,\n         span: span,\n     }\n }\n@@ -173,22 +164,29 @@ pub fn create_self_type_with_params(cx: @ext_ctxt,\n         self_ty_params.push(self_ty_param);\n     }\n \n+    let lifetime = if generics.lifetimes.is_empty() {\n+        None\n+    } else {\n+        Some(@*generics.lifetimes.get(0))\n+    };\n+\n+\n     // Create the type of `self`.\n     let self_type = build::mk_raw_path_(span,\n                                         ~[ type_ident ],\n+                                        lifetime,\n                                         self_ty_params);\n-    let self_type = ty_path(self_type, cx.next_id());\n-    @ast::Ty { id: cx.next_id(), node: self_type, span: span }\n+    build::mk_ty_path_path(cx, span, self_type)\n }\n \n pub fn create_derived_impl(cx: @ext_ctxt,\n                            span: span,\n                            type_ident: ident,\n                            generics: &Generics,\n-                           methods: &[@method],\n+                           methods: &[@ast::method],\n                            trait_path: @ast::Path,\n-                           mut impl_ty_params: opt_vec::OptVec<ast::TyParam>,\n-                           bounds_paths: opt_vec::OptVec<~[ident]>)\n+                           mut impl_generics:  Generics,\n+                           bounds_paths: opt_vec::OptVec<@ast::Path>)\n                         -> @item {\n     /*!\n      *\n@@ -204,21 +202,22 @@ pub fn create_derived_impl(cx: @ext_ctxt,\n      */\n \n     // Copy the lifetimes\n-    let impl_lifetimes = generics.lifetimes.map(|l| {\n-        build::mk_lifetime(cx, l.span, l.ident)\n-    });\n+    for generics.lifetimes.each |l| {\n+        impl_generics.lifetimes.push(copy *l)\n+    };\n \n     // Create the type parameters.\n     for generics.ty_params.each |ty_param| {\n+        // extra restrictions on the generics parameters to the type being derived upon\n         let mut bounds = do bounds_paths.map |&bound_path| {\n-            build::mk_trait_ty_param_bound_global(cx, span, bound_path)\n+            build::mk_trait_ty_param_bound_(cx, bound_path)\n         };\n \n         let this_trait_bound =\n             build::mk_trait_ty_param_bound_(cx, trait_path);\n         bounds.push(this_trait_bound);\n \n-        impl_ty_params.push(build::mk_ty_param(cx, ty_param.ident, @bounds));\n+        impl_generics.ty_params.push(build::mk_ty_param(cx, ty_param.ident, @bounds));\n     }\n \n     // Create the reference to the trait.\n@@ -231,123 +230,144 @@ pub fn create_derived_impl(cx: @ext_ctxt,\n                                                  generics);\n \n     // Create the impl item.\n-    let impl_item = item_impl(Generics {lifetimes: impl_lifetimes,\n-                                        ty_params: impl_ty_params},\n+    let impl_item = ast::item_impl(impl_generics,\n                               Some(trait_ref),\n                               self_type,\n                               methods.map(|x| *x));\n     return create_impl_item(cx, span, impl_item);\n }\n \n pub fn create_subpatterns(cx: @ext_ctxt,\n-                      span: span,\n-                      prefix: ~str,\n-                      n: uint)\n-                   -> ~[@pat] {\n-    let mut subpats = ~[];\n-    for uint::range(0, n) |_i| {\n-        // Create the subidentifier.\n-        let index = subpats.len();\n-        let ident = cx.ident_of(fmt!(\"%s_%u\", prefix, index));\n-\n-        // Create the subpattern.\n-        let subpath = build::mk_raw_path(span, ~[ ident ]);\n-        let subpat = pat_ident(bind_by_ref(m_imm), subpath, None);\n-        let subpat = build::mk_pat(cx, span, subpat);\n-        subpats.push(subpat);\n+                          span: span,\n+                          field_paths: ~[@ast::Path],\n+                          mutbl: ast::mutability)\n+                   -> ~[@ast::pat] {\n+    do field_paths.map |&path| {\n+        build::mk_pat(cx, span,\n+                      ast::pat_ident(ast::bind_by_ref(mutbl), path, None))\n     }\n-    return subpats;\n }\n \n-pub fn is_struct_tuple(struct_def: &struct_def) -> bool {\n-    struct_def.fields.len() > 0 && struct_def.fields.all(|f| {\n-        match f.node.kind {\n-            named_field(*) => false,\n-            unnamed_field => true\n-        }\n-    })\n+#[deriving(Eq)] // dogfooding!\n+enum StructType {\n+    Unknown, Record, Tuple\n+}\n+\n+pub fn create_struct_pattern(cx: @ext_ctxt,\n+                             span: span,\n+                             struct_ident: ident,\n+                             struct_def: &struct_def,\n+                             prefix: ~str,\n+                             mutbl: ast::mutability)\n+    -> (@ast::pat, ~[(Option<ident>, @expr)]) {\n+    if struct_def.fields.is_empty() {\n+        return (\n+            build::mk_pat_ident_with_binding_mode(\n+                cx, span, struct_ident, ast::bind_infer),\n+            ~[]);\n+    }\n+\n+    let matching_path = build::mk_raw_path(span, ~[ struct_ident ]);\n+\n+    let mut paths = ~[], ident_expr = ~[];\n+\n+    let mut struct_type = Unknown;\n+\n+    for struct_def.fields.eachi |i, struct_field| {\n+        let opt_id = match struct_field.node.kind {\n+            ast::named_field(ident, _, _) if (struct_type == Unknown ||\n+                                              struct_type == Record) => {\n+                struct_type = Record;\n+                Some(ident)\n+            }\n+            ast::unnamed_field if (struct_type == Unknown ||\n+                                   struct_type == Tuple) => {\n+                struct_type = Tuple;\n+                None\n+            }\n+            _ => {\n+                cx.span_bug(span, \"A struct with named and unnamed fields in `deriving`\");\n+            }\n+        };\n+        let path = build::mk_raw_path(span,\n+                                      ~[ cx.ident_of(fmt!(\"%s_%u\", prefix, i)) ]);\n+        paths.push(path);\n+        ident_expr.push((opt_id, build::mk_path_raw(cx, span, path)));\n+    }\n+\n+    let subpats = create_subpatterns(cx, span, paths, mutbl);\n+\n+    // struct_type is definitely not Unknown, since struct_def.fields\n+    // must be nonempty to reach here\n+    let pattern = if struct_type == Record {\n+        let field_pats = do vec::build |push| {\n+            for vec::each2(subpats, ident_expr) |&pat, &(id, _)| {\n+                // id is guaranteed to be Some\n+                push(ast::field_pat { ident: id.get(), pat: pat })\n+            }\n+        };\n+        build::mk_pat_struct(cx, span, matching_path, field_pats)\n+    } else {\n+        build::mk_pat_enum(cx, span, matching_path, subpats)\n+    };\n+\n+    (pattern, ident_expr)\n }\n \n pub fn create_enum_variant_pattern(cx: @ext_ctxt,\n-                               span: span,\n-                               variant: &variant,\n-                               prefix: ~str)\n-                            -> @pat {\n+                                   span: span,\n+                                   variant: &ast::variant,\n+                                   prefix: ~str,\n+                                   mutbl: ast::mutability)\n+    -> (@ast::pat, ~[(Option<ident>, @expr)]) {\n+\n     let variant_ident = variant.node.name;\n     match variant.node.kind {\n-        tuple_variant_kind(ref variant_args) => {\n-            if variant_args.len() == 0 {\n-                return build::mk_pat_ident_with_binding_mode(\n-                    cx, span, variant_ident, ast::bind_infer);\n+        ast::tuple_variant_kind(ref variant_args) => {\n+            if variant_args.is_empty() {\n+                return (build::mk_pat_ident_with_binding_mode(\n+                    cx, span, variant_ident, ast::bind_infer), ~[]);\n             }\n \n             let matching_path = build::mk_raw_path(span, ~[ variant_ident ]);\n-            let subpats = create_subpatterns(cx,\n-                                             span,\n-                                             prefix,\n-                                             variant_args.len());\n \n-            return build::mk_pat_enum(cx, span, matching_path, subpats);\n-        }\n-        struct_variant_kind(struct_def) => {\n-            let matching_path = build::mk_raw_path(span, ~[ variant_ident ]);\n-            let subpats = create_subpatterns(cx,\n-                                             span,\n-                                             prefix,\n-                                             struct_def.fields.len());\n-\n-            let field_pats = do struct_def.fields.mapi |i, struct_field| {\n-                let ident = match struct_field.node.kind {\n-                    named_field(ident, _, _) => ident,\n-                    unnamed_field => {\n-                        cx.span_bug(span, ~\"unexpected unnamed field\");\n-                    }\n-                };\n-                ast::field_pat { ident: ident, pat: subpats[i] }\n-            };\n+            let mut paths = ~[], ident_expr = ~[];\n+            for uint::range(0, variant_args.len()) |i| {\n+                let path = build::mk_raw_path(span,\n+                                              ~[ cx.ident_of(fmt!(\"%s_%u\", prefix, i)) ]);\n \n-            build::mk_pat_struct(cx, span, matching_path, field_pats)\n-        }\n-    }\n-}\n+                paths.push(path);\n+                ident_expr.push((None, build::mk_path_raw(cx, span, path)));\n+            }\n \n-pub fn variant_arg_count(_cx: @ext_ctxt, _span: span, variant: &variant) -> uint {\n-    match variant.node.kind {\n-        tuple_variant_kind(ref args) => args.len(),\n-        struct_variant_kind(ref struct_def) => struct_def.fields.len(),\n-    }\n-}\n+            let subpats = create_subpatterns(cx, span, paths, mutbl);\n \n-/// Iterate through the idents of the variant arguments. The field is\n-/// unnamed (i.e. it's not a struct-like enum), then `None`.\n-pub fn each_variant_arg_ident(_cx: @ext_ctxt, _span: span,\n-                              variant: &variant, it: &fn(uint, Option<ident>) -> bool) {\n-    match variant.node.kind {\n-        tuple_variant_kind(ref args) => {\n-            for uint::range(0, args.len()) |i| {\n-                if !it(i, None) { break }\n-            }\n+            (build::mk_pat_enum(cx, span, matching_path, subpats),\n+             ident_expr)\n         }\n-        struct_variant_kind(ref struct_def) => {\n-            for struct_def.fields.eachi |i, f| {\n-                let id = match f.node.kind {\n-                    named_field(ident, _, _) => Some(ident),\n-                    unnamed_field => None\n-                };\n-                if !it(i, id) { break }\n-            }\n+        ast::struct_variant_kind(struct_def) => {\n+            create_struct_pattern(cx, span,\n+                                  variant_ident, struct_def,\n+                                  prefix,\n+                                  mutbl)\n         }\n     }\n }\n \n+pub fn variant_arg_count(_cx: @ext_ctxt, _span: span, variant: &ast::variant) -> uint {\n+    match variant.node.kind {\n+        ast::tuple_variant_kind(ref args) => args.len(),\n+        ast::struct_variant_kind(ref struct_def) => struct_def.fields.len(),\n+    }\n+}\n \n pub fn expand_enum_or_struct_match(cx: @ext_ctxt,\n                                span: span,\n                                arms: ~[ ast::arm ])\n                             -> @expr {\n     let self_ident = cx.ident_of(~\"self\");\n     let self_expr = build::mk_path(cx, span, ~[ self_ident ]);\n-    let self_expr = build::mk_unary(cx, span, deref, self_expr);\n-    let self_match_expr = expr_match(self_expr, arms);\n+    let self_expr = build::mk_unary(cx, span, ast::deref, self_expr);\n+    let self_match_expr = ast::expr_match(self_expr, arms);\n     build::mk_expr(cx, span, self_match_expr)\n }"}, {"sha": "6195a3a64249e010fcba2a34463f2690dc053984", "filename": "src/libsyntax/ext/deriving/ty.rs", "status": "added", "additions": 242, "deletions": 0, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/b20eb970e18377191465cb37f2074f467dfd61b1/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b20eb970e18377191465cb37f2074f467dfd61b1/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs?ref=b20eb970e18377191465cb37f2074f467dfd61b1", "patch": "@@ -0,0 +1,242 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+A mini version of ast::Ty, which is easier to use, and features an\n+explicit `Self` type to use when specifying impls to be derived.\n+*/\n+\n+use ast;\n+use ast::{expr,Generics,ident};\n+use ext::base::ext_ctxt;\n+use ext::build;\n+use codemap::{span,respan};\n+use opt_vec;\n+\n+/// The types of pointers\n+#[deriving(Eq)]\n+pub enum PtrTy {\n+    Owned, // ~\n+    Managed(ast::mutability), // @[mut]\n+    Borrowed(Option<~str>, ast::mutability), // &['lifetime] [mut]\n+}\n+\n+/// A path, e.g. `::core::option::Option::<int>` (global). Has support\n+/// for type parameters and a lifetime.\n+#[deriving(Eq)]\n+pub struct Path {\n+    path: ~[~str],\n+    lifetime: Option<~str>,\n+    params: ~[~Ty],\n+    global: bool\n+}\n+\n+pub impl Path {\n+    fn new(path: ~[~str]) -> Path {\n+        Path::new_(path, None, ~[], true)\n+    }\n+    fn new_local(path: ~str) -> Path {\n+        Path::new_(~[ path ], None, ~[], false)\n+    }\n+    fn new_(path: ~[~str], lifetime: Option<~str>, params: ~[~Ty], global: bool) -> Path {\n+        Path {\n+            path: path,\n+            lifetime: lifetime,\n+            params: params,\n+            global: global\n+        }\n+    }\n+\n+    fn to_ty(&self, cx: @ext_ctxt, span: span,\n+             self_ty: ident, self_generics: &Generics) -> @ast::Ty {\n+                build::mk_ty_path_path(cx, span,\n+                                       self.to_path(cx, span,\n+                                                    self_ty, self_generics))\n+    }\n+    fn to_path(&self, cx: @ext_ctxt, span: span,\n+               self_ty: ident, self_generics: &Generics) -> @ast::Path {\n+        let idents = self.path.map(|s| cx.ident_of(*s) );\n+        let lt = mk_lifetime(cx, span, self.lifetime);\n+        let tys = self.params.map(|t| t.to_ty(cx, span, self_ty, self_generics));\n+\n+        if self.global {\n+            build::mk_raw_path_global_(span, idents, lt, tys)\n+        } else {\n+            build::mk_raw_path_(span, idents, lt, tys)\n+        }\n+    }\n+}\n+\n+/// A type. Supports pointers (except for *), Self, and literals\n+#[deriving(Eq)]\n+pub enum Ty {\n+    Self,\n+    // &/~/@ Ty\n+    Ptr(~Ty, PtrTy),\n+    // mod::mod::Type<[lifetime], [Params...]>, including a plain type\n+    // parameter, and things like `int`\n+    Literal(Path),\n+    // includes nil\n+    Tuple(~[Ty])\n+}\n+\n+pub fn borrowed_ptrty() -> PtrTy {\n+    Borrowed(None, ast::m_imm)\n+}\n+pub fn borrowed(ty: ~Ty) -> Ty {\n+    Ptr(ty, borrowed_ptrty())\n+}\n+\n+pub fn borrowed_explicit_self() -> Option<Option<PtrTy>> {\n+    Some(Some(borrowed_ptrty()))\n+}\n+\n+pub fn borrowed_self() -> Ty {\n+    borrowed(~Self)\n+}\n+\n+pub fn nil_ty() -> Ty {\n+    Tuple(~[])\n+}\n+\n+fn mk_lifetime(cx: @ext_ctxt, span: span, lt: Option<~str>) -> Option<@ast::Lifetime> {\n+    match lt {\n+        Some(s) => Some(@build::mk_lifetime(cx, span, cx.ident_of(s))),\n+        None => None\n+    }\n+}\n+\n+pub impl Ty {\n+    fn to_ty(&self, cx: @ext_ctxt, span: span,\n+             self_ty: ident, self_generics: &Generics) -> @ast::Ty {\n+        match *self {\n+            Ptr(ref ty, ref ptr) => {\n+                let raw_ty = ty.to_ty(cx, span, self_ty, self_generics);\n+                match *ptr {\n+                    Owned => {\n+                        build::mk_ty_uniq(cx, span, raw_ty)\n+                    }\n+                    Managed(copy mutbl) => {\n+                        build::mk_ty_box(cx, span, raw_ty, mutbl)\n+                    }\n+                    Borrowed(copy lt, copy mutbl) => {\n+                        let lt = mk_lifetime(cx, span, lt);\n+                        build::mk_ty_rptr(cx, span, raw_ty, lt, mutbl)\n+                    }\n+                }\n+            }\n+            Literal(ref p) => { p.to_ty(cx, span, self_ty, self_generics) }\n+            Self  => {\n+                build::mk_ty_path_path(cx, span, self.to_path(cx, span, self_ty, self_generics))\n+            }\n+            Tuple(ref fields) => {\n+                let ty = if fields.is_empty() {\n+                    ast::ty_nil\n+                } else {\n+                    ast::ty_tup(fields.map(|f| f.to_ty(cx, span, self_ty, self_generics)))\n+                };\n+\n+                build::mk_ty(cx, span, ty)\n+            }\n+        }\n+    }\n+\n+    fn to_path(&self, cx: @ext_ctxt, span: span,\n+               self_ty: ident, self_generics: &Generics) -> @ast::Path {\n+        match *self {\n+            Self => {\n+                let self_params = do self_generics.ty_params.map |ty_param| {\n+                    build::mk_ty_path(cx, span, ~[ ty_param.ident ])\n+                };\n+                let lifetime = if self_generics.lifetimes.is_empty() {\n+                    None\n+                } else {\n+                    Some(@*self_generics.lifetimes.get(0))\n+                };\n+\n+                build::mk_raw_path_(span, ~[self_ty], lifetime,\n+                                    opt_vec::take_vec(self_params))\n+            }\n+            Literal(ref p) => {\n+                p.to_path(cx, span, self_ty, self_generics)\n+            }\n+            Ptr(*) => { cx.span_bug(span, ~\"Pointer in a path in generic `deriving`\") }\n+            Tuple(*) => { cx.span_bug(span, ~\"Tuple in a path in generic `deriving`\") }\n+        }\n+    }\n+}\n+\n+\n+fn mk_ty_param(cx: @ext_ctxt, span: span, name: ~str, bounds: ~[Path],\n+               self_ident: ident, self_generics: &Generics) -> ast::TyParam {\n+    let bounds = opt_vec::from(\n+        do bounds.map |b| {\n+            let path = b.to_path(cx, span, self_ident, self_generics);\n+            build::mk_trait_ty_param_bound_(cx, path)\n+        });\n+    build::mk_ty_param(cx, cx.ident_of(name), @bounds)\n+}\n+\n+fn mk_generics(lifetimes: ~[ast::Lifetime],  ty_params: ~[ast::TyParam]) -> Generics {\n+    Generics {\n+        lifetimes: opt_vec::from(lifetimes),\n+        ty_params: opt_vec::from(ty_params)\n+    }\n+}\n+\n+/// Lifetimes and bounds on type paramers\n+pub struct LifetimeBounds {\n+    lifetimes: ~[~str],\n+    bounds: ~[(~str, ~[Path])]\n+}\n+\n+pub impl LifetimeBounds {\n+    fn empty() -> LifetimeBounds {\n+        LifetimeBounds {\n+            lifetimes: ~[], bounds: ~[]\n+        }\n+    }\n+    fn to_generics(&self, cx: @ext_ctxt, span: span,\n+                   self_ty: ident, self_generics: &Generics) -> Generics {\n+        let lifetimes = do self.lifetimes.map |&lt| {\n+            build::mk_lifetime(cx, span, cx.ident_of(lt))\n+        };\n+        let ty_params = do self.bounds.map |&(name, bounds)| {\n+            mk_ty_param(cx, span, name, bounds, self_ty, self_generics)\n+        };\n+        mk_generics(lifetimes, ty_params)\n+    }\n+}\n+\n+\n+pub fn get_explicit_self(cx: @ext_ctxt, span: span, self_ptr: Option<PtrTy>)\n+    -> (@expr, ast::self_ty) {\n+    let self_path = build::mk_path(cx, span, ~[cx.ident_of(~\"self\")]);\n+    match self_ptr {\n+        None => {\n+            (self_path, respan(span, ast::sty_value))\n+        }\n+        Some(ptr) => {\n+            let self_ty = respan(\n+                span,\n+                match ptr {\n+                    Owned => ast::sty_uniq(ast::m_imm),\n+                    Managed(mutbl) => ast::sty_box(mutbl),\n+                    Borrowed(lt, mutbl) => {\n+                        let lt = lt.map(|s| @build::mk_lifetime(cx, span,\n+                                                                cx.ident_of(*s)));\n+                        ast::sty_region(lt, mutbl)\n+                    }\n+                });\n+            let self_expr = build::mk_deref(cx, span, self_path);\n+            (self_expr, self_ty)\n+        }\n+    }\n+}"}]}