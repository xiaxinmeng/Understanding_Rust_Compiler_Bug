{"sha": "700669bbd0ab3ae0c5a56985ce13ca896d342a3a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwMDY2OWJiZDBhYjNhZTBjNWE1Njk4NWNlMTNjYTg5NmQzNDJhM2E=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-07-22T14:56:19Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-07-22T14:56:19Z"}, "message": "kill old lexer", "tree": {"sha": "20ee49ed4ee94e463cd81f3f8142d64cde0ca134", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/20ee49ed4ee94e463cd81f3f8142d64cde0ca134"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/700669bbd0ab3ae0c5a56985ce13ca896d342a3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/700669bbd0ab3ae0c5a56985ce13ca896d342a3a", "html_url": "https://github.com/rust-lang/rust/commit/700669bbd0ab3ae0c5a56985ce13ca896d342a3a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/700669bbd0ab3ae0c5a56985ce13ca896d342a3a/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75761c0e47d8c20a490a3d61ea64d2413d3c3570", "url": "https://api.github.com/repos/rust-lang/rust/commits/75761c0e47d8c20a490a3d61ea64d2413d3c3570", "html_url": "https://github.com/rust-lang/rust/commit/75761c0e47d8c20a490a3d61ea64d2413d3c3570"}], "stats": {"total": 588, "additions": 17, "deletions": 571}, "files": [{"sha": "2a4343b0a6599881123f3798de9e38590a28fd4d", "filename": "crates/ra_syntax/src/parsing/lexer.rs", "status": "modified", "additions": 17, "deletions": 148, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/700669bbd0ab3ae0c5a56985ce13ca896d342a3a/crates%2Fra_syntax%2Fsrc%2Fparsing%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700669bbd0ab3ae0c5a56985ce13ca896d342a3a/crates%2Fra_syntax%2Fsrc%2Fparsing%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparsing%2Flexer.rs?ref=700669bbd0ab3ae0c5a56985ce13ca896d342a3a", "patch": "@@ -1,22 +1,6 @@\n-mod classes;\n-mod comments;\n-mod numbers;\n-mod ptr;\n-mod strings;\n-\n use crate::{\n     SyntaxKind::{self, *},\n-    TextUnit, T,\n-};\n-\n-use self::{\n-    classes::*,\n-    comments::{scan_comment, scan_shebang},\n-    numbers::scan_number,\n-    ptr::Ptr,\n-    strings::{\n-        is_string_literal_start, scan_byte_char_or_string, scan_char, scan_raw_string, scan_string,\n-    },\n+    TextUnit,\n };\n \n /// A token of Rust source.\n@@ -141,138 +125,23 @@ pub fn tokenize(text: &str) -> Vec<Token> {\n     acc\n }\n \n-/// Get the next token from a string\n-fn next_token(text: &str) -> Token {\n-    assert!(!text.is_empty());\n-    let mut ptr = Ptr::new(text);\n-    let c = ptr.bump().unwrap();\n-    let kind = next_token_inner(c, &mut ptr);\n-    let len = ptr.into_len();\n-    Token { kind, len }\n-}\n-\n-fn next_token_inner(c: char, ptr: &mut Ptr) -> SyntaxKind {\n-    if is_whitespace(c) {\n-        ptr.bump_while(is_whitespace);\n-        return WHITESPACE;\n-    }\n-\n-    match c {\n-        '#' => {\n-            if scan_shebang(ptr) {\n-                return SHEBANG;\n-            }\n-        }\n-        '/' => {\n-            if let Some(kind) = scan_comment(ptr) {\n-                return kind;\n-            }\n-        }\n-        _ => (),\n-    }\n-\n-    let ident_start = is_ident_start(c) && !is_string_literal_start(c, ptr.current(), ptr.nth(1));\n-    if ident_start {\n-        return scan_ident(c, ptr);\n-    }\n-\n-    if is_dec_digit(c) {\n-        let kind = scan_number(c, ptr);\n-        scan_literal_suffix(ptr);\n-        return kind;\n-    }\n-\n-    // One-byte tokens.\n-    if let Some(kind) = SyntaxKind::from_char(c) {\n-        return kind;\n-    }\n-\n-    match c {\n-        // Possiblily multi-byte tokens,\n-        // but we only produce single byte token now\n-        // T![...], T![..], T![..=], T![.]\n-        '.' => return T![.],\n-        // T![::] T![:]\n-        ':' => return T![:],\n-        // T![==] FATARROW T![=]\n-        '=' => return T![=],\n-        // T![!=] T![!]\n-        '!' => return T![!],\n-        // T![->] T![-]\n-        '-' => return T![-],\n-\n-        // If the character is an ident start not followed by another single\n-        // quote, then this is a lifetime name:\n-        '\\'' => {\n-            return if ptr.at_p(is_ident_start) && !ptr.at_str(\"''\") {\n-                ptr.bump();\n-                while ptr.at_p(is_ident_continue) {\n-                    ptr.bump();\n-                }\n-                // lifetimes shouldn't end with a single quote\n-                // if we find one, then this is an invalid character literal\n-                if ptr.at('\\'') {\n-                    ptr.bump();\n-                    return CHAR;\n-                }\n-                LIFETIME\n-            } else {\n-                scan_char(ptr);\n-                scan_literal_suffix(ptr);\n-                CHAR\n-            };\n-        }\n-        'b' => {\n-            let kind = scan_byte_char_or_string(ptr);\n-            scan_literal_suffix(ptr);\n-            return kind;\n-        }\n-        '\"' => {\n-            scan_string(ptr);\n-            scan_literal_suffix(ptr);\n-            return STRING;\n-        }\n-        'r' => {\n-            scan_raw_string(ptr);\n-            scan_literal_suffix(ptr);\n-            return RAW_STRING;\n-        }\n-        _ => (),\n-    }\n-    ERROR\n-}\n-\n-fn scan_ident(c: char, ptr: &mut Ptr) -> SyntaxKind {\n-    let is_raw = match (c, ptr.current()) {\n-        ('r', Some('#')) => {\n-            ptr.bump();\n-            true\n-        }\n-        ('_', None) => return T![_],\n-        ('_', Some(c)) if !is_ident_continue(c) => return T![_],\n-        _ => false,\n-    };\n-    ptr.bump_while(is_ident_continue);\n-    if !is_raw {\n-        if let Some(kind) = SyntaxKind::from_keyword(ptr.current_token_text()) {\n-            return kind;\n-        }\n-    }\n-    IDENT\n-}\n-\n-fn scan_literal_suffix(ptr: &mut Ptr) {\n-    if ptr.at_p(is_ident_start) {\n-        ptr.bump();\n-    }\n-    ptr.bump_while(is_ident_continue);\n-}\n-\n pub fn classify_literal(text: &str) -> Option<Token> {\n-    let tkn = next_token(text);\n-    if !tkn.kind.is_literal() || tkn.len.to_usize() != text.len() {\n+    let t = ra_rustc_lexer::first_token(text);\n+    if t.len != text.len() {\n         return None;\n     }\n-\n-    Some(tkn)\n+    let kind = match t.kind {\n+        ra_rustc_lexer::TokenKind::Literal { kind, .. } => match kind {\n+            ra_rustc_lexer::LiteralKind::Int { .. } => INT_NUMBER,\n+            ra_rustc_lexer::LiteralKind::Float { .. } => FLOAT_NUMBER,\n+            ra_rustc_lexer::LiteralKind::Char { .. } => CHAR,\n+            ra_rustc_lexer::LiteralKind::Byte { .. } => BYTE,\n+            ra_rustc_lexer::LiteralKind::Str { .. } => STRING,\n+            ra_rustc_lexer::LiteralKind::ByteStr { .. } => BYTE_STRING,\n+            ra_rustc_lexer::LiteralKind::RawStr { .. } => RAW_STRING,\n+            ra_rustc_lexer::LiteralKind::RawByteStr { .. } => RAW_BYTE_STRING,\n+        },\n+        _ => return None,\n+    };\n+    Some(Token { kind, len: TextUnit::from_usize(t.len) })\n }"}, {"sha": "4235d2648ad3a903ab9d71655d16bdf70323f7ba", "filename": "crates/ra_syntax/src/parsing/lexer/classes.rs", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/75761c0e47d8c20a490a3d61ea64d2413d3c3570/crates%2Fra_syntax%2Fsrc%2Fparsing%2Flexer%2Fclasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75761c0e47d8c20a490a3d61ea64d2413d3c3570/crates%2Fra_syntax%2Fsrc%2Fparsing%2Flexer%2Fclasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparsing%2Flexer%2Fclasses.rs?ref=75761c0e47d8c20a490a3d61ea64d2413d3c3570", "patch": "@@ -1,26 +0,0 @@\n-use unicode_xid::UnicodeXID;\n-\n-pub fn is_ident_start(c: char) -> bool {\n-    (c >= 'a' && c <= 'z')\n-        || (c >= 'A' && c <= 'Z')\n-        || c == '_'\n-        || (c > '\\x7f' && UnicodeXID::is_xid_start(c))\n-}\n-\n-pub fn is_ident_continue(c: char) -> bool {\n-    (c >= 'a' && c <= 'z')\n-        || (c >= 'A' && c <= 'Z')\n-        || (c >= '0' && c <= '9')\n-        || c == '_'\n-        || (c > '\\x7f' && UnicodeXID::is_xid_continue(c))\n-}\n-\n-pub fn is_whitespace(c: char) -> bool {\n-    //FIXME: use is_pattern_whitespace\n-    //https://github.com/behnam/rust-unic/issues/192\n-    c.is_whitespace()\n-}\n-\n-pub fn is_dec_digit(c: char) -> bool {\n-    '0' <= c && c <= '9'\n-}"}, {"sha": "8bbbe659b35ea4a72035b56bdd9e148d2f708b73", "filename": "crates/ra_syntax/src/parsing/lexer/comments.rs", "status": "removed", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/75761c0e47d8c20a490a3d61ea64d2413d3c3570/crates%2Fra_syntax%2Fsrc%2Fparsing%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75761c0e47d8c20a490a3d61ea64d2413d3c3570/crates%2Fra_syntax%2Fsrc%2Fparsing%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparsing%2Flexer%2Fcomments.rs?ref=75761c0e47d8c20a490a3d61ea64d2413d3c3570", "patch": "@@ -1,57 +0,0 @@\n-use crate::parsing::lexer::ptr::Ptr;\n-\n-use crate::SyntaxKind::{self, *};\n-\n-pub(crate) fn scan_shebang(ptr: &mut Ptr) -> bool {\n-    if ptr.at_str(\"!/\") {\n-        ptr.bump();\n-        ptr.bump();\n-        bump_until_eol(ptr);\n-        true\n-    } else {\n-        false\n-    }\n-}\n-\n-fn scan_block_comment(ptr: &mut Ptr) -> Option<SyntaxKind> {\n-    if ptr.at('*') {\n-        ptr.bump();\n-        let mut depth: u32 = 1;\n-        while depth > 0 {\n-            if ptr.at_str(\"*/\") {\n-                depth -= 1;\n-                ptr.bump();\n-                ptr.bump();\n-            } else if ptr.at_str(\"/*\") {\n-                depth += 1;\n-                ptr.bump();\n-                ptr.bump();\n-            } else if ptr.bump().is_none() {\n-                break;\n-            }\n-        }\n-        Some(COMMENT)\n-    } else {\n-        None\n-    }\n-}\n-\n-pub(crate) fn scan_comment(ptr: &mut Ptr) -> Option<SyntaxKind> {\n-    if ptr.at('/') {\n-        bump_until_eol(ptr);\n-        Some(COMMENT)\n-    } else {\n-        scan_block_comment(ptr)\n-    }\n-}\n-\n-fn bump_until_eol(ptr: &mut Ptr) {\n-    loop {\n-        if ptr.at('\\n') || ptr.at_str(\"\\r\\n\") {\n-            return;\n-        }\n-        if ptr.bump().is_none() {\n-            break;\n-        }\n-    }\n-}"}, {"sha": "e53ae231b331a24e711f026b47e25d0d27f60326", "filename": "crates/ra_syntax/src/parsing/lexer/numbers.rs", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/75761c0e47d8c20a490a3d61ea64d2413d3c3570/crates%2Fra_syntax%2Fsrc%2Fparsing%2Flexer%2Fnumbers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75761c0e47d8c20a490a3d61ea64d2413d3c3570/crates%2Fra_syntax%2Fsrc%2Fparsing%2Flexer%2Fnumbers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparsing%2Flexer%2Fnumbers.rs?ref=75761c0e47d8c20a490a3d61ea64d2413d3c3570", "patch": "@@ -1,66 +0,0 @@\n-use crate::parsing::lexer::{classes::*, ptr::Ptr};\n-\n-use crate::SyntaxKind::{self, *};\n-\n-pub(crate) fn scan_number(c: char, ptr: &mut Ptr) -> SyntaxKind {\n-    if c == '0' {\n-        match ptr.current().unwrap_or('\\0') {\n-            'b' | 'o' => {\n-                ptr.bump();\n-                scan_digits(ptr, false);\n-            }\n-            'x' => {\n-                ptr.bump();\n-                scan_digits(ptr, true);\n-            }\n-            '0'..='9' | '_' | '.' | 'e' | 'E' => {\n-                scan_digits(ptr, true);\n-            }\n-            _ => return INT_NUMBER,\n-        }\n-    } else {\n-        scan_digits(ptr, false);\n-    }\n-\n-    // might be a float, but don't be greedy if this is actually an\n-    // integer literal followed by field/method access or a range pattern\n-    // (`0..2` and `12.foo()`)\n-    if ptr.at('.') && !(ptr.at_str(\"..\") || ptr.nth_is_p(1, is_ident_start)) {\n-        // might have stuff after the ., and if it does, it needs to start\n-        // with a number\n-        ptr.bump();\n-        scan_digits(ptr, false);\n-        scan_float_exponent(ptr);\n-        return FLOAT_NUMBER;\n-    }\n-    // it might be a float if it has an exponent\n-    if ptr.at('e') || ptr.at('E') {\n-        scan_float_exponent(ptr);\n-        return FLOAT_NUMBER;\n-    }\n-    INT_NUMBER\n-}\n-\n-fn scan_digits(ptr: &mut Ptr, allow_hex: bool) {\n-    while let Some(c) = ptr.current() {\n-        match c {\n-            '_' | '0'..='9' => {\n-                ptr.bump();\n-            }\n-            'a'..='f' | 'A'..='F' if allow_hex => {\n-                ptr.bump();\n-            }\n-            _ => return,\n-        }\n-    }\n-}\n-\n-fn scan_float_exponent(ptr: &mut Ptr) {\n-    if ptr.at('e') || ptr.at('E') {\n-        ptr.bump();\n-        if ptr.at('-') || ptr.at('+') {\n-            ptr.bump();\n-        }\n-        scan_digits(ptr, false);\n-    }\n-}"}, {"sha": "c341c4176bbe85a74634fa44398383a9b80401ae", "filename": "crates/ra_syntax/src/parsing/lexer/ptr.rs", "status": "removed", "additions": 0, "deletions": 162, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/75761c0e47d8c20a490a3d61ea64d2413d3c3570/crates%2Fra_syntax%2Fsrc%2Fparsing%2Flexer%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75761c0e47d8c20a490a3d61ea64d2413d3c3570/crates%2Fra_syntax%2Fsrc%2Fparsing%2Flexer%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparsing%2Flexer%2Fptr.rs?ref=75761c0e47d8c20a490a3d61ea64d2413d3c3570", "patch": "@@ -1,162 +0,0 @@\n-use crate::TextUnit;\n-\n-use std::str::Chars;\n-\n-/// A simple view into the characters of a string.\n-pub(crate) struct Ptr<'s> {\n-    text: &'s str,\n-    len: TextUnit,\n-}\n-\n-impl<'s> Ptr<'s> {\n-    /// Creates a new `Ptr` from a string.\n-    pub fn new(text: &'s str) -> Ptr<'s> {\n-        Ptr { text, len: 0.into() }\n-    }\n-\n-    /// Gets the length of the remaining string.\n-    pub fn into_len(self) -> TextUnit {\n-        self.len\n-    }\n-\n-    /// Gets the current character, if one exists.\n-    pub fn current(&self) -> Option<char> {\n-        self.chars().next()\n-    }\n-\n-    /// Gets the nth character from the current.\n-    /// For example, 0 will return the current character, 1 will return the next, etc.\n-    pub fn nth(&self, n: u32) -> Option<char> {\n-        self.chars().nth(n as usize)\n-    }\n-\n-    /// Checks whether the current character is `c`.\n-    pub fn at(&self, c: char) -> bool {\n-        self.current() == Some(c)\n-    }\n-\n-    /// Checks whether the next characters match `s`.\n-    pub fn at_str(&self, s: &str) -> bool {\n-        let chars = self.chars();\n-        chars.as_str().starts_with(s)\n-    }\n-\n-    /// Checks whether the current character satisfies the predicate `p`.\n-    pub fn at_p<P: Fn(char) -> bool>(&self, p: P) -> bool {\n-        self.current().map(p) == Some(true)\n-    }\n-\n-    /// Checks whether the nth character satisfies the predicate `p`.\n-    pub fn nth_is_p<P: Fn(char) -> bool>(&self, n: u32, p: P) -> bool {\n-        self.nth(n).map(p) == Some(true)\n-    }\n-\n-    /// Moves to the next character.\n-    pub fn bump(&mut self) -> Option<char> {\n-        let ch = self.chars().next()?;\n-        self.len += TextUnit::of_char(ch);\n-        Some(ch)\n-    }\n-\n-    /// Moves to the next character as long as `pred` is satisfied.\n-    pub fn bump_while<F: Fn(char) -> bool>(&mut self, pred: F) {\n-        loop {\n-            match self.current() {\n-                Some(c) if pred(c) => {\n-                    self.bump();\n-                }\n-                _ => return,\n-            }\n-        }\n-    }\n-\n-    /// Returns the text up to the current point.\n-    pub fn current_token_text(&self) -> &str {\n-        let len: u32 = self.len.into();\n-        &self.text[..len as usize]\n-    }\n-\n-    /// Returns an iterator over the remaining characters.\n-    fn chars(&self) -> Chars {\n-        let len: u32 = self.len.into();\n-        self.text[len as usize..].chars()\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-\n-    #[test]\n-    fn test_current() {\n-        let ptr = Ptr::new(\"test\");\n-        assert_eq!(ptr.current(), Some('t'));\n-    }\n-\n-    #[test]\n-    fn test_nth() {\n-        let ptr = Ptr::new(\"test\");\n-        assert_eq!(ptr.nth(0), Some('t'));\n-        assert_eq!(ptr.nth(1), Some('e'));\n-        assert_eq!(ptr.nth(2), Some('s'));\n-        assert_eq!(ptr.nth(3), Some('t'));\n-        assert_eq!(ptr.nth(4), None);\n-    }\n-\n-    #[test]\n-    fn test_at() {\n-        let ptr = Ptr::new(\"test\");\n-        assert!(ptr.at('t'));\n-        assert!(!ptr.at('a'));\n-    }\n-\n-    #[test]\n-    fn test_at_str() {\n-        let ptr = Ptr::new(\"test\");\n-        assert!(ptr.at_str(\"t\"));\n-        assert!(ptr.at_str(\"te\"));\n-        assert!(ptr.at_str(\"test\"));\n-        assert!(!ptr.at_str(\"tests\"));\n-        assert!(!ptr.at_str(\"rust\"));\n-    }\n-\n-    #[test]\n-    fn test_at_p() {\n-        let ptr = Ptr::new(\"test\");\n-        assert!(ptr.at_p(|c| c == 't'));\n-        assert!(!ptr.at_p(|c| c == 'e'));\n-    }\n-\n-    #[test]\n-    fn test_nth_is_p() {\n-        let ptr = Ptr::new(\"test\");\n-        assert!(ptr.nth_is_p(0, |c| c == 't'));\n-        assert!(!ptr.nth_is_p(1, |c| c == 't'));\n-        assert!(ptr.nth_is_p(3, |c| c == 't'));\n-        assert!(!ptr.nth_is_p(150, |c| c == 't'));\n-    }\n-\n-    #[test]\n-    fn test_bump() {\n-        let mut ptr = Ptr::new(\"test\");\n-        assert_eq!(ptr.current(), Some('t'));\n-        ptr.bump();\n-        assert_eq!(ptr.current(), Some('e'));\n-        ptr.bump();\n-        assert_eq!(ptr.current(), Some('s'));\n-        ptr.bump();\n-        assert_eq!(ptr.current(), Some('t'));\n-        ptr.bump();\n-        assert_eq!(ptr.current(), None);\n-        ptr.bump();\n-        assert_eq!(ptr.current(), None);\n-    }\n-\n-    #[test]\n-    fn test_bump_while() {\n-        let mut ptr = Ptr::new(\"test\");\n-        assert_eq!(ptr.current(), Some('t'));\n-        ptr.bump_while(|c| c != 's');\n-        assert_eq!(ptr.current(), Some('s'));\n-    }\n-}"}, {"sha": "f74acff9e21bac578f1e0f77d4288bb7eda2a0d1", "filename": "crates/ra_syntax/src/parsing/lexer/strings.rs", "status": "removed", "additions": 0, "deletions": 112, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/75761c0e47d8c20a490a3d61ea64d2413d3c3570/crates%2Fra_syntax%2Fsrc%2Fparsing%2Flexer%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75761c0e47d8c20a490a3d61ea64d2413d3c3570/crates%2Fra_syntax%2Fsrc%2Fparsing%2Flexer%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparsing%2Flexer%2Fstrings.rs?ref=75761c0e47d8c20a490a3d61ea64d2413d3c3570", "patch": "@@ -1,112 +0,0 @@\n-use crate::{\n-    parsing::lexer::ptr::Ptr,\n-    SyntaxKind::{self, *},\n-};\n-\n-pub(crate) fn is_string_literal_start(c: char, c1: Option<char>, c2: Option<char>) -> bool {\n-    match (c, c1, c2) {\n-        ('r', Some('\"'), _)\n-        | ('r', Some('#'), Some('\"'))\n-        | ('r', Some('#'), Some('#'))\n-        | ('b', Some('\"'), _)\n-        | ('b', Some('\\''), _)\n-        | ('b', Some('r'), Some('\"'))\n-        | ('b', Some('r'), Some('#')) => true,\n-        _ => false,\n-    }\n-}\n-\n-pub(crate) fn scan_char(ptr: &mut Ptr) {\n-    while let Some(c) = ptr.current() {\n-        match c {\n-            '\\\\' => {\n-                ptr.bump();\n-                if ptr.at('\\\\') || ptr.at('\\'') {\n-                    ptr.bump();\n-                }\n-            }\n-            '\\'' => {\n-                ptr.bump();\n-                return;\n-            }\n-            '\\n' => return,\n-            _ => {\n-                ptr.bump();\n-            }\n-        }\n-    }\n-}\n-\n-pub(crate) fn scan_byte_char_or_string(ptr: &mut Ptr) -> SyntaxKind {\n-    // unwrapping and not-exhaustive match are ok\n-    // because of string_literal_start\n-    let c = ptr.bump().unwrap();\n-    match c {\n-        '\\'' => {\n-            scan_byte(ptr);\n-            BYTE\n-        }\n-        '\"' => {\n-            scan_byte_string(ptr);\n-            BYTE_STRING\n-        }\n-        'r' => {\n-            scan_raw_string(ptr);\n-            RAW_BYTE_STRING\n-        }\n-        _ => unreachable!(),\n-    }\n-}\n-\n-pub(crate) fn scan_string(ptr: &mut Ptr) {\n-    while let Some(c) = ptr.current() {\n-        match c {\n-            '\\\\' => {\n-                ptr.bump();\n-                if ptr.at('\\\\') || ptr.at('\"') {\n-                    ptr.bump();\n-                }\n-            }\n-            '\"' => {\n-                ptr.bump();\n-                return;\n-            }\n-            _ => {\n-                ptr.bump();\n-            }\n-        }\n-    }\n-}\n-\n-pub(crate) fn scan_raw_string(ptr: &mut Ptr) {\n-    let mut hashes = 0;\n-    while ptr.at('#') {\n-        hashes += 1;\n-        ptr.bump();\n-    }\n-    if !ptr.at('\"') {\n-        return;\n-    }\n-    ptr.bump();\n-\n-    while let Some(c) = ptr.bump() {\n-        if c == '\"' {\n-            let mut hashes_left = hashes;\n-            while ptr.at('#') && hashes_left > 0 {\n-                hashes_left -= 1;\n-                ptr.bump();\n-            }\n-            if hashes_left == 0 {\n-                return;\n-            }\n-        }\n-    }\n-}\n-\n-fn scan_byte(ptr: &mut Ptr) {\n-    scan_char(ptr)\n-}\n-\n-fn scan_byte_string(ptr: &mut Ptr) {\n-    scan_string(ptr)\n-}"}]}