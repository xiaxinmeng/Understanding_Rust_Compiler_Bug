{"sha": "bf88b113eab9c36e63f8461f5849138cb60d810a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmODhiMTEzZWFiOWMzNmU2M2Y4NDYxZjU4NDkxMzhjYjYwZDgxMGE=", "commit": {"author": {"name": "Frank Steffahn", "email": "frank.steffahn@stu.uni-kiel.de", "date": "2021-08-22T12:46:15Z"}, "committer": {"name": "Frank Steffahn", "email": "frank.steffahn@stu.uni-kiel.de", "date": "2021-08-22T13:35:11Z"}, "message": "Fix typos \u201ca\u201d\u2192\u201can\u201d", "tree": {"sha": "f333d6f75d1ec09c17554a69c6420ced3203adf2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f333d6f75d1ec09c17554a69c6420ced3203adf2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bf88b113eab9c36e63f8461f5849138cb60d810a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bf88b113eab9c36e63f8461f5849138cb60d810a", "html_url": "https://github.com/rust-lang/rust/commit/bf88b113eab9c36e63f8461f5849138cb60d810a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bf88b113eab9c36e63f8461f5849138cb60d810a/comments", "author": {"login": "steffahn", "id": 3986214, "node_id": "MDQ6VXNlcjM5ODYyMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3986214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steffahn", "html_url": "https://github.com/steffahn", "followers_url": "https://api.github.com/users/steffahn/followers", "following_url": "https://api.github.com/users/steffahn/following{/other_user}", "gists_url": "https://api.github.com/users/steffahn/gists{/gist_id}", "starred_url": "https://api.github.com/users/steffahn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steffahn/subscriptions", "organizations_url": "https://api.github.com/users/steffahn/orgs", "repos_url": "https://api.github.com/users/steffahn/repos", "events_url": "https://api.github.com/users/steffahn/events{/privacy}", "received_events_url": "https://api.github.com/users/steffahn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steffahn", "id": 3986214, "node_id": "MDQ6VXNlcjM5ODYyMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3986214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steffahn", "html_url": "https://github.com/steffahn", "followers_url": "https://api.github.com/users/steffahn/followers", "following_url": "https://api.github.com/users/steffahn/following{/other_user}", "gists_url": "https://api.github.com/users/steffahn/gists{/gist_id}", "starred_url": "https://api.github.com/users/steffahn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steffahn/subscriptions", "organizations_url": "https://api.github.com/users/steffahn/orgs", "repos_url": "https://api.github.com/users/steffahn/repos", "events_url": "https://api.github.com/users/steffahn/events{/privacy}", "received_events_url": "https://api.github.com/users/steffahn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ad56d5c9031636c1509f4417e88099a49405b4e", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ad56d5c9031636c1509f4417e88099a49405b4e", "html_url": "https://github.com/rust-lang/rust/commit/2ad56d5c9031636c1509f4417e88099a49405b4e"}], "stats": {"total": 314, "additions": 157, "deletions": 157}, "files": [{"sha": "710a592e258b43d1ec067d6562e9c705ebee05b8", "filename": "compiler/rustc_ast/src/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -495,7 +495,7 @@ impl Token {\n         self.lifetime().is_some()\n     }\n \n-    /// Returns `true` if the token is a identifier whose name is the given\n+    /// Returns `true` if the token is an identifier whose name is the given\n     /// string slice.\n     pub fn is_ident_named(&self, name: Symbol) -> bool {\n         self.ident().map_or(false, |(ident, _)| ident.name == name)"}, {"sha": "3eb38514b3cfa502dc4855a2253fd936eebb286b", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -1265,7 +1265,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                                     ty,\n                                 );\n \n-                                // Construct a AnonConst where the expr is the \"ty\"'s path.\n+                                // Construct an AnonConst where the expr is the \"ty\"'s path.\n \n                                 let parent_def_id = self.current_hir_id_owner.0;\n                                 let node_id = self.resolver.next_node_id();\n@@ -2690,7 +2690,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     /// Report an error on illegal use of `'_` or a `&T` with no explicit lifetime;\n-    /// return a \"error lifetime\".\n+    /// return an \"error lifetime\".\n     fn new_error_lifetime(&mut self, id: Option<NodeId>, span: Span) -> hir::Lifetime {\n         let (id, msg, label) = match id {\n             Some(id) => (id, \"`'_` cannot be used here\", \"`'_` is a reserved lifetime name\"),"}, {"sha": "4ad711ccaf1cac7e3c3bc1a463fb8fb85b0cee30", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -1700,7 +1700,7 @@ where\n /// One or more fields: call the base case function on the first value (which depends on\n /// `use_fold`), and use that as the base case. Then perform `cs_fold` on the remainder of the\n /// fields.\n-/// When the `substructure` is a `EnumNonMatchingCollapsed`, the result of `enum_nonmatch_f`\n+/// When the `substructure` is an `EnumNonMatchingCollapsed`, the result of `enum_nonmatch_f`\n /// is returned. Statics may not be folded over.\n /// See `cs_op` in `partial_ord.rs` for a model example.\n pub fn cs_fold1<F, B>("}, {"sha": "fff2268596a686d065f0a8f97b26f4246c80c525", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -137,7 +137,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                         match scalar.value {\n                             Primitive::Int(..) => {\n                                 if self.cx().size_of(ret_ty).bytes() < 4 {\n-                                    // `va_arg` should not be called on a integer type\n+                                    // `va_arg` should not be called on an integer type\n                                     // less than 4 bytes in length. If it is, promote\n                                     // the integer to a `i32` and truncate the result\n                                     // back to the smaller type."}, {"sha": "65869483025fb7e04f432e4b46807fa788bd2789", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -901,7 +901,7 @@ fn cast_float_to_int<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     //\n     // Performance note: Unordered comparison can be lowered to a \"flipped\"\n     // comparison and a negation, and the negation can be merged into the\n-    // select. Therefore, it not necessarily any more expensive than a\n+    // select. Therefore, it not necessarily any more expensive than an\n     // ordered (\"normal\") comparison. Whether these optimizations will be\n     // performed is ultimately up to the backend, but at least x86 does\n     // perform them."}, {"sha": "19b4426981c72534869823a675d074b81bb14904", "filename": "compiler/rustc_data_structures/src/owning_ref/mod.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2Fmod.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -321,7 +321,7 @@ pub unsafe trait IntoErasedSendSync<'a> {\n /////////////////////////////////////////////////////////////////////////////\n \n impl<O, T: ?Sized> OwningRef<O, T> {\n-    /// Creates a new owning reference from a owner\n+    /// Creates a new owning reference from an owner\n     /// initialized to the direct dereference of it.\n     ///\n     /// # Example\n@@ -368,7 +368,7 @@ impl<O, T: ?Sized> OwningRef<O, T> {\n     /// fn main() {\n     ///     let owning_ref = OwningRef::new(Box::new([1, 2, 3, 4]));\n     ///\n-    ///     // create a owning reference that points at the\n+    ///     // create an owning reference that points at the\n     ///     // third element of the array.\n     ///     let owning_ref = owning_ref.map(|array| &array[2]);\n     ///     assert_eq!(*owning_ref, 3);\n@@ -396,7 +396,7 @@ impl<O, T: ?Sized> OwningRef<O, T> {\n     /// fn main() {\n     ///     let owning_ref = OwningRef::new(Box::new([1, 2, 3, 4]));\n     ///\n-    ///     // create a owning reference that points at the\n+    ///     // create an owning reference that points at the\n     ///     // third element of the array.\n     ///     let owning_ref = owning_ref.try_map(|array| {\n     ///         if array[2] == 3 { Ok(&array[2]) } else { Err(()) }\n@@ -430,7 +430,7 @@ impl<O, T: ?Sized> OwningRef<O, T> {\n     /// in an additional `Box<O>`.\n     ///\n     /// This can be used to safely erase the owner of any `OwningRef<O, T>`\n-    /// to a `OwningRef<Box<Erased>, T>`.\n+    /// to an `OwningRef<Box<Erased>, T>`.\n     pub fn map_owner_box(self) -> OwningRef<Box<O>, T> {\n         OwningRef { reference: self.reference, owner: Box::new(self.owner) }\n     }\n@@ -511,7 +511,7 @@ impl<O, T: ?Sized> OwningRef<O, T> {\n }\n \n impl<O, T: ?Sized> OwningRefMut<O, T> {\n-    /// Creates a new owning reference from a owner\n+    /// Creates a new owning reference from an owner\n     /// initialized to the direct dereference of it.\n     ///\n     /// # Example\n@@ -558,7 +558,7 @@ impl<O, T: ?Sized> OwningRefMut<O, T> {\n     /// fn main() {\n     ///     let owning_ref_mut = OwningRefMut::new(Box::new([1, 2, 3, 4]));\n     ///\n-    ///     // create a owning reference that points at the\n+    ///     // create an owning reference that points at the\n     ///     // third element of the array.\n     ///     let owning_ref = owning_ref_mut.map(|array| &array[2]);\n     ///     assert_eq!(*owning_ref, 3);\n@@ -586,7 +586,7 @@ impl<O, T: ?Sized> OwningRefMut<O, T> {\n     /// fn main() {\n     ///     let owning_ref_mut = OwningRefMut::new(Box::new([1, 2, 3, 4]));\n     ///\n-    ///     // create a owning reference that points at the\n+    ///     // create an owning reference that points at the\n     ///     // third element of the array.\n     ///     let owning_ref_mut = owning_ref_mut.map_mut(|array| &mut array[2]);\n     ///     assert_eq!(*owning_ref_mut, 3);\n@@ -614,7 +614,7 @@ impl<O, T: ?Sized> OwningRefMut<O, T> {\n     /// fn main() {\n     ///     let owning_ref_mut = OwningRefMut::new(Box::new([1, 2, 3, 4]));\n     ///\n-    ///     // create a owning reference that points at the\n+    ///     // create an owning reference that points at the\n     ///     // third element of the array.\n     ///     let owning_ref = owning_ref_mut.try_map(|array| {\n     ///         if array[2] == 3 { Ok(&array[2]) } else { Err(()) }\n@@ -644,7 +644,7 @@ impl<O, T: ?Sized> OwningRefMut<O, T> {\n     /// fn main() {\n     ///     let owning_ref_mut = OwningRefMut::new(Box::new([1, 2, 3, 4]));\n     ///\n-    ///     // create a owning reference that points at the\n+    ///     // create an owning reference that points at the\n     ///     // third element of the array.\n     ///     let owning_ref_mut = owning_ref_mut.try_map_mut(|array| {\n     ///         if array[2] == 3 { Ok(&mut array[2]) } else { Err(()) }\n@@ -678,7 +678,7 @@ impl<O, T: ?Sized> OwningRefMut<O, T> {\n     /// in an additional `Box<O>`.\n     ///\n     /// This can be used to safely erase the owner of any `OwningRefMut<O, T>`\n-    /// to a `OwningRefMut<Box<Erased>, T>`.\n+    /// to an `OwningRefMut<Box<Erased>, T>`.\n     pub fn map_owner_box(self) -> OwningRefMut<Box<O>, T> {\n         OwningRefMut { reference: self.reference, owner: Box::new(self.owner) }\n     }\n@@ -970,7 +970,7 @@ where\n     }\n }\n \n-// ^ FIXME: Is a Into impl for calling into_inner() possible as well?\n+// ^ FIXME: Is an Into impl for calling into_inner() possible as well?\n \n impl<O, T: ?Sized> Debug for OwningRef<O, T>\n where\n@@ -1139,27 +1139,27 @@ impl<T: 'static> ToHandleMut for RefCell<T> {\n // about which handle creation to use (i.e., read() vs try_read()) as well as\n // what to do with error results.\n \n-/// Typedef of a owning reference that uses a `Box` as the owner.\n+/// Typedef of an owning reference that uses a `Box` as the owner.\n pub type BoxRef<T, U = T> = OwningRef<Box<T>, U>;\n-/// Typedef of a owning reference that uses a `Vec` as the owner.\n+/// Typedef of an owning reference that uses a `Vec` as the owner.\n pub type VecRef<T, U = T> = OwningRef<Vec<T>, U>;\n-/// Typedef of a owning reference that uses a `String` as the owner.\n+/// Typedef of an owning reference that uses a `String` as the owner.\n pub type StringRef = OwningRef<String, str>;\n \n-/// Typedef of a owning reference that uses a `Rc` as the owner.\n+/// Typedef of an owning reference that uses a `Rc` as the owner.\n pub type RcRef<T, U = T> = OwningRef<Rc<T>, U>;\n-/// Typedef of a owning reference that uses a `Arc` as the owner.\n+/// Typedef of an owning reference that uses a `Arc` as the owner.\n pub type ArcRef<T, U = T> = OwningRef<Arc<T>, U>;\n \n-/// Typedef of a owning reference that uses a `Ref` as the owner.\n+/// Typedef of an owning reference that uses a `Ref` as the owner.\n pub type RefRef<'a, T, U = T> = OwningRef<Ref<'a, T>, U>;\n-/// Typedef of a owning reference that uses a `RefMut` as the owner.\n+/// Typedef of an owning reference that uses a `RefMut` as the owner.\n pub type RefMutRef<'a, T, U = T> = OwningRef<RefMut<'a, T>, U>;\n-/// Typedef of a owning reference that uses a `MutexGuard` as the owner.\n+/// Typedef of an owning reference that uses a `MutexGuard` as the owner.\n pub type MutexGuardRef<'a, T, U = T> = OwningRef<MutexGuard<'a, T>, U>;\n-/// Typedef of a owning reference that uses a `RwLockReadGuard` as the owner.\n+/// Typedef of an owning reference that uses a `RwLockReadGuard` as the owner.\n pub type RwLockReadGuardRef<'a, T, U = T> = OwningRef<RwLockReadGuard<'a, T>, U>;\n-/// Typedef of a owning reference that uses a `RwLockWriteGuard` as the owner.\n+/// Typedef of an owning reference that uses a `RwLockWriteGuard` as the owner.\n pub type RwLockWriteGuardRef<'a, T, U = T> = OwningRef<RwLockWriteGuard<'a, T>, U>;\n \n /// Typedef of a mutable owning reference that uses a `Box` as the owner.\n@@ -1219,11 +1219,11 @@ unsafe impl<'a, T: Send + Sync + 'a> IntoErasedSendSync<'a> for Arc<T> {\n     }\n }\n \n-/// Typedef of a owning reference that uses an erased `Box` as the owner.\n+/// Typedef of an owning reference that uses an erased `Box` as the owner.\n pub type ErasedBoxRef<U> = OwningRef<Box<dyn Erased>, U>;\n-/// Typedef of a owning reference that uses an erased `Rc` as the owner.\n+/// Typedef of an owning reference that uses an erased `Rc` as the owner.\n pub type ErasedRcRef<U> = OwningRef<Rc<dyn Erased>, U>;\n-/// Typedef of a owning reference that uses an erased `Arc` as the owner.\n+/// Typedef of an owning reference that uses an erased `Arc` as the owner.\n pub type ErasedArcRef<U> = OwningRef<Arc<dyn Erased>, U>;\n \n /// Typedef of a mutable owning reference that uses an erased `Box` as the owner."}, {"sha": "0bbd0eda0c6e1cdd0130013c598eb0c83a395b6b", "filename": "compiler/rustc_data_structures/src/profiling.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -220,7 +220,7 @@ impl SelfProfilerRef {\n         VerboseTimingGuard::start(message, self.generic_activity(event_label))\n     }\n \n-    /// Start profiling a extra verbose generic activity. Profiling continues until the\n+    /// Start profiling an extra verbose generic activity. Profiling continues until the\n     /// VerboseTimingGuard returned from this call is dropped. In addition to recording\n     /// a measureme event, \"extra verbose\" generic activities also print a timing entry to\n     /// stdout if the compiler is invoked with -Ztime-passes."}, {"sha": "f99ca53ab25dface5c9550a943bcf87b69fae37d", "filename": "compiler/rustc_data_structures/src/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -14,7 +14,7 @@\n //!\n //! `MTRef` is an immutable reference if cfg!(parallel_compiler), and a mutable reference otherwise.\n //!\n-//! `rustc_erase_owner!` erases a OwningRef owner into Erased or Erased + Send + Sync\n+//! `rustc_erase_owner!` erases an OwningRef owner into Erased or Erased + Send + Sync\n //! depending on the value of cfg!(parallel_compiler).\n \n use crate::owning_ref::{Erased, OwningRef};"}, {"sha": "9b07f86846eb32089b26b5834dcdb72ab0b29e9e", "filename": "compiler/rustc_data_structures/src/tiny_list.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_data_structures%2Fsrc%2Ftiny_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_data_structures%2Fsrc%2Ftiny_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftiny_list.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -5,7 +5,7 @@\n //!\n //! - If you have a list that rarely stores more than one element, then this\n //!   data-structure can store the element without allocating and only uses as\n-//!   much space as a `Option<(T, usize)>`. If T can double as the `Option`\n+//!   much space as an `Option<(T, usize)>`. If T can double as the `Option`\n //!   discriminant, it will even only be as large as `T, usize`.\n //!\n //! If you expect to store more than 1 element in the common case, steer clear"}, {"sha": "e36dbc7fc623c302d11360bcd46360fcb12796c5", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -2323,7 +2323,7 @@ pub enum TyKind<'hir> {\n     ///\n     /// Type parameters may be stored in each `PathSegment`.\n     Path(QPath<'hir>),\n-    /// A opaque type definition itself. This is currently only used for the\n+    /// An opaque type definition itself. This is currently only used for the\n     /// `opaque type Foo: Trait` item that `impl Trait` in desugars to.\n     ///\n     /// The generic argument list contains the lifetimes (and in the future"}, {"sha": "7f153867596ec8439a6077b8dfab9a2b9dc7199a", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -313,7 +313,7 @@ pub trait Visitor<'v>: Sized {\n     }\n \n     /// When invoking `visit_all_item_likes()`, you need to supply an\n-    /// item-like visitor. This method converts a \"intra-visit\"\n+    /// item-like visitor. This method converts an \"intra-visit\"\n     /// visitor into an item-like visitor that walks the entire tree.\n     /// If you use this, you probably don't want to process the\n     /// contents of nested item-like things, since the outer loop will"}, {"sha": "4830158c15afc6463bf5fb2dcd7ee67e01218654", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -1697,7 +1697,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n \n         // In some (most?) cases cause.body_id points to actual body, but in some cases\n-        // it's a actual definition. According to the comments (e.g. in\n+        // it's an actual definition. According to the comments (e.g. in\n         // librustc_typeck/check/compare_method.rs:compare_predicate_entailment) the latter\n         // is relied upon by some other code. This might (or might not) need cleanup.\n         let body_owner_def_id ="}, {"sha": "0939946ae73e8ba04b2254862ca53ce4aa72fdcc", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -389,7 +389,7 @@ where\n     }\n }\n \n-/// When we instantiate a inference variable with a value in\n+/// When we instantiate an inference variable with a value in\n /// `relate_ty_var`, we always have the pair of a `TyVid` and a `Ty`,\n /// but the ordering may vary (depending on whether the inference\n /// variable was found on the `a` or `b` sides). Therefore, this trait"}, {"sha": "af31ab0923decb72c580212b932ec59964133d5b", "filename": "compiler/rustc_infer/src/infer/region_constraints/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -186,7 +186,7 @@ pub enum GenericKind<'tcx> {\n ///        ('a: min) || ('b: min)\n ///     }\n ///\n-/// This is described with a `AnyRegion('a, 'b)` node.\n+/// This is described with an `AnyRegion('a, 'b)` node.\n #[derive(Debug, Clone)]\n pub enum VerifyBound<'tcx> {\n     /// Given a kind K and a bound B, expands to a function like the"}, {"sha": "b450c398946e5c66e5c2d4286c0e3121a4190d10", "filename": "compiler/rustc_infer/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -28,7 +28,7 @@ pub use self::project::{\n pub use rustc_middle::traits::*;\n \n /// An `Obligation` represents some trait reference (e.g., `i32: Eq`) for\n-/// which the \"impl_source\" must be found. The process of finding a \"impl_source\" is\n+/// which the \"impl_source\" must be found. The process of finding an \"impl_source\" is\n /// called \"resolving\" the `Obligation`. This process consists of\n /// either identifying an `impl` (e.g., `impl Eq for i32`) that\n /// satisfies the obligation, or else finding a bound that is in"}, {"sha": "e25c51991f5740cc9d235254ef5b45c94e13ce41", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -1171,7 +1171,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                     ty::Projection(..) => {\n                         let ty = self.cx.tcx.normalize_erasing_regions(self.cx.param_env, ty);\n \n-                        // If `ty` is a opaque type directly then `super_visit_with` won't invoke\n+                        // If `ty` is an opaque type directly then `super_visit_with` won't invoke\n                         // this function again.\n                         if ty.has_opaque_types() {\n                             self.visit_ty(ty)"}, {"sha": "620ce8c0025010c8c05a39ca54aac23cf93c93a3", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -308,7 +308,7 @@ impl<'a> CrateLoader<'a> {\n             }\n \n             // Alright, so we've gotten this far which means that `data` has the\n-            // right name, we don't have a hash, and we don't have a --extern\n+            // right name, we don't have a hash, and we don't have an --extern\n             // pointing for ourselves. We're still not quite yet done because we\n             // have to make sure that this crate was found in the crate lookup\n             // path (this is a top-level dependency) as we don't want to"}, {"sha": "8efec8ef5674d6b19b4dabbd2c39db46d243dd18", "filename": "compiler/rustc_middle/src/hir/map/blocks.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fblocks.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -63,7 +63,7 @@ impl MaybeFnLike for hir::Expr<'_> {\n     }\n }\n \n-/// Carries either an FnLikeNode or a Expr, as these are the two\n+/// Carries either an FnLikeNode or an Expr, as these are the two\n /// constructs that correspond to \"code\" (as in, something from which\n /// we can construct a control-flow graph).\n #[derive(Copy, Clone)]"}, {"sha": "00c6a2aa989c8795a1d3b29663e859ad669c9476", "filename": "compiler/rustc_middle/src/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -151,7 +151,7 @@ rustc_index::newtype_index! {\n static_assert_size!(ScopeData, 4);\n \n impl Scope {\n-    /// Returns a item-local ID associated with this scope.\n+    /// Returns an item-local ID associated with this scope.\n     ///\n     /// N.B., likely to be replaced as API is refined; e.g., pnkfelix\n     /// anticipates `fn entry_node_id` and `fn each_exit_node_id`."}, {"sha": "5d17bb9b15f4b7ebe9de5cd2f3c183adb7e63f12", "filename": "compiler/rustc_middle/src/mir/interpret/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -46,7 +46,7 @@ static_assert_size!(InterpErrorInfo<'_>, 8);\n /// Packages the kind of error we got from the const code interpreter\n /// up with a Rust-level backtrace of where the error occurred.\n /// These should always be constructed by calling `.into()` on\n-/// a `InterpError`. In `rustc_mir::interpret`, we have `throw_err_*`\n+/// an `InterpError`. In `rustc_mir::interpret`, we have `throw_err_*`\n /// macros for this.\n #[derive(Debug)]\n pub struct InterpErrorInfo<'tcx>(Box<InterpErrorInfoInner<'tcx>>);"}, {"sha": "1783a40e1264b6a6288dff7b42d8af3dd7dcdeba", "filename": "compiler/rustc_middle/src/mir/interpret/value.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -17,7 +17,7 @@ use super::{\n /// Represents the result of const evaluation via the `eval_to_allocation` query.\n #[derive(Copy, Clone, HashStable, TyEncodable, TyDecodable, Debug, Hash, Eq, PartialEq)]\n pub struct ConstAlloc<'tcx> {\n-    // the value lives here, at offset 0, and that allocation definitely is a `AllocKind::Memory`\n+    // the value lives here, at offset 0, and that allocation definitely is an `AllocKind::Memory`\n     // (so you can use `AllocMap::unwrap_memory`).\n     pub alloc_id: AllocId,\n     pub ty: Ty<'tcx>,\n@@ -113,7 +113,7 @@ impl<'tcx> ConstValue<'tcx> {\n }\n \n /// A `Scalar` represents an immediate, primitive value existing outside of a\n-/// `memory::Allocation`. It is in many ways like a small chunk of a `Allocation`, up to 16 bytes in\n+/// `memory::Allocation`. It is in many ways like a small chunk of an `Allocation`, up to 16 bytes in\n /// size. Like a range of bytes in an `Allocation`, a `Scalar` can either represent the raw bytes\n /// of a simple value or a pointer into another `Allocation`\n ///"}, {"sha": "457e80c1663ac413660e65d5db0ed0b7a720dd48", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -509,7 +509,7 @@ pub enum ImplSource<'tcx, N> {\n     TraitUpcasting(ImplSourceTraitUpcastingData<'tcx, N>),\n \n     /// ImplSource automatically generated for a closure. The `DefId` is the ID\n-    /// of the closure expression. This is a `ImplSource::UserDefined` in spirit, but the\n+    /// of the closure expression. This is an `ImplSource::UserDefined` in spirit, but the\n     /// impl is generated by the compiler and does not appear in the source.\n     Closure(ImplSourceClosureData<'tcx, N>),\n "}, {"sha": "62996bf4cbef20cbabd6ac505afbde0533ad811b", "filename": "compiler/rustc_middle/src/traits/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -111,7 +111,7 @@ pub enum SelectionCandidate<'tcx> {\n     ProjectionCandidate(usize),\n \n     /// Implementation of a `Fn`-family trait by one of the anonymous types\n-    /// generated for a `||` expression.\n+    /// generated for an `||` expression.\n     ClosureCandidate,\n \n     /// Implementation of a `Generator` trait by one of the anonymous types"}, {"sha": "27927bcca72b7a6accc5a017c64f2ee5c68d0417", "filename": "compiler/rustc_middle/src/ty/adt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -209,7 +209,7 @@ impl<'tcx> AdtDef {\n         self.flags.contains(AdtFlags::IS_UNION)\n     }\n \n-    /// Returns `true` if this is a enum.\n+    /// Returns `true` if this is an enum.\n     #[inline]\n     pub fn is_enum(&self) -> bool {\n         self.flags.contains(AdtFlags::IS_ENUM)"}, {"sha": "28e894c5cae2d7d85c06fd8c4635f08037669958", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -1792,7 +1792,7 @@ pub mod tls {\n         if context == 0 {\n             f(None)\n         } else {\n-            // We could get a `ImplicitCtxt` pointer from another thread.\n+            // We could get an `ImplicitCtxt` pointer from another thread.\n             // Ensure that `ImplicitCtxt` is `Sync`.\n             sync::assert_sync::<ImplicitCtxt<'_, '_>>();\n "}, {"sha": "77d82ee6eae6ffab0c06633f0d3cfc36f7f5fb68", "filename": "compiler/rustc_middle/src/ty/inhabitedness/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -9,7 +9,7 @@ use crate::ty::{DefId, SubstsRef};\n \n mod def_id_forest;\n \n-// The methods in this module calculate `DefIdForest`s of modules in which a\n+// The methods in this module calculate `DefIdForest`s of modules in which an\n // `AdtDef`/`VariantDef`/`FieldDef` is visibly uninhabited.\n //\n // # Example"}, {"sha": "80c99872dd7663e0fd405e581654ea5208e89bb2", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -2571,14 +2571,14 @@ where\n     /// Compute a `FnAbi` suitable for indirect calls, i.e. to `fn` pointers.\n     ///\n     /// NB: this doesn't handle virtual calls - those should use `FnAbi::of_instance`\n-    /// instead, where the instance is a `InstanceDef::Virtual`.\n+    /// instead, where the instance is an `InstanceDef::Virtual`.\n     fn of_fn_ptr(cx: &C, sig: ty::PolyFnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> Self;\n \n     /// Compute a `FnAbi` suitable for declaring/defining an `fn` instance, and for\n     /// direct calls to an `fn`.\n     ///\n     /// NB: that includes virtual calls, which are represented by \"direct calls\"\n-    /// to a `InstanceDef::Virtual` instance (of `<dyn Trait as Trait>::fn`).\n+    /// to an `InstanceDef::Virtual` instance (of `<dyn Trait as Trait>::fn`).\n     fn of_instance(cx: &C, instance: ty::Instance<'tcx>, extra_args: &[Ty<'tcx>]) -> Self;\n \n     fn new_internal("}, {"sha": "62e093581b8622322b0604546e028ead7251e4f9", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -865,7 +865,7 @@ impl<'tcx> Predicate<'tcx> {\n \n /// Represents the bounds declared on a particular set of type\n /// parameters. Should eventually be generalized into a flag list of\n-/// where-clauses. You can obtain a `InstantiatedPredicates` list from a\n+/// where-clauses. You can obtain an `InstantiatedPredicates` list from a\n /// `GenericPredicates` by using the `instantiate` method. Note that this method\n /// reflects an important semantic invariant of `InstantiatedPredicates`: while\n /// the `GenericPredicates` are expressed in terms of the bound type\n@@ -1371,7 +1371,7 @@ bitflags! {\n     }\n }\n \n-/// Definition of a variant -- a struct's fields or a enum variant.\n+/// Definition of a variant -- a struct's fields or an enum variant.\n #[derive(Debug, HashStable)]\n pub struct VariantDef {\n     /// `DefId` that identifies the variant itself."}, {"sha": "b8dae502d7a9f90f076f8f76ef9b71fd1772df54", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -1323,7 +1323,7 @@ pub type Region<'tcx> = &'tcx RegionKind;\n /// These are regions that are stored behind a binder and must be substituted\n /// with some concrete region before being used. There are two kind of\n /// bound regions: early-bound, which are bound in an item's `Generics`,\n-/// and are substituted by a `InternalSubsts`, and late-bound, which are part of\n+/// and are substituted by an `InternalSubsts`, and late-bound, which are part of\n /// higher-ranked types (e.g., `for<'a> fn(&'a ())`), and are substituted by\n /// the likes of `liberate_late_bound_regions`. The distinction exists\n /// because higher-ranked lifetimes aren't supported in all places. See [1][2].\n@@ -1471,7 +1471,7 @@ pub type PolyExistentialProjection<'tcx> = Binder<'tcx, ExistentialProjection<'t\n impl<'tcx> ExistentialProjection<'tcx> {\n     /// Extracts the underlying existential trait reference from this projection.\n     /// For example, if this is a projection of `exists T. <T as Iterator>::Item == X`,\n-    /// then this function would return a `exists T. T: Iterator` existential trait\n+    /// then this function would return an `exists T. T: Iterator` existential trait\n     /// reference.\n     pub fn trait_ref(&self, tcx: TyCtxt<'tcx>) -> ty::ExistentialTraitRef<'tcx> {\n         let def_id = tcx.associated_item(self.item_def_id).container.id();"}, {"sha": "4fbb4d1806f83fb774c2cac1d62789bc4a8ba633", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -22,7 +22,7 @@ use std::ops::ControlFlow;\n \n /// An entity in the Rust type system, which can be one of\n /// several kinds (types, lifetimes, and consts).\n-/// To reduce memory usage, a `GenericArg` is a interned pointer,\n+/// To reduce memory usage, a `GenericArg` is an interned pointer,\n /// with the lowest 2 bits being reserved for a tag to\n /// indicate the type (`Ty`, `Region`, or `Const`) it points to.\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n@@ -204,12 +204,12 @@ impl<'a, 'tcx> InternalSubsts<'tcx> {\n         GeneratorSubsts { substs: self }\n     }\n \n-    /// Creates a `InternalSubsts` that maps each generic parameter to itself.\n+    /// Creates an `InternalSubsts` that maps each generic parameter to itself.\n     pub fn identity_for_item(tcx: TyCtxt<'tcx>, def_id: DefId) -> SubstsRef<'tcx> {\n         Self::for_item(tcx, def_id, |param, _| tcx.mk_param_from_def(param))\n     }\n \n-    /// Creates a `InternalSubsts` for generic parameter definitions,\n+    /// Creates an `InternalSubsts` for generic parameter definitions,\n     /// by calling closures to obtain each kind.\n     /// The closures get to observe the `InternalSubsts` as they're\n     /// being built, which can be used to correctly"}, {"sha": "6561fe37c1c475b00f7520417c9199fedacd221a", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -825,7 +825,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 // We're going to want to traverse the first borrowed place to see if we can find\n                 // field access to a union. If we find that, then we will keep the place of the\n                 // union being accessed and the field that was being accessed so we can check the\n-                // second borrowed place for the same union and a access to a different field.\n+                // second borrowed place for the same union and an access to a different field.\n                 for (place_base, elem) in first_borrowed_place.iter_projections().rev() {\n                     match elem {\n                         ProjectionElem::Field(field, _) if union_ty(place_base).is_some() => {\n@@ -838,7 +838,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             })\n             .and_then(|(target_base, target_field)| {\n                 // With the place of a union and a field access into it, we traverse the second\n-                // borrowed place and look for a access to a different field of the same union.\n+                // borrowed place and look for an access to a different field of the same union.\n                 for (place_base, elem) in second_borrowed_place.iter_projections().rev() {\n                     if let ProjectionElem::Field(field, _) = elem {\n                         if let Some(union_ty) = union_ty(place_base) {"}, {"sha": "7be3f5414879e742495797e33d0b3f8e70f239e4", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/mutability_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -72,7 +72,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n                 // If the place is immutable then:\n                 //\n-                // - Either we deref a immutable ref to get to our final place.\n+                // - Either we deref an immutable ref to get to our final place.\n                 //    - We don't capture derefs of raw ptrs\n                 // - Or the final place is immut because the root variable of the capture\n                 //   isn't marked mut and we should suggest that to the user.\n@@ -601,7 +601,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             let reason = if let PlaceBase::Upvar(upvar_id) = closure_kind_origin.base {\n                 let upvar = ty::place_to_string_for_capture(tcx, closure_kind_origin);\n                 let root_hir_id = upvar_id.var_path.hir_id;\n-                // we have a origin for this closure kind starting at this root variable so it's safe to unwrap here\n+                // we have an origin for this closure kind starting at this root variable so it's safe to unwrap here\n                 let captured_places = tables.closure_min_captures[id].get(&root_hir_id).unwrap();\n \n                 let origin_projection = closure_kind_origin"}, {"sha": "cbb8f064bb81ae6132770ca6ce15e2225f2d8215", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/region_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -423,7 +423,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         diag\n     }\n \n-    /// Reports a error specifically for when data is escaping a closure.\n+    /// Reports an error specifically for when data is escaping a closure.\n     ///\n     /// ```text\n     /// error: borrowed data escapes outside of function\n@@ -566,7 +566,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         diag\n     }\n \n-    /// Adds a suggestion to errors where a `impl Trait` is returned.\n+    /// Adds a suggestion to errors where an `impl Trait` is returned.\n     ///\n     /// ```text\n     /// help: to allow this `impl Trait` to capture borrowed data with lifetime `'1`, add `'_` as"}, {"sha": "8e6ebd124ee182ec04c6da7249882aeaeb2c5967", "filename": "compiler/rustc_mir/src/borrow_check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -1241,7 +1241,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             }\n         }\n \n-        // Special case: you can assign a immutable local variable\n+        // Special case: you can assign an immutable local variable\n         // (e.g., `x = ...`) so long as it has never been initialized\n         // before (at this point in the flow).\n         if let Some(local) = place_span.0.as_local() {\n@@ -1702,7 +1702,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // initialization state of `a.b` is all we need to inspect to\n         // know if `a.b.c` is valid (and from that we infer that the\n         // dereference and `.d` access is also valid, since we assume\n-        // `a.b.c` is assigned a reference to a initialized and\n+        // `a.b.c` is assigned a reference to an initialized and\n         // well-formed record structure.)\n \n         // Therefore, if we seek out the *closest* prefix for which we\n@@ -2004,7 +2004,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n             if let Some((prefix, mpi)) = shortest_uninit_seen {\n                 // Check for a reassignment into a uninitialized field of a union (for example,\n-                // after a move out). In this case, do not report a error here. There is an\n+                // after a move out). In this case, do not report an error here. There is an\n                 // exception, if this is the first assignment into the union (that is, there is\n                 // no move out from an earlier location) then this is an attempt at initialization\n                 // of the union - we should error in that case."}, {"sha": "3c9b4272b36497dc3fe826d9986e2c182ba2c5b1", "filename": "compiler/rustc_mir/src/borrow_check/universal_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Funiversal_regions.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -169,7 +169,7 @@ struct UniversalRegionIndices<'tcx> {\n     /// used because trait matching and type-checking will feed us\n     /// region constraints that reference those regions and we need to\n     /// be able to map them our internal `RegionVid`. This is\n-    /// basically equivalent to a `InternalSubsts`, except that it also\n+    /// basically equivalent to an `InternalSubsts`, except that it also\n     /// contains an entry for `ReStatic` -- it might be nice to just\n     /// use a substs, and then handle `ReStatic` another way.\n     indices: FxHashMap<ty::Region<'tcx>, RegionVid>,"}, {"sha": "81f78621d1458520d90aa98b906da2125f77776d", "filename": "compiler/rustc_mir/src/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -295,7 +295,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// we can find the data.\n     /// Note that for a given layout, this operation will either always fail or always\n     /// succeed!  Whether it succeeds depends on whether the layout can be represented\n-    /// in a `Immediate`, not on which data is stored there currently.\n+    /// in an `Immediate`, not on which data is stored there currently.\n     pub(crate) fn try_read_immediate(\n         &self,\n         src: &OpTy<'tcx, M::PointerTag>,"}, {"sha": "6726b669ff2aae96ac90176a2593239ac6bcf430", "filename": "compiler/rustc_mir/src/transform/coverage/counters.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fcounters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fcounters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fcounters.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -100,7 +100,7 @@ impl CoverageCounters {\n         CounterValueReference::from(next)\n     }\n \n-    /// Expression IDs start from u32::MAX and go down because a Expression can reference\n+    /// Expression IDs start from u32::MAX and go down because an Expression can reference\n     /// (add or subtract counts) of both Counter regions and Expression regions. The counter\n     /// expression operand IDs must be unique across both types.\n     fn next_expression(&mut self) -> InjectedExpressionId {"}, {"sha": "f7fbea6ad53711a5c82b3937a8e57221634ee553", "filename": "compiler/rustc_mir/src/transform/coverage/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fmod.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -334,7 +334,7 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n     /// process (via `take_counter()`).\n     ///\n     /// Any other counter associated with a `BasicCoverageBlock`, or its incoming edge, but not\n-    /// associated with a `CoverageSpan`, should only exist if the counter is a `Expression`\n+    /// associated with a `CoverageSpan`, should only exist if the counter is an `Expression`\n     /// dependency (one of the expression operands). Collect them, and inject the additional\n     /// counters into the MIR, without a reportable coverage span.\n     fn inject_indirect_counters("}, {"sha": "e7157855cb4567f8e5f0e4e7157b219a977ecc37", "filename": "compiler/rustc_mir/src/transform/rustc_peek.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Frustc_peek.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -88,7 +88,7 @@ impl<'tcx> MirPass<'tcx> for SanityCheck {\n /// For each such call, determines what the dataflow bit-state is for\n /// the L-value corresponding to `expr`; if the bit-state is a 1, then\n /// that call to `rustc_peek` is ignored by the sanity check. If the\n-/// bit-state is a 0, then this pass emits a error message saying\n+/// bit-state is a 0, then this pass emits an error message saying\n /// \"rustc_peek: bit not set\".\n ///\n /// The intention is that one can write unit tests for dataflow by"}, {"sha": "aa2963c53f43b4f39d56465cfa5dc82b765476a4", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -61,7 +61,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     unpack!(this.expr_into_dest(destination, else_blk, &this.thir[else_opt]))\n                 } else {\n                     // Body of the `if` expression without an `else` clause must return `()`, thus\n-                    // we implicitly generate a `else {}` if it is not specified.\n+                    // we implicitly generate an `else {}` if it is not specified.\n                     let correct_si = this.source_info(expr_span.shrink_to_hi());\n                     this.cfg.push_assign_unit(else_blk, correct_si, destination, this.tcx);\n                     else_blk"}, {"sha": "a36af024ad8d0e92f52c84f8234ee3ebe09f6b51", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -1936,7 +1936,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // }\n             // ```\n             //\n-            // would yield a `arm_block` something like:\n+            // would yield an `arm_block` something like:\n             //\n             // ```\n             // StorageLive(_4);        // _4 is `x`"}, {"sha": "bfebe860971e9f8e28e6973c503e8a3d83357140", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -700,7 +700,7 @@ fn construct_const<'a, 'tcx>(\n     builder.finish()\n }\n \n-/// Construct MIR for a item that has had errors in type checking.\n+/// Construct MIR for an item that has had errors in type checking.\n ///\n /// This is required because we may still want to run MIR passes on an item\n /// with type errors, but normal MIR construction can't handle that in general.\n@@ -885,7 +885,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let tcx_hir = tcx.hir();\n         let hir_typeck_results = self.typeck_results;\n \n-        // In analyze_closure() in upvar.rs we gathered a list of upvars used by a\n+        // In analyze_closure() in upvar.rs we gathered a list of upvars used by an\n         // indexed closure and we stored in a map called closure_min_captures in TypeckResults\n         // with the closure's DefId. Here, we run through that vec of UpvarIds for\n         // the given closure and use the necessary information to create upvar"}, {"sha": "909e1fa4ffa04575ebc589829677f3c260c6f952", "filename": "compiler/rustc_parse/src/parser/attr_wrapper.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -301,7 +301,7 @@ impl<'a> Parser<'a> {\n         // If we 'broke' the last token (e.g. breaking a '>>' token to two '>' tokens),\n         // then extend the range of captured tokens to include it, since the parser\n         // was not actually bumped past it. When the `LazyTokenStream` gets converted\n-        // into a `AttrAnnotatedTokenStream`, we will create the proper token.\n+        // into an `AttrAnnotatedTokenStream`, we will create the proper token.\n         if self.token_cursor.break_last_token {\n             assert_eq!(\n                 trailing,\n@@ -320,7 +320,7 @@ impl<'a> Parser<'a> {\n         } else {\n             // Grab any replace ranges that occur *inside* the current AST node.\n             // We will perform the actual replacement when we convert the `LazyTokenStream`\n-            // to a `AttrAnnotatedTokenStream`\n+            // to an `AttrAnnotatedTokenStream`\n             let start_calls: u32 = cursor_snapshot_next_calls.try_into().unwrap();\n             self.capture_state.replace_ranges[replace_ranges_start..replace_ranges_end]\n                 .iter()"}, {"sha": "326c8f81ffbf9f64973bfbddaa7c3efadcbc17a0", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -1092,7 +1092,7 @@ impl<'a> Parser<'a> {\n         // added to the return value after the fact.\n         //\n         // Therefore, prevent sub-parser from parsing\n-        // attributes by giving them a empty \"already-parsed\" list.\n+        // attributes by giving them an empty \"already-parsed\" list.\n         let attrs = AttrVec::new();\n \n         // Note: when adding new syntax here, don't forget to adjust `TokenKind::can_begin_expr()`."}, {"sha": "4c3c140d17100a8fd00d6107d296ea7b5feb1571", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -152,7 +152,7 @@ pub struct Parser<'a> {\n /// attribute, we parse a nested AST node that has `#[cfg]` or `#[cfg_attr]`\n /// In this case, we use a `ReplaceRange` to replace the entire inner AST node\n /// with `FlatToken::AttrTarget`, allowing us to perform eager cfg-expansion\n-/// on a `AttrAnnotatedTokenStream`\n+/// on an `AttrAnnotatedTokenStream`\n ///\n /// 2. When we parse an inner attribute while collecting tokens. We\n /// remove inner attributes from the token stream entirely, and\n@@ -165,7 +165,7 @@ pub type ReplaceRange = (Range<u32>, Vec<(FlatToken, Spacing)>);\n \n /// Controls how we capture tokens. Capturing can be expensive,\n /// so we try to avoid performing capturing in cases where\n-/// we will never need a `AttrAnnotatedTokenStream`\n+/// we will never need an `AttrAnnotatedTokenStream`\n #[derive(Copy, Clone)]\n pub enum Capturing {\n     /// We aren't performing any capturing - this is the default mode.\n@@ -1362,10 +1362,10 @@ pub fn emit_unclosed_delims(unclosed_delims: &mut Vec<UnmatchedBrace>, sess: &Pa\n     }\n }\n \n-/// A helper struct used when building a `AttrAnnotatedTokenStream` from\n+/// A helper struct used when building an `AttrAnnotatedTokenStream` from\n /// a `LazyTokenStream`. Both delimiter and non-delimited tokens\n /// are stored as `FlatToken::Token`. A vector of `FlatToken`s\n-/// is then 'parsed' to build up a `AttrAnnotatedTokenStream` with nested\n+/// is then 'parsed' to build up an `AttrAnnotatedTokenStream` with nested\n /// `AttrAnnotatedTokenTree::Delimited` tokens\n #[derive(Debug, Clone)]\n pub enum FlatToken {\n@@ -1375,10 +1375,10 @@ pub enum FlatToken {\n     /// Holds the `AttributesData` for an AST node. The\n     /// `AttributesData` is inserted directly into the\n     /// constructed `AttrAnnotatedTokenStream` as\n-    /// a `AttrAnnotatedTokenTree::Attributes`\n+    /// an `AttrAnnotatedTokenTree::Attributes`\n     AttrTarget(AttributesData),\n     /// A special 'empty' token that is ignored during the conversion\n-    /// to a `AttrAnnotatedTokenStream`. This is used to simplify the\n+    /// to an `AttrAnnotatedTokenStream`. This is used to simplify the\n     /// handling of replace ranges.\n     Empty,\n }"}, {"sha": "281995c3755491844e64c695f7d864ba7e254450", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -575,7 +575,7 @@ impl EmbargoVisitor<'tcx> {\n         }\n     }\n \n-    /// Given the path segments of a `ItemKind::Use`, then we need\n+    /// Given the path segments of an `ItemKind::Use`, then we need\n     /// to update the visibility of the intermediate use so that it isn't linted\n     /// by `unreachable_pub`.\n     ///"}, {"sha": "5df2f22b7898d52bdc0c7eaf69c491f2b1ec9ddc", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -668,7 +668,7 @@ enum NameBindingKind<'a> {\n }\n \n impl<'a> NameBindingKind<'a> {\n-    /// Is this a name binding of a import?\n+    /// Is this a name binding of an import?\n     fn is_import(&self) -> bool {\n         matches!(*self, NameBindingKind::Import { .. })\n     }\n@@ -3066,7 +3066,7 @@ impl<'a> Resolver<'a> {\n             self.extern_prelude.get(&ident).map_or(true, |entry| entry.introduced_by_item);\n         // Only suggest removing an import if both bindings are to the same def, if both spans\n         // aren't dummy spans. Further, if both bindings are imports, then the ident must have\n-        // been introduced by a item.\n+        // been introduced by an item.\n         let should_remove_import = duplicate\n             && !has_dummy_span\n             && ((new_binding.is_extern_crate() || old_binding.is_extern_crate()) || from_item);\n@@ -3213,7 +3213,7 @@ impl<'a> Resolver<'a> {\n                     Applicability::MaybeIncorrect,\n                 );\n             } else {\n-                // Remove the entire line if we cannot extend the span back, this indicates a\n+                // Remove the entire line if we cannot extend the span back, this indicates an\n                 // `issue_52891::{self}` case.\n                 err.span_suggestion(\n                     import.use_span_with_attributes,"}, {"sha": "ecc8dae04800a3a44dd7c031e8804e238d0ca61f", "filename": "compiler/rustc_serialize/src/serialize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -644,7 +644,7 @@ impl<D: Decoder, T: Decodable<D> + Copy> Decodable<D> for Cell<T> {\n }\n \n // FIXME: #15036\n-// Should use `try_borrow`, returning a\n+// Should use `try_borrow`, returning an\n // `encoder.error(\"attempting to Encode borrowed RefCell\")`\n // from `encode` when `try_borrow` returns `None`.\n "}, {"sha": "bb24f7bb135ef0b22e9cac3eb2353fbdd42a8c65", "filename": "compiler/rustc_target/src/asm/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -469,7 +469,7 @@ impl InlineAsmRegClass {\n         }\n     }\n \n-    /// Returns a list of supported types for this register class, each with a\n+    /// Returns a list of supported types for this register class, each with an\n     /// options target feature required to use this type.\n     pub fn supported_types(\n         self,"}, {"sha": "c5a6e301deba96c1d835da9e9d63d54116097411", "filename": "compiler/rustc_trait_selection/src/opaque_types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -77,7 +77,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     ///     ?0: Iterator<Item = ?1>\n     ///     ?1: Debug\n     ///\n-    /// Moreover, it returns a `OpaqueTypeMap` that would map `?0` to\n+    /// Moreover, it returns an `OpaqueTypeMap` that would map `?0` to\n     /// info about the `impl Iterator<..>` type and `?1` to info about\n     /// the `impl Debug` type.\n     ///\n@@ -886,7 +886,7 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n                     // }\n                     // ```\n                     //\n-                    // Here, the return type of `foo` references a\n+                    // Here, the return type of `foo` references an\n                     // `Opaque` indeed, but not one whose value is\n                     // presently being inferred. You can get into a\n                     // similar situation with closure return types"}, {"sha": "f06f0e32f414b73f90e35192996ba41ba780fcb3", "filename": "compiler/rustc_trait_selection/src/traits/codegen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -12,7 +12,7 @@ use rustc_errors::ErrorReported;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::{self, TyCtxt};\n \n-/// Attempts to resolve an obligation to a `ImplSource`. The result is\n+/// Attempts to resolve an obligation to an `ImplSource`. The result is\n /// a shallow `ImplSource` resolution, meaning that we do not\n /// (necessarily) resolve all nested obligations on the impl. Note\n /// that type check should guarantee to us that all nested"}, {"sha": "90b6ee5f5a6a670b39e27a4251343e578cdff971", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -2009,7 +2009,7 @@ pub enum ArgKind {\n     Arg(String, String),\n \n     /// An argument of tuple type. For a \"found\" argument, the span is\n-    /// the location in the source of the pattern. For a \"expected\"\n+    /// the location in the source of the pattern. For an \"expected\"\n     /// argument, it will be None. The vector is a list of (name, ty)\n     /// strings for the components of the tuple.\n     Tuple(Option<Span>, Vec<(String, String)>),"}, {"sha": "40841a6e32d00e2cc97db003a445b919873e426c", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -1365,7 +1365,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         // When a future does not implement a trait because of a captured type in one of the\n         // generators somewhere in the call stack, then the result is a chain of obligations.\n         //\n-        // Given a `async fn` A that calls a `async fn` B which captures a non-send type and that\n+        // Given an `async fn` A that calls an `async fn` B which captures a non-send type and that\n         // future is passed as an argument to a function C which requires a `Send` type, then the\n         // chain looks something like this:\n         //"}, {"sha": "19e3c1afb9fb6691ed50ff634692b8cf4ff6261c", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -62,7 +62,7 @@ enum ProjectionTyCandidate<'tcx> {\n     /// Bounds specified on an object type\n     Object(ty::PolyProjectionPredicate<'tcx>),\n \n-    /// From a \"impl\" (or a \"pseudo-impl\" returned by select)\n+    /// From an \"impl\" (or a \"pseudo-impl\" returned by select)\n     Select(Selection<'tcx>),\n }\n \n@@ -1011,7 +1011,7 @@ fn prune_cache_value_obligations<'a, 'tcx>(\n /// Note that we used to return `Error` here, but that was quite\n /// dubious -- the premise was that an error would *eventually* be\n /// reported, when the obligation was processed. But in general once\n-/// you see a `Error` you are supposed to be able to assume that an\n+/// you see an `Error` you are supposed to be able to assume that an\n /// error *has been* reported, so that you can take whatever heuristic\n /// paths you want to take. To make things worse, it was possible for\n /// cycles to arise, where you basically had a setup like `<MyType<$0>"}, {"sha": "03087e3353a6e918261ad1a73d6c5eb25b27ee27", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/implied_outlives_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -24,7 +24,7 @@ impl<'tcx> super::QueryTypeOp<'tcx> for ImpliedOutlivesBounds<'tcx> {\n     ) -> Fallible<CanonicalizedQueryResponse<'tcx, Self::QueryResponse>> {\n         // FIXME this `unchecked_map` is only necessary because the\n         // query is defined as taking a `ParamEnvAnd<Ty>`; it should\n-        // take a `ImpliedOutlivesBounds` instead\n+        // take an `ImpliedOutlivesBounds` instead\n         let canonicalized = canonicalized.unchecked_map(|ParamEnvAnd { param_env, value }| {\n             let ImpliedOutlivesBounds { ty } = value;\n             param_env.and(ty)"}, {"sha": "ba62ce1d5312ebfa5d61b75cb1000b741069d049", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -257,7 +257,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         ImplSourceBuiltinData { nested: obligations }\n     }\n \n-    /// This handles the case where a `auto trait Foo` impl is being used.\n+    /// This handles the case where an `auto trait Foo` impl is being used.\n     /// The idea is that the impl applies to `X : Foo` if the following conditions are met:\n     ///\n     /// 1. For each constituent type `Y` in `X`, `Y : Foo` holds"}, {"sha": "88aca794a6be6971ea4d7bfcb2b1bfb431fe5393", "filename": "compiler/rustc_trait_selection/src/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -149,7 +149,7 @@ pub(super) fn specializes(tcx: TyCtxt<'_>, (impl1_def_id, impl2_def_id): (DefId,\n     let penv = tcx.param_env(impl1_def_id);\n     let impl1_trait_ref = tcx.impl_trait_ref(impl1_def_id).unwrap();\n \n-    // Create a infcx, taking the predicates of impl1 as assumptions:\n+    // Create an infcx, taking the predicates of impl1 as assumptions:\n     tcx.infer_ctxt().enter(|infcx| {\n         // Normalize the trait reference. The WF rules ought to ensure\n         // that this always succeeds."}, {"sha": "1d457d6761fd084c1e0c7bab1c98ba5f0746921b", "filename": "compiler/rustc_traits/src/chalk/db.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -718,7 +718,7 @@ impl<'tcx> chalk_ir::UnificationDatabase<RustInterner<'tcx>> for RustIrDatabase<\n     }\n }\n \n-/// Creates a `InternalSubsts` that maps each generic parameter to a higher-ranked\n+/// Creates an `InternalSubsts` that maps each generic parameter to a higher-ranked\n /// var bound at index `0`. For types, we use a `BoundVar` index equal to\n /// the type parameter index. For regions, we use the `BoundRegionKind::BrNamed`\n /// variant (which has a `DefId`)."}, {"sha": "8332e7384110e032635faf27466a439ad986f972", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -185,7 +185,7 @@ fn impl_constness(tcx: TyCtxt<'_>, def_id: DefId) -> hir::Constness {\n ///     - a type parameter or projection whose Sizedness can't be known\n ///     - a tuple of type parameters or projections, if there are multiple\n ///       such.\n-///     - a Error, if a type contained itself. The representability\n+///     - an Error, if a type contained itself. The representability\n ///       check should catch this case.\n fn adt_sized_constraint(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AdtSizedConstraint<'_> {\n     let def = tcx.adt_def(def_id);\n@@ -253,7 +253,7 @@ fn param_env(tcx: TyCtxt<'_>, def_id: DefId) -> ty::ParamEnv<'_> {\n     // `<i32 as Foo>::Bar` where `i32` does not implement `Foo`. We\n     // report these errors right here; this doesn't actually feel\n     // right to me, because constructing the environment feels like a\n-    // kind of a \"idempotent\" action, but I'm not sure where would be\n+    // kind of an \"idempotent\" action, but I'm not sure where would be\n     // a better place. In practice, we construct environments for\n     // every fn once during type checking, and we'll abort if there\n     // are any errors at that point, so after type checking you can be"}, {"sha": "7d7d69b40798f8424866f1747da5db9bb3804316", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -2350,7 +2350,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             }\n             hir::TyKind::Infer => {\n                 // Infer also appears as the type of arguments or return\n-                // values in a ExprKind::Closure, or as\n+                // values in an ExprKind::Closure, or as\n                 // the type of local variables. Both of these cases are\n                 // handled specially and will not descend into this routine.\n                 self.ty_infer(None, ast_ty.span)"}, {"sha": "43b82e41376ce344bd5d245cabb00387180e9e08", "filename": "compiler/rustc_typeck/src/check/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -606,7 +606,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Invoked when we are translating the generator that results\n     /// from desugaring an `async fn`. Returns the \"sugared\" return\n     /// type of the `async fn` -- that is, the return type that the\n-    /// user specified. The \"desugared\" return type is a `impl\n+    /// user specified. The \"desugared\" return type is an `impl\n     /// Future<Output = T>`, so we do this by searching through the\n     /// obligations to extract the `T`.\n     fn deduce_future_output_from_obligations(&self, expr_def_id: DefId) -> Option<Ty<'tcx>> {"}, {"sha": "9838fd9058f25b50a79fa98c3847eec2d4974615", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -96,7 +96,7 @@ pub struct FnCtxt<'a, 'tcx> {\n     ///   `foo(return)`; we warn on the `foo()` expression. (We then\n     ///   update the flag to `WarnedAlways` to suppress duplicate\n     ///   reports.) Similarly, if we traverse to a fresh statement (or\n-    ///   tail expression) from a `Always` setting, we will issue a\n+    ///   tail expression) from an `Always` setting, we will issue a\n     ///   warning. This corresponds to something like `{return;\n     ///   foo();}` or `{return; 22}`, where we would warn on the\n     ///   `foo()` or `22`."}, {"sha": "c0b28a885dbafd6787b09d5d730cbbe6ea7995db", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -1427,7 +1427,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // an immut-ref after on top of this.\n                 ty::Ref(.., hir::Mutability::Mut) => is_mutbl = hir::Mutability::Mut,\n \n-                // The place isn't mutable once we dereference a immutable reference.\n+                // The place isn't mutable once we dereference an immutable reference.\n                 ty::Ref(.., hir::Mutability::Not) => return hir::Mutability::Not,\n \n                 // Dereferencing a box doesn't change mutability"}, {"sha": "77834feb9ad55eef02afaf16747839f6a1114c2e", "filename": "compiler/rustc_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -819,7 +819,7 @@ fn copy_or_move<'a, 'tcx>(\n }\n \n // - If a place is used in a `ByValue` context then move it if it's not a `Copy` type.\n-// - If the place that is a `Copy` type consider it a `ImmBorrow`.\n+// - If the place that is a `Copy` type consider it an `ImmBorrow`.\n fn delegate_consume<'a, 'tcx>(\n     mc: &mc::MemCategorizationContext<'a, 'tcx>,\n     delegate: &mut (dyn Delegate<'tcx> + 'a),"}, {"sha": "ccf0fb7273837b57577ee97fe91f677e4557aab2", "filename": "compiler/rustc_typeck/src/outlives/implicit_infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fimplicit_infer.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -297,7 +297,7 @@ pub fn check_explicit_predicates<'tcx>(\n         // to apply the substs, and not filter this predicate, we might then falsely\n         // conclude that e.g., `X: 'x` was a reasonable inferred requirement.\n         //\n-        // Another similar case is where we have a inferred\n+        // Another similar case is where we have an inferred\n         // requirement like `<Self as Trait>::Foo: 'b`. We presently\n         // ignore such requirements as well (cc #54467)-- though\n         // conceivably it might be better if we could extract the `Foo"}, {"sha": "3ed3c2382cac69193a07129fa91d9b6e2a9981f3", "filename": "library/alloc/src/alloc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/library%2Falloc%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/library%2Falloc%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Falloc.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -387,7 +387,7 @@ pub mod __alloc_error_handler {\n         panic!(\"memory allocation of {} bytes failed\", size)\n     }\n \n-    // if there is a `#[alloc_error_handler]`\n+    // if there is an `#[alloc_error_handler]`\n     #[rustc_std_internal_symbol]\n     pub unsafe extern \"C\" fn __rg_oom(size: usize, align: usize) -> ! {\n         let layout = unsafe { Layout::from_size_align_unchecked(size, align) };"}, {"sha": "17697fa0e045a28cc5256cab47d4bb4e4cebf616", "filename": "library/core/src/iter/adapters/zip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fzip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fzip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fzip.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -563,7 +563,7 @@ where\n }\n \n unsafe trait SpecTrustedRandomAccess: Iterator {\n-    /// If `Self: TrustedRandomAccess`, it must be safe to call a\n+    /// If `Self: TrustedRandomAccess`, it must be safe to call\n     /// `Iterator::__iterator_get_unchecked(self, index)`.\n     unsafe fn try_get_unchecked(&mut self, index: usize) -> Self::Item;\n }"}, {"sha": "844459d77cd9661691bfc19ad944131b39f6ac3a", "filename": "library/core/src/iter/traits/marker.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fmarker.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -25,7 +25,7 @@ impl<I: FusedIterator + ?Sized> FusedIterator for &mut I {}\n /// (lower bound is equal to upper bound), or the upper bound is [`None`].\n /// The upper bound must only be [`None`] if the actual iterator length is\n /// larger than [`usize::MAX`]. In that case, the lower bound must be\n-/// [`usize::MAX`], resulting in a [`Iterator::size_hint()`] of\n+/// [`usize::MAX`], resulting in an [`Iterator::size_hint()`] of\n /// `(usize::MAX, None)`.\n ///\n /// The iterator must produce exactly the number of elements it reported"}, {"sha": "75405f471541825b9e4b5f976e3a120d10866d79", "filename": "library/core/src/num/dec2flt/lemire.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Flemire.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Flemire.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Flemire.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -9,7 +9,7 @@ use crate::num::dec2flt::table::{\n /// Compute a float using an extended-precision representation.\n ///\n /// Fast conversion of a the significant digits and decimal exponent\n-/// a float to a extended representation with a binary float. This\n+/// a float to an extended representation with a binary float. This\n /// algorithm will accurately parse the vast majority of cases,\n /// and uses a 128-bit representation (with a fallback 192-bit\n /// representation)."}, {"sha": "243922b18b565dfd0a5b55fdf944f04d9f7aa555", "filename": "library/proc_macro/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/library%2Fproc_macro%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/library%2Fproc_macro%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Flib.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -262,7 +262,7 @@ pub mod token_stream {\n }\n \n /// `quote!(..)` accepts arbitrary tokens and expands into a `TokenStream` describing the input.\n-/// For example, `quote!(a + b)` will produce a expression, that, when evaluated, constructs\n+/// For example, `quote!(a + b)` will produce an expression, that, when evaluated, constructs\n /// the `TokenStream` `[Ident(\"a\"), Punct('+', Alone), Ident(\"b\")]`.\n ///\n /// Unquoting is done with `$`, and works by taking the single next ident as the unquoted term."}, {"sha": "c999474a96f9c5e4b74c3a3b2a914c8105a4a7a7", "filename": "library/std/src/collections/hash/map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -1239,7 +1239,7 @@ pub struct IterMut<'a, K: 'a, V: 'a> {\n }\n \n impl<'a, K, V> IterMut<'a, K, V> {\n-    /// Returns a iterator of references over the remaining items.\n+    /// Returns an iterator of references over the remaining items.\n     #[inline]\n     pub(super) fn iter(&self) -> Iter<'_, K, V> {\n         Iter { base: self.base.rustc_iter() }\n@@ -1268,7 +1268,7 @@ pub struct IntoIter<K, V> {\n }\n \n impl<K, V> IntoIter<K, V> {\n-    /// Returns a iterator of references over the remaining items.\n+    /// Returns an iterator of references over the remaining items.\n     #[inline]\n     pub(super) fn iter(&self) -> Iter<'_, K, V> {\n         Iter { base: self.base.rustc_iter() }\n@@ -1371,7 +1371,7 @@ pub struct Drain<'a, K: 'a, V: 'a> {\n }\n \n impl<'a, K, V> Drain<'a, K, V> {\n-    /// Returns a iterator of references over the remaining items.\n+    /// Returns an iterator of references over the remaining items.\n     #[inline]\n     pub(super) fn iter(&self) -> Iter<'_, K, V> {\n         Iter { base: self.base.rustc_iter() }"}, {"sha": "b9e0f0e271ce76af637df34aeacfc8c3a2482054", "filename": "library/std/src/ffi/c_str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -46,7 +46,7 @@ use crate::sys_common::memchr;\n ///\n /// # Extracting a raw pointer to the whole C string\n ///\n-/// `CString` implements a [`as_ptr`][`CStr::as_ptr`] method through the [`Deref`]\n+/// `CString` implements an [`as_ptr`][`CStr::as_ptr`] method through the [`Deref`]\n /// trait. This method will give you a `*const c_char` which you can\n /// feed directly to extern functions that expect a nul-terminated\n /// string, like C's `strdup()`. Notice that [`as_ptr`][`CStr::as_ptr`] returns a\n@@ -730,7 +730,7 @@ impl CString {\n     /// );\n     /// ```\n     ///\n-    /// A incorrectly formatted [`Vec`] will produce an error.\n+    /// An incorrectly formatted [`Vec`] will produce an error.\n     ///\n     /// ```\n     /// #![feature(cstring_from_vec_with_nul)]"}, {"sha": "397b35a84cf5aa7d09ce7a9308942b1c79e6f62d", "filename": "library/std/src/ffi/os_str.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -359,7 +359,7 @@ impl OsString {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl From<String> for OsString {\n-    /// Converts a [`String`] into a [`OsString`].\n+    /// Converts a [`String`] into an [`OsString`].\n     ///\n     /// This conversion does not allocate or copy memory.\n     #[inline]\n@@ -880,7 +880,7 @@ impl From<Box<OsStr>> for OsString {\n \n #[stable(feature = \"box_from_os_string\", since = \"1.20.0\")]\n impl From<OsString> for Box<OsStr> {\n-    /// Converts a [`OsString`] into a [`Box`]`<OsStr>` without copying or allocating.\n+    /// Converts an [`OsString`] into a [`Box`]`<OsStr>` without copying or allocating.\n     #[inline]\n     fn from(s: OsString) -> Box<OsStr> {\n         s.into_boxed_os_str()\n@@ -897,7 +897,7 @@ impl Clone for Box<OsStr> {\n \n #[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\n impl From<OsString> for Arc<OsStr> {\n-    /// Converts a [`OsString`] into a [`Arc`]`<OsStr>` without copying or allocating.\n+    /// Converts an [`OsString`] into a [`Arc`]`<OsStr>` without copying or allocating.\n     #[inline]\n     fn from(s: OsString) -> Arc<OsStr> {\n         let arc = s.inner.into_arc();\n@@ -916,7 +916,7 @@ impl From<&OsStr> for Arc<OsStr> {\n \n #[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\n impl From<OsString> for Rc<OsStr> {\n-    /// Converts a [`OsString`] into a [`Rc`]`<OsStr>` without copying or allocating.\n+    /// Converts an [`OsString`] into a [`Rc`]`<OsStr>` without copying or allocating.\n     #[inline]\n     fn from(s: OsString) -> Rc<OsStr> {\n         let rc = s.inner.into_rc();"}, {"sha": "43d930677fad3d53e41712f6844bf9b19d54f49c", "filename": "library/std/src/net/addr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/library%2Fstd%2Fsrc%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/library%2Fstd%2Fsrc%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Faddr.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -561,8 +561,8 @@ impl From<SocketAddrV6> for SocketAddr {\n impl<I: Into<IpAddr>> From<(I, u16)> for SocketAddr {\n     /// Converts a tuple struct (Into<[`IpAddr`]>, `u16`) into a [`SocketAddr`].\n     ///\n-    /// This conversion creates a [`SocketAddr::V4`] for a [`IpAddr::V4`]\n-    /// and creates a [`SocketAddr::V6`] for a [`IpAddr::V6`].\n+    /// This conversion creates a [`SocketAddr::V4`] for an [`IpAddr::V4`]\n+    /// and creates a [`SocketAddr::V6`] for an [`IpAddr::V6`].\n     ///\n     /// `u16` is treated as port of the newly created [`SocketAddr`].\n     fn from(pieces: (I, u16)) -> SocketAddr {"}, {"sha": "4165a7beaa8f260bf56535284e24551021852953", "filename": "library/std/src/net/ip.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/library%2Fstd%2Fsrc%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/library%2Fstd%2Fsrc%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fip.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -380,7 +380,7 @@ impl IpAddr {\n         matches!(self, IpAddr::V6(_))\n     }\n \n-    /// Converts this address to an `IpAddr::V4` if it is a IPv4-mapped IPv6 addresses, otherwise it\n+    /// Converts this address to an `IpAddr::V4` if it is an IPv4-mapped IPv6 addresses, otherwise it\n     /// return `self` as-is.\n     ///\n     /// # Examples\n@@ -1621,8 +1621,8 @@ impl Ipv6Addr {\n         }\n     }\n \n-    /// Converts this address to an `IpAddr::V4` if it is a IPv4-mapped addresses, otherwise it\n-    /// returns self wrapped in a `IpAddr::V6`.\n+    /// Converts this address to an `IpAddr::V4` if it is an IPv4-mapped addresses, otherwise it\n+    /// returns self wrapped in an `IpAddr::V6`.\n     ///\n     /// # Examples\n     ///"}, {"sha": "1f9d42812ecc78177fe2c6da52cd998f9031cbc0", "filename": "library/std/src/os/unix/net/ancillary.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fancillary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fancillary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fancillary.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -279,7 +279,7 @@ pub enum AncillaryData<'a> {\n }\n \n impl<'a> AncillaryData<'a> {\n-    /// Create a `AncillaryData::ScmRights` variant.\n+    /// Create an `AncillaryData::ScmRights` variant.\n     ///\n     /// # Safety\n     ///\n@@ -291,7 +291,7 @@ impl<'a> AncillaryData<'a> {\n         AncillaryData::ScmRights(scm_rights)\n     }\n \n-    /// Create a `AncillaryData::ScmCredentials` variant.\n+    /// Create an `AncillaryData::ScmCredentials` variant.\n     ///\n     /// # Safety\n     ///"}, {"sha": "8d29fa7d66f995db0c4cdbd8142b0400516bb705", "filename": "library/std/src/os/windows/ffi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fffi.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -30,7 +30,7 @@\n //! [`OsString`] is the Rust wrapper for owned strings in the\n //! preferred representation of the operating system. On Windows,\n //! this struct gets augmented with an implementation of the\n-//! [`OsStringExt`] trait, which has a [`OsStringExt::from_wide`] method. This\n+//! [`OsStringExt`] trait, which has an [`OsStringExt::from_wide`] method. This\n //! lets you create an [`OsString`] from a `&[u16]` slice; presumably\n //! you get such a slice out of a `WCHAR` Windows API.\n //!"}, {"sha": "5eb545f758247788aac28d2977098492699d3571", "filename": "src/librustdoc/html/static/js/search.js", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -1331,7 +1331,7 @@ window.initSearch = function(rawSearchIndex) {\n             // an array of [(Number) item type,\n             //              (String) name]\n             var paths = rawSearchIndex[crate].p;\n-            // a array of [(String) alias name\n+            // an array of [(String) alias name\n             //             [Number] index to items]\n             var aliases = rawSearchIndex[crate].a;\n "}, {"sha": "fc53acf75cb8678a4c272ac7a2c40a58d7436832", "filename": "src/test/incremental/thinlto/cgu_invalidated_when_import_removed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/src%2Ftest%2Fincremental%2Fthinlto%2Fcgu_invalidated_when_import_removed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/src%2Ftest%2Fincremental%2Fthinlto%2Fcgu_invalidated_when_import_removed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fthinlto%2Fcgu_invalidated_when_import_removed.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -8,7 +8,7 @@\n // functions and the modules are enclosed in `[]`)\n //\n // In our specific instance, the earlier compilations were inlining the call\n-// to`B` into `A`; thus `A` ended up with a external reference to the symbol `D`\n+// to`B` into `A`; thus `A` ended up with an external reference to the symbol `D`\n // in its object code, to be resolved at subsequent link time. The LTO import\n // information provided by LLVM for those runs reflected that information: it\n // explicitly says during those runs, `B` definition and `D` declaration were"}, {"sha": "c771c09da88335bcd49a0007c0242da2b4bbc401", "filename": "src/test/rustdoc-ui/coverage/allow_missing_docs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fallow_missing_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fallow_missing_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fallow_missing_docs.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -8,7 +8,7 @@ pub mod mod_foo {\n     pub struct Bar;\n }\n \n-/// This is a struct with a `#[allow(missing_docs)]`\n+/// This is a struct with an `#[allow(missing_docs)]`\n pub struct AllowTheMissingDocs {\n     #[allow(missing_docs)]\n     pub empty_str: String,"}, {"sha": "edfecb91036925fca39492d97254a953bf83b974", "filename": "src/test/ui/async-await/drop-order/drop-order-for-temporary-in-tail-return-expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/src%2Ftest%2Fui%2Fasync-await%2Fdrop-order%2Fdrop-order-for-temporary-in-tail-return-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/src%2Ftest%2Fui%2Fasync-await%2Fdrop-order%2Fdrop-order-for-temporary-in-tail-return-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fdrop-order%2Fdrop-order-for-temporary-in-tail-return-expr.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -10,7 +10,7 @@\n // Test the drop order for parameters relative to local variables and\n // temporaries created in the tail return expression of the function\n // body. In particular, check that this drop order is the same between\n-// a `async fn` and an ordinary `fn`. See #64512.\n+// an `async fn` and an ordinary `fn`. See #64512.\n \n extern crate arc_wake;\n "}, {"sha": "59309a7f2888b5d26c039cf0f81563b958ad2112", "filename": "src/test/ui/async-await/issues/issue-69307.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-69307.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-69307.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-69307.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -1,6 +1,6 @@\n // Regression test for #69307\n //\n-// Having a `async { .. foo.await .. }` block appear inside of a `+=`\n+// Having an `async { .. foo.await .. }` block appear inside of a `+=`\n // expression was causing an ICE due to a failure to save/restore\n // state in the AST numbering pass when entering a nested body.\n //"}, {"sha": "c82bc369f430181f594aa0a38f2356b521dfcd2d", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/insignificant_drop.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.fixed?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -3,7 +3,7 @@\n #![deny(rust_2021_incompatible_closure_captures)]\n //~^ NOTE: the lint level is defined here\n \n-// Test cases for types that implement a insignificant drop (stlib defined)\n+// Test cases for types that implement an insignificant drop (stlib defined)\n \n // `t` needs Drop because one of its elements needs drop,\n // therefore precise capture might affect drop ordering"}, {"sha": "57ab15ae8f2439041e440060209a480df4cd4457", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/insignificant_drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -3,7 +3,7 @@\n #![deny(rust_2021_incompatible_closure_captures)]\n //~^ NOTE: the lint level is defined here\n \n-// Test cases for types that implement a insignificant drop (stlib defined)\n+// Test cases for types that implement an insignificant drop (stlib defined)\n \n // `t` needs Drop because one of its elements needs drop,\n // therefore precise capture might affect drop ordering"}, {"sha": "567802376184da5316e82becf37edbb70d9724c1", "filename": "src/test/ui/hrtb/hrtb-exists-forall-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-fn.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -1,4 +1,4 @@\n-// Test a `exists<'a> { forall<'b> { 'a = 'b } }` pattern -- which should not compile!\n+// Test an `exists<'a> { forall<'b> { 'a = 'b } }` pattern -- which should not compile!\n //\n // In particular, we test this pattern in trait solving, where it is not connected\n // to any part of the source code."}, {"sha": "9b9e4496a870dc926c88791b9e4aaebc4e54d623", "filename": "src/test/ui/hrtb/hrtb-exists-forall-trait-invariant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-invariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-invariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-invariant.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -1,4 +1,4 @@\n-// Test a `exists<'a> { forall<'b> { 'a = 'b } }` pattern -- which should not compile!\n+// Test an `exists<'a> { forall<'b> { 'a = 'b } }` pattern -- which should not compile!\n //\n // In particular, we test this pattern in trait solving, where it is not connected\n // to any part of the source code."}, {"sha": "9d2855f5c61666011f536b75d58c8fc2c6777f99", "filename": "src/test/ui/rfc-2008-non-exhaustive/enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -30,7 +30,7 @@ fn main() {\n     match enum_unit {\n         NonExhaustiveEnum::Unit => 1,\n         NonExhaustiveEnum::Tuple(_) => 2,\n-        // This particular arm tests that a enum marked as non-exhaustive\n+        // This particular arm tests that an enum marked as non-exhaustive\n         // will not error if its variants are matched exhaustively.\n         NonExhaustiveEnum::Struct { field } => field,\n         _ => 0 // no error with wildcard"}, {"sha": "a71051243c893dbd3b669315f3a11a1a51b49829", "filename": "src/test/ui/traits/reservation-impl/non-lattice-ok.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/src%2Ftest%2Fui%2Ftraits%2Freservation-impl%2Fnon-lattice-ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/src%2Ftest%2Fui%2Ftraits%2Freservation-impl%2Fnon-lattice-ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Freservation-impl%2Fnon-lattice-ok.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -5,7 +5,7 @@\n \n // Why did we ever want to do this?\n //\n-// We want to eventually add a `impl<T> From<!> for T` impl. That impl conflicts\n+// We want to eventually add an `impl<T> From<!> for T` impl. That impl conflicts\n // with existing impls - at least the `impl<T> From<T> for T` impl. There are\n // 2 ways we thought of for dealing with that conflict:\n //\n@@ -23,7 +23,7 @@\n // actually cause any ambiguity.\n //\n // Now it turned out lattice specialization doesn't work it, because an\n-// `impl<T> From<T> for Smaht<T>` would require a `impl From<!> for Smaht<!>`,\n+// `impl<T> From<T> for Smaht<T>` would require an `impl From<!> for Smaht<!>`,\n // breaking backwards-compatibility in a fairly painful way. So if we want to\n // go with a known approach, we should go with a \"marker trait overlap\"-style\n // approach."}, {"sha": "3f4f7ea1c10c39291d3aa798d1c87a1d162d4d88", "filename": "src/test/ui/union/union-nonzero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/src%2Ftest%2Fui%2Funion%2Funion-nonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/src%2Ftest%2Fui%2Funion%2Funion-nonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-nonzero.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -13,7 +13,7 @@\n // optimizations to types containing unions even if they're theoretically possible. (discussion:\n // https://github.com/rust-lang/rust/issues/36394)\n //\n-// Notably this nails down part of the behavior that `MaybeUninit` assumes: that a\n+// Notably this nails down part of the behavior that `MaybeUninit` assumes: that an\n // `Option<MaybeUninit<&u8>>` does not take advantage of non-zero optimization, and thus is a safe\n // construct.\n "}, {"sha": "2296842e86f556ae6dc64572f0e440146ba6d7f7", "filename": "src/tools/clippy/clippy_lints/src/loops/manual_memcpy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -268,7 +268,7 @@ impl std::ops::Sub<&MinifyingSugg<'static>> for MinifyingSugg<'static> {\n     }\n }\n \n-/// a wrapper around `MinifyingSugg`, which carries a operator like currying\n+/// a wrapper around `MinifyingSugg`, which carries an operator like currying\n /// so that the suggested code become more efficient (e.g. `foo + -bar` `foo - bar`).\n struct Offset {\n     value: MinifyingSugg<'static>,"}, {"sha": "6c2563358cafe4d04f0e6c76281f562a376fdb72", "filename": "src/tools/clippy/clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -293,7 +293,7 @@ impl<'tcx> LateLintPass<'tcx> for NonCopyConst {\n                 }) => {\n                     if_chain! {\n                         // Lint a trait impl item only when the definition is a generic type,\n-                        // assuming a assoc const is not meant to be a interior mutable type.\n+                        // assuming an assoc const is not meant to be an interior mutable type.\n                         if let Some(of_trait_def_id) = of_trait_ref.trait_def_id();\n                         if let Some(of_assoc_item) = specialization_graph::Node::Trait(of_trait_def_id)\n                             .item(cx.tcx, impl_item.ident, AssocKind::Const, of_trait_def_id);"}, {"sha": "4fa361fedafac434dbd26510c421506bed51e0b8", "filename": "src/tools/clippy/clippy_lints/src/ranges.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -51,7 +51,7 @@ declare_clippy_lint! {\n     ///\n     /// ### Known problems\n     /// Will add unnecessary pair of parentheses when the\n-    /// expression is not wrapped in a pair but starts with a opening parenthesis\n+    /// expression is not wrapped in a pair but starts with an opening parenthesis\n     /// and ends with a closing one.\n     /// I.e., `let _ = (f()+1)..(f()+1)` results in `let _ = ((f()+1)..=f())`.\n     ///"}, {"sha": "b9e317a3cfd03af73f46ea09bc2f6997936fb107", "filename": "src/tools/clippy/clippy_lints/src/shadow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fshadow.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -74,7 +74,7 @@ declare_clippy_lint! {\n declare_clippy_lint! {\n     /// ### What it does\n     /// Checks for bindings that shadow other bindings already in\n-    /// scope, either without a initialization or with one that does not even use\n+    /// scope, either without an initialization or with one that does not even use\n     /// the original value.\n     ///\n     /// ### Why is this bad?"}, {"sha": "c192f9094a8a97bdfd840c3edfd27e09948d61e4", "filename": "src/tools/clippy/clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -198,7 +198,7 @@ define_Conf! {\n     (enum_variant_name_threshold: u64 = 3),\n     /// Lint: LARGE_ENUM_VARIANT.\n     ///\n-    /// The maximum size of a enum's variant to avoid box suggestion\n+    /// The maximum size of an enum's variant to avoid box suggestion\n     (enum_variant_size_threshold: u64 = 200),\n     /// Lint: VERBOSE_BIT_MASK.\n     ///"}, {"sha": "9ba1381da659397d6d500ba7cc1e9fbe6de28198", "filename": "src/tools/clippy/clippy_utils/src/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -329,7 +329,7 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n         vec.iter().map(|elem| self.expr(elem)).collect::<Option<_>>()\n     }\n \n-    /// Lookup a possibly constant expression from a `ExprKind::Path`.\n+    /// Lookup a possibly constant expression from an `ExprKind::Path`.\n     fn fetch_path(&mut self, qpath: &QPath<'_>, id: HirId, ty: Ty<'tcx>) -> Option<Constant> {\n         let res = self.typeck_results.qpath_res(qpath, id);\n         match res {"}, {"sha": "2a13b5ee3474f5f7b7da2c5fb49512c201be6a9f", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -583,7 +583,7 @@ pub fn trait_ref_of_method<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId) -> Optio\n /// For example, if `e` represents the `v[0].a.b[x]`\n /// this method will return a tuple, composed of a `Vec`\n /// containing the `Expr`s for `v[0], v[0].a, v[0].a.b, v[0].a.b[x]`\n-/// and a `Expr` for root of them, `v`\n+/// and an `Expr` for root of them, `v`\n fn projection_stack<'a, 'hir>(mut e: &'a Expr<'hir>) -> (Vec<&'a Expr<'hir>>, &'a Expr<'hir>) {\n     let mut result = vec![];\n     let root = loop {"}, {"sha": "65d93e8f86e43f1c7953d83f45721bb9add27c43", "filename": "src/tools/clippy/clippy_utils/src/sugg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -434,7 +434,7 @@ pub fn make_assoc(op: AssocOp, lhs: &Sugg<'_>, rhs: &Sugg<'_>) -> Sugg<'static>\n         matches!(op, AssocOp::ShiftLeft | AssocOp::ShiftRight)\n     }\n \n-    /// Returns `true` if the operator is a arithmetic operator\n+    /// Returns `true` if the operator is an arithmetic operator\n     /// (i.e., `+`, `-`, `*`, `/`, `%`).\n     fn is_arith(op: AssocOp) -> bool {\n         matches!("}, {"sha": "256a336db821d8711c6c3f958e2b814784b2f701", "filename": "src/tools/clippy/tests/ui/declare_interior_mutable_const/traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdeclare_interior_mutable_const%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdeclare_interior_mutable_const%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdeclare_interior_mutable_const%2Ftraits.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -117,7 +117,7 @@ impl SelfType for AtomicUsize {\n     const WRAPPED_SELF: Option<Self> = Some(AtomicUsize::new(21)); //~ ERROR interior mutable\n }\n \n-// Even though a constant contains a generic type, if it also have a interior mutable type,\n+// Even though a constant contains a generic type, if it also have an interior mutable type,\n // it should be linted at the definition site.\n trait BothOfCellAndGeneric<T> {\n     // this is a false negative in the current implementation."}, {"sha": "f291918225f450e21b6914ffc7f7afeab7e639ee", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf88b113eab9c36e63f8461f5849138cb60d810a/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf88b113eab9c36e63f8461f5849138cb60d810a/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=bf88b113eab9c36e63f8461f5849138cb60d810a", "patch": "@@ -1733,7 +1733,7 @@ impl<'test> TestCx<'test> {\n     }\n \n     /// For each `aux-build: foo/bar` annotation, we check to find the\n-    /// file in a `auxiliary` directory relative to the test itself.\n+    /// file in an `auxiliary` directory relative to the test itself.\n     fn compute_aux_test_paths(&self, rel_ab: &str) -> TestPaths {\n         let test_ab = self\n             .testpaths"}]}