{"sha": "94d92e6830768cc026348766f7f74fc3fd510888", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0ZDkyZTY4MzA3NjhjYzAyNjM0ODc2NmY3Zjc0ZmMzZmQ1MTA4ODg=", "commit": {"author": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2014-07-19T19:34:24Z"}, "committer": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2014-07-21T21:45:23Z"}, "message": "Moved `syntax::ext::base::SyntaxEnv` into `syntax::ext::base::ExtCtx`", "tree": {"sha": "633aa0b962ea285402458469ba1a4614880288da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/633aa0b962ea285402458469ba1a4614880288da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/94d92e6830768cc026348766f7f74fc3fd510888", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/94d92e6830768cc026348766f7f74fc3fd510888", "html_url": "https://github.com/rust-lang/rust/commit/94d92e6830768cc026348766f7f74fc3fd510888", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/94d92e6830768cc026348766f7f74fc3fd510888/comments", "author": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df68c6f3c35354662b39128d56d5dcc6deadf591", "url": "https://api.github.com/repos/rust-lang/rust/commits/df68c6f3c35354662b39128d56d5dcc6deadf591", "html_url": "https://github.com/rust-lang/rust/commit/df68c6f3c35354662b39128d56d5dcc6deadf591"}], "stats": {"total": 414, "additions": 213, "deletions": 201}, "files": [{"sha": "9160c16e0d316b1e0d7b8d377cd38f6c404d27d9", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/94d92e6830768cc026348766f7f74fc3fd510888/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94d92e6830768cc026348766f7f74fc3fd510888/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=94d92e6830768cc026348766f7f74fc3fd510888", "patch": "@@ -23,6 +23,7 @@ use ext::mtwt;\n \n use std::collections::HashMap;\n use std::gc::{Gc, GC};\n+use std::rc::Rc;\n \n // new-style macro! tt code:\n //\n@@ -104,9 +105,9 @@ pub type IdentMacroExpanderFn =\n /// just into the compiler's internal macro table, for `make_def`).\n pub trait MacResult {\n     /// Define a new macro.\n-    // this particular flavor should go away; the idea that a macro might\n-    // expand into either a macro definition or an expression, depending\n-    // on what the context wants, is kind of silly.\n+    // this should go away; the idea that a macro might expand into\n+    // either a macro definition or an expression, depending on what\n+    // the context wants, is kind of silly.\n     fn make_def(&self) -> Option<MacroDef> {\n         None\n     }\n@@ -314,7 +315,7 @@ impl BlockInfo {\n \n /// The base map of methods for expanding syntax extension\n /// AST nodes into full ASTs\n-pub fn syntax_expander_table() -> SyntaxEnv {\n+fn initial_syntax_expander_table() -> SyntaxEnv {\n     // utility function to simplify creating NormalTT syntax extensions\n     fn builtin_normal_expander(f: MacroExpanderFn) -> SyntaxExtension {\n         NormalTT(box BasicMacroExpander {\n@@ -431,7 +432,9 @@ pub struct ExtCtxt<'a> {\n \n     pub mod_path: Vec<ast::Ident> ,\n     pub trace_mac: bool,\n-    pub exported_macros: Vec<Gc<ast::Item>>\n+    pub exported_macros: Vec<Gc<ast::Item>>,\n+\n+\tpub syntax_env: SyntaxEnv,\n }\n \n impl<'a> ExtCtxt<'a> {\n@@ -445,6 +448,7 @@ impl<'a> ExtCtxt<'a> {\n             ecfg: ecfg,\n             trace_mac: false,\n             exported_macros: Vec::new(),\n+            syntax_env: initial_syntax_expander_table(),\n         }\n     }\n \n@@ -453,7 +457,6 @@ impl<'a> ExtCtxt<'a> {\n             match e.node {\n                 ast::ExprMac(..) => {\n                     let mut expander = expand::MacroExpander {\n-                        extsbox: syntax_expander_table(),\n                         cx: self,\n                     };\n                     e = expand::expand_expr(e, &mut expander);\n@@ -642,10 +645,13 @@ pub fn get_exprs_from_tts(cx: &mut ExtCtxt,\n /// In order to have some notion of scoping for macros,\n /// we want to implement the notion of a transformation\n /// environment.\n-\n+///\n /// This environment maps Names to SyntaxExtensions.\n+pub struct SyntaxEnv {\n+    chain: Vec<MapChainFrame> ,\n+}\n \n-//impl question: how to implement it? Initially, the\n+// impl question: how to implement it? Initially, the\n // env will contain only macros, so it might be painful\n // to add an empty frame for every context. Let's just\n // get it working, first....\n@@ -657,15 +663,11 @@ pub fn get_exprs_from_tts(cx: &mut ExtCtxt,\n \n struct MapChainFrame {\n     info: BlockInfo,\n-    map: HashMap<Name, SyntaxExtension>,\n-}\n-\n-pub struct SyntaxEnv {\n-    chain: Vec<MapChainFrame> ,\n+    map: HashMap<Name, Rc<SyntaxExtension>>,\n }\n \n impl SyntaxEnv {\n-    pub fn new() -> SyntaxEnv {\n+    fn new() -> SyntaxEnv {\n         let mut map = SyntaxEnv { chain: Vec::new() };\n         map.push_frame();\n         map\n@@ -692,18 +694,18 @@ impl SyntaxEnv {\n         unreachable!()\n     }\n \n-    pub fn find<'a>(&'a self, k: &Name) -> Option<&'a SyntaxExtension> {\n+    pub fn find(&self, k: &Name) -> Option<Rc<SyntaxExtension>> {\n         for frame in self.chain.iter().rev() {\n             match frame.map.find(k) {\n-                Some(v) => return Some(v),\n+                Some(v) => return Some(v.clone()),\n                 None => {}\n             }\n         }\n         None\n     }\n \n     pub fn insert(&mut self, k: Name, v: SyntaxExtension) {\n-        self.find_escape_frame().map.insert(k, v);\n+        self.find_escape_frame().map.insert(k, Rc::new(v));\n     }\n \n     pub fn info<'a>(&'a mut self) -> &'a mut BlockInfo {"}, {"sha": "0c04c07a51e0439d833a51af8c119953ce4d9bfa", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 194, "deletions": 184, "changes": 378, "blob_url": "https://github.com/rust-lang/rust/blob/94d92e6830768cc026348766f7f74fc3fd510888/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94d92e6830768cc026348766f7f74fc3fd510888/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=94d92e6830768cc026348766f7f74fc3fd510888", "patch": "@@ -208,7 +208,7 @@ fn expand_mac_invoc<T>(mac: &ast::Mac, span: &codemap::Span,\n             }\n             let extname = pth.segments.get(0).identifier;\n             let extnamestr = token::get_ident(extname);\n-            match fld.extsbox.find(&extname.name) {\n+            match fld.cx.syntax_env.find(&extname.name) {\n                 None => {\n                     fld.cx.span_err(\n                         pth.span,\n@@ -218,46 +218,48 @@ fn expand_mac_invoc<T>(mac: &ast::Mac, span: &codemap::Span,\n                     // let compilation continue\n                     None\n                 }\n-                Some(&NormalTT(ref expandfun, exp_span)) => {\n-                    fld.cx.bt_push(ExpnInfo {\n-                            call_site: *span,\n-                            callee: NameAndSpan {\n-                                name: extnamestr.get().to_string(),\n-                                format: MacroBang,\n-                                span: exp_span,\n-                            },\n-                        });\n-                    let fm = fresh_mark();\n-                    let marked_before = mark_tts(tts.as_slice(), fm);\n-\n-                    // The span that we pass to the expanders we want to\n-                    // be the root of the call stack. That's the most\n-                    // relevant span and it's the actual invocation of\n-                    // the macro.\n-                    let mac_span = original_span(fld.cx);\n-\n-                    let expanded = expandfun.expand(fld.cx,\n-                                                    mac_span.call_site,\n-                                                    marked_before.as_slice());\n-                    let parsed = match parse_thunk(expanded) {\n-                        Some(e) => e,\n-                        None => {\n-                            fld.cx.span_err(\n-                                pth.span,\n-                                format!(\"non-expression macro in expression position: {}\",\n-                                        extnamestr.get().as_slice()\n-                                        ).as_slice());\n-                            return None;\n-                        }\n-                    };\n-                    Some(mark_thunk(parsed,fm))\n-                }\n-                _ => {\n-                    fld.cx.span_err(\n-                        pth.span,\n-                        format!(\"'{}' is not a tt-style macro\",\n-                                extnamestr.get()).as_slice());\n-                    None\n+                Some(rc) => match *rc {\n+                    NormalTT(ref expandfun, exp_span) => {\n+                        fld.cx.bt_push(ExpnInfo {\n+                                call_site: *span,\n+                                callee: NameAndSpan {\n+                                    name: extnamestr.get().to_string(),\n+                                    format: MacroBang,\n+                                    span: exp_span,\n+                                },\n+                            });\n+                        let fm = fresh_mark();\n+                        let marked_before = mark_tts(tts.as_slice(), fm);\n+\n+                        // The span that we pass to the expanders we want to\n+                        // be the root of the call stack. That's the most\n+                        // relevant span and it's the actual invocation of\n+                        // the macro.\n+                        let mac_span = original_span(fld.cx);\n+\n+                        let expanded = expandfun.expand(fld.cx,\n+                                                        mac_span.call_site,\n+                                                        marked_before.as_slice());\n+                        let parsed = match parse_thunk(expanded) {\n+                            Some(e) => e,\n+                            None => {\n+                                fld.cx.span_err(\n+                                    pth.span,\n+                                    format!(\"non-expression macro in expression position: {}\",\n+                                            extnamestr.get().as_slice()\n+                                            ).as_slice());\n+                                return None;\n+                            }\n+                        };\n+                        Some(mark_thunk(parsed,fm))\n+                    }\n+                    _ => {\n+                        fld.cx.span_err(\n+                            pth.span,\n+                            format!(\"'{}' is not a tt-style macro\",\n+                                    extnamestr.get()).as_slice());\n+                        None\n+                    }\n                 }\n             }\n         }\n@@ -288,10 +290,10 @@ fn expand_loop_block(loop_block: P<Block>,\n             // The rename *must* be added to the enclosed syntax context for\n             // `break` or `continue` to pick up because by definition they are\n             // in a block enclosed by loop head.\n-            fld.extsbox.push_frame();\n-            fld.extsbox.info().pending_renames.push(rename);\n+            fld.cx.syntax_env.push_frame();\n+            fld.cx.syntax_env.info().pending_renames.push(rename);\n             let expanded_block = expand_block_elts(&*loop_block, fld);\n-            fld.extsbox.pop_frame();\n+            fld.cx.syntax_env.pop_frame();\n \n             (expanded_block, Some(renamed_ident))\n         }\n@@ -321,29 +323,32 @@ fn expand_item(it: Gc<ast::Item>, fld: &mut MacroExpander)\n     for attr in it.attrs.iter() {\n         let mname = attr.name();\n \n-        match fld.extsbox.find(&intern(mname.get())) {\n-            Some(&ItemDecorator(dec_fn)) => {\n-                attr::mark_used(attr);\n+        match fld.cx.syntax_env.find(&intern(mname.get())) {\n+            Some(rc) => match *rc {\n+                ItemDecorator(dec_fn) => {\n+                    attr::mark_used(attr);\n \n-                fld.cx.bt_push(ExpnInfo {\n-                    call_site: attr.span,\n-                    callee: NameAndSpan {\n-                        name: mname.get().to_string(),\n-                        format: MacroAttribute,\n-                        span: None\n-                    }\n-                });\n+                    fld.cx.bt_push(ExpnInfo {\n+                        call_site: attr.span,\n+                        callee: NameAndSpan {\n+                            name: mname.get().to_string(),\n+                            format: MacroAttribute,\n+                            span: None\n+                        }\n+                    });\n \n-                // we'd ideally decorator_items.push_all(expand_item(item, fld)),\n-                // but that double-mut-borrows fld\n-                let mut items: SmallVector<Gc<ast::Item>> = SmallVector::zero();\n-                dec_fn(fld.cx, attr.span, attr.node.value, it,\n-                       |item| items.push(item));\n-                decorator_items.extend(items.move_iter()\n-                    .flat_map(|item| expand_item(item, fld).move_iter()));\n+                    // we'd ideally decorator_items.push_all(expand_item(item, fld)),\n+                    // but that double-mut-borrows fld\n+                    let mut items: SmallVector<Gc<ast::Item>> = SmallVector::zero();\n+                    dec_fn(fld.cx, attr.span, attr.node.value, it,\n+                        |item| items.push(item));\n+                    decorator_items.extend(items.move_iter()\n+                        .flat_map(|item| expand_item(item, fld).move_iter()));\n \n-                fld.cx.bt_pop();\n-            }\n+                    fld.cx.bt_pop();\n+                }\n+                _ => new_attrs.push((*attr).clone()),\n+            },\n             _ => new_attrs.push((*attr).clone()),\n         }\n     }\n@@ -353,7 +358,7 @@ fn expand_item(it: Gc<ast::Item>, fld: &mut MacroExpander)\n         ast::ItemMod(_) | ast::ItemForeignMod(_) => {\n             fld.cx.mod_push(it.ident);\n             let macro_escape = contains_macro_escape(new_attrs.as_slice());\n-            let result = with_exts_frame!(fld.extsbox,\n+            let result = with_exts_frame!(fld.cx.syntax_env,\n                                           macro_escape,\n                                           noop_fold_item(&*it, fld));\n             fld.cx.mod_pop();\n@@ -377,8 +382,8 @@ fn expand_item_modifiers(mut it: Gc<ast::Item>, fld: &mut MacroExpander)\n                          -> Gc<ast::Item> {\n     // partition the attributes into ItemModifiers and others\n     let (modifiers, other_attrs) = it.attrs.partitioned(|attr| {\n-        match fld.extsbox.find(&intern(attr.name().get())) {\n-            Some(&ItemModifier(_)) => true,\n+        match fld.cx.syntax_env.find(&intern(attr.name().get())) {\n+            Some(rc) => match *rc { ItemModifier(_) => true, _ => false },\n             _ => false\n         }\n     });\n@@ -395,20 +400,23 @@ fn expand_item_modifiers(mut it: Gc<ast::Item>, fld: &mut MacroExpander)\n     for attr in modifiers.iter() {\n         let mname = attr.name();\n \n-        match fld.extsbox.find(&intern(mname.get())) {\n-            Some(&ItemModifier(dec_fn)) => {\n-                attr::mark_used(attr);\n-                fld.cx.bt_push(ExpnInfo {\n-                    call_site: attr.span,\n-                    callee: NameAndSpan {\n-                        name: mname.get().to_string(),\n-                        format: MacroAttribute,\n-                        span: None,\n-                    }\n-                });\n-                it = dec_fn(fld.cx, attr.span, attr.node.value, it);\n-                fld.cx.bt_pop();\n-            }\n+        match fld.cx.syntax_env.find(&intern(mname.get())) {\n+            Some(rc) => match *rc {\n+                ItemModifier(dec_fn) => {\n+                    attr::mark_used(attr);\n+                    fld.cx.bt_push(ExpnInfo {\n+                        call_site: attr.span,\n+                        callee: NameAndSpan {\n+                            name: mname.get().to_string(),\n+                            format: MacroAttribute,\n+                            span: None,\n+                        }\n+                    });\n+                    it = dec_fn(fld.cx, attr.span, attr.node.value, it);\n+                    fld.cx.bt_pop();\n+                }\n+                _ => unreachable!()\n+            },\n             _ => unreachable!()\n         }\n     }\n@@ -452,7 +460,7 @@ fn expand_item_mac(it: Gc<ast::Item>, fld: &mut MacroExpander)\n     let extname = pth.segments.get(0).identifier;\n     let extnamestr = token::get_ident(extname);\n     let fm = fresh_mark();\n-    let expanded = match fld.extsbox.find(&extname.name) {\n+    let expanded = match fld.cx.syntax_env.find(&extname.name) {\n         None => {\n             fld.cx.span_err(pth.span,\n                             format!(\"macro undefined: '{}!'\",\n@@ -461,70 +469,72 @@ fn expand_item_mac(it: Gc<ast::Item>, fld: &mut MacroExpander)\n             return SmallVector::zero();\n         }\n \n-        Some(&NormalTT(ref expander, span)) => {\n-            if it.ident.name != parse::token::special_idents::invalid.name {\n-                fld.cx\n-                   .span_err(pth.span,\n-                             format!(\"macro {}! expects no ident argument, \\\n-                                      given '{}'\",\n-                                     extnamestr,\n-                                     token::get_ident(it.ident)).as_slice());\n-                return SmallVector::zero();\n+        Some(rc) => match *rc {\n+            NormalTT(ref expander, span) => {\n+                if it.ident.name != parse::token::special_idents::invalid.name {\n+                    fld.cx\n+                    .span_err(pth.span,\n+                                format!(\"macro {}! expects no ident argument, \\\n+                                        given '{}'\",\n+                                        extnamestr,\n+                                        token::get_ident(it.ident)).as_slice());\n+                    return SmallVector::zero();\n+                }\n+                fld.cx.bt_push(ExpnInfo {\n+                    call_site: it.span,\n+                    callee: NameAndSpan {\n+                        name: extnamestr.get().to_string(),\n+                        format: MacroBang,\n+                        span: span\n+                    }\n+                });\n+                // mark before expansion:\n+                let marked_before = mark_tts(tts.as_slice(), fm);\n+                expander.expand(fld.cx, it.span, marked_before.as_slice())\n             }\n-            fld.cx.bt_push(ExpnInfo {\n-                call_site: it.span,\n-                callee: NameAndSpan {\n-                    name: extnamestr.get().to_string(),\n-                    format: MacroBang,\n-                    span: span\n+            IdentTT(ref expander, span) => {\n+                if it.ident.name == parse::token::special_idents::invalid.name {\n+                    fld.cx.span_err(pth.span,\n+                                    format!(\"macro {}! expects an ident argument\",\n+                                            extnamestr.get()).as_slice());\n+                    return SmallVector::zero();\n                 }\n-            });\n-            // mark before expansion:\n-            let marked_before = mark_tts(tts.as_slice(), fm);\n-            expander.expand(fld.cx, it.span, marked_before.as_slice())\n-        }\n-        Some(&IdentTT(ref expander, span)) => {\n-            if it.ident.name == parse::token::special_idents::invalid.name {\n-                fld.cx.span_err(pth.span,\n-                                format!(\"macro {}! expects an ident argument\",\n-                                        extnamestr.get()).as_slice());\n-                return SmallVector::zero();\n+                fld.cx.bt_push(ExpnInfo {\n+                    call_site: it.span,\n+                    callee: NameAndSpan {\n+                        name: extnamestr.get().to_string(),\n+                        format: MacroBang,\n+                        span: span\n+                    }\n+                });\n+                // mark before expansion:\n+                let marked_tts = mark_tts(tts.as_slice(), fm);\n+                expander.expand(fld.cx, it.span, it.ident, marked_tts)\n             }\n-            fld.cx.bt_push(ExpnInfo {\n-                call_site: it.span,\n-                callee: NameAndSpan {\n-                    name: extnamestr.get().to_string(),\n-                    format: MacroBang,\n-                    span: span\n+            LetSyntaxTT(ref expander, span) => {\n+                if it.ident.name == parse::token::special_idents::invalid.name {\n+                    fld.cx.span_err(pth.span,\n+                                    format!(\"macro {}! expects an ident argument\",\n+                                            extnamestr.get()).as_slice());\n+                    return SmallVector::zero();\n                 }\n-            });\n-            // mark before expansion:\n-            let marked_tts = mark_tts(tts.as_slice(), fm);\n-            expander.expand(fld.cx, it.span, it.ident, marked_tts)\n-        }\n-        Some(&LetSyntaxTT(ref expander, span)) => {\n-            if it.ident.name == parse::token::special_idents::invalid.name {\n-                fld.cx.span_err(pth.span,\n-                                format!(\"macro {}! expects an ident argument\",\n+                fld.cx.bt_push(ExpnInfo {\n+                    call_site: it.span,\n+                    callee: NameAndSpan {\n+                        name: extnamestr.get().to_string(),\n+                        format: MacroBang,\n+                        span: span\n+                    }\n+                });\n+                // DON'T mark before expansion:\n+                expander.expand(fld.cx, it.span, it.ident, tts)\n+            }\n+            _ => {\n+                fld.cx.span_err(it.span,\n+                                format!(\"{}! is not legal in item position\",\n                                         extnamestr.get()).as_slice());\n                 return SmallVector::zero();\n             }\n-            fld.cx.bt_push(ExpnInfo {\n-                call_site: it.span,\n-                callee: NameAndSpan {\n-                    name: extnamestr.get().to_string(),\n-                    format: MacroBang,\n-                    span: span\n-                }\n-            });\n-            // DON'T mark before expansion:\n-            expander.expand(fld.cx, it.span, it.ident, tts)\n-        }\n-        _ => {\n-            fld.cx.span_err(it.span,\n-                            format!(\"{}! is not legal in item position\",\n-                                    extnamestr.get()).as_slice());\n-            return SmallVector::zero();\n         }\n     };\n \n@@ -534,7 +544,7 @@ fn expand_item_mac(it: Gc<ast::Item>, fld: &mut MacroExpander)\n             // result of expanding a LetSyntaxTT, and thus doesn't\n             // need to be marked. Not that it could be marked anyway.\n             // create issue to recommend refactoring here?\n-            fld.extsbox.insert(intern(name.as_slice()), ext);\n+            fld.cx.syntax_env.insert(intern(name.as_slice()), ext);\n             if attr::contains_name(it.attrs.as_slice(), \"macro_export\") {\n                 fld.cx.exported_macros.push(it);\n             }\n@@ -641,7 +651,7 @@ fn expand_non_macro_stmt(s: &Stmt, fld: &mut MacroExpander)\n                         rename_fld.fold_pat(expanded_pat)\n                     };\n                     // add them to the existing pending renames:\n-                    fld.extsbox.info().pending_renames.push_all_move(new_pending_renames);\n+                    fld.cx.syntax_env.info().pending_renames.push_all_move(new_pending_renames);\n                     // also, don't forget to expand the init:\n                     let new_init_opt = init.map(|e| fld.fold_expr(e));\n                     let rewritten_local =\n@@ -742,7 +752,7 @@ fn fn_decl_arg_bindings(fn_decl: &ast::FnDecl) -> Vec<ast::Ident> {\n // expand a block. pushes a new exts_frame, then calls expand_block_elts\n fn expand_block(blk: &Block, fld: &mut MacroExpander) -> P<Block> {\n     // see note below about treatment of exts table\n-    with_exts_frame!(fld.extsbox,false,\n+    with_exts_frame!(fld.cx.syntax_env,false,\n                      expand_block_elts(blk, fld))\n }\n \n@@ -753,7 +763,7 @@ fn expand_block_elts(b: &Block, fld: &mut MacroExpander) -> P<Block> {\n         b.stmts.iter().flat_map(|x| {\n             // perform all pending renames\n             let renamed_stmt = {\n-                let pending_renames = &mut fld.extsbox.info().pending_renames;\n+                let pending_renames = &mut fld.cx.syntax_env.info().pending_renames;\n                 let mut rename_fld = IdentRenamer{renames:pending_renames};\n                 rename_fld.fold_stmt(&**x).expect_one(\"rename_fold didn't return one value\")\n             };\n@@ -762,7 +772,7 @@ fn expand_block_elts(b: &Block, fld: &mut MacroExpander) -> P<Block> {\n         }).collect();\n     let new_expr = b.expr.map(|x| {\n         let expr = {\n-            let pending_renames = &mut fld.extsbox.info().pending_renames;\n+            let pending_renames = &mut fld.cx.syntax_env.info().pending_renames;\n             let mut rename_fld = IdentRenamer{renames:pending_renames};\n             rename_fld.fold_expr(x)\n         };\n@@ -795,7 +805,7 @@ fn expand_pat(p: Gc<ast::Pat>, fld: &mut MacroExpander) -> Gc<ast::Pat> {\n     }\n     let extname = pth.segments.get(0).identifier;\n     let extnamestr = token::get_ident(extname);\n-    let marked_after = match fld.extsbox.find(&extname.name) {\n+    let marked_after = match fld.cx.syntax_env.find(&extname.name) {\n         None => {\n             fld.cx.span_err(pth.span,\n                             format!(\"macro undefined: '{}!'\",\n@@ -804,43 +814,45 @@ fn expand_pat(p: Gc<ast::Pat>, fld: &mut MacroExpander) -> Gc<ast::Pat> {\n             return DummyResult::raw_pat(p.span);\n         }\n \n-        Some(&NormalTT(ref expander, span)) => {\n-            fld.cx.bt_push(ExpnInfo {\n-                call_site: p.span,\n-                callee: NameAndSpan {\n-                    name: extnamestr.get().to_string(),\n-                    format: MacroBang,\n-                    span: span\n-                }\n-            });\n-\n-            let fm = fresh_mark();\n-            let marked_before = mark_tts(tts.as_slice(), fm);\n-            let mac_span = original_span(fld.cx);\n-            let expanded = match expander.expand(fld.cx,\n-                                   mac_span.call_site,\n-                                   marked_before.as_slice()).make_pat() {\n-                Some(e) => e,\n-                None => {\n-                    fld.cx.span_err(\n-                        pth.span,\n-                        format!(\n-                            \"non-pattern macro in pattern position: {}\",\n-                            extnamestr.get()\n-                        ).as_slice()\n-                    );\n-                    return DummyResult::raw_pat(p.span);\n-                }\n-            };\n+        Some(rc) => match *rc {\n+            NormalTT(ref expander, span) => {\n+                fld.cx.bt_push(ExpnInfo {\n+                    call_site: p.span,\n+                    callee: NameAndSpan {\n+                        name: extnamestr.get().to_string(),\n+                        format: MacroBang,\n+                        span: span\n+                    }\n+                });\n \n-            // mark after:\n-            mark_pat(expanded,fm)\n-        }\n-        _ => {\n-            fld.cx.span_err(p.span,\n-                            format!(\"{}! is not legal in pattern position\",\n-                                    extnamestr.get()).as_slice());\n-            return DummyResult::raw_pat(p.span);\n+                let fm = fresh_mark();\n+                let marked_before = mark_tts(tts.as_slice(), fm);\n+                let mac_span = original_span(fld.cx);\n+                let expanded = match expander.expand(fld.cx,\n+                                    mac_span.call_site,\n+                                    marked_before.as_slice()).make_pat() {\n+                    Some(e) => e,\n+                    None => {\n+                        fld.cx.span_err(\n+                            pth.span,\n+                            format!(\n+                                \"non-pattern macro in pattern position: {}\",\n+                                extnamestr.get()\n+                            ).as_slice()\n+                        );\n+                        return DummyResult::raw_pat(p.span);\n+                    }\n+                };\n+\n+                // mark after:\n+                mark_pat(expanded,fm)\n+            }\n+            _ => {\n+                fld.cx.span_err(p.span,\n+                                format!(\"{}! is not legal in pattern position\",\n+                                        extnamestr.get()).as_slice());\n+                return DummyResult::raw_pat(p.span);\n+            }\n         }\n     };\n \n@@ -975,7 +987,6 @@ fn expand_and_rename_fn_decl_and_block(fn_decl: &ast::FnDecl, block: Gc<ast::Blo\n \n /// A tree-folder that performs macro expansion\n pub struct MacroExpander<'a, 'b> {\n-    pub extsbox: SyntaxEnv,\n     pub cx: &'a mut ExtCtxt<'b>,\n }\n \n@@ -1044,7 +1055,6 @@ pub fn expand_crate(parse_sess: &parse::ParseSess,\n                     c: Crate) -> Crate {\n     let mut cx = ExtCtxt::new(parse_sess, c.config.clone(), cfg);\n     let mut expander = MacroExpander {\n-        extsbox: syntax_expander_table(),\n         cx: &mut cx,\n     };\n \n@@ -1063,7 +1073,7 @@ pub fn expand_crate(parse_sess: &parse::ParseSess,\n     }\n \n     for (name, extension) in user_exts.move_iter() {\n-        expander.extsbox.insert(name, extension);\n+        expander.cx.syntax_env.insert(name, extension);\n     }\n \n     let mut ret = expander.fold_crate(c);"}]}