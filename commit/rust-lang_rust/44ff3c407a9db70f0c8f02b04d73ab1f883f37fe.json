{"sha": "44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "node_id": "C_kwDOAAsO6NoAKDQ0ZmYzYzQwN2E5ZGI3MGYwYzhmMDJiMDRkNzNhYjFmODgzZjM3ZmU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-07T09:49:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-07T09:49:49Z"}, "message": "Auto merge of #14232 - HKalbasi:mir, r=Veykril\n\nMIR episode 2\n\nThis PR adds:\n1. `need-mut` and `unused-mut` diagnostics\n2. `View mir` command which shows MIR for the body under cursor, useful for debugging\n3. MIR lowering for or-patterns and for-loops", "tree": {"sha": "7448ecc21d6428cd3f4bbf07859a5a44ad8703b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7448ecc21d6428cd3f4bbf07859a5a44ad8703b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "html_url": "https://github.com/rust-lang/rust/commit/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "31c12ec282de5e2d4e835f320f8858277b3ba133", "url": "https://api.github.com/repos/rust-lang/rust/commits/31c12ec282de5e2d4e835f320f8858277b3ba133", "html_url": "https://github.com/rust-lang/rust/commit/31c12ec282de5e2d4e835f320f8858277b3ba133"}, {"sha": "bcd7ecb242cb546c83a40c1a3341543f1ed71064", "url": "https://api.github.com/repos/rust-lang/rust/commits/bcd7ecb242cb546c83a40c1a3341543f1ed71064", "html_url": "https://github.com/rust-lang/rust/commit/bcd7ecb242cb546c83a40c1a3341543f1ed71064"}], "stats": {"total": 3924, "additions": 3164, "deletions": 760}, "files": [{"sha": "545d2bebf5f0d6349bf92d0ced03b36350ccd625", "filename": "crates/hir-def/src/body.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir-def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir-def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody.rs?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -24,7 +24,7 @@ use syntax::{ast, AstPtr, SyntaxNode, SyntaxNodePtr};\n use crate::{\n     attr::Attrs,\n     db::DefDatabase,\n-    expr::{dummy_expr_id, Expr, ExprId, Label, LabelId, Pat, PatId},\n+    expr::{dummy_expr_id, Binding, BindingId, Expr, ExprId, Label, LabelId, Pat, PatId},\n     item_scope::BuiltinShadowMode,\n     macro_id_to_def_id,\n     nameres::DefMap,\n@@ -270,6 +270,7 @@ pub struct Mark {\n pub struct Body {\n     pub exprs: Arena<Expr>,\n     pub pats: Arena<Pat>,\n+    pub bindings: Arena<Binding>,\n     pub or_pats: FxHashMap<PatId, Arc<[PatId]>>,\n     pub labels: Arena<Label>,\n     /// The patterns for the function's parameters. While the parameter types are\n@@ -435,13 +436,24 @@ impl Body {\n     }\n \n     fn shrink_to_fit(&mut self) {\n-        let Self { _c: _, body_expr: _, block_scopes, or_pats, exprs, labels, params, pats } = self;\n+        let Self {\n+            _c: _,\n+            body_expr: _,\n+            block_scopes,\n+            or_pats,\n+            exprs,\n+            labels,\n+            params,\n+            pats,\n+            bindings,\n+        } = self;\n         block_scopes.shrink_to_fit();\n         or_pats.shrink_to_fit();\n         exprs.shrink_to_fit();\n         labels.shrink_to_fit();\n         params.shrink_to_fit();\n         pats.shrink_to_fit();\n+        bindings.shrink_to_fit();\n     }\n }\n \n@@ -451,6 +463,7 @@ impl Default for Body {\n             body_expr: dummy_expr_id(),\n             exprs: Default::default(),\n             pats: Default::default(),\n+            bindings: Default::default(),\n             or_pats: Default::default(),\n             labels: Default::default(),\n             params: Default::default(),\n@@ -484,6 +497,14 @@ impl Index<LabelId> for Body {\n     }\n }\n \n+impl Index<BindingId> for Body {\n+    type Output = Binding;\n+\n+    fn index(&self, b: BindingId) -> &Binding {\n+        &self.bindings[b]\n+    }\n+}\n+\n // FIXME: Change `node_` prefix to something more reasonable.\n // Perhaps `expr_syntax` and `expr_id`?\n impl BodySourceMap {"}, {"sha": "b7458bfb8a7b439d7b9a5602420ca1f62db99c54", "filename": "crates/hir-def/src/body/lower.rs", "status": "modified", "additions": 80, "deletions": 37, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -15,6 +15,7 @@ use la_arena::Arena;\n use once_cell::unsync::OnceCell;\n use profile::Count;\n use rustc_hash::FxHashMap;\n+use smallvec::SmallVec;\n use syntax::{\n     ast::{\n         self, ArrayExprKind, AstChildren, HasArgList, HasLoopBody, HasName, LiteralKind,\n@@ -30,9 +31,9 @@ use crate::{\n     builtin_type::{BuiltinFloat, BuiltinInt, BuiltinUint},\n     db::DefDatabase,\n     expr::{\n-        dummy_expr_id, Array, BindingAnnotation, ClosureKind, Expr, ExprId, FloatTypeWrapper,\n-        Label, LabelId, Literal, MatchArm, Movability, Pat, PatId, RecordFieldPat, RecordLitField,\n-        Statement,\n+        dummy_expr_id, Array, Binding, BindingAnnotation, BindingId, ClosureKind, Expr, ExprId,\n+        FloatTypeWrapper, Label, LabelId, Literal, MatchArm, Movability, Pat, PatId,\n+        RecordFieldPat, RecordLitField, Statement,\n     },\n     item_scope::BuiltinShadowMode,\n     path::{GenericArgs, Path},\n@@ -87,6 +88,7 @@ pub(super) fn lower(\n         body: Body {\n             exprs: Arena::default(),\n             pats: Arena::default(),\n+            bindings: Arena::default(),\n             labels: Arena::default(),\n             params: Vec::new(),\n             body_expr: dummy_expr_id(),\n@@ -116,6 +118,22 @@ struct ExprCollector<'a> {\n     is_lowering_generator: bool,\n }\n \n+#[derive(Debug, Default)]\n+struct BindingList {\n+    map: FxHashMap<Name, BindingId>,\n+}\n+\n+impl BindingList {\n+    fn find(\n+        &mut self,\n+        ec: &mut ExprCollector<'_>,\n+        name: Name,\n+        mode: BindingAnnotation,\n+    ) -> BindingId {\n+        *self.map.entry(name).or_insert_with_key(|n| ec.alloc_binding(n.clone(), mode))\n+    }\n+}\n+\n impl ExprCollector<'_> {\n     fn collect(\n         mut self,\n@@ -127,17 +145,16 @@ impl ExprCollector<'_> {\n                 param_list.self_param().filter(|_| attr_enabled.next().unwrap_or(false))\n             {\n                 let ptr = AstPtr::new(&self_param);\n-                let param_pat = self.alloc_pat(\n-                    Pat::Bind {\n-                        name: name![self],\n-                        mode: BindingAnnotation::new(\n-                            self_param.mut_token().is_some() && self_param.amp_token().is_none(),\n-                            false,\n-                        ),\n-                        subpat: None,\n-                    },\n-                    Either::Right(ptr),\n+                let binding_id = self.alloc_binding(\n+                    name![self],\n+                    BindingAnnotation::new(\n+                        self_param.mut_token().is_some() && self_param.amp_token().is_none(),\n+                        false,\n+                    ),\n                 );\n+                let param_pat =\n+                    self.alloc_pat(Pat::Bind { id: binding_id, subpat: None }, Either::Right(ptr));\n+                self.add_definition_to_binding(binding_id, param_pat);\n                 self.body.params.push(param_pat);\n             }\n \n@@ -179,6 +196,9 @@ impl ExprCollector<'_> {\n         id\n     }\n \n+    fn alloc_binding(&mut self, name: Name, mode: BindingAnnotation) -> BindingId {\n+        self.body.bindings.alloc(Binding { name, mode, definitions: SmallVec::new() })\n+    }\n     fn alloc_pat(&mut self, pat: Pat, ptr: PatPtr) -> PatId {\n         let src = self.expander.to_source(ptr);\n         let id = self.make_pat(pat, src.clone());\n@@ -804,7 +824,7 @@ impl ExprCollector<'_> {\n     }\n \n     fn collect_pat(&mut self, pat: ast::Pat) -> PatId {\n-        let pat_id = self.collect_pat_(pat);\n+        let pat_id = self.collect_pat_(pat, &mut BindingList::default());\n         for (_, pats) in self.name_to_pat_grouping.drain() {\n             let pats = Arc::<[_]>::from(pats);\n             self.body.or_pats.extend(pats.iter().map(|&pat| (pat, pats.clone())));\n@@ -820,16 +840,18 @@ impl ExprCollector<'_> {\n         }\n     }\n \n-    fn collect_pat_(&mut self, pat: ast::Pat) -> PatId {\n+    fn collect_pat_(&mut self, pat: ast::Pat, binding_list: &mut BindingList) -> PatId {\n         let pattern = match &pat {\n             ast::Pat::IdentPat(bp) => {\n                 let name = bp.name().map(|nr| nr.as_name()).unwrap_or_else(Name::missing);\n \n                 let key = self.is_lowering_inside_or_pat.then(|| name.clone());\n                 let annotation =\n                     BindingAnnotation::new(bp.mut_token().is_some(), bp.ref_token().is_some());\n-                let subpat = bp.pat().map(|subpat| self.collect_pat_(subpat));\n-                let pattern = if annotation == BindingAnnotation::Unannotated && subpat.is_none() {\n+                let subpat = bp.pat().map(|subpat| self.collect_pat_(subpat, binding_list));\n+                let (binding, pattern) = if annotation == BindingAnnotation::Unannotated\n+                    && subpat.is_none()\n+                {\n                     // This could also be a single-segment path pattern. To\n                     // decide that, we need to try resolving the name.\n                     let (resolved, _) = self.expander.def_map.resolve_path(\n@@ -839,30 +861,37 @@ impl ExprCollector<'_> {\n                         BuiltinShadowMode::Other,\n                     );\n                     match resolved.take_values() {\n-                        Some(ModuleDefId::ConstId(_)) => Pat::Path(name.into()),\n+                        Some(ModuleDefId::ConstId(_)) => (None, Pat::Path(name.into())),\n                         Some(ModuleDefId::EnumVariantId(_)) => {\n                             // this is only really valid for unit variants, but\n                             // shadowing other enum variants with a pattern is\n                             // an error anyway\n-                            Pat::Path(name.into())\n+                            (None, Pat::Path(name.into()))\n                         }\n                         Some(ModuleDefId::AdtId(AdtId::StructId(s)))\n                             if self.db.struct_data(s).variant_data.kind() != StructKind::Record =>\n                         {\n                             // Funnily enough, record structs *can* be shadowed\n                             // by pattern bindings (but unit or tuple structs\n                             // can't).\n-                            Pat::Path(name.into())\n+                            (None, Pat::Path(name.into()))\n                         }\n                         // shadowing statics is an error as well, so we just ignore that case here\n-                        _ => Pat::Bind { name, mode: annotation, subpat },\n+                        _ => {\n+                            let id = binding_list.find(self, name, annotation);\n+                            (Some(id), Pat::Bind { id, subpat })\n+                        }\n                     }\n                 } else {\n-                    Pat::Bind { name, mode: annotation, subpat }\n+                    let id = binding_list.find(self, name, annotation);\n+                    (Some(id), Pat::Bind { id, subpat })\n                 };\n \n                 let ptr = AstPtr::new(&pat);\n                 let pat = self.alloc_pat(pattern, Either::Left(ptr));\n+                if let Some(binding_id) = binding {\n+                    self.add_definition_to_binding(binding_id, pat);\n+                }\n                 if let Some(key) = key {\n                     self.name_to_pat_grouping.entry(key).or_default().push(pat);\n                 }\n@@ -871,11 +900,11 @@ impl ExprCollector<'_> {\n             ast::Pat::TupleStructPat(p) => {\n                 let path =\n                     p.path().and_then(|path| self.expander.parse_path(self.db, path)).map(Box::new);\n-                let (args, ellipsis) = self.collect_tuple_pat(p.fields());\n+                let (args, ellipsis) = self.collect_tuple_pat(p.fields(), binding_list);\n                 Pat::TupleStruct { path, args, ellipsis }\n             }\n             ast::Pat::RefPat(p) => {\n-                let pat = self.collect_pat_opt(p.pat());\n+                let pat = self.collect_pat_opt_(p.pat(), binding_list);\n                 let mutability = Mutability::from_mutable(p.mut_token().is_some());\n                 Pat::Ref { pat, mutability }\n             }\n@@ -886,12 +915,12 @@ impl ExprCollector<'_> {\n             }\n             ast::Pat::OrPat(p) => {\n                 self.is_lowering_inside_or_pat = true;\n-                let pats = p.pats().map(|p| self.collect_pat_(p)).collect();\n+                let pats = p.pats().map(|p| self.collect_pat_(p, binding_list)).collect();\n                 Pat::Or(pats)\n             }\n-            ast::Pat::ParenPat(p) => return self.collect_pat_opt_(p.pat()),\n+            ast::Pat::ParenPat(p) => return self.collect_pat_opt_(p.pat(), binding_list),\n             ast::Pat::TuplePat(p) => {\n-                let (args, ellipsis) = self.collect_tuple_pat(p.fields());\n+                let (args, ellipsis) = self.collect_tuple_pat(p.fields(), binding_list);\n                 Pat::Tuple { args, ellipsis }\n             }\n             ast::Pat::WildcardPat(_) => Pat::Wild,\n@@ -904,7 +933,7 @@ impl ExprCollector<'_> {\n                     .fields()\n                     .filter_map(|f| {\n                         let ast_pat = f.pat()?;\n-                        let pat = self.collect_pat_(ast_pat);\n+                        let pat = self.collect_pat_(ast_pat, binding_list);\n                         let name = f.field_name()?.as_name();\n                         Some(RecordFieldPat { name, pat })\n                     })\n@@ -923,9 +952,15 @@ impl ExprCollector<'_> {\n \n                 // FIXME properly handle `RestPat`\n                 Pat::Slice {\n-                    prefix: prefix.into_iter().map(|p| self.collect_pat_(p)).collect(),\n-                    slice: slice.map(|p| self.collect_pat_(p)),\n-                    suffix: suffix.into_iter().map(|p| self.collect_pat_(p)).collect(),\n+                    prefix: prefix\n+                        .into_iter()\n+                        .map(|p| self.collect_pat_(p, binding_list))\n+                        .collect(),\n+                    slice: slice.map(|p| self.collect_pat_(p, binding_list)),\n+                    suffix: suffix\n+                        .into_iter()\n+                        .map(|p| self.collect_pat_(p, binding_list))\n+                        .collect(),\n                 }\n             }\n             ast::Pat::LiteralPat(lit) => {\n@@ -948,7 +983,7 @@ impl ExprCollector<'_> {\n                 Pat::Missing\n             }\n             ast::Pat::BoxPat(boxpat) => {\n-                let inner = self.collect_pat_opt_(boxpat.pat());\n+                let inner = self.collect_pat_opt_(boxpat.pat(), binding_list);\n                 Pat::Box { inner }\n             }\n             ast::Pat::ConstBlockPat(const_block_pat) => {\n@@ -965,7 +1000,7 @@ impl ExprCollector<'_> {\n                     let src = self.expander.to_source(Either::Left(AstPtr::new(&pat)));\n                     let pat =\n                         self.collect_macro_call(call, macro_ptr, true, |this, expanded_pat| {\n-                            this.collect_pat_opt_(expanded_pat)\n+                            this.collect_pat_opt_(expanded_pat, binding_list)\n                         });\n                     self.source_map.pat_map.insert(src, pat);\n                     return pat;\n@@ -979,21 +1014,25 @@ impl ExprCollector<'_> {\n         self.alloc_pat(pattern, Either::Left(ptr))\n     }\n \n-    fn collect_pat_opt_(&mut self, pat: Option<ast::Pat>) -> PatId {\n+    fn collect_pat_opt_(&mut self, pat: Option<ast::Pat>, binding_list: &mut BindingList) -> PatId {\n         match pat {\n-            Some(pat) => self.collect_pat_(pat),\n+            Some(pat) => self.collect_pat_(pat, binding_list),\n             None => self.missing_pat(),\n         }\n     }\n \n-    fn collect_tuple_pat(&mut self, args: AstChildren<ast::Pat>) -> (Box<[PatId]>, Option<usize>) {\n+    fn collect_tuple_pat(\n+        &mut self,\n+        args: AstChildren<ast::Pat>,\n+        binding_list: &mut BindingList,\n+    ) -> (Box<[PatId]>, Option<usize>) {\n         // Find the location of the `..`, if there is one. Note that we do not\n         // consider the possibility of there being multiple `..` here.\n         let ellipsis = args.clone().position(|p| matches!(p, ast::Pat::RestPat(_)));\n         // We want to skip the `..` pattern here, since we account for it above.\n         let args = args\n             .filter(|p| !matches!(p, ast::Pat::RestPat(_)))\n-            .map(|p| self.collect_pat_(p))\n+            .map(|p| self.collect_pat_(p, binding_list))\n             .collect();\n \n         (args, ellipsis)\n@@ -1022,6 +1061,10 @@ impl ExprCollector<'_> {\n             None => Some(()),\n         }\n     }\n+\n+    fn add_definition_to_binding(&mut self, binding_id: BindingId, pat_id: PatId) {\n+        self.body.bindings[binding_id].definitions.push(pat_id);\n+    }\n }\n \n impl From<ast::LiteralKind> for Literal {"}, {"sha": "f8b159797e44afef0110905b6205bc88962c050a", "filename": "crates/hir-def/src/body/pretty.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -5,7 +5,7 @@ use std::fmt::{self, Write};\n use syntax::ast::HasName;\n \n use crate::{\n-    expr::{Array, BindingAnnotation, ClosureKind, Literal, Movability, Statement},\n+    expr::{Array, BindingAnnotation, BindingId, ClosureKind, Literal, Movability, Statement},\n     pretty::{print_generic_args, print_path, print_type_ref},\n     type_ref::TypeRef,\n };\n@@ -524,14 +524,8 @@ impl<'a> Printer<'a> {\n             }\n             Pat::Path(path) => self.print_path(path),\n             Pat::Lit(expr) => self.print_expr(*expr),\n-            Pat::Bind { mode, name, subpat } => {\n-                let mode = match mode {\n-                    BindingAnnotation::Unannotated => \"\",\n-                    BindingAnnotation::Mutable => \"mut \",\n-                    BindingAnnotation::Ref => \"ref \",\n-                    BindingAnnotation::RefMut => \"ref mut \",\n-                };\n-                w!(self, \"{}{}\", mode, name);\n+            Pat::Bind { id, subpat } => {\n+                self.print_binding(*id);\n                 if let Some(pat) = subpat {\n                     self.whitespace();\n                     self.print_pat(*pat);\n@@ -635,4 +629,15 @@ impl<'a> Printer<'a> {\n     fn print_path(&mut self, path: &Path) {\n         print_path(path, self).unwrap();\n     }\n+\n+    fn print_binding(&mut self, id: BindingId) {\n+        let Binding { name, mode, .. } = &self.body.bindings[id];\n+        let mode = match mode {\n+            BindingAnnotation::Unannotated => \"\",\n+            BindingAnnotation::Mutable => \"mut \",\n+            BindingAnnotation::Ref => \"ref \",\n+            BindingAnnotation::RefMut => \"ref mut \",\n+        };\n+        w!(self, \"{}{}\", mode, name);\n+    }\n }"}, {"sha": "12fc1f116d7dac0cbfe98fcaa94d4c63b03ab7ed", "filename": "crates/hir-def/src/body/scope.rs", "status": "modified", "additions": 23, "deletions": 16, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -8,7 +8,7 @@ use rustc_hash::FxHashMap;\n use crate::{\n     body::Body,\n     db::DefDatabase,\n-    expr::{Expr, ExprId, LabelId, Pat, PatId, Statement},\n+    expr::{Binding, BindingId, Expr, ExprId, LabelId, Pat, PatId, Statement},\n     BlockId, DefWithBodyId,\n };\n \n@@ -23,16 +23,16 @@ pub struct ExprScopes {\n #[derive(Debug, PartialEq, Eq)]\n pub struct ScopeEntry {\n     name: Name,\n-    pat: PatId,\n+    binding: BindingId,\n }\n \n impl ScopeEntry {\n     pub fn name(&self) -> &Name {\n         &self.name\n     }\n \n-    pub fn pat(&self) -> PatId {\n-        self.pat\n+    pub fn binding(&self) -> BindingId {\n+        self.binding\n     }\n }\n \n@@ -126,18 +126,23 @@ impl ExprScopes {\n         })\n     }\n \n-    fn add_bindings(&mut self, body: &Body, scope: ScopeId, pat: PatId) {\n+    fn add_bindings(&mut self, body: &Body, scope: ScopeId, binding: BindingId) {\n+        let Binding { name, .. } = &body.bindings[binding];\n+        let entry = ScopeEntry { name: name.clone(), binding };\n+        self.scopes[scope].entries.push(entry);\n+    }\n+\n+    fn add_pat_bindings(&mut self, body: &Body, scope: ScopeId, pat: PatId) {\n         let pattern = &body[pat];\n-        if let Pat::Bind { name, .. } = pattern {\n-            let entry = ScopeEntry { name: name.clone(), pat };\n-            self.scopes[scope].entries.push(entry);\n+        if let Pat::Bind { id, .. } = pattern {\n+            self.add_bindings(body, scope, *id);\n         }\n \n-        pattern.walk_child_pats(|pat| self.add_bindings(body, scope, pat));\n+        pattern.walk_child_pats(|pat| self.add_pat_bindings(body, scope, pat));\n     }\n \n     fn add_params_bindings(&mut self, body: &Body, scope: ScopeId, params: &[PatId]) {\n-        params.iter().for_each(|pat| self.add_bindings(body, scope, *pat));\n+        params.iter().for_each(|pat| self.add_pat_bindings(body, scope, *pat));\n     }\n \n     fn set_scope(&mut self, node: ExprId, scope: ScopeId) {\n@@ -170,7 +175,7 @@ fn compute_block_scopes(\n                 }\n \n                 *scope = scopes.new_scope(*scope);\n-                scopes.add_bindings(body, *scope, *pat);\n+                scopes.add_pat_bindings(body, *scope, *pat);\n             }\n             Statement::Expr { expr, .. } => {\n                 compute_expr_scopes(*expr, body, scopes, scope);\n@@ -208,7 +213,7 @@ fn compute_expr_scopes(expr: ExprId, body: &Body, scopes: &mut ExprScopes, scope\n         Expr::For { iterable, pat, body: body_expr, label } => {\n             compute_expr_scopes(*iterable, body, scopes, scope);\n             let mut scope = scopes.new_labeled_scope(*scope, make_label(label));\n-            scopes.add_bindings(body, scope, *pat);\n+            scopes.add_pat_bindings(body, scope, *pat);\n             compute_expr_scopes(*body_expr, body, scopes, &mut scope);\n         }\n         Expr::While { condition, body: body_expr, label } => {\n@@ -229,7 +234,7 @@ fn compute_expr_scopes(expr: ExprId, body: &Body, scopes: &mut ExprScopes, scope\n             compute_expr_scopes(*expr, body, scopes, scope);\n             for arm in arms.iter() {\n                 let mut scope = scopes.new_scope(*scope);\n-                scopes.add_bindings(body, scope, arm.pat);\n+                scopes.add_pat_bindings(body, scope, arm.pat);\n                 if let Some(guard) = arm.guard {\n                     scope = scopes.new_scope(scope);\n                     compute_expr_scopes(guard, body, scopes, &mut scope);\n@@ -248,7 +253,7 @@ fn compute_expr_scopes(expr: ExprId, body: &Body, scopes: &mut ExprScopes, scope\n         &Expr::Let { pat, expr } => {\n             compute_expr_scopes(expr, body, scopes, scope);\n             *scope = scopes.new_scope(*scope);\n-            scopes.add_bindings(body, *scope, pat);\n+            scopes.add_pat_bindings(body, *scope, pat);\n         }\n         e => e.walk_child_exprs(|e| compute_expr_scopes(e, body, scopes, scope)),\n     };\n@@ -450,7 +455,7 @@ fn foo() {\n         let function = find_function(&db, file_id);\n \n         let scopes = db.expr_scopes(function.into());\n-        let (_body, source_map) = db.body_with_source_map(function.into());\n+        let (body, source_map) = db.body_with_source_map(function.into());\n \n         let expr_scope = {\n             let expr_ast = name_ref.syntax().ancestors().find_map(ast::Expr::cast).unwrap();\n@@ -460,7 +465,9 @@ fn foo() {\n         };\n \n         let resolved = scopes.resolve_name_in_scope(expr_scope, &name_ref.as_name()).unwrap();\n-        let pat_src = source_map.pat_syntax(resolved.pat()).unwrap();\n+        let pat_src = source_map\n+            .pat_syntax(*body.bindings[resolved.binding()].definitions.first().unwrap())\n+            .unwrap();\n \n         let local_name = pat_src.value.either(\n             |it| it.syntax_node_ptr().to_node(file.syntax()),"}, {"sha": "bbea608c55eb5b40894f88ed1b7379b755133835", "filename": "crates/hir-def/src/expr.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir-def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir-def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fexpr.rs?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -17,6 +17,7 @@ use std::fmt;\n use hir_expand::name::Name;\n use intern::Interned;\n use la_arena::{Idx, RawIdx};\n+use smallvec::SmallVec;\n \n use crate::{\n     builtin_type::{BuiltinFloat, BuiltinInt, BuiltinUint},\n@@ -29,6 +30,8 @@ pub use syntax::ast::{ArithOp, BinaryOp, CmpOp, LogicOp, Ordering, RangeOp, Unar\n \n pub type ExprId = Idx<Expr>;\n \n+pub type BindingId = Idx<Binding>;\n+\n /// FIXME: this is a hacky function which should be removed\n pub(crate) fn dummy_expr_id() -> ExprId {\n     ExprId::from_raw(RawIdx::from(u32::MAX))\n@@ -433,6 +436,13 @@ impl BindingAnnotation {\n     }\n }\n \n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct Binding {\n+    pub name: Name,\n+    pub mode: BindingAnnotation,\n+    pub definitions: SmallVec<[PatId; 1]>,\n+}\n+\n #[derive(Debug, Clone, Eq, PartialEq)]\n pub struct RecordFieldPat {\n     pub name: Name,\n@@ -451,7 +461,7 @@ pub enum Pat {\n     Slice { prefix: Box<[PatId]>, slice: Option<PatId>, suffix: Box<[PatId]> },\n     Path(Box<Path>),\n     Lit(ExprId),\n-    Bind { mode: BindingAnnotation, name: Name, subpat: Option<PatId> },\n+    Bind { id: BindingId, subpat: Option<PatId> },\n     TupleStruct { path: Option<Box<Path>>, args: Box<[PatId]>, ellipsis: Option<usize> },\n     Ref { pat: PatId, mutability: Mutability },\n     Box { inner: PatId },"}, {"sha": "61e64fc10363114c96c3877a8a8cef2a7a2a3d63", "filename": "crates/hir-def/src/resolver.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir-def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir-def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fresolver.rs?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -12,7 +12,7 @@ use crate::{\n     body::scope::{ExprScopes, ScopeId},\n     builtin_type::BuiltinType,\n     db::DefDatabase,\n-    expr::{ExprId, LabelId, PatId},\n+    expr::{BindingId, ExprId, LabelId},\n     generics::{GenericParams, TypeOrConstParamData},\n     item_scope::{BuiltinShadowMode, BUILTIN_SCOPE},\n     nameres::DefMap,\n@@ -105,7 +105,7 @@ pub enum ResolveValueResult {\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub enum ValueNs {\n     ImplSelf(ImplId),\n-    LocalBinding(PatId),\n+    LocalBinding(BindingId),\n     FunctionId(FunctionId),\n     ConstId(ConstId),\n     StaticId(StaticId),\n@@ -267,7 +267,7 @@ impl Resolver {\n \n                         if let Some(e) = entry {\n                             return Some(ResolveValueResult::ValueNs(ValueNs::LocalBinding(\n-                                e.pat(),\n+                                e.binding(),\n                             )));\n                         }\n                     }\n@@ -617,7 +617,7 @@ pub enum ScopeDef {\n     ImplSelfType(ImplId),\n     AdtSelfType(AdtId),\n     GenericParam(GenericParamId),\n-    Local(PatId),\n+    Local(BindingId),\n     Label(LabelId),\n }\n \n@@ -669,7 +669,7 @@ impl Scope {\n                     acc.add(&name, ScopeDef::Label(label))\n                 }\n                 scope.expr_scopes.entries(scope.scope_id).iter().for_each(|e| {\n-                    acc.add_local(e.name(), e.pat());\n+                    acc.add_local(e.name(), e.binding());\n                 });\n             }\n         }\n@@ -859,7 +859,7 @@ impl ScopeNames {\n             self.add(name, ScopeDef::Unknown)\n         }\n     }\n-    fn add_local(&mut self, name: &Name, pat: PatId) {\n+    fn add_local(&mut self, name: &Name, binding: BindingId) {\n         let set = self.map.entry(name.clone()).or_default();\n         // XXX: hack, account for local (and only local) shadowing.\n         //\n@@ -870,7 +870,7 @@ impl ScopeNames {\n             cov_mark::hit!(shadowing_shows_single_completion);\n             return;\n         }\n-        set.push(ScopeDef::Local(pat))\n+        set.push(ScopeDef::Local(binding))\n     }\n }\n "}, {"sha": "f2e42d6e5035b3fd85d6a338db2feaaab14c61a5", "filename": "crates/hir-ty/src/consteval/tests.rs", "status": "modified", "additions": 249, "deletions": 10, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -103,6 +103,22 @@ fn references() {\n     \"#,\n         5,\n     );\n+    check_number(\n+        r#\"\n+    struct Foo(i32);\n+    impl Foo {\n+        fn method(&mut self, x: i32) {\n+            self.0 = 2 * self.0 + x;\n+        }\n+    }\n+    const GOAL: i32 = {\n+        let mut x = Foo(3);\n+        x.method(5);\n+        x.0\n+    };\n+    \"#,\n+        11,\n+    );\n }\n \n #[test]\n@@ -132,6 +148,60 @@ fn reference_autoderef() {\n     );\n }\n \n+#[test]\n+fn overloaded_deref() {\n+    // FIXME: We should support this.\n+    check_fail(\n+        r#\"\n+    //- minicore: deref_mut\n+    struct Foo;\n+\n+    impl core::ops::Deref for Foo {\n+        type Target = i32;\n+        fn deref(&self) -> &i32 {\n+            &5\n+        }\n+    }\n+\n+    const GOAL: i32 = {\n+        let x = Foo;\n+        let y = &*x;\n+        *y + *x\n+    };\n+    \"#,\n+        ConstEvalError::MirLowerError(MirLowerError::NotSupported(\n+            \"explicit overloaded deref\".into(),\n+        )),\n+    );\n+}\n+\n+#[test]\n+fn overloaded_deref_autoref() {\n+    check_number(\n+        r#\"\n+    //- minicore: deref_mut\n+    struct Foo;\n+    struct Bar;\n+\n+    impl core::ops::Deref for Foo {\n+        type Target = Bar;\n+        fn deref(&self) -> &Bar {\n+            &Bar\n+        }\n+    }\n+\n+    impl Bar {\n+        fn method(&self) -> i32 {\n+            5\n+        }\n+    }\n+\n+    const GOAL: i32 = Foo.method();\n+    \"#,\n+        5,\n+    );\n+}\n+\n #[test]\n fn function_call() {\n     check_number(\n@@ -358,15 +428,15 @@ fn ifs() {\n         if a < b { b } else { a }\n     }\n \n-    const GOAL: u8 = max(max(1, max(10, 3)), 0-122);\n+    const GOAL: i32 = max(max(1, max(10, 3)), 0-122);\n         \"#,\n         10,\n     );\n \n     check_number(\n         r#\"\n     const fn max(a: &i32, b: &i32) -> &i32 {\n-        if a < b { b } else { a }\n+        if *a < *b { b } else { a }\n     }\n \n     const GOAL: i32 = *max(max(&1, max(&10, &3)), &5);\n@@ -399,6 +469,43 @@ fn loops() {\n     );\n }\n \n+#[test]\n+fn for_loops() {\n+    check_number(\n+        r#\"\n+    //- minicore: iterator\n+\n+    struct Range {\n+        start: u8,\n+        end: u8,\n+    }\n+\n+    impl Iterator for Range {\n+        type Item = u8;\n+        fn next(&mut self) -> Option<u8> {\n+            if self.start >= self.end {\n+                None\n+            } else {\n+                let r = self.start;\n+                self.start = self.start + 1;\n+                Some(r)\n+            }\n+        }\n+    }\n+\n+    const GOAL: u8 = {\n+        let mut sum = 0;\n+        let ar = Range { start: 1, end: 11 };\n+        for i in ar {\n+            sum = sum + i;\n+        }\n+        sum\n+    };\n+        \"#,\n+        55,\n+    );\n+}\n+\n #[test]\n fn recursion() {\n     check_number(\n@@ -464,6 +571,16 @@ fn tuples() {\n         \"#,\n         20,\n     );\n+    check_number(\n+        r#\"\n+    const GOAL: u8 = {\n+        let mut a = (10, 20, 3, 15);\n+        a.1 = 2;\n+        a.0 + a.1 + a.2 + a.3\n+    };\n+        \"#,\n+        30,\n+    );\n     check_number(\n         r#\"\n     struct TupleLike(i32, u8, i64, u16);\n@@ -492,6 +609,33 @@ fn tuples() {\n     );\n }\n \n+#[test]\n+fn path_pattern_matching() {\n+    check_number(\n+        r#\"\n+    enum Season {\n+        Spring,\n+        Summer,\n+        Fall,\n+        Winter,\n+    }\n+\n+    use Season::*;\n+\n+    const fn f(x: Season) -> i32 {\n+        match x {\n+            Spring => 1,\n+            Summer => 2,\n+            Fall => 3,\n+            Winter => 4,\n+        }\n+    }\n+    const GOAL: i32 = f(Spring) + 10 * f(Summer) + 100 * f(Fall) + 1000 * f(Winter);\n+        \"#,\n+        4321,\n+    );\n+}\n+\n #[test]\n fn pattern_matching_ergonomics() {\n     check_number(\n@@ -539,12 +683,55 @@ fn let_else() {\n         let Some(x) = x else { return 10 };\n         2 * x\n     }\n-    const GOAL: u8 = f(Some(1000)) + f(None);\n+    const GOAL: i32 = f(Some(1000)) + f(None);\n         \"#,\n         2010,\n     );\n }\n \n+#[test]\n+fn function_param_patterns() {\n+    check_number(\n+        r#\"\n+    const fn f((a, b): &(u8, u8)) -> u8 {\n+        *a + *b\n+    }\n+    const GOAL: u8 = f(&(2, 3));\n+        \"#,\n+        5,\n+    );\n+    check_number(\n+        r#\"\n+    const fn f(c @ (a, b): &(u8, u8)) -> u8 {\n+        *a + *b + c.0 + (*c).1\n+    }\n+    const GOAL: u8 = f(&(2, 3));\n+        \"#,\n+        10,\n+    );\n+    check_number(\n+        r#\"\n+    const fn f(ref a: u8) -> u8 {\n+        *a\n+    }\n+    const GOAL: u8 = f(2);\n+        \"#,\n+        2,\n+    );\n+    check_number(\n+        r#\"\n+    struct Foo(u8);\n+    impl Foo {\n+        const fn f(&self, (a, b): &(u8, u8)) -> u8 {\n+            self.0 + *a + *b\n+        }\n+    }\n+    const GOAL: u8 = Foo(4).f(&(2, 3));\n+        \"#,\n+        9,\n+    );\n+}\n+\n #[test]\n fn options() {\n     check_number(\n@@ -572,7 +759,7 @@ fn options() {\n             0\n         }\n     }\n-    const GOAL: u8 = f(Some(Some(10))) + f(Some(None)) + f(None);\n+    const GOAL: i32 = f(Some(Some(10))) + f(Some(None)) + f(None);\n         \"#,\n         11,\n     );\n@@ -598,6 +785,44 @@ fn options() {\n     );\n }\n \n+#[test]\n+fn or_pattern() {\n+    check_number(\n+        r#\"\n+    const GOAL: u8 = {\n+        let (a | a) = 2;\n+        a\n+    };\n+        \"#,\n+        2,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: option\n+    const fn f(x: Option<i32>) -> i32 {\n+        let (Some(a) | Some(a)) = x else { return 2; };\n+        a\n+    }\n+    const GOAL: i32 = f(Some(10)) + f(None);\n+        \"#,\n+        12,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: option\n+    const fn f(x: Option<i32>, y: Option<i32>) -> i32 {\n+        match (x, y) {\n+            (Some(x), Some(y)) => x * y,\n+            (Some(a), _) | (_, Some(a)) => a,\n+            _ => 10,\n+        }\n+    }\n+    const GOAL: i32 = f(Some(10), Some(20)) + f(Some(30), None) + f(None, Some(40)) + f(None, None);\n+        \"#,\n+        280,\n+    );\n+}\n+\n #[test]\n fn array_and_index() {\n     check_number(\n@@ -665,24 +890,24 @@ fn enums() {\n         r#\"\n     enum E {\n         F1 = 1,\n-        F2 = 2 * E::F1 as u8,\n-        F3 = 3 * E::F2 as u8,\n+        F2 = 2 * E::F1 as isize, // Rustc expects an isize here\n+        F3 = 3 * E::F2 as isize,\n     }\n-    const GOAL: i32 = E::F3 as u8;\n+    const GOAL: u8 = E::F3 as u8;\n     \"#,\n         6,\n     );\n     check_number(\n         r#\"\n     enum E { F1 = 1, F2, }\n-    const GOAL: i32 = E::F2 as u8;\n+    const GOAL: u8 = E::F2 as u8;\n     \"#,\n         2,\n     );\n     check_number(\n         r#\"\n     enum E { F1, }\n-    const GOAL: i32 = E::F1 as u8;\n+    const GOAL: u8 = E::F1 as u8;\n     \"#,\n         0,\n     );\n@@ -813,8 +1038,22 @@ fn exec_limits() {\n         }\n         sum\n     }\n-    const GOAL: usize = f(10000);\n+    const GOAL: i32 = f(10000);\n     \"#,\n         10000 * 10000,\n     );\n }\n+\n+#[test]\n+fn type_error() {\n+    let e = eval_goal(\n+        r#\"\n+    const GOAL: u8 = {\n+        let x: u16 = 2;\n+        let y: (u8, u8) = x;\n+        y.0\n+    };\n+    \"#,\n+    );\n+    assert!(matches!(e, Err(ConstEvalError::MirLowerError(MirLowerError::TypeMismatch(_)))));\n+}"}, {"sha": "304c78767f129a679b845318bd61889c75b4c490", "filename": "crates/hir-ty/src/db.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir-ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir-ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdb.rs?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -18,7 +18,7 @@ use crate::{\n     chalk_db,\n     consteval::ConstEvalError,\n     method_resolution::{InherentImpls, TraitImpls, TyFingerprint},\n-    mir::{MirBody, MirLowerError},\n+    mir::{BorrowckResult, MirBody, MirLowerError},\n     Binders, CallableDefId, Const, FnDefId, GenericArg, ImplTraitId, InferenceResult, Interner,\n     PolyFnSig, QuantifiedWhereClause, ReturnTypeImplTraits, Substitution, TraitRef, Ty, TyDefId,\n     ValueTyDefId,\n@@ -38,6 +38,9 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     #[salsa::cycle(crate::mir::mir_body_recover)]\n     fn mir_body(&self, def: DefWithBodyId) -> Result<Arc<MirBody>, MirLowerError>;\n \n+    #[salsa::invoke(crate::mir::borrowck_query)]\n+    fn borrowck(&self, def: DefWithBodyId) -> Result<Arc<BorrowckResult>, MirLowerError>;\n+\n     #[salsa::invoke(crate::lower::ty_query)]\n     #[salsa::cycle(crate::lower::ty_recover)]\n     fn ty(&self, def: TyDefId) -> Binders<Ty>;"}, {"sha": "d36b93e3bdde19d71978235ad65005ef2d84a65b", "filename": "crates/hir-ty/src/diagnostics/decl_check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -235,8 +235,8 @@ impl<'a> DeclValidator<'a> {\n         let pats_replacements = body\n             .pats\n             .iter()\n-            .filter_map(|(id, pat)| match pat {\n-                Pat::Bind { name, .. } => Some((id, name)),\n+            .filter_map(|(pat_id, pat)| match pat {\n+                Pat::Bind { id, .. } => Some((pat_id, &body.bindings[*id].name)),\n                 _ => None,\n             })\n             .filter_map(|(id, bind_name)| {"}, {"sha": "859a37804ae7fa8b33b00864f616810f266dc10a", "filename": "crates/hir-ty/src/diagnostics/match_check.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -146,8 +146,9 @@ impl<'a> PatCtxt<'a> {\n                 PatKind::Leaf { subpatterns }\n             }\n \n-            hir_def::expr::Pat::Bind { ref name, subpat, .. } => {\n+            hir_def::expr::Pat::Bind { id, subpat, .. } => {\n                 let bm = self.infer.pat_binding_modes[&pat];\n+                let name = &self.body.bindings[id].name;\n                 match (bm, ty.kind(Interner)) {\n                     (BindingMode::Ref(_), TyKind::Ref(.., rty)) => ty = rty,\n                     (BindingMode::Ref(_), _) => {"}, {"sha": "bd3eccfe43dab6d88df9362dadc46e18b291fa60", "filename": "crates/hir-ty/src/display.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -531,6 +531,7 @@ fn render_const_scalar(\n             hir_def::AdtId::UnionId(u) => write!(f, \"{}\", f.db.union_data(u).name),\n             hir_def::AdtId::EnumId(_) => f.write_str(\"<enum-not-supported>\"),\n         },\n+        chalk_ir::TyKind::FnDef(..) => ty.hir_fmt(f),\n         _ => f.write_str(\"<not-supported>\"),\n     }\n }"}, {"sha": "3a75f8712112e62dd4d82d21f9e358338bf69c40", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 26, "deletions": 3, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -22,7 +22,7 @@ use hir_def::{\n     body::Body,\n     builtin_type::{BuiltinInt, BuiltinType, BuiltinUint},\n     data::{ConstData, StaticData},\n-    expr::{BindingAnnotation, ExprId, ExprOrPatId, PatId},\n+    expr::{BindingAnnotation, BindingId, ExprId, ExprOrPatId, PatId},\n     lang_item::{LangItem, LangItemTarget},\n     layout::Integer,\n     path::Path,\n@@ -291,8 +291,10 @@ pub enum Adjust {\n /// call, with the signature `&'a T -> &'a U` or `&'a mut T -> &'a mut U`.\n /// The target type is `U` in both cases, with the region and mutability\n /// being those shared by both the receiver and the returned reference.\n+///\n+/// Mutability is `None` when we are not sure.\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub struct OverloadedDeref(pub Mutability);\n+pub struct OverloadedDeref(pub Option<Mutability>);\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub enum AutoBorrow {\n@@ -352,7 +354,10 @@ pub struct InferenceResult {\n     /// **Note**: When a pattern type is resolved it may still contain\n     /// unresolved or missing subpatterns or subpatterns of mismatched types.\n     pub type_of_pat: ArenaMap<PatId, Ty>,\n+    pub type_of_binding: ArenaMap<BindingId, Ty>,\n     pub type_of_rpit: ArenaMap<RpitId, Ty>,\n+    /// Type of the result of `.into_iter()` on the for. `ExprId` is the one of the whole for loop.\n+    pub type_of_for_iterator: FxHashMap<ExprId, Ty>,\n     type_mismatches: FxHashMap<ExprOrPatId, TypeMismatch>,\n     /// Interned common types to return references to.\n     standard_types: InternedStandardTypes,\n@@ -414,6 +419,14 @@ impl Index<PatId> for InferenceResult {\n     }\n }\n \n+impl Index<BindingId> for InferenceResult {\n+    type Output = Ty;\n+\n+    fn index(&self, b: BindingId) -> &Ty {\n+        self.type_of_binding.get(b).unwrap_or(&self.standard_types.unknown)\n+    }\n+}\n+\n /// The inference context contains all information needed during type inference.\n #[derive(Clone, Debug)]\n pub(crate) struct InferenceContext<'a> {\n@@ -534,7 +547,13 @@ impl<'a> InferenceContext<'a> {\n         for ty in result.type_of_pat.values_mut() {\n             *ty = table.resolve_completely(ty.clone());\n         }\n-        for ty in result.type_of_rpit.iter_mut().map(|x| x.1) {\n+        for ty in result.type_of_binding.values_mut() {\n+            *ty = table.resolve_completely(ty.clone());\n+        }\n+        for ty in result.type_of_rpit.values_mut() {\n+            *ty = table.resolve_completely(ty.clone());\n+        }\n+        for ty in result.type_of_for_iterator.values_mut() {\n             *ty = table.resolve_completely(ty.clone());\n         }\n         for mismatch in result.type_mismatches.values_mut() {\n@@ -704,6 +723,10 @@ impl<'a> InferenceContext<'a> {\n         self.result.type_of_pat.insert(pat, ty);\n     }\n \n+    fn write_binding_ty(&mut self, id: BindingId, ty: Ty) {\n+        self.result.type_of_binding.insert(id, ty);\n+    }\n+\n     fn push_diagnostic(&mut self, diagnostic: InferenceDiagnostic) {\n         self.result.diagnostics.push(diagnostic);\n     }"}, {"sha": "48c91530266dfbcaa5c13e94848cdc4ebef54249", "filename": "crates/hir-ty/src/infer/coerce.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -693,7 +693,7 @@ pub(super) fn auto_deref_adjust_steps(autoderef: &Autoderef<'_, '_>) -> Vec<Adju\n         .iter()\n         .map(|(kind, _source)| match kind {\n             // We do not know what kind of deref we require at this point yet\n-            AutoderefKind::Overloaded => Some(OverloadedDeref(Mutability::Not)),\n+            AutoderefKind::Overloaded => Some(OverloadedDeref(None)),\n             AutoderefKind::Builtin => None,\n         })\n         .zip(targets)"}, {"sha": "535189ff0288bd039b6edbd20cfe72c47a7d23fa", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -242,8 +242,10 @@ impl<'a> InferenceContext<'a> {\n                 let iterable_ty = self.infer_expr(iterable, &Expectation::none());\n                 let into_iter_ty =\n                     self.resolve_associated_type(iterable_ty, self.resolve_into_iter_item());\n-                let pat_ty =\n-                    self.resolve_associated_type(into_iter_ty, self.resolve_iterator_item());\n+                let pat_ty = self\n+                    .resolve_associated_type(into_iter_ty.clone(), self.resolve_iterator_item());\n+\n+                self.result.type_of_for_iterator.insert(tgt_expr, into_iter_ty);\n \n                 self.infer_top_pat(pat, &pat_ty);\n                 self.with_breakable_ctx(BreakableKind::Loop, None, label, |this| {"}, {"sha": "0f49e837881834fd71668a863df35d9bbfbc9d89", "filename": "crates/hir-ty/src/infer/pat.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -5,7 +5,10 @@ use std::iter::repeat_with;\n use chalk_ir::Mutability;\n use hir_def::{\n     body::Body,\n-    expr::{BindingAnnotation, Expr, ExprId, ExprOrPatId, Literal, Pat, PatId, RecordFieldPat},\n+    expr::{\n+        Binding, BindingAnnotation, BindingId, Expr, ExprId, ExprOrPatId, Literal, Pat, PatId,\n+        RecordFieldPat,\n+    },\n     path::Path,\n };\n use hir_expand::name::Name;\n@@ -248,8 +251,8 @@ impl<'a> InferenceContext<'a> {\n                 // FIXME update resolver for the surrounding expression\n                 self.infer_path(path, pat.into()).unwrap_or_else(|| self.err_ty())\n             }\n-            Pat::Bind { mode, name: _, subpat } => {\n-                return self.infer_bind_pat(pat, *mode, default_bm, *subpat, &expected);\n+            Pat::Bind { id, subpat } => {\n+                return self.infer_bind_pat(pat, *id, default_bm, *subpat, &expected);\n             }\n             Pat::Slice { prefix, slice, suffix } => {\n                 self.infer_slice_pat(&expected, prefix, slice, suffix, default_bm)\n@@ -320,11 +323,12 @@ impl<'a> InferenceContext<'a> {\n     fn infer_bind_pat(\n         &mut self,\n         pat: PatId,\n-        mode: BindingAnnotation,\n+        binding: BindingId,\n         default_bm: BindingMode,\n         subpat: Option<PatId>,\n         expected: &Ty,\n     ) -> Ty {\n+        let Binding { mode, .. } = self.body.bindings[binding];\n         let mode = if mode == BindingAnnotation::Unannotated {\n             default_bm\n         } else {\n@@ -344,7 +348,8 @@ impl<'a> InferenceContext<'a> {\n             }\n             BindingMode::Move => inner_ty.clone(),\n         };\n-        self.write_pat_ty(pat, bound_ty);\n+        self.write_pat_ty(pat, bound_ty.clone());\n+        self.write_binding_ty(binding, bound_ty);\n         return inner_ty;\n     }\n \n@@ -420,19 +425,22 @@ fn is_non_ref_pat(body: &hir_def::body::Body, pat: PatId) -> bool {\n         Pat::Lit(expr) => {\n             !matches!(body[*expr], Expr::Literal(Literal::String(..) | Literal::ByteString(..)))\n         }\n-        Pat::Bind {\n-            mode: BindingAnnotation::Mutable | BindingAnnotation::Unannotated,\n-            subpat: Some(subpat),\n-            ..\n-        } => is_non_ref_pat(body, *subpat),\n+        Pat::Bind { id, subpat: Some(subpat), .. }\n+            if matches!(\n+                body.bindings[*id].mode,\n+                BindingAnnotation::Mutable | BindingAnnotation::Unannotated\n+            ) =>\n+        {\n+            is_non_ref_pat(body, *subpat)\n+        }\n         Pat::Wild | Pat::Bind { .. } | Pat::Ref { .. } | Pat::Box { .. } | Pat::Missing => false,\n     }\n }\n \n pub(super) fn contains_explicit_ref_binding(body: &Body, pat_id: PatId) -> bool {\n     let mut res = false;\n     walk_pats(body, pat_id, &mut |pat| {\n-        res |= matches!(pat, Pat::Bind { mode: BindingAnnotation::Ref, .. })\n+        res |= matches!(pat, Pat::Bind { id, .. } if body.bindings[*id].mode == BindingAnnotation::Ref);\n     });\n     res\n }"}, {"sha": "2267fedaa8e9261bc1af94492cac41bfe631a685", "filename": "crates/hir-ty/src/infer/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -50,7 +50,7 @@ impl<'a> InferenceContext<'a> {\n         };\n \n         let typable: ValueTyDefId = match value {\n-            ValueNs::LocalBinding(pat) => match self.result.type_of_pat.get(pat) {\n+            ValueNs::LocalBinding(pat) => match self.result.type_of_binding.get(pat) {\n                 Some(ty) => return Some(ty.clone()),\n                 None => {\n                     never!(\"uninferred pattern?\");"}, {"sha": "a8971fde3c21edbc0c8e21de6d2d9be570a763aa", "filename": "crates/hir-ty/src/layout/tests.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir-ty%2Fsrc%2Flayout%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir-ty%2Fsrc%2Flayout%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flayout%2Ftests.rs?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -65,17 +65,9 @@ fn eval_expr(ra_fixture: &str, minicore: &str) -> Result<Layout, LayoutError> {\n         })\n         .unwrap();\n     let hir_body = db.body(adt_id.into());\n-    let pat = hir_body\n-        .pats\n-        .iter()\n-        .find(|x| match x.1 {\n-            hir_def::expr::Pat::Bind { name, .. } => name.to_smol_str() == \"goal\",\n-            _ => false,\n-        })\n-        .unwrap()\n-        .0;\n+    let b = hir_body.bindings.iter().find(|x| x.1.name.to_smol_str() == \"goal\").unwrap().0;\n     let infer = db.infer(adt_id.into());\n-    let goal_ty = infer.type_of_pat[pat].clone();\n+    let goal_ty = infer.type_of_binding[b].clone();\n     layout_of_ty(&db, &goal_ty, module_id.krate())\n }\n "}, {"sha": "92a17fc3a99728020c4b20047610d129b435bc79", "filename": "crates/hir-ty/src/method_resolution.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -579,8 +579,8 @@ impl ReceiverAdjustments {\n                     ty = new_ty.clone();\n                     adjust.push(Adjustment {\n                         kind: Adjust::Deref(match kind {\n-                            // FIXME should we know the mutability here?\n-                            AutoderefKind::Overloaded => Some(OverloadedDeref(Mutability::Not)),\n+                            // FIXME should we know the mutability here, when autoref is `None`?\n+                            AutoderefKind::Overloaded => Some(OverloadedDeref(self.autoref)),\n                             AutoderefKind::Builtin => None,\n                         }),\n                         target: new_ty,"}, {"sha": "7c1cbbdf53d27f40ecfa8c54b9d1f917b3cbd8ce", "filename": "crates/hir-ty/src/mir.rs", "status": "modified", "additions": 63, "deletions": 12, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir-ty%2Fsrc%2Fmir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir-ty%2Fsrc%2Fmir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir.rs?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -1,23 +1,27 @@\n //! MIR definitions and implementation\n \n-use std::iter;\n+use std::{fmt::Display, iter};\n \n use crate::{\n     infer::PointerCast, Const, ConstScalar, InferenceResult, Interner, MemoryMap, Substitution, Ty,\n };\n use chalk_ir::Mutability;\n use hir_def::{\n-    expr::{Expr, Ordering},\n+    expr::{BindingId, Expr, ExprId, Ordering, PatId},\n     DefWithBodyId, FieldId, UnionId, VariantId,\n };\n-use la_arena::{Arena, Idx, RawIdx};\n+use la_arena::{Arena, ArenaMap, Idx, RawIdx};\n \n mod eval;\n mod lower;\n+mod borrowck;\n+mod pretty;\n \n+pub use borrowck::{borrowck_query, BorrowckResult, MutabilityReason};\n pub use eval::{interpret_mir, pad16, Evaluator, MirEvalError};\n pub use lower::{lower_to_mir, mir_body_query, mir_body_recover, MirLowerError};\n use smallvec::{smallvec, SmallVec};\n+use stdx::impl_from;\n \n use super::consteval::{intern_const_scalar, try_const_usize};\n \n@@ -30,13 +34,7 @@ fn return_slot() -> LocalId {\n \n #[derive(Debug, PartialEq, Eq)]\n pub struct Local {\n-    pub mutability: Mutability,\n-    //pub local_info: Option<Box<LocalInfo>>,\n-    //pub internal: bool,\n-    //pub is_block_tail: Option<BlockTailInfo>,\n     pub ty: Ty,\n-    //pub user_ty: Option<Box<UserTypeProjections>>,\n-    //pub source_info: SourceInfo,\n }\n \n /// An operand in MIR represents a \"value\" in Rust, the definition of which is undecided and part of\n@@ -85,6 +83,10 @@ impl Operand {\n     fn from_bytes(data: Vec<u8>, ty: Ty) -> Self {\n         Operand::from_concrete_const(data, MemoryMap::default(), ty)\n     }\n+\n+    fn const_zst(ty: Ty) -> Operand {\n+        Self::from_bytes(vec![], ty)\n+    }\n }\n \n #[derive(Debug, PartialEq, Eq, Clone)]\n@@ -181,6 +183,11 @@ impl SwitchTargets {\n         iter::zip(&self.values, &self.targets).map(|(x, y)| (*x, *y))\n     }\n \n+    /// Returns a slice with all possible jump targets (including the fallback target).\n+    pub fn all_targets(&self) -> &[BasicBlockId] {\n+        &self.targets\n+    }\n+\n     /// Finds the `BasicBlock` to which this `SwitchInt` will branch given the\n     /// specific value. This cannot fail, as it'll return the `otherwise`\n     /// branch if there's not a specific match for the value.\n@@ -557,6 +564,30 @@ pub enum BinOp {\n     Offset,\n }\n \n+impl Display for BinOp {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        f.write_str(match self {\n+            BinOp::Add => \"+\",\n+            BinOp::Sub => \"-\",\n+            BinOp::Mul => \"*\",\n+            BinOp::Div => \"/\",\n+            BinOp::Rem => \"%\",\n+            BinOp::BitXor => \"^\",\n+            BinOp::BitAnd => \"&\",\n+            BinOp::BitOr => \"|\",\n+            BinOp::Shl => \"<<\",\n+            BinOp::Shr => \">>\",\n+            BinOp::Eq => \"==\",\n+            BinOp::Lt => \"<\",\n+            BinOp::Le => \"<=\",\n+            BinOp::Ne => \"!=\",\n+            BinOp::Ge => \">=\",\n+            BinOp::Gt => \">\",\n+            BinOp::Offset => \"`offset`\",\n+        })\n+    }\n+}\n+\n impl From<hir_def::expr::ArithOp> for BinOp {\n     fn from(value: hir_def::expr::ArithOp) -> Self {\n         match value {\n@@ -758,7 +789,7 @@ pub enum Rvalue {\n }\n \n #[derive(Debug, PartialEq, Eq, Clone)]\n-pub enum Statement {\n+pub enum StatementKind {\n     Assign(Place, Rvalue),\n     //FakeRead(Box<(FakeReadCause, Place)>),\n     //SetDiscriminant {\n@@ -773,6 +804,17 @@ pub enum Statement {\n     //Intrinsic(Box<NonDivergingIntrinsic>),\n     Nop,\n }\n+impl StatementKind {\n+    fn with_span(self, span: MirSpan) -> Statement {\n+        Statement { kind: self, span }\n+    }\n+}\n+\n+#[derive(Debug, PartialEq, Eq, Clone)]\n+pub struct Statement {\n+    pub kind: StatementKind,\n+    pub span: MirSpan,\n+}\n \n #[derive(Debug, Default, PartialEq, Eq)]\n pub struct BasicBlock {\n@@ -803,10 +845,19 @@ pub struct MirBody {\n     pub start_block: BasicBlockId,\n     pub owner: DefWithBodyId,\n     pub arg_count: usize,\n+    pub binding_locals: ArenaMap<BindingId, LocalId>,\n+    pub param_locals: Vec<LocalId>,\n }\n \n-impl MirBody {}\n-\n fn const_as_usize(c: &Const) -> usize {\n     try_const_usize(c).unwrap() as usize\n }\n+\n+#[derive(Debug, PartialEq, Eq, Clone, Copy)]\n+pub enum MirSpan {\n+    ExprId(ExprId),\n+    PatId(PatId),\n+    Unknown,\n+}\n+\n+impl_from!(ExprId, PatId for MirSpan);"}, {"sha": "c8729af86a9eaf11f5ac974ca1d6ae51d6722921", "filename": "crates/hir-ty/src/mir/borrowck.rs", "status": "added", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir-ty%2Fsrc%2Fmir%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir-ty%2Fsrc%2Fmir%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Fborrowck.rs?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -0,0 +1,223 @@\n+//! MIR borrow checker, which is used in diagnostics like `unused_mut`\n+\n+// Currently it is an ad-hoc implementation, only useful for mutability analysis. Feel free to remove all of these\n+// if needed for implementing a proper borrow checker.\n+\n+use std::sync::Arc;\n+\n+use hir_def::DefWithBodyId;\n+use la_arena::ArenaMap;\n+use stdx::never;\n+\n+use crate::db::HirDatabase;\n+\n+use super::{\n+    BasicBlockId, BorrowKind, LocalId, MirBody, MirLowerError, MirSpan, Place, ProjectionElem,\n+    Rvalue, StatementKind, Terminator,\n+};\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+/// Stores spans which implies that the local should be mutable.\n+pub enum MutabilityReason {\n+    Mut { spans: Vec<MirSpan> },\n+    Not,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct BorrowckResult {\n+    pub mir_body: Arc<MirBody>,\n+    pub mutability_of_locals: ArenaMap<LocalId, MutabilityReason>,\n+}\n+\n+pub fn borrowck_query(\n+    db: &dyn HirDatabase,\n+    def: DefWithBodyId,\n+) -> Result<Arc<BorrowckResult>, MirLowerError> {\n+    let _p = profile::span(\"borrowck_query\");\n+    let body = db.mir_body(def)?;\n+    let r = BorrowckResult { mutability_of_locals: mutability_of_locals(&body), mir_body: body };\n+    Ok(Arc::new(r))\n+}\n+\n+fn is_place_direct(lvalue: &Place) -> bool {\n+    !lvalue.projection.iter().any(|x| *x == ProjectionElem::Deref)\n+}\n+\n+enum ProjectionCase {\n+    /// Projection is a local\n+    Direct,\n+    /// Projection is some field or slice of a local\n+    DirectPart,\n+    /// Projection is deref of something\n+    Indirect,\n+}\n+\n+fn place_case(lvalue: &Place) -> ProjectionCase {\n+    let mut is_part_of = false;\n+    for proj in lvalue.projection.iter().rev() {\n+        match proj {\n+            ProjectionElem::Deref => return ProjectionCase::Indirect, // It's indirect\n+            ProjectionElem::ConstantIndex { .. }\n+            | ProjectionElem::Subslice { .. }\n+            | ProjectionElem::Field(_)\n+            | ProjectionElem::TupleField(_)\n+            | ProjectionElem::Index(_) => {\n+                is_part_of = true;\n+            }\n+            ProjectionElem::OpaqueCast(_) => (),\n+        }\n+    }\n+    if is_part_of {\n+        ProjectionCase::DirectPart\n+    } else {\n+        ProjectionCase::Direct\n+    }\n+}\n+\n+/// Returns a map from basic blocks to the set of locals that might be ever initialized before\n+/// the start of the block. Only `StorageDead` can remove something from this map, and we ignore\n+/// `Uninit` and `drop` and similars after initialization.\n+fn ever_initialized_map(body: &MirBody) -> ArenaMap<BasicBlockId, ArenaMap<LocalId, bool>> {\n+    let mut result: ArenaMap<BasicBlockId, ArenaMap<LocalId, bool>> =\n+        body.basic_blocks.iter().map(|x| (x.0, ArenaMap::default())).collect();\n+    fn dfs(\n+        body: &MirBody,\n+        b: BasicBlockId,\n+        l: LocalId,\n+        result: &mut ArenaMap<BasicBlockId, ArenaMap<LocalId, bool>>,\n+    ) {\n+        let mut is_ever_initialized = result[b][l]; // It must be filled, as we use it as mark for dfs\n+        let block = &body.basic_blocks[b];\n+        for statement in &block.statements {\n+            match &statement.kind {\n+                StatementKind::Assign(p, _) => {\n+                    if p.projection.len() == 0 && p.local == l {\n+                        is_ever_initialized = true;\n+                    }\n+                }\n+                StatementKind::StorageDead(p) => {\n+                    if *p == l {\n+                        is_ever_initialized = false;\n+                    }\n+                }\n+                StatementKind::Deinit(_) | StatementKind::Nop | StatementKind::StorageLive(_) => (),\n+            }\n+        }\n+        let Some(terminator) = &block.terminator else {\n+            never!(\"Terminator should be none only in construction\");\n+            return;\n+        };\n+        let targets = match terminator {\n+            Terminator::Goto { target } => vec![*target],\n+            Terminator::SwitchInt { targets, .. } => targets.all_targets().to_vec(),\n+            Terminator::Resume\n+            | Terminator::Abort\n+            | Terminator::Return\n+            | Terminator::Unreachable => vec![],\n+            Terminator::Call { target, cleanup, destination, .. } => {\n+                if destination.projection.len() == 0 && destination.local == l {\n+                    is_ever_initialized = true;\n+                }\n+                target.into_iter().chain(cleanup.into_iter()).copied().collect()\n+            }\n+            Terminator::Drop { .. }\n+            | Terminator::DropAndReplace { .. }\n+            | Terminator::Assert { .. }\n+            | Terminator::Yield { .. }\n+            | Terminator::GeneratorDrop\n+            | Terminator::FalseEdge { .. }\n+            | Terminator::FalseUnwind { .. } => {\n+                never!(\"We don't emit these MIR terminators yet\");\n+                vec![]\n+            }\n+        };\n+        for target in targets {\n+            if !result[target].contains_idx(l) || !result[target][l] && is_ever_initialized {\n+                result[target].insert(l, is_ever_initialized);\n+                dfs(body, target, l, result);\n+            }\n+        }\n+    }\n+    for &l in &body.param_locals {\n+        result[body.start_block].insert(l, true);\n+        dfs(body, body.start_block, l, &mut result);\n+    }\n+    for l in body.locals.iter().map(|x| x.0) {\n+        if !result[body.start_block].contains_idx(l) {\n+            result[body.start_block].insert(l, false);\n+            dfs(body, body.start_block, l, &mut result);\n+        }\n+    }\n+    result\n+}\n+\n+fn mutability_of_locals(body: &MirBody) -> ArenaMap<LocalId, MutabilityReason> {\n+    let mut result: ArenaMap<LocalId, MutabilityReason> =\n+        body.locals.iter().map(|x| (x.0, MutabilityReason::Not)).collect();\n+    let mut push_mut_span = |local, span| match &mut result[local] {\n+        MutabilityReason::Mut { spans } => spans.push(span),\n+        x @ MutabilityReason::Not => *x = MutabilityReason::Mut { spans: vec![span] },\n+    };\n+    let ever_init_maps = ever_initialized_map(body);\n+    for (block_id, mut ever_init_map) in ever_init_maps.into_iter() {\n+        let block = &body.basic_blocks[block_id];\n+        for statement in &block.statements {\n+            match &statement.kind {\n+                StatementKind::Assign(place, value) => {\n+                    match place_case(place) {\n+                        ProjectionCase::Direct => {\n+                            if ever_init_map.get(place.local).copied().unwrap_or_default() {\n+                                push_mut_span(place.local, statement.span);\n+                            } else {\n+                                ever_init_map.insert(place.local, true);\n+                            }\n+                        }\n+                        ProjectionCase::DirectPart => {\n+                            // Partial initialization is not supported, so it is definitely `mut`\n+                            push_mut_span(place.local, statement.span);\n+                        }\n+                        ProjectionCase::Indirect => (),\n+                    }\n+                    if let Rvalue::Ref(BorrowKind::Mut { .. }, p) = value {\n+                        if is_place_direct(p) {\n+                            push_mut_span(p.local, statement.span);\n+                        }\n+                    }\n+                }\n+                StatementKind::StorageDead(p) => {\n+                    ever_init_map.insert(*p, false);\n+                }\n+                StatementKind::Deinit(_) | StatementKind::StorageLive(_) | StatementKind::Nop => (),\n+            }\n+        }\n+        let Some(terminator) = &block.terminator else {\n+            never!(\"Terminator should be none only in construction\");\n+            continue;\n+        };\n+        match terminator {\n+            Terminator::Goto { .. }\n+            | Terminator::Resume\n+            | Terminator::Abort\n+            | Terminator::Return\n+            | Terminator::Unreachable\n+            | Terminator::FalseEdge { .. }\n+            | Terminator::FalseUnwind { .. }\n+            | Terminator::GeneratorDrop\n+            | Terminator::SwitchInt { .. }\n+            | Terminator::Drop { .. }\n+            | Terminator::DropAndReplace { .. }\n+            | Terminator::Assert { .. }\n+            | Terminator::Yield { .. } => (),\n+            Terminator::Call { destination, .. } => {\n+                if destination.projection.len() == 0 {\n+                    if ever_init_map.get(destination.local).copied().unwrap_or_default() {\n+                        push_mut_span(destination.local, MirSpan::Unknown);\n+                    } else {\n+                        ever_init_map.insert(destination.local, true);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    result\n+}"}, {"sha": "c5d843d9ebd8975a1098c6e8555ecac18fbc76fd", "filename": "crates/hir-ty/src/mir/eval.rs", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -29,7 +29,7 @@ use crate::{\n \n use super::{\n     const_as_usize, return_slot, AggregateKind, BinOp, CastKind, LocalId, MirBody, MirLowerError,\n-    Operand, Place, ProjectionElem, Rvalue, Statement, Terminator, UnOp,\n+    Operand, Place, ProjectionElem, Rvalue, StatementKind, Terminator, UnOp,\n };\n \n pub struct Evaluator<'a> {\n@@ -263,12 +263,14 @@ impl Evaluator<'_> {\n         for proj in &p.projection {\n             match proj {\n                 ProjectionElem::Deref => {\n-                    match &ty.data(Interner).kind {\n-                        TyKind::Ref(_, _, inner) => {\n-                            ty = inner.clone();\n+                    ty = match &ty.data(Interner).kind {\n+                        TyKind::Raw(_, inner) | TyKind::Ref(_, _, inner) => inner.clone(),\n+                        _ => {\n+                            return Err(MirEvalError::TypeError(\n+                                \"Overloaded deref in MIR is disallowed\",\n+                            ))\n                         }\n-                        _ => not_supported!(\"dereferencing smart pointers\"),\n-                    }\n+                    };\n                     let x = from_bytes!(usize, self.read_memory(addr, self.ptr_size())?);\n                     addr = Address::from_usize(x);\n                 }\n@@ -395,7 +397,8 @@ impl Evaluator<'_> {\n                 .locals\n                 .iter()\n                 .map(|(id, x)| {\n-                    let size = self.size_of_sized(&x.ty, &locals, \"no unsized local\")?;\n+                    let size =\n+                        self.size_of_sized(&x.ty, &locals, \"no unsized local in extending stack\")?;\n                     let my_ptr = stack_ptr;\n                     stack_ptr += size;\n                     Ok((id, Stack(my_ptr)))\n@@ -425,16 +428,16 @@ impl Evaluator<'_> {\n                 return Err(MirEvalError::ExecutionLimitExceeded);\n             }\n             for statement in &current_block.statements {\n-                match statement {\n-                    Statement::Assign(l, r) => {\n+                match &statement.kind {\n+                    StatementKind::Assign(l, r) => {\n                         let addr = self.place_addr(l, &locals)?;\n                         let result = self.eval_rvalue(r, &locals)?.to_vec(&self)?;\n                         self.write_memory(addr, &result)?;\n                     }\n-                    Statement::Deinit(_) => not_supported!(\"de-init statement\"),\n-                    Statement::StorageLive(_) => not_supported!(\"storage-live statement\"),\n-                    Statement::StorageDead(_) => not_supported!(\"storage-dead statement\"),\n-                    Statement::Nop => (),\n+                    StatementKind::Deinit(_) => not_supported!(\"de-init statement\"),\n+                    StatementKind::StorageLive(_)\n+                    | StatementKind::StorageDead(_)\n+                    | StatementKind::Nop => (),\n                 }\n             }\n             let Some(terminator) = current_block.terminator.as_ref() else {\n@@ -1121,7 +1124,12 @@ impl Evaluator<'_> {\n     }\n \n     fn detect_lang_function(&self, def: FunctionId) -> Option<LangItem> {\n-        lang_attr(self.db.upcast(), def)\n+        let candidate = lang_attr(self.db.upcast(), def)?;\n+        // filter normal lang functions out\n+        if [LangItem::IntoIterIntoIter, LangItem::IteratorNext].contains(&candidate) {\n+            return None;\n+        }\n+        Some(candidate)\n     }\n \n     fn create_memory_map(&self, bytes: &[u8], ty: &Ty, locals: &Locals<'_>) -> Result<MemoryMap> {"}, {"sha": "afa5275ac6bb764716d851ebd54908d975ca4eef", "filename": "crates/hir-ty/src/mir/lower.rs", "status": "modified", "additions": 780, "deletions": 426, "changes": 1206, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -6,31 +6,38 @@ use chalk_ir::{BoundVar, ConstData, DebruijnIndex, TyKind};\n use hir_def::{\n     body::Body,\n     expr::{\n-        Array, BindingAnnotation, ExprId, LabelId, Literal, MatchArm, Pat, PatId, RecordLitField,\n+        Array, BindingAnnotation, BindingId, ExprId, LabelId, Literal, MatchArm, Pat, PatId,\n+        RecordLitField,\n     },\n+    lang_item::{LangItem, LangItemTarget},\n     layout::LayoutError,\n+    path::Path,\n     resolver::{resolver_for_expr, ResolveValueResult, ValueNs},\n     DefWithBodyId, EnumVariantId, HasModule,\n };\n+use hir_expand::name::Name;\n use la_arena::ArenaMap;\n \n use crate::{\n-    consteval::ConstEvalError, db::HirDatabase, layout::layout_of_ty, mapping::ToChalk,\n-    utils::generics, Adjust, AutoBorrow, CallableDefId, TyBuilder, TyExt,\n+    consteval::ConstEvalError, db::HirDatabase, display::HirDisplay, infer::TypeMismatch,\n+    inhabitedness::is_ty_uninhabited_from, layout::layout_of_ty, mapping::ToChalk, static_lifetime,\n+    utils::generics, Adjust, Adjustment, AutoBorrow, CallableDefId, TyBuilder, TyExt,\n };\n \n use super::*;\n \n+mod as_place;\n+\n #[derive(Debug, Clone, Copy)]\n struct LoopBlocks {\n     begin: BasicBlockId,\n-    end: BasicBlockId,\n+    /// `None` for loops that are not terminating\n+    end: Option<BasicBlockId>,\n }\n \n struct MirLowerCtx<'a> {\n     result: MirBody,\n     owner: DefWithBodyId,\n-    binding_locals: ArenaMap<PatId, LocalId>,\n     current_loop_blocks: Option<LoopBlocks>,\n     discr_temp: Option<Place>,\n     db: &'a dyn HirDatabase,\n@@ -43,13 +50,22 @@ pub enum MirLowerError {\n     ConstEvalError(Box<ConstEvalError>),\n     LayoutError(LayoutError),\n     IncompleteExpr,\n-    UnresolvedName,\n+    UnresolvedName(String),\n+    RecordLiteralWithoutPath,\n+    UnresolvedMethod,\n+    UnresolvedField,\n     MissingFunctionDefinition,\n+    TypeMismatch(TypeMismatch),\n+    /// This should be never happen. Type mismatch should catch everything.\n     TypeError(&'static str),\n     NotSupported(String),\n     ContinueWithoutLoop,\n     BreakWithoutLoop,\n     Loop,\n+    /// Something that should never happen and is definitely a bug, but we don't want to panic if it happened\n+    ImplementationError(&'static str),\n+    LangItemNotFound(LangItem),\n+    MutatingRvalue,\n }\n \n macro_rules! not_supported {\n@@ -58,6 +74,13 @@ macro_rules! not_supported {\n     };\n }\n \n+macro_rules! implementation_error {\n+    ($x: expr) => {{\n+        ::stdx::never!(\"MIR lower implementation bug: {}\", $x);\n+        return Err(MirLowerError::ImplementationError($x));\n+    }};\n+}\n+\n impl From<ConstEvalError> for MirLowerError {\n     fn from(value: ConstEvalError) -> Self {\n         match value {\n@@ -73,142 +96,99 @@ impl From<LayoutError> for MirLowerError {\n     }\n }\n \n+impl MirLowerError {\n+    fn unresolved_path(db: &dyn HirDatabase, p: &Path) -> Self {\n+        Self::UnresolvedName(p.display(db).to_string())\n+    }\n+}\n+\n type Result<T> = std::result::Result<T, MirLowerError>;\n \n impl MirLowerCtx<'_> {\n     fn temp(&mut self, ty: Ty) -> Result<LocalId> {\n         if matches!(ty.kind(Interner), TyKind::Slice(_) | TyKind::Dyn(_)) {\n-            not_supported!(\"unsized temporaries\");\n-        }\n-        Ok(self.result.locals.alloc(Local { mutability: Mutability::Not, ty }))\n-    }\n-\n-    fn lower_expr_as_place(&self, expr_id: ExprId) -> Option<Place> {\n-        let adjustments = self.infer.expr_adjustments.get(&expr_id);\n-        let mut r = self.lower_expr_as_place_without_adjust(expr_id)?;\n-        for adjustment in adjustments.iter().flat_map(|x| x.iter()) {\n-            match adjustment.kind {\n-                Adjust::NeverToAny => return Some(r),\n-                Adjust::Deref(None) => {\n-                    r.projection.push(ProjectionElem::Deref);\n-                }\n-                Adjust::Deref(Some(_)) => return None,\n-                Adjust::Borrow(_) => return None,\n-                Adjust::Pointer(_) => return None,\n-            }\n-        }\n-        Some(r)\n-    }\n-\n-    fn lower_expr_as_place_without_adjust(&self, expr_id: ExprId) -> Option<Place> {\n-        match &self.body.exprs[expr_id] {\n-            Expr::Path(p) => {\n-                let resolver = resolver_for_expr(self.db.upcast(), self.owner, expr_id);\n-                let pr = resolver.resolve_path_in_value_ns(self.db.upcast(), p.mod_path())?;\n-                let pr = match pr {\n-                    ResolveValueResult::ValueNs(v) => v,\n-                    ResolveValueResult::Partial(..) => return None,\n-                };\n-                match pr {\n-                    ValueNs::LocalBinding(pat_id) => Some(self.binding_locals[pat_id].into()),\n-                    _ => None,\n-                }\n-            }\n-            Expr::UnaryOp { expr, op } => match op {\n-                hir_def::expr::UnaryOp::Deref => {\n-                    let mut r = self.lower_expr_as_place(*expr)?;\n-                    r.projection.push(ProjectionElem::Deref);\n-                    Some(r)\n-                }\n-                _ => None,\n-            },\n-            _ => None,\n+            implementation_error!(\"unsized temporaries\");\n         }\n+        Ok(self.result.locals.alloc(Local { ty }))\n     }\n \n     fn lower_expr_to_some_operand(\n         &mut self,\n         expr_id: ExprId,\n         current: BasicBlockId,\n-    ) -> Result<(Operand, BasicBlockId)> {\n+    ) -> Result<Option<(Operand, BasicBlockId)>> {\n         if !self.has_adjustments(expr_id) {\n             match &self.body.exprs[expr_id] {\n                 Expr::Literal(l) => {\n                     let ty = self.expr_ty(expr_id);\n-                    return Ok((self.lower_literal_to_operand(ty, l)?, current));\n+                    return Ok(Some((self.lower_literal_to_operand(ty, l)?, current)));\n                 }\n                 _ => (),\n             }\n         }\n-        let (p, current) = self.lower_expr_to_some_place(expr_id, current)?;\n-        Ok((Operand::Copy(p), current))\n+        let Some((p, current)) = self.lower_expr_as_place(current, expr_id, true)? else {\n+            return Ok(None);\n+        };\n+        Ok(Some((Operand::Copy(p), current)))\n     }\n \n-    fn lower_expr_to_some_place(\n+    fn lower_expr_to_place_with_adjust(\n         &mut self,\n         expr_id: ExprId,\n-        prev_block: BasicBlockId,\n-    ) -> Result<(Place, BasicBlockId)> {\n-        if let Some(p) = self.lower_expr_as_place(expr_id) {\n-            return Ok((p, prev_block));\n-        }\n-        let mut ty = self.expr_ty(expr_id);\n-        if let Some(x) = self.infer.expr_adjustments.get(&expr_id) {\n-            if let Some(x) = x.last() {\n-                ty = x.target.clone();\n-            }\n+        place: Place,\n+        current: BasicBlockId,\n+        adjustments: &[Adjustment],\n+    ) -> Result<Option<BasicBlockId>> {\n+        match adjustments.split_last() {\n+            Some((last, rest)) => match &last.kind {\n+                Adjust::NeverToAny => {\n+                    let temp = self.temp(TyKind::Never.intern(Interner))?;\n+                    self.lower_expr_to_place_with_adjust(expr_id, temp.into(), current, rest)\n+                }\n+                Adjust::Deref(_) => {\n+                    let Some((p, current)) = self.lower_expr_as_place_with_adjust(current, expr_id, true, adjustments)? else {\n+                            return Ok(None);\n+                        };\n+                    self.push_assignment(current, place, Operand::Copy(p).into(), expr_id.into());\n+                    Ok(Some(current))\n+                }\n+                Adjust::Borrow(AutoBorrow::Ref(m) | AutoBorrow::RawPtr(m)) => {\n+                    let Some((p, current)) = self.lower_expr_as_place_with_adjust(current, expr_id, true, rest)? else {\n+                            return Ok(None);\n+                        };\n+                    let bk = BorrowKind::from_chalk(*m);\n+                    self.push_assignment(current, place, Rvalue::Ref(bk, p), expr_id.into());\n+                    Ok(Some(current))\n+                }\n+                Adjust::Pointer(cast) => {\n+                    let Some((p, current)) = self.lower_expr_as_place_with_adjust(current, expr_id, true, rest)? else {\n+                            return Ok(None);\n+                        };\n+                    self.push_assignment(\n+                        current,\n+                        place,\n+                        Rvalue::Cast(\n+                            CastKind::Pointer(cast.clone()),\n+                            Operand::Copy(p).into(),\n+                            last.target.clone(),\n+                        ),\n+                        expr_id.into(),\n+                    );\n+                    Ok(Some(current))\n+                }\n+            },\n+            None => self.lower_expr_to_place_without_adjust(expr_id, place, current),\n         }\n-        let place = self.temp(ty)?;\n-        Ok((place.into(), self.lower_expr_to_place(expr_id, place.into(), prev_block)?))\n     }\n \n     fn lower_expr_to_place(\n         &mut self,\n         expr_id: ExprId,\n         place: Place,\n         prev_block: BasicBlockId,\n-    ) -> Result<BasicBlockId> {\n-        if let Some(x) = self.infer.expr_adjustments.get(&expr_id) {\n-            if x.len() > 0 {\n-                let tmp = self.temp(self.expr_ty(expr_id))?;\n-                let current =\n-                    self.lower_expr_to_place_without_adjust(expr_id, tmp.into(), prev_block)?;\n-                let mut r = Place::from(tmp);\n-                for adjustment in x {\n-                    match &adjustment.kind {\n-                        Adjust::NeverToAny => (),\n-                        Adjust::Deref(None) => {\n-                            r.projection.push(ProjectionElem::Deref);\n-                        }\n-                        Adjust::Deref(Some(_)) => not_supported!(\"overloaded dereference\"),\n-                        Adjust::Borrow(AutoBorrow::Ref(m) | AutoBorrow::RawPtr(m)) => {\n-                            let tmp = self.temp(adjustment.target.clone())?;\n-                            self.push_assignment(\n-                                current,\n-                                tmp.into(),\n-                                Rvalue::Ref(BorrowKind::from_chalk(*m), r),\n-                            );\n-                            r = tmp.into();\n-                        }\n-                        Adjust::Pointer(cast) => {\n-                            let target = &adjustment.target;\n-                            let tmp = self.temp(target.clone())?;\n-                            self.push_assignment(\n-                                current,\n-                                tmp.into(),\n-                                Rvalue::Cast(\n-                                    CastKind::Pointer(cast.clone()),\n-                                    Operand::Copy(r).into(),\n-                                    target.clone(),\n-                                ),\n-                            );\n-                            r = tmp.into();\n-                        }\n-                    }\n-                }\n-                self.push_assignment(current, place, Operand::Copy(r).into());\n-                return Ok(current);\n-            }\n+    ) -> Result<Option<BasicBlockId>> {\n+        if let Some(adjustments) = self.infer.expr_adjustments.get(&expr_id) {\n+            return self.lower_expr_to_place_with_adjust(expr_id, place, prev_block, adjustments);\n         }\n         self.lower_expr_to_place_without_adjust(expr_id, place, prev_block)\n     }\n@@ -218,42 +198,68 @@ impl MirLowerCtx<'_> {\n         expr_id: ExprId,\n         place: Place,\n         mut current: BasicBlockId,\n-    ) -> Result<BasicBlockId> {\n+    ) -> Result<Option<BasicBlockId>> {\n         match &self.body.exprs[expr_id] {\n             Expr::Missing => Err(MirLowerError::IncompleteExpr),\n             Expr::Path(p) => {\n+                let unresolved_name = || MirLowerError::unresolved_path(self.db, p);\n                 let resolver = resolver_for_expr(self.db.upcast(), self.owner, expr_id);\n                 let pr = resolver\n                     .resolve_path_in_value_ns(self.db.upcast(), p.mod_path())\n-                    .ok_or(MirLowerError::UnresolvedName)?;\n+                    .ok_or_else(unresolved_name)?;\n                 let pr = match pr {\n                     ResolveValueResult::ValueNs(v) => v,\n                     ResolveValueResult::Partial(..) => {\n-                        return match self\n+                        if let Some(assoc) = self\n                             .infer\n                             .assoc_resolutions_for_expr(expr_id)\n-                            .ok_or(MirLowerError::UnresolvedName)?\n-                            .0\n-                            //.ok_or(ConstEvalError::SemanticError(\"unresolved assoc item\"))?\n                         {\n-                            hir_def::AssocItemId::ConstId(c) => self.lower_const(c, current, place),\n-                            _ => return Err(MirLowerError::UnresolvedName),\n-                        };\n+                            match assoc.0 {\n+                                hir_def::AssocItemId::ConstId(c) => {\n+                                    self.lower_const(c, current, place, expr_id.into())?;\n+                                    return Ok(Some(current))\n+                                },\n+                                _ => not_supported!(\"associated functions and types\"),\n+                            }\n+                        } else if let Some(variant) = self\n+                            .infer\n+                            .variant_resolution_for_expr(expr_id)\n+                        {\n+                            match variant {\n+                                VariantId::EnumVariantId(e) => ValueNs::EnumVariantId(e),\n+                                VariantId::StructId(s) => ValueNs::StructId(s),\n+                                VariantId::UnionId(_) => implementation_error!(\"Union variant as path\"),\n+                            }\n+                        } else {\n+                            return Err(unresolved_name());\n+                        }\n                     }\n                 };\n                 match pr {\n                     ValueNs::LocalBinding(pat_id) => {\n                         self.push_assignment(\n                             current,\n                             place,\n-                            Operand::Copy(self.binding_locals[pat_id].into()).into(),\n+                            Operand::Copy(self.result.binding_locals[pat_id].into()).into(),\n+                            expr_id.into(),\n                         );\n-                        Ok(current)\n+                        Ok(Some(current))\n+                    }\n+                    ValueNs::ConstId(const_id) => {\n+                        self.lower_const(const_id, current, place, expr_id.into())?;\n+                        Ok(Some(current))\n                     }\n-                    ValueNs::ConstId(const_id) => self.lower_const(const_id, current, place),\n                     ValueNs::EnumVariantId(variant_id) => {\n                         let ty = self.infer.type_of_expr[expr_id].clone();\n-                        self.lower_enum_variant(variant_id, current, place, ty, vec![])\n+                        let current = self.lower_enum_variant(\n+                            variant_id,\n+                            current,\n+                            place,\n+                            ty,\n+                            vec![],\n+                            expr_id.into(),\n+                        )?;\n+                        Ok(Some(current))\n                     }\n                     ValueNs::GenericParam(p) => {\n                         let Some(def) = self.owner.as_generic_def_id() else {\n@@ -277,74 +283,89 @@ impl MirLowerCtx<'_> {\n                                 .intern(Interner),\n                             )\n                             .into(),\n+                            expr_id.into(),\n                         );\n-                        Ok(current)\n+                        Ok(Some(current))\n                     }\n                     ValueNs::StructId(_) => {\n                         // It's probably a unit struct or a zero sized function, so no action is needed.\n-                        Ok(current)\n+                        Ok(Some(current))\n                     }\n                     x => {\n                         not_supported!(\"unknown name {x:?} in value name space\");\n                     }\n                 }\n             }\n             Expr::If { condition, then_branch, else_branch } => {\n-                let (discr, current) = self.lower_expr_to_some_operand(*condition, current)?;\n+                let Some((discr, current)) = self.lower_expr_to_some_operand(*condition, current)? else {\n+                    return Ok(None);\n+                };\n                 let start_of_then = self.new_basic_block();\n-                let end = self.new_basic_block();\n                 let end_of_then =\n                     self.lower_expr_to_place(*then_branch, place.clone(), start_of_then)?;\n-                self.set_goto(end_of_then, end);\n-                let mut start_of_else = end;\n-                if let Some(else_branch) = else_branch {\n-                    start_of_else = self.new_basic_block();\n-                    let end_of_else =\n-                        self.lower_expr_to_place(*else_branch, place, start_of_else)?;\n-                    self.set_goto(end_of_else, end);\n-                }\n+                let start_of_else = self.new_basic_block();\n+                let end_of_else = if let Some(else_branch) = else_branch {\n+                    self.lower_expr_to_place(*else_branch, place, start_of_else)?\n+                } else {\n+                    Some(start_of_else)\n+                };\n                 self.set_terminator(\n                     current,\n                     Terminator::SwitchInt {\n                         discr,\n                         targets: SwitchTargets::static_if(1, start_of_then, start_of_else),\n                     },\n                 );\n-                Ok(end)\n+                Ok(self.merge_blocks(end_of_then, end_of_else))\n             }\n             Expr::Let { pat, expr } => {\n-                let (cond_place, current) = self.lower_expr_to_some_place(*expr, current)?;\n-                let result = self.new_basic_block();\n+                let Some((cond_place, current)) = self.lower_expr_as_place(current, *expr, true)? else {\n+                    return Ok(None);\n+                };\n                 let (then_target, else_target) = self.pattern_match(\n                     current,\n                     None,\n                     cond_place,\n-                    self.expr_ty(*expr),\n+                    self.expr_ty_after_adjustments(*expr),\n                     *pat,\n                     BindingAnnotation::Unannotated,\n                 )?;\n-                self.write_bytes_to_place(then_target, place.clone(), vec![1], TyBuilder::bool())?;\n-                self.set_goto(then_target, result);\n+                self.write_bytes_to_place(\n+                    then_target,\n+                    place.clone(),\n+                    vec![1],\n+                    TyBuilder::bool(),\n+                    MirSpan::Unknown,\n+                )?;\n                 if let Some(else_target) = else_target {\n-                    self.write_bytes_to_place(else_target, place, vec![0], TyBuilder::bool())?;\n-                    self.set_goto(else_target, result);\n+                    self.write_bytes_to_place(\n+                        else_target,\n+                        place,\n+                        vec![0],\n+                        TyBuilder::bool(),\n+                        MirSpan::Unknown,\n+                    )?;\n                 }\n-                Ok(result)\n+                Ok(self.merge_blocks(Some(then_target), else_target))\n             }\n             Expr::Unsafe { id: _, statements, tail } => {\n                 self.lower_block_to_place(None, statements, current, *tail, place)\n             }\n             Expr::Block { id: _, statements, tail, label } => {\n                 self.lower_block_to_place(*label, statements, current, *tail, place)\n             }\n-            Expr::Loop { body, label } => self.lower_loop(current, *label, |this, begin, _| {\n-                let (_, block) = this.lower_expr_to_some_place(*body, begin)?;\n-                this.set_goto(block, begin);\n+            Expr::Loop { body, label } => self.lower_loop(current, *label, |this, begin| {\n+                if let Some((_, block)) = this.lower_expr_as_place(begin, *body, true)? {\n+                    this.set_goto(block, begin);\n+                }\n                 Ok(())\n             }),\n             Expr::While { condition, body, label } => {\n-                self.lower_loop(current, *label, |this, begin, end| {\n-                    let (discr, to_switch) = this.lower_expr_to_some_operand(*condition, begin)?;\n+                self.lower_loop(current, *label, |this, begin| {\n+                    let Some((discr, to_switch)) = this.lower_expr_to_some_operand(*condition, begin)? else {\n+                        return Ok(());\n+                    };\n+                    let end = this.current_loop_end()?;\n                     let after_cond = this.new_basic_block();\n                     this.set_terminator(\n                         to_switch,\n@@ -353,18 +374,71 @@ impl MirLowerCtx<'_> {\n                             targets: SwitchTargets::static_if(1, after_cond, end),\n                         },\n                     );\n-                    let (_, block) = this.lower_expr_to_some_place(*body, after_cond)?;\n-                    this.set_goto(block, begin);\n+                    if let Some((_, block)) = this.lower_expr_as_place(after_cond, *body, true)? {\n+                        this.set_goto(block, begin);\n+                    }\n                     Ok(())\n                 })\n             }\n-            Expr::For { .. } => not_supported!(\"for loop\"),\n+            &Expr::For { iterable, pat, body, label } => {\n+                let into_iter_fn = self.resolve_lang_item(LangItem::IntoIterIntoIter)?\n+                    .as_function().ok_or(MirLowerError::LangItemNotFound(LangItem::IntoIterIntoIter))?;\n+                let iter_next_fn = self.resolve_lang_item(LangItem::IteratorNext)?\n+                    .as_function().ok_or(MirLowerError::LangItemNotFound(LangItem::IteratorNext))?;\n+                let option_some = self.resolve_lang_item(LangItem::OptionSome)?\n+                    .as_enum_variant().ok_or(MirLowerError::LangItemNotFound(LangItem::OptionSome))?;\n+                let option = option_some.parent;\n+                let into_iter_fn_op = Operand::const_zst(\n+                    TyKind::FnDef(\n+                        self.db.intern_callable_def(CallableDefId::FunctionId(into_iter_fn)).into(),\n+                        Substitution::from1(Interner, self.expr_ty(iterable))\n+                    ).intern(Interner));\n+                let iter_next_fn_op = Operand::const_zst(\n+                    TyKind::FnDef(\n+                        self.db.intern_callable_def(CallableDefId::FunctionId(iter_next_fn)).into(),\n+                        Substitution::from1(Interner, self.expr_ty(iterable))\n+                    ).intern(Interner));\n+                let &Some(iterator_ty) = &self.infer.type_of_for_iterator.get(&expr_id) else {\n+                    return Err(MirLowerError::TypeError(\"unknown for loop iterator type\"));\n+                };\n+                let ref_mut_iterator_ty = TyKind::Ref(Mutability::Mut, static_lifetime(), iterator_ty.clone()).intern(Interner);\n+                let item_ty = &self.infer.type_of_pat[pat];\n+                let option_item_ty = TyKind::Adt(chalk_ir::AdtId(option.into()), Substitution::from1(Interner, item_ty.clone())).intern(Interner);\n+                let iterator_place: Place = self.temp(iterator_ty.clone())?.into();\n+                let option_item_place: Place = self.temp(option_item_ty.clone())?.into();\n+                let ref_mut_iterator_place: Place = self.temp(ref_mut_iterator_ty)?.into();\n+                let Some(current) = self.lower_call_and_args(into_iter_fn_op, Some(iterable).into_iter(), iterator_place.clone(), current, false)?\n+                else {\n+                    return Ok(None);\n+                };\n+                self.push_assignment(current, ref_mut_iterator_place.clone(), Rvalue::Ref(BorrowKind::Mut { allow_two_phase_borrow: false }, iterator_place), expr_id.into());\n+                self.lower_loop(current, label, |this, begin| {\n+                    let Some(current) = this.lower_call(iter_next_fn_op, vec![Operand::Copy(ref_mut_iterator_place)], option_item_place.clone(), begin, false)?\n+                    else {\n+                        return Ok(());\n+                    };\n+                    let end = this.current_loop_end()?;\n+                    let (current, _) = this.pattern_matching_variant(\n+                        option_item_ty.clone(),\n+                        BindingAnnotation::Unannotated,\n+                        option_item_place.into(),\n+                        option_some.into(),\n+                        current,\n+                        pat.into(),\n+                        Some(end),\n+                        &[pat], &None)?;\n+                    if let Some((_, block)) = this.lower_expr_as_place(current, body, true)? {\n+                        this.set_goto(block, begin);\n+                    }\n+                    Ok(())\n+                })\n+            },\n             Expr::Call { callee, args, .. } => {\n-                let callee_ty = self.expr_ty(*callee);\n+                let callee_ty = self.expr_ty_after_adjustments(*callee);\n                 match &callee_ty.data(Interner).kind {\n                     chalk_ir::TyKind::FnDef(..) => {\n                         let func = Operand::from_bytes(vec![], callee_ty.clone());\n-                        self.lower_call(func, args.iter().copied(), place, current)\n+                        self.lower_call_and_args(func, args.iter().copied(), place, current, self.is_uninhabited(expr_id))\n                     }\n                     TyKind::Scalar(_)\n                     | TyKind::Tuple(_, _)\n@@ -394,24 +468,28 @@ impl MirLowerCtx<'_> {\n             }\n             Expr::MethodCall { receiver, args, .. } => {\n                 let (func_id, generic_args) =\n-                    self.infer.method_resolution(expr_id).ok_or(MirLowerError::UnresolvedName)?;\n+                    self.infer.method_resolution(expr_id).ok_or(MirLowerError::UnresolvedMethod)?;\n                 let ty = chalk_ir::TyKind::FnDef(\n                     CallableDefId::FunctionId(func_id).to_chalk(self.db),\n                     generic_args,\n                 )\n                 .intern(Interner);\n                 let func = Operand::from_bytes(vec![], ty);\n-                self.lower_call(\n+                self.lower_call_and_args(\n                     func,\n                     iter::once(*receiver).chain(args.iter().copied()),\n                     place,\n                     current,\n+                    self.is_uninhabited(expr_id),\n                 )\n             }\n             Expr::Match { expr, arms } => {\n-                let (cond_place, mut current) = self.lower_expr_to_some_place(*expr, current)?;\n-                let cond_ty = self.expr_ty(*expr);\n-                let end = self.new_basic_block();\n+                let Some((cond_place, mut current)) = self.lower_expr_as_place(current, *expr, true)?\n+                else {\n+                    return Ok(None);\n+                };\n+                let cond_ty = self.expr_ty_after_adjustments(*expr);\n+                let mut end = None;\n                 for MatchArm { pat, guard, expr } in arms.iter() {\n                     if guard.is_some() {\n                         not_supported!(\"pattern matching with guard\");\n@@ -424,8 +502,10 @@ impl MirLowerCtx<'_> {\n                         *pat,\n                         BindingAnnotation::Unannotated,\n                     )?;\n-                    let block = self.lower_expr_to_place(*expr, place.clone(), then)?;\n-                    self.set_goto(block, end);\n+                    if let Some(block) = self.lower_expr_to_place(*expr, place.clone(), then)? {\n+                        let r = end.get_or_insert_with(|| self.new_basic_block());\n+                        self.set_goto(block, *r);\n+                    }\n                     match otherwise {\n                         Some(o) => current = o,\n                         None => {\n@@ -446,8 +526,7 @@ impl MirLowerCtx<'_> {\n                     let loop_data =\n                         self.current_loop_blocks.ok_or(MirLowerError::ContinueWithoutLoop)?;\n                     self.set_goto(current, loop_data.begin);\n-                    let otherwise = self.new_basic_block();\n-                    Ok(otherwise)\n+                    Ok(None)\n                 }\n             },\n             Expr::Break { expr, label } => {\n@@ -457,26 +536,33 @@ impl MirLowerCtx<'_> {\n                 match label {\n                     Some(_) => not_supported!(\"break with label\"),\n                     None => {\n-                        let loop_data =\n-                            self.current_loop_blocks.ok_or(MirLowerError::BreakWithoutLoop)?;\n-                        self.set_goto(current, loop_data.end);\n-                        Ok(self.new_basic_block())\n+                        let end =\n+                            self.current_loop_end()?;\n+                        self.set_goto(current, end);\n+                        Ok(None)\n                     }\n                 }\n             }\n             Expr::Return { expr } => {\n                 if let Some(expr) = expr {\n-                    current = self.lower_expr_to_place(*expr, return_slot().into(), current)?;\n+                    if let Some(c) = self.lower_expr_to_place(*expr, return_slot().into(), current)? {\n+                        current = c;\n+                    } else {\n+                        return Ok(None);\n+                    }\n                 }\n                 self.set_terminator(current, Terminator::Return);\n-                Ok(self.new_basic_block())\n+                Ok(None)\n             }\n             Expr::Yield { .. } => not_supported!(\"yield\"),\n-            Expr::RecordLit { fields, .. } => {\n+            Expr::RecordLit { fields, path, .. } => {\n                 let variant_id = self\n                     .infer\n                     .variant_resolution_for_expr(expr_id)\n-                    .ok_or(MirLowerError::UnresolvedName)?;\n+                    .ok_or_else(|| match path {\n+                        Some(p) => MirLowerError::UnresolvedName(p.display(self.db).to_string()),\n+                        None => MirLowerError::RecordLiteralWithoutPath,\n+                    })?;\n                 let subst = match self.expr_ty(expr_id).kind(Interner) {\n                     TyKind::Adt(_, s) => s.clone(),\n                     _ => not_supported!(\"Non ADT record literal\"),\n@@ -487,9 +573,11 @@ impl MirLowerCtx<'_> {\n                         let mut operands = vec![None; variant_data.fields().len()];\n                         for RecordLitField { name, expr } in fields.iter() {\n                             let field_id =\n-                                variant_data.field(name).ok_or(MirLowerError::UnresolvedName)?;\n-                            let op;\n-                            (op, current) = self.lower_expr_to_some_operand(*expr, current)?;\n+                                variant_data.field(name).ok_or(MirLowerError::UnresolvedField)?;\n+                            let Some((op, c)) = self.lower_expr_to_some_operand(*expr, current)? else {\n+                                return Ok(None);\n+                            };\n+                            current = c;\n                             operands[u32::from(field_id.into_raw()) as usize] = Some(op);\n                         }\n                         self.push_assignment(\n@@ -501,15 +589,16 @@ impl MirLowerCtx<'_> {\n                                     MirLowerError::TypeError(\"missing field in record literal\"),\n                                 )?,\n                             ),\n+                            expr_id.into(),\n                         );\n-                        Ok(current)\n+                        Ok(Some(current))\n                     }\n                     VariantId::UnionId(union_id) => {\n                         let [RecordLitField { name, expr }] = fields.as_ref() else {\n                             not_supported!(\"Union record literal with more than one field\");\n                         };\n                         let local_id =\n-                            variant_data.field(name).ok_or(MirLowerError::UnresolvedName)?;\n+                            variant_data.field(name).ok_or(MirLowerError::UnresolvedField)?;\n                         let mut place = place;\n                         place\n                             .projection\n@@ -518,84 +607,82 @@ impl MirLowerCtx<'_> {\n                     }\n                 }\n             }\n-            Expr::Field { expr, name } => {\n-                let (mut current_place, current) = self.lower_expr_to_some_place(*expr, current)?;\n-                if let TyKind::Tuple(..) = self.expr_ty(*expr).kind(Interner) {\n-                    let index = name\n-                        .as_tuple_index()\n-                        .ok_or(MirLowerError::TypeError(\"named field on tuple\"))?;\n-                    current_place.projection.push(ProjectionElem::TupleField(index))\n-                } else {\n-                    let field = self\n-                        .infer\n-                        .field_resolution(expr_id)\n-                        .ok_or(MirLowerError::UnresolvedName)?;\n-                    current_place.projection.push(ProjectionElem::Field(field));\n-                }\n-                self.push_assignment(current, place, Operand::Copy(current_place).into());\n-                Ok(current)\n-            }\n             Expr::Await { .. } => not_supported!(\"await\"),\n             Expr::Try { .. } => not_supported!(\"? operator\"),\n             Expr::Yeet { .. } => not_supported!(\"yeet\"),\n             Expr::TryBlock { .. } => not_supported!(\"try block\"),\n             Expr::Async { .. } => not_supported!(\"async block\"),\n             Expr::Const { .. } => not_supported!(\"anonymous const block\"),\n             Expr::Cast { expr, type_ref: _ } => {\n-                let (x, current) = self.lower_expr_to_some_operand(*expr, current)?;\n+                let Some((x, current)) = self.lower_expr_to_some_operand(*expr, current)? else {\n+                    return Ok(None);\n+                };\n                 let source_ty = self.infer[*expr].clone();\n                 let target_ty = self.infer[expr_id].clone();\n                 self.push_assignment(\n                     current,\n                     place,\n                     Rvalue::Cast(cast_kind(&source_ty, &target_ty)?, x, target_ty),\n+                    expr_id.into(),\n                 );\n-                Ok(current)\n+                Ok(Some(current))\n             }\n             Expr::Ref { expr, rawness: _, mutability } => {\n-                let p;\n-                (p, current) = self.lower_expr_to_some_place(*expr, current)?;\n+                let Some((p, current)) = self.lower_expr_as_place(current, *expr, true)? else {\n+                    return Ok(None);\n+                };\n                 let bk = BorrowKind::from_hir(*mutability);\n-                self.push_assignment(current, place, Rvalue::Ref(bk, p));\n-                Ok(current)\n+                self.push_assignment(current, place, Rvalue::Ref(bk, p), expr_id.into());\n+                Ok(Some(current))\n             }\n             Expr::Box { .. } => not_supported!(\"box expression\"),\n-            Expr::UnaryOp { expr, op } => match op {\n-                hir_def::expr::UnaryOp::Deref => {\n-                    let (mut tmp, current) = self.lower_expr_to_some_place(*expr, current)?;\n-                    tmp.projection.push(ProjectionElem::Deref);\n-                    self.push_assignment(current, place, Operand::Copy(tmp).into());\n-                    Ok(current)\n-                }\n-                hir_def::expr::UnaryOp::Not => {\n-                    let (op, current) = self.lower_expr_to_some_operand(*expr, current)?;\n-                    self.push_assignment(current, place, Rvalue::UnaryOp(UnOp::Not, op));\n-                    Ok(current)\n-                }\n-                hir_def::expr::UnaryOp::Neg => {\n-                    let (op, current) = self.lower_expr_to_some_operand(*expr, current)?;\n-                    self.push_assignment(current, place, Rvalue::UnaryOp(UnOp::Neg, op));\n-                    Ok(current)\n-                }\n+            Expr::Field { .. } | Expr::Index { .. } | Expr::UnaryOp { op: hir_def::expr::UnaryOp::Deref, .. } => {\n+                let Some((p, current)) = self.lower_expr_as_place(current, expr_id, true)? else {\n+                    return Ok(None);\n+                };\n+                self.push_assignment(current, place, Operand::Copy(p).into(), expr_id.into());\n+                Ok(Some(current))\n+            }\n+            Expr::UnaryOp { expr, op: op @ (hir_def::expr::UnaryOp::Not | hir_def::expr::UnaryOp::Neg) } => {\n+                let Some((operand, current)) = self.lower_expr_to_some_operand(*expr, current)? else {\n+                    return Ok(None);\n+                };\n+                let operation = match op {\n+                    hir_def::expr::UnaryOp::Not => UnOp::Not,\n+                    hir_def::expr::UnaryOp::Neg => UnOp::Neg,\n+                    _ => unreachable!(),\n+                };\n+                self.push_assignment(\n+                    current,\n+                    place,\n+                    Rvalue::UnaryOp(operation, operand),\n+                    expr_id.into(),\n+                );\n+                Ok(Some(current))\n             },\n             Expr::BinaryOp { lhs, rhs, op } => {\n                 let op = op.ok_or(MirLowerError::IncompleteExpr)?;\n                 if let hir_def::expr::BinaryOp::Assignment { op } = op {\n                     if op.is_some() {\n                         not_supported!(\"assignment with arith op (like +=)\");\n                     }\n-                    let Some(lhs_place) = self.lower_expr_as_place(*lhs) else {\n-                        not_supported!(\"assignment to complex place\");\n+                    let Some((lhs_place, current)) =\n+                        self.lower_expr_as_place(current, *lhs, false)?\n+                    else {\n+                        return Ok(None);\n                     };\n-                    let rhs_op;\n-                    (rhs_op, current) = self.lower_expr_to_some_operand(*rhs, current)?;\n-                    self.push_assignment(current, lhs_place, rhs_op.into());\n-                    return Ok(current);\n+                    let Some((rhs_op, current)) = self.lower_expr_to_some_operand(*rhs, current)? else {\n+                        return Ok(None);\n+                    };\n+                    self.push_assignment(current, lhs_place, rhs_op.into(), expr_id.into());\n+                    return Ok(Some(current));\n                 }\n-                let lhs_op;\n-                (lhs_op, current) = self.lower_expr_to_some_operand(*lhs, current)?;\n-                let rhs_op;\n-                (rhs_op, current) = self.lower_expr_to_some_operand(*rhs, current)?;\n+                let Some((lhs_op, current)) = self.lower_expr_to_some_operand(*lhs, current)? else {\n+                    return Ok(None);\n+                };\n+                let Some((rhs_op, current)) = self.lower_expr_to_some_operand(*rhs, current)? else {\n+                    return Ok(None);\n+                };\n                 self.push_assignment(\n                     current,\n                     place,\n@@ -612,34 +699,32 @@ impl MirLowerCtx<'_> {\n                         lhs_op,\n                         rhs_op,\n                     ),\n+                    expr_id.into(),\n                 );\n-                Ok(current)\n+                Ok(Some(current))\n             }\n             Expr::Range { .. } => not_supported!(\"range\"),\n-            Expr::Index { base, index } => {\n-                let mut p_base;\n-                (p_base, current) = self.lower_expr_to_some_place(*base, current)?;\n-                let l_index = self.temp(self.expr_ty(*index))?;\n-                current = self.lower_expr_to_place(*index, l_index.into(), current)?;\n-                p_base.projection.push(ProjectionElem::Index(l_index));\n-                self.push_assignment(current, place, Operand::Copy(p_base).into());\n-                Ok(current)\n-            }\n             Expr::Closure { .. } => not_supported!(\"closure\"),\n             Expr::Tuple { exprs, is_assignee_expr: _ } => {\n-                let r = Rvalue::Aggregate(\n-                    AggregateKind::Tuple(self.expr_ty(expr_id)),\n-                    exprs\n+                let Some(values) = exprs\n                         .iter()\n                         .map(|x| {\n-                            let o;\n-                            (o, current) = self.lower_expr_to_some_operand(*x, current)?;\n-                            Ok(o)\n+                            let Some((o, c)) = self.lower_expr_to_some_operand(*x, current)? else {\n+                                return Ok(None);\n+                            };\n+                            current = c;\n+                            Ok(Some(o))\n                         })\n-                        .collect::<Result<_>>()?,\n+                        .collect::<Result<Option<_>>>()?\n+                else {\n+                    return Ok(None);\n+                };\n+                let r = Rvalue::Aggregate(\n+                    AggregateKind::Tuple(self.expr_ty(expr_id)),\n+                    values,\n                 );\n-                self.push_assignment(current, place, r);\n-                Ok(current)\n+                self.push_assignment(current, place, r, expr_id.into());\n+                Ok(Some(current))\n             }\n             Expr::Array(l) => match l {\n                 Array::ElementList { elements, .. } => {\n@@ -651,86 +736,54 @@ impl MirLowerCtx<'_> {\n                             ))\n                         }\n                     };\n-                    let r = Rvalue::Aggregate(\n-                        AggregateKind::Array(elem_ty),\n-                        elements\n+                    let Some(values) = elements\n                             .iter()\n                             .map(|x| {\n-                                let o;\n-                                (o, current) = self.lower_expr_to_some_operand(*x, current)?;\n-                                Ok(o)\n+                                let Some((o, c)) = self.lower_expr_to_some_operand(*x, current)? else {\n+                                    return Ok(None);\n+                                };\n+                                current = c;\n+                                Ok(Some(o))\n                             })\n-                            .collect::<Result<_>>()?,\n+                            .collect::<Result<Option<_>>>()?\n+                    else {\n+                        return Ok(None);\n+                    };\n+                    let r = Rvalue::Aggregate(\n+                        AggregateKind::Array(elem_ty),\n+                        values,\n                     );\n-                    self.push_assignment(current, place, r);\n-                    Ok(current)\n+                    self.push_assignment(current, place, r, expr_id.into());\n+                    Ok(Some(current))\n                 }\n                 Array::Repeat { .. } => not_supported!(\"array repeat\"),\n             },\n             Expr::Literal(l) => {\n                 let ty = self.expr_ty(expr_id);\n                 let op = self.lower_literal_to_operand(ty, l)?;\n-                self.push_assignment(current, place, op.into());\n-                Ok(current)\n+                self.push_assignment(current, place, op.into(), expr_id.into());\n+                Ok(Some(current))\n             }\n             Expr::Underscore => not_supported!(\"underscore\"),\n         }\n     }\n \n-    fn lower_block_to_place(\n-        &mut self,\n-        label: Option<LabelId>,\n-        statements: &[hir_def::expr::Statement],\n-        mut current: BasicBlockId,\n-        tail: Option<ExprId>,\n-        place: Place,\n-    ) -> Result<BasicBlockId> {\n-        if label.is_some() {\n-            not_supported!(\"block with label\");\n-        }\n-        for statement in statements.iter() {\n-            match statement {\n-                hir_def::expr::Statement::Let { pat, initializer, else_branch, type_ref: _ } => {\n-                    match initializer {\n-                        Some(expr_id) => {\n-                            let else_block;\n-                            let init_place;\n-                            (init_place, current) =\n-                                self.lower_expr_to_some_place(*expr_id, current)?;\n-                            (current, else_block) = self.pattern_match(\n-                                current,\n-                                None,\n-                                init_place,\n-                                self.expr_ty(*expr_id),\n-                                *pat,\n-                                BindingAnnotation::Unannotated,\n-                            )?;\n-                            match (else_block, else_branch) {\n-                                (None, _) => (),\n-                                (Some(else_block), None) => {\n-                                    self.set_terminator(else_block, Terminator::Unreachable);\n-                                }\n-                                (Some(else_block), Some(else_branch)) => {\n-                                    let (_, b) =\n-                                        self.lower_expr_to_some_place(*else_branch, else_block)?;\n-                                    self.set_terminator(b, Terminator::Unreachable);\n-                                }\n-                            }\n-                        }\n-                        None => continue,\n-                    }\n-                }\n-                hir_def::expr::Statement::Expr { expr, has_semi: _ } => {\n-                    let ty = self.expr_ty(*expr);\n-                    let temp = self.temp(ty)?;\n-                    current = self.lower_expr_to_place(*expr, temp.into(), current)?;\n-                }\n+    fn push_field_projection(&self, place: &mut Place, expr_id: ExprId) -> Result<()> {\n+        if let Expr::Field { expr, name } = &self.body[expr_id] {\n+            if let TyKind::Tuple(..) = self.expr_ty_after_adjustments(*expr).kind(Interner) {\n+                let index = name\n+                    .as_tuple_index()\n+                    .ok_or(MirLowerError::TypeError(\"named field on tuple\"))?;\n+                place.projection.push(ProjectionElem::TupleField(index))\n+            } else {\n+                let field =\n+                    self.infer.field_resolution(expr_id).ok_or(MirLowerError::UnresolvedField)?;\n+                place.projection.push(ProjectionElem::Field(field));\n             }\n+        } else {\n+            not_supported!(\"\")\n         }\n-        match tail {\n-            Some(tail) => self.lower_expr_to_place(tail, place, current),\n-            None => Ok(current),\n-        }\n+        Ok(())\n     }\n \n     fn lower_literal_to_operand(&mut self, ty: Ty, l: &Literal) -> Result<Operand> {\n@@ -779,19 +832,21 @@ impl MirLowerCtx<'_> {\n         const_id: hir_def::ConstId,\n         prev_block: BasicBlockId,\n         place: Place,\n-    ) -> Result<BasicBlockId> {\n+        span: MirSpan,\n+    ) -> Result<()> {\n         let c = self.db.const_eval(const_id)?;\n-        self.write_const_to_place(c, prev_block, place)\n+        self.write_const_to_place(c, prev_block, place, span)\n     }\n \n     fn write_const_to_place(\n         &mut self,\n         c: Const,\n         prev_block: BasicBlockId,\n         place: Place,\n-    ) -> Result<BasicBlockId> {\n-        self.push_assignment(prev_block, place, Operand::Constant(c).into());\n-        Ok(prev_block)\n+        span: MirSpan,\n+    ) -> Result<()> {\n+        self.push_assignment(prev_block, place, Operand::Constant(c).into(), span);\n+        Ok(())\n     }\n \n     fn write_bytes_to_place(\n@@ -800,9 +855,10 @@ impl MirLowerCtx<'_> {\n         place: Place,\n         cv: Vec<u8>,\n         ty: Ty,\n-    ) -> Result<BasicBlockId> {\n-        self.push_assignment(prev_block, place, Operand::from_bytes(cv, ty).into());\n-        Ok(prev_block)\n+        span: MirSpan,\n+    ) -> Result<()> {\n+        self.push_assignment(prev_block, place, Operand::from_bytes(cv, ty).into(), span);\n+        Ok(())\n     }\n \n     fn lower_enum_variant(\n@@ -812,6 +868,7 @@ impl MirLowerCtx<'_> {\n         place: Place,\n         ty: Ty,\n         fields: Vec<Operand>,\n+        span: MirSpan,\n     ) -> Result<BasicBlockId> {\n         let subst = match ty.kind(Interner) {\n             TyKind::Adt(_, subst) => subst.clone(),\n@@ -821,36 +878,51 @@ impl MirLowerCtx<'_> {\n             prev_block,\n             place,\n             Rvalue::Aggregate(AggregateKind::Adt(variant_id.into(), subst), fields),\n+            span,\n         );\n         Ok(prev_block)\n     }\n \n-    fn lower_call(\n+    fn lower_call_and_args(\n         &mut self,\n         func: Operand,\n         args: impl Iterator<Item = ExprId>,\n         place: Place,\n         mut current: BasicBlockId,\n-    ) -> Result<BasicBlockId> {\n-        let args = args\n+        is_uninhabited: bool,\n+    ) -> Result<Option<BasicBlockId>> {\n+        let Some(args) = args\n             .map(|arg| {\n-                let temp;\n-                (temp, current) = self.lower_expr_to_some_operand(arg, current)?;\n-                Ok(temp)\n+                if let Some((temp, c)) = self.lower_expr_to_some_operand(arg, current)? {\n+                    current = c;\n+                    Ok(Some(temp))\n+                } else {\n+                    Ok(None)\n+                }\n             })\n-            .collect::<Result<Vec<_>>>()?;\n-        let b = self.result.basic_blocks.alloc(BasicBlock {\n-            statements: vec![],\n-            terminator: None,\n-            is_cleanup: false,\n-        });\n+            .collect::<Result<Option<Vec<_>>>>()?\n+        else {\n+            return Ok(None);\n+        };\n+        self.lower_call(func, args, place, current, is_uninhabited)\n+    }\n+\n+    fn lower_call(\n+        &mut self,\n+        func: Operand,\n+        args: Vec<Operand>,\n+        place: Place,\n+        current: BasicBlockId,\n+        is_uninhabited: bool,\n+    ) -> Result<Option<BasicBlockId>> {\n+        let b = if is_uninhabited { None } else { Some(self.new_basic_block()) };\n         self.set_terminator(\n             current,\n             Terminator::Call {\n                 func,\n                 args,\n                 destination: place,\n-                target: Some(b),\n+                target: b,\n                 cleanup: None,\n                 from_hir_call: true,\n             },\n@@ -874,8 +946,28 @@ impl MirLowerCtx<'_> {\n         self.infer[e].clone()\n     }\n \n-    fn push_assignment(&mut self, block: BasicBlockId, place: Place, rvalue: Rvalue) {\n-        self.result.basic_blocks[block].statements.push(Statement::Assign(place, rvalue));\n+    fn expr_ty_after_adjustments(&self, e: ExprId) -> Ty {\n+        let mut ty = None;\n+        if let Some(x) = self.infer.expr_adjustments.get(&e) {\n+            if let Some(x) = x.last() {\n+                ty = Some(x.target.clone());\n+            }\n+        }\n+        ty.unwrap_or_else(|| self.expr_ty(e))\n+    }\n+\n+    fn push_statement(&mut self, block: BasicBlockId, statement: Statement) {\n+        self.result.basic_blocks[block].statements.push(statement);\n+    }\n+\n+    fn push_assignment(\n+        &mut self,\n+        block: BasicBlockId,\n+        place: Place,\n+        rvalue: Rvalue,\n+        span: MirSpan,\n+    ) {\n+        self.push_statement(block, StatementKind::Assign(place, rvalue).with_span(span));\n     }\n \n     /// It gets a `current` unterminated block, appends some statements and possibly a terminator to it to check if\n@@ -924,11 +1016,50 @@ impl MirLowerCtx<'_> {\n                     binding_mode,\n                 )?\n             }\n-            Pat::Or(_) => not_supported!(\"or pattern\"),\n+            Pat::Or(pats) => {\n+                let then_target = self.new_basic_block();\n+                let mut finished = false;\n+                for pat in &**pats {\n+                    let (next, next_else) = self.pattern_match(\n+                        current,\n+                        None,\n+                        cond_place.clone(),\n+                        cond_ty.clone(),\n+                        *pat,\n+                        binding_mode,\n+                    )?;\n+                    self.set_goto(next, then_target);\n+                    match next_else {\n+                        Some(t) => {\n+                            current = t;\n+                        }\n+                        None => {\n+                            finished = true;\n+                            break;\n+                        }\n+                    }\n+                }\n+                (then_target, (!finished).then_some(current))\n+            }\n             Pat::Record { .. } => not_supported!(\"record pattern\"),\n             Pat::Range { .. } => not_supported!(\"range pattern\"),\n             Pat::Slice { .. } => not_supported!(\"slice pattern\"),\n-            Pat::Path(_) => not_supported!(\"path pattern\"),\n+            Pat::Path(_) => {\n+                let Some(variant) = self.infer.variant_resolution_for_pat(pattern) else {\n+                    not_supported!(\"unresolved variant\");\n+                };\n+                self.pattern_matching_variant(\n+                    cond_ty,\n+                    binding_mode,\n+                    cond_place,\n+                    variant,\n+                    current,\n+                    pattern.into(),\n+                    current_else,\n+                    &[],\n+                    &None,\n+                )?\n+            }\n             Pat::Lit(l) => {\n                 let then_target = self.new_basic_block();\n                 let else_target = current_else.unwrap_or_else(|| self.new_basic_block());\n@@ -962,8 +1093,9 @@ impl MirLowerCtx<'_> {\n                 }\n                 (then_target, Some(else_target))\n             }\n-            Pat::Bind { mode, name: _, subpat } => {\n-                let target_place = self.binding_locals[pattern];\n+            Pat::Bind { id, subpat } => {\n+                let target_place = self.result.binding_locals[*id];\n+                let mode = self.body.bindings[*id].mode;\n                 if let Some(subpat) = subpat {\n                     (current, current_else) = self.pattern_match(\n                         current,\n@@ -975,8 +1107,9 @@ impl MirLowerCtx<'_> {\n                     )?\n                 }\n                 if matches!(mode, BindingAnnotation::Ref | BindingAnnotation::RefMut) {\n-                    binding_mode = *mode;\n+                    binding_mode = mode;\n                 }\n+                self.push_storage_live(*id, current)?;\n                 self.push_assignment(\n                     current,\n                     target_place.into(),\n@@ -990,88 +1123,109 @@ impl MirLowerCtx<'_> {\n                             cond_place,\n                         ),\n                     },\n+                    pattern.into(),\n                 );\n                 (current, current_else)\n             }\n             Pat::TupleStruct { path: _, args, ellipsis } => {\n                 let Some(variant) = self.infer.variant_resolution_for_pat(pattern) else {\n                     not_supported!(\"unresolved variant\");\n                 };\n-                pattern_matching_dereference(&mut cond_ty, &mut binding_mode, &mut cond_place);\n-                let subst = match cond_ty.kind(Interner) {\n-                    TyKind::Adt(_, s) => s,\n-                    _ => {\n-                        return Err(MirLowerError::TypeError(\n-                            \"non adt type matched with tuple struct\",\n-                        ))\n-                    }\n-                };\n-                let fields_type = self.db.field_types(variant);\n-                match variant {\n-                    VariantId::EnumVariantId(v) => {\n-                        let e = self.db.const_eval_discriminant(v)? as u128;\n-                        let next = self.new_basic_block();\n-                        let tmp = self.discr_temp_place();\n-                        self.push_assignment(\n-                            current,\n-                            tmp.clone(),\n-                            Rvalue::Discriminant(cond_place.clone()),\n-                        );\n-                        let else_target = current_else.unwrap_or_else(|| self.new_basic_block());\n-                        self.set_terminator(\n-                            current,\n-                            Terminator::SwitchInt {\n-                                discr: Operand::Copy(tmp),\n-                                targets: SwitchTargets::static_if(e, next, else_target),\n-                            },\n-                        );\n-                        let enum_data = self.db.enum_data(v.parent);\n-                        let fields =\n-                            enum_data.variants[v.local_id].variant_data.fields().iter().map(\n-                                |(x, _)| {\n-                                    (\n-                                        PlaceElem::Field(FieldId { parent: v.into(), local_id: x }),\n-                                        fields_type[x].clone().substitute(Interner, subst),\n-                                    )\n-                                },\n-                            );\n-                        self.pattern_match_tuple_like(\n-                            next,\n-                            Some(else_target),\n-                            args.iter().zip(fields).map(|(x, y)| (y.0, *x, y.1)),\n-                            *ellipsis,\n-                            &cond_place,\n-                            binding_mode,\n-                        )?\n-                    }\n-                    VariantId::StructId(s) => {\n-                        let struct_data = self.db.struct_data(s);\n-                        let fields = struct_data.variant_data.fields().iter().map(|(x, _)| {\n-                            (\n-                                PlaceElem::Field(FieldId { parent: s.into(), local_id: x }),\n-                                fields_type[x].clone().substitute(Interner, subst),\n-                            )\n-                        });\n-                        self.pattern_match_tuple_like(\n-                            current,\n-                            current_else,\n-                            args.iter().zip(fields).map(|(x, y)| (y.0, *x, y.1)),\n-                            *ellipsis,\n-                            &cond_place,\n-                            binding_mode,\n-                        )?\n-                    }\n-                    VariantId::UnionId(_) => {\n-                        return Err(MirLowerError::TypeError(\"pattern matching on union\"))\n-                    }\n-                }\n+                self.pattern_matching_variant(\n+                    cond_ty,\n+                    binding_mode,\n+                    cond_place,\n+                    variant,\n+                    current,\n+                    pattern.into(),\n+                    current_else,\n+                    args,\n+                    ellipsis,\n+                )?\n             }\n             Pat::Ref { .. } => not_supported!(\"& pattern\"),\n             Pat::Box { .. } => not_supported!(\"box pattern\"),\n             Pat::ConstBlock(_) => not_supported!(\"const block pattern\"),\n         })\n     }\n \n+    fn pattern_matching_variant(\n+        &mut self,\n+        mut cond_ty: Ty,\n+        mut binding_mode: BindingAnnotation,\n+        mut cond_place: Place,\n+        variant: VariantId,\n+        current: BasicBlockId,\n+        span: MirSpan,\n+        current_else: Option<BasicBlockId>,\n+        args: &[PatId],\n+        ellipsis: &Option<usize>,\n+    ) -> Result<(BasicBlockId, Option<BasicBlockId>)> {\n+        pattern_matching_dereference(&mut cond_ty, &mut binding_mode, &mut cond_place);\n+        let subst = match cond_ty.kind(Interner) {\n+            TyKind::Adt(_, s) => s,\n+            _ => return Err(MirLowerError::TypeError(\"non adt type matched with tuple struct\")),\n+        };\n+        let fields_type = self.db.field_types(variant);\n+        Ok(match variant {\n+            VariantId::EnumVariantId(v) => {\n+                let e = self.db.const_eval_discriminant(v)? as u128;\n+                let next = self.new_basic_block();\n+                let tmp = self.discr_temp_place();\n+                self.push_assignment(\n+                    current,\n+                    tmp.clone(),\n+                    Rvalue::Discriminant(cond_place.clone()),\n+                    span,\n+                );\n+                let else_target = current_else.unwrap_or_else(|| self.new_basic_block());\n+                self.set_terminator(\n+                    current,\n+                    Terminator::SwitchInt {\n+                        discr: Operand::Copy(tmp),\n+                        targets: SwitchTargets::static_if(e, next, else_target),\n+                    },\n+                );\n+                let enum_data = self.db.enum_data(v.parent);\n+                let fields =\n+                    enum_data.variants[v.local_id].variant_data.fields().iter().map(|(x, _)| {\n+                        (\n+                            PlaceElem::Field(FieldId { parent: v.into(), local_id: x }),\n+                            fields_type[x].clone().substitute(Interner, subst),\n+                        )\n+                    });\n+                self.pattern_match_tuple_like(\n+                    next,\n+                    Some(else_target),\n+                    args.iter().zip(fields).map(|(x, y)| (y.0, *x, y.1)),\n+                    *ellipsis,\n+                    &cond_place,\n+                    binding_mode,\n+                )?\n+            }\n+            VariantId::StructId(s) => {\n+                let struct_data = self.db.struct_data(s);\n+                let fields = struct_data.variant_data.fields().iter().map(|(x, _)| {\n+                    (\n+                        PlaceElem::Field(FieldId { parent: s.into(), local_id: x }),\n+                        fields_type[x].clone().substitute(Interner, subst),\n+                    )\n+                });\n+                self.pattern_match_tuple_like(\n+                    current,\n+                    current_else,\n+                    args.iter().zip(fields).map(|(x, y)| (y.0, *x, y.1)),\n+                    *ellipsis,\n+                    &cond_place,\n+                    binding_mode,\n+                )?\n+            }\n+            VariantId::UnionId(_) => {\n+                return Err(MirLowerError::TypeError(\"pattern matching on union\"))\n+            }\n+        })\n+    }\n+\n     fn pattern_match_tuple_like(\n         &mut self,\n         mut current: BasicBlockId,\n@@ -1109,23 +1263,161 @@ impl MirLowerCtx<'_> {\n         &mut self,\n         prev_block: BasicBlockId,\n         label: Option<LabelId>,\n-        f: impl FnOnce(&mut MirLowerCtx<'_>, BasicBlockId, BasicBlockId) -> Result<()>,\n-    ) -> Result<BasicBlockId> {\n+        f: impl FnOnce(&mut MirLowerCtx<'_>, BasicBlockId) -> Result<()>,\n+    ) -> Result<Option<BasicBlockId>> {\n         if label.is_some() {\n             not_supported!(\"loop with label\");\n         }\n         let begin = self.new_basic_block();\n-        let end = self.new_basic_block();\n-        let prev = mem::replace(&mut self.current_loop_blocks, Some(LoopBlocks { begin, end }));\n+        let prev =\n+            mem::replace(&mut self.current_loop_blocks, Some(LoopBlocks { begin, end: None }));\n         self.set_goto(prev_block, begin);\n-        f(self, begin, end)?;\n-        self.current_loop_blocks = prev;\n-        Ok(end)\n+        f(self, begin)?;\n+        let my = mem::replace(&mut self.current_loop_blocks, prev)\n+            .ok_or(MirLowerError::ImplementationError(\"current_loop_blocks is corrupt\"))?;\n+        Ok(my.end)\n     }\n \n     fn has_adjustments(&self, expr_id: ExprId) -> bool {\n         !self.infer.expr_adjustments.get(&expr_id).map(|x| x.is_empty()).unwrap_or(true)\n     }\n+\n+    fn merge_blocks(\n+        &mut self,\n+        b1: Option<BasicBlockId>,\n+        b2: Option<BasicBlockId>,\n+    ) -> Option<BasicBlockId> {\n+        match (b1, b2) {\n+            (None, None) => None,\n+            (None, Some(b)) | (Some(b), None) => Some(b),\n+            (Some(b1), Some(b2)) => {\n+                let bm = self.new_basic_block();\n+                self.set_goto(b1, bm);\n+                self.set_goto(b2, bm);\n+                Some(bm)\n+            }\n+        }\n+    }\n+\n+    fn current_loop_end(&mut self) -> Result<BasicBlockId> {\n+        let r = match self\n+            .current_loop_blocks\n+            .as_mut()\n+            .ok_or(MirLowerError::ImplementationError(\"Current loop access out of loop\"))?\n+            .end\n+        {\n+            Some(x) => x,\n+            None => {\n+                let s = self.new_basic_block();\n+                self.current_loop_blocks\n+                    .as_mut()\n+                    .ok_or(MirLowerError::ImplementationError(\"Current loop access out of loop\"))?\n+                    .end = Some(s);\n+                s\n+            }\n+        };\n+        Ok(r)\n+    }\n+\n+    fn is_uninhabited(&self, expr_id: ExprId) -> bool {\n+        is_ty_uninhabited_from(&self.infer[expr_id], self.owner.module(self.db.upcast()), self.db)\n+    }\n+\n+    /// This function push `StorageLive` statements for each binding in the pattern.\n+    fn push_storage_live(&mut self, b: BindingId, current: BasicBlockId) -> Result<()> {\n+        // Current implementation is wrong. It adds no `StorageDead` at the end of scope, and before each break\n+        // and continue. It just add a `StorageDead` before the `StorageLive`, which is not wrong, but unneeeded in\n+        // the proper implementation. Due this limitation, implementing a borrow checker on top of this mir will falsely\n+        // allow this:\n+        //\n+        // ```\n+        // let x;\n+        // loop {\n+        //     let y = 2;\n+        //     x = &y;\n+        //     if some_condition {\n+        //         break; // we need to add a StorageDead(y) above this to kill the x borrow\n+        //     }\n+        // }\n+        // use(x)\n+        // ```\n+        // But I think this approach work for mutability analysis, as user can't write code which mutates a binding\n+        // after StorageDead, except loops, which are handled by this hack.\n+        let span = self.body.bindings[b]\n+            .definitions\n+            .first()\n+            .copied()\n+            .map(MirSpan::PatId)\n+            .unwrap_or(MirSpan::Unknown);\n+        let l = self.result.binding_locals[b];\n+        self.push_statement(current, StatementKind::StorageDead(l).with_span(span));\n+        self.push_statement(current, StatementKind::StorageLive(l).with_span(span));\n+        Ok(())\n+    }\n+\n+    fn resolve_lang_item(&self, item: LangItem) -> Result<LangItemTarget> {\n+        let crate_id = self.owner.module(self.db.upcast()).krate();\n+        self.db.lang_item(crate_id, item).ok_or(MirLowerError::LangItemNotFound(item))\n+    }\n+\n+    fn lower_block_to_place(\n+        &mut self,\n+        label: Option<LabelId>,\n+        statements: &[hir_def::expr::Statement],\n+        mut current: BasicBlockId,\n+        tail: Option<ExprId>,\n+        place: Place,\n+    ) -> Result<Option<Idx<BasicBlock>>> {\n+        if label.is_some() {\n+            not_supported!(\"block with label\");\n+        }\n+        for statement in statements.iter() {\n+            match statement {\n+                hir_def::expr::Statement::Let { pat, initializer, else_branch, type_ref: _ } => {\n+                    if let Some(expr_id) = initializer {\n+                        let else_block;\n+                        let Some((init_place, c)) =\n+                        self.lower_expr_as_place(current, *expr_id, true)?\n+                    else {\n+                        return Ok(None);\n+                    };\n+                        current = c;\n+                        (current, else_block) = self.pattern_match(\n+                            current,\n+                            None,\n+                            init_place,\n+                            self.expr_ty_after_adjustments(*expr_id),\n+                            *pat,\n+                            BindingAnnotation::Unannotated,\n+                        )?;\n+                        match (else_block, else_branch) {\n+                            (None, _) => (),\n+                            (Some(else_block), None) => {\n+                                self.set_terminator(else_block, Terminator::Unreachable);\n+                            }\n+                            (Some(else_block), Some(else_branch)) => {\n+                                if let Some((_, b)) =\n+                                    self.lower_expr_as_place(else_block, *else_branch, true)?\n+                                {\n+                                    self.set_terminator(b, Terminator::Unreachable);\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                hir_def::expr::Statement::Expr { expr, has_semi: _ } => {\n+                    let Some((_, c)) = self.lower_expr_as_place(current, *expr, true)? else {\n+                        return Ok(None);\n+                    };\n+                    current = c;\n+                }\n+            }\n+        }\n+        match tail {\n+            Some(tail) => self.lower_expr_to_place(tail, place, current),\n+            None => Ok(Some(current)),\n+        }\n+    }\n }\n \n fn pattern_matching_dereference(\n@@ -1161,9 +1453,20 @@ fn cast_kind(source_ty: &Ty, target_ty: &Ty) -> Result<CastKind> {\n }\n \n pub fn mir_body_query(db: &dyn HirDatabase, def: DefWithBodyId) -> Result<Arc<MirBody>> {\n+    let _p = profile::span(\"mir_body_query\").detail(|| match def {\n+        DefWithBodyId::FunctionId(it) => db.function_data(it).name.to_string(),\n+        DefWithBodyId::StaticId(it) => db.static_data(it).name.clone().to_string(),\n+        DefWithBodyId::ConstId(it) => {\n+            db.const_data(it).name.clone().unwrap_or_else(Name::missing).to_string()\n+        }\n+        DefWithBodyId::VariantId(it) => {\n+            db.enum_data(it.parent).variants[it.local_id].name.to_string()\n+        }\n+    });\n     let body = db.body(def);\n     let infer = db.infer(def);\n-    Ok(Arc::new(lower_to_mir(db, def, &body, &infer, body.body_expr)?))\n+    let result = lower_to_mir(db, def, &body, &infer, body.body_expr)?;\n+    Ok(Arc::new(result))\n }\n \n pub fn mir_body_recover(\n@@ -1183,37 +1486,88 @@ pub fn lower_to_mir(\n     // need to take this input explicitly.\n     root_expr: ExprId,\n ) -> Result<MirBody> {\n+    if let Some((_, x)) = infer.type_mismatches().next() {\n+        return Err(MirLowerError::TypeMismatch(x.clone()));\n+    }\n     let mut basic_blocks = Arena::new();\n     let start_block =\n         basic_blocks.alloc(BasicBlock { statements: vec![], terminator: None, is_cleanup: false });\n     let mut locals = Arena::new();\n     // 0 is return local\n-    locals.alloc(Local { mutability: Mutability::Mut, ty: infer[root_expr].clone() });\n-    let mut create_local_of_path = |p: PatId| {\n-        // FIXME: mutablity is broken\n-        locals.alloc(Local { mutability: Mutability::Not, ty: infer[p].clone() })\n-    };\n+    locals.alloc(Local { ty: infer[root_expr].clone() });\n+    let mut binding_locals: ArenaMap<BindingId, LocalId> = ArenaMap::new();\n     // 1 to param_len is for params\n-    let mut binding_locals: ArenaMap<PatId, LocalId> =\n-        body.params.iter().map(|&x| (x, create_local_of_path(x))).collect();\n+    let param_locals: Vec<LocalId> = if let DefWithBodyId::FunctionId(fid) = owner {\n+        let substs = TyBuilder::placeholder_subst(db, fid);\n+        let callable_sig = db.callable_item_signature(fid.into()).substitute(Interner, &substs);\n+        body.params\n+            .iter()\n+            .zip(callable_sig.params().iter())\n+            .map(|(&x, ty)| {\n+                let local_id = locals.alloc(Local { ty: ty.clone() });\n+                if let Pat::Bind { id, subpat: None } = body[x] {\n+                    if matches!(\n+                        body.bindings[id].mode,\n+                        BindingAnnotation::Unannotated | BindingAnnotation::Mutable\n+                    ) {\n+                        binding_locals.insert(id, local_id);\n+                    }\n+                }\n+                local_id\n+            })\n+            .collect()\n+    } else {\n+        if !body.params.is_empty() {\n+            return Err(MirLowerError::TypeError(\"Unexpected parameter for non function body\"));\n+        }\n+        vec![]\n+    };\n     // and then rest of bindings\n-    for (pat_id, _) in body.pats.iter() {\n-        if !binding_locals.contains_idx(pat_id) {\n-            binding_locals.insert(pat_id, create_local_of_path(pat_id));\n+    for (id, _) in body.bindings.iter() {\n+        if !binding_locals.contains_idx(id) {\n+            binding_locals.insert(id, locals.alloc(Local { ty: infer[id].clone() }));\n         }\n     }\n-    let mir = MirBody { basic_blocks, locals, start_block, owner, arg_count: body.params.len() };\n+    let mir = MirBody {\n+        basic_blocks,\n+        locals,\n+        start_block,\n+        binding_locals,\n+        param_locals,\n+        owner,\n+        arg_count: body.params.len(),\n+    };\n     let mut ctx = MirLowerCtx {\n         result: mir,\n         db,\n         infer,\n         body,\n-        binding_locals,\n         owner,\n         current_loop_blocks: None,\n         discr_temp: None,\n     };\n-    let b = ctx.lower_expr_to_place(root_expr, return_slot().into(), start_block)?;\n-    ctx.result.basic_blocks[b].terminator = Some(Terminator::Return);\n+    let mut current = start_block;\n+    for (&param, local) in body.params.iter().zip(ctx.result.param_locals.clone().into_iter()) {\n+        if let Pat::Bind { id, .. } = body[param] {\n+            if local == ctx.result.binding_locals[id] {\n+                continue;\n+            }\n+        }\n+        let r = ctx.pattern_match(\n+            current,\n+            None,\n+            local.into(),\n+            ctx.result.locals[local].ty.clone(),\n+            param,\n+            BindingAnnotation::Unannotated,\n+        )?;\n+        if let Some(b) = r.1 {\n+            ctx.set_terminator(b, Terminator::Unreachable);\n+        }\n+        current = r.0;\n+    }\n+    if let Some(b) = ctx.lower_expr_to_place(root_expr, return_slot().into(), current)? {\n+        ctx.result.basic_blocks[b].terminator = Some(Terminator::Return);\n+    }\n     Ok(ctx.result)\n }"}, {"sha": "09bcdd93be019886de7417f3bd8bc5d64b5445ae", "filename": "crates/hir-ty/src/mir/lower/as_place.rs", "status": "added", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fas_place.rs?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -0,0 +1,237 @@\n+//! MIR lowering for places\n+\n+use super::*;\n+use hir_expand::name;\n+\n+macro_rules! not_supported {\n+    ($x: expr) => {\n+        return Err(MirLowerError::NotSupported(format!($x)))\n+    };\n+}\n+\n+impl MirLowerCtx<'_> {\n+    fn lower_expr_to_some_place_without_adjust(\n+        &mut self,\n+        expr_id: ExprId,\n+        prev_block: BasicBlockId,\n+    ) -> Result<Option<(Place, BasicBlockId)>> {\n+        let ty = self.expr_ty(expr_id);\n+        let place = self.temp(ty)?;\n+        let Some(current) = self.lower_expr_to_place_without_adjust(expr_id, place.into(), prev_block)? else {\n+            return Ok(None);\n+        };\n+        Ok(Some((place.into(), current)))\n+    }\n+\n+    fn lower_expr_to_some_place_with_adjust(\n+        &mut self,\n+        expr_id: ExprId,\n+        prev_block: BasicBlockId,\n+        adjustments: &[Adjustment],\n+    ) -> Result<Option<(Place, BasicBlockId)>> {\n+        let ty =\n+            adjustments.last().map(|x| x.target.clone()).unwrap_or_else(|| self.expr_ty(expr_id));\n+        let place = self.temp(ty)?;\n+        let Some(current) = self.lower_expr_to_place_with_adjust(expr_id, place.into(), prev_block, adjustments)? else {\n+            return Ok(None);\n+        };\n+        Ok(Some((place.into(), current)))\n+    }\n+\n+    pub(super) fn lower_expr_as_place_with_adjust(\n+        &mut self,\n+        current: BasicBlockId,\n+        expr_id: ExprId,\n+        upgrade_rvalue: bool,\n+        adjustments: &[Adjustment],\n+    ) -> Result<Option<(Place, BasicBlockId)>> {\n+        let try_rvalue = |this: &mut MirLowerCtx<'_>| {\n+            if !upgrade_rvalue {\n+                return Err(MirLowerError::MutatingRvalue);\n+            }\n+            this.lower_expr_to_some_place_with_adjust(expr_id, current, adjustments)\n+        };\n+        if let Some((last, rest)) = adjustments.split_last() {\n+            match last.kind {\n+                Adjust::Deref(None) => {\n+                    let Some(mut x) = self.lower_expr_as_place_with_adjust(\n+                        current,\n+                        expr_id,\n+                        upgrade_rvalue,\n+                        rest,\n+                    )? else {\n+                        return Ok(None);\n+                    };\n+                    x.0.projection.push(ProjectionElem::Deref);\n+                    Ok(Some(x))\n+                }\n+                Adjust::Deref(Some(od)) => {\n+                    let Some((r, current)) = self.lower_expr_as_place_with_adjust(\n+                        current,\n+                        expr_id,\n+                        upgrade_rvalue,\n+                        rest,\n+                    )? else {\n+                        return Ok(None);\n+                    };\n+                    self.lower_overloaded_deref(\n+                        current,\n+                        r,\n+                        rest.last()\n+                            .map(|x| x.target.clone())\n+                            .unwrap_or_else(|| self.expr_ty(expr_id)),\n+                        last.target.clone(),\n+                        expr_id.into(),\n+                        match od.0 {\n+                            Some(Mutability::Mut) => true,\n+                            Some(Mutability::Not) => false,\n+                            None => {\n+                                not_supported!(\"implicit overloaded deref with unknown mutability\")\n+                            }\n+                        },\n+                    )\n+                }\n+                Adjust::NeverToAny | Adjust::Borrow(_) | Adjust::Pointer(_) => try_rvalue(self),\n+            }\n+        } else {\n+            self.lower_expr_as_place_without_adjust(current, expr_id, upgrade_rvalue)\n+        }\n+    }\n+\n+    pub(super) fn lower_expr_as_place(\n+        &mut self,\n+        current: BasicBlockId,\n+        expr_id: ExprId,\n+        upgrade_rvalue: bool,\n+    ) -> Result<Option<(Place, BasicBlockId)>> {\n+        match self.infer.expr_adjustments.get(&expr_id) {\n+            Some(a) => self.lower_expr_as_place_with_adjust(current, expr_id, upgrade_rvalue, a),\n+            None => self.lower_expr_as_place_without_adjust(current, expr_id, upgrade_rvalue),\n+        }\n+    }\n+\n+    fn lower_expr_as_place_without_adjust(\n+        &mut self,\n+        current: BasicBlockId,\n+        expr_id: ExprId,\n+        upgrade_rvalue: bool,\n+    ) -> Result<Option<(Place, BasicBlockId)>> {\n+        let try_rvalue = |this: &mut MirLowerCtx<'_>| {\n+            if !upgrade_rvalue {\n+                return Err(MirLowerError::MutatingRvalue);\n+            }\n+            this.lower_expr_to_some_place_without_adjust(expr_id, current)\n+        };\n+        match &self.body.exprs[expr_id] {\n+            Expr::Path(p) => {\n+                let resolver = resolver_for_expr(self.db.upcast(), self.owner, expr_id);\n+                let Some(pr) = resolver.resolve_path_in_value_ns(self.db.upcast(), p.mod_path()) else {\n+                    return Err(MirLowerError::unresolved_path(self.db, p));\n+                };\n+                let pr = match pr {\n+                    ResolveValueResult::ValueNs(v) => v,\n+                    ResolveValueResult::Partial(..) => return try_rvalue(self),\n+                };\n+                match pr {\n+                    ValueNs::LocalBinding(pat_id) => {\n+                        Ok(Some((self.result.binding_locals[pat_id].into(), current)))\n+                    }\n+                    _ => try_rvalue(self),\n+                }\n+            }\n+            Expr::UnaryOp { expr, op } => match op {\n+                hir_def::expr::UnaryOp::Deref => {\n+                    if !matches!(\n+                        self.expr_ty(*expr).kind(Interner),\n+                        TyKind::Ref(..) | TyKind::Raw(..)\n+                    ) {\n+                        let Some(_) = self.lower_expr_as_place(current, *expr, true)? else {\n+                            return Ok(None);\n+                        };\n+                        not_supported!(\"explicit overloaded deref\");\n+                    }\n+                    let Some((mut r, current)) = self.lower_expr_as_place(current, *expr, true)? else {\n+                        return Ok(None);\n+                    };\n+                    r.projection.push(ProjectionElem::Deref);\n+                    Ok(Some((r, current)))\n+                }\n+                _ => try_rvalue(self),\n+            },\n+            Expr::Field { expr, .. } => {\n+                let Some((mut r, current)) = self.lower_expr_as_place(current, *expr, true)? else {\n+                    return Ok(None);\n+                };\n+                self.push_field_projection(&mut r, expr_id)?;\n+                Ok(Some((r, current)))\n+            }\n+            Expr::Index { base, index } => {\n+                let base_ty = self.expr_ty_after_adjustments(*base);\n+                let index_ty = self.expr_ty_after_adjustments(*index);\n+                if index_ty != TyBuilder::usize()\n+                    || !matches!(base_ty.kind(Interner), TyKind::Array(..) | TyKind::Slice(..))\n+                {\n+                    not_supported!(\"overloaded index\");\n+                }\n+                let Some((mut p_base, current)) =\n+                    self.lower_expr_as_place(current, *base, true)? else {\n+                    return Ok(None);\n+                };\n+                let l_index = self.temp(self.expr_ty_after_adjustments(*index))?;\n+                let Some(current) = self.lower_expr_to_place(*index, l_index.into(), current)? else {\n+                    return Ok(None);\n+                };\n+                p_base.projection.push(ProjectionElem::Index(l_index));\n+                Ok(Some((p_base, current)))\n+            }\n+            _ => try_rvalue(self),\n+        }\n+    }\n+\n+    fn lower_overloaded_deref(\n+        &mut self,\n+        current: BasicBlockId,\n+        place: Place,\n+        source_ty: Ty,\n+        target_ty: Ty,\n+        span: MirSpan,\n+        mutability: bool,\n+    ) -> Result<Option<(Place, BasicBlockId)>> {\n+        let (chalk_mut, trait_lang_item, trait_method_name, borrow_kind) = if !mutability {\n+            (Mutability::Not, LangItem::Deref, name![deref], BorrowKind::Shared)\n+        } else {\n+            (\n+                Mutability::Mut,\n+                LangItem::DerefMut,\n+                name![deref_mut],\n+                BorrowKind::Mut { allow_two_phase_borrow: false },\n+            )\n+        };\n+        let ty_ref = TyKind::Ref(chalk_mut, static_lifetime(), source_ty.clone()).intern(Interner);\n+        let target_ty_ref = TyKind::Ref(chalk_mut, static_lifetime(), target_ty).intern(Interner);\n+        let ref_place: Place = self.temp(ty_ref)?.into();\n+        self.push_assignment(current, ref_place.clone(), Rvalue::Ref(borrow_kind, place), span);\n+        let deref_trait = self\n+            .resolve_lang_item(trait_lang_item)?\n+            .as_trait()\n+            .ok_or(MirLowerError::LangItemNotFound(trait_lang_item))?;\n+        let deref_fn = self\n+            .db\n+            .trait_data(deref_trait)\n+            .method_by_name(&trait_method_name)\n+            .ok_or(MirLowerError::LangItemNotFound(trait_lang_item))?;\n+        let deref_fn_op = Operand::const_zst(\n+            TyKind::FnDef(\n+                self.db.intern_callable_def(CallableDefId::FunctionId(deref_fn)).into(),\n+                Substitution::from1(Interner, source_ty),\n+            )\n+            .intern(Interner),\n+        );\n+        let mut result: Place = self.temp(target_ty_ref)?.into();\n+        let Some(current) = self.lower_call(deref_fn_op, vec![Operand::Copy(ref_place)], result.clone(), current, false)? else {\n+            return Ok(None);\n+        };\n+        result.projection.push(ProjectionElem::Deref);\n+        Ok(Some((result, current)))\n+    }\n+}"}, {"sha": "ffc08b7e346c7f1007c15c18f4d28bb720fa0b0b", "filename": "crates/hir-ty/src/mir/pretty.rs", "status": "added", "additions": 348, "deletions": 0, "changes": 348, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir-ty%2Fsrc%2Fmir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir-ty%2Fsrc%2Fmir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Fpretty.rs?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -0,0 +1,348 @@\n+//! A pretty-printer for MIR.\n+\n+use std::fmt::{Display, Write};\n+\n+use hir_def::{body::Body, expr::BindingId};\n+use hir_expand::name::Name;\n+use la_arena::ArenaMap;\n+\n+use crate::{\n+    db::HirDatabase,\n+    display::HirDisplay,\n+    mir::{PlaceElem, ProjectionElem, StatementKind, Terminator},\n+};\n+\n+use super::{\n+    AggregateKind, BasicBlockId, BorrowKind, LocalId, MirBody, Operand, Place, Rvalue, UnOp,\n+};\n+\n+impl MirBody {\n+    pub fn pretty_print(&self, db: &dyn HirDatabase) -> String {\n+        let hir_body = db.body(self.owner);\n+        let mut ctx = MirPrettyCtx::new(self, &hir_body, db);\n+        ctx.for_body();\n+        ctx.result\n+    }\n+}\n+\n+struct MirPrettyCtx<'a> {\n+    body: &'a MirBody,\n+    hir_body: &'a Body,\n+    db: &'a dyn HirDatabase,\n+    result: String,\n+    ident: String,\n+    local_to_binding: ArenaMap<LocalId, BindingId>,\n+}\n+\n+macro_rules! w {\n+    ($dst:expr, $($arg:tt)*) => {\n+        { let _ = write!($dst, $($arg)*); }\n+    };\n+}\n+\n+macro_rules! wln {\n+    ($dst:expr) => {\n+        { let _ = writeln!($dst); }\n+    };\n+    ($dst:expr, $($arg:tt)*) => {\n+        { let _ = writeln!($dst, $($arg)*); }\n+    };\n+}\n+\n+impl Write for MirPrettyCtx<'_> {\n+    fn write_str(&mut self, s: &str) -> std::fmt::Result {\n+        let mut it = s.split('\\n'); // note: `.lines()` is wrong here\n+        self.write(it.next().unwrap_or_default());\n+        for line in it {\n+            self.write_line();\n+            self.write(line);\n+        }\n+        Ok(())\n+    }\n+}\n+\n+enum LocalName {\n+    Unknown(LocalId),\n+    Binding(Name, LocalId),\n+}\n+\n+impl Display for LocalName {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        match self {\n+            LocalName::Unknown(l) => write!(f, \"_{}\", u32::from(l.into_raw())),\n+            LocalName::Binding(n, l) => write!(f, \"{n}_{}\", u32::from(l.into_raw())),\n+        }\n+    }\n+}\n+\n+impl<'a> MirPrettyCtx<'a> {\n+    fn for_body(&mut self) {\n+        self.with_block(|this| {\n+            this.locals();\n+            wln!(this);\n+            this.blocks();\n+        });\n+    }\n+\n+    fn with_block(&mut self, f: impl FnOnce(&mut MirPrettyCtx<'_>)) {\n+        self.ident += \"    \";\n+        wln!(self, \"{{\");\n+        f(self);\n+        for _ in 0..4 {\n+            self.result.pop();\n+            self.ident.pop();\n+        }\n+        wln!(self, \"}}\");\n+    }\n+\n+    fn new(body: &'a MirBody, hir_body: &'a Body, db: &'a dyn HirDatabase) -> Self {\n+        let local_to_binding = body.binding_locals.iter().map(|(x, y)| (*y, x)).collect();\n+        MirPrettyCtx {\n+            body,\n+            db,\n+            result: String::new(),\n+            ident: String::new(),\n+            local_to_binding,\n+            hir_body,\n+        }\n+    }\n+\n+    fn write_line(&mut self) {\n+        self.result.push('\\n');\n+        self.result += &self.ident;\n+    }\n+\n+    fn write(&mut self, line: &str) {\n+        self.result += line;\n+    }\n+\n+    fn locals(&mut self) {\n+        for (id, local) in self.body.locals.iter() {\n+            wln!(self, \"let {}: {};\", self.local_name(id), local.ty.display(self.db));\n+        }\n+    }\n+\n+    fn local_name(&self, local: LocalId) -> LocalName {\n+        match self.local_to_binding.get(local) {\n+            Some(b) => LocalName::Binding(self.hir_body.bindings[*b].name.clone(), local),\n+            None => LocalName::Unknown(local),\n+        }\n+    }\n+\n+    fn basic_block_id(&self, basic_block_id: BasicBlockId) -> String {\n+        format!(\"'bb{}\", u32::from(basic_block_id.into_raw()))\n+    }\n+\n+    fn blocks(&mut self) {\n+        for (id, block) in self.body.basic_blocks.iter() {\n+            wln!(self);\n+            w!(self, \"{}: \", self.basic_block_id(id));\n+            self.with_block(|this| {\n+                for statement in &block.statements {\n+                    match &statement.kind {\n+                        StatementKind::Assign(l, r) => {\n+                            this.place(l);\n+                            w!(this, \" = \");\n+                            this.rvalue(r);\n+                            wln!(this, \";\");\n+                        }\n+                        StatementKind::StorageDead(p) => {\n+                            wln!(this, \"StorageDead({})\", this.local_name(*p));\n+                        }\n+                        StatementKind::StorageLive(p) => {\n+                            wln!(this, \"StorageLive({})\", this.local_name(*p));\n+                        }\n+                        StatementKind::Deinit(p) => {\n+                            w!(this, \"Deinit(\");\n+                            this.place(p);\n+                            wln!(this, \");\");\n+                        }\n+                        StatementKind::Nop => wln!(this, \"Nop;\"),\n+                    }\n+                }\n+                match &block.terminator {\n+                    Some(terminator) => match terminator {\n+                        Terminator::Goto { target } => {\n+                            wln!(this, \"goto 'bb{};\", u32::from(target.into_raw()))\n+                        }\n+                        Terminator::SwitchInt { discr, targets } => {\n+                            w!(this, \"switch \");\n+                            this.operand(discr);\n+                            w!(this, \" \");\n+                            this.with_block(|this| {\n+                                for (c, b) in targets.iter() {\n+                                    wln!(this, \"{c} => {},\", this.basic_block_id(b));\n+                                }\n+                                wln!(this, \"_ => {},\", this.basic_block_id(targets.otherwise()));\n+                            });\n+                        }\n+                        Terminator::Call { func, args, destination, target, .. } => {\n+                            w!(this, \"Call \");\n+                            this.with_block(|this| {\n+                                w!(this, \"func: \");\n+                                this.operand(func);\n+                                wln!(this, \",\");\n+                                w!(this, \"args: [\");\n+                                this.operand_list(args);\n+                                wln!(this, \"],\");\n+                                w!(this, \"destination: \");\n+                                this.place(destination);\n+                                wln!(this, \",\");\n+                                w!(this, \"target: \");\n+                                match target {\n+                                    Some(t) => w!(this, \"{}\", this.basic_block_id(*t)),\n+                                    None => w!(this, \"<unreachable>\"),\n+                                }\n+                                wln!(this, \",\");\n+                            });\n+                        }\n+                        _ => wln!(this, \"{:?};\", terminator),\n+                    },\n+                    None => wln!(this, \"<no-terminator>;\"),\n+                }\n+            })\n+        }\n+    }\n+\n+    fn place(&mut self, p: &Place) {\n+        fn f(this: &mut MirPrettyCtx<'_>, local: LocalId, projections: &[PlaceElem]) {\n+            let Some((last, head)) = projections.split_last() else {\n+                // no projection\n+                w!(this, \"{}\", this.local_name(local));\n+                return;\n+            };\n+            match last {\n+                ProjectionElem::Deref => {\n+                    w!(this, \"(*\");\n+                    f(this, local, head);\n+                    w!(this, \")\");\n+                }\n+                ProjectionElem::Field(field) => {\n+                    let variant_data = field.parent.variant_data(this.db.upcast());\n+                    let name = &variant_data.fields()[field.local_id].name;\n+                    match field.parent {\n+                        hir_def::VariantId::EnumVariantId(e) => {\n+                            w!(this, \"(\");\n+                            f(this, local, head);\n+                            let variant_name =\n+                                &this.db.enum_data(e.parent).variants[e.local_id].name;\n+                            w!(this, \" as {}).{}\", variant_name, name);\n+                        }\n+                        hir_def::VariantId::StructId(_) | hir_def::VariantId::UnionId(_) => {\n+                            f(this, local, head);\n+                            w!(this, \".{name}\");\n+                        }\n+                    }\n+                }\n+                ProjectionElem::TupleField(x) => {\n+                    f(this, local, head);\n+                    w!(this, \".{}\", x);\n+                }\n+                ProjectionElem::Index(l) => {\n+                    f(this, local, head);\n+                    w!(this, \"[{}]\", this.local_name(*l));\n+                }\n+                x => {\n+                    f(this, local, head);\n+                    w!(this, \".{:?}\", x);\n+                }\n+            }\n+        }\n+        f(self, p.local, &p.projection);\n+    }\n+\n+    fn operand(&mut self, r: &Operand) {\n+        match r {\n+            Operand::Copy(p) | Operand::Move(p) => {\n+                // MIR at the time of writing doesn't have difference between move and copy, so we show them\n+                // equally. Feel free to change it.\n+                self.place(p);\n+            }\n+            Operand::Constant(c) => w!(self, \"Const({})\", c.display(self.db)),\n+        }\n+    }\n+\n+    fn rvalue(&mut self, r: &Rvalue) {\n+        match r {\n+            Rvalue::Use(op) => self.operand(op),\n+            Rvalue::Ref(r, p) => {\n+                match r {\n+                    BorrowKind::Shared => w!(self, \"&\"),\n+                    BorrowKind::Shallow => w!(self, \"&shallow \"),\n+                    BorrowKind::Unique => w!(self, \"&uniq \"),\n+                    BorrowKind::Mut { .. } => w!(self, \"&mut \"),\n+                }\n+                self.place(p);\n+            }\n+            Rvalue::Aggregate(AggregateKind::Tuple(_), x) => {\n+                w!(self, \"(\");\n+                self.operand_list(x);\n+                w!(self, \")\");\n+            }\n+            Rvalue::Aggregate(AggregateKind::Array(_), x) => {\n+                w!(self, \"[\");\n+                self.operand_list(x);\n+                w!(self, \"]\");\n+            }\n+            Rvalue::Aggregate(AggregateKind::Adt(_, _), x) => {\n+                w!(self, \"Adt(\");\n+                self.operand_list(x);\n+                w!(self, \")\");\n+            }\n+            Rvalue::Aggregate(AggregateKind::Union(_, _), x) => {\n+                w!(self, \"Union(\");\n+                self.operand_list(x);\n+                w!(self, \")\");\n+            }\n+            Rvalue::Len(p) => {\n+                w!(self, \"Len(\");\n+                self.place(p);\n+                w!(self, \")\");\n+            }\n+            Rvalue::Cast(ck, op, ty) => {\n+                w!(self, \"Discriminant({ck:?}\");\n+                self.operand(op);\n+                w!(self, \"{})\", ty.display(self.db));\n+            }\n+            Rvalue::CheckedBinaryOp(b, o1, o2) => {\n+                self.operand(o1);\n+                w!(self, \" {b} \");\n+                self.operand(o2);\n+            }\n+            Rvalue::UnaryOp(u, o) => {\n+                let u = match u {\n+                    UnOp::Not => \"!\",\n+                    UnOp::Neg => \"-\",\n+                };\n+                w!(self, \"{u} \");\n+                self.operand(o);\n+            }\n+            Rvalue::Discriminant(p) => {\n+                w!(self, \"Discriminant(\");\n+                self.place(p);\n+                w!(self, \")\");\n+            }\n+            Rvalue::ShallowInitBox(op, _) => {\n+                w!(self, \"ShallowInitBox(\");\n+                self.operand(op);\n+                w!(self, \")\");\n+            }\n+            Rvalue::CopyForDeref(p) => {\n+                w!(self, \"CopyForDeref(\");\n+                self.place(p);\n+                w!(self, \")\");\n+            }\n+        }\n+    }\n+\n+    fn operand_list(&mut self, x: &[Operand]) {\n+        let mut it = x.iter();\n+        if let Some(first) = it.next() {\n+            self.operand(first);\n+            for op in it {\n+                w!(self, \", \");\n+                self.operand(op);\n+            }\n+        }\n+    }\n+}"}, {"sha": "b524922b6cf40a61947dd6043a44a382780945f7", "filename": "crates/hir-ty/src/tests/coercion.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir-ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir-ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -258,6 +258,7 @@ fn test() {\n \n #[test]\n fn coerce_autoderef_block() {\n+    // FIXME: We should know mutability in overloaded deref\n     check_no_mismatches(\n         r#\"\n //- minicore: deref\n@@ -267,7 +268,7 @@ fn takes_ref_str(x: &str) {}\n fn returns_string() -> String { loop {} }\n fn test() {\n     takes_ref_str(&{ returns_string() });\n-               // ^^^^^^^^^^^^^^^^^^^^^ adjustments: Deref(None), Deref(Some(OverloadedDeref(Not))), Borrow(Ref(Not))\n+               // ^^^^^^^^^^^^^^^^^^^^^ adjustments: Deref(None), Deref(Some(OverloadedDeref(None))), Borrow(Ref(Not))\n }\n \"#,\n     );"}, {"sha": "e568e7013fac0eefd670ecee7e1dd0c8892a1611", "filename": "crates/hir-ty/src/tests/method_resolution.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -1252,6 +1252,7 @@ fn foo<T: Trait>(a: &T) {\n \n #[test]\n fn autoderef_visibility_field() {\n+    // FIXME: We should know mutability in overloaded deref\n     check(\n         r#\"\n //- minicore: deref\n@@ -1273,7 +1274,7 @@ mod a {\n mod b {\n     fn foo() {\n         let x = super::a::Bar::new().0;\n-             // ^^^^^^^^^^^^^^^^^^^^ adjustments: Deref(Some(OverloadedDeref(Not)))\n+             // ^^^^^^^^^^^^^^^^^^^^ adjustments: Deref(Some(OverloadedDeref(None)))\n              // ^^^^^^^^^^^^^^^^^^^^^^ type: char\n     }\n }"}, {"sha": "c257ee2ae3a414d569a84580565ef4e707298552", "filename": "crates/hir/src/diagnostics.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -10,7 +10,7 @@ use hir_def::path::ModPath;\n use hir_expand::{name::Name, HirFileId, InFile};\n use syntax::{ast, AstPtr, SyntaxNodePtr, TextRange};\n \n-use crate::{AssocItem, Field, MacroKind, Type};\n+use crate::{AssocItem, Field, Local, MacroKind, Type};\n \n macro_rules! diagnostics {\n     ($($diag:ident,)*) => {\n@@ -41,6 +41,7 @@ diagnostics![\n     MissingFields,\n     MissingMatchArms,\n     MissingUnsafe,\n+    NeedMut,\n     NoSuchField,\n     PrivateAssocItem,\n     PrivateField,\n@@ -54,6 +55,7 @@ diagnostics![\n     UnresolvedMethodCall,\n     UnresolvedModule,\n     UnresolvedProcMacro,\n+    UnusedMut,\n ];\n \n #[derive(Debug)]\n@@ -209,4 +211,15 @@ pub struct TypeMismatch {\n     pub actual: Type,\n }\n \n+#[derive(Debug)]\n+pub struct NeedMut {\n+    pub local: Local,\n+    pub span: InFile<SyntaxNodePtr>,\n+}\n+\n+#[derive(Debug)]\n+pub struct UnusedMut {\n+    pub local: Local,\n+}\n+\n pub use hir_ty::diagnostics::IncorrectCase;"}, {"sha": "aaaa7abf3863c35057113075133e3b5d399493ee", "filename": "crates/hir/src/from_id.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir%2Fsrc%2Ffrom_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir%2Fsrc%2Ffrom_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Ffrom_id.rs?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -4,7 +4,7 @@\n //! are splitting the hir.\n \n use hir_def::{\n-    expr::{LabelId, PatId},\n+    expr::{BindingId, LabelId},\n     AdtId, AssocItemId, DefWithBodyId, EnumVariantId, FieldId, GenericDefId, GenericParamId,\n     ModuleDefId, VariantId,\n };\n@@ -251,9 +251,9 @@ impl From<AssocItem> for GenericDefId {\n     }\n }\n \n-impl From<(DefWithBodyId, PatId)> for Local {\n-    fn from((parent, pat_id): (DefWithBodyId, PatId)) -> Self {\n-        Local { parent, pat_id }\n+impl From<(DefWithBodyId, BindingId)> for Local {\n+    fn from((parent, binding_id): (DefWithBodyId, BindingId)) -> Self {\n+        Local { parent, binding_id }\n     }\n }\n "}, {"sha": "9f6b5c0a9fcc9edf3f1cde479bdbe2058aff3f71", "filename": "crates/hir/src/has_source.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir%2Fsrc%2Fhas_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir%2Fsrc%2Fhas_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fhas_source.rs?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -10,8 +10,9 @@ use hir_expand::InFile;\n use syntax::ast;\n \n use crate::{\n-    db::HirDatabase, Adt, Const, Enum, Field, FieldSource, Function, Impl, LifetimeParam, Macro,\n-    Module, Static, Struct, Trait, TraitAlias, TypeAlias, TypeOrConstParam, Union, Variant,\n+    db::HirDatabase, Adt, Const, Enum, Field, FieldSource, Function, Impl, LifetimeParam,\n+    LocalSource, Macro, Module, Static, Struct, Trait, TraitAlias, TypeAlias, TypeOrConstParam,\n+    Union, Variant,\n };\n \n pub trait HasSource {\n@@ -178,3 +179,11 @@ impl HasSource for LifetimeParam {\n         Some(child_source.map(|it| it[self.id.local_id].clone()))\n     }\n }\n+\n+impl HasSource for LocalSource {\n+    type Ast = Either<ast::IdentPat, ast::SelfParam>;\n+\n+    fn source(self, _: &dyn HirDatabase) -> Option<InFile<Self::Ast>> {\n+        Some(self.source)\n+    }\n+}"}, {"sha": "92b31031ca1118963ec26d6613d6da9f3cbc3399", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 114, "deletions": 43, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -41,7 +41,7 @@ use either::Either;\n use hir_def::{\n     adt::VariantData,\n     body::{BodyDiagnostic, SyntheticSyntax},\n-    expr::{BindingAnnotation, ExprOrPatId, LabelId, Pat, PatId},\n+    expr::{BindingAnnotation, BindingId, ExprOrPatId, LabelId, Pat},\n     generics::{LifetimeParamData, TypeOrConstParamData, TypeParamProvenance},\n     item_tree::ItemTreeNode,\n     lang_item::{LangItem, LangItemTarget},\n@@ -63,7 +63,7 @@ use hir_ty::{\n     display::HexifiedConst,\n     layout::layout_of_ty,\n     method_resolution::{self, TyFingerprint},\n-    mir::interpret_mir,\n+    mir::{self, interpret_mir},\n     primitive::UintTy,\n     traits::FnTrait,\n     AliasTy, CallableDefId, CallableSig, Canonical, CanonicalVarKinds, Cast, ClosureId,\n@@ -77,7 +77,7 @@ use rustc_hash::FxHashSet;\n use stdx::{impl_from, never};\n use syntax::{\n     ast::{self, HasAttrs as _, HasDocComments, HasName},\n-    AstNode, AstPtr, SmolStr, SyntaxNodePtr, TextRange, T,\n+    AstNode, AstPtr, SmolStr, SyntaxNode, SyntaxNodePtr, TextRange, T,\n };\n \n use crate::db::{DefDatabase, HirDatabase};\n@@ -87,10 +87,10 @@ pub use crate::{\n     diagnostics::{\n         AnyDiagnostic, BreakOutsideOfLoop, ExpectedFunction, InactiveCode, IncorrectCase,\n         InvalidDeriveTarget, MacroError, MalformedDerive, MismatchedArgCount, MissingFields,\n-        MissingMatchArms, MissingUnsafe, NoSuchField, PrivateAssocItem, PrivateField,\n+        MissingMatchArms, MissingUnsafe, NeedMut, NoSuchField, PrivateAssocItem, PrivateField,\n         ReplaceFilterMapNextWithFindMap, TypeMismatch, UnimplementedBuiltinMacro,\n         UnresolvedExternCrate, UnresolvedField, UnresolvedImport, UnresolvedMacroCall,\n-        UnresolvedMethodCall, UnresolvedModule, UnresolvedProcMacro,\n+        UnresolvedMethodCall, UnresolvedModule, UnresolvedProcMacro, UnusedMut,\n     },\n     has_source::HasSource,\n     semantics::{PathResolution, Semantics, SemanticsScope, TypeInfo, VisibleTraits},\n@@ -1327,6 +1327,15 @@ impl DefWithBody {\n         body.pretty_print(db.upcast(), self.id())\n     }\n \n+    /// A textual representation of the MIR of this def's body for debugging purposes.\n+    pub fn debug_mir(self, db: &dyn HirDatabase) -> String {\n+        let body = db.mir_body(self.id());\n+        match body {\n+            Ok(body) => body.pretty_print(db),\n+            Err(e) => format!(\"error:\\n{e:?}\"),\n+        }\n+    }\n+\n     pub fn diagnostics(self, db: &dyn HirDatabase, acc: &mut Vec<AnyDiagnostic>) {\n         let krate = self.module(db).id.krate();\n \n@@ -1500,6 +1509,41 @@ impl DefWithBody {\n             }\n         }\n \n+        let hir_body = db.body(self.into());\n+\n+        if let Ok(borrowck_result) = db.borrowck(self.into()) {\n+            let mir_body = &borrowck_result.mir_body;\n+            let mol = &borrowck_result.mutability_of_locals;\n+            for (binding_id, _) in hir_body.bindings.iter() {\n+                let need_mut = &mol[mir_body.binding_locals[binding_id]];\n+                let local = Local { parent: self.into(), binding_id };\n+                match (need_mut, local.is_mut(db)) {\n+                    (mir::MutabilityReason::Mut { .. }, true)\n+                    | (mir::MutabilityReason::Not, false) => (),\n+                    (mir::MutabilityReason::Mut { spans }, false) => {\n+                        for span in spans {\n+                            let span: InFile<SyntaxNodePtr> = match span {\n+                                mir::MirSpan::ExprId(e) => match source_map.expr_syntax(*e) {\n+                                    Ok(s) => s.map(|x| x.into()),\n+                                    Err(_) => continue,\n+                                },\n+                                mir::MirSpan::PatId(p) => match source_map.pat_syntax(*p) {\n+                                    Ok(s) => s.map(|x| match x {\n+                                        Either::Left(e) => e.into(),\n+                                        Either::Right(e) => e.into(),\n+                                    }),\n+                                    Err(_) => continue,\n+                                },\n+                                mir::MirSpan::Unknown => continue,\n+                            };\n+                            acc.push(NeedMut { local, span }.into());\n+                        }\n+                    }\n+                    (mir::MutabilityReason::Not, true) => acc.push(UnusedMut { local }.into()),\n+                }\n+            }\n+        }\n+\n         for diagnostic in BodyValidationDiagnostic::collect(db, self.into()) {\n             match diagnostic {\n                 BodyValidationDiagnostic::RecordMissingFields {\n@@ -1786,8 +1830,8 @@ impl Param {\n         let parent = DefWithBodyId::FunctionId(self.func.into());\n         let body = db.body(parent);\n         let pat_id = body.params[self.idx];\n-        if let Pat::Bind { .. } = &body[pat_id] {\n-            Some(Local { parent, pat_id: body.params[self.idx] })\n+        if let Pat::Bind { id, .. } = &body[pat_id] {\n+            Some(Local { parent, binding_id: *id })\n         } else {\n             None\n         }\n@@ -2464,13 +2508,50 @@ impl GenericDef {\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub struct Local {\n     pub(crate) parent: DefWithBodyId,\n-    pub(crate) pat_id: PatId,\n+    pub(crate) binding_id: BindingId,\n+}\n+\n+pub struct LocalSource {\n+    pub local: Local,\n+    pub source: InFile<Either<ast::IdentPat, ast::SelfParam>>,\n+}\n+\n+impl LocalSource {\n+    pub fn as_ident_pat(&self) -> Option<&ast::IdentPat> {\n+        match &self.source.value {\n+            Either::Left(x) => Some(x),\n+            Either::Right(_) => None,\n+        }\n+    }\n+\n+    pub fn into_ident_pat(self) -> Option<ast::IdentPat> {\n+        match self.source.value {\n+            Either::Left(x) => Some(x),\n+            Either::Right(_) => None,\n+        }\n+    }\n+\n+    pub fn original_file(&self, db: &dyn HirDatabase) -> FileId {\n+        self.source.file_id.original_file(db.upcast())\n+    }\n+\n+    pub fn name(&self) -> Option<ast::Name> {\n+        self.source.value.name()\n+    }\n+\n+    pub fn syntax(&self) -> &SyntaxNode {\n+        self.source.value.syntax()\n+    }\n+\n+    pub fn syntax_ptr(self) -> InFile<SyntaxNodePtr> {\n+        self.source.map(|x| SyntaxNodePtr::new(x.syntax()))\n+    }\n }\n \n impl Local {\n     pub fn is_param(self, db: &dyn HirDatabase) -> bool {\n-        let src = self.source(db);\n-        match src.value {\n+        let src = self.primary_source(db);\n+        match src.source.value {\n             Either::Left(pat) => pat\n                 .syntax()\n                 .ancestors()\n@@ -2490,13 +2571,7 @@ impl Local {\n \n     pub fn name(self, db: &dyn HirDatabase) -> Name {\n         let body = db.body(self.parent);\n-        match &body[self.pat_id] {\n-            Pat::Bind { name, .. } => name.clone(),\n-            _ => {\n-                stdx::never!(\"hir::Local is missing a name!\");\n-                Name::missing()\n-            }\n-        }\n+        body[self.binding_id].name.clone()\n     }\n \n     pub fn is_self(self, db: &dyn HirDatabase) -> bool {\n@@ -2505,15 +2580,12 @@ impl Local {\n \n     pub fn is_mut(self, db: &dyn HirDatabase) -> bool {\n         let body = db.body(self.parent);\n-        matches!(&body[self.pat_id], Pat::Bind { mode: BindingAnnotation::Mutable, .. })\n+        body[self.binding_id].mode == BindingAnnotation::Mutable\n     }\n \n     pub fn is_ref(self, db: &dyn HirDatabase) -> bool {\n         let body = db.body(self.parent);\n-        matches!(\n-            &body[self.pat_id],\n-            Pat::Bind { mode: BindingAnnotation::Ref | BindingAnnotation::RefMut, .. }\n-        )\n+        matches!(body[self.binding_id].mode, BindingAnnotation::Ref | BindingAnnotation::RefMut)\n     }\n \n     pub fn parent(self, _db: &dyn HirDatabase) -> DefWithBody {\n@@ -2527,34 +2599,33 @@ impl Local {\n     pub fn ty(self, db: &dyn HirDatabase) -> Type {\n         let def = self.parent;\n         let infer = db.infer(def);\n-        let ty = infer[self.pat_id].clone();\n+        let ty = infer[self.binding_id].clone();\n         Type::new(db, def, ty)\n     }\n \n-    pub fn associated_locals(self, db: &dyn HirDatabase) -> Box<[Local]> {\n-        let body = db.body(self.parent);\n-        body.ident_patterns_for(&self.pat_id)\n+    /// All definitions for this local. Example: `let (a$0, _) | (_, a$0) = x;`\n+    pub fn sources(self, db: &dyn HirDatabase) -> Vec<LocalSource> {\n+        let (body, source_map) = db.body_with_source_map(self.parent);\n+        body[self.binding_id]\n+            .definitions\n             .iter()\n-            .map(|&pat_id| Local { parent: self.parent, pat_id })\n+            .map(|&definition| {\n+                let src = source_map.pat_syntax(definition).unwrap(); // Hmm...\n+                let root = src.file_syntax(db.upcast());\n+                src.map(|ast| match ast {\n+                    // Suspicious unwrap\n+                    Either::Left(it) => Either::Left(it.cast().unwrap().to_node(&root)),\n+                    Either::Right(it) => Either::Right(it.to_node(&root)),\n+                })\n+            })\n+            .map(|source| LocalSource { local: self, source })\n             .collect()\n     }\n \n-    /// If this local is part of a multi-local, retrieve the representative local.\n-    /// That is the local that references are being resolved to.\n-    pub fn representative(self, db: &dyn HirDatabase) -> Local {\n-        let body = db.body(self.parent);\n-        Local { pat_id: body.pattern_representative(self.pat_id), ..self }\n-    }\n-\n-    pub fn source(self, db: &dyn HirDatabase) -> InFile<Either<ast::IdentPat, ast::SelfParam>> {\n-        let (_body, source_map) = db.body_with_source_map(self.parent);\n-        let src = source_map.pat_syntax(self.pat_id).unwrap(); // Hmm...\n-        let root = src.file_syntax(db.upcast());\n-        src.map(|ast| match ast {\n-            // Suspicious unwrap\n-            Either::Left(it) => Either::Left(it.cast().unwrap().to_node(&root)),\n-            Either::Right(it) => Either::Right(it.to_node(&root)),\n-        })\n+    /// The leftmost definition for this local. Example: `let (a$0, _) | (_, a) = x;`\n+    pub fn primary_source(self, db: &dyn HirDatabase) -> LocalSource {\n+        let all_sources = self.sources(db);\n+        all_sources.into_iter().next().unwrap()\n     }\n }\n "}, {"sha": "2a0077cf50516f0085db394465b38a6d9732091e", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -1103,7 +1103,10 @@ impl<'db> SemanticsImpl<'db> {\n                     let kind = match adjust.kind {\n                         hir_ty::Adjust::NeverToAny => Adjust::NeverToAny,\n                         hir_ty::Adjust::Deref(Some(hir_ty::OverloadedDeref(m))) => {\n-                            Adjust::Deref(Some(OverloadedDeref(mutability(m))))\n+                            // FIXME: Should we handle unknown mutability better?\n+                            Adjust::Deref(Some(OverloadedDeref(\n+                                m.map(mutability).unwrap_or(Mutability::Shared),\n+                            )))\n                         }\n                         hir_ty::Adjust::Deref(None) => Adjust::Deref(None),\n                         hir_ty::Adjust::Borrow(hir_ty::AutoBorrow::RawPtr(m)) => {\n@@ -1654,8 +1657,8 @@ impl<'a> SemanticsScope<'a> {\n                     resolver::ScopeDef::ImplSelfType(it) => ScopeDef::ImplSelfType(it.into()),\n                     resolver::ScopeDef::AdtSelfType(it) => ScopeDef::AdtSelfType(it.into()),\n                     resolver::ScopeDef::GenericParam(id) => ScopeDef::GenericParam(id.into()),\n-                    resolver::ScopeDef::Local(pat_id) => match self.resolver.body_owner() {\n-                        Some(parent) => ScopeDef::Local(Local { parent, pat_id }),\n+                    resolver::ScopeDef::Local(binding_id) => match self.resolver.body_owner() {\n+                        Some(parent) => ScopeDef::Local(Local { parent, binding_id }),\n                         None => continue,\n                     },\n                     resolver::ScopeDef::Label(label_id) => match self.resolver.body_owner() {"}, {"sha": "f6f8c9a250f06cbf16ac88c5c8b3b5b022b46347", "filename": "crates/hir/src/semantics/source_to_def.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -89,7 +89,7 @@ use base_db::FileId;\n use hir_def::{\n     child_by_source::ChildBySource,\n     dyn_map::DynMap,\n-    expr::{LabelId, PatId},\n+    expr::{BindingId, LabelId},\n     keys::{self, Key},\n     AdtId, ConstId, ConstParamId, DefWithBodyId, EnumId, EnumVariantId, FieldId, FunctionId,\n     GenericDefId, GenericParamId, ImplId, LifetimeParamId, MacroId, ModuleId, StaticId, StructId,\n@@ -98,7 +98,7 @@ use hir_def::{\n use hir_expand::{attrs::AttrId, name::AsName, HirFileId, MacroCallId};\n use rustc_hash::FxHashMap;\n use smallvec::SmallVec;\n-use stdx::impl_from;\n+use stdx::{impl_from, never};\n use syntax::{\n     ast::{self, HasName},\n     AstNode, SyntaxNode,\n@@ -216,26 +216,31 @@ impl SourceToDefCtx<'_, '_> {\n     pub(super) fn bind_pat_to_def(\n         &mut self,\n         src: InFile<ast::IdentPat>,\n-    ) -> Option<(DefWithBodyId, PatId)> {\n+    ) -> Option<(DefWithBodyId, BindingId)> {\n         let container = self.find_pat_or_label_container(src.syntax())?;\n         let (body, source_map) = self.db.body_with_source_map(container);\n         let src = src.map(ast::Pat::from);\n         let pat_id = source_map.node_pat(src.as_ref())?;\n         // the pattern could resolve to a constant, verify that that is not the case\n-        if let crate::Pat::Bind { .. } = body[pat_id] {\n-            Some((container, pat_id))\n+        if let crate::Pat::Bind { id, .. } = body[pat_id] {\n+            Some((container, id))\n         } else {\n             None\n         }\n     }\n     pub(super) fn self_param_to_def(\n         &mut self,\n         src: InFile<ast::SelfParam>,\n-    ) -> Option<(DefWithBodyId, PatId)> {\n+    ) -> Option<(DefWithBodyId, BindingId)> {\n         let container = self.find_pat_or_label_container(src.syntax())?;\n-        let (_body, source_map) = self.db.body_with_source_map(container);\n+        let (body, source_map) = self.db.body_with_source_map(container);\n         let pat_id = source_map.node_self_param(src.as_ref())?;\n-        Some((container, pat_id))\n+        if let crate::Pat::Bind { id, .. } = body[pat_id] {\n+            Some((container, id))\n+        } else {\n+            never!();\n+            None\n+        }\n     }\n     pub(super) fn label_to_def(\n         &mut self,"}, {"sha": "133fa810d66133d332b7ffcf30d4b67bb02c8a76", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -422,8 +422,8 @@ impl SourceAnalyzer {\n             // Shorthand syntax, resolve to the local\n             let path = ModPath::from_segments(PathKind::Plain, once(local_name.clone()));\n             match self.resolver.resolve_path_in_value_ns_fully(db.upcast(), &path) {\n-                Some(ValueNs::LocalBinding(pat_id)) => {\n-                    Some(Local { pat_id, parent: self.resolver.body_owner()? })\n+                Some(ValueNs::LocalBinding(binding_id)) => {\n+                    Some(Local { binding_id, parent: self.resolver.body_owner()? })\n                 }\n                 _ => None,\n             }\n@@ -1018,8 +1018,8 @@ fn resolve_hir_path_(\n     let values = || {\n         resolver.resolve_path_in_value_ns_fully(db.upcast(), path.mod_path()).and_then(|val| {\n             let res = match val {\n-                ValueNs::LocalBinding(pat_id) => {\n-                    let var = Local { parent: body_owner?, pat_id };\n+                ValueNs::LocalBinding(binding_id) => {\n+                    let var = Local { parent: body_owner?, binding_id };\n                     PathResolution::Local(var)\n                 }\n                 ValueNs::FunctionId(it) => PathResolution::Def(Function::from(it).into()),"}, {"sha": "745a870ab6b4b4e31797d287abe7734dddb43758", "filename": "crates/ide-assists/src/handlers/convert_match_to_let_else.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_match_to_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_match_to_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_match_to_let_else.rs?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -101,7 +101,7 @@ fn find_extracted_variable(ctx: &AssistContext<'_>, arm: &ast::MatchArm) -> Opti\n             let name_ref = path.syntax().descendants().find_map(ast::NameRef::cast)?;\n             match NameRefClass::classify(&ctx.sema, &name_ref)? {\n                 NameRefClass::Definition(Definition::Local(local)) => {\n-                    let source = local.source(ctx.db()).value.left()?;\n+                    let source = local.primary_source(ctx.db()).into_ident_pat()?;\n                     Some(source.name()?)\n                 }\n                 _ => None,"}, {"sha": "0b90c9ba34f5fb9ce7353197bb3018640e8394b3", "filename": "crates/ide-assists/src/handlers/extract_function.rs", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -3,7 +3,8 @@ use std::iter;\n use ast::make;\n use either::Either;\n use hir::{\n-    HasSource, HirDisplay, InFile, Local, ModuleDef, PathResolution, Semantics, TypeInfo, TypeParam,\n+    HasSource, HirDisplay, InFile, Local, LocalSource, ModuleDef, PathResolution, Semantics,\n+    TypeInfo, TypeParam,\n };\n use ide_db::{\n     defs::{Definition, NameRefClass},\n@@ -710,7 +711,7 @@ impl FunctionBody {\n                     ) => local_ref,\n                     _ => return,\n                 };\n-            let InFile { file_id, value } = local_ref.source(sema.db);\n+            let InFile { file_id, value } = local_ref.primary_source(sema.db).source;\n             // locals defined inside macros are not relevant to us\n             if !file_id.is_macro() {\n                 match value {\n@@ -972,11 +973,11 @@ impl FunctionBody {\n         locals: impl Iterator<Item = Local>,\n     ) -> Vec<Param> {\n         locals\n-            .map(|local| (local, local.source(ctx.db())))\n+            .map(|local| (local, local.primary_source(ctx.db())))\n             .filter(|(_, src)| is_defined_outside_of_body(ctx, self, src))\n-            .filter_map(|(local, src)| match src.value {\n-                Either::Left(src) => Some((local, src)),\n-                Either::Right(_) => {\n+            .filter_map(|(local, src)| match src.into_ident_pat() {\n+                Some(src) => Some((local, src)),\n+                None => {\n                     stdx::never!(false, \"Local::is_self returned false, but source is SelfParam\");\n                     None\n                 }\n@@ -1238,17 +1239,9 @@ fn local_outlives_body(\n fn is_defined_outside_of_body(\n     ctx: &AssistContext<'_>,\n     body: &FunctionBody,\n-    src: &hir::InFile<Either<ast::IdentPat, ast::SelfParam>>,\n+    src: &LocalSource,\n ) -> bool {\n-    src.file_id.original_file(ctx.db()) == ctx.file_id()\n-        && !body.contains_node(either_syntax(&src.value))\n-}\n-\n-fn either_syntax(value: &Either<ast::IdentPat, ast::SelfParam>) -> &SyntaxNode {\n-    match value {\n-        Either::Left(pat) => pat.syntax(),\n-        Either::Right(it) => it.syntax(),\n-    }\n+    src.original_file(ctx.db()) == ctx.file_id() && !body.contains_node(src.syntax())\n }\n \n /// find where to put extracted function definition"}, {"sha": "e69d1a29677a9fec828968777af14c23e7132b95", "filename": "crates/ide-assists/src/handlers/inline_local_variable.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -1,4 +1,3 @@\n-use either::Either;\n use hir::{PathResolution, Semantics};\n use ide_db::{\n     base_db::FileId,\n@@ -205,12 +204,14 @@ fn inline_usage(\n         return None;\n     }\n \n-    // FIXME: Handle multiple local definitions\n-    let bind_pat = match local.source(sema.db).value {\n-        Either::Left(ident) => ident,\n-        _ => return None,\n+    let sources = local.sources(sema.db);\n+    let [source] = sources.as_slice() else {\n+        // Not applicable with locals with multiple definitions (i.e. or patterns)\n+        return None;\n     };\n \n+    let bind_pat = source.as_ident_pat()?;\n+\n     let let_stmt = ast::LetStmt::cast(bind_pat.syntax().parent()?)?;\n \n     let UsageSearchResult { mut references } = Definition::Local(local).usages(sema).all();"}, {"sha": "f710211c8cb0f0ed977af7b86d4c5574ed5b57c0", "filename": "crates/ide-db/src/rename.rs", "status": "modified", "additions": 48, "deletions": 56, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fide-db%2Fsrc%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fide-db%2Fsrc%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Frename.rs?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -121,14 +121,7 @@ impl Definition {\n             Definition::Trait(it) => name_range(it, sema),\n             Definition::TraitAlias(it) => name_range(it, sema),\n             Definition::TypeAlias(it) => name_range(it, sema),\n-            Definition::Local(local) => {\n-                let src = local.source(sema.db);\n-                let name = match &src.value {\n-                    Either::Left(bind_pat) => bind_pat.name()?,\n-                    Either::Right(_) => return None,\n-                };\n-                src.with_value(name.syntax()).original_file_range_opt(sema.db)\n-            }\n+            Definition::Local(it) => name_range(it.primary_source(sema.db), sema),\n             Definition::GenericParam(generic_param) => match generic_param {\n                 hir::GenericParam::LifetimeParam(lifetime_param) => {\n                     let src = lifetime_param.source(sema.db)?;\n@@ -302,13 +295,7 @@ fn rename_reference(\n         source_change.insert_source_edit(file_id, edit);\n         Ok(())\n     };\n-    match def {\n-        Definition::Local(l) => l\n-            .associated_locals(sema.db)\n-            .iter()\n-            .try_for_each(|&local| insert_def_edit(Definition::Local(local))),\n-        def => insert_def_edit(def),\n-    }?;\n+    insert_def_edit(def)?;\n     Ok(source_change)\n }\n \n@@ -471,59 +458,64 @@ fn source_edit_from_def(\n     def: Definition,\n     new_name: &str,\n ) -> Result<(FileId, TextEdit)> {\n-    let FileRange { file_id, range } = def\n-        .range_for_rename(sema)\n-        .ok_or_else(|| format_err!(\"No identifier available to rename\"))?;\n-\n     let mut edit = TextEdit::builder();\n     if let Definition::Local(local) = def {\n-        if let Either::Left(pat) = local.source(sema.db).value {\n-            // special cases required for renaming fields/locals in Record patterns\n-            if let Some(pat_field) = pat.syntax().parent().and_then(ast::RecordPatField::cast) {\n+        let mut file_id = None;\n+        for source in local.sources(sema.db) {\n+            let source = source.source;\n+            file_id = source.file_id.file_id();\n+            if let Either::Left(pat) = source.value {\n                 let name_range = pat.name().unwrap().syntax().text_range();\n-                if let Some(name_ref) = pat_field.name_ref() {\n-                    if new_name == name_ref.text() && pat.at_token().is_none() {\n-                        // Foo { field: ref mut local } -> Foo { ref mut field }\n-                        //       ^^^^^^ delete this\n-                        //                      ^^^^^ replace this with `field`\n-                        cov_mark::hit!(test_rename_local_put_init_shorthand_pat);\n-                        edit.delete(\n-                            name_ref\n-                                .syntax()\n-                                .text_range()\n-                                .cover_offset(pat.syntax().text_range().start()),\n-                        );\n-                        edit.replace(name_range, name_ref.text().to_string());\n+                // special cases required for renaming fields/locals in Record patterns\n+                if let Some(pat_field) = pat.syntax().parent().and_then(ast::RecordPatField::cast) {\n+                    if let Some(name_ref) = pat_field.name_ref() {\n+                        if new_name == name_ref.text() && pat.at_token().is_none() {\n+                            // Foo { field: ref mut local } -> Foo { ref mut field }\n+                            //       ^^^^^^ delete this\n+                            //                      ^^^^^ replace this with `field`\n+                            cov_mark::hit!(test_rename_local_put_init_shorthand_pat);\n+                            edit.delete(\n+                                name_ref\n+                                    .syntax()\n+                                    .text_range()\n+                                    .cover_offset(pat.syntax().text_range().start()),\n+                            );\n+                            edit.replace(name_range, name_ref.text().to_string());\n+                        } else {\n+                            // Foo { field: ref mut local @ local 2} -> Foo { field: ref mut new_name @ local2 }\n+                            // Foo { field: ref mut local } -> Foo { field: ref mut new_name }\n+                            //                      ^^^^^ replace this with `new_name`\n+                            edit.replace(name_range, new_name.to_string());\n+                        }\n                     } else {\n-                        // Foo { field: ref mut local @ local 2} -> Foo { field: ref mut new_name @ local2 }\n-                        // Foo { field: ref mut local } -> Foo { field: ref mut new_name }\n-                        //                      ^^^^^ replace this with `new_name`\n+                        // Foo { ref mut field } -> Foo { field: ref mut new_name }\n+                        //      ^ insert `field: `\n+                        //               ^^^^^ replace this with `new_name`\n+                        edit.insert(\n+                            pat.syntax().text_range().start(),\n+                            format!(\"{}: \", pat_field.field_name().unwrap()),\n+                        );\n                         edit.replace(name_range, new_name.to_string());\n                     }\n                 } else {\n-                    // Foo { ref mut field } -> Foo { field: ref mut new_name }\n-                    //      ^ insert `field: `\n-                    //               ^^^^^ replace this with `new_name`\n-                    edit.insert(\n-                        pat.syntax().text_range().start(),\n-                        format!(\"{}: \", pat_field.field_name().unwrap()),\n-                    );\n                     edit.replace(name_range, new_name.to_string());\n                 }\n             }\n         }\n+        let Some(file_id) = file_id else { bail!(\"No file available to rename\") };\n+        return Ok((file_id, edit.finish()));\n     }\n-    if edit.is_empty() {\n-        let (range, new_name) = match def {\n-            Definition::GenericParam(hir::GenericParam::LifetimeParam(_))\n-            | Definition::Label(_) => (\n-                TextRange::new(range.start() + syntax::TextSize::from(1), range.end()),\n-                new_name.strip_prefix('\\'').unwrap_or(new_name).to_owned(),\n-            ),\n-            _ => (range, new_name.to_owned()),\n-        };\n-        edit.replace(range, new_name);\n-    }\n+    let FileRange { file_id, range } = def\n+        .range_for_rename(sema)\n+        .ok_or_else(|| format_err!(\"No identifier available to rename\"))?;\n+    let (range, new_name) = match def {\n+        Definition::GenericParam(hir::GenericParam::LifetimeParam(_)) | Definition::Label(_) => (\n+            TextRange::new(range.start() + syntax::TextSize::from(1), range.end()),\n+            new_name.strip_prefix('\\'').unwrap_or(new_name).to_owned(),\n+        ),\n+        _ => (range, new_name.to_owned()),\n+    };\n+    edit.replace(range, new_name);\n     Ok((file_id, edit.finish()))\n }\n "}, {"sha": "6298ea1927d1fda6966fbd2263d1c130025716d9", "filename": "crates/ide-db/src/search.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fide-db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fide-db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fsearch.rs?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -320,7 +320,7 @@ impl Definition {\n             scope: None,\n             include_self_kw_refs: None,\n             local_repr: match self {\n-                Definition::Local(local) => Some(local.representative(sema.db)),\n+                Definition::Local(local) => Some(local),\n                 _ => None,\n             },\n             search_self_mod: false,\n@@ -646,7 +646,7 @@ impl<'a> FindUsages<'a> {\n         match NameRefClass::classify(self.sema, name_ref) {\n             Some(NameRefClass::Definition(def @ Definition::Local(local)))\n                 if matches!(\n-                    self.local_repr, Some(repr) if repr == local.representative(self.sema.db)\n+                    self.local_repr, Some(repr) if repr == local\n                 ) =>\n             {\n                 let FileRange { file_id, range } = self.sema.original_range(name_ref.syntax());\n@@ -707,7 +707,7 @@ impl<'a> FindUsages<'a> {\n                     Definition::Field(_) if field == self.def => {\n                         ReferenceCategory::new(&field, name_ref)\n                     }\n-                    Definition::Local(_) if matches!(self.local_repr, Some(repr) if repr == local.representative(self.sema.db)) => {\n+                    Definition::Local(_) if matches!(self.local_repr, Some(repr) if repr == local) => {\n                         ReferenceCategory::new(&Definition::Local(local), name_ref)\n                     }\n                     _ => return false,\n@@ -755,7 +755,7 @@ impl<'a> FindUsages<'a> {\n             Some(NameClass::Definition(def @ Definition::Local(local))) if def != self.def => {\n                 if matches!(\n                     self.local_repr,\n-                    Some(repr) if local.representative(self.sema.db) == repr\n+                    Some(repr) if local == repr\n                 ) {\n                     let FileRange { file_id, range } = self.sema.original_range(name.syntax());\n                     let reference = FileReference {"}, {"sha": "9c79ceba01e4eb712cb9421d68e28b221d1d02e2", "filename": "crates/ide-diagnostics/src/handlers/mutability_errors.rs", "status": "added", "additions": 592, "deletions": 0, "changes": 592, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -0,0 +1,592 @@\n+use ide_db::source_change::SourceChange;\n+use syntax::{AstNode, SyntaxKind, SyntaxNode, SyntaxToken, T};\n+use text_edit::TextEdit;\n+\n+use crate::{fix, Diagnostic, DiagnosticsContext, Severity};\n+\n+// Diagnostic: need-mut\n+//\n+// This diagnostic is triggered on mutating an immutable variable.\n+pub(crate) fn need_mut(ctx: &DiagnosticsContext<'_>, d: &hir::NeedMut) -> Diagnostic {\n+    let fixes = (|| {\n+        if d.local.is_ref(ctx.sema.db) {\n+            // There is no simple way to add `mut` to `ref x` and `ref mut x`\n+            return None;\n+        }\n+        let file_id = d.span.file_id.file_id()?;\n+        let mut edit_builder = TextEdit::builder();\n+        let use_range = d.span.value.text_range();\n+        for source in d.local.sources(ctx.sema.db) {\n+            let Some(ast) = source.name() else { continue };\n+            edit_builder.insert(ast.syntax().text_range().start(), \"mut \".to_string());\n+        }\n+        let edit = edit_builder.finish();\n+        Some(vec![fix(\n+            \"add_mut\",\n+            \"Change it to be mutable\",\n+            SourceChange::from_text_edit(file_id, edit),\n+            use_range,\n+        )])\n+    })();\n+    Diagnostic::new(\n+        \"need-mut\",\n+        format!(\"cannot mutate immutable variable `{}`\", d.local.name(ctx.sema.db)),\n+        ctx.sema.diagnostics_display_range(d.span.clone()).range,\n+    )\n+    .with_fixes(fixes)\n+}\n+\n+// Diagnostic: unused-mut\n+//\n+// This diagnostic is triggered when a mutable variable isn't actually mutated.\n+pub(crate) fn unused_mut(ctx: &DiagnosticsContext<'_>, d: &hir::UnusedMut) -> Diagnostic {\n+    let ast = d.local.primary_source(ctx.sema.db).syntax_ptr();\n+    let fixes = (|| {\n+        let file_id = ast.file_id.file_id()?;\n+        let mut edit_builder = TextEdit::builder();\n+        let use_range = ast.value.text_range();\n+        for source in d.local.sources(ctx.sema.db) {\n+            let ast = source.syntax();\n+            let Some(mut_token) = token(ast, T![mut]) else { continue };\n+            edit_builder.delete(mut_token.text_range());\n+            if let Some(token) = mut_token.next_token() {\n+                if token.kind() == SyntaxKind::WHITESPACE {\n+                    edit_builder.delete(token.text_range());\n+                }\n+            }\n+        }\n+        let edit = edit_builder.finish();\n+        Some(vec![fix(\n+            \"remove_mut\",\n+            \"Remove unnecessary `mut`\",\n+            SourceChange::from_text_edit(file_id, edit),\n+            use_range,\n+        )])\n+    })();\n+    let ast = d.local.primary_source(ctx.sema.db).syntax_ptr();\n+    Diagnostic::new(\n+        \"unused-mut\",\n+        \"variable does not need to be mutable\",\n+        ctx.sema.diagnostics_display_range(ast).range,\n+    )\n+    .severity(Severity::WeakWarning)\n+    .experimental() // Not supporting `#[allow(unused_mut)]` leads to false positive.\n+    .with_fixes(fixes)\n+}\n+\n+pub(super) fn token(parent: &SyntaxNode, kind: SyntaxKind) -> Option<SyntaxToken> {\n+    parent.children_with_tokens().filter_map(|it| it.into_token()).find(|it| it.kind() == kind)\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_diagnostics, check_fix};\n+\n+    #[test]\n+    fn unused_mut_simple() {\n+        check_diagnostics(\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    let mut x = 2;\n+      //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+    f(x);\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_false_positive_simple() {\n+        check_diagnostics(\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    let x = 2;\n+    f(x);\n+}\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    let mut x = 2;\n+    x = 5;\n+    f(x);\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn multiple_errors_for_single_variable() {\n+        check_diagnostics(\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    let x = 2;\n+    x = 10;\n+  //^^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+    x = 5;\n+  //^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+    &mut x;\n+  //^^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+    f(x);\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unused_mut_fix() {\n+        check_fix(\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    let mu$0t x = 2;\n+    f(x);\n+}\n+\"#,\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    let x = 2;\n+    f(x);\n+}\n+\"#,\n+        );\n+        check_fix(\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    let ((mu$0t x, _) | (_, mut x)) = (2, 3);\n+    f(x);\n+}\n+\"#,\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    let ((x, _) | (_, x)) = (2, 3);\n+    f(x);\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn need_mut_fix() {\n+        check_fix(\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    let x = 2;\n+    x$0 = 5;\n+    f(x);\n+}\n+\"#,\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    let mut x = 2;\n+    x = 5;\n+    f(x);\n+}\n+\"#,\n+        );\n+        check_fix(\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    let ((x, _) | (_, x)) = (2, 3);\n+    x =$0 4;\n+    f(x);\n+}\n+\"#,\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    let ((mut x, _) | (_, mut x)) = (2, 3);\n+    x = 4;\n+    f(x);\n+}\n+\"#,\n+        );\n+\n+        check_fix(\n+            r#\"\n+struct Foo(i32);\n+\n+impl Foo {\n+    fn foo(self) {\n+        self = Fo$0o(5);\n+    }\n+}\n+\"#,\n+            r#\"\n+struct Foo(i32);\n+\n+impl Foo {\n+    fn foo(mut self) {\n+        self = Foo(5);\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn need_mut_fix_not_applicable_on_ref() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    let ref x = 2;\n+    x = &5;\n+  //^^^^^^ error: cannot mutate immutable variable `x`\n+}\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    let ref mut x = 2;\n+    x = &mut 5;\n+  //^^^^^^^^^^ error: cannot mutate immutable variable `x`\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn field_mutate() {\n+        check_diagnostics(\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    let mut x = (2, 7);\n+      //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+    f(x.1);\n+}\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    let mut x = (2, 7);\n+    x.0 = 5;\n+    f(x.1);\n+}\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    let x = (2, 7);\n+    x.0 = 5;\n+  //^^^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+    f(x.1);\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn mutable_reference() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    let mut x = &mut 2;\n+      //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+    *x = 5;\n+}\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    let x = 2;\n+    &mut x;\n+  //^^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+}\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    let x_own = 2;\n+    let ref mut x_ref = x_own;\n+      //^^^^^^^^^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x_own`\n+}\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+struct Foo;\n+impl Foo {\n+    fn method(&mut self, x: i32) {}\n+}\n+fn main() {\n+    let x = Foo;\n+    x.method(2);\n+  //^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn match_bindings() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    match (2, 3) {\n+        (x, mut y) => {\n+          //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+            x = 7;\n+          //^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+        }\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn mutation_in_dead_code() {\n+        // This one is interesting. Dead code is not represented at all in the MIR, so\n+        // there would be no mutablility error for locals in dead code. Rustc tries to\n+        // not emit `unused_mut` in this case, but since it works without `mut`, and\n+        // special casing it is not trivial, we emit it.\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    return;\n+    let mut x = 2;\n+      //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+    &mut x;\n+}\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    loop {}\n+    let mut x = 2;\n+      //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+    &mut x;\n+}\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+enum X {}\n+fn g() -> X {\n+    loop {}\n+}\n+fn f() -> ! {\n+    loop {}\n+}\n+fn main(b: bool) {\n+    if b {\n+        f();\n+    } else {\n+        g();\n+    }\n+    let mut x = 2;\n+      //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+    &mut x;\n+}\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+fn main(b: bool) {\n+    if b {\n+        loop {}\n+    } else {\n+        return;\n+    }\n+    let mut x = 2;\n+      //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+    &mut x;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn initialization_is_not_mutation() {\n+        check_diagnostics(\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    let mut x;\n+      //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+    x = 5;\n+    f(x);\n+}\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+fn f(_: i32) {}\n+fn main(b: bool) {\n+    let mut x;\n+      //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+    if b {\n+        x = 1;\n+    } else {\n+        x = 3;\n+    }\n+    f(x);\n+}\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+fn f(_: i32) {}\n+fn main(b: bool) {\n+    let x;\n+    if b {\n+        x = 1;\n+    }\n+    x = 3;\n+  //^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+    f(x);\n+}\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    let x;\n+    loop {\n+        x = 1;\n+      //^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+        f(x);\n+    }\n+}\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    loop {\n+        let mut x = 1;\n+          //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+        f(x);\n+        if let mut y = 2 {\n+             //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+            f(y);\n+        }\n+        match 3 {\n+            mut z => f(z),\n+          //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+        }\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn function_arguments_are_initialized() {\n+        check_diagnostics(\n+            r#\"\n+fn f(mut x: i32) {\n+   //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+}\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+fn f(x: i32) {\n+   x = 5;\n+ //^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn for_loop() {\n+        check_diagnostics(\n+            r#\"\n+//- minicore: iterators\n+fn f(x: [(i32, u8); 10]) {\n+    for (a, mut b) in x {\n+          //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+        a = 2;\n+      //^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `a`\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn overloaded_deref() {\n+        // FIXME: check for false negative\n+        check_diagnostics(\n+            r#\"\n+//- minicore: deref_mut\n+use core::ops::{Deref, DerefMut};\n+\n+struct Foo;\n+impl Deref for Foo {\n+    type Target = i32;\n+    fn deref(&self) -> &i32 {\n+        &5\n+    }\n+}\n+impl DerefMut for Foo {\n+    fn deref_mut(&mut self) -> &mut i32 {\n+        &mut 5\n+    }\n+}\n+fn f() {\n+    let x = Foo;\n+    let y = &*x;\n+    let x = Foo;\n+    let mut x = Foo;\n+    let y: &mut i32 = &mut x;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn or_pattern() {\n+        check_diagnostics(\n+            r#\"\n+//- minicore: option\n+fn f(_: i32) {}\n+fn main() {\n+    let ((Some(mut x), None) | (_, Some(mut x))) = (None, Some(7));\n+             //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+    f(x);\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn respect_allow_unused_mut() {\n+        // FIXME: respect\n+        check_diagnostics(\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    #[allow(unused_mut)]\n+    let mut x = 2;\n+      //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+    f(x);\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "f6c9b79c30c3cf31f101cda55a4b80046eb84149", "filename": "crates/ide-diagnostics/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fide-diagnostics%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fide-diagnostics%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Flib.rs?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -37,6 +37,7 @@ mod handlers {\n     pub(crate) mod missing_fields;\n     pub(crate) mod missing_match_arms;\n     pub(crate) mod missing_unsafe;\n+    pub(crate) mod mutability_errors;\n     pub(crate) mod no_such_field;\n     pub(crate) mod private_assoc_item;\n     pub(crate) mod private_field;\n@@ -273,7 +274,8 @@ pub fn diagnostics(\n             AnyDiagnostic::InvalidDeriveTarget(d) => handlers::invalid_derive_target::invalid_derive_target(&ctx, &d),\n             AnyDiagnostic::UnresolvedField(d) => handlers::unresolved_field::unresolved_field(&ctx, &d),\n             AnyDiagnostic::UnresolvedMethodCall(d) => handlers::unresolved_method::unresolved_method(&ctx, &d),\n-\n+            AnyDiagnostic::NeedMut(d) => handlers::mutability_errors::need_mut(&ctx, &d),\n+            AnyDiagnostic::UnusedMut(d) => handlers::mutability_errors::unused_mut(&ctx, &d),\n             AnyDiagnostic::InactiveCode(d) => match handlers::inactive_code::inactive_code(&ctx, &d) {\n                 Some(it) => it,\n                 None => continue,"}, {"sha": "d88ffd25c40fe008bf3cee63c2e15e15afba7583", "filename": "crates/ide/src/highlight_related.rs", "status": "modified", "additions": 32, "deletions": 25, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhighlight_related.rs?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -14,7 +14,7 @@ use syntax::{\n     SyntaxNode, SyntaxToken, TextRange, T,\n };\n \n-use crate::{references, NavigationTarget, TryToNav};\n+use crate::{navigation_target::ToNav, references, NavigationTarget, TryToNav};\n \n #[derive(PartialEq, Eq, Hash)]\n pub struct HighlightedRange {\n@@ -98,32 +98,39 @@ fn highlight_references(\n             category: access,\n         });\n     let mut res = FxHashSet::default();\n-\n-    let mut def_to_hl_range = |def| {\n-        let hl_range = match def {\n-            Definition::Module(module) => {\n-                Some(NavigationTarget::from_module_to_decl(sema.db, module))\n-            }\n-            def => def.try_to_nav(sema.db),\n-        }\n-        .filter(|decl| decl.file_id == file_id)\n-        .and_then(|decl| decl.focus_range)\n-        .map(|range| {\n-            let category =\n-                references::decl_mutability(&def, node, range).then_some(ReferenceCategory::Write);\n-            HighlightedRange { range, category }\n-        });\n-        if let Some(hl_range) = hl_range {\n-            res.insert(hl_range);\n-        }\n-    };\n     for &def in &defs {\n         match def {\n-            Definition::Local(local) => local\n-                .associated_locals(sema.db)\n-                .iter()\n-                .for_each(|&local| def_to_hl_range(Definition::Local(local))),\n-            def => def_to_hl_range(def),\n+            Definition::Local(local) => {\n+                let category = local.is_mut(sema.db).then_some(ReferenceCategory::Write);\n+                local\n+                    .sources(sema.db)\n+                    .into_iter()\n+                    .map(|x| x.to_nav(sema.db))\n+                    .filter(|decl| decl.file_id == file_id)\n+                    .filter_map(|decl| decl.focus_range)\n+                    .map(|range| HighlightedRange { range, category })\n+                    .for_each(|x| {\n+                        res.insert(x);\n+                    });\n+            }\n+            def => {\n+                let hl_range = match def {\n+                    Definition::Module(module) => {\n+                        Some(NavigationTarget::from_module_to_decl(sema.db, module))\n+                    }\n+                    def => def.try_to_nav(sema.db),\n+                }\n+                .filter(|decl| decl.file_id == file_id)\n+                .and_then(|decl| decl.focus_range)\n+                .map(|range| {\n+                    let category = references::decl_mutability(&def, node, range)\n+                        .then_some(ReferenceCategory::Write);\n+                    HighlightedRange { range, category }\n+                });\n+                if let Some(hl_range) = hl_range {\n+                    res.insert(hl_range);\n+                }\n+            }\n         }\n     }\n "}, {"sha": "da725ce502b8da62348946ab08242c6405de24f2", "filename": "crates/ide/src/hover/render.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fide%2Fsrc%2Fhover%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fide%2Fsrc%2Fhover%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Frender.rs?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -635,8 +635,8 @@ fn local(db: &RootDatabase, it: hir::Local) -> Option<Markup> {\n     let ty = it.ty(db);\n     let ty = ty.display_truncated(db, None);\n     let is_mut = if it.is_mut(db) { \"mut \" } else { \"\" };\n-    let desc = match it.source(db).value {\n-        Either::Left(ident) => {\n+    let desc = match it.primary_source(db).into_ident_pat() {\n+        Some(ident) => {\n             let name = it.name(db);\n             let let_kw = if ident\n                 .syntax()\n@@ -649,7 +649,7 @@ fn local(db: &RootDatabase, it: hir::Local) -> Option<Markup> {\n             };\n             format!(\"{let_kw}{is_mut}{name}: {ty}\")\n         }\n-        Either::Right(_) => format!(\"{is_mut}self: {ty}\"),\n+        None => format!(\"{is_mut}self: {ty}\"),\n     };\n     markup(None, desc, None)\n }"}, {"sha": "078b66dd3955f2fd4604ca81dcba912e44bb918f", "filename": "crates/ide/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Flib.rs?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -55,6 +55,7 @@ mod syntax_tree;\n mod typing;\n mod view_crate_graph;\n mod view_hir;\n+mod view_mir;\n mod view_item_tree;\n mod shuffle_crate_graph;\n \n@@ -308,6 +309,10 @@ impl Analysis {\n         self.with_db(|db| view_hir::view_hir(db, position))\n     }\n \n+    pub fn view_mir(&self, position: FilePosition) -> Cancellable<String> {\n+        self.with_db(|db| view_mir::view_mir(db, position))\n+    }\n+\n     pub fn view_item_tree(&self, file_id: FileId) -> Cancellable<String> {\n         self.with_db(|db| view_item_tree::view_item_tree(db, file_id))\n     }"}, {"sha": "6aae82f98160025169032477e7ad1a648697960e", "filename": "crates/ide/src/navigation_target.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fide%2Fsrc%2Fnavigation_target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fide%2Fsrc%2Fnavigation_target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fnavigation_target.rs?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -5,7 +5,7 @@ use std::fmt;\n use either::Either;\n use hir::{\n     symbols::FileSymbol, AssocItem, Documentation, FieldSource, HasAttrs, HasSource, HirDisplay,\n-    InFile, ModuleSource, Semantics,\n+    InFile, LocalSource, ModuleSource, Semantics,\n };\n use ide_db::{\n     base_db::{FileId, FileRange},\n@@ -387,9 +387,11 @@ impl TryToNav for hir::GenericParam {\n     }\n }\n \n-impl ToNav for hir::Local {\n+impl ToNav for LocalSource {\n     fn to_nav(&self, db: &RootDatabase) -> NavigationTarget {\n-        let InFile { file_id, value } = self.source(db);\n+        let InFile { file_id, value } = &self.source;\n+        let file_id = *file_id;\n+        let local = self.local;\n         let (node, name) = match &value {\n             Either::Left(bind_pat) => (bind_pat.syntax(), bind_pat.name()),\n             Either::Right(it) => (it.syntax(), it.name()),\n@@ -398,10 +400,10 @@ impl ToNav for hir::Local {\n         let FileRange { file_id, range: full_range } =\n             InFile::new(file_id, node).original_file_range(db);\n \n-        let name = self.name(db).to_smol_str();\n-        let kind = if self.is_self(db) {\n+        let name = local.name(db).to_smol_str();\n+        let kind = if local.is_self(db) {\n             SymbolKind::SelfParam\n-        } else if self.is_param(db) {\n+        } else if local.is_param(db) {\n             SymbolKind::ValueParam\n         } else {\n             SymbolKind::Local\n@@ -419,6 +421,12 @@ impl ToNav for hir::Local {\n     }\n }\n \n+impl ToNav for hir::Local {\n+    fn to_nav(&self, db: &RootDatabase) -> NavigationTarget {\n+        self.primary_source(db).to_nav(db)\n+    }\n+}\n+\n impl ToNav for hir::Label {\n     fn to_nav(&self, db: &RootDatabase) -> NavigationTarget {\n         let InFile { file_id, value } = self.source(db);"}, {"sha": "e10c463810220e4d8970086cf2432dcdd7863d94", "filename": "crates/ide/src/rename.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fide%2Fsrc%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fide%2Fsrc%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Frename.rs?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -353,6 +353,11 @@ mod tests {\n     fn check(new_name: &str, ra_fixture_before: &str, ra_fixture_after: &str) {\n         let ra_fixture_after = &trim_indent(ra_fixture_after);\n         let (analysis, position) = fixture::position(ra_fixture_before);\n+        if !ra_fixture_after.starts_with(\"error: \") {\n+            if let Err(err) = analysis.prepare_rename(position).unwrap() {\n+                panic!(\"Prepare rename to '{new_name}' was failed: {err}\")\n+            }\n+        }\n         let rename_result = analysis\n             .rename(position, new_name)\n             .unwrap_or_else(|err| panic!(\"Rename to '{new_name}' was cancelled: {err}\"));\n@@ -1709,6 +1714,23 @@ fn foo(bar: i32) -> Foo {\n         );\n     }\n \n+    #[test]\n+    fn test_rename_local_simple() {\n+        check(\n+            \"i\",\n+            r#\"\n+fn foo(bar$0: i32) -> i32 {\n+    bar\n+}\n+\"#,\n+            r#\"\n+fn foo(i: i32) -> i32 {\n+    i\n+}\n+\"#,\n+        );\n+    }\n+\n     #[test]\n     fn test_rename_local_put_init_shorthand() {\n         cov_mark::check!(test_rename_local_put_init_shorthand);"}, {"sha": "a36aba58bc0ed81e9a89a30578acf31fac4ee473", "filename": "crates/ide/src/view_mir.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fide%2Fsrc%2Fview_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fide%2Fsrc%2Fview_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fview_mir.rs?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -0,0 +1,29 @@\n+use hir::{DefWithBody, Semantics};\n+use ide_db::base_db::FilePosition;\n+use ide_db::RootDatabase;\n+use syntax::{algo::find_node_at_offset, ast, AstNode};\n+\n+// Feature: View Mir\n+//\n+// |===\n+// | Editor  | Action Name\n+//\n+// | VS Code | **rust-analyzer: View Mir**\n+// |===\n+pub(crate) fn view_mir(db: &RootDatabase, position: FilePosition) -> String {\n+    body_mir(db, position).unwrap_or_else(|| \"Not inside a function body\".to_string())\n+}\n+\n+fn body_mir(db: &RootDatabase, position: FilePosition) -> Option<String> {\n+    let sema = Semantics::new(db);\n+    let source_file = sema.parse(position.file_id);\n+\n+    let item = find_node_at_offset::<ast::Item>(source_file.syntax(), position.offset)?;\n+    let def: DefWithBody = match item {\n+        ast::Item::Fn(it) => sema.to_def(&it)?.into(),\n+        ast::Item::Const(it) => sema.to_def(&it)?.into(),\n+        ast::Item::Static(it) => sema.to_def(&it)?.into(),\n+        _ => return None,\n+    };\n+    Some(def.debug_mir(db))\n+}"}, {"sha": "32ac9a42dec33c99ca4905b94a3ccd9e4458868f", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -134,6 +134,16 @@ pub(crate) fn handle_view_hir(\n     Ok(res)\n }\n \n+pub(crate) fn handle_view_mir(\n+    snap: GlobalStateSnapshot,\n+    params: lsp_types::TextDocumentPositionParams,\n+) -> Result<String> {\n+    let _p = profile::span(\"handle_view_mir\");\n+    let position = from_proto::file_position(&snap, params)?;\n+    let res = snap.analysis.view_mir(position)?;\n+    Ok(res)\n+}\n+\n pub(crate) fn handle_view_file_text(\n     snap: GlobalStateSnapshot,\n     params: lsp_types::TextDocumentIdentifier,"}, {"sha": "c7b513db981ea1607d23ae3ce9e8e54190fdb0b0", "filename": "crates/rust-analyzer/src/lsp_ext.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -74,6 +74,14 @@ impl Request for ViewHir {\n     const METHOD: &'static str = \"rust-analyzer/viewHir\";\n }\n \n+pub enum ViewMir {}\n+\n+impl Request for ViewMir {\n+    type Params = lsp_types::TextDocumentPositionParams;\n+    type Result = String;\n+    const METHOD: &'static str = \"rust-analyzer/viewMir\";\n+}\n+\n pub enum ViewFileText {}\n \n impl Request for ViewFileText {"}, {"sha": "d2797690669a36bf95b05ad4dec710207381e446", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -634,6 +634,7 @@ impl GlobalState {\n             .on::<lsp_ext::AnalyzerStatus>(handlers::handle_analyzer_status)\n             .on::<lsp_ext::SyntaxTree>(handlers::handle_syntax_tree)\n             .on::<lsp_ext::ViewHir>(handlers::handle_view_hir)\n+            .on::<lsp_ext::ViewMir>(handlers::handle_view_mir)\n             .on::<lsp_ext::ViewFileText>(handlers::handle_view_file_text)\n             .on::<lsp_ext::ViewCrateGraph>(handlers::handle_view_crate_graph)\n             .on::<lsp_ext::ViewItemTree>(handlers::handle_view_item_tree)"}, {"sha": "3e43df2d0d52b57f5024c1133e71fd5ecb63187b", "filename": "crates/syntax/src/ast/traits.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fsyntax%2Fsrc%2Fast%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Fsyntax%2Fsrc%2Fast%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Ftraits.rs?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -134,3 +134,5 @@ impl Iterator for AttrDocCommentIter {\n         })\n     }\n }\n+\n+impl<A: HasName, B: HasName> HasName for Either<A, B> {}"}, {"sha": "93ff76a040c6d44eadd3384e8339d853bcc4715b", "filename": "crates/test-utils/src/minicore.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest-utils%2Fsrc%2Fminicore.rs?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -762,6 +762,20 @@ pub mod iter {\n                     self\n                 }\n             }\n+            pub struct IntoIter<T, const N: usize>([T; N]);\n+            impl<T, const N: usize> IntoIterator for [T; N] {\n+                type Item = T;\n+                type IntoIter = IntoIter<T, N>;\n+                fn into_iter(self) -> I {\n+                    IntoIter(self)\n+                }\n+            }\n+            impl<T, const N: usize> Iterator for IntoIter<T, N> {\n+                type Item = T;\n+                fn next(&mut self) -> Option<T> {\n+                    loop {}\n+                }\n+            }\n         }\n         pub use self::collect::IntoIterator;\n     }"}, {"sha": "de1422032088f536ff065d068cd2a62a59dd9aad", "filename": "docs/dev/lsp-extensions.md", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/docs%2Fdev%2Flsp-extensions.md", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/docs%2Fdev%2Flsp-extensions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2Flsp-extensions.md?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -1,5 +1,5 @@\n <!---\n-lsp_ext.rs hash: d87477896dfe41d4\n+lsp_ext.rs hash: 37f31ae648632897\n \n If you need to change the above hash to make the test pass, please check if you\n need to adjust this doc as well and ping this issue:\n@@ -527,6 +527,17 @@ Primarily for debugging, but very useful for all people working on rust-analyzer\n Returns a textual representation of the HIR of the function containing the cursor.\n For debugging or when working on rust-analyzer itself.\n \n+## View Mir\n+\n+**Method:** `rust-analyzer/viewMir`\n+\n+**Request:** `TextDocumentPositionParams`\n+\n+**Response:** `string`\n+\n+Returns a textual representation of the MIR of the function containing the cursor.\n+For debugging or when working on rust-analyzer itself.\n+\n ## View File Text\n \n **Method:** `rust-analyzer/viewFileText`"}, {"sha": "90f7b9074c858a55d3a8dc01d85b2e0de7dff1a4", "filename": "editors/code/package.json", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/editors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/editors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage.json?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -114,6 +114,11 @@\n                 \"title\": \"View Hir\",\n                 \"category\": \"rust-analyzer (debug command)\"\n             },\n+            {\n+                \"command\": \"rust-analyzer.viewMir\",\n+                \"title\": \"View Mir\",\n+                \"category\": \"rust-analyzer (debug command)\"\n+            },\n             {\n                 \"command\": \"rust-analyzer.viewFileText\",\n                 \"title\": \"View File Text (as seen by the server)\","}, {"sha": "70b91fe7dc87f40bb8c465f618954fcab392193e", "filename": "editors/code/src/commands.ts", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/editors%2Fcode%2Fsrc%2Fcommands.ts", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/editors%2Fcode%2Fsrc%2Fcommands.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcommands.ts?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -405,12 +405,11 @@ export function syntaxTree(ctx: CtxInit): Cmd {\n     };\n }\n \n-// Opens the virtual file that will show the HIR of the function containing the cursor position\n-//\n-// The contents of the file come from the `TextDocumentContentProvider`\n-export function viewHir(ctx: CtxInit): Cmd {\n+function viewHirOrMir(ctx: CtxInit, xir: \"hir\" | \"mir\"): Cmd {\n+    const viewXir = xir === \"hir\" ? \"viewHir\" : \"viewMir\";\n+    const requestType = xir === \"hir\" ? ra.viewHir : ra.viewMir;\n     const tdcp = new (class implements vscode.TextDocumentContentProvider {\n-        readonly uri = vscode.Uri.parse(\"rust-analyzer-hir://viewHir/hir.rs\");\n+        readonly uri = vscode.Uri.parse(`rust-analyzer-${xir}://${viewXir}/${xir}.rs`);\n         readonly eventEmitter = new vscode.EventEmitter<vscode.Uri>();\n         constructor() {\n             vscode.workspace.onDidChangeTextDocument(\n@@ -452,7 +451,7 @@ export function viewHir(ctx: CtxInit): Cmd {\n                 ),\n                 position: client.code2ProtocolConverter.asPosition(rustEditor.selection.active),\n             };\n-            return client.sendRequest(ra.viewHir, params, ct);\n+            return client.sendRequest(requestType, params, ct);\n         }\n \n         get onDidChange(): vscode.Event<vscode.Uri> {\n@@ -461,7 +460,7 @@ export function viewHir(ctx: CtxInit): Cmd {\n     })();\n \n     ctx.pushExtCleanup(\n-        vscode.workspace.registerTextDocumentContentProvider(\"rust-analyzer-hir\", tdcp)\n+        vscode.workspace.registerTextDocumentContentProvider(`rust-analyzer-${xir}`, tdcp)\n     );\n \n     return async () => {\n@@ -474,6 +473,20 @@ export function viewHir(ctx: CtxInit): Cmd {\n     };\n }\n \n+// Opens the virtual file that will show the HIR of the function containing the cursor position\n+//\n+// The contents of the file come from the `TextDocumentContentProvider`\n+export function viewHir(ctx: CtxInit): Cmd {\n+    return viewHirOrMir(ctx, \"hir\");\n+}\n+\n+// Opens the virtual file that will show the MIR of the function containing the cursor position\n+//\n+// The contents of the file come from the `TextDocumentContentProvider`\n+export function viewMir(ctx: CtxInit): Cmd {\n+    return viewHirOrMir(ctx, \"mir\");\n+}\n+\n export function viewFileText(ctx: CtxInit): Cmd {\n     const tdcp = new (class implements vscode.TextDocumentContentProvider {\n         readonly uri = vscode.Uri.parse(\"rust-analyzer-file-text://viewFileText/file.rs\");"}, {"sha": "400cd207d41b0a3a0541ddeaa015bdc1c5e78025", "filename": "editors/code/src/lsp_ext.ts", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/editors%2Fcode%2Fsrc%2Flsp_ext.ts", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/editors%2Fcode%2Fsrc%2Flsp_ext.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Flsp_ext.ts?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -59,6 +59,9 @@ export const viewFileText = new lc.RequestType<lc.TextDocumentIdentifier, string\n export const viewHir = new lc.RequestType<lc.TextDocumentPositionParams, string, void>(\n     \"rust-analyzer/viewHir\"\n );\n+export const viewMir = new lc.RequestType<lc.TextDocumentPositionParams, string, void>(\n+    \"rust-analyzer/viewMir\"\n+);\n export const viewItemTree = new lc.RequestType<ViewItemTreeParams, string, void>(\n     \"rust-analyzer/viewItemTree\"\n );"}, {"sha": "1eb01f30c1e194228e0dc16862a3b9a9c3f147b6", "filename": "editors/code/src/main.ts", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/editors%2Fcode%2Fsrc%2Fmain.ts", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/editors%2Fcode%2Fsrc%2Fmain.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fmain.ts?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -158,6 +158,7 @@ function createCommands(): Record<string, CommandFactory> {\n         parentModule: { enabled: commands.parentModule },\n         syntaxTree: { enabled: commands.syntaxTree },\n         viewHir: { enabled: commands.viewHir },\n+        viewMir: { enabled: commands.viewMir },\n         viewFileText: { enabled: commands.viewFileText },\n         viewItemTree: { enabled: commands.viewItemTree },\n         viewCrateGraph: { enabled: commands.viewCrateGraph },"}, {"sha": "7fff2b09c97b5e8effdf0e53ad004e39403e7555", "filename": "lib/la-arena/src/map.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/lib%2Fla-arena%2Fsrc%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44ff3c407a9db70f0c8f02b04d73ab1f883f37fe/lib%2Fla-arena%2Fsrc%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lib%2Fla-arena%2Fsrc%2Fmap.rs?ref=44ff3c407a9db70f0c8f02b04d73ab1f883f37fe", "patch": "@@ -94,6 +94,12 @@ impl<T, V> ArenaMap<Idx<T>, V> {\n             .filter_map(|(idx, o)| Some((Self::from_idx(idx), o.as_mut()?)))\n     }\n \n+    /// Returns an iterator over the arena indexes and values in the map.\n+    // FIXME: Implement `IntoIterator` trait.\n+    pub fn into_iter(self) -> impl Iterator<Item = (Idx<T>, V)> {\n+        self.v.into_iter().enumerate().filter_map(|(idx, o)| Some((Self::from_idx(idx), o?)))\n+    }\n+\n     /// Gets the given key's corresponding entry in the map for in-place manipulation.\n     pub fn entry(&mut self, idx: Idx<T>) -> Entry<'_, Idx<T>, V> {\n         let idx = Self::to_idx(idx);"}]}