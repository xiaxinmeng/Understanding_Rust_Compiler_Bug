{"sha": "34700c15c7a49d400951da385b2eacab6fb6fe86", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0NzAwYzE1YzdhNDlkNDAwOTUxZGEzODViMmVhY2FiNmZiNmZlODY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-30T20:58:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-30T20:58:57Z"}, "message": "Auto merge of #66577 - WaffleLapkin:iter_take_while_map, r=mark-simulcrum\n\nAdd `Iterator::map_while`\n\nIn `Iterator` trait there is `*_map` version of [`filter`] \u2014 [`filter_map`], however, there is no `*_map` version of [`take_while`], that can also be useful.\n\n### Use cases\nIn my code, I've found that I need to iterate through iterator of `Option`s, stopping on the first `None`. So I've written code like this:\n```rust\nlet arr = [Some(4), Some(10), None, Some(3)];\nlet mut iter = arr.iter()\n    .take_while(|x| x.is_some())\n    .map(|x| x.unwrap());\n\nassert_eq!(iter.next(), Some(4));\nassert_eq!(iter.next(), Some(10));\nassert_eq!(iter.next(), None);\nassert_eq!(iter.next(), None);\n```\nThit code\n1) isn't clean\n2) In theory, can generate bad bytecode (I'm actually **not** sure, but I think that `unwrap` would generate additional branches with `panic!`)\n\nThe same code, but with `map_while` (in the original PR message it was named \"take_while_map\"):\n```rust\nlet arr = [Some(4), Some(10), None, Some(3)];\nlet mut iter = arr.iter().map_while(std::convert::identity);\n```\n\nAlso, `map_while` can be useful when converting something (as in [examples]).\n\n[`filter`]: https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.filter\n[`filter_map`]: https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.filter_map\n[`take_while`]: https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.take_while\n[examples]: https://github.com/rust-lang/rust/compare/master...WaffleLapkin:iter_take_while_map?expand=1#diff-7e57917f962fe6ffdfba51e4955ad6acR1042", "tree": {"sha": "a9b6c00759063072d80ff36975e14b4d1a8012b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9b6c00759063072d80ff36975e14b4d1a8012b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34700c15c7a49d400951da385b2eacab6fb6fe86", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34700c15c7a49d400951da385b2eacab6fb6fe86", "html_url": "https://github.com/rust-lang/rust/commit/34700c15c7a49d400951da385b2eacab6fb6fe86", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34700c15c7a49d400951da385b2eacab6fb6fe86/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "212b2c7da87f3086af535b33a9ca6b5242f2d5a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/212b2c7da87f3086af535b33a9ca6b5242f2d5a7", "html_url": "https://github.com/rust-lang/rust/commit/212b2c7da87f3086af535b33a9ca6b5242f2d5a7"}, {"sha": "db1a107b3f920637dc785fcc6d6bbe247a271e7b", "url": "https://api.github.com/repos/rust-lang/rust/commits/db1a107b3f920637dc785fcc6d6bbe247a271e7b", "html_url": "https://github.com/rust-lang/rust/commit/db1a107b3f920637dc785fcc6d6bbe247a271e7b"}], "stats": {"total": 196, "additions": 195, "deletions": 1}, "files": [{"sha": "7d10ef3d282198d49a1078da50674b5869c1e887", "filename": "src/libcore/iter/adapters/mod.rs", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/34700c15c7a49d400951da385b2eacab6fb6fe86/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34700c15c7a49d400951da385b2eacab6fb6fe86/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs?ref=34700c15c7a49d400951da385b2eacab6fb6fe86", "patch": "@@ -1752,6 +1752,95 @@ where\n     }\n }\n \n+/// An iterator that only accepts elements while `predicate` returns `Some(_)`.\n+///\n+/// This `struct` is created by the [`map_while`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`map_while`]: trait.Iterator.html#method.map_while\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[unstable(feature = \"iter_map_while\", reason = \"recently added\", issue = \"68537\")]\n+#[derive(Clone)]\n+pub struct MapWhile<I, P> {\n+    iter: I,\n+    finished: bool,\n+    predicate: P,\n+}\n+\n+impl<I, P> MapWhile<I, P> {\n+    pub(super) fn new(iter: I, predicate: P) -> MapWhile<I, P> {\n+        MapWhile { iter, finished: false, predicate }\n+    }\n+}\n+\n+#[unstable(feature = \"iter_map_while\", reason = \"recently added\", issue = \"68537\")]\n+impl<I: fmt::Debug, P> fmt::Debug for MapWhile<I, P> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"MapWhile\").field(\"iter\", &self.iter).field(\"flag\", &self.finished).finish()\n+    }\n+}\n+\n+#[unstable(feature = \"iter_map_while\", reason = \"recently added\", issue = \"68537\")]\n+impl<B, I: Iterator, P> Iterator for MapWhile<I, P>\n+where\n+    P: FnMut(I::Item) -> Option<B>,\n+{\n+    type Item = B;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<B> {\n+        if self.finished {\n+            None\n+        } else {\n+            let x = self.iter.next()?;\n+            let ret = (self.predicate)(x);\n+            self.finished = ret.is_none();\n+            ret\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.finished {\n+            (0, Some(0))\n+        } else {\n+            let (_, upper) = self.iter.size_hint();\n+            (0, upper) // can't know a lower bound, due to the predicate\n+        }\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        fn check<'a, B, T, Acc, R: Try<Ok = Acc>>(\n+            flag: &'a mut bool,\n+            p: &'a mut impl FnMut(T) -> Option<B>,\n+            mut fold: impl FnMut(Acc, B) -> R + 'a,\n+        ) -> impl FnMut(Acc, T) -> LoopState<Acc, R> + 'a {\n+            move |acc, x| match p(x) {\n+                Some(item) => LoopState::from_try(fold(acc, item)),\n+                None => {\n+                    *flag = true;\n+                    LoopState::Break(Try::from_ok(acc))\n+                }\n+            }\n+        }\n+\n+        if self.finished {\n+            Try::from_ok(init)\n+        } else {\n+            let flag = &mut self.finished;\n+            let p = &mut self.predicate;\n+            self.iter.try_fold(init, check(flag, p, fold)).into_try()\n+        }\n+    }\n+}\n+\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<I, P> FusedIterator for TakeWhile<I, P>\n where"}, {"sha": "d8a56cb3ae5152cc5e47fb3578e0d9ae0e395334", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34700c15c7a49d400951da385b2eacab6fb6fe86/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34700c15c7a49d400951da385b2eacab6fb6fe86/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=34700c15c7a49d400951da385b2eacab6fb6fe86", "patch": "@@ -351,6 +351,8 @@ pub use self::adapters::Cloned;\n pub use self::adapters::Copied;\n #[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n pub use self::adapters::Flatten;\n+#[unstable(feature = \"iter_map_while\", reason = \"recently added\", issue = \"68537\")]\n+pub use self::adapters::MapWhile;\n #[stable(feature = \"iterator_step_by\", since = \"1.28.0\")]\n pub use self::adapters::StepBy;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "1d055676c7708a75db07fd4d25c018bc33cc3712", "filename": "src/libcore/iter/traits/iterator.rs", "status": "modified", "additions": 101, "deletions": 1, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/34700c15c7a49d400951da385b2eacab6fb6fe86/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34700c15c7a49d400951da385b2eacab6fb6fe86/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs?ref=34700c15c7a49d400951da385b2eacab6fb6fe86", "patch": "@@ -1,4 +1,6 @@\n // ignore-tidy-filelength\n+// This file almost exclusively consists of the definition of `Iterator`. We\n+// can't split that into multiple files.\n \n use crate::cmp::{self, Ordering};\n use crate::ops::{Add, Try};\n@@ -7,7 +9,9 @@ use super::super::LoopState;\n use super::super::{Chain, Cloned, Copied, Cycle, Enumerate, Filter, FilterMap, Fuse};\n use super::super::{FlatMap, Flatten};\n use super::super::{FromIterator, Product, Sum, Zip};\n-use super::super::{Inspect, Map, Peekable, Rev, Scan, Skip, SkipWhile, StepBy, Take, TakeWhile};\n+use super::super::{\n+    Inspect, Map, MapWhile, Peekable, Rev, Scan, Skip, SkipWhile, StepBy, Take, TakeWhile,\n+};\n \n fn _assert_is_object_safe(_: &dyn Iterator<Item = ()>) {}\n \n@@ -1026,6 +1030,102 @@ pub trait Iterator {\n         TakeWhile::new(self, predicate)\n     }\n \n+    /// Creates an iterator that both yields elements based on a predicate and maps.\n+    ///\n+    /// `map_while()` takes a closure as an argument. It will call this\n+    /// closure on each element of the iterator, and yield elements\n+    /// while it returns [`Some(_)`][`Some`].\n+    ///\n+    /// After [`None`] is returned, `map_while()`'s job is over, and the\n+    /// rest of the elements are ignored.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(iter_map_while)]\n+    /// let a = [-1i32, 4, 0, 1];\n+    ///\n+    /// let mut iter = a.iter().map_while(|x| 16i32.checked_div(*x));\n+    ///\n+    /// assert_eq!(iter.next(), Some(-16));\n+    /// assert_eq!(iter.next(), Some(4));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// Here's the same example, but with [`take_while`] and [`map`]:\n+    ///\n+    /// [`take_while`]: #method.take_while\n+    /// [`map`]: #method.map\n+    ///\n+    /// ```\n+    /// let a = [-1i32, 4, 0, 1];\n+    ///\n+    /// let mut iter = a.iter()\n+    ///                 .map(|x| 16i32.checked_div(*x))\n+    ///                 .take_while(|x| x.is_some())\n+    ///                 .map(|x| x.unwrap());\n+    ///\n+    /// assert_eq!(iter.next(), Some(-16));\n+    /// assert_eq!(iter.next(), Some(4));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// Stopping after an initial [`None`]:\n+    ///\n+    /// ```\n+    /// #![feature(iter_map_while)]\n+    /// use std::convert::TryFrom;\n+    ///\n+    /// let a = [0, -1, 1, -2];\n+    ///\n+    /// let mut iter = a.iter().map_while(|x| u32::try_from(*x).ok());\n+    ///\n+    /// assert_eq!(iter.next(), Some(0u32));\n+    ///\n+    /// // We have more elements that are fit in u32, but since we already\n+    /// // got a None, map_while() isn't used any more\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// Because `map_while()` needs to look at the value in order to see if it\n+    /// should be included or not, consuming iterators will see that it is\n+    /// removed:\n+    ///\n+    /// ```\n+    /// #![feature(iter_map_while)]\n+    /// use std::convert::TryFrom;\n+    ///\n+    /// let a = [1, 2, -3, 4];\n+    /// let mut iter = a.iter();\n+    ///\n+    /// let result: Vec<u32> = iter.by_ref()\n+    ///                            .map_while(|n| u32::try_from(*n).ok())\n+    ///                            .collect();\n+    ///\n+    /// assert_eq!(result, &[1, 2]);\n+    ///\n+    /// let result: Vec<i32> = iter.cloned().collect();\n+    ///\n+    /// assert_eq!(result, &[4]);\n+    /// ```\n+    ///\n+    /// The `-3` is no longer there, because it was consumed in order to see if\n+    /// the iteration should stop, but wasn't placed back into the iterator.\n+    ///\n+    /// [`Some`]: ../../std/option/enum.Option.html#variant.Some\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    #[inline]\n+    #[unstable(feature = \"iter_map_while\", reason = \"recently added\", issue = \"68537\")]\n+    fn map_while<B, P>(self, predicate: P) -> MapWhile<Self, P>\n+    where\n+        Self: Sized,\n+        P: FnMut(Self::Item) -> Option<B>,\n+    {\n+        MapWhile::new(self, predicate)\n+    }\n+\n     /// Creates an iterator that skips the first `n` elements.\n     ///\n     /// After they have been consumed, the rest of the elements are yielded."}, {"sha": "bd3218ec27f3212112f585a440970b830e2896fc", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34700c15c7a49d400951da385b2eacab6fb6fe86/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34700c15c7a49d400951da385b2eacab6fb6fe86/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=34700c15c7a49d400951da385b2eacab6fb6fe86", "patch": "@@ -1477,6 +1477,7 @@ fn test_iterator_size_hint() {\n     assert_eq!(c.clone().take(5).size_hint(), (5, Some(5)));\n     assert_eq!(c.clone().skip(5).size_hint().1, None);\n     assert_eq!(c.clone().take_while(|_| false).size_hint(), (0, None));\n+    assert_eq!(c.clone().map_while(|_| None::<()>).size_hint(), (0, None));\n     assert_eq!(c.clone().skip_while(|_| false).size_hint(), (0, None));\n     assert_eq!(c.clone().enumerate().size_hint(), (usize::MAX, None));\n     assert_eq!(c.clone().chain(vi.clone().cloned()).size_hint(), (usize::MAX, None));\n@@ -1491,6 +1492,7 @@ fn test_iterator_size_hint() {\n     assert_eq!(vi.clone().skip(3).size_hint(), (7, Some(7)));\n     assert_eq!(vi.clone().skip(12).size_hint(), (0, Some(0)));\n     assert_eq!(vi.clone().take_while(|_| false).size_hint(), (0, Some(10)));\n+    assert_eq!(vi.clone().map_while(|_| None::<()>).size_hint(), (0, Some(10)));\n     assert_eq!(vi.clone().skip_while(|_| false).size_hint(), (0, Some(10)));\n     assert_eq!(vi.clone().enumerate().size_hint(), (10, Some(10)));\n     assert_eq!(vi.clone().chain(v2).size_hint(), (13, Some(13)));"}, {"sha": "8fd19ef67fccf33e53d9e22a41d2d91f17963bc5", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/34700c15c7a49d400951da385b2eacab6fb6fe86/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34700c15c7a49d400951da385b2eacab6fb6fe86/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=34700c15c7a49d400951da385b2eacab6fb6fe86", "patch": "@@ -36,6 +36,7 @@\n #![feature(iter_is_partitioned)]\n #![feature(iter_order_by)]\n #![feature(cmp_min_max_by)]\n+#![feature(iter_map_while)]\n #![feature(const_slice_from_raw_parts)]\n #![feature(const_raw_ptr_deref)]\n #![feature(never_type)]"}]}