{"sha": "c3bc8fada838c15e09e76a9d5d85438667c1636c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzYmM4ZmFkYTgzOGMxNWUwOWU3NmE5ZDVkODU0Mzg2NjdjMTYzNmM=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-01-15T00:05:07Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-01-17T18:08:16Z"}, "message": "Allow omission of the '.' after nullary tag patterns\n\nThis commit allows patterns like:\n\nalt x { some(_) { ... } none { } }\n\nwithout the '.' after none. The parser suspends judgment about\nwhether a bare ident is a tag or a new bound variable; instead,\nthe resolver disambiguates.\n\nThis means that any code after resolution that pattern-matches on\npatterns needs to call pat_util::normalize_pat, which consults\nan environment to do this disambiguation.\n\nIn addition, local variables are no longer allowed to shadow\ntag names, so this required changing some code (e.g. renaming\nvariables named \"mut\", and renaming ast::sub to subtract).\n\nThe parser currently accepts patterns with and without the '.'.\nOnce the compiler and libraries are changed, it will no longer\naccept the '.'.", "tree": {"sha": "e0ff1cb9ea73f7ee894e8ff3ab3180260f71aeac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0ff1cb9ea73f7ee894e8ff3ab3180260f71aeac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c3bc8fada838c15e09e76a9d5d85438667c1636c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c3bc8fada838c15e09e76a9d5d85438667c1636c", "html_url": "https://github.com/rust-lang/rust/commit/c3bc8fada838c15e09e76a9d5d85438667c1636c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c3bc8fada838c15e09e76a9d5d85438667c1636c/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a7bd817017c247edb0680936c6cf34ec4d8e7fc0", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7bd817017c247edb0680936c6cf34ec4d8e7fc0", "html_url": "https://github.com/rust-lang/rust/commit/a7bd817017c247edb0680936c6cf34ec4d8e7fc0"}], "stats": {"total": 595, "additions": 405, "deletions": 190}, "files": [{"sha": "93239ec116e25318d9f6baca332268202fc4f1db", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c3bc8fada838c15e09e76a9d5d85438667c1636c/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3bc8fada838c15e09e76a9d5d85438667c1636c/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=c3bc8fada838c15e09e76a9d5d85438667c1636c", "patch": "@@ -9,6 +9,7 @@ import std::list;\n import option::{some, none, is_none};\n import list::list;\n import driver::session::session;\n+import pat_util::*;\n \n // This is not an alias-analyser (though it would merit from becoming one, or\n // getting input from one, to be more precise). It is a pass that checks\n@@ -323,7 +324,7 @@ fn check_alt(cx: ctx, input: @ast::expr, arms: [ast::arm], sc: scope,\n     for a: ast::arm in arms {\n         let new_bs = sc.bs;\n         let root_var = path_def_id(cx, root.ex);\n-        let pat_id_map = ast_util::pat_id_map(a.pats[0]);\n+        let pat_id_map = pat_util::pat_id_map(cx.tcx, a.pats[0]);\n         type info = {\n             id: node_id,\n             mutable unsafe_tys: [unsafe_ty],\n@@ -588,10 +589,11 @@ fn pattern_roots(tcx: ty::ctxt, mut: option::t<unsafe_ty>, pat: @ast::pat)\n     -> [pattern_root] {\n     fn walk(tcx: ty::ctxt, mut: option::t<unsafe_ty>, pat: @ast::pat,\n             &set: [pattern_root]) {\n-        alt pat.node {\n+        alt normalize_pat(tcx, pat).node {\n           ast::pat_wild. | ast::pat_lit(_) | ast::pat_range(_, _) {}\n-          ast::pat_bind(nm, sub) {\n-            set += [{id: pat.id, name: nm, mut: mut, span: pat.span}];\n+          ast::pat_ident(nm, sub) {\n+            set += [{id: pat.id, name: path_to_ident(nm), mut: mut,\n+                        span: pat.span}];\n             alt sub { some(p) { walk(tcx, mut, p, set); } _ {} }\n           }\n           ast::pat_tag(_, ps) | ast::pat_tup(ps) {"}, {"sha": "de04da4901412df40a7bdf2bd5b4b95c6801a6c5", "filename": "src/comp/middle/ast_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c3bc8fada838c15e09e76a9d5d85438667c1636c/src%2Fcomp%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3bc8fada838c15e09e76a9d5d85438667c1636c/src%2Fcomp%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fast_map.rs?ref=c3bc8fada838c15e09e76a9d5d85438667c1636c", "patch": "@@ -44,14 +44,14 @@ fn map_fn(cx: ctx, _fk: visit::fn_kind, decl: fn_decl, _body: blk,\n }\n \n fn map_local(cx: ctx, loc: @local) {\n-    ast_util::pat_bindings(loc.node.pat) {|p|\n+    pat_util::pat_bindings(loc.node.pat) {|p|\n         cx.map.insert(p.id, node_local(cx.local_id));\n         cx.local_id += 1u;\n     };\n }\n \n fn map_arm(cx: ctx, arm: arm) {\n-    ast_util::pat_bindings(arm.pats[0]) {|p|\n+    pat_util::pat_bindings(arm.pats[0]) {|p|\n         cx.map.insert(p.id, node_local(cx.local_id));\n         cx.local_id += 1u;\n     };"}, {"sha": "e32866e574941071ad4c7fbce257a68d0d8d8e63", "filename": "src/comp/middle/check_alt.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c3bc8fada838c15e09e76a9d5d85438667c1636c/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3bc8fada838c15e09e76a9d5d85438667c1636c/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs?ref=c3bc8fada838c15e09e76a9d5d85438667c1636c", "patch": "@@ -1,6 +1,7 @@\n import syntax::ast::*;\n import syntax::ast_util::{variant_def_ids, dummy_sp, compare_lit_exprs,\n                           lit_expr_eq};\n+import pat_util::*;\n import syntax::visit;\n import option::{some, none};\n import driver::session::session;\n@@ -16,7 +17,12 @@ fn check_crate(tcx: ty::ctxt, crate: @crate) {\n \n fn check_expr(tcx: ty::ctxt, ex: @expr, &&s: (), v: visit::vt<()>) {\n     visit::visit_expr(ex, s, v);\n-    alt ex.node { expr_alt(_, arms) { check_arms(tcx, arms); } _ { } }\n+    alt ex.node {\n+        expr_alt(_, arms) {\n+            check_arms(tcx, pat_util::normalize_arms(tcx, arms));\n+        }\n+        _ { }\n+    }\n }\n \n fn check_arms(tcx: ty::ctxt, arms: [arm]) {\n@@ -66,8 +72,8 @@ fn pattern_supersedes(tcx: ty::ctxt, a: @pat, b: @pat) -> bool {\n     }\n \n     alt a.node {\n-      pat_bind(_, some(p)) { pattern_supersedes(tcx, p, b) }\n-      pat_wild. | pat_bind(_, none.) { true }\n+      pat_ident(_, some(p)) { pattern_supersedes(tcx, p, b) }\n+      pat_wild. | pat_ident(_, none.) { true }\n       pat_lit(la) {\n         alt b.node {\n           pat_lit(lb) { lit_expr_eq(la, lb) }\n@@ -132,11 +138,11 @@ fn check_local(tcx: ty::ctxt, loc: @local, &&s: (), v: visit::vt<()>) {\n }\n \n fn is_refutable(tcx: ty::ctxt, pat: @pat) -> bool {\n-    alt pat.node {\n-      pat_box(sub) | pat_uniq(sub) | pat_bind(_, some(sub)) {\n+    alt normalize_pat(tcx, pat).node {\n+      pat_box(sub) | pat_uniq(sub) | pat_ident(_, some(sub)) {\n         is_refutable(tcx, sub)\n       }\n-      pat_wild. | pat_bind(_, none.) { false }\n+      pat_wild. | pat_ident(_, none.) { false }\n       pat_lit(_) { true }\n       pat_rec(fields, _) {\n         for field: field_pat in fields {"}, {"sha": "938fcac52d358ec761c7d5658711522fef16dc60", "filename": "src/comp/middle/debuginfo.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c3bc8fada838c15e09e76a9d5d85438667c1636c/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3bc8fada838c15e09e76a9d5d85438667c1636c/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs?ref=c3bc8fada838c15e09e76a9d5d85438667c1636c", "patch": "@@ -8,6 +8,7 @@ import middle::trans_build::B;\n import middle::ty;\n import syntax::{ast, codemap};\n import ast::ty;\n+import pat_util::*;\n import util::ppaux::ty_to_str;\n \n export create_local_var;\n@@ -629,9 +630,10 @@ fn create_local_var(bcx: @block_ctxt, local: @ast::local)\n       option::none. {}\n     }\n \n-    let name = alt local.node.pat.node {\n-      ast::pat_bind(ident, _) { ident /*XXX deal w/ optional node binding*/ }\n-    };\n+    let name = path_to_ident(alt pat_util::normalize_pat(bcx_tcx(bcx),\n+                                           local.node.pat).node {\n+      ast::pat_ident(ident, _) { ident /*XXX deal w/ optional node binding*/ }\n+     });\n     let loc = codemap::lookup_char_pos(cx.sess.codemap,\n                                        local.span.lo);\n     let ty = trans::node_id_type(cx, local.node.id);"}, {"sha": "f2d1b6ea6cab4d06f43c760520d5798001e7e92f", "filename": "src/comp/middle/pat_util.rs", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/c3bc8fada838c15e09e76a9d5d85438667c1636c/src%2Fcomp%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3bc8fada838c15e09e76a9d5d85438667c1636c/src%2Fcomp%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fpat_util.rs?ref=c3bc8fada838c15e09e76a9d5d85438667c1636c", "patch": "@@ -0,0 +1,119 @@\n+import syntax::ast::*;\n+import syntax::ast_util;\n+import syntax::ast_util::respan;\n+import syntax::fold;\n+import syntax::fold::*;\n+\n+export normalize_arms;\n+export normalize_pat;\n+export normalize_pat_def_map;\n+export pat_binding_ids;\n+export pat_bindings;\n+export pat_id_map;\n+export path_to_ident;\n+\n+fn normalize_pat_def_map(dm: resolve::def_map, p: @pat) -> @pat {\n+  // have to do it the hard way b/c ast fold doesn't pass around\n+  // node IDs. bother.\n+  alt p.node {\n+      pat_wild. { p }\n+      pat_ident(_, none.) { normalize_one(dm, p) }\n+      pat_ident(q, some(r)) {\n+        @{node: pat_ident(q, some(normalize_pat_def_map(dm, r)))\n+            with *p}\n+      }\n+      pat_tag(a_path, subs) {\n+        @{node: pat_tag(a_path,\n+           vec::map(subs, {|p| normalize_pat_def_map(dm, p)})) with *p}\n+      }\n+      pat_rec(field_pats, b) {\n+        @{node: pat_rec(vec::map(field_pats,\n+           {|fp| {pat: normalize_pat_def_map(dm, fp.pat) with fp}}), b)\n+            with *p}\n+      }\n+      pat_tup(subs) {\n+        @{node: pat_tup(vec::map(subs, {|p| normalize_pat_def_map(dm, p)}))\n+            with *p}\n+      }\n+      pat_box(q) {\n+        @{node: pat_box(normalize_pat_def_map(dm, q))\n+            with *p}\n+      }\n+      pat_uniq(q) {\n+        @{node: pat_uniq(normalize_pat_def_map(dm, q))\n+            with *p}\n+      }\n+      pat_lit(_) { p }\n+      pat_range(_,_) { p }\n+    }\n+}\n+\n+fn normalize_one(dm: resolve::def_map, p: @pat) -> @pat {\n+    alt dm.find(p.id) {\n+        some(d) {\n+          alt p.node {\n+              pat_ident(tag_path, _) { @{id: p.id,\n+                    node: pat_tag(tag_path, []),\n+                    span: p.span} }\n+              _ { p }\n+          }\n+        }\n+        none. { p }\n+    }\n+}\n+\n+fn normalize_pat(tcx: ty::ctxt, p: @pat) -> @pat {\n+  normalize_pat_def_map(tcx.def_map, p)\n+}\n+\n+fn normalize_arms(tcx: ty::ctxt, arms:[arm]) -> [arm] {\n+      vec::map(arms, {|a|\n+            {pats:\n+              vec::map(a.pats, {|p|\n+                    pat_util::normalize_pat(tcx, p)})\n+                with a}})\n+}\n+\n+type pat_id_map = std::map::hashmap<str, node_id>;\n+\n+// This is used because same-named variables in alternative patterns need to\n+// use the node_id of their namesake in the first pattern.\n+fn pat_id_map(tcx: ty::ctxt, pat: @pat) -> pat_id_map {\n+    let map = std::map::new_str_hash::<node_id>();\n+    pat_bindings(normalize_pat(tcx, pat)) {|bound|\n+        let name = path_to_ident(alt bound.node\n+           { pat_ident(n, _) { n } });\n+        map.insert(name, bound.id);\n+    };\n+    ret map;\n+}\n+\n+// This does *not* normalize. The pattern should be already normalized\n+// if you want to get a normalized pattern out of it.\n+// Could return a constrained type in order to express that (future work)\n+fn pat_bindings(pat: @pat, it: block(@pat)) {\n+  alt pat.node {\n+      pat_ident(_, option::none.) { it(pat); }\n+      pat_ident(_, option::some(sub)) { it(pat); pat_bindings(sub, it); }\n+      pat_tag(_, sub) { for p in sub { pat_bindings(p, it); } }\n+      pat_rec(fields, _) { for f in fields { pat_bindings(f.pat, it); } }\n+      pat_tup(elts) { for elt in elts { pat_bindings(elt, it); } }\n+      pat_box(sub) { pat_bindings(sub, it); }\n+      pat_uniq(sub) { pat_bindings(sub, it); }\n+      pat_wild. | pat_lit(_) | pat_range(_, _) { }\n+    }\n+}\n+\n+fn pat_binding_ids(pat: @pat) -> [node_id] {\n+    let found = [];\n+    pat_bindings(pat) {|b| found += [b.id]; };\n+    ret found;\n+}\n+\n+fn path_to_ident(p: @path) -> ident {\n+    alt vec::last(p.node.idents) {\n+        none. { // sigh\n+          fail \"Malformed path\"; }\n+      some(i) { ret i; }\n+    }\n+}"}, {"sha": "6ccc8cc12bea948034d4b8d6e20dba0c422b45a6", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 44, "deletions": 20, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/c3bc8fada838c15e09e76a9d5d85438667c1636c/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3bc8fada838c15e09e76a9d5d85438667c1636c/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=c3bc8fada838c15e09e76a9d5d85438667c1636c", "patch": "@@ -3,6 +3,7 @@ import syntax::{ast, ast_util, codemap};\n import syntax::ast::*;\n import ast::{ident, fn_ident, def, def_id, node_id};\n import syntax::ast_util::{local_def, def_id_of_def};\n+import pat_util::*;\n \n import front::attr;\n import metadata::{csearch, cstore};\n@@ -181,10 +182,12 @@ fn resolve_crate(sess: session, amap: ast_map::map, crate: @ast::crate) ->\n           sess: sess};\n     map_crate(e, crate);\n     resolve_imports(*e);\n-    check_for_collisions(e, *crate);\n     check_exports(e);\n     resolve_names(e, crate);\n     resolve_impls(e, crate);\n+    // check_for_collisions must happen after resolve_names so we\n+    // don't complain if a pattern uses the same nullary tag twice\n+    check_for_collisions(e, *crate);\n     if sess.opts.warn_unused_imports {\n         check_unused_imports(e);\n     }\n@@ -417,6 +420,20 @@ fn resolve_names(e: @env, c: @ast::crate) {\n               }\n             }\n           }\n+          /* Here we determine whether a given pat_ident binds a new\n+           variable a refers to a nullary tag. */\n+          ast::pat_ident(p, none.) {\n+              let fnd = lookup_in_scope(*e, sc, p.span, path_to_ident(p),\n+                                    ns_val(ns_a_tag));\n+              alt fnd {\n+                some(ast::def_variant(did, vid)) {\n+                    e.def_map.insert(pat.id, ast::def_variant(did, vid));\n+                }\n+                _ {\n+                    // Binds a var -- nothing needs to be done\n+                }\n+              }\n+          }\n           _ { }\n         }\n     }\n@@ -539,30 +556,32 @@ fn visit_expr_with_scope(x: @ast::expr, sc: scopes, v: vt<scopes>) {\n     }\n }\n \n+// This is only for irrefutable patterns (e.g. ones that appear in a let)\n+// So if x occurs, and x is already known to be a tag, that's always an error.\n fn visit_local_with_scope(e: @env, loc: @local, sc:scopes, v:vt<scopes>) {\n-    // Checks whether the given local has the same name as a tag that's\n+    // Check whether the given local has the same name as a tag that's\n     // in scope\n     // We disallow this, in order to make alt patterns consisting of\n     // a single identifier unambiguous (does the pattern \"foo\" refer\n     // to tag foo, or is it binding a new name foo?)\n     alt loc.node.pat.node {\n-      pat_bind(an_ident,_) {\n+      pat_ident(an_ident,_) {\n           // Be sure to pass ns_a_tag to lookup_in_scope so that\n           // if this is a name that's being shadowed, we don't die\n-          alt lookup_in_scope(*e, sc, loc.span, an_ident, ns_val(ns_a_tag)) {\n+          alt lookup_in_scope(*e, sc, loc.span,\n+                 path_to_ident(an_ident), ns_val(ns_a_tag)) {\n               some(ast::def_variant(tag_id,variant_id)) {\n                   // Declaration shadows a tag that's in scope.\n                   // That's an error.\n                   e.sess.span_err(loc.span,\n                     #fmt(\"Declaration of %s shadows a tag that's in scope\",\n-                         an_ident));\n+                         path_to_ident(an_ident)));\n                   }\n               _ {}\n           }\n       }\n       _ {}\n     }\n-\n     visit::visit_local(loc, sc, v);\n }\n \n@@ -907,7 +926,7 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n           }\n           scope_loop(local) {\n             if ns == ns_val(ns_any_value) {\n-                alt lookup_in_pat(name, local.node.pat) {\n+                alt lookup_in_pat(e, name, local.node.pat) {\n                   some(did) { ret some(ast::def_binding(did)); }\n                   _ { }\n                 }\n@@ -918,7 +937,7 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n           }\n           scope_arm(a) {\n             if ns == ns_val(ns_any_value) {\n-                alt lookup_in_pat(name, a.pats[0]) {\n+                alt lookup_in_pat(e, name, a.pats[0]) {\n                   some(did) { ret some(ast::def_binding(did)); }\n                   _ { ret none; }\n                 }\n@@ -997,11 +1016,13 @@ fn lookup_in_ty_params(e: env, name: ident, ty_params: [ast::ty_param])\n     ret none::<def>;\n }\n \n-fn lookup_in_pat(name: ident, pat: @ast::pat) -> option::t<def_id> {\n+fn lookup_in_pat(e: env, name: ident, pat: @ast::pat) -> option::t<def_id> {\n     let found = none;\n-    ast_util::pat_bindings(pat) {|bound|\n-        let p_name = alt bound.node { ast::pat_bind(n, _) { n } };\n-        if str::eq(p_name, name) { found = some(local_def(bound.id)); }\n+\n+    pat_util::pat_bindings(normalize_pat_def_map(e.def_map, pat)) {|bound|\n+        let p_name = alt bound.node { ast::pat_ident(n, _) { n } };\n+        if str::eq(path_to_ident(p_name), name)\n+                    { found = some(local_def(bound.id)); }\n     };\n     ret found;\n }\n@@ -1041,7 +1062,7 @@ fn lookup_in_block(e: env, name: ident, sp: span, b: ast::blk_, pos: uint,\n                         let (style, loc) = locs[j];\n                         if ns == ns_val(ns_any_value)\n                                      && (i < pos || j < loc_pos) {\n-                            alt lookup_in_pat(name, loc.node.pat) {\n+                            alt lookup_in_pat(e, name, loc.node.pat) {\n                               some(did) {\n                                 ret some(ast::def_local(did, style));\n                               }\n@@ -1571,23 +1592,23 @@ fn check_item(e: @env, i: @ast::item, &&x: (), v: vt<()>) {\n     }\n }\n \n-fn check_pat(ch: checker, p: @ast::pat) {\n-    ast_util::pat_bindings(p) {|p|\n-        let ident = alt p.node { pat_bind(n, _) { n } };\n+fn check_pat(e: @env, ch: checker, p: @ast::pat) {\n+    pat_util::pat_bindings(normalize_pat_def_map(e.def_map, p)) {|p|\n+        let ident = path_to_ident(alt p.node { pat_ident(n, _) { n } });\n         add_name(ch, p.span, ident);\n     };\n }\n \n fn check_arm(e: @env, a: ast::arm, &&x: (), v: vt<()>) {\n     visit::visit_arm(a, x, v);\n     let ch0 = checker(*e, \"binding\");\n-    check_pat(ch0, a.pats[0]);\n+    check_pat(e, ch0, a.pats[0]);\n     let seen0 = ch0.seen;\n     let i = vec::len(a.pats);\n     while i > 1u {\n         i -= 1u;\n         let ch = checker(*e, \"binding\");\n-        check_pat(ch, a.pats[i]);\n+        check_pat(e, ch, a.pats[i]);\n \n         // Ensure the bindings introduced in this pattern are the same as in\n         // the first pattern.\n@@ -1620,8 +1641,11 @@ fn check_block(e: @env, b: ast::blk, &&x: (), v: vt<()>) {\n               ast::decl_local(locs) {\n                 let local_values = checker(*e, \"value\");\n                 for (_, loc) in locs {\n-                    ast_util::pat_bindings(loc.node.pat) {|p|\n-                        let ident = alt p.node { pat_bind(n, _) { n } };\n+                        pat_util::pat_bindings\n+                            (normalize_pat_def_map(e.def_map, loc.node.pat))\n+                            {|p|\n+                            let ident = path_to_ident(alt p.node\n+                                 { pat_ident(n, _) { n } });\n                         add_name(local_values, p.span, ident);\n                         check_name(values, p.span, ident);\n                     };"}, {"sha": "314385a9f25aa124b7bf4a1450a754cba4955d6b", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c3bc8fada838c15e09e76a9d5d85438667c1636c/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3bc8fada838c15e09e76a9d5d85438667c1636c/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=c3bc8fada838c15e09e76a9d5d85438667c1636c", "patch": "@@ -26,7 +26,8 @@ import back::{link, abi, upcall};\n import syntax::{ast, ast_util, codemap};\n import syntax::visit;\n import syntax::codemap::span;\n-import syntax::print::pprust::{expr_to_str, stmt_to_str};\n+import syntax::print::pprust::{expr_to_str, stmt_to_str, path_to_str};\n+import pat_util::*;\n import visit::vt;\n import util::common::*;\n import lib::llvm::{llvm, mk_target_data, mk_type_names};\n@@ -775,6 +776,8 @@ fn GEP_tag(cx: @block_ctxt, llblobptr: ValueRef, tag_id: ast::def_id,\n \n     let true_arg_tys: [ty::t] = [];\n     for aty: ty::t in arg_tys {\n+            // Would be nice to have a way of stating the invariant\n+            // that ty_substs is valid for aty\n         let arg_ty = ty::substitute_type_params(bcx_tcx(cx), ty_substs, aty);\n         true_arg_tys += [arg_ty];\n     }\n@@ -2203,7 +2206,7 @@ fn trans_eager_binop(cx: @block_ctxt, op: ast::binop, lhs: ValueRef,\n         if is_float { FAdd(cx, lhs, rhs) }\n         else { Add(cx, lhs, rhs) }\n       }\n-      ast::sub. {\n+      ast::subtract. {\n         if is_float { FSub(cx, lhs, rhs) }\n         else { Sub(cx, lhs, rhs) }\n       }\n@@ -2641,6 +2644,7 @@ fn trans_local_var(cx: @block_ctxt, def: ast::def) -> local_var_result {\n         alt table.find(id) {\n           some(local_mem(v)) { {val: v, kind: owned} }\n           some(local_imm(v)) { {val: v, kind: owned_imm} }\n+          r { fail(\"take_local: internal error\"); }\n         }\n     }\n     alt def {\n@@ -2649,9 +2653,11 @@ fn trans_local_var(cx: @block_ctxt, def: ast::def) -> local_var_result {\n         ret { val: cx.fcx.llupvars.get(did.node), kind: owned };\n       }\n       ast::def_arg(did, _) {\n+        assert (cx.fcx.llargs.contains_key(did.node));\n         ret take_local(cx.fcx.llargs, did.node);\n       }\n       ast::def_local(did, _) | ast::def_binding(did) {\n+        assert (cx.fcx.lllocals.contains_key(did.node));\n         ret take_local(cx.fcx.lllocals, did.node);\n       }\n       ast::def_self(did) {\n@@ -3502,6 +3508,7 @@ fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n         ret trans_expr(bcx, ast_util::ternary_to_if(e), dest);\n       }\n       ast::expr_alt(expr, arms) {\n+          //          tcx.sess.span_note(e.span, \"about to call trans_alt\");\n         ret trans_alt::trans_alt(bcx, expr, arms, dest);\n       }\n       ast::expr_block(blk) {\n@@ -4205,8 +4212,9 @@ fn alloc_ty(cx: @block_ctxt, t: ty::t) -> result {\n \n fn alloc_local(cx: @block_ctxt, local: @ast::local) -> @block_ctxt {\n     let t = node_id_type(bcx_ccx(cx), local.node.id);\n-    let is_simple = alt local.node.pat.node {\n-      ast::pat_bind(_, none.) { true } _ { false }\n+    let p = normalize_pat(bcx_tcx(cx), local.node.pat);\n+    let is_simple = alt p.node {\n+      ast::pat_ident(_, none.) { true } _ { false }\n     };\n     // Do not allocate space for locals that can be kept immediate.\n     let ccx = bcx_ccx(cx);\n@@ -4219,10 +4227,10 @@ fn alloc_local(cx: @block_ctxt, local: @ast::local) -> @block_ctxt {\n         }\n     }\n     let r = alloc_ty(cx, t);\n-    alt local.node.pat.node {\n-      ast::pat_bind(ident, none.) {\n+    alt p.node {\n+      ast::pat_ident(pth, none.) {\n         if bcx_ccx(cx).sess.opts.debuginfo {\n-            let _: () = str::as_buf(ident, {|buf|\n+            let _: () = str::as_buf(path_to_ident(pth), {|buf|\n                 llvm::LLVMSetValueName(r.val, buf)\n             });\n         }\n@@ -4635,7 +4643,7 @@ fn trans_const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n             if is_float { llvm::LLVMConstFAdd(te1, te2) }\n             else        { llvm::LLVMConstAdd(te1, te2) }\n           }\n-          ast::sub.    {\n+          ast::subtract. {\n             if is_float { llvm::LLVMConstFSub(te1, te2) }\n             else        { llvm::LLVMConstSub(te1, te2) }\n           }"}, {"sha": "5addbebddc1ab6edb64fd54750d98b654d263722", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 39, "deletions": 19, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/c3bc8fada838c15e09e76a9d5d85438667c1636c/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3bc8fada838c15e09e76a9d5d85438667c1636c/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=c3bc8fada838c15e09e76a9d5d85438667c1636c", "patch": "@@ -1,15 +1,18 @@\n import core::{str, vec, option};\n import option::{some, none};\n \n+import driver::session::session;\n import lib::llvm::llvm;\n import lib::llvm::llvm::{ValueRef, BasicBlockRef};\n+import pat_util::*;\n import trans_build::*;\n import trans::{new_sub_block_ctxt, new_scope_block_ctxt, load_if_immediate};\n import syntax::ast;\n import syntax::ast_util;\n import syntax::ast_util::{dummy_sp};\n import syntax::ast::def_id;\n import syntax::codemap::span;\n+import syntax::print::pprust::pat_to_str;\n \n import trans_common::*;\n \n@@ -61,6 +64,7 @@ fn trans_opt(bcx: @block_ctxt, o: opt) -> opt_result {\n     }\n }\n \n+// FIXME: invariant -- pat_id is bound in the def_map?\n fn variant_opt(ccx: @crate_ctxt, pat_id: ast::node_id) -> opt {\n     let vdef = ast_util::variant_def_ids(ccx.tcx.def_map.get(pat_id));\n     let variants = ty::tag_variants(ccx.tcx, vdef.tg);\n@@ -83,13 +87,13 @@ type match_branch =\n       bound: bind_map,\n       data: @{body: BasicBlockRef,\n               guard: option::t<@ast::expr>,\n-              id_map: ast_util::pat_id_map}};\n+              id_map: pat_id_map}};\n type match = [match_branch];\n \n fn has_nested_bindings(m: match, col: uint) -> bool {\n     for br in m {\n         alt br.pats[col].node {\n-          ast::pat_bind(_, some(_)) { ret true; }\n+          ast::pat_ident(_, some(_)) { ret true; }\n           _ {}\n         }\n     }\n@@ -99,12 +103,13 @@ fn has_nested_bindings(m: match, col: uint) -> bool {\n fn expand_nested_bindings(m: match, col: uint, val: ValueRef) -> match {\n     let result = [];\n     for br in m {\n-        alt br.pats[col].node {\n-          ast::pat_bind(name, some(inner)) {\n+      alt br.pats[col].node {\n+          ast::pat_ident(name, some(inner)) {\n             let pats = vec::slice(br.pats, 0u, col) + [inner] +\n                 vec::slice(br.pats, col + 1u, vec::len(br.pats));\n             result += [@{pats: pats,\n-                         bound: br.bound + [{ident: name, val: val}]\n+                        bound: br.bound + [{ident: path_to_ident(name),\n+                                val: val}]\n                          with *br}];\n           }\n           _ { result += [br]; }\n@@ -124,8 +129,9 @@ fn enter_match(m: match, col: uint, val: ValueRef, e: enter_pat) -> match {\n                 vec::slice(br.pats, col + 1u, vec::len(br.pats));\n             let new_br = @{pats: pats,\n                            bound: alt br.pats[col].node {\n-                             ast::pat_bind(name, none.) {\n-                               br.bound + [{ident: name, val: val}]\n+                             ast::pat_ident(name, none.) {\n+                                 br.bound + [{ident: path_to_ident(name),\n+                                              val: val}]\n                              }\n                              _ { br.bound }\n                            } with *br};\n@@ -139,11 +145,11 @@ fn enter_match(m: match, col: uint, val: ValueRef, e: enter_pat) -> match {\n \n fn enter_default(m: match, col: uint, val: ValueRef) -> match {\n     fn matches_always(p: @ast::pat) -> bool {\n-        ret alt p.node {\n-          ast::pat_wild. | ast::pat_bind(_, none.) | ast::pat_rec(_, _) |\n-          ast::pat_tup(_) { true }\n-          _ { false }\n-        };\n+        alt p.node {\n+                ast::pat_wild. | ast::pat_rec(_, _) |\n+                ast::pat_ident(_, none.) | ast::pat_tup(_) { true }\n+                _ { false }\n+        }\n     }\n     fn e(p: @ast::pat) -> option::t<[@ast::pat]> {\n         ret if matches_always(p) { some([]) } else { none };\n@@ -257,6 +263,8 @@ fn extract_variant_args(bcx: @block_ctxt, pat_id: ast::node_id,\n                         vdefs: {tg: def_id, var: def_id}, val: ValueRef) ->\n    {vals: [ValueRef], bcx: @block_ctxt} {\n     let ccx = bcx.fcx.lcx.ccx, bcx = bcx;\n+    // invariant:\n+    // pat_id must have the same length ty_param_substs as vdefs?\n     let ty_param_substs = ty::node_id_to_type_params(ccx.tcx, pat_id);\n     let blobptr = val;\n     let variants = ty::tag_variants(ccx.tcx, vdefs.tg);\n@@ -274,6 +282,9 @@ fn extract_variant_args(bcx: @block_ctxt, pat_id: ast::node_id,\n     while i < size {\n         check (valid_variant_index(i, bcx, vdefs_tg, vdefs_var));\n         let r =\n+            // invariant needed:\n+            // how do we know it even makes sense to pass in ty_param_substs\n+            // here? What if it's [] and the tag type has variables in it?\n             trans::GEP_tag(bcx, blobptr, vdefs_tg, vdefs_var, ty_param_substs,\n                            i);\n         bcx = r.bcx;\n@@ -328,7 +339,7 @@ fn pick_col(m: match) -> uint {\n     fn score(p: @ast::pat) -> uint {\n         alt p.node {\n           ast::pat_lit(_) | ast::pat_tag(_, _) | ast::pat_range(_, _) { 1u }\n-          ast::pat_bind(_, some(p)) { score(p) }\n+          ast::pat_ident(_, some(p)) { score(p) }\n           _ { 0u }\n         }\n     }\n@@ -582,7 +593,7 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n \n // Returns false for unreachable blocks\n fn make_phi_bindings(bcx: @block_ctxt, map: [exit_node],\n-                     ids: ast_util::pat_id_map) -> bool {\n+                     ids: pat_util::pat_id_map) -> bool {\n     let our_block = bcx.llbb as uint;\n     let success = true, bcx = bcx;\n     ids.items {|name, node_id|\n@@ -623,7 +634,7 @@ fn make_phi_bindings(bcx: @block_ctxt, map: [exit_node],\n     ret success;\n }\n \n-fn trans_alt(cx: @block_ctxt, expr: @ast::expr, arms: [ast::arm],\n+fn trans_alt(cx: @block_ctxt, expr: @ast::expr, arms_: [ast::arm],\n              dest: trans::dest) -> @block_ctxt {\n     let bodies = [];\n     let match: match = [];\n@@ -633,9 +644,15 @@ fn trans_alt(cx: @block_ctxt, expr: @ast::expr, arms: [ast::arm],\n     let er = trans::trans_temp_expr(alt_cx, expr);\n     if er.bcx.unreachable { ret er.bcx; }\n \n+    /*\n+      n.b. nothing else in this module should need to normalize,\n+      b/c of this call\n+     */\n+    let arms = normalize_arms(bcx_tcx(cx), arms_);\n+\n     for a: ast::arm in arms {\n         let body = new_scope_block_ctxt(er.bcx, \"case_body\");\n-        let id_map = ast_util::pat_id_map(a.pats[0]);\n+        let id_map = pat_util::pat_id_map(bcx_tcx(cx), a.pats[0]);\n         bodies += [body];\n         for p: @ast::pat in a.pats {\n             match +=\n@@ -666,7 +683,8 @@ fn trans_alt(cx: @block_ctxt, expr: @ast::expr, arms: [ast::arm],\n     for a: ast::arm in arms {\n         let body_cx = bodies[i];\n         if make_phi_bindings(body_cx, exit_map,\n-                             ast_util::pat_id_map(a.pats[0])) {\n+                             pat_util::pat_id_map(bcx_tcx(cx),\n+                                                  a.pats[0])) {\n             let arm_dest = trans::dup_for_join(dest);\n             arm_dests += [arm_dest];\n             arm_cxs += [trans::trans_block_dps(body_cx, a.body, arm_dest)];\n@@ -684,8 +702,10 @@ fn trans_alt(cx: @block_ctxt, expr: @ast::expr, arms: [ast::arm],\n fn bind_irrefutable_pat(bcx: @block_ctxt, pat: @ast::pat, val: ValueRef,\n                         make_copy: bool) -> @block_ctxt {\n     let ccx = bcx.fcx.lcx.ccx, bcx = bcx;\n-    alt pat.node {\n-      ast::pat_bind(_, inner) {\n+\n+    // Necessary since bind_irrefutable_pat is called outside trans_alt\n+    alt normalize_pat(bcx_tcx(bcx), pat).node {\n+      ast::pat_ident(_,inner) {\n         if make_copy || ccx.copy_map.contains_key(pat.id) {\n             let ty = ty::node_id_to_monotype(ccx.tcx, pat.id);\n             // FIXME: Could constrain pat_bind to make this"}, {"sha": "f44ac06e4c16a8bd6cd6dcfc2320dcaae1c2618b", "filename": "src/comp/middle/tstate/annotate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c3bc8fada838c15e09e76a9d5d85438667c1636c/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3bc8fada838c15e09e76a9d5d85438667c1636c/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs?ref=c3bc8fada838c15e09e76a9d5d85438667c1636c", "patch": "@@ -1,12 +1,12 @@\n \n import core::{int, uint};\n import syntax::ast::*;\n-import syntax::ast_util::pat_binding_ids;\n import syntax::visit;\n import syntax::codemap::span;\n import util::common::{log_stmt};\n import aux::{num_constraints, get_fn_info, crate_ctxt, add_node};\n-import middle::tstate::ann::empty_ann;\n+import ann::empty_ann;\n+import pat_util::pat_binding_ids;\n \n fn collect_ids_expr(e: @expr, rs: @mutable [node_id]) { *rs += [e.id]; }\n "}, {"sha": "cb592be250c2ad21ea1622281a7f9de79fc11c32", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c3bc8fada838c15e09e76a9d5d85438667c1636c/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3bc8fada838c15e09e76a9d5d85438667c1636c/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=c3bc8fada838c15e09e76a9d5d85438667c1636c", "patch": "@@ -1,5 +1,6 @@\n import core::{vec, int, uint, option};\n import option::*;\n+import pat_util::*;\n import syntax::ast::*;\n import syntax::ast_util::*;\n import syntax::{visit, codemap};\n@@ -69,10 +70,10 @@ fn tritv_to_str(fcx: fn_ctxt, v: tritv::t) -> str {\n     for p: norm_constraint in constraints(fcx) {\n         alt tritv_get(v, p.bit_num) {\n           dont_care. { }\n-          t {\n+          tt {\n             s +=\n                 if comma { \", \" } else { comma = true; \"\" } +\n-                    if t == tfalse { \"!\" } else { \"\" } +\n+                    if tt == tfalse { \"!\" } else { \"\" } +\n                     constraint_to_str(fcx.ccx.tcx, p.c);\n           }\n         }\n@@ -313,7 +314,7 @@ fn node_id_to_ts_ann(ccx: crate_ctxt, id: node_id) -> ts_ann {\n         #error(\"node_id_to_ts_ann: no ts_ann for node_id %d\", id);\n         fail;\n       }\n-      some(t) { ret t; }\n+      some(tt) { ret tt; }\n     }\n }\n \n@@ -779,13 +780,6 @@ fn replace(subst: subst, d: pred_args) -> [constr_arg_general_<inst>] {\n     ret rslt;\n }\n \n-fn path_to_ident(cx: ty::ctxt, p: @path) -> ident {\n-    alt vec::last(p.node.idents) {\n-      none. { cx.sess.span_fatal(p.span, \"Malformed path\"); }\n-      some(i) { ret i; }\n-    }\n-}\n-\n tag if_ty { if_check; plain_if; }\n \n fn local_node_id_to_def_id_strict(fcx: fn_ctxt, sp: span, i: node_id) ->\n@@ -1059,18 +1053,20 @@ fn ast_constr_to_sp_constr(tcx: ty::ctxt, args: [arg], c: @constr) ->\n \n type binding = {lhs: [inst], rhs: option::t<initializer>};\n \n-fn local_to_bindings(loc: @local) -> binding {\n+fn local_to_bindings(tcx: ty::ctxt, loc: @local) -> binding {\n     let lhs = [];\n-    pat_bindings(loc.node.pat) {|p|\n-        let ident = alt p.node { pat_bind(name, _) { name } };\n+    pat_bindings(pat_util::normalize_pat(tcx, loc.node.pat)) {|p|\n+            let ident = alt p.node\n+               { pat_ident(name, _) { path_to_ident(name) } };\n         lhs += [{ident: ident, node: p.id}];\n     };\n     {lhs: lhs, rhs: loc.node.init}\n }\n \n-fn locals_to_bindings(locals: [(let_style, @local)]) -> [binding] {\n+fn locals_to_bindings(tcx: ty::ctxt,\n+                      locals: [(let_style, @local)]) -> [binding] {\n     let rslt = [];\n-    for (_, loc) in locals { rslt += [local_to_bindings(loc)]; }\n+    for (_, loc) in locals { rslt += [local_to_bindings(tcx, loc)]; }\n     ret rslt;\n }\n "}, {"sha": "102451a6985fb899aeceee17a3555058c25884fd", "filename": "src/comp/middle/tstate/collect_locals.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c3bc8fada838c15e09e76a9d5d85438667c1636c/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3bc8fada838c15e09e76a9d5d85438667c1636c/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=c3bc8fada838c15e09e76a9d5d85438667c1636c", "patch": "@@ -1,18 +1,20 @@\n+import option::*;\n+import pat_util::*;\n import syntax::ast::*;\n import syntax::ast_util::*;\n-import option::*;\n import syntax::visit;\n-import aux::*;\n import util::common::new_def_hash;\n import syntax::codemap::span;\n import syntax::ast_util::respan;\n import driver::session::session;\n+import aux::*;\n \n type ctxt = {cs: @mutable [sp_constr], tcx: ty::ctxt};\n \n fn collect_local(loc: @local, cx: ctxt, v: visit::vt<ctxt>) {\n-    pat_bindings(loc.node.pat) {|p|\n-        let ident = alt p.node { pat_bind(id, _) { id } };\n+    pat_bindings(pat_util::normalize_pat(cx.tcx, loc.node.pat)) {|p|\n+            let ident = alt p.node\n+                 { pat_ident(id, _) { path_to_ident(id) } };\n         log(debug, \"collect_local: pushing \" + ident);;\n         *cx.cs += [respan(loc.span, ninit(p.id, ident))];\n     };"}, {"sha": "57bb0379779294e8d54ed5a5035183467e5d4d25", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 23, "deletions": 15, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c3bc8fada838c15e09e76a9d5d85438667c1636c/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3bc8fada838c15e09e76a9d5d85438667c1636c/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=c3bc8fada838c15e09e76a9d5d85438667c1636c", "patch": "@@ -8,6 +8,8 @@ import bitvectors::{bit_num, seq_preconds, seq_postconds,\n                     intersect_states,\n                     relax_precond_block, gen};\n import tritv::*;\n+\n+import pat_util::*;\n import syntax::ast::*;\n import syntax::ast_util::*;\n import syntax::visit;\n@@ -16,6 +18,7 @@ import util::common::{new_def_hash, log_expr, field_exprs,\n import syntax::codemap::span;\n import driver::session::session;\n \n+\n fn find_pre_post_mod(_m: _mod) -> _mod {\n     #debug(\"implement find_pre_post_mod!\");\n     fail;\n@@ -103,8 +106,9 @@ fn find_pre_post_loop(fcx: fn_ctxt, l: @local, index: @expr, body: blk,\n                       id: node_id) {\n     find_pre_post_expr(fcx, index);\n     find_pre_post_block(fcx, body);\n-    pat_bindings(l.node.pat) {|p|\n-        let ident = alt p.node { pat_bind(id, _) { id } };\n+    pat_bindings(normalize_pat(fcx.ccx.tcx, l.node.pat)) {|p|\n+        let ident = alt p.node\n+             { pat_ident(id, _) { path_to_ident(id) } };\n         let v_init = ninit(p.id, ident);\n         relax_precond_block(fcx, bit_num(fcx, v_init) as node_id, body);\n         // Hack: for-loop index variables are frequently ignored,\n@@ -197,7 +201,7 @@ fn gen_if_local(fcx: fn_ctxt, lhs: @expr, rhs: @expr, larger_id: node_id,\n             set_pre_and_post(fcx.ccx, larger_id, p.precondition,\n                              p.postcondition);\n             gen(fcx, larger_id,\n-                ninit(d_id.node, path_to_ident(fcx.ccx.tcx, pth)));\n+                ninit(d_id.node, path_to_ident(pth)));\n           }\n           _ { find_pre_post_exprs(fcx, [lhs, rhs], larger_id); }\n         }\n@@ -232,7 +236,7 @@ fn handle_update(fcx: fn_ctxt, parent: @expr, lhs: @expr, rhs: @expr,\n               def_local(d_id, _) {\n                 let i =\n                     bit_num(fcx,\n-                            ninit(d_id.node, path_to_ident(fcx.ccx.tcx, p)));\n+                            ninit(d_id.node, path_to_ident(p)));\n                 require_and_preserve(i, expr_pp(fcx.ccx, lhs));\n               }\n               _ { }\n@@ -250,9 +254,9 @@ fn handle_update(fcx: fn_ctxt, parent: @expr, lhs: @expr, rhs: @expr,\n                 alt d1 {\n                   some(id1) {\n                     let instlhs =\n-                        {ident: path_to_ident(fcx.ccx.tcx, p), node: id};\n+                        {ident: path_to_ident(p), node: id};\n                     let instrhs =\n-                        {ident: path_to_ident(fcx.ccx.tcx, p1), node: id1};\n+                        {ident: path_to_ident(p1), node: id1};\n                     copy_in_poststate_two(fcx, tmp, post, instlhs, instrhs,\n                                           ty);\n                   }\n@@ -340,7 +344,7 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n       expr_path(p) {\n         let rslt = expr_pp(fcx.ccx, e);\n         clear_pp(rslt);\n-        handle_var(fcx, rslt, e.id, path_to_ident(fcx.ccx.tcx, p));\n+        handle_var(fcx, rslt, e.id, path_to_ident(p));\n       }\n       expr_log(_, lvl, arg) {\n         find_pre_post_exprs(fcx, [lvl, arg], e.id);\n@@ -581,18 +585,19 @@ fn find_pre_post_stmt(fcx: fn_ctxt, s: stmt) {\n                       _ { }\n                     }\n \n-                    pat_bindings(alocal.node.pat) {|pat|\n+                    pat_bindings(normalize_pat(fcx.ccx.tcx, alocal.node.pat))\n+                        {|pat|\n                         /* FIXME: This won't be necessary when typestate\n                         works well enough for pat_bindings to return a\n                         refinement-typed thing. */\n-                        let ident = alt pat.node { pat_bind(n, _) { n } };\n+                            let ident = alt pat.node\n+                                     { pat_ident(n, _) { path_to_ident(n) } };\n                         alt p {\n                           some(p) {\n                             copy_in_postcond(fcx, id,\n                                              {ident: ident, node: pat.id},\n                                              {ident:\n-                                                  path_to_ident(fcx.ccx.tcx,\n-                                                                p),\n+                                                  path_to_ident(p),\n                                               node: an_init.expr.id},\n                                              op_to_oper_ty(an_init.op));\n                           }\n@@ -612,11 +617,14 @@ fn find_pre_post_stmt(fcx: fn_ctxt, s: stmt) {\n                                seq_preconds(fcx, [prev_pp, e_pp]));\n                     /* Include the LHSs too, since those aren't in the\n                      postconds of the RHSs themselves */\n-                    pat_bindings(alocal.node.pat) {|pat|\n+                    pat_bindings(normalize_pat(fcx.ccx.tcx, alocal.node.pat))\n+                        {|pat|\n+                            // FIXME\n+                            // Generalize this pattern? map_if_ident...\n                         alt pat.node {\n-                          pat_bind(n, _) {\n-                            set_in_postcond(bit_num(fcx, ninit(pat.id, n)),\n-                                            prev_pp);\n+                          pat_ident(n, _) {\n+                            set_in_postcond(bit_num(fcx,\n+                               ninit(pat.id, path_to_ident(n))), prev_pp);\n                           }\n                         }\n                     };"}, {"sha": "50208b9dacf29d30b03e1911d46682a72d239481", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c3bc8fada838c15e09e76a9d5d85438667c1636c/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3bc8fada838c15e09e76a9d5d85438667c1636c/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=c3bc8fada838c15e09e76a9d5d85438667c1636c", "patch": "@@ -5,6 +5,7 @@ import aux::*;\n import tritv::{tritv_clone, tritv_set, ttrue};\n \n import bitvectors::*;\n+import pat_util::*;\n import syntax::ast::*;\n import syntax::ast_util::*;\n import syntax::codemap::span;\n@@ -37,7 +38,7 @@ fn handle_move_or_copy(fcx: fn_ctxt, post: poststate, rhs_path: @path,\n       some(rhsid) {\n         // RHS is a local var\n         let instrhs =\n-            {ident: path_to_ident(fcx.ccx.tcx, rhs_path), node: rhsid.node};\n+            {ident: path_to_ident(rhs_path), node: rhsid.node};\n         copy_in_poststate(fcx, post, instlhs, instrhs,\n                           op_to_oper_ty(init_op));\n       }\n@@ -143,9 +144,9 @@ fn find_pre_post_state_two(fcx: fn_ctxt, pres: prestate, lhs: @expr,\n                 alt d1 {\n                   some(id1) {\n                     let instlhs =\n-                        {ident: path_to_ident(fcx.ccx.tcx, p), node: id};\n+                        {ident: path_to_ident(p), node: id};\n                     let instrhs =\n-                        {ident: path_to_ident(fcx.ccx.tcx, p1), node: id1};\n+                        {ident: path_to_ident(p1), node: id1};\n                     copy_in_poststate_two(fcx, tmp, post, instlhs, instrhs,\n                                           ty);\n                   }\n@@ -206,8 +207,9 @@ fn find_pre_post_state_loop(fcx: fn_ctxt, pres: prestate, l: @local,\n     // Make sure the index vars are considered initialized\n     // in the body\n     let index_post = tritv_clone(expr_poststate(fcx.ccx, index));\n-    pat_bindings(l.node.pat) {|p|\n-        let ident = alt p.node { pat_bind(name, _) { name } };\n+    pat_bindings(pat_util::normalize_pat(fcx.ccx.tcx, l.node.pat)) {|p|\n+        let ident = alt p.node\n+           { pat_ident(name, _) { path_to_ident(name) } };\n         set_in_poststate_ident(fcx, p.id, ident, index_post);\n     };\n \n@@ -231,7 +233,7 @@ fn gen_if_local(fcx: fn_ctxt, p: poststate, e: @expr) -> bool {\n         alt fcx.ccx.tcx.def_map.find(e.id) {\n           some(def_local(loc, _)) {\n             ret set_in_poststate_ident(fcx, loc.node,\n-                                       path_to_ident(fcx.ccx.tcx, pth), p);\n+                                       path_to_ident(pth), p);\n           }\n           _ { ret false; }\n         }\n@@ -632,7 +634,8 @@ fn find_pre_post_state_stmt(fcx: fn_ctxt, pres: prestate, s: @stmt) -> bool {\n         alt adecl.node {\n           decl_local(alocals) {\n             set_prestate(stmt_ann, pres);\n-            let c_and_p = seq_states(fcx, pres, locals_to_bindings(alocals));\n+            let c_and_p = seq_states(fcx, pres,\n+                  locals_to_bindings(fcx.ccx.tcx, alocals));\n             /* important to do this in one step to ensure\n             termination (don't want to set changed to true\n             for intermediate changes) */"}, {"sha": "59fd826791a309ddac2ff427675f7b33d05b2bd4", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c3bc8fada838c15e09e76a9d5d85438667c1636c/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3bc8fada838c15e09e76a9d5d85438667c1636c/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=c3bc8fada838c15e09e76a9d5d85438667c1636c", "patch": "@@ -371,6 +371,8 @@ const idx_first_others: uint = 20u;\n \n type type_store = interner::interner<@raw_t>;\n \n+// substs is a list of actuals that correspond to ty's\n+// formal parameters\n type ty_param_substs_opt_and_ty = {substs: option::t<[ty::t]>, ty: ty::t};\n \n type node_type_table =\n@@ -2215,7 +2217,7 @@ mod unify {\n           ty::ty_box(expected_mt) {\n             alt struct(cx.tcx, actual) {\n               ty::ty_box(actual_mt) {\n-                let (mut, var) = alt unify_mut(\n+                let (mutt, var) = alt unify_mut(\n                     expected_mt.mut, actual_mt.mut, variance) {\n                   none. { ret ures_err(terr_box_mutability); }\n                   some(mv) { mv }\n@@ -2224,7 +2226,7 @@ mod unify {\n                     cx, expected_mt.ty, actual_mt.ty, var);\n                 alt result {\n                   ures_ok(result_sub) {\n-                    let mt = {ty: result_sub, mut: mut};\n+                    let mt = {ty: result_sub, mut: mutt};\n                     ret ures_ok(mk_box(cx.tcx, mt));\n                   }\n                   _ { ret result; }\n@@ -2236,7 +2238,7 @@ mod unify {\n           ty::ty_uniq(expected_mt) {\n             alt struct(cx.tcx, actual) {\n               ty::ty_uniq(actual_mt) {\n-                let (mut, var) = alt unify_mut(\n+                let (mutt, var) = alt unify_mut(\n                     expected_mt.mut, actual_mt.mut, variance) {\n                   none. { ret ures_err(terr_box_mutability); }\n                   some(mv) { mv }\n@@ -2245,7 +2247,7 @@ mod unify {\n                     cx, expected_mt.ty, actual_mt.ty, var);\n                 alt result {\n                   ures_ok(result_mt) {\n-                    let mt = {ty: result_mt, mut: mut};\n+                    let mt = {ty: result_mt, mut: mutt};\n                     ret ures_ok(mk_uniq(cx.tcx, mt));\n                   }\n                   _ { ret result; }\n@@ -2257,7 +2259,7 @@ mod unify {\n           ty::ty_vec(expected_mt) {\n             alt struct(cx.tcx, actual) {\n               ty::ty_vec(actual_mt) {\n-                let (mut, var) = alt unify_mut(\n+                let (mutt, var) = alt unify_mut(\n                     expected_mt.mut, actual_mt.mut, variance) {\n                   none. { ret ures_err(terr_vec_mutability); }\n                   some(mv) { mv }\n@@ -2266,7 +2268,7 @@ mod unify {\n                     cx, expected_mt.ty, actual_mt.ty, var);\n                 alt result {\n                   ures_ok(result_sub) {\n-                    let mt = {ty: result_sub, mut: mut};\n+                    let mt = {ty: result_sub, mut: mutt};\n                     ret ures_ok(mk_vec(cx.tcx, mt));\n                   }\n                   _ { ret result; }\n@@ -2278,7 +2280,7 @@ mod unify {\n           ty::ty_ptr(expected_mt) {\n             alt struct(cx.tcx, actual) {\n               ty::ty_ptr(actual_mt) {\n-                let (mut, var) = alt unify_mut(\n+                let (mutt, var) = alt unify_mut(\n                     expected_mt.mut, actual_mt.mut, variance) {\n                   none. { ret ures_err(terr_vec_mutability); }\n                   some(mv) { mv }\n@@ -2287,7 +2289,7 @@ mod unify {\n                     cx, expected_mt.ty, actual_mt.ty, var);\n                 alt result {\n                   ures_ok(result_sub) {\n-                    let mt = {ty: result_sub, mut: mut};\n+                    let mt = {ty: result_sub, mut: mutt};\n                     ret ures_ok(mk_ptr(cx.tcx, mt));\n                   }\n                   _ { ret result; }\n@@ -2342,7 +2344,7 @@ mod unify {\n                 while i < expected_len {\n                     let expected_field = expected_fields[i];\n                     let actual_field = actual_fields[i];\n-                    let (mut, var) = alt unify_mut(\n+                    let (mutt, var) = alt unify_mut(\n                         expected_field.mt.mut, actual_field.mt.mut, variance)\n                         {\n                       none. { ret ures_err(terr_record_mutability); }\n@@ -2359,7 +2361,7 @@ mod unify {\n                                    actual_field.mt.ty, var);\n                     alt result {\n                       ures_ok(rty) {\n-                        let mt = {ty: rty, mut: mut};\n+                        let mt = {ty: rty, mut: mutt};\n                         result_fields += [{mt: mt with expected_field}];\n                       }\n                       _ { ret result; }\n@@ -2579,11 +2581,18 @@ fn type_err_to_str(err: ty::type_err) -> str {\n // Replaces type parameters in the given type using the given list of\n // substitions.\n fn substitute_type_params(cx: ctxt, substs: [ty::t], typ: t) -> t {\n-    if !type_contains_params(cx, typ) { ret typ; }\n+\n+   if !type_contains_params(cx, typ) { ret typ; }\n+    // Precondition? idx < vec::len(substs)\n     fn substituter(_cx: ctxt, substs: @[ty::t], idx: uint, _did: def_id)\n         -> t {\n-        // FIXME: bounds check can fail\n-        ret substs[idx];\n+        if idx < vec::len(*substs) {\n+            ret substs[idx];\n+        }\n+        else {\n+            fail #fmt(\"Internal error in substituter (substitute_type_params)\\\n+             %u %u\", vec::len(*substs), idx);\n+        }\n     }\n     ret fold_ty(cx, fm_param(bind substituter(cx, @substs, _, _)), typ);\n }\n@@ -2729,7 +2738,7 @@ fn is_binopable(cx: ctxt, ty: t, op: ast::binop) -> bool {\n     fn opcat(op: ast::binop) -> int {\n         alt op {\n           ast::add. { opcat_add }\n-          ast::sub. { opcat_sub }\n+          ast::subtract. { opcat_sub }\n           ast::mul. { opcat_mult }\n           ast::div. { opcat_mult }\n           ast::rem. { opcat_mult }"}, {"sha": "d447dfcfce4bb372bea0515bb561d981462f9a22", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c3bc8fada838c15e09e76a9d5d85438667c1636c/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3bc8fada838c15e09e76a9d5d85438667c1636c/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=c3bc8fada838c15e09e76a9d5d85438667c1636c", "patch": "@@ -6,6 +6,7 @@ import metadata::csearch;\n import driver::session::session;\n import util::common::*;\n import syntax::codemap::span;\n+import pat_util::*;\n import middle::ty;\n import middle::ty::{node_id_to_type, arg, block_ty,\n                     expr_ty, field, node_type_table, mk_nil,\n@@ -1137,8 +1138,8 @@ fn gather_locals(ccx: @crate_ctxt,\n \n     // Add pattern bindings.\n     let visit_pat = fn@(p: @ast::pat, &&e: (), v: visit::vt<()>) {\n-            alt p.node {\n-              ast::pat_bind(_, _) { assign(p.id, none); }\n+        alt normalize_pat(ccx.tcx, p).node {\n+              ast::pat_ident(_, _) { assign(p.id, none); }\n               _ {/* no-op */ }\n             }\n             visit::visit_pat(p, e, v);\n@@ -1181,9 +1182,9 @@ fn valid_range_bounds(from: @ast::expr, to: @ast::expr) -> bool {\n \n // Pattern checking is top-down rather than bottom-up so that bindings get\n // their types immediately.\n-fn check_pat(fcx: @fn_ctxt, map: ast_util::pat_id_map, pat: @ast::pat,\n+fn check_pat(fcx: @fn_ctxt, map: pat_util::pat_id_map, pat: @ast::pat,\n              expected: ty::t) {\n-    alt pat.node {\n+    alt normalize_pat(fcx.ccx.tcx, pat).node {\n       ast::pat_wild. {\n           alt structure_of(fcx, pat.span, expected) {\n                   ty::ty_tag(_, expected_tps) {\n@@ -1218,11 +1219,11 @@ fn check_pat(fcx: @fn_ctxt, map: ast_util::pat_id_map, pat: @ast::pat,\n         }\n         write::ty_only_fixup(fcx, pat.id, b_ty);\n       }\n-      ast::pat_bind(name, sub) {\n+      ast::pat_ident(name, sub) {\n         let vid = lookup_local(fcx, pat.span, pat.id);\n         let typ = ty::mk_var(fcx.ccx.tcx, vid);\n         typ = demand::simple(fcx, pat.span, expected, typ);\n-        let canon_id = map.get(name);\n+        let canon_id = map.get(path_to_ident(name));\n         if canon_id != pat.id {\n             let ct =\n                 ty::mk_var(fcx.ccx.tcx,\n@@ -2014,7 +2015,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         // bindings.\n         let pattern_ty = ty::expr_ty(tcx, expr);\n         for arm: ast::arm in arms {\n-            let id_map = ast_util::pat_id_map(arm.pats[0]);\n+            let id_map = pat_util::pat_id_map(tcx, arm.pats[0]);\n             for p: @ast::pat in arm.pats {\n                 check_pat(fcx, id_map, p, pattern_ty);\n             }\n@@ -2360,7 +2361,7 @@ fn check_decl_local(fcx: @fn_ctxt, local: @ast::local) -> bool {\n           }\n           _ {/* fall through */ }\n         }\n-        let id_map = ast_util::pat_id_map(local.node.pat);\n+        let id_map = pat_util::pat_id_map(fcx.ccx.tcx, local.node.pat);\n         check_pat(fcx, id_map, local.node.pat, t);\n       }\n     }"}, {"sha": "db36e6adc9610f25f1ecd16f4cd087ea2099b640", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c3bc8fada838c15e09e76a9d5d85438667c1636c/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/c3bc8fada838c15e09e76a9d5d85438667c1636c/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=c3bc8fada838c15e09e76a9d5d85438667c1636c", "patch": "@@ -39,6 +39,7 @@ mod middle {\n     mod gc;\n     mod debuginfo;\n     mod capture;\n+    mod pat_util;\n \n     mod tstate {\n         mod ck;"}, {"sha": "6419e690c44062c27441469bb2cf0c8202044a1d", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c3bc8fada838c15e09e76a9d5d85438667c1636c/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3bc8fada838c15e09e76a9d5d85438667c1636c/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=c3bc8fada838c15e09e76a9d5d85438667c1636c", "patch": "@@ -97,7 +97,17 @@ type field_pat = {ident: ident, pat: @pat};\n \n tag pat_ {\n     pat_wild;\n-    pat_bind(ident, option::t<@pat>);\n+    // A pat_ident may either be a new bound variable,\n+    // or a nullary tag (in which case the second field\n+    // is none).\n+    // In the nullary tag case, the parser can't determine\n+    // which it is. The resolver determines this, and\n+    // records this pattern's node_id in an auxiliary\n+    // set (of \"pat_idents that refer to nullary tags\")\n+    // After the resolution phase, code should never pattern-\n+    // match on a pat directly! Always call pat_util::normalize_pat --\n+    // it turns any pat_idents that refer to nullary tags into pat_tags.\n+    pat_ident(@path, option::t<@pat>);\n     pat_tag(@path, [@pat]);\n     pat_rec([field_pat], bool);\n     pat_tup([@pat]);\n@@ -126,7 +136,7 @@ pure fn is_blockish(p: ast::proto) -> bool {\n \n tag binop {\n     add;\n-    sub;\n+    subtract;\n     mul;\n     div;\n     rem;"}, {"sha": "ed65aa11df9e919954732f2d11c344ad9ffbae71", "filename": "src/comp/syntax/ast_util.rs", "status": "modified", "additions": 8, "deletions": 37, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/c3bc8fada838c15e09e76a9d5d85438667c1636c/src%2Fcomp%2Fsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3bc8fada838c15e09e76a9d5d85438667c1636c/src%2Fcomp%2Fsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast_util.rs?ref=c3bc8fada838c15e09e76a9d5d85438667c1636c", "patch": "@@ -33,43 +33,10 @@ fn def_id_of_def(d: def) -> def_id {\n     }\n }\n \n-type pat_id_map = std::map::hashmap<str, node_id>;\n-\n-// This is used because same-named variables in alternative patterns need to\n-// use the node_id of their namesake in the first pattern.\n-fn pat_id_map(pat: @pat) -> pat_id_map {\n-    let map = std::map::new_str_hash::<node_id>();\n-    pat_bindings(pat) {|bound|\n-        let name = alt bound.node { pat_bind(n, _) { n } };\n-        map.insert(name, bound.id);\n-    };\n-    ret map;\n-}\n-\n-// FIXME: could return a constrained type\n-fn pat_bindings(pat: @pat, it: block(@pat)) {\n-    alt pat.node {\n-      pat_bind(_, option::none.) { it(pat); }\n-      pat_bind(_, option::some(sub)) { it(pat); pat_bindings(sub, it); }\n-      pat_tag(_, sub) { for p in sub { pat_bindings(p, it); } }\n-      pat_rec(fields, _) { for f in fields { pat_bindings(f.pat, it); } }\n-      pat_tup(elts) { for elt in elts { pat_bindings(elt, it); } }\n-      pat_box(sub) { pat_bindings(sub, it); }\n-      pat_uniq(sub) { pat_bindings(sub, it); }\n-      pat_wild. | pat_lit(_) | pat_range(_, _) { }\n-    }\n-}\n-\n-fn pat_binding_ids(pat: @pat) -> [node_id] {\n-    let found = [];\n-    pat_bindings(pat) {|b| found += [b.id]; };\n-    ret found;\n-}\n-\n fn binop_to_str(op: binop) -> str {\n     alt op {\n       add. { ret \"+\"; }\n-      sub. { ret \"-\"; }\n+      subtract. { ret \"-\"; }\n       mul. { ret \"*\"; }\n       div. { ret \"/\"; }\n       rem. { ret \"%\"; }\n@@ -262,7 +229,7 @@ fn eval_const_expr(e: @expr) -> const_val {\n         alt (eval_const_expr(a), eval_const_expr(b)) {\n           (const_float(a), const_float(b)) {\n             alt op {\n-              add. { const_float(a + b) } sub. { const_float(a - b) }\n+              add. { const_float(a + b) } subtract. { const_float(a - b) }\n               mul. { const_float(a * b) } div. { const_float(a / b) }\n               rem. { const_float(a % b) } eq. { fromb(a == b) }\n               lt. { fromb(a < b) } le. { fromb(a <= b) } ne. { fromb(a != b) }\n@@ -271,7 +238,7 @@ fn eval_const_expr(e: @expr) -> const_val {\n           }\n           (const_int(a), const_int(b)) {\n             alt op {\n-              add. { const_int(a + b) } sub. { const_int(a - b) }\n+              add. { const_int(a + b) } subtract. { const_int(a - b) }\n               mul. { const_int(a * b) } div. { const_int(a / b) }\n               rem. { const_int(a % b) } and. | bitand. { const_int(a & b) }\n               or. | bitor. { const_int(a | b) } bitxor. { const_int(a ^ b) }\n@@ -282,7 +249,7 @@ fn eval_const_expr(e: @expr) -> const_val {\n           }\n           (const_uint(a), const_uint(b)) {\n             alt op {\n-              add. { const_uint(a + b) } sub. { const_uint(a - b) }\n+              add. { const_uint(a + b) } subtract. { const_uint(a - b) }\n               mul. { const_uint(a * b) } div. { const_uint(a / b) }\n               rem. { const_uint(a % b) } and. | bitand. { const_uint(a & b) }\n               or. | bitor. { const_uint(a | b) } bitxor. { const_uint(a ^ b) }\n@@ -327,6 +294,10 @@ fn lit_eq(a: @lit, b: @lit) -> bool {\n     compare_const_vals(lit_to_const(a), lit_to_const(b)) == 0\n }\n \n+fn ident_to_path(s: span, i: ident) -> @path {\n+    @respan(s, {global: false, idents: [i], types: []})\n+}\n+\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "a5ce71f8cd50fda5d81c066ca94c0fd514fdf316", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c3bc8fada838c15e09e76a9d5d85438667c1636c/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3bc8fada838c15e09e76a9d5d85438667c1636c/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=c3bc8fada838c15e09e76a9d5d85438667c1636c", "patch": "@@ -10,6 +10,7 @@ export make_fold;\n export noop_fold_crate;\n export noop_fold_item;\n export noop_fold_expr;\n+export noop_fold_pat;\n export noop_fold_mod;\n export noop_fold_ty;\n \n@@ -273,8 +274,8 @@ fn noop_fold_arm(a: arm, fld: ast_fold) -> arm {\n fn noop_fold_pat(p: pat_, fld: ast_fold) -> pat_ {\n     ret alt p {\n           pat_wild. { p }\n-          pat_bind(ident, sub) {\n-            pat_bind(fld.fold_ident(ident), option::map(sub, fld.fold_pat))\n+          pat_ident(pth, sub) {\n+            pat_ident(fld.fold_path(pth), option::map(sub, fld.fold_pat))\n           }\n           pat_lit(_) { p }\n           pat_tag(pth, pats) {\n@@ -317,8 +318,8 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n     let fold_mac = bind fold_mac_(_, fld);\n \n     ret alt e {\n-          expr_vec(exprs, mut) {\n-            expr_vec(fld.map_exprs(fld.fold_expr, exprs), mut)\n+            expr_vec(exprs, mutt) {\n+            expr_vec(fld.map_exprs(fld.fold_expr, exprs), mutt)\n           }\n           expr_rec(fields, maybe_expr) {\n             expr_rec(vec::map(fields, fold_field),\n@@ -390,8 +391,7 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n           }\n           expr_path(pth) { expr_path(fld.fold_path(pth)) }\n           expr_fail(e) { expr_fail(option::map(e, fld.fold_expr)) }\n-          expr_break. { e }\n-          expr_cont. { e }\n+          expr_break. | expr_cont. { e }\n           expr_ret(e) { expr_ret(option::map(e, fld.fold_expr)) }\n           expr_be(e) { expr_be(fld.fold_expr(e)) }\n           expr_log(i, lv, e) { expr_log(i, fld.fold_expr(lv),"}, {"sha": "b8f55dcba963ee88d5ee2de9be23ca14487b24bd", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c3bc8fada838c15e09e76a9d5d85438667c1636c/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3bc8fada838c15e09e76a9d5d85438667c1636c/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=c3bc8fada838c15e09e76a9d5d85438667c1636c", "patch": "@@ -8,6 +8,7 @@ import token::can_begin_expr;\n import codemap::span;\n import util::interner;\n import ast::{node_id, spanned};\n+import ast_util::{mk_sp, ident_to_path};\n import front::attr;\n import lexer::reader;\n import driver::diagnostic;\n@@ -1097,7 +1098,7 @@ fn prec_table() -> @[op_spec] {\n           {tok: token::BINOP(token::SLASH), op: ast::div, prec: 11},\n           {tok: token::BINOP(token::PERCENT), op: ast::rem, prec: 11},\n           {tok: token::BINOP(token::PLUS), op: ast::add, prec: 10},\n-          {tok: token::BINOP(token::MINUS), op: ast::sub, prec: 10},\n+          {tok: token::BINOP(token::MINUS), op: ast::subtract, prec: 10},\n           {tok: token::BINOP(token::LSL), op: ast::lsl, prec: 9},\n           {tok: token::BINOP(token::LSR), op: ast::lsr, prec: 9},\n           {tok: token::BINOP(token::ASR), op: ast::asr, prec: 9},\n@@ -1165,7 +1166,7 @@ fn parse_assign_expr(p: parser) -> @ast::expr {\n         let aop = ast::add;\n         alt op {\n           token::PLUS. { aop = ast::add; }\n-          token::MINUS. { aop = ast::sub; }\n+          token::MINUS. { aop = ast::subtract; }\n           token::STAR. { aop = ast::mul; }\n           token::SLASH. { aop = ast::div; }\n           token::PERCENT. { aop = ast::rem; }\n@@ -1426,7 +1427,11 @@ fn parse_pat(p: parser) -> @ast::pat {\n                 break;\n             }\n \n+            let lo1 = p.last_span.lo;\n             let fieldname = parse_ident(p);\n+            let hi1 = p.last_span.lo;\n+            let fieldpath = ast_util::ident_to_path(ast_util::mk_sp(lo1, hi1),\n+                                          fieldname);\n             let subpat;\n             if p.token == token::COLON {\n                 p.bump();\n@@ -1436,7 +1441,7 @@ fn parse_pat(p: parser) -> @ast::pat {\n                     p.fatal(\"found \" + fieldname + \" in binding position\");\n                 }\n                 subpat = @{id: p.get_id(),\n-                           node: ast::pat_bind(fieldname, none),\n+                           node: ast::pat_ident(fieldpath, none),\n                            span: ast_util::mk_sp(lo, hi)};\n             }\n             fields += [{ident: fieldname, pat: subpat}];\n@@ -1478,15 +1483,18 @@ fn parse_pat(p: parser) -> @ast::pat {\n             }\n         } else if is_plain_ident(p) &&\n                       alt p.look_ahead(1u) {\n-                        token::DOT. | token::LPAREN. | token::LBRACKET. {\n+                    // Take this out once the libraries change\n+                        token::DOT. |\n+                        token::LPAREN. | token::LBRACKET. |\n+                            token::LT. {\n                           false\n                         }\n                         _ { true }\n                       } {\n             hi = p.span.hi;\n             let name = parse_value_ident(p);\n             let sub = eat(p, token::AT) ? some(parse_pat(p)) : none;\n-            pat = ast::pat_bind(name, sub);\n+            pat = ast::pat_ident(ident_to_path(mk_sp(lo, hi), name), sub);\n         } else {\n             let tag_path = parse_path_and_ty_param_substs(p, true);\n             hi = tag_path.span.hi;\n@@ -1499,10 +1507,19 @@ fn parse_pat(p: parser) -> @ast::pat {\n                 args = a.node;\n                 hi = a.span.hi;\n               }\n+              token::LBRACE. { args = []; }\n+              // take this out once the libraries change\n               token::DOT. { args = []; p.bump(); }\n               _ { expect(p, token::LPAREN); fail; }\n             }\n-            pat = ast::pat_tag(tag_path, args);\n+            // at this point, we're not sure whether it's a tag or a bind\n+            if vec::len(args) == 0u &&\n+               vec::len(tag_path.node.idents) == 1u {\n+                pat = ast::pat_ident(tag_path, none);\n+            }\n+            else {\n+                pat = ast::pat_tag(tag_path, args);\n+            }\n         }\n       }\n     }"}, {"sha": "258012c4f490a63fb02d04a6f70e135f214ad9c9", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c3bc8fada838c15e09e76a9d5d85438667c1636c/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3bc8fada838c15e09e76a9d5d85438667c1636c/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=c3bc8fada838c15e09e76a9d5d85438667c1636c", "patch": "@@ -1055,10 +1055,12 @@ fn print_pat(s: ps, &&pat: @ast::pat) {\n     maybe_print_comment(s, pat.span.lo);\n     let ann_node = node_pat(s, pat);\n     s.ann.pre(ann_node);\n+    /* Pat isn't normalized, but the beauty of it\n+     is that it doesn't matter */\n     alt pat.node {\n       ast::pat_wild. { word(s.s, \"_\"); }\n-      ast::pat_bind(id, sub) {\n-        word(s.s, id);\n+      ast::pat_ident(path, sub) {\n+        print_path(s, path, true);\n         alt sub {\n           some(p) { word(s.s, \"@\"); print_pat(s, p); }\n           _ {}\n@@ -1070,7 +1072,7 @@ fn print_pat(s: ps, &&pat: @ast::pat) {\n             popen(s);\n             commasep(s, inconsistent, args, print_pat);\n             pclose(s);\n-        } else { word(s.s, \".\"); }\n+        } else { word(s.s, \".\"); }  // FIXME\n       }\n       ast::pat_rec(fields, etc) {\n         word(s.s, \"{\");"}, {"sha": "a48b949bad1e1bef3a191cca190a37a7e179b813", "filename": "src/comp/syntax/visit.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c3bc8fada838c15e09e76a9d5d85438667c1636c/src%2Fcomp%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3bc8fada838c15e09e76a9d5d85438667c1636c/src%2Fcomp%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fvisit.rs?ref=c3bc8fada838c15e09e76a9d5d85438667c1636c", "patch": "@@ -195,9 +195,13 @@ fn visit_pat<E>(p: @pat, e: E, v: vt<E>) {\n         for f: field_pat in fields { v.visit_pat(f.pat, e, v); }\n       }\n       pat_tup(elts) { for elt in elts { v.visit_pat(elt, e, v); } }\n-      pat_box(inner) | pat_uniq(inner) | pat_bind(_, some(inner)) {\n+      pat_box(inner) | pat_uniq(inner) {\n         v.visit_pat(inner, e, v);\n       }\n+      pat_ident(path, inner) {\n+          visit_path(path, e, v);\n+          option::may(inner, {|subpat| v.visit_pat(subpat, e, v)});\n+      }\n       _ { }\n     }\n }"}, {"sha": "55175873f5a448272173adf746c3eb55e432b1ff", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c3bc8fada838c15e09e76a9d5d85438667c1636c/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3bc8fada838c15e09e76a9d5d85438667c1636c/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=c3bc8fada838c15e09e76a9d5d85438667c1636c", "patch": "@@ -1278,7 +1278,7 @@ mod node {\n             while true {\n                 alt(get_current_or_next_leaf(it)) {\n                   option::none. { ret option::none; }\n-                  option::some(leaf) {\n+                  option::some(_) {\n                     let next_char = get_next_char_in_leaf(it);\n                     alt(next_char) {\n                       option::none. {\n@@ -1301,7 +1301,7 @@ mod node {\n                 let next = leaf_iterator::next(it.leaf_iterator);\n                 alt(next) {\n                   option::none. { ret option::none }\n-                  option::some(leaf) {\n+                  option::some(_) {\n                     it.leaf          = next;\n                     it.leaf_byte_pos = 0u;\n                     ret next;\n@@ -1314,16 +1314,16 @@ mod node {\n         fn get_next_char_in_leaf(it: t) -> option::t<char> {\n             alt(it.leaf) {\n               option::none. { ret option::none }\n-              option::some(leaf) {\n-                if it.leaf_byte_pos >= leaf.byte_len {\n+              option::some(aleaf) {\n+                if it.leaf_byte_pos >= aleaf.byte_len {\n                     //We are actually past the end of the leaf\n                     it.leaf = option::none;\n                     ret option::none\n                 } else {\n                     let {ch, next} =\n-                        str::char_range_at(*leaf.content,\n-                                     it.leaf_byte_pos + leaf.byte_offset);\n-                    it.leaf_byte_pos = next - leaf.byte_offset;\n+                        str::char_range_at(*aleaf.content,\n+                                     it.leaf_byte_pos + aleaf.byte_offset);\n+                    it.leaf_byte_pos = next - aleaf.byte_offset;\n                     ret option::some(ch)\n                 }\n               }"}, {"sha": "bf5f963e9cc92cc9ff31aad0b8a94da021684a4d", "filename": "src/test/run-pass/alt-bot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3bc8fada838c15e09e76a9d5d85438667c1636c/src%2Ftest%2Frun-pass%2Falt-bot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3bc8fada838c15e09e76a9d5d85438667c1636c/src%2Ftest%2Frun-pass%2Falt-bot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-bot.rs?ref=c3bc8fada838c15e09e76a9d5d85438667c1636c", "patch": "@@ -1,6 +1,6 @@\n \n fn main() {\n     let i: int =\n-        alt some::<int>(3) { none::<int>. { fail } some::<int>(_) { 5 } };\n+        alt some::<int>(3) { none::<int> { fail } some::<int>(_) { 5 } };\n     log(debug, i);\n }"}, {"sha": "8d4609f95d06e8e73f2a12d51e169434139445fc", "filename": "src/test/run-pass/nullary-or-pattern.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c3bc8fada838c15e09e76a9d5d85438667c1636c/src%2Ftest%2Frun-pass%2Fnullary-or-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3bc8fada838c15e09e76a9d5d85438667c1636c/src%2Ftest%2Frun-pass%2Fnullary-or-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnullary-or-pattern.rs?ref=c3bc8fada838c15e09e76a9d5d85438667c1636c", "patch": "@@ -0,0 +1,10 @@\n+tag blah { a; b; }\n+\n+fn or_alt(q: blah) -> int {\n+  alt q { a. | b. { 42 } }\n+}\n+\n+fn main() {\n+    assert (or_alt(a) == 42);\n+    assert (or_alt(b) == 42);\n+}"}]}