{"sha": "fcc4d8ce98ef61586fccfb7efae7563788453b73", "node_id": "C_kwDOAAsO6NoAKGZjYzRkOGNlOThlZjYxNTg2ZmNjZmI3ZWZhZTc1NjM3ODg0NTNiNzM", "commit": {"author": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2022-03-29T09:38:08Z"}, "committer": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2022-03-29T09:41:01Z"}, "message": "include refs in valtree creation", "tree": {"sha": "fbcfc3b6c6bfc1065229c5d8e6ef8eb74bf8b915", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fbcfc3b6c6bfc1065229c5d8e6ef8eb74bf8b915"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fcc4d8ce98ef61586fccfb7efae7563788453b73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fcc4d8ce98ef61586fccfb7efae7563788453b73", "html_url": "https://github.com/rust-lang/rust/commit/fcc4d8ce98ef61586fccfb7efae7563788453b73", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fcc4d8ce98ef61586fccfb7efae7563788453b73/comments", "author": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "committer": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "51aa3f86a040599dad36a75c22fa0321f7de0741", "url": "https://api.github.com/repos/rust-lang/rust/commits/51aa3f86a040599dad36a75c22fa0321f7de0741", "html_url": "https://github.com/rust-lang/rust/commit/51aa3f86a040599dad36a75c22fa0321f7de0741"}], "stats": {"total": 187, "additions": 158, "deletions": 29}, "files": [{"sha": "dad6e5e34a6c8d9a6dca2101ed6991f24294c87f", "filename": "compiler/rustc_const_eval/src/const_eval/mod.rs", "status": "modified", "additions": 113, "deletions": 25, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/fcc4d8ce98ef61586fccfb7efae7563788453b73/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcc4d8ce98ef61586fccfb7efae7563788453b73/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs?ref=fcc4d8ce98ef61586fccfb7efae7563788453b73", "patch": "@@ -6,9 +6,10 @@ use rustc_hir::Mutability;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_middle::{\n     mir::{self, interpret::ConstAlloc},\n-    ty::ScalarInt,\n+    ty::{ScalarInt, Ty},\n };\n use rustc_span::{source_map::DUMMY_SP, symbol::Symbol};\n+use rustc_target::abi::VariantIdx;\n \n use crate::interpret::{\n     intern_const_alloc_recursive, ConstValue, InternKind, InterpCx, InterpResult, MPlaceTy,\n@@ -55,28 +56,43 @@ pub(crate) fn const_to_valtree<'tcx>(\n     const_to_valtree_inner(&ecx, &place)\n }\n \n+#[instrument(skip(ecx), level = \"debug\")]\n+fn branches<'tcx>(\n+    ecx: &CompileTimeEvalContext<'tcx, 'tcx>,\n+    place: &MPlaceTy<'tcx>,\n+    n: usize,\n+    variant: Option<VariantIdx>,\n+) -> Option<ty::ValTree<'tcx>> {\n+    let place = match variant {\n+        Some(variant) => ecx.mplace_downcast(&place, variant).unwrap(),\n+        None => *place,\n+    };\n+    let variant = variant.map(|variant| Some(ty::ValTree::Leaf(ScalarInt::from(variant.as_u32()))));\n+    debug!(?place, ?variant);\n+\n+    let fields = (0..n).map(|i| {\n+        let field = ecx.mplace_field(&place, i).unwrap();\n+        const_to_valtree_inner(ecx, &field)\n+    });\n+    // For enums, we preped their variant index before the variant's fields so we can figure out\n+    // the variant again when just seeing a valtree.\n+    let branches = variant.into_iter().chain(fields);\n+    Some(ty::ValTree::Branch(ecx.tcx.arena.alloc_from_iter(branches.collect::<Option<Vec<_>>>()?)))\n+}\n+\n+#[instrument(skip(ecx), level = \"debug\")]\n fn const_to_valtree_inner<'tcx>(\n     ecx: &CompileTimeEvalContext<'tcx, 'tcx>,\n     place: &MPlaceTy<'tcx>,\n ) -> Option<ty::ValTree<'tcx>> {\n-    let branches = |n, variant| {\n-        let place = match variant {\n-            Some(variant) => ecx.mplace_downcast(&place, variant).unwrap(),\n-            None => *place,\n-        };\n-        let variant =\n-            variant.map(|variant| Some(ty::ValTree::Leaf(ScalarInt::from(variant.as_u32()))));\n-        let fields = (0..n).map(|i| {\n-            let field = ecx.mplace_field(&place, i).unwrap();\n-            const_to_valtree_inner(ecx, &field)\n-        });\n-        // For enums, we preped their variant index before the variant's fields so we can figure out\n-        // the variant again when just seeing a valtree.\n-        let branches = variant.into_iter().chain(fields);\n-        Some(ty::ValTree::Branch(\n-            ecx.tcx.arena.alloc_from_iter(branches.collect::<Option<Vec<_>>>()?),\n-        ))\n+    // We only want to use raw bytes in ValTrees for string slices or &[<integer_ty>]\n+    let use_bytes_for_ref = |ty: Ty<'tcx>| -> bool {\n+        match ty.kind() {\n+            ty::Str | ty::Char | ty::Uint(_) | ty::Int(_) | ty::Bool => true,\n+            _ => false,\n+        }\n     };\n+\n     match place.layout.ty.kind() {\n         ty::FnDef(..) => Some(ty::ValTree::zst()),\n         ty::Bool | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Char => {\n@@ -90,19 +106,91 @@ fn const_to_valtree_inner<'tcx>(\n         // Technically we could allow function pointers (represented as `ty::Instance`), but this is not guaranteed to\n         // agree with runtime equality tests.\n         ty::FnPtr(_) | ty::RawPtr(_) => None,\n-        ty::Ref(..) => unimplemented!(\"need to use deref_const\"),\n+\n+        ty::Ref(_, ref_ty, _) if place.layout.ty.is_slice() => {\n+            match ecx.try_read_immediate_from_mplace(&place) {\n+                Ok(Some(imm)) => {\n+                    // `imm` is a ScalarPair. We try to get the underlying bytes behind that\n+                    // fat pointer for string slices and slices of integer types. For any other\n+                    // slice types we use `branches` to recursively construct the Valtree.\n+\n+                    if use_bytes_for_ref(*ref_ty) {\n+                        let (alloc, range) = ecx.get_alloc_from_imm_scalar_pair(imm);\n+                        let alloc_bytes = match alloc.get_bytes(&ecx.tcx, range) {\n+                            Ok(bytes) => bytes,\n+                            Err(_e) => return None,\n+                        };\n+                        debug!(?alloc_bytes);\n+\n+                        let bytes = ecx.tcx.arena.alloc_slice(alloc_bytes);\n+                        let len = bytes.len();\n+                        debug!(?bytes, ?len);\n+\n+                        let slice = ty::ValSlice { bytes};\n+\n+                        Some(ty::ValTree::SliceOrStr(slice))\n+                    } else {\n+                        let derefd = ecx.deref_operand(&imm.into()).expect(&format!(\"couldnt deref {:?}\", imm));\n+                        debug!(\"derefd: {:?}\", derefd);\n+\n+                        let derefd_imm = match ecx.try_read_immediate_from_mplace(&derefd) {\n+                            Ok(Some(imm)) => imm,\n+                            _ => return None,\n+                        };\n+                        debug!(?derefd_imm);\n+\n+                        let tcx = ecx.tcx.tcx;\n+                        let scalar_len= derefd.meta.unwrap_meta();\n+                        let len = match scalar_len {\n+                            Scalar::Int(int) => {\n+                                int.try_to_machine_usize(tcx).expect(&format!(\"Expected a valid ScalarInt in {:?}\", scalar_len))\n+                            }\n+                            _ => bug!(\"expected a ScalarInt in meta data for {:?}\", place),\n+                        };\n+                        debug!(?len);\n+\n+                        let valtree = branches(ecx, place, len.try_into().expect(\"BLA\"), None);\n+                        debug!(?valtree);\n+\n+                        valtree\n+                    }\n+                }\n+                _ => {\n+                    None\n+                }\n+            }\n+        }\n+\n+        ty::Ref(_, inner_ty, _) => {\n+            debug!(\"Ref with inner_ty: {:?}\", inner_ty);\n+            let imm = ecx.try_read_immediate_from_mplace(&place).unwrap_or_else(|e| bug!(\"couldnt read immediate from {:?}, error: {:?}\", place, e));\n+            match imm {\n+                Some(imm) => {\n+                    debug!(?imm);\n+\n+                    let derefd_place = ecx.deref_mplace(place).unwrap_or_else(|e| bug!(\"couldn't deref {:?}, error: {:?}\", place, e));\n+                    debug!(?derefd_place);\n+\n+                    const_to_valtree_inner(ecx, &derefd_place)\n+                }\n+                None => None,\n+            }\n+        }\n+        ty::Str => {\n+            bug!(\"ty::Str should have been handled in ty::Ref branch that uses raw bytes\");\n+        }\n+        ty::Slice(_) => {\n+            bug!(\"should have been handled in the Ref arm\");\n+        }\n \n         // Trait objects are not allowed in type level constants, as we have no concept for\n         // resolving their backing type, even if we can do that at const eval time. We may\n         // hypothetically be able to allow `dyn StructuralEq` trait objects in the future,\n         // but it is unclear if this is useful.\n         ty::Dynamic(..) => None,\n \n-        ty::Slice(_) | ty::Str => {\n-            unimplemented!(\"need to find the backing data of the slice/str and recurse on that\")\n-        }\n-        ty::Tuple(substs) => branches(substs.len(), None),\n-        ty::Array(_, len) => branches(usize::try_from(len.eval_usize(ecx.tcx.tcx, ecx.param_env)).unwrap(), None),\n+        ty::Tuple(substs) => branches(ecx, place, substs.len(), None),\n+        ty::Array(_, len) => branches(ecx, place, usize::try_from(len.eval_usize(ecx.tcx.tcx, ecx.param_env)).unwrap(), None),\n \n         ty::Adt(def, _) => {\n             if def.variants().is_empty() {\n@@ -111,7 +199,7 @@ fn const_to_valtree_inner<'tcx>(\n \n             let variant = ecx.read_discriminant(&place.into()).unwrap().1;\n \n-            branches(def.variant(variant).fields.len(), def.is_enum().then_some(variant))\n+            branches(ecx, place, def.variant(variant).fields.len(), def.is_enum().then_some(variant))\n         }\n \n         ty::Never"}, {"sha": "d271bf53eac0c12d43dee1427af69c9f462d11fa", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 33, "deletions": 4, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/fcc4d8ce98ef61586fccfb7efae7563788453b73/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcc4d8ce98ef61586fccfb7efae7563788453b73/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=fcc4d8ce98ef61586fccfb7efae7563788453b73", "patch": "@@ -14,9 +14,9 @@ use rustc_target::abi::{Abi, HasDataLayout, Size, TagEncoding};\n use rustc_target::abi::{VariantIdx, Variants};\n \n use super::{\n-    alloc_range, from_known_layout, mir_assign_valid_types, AllocId, ConstValue, GlobalId,\n-    InterpCx, InterpResult, MPlaceTy, Machine, MemPlace, Place, PlaceTy, Pointer, Provenance,\n-    Scalar, ScalarMaybeUninit,\n+    alloc_range, from_known_layout, mir_assign_valid_types, AllocId, AllocRange, Allocation,\n+    ConstValue, GlobalId, InterpCx, InterpResult, MPlaceTy, Machine, MemPlace, Place, PlaceTy,\n+    Pointer, Provenance, Scalar, ScalarMaybeUninit,\n };\n \n /// An `Immediate` represents a single immediate self-contained Rust value.\n@@ -248,7 +248,7 @@ impl<'tcx, Tag: Provenance> ImmTy<'tcx, Tag> {\n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Try reading an immediate in memory; this is interesting particularly for `ScalarPair`.\n     /// Returns `None` if the layout does not permit loading this as a value.\n-    fn try_read_immediate_from_mplace(\n+    pub(crate) fn try_read_immediate_from_mplace(\n         &self,\n         mplace: &MPlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, Option<ImmTy<'tcx, M::PointerTag>>> {\n@@ -777,3 +777,32 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         })\n     }\n }\n+\n+impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx, PointerTag = AllocId>> InterpCx<'mir, 'tcx, M> {\n+    pub fn get_alloc_from_imm_scalar_pair(\n+        &self,\n+        imm: ImmTy<'tcx, M::PointerTag>,\n+    ) -> (&Allocation, AllocRange) {\n+        match imm.imm {\n+            Immediate::ScalarPair(a, b) => {\n+                // We know `offset` is relative to the allocation, so we can use `into_parts`.\n+                let (data, start) = match self.scalar_to_ptr(a.check_init().unwrap()).into_parts() {\n+                    (Some(alloc_id), offset) => {\n+                        (self.tcx.global_alloc(alloc_id).unwrap_memory(), offset.bytes())\n+                    }\n+                    (None, _offset) => (\n+                        self.tcx.intern_const_alloc(Allocation::from_bytes_byte_aligned_immutable(\n+                            b\"\" as &[u8],\n+                        )),\n+                        0,\n+                    ),\n+                };\n+                let len = b.to_machine_usize(self).unwrap();\n+                let size = Size::from_bytes(len);\n+                let start = Size::from_bytes(start);\n+                (data.inner(), AllocRange { start, size })\n+            }\n+            _ => bug!(\"{:?} not a ScalarPair\", imm),\n+        }\n+    }\n+}"}, {"sha": "ad7620d83e677bfee73de4974d7735e8e7715da2", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fcc4d8ce98ef61586fccfb7efae7563788453b73/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcc4d8ce98ef61586fccfb7efae7563788453b73/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=fcc4d8ce98ef61586fccfb7efae7563788453b73", "patch": "@@ -305,6 +305,18 @@ where\n         Ok(mplace)\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n+    pub fn deref_mplace(\n+        &self,\n+        src: &MPlaceTy<'tcx, M::PointerTag>,\n+    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n+        let val = self.try_read_immediate_from_mplace(src)?;\n+        let mplace = self.ref_to_mplace(&val.unwrap())?;\n+        self.check_mplace_access(mplace, CheckInAllocMsg::DerefTest)?;\n+\n+        Ok(mplace)\n+    }\n+\n     #[inline]\n     pub(super) fn get_alloc(\n         &self,"}]}