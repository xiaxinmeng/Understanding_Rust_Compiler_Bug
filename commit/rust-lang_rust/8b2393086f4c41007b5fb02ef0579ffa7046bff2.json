{"sha": "8b2393086f4c41007b5fb02ef0579ffa7046bff2", "node_id": "C_kwDOAAsO6NoAKDhiMjM5MzA4NmY0YzQxMDA3YjVmYjAyZWYwNTc5ZmZhNzA0NmJmZjI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-22T02:30:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-22T02:30:27Z"}, "message": "Auto merge of #96282 - petrochenkov:unindent, r=GuillaumeGomez\n\nrustdoc: Unindent doc fragments on `Attributes` construction\n\n`Attributes` can be constructed at arbitrary points, even after the `unindent_comments` pass.\n`Attributes` that are constructed too late end up unindented.\n\nAll doc fragments need to be eventually indented before use, so there are no reasons to not do this immediately during their construction.\n\nFixes https://rust-lang.zulipchat.com/#narrow/stream/266220-rustdoc/topic/.60unindent_comments.60.20cannot.20work.20as.20a.20separate.20pass.\nI'm not sure how to make a minimized reproduction, but unindenting the fragments during their construction should fix the issue.. by construction, and I also verified that all doc strings now hit the `resolver_caches.markdown_links` cache in https://github.com/rust-lang/rust/pull/94857.", "tree": {"sha": "263a9f1a9deda26bb0056b231c849caa1f6cf7f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/263a9f1a9deda26bb0056b231c849caa1f6cf7f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8b2393086f4c41007b5fb02ef0579ffa7046bff2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8b2393086f4c41007b5fb02ef0579ffa7046bff2", "html_url": "https://github.com/rust-lang/rust/commit/8b2393086f4c41007b5fb02ef0579ffa7046bff2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8b2393086f4c41007b5fb02ef0579ffa7046bff2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b3404b01b251401e6b45cb1c4df8f883dfab2d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b3404b01b251401e6b45cb1c4df8f883dfab2d7", "html_url": "https://github.com/rust-lang/rust/commit/0b3404b01b251401e6b45cb1c4df8f883dfab2d7"}, {"sha": "7803a411517f0f1e64d8f37ce377c684d1f2d1fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/7803a411517f0f1e64d8f37ce377c684d1f2d1fd", "html_url": "https://github.com/rust-lang/rust/commit/7803a411517f0f1e64d8f37ce377c684d1f2d1fd"}], "stats": {"total": 222, "additions": 89, "deletions": 133}, "files": [{"sha": "2b65b8f910c7069b74c23d24c4847a5240898dc8", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 86, "deletions": 3, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/8b2393086f4c41007b5fb02ef0579ffa7046bff2/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b2393086f4c41007b5fb02ef0579ffa7046bff2/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=8b2393086f4c41007b5fb02ef0579ffa7046bff2", "patch": "@@ -1,13 +1,11 @@\n use std::cell::RefCell;\n use std::default::Default;\n-use std::fmt;\n use std::hash::Hash;\n-use std::iter;\n use std::lazy::SyncOnceCell as OnceCell;\n use std::path::PathBuf;\n use std::rc::Rc;\n use std::sync::Arc;\n-use std::vec;\n+use std::{cmp, fmt, iter};\n \n use arrayvec::ArrayVec;\n \n@@ -55,6 +53,9 @@ crate use self::Type::{\n };\n crate use self::Visibility::{Inherited, Public};\n \n+#[cfg(test)]\n+mod tests;\n+\n crate type ItemIdSet = FxHashSet<ItemId>;\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash, Copy)]\n@@ -1028,6 +1029,86 @@ crate fn collapse_doc_fragments(doc_strings: &[DocFragment]) -> String {\n     acc\n }\n \n+/// Removes excess indentation on comments in order for the Markdown\n+/// to be parsed correctly. This is necessary because the convention for\n+/// writing documentation is to provide a space between the /// or //! marker\n+/// and the doc text, but Markdown is whitespace-sensitive. For example,\n+/// a block of text with four-space indentation is parsed as a code block,\n+/// so if we didn't unindent comments, these list items\n+///\n+/// /// A list:\n+/// ///\n+/// ///    - Foo\n+/// ///    - Bar\n+///\n+/// would be parsed as if they were in a code block, which is likely not what the user intended.\n+fn unindent_doc_fragments(docs: &mut Vec<DocFragment>) {\n+    // `add` is used in case the most common sugared doc syntax is used (\"/// \"). The other\n+    // fragments kind's lines are never starting with a whitespace unless they are using some\n+    // markdown formatting requiring it. Therefore, if the doc block have a mix between the two,\n+    // we need to take into account the fact that the minimum indent minus one (to take this\n+    // whitespace into account).\n+    //\n+    // For example:\n+    //\n+    // /// hello!\n+    // #[doc = \"another\"]\n+    //\n+    // In this case, you want \"hello! another\" and not \"hello!  another\".\n+    let add = if docs.windows(2).any(|arr| arr[0].kind != arr[1].kind)\n+        && docs.iter().any(|d| d.kind == DocFragmentKind::SugaredDoc)\n+    {\n+        // In case we have a mix of sugared doc comments and \"raw\" ones, we want the sugared one to\n+        // \"decide\" how much the minimum indent will be.\n+        1\n+    } else {\n+        0\n+    };\n+\n+    // `min_indent` is used to know how much whitespaces from the start of each lines must be\n+    // removed. Example:\n+    //\n+    // ///     hello!\n+    // #[doc = \"another\"]\n+    //\n+    // In here, the `min_indent` is 1 (because non-sugared fragment are always counted with minimum\n+    // 1 whitespace), meaning that \"hello!\" will be considered a codeblock because it starts with 4\n+    // (5 - 1) whitespaces.\n+    let Some(min_indent) = docs\n+        .iter()\n+        .map(|fragment| {\n+            fragment.doc.as_str().lines().fold(usize::MAX, |min_indent, line| {\n+                if line.chars().all(|c| c.is_whitespace()) {\n+                    min_indent\n+                } else {\n+                    // Compare against either space or tab, ignoring whether they are\n+                    // mixed or not.\n+                    let whitespace = line.chars().take_while(|c| *c == ' ' || *c == '\\t').count();\n+                    cmp::min(min_indent, whitespace)\n+                        + if fragment.kind == DocFragmentKind::SugaredDoc { 0 } else { add }\n+                }\n+            })\n+        })\n+        .min()\n+    else {\n+        return;\n+    };\n+\n+    for fragment in docs {\n+        if fragment.doc == kw::Empty {\n+            continue;\n+        }\n+\n+        let min_indent = if fragment.kind != DocFragmentKind::SugaredDoc && min_indent > 0 {\n+            min_indent - add\n+        } else {\n+            min_indent\n+        };\n+\n+        fragment.indent = min_indent;\n+    }\n+}\n+\n /// A link that has not yet been rendered.\n ///\n /// This link will be turned into a rendered link by [`Item::links`].\n@@ -1119,6 +1200,8 @@ impl Attributes {\n             }\n         }\n \n+        unindent_doc_fragments(&mut doc_strings);\n+\n         Attributes { doc_strings, other_attrs }\n     }\n "}, {"sha": "71eddf4348f1e7dadfc52fbf4c9a5de7c05517ee", "filename": "src/librustdoc/clean/types/tests.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b2393086f4c41007b5fb02ef0579ffa7046bff2/src%2Flibrustdoc%2Fclean%2Ftypes%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b2393086f4c41007b5fb02ef0579ffa7046bff2/src%2Flibrustdoc%2Fclean%2Ftypes%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes%2Ftests.rs?ref=8b2393086f4c41007b5fb02ef0579ffa7046bff2", "patch": "@@ -20,7 +20,7 @@ fn create_doc_fragment(s: &str) -> Vec<DocFragment> {\n fn run_test(input: &str, expected: &str) {\n     create_default_session_globals_then(|| {\n         let mut s = create_doc_fragment(input);\n-        unindent_fragments(&mut s);\n+        unindent_doc_fragments(&mut s);\n         assert_eq!(collapse_doc_fragments(&s), expected);\n     });\n }", "previous_filename": "src/librustdoc/passes/unindent_comments/tests.rs"}, {"sha": "45ac16e75aa37474e81be14ddbaf9068d06375cf", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b2393086f4c41007b5fb02ef0579ffa7046bff2/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b2393086f4c41007b5fb02ef0579ffa7046bff2/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=8b2393086f4c41007b5fb02ef0579ffa7046bff2", "patch": "@@ -1174,8 +1174,6 @@ impl<'a, 'hir, 'tcx> HirCollector<'a, 'hir, 'tcx> {\n         nested: F,\n     ) {\n         let ast_attrs = self.tcx.hir().attrs(hir_id);\n-        let mut attrs = Attributes::from_ast(ast_attrs, None);\n-\n         if let Some(ref cfg) = ast_attrs.cfg(self.tcx, &FxHashSet::default()) {\n             if !cfg.matches(&self.sess.parse_sess, Some(self.sess.features_untracked())) {\n                 return;\n@@ -1187,9 +1185,9 @@ impl<'a, 'hir, 'tcx> HirCollector<'a, 'hir, 'tcx> {\n             self.collector.names.push(name);\n         }\n \n-        attrs.unindent_doc_comments();\n         // The collapse-docs pass won't combine sugared/raw doc attributes, or included files with\n         // anything else, this will combine them for us.\n+        let attrs = Attributes::from_ast(ast_attrs, None);\n         if let Some(doc) = attrs.collapsed_doc_value() {\n             // Use the outermost invocation, so that doctest names come from where the docs were written.\n             let span = ast_attrs"}, {"sha": "68e10e3a18c7ec40b6e7acf2b1d2a5bb0c12f664", "filename": "src/librustdoc/passes/collect_intra_doc_links/early.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b2393086f4c41007b5fb02ef0579ffa7046bff2/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b2393086f4c41007b5fb02ef0579ffa7046bff2/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs?ref=8b2393086f4c41007b5fb02ef0579ffa7046bff2", "patch": "@@ -66,9 +66,7 @@ crate fn early_resolve_intra_doc_links(\n }\n \n fn doc_attrs<'a>(attrs: impl Iterator<Item = &'a ast::Attribute>) -> Attributes {\n-    let mut attrs = Attributes::from_ast_iter(attrs.map(|attr| (attr, None)), true);\n-    attrs.unindent_doc_comments();\n-    attrs\n+    Attributes::from_ast_iter(attrs.map(|attr| (attr, None)), true)\n }\n \n struct EarlyDocLinkResolver<'r, 'ra> {"}, {"sha": "97a436c7500701f626c4136227d91759ddaffea2", "filename": "src/librustdoc/passes/mod.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8b2393086f4c41007b5fb02ef0579ffa7046bff2/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b2393086f4c41007b5fb02ef0579ffa7046bff2/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=8b2393086f4c41007b5fb02ef0579ffa7046bff2", "patch": "@@ -24,9 +24,6 @@ crate use self::strip_private::STRIP_PRIVATE;\n mod strip_priv_imports;\n crate use self::strip_priv_imports::STRIP_PRIV_IMPORTS;\n \n-mod unindent_comments;\n-crate use self::unindent_comments::UNINDENT_COMMENTS;\n-\n mod propagate_doc_cfg;\n crate use self::propagate_doc_cfg::PROPAGATE_DOC_CFG;\n \n@@ -81,7 +78,6 @@ crate enum Condition {\n crate const PASSES: &[Pass] = &[\n     CHECK_DOC_TEST_VISIBILITY,\n     STRIP_HIDDEN,\n-    UNINDENT_COMMENTS,\n     STRIP_PRIVATE,\n     STRIP_PRIV_IMPORTS,\n     PROPAGATE_DOC_CFG,\n@@ -96,7 +92,6 @@ crate const PASSES: &[Pass] = &[\n /// The list of passes run by default.\n crate const DEFAULT_PASSES: &[ConditionalPass] = &[\n     ConditionalPass::always(COLLECT_TRAIT_IMPLS),\n-    ConditionalPass::always(UNINDENT_COMMENTS),\n     ConditionalPass::always(CHECK_DOC_TEST_VISIBILITY),\n     ConditionalPass::new(STRIP_HIDDEN, WhenNotDocumentHidden),\n     ConditionalPass::new(STRIP_PRIVATE, WhenNotDocumentPrivate),"}, {"sha": "0f604157291bdcf6ab600c187c8d7459c4e0780f", "filename": "src/librustdoc/passes/unindent_comments.rs", "status": "removed", "additions": 0, "deletions": 116, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/0b3404b01b251401e6b45cb1c4df8f883dfab2d7/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3404b01b251401e6b45cb1c4df8f883dfab2d7/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs?ref=0b3404b01b251401e6b45cb1c4df8f883dfab2d7", "patch": "@@ -1,116 +0,0 @@\n-//! Removes excess indentation on comments in order for the Markdown\n-//! to be parsed correctly. This is necessary because the convention for\n-//! writing documentation is to provide a space between the /// or //! marker\n-//! and the doc text, but Markdown is whitespace-sensitive. For example,\n-//! a block of text with four-space indentation is parsed as a code block,\n-//! so if we didn't unindent comments, these list items\n-//!\n-//! /// A list:\n-//! ///\n-//! ///    - Foo\n-//! ///    - Bar\n-//!\n-//! would be parsed as if they were in a code block, which is likely not what the user intended.\n-use std::cmp;\n-\n-use rustc_span::symbol::kw;\n-\n-use crate::clean::{self, DocFragment, DocFragmentKind, Item};\n-use crate::core::DocContext;\n-use crate::fold::{self, DocFolder};\n-use crate::passes::Pass;\n-\n-#[cfg(test)]\n-mod tests;\n-\n-crate const UNINDENT_COMMENTS: Pass = Pass {\n-    name: \"unindent-comments\",\n-    run: unindent_comments,\n-    description: \"removes excess indentation on comments in order for markdown to like it\",\n-};\n-\n-crate fn unindent_comments(krate: clean::Crate, _: &mut DocContext<'_>) -> clean::Crate {\n-    CommentCleaner.fold_crate(krate)\n-}\n-\n-struct CommentCleaner;\n-\n-impl fold::DocFolder for CommentCleaner {\n-    fn fold_item(&mut self, mut i: Item) -> Option<Item> {\n-        i.attrs.unindent_doc_comments();\n-        Some(self.fold_item_recur(i))\n-    }\n-}\n-\n-impl clean::Attributes {\n-    crate fn unindent_doc_comments(&mut self) {\n-        unindent_fragments(&mut self.doc_strings);\n-    }\n-}\n-\n-fn unindent_fragments(docs: &mut Vec<DocFragment>) {\n-    // `add` is used in case the most common sugared doc syntax is used (\"/// \"). The other\n-    // fragments kind's lines are never starting with a whitespace unless they are using some\n-    // markdown formatting requiring it. Therefore, if the doc block have a mix between the two,\n-    // we need to take into account the fact that the minimum indent minus one (to take this\n-    // whitespace into account).\n-    //\n-    // For example:\n-    //\n-    // /// hello!\n-    // #[doc = \"another\"]\n-    //\n-    // In this case, you want \"hello! another\" and not \"hello!  another\".\n-    let add = if docs.windows(2).any(|arr| arr[0].kind != arr[1].kind)\n-        && docs.iter().any(|d| d.kind == DocFragmentKind::SugaredDoc)\n-    {\n-        // In case we have a mix of sugared doc comments and \"raw\" ones, we want the sugared one to\n-        // \"decide\" how much the minimum indent will be.\n-        1\n-    } else {\n-        0\n-    };\n-\n-    // `min_indent` is used to know how much whitespaces from the start of each lines must be\n-    // removed. Example:\n-    //\n-    // ///     hello!\n-    // #[doc = \"another\"]\n-    //\n-    // In here, the `min_indent` is 1 (because non-sugared fragment are always counted with minimum\n-    // 1 whitespace), meaning that \"hello!\" will be considered a codeblock because it starts with 4\n-    // (5 - 1) whitespaces.\n-    let Some(min_indent) = docs\n-        .iter()\n-        .map(|fragment| {\n-            fragment.doc.as_str().lines().fold(usize::MAX, |min_indent, line| {\n-                if line.chars().all(|c| c.is_whitespace()) {\n-                    min_indent\n-                } else {\n-                    // Compare against either space or tab, ignoring whether they are\n-                    // mixed or not.\n-                    let whitespace = line.chars().take_while(|c| *c == ' ' || *c == '\\t').count();\n-                    cmp::min(min_indent, whitespace)\n-                        + if fragment.kind == DocFragmentKind::SugaredDoc { 0 } else { add }\n-                }\n-            })\n-        })\n-        .min()\n-    else {\n-        return;\n-    };\n-\n-    for fragment in docs {\n-        if fragment.doc == kw::Empty {\n-            continue;\n-        }\n-\n-        let min_indent = if fragment.kind != DocFragmentKind::SugaredDoc && min_indent > 0 {\n-            min_indent - add\n-        } else {\n-            min_indent\n-        };\n-\n-        fragment.indent = min_indent;\n-    }\n-}"}, {"sha": "a19e452b459e19c85d84fb048b34a3b03cac84fc", "filename": "src/test/rustdoc-ui/issue-91713.stdout", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b2393086f4c41007b5fb02ef0579ffa7046bff2/src%2Ftest%2Frustdoc-ui%2Fissue-91713.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/8b2393086f4c41007b5fb02ef0579ffa7046bff2/src%2Ftest%2Frustdoc-ui%2Fissue-91713.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fissue-91713.stdout?ref=8b2393086f4c41007b5fb02ef0579ffa7046bff2", "patch": "@@ -1,7 +1,6 @@\n Available passes for running rustdoc:\n check_doc_test_visibility - run various visibility-related lints on doctests\n         strip-hidden - strips all `#[doc(hidden)]` items from the output\n-   unindent-comments - removes excess indentation on comments in order for markdown to like it\n        strip-private - strips all private items from a crate which cannot be seen externally, implies strip-priv-imports\n   strip-priv-imports - strips all private import statements (`use`, `extern crate`) from a crate\n    propagate-doc-cfg - propagates `#[doc(cfg(...))]` to child items\n@@ -14,7 +13,6 @@ check-invalid-html-tags - detects invalid HTML tags in doc comments\n \n Default passes for rustdoc:\n  collect-trait-impls\n-   unindent-comments\n check_doc_test_visibility\n         strip-hidden  (when not --document-hidden-items)\n        strip-private  (when not --document-private-items)"}]}