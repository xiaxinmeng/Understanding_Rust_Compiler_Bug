{"sha": "0b5d39f2a204e5ec6cd6205440e4cdc763162814", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiNWQzOWYyYTIwNGU1ZWM2Y2Q2MjA1NDQwZTRjZGM3NjMxNjI4MTQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-01-20T20:25:34Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-01-20T20:25:34Z"}, "message": "Markers API", "tree": {"sha": "8d201ef62b5e4fe48e3cce7b557071e434530801", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8d201ef62b5e4fe48e3cce7b557071e434530801"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b5d39f2a204e5ec6cd6205440e4cdc763162814", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b5d39f2a204e5ec6cd6205440e4cdc763162814", "html_url": "https://github.com/rust-lang/rust/commit/0b5d39f2a204e5ec6cd6205440e4cdc763162814", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b5d39f2a204e5ec6cd6205440e4cdc763162814/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be60d5aa6669a74e92495288f44b7f9258a8518f", "url": "https://api.github.com/repos/rust-lang/rust/commits/be60d5aa6669a74e92495288f44b7f9258a8518f", "html_url": "https://github.com/rust-lang/rust/commit/be60d5aa6669a74e92495288f44b7f9258a8518f"}], "stats": {"total": 334, "additions": 189, "deletions": 145}, "files": [{"sha": "2d04a1a410ef2da15323012838c73154fe5ad1ab", "filename": "src/parser/event_parser/grammar/attributes.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0b5d39f2a204e5ec6cd6205440e4cdc763162814/src%2Fparser%2Fevent_parser%2Fgrammar%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b5d39f2a204e5ec6cd6205440e4cdc763162814/src%2Fparser%2Fevent_parser%2Fgrammar%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fevent_parser%2Fgrammar%2Fattributes.rs?ref=0b5d39f2a204e5ec6cd6205440e4cdc763162814", "patch": "@@ -19,13 +19,13 @@ fn attribute(p: &mut Parser, kind: AttrKind) -> bool {\n         if kind == AttrKind::Inner && p.raw_lookahead(1) != EXCL {\n             return false;\n         }\n-        p.start(ATTR);\n+        let attr = p.start();\n         p.bump();\n         if kind == AttrKind::Inner {\n             p.bump();\n         }\n         p.expect(L_BRACK) && meta_item(p) && p.expect(R_BRACK);\n-        p.finish();\n+        attr.complete(p, ATTR);\n         true\n     } else {\n         false\n@@ -34,7 +34,7 @@ fn attribute(p: &mut Parser, kind: AttrKind) -> bool {\n \n fn meta_item(p: &mut Parser) -> bool {\n     if p.at(IDENT) {\n-        p.start(META_ITEM);\n+        let meta_item = p.start();\n         p.bump();\n         if p.eat(EQ) {\n             if !expressions::literal(p) {\n@@ -46,7 +46,7 @@ fn meta_item(p: &mut Parser) -> bool {\n             comma_list(p, R_PAREN, meta_item_inner);\n             p.expect(R_PAREN);\n         }\n-        p.finish();\n+        meta_item.complete(p, META_ITEM);\n         true\n     } else {\n         false"}, {"sha": "a943b8c813a6db2c7edb881535bead865f0805f7", "filename": "src/parser/event_parser/grammar/expressions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b5d39f2a204e5ec6cd6205440e4cdc763162814/src%2Fparser%2Fevent_parser%2Fgrammar%2Fexpressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b5d39f2a204e5ec6cd6205440e4cdc763162814/src%2Fparser%2Fevent_parser%2Fgrammar%2Fexpressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fevent_parser%2Fgrammar%2Fexpressions.rs?ref=0b5d39f2a204e5ec6cd6205440e4cdc763162814", "patch": "@@ -6,9 +6,9 @@ pub(super) fn literal(p: &mut Parser) -> bool {\n         INT_NUMBER | FLOAT_NUMBER |\n         BYTE | CHAR |\n         STRING | RAW_STRING | BYTE_STRING | RAW_BYTE_STRING => {\n-            p.start(LITERAL);\n+            let lit = p.start();\n             p.bump();\n-            p.finish();\n+            lit.complete(p, LITERAL);\n             true\n         }\n         _ => false"}, {"sha": "c9a8905531330c83d1c1b28169643cce57f1f4d1", "filename": "src/parser/event_parser/grammar/items.rs", "status": "modified", "additions": 73, "deletions": 78, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/0b5d39f2a204e5ec6cd6205440e4cdc763162814/src%2Fparser%2Fevent_parser%2Fgrammar%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b5d39f2a204e5ec6cd6205440e4cdc763162814/src%2Fparser%2Fevent_parser%2Fgrammar%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fevent_parser%2Fgrammar%2Fitems.rs?ref=0b5d39f2a204e5ec6cd6205440e4cdc763162814", "patch": "@@ -8,19 +8,34 @@ pub(super) fn mod_contents(p: &mut Parser) {\n }\n \n fn item(p: &mut Parser) {\n-    let attrs_start = p.mark();\n+    let item = p.start();\n     attributes::outer_attributes(p);\n     visibility(p);\n     let la = p.raw_lookahead(1);\n-    let item_start = p.mark();\n-    match p.current() {\n-        EXTERN_KW if la == CRATE_KW => extern_crate_item(p),\n-        MOD_KW => mod_item(p),\n-        USE_KW => use_item(p),\n-        STRUCT_KW => struct_item(p),\n-        FN_KW => fn_item(p),\n+    let item_kind = match p.current() {\n+        EXTERN_KW if la == CRATE_KW => {\n+            extern_crate_item(p);\n+            EXTERN_CRATE_ITEM\n+        }\n+        MOD_KW => {\n+            mod_item(p);\n+            MOD_ITEM\n+        }\n+        USE_KW => {\n+            use_item(p);\n+            USE_ITEM\n+        }\n+        STRUCT_KW => {\n+            struct_item(p);\n+            STRUCT_ITEM\n+        }\n+        FN_KW => {\n+            fn_item(p);\n+            FN_ITEM\n+        }\n         err_token => {\n-            p.start(ERROR);\n+            item.abandon(p);\n+            let err = p.start();\n             let message = if err_token == SEMI {\n                 //TODO: if the item is incomplete, this message is misleading\n                 \"expected item, found `;`\\n\\\n@@ -32,60 +47,52 @@ fn item(p: &mut Parser) {\n                 .message(message)\n                 .emit();\n             p.bump();\n-            p.finish();\n+            err.complete(p, ERROR);\n             return;\n         }\n     };\n-    p.forward_parent(attrs_start, item_start);\n+    item.complete(p, item_kind);\n }\n \n fn struct_item(p: &mut Parser) {\n-    p.start(STRUCT_ITEM);\n-\n     assert!(p.at(STRUCT_KW));\n     p.bump();\n \n-    struct_inner(p);\n-    p.finish();\n-\n-    fn struct_inner(p: &mut Parser) {\n-        if !p.expect(IDENT) {\n-            p.finish();\n-            return;\n-        }\n-        generic_parameters(p);\n-        match p.current() {\n-            WHERE_KW => {\n-                where_clause(p);\n-                match p.current() {\n-                    SEMI => {\n-                        p.bump();\n-                        return;\n-                    }\n-                    L_CURLY => named_fields(p),\n-                    _ => { //TODO: special case `(` error message\n-                        p.error()\n-                            .message(\"expected `;` or `{`\")\n-                            .emit();\n-                        return;\n-                    }\n+    if !p.expect(IDENT) {\n+        return;\n+    }\n+    generic_parameters(p);\n+    match p.current() {\n+        WHERE_KW => {\n+            where_clause(p);\n+            match p.current() {\n+                SEMI => {\n+                    p.bump();\n+                    return;\n+                }\n+                L_CURLY => named_fields(p),\n+                _ => { //TODO: special case `(` error message\n+                    p.error()\n+                        .message(\"expected `;` or `{`\")\n+                        .emit();\n+                    return;\n                 }\n             }\n-            SEMI => {\n-                p.bump();\n-                return;\n-            }\n-            L_CURLY => named_fields(p),\n-            L_PAREN => {\n-                tuple_fields(p);\n-                p.expect(SEMI);\n-            }\n-            _ => {\n-                p.error()\n-                    .message(\"expected `;`, `{`, or `(`\")\n-                    .emit();\n-                return;\n-            }\n+        }\n+        SEMI => {\n+            p.bump();\n+            return;\n+        }\n+        L_CURLY => named_fields(p),\n+        L_PAREN => {\n+            pos_fields(p);\n+            p.expect(SEMI);\n+        }\n+        _ => {\n+            p.error()\n+                .message(\"expected `;`, `{`, or `(`\")\n+                .emit();\n+            return;\n         }\n     }\n }\n@@ -97,30 +104,30 @@ fn named_fields(p: &mut Parser) {\n     }));\n \n     fn named_field(p: &mut Parser) {\n-        p.start(NAMED_FIELD);\n+        let field = p.start();\n         visibility(p);\n         if p.expect(IDENT) && p.expect(COLON) {\n             types::type_ref(p);\n         };\n-        p.finish()\n+        field.complete(p, NAMED_FIELD);\n     }\n }\n \n-fn tuple_fields(p: &mut Parser) {\n+fn pos_fields(p: &mut Parser) {\n     if !p.expect(L_PAREN) {\n         return;\n     }\n     comma_list(p, R_PAREN, |p| {\n-        tuple_field(p);\n+        pos_field(p);\n         true\n     });\n     p.expect(R_PAREN);\n \n-    fn tuple_field(p: &mut Parser) {\n-        p.start(POS_FIELD);\n+    fn pos_field(p: &mut Parser) {\n+        let pos_field = p.start();\n         visibility(p);\n         types::type_ref(p);\n-        p.finish();\n+        pos_field.complete(p, POS_FIELD);\n     }\n }\n \n@@ -129,57 +136,46 @@ fn generic_parameters(_: &mut Parser) {}\n fn where_clause(_: &mut Parser) {}\n \n fn extern_crate_item(p: &mut Parser) {\n-    p.start(EXTERN_CRATE_ITEM);\n-\n     assert!(p.at(EXTERN_KW));\n     p.bump();\n-\n     assert!(p.at(CRATE_KW));\n     p.bump();\n \n     p.expect(IDENT) && alias(p) && p.expect(SEMI);\n-    p.finish();\n }\n \n fn mod_item(p: &mut Parser) {\n-    p.start(MOD_ITEM);\n-\n     assert!(p.at(MOD_KW));\n     p.bump();\n \n     if p.expect(IDENT) && !p.eat(SEMI) {\n         p.curly_block(mod_contents);\n     }\n-    p.finish()\n }\n \n pub(super) fn is_use_tree_start(kind: SyntaxKind) -> bool {\n     kind == STAR || kind == L_CURLY\n }\n \n fn use_item(p: &mut Parser) {\n-    p.start(USE_ITEM);\n-\n     assert!(p.at(USE_KW));\n     p.bump();\n+\n     use_tree(p);\n     p.expect(SEMI);\n-    p.finish();\n \n     fn use_tree(p: &mut Parser) -> bool {\n         let la = p.raw_lookahead(1);\n+        let m = p.start();\n         match (p.current(), la) {\n             (STAR, _) => {\n-                p.start(USE_TREE);\n                 p.bump();\n             }\n             (COLONCOLON, STAR) => {\n-                p.start(USE_TREE);\n                 p.bump();\n                 p.bump();\n             }\n             (L_CURLY, _) | (COLONCOLON, L_CURLY) => {\n-                p.start(USE_TREE);\n                 if p.at(COLONCOLON) {\n                     p.bump();\n                 }\n@@ -188,7 +184,6 @@ fn use_item(p: &mut Parser) {\n                 });\n             }\n             _ if paths::is_path_start(p) => {\n-                p.start(USE_TREE);\n                 paths::use_path(p);\n                 match p.current() {\n                     AS_KW => {\n@@ -216,23 +211,23 @@ fn use_item(p: &mut Parser) {\n                     _ => (),\n                 }\n             }\n-            _ => return false,\n+            _ => {\n+                m.abandon(p);\n+                return false\n+            },\n         }\n-        p.finish();\n+        m.complete(p, USE_TREE);\n         return true;\n     }\n }\n \n \n fn fn_item(p: &mut Parser) {\n-    p.start(FN_ITEM);\n-\n     assert!(p.at(FN_KW));\n     p.bump();\n \n     p.expect(IDENT) && p.expect(L_PAREN) && p.expect(R_PAREN)\n         && p.curly_block(|_| ());\n-    p.finish();\n }\n \n "}, {"sha": "d3b63c4c1d45c93194783f301adaafe96b789ad8", "filename": "src/parser/event_parser/grammar/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0b5d39f2a204e5ec6cd6205440e4cdc763162814/src%2Fparser%2Fevent_parser%2Fgrammar%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b5d39f2a204e5ec6cd6205440e4cdc763162814/src%2Fparser%2Fevent_parser%2Fgrammar%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fevent_parser%2Fgrammar%2Fmod.rs?ref=0b5d39f2a204e5ec6cd6205440e4cdc763162814", "patch": "@@ -10,15 +10,15 @@ mod types;\n mod paths;\n \n pub(crate) fn file(p: &mut Parser) {\n-    p.start(FILE);\n+    let file = p.start();\n     p.eat(SHEBANG);\n     items::mod_contents(p);\n-    p.finish()\n+    file.complete(p, FILE);\n }\n \n fn visibility(p: &mut Parser) {\n     if p.at(PUB_KW) {\n-        p.start(VISIBILITY);\n+        let vis = p.start();\n         p.bump();\n         if p.at(L_PAREN) {\n             match p.raw_lookahead(1) {\n@@ -32,16 +32,16 @@ fn visibility(p: &mut Parser) {\n                 _ => ()\n             }\n         }\n-        p.finish();\n+        vis.complete(p, VISIBILITY);\n     }\n }\n \n fn alias(p: &mut Parser) -> bool {\n     if p.at(AS_KW) {\n-        p.start(ALIAS);\n+        let alias = p.start();\n         p.bump();\n         p.expect(IDENT);\n-        p.finish();\n+        alias.complete(p, ALIAS);\n     }\n     true //FIXME: return false if three are errors\n }"}, {"sha": "b58c59aef96537653210b19beb9ea9fee9ca5970", "filename": "src/parser/event_parser/grammar/paths.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0b5d39f2a204e5ec6cd6205440e4cdc763162814/src%2Fparser%2Fevent_parser%2Fgrammar%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b5d39f2a204e5ec6cd6205440e4cdc763162814/src%2Fparser%2Fevent_parser%2Fgrammar%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fevent_parser%2Fgrammar%2Fpaths.rs?ref=0b5d39f2a204e5ec6cd6205440e4cdc763162814", "patch": "@@ -8,27 +8,24 @@ pub(crate) fn use_path(p: &mut Parser) {\n     if !is_path_start(p) {\n         return;\n     }\n-    let mut prev = p.mark();\n-    p.start(PATH);\n+    let path = p.start();\n     path_segment(p, true);\n-    p.finish();\n+    let mut qual = path.complete(p, PATH);\n     loop {\n-        let curr = p.mark();\n         if p.at(COLONCOLON) && !items::is_use_tree_start(p.raw_lookahead(1)) {\n-            p.start(PATH);\n+            let path = qual.precede(p);\n             p.bump();\n             path_segment(p, false);\n-            p.forward_parent(prev, curr);\n-            prev = curr;\n-            p.finish();\n+            let path = path.complete(p, PATH);\n+            qual = path;\n         } else {\n             break;\n         }\n     }\n }\n \n fn path_segment(p: &mut Parser, first: bool) {\n-    p.start(PATH_SEGMENT);\n+    let segment = p.start();\n     if first {\n         p.eat(COLONCOLON);\n     }\n@@ -42,5 +39,5 @@ fn path_segment(p: &mut Parser, first: bool) {\n                 .emit();\n         }\n     };\n-    p.finish();\n+    segment.complete(p, PATH_SEGMENT);\n }"}, {"sha": "7c81182e3e78083f94d9bc02bd802474494f2903", "filename": "src/parser/event_parser/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b5d39f2a204e5ec6cd6205440e4cdc763162814/src%2Fparser%2Fevent_parser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b5d39f2a204e5ec6cd6205440e4cdc763162814/src%2Fparser%2Fevent_parser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fevent_parser%2Fmod.rs?ref=0b5d39f2a204e5ec6cd6205440e4cdc763162814", "patch": "@@ -23,4 +23,4 @@ pub(crate) fn parse<'t>(text: &'t str, raw_tokens: &'t [Token]) -> Vec<Event> {\n     let mut parser = parser::Parser::new(text, raw_tokens);\n     grammar::file(&mut parser);\n     parser.into_events()\n-}\n\\ No newline at end of file\n+}"}, {"sha": "2bc9dd34f50f9087b71290508f0137dc6ed342a4", "filename": "src/parser/event_parser/parser.rs", "status": "modified", "additions": 76, "deletions": 36, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/0b5d39f2a204e5ec6cd6205440e4cdc763162814/src%2Fparser%2Fevent_parser%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b5d39f2a204e5ec6cd6205440e4cdc763162814/src%2Fparser%2Fevent_parser%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fevent_parser%2Fparser.rs?ref=0b5d39f2a204e5ec6cd6205440e4cdc763162814", "patch": "@@ -1,8 +1,71 @@\n use {Token, SyntaxKind, TextUnit};\n-use super::{Event};\n+use super::Event;\n use super::super::is_insignificant;\n use syntax_kinds::{L_CURLY, R_CURLY, ERROR};\n-use tree::EOF;\n+use tree::{EOF, TOMBSTONE};\n+\n+pub(crate) struct Marker {\n+    pos: u32\n+}\n+\n+impl Marker {\n+    pub fn complete(self, p: &mut Parser, kind: SyntaxKind) -> CompleteMarker {\n+        match self.event(p) {\n+            &mut Event::Start { kind: ref mut slot, ..} => {\n+                *slot = kind;\n+            }\n+            _ => unreachable!(),\n+        }\n+        p.event(Event::Finish);\n+        let result = CompleteMarker { pos: self.pos };\n+        ::std::mem::forget(self);\n+        result\n+    }\n+\n+    pub fn abandon(self, p: &mut Parser) {\n+        let idx = self.pos as usize;\n+        if idx == p.events.len() - 1 {\n+            match p.events.pop() {\n+                Some(Event::Start { kind: TOMBSTONE, forward_parent: None }) => (),\n+                _ => unreachable!()\n+            }\n+        }\n+        ::std::mem::forget(self);\n+    }\n+\n+    fn event<'p>(&self, p: &'p mut Parser) -> &'p mut Event {\n+        &mut p.events[self.idx()]\n+    }\n+\n+    fn idx(&self) -> usize {\n+        self.pos as usize\n+    }\n+}\n+\n+impl Drop for Marker {\n+    fn drop(&mut self) {\n+        if !::std::thread::panicking() {\n+            panic!(\"Each marker should be eithe completed or abandoned\");\n+        }\n+    }\n+}\n+\n+pub(crate) struct CompleteMarker {\n+    pos: u32\n+}\n+\n+impl CompleteMarker {\n+    pub(crate) fn precede(self, p: &mut Parser) -> Marker {\n+        let m = p.start();\n+        match p.events[self.pos as usize] {\n+            Event::Start { ref mut forward_parent, ..} => {\n+                *forward_parent = Some(m.pos - self.pos);\n+            }\n+            _ => unreachable!(),\n+        }\n+        m\n+    }\n+}\n \n \n pub(crate) struct Parser<'t> {\n@@ -19,12 +82,9 @@ pub(crate) struct Parser<'t> {\n     curly_limit: Option<i32>,\n }\n \n-#[derive(Debug, Clone, Copy,PartialEq, Eq)]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n pub(crate) struct Pos(u32);\n \n-#[derive(Debug, Clone, Copy,PartialEq, Eq)]\n-pub(crate) struct Mark(u32);\n-\n impl<'t> Parser<'t> {\n     pub(crate) fn new(text: &'t str, raw_tokens: &'t [Token]) -> Parser<'t> {\n         let mut tokens = Vec::new();\n@@ -50,31 +110,13 @@ impl<'t> Parser<'t> {\n         }\n     }\n \n-    pub(crate) fn mark(&self) -> Mark {\n-        Mark(self.events.len() as u32)\n-    }\n-\n-    pub(crate) fn forward_parent(&mut self, child: Mark, parent: Mark) {\n-        if child == parent || parent == self.mark() {\n-            return\n-        }\n-        assert!(child.0 < parent.0);\n-        let diff = parent.0 - child.0;\n-        match self.events[child.0 as usize] {\n-            Event::Start { ref mut forward_parent, .. } => {\n-                *forward_parent = Some(diff);\n-            }\n-            _ => unreachable!()\n-        }\n-    }\n-\n     pub(crate) fn pos(&self) -> Pos {\n         Pos(self.pos as u32)\n     }\n \n     pub(crate) fn into_events(self) -> Vec<Event> {\n         assert!(self.curly_limit.is_none());\n-        assert!(self.current() == EOF);\n+        assert_eq!(self.current(), EOF);\n         self.events\n     }\n \n@@ -85,18 +127,16 @@ impl<'t> Parser<'t> {\n         let token = self.tokens[self.pos];\n         if let Some(limit) = self.curly_limit {\n             if limit == self.curly_level && token.kind == R_CURLY {\n-                return EOF\n+                return EOF;\n             }\n         }\n         token.kind\n     }\n \n-    pub(crate) fn start(&mut self, kind: SyntaxKind) {\n-        self.event(Event::Start { kind, forward_parent: None });\n-    }\n-\n-    pub(crate) fn finish(&mut self) {\n-        self.event(Event::Finish);\n+    pub(crate) fn start(&mut self) -> Marker {\n+        let m = Marker { pos: self.events.len() as u32 };\n+        self.event(Event::Start { kind: TOMBSTONE, forward_parent: None });\n+        m\n     }\n \n     pub(crate) fn error<'p>(&'p mut self) -> ErrorBuilder<'p, 't> {\n@@ -124,20 +164,20 @@ impl<'t> Parser<'t> {\n         let old_level = self.curly_level;\n         let old_limit = self.curly_limit;\n         if !self.expect(L_CURLY) {\n-            return false\n+            return false;\n         }\n         self.curly_limit = Some(self.curly_level);\n         f(self);\n         assert!(self.curly_level > old_level);\n         self.curly_limit = old_limit;\n         if !self.expect(R_CURLY) {\n-            self.start(ERROR);\n+            let err = self.start();\n             while self.curly_level > old_level {\n                 if self.bump() == EOF {\n                     break;\n                 }\n             }\n-            self.finish();\n+            err.complete(self, ERROR);\n         }\n         true\n     }\n@@ -149,7 +189,7 @@ impl<'t> Parser<'t> {\n \n pub(crate) struct ErrorBuilder<'p, 't: 'p> {\n     message: Option<String>,\n-    parser: &'p mut Parser<'t>\n+    parser: &'p mut Parser<'t>,\n }\n \n impl<'t, 'p> ErrorBuilder<'p, 't> {"}, {"sha": "5ec4b8e93a9e33f57f692317246668e2293f6306", "filename": "src/parser/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0b5d39f2a204e5ec6cd6205440e4cdc763162814/src%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b5d39f2a204e5ec6cd6205440e4cdc763162814/src%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fmod.rs?ref=0b5d39f2a204e5ec6cd6205440e4cdc763162814", "patch": "@@ -1,6 +1,7 @@\n use {Token, File, FileBuilder, Sink, SyntaxKind};\n \n use syntax_kinds::*;\n+use tree::TOMBSTONE;\n \n mod event_parser;\n use self::event_parser::Event;\n@@ -29,6 +30,8 @@ fn from_events_to_file(\n         }\n \n         match event {\n+            &Event::Start { kind: TOMBSTONE, .. } => (),\n+\n             &Event::Start { .. } => {\n                 forward_parents.clear();\n                 let mut idx = i;\n@@ -62,7 +65,7 @@ fn from_events_to_file(\n                 }\n                 builder.finish_internal()\n             },\n-            &Event::Token { kind, mut n_raw_tokens } => loop {\n+            &Event::Token { kind: _, mut n_raw_tokens } => loop {\n                 let token = tokens[idx];\n                 if !is_insignificant(token.kind) {\n                     n_raw_tokens -= 1;"}, {"sha": "35702ddd76995807f5e759a54491680d086b5534", "filename": "src/tree/file_builder.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0b5d39f2a204e5ec6cd6205440e4cdc763162814/src%2Ftree%2Ffile_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b5d39f2a204e5ec6cd6205440e4cdc763162814/src%2Ftree%2Ffile_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftree%2Ffile_builder.rs?ref=0b5d39f2a204e5ec6cd6205440e4cdc763162814", "patch": "@@ -48,7 +48,9 @@ impl Sink for FileBuilder {\n     }\n \n     fn finish_internal(&mut self) {\n-        let (id, _) = self.in_progress.pop().unwrap();\n+        let (id, _) = self.in_progress.pop().expect(\n+            \"trying to complete a node, but there are no in-progress nodes\"\n+        );\n         if !self.in_progress.is_empty() {\n             self.add_len(id);\n         }\n@@ -77,8 +79,8 @@ impl FileBuilder {\n             self.in_progress.iter().map(|&(idx, _)| self.nodes[idx].kind)\n                 .collect::<Vec<_>>()\n         );\n-        assert!(\n-            self.pos == (self.text.len() as u32).into(),\n+        assert_eq!(\n+            self.pos, (self.text.len() as u32).into(),\n             \"nodes in FileBuilder do not cover the whole file\"\n         );\n         File {"}, {"sha": "3315b926ed673f5270249ef6e871edf33c3b26b7", "filename": "src/tree/mod.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0b5d39f2a204e5ec6cd6205440e4cdc763162814/src%2Ftree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b5d39f2a204e5ec6cd6205440e4cdc763162814/src%2Ftree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftree%2Fmod.rs?ref=0b5d39f2a204e5ec6cd6205440e4cdc763162814", "patch": "@@ -10,17 +10,24 @@ pub use self::file_builder::{FileBuilder, Sink};\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct SyntaxKind(pub(crate) u32);\n \n-pub(crate) const EOF: SyntaxKind = SyntaxKind(10000);\n+pub(crate) const EOF: SyntaxKind = SyntaxKind(!0);\n pub(crate) const EOF_INFO: SyntaxInfo = SyntaxInfo {\n     name: \"EOF\"\n };\n \n+pub(crate) const TOMBSTONE: SyntaxKind = SyntaxKind(!0 - 1);\n+pub(crate) const TOMBSTONE_INFO: SyntaxInfo = SyntaxInfo {\n+    name: \"TOMBSTONE\"\n+};\n+\n+\n impl SyntaxKind {\n     fn info(self) -> &'static SyntaxInfo {\n-        if self == EOF {\n-            return &EOF_INFO;\n+        match self {\n+            EOF => &EOF_INFO,\n+            TOMBSTONE => &TOMBSTONE_INFO,\n+            _ => syntax_info(self),\n         }\n-        syntax_info(self)\n     }\n }\n "}]}