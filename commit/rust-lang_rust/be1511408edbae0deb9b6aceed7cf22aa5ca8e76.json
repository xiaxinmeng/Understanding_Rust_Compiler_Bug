{"sha": "be1511408edbae0deb9b6aceed7cf22aa5ca8e76", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlMTUxMTQwOGVkYmFlMGRlYjliNmFjZWVkN2NmMjJhYTVjYThlNzY=", "commit": {"author": {"name": "Julian Orth", "email": "ju.orth@gmail.com", "date": "2020-12-19T18:08:03Z"}, "committer": {"name": "Julian Orth", "email": "ju.orth@gmail.com", "date": "2020-12-19T19:43:15Z"}, "message": "Optimize DST field access\n\nFor\n\n    struct X<T: ?Sized>(T)\n    struct Y<T: ?Sized>(u8, T)\n\nthe offset of the unsized field is\n\n    0\n    mem::align_of_val(&self.1)\n\nrespectively. This patch changes the expression used to compute these\noffsets so that the optimizer can perform this optimization.\n\nConsider\n\n```rust\nfn test(x: &X<dyn Any>) -> &dyn Any {\n    &x.0\n}\n```\n\nBefore:\n\n```asm\ntest:\n\tmovq\t%rsi, %rdx\n\tmovq\t16(%rsi), %rax\n\tleaq\t-1(%rax), %rcx\n\tnegq\t%rax\n\tandq\t%rcx, %rax\n\taddq\t%rdi, %rax\n\tretq\n```\n\nAfter:\n\n```asm\ntest:\n\tmovq\t%rsi, %rdx\n\tmovq\t%rdi, %rax\n\tretq\n```", "tree": {"sha": "9d7cacbcc0f85ec877e3a115db46766bc49d27ba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d7cacbcc0f85ec877e3a115db46766bc49d27ba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be1511408edbae0deb9b6aceed7cf22aa5ca8e76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be1511408edbae0deb9b6aceed7cf22aa5ca8e76", "html_url": "https://github.com/rust-lang/rust/commit/be1511408edbae0deb9b6aceed7cf22aa5ca8e76", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be1511408edbae0deb9b6aceed7cf22aa5ca8e76/comments", "author": {"login": "mahkoh", "id": 1882250, "node_id": "MDQ6VXNlcjE4ODIyNTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1882250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mahkoh", "html_url": "https://github.com/mahkoh", "followers_url": "https://api.github.com/users/mahkoh/followers", "following_url": "https://api.github.com/users/mahkoh/following{/other_user}", "gists_url": "https://api.github.com/users/mahkoh/gists{/gist_id}", "starred_url": "https://api.github.com/users/mahkoh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mahkoh/subscriptions", "organizations_url": "https://api.github.com/users/mahkoh/orgs", "repos_url": "https://api.github.com/users/mahkoh/repos", "events_url": "https://api.github.com/users/mahkoh/events{/privacy}", "received_events_url": "https://api.github.com/users/mahkoh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mahkoh", "id": 1882250, "node_id": "MDQ6VXNlcjE4ODIyNTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1882250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mahkoh", "html_url": "https://github.com/mahkoh", "followers_url": "https://api.github.com/users/mahkoh/followers", "following_url": "https://api.github.com/users/mahkoh/following{/other_user}", "gists_url": "https://api.github.com/users/mahkoh/gists{/gist_id}", "starred_url": "https://api.github.com/users/mahkoh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mahkoh/subscriptions", "organizations_url": "https://api.github.com/users/mahkoh/orgs", "repos_url": "https://api.github.com/users/mahkoh/repos", "events_url": "https://api.github.com/users/mahkoh/events{/privacy}", "received_events_url": "https://api.github.com/users/mahkoh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8bb302d34dde36cc78a288cb5beb4af7fe30ba41", "url": "https://api.github.com/repos/rust-lang/rust/commits/8bb302d34dde36cc78a288cb5beb4af7fe30ba41", "html_url": "https://github.com/rust-lang/rust/commit/8bb302d34dde36cc78a288cb5beb4af7fe30ba41"}], "stats": {"total": 54, "additions": 44, "deletions": 10}, "files": [{"sha": "3c0cddf10bf020e24b99978a52cf96854b91470e", "filename": "compiler/rustc_codegen_ssa/src/mir/place.rs", "status": "modified", "additions": 44, "deletions": 10, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/be1511408edbae0deb9b6aceed7cf22aa5ca8e76/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be1511408edbae0deb9b6aceed7cf22aa5ca8e76/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs?ref=be1511408edbae0deb9b6aceed7cf22aa5ca8e76", "patch": "@@ -178,16 +178,8 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n         // Get the alignment of the field\n         let (_, unsized_align) = glue::size_and_align_of_dst(bx, field.ty, meta);\n \n-        // Bump the unaligned offset up to the appropriate alignment using the\n-        // following expression:\n-        //\n-        //     (unaligned offset + (align - 1)) & -align\n-\n-        // Calculate offset.\n-        let align_sub_1 = bx.sub(unsized_align, bx.cx().const_usize(1u64));\n-        let and_lhs = bx.add(unaligned_offset, align_sub_1);\n-        let and_rhs = bx.neg(unsized_align);\n-        let offset = bx.and(and_lhs, and_rhs);\n+        // Bump the unaligned offset up to the appropriate alignment\n+        let offset = round_up_const_value_to_alignment(bx, unaligned_offset, unsized_align);\n \n         debug!(\"struct_field_ptr: DST field offset: {:?}\", offset);\n \n@@ -518,3 +510,45 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         self.monomorphize(place_ty.ty)\n     }\n }\n+\n+fn round_up_const_value_to_alignment<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &mut Bx,\n+    value: Bx::Value,\n+    align: Bx::Value,\n+) -> Bx::Value {\n+    // In pseudo code:\n+    //\n+    //     if value & (align - 1) == 0 {\n+    //         value\n+    //     } else {\n+    //         (value & !(align - 1)) + align\n+    //     }\n+    //\n+    // Usually this is written without branches as\n+    //\n+    //     (value + align - 1) & !(align - 1)\n+    //\n+    // But this formula cannot take advantage of constant `value`. E.g. if `value` is known\n+    // at compile time to be `1`, this expression should be optimized to `align`. However,\n+    // optimization only holds if `align` is a power of two. Since the optimizer doesn't know\n+    // that `align` is a power of two, it cannot perform this optimization.\n+    //\n+    // Instead we use\n+    //\n+    //     value + (-value & (align - 1))\n+    //\n+    // Since `align` is used only once, the expression can be optimized. For `value = 0`\n+    // its optimized to `0` even in debug mode.\n+    //\n+    // NB: The previous version of this code used\n+    //\n+    //     (value + align - 1) & -align\n+    //\n+    // Even though `-align == !(align - 1)`, LLVM failed to optimize this even for\n+    // `value = 0`. Bug report: https://bugs.llvm.org/show_bug.cgi?id=48559\n+    let one = bx.const_usize(1);\n+    let align_minus_1 = bx.sub(align, one);\n+    let neg_value = bx.neg(value);\n+    let offset = bx.and(neg_value, align_minus_1);\n+    bx.add(value, offset)\n+}"}]}