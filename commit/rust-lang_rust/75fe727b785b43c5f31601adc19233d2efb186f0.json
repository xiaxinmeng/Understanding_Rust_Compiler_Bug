{"sha": "75fe727b785b43c5f31601adc19233d2efb186f0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1ZmU3MjdiNzg1YjQzYzVmMzE2MDFhZGMxOTIzM2QyZWZiMTg2ZjA=", "commit": {"author": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2016-12-12T02:51:22Z"}, "committer": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2016-12-13T05:44:09Z"}, "message": "Implement RFC #1725\n\ncc #37955", "tree": {"sha": "601862196601c2f65aca6c8bd8f08ccf9e4a0b96", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/601862196601c2f65aca6c8bd8f08ccf9e4a0b96"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75fe727b785b43c5f31601adc19233d2efb186f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75fe727b785b43c5f31601adc19233d2efb186f0", "html_url": "https://github.com/rust-lang/rust/commit/75fe727b785b43c5f31601adc19233d2efb186f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75fe727b785b43c5f31601adc19233d2efb186f0/comments", "author": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3db197aa9d343c7974b06a9b18ae5f78d5c64637", "url": "https://api.github.com/repos/rust-lang/rust/commits/3db197aa9d343c7974b06a9b18ae5f78d5c64637", "html_url": "https://github.com/rust-lang/rust/commit/3db197aa9d343c7974b06a9b18ae5f78d5c64637"}], "stats": {"total": 107, "additions": 107, "deletions": 0}, "files": [{"sha": "e3ca8eca76c570979eaa607bb4f422368985863d", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/75fe727b785b43c5f31601adc19233d2efb186f0/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75fe727b785b43c5f31601adc19233d2efb186f0/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=75fe727b785b43c5f31601adc19233d2efb186f0", "patch": "@@ -117,6 +117,8 @@ pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T {\n /// `zero_memory`, or `copy_memory`). Note that `*src = foo` counts as a use\n /// because it will attempt to drop the value previously at `*src`.\n ///\n+/// The pointer must be aligned; use `read_unaligned` if that is not the case.\n+///\n /// # Examples\n ///\n /// Basic usage:\n@@ -137,6 +139,44 @@ pub unsafe fn read<T>(src: *const T) -> T {\n     tmp\n }\n \n+/// Reads the value from `src` without moving it. This leaves the\n+/// memory in `src` unchanged.\n+///\n+/// Unlike `read`, the pointer may be unaligned.\n+///\n+/// # Safety\n+///\n+/// Beyond accepting a raw pointer, this is unsafe because it semantically\n+/// moves the value out of `src` without preventing further usage of `src`.\n+/// If `T` is not `Copy`, then care must be taken to ensure that the value at\n+/// `src` is not used before the data is overwritten again (e.g. with `write`,\n+/// `zero_memory`, or `copy_memory`). Note that `*src = foo` counts as a use\n+/// because it will attempt to drop the value previously at `*src`.\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// #![feature(ptr_unaligned)]\n+///\n+/// let x = 12;\n+/// let y = &x as *const i32;\n+///\n+/// unsafe {\n+///     assert_eq!(std::ptr::read_unaligned(y), 12);\n+/// }\n+/// ```\n+#[inline(always)]\n+#[unstable(feature = \"ptr_unaligned\", issue = \"37955\")]\n+pub unsafe fn read_unaligned<T>(src: *const T) -> T {\n+    let mut tmp: T = mem::uninitialized();\n+    copy_nonoverlapping(src as *const u8,\n+                        &mut tmp as *mut T as *mut u8,\n+                        mem::size_of::<T>());\n+    tmp\n+}\n+\n /// Overwrites a memory location with the given value without reading or\n /// dropping the old value.\n ///\n@@ -151,6 +191,8 @@ pub unsafe fn read<T>(src: *const T) -> T {\n /// This is appropriate for initializing uninitialized memory, or overwriting\n /// memory that has previously been `read` from.\n ///\n+/// The pointer must be aligned; use `write_unaligned` if that is not the case.\n+///\n /// # Examples\n ///\n /// Basic usage:\n@@ -171,6 +213,47 @@ pub unsafe fn write<T>(dst: *mut T, src: T) {\n     intrinsics::move_val_init(&mut *dst, src)\n }\n \n+/// Overwrites a memory location with the given value without reading or\n+/// dropping the old value.\n+///\n+/// Unlike `write`, the pointer may be unaligned.\n+///\n+/// # Safety\n+///\n+/// This operation is marked unsafe because it accepts a raw pointer.\n+///\n+/// It does not drop the contents of `dst`. This is safe, but it could leak\n+/// allocations or resources, so care must be taken not to overwrite an object\n+/// that should be dropped.\n+///\n+/// This is appropriate for initializing uninitialized memory, or overwriting\n+/// memory that has previously been `read` from.\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// #![feature(ptr_unaligned)]\n+///\n+/// let mut x = 0;\n+/// let y = &mut x as *mut i32;\n+/// let z = 12;\n+///\n+/// unsafe {\n+///     std::ptr::write_unaligned(y, z);\n+///     assert_eq!(std::ptr::read_unaligned(y), 12);\n+/// }\n+/// ```\n+#[inline]\n+#[unstable(feature = \"ptr_unaligned\", issue = \"37955\")]\n+pub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n+    copy_nonoverlapping(&src as *const T as *const u8,\n+                        dst as *mut u8,\n+                        mem::size_of::<T>());\n+    mem::forget(src);\n+}\n+\n /// Performs a volatile read of the value from `src` without moving it. This\n /// leaves the memory in `src` unchanged.\n ///"}, {"sha": "5b6686309a4b3eef8bf56813609a1c57528a579e", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/75fe727b785b43c5f31601adc19233d2efb186f0/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75fe727b785b43c5f31601adc19233d2efb186f0/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=75fe727b785b43c5f31601adc19233d2efb186f0", "patch": "@@ -36,6 +36,7 @@\n #![feature(iter_min_by)]\n #![feature(ordering_chaining)]\n #![feature(result_unwrap_or_default)]\n+#![feature(ptr_unaligned)]\n \n extern crate core;\n extern crate test;"}, {"sha": "7f6f472bfbb78ea5588f7a770a61792f95bc6f1a", "filename": "src/libcoretest/ptr.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/75fe727b785b43c5f31601adc19233d2efb186f0/src%2Flibcoretest%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75fe727b785b43c5f31601adc19233d2efb186f0/src%2Flibcoretest%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fptr.rs?ref=75fe727b785b43c5f31601adc19233d2efb186f0", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use core::ptr::*;\n+use core::cell::RefCell;\n \n #[test]\n fn test() {\n@@ -189,3 +190,25 @@ pub fn test_variadic_fnptr() {\n     let mut s = SipHasher::new();\n     assert_eq!(p.hash(&mut s), q.hash(&mut s));\n }\n+\n+#[test]\n+fn write_unaligned_drop() {\n+    thread_local! {\n+        static DROPS: RefCell<Vec<u32>> = RefCell::new(Vec::new());\n+    }\n+\n+    struct Dropper(u32);\n+\n+    impl Drop for Dropper {\n+        fn drop(&mut self) {\n+            DROPS.with(|d| d.borrow_mut().push(self.0));\n+        }\n+    }\n+\n+    {\n+        let c = Dropper(0);\n+        let mut t = Dropper(1);\n+        unsafe { write_unaligned(&mut t, c); }\n+    }\n+    DROPS.with(|d| assert_eq!(*d.borrow(), [0]));\n+}"}]}