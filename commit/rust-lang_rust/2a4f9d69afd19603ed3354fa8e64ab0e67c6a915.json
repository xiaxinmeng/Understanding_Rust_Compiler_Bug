{"sha": "2a4f9d69afd19603ed3354fa8e64ab0e67c6a915", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhNGY5ZDY5YWZkMTk2MDNlZDMzNTRmYThlNjRhYjBlNjdjNmE5MTU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-28T01:50:16Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-28T07:09:31Z"}, "message": "Implement native TCP I/O", "tree": {"sha": "411a20151bace8706b50d0e19aa682cfee652ee3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/411a20151bace8706b50d0e19aa682cfee652ee3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a4f9d69afd19603ed3354fa8e64ab0e67c6a915", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a4f9d69afd19603ed3354fa8e64ab0e67c6a915", "html_url": "https://github.com/rust-lang/rust/commit/2a4f9d69afd19603ed3354fa8e64ab0e67c6a915", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a4f9d69afd19603ed3354fa8e64ab0e67c6a915/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1763f36c9d47550838793e129f2297ecfc8bebd1", "url": "https://api.github.com/repos/rust-lang/rust/commits/1763f36c9d47550838793e129f2297ecfc8bebd1", "html_url": "https://github.com/rust-lang/rust/commit/1763f36c9d47550838793e129f2297ecfc8bebd1"}], "stats": {"total": 918, "additions": 825, "deletions": 93}, "files": [{"sha": "6197bd70c76109dddb14b46b73274d255522ed0a", "filename": "src/libnative/io/file.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2a4f9d69afd19603ed3354fa8e64ab0e67c6a915/src%2Flibnative%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a4f9d69afd19603ed3354fa8e64ab0e67c6a915/src%2Flibnative%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile.rs?ref=2a4f9d69afd19603ed3354fa8e64ab0e67c6a915", "patch": "@@ -26,7 +26,7 @@ use super::IoResult;\n #[cfg(windows)] use std::ptr;\n #[cfg(windows)] use std::str;\n \n-fn keep_going(data: &[u8], f: |*u8, uint| -> i64) -> i64 {\n+pub fn keep_going(data: &[u8], f: |*u8, uint| -> i64) -> i64 {\n     #[cfg(windows)] static eintr: int = 0; // doesn't matter\n     #[cfg(not(windows))] static eintr: int = libc::EINTR as int;\n \n@@ -92,7 +92,7 @@ impl FileDesc {\n             Ok(ret as uint)\n         }\n     }\n-    fn inner_write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+    pub fn inner_write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n         #[cfg(windows)] type wlen = libc::c_uint;\n         #[cfg(not(windows))] type wlen = libc::size_t;\n         let ret = keep_going(buf, |buf, len| {\n@@ -106,6 +106,8 @@ impl FileDesc {\n             Ok(())\n         }\n     }\n+\n+    pub fn fd(&self) -> fd_t { self.fd }\n }\n \n impl io::Reader for FileDesc {\n@@ -902,7 +904,7 @@ pub fn utime(p: &CString, atime: u64, mtime: u64) -> IoResult<()> {\n \n #[cfg(test)]\n mod tests {\n-    use super::{CFile, FileDesc, CloseFd};\n+    use super::{CFile, FileDesc};\n     use std::io;\n     use std::libc;\n     use std::os;"}, {"sha": "9e76dea5ebf7391b92ae73550dfedf65bba61a9a", "filename": "src/libnative/io/mod.rs", "status": "modified", "additions": 43, "deletions": 10, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/2a4f9d69afd19603ed3354fa8e64ab0e67c6a915/src%2Flibnative%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a4f9d69afd19603ed3354fa8e64ab0e67c6a915/src%2Flibnative%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fmod.rs?ref=2a4f9d69afd19603ed3354fa8e64ab0e67c6a915", "patch": "@@ -44,6 +44,7 @@ pub use self::process::Process;\n // Native I/O implementations\n pub mod file;\n pub mod process;\n+pub mod net;\n \n type IoResult<T> = Result<T, IoError>;\n \n@@ -60,7 +61,20 @@ fn translate_error(errno: i32, detail: bool) -> IoError {\n     fn get_err(errno: i32) -> (io::IoErrorKind, &'static str) {\n         match errno {\n             libc::EOF => (io::EndOfFile, \"end of file\"),\n-            _ => (io::OtherIoError, \"unknown error\"),\n+            libc::WSAECONNREFUSED => (io::ConnectionRefused, \"connection refused\"),\n+            libc::WSAECONNRESET => (io::ConnectionReset, \"connection reset\"),\n+            libc::WSAEACCES => (io::PermissionDenied, \"permission denied\"),\n+            libc::WSAEWOULDBLOCK =>\n+                (io::ResourceUnavailable, \"resource temporarily unavailable\"),\n+            libc::WSAENOTCONN => (io::NotConnected, \"not connected\"),\n+            libc::WSAECONNABORTED => (io::ConnectionAborted, \"connection aborted\"),\n+            libc::WSAEADDRNOTAVAIL => (io::ConnectionRefused, \"address not available\"),\n+            libc::WSAEADDRINUSE => (io::ConnectionRefused, \"address in use\"),\n+\n+            x => {\n+                debug!(\"ignoring {}: {}\", x, os::last_os_error());\n+                (io::OtherIoError, \"unknown error\")\n+            }\n         }\n     }\n \n@@ -69,13 +83,25 @@ fn translate_error(errno: i32, detail: bool) -> IoError {\n         // XXX: this should probably be a bit more descriptive...\n         match errno {\n             libc::EOF => (io::EndOfFile, \"end of file\"),\n+            libc::ECONNREFUSED => (io::ConnectionRefused, \"connection refused\"),\n+            libc::ECONNRESET => (io::ConnectionReset, \"connection reset\"),\n+            libc::EPERM | libc::EACCES =>\n+                (io::PermissionDenied, \"permission denied\"),\n+            libc::EPIPE => (io::BrokenPipe, \"broken pipe\"),\n+            libc::ENOTCONN => (io::NotConnected, \"not connected\"),\n+            libc::ECONNABORTED => (io::ConnectionAborted, \"connection aborted\"),\n+            libc::EADDRNOTAVAIL => (io::ConnectionRefused, \"address not available\"),\n+            libc::EADDRINUSE => (io::ConnectionRefused, \"address in use\"),\n \n             // These two constants can have the same value on some systems, but\n             // different values on others, so we can't use a match clause\n             x if x == libc::EAGAIN || x == libc::EWOULDBLOCK =>\n                 (io::ResourceUnavailable, \"resource temporarily unavailable\"),\n \n-            _ => (io::OtherIoError, \"unknown error\"),\n+            x => {\n+                debug!(\"ignoring {}: {}\", x, os::last_os_error());\n+                (io::OtherIoError, \"unknown error\")\n+            }\n         }\n     }\n \n@@ -121,15 +147,24 @@ fn retry(f: || -> libc::c_int) -> IoResult<libc::c_int> {\n \n /// Implementation of rt::rtio's IoFactory trait to generate handles to the\n /// native I/O functionality.\n-pub struct IoFactory;\n+pub struct IoFactory {\n+    priv cannot_construct_outside_of_this_module: ()\n+}\n+\n+impl IoFactory {\n+    pub fn new() -> IoFactory {\n+        net::init();\n+        IoFactory { cannot_construct_outside_of_this_module: () }\n+    }\n+}\n \n impl rtio::IoFactory for IoFactory {\n     // networking\n-    fn tcp_connect(&mut self, _addr: SocketAddr) -> IoResult<~RtioTcpStream> {\n-        Err(unimpl())\n+    fn tcp_connect(&mut self, addr: SocketAddr) -> IoResult<~RtioTcpStream> {\n+        net::TcpStream::connect(addr).map(|s| ~s as ~RtioTcpStream)\n     }\n-    fn tcp_bind(&mut self, _addr: SocketAddr) -> IoResult<~RtioTcpListener> {\n-        Err(unimpl())\n+    fn tcp_bind(&mut self, addr: SocketAddr) -> IoResult<~RtioTcpListener> {\n+        net::TcpListener::bind(addr).map(|s| ~s as ~RtioTcpListener)\n     }\n     fn udp_bind(&mut self, _addr: SocketAddr) -> IoResult<~RtioUdpSocket> {\n         Err(unimpl())\n@@ -217,9 +252,7 @@ impl rtio::IoFactory for IoFactory {\n     }\n     fn tty_open(&mut self, fd: c_int, _readable: bool) -> IoResult<~RtioTTY> {\n         if unsafe { libc::isatty(fd) } != 0 {\n-            // Don't ever close the stdio file descriptors, nothing good really\n-            // comes of that.\n-            Ok(~file::FileDesc::new(fd, fd > libc::STDERR_FILENO) as ~RtioTTY)\n+            Ok(~file::FileDesc::new(fd, true) as ~RtioTTY)\n         } else {\n             Err(IoError {\n                 kind: io::MismatchedFileTypeForOperation,"}, {"sha": "aaa95ce0cfbe2d95367df9f8c61deaa1b0d69fac", "filename": "src/libnative/io/net.rs", "status": "added", "additions": 412, "deletions": 0, "changes": 412, "blob_url": "https://github.com/rust-lang/rust/blob/2a4f9d69afd19603ed3354fa8e64ab0e67c6a915/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a4f9d69afd19603ed3354fa8e64ab0e67c6a915/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=2a4f9d69afd19603ed3354fa8e64ab0e67c6a915", "patch": "@@ -0,0 +1,412 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::cast;\n+use std::io::net::ip;\n+use std::io;\n+use std::libc;\n+use std::mem;\n+use std::rt::rtio;\n+use std::unstable::intrinsics;\n+\n+use super::IoResult;\n+use super::file::keep_going;\n+\n+#[cfg(windows)] pub type sock_t = libc::SOCKET;\n+#[cfg(unix)]    pub type sock_t = super::file::fd_t;\n+\n+pub struct TcpStream {\n+    priv fd: sock_t,\n+}\n+\n+#[cfg(target_endian = \"big\")] pub fn htons(x: u16) -> u16 { x }\n+#[cfg(target_endian = \"big\")] pub fn ntohs(x: u16) -> u16 { x }\n+#[cfg(target_endian = \"little\")]\n+pub fn htons(u: u16) -> u16 {\n+    unsafe { intrinsics::bswap16(u as i16) as u16 }\n+}\n+#[cfg(target_endian = \"little\")]\n+pub fn ntohs(u: u16) -> u16 {\n+    unsafe { intrinsics::bswap16(u as i16) as u16 }\n+}\n+\n+fn addr_to_sockaddr(addr: ip::SocketAddr) -> (libc::sockaddr_storage, uint) {\n+    unsafe {\n+        let storage: libc::sockaddr_storage = intrinsics::init();\n+        let len = match addr.ip {\n+            ip::Ipv4Addr(a, b, c, d) => {\n+                let storage: *mut libc::sockaddr_in = cast::transmute(&storage);\n+                (*storage).sin_family = libc::AF_INET as libc::sa_family_t;\n+                (*storage).sin_port = htons(addr.port);\n+                (*storage).sin_addr.s_addr = (d as u32 << 24) |\n+                                             (c as u32 << 16) |\n+                                             (b as u32 <<  8) |\n+                                             (a as u32 <<  0);\n+                mem::size_of::<libc::sockaddr_in>()\n+            }\n+            ip::Ipv6Addr(a, b, c, d, e, f, g, h) => {\n+                let storage: *mut libc::sockaddr_in6 = cast::transmute(&storage);\n+                (*storage).sin6_family = libc::AF_INET6 as libc::sa_family_t;\n+                (*storage).sin6_port = htons(addr.port);\n+                (*storage).sin6_addr.s6_addr[0] = htons(a);\n+                (*storage).sin6_addr.s6_addr[1] = htons(b);\n+                (*storage).sin6_addr.s6_addr[2] = htons(c);\n+                (*storage).sin6_addr.s6_addr[3] = htons(d);\n+                (*storage).sin6_addr.s6_addr[4] = htons(e);\n+                (*storage).sin6_addr.s6_addr[5] = htons(f);\n+                (*storage).sin6_addr.s6_addr[6] = htons(g);\n+                (*storage).sin6_addr.s6_addr[7] = htons(h);\n+                mem::size_of::<libc::sockaddr_in6>()\n+            }\n+        };\n+        return (storage, len);\n+    }\n+}\n+\n+fn socket(addr: ip::SocketAddr) -> IoResult<sock_t> {\n+    unsafe {\n+        let fam = match addr.ip {\n+            ip::Ipv4Addr(..) => libc::AF_INET,\n+            ip::Ipv6Addr(..) => libc::AF_INET6,\n+        };\n+        match libc::socket(fam, libc::SOCK_STREAM, 0) {\n+            -1 => Err(super::last_error()),\n+            fd => Ok(fd),\n+        }\n+    }\n+}\n+\n+fn sockname(fd: sock_t,\n+            f: extern \"system\" unsafe fn(sock_t, *mut libc::sockaddr,\n+                                         *mut libc::socklen_t) -> libc::c_int)\n+    -> IoResult<ip::SocketAddr>\n+{\n+    let mut storage: libc::sockaddr_storage = unsafe { intrinsics::init() };\n+    let mut len = mem::size_of::<libc::sockaddr_storage>() as libc::socklen_t;\n+    unsafe {\n+        let storage = &mut storage as *mut libc::sockaddr_storage;\n+        let ret = f(fd,\n+                    storage as *mut libc::sockaddr,\n+                    &mut len as *mut libc::socklen_t);\n+        if ret != 0 {\n+            return Err(super::last_error())\n+        }\n+    }\n+    match storage.ss_family as libc::c_int {\n+        libc::AF_INET => {\n+            assert!(len as uint >= mem::size_of::<libc::sockaddr_in>());\n+            let storage: &mut libc::sockaddr_in = unsafe {\n+                cast::transmute(&mut storage)\n+            };\n+            let addr = storage.sin_addr.s_addr as u32;\n+            let a = (addr >>  0) as u8;\n+            let b = (addr >>  8) as u8;\n+            let c = (addr >> 16) as u8;\n+            let d = (addr >> 24) as u8;\n+            Ok(ip::SocketAddr {\n+                ip: ip::Ipv4Addr(a, b, c, d),\n+                port: ntohs(storage.sin_port),\n+            })\n+        }\n+        libc::AF_INET6 => {\n+            assert!(len as uint >= mem::size_of::<libc::sockaddr_in6>());\n+            let storage: &mut libc::sockaddr_in6 = unsafe {\n+                cast::transmute(&mut storage)\n+            };\n+            let a = ntohs(storage.sin6_addr.s6_addr[0]);\n+            let b = ntohs(storage.sin6_addr.s6_addr[1]);\n+            let c = ntohs(storage.sin6_addr.s6_addr[2]);\n+            let d = ntohs(storage.sin6_addr.s6_addr[3]);\n+            let e = ntohs(storage.sin6_addr.s6_addr[4]);\n+            let f = ntohs(storage.sin6_addr.s6_addr[5]);\n+            let g = ntohs(storage.sin6_addr.s6_addr[6]);\n+            let h = ntohs(storage.sin6_addr.s6_addr[7]);\n+            Ok(ip::SocketAddr {\n+                ip: ip::Ipv6Addr(a, b, c, d, e, f, g, h),\n+                port: ntohs(storage.sin6_port),\n+            })\n+        }\n+        _ => {\n+            Err(io::standard_error(io::OtherIoError))\n+        }\n+    }\n+}\n+\n+#[cfg(unix)]\n+pub fn init() {}\n+\n+#[cfg(windows)]\n+pub fn init() {\n+    static WSADESCRIPTION_LEN: uint = 256;\n+    static WSASYS_STATUS_LEN: uint = 128;\n+    struct WSADATA {\n+        wVersion: libc::WORD,\n+        wHighVersion: libc::WORD,\n+        szDescription: [u8, ..WSADESCRIPTION_LEN + 1],\n+        szSystemStatus: [u8, ..WSASYS_STATUS_LEN + 1],\n+        iMaxSockets: u16,\n+        iMaxUdpDg: u16,\n+        lpVendorInfo: *u8,\n+    }\n+    type LPWSADATA = *mut WSADATA;\n+\n+    #[link(name = \"ws2_32\")]\n+    extern \"system\" {\n+        fn WSAStartup(wVersionRequested: libc::WORD,\n+                       lpWSAData: LPWSADATA) -> libc::c_int;\n+    }\n+\n+    unsafe {\n+        use std::unstable::mutex::{Mutex, MUTEX_INIT};\n+        static mut LOCK: Mutex = MUTEX_INIT;\n+        static mut INITIALIZED: bool = false;\n+        if INITIALIZED { return }\n+        LOCK.lock();\n+        if !INITIALIZED {\n+            let mut data: WSADATA = intrinsics::init();\n+            let ret = WSAStartup(0x202,      // version 2.2\n+                                 &mut data);\n+            assert_eq!(ret, 0);\n+            INITIALIZED = true;\n+        }\n+        LOCK.unlock();\n+    }\n+}\n+\n+impl TcpStream {\n+    pub fn connect(addr: ip::SocketAddr) -> IoResult<TcpStream> {\n+        unsafe {\n+            socket(addr).and_then(|fd| {\n+                let (addr, len) = addr_to_sockaddr(addr);\n+                let addrp = &addr as *libc::sockaddr_storage;\n+                let ret = TcpStream { fd: fd };\n+                match libc::connect(fd, addrp as *libc::sockaddr,\n+                                    len as libc::socklen_t) {\n+                    -1 => Err(super::last_error()),\n+                    _ => Ok(ret),\n+                }\n+            })\n+        }\n+    }\n+\n+    pub fn fd(&self) -> sock_t { self.fd }\n+\n+    fn set_nodelay(&mut self, nodelay: bool) -> IoResult<()> {\n+        unsafe {\n+            let on = nodelay as libc::c_int;\n+            let on = &on as *libc::c_int;\n+            super::mkerr_libc(libc::setsockopt(self.fd,\n+                                               libc::IPPROTO_TCP,\n+                                               libc::TCP_NODELAY,\n+                                               on as *libc::c_void,\n+                                               mem::size_of::<libc::c_void>()\n+                                                    as libc::socklen_t))\n+        }\n+    }\n+\n+    fn set_keepalive(&mut self, seconds: Option<uint>) -> IoResult<()> {\n+        unsafe {\n+            let on = seconds.is_some() as libc::c_int;\n+            let on = &on as *libc::c_int;\n+            let ret = libc::setsockopt(self.fd,\n+                                       libc::SOL_SOCKET,\n+                                       libc::SO_KEEPALIVE,\n+                                       on as *libc::c_void,\n+                                       mem::size_of::<libc::c_void>()\n+                                            as libc::socklen_t);\n+            if ret != 0 { return Err(super::last_error()) }\n+\n+            match seconds {\n+                Some(n) => self.set_tcp_keepalive(n),\n+                None => Ok(())\n+            }\n+        }\n+    }\n+\n+    #[cfg(target_os = \"macos\")]\n+    unsafe fn set_tcp_keepalive(&mut self, seconds: uint) -> IoResult<()> {\n+        let delay = seconds as libc::c_uint;\n+        let delay = &delay as *libc::c_uint;\n+        let ret = libc::setsockopt(self.fd,\n+                                   libc::IPPROTO_TCP,\n+                                   libc::TCP_KEEPALIVE,\n+                                   delay as *libc::c_void,\n+                                   mem::size_of::<libc::c_uint>()\n+                                        as libc::socklen_t);\n+        super::mkerr_libc(ret)\n+    }\n+    #[cfg(target_os = \"freebsd\")]\n+    unsafe fn set_tcp_keepalive(&mut self, seconds: uint) -> IoResult<()> {\n+        let delay = seconds as libc::c_uint;\n+        let delay = &delay as *libc::c_uint;\n+        let ret = libc::setsockopt(self.fd,\n+                                   libc::IPPROTO_TCP,\n+                                   libc::TCP_KEEPIDLE,\n+                                   delay as *libc::c_void,\n+                                   mem::size_of::<libc::c_uint>()\n+                                        as libc::socklen_t);\n+        super::mkerr_libc(ret)\n+    }\n+    #[cfg(not(target_os = \"macos\"), not(target_os = \"freebsd\"))]\n+    unsafe fn set_tcp_keepalive(&mut self, _seconds: uint) -> IoResult<()> {\n+        Ok(())\n+    }\n+}\n+\n+#[cfg(windows)] type wrlen = libc::c_int;\n+#[cfg(not(windows))] type wrlen = libc::size_t;\n+\n+impl rtio::RtioTcpStream for TcpStream {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+        let ret = keep_going(buf, |buf, len| {\n+            unsafe {\n+                libc::recv(self.fd,\n+                           buf as *mut libc::c_void,\n+                           len as wrlen,\n+                           0) as i64\n+            }\n+        });\n+        if ret == 0 {\n+            Err(io::standard_error(io::EndOfFile))\n+        } else if ret < 0 {\n+            Err(super::last_error())\n+        } else {\n+            Ok(ret as uint)\n+        }\n+    }\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+        let ret = keep_going(buf, |buf, len| {\n+            unsafe {\n+                libc::send(self.fd,\n+                           buf as *mut libc::c_void,\n+                           len as wrlen,\n+                           0) as i64\n+            }\n+        });\n+        if ret < 0 {\n+            Err(super::last_error())\n+        } else {\n+            Ok(())\n+        }\n+    }\n+    fn peer_name(&mut self) -> IoResult<ip::SocketAddr> {\n+        sockname(self.fd, libc::getpeername)\n+    }\n+    fn control_congestion(&mut self) -> IoResult<()> {\n+        self.set_nodelay(false)\n+    }\n+    fn nodelay(&mut self) -> IoResult<()> {\n+        self.set_nodelay(true)\n+    }\n+    fn keepalive(&mut self, delay_in_seconds: uint) -> IoResult<()> {\n+        self.set_keepalive(Some(delay_in_seconds))\n+    }\n+    fn letdie(&mut self) -> IoResult<()> {\n+        self.set_keepalive(None)\n+    }\n+}\n+\n+impl rtio::RtioSocket for TcpStream {\n+    fn socket_name(&mut self) -> IoResult<ip::SocketAddr> {\n+        sockname(self.fd, libc::getsockname)\n+    }\n+}\n+\n+impl Drop for TcpStream {\n+    #[cfg(unix)]\n+    fn drop(&mut self) {\n+        unsafe { libc::close(self.fd); }\n+    }\n+\n+    #[cfg(windows)]\n+    fn drop(&mut self) {\n+        unsafe { libc::closesocket(self.fd); }\n+    }\n+}\n+\n+pub struct TcpListener {\n+    priv fd: sock_t,\n+}\n+\n+impl TcpListener {\n+    pub fn bind(addr: ip::SocketAddr) -> IoResult<TcpListener> {\n+        unsafe {\n+            socket(addr).and_then(|fd| {\n+                let (addr, len) = addr_to_sockaddr(addr);\n+                let addrp = &addr as *libc::sockaddr_storage;\n+                let ret = TcpListener { fd: fd };\n+                match libc::bind(fd, addrp as *libc::sockaddr,\n+                                 len as libc::socklen_t) {\n+                    -1 => Err(super::last_error()),\n+                    _ => Ok(ret),\n+                }\n+            })\n+        }\n+    }\n+\n+    pub fn fd(&self) -> sock_t { self.fd }\n+\n+    pub fn native_listen(self, backlog: int) -> IoResult<TcpAcceptor> {\n+        match unsafe { libc::listen(self.fd, backlog as libc::c_int) } {\n+            -1 => Err(super::last_error()),\n+            _ => Ok(TcpAcceptor { fd: self.fd })\n+        }\n+    }\n+}\n+\n+impl rtio::RtioTcpListener for TcpListener {\n+    fn listen(~self) -> IoResult<~rtio::RtioTcpAcceptor> {\n+        self.native_listen(128).map(|a| ~a as ~rtio::RtioTcpAcceptor)\n+    }\n+}\n+\n+impl rtio::RtioSocket for TcpListener {\n+    fn socket_name(&mut self) -> IoResult<ip::SocketAddr> {\n+        sockname(self.fd, libc::getsockname)\n+    }\n+}\n+\n+pub struct TcpAcceptor {\n+    priv fd: sock_t,\n+}\n+\n+impl TcpAcceptor {\n+    pub fn fd(&self) -> sock_t { self.fd }\n+\n+    pub fn native_accept(&mut self) -> IoResult<TcpStream> {\n+        unsafe {\n+            let mut storage: libc::sockaddr_storage = intrinsics::init();\n+            let storagep = &mut storage as *mut libc::sockaddr_storage;\n+            let size = mem::size_of::<libc::sockaddr_storage>();\n+            let mut size = size as libc::socklen_t;\n+            match libc::accept(self.fd,\n+                               storagep as *mut libc::sockaddr,\n+                               &mut size as *mut libc::socklen_t) {\n+                -1 => Err(super::last_error()),\n+                fd => Ok(TcpStream { fd: fd })\n+            }\n+        }\n+    }\n+}\n+\n+impl rtio::RtioSocket for TcpAcceptor {\n+    fn socket_name(&mut self) -> IoResult<ip::SocketAddr> {\n+        sockname(self.fd, libc::getsockname)\n+    }\n+}\n+\n+impl rtio::RtioTcpAcceptor for TcpAcceptor {\n+    fn accept(&mut self) -> IoResult<~rtio::RtioTcpStream> {\n+        self.native_accept().map(|s| ~s as ~rtio::RtioTcpStream)\n+    }\n+\n+    fn accept_simultaneously(&mut self) -> IoResult<()> { Ok(()) }\n+    fn dont_accept_simultaneously(&mut self) -> IoResult<()> { Ok(()) }\n+}"}, {"sha": "3fda4486921591fc7d1a0d7ff260af7568ed85f3", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a4f9d69afd19603ed3354fa8e64ab0e67c6a915/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a4f9d69afd19603ed3354fa8e64ab0e67c6a915/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=2a4f9d69afd19603ed3354fa8e64ab0e67c6a915", "patch": "@@ -407,8 +407,8 @@ fn spawn_process_os(prog: &str, args: &[~str],\n     }\n \n     let pipe = os::pipe();\n-    let mut input = file::FileDesc::new(pipe.input, file::CloseFd);\n-    let mut output = file::FileDesc::new(pipe.out, file::CloseFd);\n+    let mut input = file::FileDesc::new(pipe.input, true);\n+    let mut output = file::FileDesc::new(pipe.out, true);\n \n     unsafe { set_cloexec(output.fd()) };\n "}, {"sha": "8f2dff424049b3c4ef3410825b49761c0fb0a095", "filename": "src/libnative/task.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2a4f9d69afd19603ed3354fa8e64ab0e67c6a915/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a4f9d69afd19603ed3354fa8e64ab0e67c6a915/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=2a4f9d69afd19603ed3354fa8e64ab0e67c6a915", "patch": "@@ -34,6 +34,7 @@ pub fn new() -> ~Task {\n     task.put_runtime(~Ops {\n         lock: unsafe { Mutex::new() },\n         awoken: false,\n+        io: io::IoFactory::new(),\n     } as ~rt::Runtime);\n     return task;\n }\n@@ -86,8 +87,9 @@ pub fn spawn_opts(opts: TaskOpts, f: proc()) {\n // This structure is the glue between channels and the 1:1 scheduling mode. This\n // structure is allocated once per task.\n struct Ops {\n-    lock: Mutex,  // native synchronization\n-    awoken: bool, // used to prevent spurious wakeups\n+    lock: Mutex,       // native synchronization\n+    awoken: bool,      // used to prevent spurious wakeups\n+    io: io::IoFactory, // local I/O factory\n }\n \n impl rt::Runtime for Ops {\n@@ -217,11 +219,7 @@ impl rt::Runtime for Ops {\n     }\n \n     fn local_io<'a>(&'a mut self) -> Option<rtio::LocalIo<'a>> {\n-        static mut io: io::IoFactory = io::IoFactory;\n-        // Unsafety is from accessing `io`, which is guaranteed to be safe\n-        // because you can't do anything usable with this statically initialized\n-        // unit struct.\n-        Some(unsafe { rtio::LocalIo::new(&mut io as &mut rtio::IoFactory) })\n+        Some(rtio::LocalIo::new(&mut self.io as &mut rtio::IoFactory))\n     }\n }\n "}, {"sha": "5d08656b798cb4d565036d33f5244e5e8eb6f4ce", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2a4f9d69afd19603ed3354fa8e64ab0e67c6a915/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a4f9d69afd19603ed3354fa8e64ab0e67c6a915/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=2a4f9d69afd19603ed3354fa8e64ab0e67c6a915", "patch": "@@ -345,6 +345,7 @@ pub fn uv_error_to_io_error(uverr: UvError) -> IoError {\n             uvll::ENOENT => io::FileNotFound,\n             uvll::EPIPE => io::BrokenPipe,\n             uvll::ECONNABORTED => io::ConnectionAborted,\n+            uvll::EADDRNOTAVAIL => io::ConnectionRefused,\n             err => {\n                 uvdebug!(\"uverr.code {}\", err as int);\n                 // XXX: Need to map remaining uv error types"}, {"sha": "dfe67f050ec9f30f3b275e1fb6ca29fd55421144", "filename": "src/librustuv/uvll.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a4f9d69afd19603ed3354fa8e64ab0e67c6a915/src%2Flibrustuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a4f9d69afd19603ed3354fa8e64ab0e67c6a915/src%2Flibrustuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvll.rs?ref=2a4f9d69afd19603ed3354fa8e64ab0e67c6a915", "patch": "@@ -38,7 +38,7 @@ use std::libc;\n use std::libc::uintptr_t;\n \n pub use self::errors::{EACCES, ECONNREFUSED, ECONNRESET, EPIPE, ECONNABORTED,\n-                       ECANCELED, EBADF, ENOTCONN, ENOENT};\n+                       ECANCELED, EBADF, ENOTCONN, ENOENT, EADDRNOTAVAIL};\n \n pub static OK: c_int = 0;\n pub static EOF: c_int = -4095;\n@@ -60,6 +60,7 @@ pub mod errors {\n     pub static ECONNABORTED: c_int = -4079;\n     pub static ECANCELED: c_int = -4081;\n     pub static EBADF: c_int = -4083;\n+    pub static EADDRNOTAVAIL: c_int = -4090;\n }\n #[cfg(not(windows))]\n pub mod errors {\n@@ -75,6 +76,7 @@ pub mod errors {\n     pub static ECONNABORTED: c_int = -libc::ECONNABORTED;\n     pub static ECANCELED : c_int = -libc::ECANCELED;\n     pub static EBADF : c_int = -libc::EBADF;\n+    pub static EADDRNOTAVAIL : c_int = -libc::EADDRNOTAVAIL;\n }\n \n pub static PROCESS_SETUID: c_int = 1 << 0;"}, {"sha": "52cca7f622b532984e0da0794f903eaf9e3203f1", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 40, "deletions": 65, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/2a4f9d69afd19603ed3354fa8e64ab0e67c6a915/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a4f9d69afd19603ed3354fa8e64ab0e67c6a915/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=2a4f9d69afd19603ed3354fa8e64ab0e67c6a915", "patch": "@@ -138,8 +138,7 @@ mod test {\n     use io::*;\n     use prelude::*;\n \n-    #[test] #[ignore]\n-    fn bind_error() {\n+    iotest!(fn bind_error() {\n         let mut called = false;\n         io_error::cond.trap(|e| {\n             assert!(e.kind == PermissionDenied);\n@@ -150,30 +149,22 @@ mod test {\n             assert!(listener.is_none());\n         });\n         assert!(called);\n-    }\n+    } #[ignore(cfg(windows))])\n \n-    #[test]\n-    fn connect_error() {\n+    iotest!(fn connect_error() {\n         let mut called = false;\n         io_error::cond.trap(|e| {\n-            let expected_error = if cfg!(unix) {\n-                ConnectionRefused\n-            } else {\n-                // On Win32, opening port 1 gives WSAEADDRNOTAVAIL error.\n-                OtherIoError\n-            };\n-            assert_eq!(e.kind, expected_error);\n+            assert_eq!(e.kind, ConnectionRefused);\n             called = true;\n         }).inside(|| {\n             let addr = SocketAddr { ip: Ipv4Addr(0, 0, 0, 0), port: 1 };\n             let stream = TcpStream::connect(addr);\n             assert!(stream.is_none());\n         });\n         assert!(called);\n-    }\n+    })\n \n-    #[test]\n-    fn smoke_test_ip4() {\n+    iotest!(fn smoke_test_ip4() {\n         let addr = next_test_ip4();\n         let (port, chan) = Chan::new();\n \n@@ -189,10 +180,9 @@ mod test {\n         let mut buf = [0];\n         stream.read(buf);\n         assert!(buf[0] == 99);\n-    }\n+    })\n \n-    #[test]\n-    fn smoke_test_ip6() {\n+    iotest!(fn smoke_test_ip6() {\n         let addr = next_test_ip6();\n         let (port, chan) = Chan::new();\n \n@@ -208,10 +198,9 @@ mod test {\n         let mut buf = [0];\n         stream.read(buf);\n         assert!(buf[0] == 99);\n-    }\n+    })\n \n-    #[test]\n-    fn read_eof_ip4() {\n+    iotest!(fn read_eof_ip4() {\n         let addr = next_test_ip4();\n         let (port, chan) = Chan::new();\n \n@@ -227,10 +216,9 @@ mod test {\n         let mut buf = [0];\n         let nread = stream.read(buf);\n         assert!(nread.is_none());\n-    }\n+    })\n \n-    #[test]\n-    fn read_eof_ip6() {\n+    iotest!(fn read_eof_ip6() {\n         let addr = next_test_ip6();\n         let (port, chan) = Chan::new();\n \n@@ -246,10 +234,9 @@ mod test {\n         let mut buf = [0];\n         let nread = stream.read(buf);\n         assert!(nread.is_none());\n-    }\n+    })\n \n-    #[test]\n-    fn read_eof_twice_ip4() {\n+    iotest!(fn read_eof_twice_ip4() {\n         let addr = next_test_ip4();\n         let (port, chan) = Chan::new();\n \n@@ -275,10 +262,9 @@ mod test {\n             let nread = stream.read(buf);\n             assert!(nread.is_none());\n         })\n-    }\n+    })\n \n-    #[test]\n-    fn read_eof_twice_ip6() {\n+    iotest!(fn read_eof_twice_ip6() {\n         let addr = next_test_ip6();\n         let (port, chan) = Chan::new();\n \n@@ -304,10 +290,9 @@ mod test {\n             let nread = stream.read(buf);\n             assert!(nread.is_none());\n         })\n-    }\n+    })\n \n-    #[test]\n-    fn write_close_ip4() {\n+    iotest!(fn write_close_ip4() {\n         let addr = next_test_ip4();\n         let (port, chan) = Chan::new();\n \n@@ -336,10 +321,9 @@ mod test {\n             });\n             if stop { break }\n         }\n-    }\n+    })\n \n-    #[test]\n-    fn write_close_ip6() {\n+    iotest!(fn write_close_ip6() {\n         let addr = next_test_ip6();\n         let (port, chan) = Chan::new();\n \n@@ -368,10 +352,9 @@ mod test {\n             });\n             if stop { break }\n         }\n-    }\n+    })\n \n-    #[test]\n-    fn multiple_connect_serial_ip4() {\n+    iotest!(fn multiple_connect_serial_ip4() {\n         let addr = next_test_ip4();\n         let max = 10;\n         let (port, chan) = Chan::new();\n@@ -391,10 +374,9 @@ mod test {\n             stream.read(buf);\n             assert_eq!(buf[0], 99);\n         }\n-    }\n+    })\n \n-    #[test]\n-    fn multiple_connect_serial_ip6() {\n+    iotest!(fn multiple_connect_serial_ip6() {\n         let addr = next_test_ip6();\n         let max = 10;\n         let (port, chan) = Chan::new();\n@@ -414,10 +396,9 @@ mod test {\n             stream.read(buf);\n             assert_eq!(buf[0], 99);\n         }\n-    }\n+    })\n \n-    #[test]\n-    fn multiple_connect_interleaved_greedy_schedule_ip4() {\n+    iotest!(fn multiple_connect_interleaved_greedy_schedule_ip4() {\n         let addr = next_test_ip4();\n         static MAX: int = 10;\n         let (port, chan) = Chan::new();\n@@ -452,10 +433,9 @@ mod test {\n                 stream.write([i as u8]);\n             }\n         }\n-    }\n+    })\n \n-    #[test]\n-    fn multiple_connect_interleaved_greedy_schedule_ip6() {\n+    iotest!(fn multiple_connect_interleaved_greedy_schedule_ip6() {\n         let addr = next_test_ip6();\n         static MAX: int = 10;\n         let (port, chan) = Chan::<()>::new();\n@@ -490,10 +470,9 @@ mod test {\n                 stream.write([i as u8]);\n             }\n         }\n-    }\n+    })\n \n-    #[test]\n-    fn multiple_connect_interleaved_lazy_schedule_ip4() {\n+    iotest!(fn multiple_connect_interleaved_lazy_schedule_ip4() {\n         let addr = next_test_ip4();\n         static MAX: int = 10;\n         let (port, chan) = Chan::new();\n@@ -528,9 +507,9 @@ mod test {\n                 stream.write([99]);\n             }\n         }\n-    }\n-    #[test]\n-    fn multiple_connect_interleaved_lazy_schedule_ip6() {\n+    })\n+\n+    iotest!(fn multiple_connect_interleaved_lazy_schedule_ip6() {\n         let addr = next_test_ip6();\n         static MAX: int = 10;\n         let (port, chan) = Chan::new();\n@@ -565,10 +544,9 @@ mod test {\n                 stream.write([99]);\n             }\n         }\n-    }\n+    })\n \n-    #[cfg(test)]\n-    fn socket_name(addr: SocketAddr) {\n+    pub fn socket_name(addr: SocketAddr) {\n         let mut listener = TcpListener::bind(addr).unwrap();\n \n         // Make sure socket_name gives\n@@ -578,8 +556,7 @@ mod test {\n         assert_eq!(addr, so_name.unwrap());\n     }\n \n-    #[cfg(test)]\n-    fn peer_name(addr: SocketAddr) {\n+    pub fn peer_name(addr: SocketAddr) {\n         let (port, chan) = Chan::new();\n \n         do spawn {\n@@ -602,16 +579,14 @@ mod test {\n         assert_eq!(addr, peer_name.unwrap());\n     }\n \n-    #[test]\n-    fn socket_and_peer_name_ip4() {\n+    iotest!(fn socket_and_peer_name_ip4() {\n         peer_name(next_test_ip4());\n         socket_name(next_test_ip4());\n-    }\n+    })\n \n-    #[test]\n-    fn socket_and_peer_name_ip6() {\n+    iotest!(fn socket_and_peer_name_ip6() {\n         // XXX: peer name is not consistent\n         //peer_name(next_test_ip6());\n         socket_name(next_test_ip6());\n-    }\n+    })\n }"}, {"sha": "92b2cfa8be2008dba0a2ca9addf3eda6699cea70", "filename": "src/libstd/io/test.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2a4f9d69afd19603ed3354fa8e64ab0e67c6a915/src%2Flibstd%2Fio%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a4f9d69afd19603ed3354fa8e64ab0e67c6a915/src%2Flibstd%2Fio%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftest.rs?ref=2a4f9d69afd19603ed3354fa8e64ab0e67c6a915", "patch": "@@ -18,7 +18,7 @@ use std::io::net::ip::*;\n use sync::atomics::{AtomicUint, INIT_ATOMIC_UINT, Relaxed};\n \n macro_rules! iotest (\n-    { fn $name:ident() $b:block } => (\n+    { fn $name:ident() $b:block $($a:attr)* } => (\n         mod $name {\n             #[allow(unused_imports)];\n \n@@ -28,6 +28,7 @@ macro_rules! iotest (\n             use prelude::*;\n             use io::*;\n             use io::fs::*;\n+            use io::test::*;\n             use io::net::tcp::*;\n             use io::net::ip::*;\n             use io::net::udp::*;\n@@ -39,8 +40,8 @@ macro_rules! iotest (\n \n             fn f() $b\n \n-            #[test] fn green() { f() }\n-            #[test] fn native() {\n+            $($a)* #[test] fn green() { f() }\n+            $($a)* #[test] fn native() {\n                 use native;\n                 let (p, c) = Chan::new();\n                 do native::task::spawn { c.send(f()) }\n@@ -91,9 +92,9 @@ fn base_port() -> u16 {\n \n     let bases = [\n         (\"32-opt\", base + range * 1),\n-        (\"32-noopt\", base + range * 2),\n+        (\"32-nopt\", base + range * 2),\n         (\"64-opt\", base + range * 3),\n-        (\"64-noopt\", base + range * 4),\n+        (\"64-nopt\", base + range * 4),\n         (\"64-opt-vg\", base + range * 5),\n         (\"all-opt\", base + range * 6),\n         (\"snap3\", base + range * 7),"}, {"sha": "2696e27c373174f841dd1416cde375b904ab5064", "filename": "src/libstd/libc.rs", "status": "modified", "additions": 308, "deletions": 0, "changes": 308, "blob_url": "https://github.com/rust-lang/rust/blob/2a4f9d69afd19603ed3354fa8e64ab0e67c6a915/src%2Flibstd%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a4f9d69afd19603ed3354fa8e64ab0e67c6a915/src%2Flibstd%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flibc.rs?ref=2a4f9d69afd19603ed3354fa8e64ab0e67c6a915", "patch": "@@ -76,6 +76,7 @@ pub use libc::types::common::posix01::*;\n pub use libc::types::common::posix08::*;\n pub use libc::types::common::bsd44::*;\n pub use libc::types::os::common::posix01::*;\n+pub use libc::types::os::common::bsd44::*;\n pub use libc::types::os::arch::c95::*;\n pub use libc::types::os::arch::c99::*;\n pub use libc::types::os::arch::posix88::*;\n@@ -111,6 +112,7 @@ pub use libc::funcs::posix01::glob::*;\n pub use libc::funcs::posix01::mman::*;\n pub use libc::funcs::posix08::unistd::*;\n \n+pub use libc::funcs::bsd43::*;\n pub use libc::funcs::bsd44::*;\n pub use libc::funcs::extra::*;\n \n@@ -240,6 +242,40 @@ pub mod types {\n                     __unused5: *c_void,\n                 }\n             }\n+            pub mod bsd44 {\n+                pub type socklen_t = u32;\n+                pub type sa_family_t = u16;\n+                pub type in_port_t = u16;\n+                pub type in_addr_t = u32;\n+                pub struct sockaddr {\n+                    sa_family: sa_family_t,\n+                    sa_data: [u8, ..14],\n+                }\n+                pub struct sockaddr_storage {\n+                    ss_family: sa_family_t,\n+                    __ss_align: i64,\n+                    __ss_pad2: [u8, ..112],\n+                }\n+                pub struct sockaddr_in {\n+                    sin_family: sa_family_t,\n+                    sin_port: in_port_t,\n+                    sin_addr: in_addr,\n+                    sin_zero: [u8, ..8],\n+                }\n+                pub struct in_addr {\n+                    s_addr: in_addr_t,\n+                }\n+                pub struct sockaddr_in6 {\n+                    sin6_family: sa_family_t,\n+                    sin6_port: in_port_t,\n+                    sin6_flowinfo: u32,\n+                    sin6_addr: in6_addr,\n+                    sin6_scope_id: u32,\n+                }\n+                pub struct in6_addr {\n+                    s6_addr: [u16, ..8]\n+                }\n+            }\n         }\n \n         #[cfg(target_arch = \"x86\")]\n@@ -538,6 +574,45 @@ pub mod types {\n                     __unused8: *c_void,\n                 }\n             }\n+            pub mod bsd44 {\n+                pub type socklen_t = u32;\n+                pub type sa_family_t = u8;\n+                pub type in_port_t = u16;\n+                pub type in_addr_t = u32;\n+                pub struct sockaddr {\n+                    sa_len: u8,\n+                    sa_family: sa_family_t,\n+                    sa_data: [u8, ..14],\n+                }\n+                pub struct sockaddr_storage {\n+                    ss_len: u8,\n+                    ss_family: sa_family_t,\n+                    __ss_pad1: [u8, ..6],\n+                    __ss_align: i64,\n+                    __ss_pad2: [u8, ..112],\n+                }\n+                pub struct sockaddr_in {\n+                    sin_len: u8,\n+                    sin_family: sa_family_t,\n+                    sin_port: in_port_t,\n+                    sin_addr: in_addr,\n+                    sin_zero: [u8, ..8],\n+                }\n+                pub struct in_addr {\n+                    s_addr: in_addr_t,\n+                }\n+                pub struct sockaddr_in6 {\n+                    sin6_len: u8,\n+                    sin6_family: sa_family_t,\n+                    sin6_port: in_port_t,\n+                    sin6_flowinfo: u32,\n+                    sin6_addr: in6_addr,\n+                    sin6_scope_id: u32,\n+                }\n+                pub struct in6_addr {\n+                    s6_addr: [u16, ..8]\n+                }\n+            }\n         }\n \n         #[cfg(target_arch = \"x86_64\")]\n@@ -661,6 +736,44 @@ pub mod types {\n                     modtime: time64_t,\n                 }\n             }\n+\n+            pub mod bsd44 {\n+                use libc::types::os::arch::c95::{c_int, c_uint};\n+\n+                pub type SOCKET = c_uint;\n+                pub type socklen_t = c_int;\n+                pub type sa_family_t = u16;\n+                pub type in_port_t = u16;\n+                pub type in_addr_t = u32;\n+                pub struct sockaddr {\n+                    sa_family: sa_family_t,\n+                    sa_data: [u8, ..14],\n+                }\n+                pub struct sockaddr_storage {\n+                    ss_family: sa_family_t,\n+                    __ss_align: i64,\n+                    __ss_pad2: [u8, ..112],\n+                }\n+                pub struct sockaddr_in {\n+                    sin_family: sa_family_t,\n+                    sin_port: in_port_t,\n+                    sin_addr: in_addr,\n+                    sin_zero: [u8, ..8],\n+                }\n+                pub struct in_addr {\n+                    s_addr: in_addr_t,\n+                }\n+                pub struct sockaddr_in6 {\n+                    sin6_family: sa_family_t,\n+                    sin6_port: in_port_t,\n+                    sin6_flowinfo: u32,\n+                    sin6_addr: in6_addr,\n+                    sin6_scope_id: u32,\n+                }\n+                pub struct in6_addr {\n+                    s6_addr: [u16, ..8]\n+                }\n+            }\n         }\n \n         pub mod arch {\n@@ -900,6 +1013,48 @@ pub mod types {\n                     __unused8: *c_void,\n                 }\n             }\n+\n+            pub mod bsd44 {\n+                use libc::types::os::arch::c95::c_int;\n+\n+                pub type socklen_t = c_int;\n+                pub type sa_family_t = u8;\n+                pub type in_port_t = u16;\n+                pub type in_addr_t = u32;\n+                pub struct sockaddr {\n+                    sa_len: u8,\n+                    sa_family: sa_family_t,\n+                    sa_data: [u8, ..14],\n+                }\n+                pub struct sockaddr_storage {\n+                    ss_len: u8,\n+                    ss_family: sa_family_t,\n+                    __ss_pad1: [u8, ..6],\n+                    __ss_align: i64,\n+                    __ss_pad2: [u8, ..112],\n+                }\n+                pub struct sockaddr_in {\n+                    sin_len: u8,\n+                    sin_family: sa_family_t,\n+                    sin_port: in_port_t,\n+                    sin_addr: in_addr,\n+                    sin_zero: [u8, ..8],\n+                }\n+                pub struct in_addr {\n+                    s_addr: in_addr_t,\n+                }\n+                pub struct sockaddr_in6 {\n+                    sin6_len: u8,\n+                    sin6_family: sa_family_t,\n+                    sin6_port: in_port_t,\n+                    sin6_flowinfo: u32,\n+                    sin6_addr: in6_addr,\n+                    sin6_scope_id: u32,\n+                }\n+                pub struct in6_addr {\n+                    s6_addr: [u16, ..8]\n+                }\n+            }\n         }\n \n         #[cfg(target_arch = \"x86\")]\n@@ -1109,6 +1264,59 @@ pub mod consts {\n             pub static FILENAME_MAX : c_uint = 260_u32;\n             pub static L_tmpnam : c_uint = 16_u32;\n             pub static TMP_MAX : c_uint = 32767_u32;\n+\n+            pub static WSAEINTR: c_int = 10004;\n+            pub static WSAEBADF: c_int = 10009;\n+            pub static WSAEACCES: c_int = 10013;\n+            pub static WSAEFAULT: c_int = 10014;\n+            pub static WSAEINVAL: c_int = 10022;\n+            pub static WSAEMFILE: c_int = 10024;\n+            pub static WSAEWOULDBLOCK: c_int = 10035;\n+            pub static WSAEINPROGRESS: c_int = 10036;\n+            pub static WSAEALREADY: c_int = 10037;\n+            pub static WSAENOTSOCK: c_int = 10038;\n+            pub static WSAEDESTADDRREQ: c_int = 10039;\n+            pub static WSAEMSGSIZE: c_int = 10040;\n+            pub static WSAEPROTOTYPE: c_int = 10041;\n+            pub static WSAENOPROTOOPT: c_int = 10042;\n+            pub static WSAEPROTONOSUPPORT: c_int = 10043;\n+            pub static WSAESOCKTNOSUPPORT: c_int = 10044;\n+            pub static WSAEOPNOTSUPP: c_int = 10045;\n+            pub static WSAEPFNOSUPPORT: c_int = 10046;\n+            pub static WSAEAFNOSUPPORT: c_int = 10047;\n+            pub static WSAEADDRINUSE: c_int = 10048;\n+            pub static WSAEADDRNOTAVAIL: c_int = 10049;\n+            pub static WSAENETDOWN: c_int = 10050;\n+            pub static WSAENETUNREACH: c_int = 10051;\n+            pub static WSAENETRESET: c_int = 10052;\n+            pub static WSAECONNABORTED: c_int = 10053;\n+            pub static WSAECONNRESET: c_int = 10054;\n+            pub static WSAENOBUFS: c_int = 10055;\n+            pub static WSAEISCONN: c_int = 10056;\n+            pub static WSAENOTCONN: c_int = 10057;\n+            pub static WSAESHUTDOWN: c_int = 10058;\n+            pub static WSAETOOMANYREFS: c_int = 10059;\n+            pub static WSAETIMEDOUT: c_int = 10060;\n+            pub static WSAECONNREFUSED: c_int = 10061;\n+            pub static WSAELOOP: c_int = 10062;\n+            pub static WSAENAMETOOLONG: c_int = 10063;\n+            pub static WSAEHOSTDOWN: c_int = 10064;\n+            pub static WSAEHOSTUNREACH: c_int = 10065;\n+            pub static WSAENOTEMPTY: c_int = 10066;\n+            pub static WSAEPROCLIM: c_int = 10067;\n+            pub static WSAEUSERS: c_int = 10068;\n+            pub static WSAEDQUOT: c_int = 10069;\n+            pub static WSAESTALE: c_int = 10070;\n+            pub static WSAEREMOTE: c_int = 10071;\n+            pub static WSASYSNOTREADY: c_int = 10091;\n+            pub static WSAVERNOTSUPPORTED: c_int = 10092;\n+            pub static WSANOTINITIALISED: c_int = 10093;\n+            pub static WSAEDISCON: c_int = 10101;\n+            pub static WSAENOMORE: c_int = 10102;\n+            pub static WSAECANCELLED: c_int = 10103;\n+            pub static WSAEINVALIDPROCTABLE: c_int = 10104;\n+            pub static WSAEINVALIDPROVIDER: c_int = 10105;\n+            pub static WSAEPROVIDERFAILEDINIT: c_int = 10106;\n         }\n         pub mod c99 {\n         }\n@@ -1149,6 +1357,17 @@ pub mod consts {\n         pub mod posix08 {\n         }\n         pub mod bsd44 {\n+            use libc::types::os::arch::c95::c_int;\n+\n+            pub static AF_INET: c_int = 2;\n+            pub static AF_INET6: c_int = 23;\n+            pub static SOCK_STREAM: c_int = 1;\n+            pub static SOCK_DGRAM: c_int = 2;\n+            pub static IPPROTO_TCP: c_int = 6;\n+\n+            pub static TCP_NODELAY: c_int = 0x0001;\n+            pub static SOL_SOCKET: c_int = 0xffff;\n+            pub static SO_KEEPALIVE: c_int = 8;\n         }\n         pub mod extra {\n             use libc::types::os::arch::c95::c_int;\n@@ -1845,6 +2064,16 @@ pub mod consts {\n             pub static MADV_MERGEABLE : c_int = 12;\n             pub static MADV_UNMERGEABLE : c_int = 13;\n             pub static MADV_HWPOISON : c_int = 100;\n+\n+            pub static AF_INET: c_int = 2;\n+            pub static AF_INET6: c_int = 10;\n+            pub static SOCK_STREAM: c_int = 1;\n+            pub static SOCK_DGRAM: c_int = 2;\n+            pub static IPPROTO_TCP: c_int = 6;\n+\n+            pub static TCP_NODELAY: c_int = 1;\n+            pub static SOL_SOCKET: c_int = 1;\n+            pub static SO_KEEPALIVE: c_int = 9;\n         }\n         #[cfg(target_arch = \"x86\")]\n         #[cfg(target_arch = \"x86_64\")]\n@@ -2262,6 +2491,17 @@ pub mod consts {\n             pub static MINCORE_REFERENCED_OTHER : c_int = 0x8;\n             pub static MINCORE_MODIFIED_OTHER : c_int = 0x10;\n             pub static MINCORE_SUPER : c_int = 0x20;\n+\n+            pub static AF_INET: c_int = 2;\n+            pub static AF_INET6: c_int = 28;\n+            pub static SOCK_STREAM: c_int = 1;\n+            pub static SOCK_DGRAM: c_int = 2;\n+            pub static IPPROTO_TCP: c_int = 6;\n+\n+            pub static TCP_NODELAY: c_int = 1;\n+            pub static TCP_KEEPIDLE: c_int = 256;\n+            pub static SOL_SOCKET: c_int = 0xffff;\n+            pub static SO_KEEPALIVE: c_int = 0x0008;\n         }\n         pub mod extra {\n             use libc::types::os::arch::c95::c_int;\n@@ -2616,6 +2856,17 @@ pub mod consts {\n             pub static MINCORE_MODIFIED : c_int = 0x4;\n             pub static MINCORE_REFERENCED_OTHER : c_int = 0x8;\n             pub static MINCORE_MODIFIED_OTHER : c_int = 0x10;\n+\n+            pub static AF_INET: c_int = 2;\n+            pub static AF_INET6: c_int = 30;\n+            pub static SOCK_STREAM: c_int = 1;\n+            pub static SOCK_DGRAM: c_int = 2;\n+            pub static IPPROTO_TCP: c_int = 6;\n+\n+            pub static TCP_NODELAY: c_int = 0x01;\n+            pub static TCP_KEEPALIVE: c_int = 0x10;\n+            pub static SOL_SOCKET: c_int = 0xffff;\n+            pub static SO_KEEPALIVE: c_int = 0x0008;\n         }\n         pub mod extra {\n             use libc::types::os::arch::c95::c_int;\n@@ -3296,6 +3547,63 @@ pub mod funcs {\n         }\n     }\n \n+    #[cfg(not(windows))]\n+    pub mod bsd43 {\n+        use libc::types::common::c95::{c_void};\n+        use libc::types::os::common::bsd44::{socklen_t, sockaddr};\n+        use libc::types::os::arch::c95::{c_int, size_t};\n+        use libc::types::os::arch::posix88::ssize_t;\n+\n+        extern \"system\" {\n+            pub fn socket(domain: c_int, ty: c_int, protocol: c_int) -> c_int;\n+            pub fn connect(socket: c_int, address: *sockaddr,\n+                           len: socklen_t) -> c_int;\n+            pub fn bind(socket: c_int, address: *sockaddr,\n+                        address_len: socklen_t) -> c_int;\n+            pub fn listen(socket: c_int, backlog: c_int) -> c_int;\n+            pub fn accept(socket: c_int, address: *mut sockaddr,\n+                          address_len: *mut socklen_t) -> c_int;\n+            pub fn getpeername(socket: c_int, address: *mut sockaddr,\n+                               address_len: *mut socklen_t) -> c_int;\n+            pub fn getsockname(socket: c_int, address: *mut sockaddr,\n+                               address_len: *mut socklen_t) -> c_int;\n+            pub fn setsockopt(socket: c_int, level: c_int, name: c_int,\n+                              value: *c_void, option_len: socklen_t) -> c_int;\n+            pub fn recv(socket: c_int, buf: *mut c_void, len: size_t,\n+                        flags: c_int) -> ssize_t;\n+            pub fn send(socket: c_int, buf: *mut c_void, len: size_t,\n+                        flags: c_int) -> ssize_t;\n+        }\n+    }\n+\n+    #[cfg(windows)]\n+    pub mod bsd43 {\n+        use libc::types::common::c95::{c_void};\n+        use libc::types::os::common::bsd44::{socklen_t, sockaddr, SOCKET};\n+        use libc::types::os::arch::c95::c_int;\n+\n+        extern \"system\" {\n+            pub fn socket(domain: c_int, ty: c_int, protocol: c_int) -> SOCKET;\n+            pub fn connect(socket: SOCKET, address: *sockaddr,\n+                           len: socklen_t) -> c_int;\n+            pub fn bind(socket: SOCKET, address: *sockaddr,\n+                        address_len: socklen_t) -> c_int;\n+            pub fn listen(socket: SOCKET, backlog: c_int) -> c_int;\n+            pub fn accept(socket: SOCKET, address: *mut sockaddr,\n+                          address_len: *mut socklen_t) -> SOCKET;\n+            pub fn getpeername(socket: SOCKET, address: *mut sockaddr,\n+                               address_len: *mut socklen_t) -> c_int;\n+            pub fn getsockname(socket: SOCKET, address: *mut sockaddr,\n+                               address_len: *mut socklen_t) -> c_int;\n+            pub fn setsockopt(socket: SOCKET, level: c_int, name: c_int,\n+                              value: *c_void, option_len: socklen_t) -> c_int;\n+            pub fn closesocket(socket: SOCKET) -> c_int;\n+            pub fn recv(socket: SOCKET, buf: *mut c_void, len: c_int,\n+                        flags: c_int) -> c_int;\n+            pub fn send(socket: SOCKET, buf: *mut c_void, len: c_int,\n+                        flags: c_int) -> c_int;\n+        }\n+    }\n \n     #[cfg(target_os = \"macos\")]\n     #[cfg(target_os = \"freebsd\")]"}]}