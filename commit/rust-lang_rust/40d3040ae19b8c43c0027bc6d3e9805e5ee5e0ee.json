{"sha": "40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee", "node_id": "C_kwDOAAsO6NoAKDQwZDMwNDBhZTE5YjhjNDNjMDAyN2JjNmQzZTk4MDVlNWVlNWUwZWU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-03T21:40:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-03T21:40:28Z"}, "message": "Auto merge of #94571 - matthiaskrgr:rollup-4ul5ydb, r=matthiaskrgr\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #92697 (Use cgroup quotas for calculating `available_parallelism`)\n - #94057 (improve comments for `simplify_type`)\n - #94547 (`parse_tt` cleanups)\n - #94550 (rustdoc: Add test for higher kinded functions generated by macros)\n - #94551 (Doc: Fix use of quote instead of backstick in Adapter::map.)\n - #94554 (Fix invalid lint_node_id being put on a removed stmt)\n - #94555 (all: fix some typos)\n - #94563 (Remove a unnecessary `..` pattern)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "69fdb6d043602269c8cfb2a9c51984d5039b4ed6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69fdb6d043602269c8cfb2a9c51984d5039b4ed6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee", "html_url": "https://github.com/rust-lang/rust/commit/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10913c00018c76103b2fd4260d8c02ec728fd244", "url": "https://api.github.com/repos/rust-lang/rust/commits/10913c00018c76103b2fd4260d8c02ec728fd244", "html_url": "https://github.com/rust-lang/rust/commit/10913c00018c76103b2fd4260d8c02ec728fd244"}, {"sha": "cfa58dfd1c78ec170a1b13ae1d31ce99310bdce8", "url": "https://api.github.com/repos/rust-lang/rust/commits/cfa58dfd1c78ec170a1b13ae1d31ce99310bdce8", "html_url": "https://github.com/rust-lang/rust/commit/cfa58dfd1c78ec170a1b13ae1d31ce99310bdce8"}], "stats": {"total": 513, "additions": 328, "deletions": 185}, "files": [{"sha": "08040f481583643dfdc6edd03229d7f690af9d84", "filename": "RELEASES.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee", "patch": "@@ -1060,7 +1060,7 @@ Version 1.52.1 (2021-05-10)\n This release disables incremental compilation, unless the user has explicitly\n opted in via the newly added RUSTC_FORCE_INCREMENTAL=1 environment variable.\n \n-This is due to the widespread, and frequently occuring, breakage encountered by\n+This is due to the widespread, and frequently occurring, breakage encountered by\n Rust users due to newly enabled incremental verification in 1.52.0. Notably,\n Rust users **should** upgrade to 1.52.0 or 1.52.1: the bugs that are detected by\n newly added incremental verification are still present in past stable versions,"}, {"sha": "be3f6a12706f84c16ddafbb580c74a6ac87e0e6a", "filename": "compiler/rustc_codegen_gcc/src/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs?ref=40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee", "patch": "@@ -1064,7 +1064,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         let val_type = value.get_type();\n         match (type_is_pointer(val_type), type_is_pointer(dest_ty)) {\n             (false, true) => {\n-                // NOTE: Projecting a field of a pointer type will attemp a cast from a signed char to\n+                // NOTE: Projecting a field of a pointer type will attempt a cast from a signed char to\n                 // a pointer, which is not supported by gccjit.\n                 return self.cx.context.new_cast(None, self.inttoptr(value, val_type.make_pointer()), dest_ty);\n             },"}, {"sha": "e9d13a4ebaf8cb775162de4b198f660d5c8214f3", "filename": "compiler/rustc_codegen_llvm/src/llvm_util.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs?ref=40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee", "patch": "@@ -369,12 +369,12 @@ pub fn target_cpu(sess: &Session) -> &str {\n /// The list of LLVM features computed from CLI flags (`-Ctarget-cpu`, `-Ctarget-feature`,\n /// `--target` and similar).\n pub(crate) fn global_llvm_features(sess: &Session, diagnostics: bool) -> Vec<String> {\n-    // Features that come earlier are overriden by conflicting features later in the string.\n+    // Features that come earlier are overridden by conflicting features later in the string.\n     // Typically we'll want more explicit settings to override the implicit ones, so:\n     //\n-    // * Features from -Ctarget-cpu=*; are overriden by [^1]\n-    // * Features implied by --target; are overriden by\n-    // * Features from -Ctarget-feature; are overriden by\n+    // * Features from -Ctarget-cpu=*; are overridden by [^1]\n+    // * Features implied by --target; are overridden by\n+    // * Features from -Ctarget-feature; are overridden by\n     // * function specific features.\n     //\n     // [^1]: target-cpu=native is handled here, other target-cpu values are handled implicitly\n@@ -383,7 +383,7 @@ pub(crate) fn global_llvm_features(sess: &Session, diagnostics: bool) -> Vec<Str\n     // FIXME(nagisa): it isn't clear what's the best interaction between features implied by\n     // `-Ctarget-cpu` and `--target` are. On one hand, you'd expect CLI arguments to always\n     // override anything that's implicit, so e.g. when there's no `--target` flag, features implied\n-    // the host target are overriden by `-Ctarget-cpu=*`. On the other hand, what about when both\n+    // the host target are overridden by `-Ctarget-cpu=*`. On the other hand, what about when both\n     // `--target` and `-Ctarget-cpu=*` are specified? Both then imply some target features and both\n     // flags are specified by the user on the CLI. It isn't as clear-cut which order of precedence\n     // should be taken in cases like these."}, {"sha": "37e84046901f695ee1533b906ea63ed225bc736d", "filename": "compiler/rustc_codegen_ssa/src/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs?ref=40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee", "patch": "@@ -1,6 +1,6 @@\n // Type Names for Debug Info.\n \n-// Notes on targetting MSVC:\n+// Notes on targeting MSVC:\n // In general, MSVC's debugger attempts to parse all arguments as C++ expressions,\n // even if the argument is explicitly a symbol name.\n // As such, there are many things that cause parsing issues:"}, {"sha": "16870489176d77cb3da5c6081f43ab9cfbdfb7c7", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee", "patch": "@@ -535,7 +535,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let val =\n                     self.subst_from_current_frame_and_normalize_erasing_regions(constant.literal)?;\n                 // This can still fail:\n-                // * During ConstProp, with `TooGeneric` or since the `requried_consts` were not all\n+                // * During ConstProp, with `TooGeneric` or since the `required_consts` were not all\n                 //   checked yet.\n                 // * During CTFE, since promoteds in `const`/`static` initializer bodies can fail.\n "}, {"sha": "43c9e9296b90aab2928f7ba275e1d5ef2d6eff12", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee", "patch": "@@ -1228,7 +1228,7 @@ pub fn report_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str) {\n ///\n /// A custom rustc driver can skip calling this to set up a custom ICE hook.\n pub fn install_ice_hook() {\n-    // If the user has not explicitly overriden \"RUST_BACKTRACE\", then produce\n+    // If the user has not explicitly overridden \"RUST_BACKTRACE\", then produce\n     // full backtraces. When a compiler ICE happens, we want to gather\n     // as much information as possible to present in the issue opened\n     // by the user. Compiler developers and other rustc users can"}, {"sha": "3b73abaf776c25bbda797300c44dada05266b1cc", "filename": "compiler/rustc_error_codes/src/error_codes/E0772.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0772.md", "raw_url": "https://github.com/rust-lang/rust/raw/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0772.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0772.md?ref=40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee", "patch": "@@ -45,7 +45,7 @@ trait object's internal data to be accessed safely from any trait methods. This\n rule also goes for any lifetime any struct made into a trait object may have.\n \n In the implementation for `dyn Person`, the `'2` lifetime representing the\n-internal data was ommitted, meaning that the compiler inferred the lifetime\n+internal data was omitted, meaning that the compiler inferred the lifetime\n `'static`. As a result, the implementation's `is_cool` is inferred by the\n compiler to look like this:\n "}, {"sha": "4af376b983c94a44ec2baca5bca2df9d3cd2c483", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee", "patch": "@@ -1841,7 +1841,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n         self.flat_map_node(node)\n     }\n \n-    fn flat_map_stmt(&mut self, mut node: ast::Stmt) -> SmallVec<[ast::Stmt; 1]> {\n+    fn flat_map_stmt(&mut self, node: ast::Stmt) -> SmallVec<[ast::Stmt; 1]> {\n         // FIXME: invocations in semicolon-less expressions positions are expanded as expressions,\n         // changing that requires some compatibility measures.\n         if node.is_expr() {\n@@ -1863,7 +1863,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                     self.cx.current_expansion.is_trailing_mac = false;\n                     res\n                 }\n-                _ => assign_id!(self, &mut node.id, || noop_flat_map_stmt(node, self)),\n+                _ => noop_flat_map_stmt(node, self),\n             };\n         }\n "}, {"sha": "bb36dfd793d4a03bb3a8b96a50b281661323079f", "filename": "compiler/rustc_expand/src/mbe/macro_parser.rs", "status": "modified", "additions": 115, "deletions": 101, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs?ref=40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee", "patch": "@@ -154,7 +154,7 @@ type NamedMatchVec = SmallVec<[NamedMatch; 4]>;\n /// lifetime. By separating `'tt` from `'root`, we can show that.\n #[derive(Clone)]\n struct MatcherPos<'root, 'tt> {\n-    /// The token or sequence of tokens that make up the matcher\n+    /// The token or sequence of tokens that make up the matcher. `elts` is short for \"elements\".\n     top_elts: TokenTreeOrTokenTreeSlice<'tt>,\n \n     /// The position of the \"dot\" in this matcher\n@@ -184,17 +184,8 @@ struct MatcherPos<'root, 'tt> {\n     /// in this matcher.\n     match_hi: usize,\n \n-    // The following fields are used if we are matching a repetition. If we aren't, they should be\n-    // `None`.\n-    /// The KleeneOp of this sequence if we are in a repetition.\n-    seq_op: Option<mbe::KleeneOp>,\n-\n-    /// The separator if we are in a repetition.\n-    sep: Option<Token>,\n-\n-    /// The \"parent\" matcher position if we are in a repetition. That is, the matcher position just\n-    /// before we enter the sequence.\n-    up: Option<MatcherPosHandle<'root, 'tt>>,\n+    /// This field is only used if we are matching a repetition.\n+    repetition: Option<MatcherPosRepetition<'root, 'tt>>,\n \n     /// Specifically used to \"unzip\" token trees. By \"unzip\", we mean to unwrap the delimiters from\n     /// a delimited token tree (e.g., something wrapped in `(` `)`) or to get the contents of a doc\n@@ -207,14 +198,58 @@ struct MatcherPos<'root, 'tt> {\n     stack: SmallVec<[MatcherTtFrame<'tt>; 1]>,\n }\n \n+// This type is used a lot. Make sure it doesn't unintentionally get bigger.\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+rustc_data_structures::static_assert_size!(MatcherPos<'_, '_>, 192);\n+\n impl<'root, 'tt> MatcherPos<'root, 'tt> {\n+    /// Generates the top-level matcher position in which the \"dot\" is before the first token of\n+    /// the matcher `ms`.\n+    fn new(ms: &'tt [TokenTree]) -> Self {\n+        let match_idx_hi = count_names(ms);\n+        MatcherPos {\n+            // Start with the top level matcher given to us.\n+            top_elts: TtSeq(ms),\n+\n+            // The \"dot\" is before the first token of the matcher.\n+            idx: 0,\n+\n+            // Initialize `matches` to a bunch of empty `Vec`s -- one for each metavar in\n+            // `top_elts`. `match_lo` for `top_elts` is 0 and `match_hi` is `match_idx_hi`.\n+            // `match_cur` is 0 since we haven't actually matched anything yet.\n+            matches: create_matches(match_idx_hi),\n+            match_lo: 0,\n+            match_cur: 0,\n+            match_hi: match_idx_hi,\n+\n+            // Haven't descended into any delimiters, so this is empty.\n+            stack: smallvec![],\n+\n+            // Haven't descended into any sequences, so this is `None`.\n+            repetition: None,\n+        }\n+    }\n+\n     /// Adds `m` as a named match for the `idx`-th metavar.\n     fn push_match(&mut self, idx: usize, m: NamedMatch) {\n         let matches = Lrc::make_mut(&mut self.matches[idx]);\n         matches.push(m);\n     }\n }\n \n+#[derive(Clone)]\n+struct MatcherPosRepetition<'root, 'tt> {\n+    /// The KleeneOp of this sequence.\n+    seq_op: mbe::KleeneOp,\n+\n+    /// The separator.\n+    sep: Option<Token>,\n+\n+    /// The \"parent\" matcher position. That is, the matcher position just before we enter the\n+    /// sequence.\n+    up: MatcherPosHandle<'root, 'tt>,\n+}\n+\n // Lots of MatcherPos instances are created at runtime. Allocating them on the\n // heap is slow. Furthermore, using SmallVec<MatcherPos> to allocate them all\n // on the stack is also slow, because MatcherPos is quite a large type and\n@@ -258,6 +293,12 @@ impl<'root, 'tt> DerefMut for MatcherPosHandle<'root, 'tt> {\n     }\n }\n \n+enum EofItems<'root, 'tt> {\n+    None,\n+    One(MatcherPosHandle<'root, 'tt>),\n+    Multiple,\n+}\n+\n /// Represents the possible results of an attempted parse.\n crate enum ParseResult<T> {\n     /// Parsed successfully.\n@@ -300,35 +341,6 @@ fn create_matches(len: usize) -> Box<[Lrc<NamedMatchVec>]> {\n     .into_boxed_slice()\n }\n \n-/// Generates the top-level matcher position in which the \"dot\" is before the first token of the\n-/// matcher `ms`.\n-fn initial_matcher_pos<'root, 'tt>(ms: &'tt [TokenTree]) -> MatcherPos<'root, 'tt> {\n-    let match_idx_hi = count_names(ms);\n-    let matches = create_matches(match_idx_hi);\n-    MatcherPos {\n-        // Start with the top level matcher given to us\n-        top_elts: TtSeq(ms), // \"elts\" is an abbr. for \"elements\"\n-        // The \"dot\" is before the first token of the matcher\n-        idx: 0,\n-\n-        // Initialize `matches` to a bunch of empty `Vec`s -- one for each metavar in `top_elts`.\n-        // `match_lo` for `top_elts` is 0 and `match_hi` is `matches.len()`. `match_cur` is 0 since\n-        // we haven't actually matched anything yet.\n-        matches,\n-        match_lo: 0,\n-        match_cur: 0,\n-        match_hi: match_idx_hi,\n-\n-        // Haven't descended into any delimiters, so empty stack\n-        stack: smallvec![],\n-\n-        // Haven't descended into any sequences, so both of these are `None`.\n-        seq_op: None,\n-        sep: None,\n-        up: None,\n-    }\n-}\n-\n /// `NamedMatch` is a pattern-match result for a single `token::MATCH_NONTERMINAL`:\n /// so it is associated with a single ident in a parse, and all\n /// `MatchedNonterminal`s in the `NamedMatch` have the same non-terminal type\n@@ -475,10 +487,10 @@ fn inner_parse_loop<'root, 'tt>(\n     sess: &ParseSess,\n     cur_items: &mut SmallVec<[MatcherPosHandle<'root, 'tt>; 1]>,\n     next_items: &mut Vec<MatcherPosHandle<'root, 'tt>>,\n-    eof_items: &mut SmallVec<[MatcherPosHandle<'root, 'tt>; 1]>,\n     bb_items: &mut SmallVec<[MatcherPosHandle<'root, 'tt>; 1]>,\n+    eof_items: &mut EofItems<'root, 'tt>,\n     token: &Token,\n-) -> ParseResult<()> {\n+) -> Result<(), (rustc_span::Span, String)> {\n     // Pop items from `cur_items` until it is empty.\n     while let Some(mut item) = cur_items.pop() {\n         // When unzipped trees end, remove them. This corresponds to backtracking out of a\n@@ -504,7 +516,7 @@ fn inner_parse_loop<'root, 'tt>(\n             // We are repeating iff there is a parent. If the matcher is inside of a repetition,\n             // then we could be at the end of a sequence or at the beginning of the next\n             // repetition.\n-            if item.up.is_some() {\n+            if let Some(repetition) = &item.repetition {\n                 // At this point, regardless of whether there is a separator, we should add all\n                 // matches from the complete repetition of the sequence to the shared, top-level\n                 // `matches` list (actually, `up.matches`, which could itself not be the top-level,\n@@ -515,7 +527,7 @@ fn inner_parse_loop<'root, 'tt>(\n                 // NOTE: removing the condition `idx == len` allows trailing separators.\n                 if idx == len {\n                     // Get the `up` matcher\n-                    let mut new_pos = item.up.clone().unwrap();\n+                    let mut new_pos = repetition.up.clone();\n \n                     // Add matches from this repetition to the `matches` of `up`\n                     for idx in item.match_lo..item.match_hi {\n@@ -530,32 +542,33 @@ fn inner_parse_loop<'root, 'tt>(\n                 }\n \n                 // Check if we need a separator.\n-                if idx == len && item.sep.is_some() {\n+                if idx == len && repetition.sep.is_some() {\n                     // We have a separator, and it is the current token. We can advance past the\n                     // separator token.\n-                    if item.sep.as_ref().map_or(false, |sep| token_name_eq(token, sep)) {\n+                    if repetition.sep.as_ref().map_or(false, |sep| token_name_eq(token, sep)) {\n                         item.idx += 1;\n                         next_items.push(item);\n                     }\n-                }\n-                // We don't need a separator. Move the \"dot\" back to the beginning of the matcher\n-                // and try to match again UNLESS we are only allowed to have _one_ repetition.\n-                else if item.seq_op != Some(mbe::KleeneOp::ZeroOrOne) {\n+                } else if repetition.seq_op != mbe::KleeneOp::ZeroOrOne {\n+                    // We don't need a separator. Move the \"dot\" back to the beginning of the\n+                    // matcher and try to match again UNLESS we are only allowed to have _one_\n+                    // repetition.\n                     item.match_cur = item.match_lo;\n                     item.idx = 0;\n                     cur_items.push(item);\n                 }\n+            } else {\n+                // If we are not in a repetition, then being at the end of a matcher means that we\n+                // have reached the potential end of the input.\n+                *eof_items = match eof_items {\n+                    EofItems::None => EofItems::One(item),\n+                    EofItems::One(_) | EofItems::Multiple => EofItems::Multiple,\n+                }\n             }\n-            // If we are not in a repetition, then being at the end of a matcher means that we have\n-            // reached the potential end of the input.\n-            else {\n-                eof_items.push(item);\n-            }\n-        }\n-        // We are in the middle of a matcher.\n-        else {\n-            // Look at what token in the matcher we are trying to match the current token (`token`)\n-            // against. Depending on that, we may generate new items.\n+        } else {\n+            // We are in the middle of a matcher. Look at what token in the matcher we are trying\n+            // to match the current token (`token`) against. Depending on that, we may generate new\n+            // items.\n             match item.top_elts.get_tt(idx) {\n                 // Need to descend into a sequence\n                 TokenTree::Sequence(sp, seq) => {\n@@ -578,22 +591,24 @@ fn inner_parse_loop<'root, 'tt>(\n                     let matches = create_matches(item.matches.len());\n                     cur_items.push(MatcherPosHandle::Box(Box::new(MatcherPos {\n                         stack: smallvec![],\n-                        sep: seq.separator.clone(),\n-                        seq_op: Some(seq.kleene.op),\n                         idx: 0,\n                         matches,\n                         match_lo: item.match_cur,\n                         match_cur: item.match_cur,\n                         match_hi: item.match_cur + seq.num_captures,\n-                        up: Some(item),\n+                        repetition: Some(MatcherPosRepetition {\n+                            up: item,\n+                            sep: seq.separator.clone(),\n+                            seq_op: seq.kleene.op,\n+                        }),\n                         top_elts: Tt(TokenTree::Sequence(sp, seq)),\n                     })));\n                 }\n \n                 // We need to match a metavar (but the identifier is invalid)... this is an error\n                 TokenTree::MetaVarDecl(span, _, None) => {\n                     if sess.missing_fragment_specifiers.borrow_mut().remove(&span).is_some() {\n-                        return Error(span, \"missing fragment specifier\".to_string());\n+                        return Err((span, \"missing fragment specifier\".to_string()));\n                     }\n                 }\n \n@@ -641,7 +656,7 @@ fn inner_parse_loop<'root, 'tt>(\n     }\n \n     // Yay a successful parse (so far)!\n-    Success(())\n+    Ok(())\n }\n \n /// Use the given sequence of token trees (`ms`) as a matcher. Match the token\n@@ -659,17 +674,18 @@ pub(super) fn parse_tt(\n     //\n     // This MatcherPos instance is allocated on the stack. All others -- and\n     // there are frequently *no* others! -- are allocated on the heap.\n-    let mut initial = initial_matcher_pos(ms);\n+    let mut initial = MatcherPos::new(ms);\n     let mut cur_items = smallvec![MatcherPosHandle::Ref(&mut initial)];\n     let mut next_items = Vec::new();\n \n     loop {\n+        assert!(next_items.is_empty());\n+\n         // Matcher positions black-box parsed by parser.rs (`parser`)\n         let mut bb_items = SmallVec::new();\n \n         // Matcher positions that would be valid if the macro invocation was over now\n-        let mut eof_items = SmallVec::new();\n-        assert!(next_items.is_empty());\n+        let mut eof_items = EofItems::None;\n \n         // Process `cur_items` until either we have finished the input or we need to get some\n         // parsing from the black-box parser done. The result is that `next_items` will contain a\n@@ -678,37 +694,34 @@ pub(super) fn parse_tt(\n             parser.sess,\n             &mut cur_items,\n             &mut next_items,\n-            &mut eof_items,\n             &mut bb_items,\n+            &mut eof_items,\n             &parser.token,\n         ) {\n-            Success(_) => {}\n-            Failure(token, msg) => return Failure(token, msg),\n-            Error(sp, msg) => return Error(sp, msg),\n-            ErrorReported => return ErrorReported,\n+            Ok(()) => {}\n+            Err((sp, msg)) => return Error(sp, msg),\n         }\n \n         // inner parse loop handled all cur_items, so it's empty\n         assert!(cur_items.is_empty());\n \n-        // We need to do some post processing after the `inner_parser_loop`.\n+        // We need to do some post processing after the `inner_parse_loop`.\n         //\n         // Error messages here could be improved with links to original rules.\n \n         // If we reached the EOF, check that there is EXACTLY ONE possible matcher. Otherwise,\n         // either the parse is ambiguous (which should never happen) or there is a syntax error.\n         if parser.token == token::Eof {\n-            if eof_items.len() == 1 {\n-                let matches =\n-                    eof_items[0].matches.iter_mut().map(|dv| Lrc::make_mut(dv).pop().unwrap());\n-                return nameize(parser.sess, ms, matches);\n-            } else if eof_items.len() > 1 {\n-                return Error(\n-                    parser.token.span,\n-                    \"ambiguity: multiple successful parses\".to_string(),\n-                );\n-            } else {\n-                return Failure(\n+            return match eof_items {\n+                EofItems::One(mut eof_item) => {\n+                    let matches =\n+                        eof_item.matches.iter_mut().map(|dv| Lrc::make_mut(dv).pop().unwrap());\n+                    nameize(parser.sess, ms, matches)\n+                }\n+                EofItems::Multiple => {\n+                    Error(parser.token.span, \"ambiguity: multiple successful parses\".to_string())\n+                }\n+                EofItems::None => Failure(\n                     Token::new(\n                         token::Eof,\n                         if parser.token.span.is_dummy() {\n@@ -718,22 +731,23 @@ pub(super) fn parse_tt(\n                         },\n                     ),\n                     \"missing tokens in macro arguments\",\n-                );\n-            }\n+                ),\n+            };\n         }\n-        // Performance hack: eof_items may share matchers via Rc with other things that we want\n-        // to modify. Dropping eof_items now may drop these refcounts to 1, preventing an\n-        // unnecessary implicit clone later in Rc::make_mut.\n+        // Performance hack: `eof_items` may share matchers via `Rc` with other things that we want\n+        // to modify. Dropping `eof_items` now may drop these refcounts to 1, preventing an\n+        // unnecessary implicit clone later in `Rc::make_mut`.\n         drop(eof_items);\n \n         // If there are no possible next positions AND we aren't waiting for the black-box parser,\n         // then there is a syntax error.\n         if bb_items.is_empty() && next_items.is_empty() {\n             return Failure(parser.token.clone(), \"no rules expected this token in macro call\");\n         }\n-        // Another possibility is that we need to call out to parse some rust nonterminal\n-        // (black-box) parser. However, if there is not EXACTLY ONE of these, something is wrong.\n-        else if (!bb_items.is_empty() && !next_items.is_empty()) || bb_items.len() > 1 {\n+\n+        if (!bb_items.is_empty() && !next_items.is_empty()) || bb_items.len() > 1 {\n+            // We need to call out to parse some rust nonterminal (black-box) parser. But something\n+            // is wrong, because there is not EXACTLY ONE of these.\n             let nts = bb_items\n                 .iter()\n                 .map(|item| match item.top_elts.get_tt(item.idx) {\n@@ -755,15 +769,15 @@ pub(super) fn parse_tt(\n                 ),\n             );\n         }\n-        // Dump all possible `next_items` into `cur_items` for the next iteration.\n-        else if !next_items.is_empty() {\n-            // Now process the next token\n+\n+        if !next_items.is_empty() {\n+            // Dump all possible `next_items` into `cur_items` for the next iteration. Then process\n+            // the next token.\n             cur_items.extend(next_items.drain(..));\n             parser.to_mut().bump();\n-        }\n-        // Finally, we have the case where we need to call the black-box parser to get some\n-        // nonterminal.\n-        else {\n+        } else {\n+            // Finally, we have the case where we need to call the black-box parser to get some\n+            // nonterminal.\n             assert_eq!(bb_items.len(), 1);\n \n             let mut item = bb_items.pop().unwrap();"}, {"sha": "760dea77f9c2b1ecc9f2c018342dffadab2bb2e6", "filename": "compiler/rustc_expand/src/mbe/transcribe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs?ref=40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee", "patch": "@@ -233,7 +233,7 @@ pub(super) fn transcribe<'a>(\n                         } else {\n                             // Other variables are emitted into the output stream as groups with\n                             // `Delimiter::None` to maintain parsing priorities.\n-                            // `Interpolated` is currenty used for such groups in rustc parser.\n+                            // `Interpolated` is currently used for such groups in rustc parser.\n                             marker.visit_span(&mut sp);\n                             TokenTree::token(token::Interpolated(nt.clone()), sp)\n                         };"}, {"sha": "0aef5982cff509ccd066b6584fb6b9b071d7a191", "filename": "compiler/rustc_expand/src/proc_macro_server.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs?ref=40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee", "patch": "@@ -847,7 +847,7 @@ impl server::Span for Rustc<'_, '_> {\n     /// the `quote` proc-macro. This will save the span of\n     /// \"hello\" into the metadata of `my_proc_macro`. As a result,\n     /// the body of `my_proc_macro` (after expansion) will end\n-    /// up containg a call that looks like this:\n+    /// up containing a call that looks like this:\n     /// `proc_macro::Ident::new(\"hello\", proc_macro::Span::recover_proc_macro_span(0))`\n     ///\n     /// where `0` is the id returned by this function."}, {"sha": "908a936142475bce5cd080b53393c68516b3c292", "filename": "compiler/rustc_incremental/src/persist/load.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs?ref=40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee", "patch": "@@ -27,7 +27,7 @@ pub enum LoadResult<T> {\n     },\n     /// The file either didn't exist or was produced by an incompatible compiler version.\n     DataOutOfDate,\n-    /// An error occured.\n+    /// An error occurred.\n     Error {\n         #[allow(missing_docs)]\n         message: String,"}, {"sha": "16f7504cbbe588a8ab07ef707d3af7d7fcff4acd", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee", "patch": "@@ -928,7 +928,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n /// performing that replacement, we'll turn all remaining infer type params to use their name from\n /// their definition, and replace all the `[type error]`s back to being infer so they display in\n /// the output as `_`. If we didn't go through `[type error]`, we would either show all type params\n-/// by their name *or* `_`, neither of which is desireable: we want to show all types that we could\n+/// by their name *or* `_`, neither of which is desirable: we want to show all types that we could\n /// infer as `_` to reduce verbosity and avoid telling the user about unnecessary type annotations.\n struct ResolvedTypeParamEraser<'tcx> {\n     tcx: TyCtxt<'tcx>,"}, {"sha": "4710eae6189a5fc087819f915fef1f9b26636d1a", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/mismatched_static_lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmismatched_static_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmismatched_static_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmismatched_static_lifetime.rs?ref=40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee", "patch": "@@ -58,7 +58,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                 bug!(\"Node not an impl.\");\n             };\n \n-            // Next, let's figure out the set of trait objects with implict static bounds\n+            // Next, let's figure out the set of trait objects with implicit static bounds\n             let ty = self.tcx().type_of(*impl_def_id);\n             let mut v = super::static_impl_trait::TraitObjectVisitor(FxHashSet::default());\n             v.visit_ty(ty);"}, {"sha": "06f73c1c91600d4a955e39c5331dc4190b3efcce", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee", "patch": "@@ -26,7 +26,7 @@ use rustc_middle::mir::interpret;\n use rustc_middle::thir;\n use rustc_middle::traits::specialization_graph;\n use rustc_middle::ty::codec::TyEncoder;\n-use rustc_middle::ty::fast_reject::{self, SimplifiedType, SimplifyParams};\n+use rustc_middle::ty::fast_reject::{self, SimplifiedType, TreatParams};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, SymbolName, Ty, TyCtxt};\n use rustc_serialize::{opaque, Encodable, Encoder};\n@@ -2043,7 +2043,7 @@ impl<'tcx, 'v> ItemLikeVisitor<'v> for ImplsVisitor<'tcx> {\n                     let simplified_self_ty = fast_reject::simplify_type(\n                         self.tcx,\n                         trait_ref.self_ty(),\n-                        SimplifyParams::No,\n+                        TreatParams::AsPlaceholders,\n                     );\n \n                     self.impls"}, {"sha": "c0dd4db2945dc0f0c710b0449d08a3d215943fc8", "filename": "compiler/rustc_middle/src/ty/fast_reject.rs", "status": "modified", "additions": 33, "deletions": 36, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs?ref=40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee", "patch": "@@ -49,36 +49,36 @@ where\n }\n \n #[derive(PartialEq, Eq, Debug, Clone, Copy)]\n-pub enum SimplifyParams {\n-    Yes,\n-    No,\n+pub enum TreatParams {\n+    /// Treat parameters as bound types in the given environment.\n+    ///\n+    /// For this to be correct the input has to be fully normalized\n+    /// in its param env as it may otherwise cause us to ignore\n+    /// potentially applying impls.\n+    AsBoundTypes,\n+    AsPlaceholders,\n }\n \n /// Tries to simplify a type by only returning the outermost injective\u00b9 layer, if one exists.\n ///\n /// The idea is to get something simple that we can use to quickly decide if two types could unify,\n /// for example during method lookup.\n ///\n-/// A special case here are parameters and projections. Projections can be normalized to\n-/// a different type, meaning that `<T as Trait>::Assoc` and `u8` can be unified, even though\n-/// their outermost layer is different while parameters like `T` of impls are later replaced\n-/// with an inference variable, which then also allows unification with other types.\n+/// A special case here are parameters and projections, which are only injective\n+/// if they are treated as bound types.\n ///\n-/// When using `SimplifyParams::Yes`, we still return a simplified type for params and projections\u00b2,\n-/// the reasoning for this can be seen at the places doing this.\n+/// For example when storing impls based on their simplified self type, we treat\n+/// generic parameters as placeholders. We must not simplify them here,\n+/// as they can unify with any other type.\n ///\n+/// With projections we have to be even more careful, as even when treating them as bound types\n+/// this is still only correct if they are fully normalized.\n ///\n-/// \u00b9 meaning that if two outermost layers are different, then the whole types are also different.\n-/// \u00b2 FIXME(@lcnr): this seems like it can actually end up being unsound with the way it's used during\n-///   candidate selection. We do not consider non blanket impls for `<_ as Trait>::Assoc` even\n-///   though `_` can be inferred to a concrete type later at which point a concrete impl\n-///   could actually apply. After experimenting for about an hour I wasn't able to cause any issues\n-///   this way so I am not going to change this until we actually find an issue as I am really\n-///   interesting in getting an actual test for this.\n-pub fn simplify_type(\n-    tcx: TyCtxt<'_>,\n-    ty: Ty<'_>,\n-    can_simplify_params: SimplifyParams,\n+/// \u00b9 meaning that if the outermost layers are different, then the whole types are also different.\n+pub fn simplify_type<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    ty: Ty<'tcx>,\n+    treat_params: TreatParams,\n ) -> Option<SimplifiedType> {\n     match *ty.kind() {\n         ty::Bool => Some(BoolSimplifiedType),\n@@ -91,7 +91,7 @@ pub fn simplify_type(\n         ty::Array(..) => Some(ArraySimplifiedType),\n         ty::Slice(..) => Some(SliceSimplifiedType),\n         ty::RawPtr(ptr) => Some(PtrSimplifiedType(ptr.mutbl)),\n-        ty::Dynamic(ref trait_info, ..) => match trait_info.principal_def_id() {\n+        ty::Dynamic(trait_info, ..) => match trait_info.principal_def_id() {\n             Some(principal_def_id) if !tcx.trait_is_auto(principal_def_id) => {\n                 Some(TraitSimplifiedType(principal_def_id))\n             }\n@@ -100,24 +100,21 @@ pub fn simplify_type(\n         ty::Ref(_, _, mutbl) => Some(RefSimplifiedType(mutbl)),\n         ty::FnDef(def_id, _) | ty::Closure(def_id, _) => Some(ClosureSimplifiedType(def_id)),\n         ty::Generator(def_id, _, _) => Some(GeneratorSimplifiedType(def_id)),\n-        ty::GeneratorWitness(ref tys) => {\n-            Some(GeneratorWitnessSimplifiedType(tys.skip_binder().len()))\n-        }\n+        ty::GeneratorWitness(tys) => Some(GeneratorWitnessSimplifiedType(tys.skip_binder().len())),\n         ty::Never => Some(NeverSimplifiedType),\n-        ty::Tuple(ref tys) => Some(TupleSimplifiedType(tys.len())),\n-        ty::FnPtr(ref f) => Some(FunctionSimplifiedType(f.skip_binder().inputs().len())),\n-        ty::Projection(_) | ty::Param(_) => {\n-            if can_simplify_params == SimplifyParams::Yes {\n-                // In normalized types, projections don't unify with\n-                // anything. when lazy normalization happens, this\n-                // will change. It would still be nice to have a way\n-                // to deal with known-not-to-unify-with-anything\n-                // projections (e.g., the likes of <__S as Encoder>::Error).\n+        ty::Tuple(tys) => Some(TupleSimplifiedType(tys.len())),\n+        ty::FnPtr(f) => Some(FunctionSimplifiedType(f.skip_binder().inputs().len())),\n+        ty::Param(_) | ty::Projection(_) => match treat_params {\n+            // When treated as bound types, projections don't unify with\n+            // anything as long as they are fully normalized.\n+            //\n+            // We will have to be careful with lazy normalization here.\n+            TreatParams::AsBoundTypes => {\n+                debug!(\"treating `{}` as a bound type\", ty);\n                 Some(ParameterSimplifiedType)\n-            } else {\n-                None\n             }\n-        }\n+            TreatParams::AsPlaceholders => None,\n+        },\n         ty::Opaque(def_id, _) => Some(OpaqueSimplifiedType(def_id)),\n         ty::Foreign(def_id) => Some(ForeignSimplifiedType(def_id)),\n         ty::Placeholder(..) | ty::Bound(..) | ty::Infer(_) | ty::Error(_) => None,"}, {"sha": "8ebeca50c4174c5b8d353fc7bbc0be39c81fa5d5", "filename": "compiler/rustc_middle/src/ty/trait_def.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs?ref=40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee", "patch": "@@ -1,5 +1,5 @@\n use crate::traits::specialization_graph;\n-use crate::ty::fast_reject::{self, SimplifiedType, SimplifyParams};\n+use crate::ty::fast_reject::{self, SimplifiedType, TreatParams};\n use crate::ty::fold::TypeFoldable;\n use crate::ty::{Ident, Ty, TyCtxt};\n use rustc_hir as hir;\n@@ -150,7 +150,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         self_ty: Ty<'tcx>,\n     ) -> impl Iterator<Item = DefId> + 'tcx {\n         let impls = self.trait_impls_of(def_id);\n-        if let Some(simp) = fast_reject::simplify_type(self, self_ty, SimplifyParams::No) {\n+        if let Some(simp) = fast_reject::simplify_type(self, self_ty, TreatParams::AsPlaceholders) {\n             if let Some(impls) = impls.non_blanket_impls.get(&simp) {\n                 return impls.iter().copied();\n             }\n@@ -180,14 +180,14 @@ impl<'tcx> TyCtxt<'tcx> {\n             }\n         }\n \n-        // Note that we're using `SimplifyParams::Yes` to query `non_blanket_impls` while using\n-        // `SimplifyParams::No` while actually adding them.\n+        // Note that we're using `TreatParams::AsBoundTypes` to query `non_blanket_impls` while using\n+        // `TreatParams::AsPlaceholders` while actually adding them.\n         //\n         // This way, when searching for some impl for `T: Trait`, we do not look at any impls\n         // whose outer level is not a parameter or projection. Especially for things like\n         // `T: Clone` this is incredibly useful as we would otherwise look at all the impls\n         // of `Clone` for `Option<T>`, `Vec<T>`, `ConcreteType` and so on.\n-        if let Some(simp) = fast_reject::simplify_type(self, self_ty, SimplifyParams::Yes) {\n+        if let Some(simp) = fast_reject::simplify_type(self, self_ty, TreatParams::AsBoundTypes) {\n             if let Some(impls) = impls.non_blanket_impls.get(&simp) {\n                 for &impl_def_id in impls {\n                     if let result @ Some(_) = f(impl_def_id) {\n@@ -247,7 +247,7 @@ pub(super) fn trait_impls_of_provider(tcx: TyCtxt<'_>, trait_id: DefId) -> Trait\n         }\n \n         if let Some(simplified_self_ty) =\n-            fast_reject::simplify_type(tcx, impl_self_ty, SimplifyParams::No)\n+            fast_reject::simplify_type(tcx, impl_self_ty, TreatParams::AsPlaceholders)\n         {\n             impls.non_blanket_impls.entry(simplified_self_ty).or_default().push(impl_def_id);\n         } else {"}, {"sha": "3342bd146c4ee50a6c8a6f948aa9aa64af30bec0", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee", "patch": "@@ -3207,7 +3207,7 @@ impl<'a> Resolver<'a> {\n                     }\n                 }\n             }\n-            ImportKind::ExternCrate { source, target, .. } => {\n+            ImportKind::ExternCrate { source, target } => {\n                 suggestion = Some(format!(\n                     \"extern crate {} as {};\",\n                     source.unwrap_or(target.name),"}, {"sha": "63efa951f9674717f5af28044c85678c20160027", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee", "patch": "@@ -20,7 +20,7 @@ use rustc_hir::CRATE_HIR_ID;\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_infer::traits::TraitEngine;\n use rustc_middle::traits::specialization_graph::OverlapMode;\n-use rustc_middle::ty::fast_reject::{self, SimplifyParams};\n+use rustc_middle::ty::fast_reject::{self, TreatParams};\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n@@ -87,8 +87,8 @@ where\n         impl2_ref.iter().flat_map(|tref| tref.substs.types()),\n     )\n     .any(|(ty1, ty2)| {\n-        let t1 = fast_reject::simplify_type(tcx, ty1, SimplifyParams::No);\n-        let t2 = fast_reject::simplify_type(tcx, ty2, SimplifyParams::No);\n+        let t1 = fast_reject::simplify_type(tcx, ty1, TreatParams::AsPlaceholders);\n+        let t2 = fast_reject::simplify_type(tcx, ty2, TreatParams::AsPlaceholders);\n \n         if let (Some(t1), Some(t2)) = (t1, t2) {\n             // Simplified successfully"}, {"sha": "8af4606db85200eec7d87ecd70e71776ee725ffe", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee", "patch": "@@ -36,7 +36,7 @@ use rustc_infer::infer::LateBoundRegionConversionTime;\n use rustc_middle::dep_graph::{DepKind, DepNodeIndex};\n use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::thir::abstract_const::NotConstEvaluatable;\n-use rustc_middle::ty::fast_reject::{self, SimplifyParams};\n+use rustc_middle::ty::fast_reject::{self, TreatParams};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::relate::TypeRelation;\n use rustc_middle::ty::subst::{GenericArgKind, Subst, SubstsRef};\n@@ -2176,8 +2176,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn fast_reject_trait_refs(\n         &mut self,\n-        obligation: &TraitObligation<'_>,\n-        impl_trait_ref: &ty::TraitRef<'_>,\n+        obligation: &TraitObligation<'tcx>,\n+        impl_trait_ref: &ty::TraitRef<'tcx>,\n     ) -> bool {\n         // We can avoid creating type variables and doing the full\n         // substitution if we find that any of the input types, when\n@@ -2193,10 +2193,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         let simplified_obligation_ty = fast_reject::simplify_type(\n                             self.tcx(),\n                             obligation_ty,\n-                            SimplifyParams::Yes,\n+                            TreatParams::AsBoundTypes,\n+                        );\n+                        let simplified_impl_ty = fast_reject::simplify_type(\n+                            self.tcx(),\n+                            impl_ty,\n+                            TreatParams::AsPlaceholders,\n                         );\n-                        let simplified_impl_ty =\n-                            fast_reject::simplify_type(self.tcx(), impl_ty, SimplifyParams::No);\n \n                         simplified_obligation_ty.is_some()\n                             && simplified_impl_ty.is_some()"}, {"sha": "8b23dcfe3808abce209899d91b369e28e7dfd85f", "filename": "compiler/rustc_trait_selection/src/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee", "patch": "@@ -2,7 +2,7 @@ use super::OverlapError;\n \n use crate::traits;\n use rustc_hir::def_id::DefId;\n-use rustc_middle::ty::fast_reject::{self, SimplifiedType, SimplifyParams};\n+use rustc_middle::ty::fast_reject::{self, SimplifiedType, TreatParams};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{self, TyCtxt, TypeFoldable};\n \n@@ -49,7 +49,9 @@ impl ChildrenExt<'_> for Children {\n     /// Insert an impl into this set of children without comparing to any existing impls.\n     fn insert_blindly(&mut self, tcx: TyCtxt<'_>, impl_def_id: DefId) {\n         let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n-        if let Some(st) = fast_reject::simplify_type(tcx, trait_ref.self_ty(), SimplifyParams::No) {\n+        if let Some(st) =\n+            fast_reject::simplify_type(tcx, trait_ref.self_ty(), TreatParams::AsPlaceholders)\n+        {\n             debug!(\"insert_blindly: impl_def_id={:?} st={:?}\", impl_def_id, st);\n             self.non_blanket_impls.entry(st).or_default().push(impl_def_id)\n         } else {\n@@ -64,7 +66,9 @@ impl ChildrenExt<'_> for Children {\n     fn remove_existing(&mut self, tcx: TyCtxt<'_>, impl_def_id: DefId) {\n         let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n         let vec: &mut Vec<DefId>;\n-        if let Some(st) = fast_reject::simplify_type(tcx, trait_ref.self_ty(), SimplifyParams::No) {\n+        if let Some(st) =\n+            fast_reject::simplify_type(tcx, trait_ref.self_ty(), TreatParams::AsPlaceholders)\n+        {\n             debug!(\"remove_existing: impl_def_id={:?} st={:?}\", impl_def_id, st);\n             vec = self.non_blanket_impls.get_mut(&st).unwrap();\n         } else {\n@@ -312,7 +316,8 @@ impl GraphExt for Graph {\n \n         let mut parent = trait_def_id;\n         let mut last_lint = None;\n-        let simplified = fast_reject::simplify_type(tcx, trait_ref.self_ty(), SimplifyParams::No);\n+        let simplified =\n+            fast_reject::simplify_type(tcx, trait_ref.self_ty(), TreatParams::AsPlaceholders);\n \n         // Descend the specialization tree, where `parent` is the current parent node.\n         loop {"}, {"sha": "0ae2dfa180b9eaaf940ca348cd98afd21bf80ff7", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee", "patch": "@@ -12,7 +12,7 @@ use rustc_hir::lang_items::LangItem;\n use rustc_hir::{ExprKind, Node, QPath};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_middle::traits::util::supertraits;\n-use rustc_middle::ty::fast_reject::{simplify_type, SimplifyParams};\n+use rustc_middle::ty::fast_reject::{simplify_type, TreatParams};\n use rustc_middle::ty::print::with_crate_prefix;\n use rustc_middle::ty::ToPolyTraitRef;\n use rustc_middle::ty::{self, DefIdTree, ToPredicate, Ty, TyCtxt, TypeFoldable};\n@@ -1777,7 +1777,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // FIXME: Even though negative bounds are not implemented, we could maybe handle\n                 // cases where a positive bound implies a negative impl.\n                 (candidates, Vec::new())\n-            } else if let Some(simp_rcvr_ty) = simplify_type(self.tcx, rcvr_ty, SimplifyParams::Yes)\n+            } else if let Some(simp_rcvr_ty) =\n+                simplify_type(self.tcx, rcvr_ty, TreatParams::AsBoundTypes)\n             {\n                 let mut potential_candidates = Vec::new();\n                 let mut explicitly_negative = Vec::new();\n@@ -1792,7 +1793,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         .any(|imp_did| {\n                             let imp = self.tcx.impl_trait_ref(imp_did).unwrap();\n                             let imp_simp =\n-                                simplify_type(self.tcx, imp.self_ty(), SimplifyParams::Yes);\n+                                simplify_type(self.tcx, imp.self_ty(), TreatParams::AsBoundTypes);\n                             imp_simp.map_or(false, |s| s == simp_rcvr_ty)\n                         })\n                     {"}, {"sha": "d2077a63e150a96b6d589ec7d836fe7fab107be5", "filename": "library/core/src/iter/adapters/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmap.rs?ref=40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee", "patch": "@@ -38,7 +38,7 @@ use crate::ops::Try;\n /// }\n /// ```\n ///\n-/// This will print \"('a', 1), ('b', 2), ('c', 3)\".\n+/// This will print `('a', 1), ('b', 2), ('c', 3)`.\n ///\n /// Now consider this twist where we add a call to `rev`. This version will\n /// print `('c', 1), ('b', 2), ('a', 3)`. Note that the letters are reversed,"}, {"sha": "ff01ce273332909b3ee2dd06621f0b0c838549ce", "filename": "library/std/src/sys/unix/thread.rs", "status": "modified", "additions": 82, "deletions": 3, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs?ref=40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee", "patch": "@@ -279,10 +279,15 @@ pub fn available_parallelism() -> io::Result<NonZeroUsize> {\n         ))] {\n             #[cfg(any(target_os = \"android\", target_os = \"linux\"))]\n             {\n+                let quota = cgroup2_quota().max(1);\n                 let mut set: libc::cpu_set_t = unsafe { mem::zeroed() };\n-                if unsafe { libc::sched_getaffinity(0, mem::size_of::<libc::cpu_set_t>(), &mut set) } == 0 {\n-                    let count = unsafe { libc::CPU_COUNT(&set) };\n-                    return Ok(unsafe { NonZeroUsize::new_unchecked(count as usize) });\n+                unsafe {\n+                    if libc::sched_getaffinity(0, mem::size_of::<libc::cpu_set_t>(), &mut set) == 0 {\n+                        let count = libc::CPU_COUNT(&set) as usize;\n+                        let count = count.min(quota);\n+                        // SAFETY: affinity mask can't be empty and the quota gets clamped to a minimum of 1\n+                        return Ok(NonZeroUsize::new_unchecked(count));\n+                    }\n                 }\n             }\n             match unsafe { libc::sysconf(libc::_SC_NPROCESSORS_ONLN) } {\n@@ -368,6 +373,80 @@ pub fn available_parallelism() -> io::Result<NonZeroUsize> {\n     }\n }\n \n+/// Returns cgroup CPU quota in core-equivalents, rounded down, or usize::MAX if the quota cannot\n+/// be determined or is not set.\n+#[cfg(any(target_os = \"android\", target_os = \"linux\"))]\n+fn cgroup2_quota() -> usize {\n+    use crate::ffi::OsString;\n+    use crate::fs::{try_exists, File};\n+    use crate::io::Read;\n+    use crate::os::unix::ffi::OsStringExt;\n+    use crate::path::PathBuf;\n+\n+    let mut quota = usize::MAX;\n+\n+    let _: Option<()> = try {\n+        let mut buf = Vec::with_capacity(128);\n+        // find our place in the cgroup hierarchy\n+        File::open(\"/proc/self/cgroup\").ok()?.read_to_end(&mut buf).ok()?;\n+        let cgroup_path = buf\n+            .split(|&c| c == b'\\n')\n+            .filter_map(|line| {\n+                let mut fields = line.splitn(3, |&c| c == b':');\n+                // expect cgroupv2 which has an empty 2nd field\n+                if fields.nth(1) != Some(b\"\") {\n+                    return None;\n+                }\n+                let path = fields.last()?;\n+                // skip leading slash\n+                Some(path[1..].to_owned())\n+            })\n+            .next()?;\n+        let cgroup_path = PathBuf::from(OsString::from_vec(cgroup_path));\n+\n+        let mut path = PathBuf::with_capacity(128);\n+        let mut read_buf = String::with_capacity(20);\n+\n+        let cgroup_mount = \"/sys/fs/cgroup\";\n+\n+        path.push(cgroup_mount);\n+        path.push(&cgroup_path);\n+\n+        path.push(\"cgroup.controllers\");\n+\n+        // skip if we're not looking at cgroup2\n+        if matches!(try_exists(&path), Err(_) | Ok(false)) {\n+            return usize::MAX;\n+        };\n+\n+        path.pop();\n+\n+        while path.starts_with(cgroup_mount) {\n+            path.push(\"cpu.max\");\n+\n+            read_buf.clear();\n+\n+            if File::open(&path).and_then(|mut f| f.read_to_string(&mut read_buf)).is_ok() {\n+                let raw_quota = read_buf.lines().next()?;\n+                let mut raw_quota = raw_quota.split(' ');\n+                let limit = raw_quota.next()?;\n+                let period = raw_quota.next()?;\n+                match (limit.parse::<usize>(), period.parse::<usize>()) {\n+                    (Ok(limit), Ok(period)) => {\n+                        quota = quota.min(limit / period);\n+                    }\n+                    _ => {}\n+                }\n+            }\n+\n+            path.pop(); // pop filename\n+            path.pop(); // pop dir\n+        }\n+    };\n+\n+    quota\n+}\n+\n #[cfg(all(\n     not(target_os = \"linux\"),\n     not(target_os = \"freebsd\"),"}, {"sha": "09d1e714ab6ddcab91a76175ac32497fe1f6f4ab", "filename": "library/std/src/thread/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs?ref=40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee", "patch": "@@ -1524,7 +1524,10 @@ fn _assert_sync_and_send() {\n ///\n /// On Linux:\n /// - It may overcount the amount of parallelism available when limited by a\n-///   process-wide affinity mask, or when affected by cgroup limits.\n+///   process-wide affinity mask or cgroup quotas and cgroup2 fs or `sched_getaffinity()` can't be\n+///   queried, e.g. due to sandboxing.\n+/// - It may undercount the amount of parallelism if the current thread's affinity mask\n+///   does not reflect the process' cpuset, e.g. due to pinned threads.\n ///\n /// On all targets:\n /// - It may overcount the amount of parallelism available when running in a VM"}, {"sha": "02a4305644e7d57684158e441e83c8181b779c80", "filename": "src/test/rustdoc/macro-higher-kinded-function.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/src%2Ftest%2Frustdoc%2Fmacro-higher-kinded-function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/src%2Ftest%2Frustdoc%2Fmacro-higher-kinded-function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fmacro-higher-kinded-function.rs?ref=40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee", "patch": "@@ -0,0 +1,21 @@\n+#![crate_name = \"foo\"]\n+\n+pub struct TyCtxt<'tcx>(&'tcx u8);\n+\n+macro_rules! gen {\n+    ($(($name:ident, $tcx:lifetime, [$k:ty], [$r:ty]))*) => {\n+        pub struct Providers {\n+            $(pub $name: for<$tcx> fn(TyCtxt<$tcx>, $k) -> $r,)*\n+        }\n+    }\n+}\n+\n+// @has 'foo/struct.Providers.html'\n+// @has - '//*[@class=\"docblock item-decl\"]//code' \"pub a: for<'tcx> fn(_: TyCtxt<'tcx>, _: u8) -> i8,\"\n+// @has - '//*[@class=\"docblock item-decl\"]//code' \"pub b: for<'tcx> fn(_: TyCtxt<'tcx>, _: u16) -> i16,\"\n+// @has - '//*[@id=\"structfield.a\"]/code' \"a: for<'tcx> fn(_: TyCtxt<'tcx>, _: u8) -> i8\"\n+// @has - '//*[@id=\"structfield.b\"]/code' \"b: for<'tcx> fn(_: TyCtxt<'tcx>, _: u16) -> i16\"\n+gen! {\n+    (a, 'tcx, [u8], [i8])\n+    (b, 'tcx, [u16], [i16])\n+}"}, {"sha": "cf76487ed46fb56d9060485f7b23397c71653fb0", "filename": "src/test/ui/check-cfg/stmt-no-ice.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/src%2Ftest%2Fui%2Fcheck-cfg%2Fstmt-no-ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/src%2Ftest%2Fui%2Fcheck-cfg%2Fstmt-no-ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcheck-cfg%2Fstmt-no-ice.rs?ref=40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee", "patch": "@@ -0,0 +1,10 @@\n+// This test checks that there is no ICE with this code\n+//\n+// check-pass\n+// compile-flags:--check-cfg=names() -Z unstable-options\n+\n+fn main() {\n+    #[cfg(crossbeam_loom)]\n+    //~^ WARNING unexpected `cfg` condition name\n+    {}\n+}"}, {"sha": "da65b596911d2884254267724cea4fd3c9d732f7", "filename": "src/test/ui/check-cfg/stmt-no-ice.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/src%2Ftest%2Fui%2Fcheck-cfg%2Fstmt-no-ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee/src%2Ftest%2Fui%2Fcheck-cfg%2Fstmt-no-ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcheck-cfg%2Fstmt-no-ice.stderr?ref=40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee", "patch": "@@ -0,0 +1,10 @@\n+warning: unexpected `cfg` condition name\n+  --> $DIR/stmt-no-ice.rs:7:11\n+   |\n+LL |     #[cfg(crossbeam_loom)]\n+   |           ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(unexpected_cfgs)]` on by default\n+\n+warning: 1 warning emitted\n+"}]}