{"sha": "b175aef0c40d0b60316fabc6b4023c60c5bc832e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxNzVhZWYwYzQwZDBiNjAzMTZmYWJjNmI0MDIzYzYwYzViYzgzMmU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-04-23T09:14:10Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-05-03T19:28:16Z"}, "message": "make transitive relation use a hash map", "tree": {"sha": "7b39c5544a35b1569ec1ef9a6ea0d4992a943982", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7b39c5544a35b1569ec1ef9a6ea0d4992a943982"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b175aef0c40d0b60316fabc6b4023c60c5bc832e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b175aef0c40d0b60316fabc6b4023c60c5bc832e", "html_url": "https://github.com/rust-lang/rust/commit/b175aef0c40d0b60316fabc6b4023c60c5bc832e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b175aef0c40d0b60316fabc6b4023c60c5bc832e/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "488b2a3e7b9d8a4c96f388dc7d8fdd2023ecc815", "url": "https://api.github.com/repos/rust-lang/rust/commits/488b2a3e7b9d8a4c96f388dc7d8fdd2023ecc815", "html_url": "https://github.com/rust-lang/rust/commit/488b2a3e7b9d8a4c96f388dc7d8fdd2023ecc815"}], "stats": {"total": 69, "additions": 42, "deletions": 27}, "files": [{"sha": "0d166cc0b9e81dc071772831c1d2c02eaf6bd390", "filename": "src/librustc_data_structures/transitive_relation.rs", "status": "modified", "additions": 42, "deletions": 27, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/b175aef0c40d0b60316fabc6b4023c60c5bc832e/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b175aef0c40d0b60316fabc6b4023c60c5bc832e/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftransitive_relation.rs?ref=b175aef0c40d0b60316fabc6b4023c60c5bc832e", "patch": "@@ -9,21 +9,23 @@\n // except according to those terms.\n \n use bitvec::BitMatrix;\n-use stable_hasher::{HashStable, StableHasher, StableHasherResult};\n+use fx::FxHashMap;\n use rustc_serialize::{Encodable, Encoder, Decodable, Decoder};\n+use stable_hasher::{HashStable, StableHasher, StableHasherResult};\n use std::cell::RefCell;\n use std::fmt::Debug;\n+use std::hash::Hash;\n use std::mem;\n \n \n-\n #[derive(Clone)]\n-pub struct TransitiveRelation<T: Debug + PartialEq> {\n-    // List of elements. This is used to map from a T to a usize.  We\n-    // expect domain to be small so just use a linear list versus a\n-    // hashmap or something.\n+pub struct TransitiveRelation<T: Clone + Debug + Eq + Hash + Clone> {\n+    // List of elements. This is used to map from a T to a usize.\n     elements: Vec<T>,\n \n+    // Maps each element to an index.\n+    map: FxHashMap<T, Index>,\n+\n     // List of base edges in the graph. Require to compute transitive\n     // closure.\n     edges: Vec<Edge>,\n@@ -40,19 +42,20 @@ pub struct TransitiveRelation<T: Debug + PartialEq> {\n     closure: RefCell<Option<BitMatrix>>,\n }\n \n-#[derive(Clone, PartialEq, PartialOrd, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n struct Index(usize);\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n struct Edge {\n     source: Index,\n     target: Index,\n }\n \n-impl<T: Debug + PartialEq> TransitiveRelation<T> {\n+impl<T: Clone + Debug + Eq + Hash + Clone> TransitiveRelation<T> {\n     pub fn new() -> TransitiveRelation<T> {\n         TransitiveRelation {\n             elements: vec![],\n+            map: FxHashMap(),\n             edges: vec![],\n             closure: RefCell::new(None),\n         }\n@@ -63,29 +66,35 @@ impl<T: Debug + PartialEq> TransitiveRelation<T> {\n     }\n \n     fn index(&self, a: &T) -> Option<Index> {\n-        self.elements.iter().position(|e| *e == *a).map(Index)\n+        self.map.get(a).cloned()\n     }\n \n     fn add_index(&mut self, a: T) -> Index {\n-        match self.index(&a) {\n-            Some(i) => i,\n-            None => {\n-                self.elements.push(a);\n-\n-                // if we changed the dimensions, clear the cache\n-                *self.closure.borrow_mut() = None;\n-\n-                Index(self.elements.len() - 1)\n-            }\n-        }\n+        let &mut TransitiveRelation {\n+            ref mut elements,\n+            ref closure,\n+            ref mut map,\n+            ..\n+        } = self;\n+\n+        map.entry(a.clone())\n+           .or_insert_with(|| {\n+               elements.push(a);\n+\n+               // if we changed the dimensions, clear the cache\n+               *closure.borrow_mut() = None;\n+\n+               Index(elements.len() - 1)\n+           })\n+           .clone()\n     }\n \n     /// Applies the (partial) function to each edge and returns a new\n     /// relation.  If `f` returns `None` for any end-point, returns\n     /// `None`.\n     pub fn maybe_map<F, U>(&self, mut f: F) -> Option<TransitiveRelation<U>>\n         where F: FnMut(&T) -> Option<U>,\n-              U: Debug + PartialEq,\n+              U: Clone + Debug + Eq + Hash + Clone,\n     {\n         let mut result = TransitiveRelation::new();\n         for edge in &self.edges {\n@@ -335,7 +344,7 @@ fn pare_down(candidates: &mut Vec<usize>, closure: &BitMatrix) {\n }\n \n impl<T> Encodable for TransitiveRelation<T>\n-    where T: Encodable + Debug + PartialEq\n+    where T: Clone + Encodable + Debug + Eq + Hash + Clone\n {\n     fn encode<E: Encoder>(&self, s: &mut E) -> Result<(), E::Error> {\n         s.emit_struct(\"TransitiveRelation\", 2, |s| {\n@@ -347,19 +356,23 @@ impl<T> Encodable for TransitiveRelation<T>\n }\n \n impl<T> Decodable for TransitiveRelation<T>\n-    where T: Decodable + Debug + PartialEq\n+    where T: Clone + Decodable + Debug + Eq + Hash + Clone\n {\n     fn decode<D: Decoder>(d: &mut D) -> Result<Self, D::Error> {\n         d.read_struct(\"TransitiveRelation\", 2, |d| {\n-            let elements = d.read_struct_field(\"elements\", 0, |d| Decodable::decode(d))?;\n+            let elements: Vec<T> = d.read_struct_field(\"elements\", 0, |d| Decodable::decode(d))?;\n             let edges = d.read_struct_field(\"edges\", 1, |d| Decodable::decode(d))?;\n-            Ok(TransitiveRelation { elements, edges, closure: RefCell::new(None) })\n+            let map = elements.iter()\n+                              .enumerate()\n+                              .map(|(index, elem)| (elem.clone(), Index(index)))\n+                              .collect();\n+            Ok(TransitiveRelation { elements, edges, map, closure: RefCell::new(None) })\n         })\n     }\n }\n \n impl<CTX, T> HashStable<CTX> for TransitiveRelation<T>\n-    where T: HashStable<CTX> + PartialEq + Debug\n+    where T: HashStable<CTX> + Eq + Debug + Clone + Hash\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut CTX,\n@@ -369,6 +382,8 @@ impl<CTX, T> HashStable<CTX> for TransitiveRelation<T>\n         let TransitiveRelation {\n             ref elements,\n             ref edges,\n+            // \"map\" is just a copy of elements vec\n+            map: _,\n             // \"closure\" is just a copy of the data above\n             closure: _\n         } = *self;"}]}