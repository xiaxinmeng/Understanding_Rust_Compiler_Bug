{"sha": "a698b81ebfe02a614f9b41e68c6b604597a81229", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2OThiODFlYmZlMDJhNjE0ZjliNDFlNjhjNmI2MDQ1OTdhODEyMjk=", "commit": {"author": {"name": "Andrew Poelstra", "email": "apoelstra@wpsoftware.net", "date": "2014-07-02T15:24:55Z"}, "committer": {"name": "Andrew Poelstra", "email": "apoelstra@wpsoftware.net", "date": "2014-07-02T19:36:00Z"}, "message": "collections::bitv: ensure correct masking behaviour\n\nThe internal masking behaviour for `Bitv` is now defined as:\n  - Any entirely words in self.storage must be all zeroes.\n  - Any partially used words may have anything at all in their\n    unused bits.\n\nThis means:\n  - When decreasing self.nbits, care must be taken that any\n    no-longer-used words are zeroed out.\n\n  - When increasing self.nbits, care must be taken that any\n    newly-unmasked bits are set to their correct values.\n\n  - When reading words, care should be taken that the values of\n    unused bits are not used. (Preferably, use `Bitv::mask_words`\n    which zeroes them out for you.)\n\nThe old behaviour was that every unused bit was always set to\nzero. The problem with this is that unused bits are almost never\nread, so forgetting to do this will result in very subtle and\nhard-to-track down bugs. This way the responsibility for masking\nfalls on the places which might cause unused bits to be read: for\nnow, this is only `Bitv::mask_words` and `BitvSet::insert`.", "tree": {"sha": "17eb9394072a19419faef3bb9486a0d183771a11", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/17eb9394072a19419faef3bb9486a0d183771a11"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a698b81ebfe02a614f9b41e68c6b604597a81229", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a698b81ebfe02a614f9b41e68c6b604597a81229", "html_url": "https://github.com/rust-lang/rust/commit/a698b81ebfe02a614f9b41e68c6b604597a81229", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a698b81ebfe02a614f9b41e68c6b604597a81229/comments", "author": {"login": "apoelstra", "id": 1351933, "node_id": "MDQ6VXNlcjEzNTE5MzM=", "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apoelstra", "html_url": "https://github.com/apoelstra", "followers_url": "https://api.github.com/users/apoelstra/followers", "following_url": "https://api.github.com/users/apoelstra/following{/other_user}", "gists_url": "https://api.github.com/users/apoelstra/gists{/gist_id}", "starred_url": "https://api.github.com/users/apoelstra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions", "organizations_url": "https://api.github.com/users/apoelstra/orgs", "repos_url": "https://api.github.com/users/apoelstra/repos", "events_url": "https://api.github.com/users/apoelstra/events{/privacy}", "received_events_url": "https://api.github.com/users/apoelstra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "apoelstra", "id": 1351933, "node_id": "MDQ6VXNlcjEzNTE5MzM=", "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apoelstra", "html_url": "https://github.com/apoelstra", "followers_url": "https://api.github.com/users/apoelstra/followers", "following_url": "https://api.github.com/users/apoelstra/following{/other_user}", "gists_url": "https://api.github.com/users/apoelstra/gists{/gist_id}", "starred_url": "https://api.github.com/users/apoelstra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions", "organizations_url": "https://api.github.com/users/apoelstra/orgs", "repos_url": "https://api.github.com/users/apoelstra/repos", "events_url": "https://api.github.com/users/apoelstra/events{/privacy}", "received_events_url": "https://api.github.com/users/apoelstra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d23319e334a4fa1a6ec440b2cb0e48d0cadc542", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d23319e334a4fa1a6ec440b2cb0e48d0cadc542", "html_url": "https://github.com/rust-lang/rust/commit/2d23319e334a4fa1a6ec440b2cb0e48d0cadc542"}], "stats": {"total": 170, "additions": 87, "deletions": 83}, "files": [{"sha": "b480b88b4d4f05d86740c27ebd0d2d5e469080af", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 87, "deletions": 83, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/a698b81ebfe02a614f9b41e68c6b604597a81229/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a698b81ebfe02a614f9b41e68c6b604597a81229/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=a698b81ebfe02a614f9b41e68c6b604597a81229", "patch": "@@ -24,22 +24,6 @@ use std::hash;\n use {Collection, Mutable, Set, MutableSet};\n use vec::Vec;\n \n-/**\n- * A mask that has a 1 for each defined bit in the n'th element of a `Bitv`,\n- * assuming n bits.\n- */\n-#[inline]\n-fn big_mask(nbits: uint, elem: uint) -> uint {\n-    let rmd = nbits % uint::BITS;\n-    let nelems = (nbits + uint::BITS - 1) / uint::BITS;\n-\n-    if elem < nelems - 1 || rmd == 0 {\n-        !0\n-    } else {\n-        (1 << rmd) - 1\n-    }\n-}\n-\n /// The bitvector type\n ///\n /// # Example\n@@ -75,35 +59,47 @@ pub struct Bitv {\n     nbits: uint\n }\n \n-struct Words<'a> {\n+struct MaskWords<'a> {\n     iter: slice::Items<'a, uint>,\n+    next_word: Option<&'a uint>,\n+    last_word_mask: uint,\n     offset: uint\n }\n \n-impl<'a> Iterator<(uint, uint)> for Words<'a> {\n+impl<'a> Iterator<(uint, uint)> for MaskWords<'a> {\n     /// Returns (offset, word)\n     fn next<'a>(&'a mut self) -> Option<(uint, uint)> {\n-        let ret = self.iter.next().map(|&n| (self.offset, n));\n-        self.offset += 1;\n-        ret\n+        let ret = self.next_word;\n+        match ret {\n+            Some(&w) => {\n+                self.next_word = self.iter.next();\n+                self.offset += 1;\n+                // The last word may need to be masked\n+                if self.next_word.is_none() {\n+                    Some((self.offset - 1, w & self.last_word_mask))\n+                } else {\n+                    Some((self.offset - 1, w))\n+                }\n+            },\n+            None => None\n+        }\n     }\n }\n \n impl Bitv {\n     #[inline]\n-    fn process(&mut self, other: &Bitv, nbits: uint,\n-               op: |uint, uint| -> uint) -> bool {\n+    fn process(&mut self, other: &Bitv, op: |uint, uint| -> uint) -> bool {\n         let len = other.storage.len();\n         assert_eq!(self.storage.len(), len);\n         let mut changed = false;\n-        for (i, (a, b)) in self.storage.mut_iter()\n-                               .zip(other.storage.iter())\n-                               .enumerate() {\n-            let mask = big_mask(nbits, i);\n-            let w0 = *a & mask;\n-            let w1 = *b & mask;\n-            let w = op(w0, w1) & mask;\n-            if w0 != w {\n+        // Notice: `a` is *not* masked here, which is fine as long as\n+        // `op` is a bitwise operation, since any bits that should've\n+        // been masked were fine to change anyway. `b` is masked to\n+        // make sure its unmasked bits do not cause damage.\n+        for (a, (_, b)) in self.storage.mut_iter()\n+                           .zip(other.mask_words(0)) {\n+            let w = op(*a, b);\n+            if *a != w {\n                 changed = true;\n                 *a = w;\n             }\n@@ -112,10 +108,20 @@ impl Bitv {\n     }\n \n     #[inline]\n-    #[inline]\n-    fn words<'a>(&'a self, start: uint) -> Words<'a> {\n-        Words {\n-          iter: self.storage.slice_from(start).iter(),\n+    fn mask_words<'a>(&'a self, mut start: uint) -> MaskWords<'a> {\n+        if start > self.storage.len() {\n+            start = self.storage.len();\n+        }\n+        let mut iter = self.storage.slice_from(start).iter();\n+        MaskWords {\n+          next_word: iter.next(),\n+          iter: iter,\n+          last_word_mask: {\n+              let rem = self.nbits % uint::BITS;\n+              if rem > 0 {\n+                  (1 << rem) - 1\n+              } else { !0 }\n+          },\n           offset: start\n         }\n     }\n@@ -124,15 +130,8 @@ impl Bitv {\n     /// to `init`.\n     pub fn new(nbits: uint, init: bool) -> Bitv {\n         Bitv {\n-            storage: {\n-                let nelems = (nbits + uint::BITS - 1) / uint::BITS;\n-                let mut v = Vec::from_elem(nelems, if init { !0u } else { 0u });\n-                // Zero out any remainder bits\n-                if nbits % uint::BITS > 0 {\n-                    *v.get_mut(nelems - 1) &= (1 << nbits % uint::BITS) - 1;\n-                }\n-                v\n-            },\n+            storage: Vec::from_elem((nbits + uint::BITS - 1) / uint::BITS,\n+                                    if init { !0u } else { 0u }),\n             nbits: nbits\n         }\n     }\n@@ -145,8 +144,7 @@ impl Bitv {\n     */\n     #[inline]\n     pub fn union(&mut self, other: &Bitv) -> bool {\n-        let nbits = self.nbits;\n-        self.process(other, nbits, |w1, w2| w1 | w2)\n+        self.process(other, |w1, w2| w1 | w2)\n     }\n \n     /**\n@@ -157,8 +155,7 @@ impl Bitv {\n     */\n     #[inline]\n     pub fn intersect(&mut self, other: &Bitv) -> bool {\n-        let nbits = self.nbits;\n-        self.process(other, nbits, |w1, w2| w1 & w2)\n+        self.process(other, |w1, w2| w1 & w2)\n     }\n \n     /**\n@@ -169,8 +166,7 @@ impl Bitv {\n      */\n     #[inline]\n     pub fn assign(&mut self, other: &Bitv) -> bool {\n-        let nbits = self.nbits;\n-        self.process(other, nbits, |_, w| w)\n+        self.process(other, |_, w| w)\n     }\n \n     /// Retrieve the value at index `i`\n@@ -227,20 +223,18 @@ impl Bitv {\n      */\n     #[inline]\n     pub fn difference(&mut self, other: &Bitv) -> bool {\n-        let nbits = self.nbits;\n-        self.process(other, nbits, |w1, w2| w1 & !w2)\n+        self.process(other, |w1, w2| w1 & !w2)\n     }\n \n     /// Returns `true` if all bits are 1\n     #[inline]\n     pub fn all(&self) -> bool {\n-        for (i, &elem) in self.storage.iter().enumerate() {\n-            let mask = big_mask(self.nbits, i);\n-            if elem & mask != mask {\n-                return false;\n-            }\n-        }\n-        true\n+        let mut last_word = !0u;\n+        // Check that every word but the last is all-ones...\n+        self.mask_words(0).all(|(_, elem)|\n+            { let tmp = last_word; last_word = elem; tmp == !0u }) &&\n+        // ...and that the last word is ones as far as it needs to be\n+        (last_word == ((1 << self.nbits % uint::BITS) - 1) || last_word == !0u)\n     }\n \n     /// Returns an iterator over the elements of the vector in order.\n@@ -265,13 +259,7 @@ impl Bitv {\n \n     /// Returns `true` if all bits are 0\n     pub fn none(&self) -> bool {\n-        for (i, &elem) in self.storage.iter().enumerate() {\n-            let mask = big_mask(self.nbits, i);\n-            if elem & mask != 0 {\n-                return false;\n-            }\n-        }\n-        true\n+        self.mask_words(0).all(|(_, w)| w == 0)\n     }\n \n     #[inline]\n@@ -397,8 +385,8 @@ impl fmt::Show for Bitv {\n impl<S: hash::Writer> hash::Hash<S> for Bitv {\n     fn hash(&self, state: &mut S) {\n         self.nbits.hash(state);\n-        for (i, elem) in self.storage.iter().enumerate() {\n-            (elem & big_mask(self.nbits, i)).hash(state);\n+        for (_, elem) in self.mask_words(0) {\n+            elem.hash(state);\n         }\n     }\n }\n@@ -409,13 +397,7 @@ impl cmp::PartialEq for Bitv {\n         if self.nbits != other.nbits {\n             return false;\n         }\n-        for (i, (&w1, &w2)) in self.storage.iter().zip(other.storage.iter()).enumerate() {\n-            let mask = big_mask(self.nbits, i);\n-            if w1 & mask != w2 & mask {\n-                return false;\n-            }\n-        }\n-        true\n+        self.mask_words(0).zip(other.mask_words(0)).all(|((_, w1), (_, w2))| w1 == w2)\n     }\n }\n \n@@ -546,7 +528,7 @@ impl BitvSet {\n         // Unwrap Bitvs\n         let &BitvSet(ref mut self_bitv) = self;\n         let &BitvSet(ref other_bitv) = other;\n-        for (i, w) in other_bitv.words(0) {\n+        for (i, w) in other_bitv.mask_words(0) {\n             let old = *self_bitv.storage.get(i);\n             let new = f(old, w);\n             *self_bitv.storage.get_mut(i) = new;\n@@ -563,7 +545,7 @@ impl BitvSet {\n         let n = bitv.storage.iter().rev().take_while(|&&n| n == 0).count();\n         // Truncate\n         let trunc_len = cmp::max(old_len - n, 1);\n-        bitv.storage.truncate(cmp::max(old_len - n, 1));\n+        bitv.storage.truncate(trunc_len);\n         bitv.nbits = trunc_len * uint::BITS;\n     }\n \n@@ -710,6 +692,12 @@ impl MutableSet<uint> for BitvSet {\n         }\n         let &BitvSet(ref mut bitv) = self;\n         if value >= bitv.nbits {\n+            // If we are increasing nbits, make sure we mask out any previously-unconsidered bits\n+            let old_rem = bitv.nbits % uint::BITS;\n+            if old_rem != 0 {\n+                let old_last_word = (bitv.nbits + uint::BITS - 1) / uint::BITS - 1;\n+                *bitv.storage.get_mut(old_last_word) &= (1 << old_rem) - 1;\n+            }\n             bitv.nbits = value + 1;\n         }\n         bitv.set(value, true);\n@@ -733,10 +721,10 @@ impl BitvSet {\n     /// and w1/w2 are the words coming from the two vectors self, other.\n     fn commons<'a>(&'a self, other: &'a BitvSet)\n         -> Map<((uint, uint), (uint, uint)), (uint, uint, uint),\n-               Zip<Words<'a>, Words<'a>>> {\n+               Zip<MaskWords<'a>, MaskWords<'a>>> {\n         let &BitvSet(ref self_bitv) = self;\n         let &BitvSet(ref other_bitv) = other;\n-        self_bitv.words(0).zip(other_bitv.words(0))\n+        self_bitv.mask_words(0).zip(other_bitv.mask_words(0))\n             .map(|((i, w1), (_, w2))| (i * uint::BITS, w1, w2))\n     }\n \n@@ -748,17 +736,17 @@ impl BitvSet {\n     /// is true if the word comes from `self`, and `false` if it comes from\n     /// `other`.\n     fn outliers<'a>(&'a self, other: &'a BitvSet)\n-        -> Map<(uint, uint), (bool, uint, uint), Words<'a>> {\n+        -> Map<(uint, uint), (bool, uint, uint), MaskWords<'a>> {\n         let slen = self.capacity() / uint::BITS;\n         let olen = other.capacity() / uint::BITS;\n         let &BitvSet(ref self_bitv) = self;\n         let &BitvSet(ref other_bitv) = other;\n \n         if olen < slen {\n-            self_bitv.words(olen)\n+            self_bitv.mask_words(olen)\n                 .map(|(i, w)| (true, i * uint::BITS, w))\n         } else {\n-            other_bitv.words(slen)\n+            other_bitv.mask_words(slen)\n                 .map(|(i, w)| (false, i * uint::BITS, w))\n         }\n     }\n@@ -1250,16 +1238,32 @@ mod tests {\n         });\n     }\n \n+    #[test]\n+    fn test_bitv_masking() {\n+        let b = Bitv::new(140, true); \n+        let mut bs = BitvSet::from_bitv(b);\n+        assert!(bs.contains(&139));\n+        assert!(!bs.contains(&140));\n+        assert!(bs.insert(150));\n+        assert!(!bs.contains(&140));\n+        assert!(!bs.contains(&149));\n+        assert!(bs.contains(&150));\n+        assert!(!bs.contains(&151));\n+    }\n+\n     #[test]\n     fn test_bitv_set_basic() {\n         let mut b = BitvSet::new();\n         assert!(b.insert(3));\n         assert!(!b.insert(3));\n         assert!(b.contains(&3));\n+        assert!(b.insert(4));\n+        assert!(!b.insert(4));\n+        assert!(b.contains(&3));\n         assert!(b.insert(400));\n         assert!(!b.insert(400));\n         assert!(b.contains(&400));\n-        assert_eq!(b.len(), 2);\n+        assert_eq!(b.len(), 3);\n     }\n \n     #[test]"}]}