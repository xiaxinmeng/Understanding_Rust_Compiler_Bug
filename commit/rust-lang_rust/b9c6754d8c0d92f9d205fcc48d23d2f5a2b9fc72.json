{"sha": "b9c6754d8c0d92f9d205fcc48d23d2f5a2b9fc72", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5YzY3NTRkOGMwZDkyZjlkMjA1ZmNjNDhkMjNkMmY1YTJiOWZjNzI=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-07-23T22:08:41Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-07-23T22:08:41Z"}, "message": "Refactoring: move `format_project` and `Timer` out of Session", "tree": {"sha": "edd5cc948936513e0174f8cc8ed6535b6bd71aa3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/edd5cc948936513e0174f8cc8ed6535b6bd71aa3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b9c6754d8c0d92f9d205fcc48d23d2f5a2b9fc72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b9c6754d8c0d92f9d205fcc48d23d2f5a2b9fc72", "html_url": "https://github.com/rust-lang/rust/commit/b9c6754d8c0d92f9d205fcc48d23d2f5a2b9fc72", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b9c6754d8c0d92f9d205fcc48d23d2f5a2b9fc72/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "920a50ded91cf108ca29ce85dab7eda3b5a76309", "url": "https://api.github.com/repos/rust-lang/rust/commits/920a50ded91cf108ca29ce85dab7eda3b5a76309", "html_url": "https://github.com/rust-lang/rust/commit/920a50ded91cf108ca29ce85dab7eda3b5a76309"}], "stats": {"total": 359, "additions": 176, "deletions": 183}, "files": [{"sha": "1c196ca3b751996c61e62f05e550ed9e529bf34d", "filename": "src/formatting.rs", "status": "modified", "additions": 175, "deletions": 178, "changes": 353, "blob_url": "https://github.com/rust-lang/rust/blob/b9c6754d8c0d92f9d205fcc48d23d2f5a2b9fc72/src%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9c6754d8c0d92f9d205fcc48d23d2f5a2b9fc72/src%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fformatting.rs?ref=b9c6754d8c0d92f9d205fcc48d23d2f5a2b9fc72", "patch": "@@ -313,13 +313,12 @@ impl<'b, T: Write + 'b> Session<'b, T> {\n             return Ok((FileMap::new(), FormatReport::new()));\n         }\n \n-        let input_is_stdin = input.is_text();\n         let mut filemap = FileMap::new();\n-        // TODO split Session? out vs config?\n-        let format_result = self.format_project(input, |this, path, mut result| {\n-            if let Some(ref mut out) = this.out {\n-                match filemap::write_file(&mut result, &path, out, &this.config) {\n-                    Ok(b) if b => this.summary.add_diff(),\n+        let config = &self.config.clone();\n+        let format_result = format_project(input, config, |path, mut result| {\n+            if let Some(ref mut out) = self.out {\n+                match filemap::write_file(&mut result, &path, out, &self.config) {\n+                    Ok(b) if b => self.summary.add_diff(),\n                     Err(e) => {\n                         // Create a new error with path_str to help users see which files failed\n                         let err_msg = format!(\"{}: {}\", path, e);\n@@ -333,198 +332,192 @@ impl<'b, T: Write + 'b> Session<'b, T> {\n             Ok(())\n         });\n \n-        should_emit_verbose(input_is_stdin, &self.config, || {\n-            fn duration_to_f32(d: Duration) -> f32 {\n-                d.as_secs() as f32 + d.subsec_nanos() as f32 / 1_000_000_000f32\n-            }\n-\n-            println!(\n-                \"Spent {0:.3} secs in the parsing phase, and {1:.3} secs in the formatting phase\",\n-                duration_to_f32(self.timer.get_parse_time().unwrap()),\n-                duration_to_f32(self.timer.get_format_time().unwrap()),\n-            )\n-        });\n-\n         format_result.map(|(result, summary)| {\n             self.summary.add(summary);\n             (filemap, result)\n         })\n     }\n+}\n \n-    // TODO only uses config and timer\n-    fn format_project<F>(\n-        &mut self,\n-        input: Input,\n-        mut formatted_file: F,\n-    ) -> Result<(FormatReport, Summary), ErrorKind>\n-    where\n-        F: FnMut(&mut Session<T>, FileName, String) -> Result<(), ErrorKind>,\n-    {\n-        let mut summary = Summary::default();\n-        let main_file = match input {\n-            Input::File(ref file) => FileName::Real(file.clone()),\n-            Input::Text(..) => FileName::Stdin,\n-        };\n-\n-        // Parse the crate.\n-        let codemap = Rc::new(CodeMap::new(FilePathMapping::empty()));\n-        let mut parse_session = self.make_parse_sess(codemap.clone());\n-        let krate = match parse_input(input, &parse_session, &self.config) {\n-            Ok(krate) => krate,\n-            Err(err) => {\n-                match err {\n-                    ParseError::Error(mut diagnostic) => diagnostic.emit(),\n-                    ParseError::Panic => {\n-                        // Note that if you see this message and want more information,\n-                        // then go to `parse_input` and run the parse function without\n-                        // `catch_unwind` so rustfmt panics and you can get a backtrace.\n-                        should_emit_verbose(main_file != FileName::Stdin, &self.config, || {\n-                            println!(\"The Rust parser panicked\")\n-                        });\n-                    }\n-                    ParseError::Recovered => {}\n-                }\n-                summary.add_parsing_error();\n-                return Err(ErrorKind::ParseError);\n-            }\n-        };\n-        self.timer = self.timer.done_parsing();\n-\n-        // Suppress error output if we have to do any further parsing.\n-        let silent_emitter = Box::new(EmitterWriter::new(\n-            Box::new(Vec::new()),\n-            Some(codemap.clone()),\n-            false,\n-            false,\n-        ));\n-        parse_session.span_diagnostic = Handler::with_emitter(true, false, silent_emitter);\n+fn format_project<F>(\n+    input: Input,\n+    config: &Config,\n+    mut formatted_file: F,\n+) -> Result<(FormatReport, Summary), ErrorKind>\n+where\n+    F: FnMut(FileName, String) -> Result<(), ErrorKind>,\n+{\n+    let mut summary = Summary::default();\n+    let mut timer = Timer::Initialized(Instant::now());\n \n-        let report = FormatReport::new();\n+    let input_is_stdin = input.is_text();\n+    let main_file = match input {\n+        Input::File(ref file) => FileName::Real(file.clone()),\n+        Input::Text(..) => FileName::Stdin,\n+    };\n \n-        let skip_children = self.config.skip_children();\n-        for (path, module) in modules::list_files(&krate, parse_session.codemap())? {\n-            if (skip_children && path != main_file) || self.config.ignore().skip_file(&path) {\n-                continue;\n-            }\n-            should_emit_verbose(main_file != FileName::Stdin, &self.config, || {\n-                println!(\"Formatting {}\", path)\n-            });\n-            let filemap = parse_session\n-                .codemap()\n-                .lookup_char_pos(module.inner.lo())\n-                .file;\n-            let big_snippet = filemap.src.as_ref().unwrap();\n-            let snippet_provider = SnippetProvider::new(filemap.start_pos, big_snippet);\n-            let mut visitor = FmtVisitor::from_codemap(\n-                &parse_session,\n-                &self.config,\n-                &snippet_provider,\n-                report.clone(),\n-            );\n-            // Format inner attributes if available.\n-            if !krate.attrs.is_empty() && path == main_file {\n-                visitor.skip_empty_lines(filemap.end_pos);\n-                if visitor.visit_attrs(&krate.attrs, ast::AttrStyle::Inner) {\n-                    visitor.push_rewrite(module.inner, None);\n-                } else {\n-                    visitor.format_separate_mod(module, &*filemap);\n+    // Parse the crate.\n+    let codemap = Rc::new(CodeMap::new(FilePathMapping::empty()));\n+    let mut parse_session = make_parse_sess(codemap.clone(), config);\n+    let krate = match parse_input(input, &parse_session, config) {\n+        Ok(krate) => krate,\n+        Err(err) => {\n+            match err {\n+                ParseError::Error(mut diagnostic) => diagnostic.emit(),\n+                ParseError::Panic => {\n+                    // Note that if you see this message and want more information,\n+                    // then go to `parse_input` and run the parse function without\n+                    // `catch_unwind` so rustfmt panics and you can get a backtrace.\n+                    should_emit_verbose(main_file != FileName::Stdin, config, || {\n+                        println!(\"The Rust parser panicked\")\n+                    });\n                 }\n+                ParseError::Recovered => {}\n+            }\n+            summary.add_parsing_error();\n+            return Err(ErrorKind::ParseError);\n+        }\n+    };\n+    timer = timer.done_parsing();\n+\n+    // Suppress error output if we have to do any further parsing.\n+    let silent_emitter = Box::new(EmitterWriter::new(\n+        Box::new(Vec::new()),\n+        Some(codemap.clone()),\n+        false,\n+        false,\n+    ));\n+    parse_session.span_diagnostic = Handler::with_emitter(true, false, silent_emitter);\n+\n+    let report = FormatReport::new();\n+\n+    let skip_children = config.skip_children();\n+    for (path, module) in modules::list_files(&krate, parse_session.codemap())? {\n+        if (skip_children && path != main_file) || config.ignore().skip_file(&path) {\n+            continue;\n+        }\n+        should_emit_verbose(main_file != FileName::Stdin, config, || {\n+            println!(\"Formatting {}\", path)\n+        });\n+        let filemap = parse_session\n+            .codemap()\n+            .lookup_char_pos(module.inner.lo())\n+            .file;\n+        let big_snippet = filemap.src.as_ref().unwrap();\n+        let snippet_provider = SnippetProvider::new(filemap.start_pos, big_snippet);\n+        let mut visitor =\n+            FmtVisitor::from_codemap(&parse_session, config, &snippet_provider, report.clone());\n+        // Format inner attributes if available.\n+        if !krate.attrs.is_empty() && path == main_file {\n+            visitor.skip_empty_lines(filemap.end_pos);\n+            if visitor.visit_attrs(&krate.attrs, ast::AttrStyle::Inner) {\n+                visitor.push_rewrite(module.inner, None);\n             } else {\n-                visitor.last_pos = filemap.start_pos;\n-                visitor.skip_empty_lines(filemap.end_pos);\n                 visitor.format_separate_mod(module, &*filemap);\n-            };\n-\n-            debug_assert_eq!(\n-                visitor.line_number,\n-                ::utils::count_newlines(&visitor.buffer)\n-            );\n-\n-            // For some reason, the codemap does not include terminating\n-            // newlines so we must add one on for each file. This is sad.\n-            filemap::append_newline(&mut visitor.buffer);\n-\n-            format_lines(\n-                &mut visitor.buffer,\n-                &path,\n-                &visitor.skipped_range,\n-                &self.config,\n-                &report,\n-            );\n-            self.replace_with_system_newlines(&mut visitor.buffer);\n-\n-            if visitor.macro_rewrite_failure {\n-                summary.add_macro_format_failure();\n             }\n+        } else {\n+            visitor.last_pos = filemap.start_pos;\n+            visitor.skip_empty_lines(filemap.end_pos);\n+            visitor.format_separate_mod(module, &*filemap);\n+        };\n \n-            formatted_file(self, path, visitor.buffer)?;\n+        debug_assert_eq!(\n+            visitor.line_number,\n+            ::utils::count_newlines(&visitor.buffer)\n+        );\n+\n+        // For some reason, the codemap does not include terminating\n+        // newlines so we must add one on for each file. This is sad.\n+        filemap::append_newline(&mut visitor.buffer);\n+\n+        format_lines(\n+            &mut visitor.buffer,\n+            &path,\n+            &visitor.skipped_range,\n+            config,\n+            &report,\n+        );\n+        replace_with_system_newlines(&mut visitor.buffer, config);\n+\n+        if visitor.macro_rewrite_failure {\n+            summary.add_macro_format_failure();\n         }\n-        self.timer = self.timer.done_formatting();\n \n-        if report.has_warnings() {\n-            summary.add_formatting_error();\n+        formatted_file(path, visitor.buffer)?;\n+    }\n+    timer = timer.done_formatting();\n+\n+    should_emit_verbose(input_is_stdin, config, || {\n+        println!(\n+            \"Spent {0:.3} secs in the parsing phase, and {1:.3} secs in the formatting phase\",\n+            timer.get_parse_time(),\n+            timer.get_format_time(),\n+        )\n+    });\n+\n+    if report.has_warnings() {\n+        summary.add_formatting_error();\n+    }\n+    {\n+        let report_errs = &report.internal.borrow().1;\n+        if report_errs.has_check_errors {\n+            summary.add_check_error();\n         }\n-        {\n-            let report_errs = &report.internal.borrow().1;\n-            if report_errs.has_check_errors {\n-                summary.add_check_error();\n-            }\n-            if report_errs.has_operational_errors {\n-                summary.add_operational_error();\n-            }\n+        if report_errs.has_operational_errors {\n+            summary.add_operational_error();\n         }\n-\n-        Ok((report, summary))\n     }\n \n-    fn make_parse_sess(&self, codemap: Rc<CodeMap>) -> ParseSess {\n-        let tty_handler = if self.config.hide_parse_errors() {\n-            let silent_emitter = Box::new(EmitterWriter::new(\n-                Box::new(Vec::new()),\n-                Some(codemap.clone()),\n-                false,\n-                false,\n-            ));\n-            Handler::with_emitter(true, false, silent_emitter)\n+    Ok((report, summary))\n+}\n+\n+fn make_parse_sess(codemap: Rc<CodeMap>, config: &Config) -> ParseSess {\n+    let tty_handler = if config.hide_parse_errors() {\n+        let silent_emitter = Box::new(EmitterWriter::new(\n+            Box::new(Vec::new()),\n+            Some(codemap.clone()),\n+            false,\n+            false,\n+        ));\n+        Handler::with_emitter(true, false, silent_emitter)\n+    } else {\n+        let supports_color = term::stderr().map_or(false, |term| term.supports_color());\n+        let color_cfg = if supports_color {\n+            ColorConfig::Auto\n         } else {\n-            let supports_color = term::stderr().map_or(false, |term| term.supports_color());\n-            let color_cfg = if supports_color {\n-                ColorConfig::Auto\n-            } else {\n-                ColorConfig::Never\n-            };\n-            Handler::with_tty_emitter(color_cfg, true, false, Some(codemap.clone()))\n+            ColorConfig::Never\n         };\n+        Handler::with_tty_emitter(color_cfg, true, false, Some(codemap.clone()))\n+    };\n \n-        ParseSess::with_span_handler(tty_handler, codemap)\n-    }\n+    ParseSess::with_span_handler(tty_handler, codemap)\n+}\n \n-    fn replace_with_system_newlines(&self, text: &mut String) -> () {\n-        let style = if self.config.newline_style() == NewlineStyle::Native {\n-            if cfg!(windows) {\n-                NewlineStyle::Windows\n-            } else {\n-                NewlineStyle::Unix\n-            }\n+fn replace_with_system_newlines(text: &mut String, config: &Config) -> () {\n+    let style = if config.newline_style() == NewlineStyle::Native {\n+        if cfg!(windows) {\n+            NewlineStyle::Windows\n         } else {\n-            self.config.newline_style()\n-        };\n+            NewlineStyle::Unix\n+        }\n+    } else {\n+        config.newline_style()\n+    };\n \n-        match style {\n-            NewlineStyle::Unix => return,\n-            NewlineStyle::Windows => {\n-                let mut transformed = String::with_capacity(text.capacity());\n-                for c in text.chars() {\n-                    match c {\n-                        '\\n' => transformed.push_str(\"\\r\\n\"),\n-                        '\\r' => continue,\n-                        c => transformed.push(c),\n-                    }\n+    match style {\n+        NewlineStyle::Unix => return,\n+        NewlineStyle::Windows => {\n+            let mut transformed = String::with_capacity(text.capacity());\n+            for c in text.chars() {\n+                match c {\n+                    '\\n' => transformed.push_str(\"\\r\\n\"),\n+                    '\\r' => continue,\n+                    c => transformed.push(c),\n                 }\n-                *text = transformed;\n             }\n-            NewlineStyle::Native => unreachable!(),\n+            *text = transformed;\n         }\n+        NewlineStyle::Native => unreachable!(),\n     }\n }\n \n@@ -548,7 +541,7 @@ pub(crate) struct ModifiedLines {\n }\n \n #[derive(Clone, Copy, Debug)]\n-pub(crate) enum Timer {\n+enum Timer {\n     Initialized(Instant),\n     DoneParsing(Instant, Instant),\n     DoneFormatting(Instant, Instant, Instant),\n@@ -571,27 +564,31 @@ impl Timer {\n         }\n     }\n \n-    /// Returns the time it took to parse the source files in nanoseconds.\n-    fn get_parse_time(&self) -> Option<Duration> {\n+    /// Returns the time it took to parse the source files in seconds.\n+    fn get_parse_time(&self) -> f32 {\n         match *self {\n             Timer::DoneParsing(init, parse_time) | Timer::DoneFormatting(init, parse_time, _) => {\n                 // This should never underflow since `Instant::now()` guarantees monotonicity.\n-                Some(parse_time.duration_since(init))\n+                Self::duration_to_f32(parse_time.duration_since(init))\n             }\n-            Timer::Initialized(..) => None,\n+            Timer::Initialized(..) => unreachable!(),\n         }\n     }\n \n     /// Returns the time it took to go from the parsed AST to the formatted output. Parsing time is\n     /// not included.\n-    fn get_format_time(&self) -> Option<Duration> {\n+    fn get_format_time(&self) -> f32 {\n         match *self {\n             Timer::DoneFormatting(_init, parse_time, format_time) => {\n-                Some(format_time.duration_since(parse_time))\n+                Self::duration_to_f32(format_time.duration_since(parse_time))\n             }\n-            Timer::DoneParsing(..) | Timer::Initialized(..) => None,\n+            Timer::DoneParsing(..) | Timer::Initialized(..) => unreachable!(),\n         }\n     }\n+\n+    fn duration_to_f32(d: Duration) -> f32 {\n+        d.as_secs() as f32 + d.subsec_nanos() as f32 / 1_000_000_000f32\n+    }\n }\n \n /// A summary of a Rustfmt run."}, {"sha": "4d90f5a223eb86dd73e61af9dafb59325bed2586", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b9c6754d8c0d92f9d205fcc48d23d2f5a2b9fc72/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9c6754d8c0d92f9d205fcc48d23d2f5a2b9fc72/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=b9c6754d8c0d92f9d205fcc48d23d2f5a2b9fc72", "patch": "@@ -45,12 +45,11 @@ use std::io::{self, Write};\n use std::mem;\n use std::path::PathBuf;\n use std::rc::Rc;\n-use std::time::Instant;\n use syntax::ast;\n \n use comment::LineClasses;\n use failure::Fail;\n-use formatting::{FormatErrorMap, FormattingError, ReportedErrors, Summary, Timer};\n+use formatting::{FormatErrorMap, FormattingError, ReportedErrors, Summary};\n use issues::Issue;\n use shape::Indent;\n \n@@ -445,8 +444,6 @@ pub struct Session<'b, T: Write + 'b> {\n     pub config: Config,\n     pub out: Option<&'b mut T>,\n     pub summary: Summary,\n-    // Keeps track of time spent in parsing and formatting steps.\n-    timer: Timer,\n }\n \n impl<'b, T: Write + 'b> Session<'b, T> {\n@@ -459,7 +456,6 @@ impl<'b, T: Write + 'b> Session<'b, T> {\n             config,\n             out,\n             summary: Summary::default(),\n-            timer: Timer::Initialized(Instant::now()),\n         }\n     }\n "}]}