{"sha": "d0fa7abc5044471b951149aa35244620db847ff9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwZmE3YWJjNTA0NDQ3MWI5NTExNDlhYTM1MjQ0NjIwZGI4NDdmZjk=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-03-03T18:49:43Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-03-03T18:49:43Z"}, "message": "Merge #7863\n\n7863: Prevent renaming SelfType and BuiltinType r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "8c17e7bf082182dc7bfe39bb3f8c7c0c19e2cb91", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c17e7bf082182dc7bfe39bb3f8c7c0c19e2cb91"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d0fa7abc5044471b951149aa35244620db847ff9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgP9pHCRBK7hj4Ov3rIwAAdHIIAJ+u7LwQ70g4M2YPIdDHfOJD\nB+71Agcrb0iWVWV29cd9kszpwJvo11mD0UqLo5BsSMYqzR1PMosMm5bIkbg7u+Vc\nO42z7e4mKI/rShBfWMJ0iHXDvJkqcoGc86oux89LdyAG7mqVxRRedX9LkuM8E5yi\nPI0k5C0VPw9qsieqq3HOUHqbo1xfAsyWqmDSSVTHpMDAiluGJmY2nyyxROXZukUm\nWMct6lYJf0GbERCtdywY/kjQEybcv22V8V7mFko7BMQ6MKKFXdFxnxZJhcndI+bw\nz/HZ6yWCQ1ewGME+c7Km+jwjT29HpjpU47v5CVJ9ZrCKY0zYQHezhtXg4AphnCs=\n=1IQm\n-----END PGP SIGNATURE-----\n", "payload": "tree 8c17e7bf082182dc7bfe39bb3f8c7c0c19e2cb91\nparent 607716d213b88eddd34693c2e877c33bdd68aad1\nparent e194f2edc4275f592c247e26a460b025c69c6cea\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1614797383 +0000\ncommitter GitHub <noreply@github.com> 1614797383 +0000\n\nMerge #7863\n\n7863: Prevent renaming SelfType and BuiltinType r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d0fa7abc5044471b951149aa35244620db847ff9", "html_url": "https://github.com/rust-lang/rust/commit/d0fa7abc5044471b951149aa35244620db847ff9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d0fa7abc5044471b951149aa35244620db847ff9/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "607716d213b88eddd34693c2e877c33bdd68aad1", "url": "https://api.github.com/repos/rust-lang/rust/commits/607716d213b88eddd34693c2e877c33bdd68aad1", "html_url": "https://github.com/rust-lang/rust/commit/607716d213b88eddd34693c2e877c33bdd68aad1"}, {"sha": "e194f2edc4275f592c247e26a460b025c69c6cea", "url": "https://api.github.com/repos/rust-lang/rust/commits/e194f2edc4275f592c247e26a460b025c69c6cea", "html_url": "https://github.com/rust-lang/rust/commit/e194f2edc4275f592c247e26a460b025c69c6cea"}], "stats": {"total": 378, "additions": 189, "deletions": 189}, "files": [{"sha": "1919639a3d12065b7fb6aad537eed52cde8ffc83", "filename": "crates/ide/src/references/rename.rs", "status": "modified", "additions": 189, "deletions": 189, "changes": 378, "blob_url": "https://github.com/rust-lang/rust/blob/d0fa7abc5044471b951149aa35244620db847ff9/crates%2Fide%2Fsrc%2Freferences%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0fa7abc5044471b951149aa35244620db847ff9/crates%2Fide%2Fsrc%2Freferences%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences%2Frename.rs?ref=d0fa7abc5044471b951149aa35244620db847ff9", "patch": "@@ -88,6 +88,8 @@ pub(crate) fn rename_with_semantics(\n     let def = find_definition(sema, syntax, position)?;\n     match def {\n         Definition::ModuleDef(ModuleDef::Module(module)) => rename_mod(&sema, module, new_name),\n+        Definition::SelfType(_) => bail!(\"Cannot rename `Self`\"),\n+        Definition::ModuleDef(ModuleDef::BuiltinType(_)) => bail!(\"Cannot rename builtin type\"),\n         def => rename_reference(sema, def, new_name),\n     }\n }\n@@ -122,7 +124,7 @@ fn check_identifier(new_name: &str) -> RenameResult<IdentifierKind> {\n                 Ok(IdentifierKind::Lifetime)\n             }\n             (SyntaxKind::LIFETIME_IDENT, _) => {\n-                bail!(\"Invalid name `{0}`: Cannot rename lifetime to {0}\", new_name)\n+                bail!(\"Invalid name `{}`: not a lifetime identifier\", new_name)\n             }\n             (_, Some(syntax_error)) => bail!(\"Invalid name `{}`: {}\", new_name, syntax_error),\n             (_, None) => bail!(\"Invalid name `{}`: not an identifier\", new_name),\n@@ -162,119 +164,6 @@ fn find_definition(\n     .ok_or_else(|| format_err!(\"No references found at position\"))\n }\n \n-fn source_edit_from_references(\n-    _sema: &Semantics<RootDatabase>,\n-    file_id: FileId,\n-    references: &[FileReference],\n-    def: Definition,\n-    new_name: &str,\n-) -> (FileId, TextEdit) {\n-    let mut edit = TextEdit::builder();\n-    for reference in references {\n-        let (range, replacement) = match &reference.name {\n-            // if the ranges differ then the node is inside a macro call, we can't really attempt\n-            // to make special rewrites like shorthand syntax and such, so just rename the node in\n-            // the macro input\n-            ast::NameLike::NameRef(name_ref)\n-                if name_ref.syntax().text_range() == reference.range =>\n-            {\n-                source_edit_from_name_ref(name_ref, new_name, def)\n-            }\n-            ast::NameLike::Name(name) if name.syntax().text_range() == reference.range => {\n-                source_edit_from_name(name, new_name)\n-            }\n-            _ => None,\n-        }\n-        .unwrap_or_else(|| (reference.range, new_name.to_string()));\n-        edit.replace(range, replacement);\n-    }\n-    (file_id, edit.finish())\n-}\n-\n-fn source_edit_from_name(name: &ast::Name, new_name: &str) -> Option<(TextRange, String)> {\n-    if let Some(_) = ast::RecordPatField::for_field_name(name) {\n-        if let Some(ident_pat) = name.syntax().parent().and_then(ast::IdentPat::cast) {\n-            return Some((\n-                TextRange::empty(ident_pat.syntax().text_range().start()),\n-                format!(\"{}: \", new_name),\n-            ));\n-        }\n-    }\n-    None\n-}\n-\n-fn source_edit_from_name_ref(\n-    name_ref: &ast::NameRef,\n-    new_name: &str,\n-    def: Definition,\n-) -> Option<(TextRange, String)> {\n-    if let Some(record_field) = ast::RecordExprField::for_name_ref(name_ref) {\n-        let rcf_name_ref = record_field.name_ref();\n-        let rcf_expr = record_field.expr();\n-        match (rcf_name_ref, rcf_expr.and_then(|it| it.name_ref())) {\n-            // field: init-expr, check if we can use a field init shorthand\n-            (Some(field_name), Some(init)) => {\n-                if field_name == *name_ref {\n-                    if init.text() == new_name {\n-                        mark::hit!(test_rename_field_put_init_shorthand);\n-                        // same names, we can use a shorthand here instead.\n-                        // we do not want to erase attributes hence this range start\n-                        let s = field_name.syntax().text_range().start();\n-                        let e = record_field.syntax().text_range().end();\n-                        return Some((TextRange::new(s, e), new_name.to_owned()));\n-                    }\n-                } else if init == *name_ref {\n-                    if field_name.text() == new_name {\n-                        mark::hit!(test_rename_local_put_init_shorthand);\n-                        // same names, we can use a shorthand here instead.\n-                        // we do not want to erase attributes hence this range start\n-                        let s = field_name.syntax().text_range().start();\n-                        let e = record_field.syntax().text_range().end();\n-                        return Some((TextRange::new(s, e), new_name.to_owned()));\n-                    }\n-                }\n-                None\n-            }\n-            // init shorthand\n-            // FIXME: instead of splitting the shorthand, recursively trigger a rename of the\n-            // other name https://github.com/rust-analyzer/rust-analyzer/issues/6547\n-            (None, Some(_)) if matches!(def, Definition::Field(_)) => {\n-                mark::hit!(test_rename_field_in_field_shorthand);\n-                let s = name_ref.syntax().text_range().start();\n-                Some((TextRange::empty(s), format!(\"{}: \", new_name)))\n-            }\n-            (None, Some(_)) if matches!(def, Definition::Local(_)) => {\n-                mark::hit!(test_rename_local_in_field_shorthand);\n-                let s = name_ref.syntax().text_range().end();\n-                Some((TextRange::empty(s), format!(\": {}\", new_name)))\n-            }\n-            _ => None,\n-        }\n-    } else if let Some(record_field) = ast::RecordPatField::for_field_name_ref(name_ref) {\n-        let rcf_name_ref = record_field.name_ref();\n-        let rcf_pat = record_field.pat();\n-        match (rcf_name_ref, rcf_pat) {\n-            // field: rename\n-            (Some(field_name), Some(ast::Pat::IdentPat(pat))) if field_name == *name_ref => {\n-                // field name is being renamed\n-                if pat.name().map_or(false, |it| it.text() == new_name) {\n-                    mark::hit!(test_rename_field_put_init_shorthand_pat);\n-                    // same names, we can use a shorthand here instead/\n-                    // we do not want to erase attributes hence this range start\n-                    let s = field_name.syntax().text_range().start();\n-                    let e = record_field.syntax().text_range().end();\n-                    Some((TextRange::new(s, e), pat.to_string()))\n-                } else {\n-                    None\n-                }\n-            }\n-            _ => None,\n-        }\n-    } else {\n-        None\n-    }\n-}\n-\n fn rename_mod(\n     sema: &Semantics<RootDatabase>,\n     module: Module,\n@@ -308,18 +197,75 @@ fn rename_mod(\n                 TextEdit::replace(name.syntax().text_range(), new_name.to_string()),\n             ),\n             _ => unreachable!(),\n-        };\n+        }\n     }\n     let def = Definition::ModuleDef(ModuleDef::Module(module));\n     let usages = def.usages(sema).all();\n     let ref_edits = usages.iter().map(|(&file_id, references)| {\n-        source_edit_from_references(sema, file_id, references, def, new_name)\n+        (file_id, source_edit_from_references(references, def, new_name))\n     });\n     source_change.extend(ref_edits);\n \n     Ok(source_change)\n }\n \n+fn rename_reference(\n+    sema: &Semantics<RootDatabase>,\n+    def: Definition,\n+    new_name: &str,\n+) -> RenameResult<SourceChange> {\n+    let ident_kind = check_identifier(new_name)?;\n+\n+    let def_is_lbl_or_lt = matches!(\n+        def,\n+        Definition::GenericParam(hir::GenericParam::LifetimeParam(_)) | Definition::Label(_)\n+    );\n+    match (ident_kind, def) {\n+        (IdentifierKind::ToSelf, _)\n+        | (IdentifierKind::Underscore, _)\n+        | (IdentifierKind::Ident, _)\n+            if def_is_lbl_or_lt =>\n+        {\n+            mark::hit!(rename_not_a_lifetime_ident_ref);\n+            bail!(\"Invalid name `{}`: not a lifetime identifier\", new_name)\n+        }\n+        (IdentifierKind::Lifetime, _) if def_is_lbl_or_lt => mark::hit!(rename_lifetime),\n+        (IdentifierKind::Lifetime, _) => {\n+            mark::hit!(rename_not_an_ident_ref);\n+            bail!(\"Invalid name `{}`: not an identifier\", new_name)\n+        }\n+        (IdentifierKind::ToSelf, Definition::Local(local)) if local.is_self(sema.db) => {\n+            // no-op\n+            mark::hit!(rename_self_to_self);\n+            return Ok(SourceChange::default());\n+        }\n+        (ident_kind, Definition::Local(local)) if local.is_self(sema.db) => {\n+            mark::hit!(rename_self_to_param);\n+            return rename_self_to_param(sema, local, new_name, ident_kind);\n+        }\n+        (IdentifierKind::ToSelf, Definition::Local(local)) => {\n+            mark::hit!(rename_to_self);\n+            return rename_to_self(sema, local);\n+        }\n+        (IdentifierKind::ToSelf, _) => bail!(\"Invalid name `{}`: not an identifier\", new_name),\n+        (IdentifierKind::Ident, _) | (IdentifierKind::Underscore, _) => mark::hit!(rename_ident),\n+    }\n+\n+    let usages = def.usages(sema).all();\n+    if !usages.is_empty() && ident_kind == IdentifierKind::Underscore {\n+        mark::hit!(rename_underscore_multiple);\n+        bail!(\"Cannot rename reference to `_` as it is being referenced multiple times\");\n+    }\n+    let mut source_change = SourceChange::default();\n+    source_change.extend(usages.iter().map(|(&file_id, references)| {\n+        (file_id, source_edit_from_references(&references, def, new_name))\n+    }));\n+\n+    let (file_id, edit) = source_edit_from_def(sema, def, new_name)?;\n+    source_change.insert_source_edit(file_id, edit);\n+    Ok(source_change)\n+}\n+\n fn rename_to_self(sema: &Semantics<RootDatabase>, local: hir::Local) -> RenameResult<SourceChange> {\n     if never!(local.is_self(sema.db)) {\n         bail!(\"rename_to_self invoked on self\");\n@@ -384,7 +330,7 @@ fn rename_to_self(sema: &Semantics<RootDatabase>, local: hir::Local) -> RenameRe\n     let usages = def.usages(sema).all();\n     let mut source_change = SourceChange::default();\n     source_change.extend(usages.iter().map(|(&file_id, references)| {\n-        source_edit_from_references(sema, file_id, references, def, \"self\")\n+        (file_id, source_edit_from_references(references, def, \"self\"))\n     }));\n     source_change.insert_source_edit(\n         file_id.original_file(sema.db),\n@@ -394,29 +340,6 @@ fn rename_to_self(sema: &Semantics<RootDatabase>, local: hir::Local) -> RenameRe\n     Ok(source_change)\n }\n \n-fn text_edit_from_self_param(self_param: &ast::SelfParam, new_name: &str) -> Option<TextEdit> {\n-    fn target_type_name(impl_def: &ast::Impl) -> Option<String> {\n-        if let Some(ast::Type::PathType(p)) = impl_def.self_ty() {\n-            return Some(p.path()?.segment()?.name_ref()?.text().to_string());\n-        }\n-        None\n-    }\n-\n-    let impl_def = self_param.syntax().ancestors().find_map(|it| ast::Impl::cast(it))?;\n-    let type_name = target_type_name(&impl_def)?;\n-\n-    let mut replacement_text = String::from(new_name);\n-    replacement_text.push_str(\": \");\n-    match (self_param.amp_token(), self_param.mut_token()) {\n-        (None, None) => (),\n-        (Some(_), None) => replacement_text.push('&'),\n-        (_, Some(_)) => replacement_text.push_str(\"&mut \"),\n-    };\n-    replacement_text.push_str(type_name.as_str());\n-\n-    Some(TextEdit::replace(self_param.syntax().text_range(), replacement_text))\n-}\n-\n fn rename_self_to_param(\n     sema: &Semantics<RootDatabase>,\n     local: hir::Local,\n@@ -441,66 +364,143 @@ fn rename_self_to_param(\n     let mut source_change = SourceChange::default();\n     source_change.insert_source_edit(file_id.original_file(sema.db), edit);\n     source_change.extend(usages.iter().map(|(&file_id, references)| {\n-        source_edit_from_references(sema, file_id, &references, def, new_name)\n+        (file_id, source_edit_from_references(&references, def, new_name))\n     }));\n     Ok(source_change)\n }\n \n-fn rename_reference(\n-    sema: &Semantics<RootDatabase>,\n+fn text_edit_from_self_param(self_param: &ast::SelfParam, new_name: &str) -> Option<TextEdit> {\n+    fn target_type_name(impl_def: &ast::Impl) -> Option<String> {\n+        if let Some(ast::Type::PathType(p)) = impl_def.self_ty() {\n+            return Some(p.path()?.segment()?.name_ref()?.text().to_string());\n+        }\n+        None\n+    }\n+\n+    let impl_def = self_param.syntax().ancestors().find_map(|it| ast::Impl::cast(it))?;\n+    let type_name = target_type_name(&impl_def)?;\n+\n+    let mut replacement_text = String::from(new_name);\n+    replacement_text.push_str(\": \");\n+    match (self_param.amp_token(), self_param.mut_token()) {\n+        (Some(_), None) => replacement_text.push('&'),\n+        (Some(_), Some(_)) => replacement_text.push_str(\"&mut \"),\n+        (_, _) => (),\n+    };\n+    replacement_text.push_str(type_name.as_str());\n+\n+    Some(TextEdit::replace(self_param.syntax().text_range(), replacement_text))\n+}\n+\n+fn source_edit_from_references(\n+    references: &[FileReference],\n     def: Definition,\n     new_name: &str,\n-) -> RenameResult<SourceChange> {\n-    let ident_kind = check_identifier(new_name)?;\n-\n-    let def_is_lbl_or_lt = matches!(\n-        def,\n-        Definition::GenericParam(hir::GenericParam::LifetimeParam(_)) | Definition::Label(_)\n-    );\n-    match (ident_kind, def) {\n-        (IdentifierKind::ToSelf, _)\n-        | (IdentifierKind::Underscore, _)\n-        | (IdentifierKind::Ident, _)\n-            if def_is_lbl_or_lt =>\n-        {\n-            mark::hit!(rename_not_a_lifetime_ident_ref);\n-            bail!(\"Invalid name `{}`: not a lifetime identifier\", new_name)\n-        }\n-        (IdentifierKind::Lifetime, _) if def_is_lbl_or_lt => mark::hit!(rename_lifetime),\n-        (IdentifierKind::Lifetime, _) => {\n-            mark::hit!(rename_not_an_ident_ref);\n-            bail!(\"Invalid name `{}`: not an identifier\", new_name)\n-        }\n-        (IdentifierKind::ToSelf, Definition::Local(local)) if local.is_self(sema.db) => {\n-            // no-op\n-            mark::hit!(rename_self_to_self);\n-            return Ok(SourceChange::default());\n-        }\n-        (ident_kind, Definition::Local(local)) if local.is_self(sema.db) => {\n-            mark::hit!(rename_self_to_param);\n-            return rename_self_to_param(sema, local, new_name, ident_kind);\n-        }\n-        (IdentifierKind::ToSelf, Definition::Local(local)) => {\n-            mark::hit!(rename_to_self);\n-            return rename_to_self(sema, local);\n+) -> TextEdit {\n+    let mut edit = TextEdit::builder();\n+    for reference in references {\n+        let (range, replacement) = match &reference.name {\n+            // if the ranges differ then the node is inside a macro call, we can't really attempt\n+            // to make special rewrites like shorthand syntax and such, so just rename the node in\n+            // the macro input\n+            ast::NameLike::NameRef(name_ref)\n+                if name_ref.syntax().text_range() == reference.range =>\n+            {\n+                source_edit_from_name_ref(name_ref, new_name, def)\n+            }\n+            ast::NameLike::Name(name) if name.syntax().text_range() == reference.range => {\n+                source_edit_from_name(name, new_name)\n+            }\n+            _ => None,\n         }\n-        (IdentifierKind::ToSelf, _) => bail!(\"Invalid name `{}`: not an identifier\", new_name),\n-        (IdentifierKind::Ident, _) | (IdentifierKind::Underscore, _) => mark::hit!(rename_ident),\n+        .unwrap_or_else(|| (reference.range, new_name.to_string()));\n+        edit.replace(range, replacement);\n     }\n+    edit.finish()\n+}\n \n-    let usages = def.usages(sema).all();\n-    if !usages.is_empty() && ident_kind == IdentifierKind::Underscore {\n-        mark::hit!(rename_underscore_multiple);\n-        bail!(\"Cannot rename reference to `_` as it is being referenced multiple times\");\n+fn source_edit_from_name(name: &ast::Name, new_name: &str) -> Option<(TextRange, String)> {\n+    if let Some(_) = ast::RecordPatField::for_field_name(name) {\n+        if let Some(ident_pat) = name.syntax().parent().and_then(ast::IdentPat::cast) {\n+            return Some((\n+                TextRange::empty(ident_pat.syntax().text_range().start()),\n+                [new_name, \": \"].concat(),\n+            ));\n+        }\n     }\n-    let mut source_change = SourceChange::default();\n-    source_change.extend(usages.iter().map(|(&file_id, references)| {\n-        source_edit_from_references(sema, file_id, &references, def, new_name)\n-    }));\n+    None\n+}\n \n-    let (file_id, edit) = source_edit_from_def(sema, def, new_name)?;\n-    source_change.insert_source_edit(file_id, edit);\n-    Ok(source_change)\n+fn source_edit_from_name_ref(\n+    name_ref: &ast::NameRef,\n+    new_name: &str,\n+    def: Definition,\n+) -> Option<(TextRange, String)> {\n+    if let Some(record_field) = ast::RecordExprField::for_name_ref(name_ref) {\n+        let rcf_name_ref = record_field.name_ref();\n+        let rcf_expr = record_field.expr();\n+        match (rcf_name_ref, rcf_expr.and_then(|it| it.name_ref())) {\n+            // field: init-expr, check if we can use a field init shorthand\n+            (Some(field_name), Some(init)) => {\n+                if field_name == *name_ref {\n+                    if init.text() == new_name {\n+                        mark::hit!(test_rename_field_put_init_shorthand);\n+                        // same names, we can use a shorthand here instead.\n+                        // we do not want to erase attributes hence this range start\n+                        let s = field_name.syntax().text_range().start();\n+                        let e = record_field.syntax().text_range().end();\n+                        return Some((TextRange::new(s, e), new_name.to_owned()));\n+                    }\n+                } else if init == *name_ref {\n+                    if field_name.text() == new_name {\n+                        mark::hit!(test_rename_local_put_init_shorthand);\n+                        // same names, we can use a shorthand here instead.\n+                        // we do not want to erase attributes hence this range start\n+                        let s = field_name.syntax().text_range().start();\n+                        let e = record_field.syntax().text_range().end();\n+                        return Some((TextRange::new(s, e), new_name.to_owned()));\n+                    }\n+                }\n+                None\n+            }\n+            // init shorthand\n+            // FIXME: instead of splitting the shorthand, recursively trigger a rename of the\n+            // other name https://github.com/rust-analyzer/rust-analyzer/issues/6547\n+            (None, Some(_)) if matches!(def, Definition::Field(_)) => {\n+                mark::hit!(test_rename_field_in_field_shorthand);\n+                let s = name_ref.syntax().text_range().start();\n+                Some((TextRange::empty(s), format!(\"{}: \", new_name)))\n+            }\n+            (None, Some(_)) if matches!(def, Definition::Local(_)) => {\n+                mark::hit!(test_rename_local_in_field_shorthand);\n+                let s = name_ref.syntax().text_range().end();\n+                Some((TextRange::empty(s), format!(\": {}\", new_name)))\n+            }\n+            _ => None,\n+        }\n+    } else if let Some(record_field) = ast::RecordPatField::for_field_name_ref(name_ref) {\n+        let rcf_name_ref = record_field.name_ref();\n+        let rcf_pat = record_field.pat();\n+        match (rcf_name_ref, rcf_pat) {\n+            // field: rename\n+            (Some(field_name), Some(ast::Pat::IdentPat(pat))) if field_name == *name_ref => {\n+                // field name is being renamed\n+                if pat.name().map_or(false, |it| it.text() == new_name) {\n+                    mark::hit!(test_rename_field_put_init_shorthand_pat);\n+                    // same names, we can use a shorthand here instead/\n+                    // we do not want to erase attributes hence this range start\n+                    let s = field_name.syntax().text_range().start();\n+                    let e = record_field.syntax().text_range().end();\n+                    Some((TextRange::new(s, e), pat.to_string()))\n+                } else {\n+                    None\n+                }\n+            }\n+            _ => None,\n+        }\n+    } else {\n+        None\n+    }\n }\n \n fn source_edit_from_def("}]}