{"sha": "da18f1130756c4fdd611d95e4f98e553b4b65995", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhMThmMTEzMDc1NmM0ZmRkNjExZDk1ZTRmOThlNTUzYjRiNjU5OTU=", "commit": {"author": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2020-04-18T11:28:07Z"}, "committer": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2020-04-18T11:28:07Z"}, "message": "Split LIFETIME to two tokens in mbe", "tree": {"sha": "a3bbf8863a69a5a27e75e63f5ce0855759509024", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a3bbf8863a69a5a27e75e63f5ce0855759509024"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da18f1130756c4fdd611d95e4f98e553b4b65995", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da18f1130756c4fdd611d95e4f98e553b4b65995", "html_url": "https://github.com/rust-lang/rust/commit/da18f1130756c4fdd611d95e4f98e553b4b65995", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da18f1130756c4fdd611d95e4f98e553b4b65995/comments", "author": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f78de3bb95acb996102a74b5b12d33054ba6d4c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/f78de3bb95acb996102a74b5b12d33054ba6d4c4", "html_url": "https://github.com/rust-lang/rust/commit/f78de3bb95acb996102a74b5b12d33054ba6d4c4"}], "stats": {"total": 103, "additions": 89, "deletions": 14}, "files": [{"sha": "9485c62b839a9fe2c9f3b4781c99d36577d8de43", "filename": "crates/ra_mbe/src/mbe_expander/matcher.rs", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/da18f1130756c4fdd611d95e4f98e553b4b65995/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da18f1130756c4fdd611d95e4f98e553b4b65995/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs?ref=da18f1130756c4fdd611d95e4f98e553b4b65995", "patch": "@@ -202,6 +202,13 @@ impl<'a> TtIter<'a> {\n     }\n \n     pub(crate) fn expect_tt(&mut self) -> Result<tt::TokenTree, ()> {\n+        match self.peek_n(0) {\n+            Some(tt::TokenTree::Leaf(tt::Leaf::Punct(punct))) if punct.char == '\\'' => {\n+                return self.expect_lifetime();\n+            }\n+            _ => (),\n+        }\n+\n         let tt = self.next().ok_or_else(|| ())?.clone();\n         let punct = match tt {\n             tt::TokenTree::Leaf(tt::Leaf::Punct(punct)) if punct.spacing == tt::Spacing::Joint => {\n@@ -255,13 +262,21 @@ impl<'a> TtIter<'a> {\n         }\n     }\n \n-    pub(crate) fn expect_lifetime(&mut self) -> Result<&tt::Ident, ()> {\n-        let ident = self.expect_ident()?;\n-        // check if it start from \"`\"\n-        if !ident.text.starts_with('\\'') {\n+    pub(crate) fn expect_lifetime(&mut self) -> Result<tt::TokenTree, ()> {\n+        let punct = self.expect_punct()?;\n+        if punct.char != '\\'' {\n             return Err(());\n         }\n-        Ok(ident)\n+        let ident = self.expect_ident()?;\n+\n+        Ok(tt::Subtree {\n+            delimiter: None,\n+            token_trees: vec![\n+                tt::Leaf::Punct(punct.clone()).into(),\n+                tt::Leaf::Ident(ident.clone()).into(),\n+            ],\n+        }\n+        .into())\n     }\n \n     pub(crate) fn expect_fragment(\n@@ -274,7 +289,10 @@ impl<'a> TtIter<'a> {\n         }\n \n         impl<'a> TreeSink for OffsetTokenSink<'a> {\n-            fn token(&mut self, _kind: SyntaxKind, n_tokens: u8) {\n+            fn token(&mut self, kind: SyntaxKind, mut n_tokens: u8) {\n+                if kind == SyntaxKind::LIFETIME {\n+                    n_tokens = 2;\n+                }\n                 for _ in 0..n_tokens {\n                     self.cursor = self.cursor.bump_subtree();\n                 }\n@@ -286,7 +304,7 @@ impl<'a> TtIter<'a> {\n             }\n         }\n \n-        let buffer = TokenBuffer::new(self.inner.as_slice());\n+        let buffer = TokenBuffer::new(&self.inner.as_slice());\n         let mut src = SubtreeTokenSource::new(&buffer);\n         let mut sink = OffsetTokenSink { cursor: buffer.begin(), error: false };\n \n@@ -422,7 +440,7 @@ fn match_meta_var(kind: &str, input: &mut TtIter) -> ExpandResult<Option<Fragmen\n                 \"tt\" => input.expect_tt().map(Some).map_err(|()| err!()),\n                 \"lifetime\" => input\n                     .expect_lifetime()\n-                    .map(|ident| Some(tt::Leaf::Ident(ident.clone()).into()))\n+                    .map(|tt| Some(tt))\n                     .map_err(|()| err!(\"expected lifetime\")),\n                 \"literal\" => input\n                     .expect_literal()"}, {"sha": "46791efaaefba4cb21c31159133ac803cf5d50f1", "filename": "crates/ra_mbe/src/subtree_source.rs", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/da18f1130756c4fdd611d95e4f98e553b4b65995/crates%2Fra_mbe%2Fsrc%2Fsubtree_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da18f1130756c4fdd611d95e4f98e553b4b65995/crates%2Fra_mbe%2Fsrc%2Fsubtree_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsubtree_source.rs?ref=da18f1130756c4fdd611d95e4f98e553b4b65995", "patch": "@@ -50,6 +50,26 @@ impl<'a> SubtreeTokenSource<'a> {\n     }\n \n     fn get(&self, pos: usize) -> Ref<Option<TtToken>> {\n+        fn is_lifetime(c: Cursor) -> Option<(Cursor, SmolStr)> {\n+            let tkn = c.token_tree();\n+\n+            if let Some(tt::TokenTree::Leaf(tt::Leaf::Punct(punct))) = tkn {\n+                if punct.char == '\\'' {\n+                    let next = c.bump();\n+                    if let Some(tt::TokenTree::Leaf(tt::Leaf::Ident(ident))) = next.token_tree() {\n+                        let res_cursor = next.bump();\n+                        let text = SmolStr::new(\"'\".to_string() + &ident.to_string());\n+\n+                        return Some((res_cursor, text));\n+                    } else {\n+                        panic!(\"Next token must be ident : {:#?}\", next.token_tree());\n+                    }\n+                }\n+            }\n+\n+            None\n+        }\n+\n         if pos < self.cached.borrow().len() {\n             return Ref::map(self.cached.borrow(), |c| &c[pos]);\n         }\n@@ -63,6 +83,12 @@ impl<'a> SubtreeTokenSource<'a> {\n                     continue;\n                 }\n \n+                if let Some((curr, text)) = is_lifetime(cursor) {\n+                    cached.push(Some(TtToken { kind: LIFETIME, is_joint_to_next: false, text }));\n+                    self.cached_cursor.set(curr);\n+                    continue;\n+                }\n+\n                 match cursor.token_tree() {\n                     Some(tt::TokenTree::Leaf(leaf)) => {\n                         cached.push(Some(convert_leaf(&leaf)));\n@@ -152,7 +178,11 @@ fn convert_ident(ident: &tt::Ident) -> TtToken {\n }\n \n fn convert_punct(p: tt::Punct) -> TtToken {\n-    let kind = SyntaxKind::from_char(p.char).unwrap();\n+    let kind = match SyntaxKind::from_char(p.char) {\n+        None => panic!(\"{:#?} is not a valid punct\", p),\n+        Some(kind) => kind,\n+    };\n+\n     let text = {\n         let mut buf = [0u8; 4];\n         let s: &str = p.char.encode_utf8(&mut buf);"}, {"sha": "70899bc5d93fa760a9195e8d188e32dc5e76fe50", "filename": "crates/ra_mbe/src/syntax_bridge.rs", "status": "modified", "additions": 32, "deletions": 5, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/da18f1130756c4fdd611d95e4f98e553b4b65995/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da18f1130756c4fdd611d95e4f98e553b4b65995/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs?ref=da18f1130756c4fdd611d95e4f98e553b4b65995", "patch": "@@ -271,7 +271,7 @@ struct RawConvertor<'a> {\n     inner: std::slice::Iter<'a, RawToken>,\n }\n \n-trait SrcToken {\n+trait SrcToken: std::fmt::Debug {\n     fn kind(&self) -> SyntaxKind;\n \n     fn to_char(&self) -> Option<char>;\n@@ -361,8 +361,12 @@ trait TokenConvertor {\n                     Some(next) if next.kind().is_punct() => tt::Spacing::Joint,\n                     _ => tt::Spacing::Alone,\n                 };\n-                let char = token.to_char().expect(\"Token from lexer must be single char\");\n-\n+                let char = match token.to_char() {\n+                    Some(c) => c,\n+                    None => {\n+                        panic!(\"Token from lexer must be single char: token = {:#?}\", token);\n+                    }\n+                };\n                 tt::Leaf::from(tt::Punct { char, spacing, id: self.id_alloc().alloc(range) }).into()\n             }\n         } else {\n@@ -373,9 +377,28 @@ trait TokenConvertor {\n             }\n             let leaf: tt::Leaf = match k {\n                 T![true] | T![false] => make_leaf!(Literal),\n-                IDENT | LIFETIME => make_leaf!(Ident),\n+                IDENT => make_leaf!(Ident),\n                 k if k.is_keyword() => make_leaf!(Ident),\n                 k if k.is_literal() => make_leaf!(Literal),\n+                LIFETIME => {\n+                    let char_unit = TextUnit::from_usize(1);\n+                    let r = TextRange::offset_len(range.start(), char_unit);\n+                    let apostrophe = tt::Leaf::from(tt::Punct {\n+                        char: '\\'',\n+                        spacing: tt::Spacing::Joint,\n+                        id: self.id_alloc().alloc(r),\n+                    });\n+                    result.push(apostrophe.into());\n+\n+                    let r =\n+                        TextRange::offset_len(range.start() + char_unit, range.len() - char_unit);\n+                    let ident = tt::Leaf::from(tt::Ident {\n+                        text: SmolStr::new(&token.to_text()[1..]),\n+                        id: self.id_alloc().alloc(r),\n+                    });\n+                    result.push(ident.into());\n+                    return;\n+                }\n                 _ => return,\n             };\n \n@@ -455,6 +478,7 @@ impl Convertor {\n     }\n }\n \n+#[derive(Debug)]\n enum SynToken {\n     Ordiniary(SyntaxToken),\n     Punch(SyntaxToken, TextUnit),\n@@ -592,11 +616,14 @@ fn delim_to_str(d: Option<tt::DelimiterKind>, closing: bool) -> SmolStr {\n }\n \n impl<'a> TreeSink for TtTreeSink<'a> {\n-    fn token(&mut self, kind: SyntaxKind, n_tokens: u8) {\n+    fn token(&mut self, kind: SyntaxKind, mut n_tokens: u8) {\n         if kind == L_DOLLAR || kind == R_DOLLAR {\n             self.cursor = self.cursor.bump_subtree();\n             return;\n         }\n+        if kind == LIFETIME {\n+            n_tokens = 2;\n+        }\n \n         let mut last = self.cursor;\n         for _ in 0..n_tokens {"}]}