{"sha": "6155b9a772c944702f931ce5940d6c19cb7ced07", "node_id": "C_kwDOAAsO6NoAKDYxNTViOWE3NzJjOTQ0NzAyZjkzMWNlNTk0MGQ2YzE5Y2I3Y2VkMDc", "commit": {"author": {"name": "Ingvar Stepanyan", "email": "me@rreverser.com", "date": "2023-01-12T18:47:05Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-01-12T18:47:05Z"}, "message": "Avoid __cxa_thread_atexit_impl on Emscripten\n\n - Fixes https://github.com/rust-lang/rust/issues/91628.\r\n - Fixes https://github.com/emscripten-core/emscripten/issues/15722.\r\n\r\nSee discussion in both issues.\r\n\r\nThe TL;DR is that weak linkage causes LLVM to produce broken Wasm, presumably due to pointer mismatch. The code is casting a void pointer to a function pointer with specific signature, but Wasm is very strict about function pointer compatibility, so the resulting code is invalid.\r\n\r\nIdeally LLVM should catch this earlier in the process rather than emit invalid Wasm, but it currently doesn't and this is an easy and valid fix, given that Emcripten doesn't have `__cxa_thread_atexit_impl` these days anyway.\r\n\r\nUnfortunately, I can't add a regression test as even after looking into this issue for a long time, I couldn't reproduce it with any minimal Rust example, only with extracted LLVM IR or on a large project involving Rust + C++.\r\n\r\nr? @alexcrichton", "tree": {"sha": "01614573705883aa3700c3c7f4fd04480f57a7b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/01614573705883aa3700c3c7f4fd04480f57a7b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6155b9a772c944702f931ce5940d6c19cb7ced07", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjwFWpCRBK7hj4Ov3rIwAAXQIIABdGVhgT/+Dky0CgLv1wZpjp\nrxL2X3U+odoh6+PaqhaiFwB6gvCT0vrUXXJagckvmkzzmaomANkRw7rc8LnQ0ToT\nniB1dmJdPICPitEVVZSS8GKpgKXgaib7rreVrBaALMUFbCdG6q5vHcFSenBZc6FT\n6WI34l1fqhoi2Iizq+pEM7JZhL04+Stx0bdoQt93cHBKv6Jeo6e5yTRxVwOu2P9r\nZw14Rhz6FMwv1mljEAEtC2OYiLM8VjCK/EoiLydTdx/BoDMsbwezZcsJQaA6v2Za\nALe5p5hBfTGzKwWEBr5Zn1fW1IWojFoFJ+HLn73lXawsd1SytjOq348sjeIAFec=\n=MaaJ\n-----END PGP SIGNATURE-----\n", "payload": "tree 01614573705883aa3700c3c7f4fd04480f57a7b9\nparent 222d1ff68d5bfe1dc2d7f3f0c42811fe12964af9\nauthor Ingvar Stepanyan <me@rreverser.com> 1673549225 +0000\ncommitter GitHub <noreply@github.com> 1673549225 +0000\n\nAvoid __cxa_thread_atexit_impl on Emscripten\n\n - Fixes https://github.com/rust-lang/rust/issues/91628.\r\n - Fixes https://github.com/emscripten-core/emscripten/issues/15722.\r\n\r\nSee discussion in both issues.\r\n\r\nThe TL;DR is that weak linkage causes LLVM to produce broken Wasm, presumably due to pointer mismatch. The code is casting a void pointer to a function pointer with specific signature, but Wasm is very strict about function pointer compatibility, so the resulting code is invalid.\r\n\r\nIdeally LLVM should catch this earlier in the process rather than emit invalid Wasm, but it currently doesn't and this is an easy and valid fix, given that Emcripten doesn't have `__cxa_thread_atexit_impl` these days anyway.\r\n\r\nUnfortunately, I can't add a regression test as even after looking into this issue for a long time, I couldn't reproduce it with any minimal Rust example, only with extracted LLVM IR or on a large project involving Rust + C++.\r\n\r\nr? @alexcrichton"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6155b9a772c944702f931ce5940d6c19cb7ced07", "html_url": "https://github.com/rust-lang/rust/commit/6155b9a772c944702f931ce5940d6c19cb7ced07", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6155b9a772c944702f931ce5940d6c19cb7ced07/comments", "author": {"login": "RReverser", "id": 557590, "node_id": "MDQ6VXNlcjU1NzU5MA==", "avatar_url": "https://avatars.githubusercontent.com/u/557590?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RReverser", "html_url": "https://github.com/RReverser", "followers_url": "https://api.github.com/users/RReverser/followers", "following_url": "https://api.github.com/users/RReverser/following{/other_user}", "gists_url": "https://api.github.com/users/RReverser/gists{/gist_id}", "starred_url": "https://api.github.com/users/RReverser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RReverser/subscriptions", "organizations_url": "https://api.github.com/users/RReverser/orgs", "repos_url": "https://api.github.com/users/RReverser/repos", "events_url": "https://api.github.com/users/RReverser/events{/privacy}", "received_events_url": "https://api.github.com/users/RReverser/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "222d1ff68d5bfe1dc2d7f3f0c42811fe12964af9", "url": "https://api.github.com/repos/rust-lang/rust/commits/222d1ff68d5bfe1dc2d7f3f0c42811fe12964af9", "html_url": "https://github.com/rust-lang/rust/commit/222d1ff68d5bfe1dc2d7f3f0c42811fe12964af9"}], "stats": {"total": 10, "additions": 2, "deletions": 8}, "files": [{"sha": "aa4df0006320879c00b836b02d5ccfff08d0f24b", "filename": "library/std/src/sys/unix/thread_local_dtor.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6155b9a772c944702f931ce5940d6c19cb7ced07/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_local_dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6155b9a772c944702f931ce5940d6c19cb7ced07/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_local_dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_local_dtor.rs?ref=6155b9a772c944702f931ce5940d6c19cb7ced07", "patch": "@@ -11,13 +11,7 @@\n // Note, however, that we run on lots older linuxes, as well as cross\n // compiling from a newer linux to an older linux, so we also have a\n // fallback implementation to use as well.\n-#[cfg(any(\n-    target_os = \"linux\",\n-    target_os = \"fuchsia\",\n-    target_os = \"redox\",\n-    target_os = \"emscripten\"\n-))]\n-#[cfg_attr(target_family = \"wasm\", allow(unused))] // might remain unused depending on target details (e.g. wasm32-unknown-emscripten)\n+#[cfg(any(target_os = \"linux\", target_os = \"fuchsia\", target_os = \"redox\"))]\n pub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern \"C\" fn(*mut u8)) {\n     use crate::mem;\n     use crate::sys_common::thread_local_dtor::register_dtor_fallback;\n@@ -94,7 +88,7 @@ pub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern \"C\" fn(*mut u8)) {\n     }\n }\n \n-#[cfg(any(target_os = \"vxworks\", target_os = \"horizon\"))]\n+#[cfg(any(target_os = \"vxworks\", target_os = \"horizon\", target_os = \"emscripten\"))]\n pub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern \"C\" fn(*mut u8)) {\n     use crate::sys_common::thread_local_dtor::register_dtor_fallback;\n     register_dtor_fallback(t, dtor);"}]}