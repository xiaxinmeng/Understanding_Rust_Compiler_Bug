{"sha": "1dad788d8d18672e79d20c832c9219967421f11d", "node_id": "C_kwDOAAsO6NoAKDFkYWQ3ODhkOGQxODY3MmU3OWQyMGM4MzJjOTIxOTk2NzQyMWYxMWQ", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2023-03-18T22:10:42Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2023-03-23T11:53:30Z"}, "message": "Fix ICE for intra-doc link on intermediate re-export", "tree": {"sha": "4c6d4c8b85d7051442950ed8d01d8d81b4c40b32", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c6d4c8b85d7051442950ed8d01d8d81b4c40b32"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1dad788d8d18672e79d20c832c9219967421f11d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1dad788d8d18672e79d20c832c9219967421f11d", "html_url": "https://github.com/rust-lang/rust/commit/1dad788d8d18672e79d20c832c9219967421f11d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1dad788d8d18672e79d20c832c9219967421f11d/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84dd6dfd9d19176cc3c94bc1448a841e44d57890", "url": "https://api.github.com/repos/rust-lang/rust/commits/84dd6dfd9d19176cc3c94bc1448a841e44d57890", "html_url": "https://github.com/rust-lang/rust/commit/84dd6dfd9d19176cc3c94bc1448a841e44d57890"}], "stats": {"total": 115, "additions": 80, "deletions": 35}, "files": [{"sha": "b419c81301c180df79cc99096c4827f7a01d0e0c", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 44, "deletions": 20, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/1dad788d8d18672e79d20c832c9219967421f11d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dad788d8d18672e79d20c832c9219967421f11d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=1dad788d8d18672e79d20c832c9219967421f11d", "patch": "@@ -39,7 +39,6 @@ use std::hash::Hash;\n use std::mem;\n use thin_vec::ThinVec;\n \n-use crate::clean::inline::merge_attrs;\n use crate::core::{self, DocContext, ImplTraitParam};\n use crate::formats::item_type::ItemType;\n use crate::visit_ast::Module as DocModule;\n@@ -2168,32 +2167,40 @@ impl<'hir> hir::intravisit::Visitor<'hir> for OneLevelVisitor<'hir> {\n /// documentation. Otherwise, we repeat the same operation until we find the \"end item\".\n fn get_all_import_attributes<'hir>(\n     mut item: &hir::Item<'hir>,\n-    tcx: TyCtxt<'hir>,\n+    cx: &mut DocContext<'hir>,\n     target_def_id: LocalDefId,\n-    attributes: &mut Vec<ast::Attribute>,\n     is_inline: bool,\n-) {\n+    mut prev_import: LocalDefId,\n+) -> Vec<(ast::Attribute, Option<DefId>)> {\n+    let mut attributes: Vec<(ast::Attribute, Option<DefId>)> = Vec::new();\n     let mut first = true;\n-    let hir_map = tcx.hir();\n+    let hir_map = cx.tcx.hir();\n     let mut visitor = OneLevelVisitor::new(hir_map, target_def_id);\n     let mut visited = FxHashSet::default();\n+    let mut import_attrs = Vec::new();\n \n     // If the item is an import and has at least a path with two parts, we go into it.\n     while let hir::ItemKind::Use(path, _) = item.kind && visited.insert(item.hir_id()) {\n+        let import_parent = cx.tcx.opt_local_parent(prev_import).map(|def_id| def_id.to_def_id());\n         if first {\n             // This is the \"original\" reexport so we get all its attributes without filtering them.\n-            attributes.extend_from_slice(hir_map.attrs(item.hir_id()));\n+            attributes = hir_map.attrs(item.hir_id()).iter().cloned().map(|attr| (attr, import_parent)).collect::<Vec<_>>();\n             first = false;\n         } else {\n-            add_without_unwanted_attributes(attributes, hir_map.attrs(item.hir_id()), is_inline);\n+            add_without_unwanted_attributes(&mut import_attrs, hir_map.attrs(item.hir_id()), is_inline);\n+            for attr in import_attrs.drain(..) {\n+                attributes.push((attr, import_parent));\n+            }\n         }\n \n-        if let Some(i) = visitor.find_target(tcx, item.owner_id.def_id.to_def_id(), path) {\n+        if let Some(i) = visitor.find_target(cx.tcx, item.owner_id.def_id.to_def_id(), path) {\n             item = i;\n         } else {\n             break;\n         }\n+        prev_import = item.owner_id.def_id;\n     }\n+    attributes\n }\n \n fn filter_tokens_from_list(\n@@ -2244,7 +2251,7 @@ fn add_without_unwanted_attributes(\n     new_attrs: &[ast::Attribute],\n     is_inline: bool,\n ) {\n-    // If it's `#[doc(inline)]`, we don't want all attributes, otherwise we keep everything.\n+    // If it's not `#[doc(inline)]`, we don't want all attributes, otherwise we keep everything.\n     if !is_inline {\n         attrs.extend_from_slice(new_attrs);\n         return;\n@@ -2374,26 +2381,43 @@ fn clean_maybe_renamed_item<'tcx>(\n             _ => unreachable!(\"not yet converted\"),\n         };\n \n-        let mut import_attrs = Vec::new();\n-        let mut target_attrs = Vec::new();\n-        if let Some(import_id) = import_id &&\n+        let attrs = if let Some(import_id) = import_id &&\n             let Some(hir::Node::Item(use_node)) = cx.tcx.hir().find_by_def_id(import_id)\n         {\n-            let is_inline = inline::load_attrs(cx, import_id.to_def_id()).lists(sym::doc).get_word_attr(sym::inline).is_some();\n+            let is_inline = inline::load_attrs(cx, import_id.to_def_id())\n+                .lists(sym::doc)\n+                .get_word_attr(sym::inline)\n+                .is_some();\n             // Then we get all the various imports' attributes.\n-            get_all_import_attributes(use_node, cx.tcx, item.owner_id.def_id, &mut import_attrs, is_inline);\n-            add_without_unwanted_attributes(&mut target_attrs, inline::load_attrs(cx, def_id), is_inline);\n+            let mut attrs = get_all_import_attributes(\n+                use_node,\n+                cx,\n+                item.owner_id.def_id,\n+                is_inline,\n+                import_id,\n+            );\n+\n+            let mut target_attrs = Vec::new();\n+            add_without_unwanted_attributes(\n+                &mut target_attrs,\n+                inline::load_attrs(cx, def_id),\n+                is_inline,\n+            );\n+            for attr in target_attrs.into_iter() {\n+                attrs.push((attr, None));\n+            }\n+            attrs\n         } else {\n             // We only keep the item's attributes.\n-            target_attrs.extend_from_slice(inline::load_attrs(cx, def_id));\n-        }\n+            inline::load_attrs(cx, def_id).iter().cloned().map(|attr| (attr, None)).collect::<Vec<_>>()\n+        };\n \n-        let import_id = import_id.map(|def_id| def_id.to_def_id());\n-        let (attrs, cfg) =  merge_attrs(cx, &target_attrs, Some((&import_attrs, import_id)));\n+        let cfg = attrs.cfg(cx.tcx, &cx.cache.hidden_cfg);\n+        let attrs = Attributes::from_ast_iter(attrs.iter().map(|(attr, did)| (attr, *did)), false);\n \n         let mut item =\n             Item::from_def_id_and_attrs_and_parts(def_id, Some(name), kind, Box::new(attrs), cfg);\n-        item.inline_stmt_id = import_id;\n+        item.inline_stmt_id = import_id.map(|local| local.to_def_id());\n         vec![item]\n     })\n }"}, {"sha": "74831811aa2e47ad8f32500507793e80f2d887ba", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 36, "deletions": 15, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/1dad788d8d18672e79d20c832c9219967421f11d/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dad788d8d18672e79d20c832c9219967421f11d/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=1dad788d8d18672e79d20c832c9219967421f11d", "patch": "@@ -867,27 +867,16 @@ pub(crate) struct Module {\n \n pub(crate) trait AttributesExt {\n     type AttributeIterator<'a>: Iterator<Item = ast::NestedMetaItem>\n+    where\n+        Self: 'a;\n+    type Attributes<'a>: Iterator<Item = &'a ast::Attribute>\n     where\n         Self: 'a;\n \n     fn lists<'a>(&'a self, name: Symbol) -> Self::AttributeIterator<'a>;\n \n-    fn span(&self) -> Option<rustc_span::Span>;\n-\n-    fn cfg(&self, tcx: TyCtxt<'_>, hidden_cfg: &FxHashSet<Cfg>) -> Option<Arc<Cfg>>;\n-}\n-\n-impl AttributesExt for [ast::Attribute] {\n-    type AttributeIterator<'a> = impl Iterator<Item = ast::NestedMetaItem> + 'a;\n+    fn iter<'a>(&'a self) -> Self::Attributes<'a>;\n \n-    fn lists<'a>(&'a self, name: Symbol) -> Self::AttributeIterator<'a> {\n-        self.iter()\n-            .filter(move |attr| attr.has_name(name))\n-            .filter_map(ast::Attribute::meta_item_list)\n-            .flatten()\n-    }\n-\n-    /// Return the span of the first doc-comment, if it exists.\n     fn span(&self) -> Option<rustc_span::Span> {\n         self.iter().find(|attr| attr.doc_str().is_some()).map(|attr| attr.span)\n     }\n@@ -980,6 +969,38 @@ impl AttributesExt for [ast::Attribute] {\n     }\n }\n \n+impl AttributesExt for [ast::Attribute] {\n+    type AttributeIterator<'a> = impl Iterator<Item = ast::NestedMetaItem> + 'a;\n+    type Attributes<'a> = impl Iterator<Item = &'a ast::Attribute> + 'a;\n+\n+    fn lists<'a>(&'a self, name: Symbol) -> Self::AttributeIterator<'a> {\n+        self.iter()\n+            .filter(move |attr| attr.has_name(name))\n+            .filter_map(ast::Attribute::meta_item_list)\n+            .flatten()\n+    }\n+\n+    fn iter<'a>(&'a self) -> Self::Attributes<'a> {\n+        self.into_iter()\n+    }\n+}\n+\n+impl AttributesExt for [(ast::Attribute, Option<DefId>)] {\n+    type AttributeIterator<'a> = impl Iterator<Item = ast::NestedMetaItem> + 'a;\n+    type Attributes<'a> = impl Iterator<Item = &'a ast::Attribute> + 'a;\n+\n+    fn lists<'a>(&'a self, name: Symbol) -> Self::AttributeIterator<'a> {\n+        AttributesExt::iter(self)\n+            .filter(move |attr| attr.has_name(name))\n+            .filter_map(ast::Attribute::meta_item_list)\n+            .flatten()\n+    }\n+\n+    fn iter<'a>(&'a self) -> Self::Attributes<'a> {\n+        self.into_iter().map(|(attr, _)| attr)\n+    }\n+}\n+\n pub(crate) trait NestedAttributesExt {\n     /// Returns `true` if the attribute list contains a specific `word`\n     fn has_word(self, word: Symbol) -> bool"}]}