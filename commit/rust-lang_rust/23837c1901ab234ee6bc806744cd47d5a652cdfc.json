{"sha": "23837c1901ab234ee6bc806744cd47d5a652cdfc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIzODM3YzE5MDFhYjIzNGVlNmJjODA2NzQ0Y2Q0N2Q1YTY1MmNkZmM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-02-09T15:34:23Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-03-13T15:21:29Z"}, "message": "improve TypeFoldable/Lift macros and make a bunch of stuff use them\n\nImprovements:\n\n- Use Clone not Copy for the \"simple cases\"\n- Separate TypeFoldable and Lift for the \"simple cases\"\n- Support generics type parameters\n- Support named fields in enum variants\n- etc", "tree": {"sha": "be34e5c15bfee3a8e092b9c22d3f382e5637c44b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/be34e5c15bfee3a8e092b9c22d3f382e5637c44b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/23837c1901ab234ee6bc806744cd47d5a652cdfc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/23837c1901ab234ee6bc806744cd47d5a652cdfc", "html_url": "https://github.com/rust-lang/rust/commit/23837c1901ab234ee6bc806744cd47d5a652cdfc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/23837c1901ab234ee6bc806744cd47d5a652cdfc/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f873c1e2db8d06be6a816b838655906fa9f2dac9", "url": "https://api.github.com/repos/rust-lang/rust/commits/f873c1e2db8d06be6a816b838655906fa9f2dac9", "html_url": "https://github.com/rust-lang/rust/commit/f873c1e2db8d06be6a816b838655906fa9f2dac9"}], "stats": {"total": 1364, "additions": 551, "deletions": 813}, "files": [{"sha": "b94f1819c7ddb6f506500e6a07de1e82a5b9c8d9", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/23837c1901ab234ee6bc806744cd47d5a652cdfc/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23837c1901ab234ee6bc806744cd47d5a652cdfc/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=23837c1901ab234ee6bc806744cd47d5a652cdfc", "patch": "@@ -1647,19 +1647,6 @@ impl<'tcx> TypeFoldable<'tcx> for ValuePairs<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for TypeTrace<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        TypeTrace {\n-            cause: self.cause.fold_with(folder),\n-            values: self.values.fold_with(folder)\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.cause.visit_with(visitor) || self.values.visit_with(visitor)\n-    }\n-}\n-\n impl<'tcx> fmt::Debug for RegionObligation<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"RegionObligation(sub_region={:?}, sup_type={:?})\","}, {"sha": "2cf176036296b0481290f85ec31f0043f1335d22", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/23837c1901ab234ee6bc806744cd47d5a652cdfc/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23837c1901ab234ee6bc806744cd47d5a652cdfc/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=23837c1901ab234ee6bc806744cd47d5a652cdfc", "patch": "@@ -57,6 +57,7 @@\n #![feature(inclusive_range)]\n #![feature(inclusive_range_syntax)]\n #![cfg_attr(windows, feature(libc))]\n+#![feature(macro_lifetime_matcher)]\n #![feature(macro_vis_matcher)]\n #![feature(match_default_bindings)]\n #![feature(never_type)]"}, {"sha": "6013e3aef81e17d35a5ca7445548150873c3d47e", "filename": "src/librustc/macros.rs", "status": "modified", "additions": 300, "deletions": 0, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/23837c1901ab234ee6bc806744cd47d5a652cdfc/src%2Flibrustc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23837c1901ab234ee6bc806744cd47d5a652cdfc/src%2Flibrustc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmacros.rs?ref=23837c1901ab234ee6bc806744cd47d5a652cdfc", "patch": "@@ -138,3 +138,303 @@ macro_rules! impl_stable_hash_for_spanned {\n     );\n }\n \n+///////////////////////////////////////////////////////////////////////////\n+// Lift and TypeFoldable macros\n+//\n+// When possible, use one of these (relatively) convenient macros to write\n+// the impls for you.\n+\n+#[macro_export]\n+macro_rules! CloneLiftImpls {\n+    (for <$tcx:lifetime> { $($ty:ty,)+ }) => {\n+        $(\n+            impl<$tcx> $crate::ty::Lift<$tcx> for $ty {\n+                type Lifted = Self;\n+                fn lift_to_tcx<'a, 'gcx>(&self, _: $crate::ty::TyCtxt<'a, 'gcx, $tcx>) -> Option<Self> {\n+                    Some(Clone::clone(self))\n+                }\n+            }\n+        )+\n+    };\n+\n+    ($($ty:ty,)+) => {\n+        CloneLiftImpls! {\n+            for <'tcx> {\n+                $($ty,)+\n+            }\n+        }\n+    };\n+}\n+\n+/// Used for types that are `Copy` and which **do not care arena\n+/// allocated data** (i.e., don't need to be folded).\n+#[macro_export]\n+macro_rules! CloneTypeFoldableImpls {\n+    (for <$tcx:lifetime> { $($ty:ty,)+ }) => {\n+        $(\n+            impl<$tcx> $crate::ty::fold::TypeFoldable<$tcx> for $ty {\n+                fn super_fold_with<'gcx: $tcx, F: $crate::ty::fold::TypeFolder<'gcx, $tcx>>(\n+                    &self,\n+                    _: &mut F\n+                ) -> $ty {\n+                    Clone::clone(self)\n+                }\n+\n+                fn super_visit_with<F: $crate::ty::fold::TypeVisitor<$tcx>>(\n+                    &self,\n+                    _: &mut F)\n+                    -> bool\n+                {\n+                    false\n+                }\n+            }\n+        )+\n+    };\n+\n+    ($($ty:ty,)+) => {\n+        CloneTypeFoldableImpls! {\n+            for <'tcx> {\n+                $($ty,)+\n+            }\n+        }\n+    };\n+}\n+\n+#[macro_export]\n+macro_rules! CloneTypeFoldableAndLiftImpls {\n+    ($($t:tt)*) => {\n+        CloneTypeFoldableImpls! { $($t)* }\n+        CloneLiftImpls! { $($t)* }\n+    }\n+}\n+\n+#[macro_export]\n+macro_rules! BraceStructLiftImpl {\n+    (impl<$($p:tt),*> Lift<$tcx:tt> for $s:path {\n+        type Lifted = $lifted:ty;\n+        $($field:ident),* $(,)*\n+    } $(where $($wc:tt)*)*) => {\n+        impl<$($p),*> $crate::ty::Lift<$tcx> for $s\n+            $(where $($wc)*)*\n+        {\n+            type Lifted = $lifted;\n+\n+            fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<$lifted> {\n+                $(let $field = tcx.lift(&self.$field)?;)*\n+                Some(Self::Lifted { $($field),* })\n+            }\n+        }\n+    };\n+}\n+\n+#[macro_export]\n+macro_rules! EnumLiftImpl {\n+    (impl<$($p:tt),*> Lift<$tcx:tt> for $s:path {\n+        type Lifted = $lifted:ty;\n+        $(\n+            ($variant:path) ( $( $variant_arg:ident),* )\n+        ),*\n+        $(,)*\n+    } $(where $($wc:tt)*)*) => {\n+        impl<$($p),*> $crate::ty::Lift<$tcx> for $s\n+            $(where $($wc)*)*\n+        {\n+            type Lifted = $lifted;\n+\n+            fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<$lifted> {\n+                match self {\n+                    $($variant ( $($variant_arg),* ) => {\n+                        Some($variant ( $(tcx.lift($variant_arg)?),* ))\n+                    })*\n+                }\n+            }\n+        }\n+    };\n+}\n+\n+#[macro_export]\n+macro_rules! BraceStructTypeFoldableImpl {\n+    (impl<$($p:tt),*> TypeFoldable<$tcx:tt> for $s:path {\n+        $($field:ident),* $(,)*\n+    } $(where $($wc:tt)*)*) => {\n+        impl<$($p),*> $crate::ty::fold::TypeFoldable<$tcx> for $s\n+            $(where $($wc)*)*\n+        {\n+            fn super_fold_with<'gcx: $tcx, V: $crate::ty::fold::TypeFolder<'gcx, $tcx>>(\n+                &self,\n+                folder: &mut V,\n+            ) -> Self {\n+                let $s { $($field,)* } = self;\n+                $s { $($field: $crate::ty::fold::TypeFoldable::fold_with($field, folder),)* }\n+            }\n+\n+            fn super_visit_with<V: $crate::ty::fold::TypeVisitor<$tcx>>(\n+                &self,\n+                visitor: &mut V,\n+            ) -> bool {\n+                let $s { $($field,)* } = self;\n+                false $(|| $crate::ty::fold::TypeFoldable::visit_with($field, visitor))*\n+            }\n+        }\n+    };\n+}\n+\n+#[macro_export]\n+macro_rules! TupleStructTypeFoldableImpl {\n+    (impl<$($p:tt),*> TypeFoldable<$tcx:tt> for $s:path {\n+        $($field:ident),* $(,)*\n+    } $(where $($wc:tt)*)*) => {\n+        impl<$($p),*> $crate::ty::fold::TypeFoldable<$tcx> for $s\n+            $(where $($wc)*)*\n+        {\n+            fn super_fold_with<'gcx: $tcx, V: $crate::ty::fold::TypeFolder<'gcx, $tcx>>(\n+                &self,\n+                folder: &mut V,\n+            ) -> Self {\n+                let $s($($field,)*)= self;\n+                $s($($crate::ty::fold::TypeFoldable::fold_with($field, folder),)*)\n+            }\n+\n+            fn super_visit_with<V: $crate::ty::fold::TypeVisitor<$tcx>>(\n+                &self,\n+                visitor: &mut V,\n+            ) -> bool {\n+                let $s($($field,)*) = self;\n+                false $(|| $crate::ty::fold::TypeFoldable::visit_with($field, visitor))*\n+            }\n+        }\n+    };\n+}\n+\n+#[macro_export]\n+macro_rules! EnumTypeFoldableImpl {\n+    (impl<$($p:tt),*> TypeFoldable<$tcx:tt> for $s:path {\n+        $($variants:tt)*\n+    } $(where $($wc:tt)*)*) => {\n+        impl<$($p),*> $crate::ty::fold::TypeFoldable<$tcx> for $s\n+            $(where $($wc)*)*\n+        {\n+            fn super_fold_with<'gcx: $tcx, V: $crate::ty::fold::TypeFolder<'gcx, $tcx>>(\n+                &self,\n+                folder: &mut V,\n+            ) -> Self {\n+                EnumTypeFoldableImpl!(@FoldVariants(self, folder) input($($variants)*) output())\n+            }\n+\n+            fn super_visit_with<V: $crate::ty::fold::TypeVisitor<$tcx>>(\n+                &self,\n+                visitor: &mut V,\n+            ) -> bool {\n+                EnumTypeFoldableImpl!(@VisitVariants(self, visitor) input($($variants)*) output())\n+            }\n+        }\n+    };\n+\n+    (@FoldVariants($this:expr, $folder:expr) input() output($($output:tt)*)) => {\n+        match $this {\n+            $($output)*\n+        }\n+    };\n+\n+    (@FoldVariants($this:expr, $folder:expr)\n+     input( ($variant:path) ( $($variant_arg:ident),* ) , $($input:tt)*)\n+     output( $($output:tt)*) ) => {\n+        EnumTypeFoldableImpl!(\n+            @FoldVariants($this, $folder)\n+                input($($input)*)\n+                output(\n+                    $variant ( $($variant_arg),* ) => {\n+                        $variant (\n+                            $($crate::ty::fold::TypeFoldable::fold_with($variant_arg, $folder)),*\n+                        )\n+                    }\n+                    $($output)*\n+                )\n+        )\n+    };\n+\n+    (@FoldVariants($this:expr, $folder:expr)\n+     input( ($variant:path) { $($variant_arg:ident),* $(,)* } , $($input:tt)*)\n+     output( $($output:tt)*) ) => {\n+        EnumTypeFoldableImpl!(\n+            @FoldVariants($this, $folder)\n+                input($($input)*)\n+                output(\n+                    $variant { $($variant_arg),* } => {\n+                        $variant {\n+                            $($variant_arg: $crate::ty::fold::TypeFoldable::fold_with(\n+                                $variant_arg, $folder\n+                            )),* }\n+                    }\n+                    $($output)*\n+                )\n+        )\n+    };\n+\n+    (@FoldVariants($this:expr, $folder:expr)\n+     input( ($variant:path), $($input:tt)*)\n+     output( $($output:tt)*) ) => {\n+        EnumTypeFoldableImpl!(\n+            @FoldVariants($this, $folder)\n+                input($($input)*)\n+                output(\n+                    $variant => { $variant }\n+                    $($output)*\n+                )\n+        )\n+    };\n+\n+    (@VisitVariants($this:expr, $visitor:expr) input() output($($output:tt)*)) => {\n+        match $this {\n+            $($output)*\n+        }\n+    };\n+\n+    (@VisitVariants($this:expr, $visitor:expr)\n+     input( ($variant:path) ( $($variant_arg:ident),* ) , $($input:tt)*)\n+     output( $($output:tt)*) ) => {\n+        EnumTypeFoldableImpl!(\n+            @VisitVariants($this, $visitor)\n+                input($($input)*)\n+                output(\n+                    $variant ( $($variant_arg),* ) => {\n+                        false $(|| $crate::ty::fold::TypeFoldable::visit_with(\n+                            $variant_arg, $visitor\n+                        ))*\n+                    }\n+                    $($output)*\n+                )\n+        )\n+    };\n+\n+    (@VisitVariants($this:expr, $visitor:expr)\n+     input( ($variant:path) { $($variant_arg:ident),* $(,)* } , $($input:tt)*)\n+     output( $($output:tt)*) ) => {\n+        EnumTypeFoldableImpl!(\n+            @VisitVariants($this, $visitor)\n+                input($($input)*)\n+                output(\n+                    $variant { $($variant_arg),* } => {\n+                        false $(|| $crate::ty::fold::TypeFoldable::visit_with(\n+                            $variant_arg, $visitor\n+                        ))*\n+                    }\n+                    $($output)*\n+                )\n+        )\n+    };\n+\n+    (@VisitVariants($this:expr, $visitor:expr)\n+     input( ($variant:path), $($input:tt)*)\n+     output( $($output:tt)*) ) => {\n+        EnumTypeFoldableImpl!(\n+            @VisitVariants($this, $visitor)\n+                input($($input)*)\n+                output(\n+                    $variant => { false }\n+                    $($output)*\n+                )\n+        )\n+    };\n+}\n+"}, {"sha": "9b75c19a875ebc4ad83ac100ae5f1aa6a78afb92", "filename": "src/librustc/mir/cache.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/23837c1901ab234ee6bc806744cd47d5a652cdfc/src%2Flibrustc%2Fmir%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23837c1901ab234ee6bc806744cd47d5a652cdfc/src%2Flibrustc%2Fmir%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fcache.rs?ref=23837c1901ab234ee6bc806744cd47d5a652cdfc", "patch": "@@ -76,3 +76,7 @@ fn calculate_predecessors(mir: &Mir) -> IndexVec<BasicBlock, Vec<BasicBlock>> {\n \n     result\n }\n+\n+CloneTypeFoldableAndLiftImpls! {\n+    Cache,\n+}"}, {"sha": "939710ffd2b86a53a7864b91241da4dfd41e84da", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 64, "deletions": 122, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/23837c1901ab234ee6bc806744cd47d5a652cdfc/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23837c1901ab234ee6bc806744cd47d5a652cdfc/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=23837c1901ab234ee6bc806744cd47d5a652cdfc", "patch": "@@ -2109,148 +2109,90 @@ pub enum ClosureOutlivesSubject<'tcx> {\n  * TypeFoldable implementations for MIR types\n  */\n \n-impl<'tcx> TypeFoldable<'tcx> for Mir<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        Mir {\n-            basic_blocks: self.basic_blocks.fold_with(folder),\n-            visibility_scopes: self.visibility_scopes.clone(),\n-            visibility_scope_info: self.visibility_scope_info.clone(),\n-            promoted: self.promoted.fold_with(folder),\n-            yield_ty: self.yield_ty.fold_with(folder),\n-            generator_drop: self.generator_drop.fold_with(folder),\n-            generator_layout: self.generator_layout.fold_with(folder),\n-            local_decls: self.local_decls.fold_with(folder),\n-            arg_count: self.arg_count,\n-            upvar_decls: self.upvar_decls.clone(),\n-            spread_arg: self.spread_arg,\n-            span: self.span,\n-            cache: cache::Cache::new()\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.basic_blocks.visit_with(visitor) ||\n-        self.generator_drop.visit_with(visitor) ||\n-        self.generator_layout.visit_with(visitor) ||\n-        self.yield_ty.visit_with(visitor) ||\n-        self.promoted.visit_with(visitor)     ||\n-        self.local_decls.visit_with(visitor)\n-    }\n+CloneTypeFoldableAndLiftImpls! {\n+    Mutability,\n+    SourceInfo,\n+    UpvarDecl,\n+    ValidationOp,\n+    VisibilityScopeData,\n+    VisibilityScope,\n+    VisibilityScopeInfo,\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for GeneratorLayout<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        GeneratorLayout {\n-            fields: self.fields.fold_with(folder),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.fields.visit_with(visitor)\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for Mir<'tcx> {\n+        basic_blocks,\n+        visibility_scopes,\n+        visibility_scope_info,\n+        promoted,\n+        yield_ty,\n+        generator_drop,\n+        generator_layout,\n+        local_decls,\n+        arg_count,\n+        upvar_decls,\n+        spread_arg,\n+        span,\n+        cache,\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for LocalDecl<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        LocalDecl {\n-            ty: self.ty.fold_with(folder),\n-            ..self.clone()\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.ty.visit_with(visitor)\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for GeneratorLayout<'tcx> {\n+        fields\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for BasicBlockData<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        BasicBlockData {\n-            statements: self.statements.fold_with(folder),\n-            terminator: self.terminator.fold_with(folder),\n-            is_cleanup: self.is_cleanup\n-        }\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for LocalDecl<'tcx> {\n+        mutability,\n+        is_user_variable,\n+        internal,\n+        ty,\n+        name,\n+        source_info,\n+        syntactic_scope,\n     }\n+}\n \n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.statements.visit_with(visitor) || self.terminator.visit_with(visitor)\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for BasicBlockData<'tcx> {\n+        statements,\n+        terminator,\n+        is_cleanup,\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ValidationOperand<'tcx, Place<'tcx>> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ValidationOperand {\n-            place: self.place.fold_with(folder),\n-            ty: self.ty.fold_with(folder),\n-            re: self.re,\n-            mutbl: self.mutbl,\n-        }\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for ValidationOperand<'tcx, Place<'tcx>> {\n+        place, ty, re, mutbl\n     }\n+}\n \n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.place.visit_with(visitor) || self.ty.visit_with(visitor)\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for Statement<'tcx> {\n+        source_info, kind\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for Statement<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        use mir::StatementKind::*;\n-\n-        let kind = match self.kind {\n-            Assign(ref place, ref rval) => Assign(place.fold_with(folder), rval.fold_with(folder)),\n-            SetDiscriminant { ref place, variant_index } => SetDiscriminant {\n-                place: place.fold_with(folder),\n-                variant_index,\n-            },\n-            StorageLive(ref local) => StorageLive(local.fold_with(folder)),\n-            StorageDead(ref local) => StorageDead(local.fold_with(folder)),\n-            InlineAsm { ref asm, ref outputs, ref inputs } => InlineAsm {\n-                asm: asm.clone(),\n-                outputs: outputs.fold_with(folder),\n-                inputs: inputs.fold_with(folder)\n-            },\n-\n-            // Note for future: If we want to expose the region scopes\n-            // during the fold, we need to either generalize EndRegion\n-            // to carry `[ty::Region]`, or extend the `TypeFolder`\n-            // trait with a `fn fold_scope`.\n-            EndRegion(ref region_scope) => EndRegion(region_scope.clone()),\n-\n-            Validate(ref op, ref places) =>\n-                Validate(op.clone(),\n-                         places.iter().map(|operand| operand.fold_with(folder)).collect()),\n-\n-            Nop => Nop,\n-        };\n-        Statement {\n-            source_info: self.source_info,\n-            kind,\n-        }\n+EnumTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for StatementKind<'tcx> {\n+        (StatementKind::Assign)(a, b),\n+        (StatementKind::SetDiscriminant) { place, variant_index },\n+        (StatementKind::StorageLive)(a),\n+        (StatementKind::StorageDead)(a),\n+        (StatementKind::InlineAsm) { asm, outputs, inputs },\n+        (StatementKind::Validate)(a, b),\n+        (StatementKind::EndRegion)(a),\n+        (StatementKind::Nop),\n     }\n+}\n \n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        use mir::StatementKind::*;\n-\n-        match self.kind {\n-            Assign(ref place, ref rval) => { place.visit_with(visitor) || rval.visit_with(visitor) }\n-            SetDiscriminant { ref place, .. } => place.visit_with(visitor),\n-            StorageLive(ref local) |\n-            StorageDead(ref local) => local.visit_with(visitor),\n-            InlineAsm { ref outputs, ref inputs, .. } =>\n-                outputs.visit_with(visitor) || inputs.visit_with(visitor),\n-\n-            // Note for future: If we want to expose the region scopes\n-            // during the visit, we need to either generalize EndRegion\n-            // to carry `[ty::Region]`, or extend the `TypeVisitor`\n-            // trait with a `fn visit_scope`.\n-            EndRegion(ref _scope) => false,\n-\n-            Validate(ref _op, ref places) =>\n-                places.iter().any(|ty_and_place| ty_and_place.visit_with(visitor)),\n-\n-            Nop => false,\n-        }\n-    }\n+EnumTypeFoldableImpl! {\n+    impl<'tcx, T> TypeFoldable<'tcx> for ClearCrossCrate<T> {\n+        (ClearCrossCrate::Clear),\n+        (ClearCrossCrate::Set)(a),\n+    } where T: TypeFoldable<'tcx>\n }\n \n impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {"}, {"sha": "d779ccd17360ad212af3b96272ce92030a59651d", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 4, "deletions": 20, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/23837c1901ab234ee6bc806744cd47d5a652cdfc/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23837c1901ab234ee6bc806744cd47d5a652cdfc/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=23837c1901ab234ee6bc806744cd47d5a652cdfc", "patch": "@@ -16,7 +16,6 @@\n use mir::*;\n use ty::subst::{Subst, Substs};\n use ty::{self, AdtDef, Ty, TyCtxt};\n-use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use hir;\n use ty::util::IntTypeExt;\n \n@@ -100,25 +99,10 @@ impl<'a, 'gcx, 'tcx> PlaceTy<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for PlaceTy<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        match *self {\n-            PlaceTy::Ty { ty } => PlaceTy::Ty { ty: ty.fold_with(folder) },\n-            PlaceTy::Downcast { adt_def, substs, variant_index } => {\n-                PlaceTy::Downcast {\n-                    adt_def,\n-                    substs: substs.fold_with(folder),\n-                    variant_index,\n-                }\n-            }\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        match *self {\n-            PlaceTy::Ty { ty } => ty.visit_with(visitor),\n-            PlaceTy::Downcast { substs, .. } => substs.visit_with(visitor)\n-        }\n+EnumTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for PlaceTy<'tcx> {\n+        (PlaceTy::Ty) { ty },\n+        (PlaceTy::Downcast) { adt_def, substs, variant_index },\n     }\n }\n "}, {"sha": "99adc1fc873defaf7227ec6aaa8adf79b18991b4", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 45, "deletions": 236, "changes": 281, "blob_url": "https://github.com/rust-lang/rust/blob/23837c1901ab234ee6bc806744cd47d5a652cdfc/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23837c1901ab234ee6bc806744cd47d5a652cdfc/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=23837c1901ab234ee6bc806744cd47d5a652cdfc", "patch": "@@ -363,258 +363,67 @@ impl<'tcx, O: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Obligation<'tcx\n     }\n }\n \n-impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableImplData<'tcx, N> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        traits::VtableImplData {\n-            impl_def_id: self.impl_def_id,\n-            substs: self.substs.fold_with(folder),\n-            nested: self.nested.fold_with(folder),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.substs.visit_with(visitor) || self.nested.visit_with(visitor)\n-    }\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx, N> TypeFoldable<'tcx> for traits::VtableImplData<'tcx, N> {\n+        impl_def_id, substs, nested\n+    } where N: TypeFoldable<'tcx>\n }\n \n-impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableGeneratorData<'tcx, N> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        traits::VtableGeneratorData {\n-            closure_def_id: self.closure_def_id,\n-            substs: self.substs.fold_with(folder),\n-            nested: self.nested.fold_with(folder),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.substs.visit_with(visitor) || self.nested.visit_with(visitor)\n-    }\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx, N> TypeFoldable<'tcx> for traits::VtableGeneratorData<'tcx, N> {\n+        closure_def_id, substs, nested\n+    } where N: TypeFoldable<'tcx>\n }\n \n-impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableClosureData<'tcx, N> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        traits::VtableClosureData {\n-            closure_def_id: self.closure_def_id,\n-            substs: self.substs.fold_with(folder),\n-            nested: self.nested.fold_with(folder),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.substs.visit_with(visitor) || self.nested.visit_with(visitor)\n-    }\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx, N> TypeFoldable<'tcx> for traits::VtableClosureData<'tcx, N> {\n+        closure_def_id, substs, nested\n+    } where N: TypeFoldable<'tcx>\n }\n \n-impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableAutoImplData<N> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        traits::VtableAutoImplData {\n-            trait_def_id: self.trait_def_id,\n-            nested: self.nested.fold_with(folder),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.nested.visit_with(visitor)\n-    }\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx, N> TypeFoldable<'tcx> for traits::VtableAutoImplData<N> {\n+        trait_def_id, nested\n+    } where N: TypeFoldable<'tcx>\n }\n \n-impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableBuiltinData<N> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        traits::VtableBuiltinData {\n-            nested: self.nested.fold_with(folder),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.nested.visit_with(visitor)\n-    }\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx, N> TypeFoldable<'tcx> for traits::VtableBuiltinData<N> {\n+        nested\n+    } where N: TypeFoldable<'tcx>\n }\n \n-impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableObjectData<'tcx, N> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        traits::VtableObjectData {\n-            upcast_trait_ref: self.upcast_trait_ref.fold_with(folder),\n-            vtable_base: self.vtable_base,\n-            nested: self.nested.fold_with(folder),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.upcast_trait_ref.visit_with(visitor) || self.nested.visit_with(visitor)\n-    }\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx, N> TypeFoldable<'tcx> for traits::VtableObjectData<'tcx, N> {\n+        upcast_trait_ref, vtable_base, nested\n+    } where N: TypeFoldable<'tcx>\n }\n \n-impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableFnPointerData<'tcx, N> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        traits::VtableFnPointerData {\n-            fn_ty: self.fn_ty.fold_with(folder),\n-            nested: self.nested.fold_with(folder),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.fn_ty.visit_with(visitor) || self.nested.visit_with(visitor)\n-    }\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx, N> TypeFoldable<'tcx> for traits::VtableFnPointerData<'tcx, N> {\n+        fn_ty,\n+        nested\n+    } where N: TypeFoldable<'tcx>\n }\n \n-impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Vtable<'tcx, N> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        match *self {\n-            traits::VtableImpl(ref v) => traits::VtableImpl(v.fold_with(folder)),\n-            traits::VtableAutoImpl(ref t) => traits::VtableAutoImpl(t.fold_with(folder)),\n-            traits::VtableGenerator(ref d) => {\n-                traits::VtableGenerator(d.fold_with(folder))\n-            }\n-            traits::VtableClosure(ref d) => {\n-                traits::VtableClosure(d.fold_with(folder))\n-            }\n-            traits::VtableFnPointer(ref d) => {\n-                traits::VtableFnPointer(d.fold_with(folder))\n-            }\n-            traits::VtableParam(ref n) => traits::VtableParam(n.fold_with(folder)),\n-            traits::VtableBuiltin(ref d) => traits::VtableBuiltin(d.fold_with(folder)),\n-            traits::VtableObject(ref d) => traits::VtableObject(d.fold_with(folder)),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        match *self {\n-            traits::VtableImpl(ref v) => v.visit_with(visitor),\n-            traits::VtableAutoImpl(ref t) => t.visit_with(visitor),\n-            traits::VtableGenerator(ref d) => d.visit_with(visitor),\n-            traits::VtableClosure(ref d) => d.visit_with(visitor),\n-            traits::VtableFnPointer(ref d) => d.visit_with(visitor),\n-            traits::VtableParam(ref n) => n.visit_with(visitor),\n-            traits::VtableBuiltin(ref d) => d.visit_with(visitor),\n-            traits::VtableObject(ref d) => d.visit_with(visitor),\n-        }\n-    }\n+EnumTypeFoldableImpl! {\n+    impl<'tcx, N> TypeFoldable<'tcx> for traits::Vtable<'tcx, N> {\n+        (traits::VtableImpl)(a),\n+        (traits::VtableAutoImpl)(a),\n+        (traits::VtableGenerator)(a),\n+        (traits::VtableClosure)(a),\n+        (traits::VtableFnPointer)(a),\n+        (traits::VtableParam)(a),\n+        (traits::VtableBuiltin)(a),\n+        (traits::VtableObject)(a),\n+    } where N: TypeFoldable<'tcx>\n }\n \n-impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Normalized<'tcx, T> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        Normalized {\n-            value: self.value.fold_with(folder),\n-            obligations: self.obligations.fold_with(folder),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.value.visit_with(visitor) || self.obligations.visit_with(visitor)\n-    }\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx, T> TypeFoldable<'tcx> for Normalized<'tcx, T> {\n+        value,\n+        obligations\n+    } where T: TypeFoldable<'tcx>\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for traits::ObligationCauseCode<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        match *self {\n-            super::ExprAssignable |\n-            super::MatchExpressionArm { arm_span: _, source: _ } |\n-            super::IfExpression |\n-            super::IfExpressionWithNoElse |\n-            super::MainFunctionType |\n-            super::StartFunctionType |\n-            super::IntrinsicType |\n-            super::MethodReceiver |\n-            super::MiscObligation |\n-            super::SliceOrArrayElem |\n-            super::TupleElem |\n-            super::ItemObligation(_) |\n-            super::AssignmentLhsSized |\n-            super::TupleInitializerSized |\n-            super::StructInitializerSized |\n-            super::VariableType(_) |\n-            super::ReturnType(_) |\n-            super::SizedReturnType |\n-            super::SizedYieldType |\n-            super::ReturnNoExpression |\n-            super::RepeatVec |\n-            super::FieldSized(_) |\n-            super::ConstSized |\n-            super::SharedStatic |\n-            super::BlockTailExpression(_) |\n-            super::CompareImplMethodObligation { .. } => self.clone(),\n-\n-            super::ProjectionWf(proj) => super::ProjectionWf(proj.fold_with(folder)),\n-            super::ReferenceOutlivesReferent(ty) => {\n-                super::ReferenceOutlivesReferent(ty.fold_with(folder))\n-            }\n-            super::ObjectTypeBound(ty, r) => {\n-                super::ObjectTypeBound(ty.fold_with(folder), r.fold_with(folder))\n-            }\n-            super::ObjectCastObligation(ty) => {\n-                super::ObjectCastObligation(ty.fold_with(folder))\n-            }\n-            super::BuiltinDerivedObligation(ref cause) => {\n-                super::BuiltinDerivedObligation(cause.fold_with(folder))\n-            }\n-            super::ImplDerivedObligation(ref cause) => {\n-                super::ImplDerivedObligation(cause.fold_with(folder))\n-            }\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        match *self {\n-            super::ExprAssignable |\n-            super::MatchExpressionArm { arm_span: _, source: _ } |\n-            super::IfExpression |\n-            super::IfExpressionWithNoElse |\n-            super::MainFunctionType |\n-            super::StartFunctionType |\n-            super::IntrinsicType |\n-            super::MethodReceiver |\n-            super::MiscObligation |\n-            super::SliceOrArrayElem |\n-            super::TupleElem |\n-            super::ItemObligation(_) |\n-            super::AssignmentLhsSized |\n-            super::TupleInitializerSized |\n-            super::StructInitializerSized |\n-            super::VariableType(_) |\n-            super::ReturnType(_) |\n-            super::SizedReturnType |\n-            super::SizedYieldType |\n-            super::ReturnNoExpression |\n-            super::RepeatVec |\n-            super::FieldSized(_) |\n-            super::ConstSized |\n-            super::SharedStatic |\n-            super::BlockTailExpression(_) |\n-            super::CompareImplMethodObligation { .. } => false,\n-\n-            super::ProjectionWf(proj) => proj.visit_with(visitor),\n-            super::ReferenceOutlivesReferent(ty) => ty.visit_with(visitor),\n-            super::ObjectTypeBound(ty, r) => ty.visit_with(visitor) || r.visit_with(visitor),\n-            super::ObjectCastObligation(ty) => ty.visit_with(visitor),\n-            super::BuiltinDerivedObligation(ref cause) => cause.visit_with(visitor),\n-            super::ImplDerivedObligation(ref cause) => cause.visit_with(visitor)\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for traits::DerivedObligationCause<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        traits::DerivedObligationCause {\n-            parent_trait_ref: self.parent_trait_ref.fold_with(folder),\n-            parent_code: self.parent_code.fold_with(folder)\n-        }\n-    }\n \n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.parent_trait_ref.visit_with(visitor) || self.parent_code.visit_with(visitor)\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for traits::ObligationCause<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        traits::ObligationCause {\n-            span: self.span,\n-            body_id: self.body_id,\n-            code: self.code.fold_with(folder),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.code.visit_with(visitor)\n-    }\n-}"}, {"sha": "8071cd0c639da6b8a3dec899d13b7dd9853b94ab", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/23837c1901ab234ee6bc806744cd47d5a652cdfc/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23837c1901ab234ee6bc806744cd47d5a652cdfc/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=23837c1901ab234ee6bc806744cd47d5a652cdfc", "patch": "@@ -49,6 +49,9 @@ use util::nodemap::FxHashSet;\n \n /// The TypeFoldable trait is implemented for every type that can be folded.\n /// Basically, every type that has a corresponding method in TypeFolder.\n+///\n+/// To implement this conveniently, use the\n+/// `BraceStructTypeFoldableImpl` etc macros found in `macros.rs`.\n pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self;\n     fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {"}, {"sha": "0ca2769aa17b8ef56d4274cc425aa5184477e47f", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/23837c1901ab234ee6bc806744cd47d5a652cdfc/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23837c1901ab234ee6bc806744cd47d5a652cdfc/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=23837c1901ab234ee6bc806744cd47d5a652cdfc", "patch": "@@ -18,7 +18,6 @@ use middle::const_val::ConstVal;\n use traits::Reveal;\n use ty::subst::{UnpackedKind, Substs};\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n-use ty::fold::{TypeVisitor, TypeFolder};\n use ty::error::{ExpectedFound, TypeError};\n use mir::interpret::{GlobalId, Value, PrimVal};\n use util::common::ErrorReported;\n@@ -326,13 +325,9 @@ impl<'tcx> Relate<'tcx> for ty::ExistentialTraitRef<'tcx> {\n #[derive(Debug, Clone)]\n struct GeneratorWitness<'tcx>(&'tcx ty::Slice<Ty<'tcx>>);\n \n-impl<'tcx> TypeFoldable<'tcx> for GeneratorWitness<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        GeneratorWitness(self.0.fold_with(folder))\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.0.visit_with(visitor)\n+TupleStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for GeneratorWitness<'tcx> {\n+        a\n     }\n }\n "}, {"sha": "0627bcdfb0ec1a863c6cbd697fe5754c9619399a", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 127, "deletions": 414, "changes": 541, "blob_url": "https://github.com/rust-lang/rust/blob/23837c1901ab234ee6bc806744cd47d5a652cdfc/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23837c1901ab234ee6bc806744cd47d5a652cdfc/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=23837c1901ab234ee6bc806744cd47d5a652cdfc", "patch": "@@ -28,153 +28,37 @@ use std::rc::Rc;\n // For things that don't carry any arena-allocated data (and are\n // copy...), just add them to this list.\n \n-macro_rules! CopyImpls {\n-    ($($ty:ty,)+) => {\n-        $(\n-            impl<'tcx> Lift<'tcx> for $ty {\n-                type Lifted = Self;\n-                fn lift_to_tcx<'a, 'gcx>(&self, _: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self> {\n-                    Some(*self)\n-                }\n-            }\n-\n-            impl<'tcx> TypeFoldable<'tcx> for $ty {\n-                fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, _: &mut F) -> $ty {\n-                    *self\n-                }\n-\n-                fn super_visit_with<F: TypeVisitor<'tcx>>(&self, _: &mut F) -> bool {\n-                    false\n-                }\n-            }\n-        )+\n-    }\n-}\n-\n-CopyImpls! {\n+CloneTypeFoldableAndLiftImpls! {\n     (),\n+    bool,\n+    usize,\n+    u64,\n+    ::middle::region::Scope,\n+    ::syntax::ast::FloatTy,\n+    ::syntax::ast::NodeId,\n+    ::syntax_pos::symbol::Symbol,\n+    ::hir::def::Def,\n+    ::hir::def_id::DefId,\n+    ::hir::InlineAsm,\n+    ::hir::MatchSource,\n+    ::hir::Mutability,\n     ::hir::Unsafety,\n     ::syntax::abi::Abi,\n-    ::hir::def_id::DefId,\n     ::mir::Local,\n     ::mir::Promoted,\n     ::traits::Reveal,\n+    ::ty::adjustment::AutoBorrowMutability,\n+    ::ty::AdtKind,\n+    // Including `BoundRegion` is a *bit* dubious, but direct\n+    // references to bound region appear in `ty::Error`, and aren't\n+    // really meant to be folded. In general, we can only fold a fully\n+    // general `Region`.\n+    ::ty::BoundRegion,\n+    ::ty::ClosureKind,\n+    ::ty::IntVarValue,\n     ::syntax_pos::Span,\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-// Macros\n-//\n-// When possible, use one of these (relatively) convenient macros to write\n-// the impls for you.\n-\n-#[macro_export]\n-macro_rules! BraceStructLiftImpl {\n-    (impl<$($p:tt),*> Lift<$tcx:tt> for $s:path {\n-        type Lifted = $lifted:ty;\n-        $($field:ident),* $(,)*\n-    } $(where $($wc:tt)*)*) => {\n-        impl<$($p),*> $crate::ty::Lift<$tcx> for $s\n-            $(where $($wc)*)*\n-        {\n-            type Lifted = $lifted;\n-\n-            fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<$lifted> {\n-                $(let $field = tcx.lift(&self.$field)?;)*\n-                Some(Self::Lifted { $($field),* })\n-            }\n-        }\n-    };\n-}\n-\n-#[macro_export]\n-macro_rules! EnumLiftImpl {\n-    (impl<$($p:tt),*> Lift<$tcx:tt> for $s:path {\n-        type Lifted = $lifted:ty;\n-        $(\n-            ($variant:path) ( $( $variant_arg:ident),* )\n-        ),*\n-        $(,)*\n-    } $(where $($wc:tt)*)*) => {\n-        impl<$($p),*> $crate::ty::Lift<$tcx> for $s\n-            $(where $($wc)*)*\n-        {\n-            type Lifted = $lifted;\n-\n-            fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<$lifted> {\n-                match self {\n-                    $($variant ( $($variant_arg),* ) => {\n-                        Some($variant ( $(tcx.lift($variant_arg)?),* ))\n-                    })*\n-                }\n-            }\n-        }\n-    };\n-}\n-\n-#[macro_export]\n-macro_rules! BraceStructTypeFoldableImpl {\n-    (impl<$($p:tt),*> TypeFoldable<$tcx:tt> for $s:path {\n-        $($field:ident),* $(,)*\n-    } $(where $($wc:tt)*)*) => {\n-        impl<$($p),*> $crate::ty::fold::TypeFoldable<$tcx> for $s\n-            $(where $($wc)*)*\n-        {\n-            fn super_fold_with<'gcx: $tcx, V: $crate::ty::fold::TypeFolder<'gcx, $tcx>>(\n-                &self,\n-                folder: &mut V,\n-            ) -> Self {\n-                let $s { $($field,)* } = self;\n-                $s { $($field: $field.fold_with(folder),)* }\n-            }\n-\n-            fn super_visit_with<V: $crate::ty::fold::TypeVisitor<$tcx>>(\n-                &self,\n-                visitor: &mut V,\n-            ) -> bool {\n-                let $s { $($field,)* } = self;\n-                false $(|| $field.visit_with(visitor))*\n-            }\n-        }\n-    };\n-}\n-\n-#[macro_export]\n-macro_rules! EnumTypeFoldableImpl {\n-    (impl<$($p:tt),*> TypeFoldable<$tcx:tt> for $s:path {\n-        $(\n-            ($variant:path) ( $( $variant_arg:ident),* )\n-        ),*\n-        $(,)*\n-    } $(where $($wc:tt)*)*) => {\n-        impl<$($p),*> $crate::ty::fold::TypeFoldable<$tcx> for $s\n-            $(where $($wc)*)*\n-        {\n-            fn super_fold_with<'gcx: $tcx, V: $crate::ty::fold::TypeFolder<'gcx, $tcx>>(\n-                &self,\n-                folder: &mut V,\n-            ) -> Self {\n-                match self {\n-                    $($variant ( $($variant_arg),* ) => {\n-                        $variant ( $($variant_arg.fold_with(folder)),* )\n-                    })*\n-                }\n-            }\n-\n-            fn super_visit_with<V: $crate::ty::fold::TypeVisitor<$tcx>>(\n-                &self,\n-                visitor: &mut V,\n-            ) -> bool {\n-                match self {\n-                    $($variant ( $($variant_arg),* ) => {\n-                        false $(|| $variant_arg.visit_with(visitor))*\n-                    })*\n-                }\n-            }\n-        }\n-    };\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // Lift implementations\n \n@@ -776,6 +660,17 @@ BraceStructLiftImpl! {\n // can easily refactor the folding into the TypeFolder trait as\n // needed.\n \n+/// AdtDefs are basically the same as a DefId.\n+impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::AdtDef {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, _folder: &mut F) -> Self {\n+        *self\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _visitor: &mut V) -> bool {\n+        false\n+    }\n+}\n+\n impl<'tcx, T:TypeFoldable<'tcx>, U:TypeFoldable<'tcx>> TypeFoldable<'tcx> for (T, U) {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> (T, U) {\n         (self.0.fold_with(folder), self.1.fold_with(folder))\n@@ -786,14 +681,11 @@ impl<'tcx, T:TypeFoldable<'tcx>, U:TypeFoldable<'tcx>> TypeFoldable<'tcx> for (T\n     }\n }\n \n-impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Option<T> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        self.as_ref().map(|t| t.fold_with(folder))\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.iter().any(|t| t.visit_with(visitor))\n-    }\n+EnumTypeFoldableImpl! {\n+    impl<'tcx, T> TypeFoldable<'tcx> for Option<T> {\n+        (Some)(a),\n+        (None),\n+    } where T: TypeFoldable<'tcx>\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Rc<T> {\n@@ -881,22 +773,11 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Slice<ty::ExistentialPredicate<'tcx>\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::ExistentialPredicate<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self  {\n-        use ty::ExistentialPredicate::*;\n-        match *self {\n-            Trait(ref tr) => Trait(tr.fold_with(folder)),\n-            Projection(ref p) => Projection(p.fold_with(folder)),\n-            AutoTrait(did) => AutoTrait(did),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        match *self {\n-            ty::ExistentialPredicate::Trait(ref tr) => tr.visit_with(visitor),\n-            ty::ExistentialPredicate::Projection(ref p) => p.visit_with(visitor),\n-            ty::ExistentialPredicate::AutoTrait(_) => false,\n-        }\n+EnumTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for ty::ExistentialPredicate<'tcx> {\n+        (ty::ExistentialPredicate::Trait)(a),\n+        (ty::ExistentialPredicate::Projection)(a),\n+        (ty::ExistentialPredicate::AutoTrait)(a),\n     }\n }\n \n@@ -1049,13 +930,9 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::TypeAndMut<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::TypeAndMut { ty: self.ty.fold_with(folder), mutbl: self.mutbl }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.ty.visit_with(visitor)\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for ty::TypeAndMut<'tcx> {\n+        ty, mutbl\n     }\n }\n \n@@ -1065,20 +942,9 @@ BraceStructTypeFoldableImpl! {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::FnSig<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        let inputs_and_output = self.inputs_and_output.fold_with(folder);\n-        ty::FnSig {\n-            inputs_and_output: folder.tcx().intern_type_list(&inputs_and_output),\n-            variadic: self.variadic,\n-            unsafety: self.unsafety,\n-            abi: self.abi,\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.inputs().iter().any(|i| i.visit_with(visitor)) ||\n-        self.output().visit_with(visitor)\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for ty::FnSig<'tcx> {\n+        inputs_and_output, variadic, unsafety, abi\n     }\n }\n \n@@ -1117,28 +983,15 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Region<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::ClosureSubsts<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::ClosureSubsts {\n-            substs: self.substs.fold_with(folder),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.substs.visit_with(visitor)\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for ty::ClosureSubsts<'tcx> {\n+        substs,\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::GeneratorInterior<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::GeneratorInterior {\n-           witness: self.witness.fold_with(folder),\n-           movable: self.movable,\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.witness.visit_with(visitor)\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for ty::GeneratorInterior<'tcx> {\n+        witness, movable,\n     }\n }\n \n@@ -1149,74 +1002,32 @@ BraceStructTypeFoldableImpl! {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::Adjust<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        match *self {\n-            ty::adjustment::Adjust::NeverToAny |\n-            ty::adjustment::Adjust::ReifyFnPointer |\n-            ty::adjustment::Adjust::UnsafeFnPointer |\n-            ty::adjustment::Adjust::ClosureFnPointer |\n-            ty::adjustment::Adjust::MutToConstPointer |\n-            ty::adjustment::Adjust::Unsize => self.clone(),\n-            ty::adjustment::Adjust::Deref(ref overloaded) => {\n-                ty::adjustment::Adjust::Deref(overloaded.fold_with(folder))\n-            }\n-            ty::adjustment::Adjust::Borrow(ref autoref) => {\n-                ty::adjustment::Adjust::Borrow(autoref.fold_with(folder))\n-            }\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        match *self {\n-            ty::adjustment::Adjust::NeverToAny |\n-            ty::adjustment::Adjust::ReifyFnPointer |\n-            ty::adjustment::Adjust::UnsafeFnPointer |\n-            ty::adjustment::Adjust::ClosureFnPointer |\n-            ty::adjustment::Adjust::MutToConstPointer |\n-            ty::adjustment::Adjust::Unsize => false,\n-            ty::adjustment::Adjust::Deref(ref overloaded) => {\n-                overloaded.visit_with(visitor)\n-            }\n-            ty::adjustment::Adjust::Borrow(ref autoref) => {\n-                autoref.visit_with(visitor)\n-            }\n-        }\n+EnumTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::Adjust<'tcx> {\n+        (ty::adjustment::Adjust::NeverToAny),\n+        (ty::adjustment::Adjust::ReifyFnPointer),\n+        (ty::adjustment::Adjust::UnsafeFnPointer),\n+        (ty::adjustment::Adjust::ClosureFnPointer),\n+        (ty::adjustment::Adjust::MutToConstPointer),\n+        (ty::adjustment::Adjust::Unsize),\n+        (ty::adjustment::Adjust::Deref)(a),\n+        (ty::adjustment::Adjust::Borrow)(a),\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::OverloadedDeref<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::adjustment::OverloadedDeref {\n-            region: self.region.fold_with(folder),\n-            mutbl: self.mutbl,\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.region.visit_with(visitor)\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::OverloadedDeref<'tcx> {\n+        region, mutbl,\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::AutoBorrow<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        match *self {\n-            ty::adjustment::AutoBorrow::Ref(ref r, m) => {\n-                ty::adjustment::AutoBorrow::Ref(r.fold_with(folder), m)\n-            }\n-            ty::adjustment::AutoBorrow::RawPtr(m) => ty::adjustment::AutoBorrow::RawPtr(m)\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        match *self {\n-            ty::adjustment::AutoBorrow::Ref(r, _m) => r.visit_with(visitor),\n-            ty::adjustment::AutoBorrow::RawPtr(_m) => false,\n-        }\n+EnumTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::AutoBorrow<'tcx> {\n+        (ty::adjustment::AutoBorrow::Ref)(a, b),\n+        (ty::adjustment::AutoBorrow::RawPtr)(m),\n     }\n }\n \n-\n BraceStructTypeFoldableImpl! {\n     impl<'tcx> TypeFoldable<'tcx> for ty::GenericPredicates<'tcx> {\n         parent, predicates\n@@ -1234,43 +1045,17 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Slice<ty::Predicate<'tcx>> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        match *self {\n-            ty::Predicate::Trait(ref a) =>\n-                ty::Predicate::Trait(a.fold_with(folder)),\n-            ty::Predicate::Subtype(ref binder) =>\n-                ty::Predicate::Subtype(binder.fold_with(folder)),\n-            ty::Predicate::RegionOutlives(ref binder) =>\n-                ty::Predicate::RegionOutlives(binder.fold_with(folder)),\n-            ty::Predicate::TypeOutlives(ref binder) =>\n-                ty::Predicate::TypeOutlives(binder.fold_with(folder)),\n-            ty::Predicate::Projection(ref binder) =>\n-                ty::Predicate::Projection(binder.fold_with(folder)),\n-            ty::Predicate::WellFormed(data) =>\n-                ty::Predicate::WellFormed(data.fold_with(folder)),\n-            ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) =>\n-                ty::Predicate::ClosureKind(closure_def_id, closure_substs.fold_with(folder), kind),\n-            ty::Predicate::ObjectSafe(trait_def_id) =>\n-                ty::Predicate::ObjectSafe(trait_def_id),\n-            ty::Predicate::ConstEvaluatable(def_id, substs) =>\n-                ty::Predicate::ConstEvaluatable(def_id, substs.fold_with(folder)),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        match *self {\n-            ty::Predicate::Trait(ref a) => a.visit_with(visitor),\n-            ty::Predicate::Subtype(ref binder) => binder.visit_with(visitor),\n-            ty::Predicate::RegionOutlives(ref binder) => binder.visit_with(visitor),\n-            ty::Predicate::TypeOutlives(ref binder) => binder.visit_with(visitor),\n-            ty::Predicate::Projection(ref binder) => binder.visit_with(visitor),\n-            ty::Predicate::WellFormed(data) => data.visit_with(visitor),\n-            ty::Predicate::ClosureKind(_closure_def_id, closure_substs, _kind) =>\n-                closure_substs.visit_with(visitor),\n-            ty::Predicate::ObjectSafe(_trait_def_id) => false,\n-            ty::Predicate::ConstEvaluatable(_def_id, substs) => substs.visit_with(visitor),\n-        }\n+EnumTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n+        (ty::Predicate::Trait)(a),\n+        (ty::Predicate::Subtype)(a),\n+        (ty::Predicate::RegionOutlives)(a),\n+        (ty::Predicate::TypeOutlives)(a),\n+        (ty::Predicate::Projection)(a),\n+        (ty::Predicate::WellFormed)(a),\n+        (ty::Predicate::ClosureKind)(a, b, c),\n+        (ty::Predicate::ObjectSafe)(a),\n+        (ty::Predicate::ConstEvaluatable)(a, b),\n     }\n }\n \n@@ -1298,71 +1083,40 @@ BraceStructTypeFoldableImpl! {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::SubtypePredicate<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::SubtypePredicate {\n-            a_is_expected: self.a_is_expected,\n-            a: self.a.fold_with(folder),\n-            b: self.b.fold_with(folder)\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.a.visit_with(visitor) || self.b.visit_with(visitor)\n-    }\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx, T> TypeFoldable<'tcx> for ty::ParamEnvAnd<'tcx, T> {\n+        param_env, value\n+    } where T: TypeFoldable<'tcx>\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::TraitPredicate<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::TraitPredicate {\n-            trait_ref: self.trait_ref.fold_with(folder)\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.trait_ref.visit_with(visitor)\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for ty::SubtypePredicate<'tcx> {\n+        a_is_expected, a, b\n     }\n }\n \n-impl<'tcx,T,U> TypeFoldable<'tcx> for ty::OutlivesPredicate<T,U>\n-    where T : TypeFoldable<'tcx>,\n-          U : TypeFoldable<'tcx>,\n-{\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::OutlivesPredicate(self.0.fold_with(folder),\n-                              self.1.fold_with(folder))\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.0.visit_with(visitor) || self.1.visit_with(visitor)\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for ty::TraitPredicate<'tcx> {\n+        trait_ref\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::ClosureUpvar<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::ClosureUpvar {\n-            def: self.def,\n-            span: self.span,\n-            ty: self.ty.fold_with(folder),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.ty.visit_with(visitor)\n-    }\n+TupleStructTypeFoldableImpl! {\n+    impl<'tcx,T,U> TypeFoldable<'tcx> for ty::OutlivesPredicate<T,U> {\n+        a, b\n+    } where T : TypeFoldable<'tcx>, U : TypeFoldable<'tcx>,\n }\n \n-impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::error::ExpectedFound<T> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::error::ExpectedFound {\n-            expected: self.expected.fold_with(folder),\n-            found: self.found.fold_with(folder),\n-        }\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for ty::ClosureUpvar<'tcx> {\n+        def, span, ty\n     }\n+}\n \n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.expected.visit_with(visitor) || self.found.visit_with(visitor)\n-    }\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx, T> TypeFoldable<'tcx> for ty::error::ExpectedFound<T> {\n+        expected, found\n+    } where T: TypeFoldable<'tcx>\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>, I: Idx> TypeFoldable<'tcx> for IndexVec<I, T> {\n@@ -1375,69 +1129,28 @@ impl<'tcx, T: TypeFoldable<'tcx>, I: Idx> TypeFoldable<'tcx> for IndexVec<I, T>\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::error::TypeError<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        use ty::error::TypeError::*;\n-\n-        match *self {\n-            Mismatch => Mismatch,\n-            UnsafetyMismatch(x) => UnsafetyMismatch(x.fold_with(folder)),\n-            AbiMismatch(x) => AbiMismatch(x.fold_with(folder)),\n-            Mutability => Mutability,\n-            TupleSize(x) => TupleSize(x),\n-            FixedArraySize(x) => FixedArraySize(x),\n-            ArgCount => ArgCount,\n-            RegionsDoesNotOutlive(a, b) => {\n-                RegionsDoesNotOutlive(a.fold_with(folder), b.fold_with(folder))\n-            },\n-            RegionsInsufficientlyPolymorphic(a, b) => {\n-                RegionsInsufficientlyPolymorphic(a, b.fold_with(folder))\n-            },\n-            RegionsOverlyPolymorphic(a, b) => {\n-                RegionsOverlyPolymorphic(a, b.fold_with(folder))\n-            },\n-            IntMismatch(x) => IntMismatch(x),\n-            FloatMismatch(x) => FloatMismatch(x),\n-            Traits(x) => Traits(x),\n-            VariadicMismatch(x) => VariadicMismatch(x),\n-            CyclicTy(t) => CyclicTy(t.fold_with(folder)),\n-            ProjectionMismatched(x) => ProjectionMismatched(x),\n-            ProjectionBoundsLength(x) => ProjectionBoundsLength(x),\n-            Sorts(x) => Sorts(x.fold_with(folder)),\n-            ExistentialMismatch(x) => ExistentialMismatch(x.fold_with(folder)),\n-            OldStyleLUB(ref x) => OldStyleLUB(x.fold_with(folder)),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        use ty::error::TypeError::*;\n-\n-        match *self {\n-            UnsafetyMismatch(x) => x.visit_with(visitor),\n-            AbiMismatch(x) => x.visit_with(visitor),\n-            RegionsDoesNotOutlive(a, b) => {\n-                a.visit_with(visitor) || b.visit_with(visitor)\n-            },\n-            RegionsInsufficientlyPolymorphic(_, b) |\n-            RegionsOverlyPolymorphic(_, b) => {\n-                b.visit_with(visitor)\n-            },\n-            Sorts(x) => x.visit_with(visitor),\n-            OldStyleLUB(ref x) => x.visit_with(visitor),\n-            ExistentialMismatch(x) => x.visit_with(visitor),\n-            CyclicTy(t) => t.visit_with(visitor),\n-            Mismatch |\n-            Mutability |\n-            TupleSize(_) |\n-            FixedArraySize(_) |\n-            ArgCount |\n-            IntMismatch(_) |\n-            FloatMismatch(_) |\n-            Traits(_) |\n-            VariadicMismatch(_) |\n-            ProjectionMismatched(_) |\n-            ProjectionBoundsLength(_) => false,\n-        }\n+EnumTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for ty::error::TypeError<'tcx> {\n+        (ty::error::TypeError::Mismatch),\n+        (ty::error::TypeError::UnsafetyMismatch)(x),\n+        (ty::error::TypeError::AbiMismatch)(x),\n+        (ty::error::TypeError::Mutability),\n+        (ty::error::TypeError::TupleSize)(x),\n+        (ty::error::TypeError::FixedArraySize)(x),\n+        (ty::error::TypeError::ArgCount),\n+        (ty::error::TypeError::RegionsDoesNotOutlive)(a, b),\n+        (ty::error::TypeError::RegionsInsufficientlyPolymorphic)(a, b),\n+        (ty::error::TypeError::RegionsOverlyPolymorphic)(a, b),\n+        (ty::error::TypeError::IntMismatch)(x),\n+        (ty::error::TypeError::FloatMismatch)(x),\n+        (ty::error::TypeError::Traits)(x),\n+        (ty::error::TypeError::VariadicMismatch)(x),\n+        (ty::error::TypeError::CyclicTy)(t),\n+        (ty::error::TypeError::ProjectionMismatched)(x),\n+        (ty::error::TypeError::ProjectionBoundsLength)(x),\n+        (ty::error::TypeError::Sorts)(x),\n+        (ty::error::TypeError::ExistentialMismatch)(x),\n+        (ty::error::TypeError::OldStyleLUB)(x),\n     }\n }\n "}]}