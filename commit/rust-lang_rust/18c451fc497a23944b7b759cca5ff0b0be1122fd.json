{"sha": "18c451fc497a23944b7b759cca5ff0b0be1122fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4YzQ1MWZjNDk3YTIzOTQ0YjdiNzU5Y2NhNWZmMGIwYmUxMTIyZmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-14T06:36:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-14T06:36:49Z"}, "message": "auto merge of #14739 : zwarich/rust/mut-unique-path, r=nikomatsakis\n\nImplement the stronger guarantees for mutable borrows proposed in #12624.", "tree": {"sha": "6d51b100a0e6a6b2f1b6c95b28b36125cacad5e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d51b100a0e6a6b2f1b6c95b28b36125cacad5e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18c451fc497a23944b7b759cca5ff0b0be1122fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18c451fc497a23944b7b759cca5ff0b0be1122fd", "html_url": "https://github.com/rust-lang/rust/commit/18c451fc497a23944b7b759cca5ff0b0be1122fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18c451fc497a23944b7b759cca5ff0b0be1122fd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c6caad1bab0660ce8b4797c10d5530964d6e8d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c6caad1bab0660ce8b4797c10d5530964d6e8d9", "html_url": "https://github.com/rust-lang/rust/commit/2c6caad1bab0660ce8b4797c10d5530964d6e8d9"}, {"sha": "6fc788916c297d6e03464b80f12ba0e62fccccac", "url": "https://api.github.com/repos/rust-lang/rust/commits/6fc788916c297d6e03464b80f12ba0e62fccccac", "html_url": "https://github.com/rust-lang/rust/commit/6fc788916c297d6e03464b80f12ba0e62fccccac"}], "stats": {"total": 702, "additions": 503, "deletions": 199}, "files": [{"sha": "34264aa1b814565d6644c524cfb8a98c6d741a91", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/18c451fc497a23944b7b759cca5ff0b0be1122fd/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c451fc497a23944b7b759cca5ff0b0be1122fd/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=18c451fc497a23944b7b759cca5ff0b0be1122fd", "patch": "@@ -406,7 +406,8 @@ impl<T> TypedArenaChunk<T> {\n             None => {}\n             Some(mut next) => {\n                 // We assume that the next chunk is completely filled.\n-                next.destroy(next.capacity)\n+                let capacity = next.capacity;\n+                next.destroy(capacity)\n             }\n         }\n     }"}, {"sha": "29edf1db51d704a4469b18808e08188dcc6cd86f", "filename": "src/libcollections/ringbuf.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/18c451fc497a23944b7b759cca5ff0b0be1122fd/src%2Flibcollections%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c451fc497a23944b7b759cca5ff0b0be1122fd/src%2Flibcollections%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fringbuf.rs?ref=18c451fc497a23944b7b759cca5ff0b0be1122fd", "patch": "@@ -66,7 +66,8 @@ impl<T> Deque<T> for RingBuf<T> {\n \n     /// Return a mutable reference to the last element in the RingBuf\n     fn back_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n-        if self.nelts > 0 { Some(self.get_mut(self.nelts - 1)) } else { None }\n+        let nelts = self.nelts;\n+        if nelts > 0 { Some(self.get_mut(nelts - 1)) } else { None }\n     }\n \n     /// Remove and return the first element in the RingBuf, or None if it is empty"}, {"sha": "61e732846a1a3db6f0e43d5ec3129ef2af2610f2", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/18c451fc497a23944b7b759cca5ff0b0be1122fd/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c451fc497a23944b7b759cca5ff0b0be1122fd/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=18c451fc497a23944b7b759cca5ff0b0be1122fd", "patch": "@@ -114,7 +114,8 @@ impl<T> Vec<T> {\n         unsafe {\n             let mut xs = Vec::with_capacity(length);\n             while xs.len < length {\n-                ptr::write(xs.as_mut_slice().unsafe_mut_ref(xs.len), op(xs.len));\n+                let len = xs.len;\n+                ptr::write(xs.as_mut_slice().unsafe_mut_ref(len), op(len));\n                 xs.len += 1;\n             }\n             xs\n@@ -210,7 +211,8 @@ impl<T: Clone> Vec<T> {\n         unsafe {\n             let mut xs = Vec::with_capacity(length);\n             while xs.len < length {\n-                ptr::write(xs.as_mut_slice().unsafe_mut_ref(xs.len),\n+                let len = xs.len;\n+                ptr::write(xs.as_mut_slice().unsafe_mut_ref(len),\n                            value.clone());\n                 xs.len += 1;\n             }\n@@ -321,9 +323,10 @@ impl<T:Clone> Clone for Vec<T> {\n             let this_slice = self.as_slice();\n             while vector.len < len {\n                 unsafe {\n+                    let len = vector.len;\n                     ptr::write(\n-                        vector.as_mut_slice().unsafe_mut_ref(vector.len),\n-                        this_slice.unsafe_ref(vector.len).clone());\n+                        vector.as_mut_slice().unsafe_mut_ref(len),\n+                        this_slice.unsafe_ref(len).clone());\n                 }\n                 vector.len += 1;\n             }"}, {"sha": "83eb4adfa9759605640b9e607f790f1f1fdb477f", "filename": "src/libdebug/repr.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/18c451fc497a23944b7b759cca5ff0b0be1122fd/src%2Flibdebug%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c451fc497a23944b7b759cca5ff0b0be1122fd/src%2Flibdebug%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibdebug%2Frepr.rs?ref=18c451fc497a23944b7b759cca5ff0b0be1122fd", "patch": "@@ -127,13 +127,15 @@ impl<'a> ReprVisitor<'a> {\n     #[inline]\n     pub fn get<T>(&mut self, f: |&mut ReprVisitor, &T| -> bool) -> bool {\n         unsafe {\n-            f(self, mem::transmute::<*u8,&T>(self.ptr))\n+            let ptr = self.ptr;\n+            f(self, mem::transmute::<*u8,&T>(ptr))\n         }\n     }\n \n     #[inline]\n     pub fn visit_inner(&mut self, inner: *TyDesc) -> bool {\n-        self.visit_ptr_inner(self.ptr, inner)\n+        let ptr = self.ptr;\n+        self.visit_ptr_inner(ptr, inner)\n     }\n \n     #[inline]"}, {"sha": "1c33114dc71739d90ee385cc60a4ce79aa27ab98", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/18c451fc497a23944b7b759cca5ff0b0be1122fd/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c451fc497a23944b7b759cca5ff0b0be1122fd/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=18c451fc497a23944b7b759cca5ff0b0be1122fd", "patch": "@@ -637,16 +637,15 @@ impl rtio::RtioUdpSocket for UdpSocket {\n                 mem::size_of::<libc::sockaddr_storage>() as libc::socklen_t;\n \n         let dolock = || self.lock_nonblocking();\n-        let doread = |nb| unsafe {\n+        let n = try!(read(fd, self.read_deadline, dolock, |nb| unsafe {\n             let flags = if nb {c::MSG_DONTWAIT} else {0};\n             libc::recvfrom(fd,\n                            buf.as_mut_ptr() as *mut libc::c_void,\n                            buf.len() as msglen_t,\n                            flags,\n                            storagep,\n                            &mut addrlen) as libc::c_int\n-        };\n-        let n = try!(read(fd, self.read_deadline, dolock, doread));\n+        }));\n         sockaddr_to_addr(&storage, addrlen as uint).and_then(|addr| {\n             Ok((n as uint, addr))\n         })"}, {"sha": "cedc40df300b604c0f6f6e7c3e282df9c577d48d", "filename": "src/libregex/parse/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/18c451fc497a23944b7b759cca5ff0b0be1122fd/src%2Flibregex%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c451fc497a23944b7b759cca5ff0b0be1122fd/src%2Flibregex%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse%2Fmod.rs?ref=18c451fc497a23944b7b759cca5ff0b0be1122fd", "patch": "@@ -345,18 +345,19 @@ impl<'a> Parser<'a> {\n     }\n \n     fn push_literal(&mut self, c: char) -> Result<(), Error> {\n+        let flags = self.flags;\n         match c {\n             '.' => {\n-                self.push(Dot(self.flags))\n+                self.push(Dot(flags))\n             }\n             '^' => {\n-                self.push(Begin(self.flags))\n+                self.push(Begin(flags))\n             }\n             '$' => {\n-                self.push(End(self.flags))\n+                self.push(End(flags))\n             }\n             _ => {\n-                self.push(Literal(c, self.flags))\n+                self.push(Literal(c, flags))\n             }\n         }\n         Ok(())"}, {"sha": "111441180475e9a03d4fac38d3086ebd6833ceda", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 128, "deletions": 66, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/18c451fc497a23944b7b759cca5ff0b0be1122fd/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c451fc497a23944b7b759cca5ff0b0be1122fd/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=18c451fc497a23944b7b759cca5ff0b0be1122fd", "patch": "@@ -150,9 +150,9 @@ pub fn check_loans(bccx: &BorrowckCtxt,\n }\n \n #[deriving(PartialEq)]\n-enum MoveError {\n-    MoveOk,\n-    MoveWhileBorrowed(/*loan*/Rc<LoanPath>, /*loan*/Span)\n+enum UseError {\n+    UseOk,\n+    UseWhileBorrowed(/*loan*/Rc<LoanPath>, /*loan*/Span)\n }\n \n impl<'a> CheckLoanCtxt<'a> {\n@@ -438,8 +438,7 @@ impl<'a> CheckLoanCtxt<'a> {\n             Some(lp) => {\n                 let moved_value_use_kind = match mode {\n                     euv::Copy => {\n-                        // FIXME(#12624) -- If we are copying the value,\n-                        // we don't care if it's borrowed.\n+                        self.check_for_copy_of_frozen_path(id, span, &*lp);\n                         MovedInUse\n                     }\n                     euv::Move(_) => {\n@@ -454,7 +453,7 @@ impl<'a> CheckLoanCtxt<'a> {\n                             }\n                             Some(move_kind) => {\n                                 self.check_for_move_of_borrowed_path(id, span,\n-                                                                     &lp, move_kind);\n+                                                                     &*lp, move_kind);\n                                 if move_kind == move_data::Captured {\n                                     MovedInCapture\n                                 } else {\n@@ -471,23 +470,47 @@ impl<'a> CheckLoanCtxt<'a> {\n         }\n     }\n \n+    fn check_for_copy_of_frozen_path(&self,\n+                                     id: ast::NodeId,\n+                                     span: Span,\n+                                     copy_path: &LoanPath) {\n+        match self.analyze_restrictions_on_use(id, copy_path, ty::ImmBorrow) {\n+            UseOk => { }\n+            UseWhileBorrowed(loan_path, loan_span) => {\n+                self.bccx.span_err(\n+                    span,\n+                    format!(\"cannot use `{}` because it was mutably borrowed\",\n+                            self.bccx.loan_path_to_str(copy_path).as_slice())\n+                    .as_slice());\n+                self.bccx.span_note(\n+                    loan_span,\n+                    format!(\"borrow of `{}` occurs here\",\n+                            self.bccx.loan_path_to_str(&*loan_path).as_slice())\n+                    .as_slice());\n+            }\n+        }\n+    }\n+\n     fn check_for_move_of_borrowed_path(&self,\n                                        id: ast::NodeId,\n                                        span: Span,\n-                                       move_path: &Rc<LoanPath>,\n+                                       move_path: &LoanPath,\n                                        move_kind: move_data::MoveKind) {\n-        match self.analyze_move_out_from(id, &**move_path) {\n-            MoveOk => { }\n-            MoveWhileBorrowed(loan_path, loan_span) => {\n+        // We want to detect if there are any loans at all, so we search for\n+        // any loans incompatible with MutBorrrow, since all other kinds of\n+        // loans are incompatible with that.\n+        match self.analyze_restrictions_on_use(id, move_path, ty::MutBorrow) {\n+            UseOk => { }\n+            UseWhileBorrowed(loan_path, loan_span) => {\n                 let err_message = match move_kind {\n                     move_data::Captured =>\n                         format!(\"cannot move `{}` into closure because it is borrowed\",\n-                                self.bccx.loan_path_to_str(&**move_path).as_slice()),\n+                                self.bccx.loan_path_to_str(move_path).as_slice()),\n                     move_data::Declared |\n                     move_data::MoveExpr |\n                     move_data::MovePat =>\n                         format!(\"cannot move out of `{}` because it is borrowed\",\n-                                self.bccx.loan_path_to_str(&**move_path).as_slice())\n+                                self.bccx.loan_path_to_str(move_path).as_slice())\n                 };\n \n                 self.bccx.span_err(span, err_message.as_slice());\n@@ -500,6 +523,99 @@ impl<'a> CheckLoanCtxt<'a> {\n         }\n     }\n \n+    pub fn analyze_restrictions_on_use(&self,\n+                                       expr_id: ast::NodeId,\n+                                       use_path: &LoanPath,\n+                                       borrow_kind: ty::BorrowKind)\n+                                       -> UseError {\n+        debug!(\"analyze_restrictions_on_use(expr_id={:?}, use_path={})\",\n+               self.tcx().map.node_to_str(expr_id),\n+               use_path.repr(self.tcx()));\n+\n+        let mut ret = UseOk;\n+\n+        // First, we check for a restriction on the path P being used. This\n+        // accounts for borrows of P but also borrows of subpaths, like P.a.b.\n+        // Consider the following example:\n+        //\n+        //     let x = &mut a.b.c; // Restricts a, a.b, and a.b.c\n+        //     let y = a;          // Conflicts with restriction\n+\n+        self.each_in_scope_restriction(expr_id, use_path, |loan, _restr| {\n+            if incompatible(loan.kind, borrow_kind) {\n+                ret = UseWhileBorrowed(loan.loan_path.clone(), loan.span);\n+                false\n+            } else {\n+                true\n+            }\n+        });\n+\n+        // Next, we must check for *loans* (not restrictions) on the path P or\n+        // any base path. This rejects examples like the following:\n+        //\n+        //     let x = &mut a.b;\n+        //     let y = a.b.c;\n+        //\n+        // Limiting this search to *loans* and not *restrictions* means that\n+        // examples like the following continue to work:\n+        //\n+        //     let x = &mut a.b;\n+        //     let y = a.c;\n+\n+        let mut loan_path = use_path;\n+        loop {\n+            self.each_in_scope_loan(expr_id, |loan| {\n+                if *loan.loan_path == *loan_path &&\n+                   incompatible(loan.kind, borrow_kind) {\n+                    ret = UseWhileBorrowed(loan.loan_path.clone(), loan.span);\n+                    false\n+                } else {\n+                    true\n+                }\n+            });\n+\n+            match *loan_path {\n+                LpVar(_) => {\n+                    break;\n+                }\n+                LpExtend(ref lp_base, _, _) => {\n+                    loan_path = &**lp_base;\n+                }\n+            }\n+        }\n+\n+        return ret;\n+\n+        fn incompatible(borrow_kind1: ty::BorrowKind,\n+                        borrow_kind2: ty::BorrowKind)\n+                        -> bool {\n+            borrow_kind1 != ty::ImmBorrow || borrow_kind2 != ty::ImmBorrow\n+        }\n+    }\n+\n+    fn check_if_path_is_moved(&self,\n+                              id: ast::NodeId,\n+                              span: Span,\n+                              use_kind: MovedValueUseKind,\n+                              lp: &Rc<LoanPath>) {\n+        /*!\n+         * Reports an error if `expr` (which should be a path)\n+         * is using a moved/uninitialized value\n+         */\n+\n+        debug!(\"check_if_path_is_moved(id={:?}, use_kind={:?}, lp={})\",\n+               id, use_kind, lp.repr(self.bccx.tcx));\n+        self.move_data.each_move_of(id, lp, |move, moved_lp| {\n+            self.bccx.report_use_of_moved_value(\n+                span,\n+                use_kind,\n+                &**lp,\n+                move,\n+                moved_lp);\n+            false\n+        });\n+    }\n+\n     fn check_if_assigned_path_is_moved(&self,\n                                        id: ast::NodeId,\n                                        span: Span,\n@@ -541,29 +657,6 @@ impl<'a> CheckLoanCtxt<'a> {\n         }\n     }\n \n-    fn check_if_path_is_moved(&self,\n-                              id: ast::NodeId,\n-                              span: Span,\n-                              use_kind: MovedValueUseKind,\n-                              lp: &Rc<LoanPath>) {\n-        /*!\n-         * Reports an error if `expr` (which should be a path)\n-         * is using a moved/uninitialized value\n-         */\n-\n-        debug!(\"check_if_path_is_moved(id={:?}, use_kind={:?}, lp={})\",\n-               id, use_kind, lp.repr(self.bccx.tcx));\n-        self.move_data.each_move_of(id, lp, |move, moved_lp| {\n-            self.bccx.report_use_of_moved_value(\n-                span,\n-                use_kind,\n-                &**lp,\n-                move,\n-                moved_lp);\n-            false\n-        });\n-    }\n-\n     fn check_assignment(&self,\n                         assignment_id: ast::NodeId,\n                         assignment_span: Span,\n@@ -862,35 +955,4 @@ impl<'a> CheckLoanCtxt<'a> {\n             format!(\"borrow of `{}` occurs here\",\n                     self.bccx.loan_path_to_str(loan_path)).as_slice());\n     }\n-\n-    pub fn analyze_move_out_from(&self,\n-                                 expr_id: ast::NodeId,\n-                                 move_path: &LoanPath)\n-                                 -> MoveError {\n-        debug!(\"analyze_move_out_from(expr_id={:?}, move_path={})\",\n-               self.tcx().map.node_to_str(expr_id),\n-               move_path.repr(self.tcx()));\n-\n-        // We must check every element of a move path. See\n-        // `borrowck-move-subcomponent.rs` for a test case.\n-\n-        // check for a conflicting loan:\n-        let mut ret = MoveOk;\n-        self.each_in_scope_restriction(expr_id, move_path, |loan, _| {\n-            // Any restriction prevents moves.\n-            ret = MoveWhileBorrowed(loan.loan_path.clone(), loan.span);\n-            false\n-        });\n-\n-        if ret != MoveOk {\n-            return ret\n-        }\n-\n-        match *move_path {\n-            LpVar(_) => MoveOk,\n-            LpExtend(ref subpath, _, _) => {\n-                self.analyze_move_out_from(expr_id, &**subpath)\n-            }\n-        }\n-    }\n }"}, {"sha": "bc083dac6ac7512b77d49d56496c57e5577aa38a", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/18c451fc497a23944b7b759cca5ff0b0be1122fd/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c451fc497a23944b7b759cca5ff0b0be1122fd/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=18c451fc497a23944b7b759cca5ff0b0be1122fd", "patch": "@@ -300,12 +300,13 @@ impl<'a, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, O> {\n         }\n \n         {\n+            let words_per_id = self.words_per_id;\n             let mut propcx = PropagationContext {\n                 dfcx: &mut *self,\n                 changed: true\n             };\n \n-            let mut temp = Vec::from_elem(self.words_per_id, 0u);\n+            let mut temp = Vec::from_elem(words_per_id, 0u);\n             let mut loop_scopes = Vec::new();\n \n             while propcx.changed {"}, {"sha": "cd876113807a973acd94f122686f72def9f9bf02", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/18c451fc497a23944b7b759cca5ff0b0be1122fd/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c451fc497a23944b7b759cca5ff0b0be1122fd/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=18c451fc497a23944b7b759cca5ff0b0be1122fd", "patch": "@@ -547,11 +547,13 @@ struct Liveness<'a> {\n \n impl<'a> Liveness<'a> {\n     fn new(ir: &'a mut IrMaps<'a>, specials: Specials) -> Liveness<'a> {\n+        let num_live_nodes = ir.num_live_nodes;\n+        let num_vars = ir.num_vars;\n         Liveness {\n             ir: ir,\n             s: specials,\n-            successors: Vec::from_elem(ir.num_live_nodes, invalid_node()),\n-            users: Vec::from_elem(ir.num_live_nodes * ir.num_vars, invalid_users()),\n+            successors: Vec::from_elem(num_live_nodes, invalid_node()),\n+            users: Vec::from_elem(num_live_nodes * num_vars, invalid_users()),\n             loop_scope: Vec::new(),\n             break_ln: NodeMap::new(),\n             cont_ln: NodeMap::new(),\n@@ -826,8 +828,9 @@ impl<'a> Liveness<'a> {\n \n         debug!(\"compute: using id for block, {}\", block_to_str(body));\n \n+        let exit_ln = self.s.exit_ln;\n         let entry_ln: LiveNode =\n-            self.with_loop_nodes(body.id, self.s.exit_ln, self.s.exit_ln,\n+            self.with_loop_nodes(body.id, exit_ln, exit_ln,\n               |this| this.propagate_through_fn_block(decl, body));\n \n         // hack to skip the loop unless debug! is enabled:\n@@ -847,12 +850,13 @@ impl<'a> Liveness<'a> {\n                                   -> LiveNode {\n         // the fallthrough exit is only for those cases where we do not\n         // explicitly return:\n-        self.init_from_succ(self.s.fallthrough_ln, self.s.exit_ln);\n+        let s = self.s;\n+        self.init_from_succ(s.fallthrough_ln, s.exit_ln);\n         if blk.expr.is_none() {\n-            self.acc(self.s.fallthrough_ln, self.s.no_ret_var, ACC_READ)\n+            self.acc(s.fallthrough_ln, s.no_ret_var, ACC_READ)\n         }\n \n-        self.propagate_through_block(blk, self.s.fallthrough_ln)\n+        self.propagate_through_block(blk, s.fallthrough_ln)\n     }\n \n     fn propagate_through_block(&mut self, blk: &Block, succ: LiveNode)\n@@ -1036,7 +1040,8 @@ impl<'a> Liveness<'a> {\n \n           ExprRet(o_e) => {\n             // ignore succ and subst exit_ln:\n-            self.propagate_through_opt_expr(o_e, self.s.exit_ln)\n+            let exit_ln = self.s.exit_ln;\n+            self.propagate_through_opt_expr(o_e, exit_ln)\n           }\n \n           ExprBreak(opt_label) => {"}, {"sha": "112ecd66f4cc9023c418b2027b16ac49ce8beb9e", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/18c451fc497a23944b7b759cca5ff0b0be1122fd/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c451fc497a23944b7b759cca5ff0b0be1122fd/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=18c451fc497a23944b7b759cca5ff0b0be1122fd", "patch": "@@ -1019,9 +1019,10 @@ impl<'a> Visitor<()> for SanePrivacyVisitor<'a> {\n             self.check_sane_privacy(item);\n         }\n \n+        let in_fn = self.in_fn;\n         let orig_in_fn = replace(&mut self.in_fn, match item.node {\n             ast::ItemMod(..) => false, // modules turn privacy back on\n-            _ => self.in_fn,           // otherwise we inherit\n+            _ => in_fn,           // otherwise we inherit\n         });\n         visit::walk_item(self, item, ());\n         self.in_fn = orig_in_fn;"}, {"sha": "ca7596925a9cbd706033af708f71e4efe4b911e5", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/18c451fc497a23944b7b759cca5ff0b0be1122fd/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c451fc497a23944b7b759cca5ff0b0be1122fd/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=18c451fc497a23944b7b759cca5ff0b0be1122fd", "patch": "@@ -202,7 +202,8 @@ impl<'a, 'b> Context<'a, 'b> {\n             }\n             parse::CountIsNextParam => {\n                 if self.check_positional_ok() {\n-                    self.verify_arg_type(Exact(self.next_arg), Unsigned);\n+                    let next_arg = self.next_arg;\n+                    self.verify_arg_type(Exact(next_arg), Unsigned);\n                     self.next_arg += 1;\n                 }\n             }"}, {"sha": "c9122e3ceafb5e253b11d9a0243995b5c8b18c9a", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/18c451fc497a23944b7b759cca5ff0b0be1122fd/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c451fc497a23944b7b759cca5ff0b0be1122fd/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=18c451fc497a23944b7b759cca5ff0b0be1122fd", "patch": "@@ -73,7 +73,8 @@ impl<'a> ParserAttr for Parser<'a> {\n \n                 let style = if self.eat(&token::NOT) {\n                     if !permit_inner {\n-                        self.span_err(self.span,\n+                        let span = self.span;\n+                        self.span_err(span,\n                                       \"an inner attribute is not permitted in \\\n                                        this context\");\n                     }"}, {"sha": "f7eac0b323f7eee74040619760ef2042dca6218f", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 54, "deletions": 28, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/18c451fc497a23944b7b759cca5ff0b0be1122fd/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c451fc497a23944b7b759cca5ff0b0be1122fd/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=18c451fc497a23944b7b759cca5ff0b0be1122fd", "patch": "@@ -368,7 +368,8 @@ impl<'a> StringReader<'a> {\n                 } else {\n                     \"unterminated block comment\"\n                 };\n-                self.fatal_span(start_bpos, self.last_pos, msg);\n+                let last_bpos = self.last_pos;\n+                self.fatal_span(start_bpos, last_bpos, msg);\n             } else if self.curr_is('/') && self.nextch_is('*') {\n                 level += 1;\n                 self.bump();\n@@ -419,7 +420,8 @@ impl<'a> StringReader<'a> {\n                 rslt.push_str(exponent.as_slice());\n                 return Some(rslt);\n             } else {\n-                self.err_span(start_bpos, self.last_pos, \"scan_exponent: bad fp literal\");\n+                let last_bpos = self.last_pos;\n+                self.err_span(start_bpos, last_bpos, \"scan_exponent: bad fp literal\");\n                 rslt.push_str(\"1\"); // arbitrary placeholder exponent\n                 return Some(rslt);\n             }\n@@ -506,14 +508,16 @@ impl<'a> StringReader<'a> {\n                           else { Unsigned(ast::TyU64) };\n             }\n             if num_str.len() == 0u {\n-                self.err_span(start_bpos, self.last_pos, \"no valid digits found for number\");\n+                let last_bpos = self.last_pos;\n+                self.err_span(start_bpos, last_bpos, \"no valid digits found for number\");\n                 num_str = \"1\".to_string();\n             }\n             let parsed = match from_str_radix::<u64>(num_str.as_slice(),\n                                                      base as uint) {\n                 Some(p) => p,\n                 None => {\n-                    self.err_span(start_bpos, self.last_pos, \"int literal is too large\");\n+                    let last_bpos = self.last_pos;\n+                    self.err_span(start_bpos, last_bpos, \"int literal is too large\");\n                     1\n                 }\n             };\n@@ -546,13 +550,15 @@ impl<'a> StringReader<'a> {\n             if c == '3' && n == '2' {\n                 self.bump();\n                 self.bump();\n-                self.check_float_base(start_bpos, self.last_pos, base);\n+                let last_bpos = self.last_pos;\n+                self.check_float_base(start_bpos, last_bpos, base);\n                 return token::LIT_FLOAT(str_to_ident(num_str.as_slice()),\n                                         ast::TyF32);\n             } else if c == '6' && n == '4' {\n                 self.bump();\n                 self.bump();\n-                self.check_float_base(start_bpos, self.last_pos, base);\n+                let last_bpos = self.last_pos;\n+                self.check_float_base(start_bpos, last_bpos, base);\n                 return token::LIT_FLOAT(str_to_ident(num_str.as_slice()),\n                                         ast::TyF64);\n                 /* FIXME (#2252): if this is out of range for either a\n@@ -562,25 +568,30 @@ impl<'a> StringReader<'a> {\n                 self.bump();\n                 self.bump();\n                 self.bump();\n-                self.check_float_base(start_bpos, self.last_pos, base);\n+                let last_bpos = self.last_pos;\n+                self.check_float_base(start_bpos, last_bpos, base);\n                 return token::LIT_FLOAT(str_to_ident(num_str.as_slice()), ast::TyF128);\n             }\n-            self.err_span(start_bpos, self.last_pos, \"expected `f32`, `f64` or `f128` suffix\");\n+            let last_bpos = self.last_pos;\n+            self.err_span(start_bpos, last_bpos, \"expected `f32`, `f64` or `f128` suffix\");\n         }\n         if is_float {\n-            self.check_float_base(start_bpos, self.last_pos, base);\n+            let last_bpos = self.last_pos;\n+            self.check_float_base(start_bpos, last_bpos, base);\n             return token::LIT_FLOAT_UNSUFFIXED(str_to_ident(\n                     num_str.as_slice()));\n         } else {\n             if num_str.len() == 0u {\n-                self.err_span(start_bpos, self.last_pos, \"no valid digits found for number\");\n+                let last_bpos = self.last_pos;\n+                self.err_span(start_bpos, last_bpos, \"no valid digits found for number\");\n                 num_str = \"1\".to_string();\n             }\n             let parsed = match from_str_radix::<u64>(num_str.as_slice(),\n                                                      base as uint) {\n                 Some(p) => p,\n                 None => {\n-                    self.err_span(start_bpos, self.last_pos, \"int literal is too large\");\n+                    let last_bpos = self.last_pos;\n+                    self.err_span(start_bpos, last_bpos, \"int literal is too large\");\n                     1\n                 }\n             };\n@@ -597,10 +608,12 @@ impl<'a> StringReader<'a> {\n         let start_bpos = self.last_pos;\n         for _ in range(0, n_hex_digits) {\n             if self.is_eof() {\n-                self.fatal_span(start_bpos, self.last_pos, \"unterminated numeric character escape\");\n+                let last_bpos = self.last_pos;\n+                self.fatal_span(start_bpos, last_bpos, \"unterminated numeric character escape\");\n             }\n             if self.curr_is(delim) {\n-                self.err_span(start_bpos, self.last_pos, \"numeric character escape is too short\");\n+                let last_bpos = self.last_pos;\n+                self.err_span(start_bpos, last_bpos, \"numeric character escape is too short\");\n                 break;\n             }\n             let c = self.curr.unwrap_or('\\x00');\n@@ -616,7 +629,8 @@ impl<'a> StringReader<'a> {\n         match char::from_u32(accum_int) {\n             Some(x) => x,\n             None => {\n-                self.err_span(start_bpos, self.last_pos, \"illegal numeric character escape\");\n+                let last_bpos = self.last_pos;\n+                self.err_span(start_bpos, last_bpos, \"illegal numeric character escape\");\n                 '?'\n             }\n         }\n@@ -773,17 +787,18 @@ impl<'a> StringReader<'a> {\n                     });\n                 let keyword_checking_token =\n                     &token::IDENT(keyword_checking_ident, false);\n+                let last_bpos = self.last_pos;\n                 if token::is_keyword(token::keywords::Self,\n                                      keyword_checking_token) {\n                     self.err_span(start,\n-                                  self.last_pos,\n+                                  last_bpos,\n                                   \"invalid lifetime name: 'self \\\n                                    is no longer a special lifetime\");\n                 } else if token::is_any_keyword(keyword_checking_token) &&\n                     !token::is_keyword(token::keywords::Static,\n                                        keyword_checking_token) {\n                     self.err_span(start,\n-                                  self.last_pos,\n+                                  last_bpos,\n                                   \"invalid lifetime name\");\n                 }\n                 return token::LIFETIME(ident);\n@@ -811,7 +826,8 @@ impl<'a> StringReader<'a> {\n                                 'u' => self.scan_numeric_escape(4u, '\\''),\n                                 'U' => self.scan_numeric_escape(8u, '\\''),\n                                 c2 => {\n-                                    self.err_span_char(escaped_pos, self.last_pos,\n+                                    let last_bpos = self.last_pos;\n+                                    self.err_span_char(escaped_pos, last_bpos,\n                                                          \"unknown character escape\", c2);\n                                     c2\n                                 }\n@@ -820,17 +836,19 @@ impl<'a> StringReader<'a> {\n                     }\n                 }\n                 '\\t' | '\\n' | '\\r' | '\\'' => {\n-                    self.err_span_char( start, self.last_pos,\n+                    let last_bpos = self.last_pos;\n+                    self.err_span_char( start, last_bpos,\n                         \"character constant must be escaped\", c2);\n                 }\n                 _ => {}\n             }\n             if !self.curr_is('\\'') {\n+                let last_bpos = self.last_pos;\n                 self.fatal_span_verbose(\n                                    // Byte offsetting here is okay because the\n                                    // character before position `start` is an\n                                    // ascii single quote.\n-                                   start - BytePos(1), self.last_pos,\n+                                   start - BytePos(1), last_bpos,\n                                    \"unterminated character constant\".to_string());\n             }\n             self.bump(); // advance curr past token\n@@ -842,15 +860,17 @@ impl<'a> StringReader<'a> {\n             self.bump();\n             while !self.curr_is('\"') {\n                 if self.is_eof() {\n-                    self.fatal_span(start_bpos, self.last_pos, \"unterminated double quote string\");\n+                    let last_bpos = self.last_pos;\n+                    self.fatal_span(start_bpos, last_bpos, \"unterminated double quote string\");\n                 }\n \n                 let ch = self.curr.unwrap();\n                 self.bump();\n                 match ch {\n                   '\\\\' => {\n                     if self.is_eof() {\n-                        self.fatal_span(start_bpos, self.last_pos,\n+                        let last_bpos = self.last_pos;\n+                        self.fatal_span(start_bpos, last_bpos,\n                                \"unterminated double quote string\");\n                     }\n \n@@ -876,7 +896,8 @@ impl<'a> StringReader<'a> {\n                         accum_str.push_char(self.scan_numeric_escape(8u, '\"'));\n                       }\n                       c2 => {\n-                        self.err_span_char(escaped_pos, self.last_pos,\n+                        let last_bpos = self.last_pos;\n+                        self.err_span_char(escaped_pos, last_bpos,\n                                         \"unknown string escape\", c2);\n                       }\n                     }\n@@ -897,19 +918,23 @@ impl<'a> StringReader<'a> {\n             }\n \n             if self.is_eof() {\n-                self.fatal_span(start_bpos, self.last_pos, \"unterminated raw string\");\n+                let last_bpos = self.last_pos;\n+                self.fatal_span(start_bpos, last_bpos, \"unterminated raw string\");\n             } else if !self.curr_is('\"') {\n-                self.fatal_span_char(start_bpos, self.last_pos,\n+                let last_bpos = self.last_pos;\n+                let curr_char = self.curr.unwrap();\n+                self.fatal_span_char(start_bpos, last_bpos,\n                                 \"only `#` is allowed in raw string delimitation; \\\n                                  found illegal character\",\n-                                self.curr.unwrap());\n+                                curr_char);\n             }\n             self.bump();\n             let content_start_bpos = self.last_pos;\n             let mut content_end_bpos;\n             'outer: loop {\n                 if self.is_eof() {\n-                    self.fatal_span(start_bpos, self.last_pos, \"unterminated raw string\");\n+                    let last_bpos = self.last_pos;\n+                    self.fatal_span(start_bpos, last_bpos, \"unterminated raw string\");\n                 }\n                 if self.curr_is('\"') {\n                     content_end_bpos = self.last_pos;\n@@ -956,8 +981,9 @@ impl<'a> StringReader<'a> {\n           '^' => { return self.binop(token::CARET); }\n           '%' => { return self.binop(token::PERCENT); }\n           c => {\n-              self.fatal_span_char(self.last_pos, self.pos,\n-                              \"unknown start of token\", c);\n+              let last_bpos = self.last_pos;\n+              let bpos = self.pos;\n+              self.fatal_span_char(last_bpos, bpos, \"unknown start of token\", c);\n           }\n         }\n     }"}, {"sha": "250ed4af57198c38ff632bfa5d96c0707ca1061e", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 102, "deletions": 55, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/18c451fc497a23944b7b759cca5ff0b0be1122fd/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c451fc497a23944b7b759cca5ff0b0be1122fd/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=18c451fc497a23944b7b759cca5ff0b0be1122fd", "patch": "@@ -146,10 +146,12 @@ macro_rules! maybe_whole_expr (\n                         INTERPOLATED(token::NtPath(ref pt)) => (**pt).clone(),\n                         _ => unreachable!()\n                     };\n-                    Some($p.mk_expr($p.span.lo, $p.span.hi, ExprPath(pt)))\n+                    let span = $p.span;\n+                    Some($p.mk_expr(span.lo, span.hi, ExprPath(pt)))\n                 }\n                 INTERPOLATED(token::NtBlock(b)) => {\n-                    Some($p.mk_expr($p.span.lo, $p.span.hi, ExprBlock(b)))\n+                    let span = $p.span;\n+                    Some($p.mk_expr(span.lo, span.hi, ExprBlock(b)))\n                 }\n                 _ => None\n             };\n@@ -370,7 +372,8 @@ impl<'a> Parser<'a> {\n \n     pub fn unexpected_last(&mut self, t: &token::Token) -> ! {\n         let token_str = Parser::token_to_str(t);\n-        self.span_fatal(self.last_span, format!(\"unexpected token: `{}`\",\n+        let last_span = self.last_span;\n+        self.span_fatal(last_span, format!(\"unexpected token: `{}`\",\n                                                 token_str).as_slice());\n     }\n \n@@ -441,7 +444,8 @@ impl<'a> Parser<'a> {\n             && expected.iter().all(|t| *t != token::LBRACE)\n             && self.look_ahead(1, |t| *t == token::RBRACE) {\n             // matched; signal non-fatal error and recover.\n-            self.span_err(self.span,\n+            let span = self.span;\n+            self.span_err(span,\n                           \"unit-like struct construction is written with no trailing `{ }`\");\n             self.eat(&token::LBRACE);\n             self.eat(&token::RBRACE);\n@@ -560,7 +564,8 @@ impl<'a> Parser<'a> {\n     pub fn check_strict_keywords(&mut self) {\n         if token::is_strict_keyword(&self.token) {\n             let token_str = self.this_token_to_str();\n-            self.span_err(self.span,\n+            let span = self.span;\n+            self.span_err(span,\n                           format!(\"found `{}` in ident position\",\n                                   token_str).as_slice());\n         }\n@@ -581,8 +586,9 @@ impl<'a> Parser<'a> {\n         match self.token {\n             token::BINOP(token::AND) => self.bump(),\n             token::ANDAND => {\n-                let lo = self.span.lo + BytePos(1);\n-                self.replace_token(token::BINOP(token::AND), lo, self.span.hi)\n+                let span = self.span;\n+                let lo = span.lo + BytePos(1);\n+                self.replace_token(token::BINOP(token::AND), lo, span.hi)\n             }\n             _ => {\n                 let token_str = self.this_token_to_str();\n@@ -601,8 +607,9 @@ impl<'a> Parser<'a> {\n         match self.token {\n             token::BINOP(token::OR) => self.bump(),\n             token::OROR => {\n-                let lo = self.span.lo + BytePos(1);\n-                self.replace_token(token::BINOP(token::OR), lo, self.span.hi)\n+                let span = self.span;\n+                let lo = span.lo + BytePos(1);\n+                self.replace_token(token::BINOP(token::OR), lo, span.hi)\n             }\n             _ => {\n                 let found_token = self.this_token_to_str();\n@@ -644,8 +651,9 @@ impl<'a> Parser<'a> {\n                     _ => false,\n                 });\n                 if force || next_lifetime {\n-                    let lo = self.span.lo + BytePos(1);\n-                    self.replace_token(token::LT, lo, self.span.hi);\n+                    let span = self.span;\n+                    let lo = span.lo + BytePos(1);\n+                    self.replace_token(token::LT, lo, span.hi);\n                     true\n                 } else {\n                     false\n@@ -693,8 +701,9 @@ impl<'a> Parser<'a> {\n         match self.token {\n             token::GT => self.bump(),\n             token::BINOP(token::SHR) => {\n-                let lo = self.span.lo + BytePos(1);\n-                self.replace_token(token::GT, lo, self.span.hi)\n+                let span = self.span;\n+                let lo = span.lo + BytePos(1);\n+                self.replace_token(token::GT, lo, span.hi)\n             }\n             _ => {\n                 let gt_str = Parser::token_to_str(&token::GT);\n@@ -805,7 +814,8 @@ impl<'a> Parser<'a> {\n                                -> Vec<T> {\n         let result = self.parse_unspanned_seq(bra, ket, sep, f);\n         if result.is_empty() {\n-            self.span_err(self.last_span,\n+            let last_span = self.last_span;\n+            self.span_err(last_span,\n             \"nullary enum variants are written with no trailing `( )`\");\n         }\n         result\n@@ -1336,10 +1346,11 @@ impl<'a> Parser<'a> {\n         } else if self.token == token::TILDE {\n             // OWNED POINTER\n             self.bump();\n+            let last_span = self.last_span;\n             match self.token {\n                 token::LBRACKET =>\n-                    self.obsolete(self.last_span, ObsoleteOwnedVector),\n-                _ => self.obsolete(self.last_span, ObsoleteOwnedType),\n+                    self.obsolete(last_span, ObsoleteOwnedVector),\n+                _ => self.obsolete(last_span, ObsoleteOwnedType),\n             };\n             TyUniq(self.parse_ty(true))\n         } else if self.token == token::BINOP(token::STAR) {\n@@ -2375,17 +2386,18 @@ impl<'a> Parser<'a> {\n             let e = self.parse_prefix_expr();\n             hi = e.span.hi;\n             // HACK: turn ~[...] into a ~-vec\n+            let last_span = self.last_span;\n             ex = match e.node {\n               ExprVec(..) | ExprRepeat(..) => {\n-                  self.obsolete(self.last_span, ObsoleteOwnedVector);\n+                  self.obsolete(last_span, ObsoleteOwnedVector);\n                   ExprVstore(e, ExprVstoreUniq)\n               }\n               ExprLit(lit) if lit_is_str(lit) => {\n-                  self.obsolete(self.last_span, ObsoleteOwnedExpr);\n+                  self.obsolete(last_span, ObsoleteOwnedExpr);\n                   ExprVstore(e, ExprVstoreUniq)\n               }\n               _ => {\n-                  self.obsolete(self.last_span, ObsoleteOwnedExpr);\n+                  self.obsolete(last_span, ObsoleteOwnedExpr);\n                   self.mk_unary(UnUniq, e)\n               }\n             };\n@@ -2412,7 +2424,8 @@ impl<'a> Parser<'a> {\n             // HACK: turn `box [...]` into a boxed-vec\n             ex = match subexpression.node {\n                 ExprVec(..) | ExprRepeat(..) => {\n-                    self.obsolete(self.last_span, ObsoleteOwnedVector);\n+                    let last_span = self.last_span;\n+                    self.obsolete(last_span, ObsoleteOwnedVector);\n                     ExprVstore(subexpression, ExprVstoreUniq)\n                 }\n                 ExprLit(lit) if lit_is_str(lit) => {\n@@ -2843,8 +2856,9 @@ impl<'a> Parser<'a> {\n             self.bump();\n             let sub = self.parse_pat();\n             pat = PatBox(sub);\n-            hi = self.last_span.hi;\n-            self.obsolete(self.last_span, ObsoleteOwnedPattern);\n+            let last_span = self.last_span;\n+            hi = last_span.hi;\n+            self.obsolete(last_span, ObsoleteOwnedPattern);\n             return box(GC) ast::Pat {\n                 id: ast::DUMMY_NODE_ID,\n                 node: pat,\n@@ -3061,7 +3075,8 @@ impl<'a> Parser<'a> {\n                        binding_mode: ast::BindingMode)\n                        -> ast::Pat_ {\n         if !is_plain_ident(&self.token) {\n-            self.span_fatal(self.last_span,\n+            let last_span = self.last_span;\n+            self.span_fatal(last_span,\n                             \"expected identifier, found path\");\n         }\n         // why a path here, and not just an identifier?\n@@ -3079,8 +3094,9 @@ impl<'a> Parser<'a> {\n         // binding mode then we do not end up here, because the lookahead\n         // will direct us over to parse_enum_variant()\n         if self.token == token::LPAREN {\n+            let last_span = self.last_span;\n             self.span_fatal(\n-                self.last_span,\n+                last_span,\n                 \"expected identifier, found enum pattern\");\n         }\n \n@@ -3144,7 +3160,8 @@ impl<'a> Parser<'a> {\n         fn check_expected_item(p: &mut Parser, found_attrs: bool) {\n             // If we have attributes then we should have an item\n             if found_attrs {\n-                p.span_err(p.last_span, \"expected item after attributes\");\n+                let last_span = p.last_span;\n+                p.span_err(last_span, \"expected item after attributes\");\n             }\n         }\n \n@@ -3333,7 +3350,8 @@ impl<'a> Parser<'a> {\n             match self.token {\n                 token::SEMI => {\n                     if !attributes_box.is_empty() {\n-                        self.span_err(self.last_span, \"expected item after attributes\");\n+                        let last_span = self.last_span;\n+                        self.span_err(last_span, \"expected item after attributes\");\n                         attributes_box = Vec::new();\n                     }\n                     self.bump(); // empty\n@@ -3409,7 +3427,8 @@ impl<'a> Parser<'a> {\n         }\n \n         if !attributes_box.is_empty() {\n-            self.span_err(self.last_span, \"expected item after attributes\");\n+            let last_span = self.last_span;\n+            self.span_err(last_span, \"expected item after attributes\");\n         }\n \n         let hi = self.span.hi;\n@@ -3566,7 +3585,8 @@ impl<'a> Parser<'a> {\n                 if ty_param.default.is_some() {\n                     seen_default = true;\n                 } else if seen_default {\n-                    p.span_err(p.last_span,\n+                    let last_span = p.last_span;\n+                    p.span_err(last_span,\n                                \"type parameters with a default must be trailing\");\n                 }\n                 ty_param\n@@ -3591,7 +3611,8 @@ impl<'a> Parser<'a> {\n \n     fn forbid_lifetime(&mut self) {\n         if Parser::token_is_lifetime(&self.token) {\n-            self.span_fatal(self.span, \"lifetime parameters must be declared \\\n+            let span = self.span;\n+            self.span_fatal(span, \"lifetime parameters must be declared \\\n                                         prior to type parameters\");\n         }\n     }\n@@ -3609,11 +3630,13 @@ impl<'a> Parser<'a> {\n                         p.bump();\n                         if allow_variadic {\n                             if p.token != token::RPAREN {\n-                                p.span_fatal(p.span,\n+                                let span = p.span;\n+                                p.span_fatal(span,\n                                     \"`...` must be last in argument list for variadic function\");\n                             }\n                         } else {\n-                            p.span_fatal(p.span,\n+                            let span = p.span;\n+                            p.span_fatal(span,\n                                          \"only foreign functions are allowed to be variadic\");\n                         }\n                         None\n@@ -3756,7 +3779,8 @@ impl<'a> Parser<'a> {\n                     self.parse_mutability()\n                 } else { MutImmutable };\n                 if self.is_self_ident() {\n-                    self.span_err(self.span, \"cannot pass self by unsafe pointer\");\n+                    let span = self.span;\n+                    self.span_err(span, \"cannot pass self by unsafe pointer\");\n                     self.bump();\n                 }\n                 SelfValue\n@@ -4128,15 +4152,17 @@ impl<'a> Parser<'a> {\n             token::RBRACE => {}\n             #[cfg(stage0)]\n             _ => {\n+                let span = self.span;\n                 let token_str = self.this_token_to_str();\n-                self.span_fatal(self.span,\n+                self.span_fatal(span,\n                                 format!(\"expected `,`, or `\\\\}` but found `{}`\",\n                                         token_str).as_slice())\n             }\n             #[cfg(not(stage0))]\n             _ => {\n+                let span = self.span;\n                 let token_str = self.this_token_to_str();\n-                self.span_fatal(self.span,\n+                self.span_fatal(span,\n                                 format!(\"expected `,`, or `}}` but found `{}`\",\n                                         token_str).as_slice())\n             }\n@@ -4170,7 +4196,8 @@ impl<'a> Parser<'a> {\n     fn parse_for_sized(&mut self) -> Sized {\n         if self.eat_keyword(keywords::For) {\n             if !self.eat_keyword(keywords::Type) {\n-                self.span_err(self.last_span,\n+                let last_span = self.last_span;\n+                self.span_err(last_span,\n                     \"expected 'type' after for in trait item\");\n             }\n             DynSize\n@@ -4226,7 +4253,8 @@ impl<'a> Parser<'a> {\n \n         if first && attrs_remaining_len > 0u {\n             // We parsed attributes for the first item but didn't find it\n-            self.span_err(self.last_span, \"expected item after attributes\");\n+            let last_span = self.last_span;\n+            self.span_err(last_span, \"expected item after attributes\");\n         }\n \n         ast::Mod {\n@@ -4458,7 +4486,8 @@ impl<'a> Parser<'a> {\n             foreign_items: foreign_items\n         } = self.parse_foreign_items(first_item_attrs, true);\n         if ! attrs_remaining.is_empty() {\n-            self.span_err(self.last_span,\n+            let last_span = self.last_span;\n+            self.span_err(last_span,\n                           \"expected item after attributes\");\n         }\n         assert!(self.token == token::RBRACE);\n@@ -4494,8 +4523,9 @@ impl<'a> Parser<'a> {\n                 (path, the_ident)\n             }\n             _ => {\n+                let span = self.span;\n                 let token_str = self.this_token_to_str();\n-                self.span_fatal(self.span,\n+                self.span_fatal(span,\n                                 format!(\"expected extern crate name but \\\n                                          found `{}`\",\n                                         token_str).as_slice());\n@@ -4535,8 +4565,9 @@ impl<'a> Parser<'a> {\n         let m = self.parse_foreign_mod_items(abi, next);\n         self.expect(&token::RBRACE);\n \n+        let last_span = self.last_span;\n         let item = self.mk_item(lo,\n-                                self.last_span.hi,\n+                                last_span.hi,\n                                 special_idents::invalid,\n                                 ItemForeignMod(m),\n                                 visibility,\n@@ -4663,8 +4694,9 @@ impl<'a> Parser<'a> {\n                 match abi::lookup(the_string) {\n                     Some(abi) => Some(abi),\n                     None => {\n+                        let last_span = self.last_span;\n                         self.span_err(\n-                            self.last_span,\n+                            last_span,\n                             format!(\"illegal ABI: expected one of [{}], \\\n                                      found `{}`\",\n                                     abi::all_names().connect(\", \"),\n@@ -4720,7 +4752,8 @@ impl<'a> Parser<'a> {\n \n             if next_is_mod || self.eat_keyword(keywords::Crate) {\n                 if next_is_mod {\n-                   self.span_err(mk_sp(lo, self.last_span.hi),\n+                    let last_span = self.last_span;\n+                    self.span_err(mk_sp(lo, last_span.hi),\n                                  format!(\"`extern mod` is obsolete, use \\\n                                           `extern crate` instead \\\n                                           to refer to external \\\n@@ -4736,8 +4769,9 @@ impl<'a> Parser<'a> {\n                 let abi = opt_abi.unwrap_or(abi::C);\n                 let (ident, item_, extra_attrs) =\n                     self.parse_item_fn(NormalFn, abi);\n+                let last_span = self.last_span;\n                 let item = self.mk_item(lo,\n-                                        self.last_span.hi,\n+                                        last_span.hi,\n                                         ident,\n                                         item_,\n                                         visibility,\n@@ -4747,15 +4781,17 @@ impl<'a> Parser<'a> {\n                 return self.parse_item_foreign_mod(lo, opt_abi, visibility, attrs);\n             }\n \n+            let span = self.span;\n             let token_str = self.this_token_to_str();\n-            self.span_fatal(self.span,\n+            self.span_fatal(span,\n                             format!(\"expected `{}` or `fn` but found `{}`\", \"{\",\n                                     token_str).as_slice());\n         }\n \n         let is_virtual = self.eat_keyword(keywords::Virtual);\n         if is_virtual && !self.is_keyword(keywords::Struct) {\n-            self.span_err(self.span,\n+            let span = self.span;\n+            self.span_err(span,\n                           \"`virtual` keyword may only be used with `struct`\");\n         }\n \n@@ -4764,8 +4800,9 @@ impl<'a> Parser<'a> {\n             // STATIC ITEM\n             self.bump();\n             let (ident, item_, extra_attrs) = self.parse_item_const();\n+            let last_span = self.last_span;\n             let item = self.mk_item(lo,\n-                                    self.last_span.hi,\n+                                    last_span.hi,\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -4778,8 +4815,9 @@ impl<'a> Parser<'a> {\n             self.bump();\n             let (ident, item_, extra_attrs) =\n                 self.parse_item_fn(NormalFn, abi::Rust);\n+            let last_span = self.last_span;\n             let item = self.mk_item(lo,\n-                                    self.last_span.hi,\n+                                    last_span.hi,\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -4798,8 +4836,9 @@ impl<'a> Parser<'a> {\n             self.expect_keyword(keywords::Fn);\n             let (ident, item_, extra_attrs) =\n                 self.parse_item_fn(UnsafeFn, abi);\n+            let last_span = self.last_span;\n             let item = self.mk_item(lo,\n-                                    self.last_span.hi,\n+                                    last_span.hi,\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -4810,8 +4849,9 @@ impl<'a> Parser<'a> {\n             // MODULE ITEM\n             let (ident, item_, extra_attrs) =\n                 self.parse_item_mod(attrs.as_slice());\n+            let last_span = self.last_span;\n             let item = self.mk_item(lo,\n-                                    self.last_span.hi,\n+                                    last_span.hi,\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -4821,8 +4861,9 @@ impl<'a> Parser<'a> {\n         if self.eat_keyword(keywords::Type) {\n             // TYPE ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_type();\n+            let last_span = self.last_span;\n             let item = self.mk_item(lo,\n-                                    self.last_span.hi,\n+                                    last_span.hi,\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -4832,8 +4873,9 @@ impl<'a> Parser<'a> {\n         if self.eat_keyword(keywords::Enum) {\n             // ENUM ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_enum();\n+            let last_span = self.last_span;\n             let item = self.mk_item(lo,\n-                                    self.last_span.hi,\n+                                    last_span.hi,\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -4843,8 +4885,9 @@ impl<'a> Parser<'a> {\n         if self.eat_keyword(keywords::Trait) {\n             // TRAIT ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_trait();\n+            let last_span = self.last_span;\n             let item = self.mk_item(lo,\n-                                    self.last_span.hi,\n+                                    last_span.hi,\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -4854,8 +4897,9 @@ impl<'a> Parser<'a> {\n         if self.eat_keyword(keywords::Impl) {\n             // IMPL ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_impl();\n+            let last_span = self.last_span;\n             let item = self.mk_item(lo,\n-                                    self.last_span.hi,\n+                                    last_span.hi,\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -4865,8 +4909,9 @@ impl<'a> Parser<'a> {\n         if self.eat_keyword(keywords::Struct) {\n             // STRUCT ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_struct(is_virtual);\n+            let last_span = self.last_span;\n             let item = self.mk_item(lo,\n-                                    self.last_span.hi,\n+                                    last_span.hi,\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -4942,8 +4987,9 @@ impl<'a> Parser<'a> {\n                                              span: mk_sp(self.span.lo,\n                                                          self.span.hi) };\n             let item_ = ItemMac(m);\n+            let last_span = self.last_span;\n             let item = self.mk_item(lo,\n-                                    self.last_span.hi,\n+                                    last_span.hi,\n                                     id,\n                                     item_,\n                                     visibility,\n@@ -4960,7 +5006,8 @@ impl<'a> Parser<'a> {\n                 s.push_str(\"priv\")\n             }\n             s.push_char('`');\n-            self.span_fatal(self.last_span, s.as_slice());\n+            let last_span = self.last_span;\n+            self.span_fatal(last_span, s.as_slice());\n         }\n         return IoviNone(attrs);\n     }"}, {"sha": "672e08af2d8ff74dbfc411c5b7bdde7e076ccb17", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/18c451fc497a23944b7b759cca5ff0b0be1122fd/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c451fc497a23944b7b759cca5ff0b0be1122fd/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=18c451fc497a23944b7b759cca5ff0b0be1122fd", "patch": "@@ -322,7 +322,8 @@ impl Printer {\n                    b.offset, self.left, self.right);\n             *self.token.get_mut(self.right) = t;\n             *self.size.get_mut(self.right) = -self.right_total;\n-            self.scan_push(self.right);\n+            let right = self.right;\n+            self.scan_push(right);\n             Ok(())\n           }\n           End => {\n@@ -334,7 +335,8 @@ impl Printer {\n                 self.advance_right();\n                 *self.token.get_mut(self.right) = t;\n                 *self.size.get_mut(self.right) = -1;\n-                self.scan_push(self.right);\n+                let right = self.right;\n+                self.scan_push(right);\n                 Ok(())\n             }\n           }\n@@ -348,7 +350,8 @@ impl Printer {\n             debug!(\"pp Break({})/buffer ~[{},{}]\",\n                    b.offset, self.left, self.right);\n             self.check_stack(0);\n-            self.scan_push(self.right);\n+            let right = self.right;\n+            self.scan_push(right);\n             *self.token.get_mut(self.right) = t;\n             *self.size.get_mut(self.right) = -self.right_total;\n             self.right_total += b.blank_space;"}, {"sha": "b49c698486450e68586e67e28f45f38b4884ad70", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/18c451fc497a23944b7b759cca5ff0b0be1122fd/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c451fc497a23944b7b759cca5ff0b0be1122fd/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=18c451fc497a23944b7b759cca5ff0b0be1122fd", "patch": "@@ -347,7 +347,8 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                         let res = format(stack.pop().unwrap(), FormatOp::from_char(cur), *flags);\n                         if res.is_err() { return res }\n                         output.push_all(res.unwrap().as_slice());\n-                        old_state = state; // will cause state to go to Nothing\n+                        // will cause state to go to Nothing\n+                        old_state = FormatPattern(*flags, *fstate);\n                     } else { return Err(\"stack is empty\".to_string()) },\n                     (FormatStateFlags,'#') => {\n                         flags.alternate = true;"}, {"sha": "72042b8373d84c2565e2e12daf150130ffd59601", "filename": "src/test/compile-fail/borrowck-field-sensitivity.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/18c451fc497a23944b7b759cca5ff0b0be1122fd/src%2Ftest%2Fcompile-fail%2Fborrowck-field-sensitivity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c451fc497a23944b7b759cca5ff0b0be1122fd/src%2Ftest%2Fcompile-fail%2Fborrowck-field-sensitivity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-field-sensitivity.rs?ref=18c451fc497a23944b7b759cca5ff0b0be1122fd", "patch": "@@ -84,20 +84,6 @@ fn fu_move_after_fu_move() {\n \n // The following functions aren't yet accepted, but they should be.\n \n-fn move_after_borrow_correct() {\n-    let x = A { a: 1, b: box 2 };\n-    let p = &x.a;\n-    drop(x.b); //~ ERROR cannot move out of `x.b` because it is borrowed\n-    drop(*p);\n-}\n-\n-fn fu_move_after_borrow_correct() {\n-    let x = A { a: 1, b: box 2 };\n-    let p = &x.a;\n-    let _y = A { a: 3, .. x }; //~ ERROR cannot move out of `x.b` because it is borrowed\n-    drop(*p);\n-}\n-\n fn copy_after_field_assign_after_uninit() {\n     let mut x: A;\n     x.a = 1;\n@@ -132,9 +118,6 @@ fn main() {\n     fu_move_after_move();\n     fu_move_after_fu_move();\n \n-    move_after_borrow_correct();\n-    fu_move_after_borrow_correct();\n-\n     copy_after_field_assign_after_uninit();\n     borrow_after_field_assign_after_uninit();\n     move_after_field_assign_after_uninit();"}, {"sha": "7414bb930d4d6e87b497f719cd6928fb1ee08861", "filename": "src/test/compile-fail/borrowck-use-mut-borrow.rs", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/18c451fc497a23944b7b759cca5ff0b0be1122fd/src%2Ftest%2Fcompile-fail%2Fborrowck-use-mut-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c451fc497a23944b7b759cca5ff0b0be1122fd/src%2Ftest%2Fcompile-fail%2Fborrowck-use-mut-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-use-mut-borrow.rs?ref=18c451fc497a23944b7b759cca5ff0b0be1122fd", "patch": "@@ -0,0 +1,93 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct A { a: int, b: int }\n+struct B { a: int, b: Box<int> }\n+\n+fn var_copy_after_var_borrow() {\n+    let mut x: int = 1;\n+    let p = &mut x;\n+    drop(x); //~ ERROR cannot use `x` because it was mutably borrowed\n+    *p = 2;\n+}\n+\n+fn var_copy_after_field_borrow() {\n+    let mut x = A { a: 1, b: 2 };\n+    let p = &mut x.a;\n+    drop(x); //~ ERROR cannot use `x` because it was mutably borrowed\n+    *p = 3;\n+}\n+\n+fn field_copy_after_var_borrow() {\n+    let mut x = A { a: 1, b: 2 };\n+    let p = &mut x;\n+    drop(x.a); //~ ERROR cannot use `x.a` because it was mutably borrowed\n+    p.a = 3;\n+}\n+\n+fn field_copy_after_field_borrow() {\n+    let mut x = A { a: 1, b: 2 };\n+    let p = &mut x.a;\n+    drop(x.a); //~ ERROR cannot use `x.a` because it was mutably borrowed\n+    *p = 3;\n+}\n+\n+fn fu_field_copy_after_var_borrow() {\n+    let mut x = A { a: 1, b: 2 };\n+    let p = &mut x;\n+    let y = A { b: 3, .. x }; //~ ERROR cannot use `x.a` because it was mutably borrowed\n+    drop(y);\n+    p.a = 4;\n+}\n+\n+fn fu_field_copy_after_field_borrow() {\n+    let mut x = A { a: 1, b: 2 };\n+    let p = &mut x.a;\n+    let y = A { b: 3, .. x }; //~ ERROR cannot use `x.a` because it was mutably borrowed\n+    drop(y);\n+    *p = 4;\n+}\n+\n+fn var_deref_after_var_borrow() {\n+    let mut x: Box<int> = box 1;\n+    let p = &mut x;\n+    drop(*x); //~ ERROR cannot use `*x` because it was mutably borrowed\n+    **p = 2;\n+}\n+\n+fn field_deref_after_var_borrow() {\n+    let mut x = B { a: 1, b: box 2 };\n+    let p = &mut x;\n+    drop(*x.b); //~ ERROR cannot use `*x.b` because it was mutably borrowed\n+    p.a = 3;\n+}\n+\n+fn field_deref_after_field_borrow() {\n+    let mut x = B { a: 1, b: box 2 };\n+    let p = &mut x.b;\n+    drop(*x.b); //~ ERROR cannot use `*x.b` because it was mutably borrowed\n+    **p = 3;\n+}\n+\n+fn main() {\n+    var_copy_after_var_borrow();\n+    var_copy_after_field_borrow();\n+\n+    field_copy_after_var_borrow();\n+    field_copy_after_field_borrow();\n+\n+    fu_field_copy_after_var_borrow();\n+    fu_field_copy_after_field_borrow();\n+\n+    var_deref_after_var_borrow();\n+    field_deref_after_var_borrow();\n+    field_deref_after_field_borrow();\n+}\n+"}, {"sha": "ff029ce624c9be24c3adc97764d05397382ade40", "filename": "src/test/compile-fail/borrowck-vec-pattern-loan-from-mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18c451fc497a23944b7b759cca5ff0b0be1122fd/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-loan-from-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c451fc497a23944b7b759cca5ff0b0be1122fd/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-loan-from-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-loan-from-mut.rs?ref=18c451fc497a23944b7b759cca5ff0b0be1122fd", "patch": "@@ -12,7 +12,7 @@ fn a() {\n     let mut v = vec!(1, 2, 3);\n     let vb: &mut [int] = v.as_mut_slice();\n     match vb {\n-        [_a, ..tail] => {\n+        [_a, ..tail] => { //~ ERROR cannot use `vb[..]` because it was mutably borrowed\n             v.push(tail[0] + tail[1]); //~ ERROR cannot borrow\n         }\n         _ => {}"}, {"sha": "89350f16167603f3b9ae01c8409623e2f405feea", "filename": "src/test/compile-fail/regions-escape-loop-via-vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/18c451fc497a23944b7b759cca5ff0b0be1122fd/src%2Ftest%2Fcompile-fail%2Fregions-escape-loop-via-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c451fc497a23944b7b759cca5ff0b0be1122fd/src%2Ftest%2Fcompile-fail%2Fregions-escape-loop-via-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-escape-loop-via-vec.rs?ref=18c451fc497a23944b7b759cca5ff0b0be1122fd", "patch": "@@ -12,8 +12,8 @@\n fn broken() {\n     let mut x = 3;\n     let mut _y = vec!(&mut x);\n-    while x < 10 {\n-        let mut z = x;\n+    while x < 10 { //~ ERROR cannot use `x` because it was mutably borrowed\n+        let mut z = x; //~ ERROR cannot use `x` because it was mutably borrowed\n         _y.push(&mut z); //~ ERROR `z` does not live long enough\n         x += 1; //~ ERROR cannot assign\n     }"}, {"sha": "33be47e504be2a06c6624d9d00b8a3e3990ee450", "filename": "src/test/run-pass/borrowck-field-sensitivity.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/18c451fc497a23944b7b759cca5ff0b0be1122fd/src%2Ftest%2Frun-pass%2Fborrowck-field-sensitivity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c451fc497a23944b7b759cca5ff0b0be1122fd/src%2Ftest%2Frun-pass%2Fborrowck-field-sensitivity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-field-sensitivity.rs?ref=18c451fc497a23944b7b759cca5ff0b0be1122fd", "patch": "@@ -73,6 +73,20 @@ fn borrow_after_fu_move() {\n     drop(*p);\n }\n \n+fn move_after_borrow() {\n+    let x = A { a: 1, b: box 2 };\n+    let p = &x.a;\n+    drop(x.b);\n+    drop(*p);\n+}\n+\n+fn fu_move_after_borrow() {\n+    let x = A { a: 1, b: box 2 };\n+    let p = &x.a;\n+    let _y = A { a: 3, .. x };\n+    drop(*p);\n+}\n+\n fn mut_borrow_after_mut_borrow() {\n     let mut x = A { a: 1, b: box 2 };\n     let p = &mut x.a;\n@@ -225,6 +239,8 @@ fn main() {\n \n     borrow_after_move();\n     borrow_after_fu_move();\n+    move_after_borrow();\n+    fu_move_after_borrow();\n     mut_borrow_after_mut_borrow();\n \n     move_after_move();"}, {"sha": "cbfdd5961ffacc650d40dc7190e350d87ff702bf", "filename": "src/test/run-pass/borrowck-use-mut-borrow.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/18c451fc497a23944b7b759cca5ff0b0be1122fd/src%2Ftest%2Frun-pass%2Fborrowck-use-mut-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c451fc497a23944b7b759cca5ff0b0be1122fd/src%2Ftest%2Frun-pass%2Fborrowck-use-mut-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-use-mut-borrow.rs?ref=18c451fc497a23944b7b759cca5ff0b0be1122fd", "patch": "@@ -0,0 +1,57 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct A { a: int, b: Box<int> }\n+\n+fn field_copy_after_field_borrow() {\n+    let mut x = A { a: 1, b: box 2 };\n+    let p = &mut x.b;\n+    drop(x.a);\n+    **p = 3;\n+}\n+\n+fn fu_field_copy_after_field_borrow() {\n+    let mut x = A { a: 1, b: box 2 };\n+    let p = &mut x.b;\n+    let y = A { b: box 3, .. x };\n+    drop(y);\n+    **p = 4;\n+}\n+\n+fn field_deref_after_field_borrow() {\n+    let mut x = A { a: 1, b: box 2 };\n+    let p = &mut x.a;\n+    drop(*x.b);\n+    *p = 3;\n+}\n+\n+fn field_move_after_field_borrow() {\n+    let mut x = A { a: 1, b: box 2 };\n+    let p = &mut x.a;\n+    drop(x.b);\n+    *p = 3;\n+}\n+\n+fn fu_field_move_after_field_borrow() {\n+    let mut x = A { a: 1, b: box 2 };\n+    let p = &mut x.a;\n+    let y = A { a: 3, .. x };\n+    drop(y);\n+    *p = 4;\n+}\n+\n+fn main() {\n+    field_copy_after_field_borrow();\n+    fu_field_copy_after_field_borrow();\n+    field_deref_after_field_borrow();\n+    field_move_after_field_borrow();\n+    fu_field_move_after_field_borrow();\n+}\n+"}]}