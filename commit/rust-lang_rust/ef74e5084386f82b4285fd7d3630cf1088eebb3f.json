{"sha": "ef74e5084386f82b4285fd7d3630cf1088eebb3f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmNzRlNTA4NDM4NmY4MmI0Mjg1ZmQ3ZDM2MzBjZjEwODhlZWJiM2Y=", "commit": {"author": {"name": "Neutron3529", "email": "qweytr_1@163.com", "date": "2020-07-15T14:39:39Z"}, "committer": {"name": "Neutron3529", "email": "qweytr1@mail.ustc.edu.cn", "date": "2020-07-23T06:55:15Z"}, "message": "Rearrange the pipeline of `pow` to gain efficiency\n\nThe check of the `exp` parameter seems useless if we execute the while-loop more than once.\nThe original implementation of `pow` function using one more comparison if the `exp==0` and may break the pipeline of the cpu, which may generate a slower code.\nThe performance gap between the old and the new implementation may be small, but IMO, at least the newer one looks more beautiful.\n\n---\n\nbench prog:\n```\nextern crate test;\n($a:expr)=>{let time=std::time::Instant::now();{$a;}print!(\"{:?} \",time.elapsed())};\n($a:expr,$b:literal)=>{let time=std::time::Instant::now();let mut a=0;for _ in 0..$b{a^=$a;}print!(\"{:?} {} \",time.elapsed(),a)}\n}\npub fn pow_rust(x:i64, mut exp: u32) -> i64 {\n    let mut base = x;\n    let mut acc = 1;\n    while exp > 1 {\n        if (exp & 1) == 1 {\n            acc = acc * base;\n        }\n        exp /= 2;\n        base = base * base;\n    }\n    if exp == 1 {\n        acc = acc * base;\n    }\n    acc\n}\npub fn pow_new(x:i64, mut exp: u32) -> i64 {\n    if exp==0{\n        1\n    }else{\n        let mut base = x;\n        let mut acc = 1;\n        while exp > 1 {\n            if (exp & 1) == 1 {\n                acc = acc * base;\n            }\n            exp >>= 1;\n            base = base * base;\n        }\n        acc * base\n    }\n}\n\nfn main(){\nlet a=2i64;\nlet b=1_u32;\nprintln!();\ntiming!(test::black_box(a).pow(test::black_box(b)),100000000);\ntiming!(pow_new(test::black_box(a),test::black_box(b)),100000000);\ntiming!(pow_rust(test::black_box(a),test::black_box(b)),100000000);\nprintln!();\ntiming!(test::black_box(a).pow(test::black_box(b)),100000000);\ntiming!(pow_new(test::black_box(a),test::black_box(b)),100000000);\ntiming!(pow_rust(test::black_box(a),test::black_box(b)),100000000);\nprintln!();\ntiming!(test::black_box(a).pow(test::black_box(b)),100000000);\ntiming!(pow_new(test::black_box(a),test::black_box(b)),100000000);\ntiming!(pow_rust(test::black_box(a),test::black_box(b)),100000000);\nprintln!();\ntiming!(test::black_box(a).pow(test::black_box(b)),100000000);\ntiming!(pow_new(test::black_box(a),test::black_box(b)),100000000);\ntiming!(pow_rust(test::black_box(a),test::black_box(b)),100000000);\nprintln!();\ntiming!(test::black_box(a).pow(test::black_box(b)),100000000);\ntiming!(pow_new(test::black_box(a),test::black_box(b)),100000000);\ntiming!(pow_rust(test::black_box(a),test::black_box(b)),100000000);\nprintln!();\ntiming!(test::black_box(a).pow(test::black_box(b)),100000000);\ntiming!(pow_new(test::black_box(a),test::black_box(b)),100000000);\ntiming!(pow_rust(test::black_box(a),test::black_box(b)),100000000);\nprintln!();\ntiming!(test::black_box(a).pow(test::black_box(b)),100000000);\ntiming!(pow_new(test::black_box(a),test::black_box(b)),100000000);\ntiming!(pow_rust(test::black_box(a),test::black_box(b)),100000000);\nprintln!();\ntiming!(test::black_box(a).pow(test::black_box(b)),100000000);\ntiming!(pow_new(test::black_box(a),test::black_box(b)),100000000);\ntiming!(pow_rust(test::black_box(a),test::black_box(b)),100000000);\nprintln!();\n}\n```\nbench in my laptop:\n```\nneutron@Neutron:/me/rust$ rc commit.rs\nrustc commit.rs  && ./commit\n\n3.978419716s 0 4.079765171s 0 3.964630622s 0\n3.997127013s 0 4.260304804s 0 3.997638211s 0\n3.963195544s 0 4.11657718s 0 4.176054164s 0\n3.830128579s 0 3.980396122s 0 3.937258567s 0\n3.986055948s 0 4.127804162s 0 4.018943411s 0\n4.185568857s 0 4.217512517s 0 3.98313603s 0\n3.863018225s 0 4.030447988s 0 3.694878237s 0\n4.206987927s 0 4.137608047s 0 4.115564664s 0\nneutron@Neutron:/me/rust$ rc commit.rs -O\nrustc commit.rs -O && ./commit\n\n162.111993ms 0 165.107125ms 0 166.26924ms 0\n175.20479ms 0 205.062565ms 0 176.278791ms 0\n174.408975ms 0 166.526899ms 0 201.857604ms 0\n146.190062ms 0 168.592821ms 0 154.61411ms 0\n199.678912ms 0 168.411598ms 0 162.129996ms 0\n147.420765ms 0 209.759326ms 0 154.807907ms 0\n165.507134ms 0 188.476239ms 0 157.351524ms 0\n121.320123ms 0 126.401229ms 0 114.86428ms 0\n```\n\ndelete an unnecessary semicolon...\n\nSorry for the typo.\n\ndelete trailing whitespace\n\nSorry, too..\n\nSorry for the missing...\n\nI checked all the implementations, and finally found that there is one function that does not check whether `exp == 0`\n\nadd extra tests\n\nadd extra tests.\n\nfinished adding the extra tests to prevent further typo\n\nadd pow(2) to negative exp\n\nadd whitespace.\n\nadd whitespace\n\nadd whitespace\n\ndelete extra line", "tree": {"sha": "1ee3a8fc994e225047a35fda5fd06d708462b205", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ee3a8fc994e225047a35fda5fd06d708462b205"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef74e5084386f82b4285fd7d3630cf1088eebb3f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef74e5084386f82b4285fd7d3630cf1088eebb3f", "html_url": "https://github.com/rust-lang/rust/commit/ef74e5084386f82b4285fd7d3630cf1088eebb3f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef74e5084386f82b4285fd7d3630cf1088eebb3f/comments", "author": {"login": "Neutron3529", "id": 26130174, "node_id": "MDQ6VXNlcjI2MTMwMTc0", "avatar_url": "https://avatars.githubusercontent.com/u/26130174?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Neutron3529", "html_url": "https://github.com/Neutron3529", "followers_url": "https://api.github.com/users/Neutron3529/followers", "following_url": "https://api.github.com/users/Neutron3529/following{/other_user}", "gists_url": "https://api.github.com/users/Neutron3529/gists{/gist_id}", "starred_url": "https://api.github.com/users/Neutron3529/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Neutron3529/subscriptions", "organizations_url": "https://api.github.com/users/Neutron3529/orgs", "repos_url": "https://api.github.com/users/Neutron3529/repos", "events_url": "https://api.github.com/users/Neutron3529/events{/privacy}", "received_events_url": "https://api.github.com/users/Neutron3529/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c714eae0e3b4ba263c193d54f6e46bb9a1feb2cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/c714eae0e3b4ba263c193d54f6e46bb9a1feb2cc", "html_url": "https://github.com/rust-lang/rust/commit/c714eae0e3b4ba263c193d54f6e46bb9a1feb2cc"}], "stats": {"total": 145, "additions": 101, "deletions": 44}, "files": [{"sha": "c576465c622fea9747c609e0c3fbfeaf06bfde67", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 44, "deletions": 43, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/ef74e5084386f82b4285fd7d3630cf1088eebb3f/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef74e5084386f82b4285fd7d3630cf1088eebb3f/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=ef74e5084386f82b4285fd7d3630cf1088eebb3f", "patch": "@@ -1103,6 +1103,9 @@ $EndFeature, \"\n                           without modifying the original\"]\n             #[inline]\n             pub const fn checked_pow(self, mut exp: u32) -> Option<Self> {\n+                if exp == 0 {\n+                    return Some(1);\n+                }\n                 let mut base = self;\n                 let mut acc: Self = 1;\n \n@@ -1113,15 +1116,11 @@ $EndFeature, \"\n                     exp /= 2;\n                     base = try_opt!(base.checked_mul(base));\n                 }\n-\n+                // since exp!=0, finally the exp must be 1.\n                 // Deal with the final bit of the exponent separately, since\n                 // squaring the base afterwards is not necessary and may cause a\n                 // needless overflow.\n-                if exp == 1 {\n-                    acc = try_opt!(acc.checked_mul(base));\n-                }\n-\n-                Some(acc)\n+                Some(try_opt!(acc.checked_mul(base)))\n             }\n         }\n \n@@ -1631,6 +1630,9 @@ $EndFeature, \"\n                           without modifying the original\"]\n             #[inline]\n             pub const fn wrapping_pow(self, mut exp: u32) -> Self {\n+                if exp == 0 {\n+                    return 1;\n+                }\n                 let mut base = self;\n                 let mut acc: Self = 1;\n \n@@ -1642,14 +1644,11 @@ $EndFeature, \"\n                     base = base.wrapping_mul(base);\n                 }\n \n+                // since exp!=0, finally the exp must be 1.\n                 // Deal with the final bit of the exponent separately, since\n                 // squaring the base afterwards is not necessary and may cause a\n                 // needless overflow.\n-                if exp == 1 {\n-                    acc = acc.wrapping_mul(base);\n-                }\n-\n-                acc\n+                acc.wrapping_mul(base)\n             }\n         }\n \n@@ -1999,6 +1998,9 @@ $EndFeature, \"\n                           without modifying the original\"]\n             #[inline]\n             pub const fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {\n+                if exp == 0 {\n+                    return (1,false);\n+                }\n                 let mut base = self;\n                 let mut acc: Self = 1;\n                 let mut overflown = false;\n@@ -2017,16 +2019,13 @@ $EndFeature, \"\n                     overflown |= r.1;\n                 }\n \n+                // since exp!=0, finally the exp must be 1.\n                 // Deal with the final bit of the exponent separately, since\n                 // squaring the base afterwards is not necessary and may cause a\n                 // needless overflow.\n-                if exp == 1 {\n-                    r = acc.overflowing_mul(base);\n-                    acc = r.0;\n-                    overflown |= r.1;\n-                }\n-\n-                (acc, overflown)\n+                r = acc.overflowing_mul(base);\n+                r.1 |= overflown;\n+                r\n             }\n         }\n \n@@ -2050,6 +2049,9 @@ $EndFeature, \"\n             #[inline]\n             #[rustc_inherit_overflow_checks]\n             pub const fn pow(self, mut exp: u32) -> Self {\n+                if exp == 0 {\n+                    return 1;\n+                }\n                 let mut base = self;\n                 let mut acc = 1;\n \n@@ -2061,14 +2063,11 @@ $EndFeature, \"\n                     base = base * base;\n                 }\n \n+                // since exp!=0, finally the exp must be 1.\n                 // Deal with the final bit of the exponent separately, since\n                 // squaring the base afterwards is not necessary and may cause a\n                 // needless overflow.\n-                if exp == 1 {\n-                    acc = acc * base;\n-                }\n-\n-                acc\n+                acc * base\n             }\n         }\n \n@@ -3306,6 +3305,9 @@ assert_eq!(\", stringify!($SelfT), \"::MAX.checked_pow(2), None);\", $EndFeature, \"\n                           without modifying the original\"]\n             #[inline]\n             pub const fn checked_pow(self, mut exp: u32) -> Option<Self> {\n+                if exp == 0 {\n+                    return Some(1);\n+                }\n                 let mut base = self;\n                 let mut acc: Self = 1;\n \n@@ -3317,14 +3319,12 @@ assert_eq!(\", stringify!($SelfT), \"::MAX.checked_pow(2), None);\", $EndFeature, \"\n                     base = try_opt!(base.checked_mul(base));\n                 }\n \n+                // since exp!=0, finally the exp must be 1.\n                 // Deal with the final bit of the exponent separately, since\n                 // squaring the base afterwards is not necessary and may cause a\n                 // needless overflow.\n-                if exp == 1 {\n-                    acc = try_opt!(acc.checked_mul(base));\n-                }\n \n-                Some(acc)\n+                Some(try_opt!(acc.checked_mul(base)))\n             }\n         }\n \n@@ -3715,6 +3715,9 @@ assert_eq!(3u8.wrapping_pow(6), 217);\", $EndFeature, \"\n                           without modifying the original\"]\n             #[inline]\n             pub const fn wrapping_pow(self, mut exp: u32) -> Self {\n+                if exp == 0 {\n+                    return 1;\n+                }\n                 let mut base = self;\n                 let mut acc: Self = 1;\n \n@@ -3726,14 +3729,11 @@ assert_eq!(3u8.wrapping_pow(6), 217);\", $EndFeature, \"\n                     base = base.wrapping_mul(base);\n                 }\n \n+                // since exp!=0, finally the exp must be 1.\n                 // Deal with the final bit of the exponent separately, since\n                 // squaring the base afterwards is not necessary and may cause a\n                 // needless overflow.\n-                if exp == 1 {\n-                    acc = acc.wrapping_mul(base);\n-                }\n-\n-                acc\n+                acc.wrapping_mul(base)\n             }\n         }\n \n@@ -4040,6 +4040,9 @@ assert_eq!(3u8.overflowing_pow(6), (217, true));\", $EndFeature, \"\n                           without modifying the original\"]\n             #[inline]\n             pub const fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {\n+                if exp == 0{\n+                    return (1,false);\n+                }\n                 let mut base = self;\n                 let mut acc: Self = 1;\n                 let mut overflown = false;\n@@ -4058,16 +4061,14 @@ assert_eq!(3u8.overflowing_pow(6), (217, true));\", $EndFeature, \"\n                     overflown |= r.1;\n                 }\n \n+                // since exp!=0, finally the exp must be 1.\n                 // Deal with the final bit of the exponent separately, since\n                 // squaring the base afterwards is not necessary and may cause a\n                 // needless overflow.\n-                if exp == 1 {\n-                    r = acc.overflowing_mul(base);\n-                    acc = r.0;\n-                    overflown |= r.1;\n-                }\n+                r = acc.overflowing_mul(base);\n+                r.1 |= overflown;\n \n-                (acc, overflown)\n+                r\n             }\n         }\n \n@@ -4088,6 +4089,9 @@ Basic usage:\n         #[inline]\n         #[rustc_inherit_overflow_checks]\n         pub const fn pow(self, mut exp: u32) -> Self {\n+            if exp == 0 {\n+                return 1;\n+            }\n             let mut base = self;\n             let mut acc = 1;\n \n@@ -4099,14 +4103,11 @@ Basic usage:\n                 base = base * base;\n             }\n \n+            // since exp!=0, finally the exp must be 1.\n             // Deal with the final bit of the exponent separately, since\n             // squaring the base afterwards is not necessary and may cause a\n             // needless overflow.\n-            if exp == 1 {\n-                acc = acc * base;\n-            }\n-\n-            acc\n+            acc * base\n         }\n     }\n "}, {"sha": "58a585669122ca3b7859cf19b9bef7525354d705", "filename": "src/libcore/tests/num/int_macros.rs", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ef74e5084386f82b4285fd7d3630cf1088eebb3f/src%2Flibcore%2Ftests%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef74e5084386f82b4285fd7d3630cf1088eebb3f/src%2Flibcore%2Ftests%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fint_macros.rs?ref=ef74e5084386f82b4285fd7d3630cf1088eebb3f", "patch": "@@ -255,12 +255,43 @@ macro_rules! int_module {\n             #[test]\n             fn test_pow() {\n                 let mut r = 2 as $T;\n-\n                 assert_eq!(r.pow(2), 4 as $T);\n                 assert_eq!(r.pow(0), 1 as $T);\n+                assert_eq!(r.wrapping_pow(2), 4 as $T);\n+                assert_eq!(r.wrapping_pow(0), 1 as $T);\n+                assert_eq!(r.checked_pow(2), Some(4 as $T));\n+                assert_eq!(r.checked_pow(0), Some(1 as $T));\n+                assert_eq!(r.overflowing_pow(2), (4 as $T, false));\n+                assert_eq!(r.overflowing_pow(0), (1 as $T, false));\n+                assert_eq!(r.saturating_pow(2), 4 as $T);\n+                assert_eq!(r.saturating_pow(0), 1 as $T);\n+\n+                r = MAX;\n+                // use `^` to represent .pow() with no overflow.\n+                // if itest::MAX == 2^j-1, then itest is a `j` bit int,\n+                // so that `itest::MAX*itest::MAX == 2^(2*j)-2^(j+1)+1`,\n+                // thussaturating_pow the overflowing result is exactly 1.\n+                assert_eq!(r.wrapping_pow(2), 1 as $T);\n+                assert_eq!(r.checked_pow(2), None);\n+                assert_eq!(r.overflowing_pow(2), (1 as $T, true));\n+                assert_eq!(r.saturating_pow(2), MAX);\n+                //test for negative exponent.\n                 r = -2 as $T;\n                 assert_eq!(r.pow(2), 4 as $T);\n                 assert_eq!(r.pow(3), -8 as $T);\n+                assert_eq!(r.pow(0), 1 as $T);\n+                assert_eq!(r.wrapping_pow(2), 4 as $T);\n+                assert_eq!(r.wrapping_pow(3), -8 as $T);\n+                assert_eq!(r.wrapping_pow(0), 1 as $T);\n+                assert_eq!(r.checked_pow(2), Some(4 as $T));\n+                assert_eq!(r.checked_pow(3), Some(-8 as $T));\n+                assert_eq!(r.checked_pow(0), Some(1 as $T));\n+                assert_eq!(r.overflowing_pow(2), (4 as $T, false));\n+                assert_eq!(r.overflowing_pow(3), (-8 as $T, false));\n+                assert_eq!(r.overflowing_pow(0), (1 as $T, false));\n+                assert_eq!(r.saturating_pow(2), 4 as $T);\n+                assert_eq!(r.saturating_pow(3), -8 as $T);\n+                assert_eq!(r.saturating_pow(0), 1 as $T);\n             }\n         }\n     };"}, {"sha": "b84a8a7d9f88ba3aee84214cc61ac21f764e9a56", "filename": "src/libcore/tests/num/uint_macros.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ef74e5084386f82b4285fd7d3630cf1088eebb3f/src%2Flibcore%2Ftests%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef74e5084386f82b4285fd7d3630cf1088eebb3f/src%2Flibcore%2Ftests%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fuint_macros.rs?ref=ef74e5084386f82b4285fd7d3630cf1088eebb3f", "patch": "@@ -184,6 +184,31 @@ macro_rules! uint_module {\n                 assert_eq!($T::from_str_radix(\"Z\", 10).ok(), None::<$T>);\n                 assert_eq!($T::from_str_radix(\"_\", 2).ok(), None::<$T>);\n             }\n+\n+            #[test]\n+            fn test_pow() {\n+                let mut r = 2 as $T;\n+                assert_eq!(r.pow(2), 4 as $T);\n+                assert_eq!(r.pow(0), 1 as $T);\n+                assert_eq!(r.wrapping_pow(2), 4 as $T);\n+                assert_eq!(r.wrapping_pow(0), 1 as $T);\n+                assert_eq!(r.checked_pow(2), Some(4 as $T));\n+                assert_eq!(r.checked_pow(0), Some(1 as $T));\n+                assert_eq!(r.overflowing_pow(2), (4 as $T, false));\n+                assert_eq!(r.overflowing_pow(0), (1 as $T, false));\n+                assert_eq!(r.saturating_pow(2), 4 as $T);\n+                assert_eq!(r.saturating_pow(0), 1 as $T);\n+\n+                r = MAX;\n+                // use `^` to represent .pow() with no overflow.\n+                // if itest::MAX == 2^j-1, then itest is a `j` bit int,\n+                // so that `itest::MAX*itest::MAX == 2^(2*j)-2^(j+1)+1`,\n+                // thussaturating_pow the overflowing result is exactly 1.\n+                assert_eq!(r.wrapping_pow(2), 1 as $T);\n+                assert_eq!(r.checked_pow(2), None);\n+                assert_eq!(r.overflowing_pow(2), (1 as $T, true));\n+                assert_eq!(r.saturating_pow(2), MAX);\n+            }\n         }\n     };\n }"}]}