{"sha": "ddc54188fb6774ff1493aa896d9175e112d92cce", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkYzU0MTg4ZmI2Nzc0ZmYxNDkzYWE4OTZkOTE3NWUxMTJkOTJjY2U=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-05-02T04:03:06Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-05-22T02:15:29Z"}, "message": "Introduce AllocType which indicates what AllocIds point to", "tree": {"sha": "3cf2459af23a60258184a8d21d4d1c5976e950f6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3cf2459af23a60258184a8d21d4d1c5976e950f6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ddc54188fb6774ff1493aa896d9175e112d92cce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ddc54188fb6774ff1493aa896d9175e112d92cce", "html_url": "https://github.com/rust-lang/rust/commit/ddc54188fb6774ff1493aa896d9175e112d92cce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ddc54188fb6774ff1493aa896d9175e112d92cce/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "90167500cf68dd3d1e31eab4c0da44dc21493c89", "url": "https://api.github.com/repos/rust-lang/rust/commits/90167500cf68dd3d1e31eab4c0da44dc21493c89", "html_url": "https://github.com/rust-lang/rust/commit/90167500cf68dd3d1e31eab4c0da44dc21493c89"}], "stats": {"total": 535, "additions": 251, "deletions": 284}, "files": [{"sha": "8c4ff718aa6ee54cb880f649441d37a72a4f1913", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 19, "deletions": 31, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/ddc54188fb6774ff1493aa896d9175e112d92cce/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddc54188fb6774ff1493aa896d9175e112d92cce/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=ddc54188fb6774ff1493aa896d9175e112d92cce", "patch": "@@ -420,17 +420,6 @@ impl_stable_hash_for!(struct mir::interpret::MemoryPointer {\n     offset\n });\n \n-enum AllocDiscriminant {\n-    Alloc,\n-    Static,\n-    Function,\n-}\n-impl_stable_hash_for!(enum self::AllocDiscriminant {\n-    Alloc,\n-    Static,\n-    Function\n-});\n-\n impl<'a> HashStable<StableHashingContext<'a>> for mir::interpret::AllocId {\n     fn hash_stable<W: StableHasherResult>(\n         &self,\n@@ -440,30 +429,29 @@ impl<'a> HashStable<StableHashingContext<'a>> for mir::interpret::AllocId {\n         ty::tls::with_opt(|tcx| {\n             trace!(\"hashing {:?}\", *self);\n             let tcx = tcx.expect(\"can't hash AllocIds during hir lowering\");\n-            if let Some(def_id) = tcx.interpret_interner.get_static(*self) {\n-                AllocDiscriminant::Static.hash_stable(hcx, hasher);\n-                trace!(\"hashing {:?} as static {:?}\", *self, def_id);\n-                def_id.hash_stable(hcx, hasher);\n-            } else if let Some(alloc) = tcx.interpret_interner.get_alloc(*self) {\n-                AllocDiscriminant::Alloc.hash_stable(hcx, hasher);\n-                if hcx.alloc_id_recursion_tracker.insert(*self) {\n-                    trace!(\"hashing {:?} as alloc {:#?}\", *self, alloc);\n-                    alloc.hash_stable(hcx, hasher);\n-                    assert!(hcx.alloc_id_recursion_tracker.remove(self));\n-                } else {\n-                    trace!(\"skipping hashing of {:?} due to recursion\", *self);\n-                }\n-            } else if let Some(inst) = tcx.interpret_interner.get_fn(*self) {\n-                trace!(\"hashing {:?} as fn {:#?}\", *self, inst);\n-                AllocDiscriminant::Function.hash_stable(hcx, hasher);\n-                inst.hash_stable(hcx, hasher);\n-            } else {\n-                bug!(\"no allocation for {}\", self);\n-            }\n+            let alloc_kind = tcx.alloc_map.lock().get(*self).expect(\"no value for AllocId\");\n+            alloc_kind.hash_stable(hcx, hasher);\n         });\n     }\n }\n \n+impl<'a, 'gcx, M: HashStable<StableHashingContext<'a>>> HashStable<StableHashingContext<'a>>\n+for mir::interpret::AllocType<'gcx, M> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use mir::interpret::AllocType::*;\n+\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+\n+        match *self {\n+            Function(instance) => instance.hash_stable(hcx, hasher),\n+            Static(def_id) => def_id.hash_stable(hcx, hasher),\n+            Memory(ref mem) => mem.hash_stable(hcx, hasher),\n+        }\n+    }\n+}\n+\n impl<'a> HashStable<StableHashingContext<'a>> for mir::interpret::Allocation {\n     fn hash_stable<W: StableHasherResult>(\n         &self,"}, {"sha": "6f5401f54dc98a15941f279d68ded7045e91be89", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 119, "deletions": 22, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/ddc54188fb6774ff1493aa896d9175e112d92cce/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddc54188fb6774ff1493aa896d9175e112d92cce/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=ddc54188fb6774ff1493aa896d9175e112d92cce", "patch": "@@ -16,13 +16,15 @@ use std::collections::BTreeMap;\n use std::fmt;\n use mir;\n use hir::def_id::DefId;\n-use ty::{self, TyCtxt};\n+use ty::{self, TyCtxt, Instance};\n use ty::layout::{self, Align, HasDataLayout, Size};\n use middle::region;\n use std::iter;\n use std::io;\n+use std::hash::Hash;\n use syntax::ast::Mutability;\n use rustc_serialize::{Encoder, Decoder, Decodable, Encodable};\n+use rustc_data_structures::fx::FxHashMap;\n use byteorder::{WriteBytesExt, ReadBytesExt, LittleEndian, BigEndian};\n \n #[derive(Clone, Debug, PartialEq, RustcEncodable, RustcDecodable)]\n@@ -150,7 +152,7 @@ impl<'tcx> MemoryPointer {\n }\n \n \n-#[derive(Copy, Clone, Default, Eq, Hash, Ord, PartialEq, PartialOrd, Debug)]\n+#[derive(Copy, Clone, Eq, Hash, Ord, PartialEq, PartialOrd, Debug)]\n pub struct AllocId(pub u64);\n \n impl ::rustc_serialize::UseSpecializedEncodable for AllocId {}\n@@ -171,20 +173,25 @@ pub fn specialized_encode_alloc_id<\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     alloc_id: AllocId,\n ) -> Result<(), E::Error> {\n-    if let Some(alloc) = tcx.interpret_interner.get_alloc(alloc_id) {\n-        trace!(\"encoding {:?} with {:#?}\", alloc_id, alloc);\n-        AllocKind::Alloc.encode(encoder)?;\n-        alloc.encode(encoder)?;\n-    } else if let Some(fn_instance) = tcx.interpret_interner.get_fn(alloc_id) {\n-        trace!(\"encoding {:?} with {:#?}\", alloc_id, fn_instance);\n-        AllocKind::Fn.encode(encoder)?;\n-        fn_instance.encode(encoder)?;\n-    } else if let Some(did) = tcx.interpret_interner.get_static(alloc_id) {\n-        // referring to statics doesn't need to know about their allocations, just about its DefId\n-        AllocKind::Static.encode(encoder)?;\n-        did.encode(encoder)?;\n-    } else {\n-        bug!(\"alloc id without corresponding allocation: {}\", alloc_id);\n+    let alloc_type: AllocType<'tcx, &'tcx Allocation> =\n+        tcx.alloc_map.lock().get(alloc_id).expect(\"no value for AllocId\");\n+    match alloc_type {\n+        AllocType::Memory(alloc) => {\n+            trace!(\"encoding {:?} with {:#?}\", alloc_id, alloc);\n+            AllocKind::Alloc.encode(encoder)?;\n+            alloc.encode(encoder)?;\n+        }\n+        AllocType::Function(fn_instance) => {\n+            trace!(\"encoding {:?} with {:#?}\", alloc_id, fn_instance);\n+            AllocKind::Fn.encode(encoder)?;\n+            fn_instance.encode(encoder)?;\n+        }\n+        AllocType::Static(did) => {\n+            // referring to statics doesn't need to know about their allocations,\n+            // just about its DefId\n+            AllocKind::Static.encode(encoder)?;\n+            did.encode(encoder)?;\n+        }\n     }\n     Ok(())\n }\n@@ -200,31 +207,30 @@ pub fn specialized_decode_alloc_id<\n ) -> Result<AllocId, D::Error> {\n     match AllocKind::decode(decoder)? {\n         AllocKind::Alloc => {\n-            let alloc_id = tcx.interpret_interner.reserve();\n+            let alloc_id = tcx.alloc_map.lock().reserve();\n             trace!(\"creating alloc id {:?}\", alloc_id);\n             // insert early to allow recursive allocs\n             cache(decoder, alloc_id);\n \n-            let allocation = Allocation::decode(decoder)?;\n+            let allocation = <&'tcx Allocation as Decodable>::decode(decoder)?;\n             trace!(\"decoded alloc {:?} {:#?}\", alloc_id, allocation);\n-            let allocation = tcx.intern_const_alloc(allocation);\n-            tcx.interpret_interner.intern_at_reserved(alloc_id, allocation);\n+            tcx.alloc_map.lock().set_id_memory(alloc_id, allocation);\n \n             Ok(alloc_id)\n         },\n         AllocKind::Fn => {\n             trace!(\"creating fn alloc id\");\n             let instance = ty::Instance::decode(decoder)?;\n             trace!(\"decoded fn alloc instance: {:?}\", instance);\n-            let id = tcx.interpret_interner.create_fn_alloc(instance);\n+            let id = tcx.alloc_map.lock().create_fn_alloc(instance);\n             trace!(\"created fn alloc id: {:?}\", id);\n             cache(decoder, id);\n             Ok(id)\n         },\n         AllocKind::Static => {\n             trace!(\"creating extern static alloc id at\");\n             let did = DefId::decode(decoder)?;\n-            let alloc_id = tcx.interpret_interner.cache_static(did);\n+            let alloc_id = tcx.alloc_map.lock().intern_static(did);\n             cache(decoder, alloc_id);\n             Ok(alloc_id)\n         },\n@@ -237,6 +243,97 @@ impl fmt::Display for AllocId {\n     }\n }\n \n+#[derive(Debug, Clone, Eq, PartialEq, Hash, RustcDecodable, RustcEncodable)]\n+pub enum AllocType<'tcx, M> {\n+    /// The alloc id is used as a function pointer\n+    Function(Instance<'tcx>),\n+    /// The alloc id points to a static variable\n+    Static(DefId),\n+    /// The alloc id points to memory\n+    Memory(M)\n+}\n+\n+pub struct AllocMap<'tcx, M> {\n+    /// Lets you know what an AllocId refers to\n+    id_to_type: FxHashMap<AllocId, AllocType<'tcx, M>>,\n+\n+    /// Used to ensure that functions and statics only get one associated AllocId\n+    type_interner: FxHashMap<AllocType<'tcx, M>, AllocId>,\n+\n+    /// The AllocId to assign to the next requested id.\n+    /// Always incremented, never gets smaller.\n+    next_id: AllocId,\n+}\n+\n+impl<'tcx, M: fmt::Debug + Eq + Hash + Clone> AllocMap<'tcx, M> {\n+    pub fn new() -> Self {\n+        AllocMap {\n+            id_to_type: FxHashMap(),\n+            type_interner: FxHashMap(),\n+            next_id: AllocId(0),\n+        }\n+    }\n+\n+    /// obtains a new allocation ID that can be referenced but does not\n+    /// yet have an allocation backing it.\n+    pub fn reserve(\n+        &mut self,\n+    ) -> AllocId {\n+        let next = self.next_id;\n+        self.next_id.0 = self.next_id.0\n+            .checked_add(1)\n+            .expect(\"You overflowed a u64 by incrementing by 1... \\\n+                     You've just earned yourself a free drink if we ever meet. \\\n+                     Seriously, how did you do that?!\");\n+        next\n+    }\n+\n+    fn intern(&mut self, alloc_type: AllocType<'tcx, M>) -> AllocId {\n+        if let Some(&alloc_id) = self.type_interner.get(&alloc_type) {\n+            return alloc_id;\n+        }\n+        let id = self.reserve();\n+        debug!(\"creating alloc_type {:?} with id {}\", alloc_type, id);\n+        self.id_to_type.insert(id, alloc_type.clone());\n+        self.type_interner.insert(alloc_type, id);\n+        id\n+    }\n+\n+    // FIXME: Check if functions have identity. If not, we should not intern these,\n+    // but instead create a new id per use.\n+    // Alternatively we could just make comparing function pointers an error.\n+    pub fn create_fn_alloc(&mut self, instance: Instance<'tcx>) -> AllocId {\n+        self.intern(AllocType::Function(instance))\n+    }\n+\n+    pub fn get(&self, id: AllocId) -> Option<AllocType<'tcx, M>> {\n+        self.id_to_type.get(&id).cloned()\n+    }\n+\n+    pub fn unwrap_memory(&self, id: AllocId) -> M {\n+        match self.get(id) {\n+            Some(AllocType::Memory(mem)) => mem,\n+            _ => bug!(\"expected allocation id {} to point to memory\", id),\n+        }\n+    }\n+\n+    pub fn intern_static(&mut self, static_id: DefId) -> AllocId {\n+        self.intern(AllocType::Static(static_id))\n+    }\n+\n+    pub fn allocate(&mut self, mem: M) -> AllocId {\n+        let id = self.reserve();\n+        self.set_id_memory(id, mem);\n+        id\n+    }\n+\n+    pub fn set_id_memory(&mut self, id: AllocId, mem: M) {\n+        if let Some(old) = self.id_to_type.insert(id, AllocType::Memory(mem)) {\n+            bug!(\"tried to set allocation id {}, but it was already existing as {:#?}\", id, old);\n+        }\n+    }\n+}\n+\n #[derive(Clone, Debug, Eq, PartialEq, Hash, RustcEncodable, RustcDecodable)]\n pub struct Allocation {\n     /// The actual bytes of the allocation."}, {"sha": "66b08f5c3b00b536c52d98709eba7149d807a7a0", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ddc54188fb6774ff1493aa896d9175e112d92cce/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddc54188fb6774ff1493aa896d9175e112d92cce/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=ddc54188fb6774ff1493aa896d9175e112d92cce", "patch": "@@ -1908,17 +1908,15 @@ pub fn print_miri_value<W: Write>(value: Value, ty: Ty, f: &mut W) -> fmt::Resul\n         (Value::ByValPair(PrimVal::Ptr(ptr), PrimVal::Bytes(len)),\n          &TyRef(_, &ty::TyS { sty: TyStr, .. }, _)) => {\n             ty::tls::with(|tcx| {\n-                let alloc = tcx\n-                    .interpret_interner\n-                    .get_alloc(ptr.alloc_id);\n-                if let Some(alloc) = alloc {\n-                    assert_eq!(len as usize as u128, len);\n-                    let slice = &alloc.bytes[(ptr.offset.bytes() as usize)..][..(len as usize)];\n-                    let s = ::std::str::from_utf8(slice)\n-                        .expect(\"non utf8 str from miri\");\n-                    write!(f, \"{:?}\", s)\n-                } else {\n-                    write!(f, \"pointer to erroneous constant {:?}, {:?}\", ptr, len)\n+                match tcx.alloc_map.lock().get(ptr.alloc_id) {\n+                    Some(interpret::AllocType::Memory(alloc)) => {\n+                        assert_eq!(len as usize as u128, len);\n+                        let slice = &alloc.bytes[(ptr.offset.bytes() as usize)..][..(len as usize)];\n+                        let s = ::std::str::from_utf8(slice)\n+                            .expect(\"non utf8 str from miri\");\n+                        write!(f, \"{:?}\", s)\n+                    }\n+                    _ => write!(f, \"pointer to erroneous constant {:?}, {:?}\", ptr, len),\n                 }\n             })\n         },"}, {"sha": "82d796253bd8602aea47c9c54d5f530ef6e86699", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 3, "deletions": 112, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/ddc54188fb6774ff1493aa896d9175e112d92cce/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddc54188fb6774ff1493aa896d9175e112d92cce/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=ddc54188fb6774ff1493aa896d9175e112d92cce", "patch": "@@ -35,7 +35,6 @@ use mir::{self, Mir, interpret};\n use mir::interpret::Allocation;\n use ty::subst::{Kind, Substs, Subst};\n use ty::ReprOptions;\n-use ty::Instance;\n use traits;\n use traits::{Clause, Clauses, Goal, Goals};\n use ty::{self, Ty, TypeAndMut};\n@@ -918,7 +917,7 @@ pub struct GlobalCtxt<'tcx> {\n     /// Stores the value of constants (and deduplicates the actual memory)\n     allocation_interner: Lock<FxHashSet<&'tcx Allocation>>,\n \n-    pub interpret_interner: InterpretInterner<'tcx>,\n+    pub alloc_map: Lock<interpret::AllocMap<'tcx, &'tcx Allocation>>,\n \n     layout_interner: Lock<FxHashSet<&'tcx LayoutDetails>>,\n \n@@ -933,110 +932,6 @@ pub struct GlobalCtxt<'tcx> {\n     output_filenames: Arc<OutputFilenames>,\n }\n \n-/// Everything needed to efficiently work with interned allocations\n-#[derive(Debug, Default)]\n-pub struct InterpretInterner<'tcx> {\n-    inner: Lock<InterpretInternerInner<'tcx>>,\n-}\n-\n-#[derive(Debug, Default)]\n-struct InterpretInternerInner<'tcx> {\n-    /// Allows obtaining function instance handles via a unique identifier\n-    functions: FxHashMap<interpret::AllocId, Instance<'tcx>>,\n-\n-    /// Inverse map of `interpret_functions`.\n-    /// Used so we don't allocate a new pointer every time we need one\n-    function_cache: FxHashMap<Instance<'tcx>, interpret::AllocId>,\n-\n-    /// Allows obtaining const allocs via a unique identifier\n-    alloc_by_id: FxHashMap<interpret::AllocId, &'tcx interpret::Allocation>,\n-\n-    /// Allows obtaining static def ids via a unique id\n-    statics: FxHashMap<interpret::AllocId, DefId>,\n-\n-    /// The AllocId to assign to the next new regular allocation.\n-    /// Always incremented, never gets smaller.\n-    next_id: interpret::AllocId,\n-\n-    /// Inverse map of `statics`\n-    /// Used so we don't allocate a new pointer every time we need one\n-    static_cache: FxHashMap<DefId, interpret::AllocId>,\n-}\n-\n-impl<'tcx> InterpretInterner<'tcx> {\n-    pub fn create_fn_alloc(&self, instance: Instance<'tcx>) -> interpret::AllocId {\n-        if let Some(&alloc_id) = self.inner.borrow().function_cache.get(&instance) {\n-            return alloc_id;\n-        }\n-        let id = self.reserve();\n-        debug!(\"creating fn ptr: {}\", id);\n-        let mut inner = self.inner.borrow_mut();\n-        inner.functions.insert(id, instance);\n-        inner.function_cache.insert(instance, id);\n-        id\n-    }\n-\n-    pub fn get_fn(\n-        &self,\n-        id: interpret::AllocId,\n-    ) -> Option<Instance<'tcx>> {\n-        self.inner.borrow().functions.get(&id).cloned()\n-    }\n-\n-    pub fn get_alloc(\n-        &self,\n-        id: interpret::AllocId,\n-    ) -> Option<&'tcx interpret::Allocation> {\n-        self.inner.borrow().alloc_by_id.get(&id).cloned()\n-    }\n-\n-    pub fn cache_static(\n-        &self,\n-        static_id: DefId,\n-    ) -> interpret::AllocId {\n-        if let Some(alloc_id) = self.inner.borrow().static_cache.get(&static_id).cloned() {\n-            return alloc_id;\n-        }\n-        let alloc_id = self.reserve();\n-        let mut inner = self.inner.borrow_mut();\n-        inner.static_cache.insert(static_id, alloc_id);\n-        inner.statics.insert(alloc_id, static_id);\n-        alloc_id\n-    }\n-\n-    pub fn get_static(\n-        &self,\n-        ptr: interpret::AllocId,\n-    ) -> Option<DefId> {\n-        self.inner.borrow().statics.get(&ptr).cloned()\n-    }\n-\n-    pub fn intern_at_reserved(\n-        &self,\n-        id: interpret::AllocId,\n-        alloc: &'tcx interpret::Allocation,\n-    ) {\n-        if let Some(old) = self.inner.borrow_mut().alloc_by_id.insert(id, alloc) {\n-            bug!(\"tried to intern allocation at {}, but was already existing as {:#?}\", id, old);\n-        }\n-    }\n-\n-    /// obtains a new allocation ID that can be referenced but does not\n-    /// yet have an allocation backing it.\n-    pub fn reserve(\n-        &self,\n-    ) -> interpret::AllocId {\n-        let mut inner = self.inner.borrow_mut();\n-        let next = inner.next_id;\n-        inner.next_id.0 = inner.next_id.0\n-            .checked_add(1)\n-            .expect(\"You overflowed a u64 by incrementing by 1... \\\n-                     You've just earned yourself a free drink if we ever meet. \\\n-                     Seriously, how did you do that?!\");\n-        next\n-    }\n-}\n-\n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Get the global TyCtxt.\n     #[inline]\n@@ -1124,11 +1019,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // create an allocation that just contains these bytes\n         let alloc = interpret::Allocation::from_byte_aligned_bytes(bytes);\n         let alloc = self.intern_const_alloc(alloc);\n-\n-        // the next unique id\n-        let id = self.interpret_interner.reserve();\n-        self.interpret_interner.intern_at_reserved(id, alloc);\n-        id\n+        self.alloc_map.lock().allocate(alloc)\n     }\n \n     pub fn intern_stability(self, stab: attr::Stability) -> &'gcx attr::Stability {\n@@ -1279,7 +1170,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             layout_interner: Lock::new(FxHashSet()),\n             stability_interner: Lock::new(FxHashSet()),\n             allocation_interner: Lock::new(FxHashSet()),\n-            interpret_interner: Default::default(),\n+            alloc_map: Lock::new(interpret::AllocMap::new()),\n             tx_to_llvm_workers: Lock::new(tx),\n             output_filenames: Arc::new(output_filenames.clone()),\n         };"}, {"sha": "b975f9e5195864b866544af75552469255b8031a", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddc54188fb6774ff1493aa896d9175e112d92cce/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddc54188fb6774ff1493aa896d9175e112d92cce/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=ddc54188fb6774ff1493aa896d9175e112d92cce", "patch": "@@ -78,7 +78,7 @@ pub use self::binding::BindingMode;\n pub use self::binding::BindingMode::*;\n \n pub use self::context::{TyCtxt, GlobalArenas, AllArenas, tls, keep_local};\n-pub use self::context::{Lift, TypeckTables, InterpretInterner};\n+pub use self::context::{Lift, TypeckTables};\n \n pub use self::instance::{Instance, InstanceDef};\n "}, {"sha": "07fb683a84f67699dd9974ad1e6905ab3c18f2c0", "filename": "src/librustc_codegen_llvm/mir/constant.rs", "status": "modified", "additions": 22, "deletions": 26, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/ddc54188fb6774ff1493aa896d9175e112d92cce/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddc54188fb6774ff1493aa896d9175e112d92cce/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs?ref=ddc54188fb6774ff1493aa896d9175e112d92cce", "patch": "@@ -14,7 +14,7 @@ use rustc_mir::interpret::{read_target_uint, const_val_field};\n use rustc::hir::def_id::DefId;\n use rustc::mir;\n use rustc_data_structures::indexed_vec::Idx;\n-use rustc::mir::interpret::{GlobalId, MemoryPointer, PrimVal, Allocation, ConstValue};\n+use rustc::mir::interpret::{GlobalId, MemoryPointer, PrimVal, Allocation, ConstValue, AllocType};\n use rustc::ty::{self, Ty};\n use rustc::ty::layout::{self, HasDataLayout, LayoutOf, Scalar, Size};\n use builder::Builder;\n@@ -44,38 +44,34 @@ pub fn primval_to_llvm(cx: &CodegenCx,\n             }\n         },\n         PrimVal::Ptr(ptr) => {\n-            if let Some(fn_instance) = cx.tcx.interpret_interner.get_fn(ptr.alloc_id) {\n-                callee::get_fn(cx, fn_instance)\n-            } else {\n-                let static_ = cx\n-                    .tcx\n-                    .interpret_interner\n-                    .get_static(ptr.alloc_id);\n-                let base_addr = if let Some(def_id) = static_ {\n-                    assert!(cx.tcx.is_static(def_id).is_some());\n-                    consts::get_static(cx, def_id)\n-                } else if let Some(alloc) = cx.tcx.interpret_interner\n-                                              .get_alloc(ptr.alloc_id) {\n+            let alloc_type = cx.tcx.alloc_map.lock().get(ptr.alloc_id);\n+            let base_addr = match alloc_type {\n+                Some(AllocType::Memory(alloc)) => {\n                     let init = const_alloc_to_llvm(cx, alloc);\n                     if alloc.runtime_mutability == Mutability::Mutable {\n                         consts::addr_of_mut(cx, init, alloc.align, \"byte_str\")\n                     } else {\n                         consts::addr_of(cx, init, alloc.align, \"byte_str\")\n                     }\n-                } else {\n-                    bug!(\"missing allocation {:?}\", ptr.alloc_id);\n-                };\n-\n-                let llval = unsafe { llvm::LLVMConstInBoundsGEP(\n-                    consts::bitcast(base_addr, Type::i8p(cx)),\n-                    &C_usize(cx, ptr.offset.bytes()),\n-                    1,\n-                ) };\n-                if scalar.value != layout::Pointer {\n-                    unsafe { llvm::LLVMConstPtrToInt(llval, llty.to_ref()) }\n-                } else {\n-                    consts::bitcast(llval, llty)\n                 }\n+                Some(AllocType::Function(fn_instance)) => {\n+                    callee::get_fn(cx, fn_instance)\n+                }\n+                Some(AllocType::Static(def_id)) => {\n+                    assert!(cx.tcx.is_static(def_id).is_some());\n+                    consts::get_static(cx, def_id)\n+                }\n+                None => bug!(\"missing allocation {:?}\", ptr.alloc_id),\n+            };\n+            let llval = unsafe { llvm::LLVMConstInBoundsGEP(\n+                consts::bitcast(base_addr, Type::i8p(cx)),\n+                &C_usize(cx, ptr.offset.bytes()),\n+                1,\n+            ) };\n+            if scalar.value != layout::Pointer {\n+                unsafe { llvm::LLVMConstPtrToInt(llval, llty.to_ref()) }\n+            } else {\n+                consts::bitcast(llval, llty)\n             }\n         }\n     }"}, {"sha": "70e8cd336a31c644eb1e805c3365cd78762f068f", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ddc54188fb6774ff1493aa896d9175e112d92cce/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddc54188fb6774ff1493aa896d9175e112d92cce/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=ddc54188fb6774ff1493aa896d9175e112d92cce", "patch": "@@ -187,10 +187,7 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n                             .and_then(|t| t.ty.builtin_index())\n                             .map_or(false, |t| t == tcx.types.u8);\n                         assert!(is_array_ptr);\n-                        let alloc = tcx\n-                            .interpret_interner\n-                            .get_alloc(ptr.alloc_id)\n-                            .unwrap();\n+                        let alloc = tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id);\n                         assert_eq!(ptr.offset.bytes(), 0);\n                         // FIXME: check length\n                         alloc.bytes.iter().map(|b| {\n@@ -558,10 +555,7 @@ fn max_slice_length<'p, 'a: 'p, 'tcx: 'a, I>(\n                         .and_then(|t| t.ty.builtin_index())\n                         .map_or(false, |t| t == cx.tcx.types.u8);\n                     if is_array_ptr {\n-                        let alloc = cx.tcx\n-                            .interpret_interner\n-                            .get_alloc(ptr.alloc_id)\n-                            .unwrap();\n+                        let alloc = cx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id);\n                         max_fixed_len = cmp::max(max_fixed_len, alloc.bytes.len() as u64);\n                     }\n                 }\n@@ -945,12 +939,7 @@ fn slice_pat_covered_by_constructor<'tcx>(\n                     .and_then(|t| t.ty.builtin_index())\n                     .map_or(false, |t| t == tcx.types.u8);\n                 assert!(is_array_ptr);\n-                tcx\n-                    .interpret_interner\n-                    .get_alloc(ptr.alloc_id)\n-                    .unwrap()\n-                    .bytes\n-                    .as_ref()\n+                tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id).bytes.as_ref()\n             } else {\n                 bug!()\n             }\n@@ -1088,9 +1077,9 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n                             .map_or(false, |t| t == cx.tcx.types.u8);\n                         assert!(is_array_ptr);\n                         let data_len = cx.tcx\n-                            .interpret_interner\n-                            .get_alloc(ptr.alloc_id)\n-                            .unwrap()\n+                            .alloc_map\n+                            .lock()\n+                            .unwrap_memory(ptr.alloc_id)\n                             .bytes\n                             .len();\n                         if wild_patterns.len() == data_len {"}, {"sha": "1b4cde2f6ca8f0effafa2b480882b5ff92c80f96", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ddc54188fb6774ff1493aa896d9175e112d92cce/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddc54188fb6774ff1493aa896d9175e112d92cce/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=ddc54188fb6774ff1493aa896d9175e112d92cce", "patch": "@@ -377,8 +377,9 @@ impl<'mir, 'tcx> super::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n     ) -> EvalResult<'tcx, AllocId> {\n         Ok(ecx\n             .tcx\n-            .interpret_interner\n-            .cache_static(cid.instance.def_id()))\n+            .alloc_map\n+            .lock()\n+            .intern_static(cid.instance.def_id()))\n     }\n \n     fn box_alloc<'a>("}, {"sha": "15103b78ca8ff67977bd41514253a69a682f0c87", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ddc54188fb6774ff1493aa896d9175e112d92cce/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddc54188fb6774ff1493aa896d9175e112d92cce/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=ddc54188fb6774ff1493aa896d9175e112d92cce", "patch": "@@ -1015,8 +1015,9 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         if self.tcx.is_static(gid.instance.def_id()).is_some() {\n             let alloc_id = self\n                 .tcx\n-                .interpret_interner\n-                .cache_static(gid.instance.def_id());\n+                .alloc_map\n+                .lock()\n+                .intern_static(gid.instance.def_id());\n             let layout = self.layout_of(ty)?;\n             let ptr = MemoryPointer::new(alloc_id, Size::from_bytes(0));\n             return Ok(Value::ByRef(ptr.into(), layout.align))"}, {"sha": "b2a6e2b452721fb8158eb52abfc461ea390d5a80", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 45, "deletions": 43, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/ddc54188fb6774ff1493aa896d9175e112d92cce/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddc54188fb6774ff1493aa896d9175e112d92cce/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=ddc54188fb6774ff1493aa896d9175e112d92cce", "patch": "@@ -11,7 +11,7 @@ use rustc::middle::const_val::{ConstVal, ErrKind};\n \n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n use rustc::mir::interpret::{MemoryPointer, AllocId, Allocation, AccessKind, Value, Pointer,\n-                            EvalResult, PrimVal, EvalErrorKind, GlobalId};\n+                            EvalResult, PrimVal, EvalErrorKind, GlobalId, AllocType};\n pub use rustc::mir::interpret::{write_target_uint, write_target_int, read_target_uint};\n \n use super::{EvalContext, Machine};\n@@ -72,7 +72,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     }\n \n     pub fn create_fn_alloc(&mut self, instance: Instance<'tcx>) -> MemoryPointer {\n-        let id = self.tcx.interpret_interner.create_fn_alloc(instance);\n+        let id = self.tcx.alloc_map.lock().create_fn_alloc(instance);\n         MemoryPointer::new(id, Size::from_bytes(0))\n     }\n \n@@ -87,7 +87,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         alloc: Allocation,\n         kind: Option<MemoryKind<M::MemoryKinds>>,\n     ) -> EvalResult<'tcx, AllocId> {\n-        let id = self.tcx.interpret_interner.reserve();\n+        let id = self.tcx.alloc_map.lock().reserve();\n         M::add_lock(self, id);\n         match kind {\n             Some(kind @ MemoryKind::Stack) |\n@@ -177,19 +177,20 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n                     \"uninitializedstatic\".to_string(),\n                     format!(\"{:?}\", kind),\n                 ))\n-            } else if self.tcx.interpret_interner.get_fn(ptr.alloc_id).is_some() {\n-                return err!(DeallocatedWrongMemoryKind(\n-                    \"function\".to_string(),\n-                    format!(\"{:?}\", kind),\n-                ))\n-            } else if self.tcx.interpret_interner.get_alloc(ptr.alloc_id).is_some() {\n-                return err!(DeallocatedWrongMemoryKind(\n-                    \"static\".to_string(),\n-                    format!(\"{:?}\", kind),\n-                ))\n             } else {\n-                return err!(DoubleFree)\n-            },\n+                return match self.tcx.alloc_map.lock().get(ptr.alloc_id) {\n+                    Some(AllocType::Function(..)) => err!(DeallocatedWrongMemoryKind(\n+                        \"function\".to_string(),\n+                        format!(\"{:?}\", kind),\n+                    )),\n+                    Some(AllocType::Static(..)) |\n+                    Some(AllocType::Memory(..)) => err!(DeallocatedWrongMemoryKind(\n+                        \"static\".to_string(),\n+                        format!(\"{:?}\", kind),\n+                    )),\n+                    None => err!(DoubleFree)\n+                }\n+            }\n         };\n \n         let alloc_kind = self.alloc_kind.remove(&ptr.alloc_id).expect(\"alloc_map out of sync with alloc_kind\");\n@@ -312,19 +313,16 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n                 Some(alloc) => Ok(alloc),\n                 None => {\n                     // static alloc?\n-                    if let Some(a) = self.tcx.interpret_interner.get_alloc(id) {\n-                        return Ok(a);\n+                    match self.tcx.alloc_map.lock().get(id) {\n+                        Some(AllocType::Memory(mem)) => Ok(mem),\n+                        Some(AllocType::Function(..)) => {\n+                            Err(EvalErrorKind::DerefFunctionPointer.into())\n+                        }\n+                        Some(AllocType::Static(did)) => {\n+                            self.const_eval_static(did)\n+                        }\n+                        None => Err(EvalErrorKind::DanglingPointerDeref.into()),\n                     }\n-                    // static variable?\n-                    if let Some(did) = self.tcx.interpret_interner.get_static(id) {\n-                        return self.const_eval_static(did);\n-                    }\n-                    // otherwise return an error\n-                    Err(if self.tcx.interpret_interner.get_fn(id).is_some() {\n-                        EvalErrorKind::DerefFunctionPointer.into()\n-                    } else {\n-                        EvalErrorKind::DanglingPointerDeref.into()\n-                    })\n                 },\n             },\n         }\n@@ -342,12 +340,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n                 Some(alloc) => Ok(alloc),\n                 None => {\n                     // no alloc or immutable alloc? produce an error\n-                    if self.tcx.interpret_interner.get_alloc(id).is_some() {\n-                        err!(ModifiedConstantMemory)\n-                    } else if self.tcx.interpret_interner.get_fn(id).is_some() {\n-                        err!(DerefFunctionPointer)\n-                    } else {\n-                        err!(DanglingPointerDeref)\n+                    match self.tcx.alloc_map.lock().get(id) {\n+                        Some(AllocType::Memory(..)) |\n+                        Some(AllocType::Static(..)) => err!(ModifiedConstantMemory),\n+                        Some(AllocType::Function(..)) => err!(DerefFunctionPointer),\n+                        None => err!(DanglingPointerDeref),\n                     }\n                 },\n             },\n@@ -359,10 +356,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             return err!(InvalidFunctionPointer);\n         }\n         debug!(\"reading fn ptr: {}\", ptr.alloc_id);\n-        self.tcx\n-            .interpret_interner\n-            .get_fn(ptr.alloc_id)\n-            .ok_or(EvalErrorKind::ExecuteMemory.into())\n+        match self.tcx.alloc_map.lock().get(ptr.alloc_id) {\n+            Some(AllocType::Function(instance)) => Ok(instance),\n+            _ => Err(EvalErrorKind::ExecuteMemory.into()),\n+        }\n     }\n \n     pub fn get_alloc_kind(&self, id: AllocId) -> Option<MemoryKind<M::MemoryKinds>> {\n@@ -405,15 +402,20 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n                         Some(a) => (a, \" (static in the process of initialization)\".to_owned()),\n                         None => {\n                             // static alloc?\n-                            match self.tcx.interpret_interner.get_alloc(id) {\n-                                Some(a) => (a, \"(immutable)\".to_owned()),\n-                                None => if let Some(func) = self.tcx.interpret_interner.get_fn(id) {\n+                            match self.tcx.alloc_map.lock().get(id) {\n+                                Some(AllocType::Memory(a)) => (a, \"(immutable)\".to_owned()),\n+                                Some(AllocType::Function(func)) => {\n                                     trace!(\"{} {}\", msg, func);\n                                     continue;\n-                                } else {\n+                                }\n+                                Some(AllocType::Static(did)) => {\n+                                    trace!(\"{} {:?}\", msg, did);\n+                                    continue;\n+                                }\n+                                None => {\n                                     trace!(\"{} (deallocated)\", msg);\n                                     continue;\n-                                },\n+                                }\n                             }\n                         },\n                     },\n@@ -579,7 +581,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             // ensure llvm knows not to put this into immutable memroy\n             alloc.runtime_mutability = mutability;\n             let alloc = self.tcx.intern_const_alloc(alloc);\n-            self.tcx.interpret_interner.intern_at_reserved(alloc_id, alloc);\n+            self.tcx.alloc_map.lock().set_id_memory(alloc_id, alloc);\n             // recurse into inner allocations\n             for &alloc in alloc.relocations.values() {\n                 self.mark_inner_allocation_initialized(alloc, mutability)?;"}, {"sha": "b181a281ef4e8585b1bfd351e1b49cb7e28eb2aa", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ddc54188fb6774ff1493aa896d9175e112d92cce/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddc54188fb6774ff1493aa896d9175e112d92cce/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=ddc54188fb6774ff1493aa896d9175e112d92cce", "patch": "@@ -203,7 +203,7 @@ use rustc::session::config;\n use rustc::mir::{self, Location, Promoted};\n use rustc::mir::visit::Visitor as MirVisitor;\n use rustc::mir::mono::MonoItem;\n-use rustc::mir::interpret::{PrimVal, GlobalId};\n+use rustc::mir::interpret::{PrimVal, GlobalId, AllocType};\n \n use monomorphize::{self, Instance};\n use rustc::util::nodemap::{FxHashSet, FxHashMap, DefIdMap};\n@@ -1146,24 +1146,28 @@ fn collect_miri<'a, 'tcx>(\n     alloc_id: AllocId,\n     output: &mut Vec<MonoItem<'tcx>>,\n ) {\n-    if let Some(did) = tcx.interpret_interner.get_static(alloc_id) {\n-        let instance = Instance::mono(tcx, did);\n-        if should_monomorphize_locally(tcx, &instance) {\n-            trace!(\"collecting static {:?}\", did);\n-            output.push(MonoItem::Static(did));\n-        }\n-    } else if let Some(alloc) = tcx.interpret_interner.get_alloc(alloc_id) {\n-        trace!(\"collecting {:?} with {:#?}\", alloc_id, alloc);\n-        for &inner in alloc.relocations.values() {\n-            collect_miri(tcx, inner, output);\n+    let alloc_type = tcx.alloc_map.lock().get(alloc_id);\n+    match alloc_type {\n+        Some(AllocType::Static(did)) => {\n+            let instance = Instance::mono(tcx, did);\n+            if should_monomorphize_locally(tcx, &instance) {\n+                trace!(\"collecting static {:?}\", did);\n+                output.push(MonoItem::Static(did));\n+            }\n         }\n-    } else if let Some(fn_instance) = tcx.interpret_interner.get_fn(alloc_id) {\n-        if should_monomorphize_locally(tcx, &fn_instance) {\n-            trace!(\"collecting {:?} with {:#?}\", alloc_id, fn_instance);\n-            output.push(create_fn_mono_item(fn_instance));\n+        Some(AllocType::Memory(alloc)) => {\n+            trace!(\"collecting {:?} with {:#?}\", alloc_id, alloc);\n+            for &inner in alloc.relocations.values() {\n+                collect_miri(tcx, inner, output);\n+            }\n+        },\n+        Some(AllocType::Function(fn_instance)) => {\n+            if should_monomorphize_locally(tcx, &fn_instance) {\n+                trace!(\"collecting {:?} with {:#?}\", alloc_id, fn_instance);\n+                output.push(create_fn_mono_item(fn_instance));\n+            }\n         }\n-    } else {\n-        bug!(\"alloc id without corresponding allocation: {}\", alloc_id);\n+        None => bug!(\"alloc id without corresponding allocation: {}\", alloc_id),\n     }\n }\n "}]}