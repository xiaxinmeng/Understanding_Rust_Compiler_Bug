{"sha": "d3732a12e896ab98aa27eaffab99a78bbaf837e4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzNzMyYTEyZTg5NmFiOThhYTI3ZWFmZmFiOTlhNzhiYmFmODM3ZTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-06T23:30:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-06T23:30:17Z"}, "message": "Auto merge of #21997 - Manishearth:rollup, r=alexcrichton\n\nNone", "tree": {"sha": "c0d1d61f5e603754ec67ddb0893ff188167a3104", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c0d1d61f5e603754ec67ddb0893ff188167a3104"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3732a12e896ab98aa27eaffab99a78bbaf837e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3732a12e896ab98aa27eaffab99a78bbaf837e4", "html_url": "https://github.com/rust-lang/rust/commit/d3732a12e896ab98aa27eaffab99a78bbaf837e4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3732a12e896ab98aa27eaffab99a78bbaf837e4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b75b21cb9b187a6f836da61769a8110354fd6dad", "url": "https://api.github.com/repos/rust-lang/rust/commits/b75b21cb9b187a6f836da61769a8110354fd6dad", "html_url": "https://github.com/rust-lang/rust/commit/b75b21cb9b187a6f836da61769a8110354fd6dad"}, {"sha": "df7db970dcdb7b7fb1080b9d66baf2e45b689914", "url": "https://api.github.com/repos/rust-lang/rust/commits/df7db970dcdb7b7fb1080b9d66baf2e45b689914", "html_url": "https://github.com/rust-lang/rust/commit/df7db970dcdb7b7fb1080b9d66baf2e45b689914"}], "stats": {"total": 4086, "additions": 2054, "deletions": 2032}, "files": [{"sha": "e6d2a691cf5630467f1edf4aef3b12b756be7eb2", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -118,7 +118,10 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n     }\n \n     fn opt_path(m: &getopts::Matches, nm: &str) -> Path {\n-        Path::new(m.opt_str(nm).unwrap())\n+        match m.opt_str(nm) {\n+            Some(s) => Path::new(s),\n+            None => panic!(\"no option (=path) found for {}\", nm),\n+        }\n     }\n \n     let filter = if !matches.free.is_empty() {"}, {"sha": "9851e1c28fbf0856288b4d9de310cb6189b7c0cb", "filename": "src/doc/reference.md", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -1813,7 +1813,6 @@ default visibility with the `priv` keyword. When an item is declared as `pub`,\n it can be thought of as being accessible to the outside world. For example:\n \n ```\n-# #![allow(missing_copy_implementations)]\n # fn main() {}\n // Declare a private struct\n struct Foo;"}, {"sha": "3b5aa085e055a782b972aeb89cdf38fe2a319e40", "filename": "src/doc/trpl/ownership.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Fdoc%2Ftrpl%2Fownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Fdoc%2Ftrpl%2Fownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fownership.md?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -523,7 +523,7 @@ fn print<'a>(s: &'a str); // expanded\n fn debug(lvl: u32, s: &str); // elided\n fn debug<'a>(lvl: u32, s: &'a str); // expanded\n \n-// In the preceeding example, `lvl` doesn't need a lifetime because it's not a\n+// In the preceding example, `lvl` doesn't need a lifetime because it's not a\n // reference (`&`). Only things relating to references (such as a `struct`\n // which contains a reference) need lifetimes.\n "}, {"sha": "ce972c91c8180a41d0cb6fffba7eff5aeadb82de", "filename": "src/etc/featureck.py", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Fetc%2Ffeatureck.py", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Fetc%2Ffeatureck.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ffeatureck.py?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -194,9 +194,9 @@\n         if not name in joint_features:\n             print \"error: feature '\" + name + \"' is both a lang and lib feature but not whitelisted\"\n             errors = True\n-        lang_status = lang_feature_stats[name][3]\n+        lang_status = language_feature_stats[name][3]\n         lib_status = lib_feature_stats[name][3]\n-        lang_stable_since = lang_feature_stats[name][4]\n+        lang_stable_since = language_feature_stats[name][4]\n         lib_stable_since = lib_feature_stats[name][4]\n \n         if lang_status != lib_status and lib_status != \"deprecated\":"}, {"sha": "d3d3a2b997c994a2786880e82703f50462630cd2", "filename": "src/grammar/parser-lalr.y", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Fgrammar%2Fparser-lalr.y", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Fgrammar%2Fparser-lalr.y", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fparser-lalr.y?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -1195,7 +1195,7 @@ maybe_stmts\n //\n // There are also two other expr subtypes: first, nonparen_expr\n // disallows exprs surrounded by parens (including tuple expressions),\n-// this is neccesary for BOX (place) expressions, so a parens expr\n+// this is necessary for BOX (place) expressions, so a parens expr\n // following the BOX is always parsed as the place. There is also\n // expr_norange used in index_expr, which disallows '..' in\n // expressions as that has special meaning inside of brackets."}, {"sha": "24b4abbff4ae26527c8785993b219819d0e59c9c", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -311,7 +311,7 @@ impl<T: Sync + Send> Drop for Arc<T> {\n     ///\n     ///     // stuff\n     ///\n-    ///     drop(five); // explict drop\n+    ///     drop(five); // explicit drop\n     /// }\n     /// {\n     ///     let five = Arc::new(5);\n@@ -441,7 +441,7 @@ impl<T: Sync + Send> Drop for Weak<T> {\n     ///\n     ///     // stuff\n     ///\n-    ///     drop(weak_five); // explict drop\n+    ///     drop(weak_five); // explicit drop\n     /// }\n     /// {\n     ///     let five = Arc::new(5);"}, {"sha": "d99a5e2cc6d4aacf80bf3433ef6a4ce6711046aa", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -73,7 +73,9 @@\n #![feature(unboxed_closures)]\n #![feature(core)]\n #![feature(hash)]\n-#![feature(libc)]\n+#![cfg_attr(all(not(feature = \"external_funcs\"), not(feature = \"external_crate\")),\n+            feature(libc))]\n+\n \n #[macro_use]\n extern crate core;"}, {"sha": "614fe094e3073c299db784d10404800e5d15fa00", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -383,7 +383,7 @@ impl<T> Drop for Rc<T> {\n     ///\n     ///     // stuff\n     ///\n-    ///     drop(five); // explict drop\n+    ///     drop(five); // explicit drop\n     /// }\n     /// {\n     ///     let five = Rc::new(5);\n@@ -688,7 +688,7 @@ impl<T> Drop for Weak<T> {\n     ///\n     ///     // stuff\n     ///\n-    ///     drop(weak_five); // explict drop\n+    ///     drop(weak_five); // explicit drop\n     /// }\n     /// {\n     ///     let five = Rc::new(5);"}, {"sha": "b0a5911720a40aa384c75374604c84b7c0d42967", "filename": "src/libcollections/bench.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibcollections%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibcollections%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbench.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -13,40 +13,40 @@ use std::rand;\n use std::rand::Rng;\n use test::{Bencher, black_box};\n \n-pub fn insert_rand_n<M, I, R>(n: uint,\n+pub fn insert_rand_n<M, I, R>(n: usize,\n                               map: &mut M,\n                               b: &mut Bencher,\n                               mut insert: I,\n                               mut remove: R) where\n-    I: FnMut(&mut M, uint),\n-    R: FnMut(&mut M, uint),\n+    I: FnMut(&mut M, usize),\n+    R: FnMut(&mut M, usize),\n {\n     // setup\n     let mut rng = rand::weak_rng();\n \n     for _ in 0..n {\n-        insert(map, rng.gen::<uint>() % n);\n+        insert(map, rng.gen::<usize>() % n);\n     }\n \n     // measure\n     b.iter(|| {\n-        let k = rng.gen::<uint>() % n;\n+        let k = rng.gen::<usize>() % n;\n         insert(map, k);\n         remove(map, k);\n     });\n     black_box(map);\n }\n \n-pub fn insert_seq_n<M, I, R>(n: uint,\n+pub fn insert_seq_n<M, I, R>(n: usize,\n                              map: &mut M,\n                              b: &mut Bencher,\n                              mut insert: I,\n                              mut remove: R) where\n-    I: FnMut(&mut M, uint),\n-    R: FnMut(&mut M, uint),\n+    I: FnMut(&mut M, usize),\n+    R: FnMut(&mut M, usize),\n {\n     // setup\n-    for i in 0u..n {\n+    for i in 0..n {\n         insert(map, i * 2);\n     }\n \n@@ -60,18 +60,17 @@ pub fn insert_seq_n<M, I, R>(n: uint,\n     black_box(map);\n }\n \n-pub fn find_rand_n<M, T, I, F>(n: uint,\n+pub fn find_rand_n<M, T, I, F>(n: usize,\n                                map: &mut M,\n                                b: &mut Bencher,\n                                mut insert: I,\n                                mut find: F) where\n-    I: FnMut(&mut M, uint),\n-    F: FnMut(&M, uint) -> T,\n+    I: FnMut(&mut M, usize),\n+    F: FnMut(&M, usize) -> T,\n {\n     // setup\n     let mut rng = rand::weak_rng();\n-    let mut keys = (0..n).map(|_| rng.gen::<uint>() % n)\n-                              .collect::<Vec<_>>();\n+    let mut keys: Vec<_> = (0..n).map(|_| rng.gen::<usize>() % n).collect();\n \n     for k in &keys {\n         insert(map, *k);\n@@ -88,16 +87,16 @@ pub fn find_rand_n<M, T, I, F>(n: uint,\n     })\n }\n \n-pub fn find_seq_n<M, T, I, F>(n: uint,\n+pub fn find_seq_n<M, T, I, F>(n: usize,\n                               map: &mut M,\n                               b: &mut Bencher,\n                               mut insert: I,\n                               mut find: F) where\n-    I: FnMut(&mut M, uint),\n-    F: FnMut(&M, uint) -> T,\n+    I: FnMut(&mut M, usize),\n+    F: FnMut(&M, usize) -> T,\n {\n     // setup\n-    for i in 0u..n {\n+    for i in 0..n {\n         insert(map, i);\n     }\n "}, {"sha": "275fc34f8132659c3c35bfc381d7755e45168bc7", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 65, "deletions": 66, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -28,12 +28,12 @@\n //! ```\n //! use std::cmp::Ordering;\n //! use std::collections::BinaryHeap;\n-//! use std::uint;\n+//! use std::usize;\n //!\n //! #[derive(Copy, Eq, PartialEq)]\n //! struct State {\n-//!     cost: uint,\n-//!     position: uint,\n+//!     cost: usize,\n+//!     position: usize,\n //! }\n //!\n //! // The priority queue depends on `Ord`.\n@@ -53,21 +53,21 @@\n //!     }\n //! }\n //!\n-//! // Each node is represented as an `uint`, for a shorter implementation.\n+//! // Each node is represented as an `usize`, for a shorter implementation.\n //! struct Edge {\n-//!     node: uint,\n-//!     cost: uint,\n+//!     node: usize,\n+//!     cost: usize,\n //! }\n //!\n //! // Dijkstra's shortest path algorithm.\n //!\n //! // Start at `start` and use `dist` to track the current shortest distance\n //! // to each node. This implementation isn't memory-efficient as it may leave duplicate\n-//! // nodes in the queue. It also uses `uint::MAX` as a sentinel value,\n+//! // nodes in the queue. It also uses `usize::MAX` as a sentinel value,\n //! // for a simpler implementation.\n-//! fn shortest_path(adj_list: &Vec<Vec<Edge>>, start: uint, goal: uint) -> uint {\n+//! fn shortest_path(adj_list: &Vec<Vec<Edge>>, start: usize, goal: usize) -> usize {\n //!     // dist[node] = current shortest distance from `start` to `node`\n-//!     let mut dist: Vec<_> = (0..adj_list.len()).map(|_| uint::MAX).collect();\n+//!     let mut dist: Vec<_> = (0..adj_list.len()).map(|_| usize::MAX).collect();\n //!\n //!     let mut heap = BinaryHeap::new();\n //!\n@@ -98,7 +98,7 @@\n //!     }\n //!\n //!     // Goal not reachable\n-//!     uint::MAX\n+//!     usize::MAX\n //! }\n //!\n //! fn main() {\n@@ -143,7 +143,7 @@\n //!     assert_eq!(shortest_path(&graph, 0, 3), 3);\n //!     assert_eq!(shortest_path(&graph, 3, 0), 7);\n //!     assert_eq!(shortest_path(&graph, 0, 4), 5);\n-//!     assert_eq!(shortest_path(&graph, 4, 0), uint::MAX);\n+//!     assert_eq!(shortest_path(&graph, 4, 0), usize::MAX);\n //! }\n //! ```\n \n@@ -183,7 +183,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// ```\n     /// use std::collections::BinaryHeap;\n     /// let mut heap = BinaryHeap::new();\n-    /// heap.push(4u);\n+    /// heap.push(4);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> BinaryHeap<T> { BinaryHeap { data: vec![] } }\n@@ -198,10 +198,10 @@ impl<T: Ord> BinaryHeap<T> {\n     /// ```\n     /// use std::collections::BinaryHeap;\n     /// let mut heap = BinaryHeap::with_capacity(10);\n-    /// heap.push(4u);\n+    /// heap.push(4);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn with_capacity(capacity: uint) -> BinaryHeap<T> {\n+    pub fn with_capacity(capacity: usize) -> BinaryHeap<T> {\n         BinaryHeap { data: Vec::with_capacity(capacity) }\n     }\n \n@@ -292,10 +292,10 @@ impl<T: Ord> BinaryHeap<T> {\n     /// use std::collections::BinaryHeap;\n     /// let mut heap = BinaryHeap::with_capacity(100);\n     /// assert!(heap.capacity() >= 100);\n-    /// heap.push(4u);\n+    /// heap.push(4);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn capacity(&self) -> uint { self.data.capacity() }\n+    pub fn capacity(&self) -> usize { self.data.capacity() }\n \n     /// Reserves the minimum capacity for exactly `additional` more elements to be inserted in the\n     /// given `BinaryHeap`. Does nothing if the capacity is already sufficient.\n@@ -306,7 +306,7 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the new capacity overflows `uint`.\n+    /// Panics if the new capacity overflows `usize`.\n     ///\n     /// # Examples\n     ///\n@@ -315,10 +315,10 @@ impl<T: Ord> BinaryHeap<T> {\n     /// let mut heap = BinaryHeap::new();\n     /// heap.reserve_exact(100);\n     /// assert!(heap.capacity() >= 100);\n-    /// heap.push(4u);\n+    /// heap.push(4);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn reserve_exact(&mut self, additional: uint) {\n+    pub fn reserve_exact(&mut self, additional: usize) {\n         self.data.reserve_exact(additional);\n     }\n \n@@ -327,7 +327,7 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the new capacity overflows `uint`.\n+    /// Panics if the new capacity overflows `usize`.\n     ///\n     /// # Examples\n     ///\n@@ -336,10 +336,10 @@ impl<T: Ord> BinaryHeap<T> {\n     /// let mut heap = BinaryHeap::new();\n     /// heap.reserve(100);\n     /// assert!(heap.capacity() >= 100);\n-    /// heap.push(4u);\n+    /// heap.push(4);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn reserve(&mut self, additional: uint) {\n+    pub fn reserve(&mut self, additional: usize) {\n         self.data.reserve(additional);\n     }\n \n@@ -497,7 +497,7 @@ impl<T: Ord> BinaryHeap<T> {\n     // zeroed element), shift along the others and move it back into the\n     // vector over the junk element. This reduces the constant factor\n     // compared to using swaps, which involves twice as many moves.\n-    fn sift_up(&mut self, start: uint, mut pos: uint) {\n+    fn sift_up(&mut self, start: usize, mut pos: usize) {\n         unsafe {\n             let new = replace(&mut self.data[pos], zeroed());\n \n@@ -514,7 +514,7 @@ impl<T: Ord> BinaryHeap<T> {\n         }\n     }\n \n-    fn sift_down_range(&mut self, mut pos: uint, end: uint) {\n+    fn sift_down_range(&mut self, mut pos: usize, end: usize) {\n         unsafe {\n             let start = pos;\n             let new = replace(&mut self.data[pos], zeroed());\n@@ -536,14 +536,14 @@ impl<T: Ord> BinaryHeap<T> {\n         }\n     }\n \n-    fn sift_down(&mut self, pos: uint) {\n+    fn sift_down(&mut self, pos: usize) {\n         let len = self.len();\n         self.sift_down_range(pos, len);\n     }\n \n     /// Returns the length of the binary heap.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> uint { self.data.len() }\n+    pub fn len(&self) -> usize { self.data.len() }\n \n     /// Checks if the binary heap is empty.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -584,7 +584,7 @@ impl<'a, T> Iterator for Iter<'a, T> {\n     fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -610,7 +610,7 @@ impl<T> Iterator for IntoIter<T> {\n     fn next(&mut self) -> Option<T> { self.iter.next() }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -636,7 +636,7 @@ impl<'a, T: 'a> Iterator for Drain<'a, T> {\n     fn next(&mut self) -> Option<T> { self.iter.next() }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -692,7 +692,7 @@ mod tests {\n \n     #[test]\n     fn test_iterator() {\n-        let data = vec!(5, 9, 3);\n+        let data = vec![5, 9, 3];\n         let iterout = [9, 5, 3];\n         let heap = BinaryHeap::from_vec(data);\n         let mut i = 0;\n@@ -704,27 +704,27 @@ mod tests {\n \n     #[test]\n     fn test_iterator_reverse() {\n-        let data = vec!(5, 9, 3);\n-        let iterout = vec!(3, 5, 9);\n+        let data = vec![5, 9, 3];\n+        let iterout = vec![3, 5, 9];\n         let pq = BinaryHeap::from_vec(data);\n \n-        let v: Vec<int> = pq.iter().rev().map(|&x| x).collect();\n+        let v: Vec<_> = pq.iter().rev().cloned().collect();\n         assert_eq!(v, iterout);\n     }\n \n     #[test]\n     fn test_move_iter() {\n-        let data = vec!(5, 9, 3);\n-        let iterout = vec!(9, 5, 3);\n+        let data = vec![5, 9, 3];\n+        let iterout = vec![9, 5, 3];\n         let pq = BinaryHeap::from_vec(data);\n \n-        let v: Vec<int> = pq.into_iter().collect();\n+        let v: Vec<_> = pq.into_iter().collect();\n         assert_eq!(v, iterout);\n     }\n \n     #[test]\n     fn test_move_iter_size_hint() {\n-        let data = vec!(5, 9);\n+        let data = vec![5, 9];\n         let pq = BinaryHeap::from_vec(data);\n \n         let mut it = pq.into_iter();\n@@ -741,17 +741,17 @@ mod tests {\n \n     #[test]\n     fn test_move_iter_reverse() {\n-        let data = vec!(5, 9, 3);\n-        let iterout = vec!(3, 5, 9);\n+        let data = vec![5, 9, 3];\n+        let iterout = vec![3, 5, 9];\n         let pq = BinaryHeap::from_vec(data);\n \n-        let v: Vec<int> = pq.into_iter().rev().collect();\n+        let v: Vec<_> = pq.into_iter().rev().collect();\n         assert_eq!(v, iterout);\n     }\n \n     #[test]\n     fn test_peek_and_pop() {\n-        let data = vec!(2u, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1);\n+        let data = vec![2, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1];\n         let mut sorted = data.clone();\n         sorted.sort();\n         let mut heap = BinaryHeap::from_vec(data);\n@@ -763,7 +763,7 @@ mod tests {\n \n     #[test]\n     fn test_push() {\n-        let mut heap = BinaryHeap::from_vec(vec!(2, 4, 9));\n+        let mut heap = BinaryHeap::from_vec(vec![2, 4, 9]);\n         assert_eq!(heap.len(), 3);\n         assert!(*heap.peek().unwrap() == 9);\n         heap.push(11);\n@@ -785,7 +785,7 @@ mod tests {\n \n     #[test]\n     fn test_push_unique() {\n-        let mut heap = BinaryHeap::from_vec(vec!(box 2, box 4, box 9));\n+        let mut heap = BinaryHeap::from_vec(vec![box 2, box 4, box 9]);\n         assert_eq!(heap.len(), 3);\n         assert!(*heap.peek().unwrap() == box 9);\n         heap.push(box 11);\n@@ -807,7 +807,7 @@ mod tests {\n \n     #[test]\n     fn test_push_pop() {\n-        let mut heap = BinaryHeap::from_vec(vec!(5, 5, 2, 1, 3));\n+        let mut heap = BinaryHeap::from_vec(vec![5, 5, 2, 1, 3]);\n         assert_eq!(heap.len(), 5);\n         assert_eq!(heap.push_pop(6), 6);\n         assert_eq!(heap.len(), 5);\n@@ -821,7 +821,7 @@ mod tests {\n \n     #[test]\n     fn test_replace() {\n-        let mut heap = BinaryHeap::from_vec(vec!(5, 5, 2, 1, 3));\n+        let mut heap = BinaryHeap::from_vec(vec![5, 5, 2, 1, 3]);\n         assert_eq!(heap.len(), 5);\n         assert_eq!(heap.replace(6).unwrap(), 5);\n         assert_eq!(heap.len(), 5);\n@@ -833,7 +833,7 @@ mod tests {\n         assert_eq!(heap.len(), 5);\n     }\n \n-    fn check_to_vec(mut data: Vec<int>) {\n+    fn check_to_vec(mut data: Vec<i32>) {\n         let heap = BinaryHeap::from_vec(data.clone());\n         let mut v = heap.clone().into_vec();\n         v.sort();\n@@ -845,44 +845,44 @@ mod tests {\n \n     #[test]\n     fn test_to_vec() {\n-        check_to_vec(vec!());\n-        check_to_vec(vec!(5));\n-        check_to_vec(vec!(3, 2));\n-        check_to_vec(vec!(2, 3));\n-        check_to_vec(vec!(5, 1, 2));\n-        check_to_vec(vec!(1, 100, 2, 3));\n-        check_to_vec(vec!(1, 3, 5, 7, 9, 2, 4, 6, 8, 0));\n-        check_to_vec(vec!(2, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1));\n-        check_to_vec(vec!(9, 11, 9, 9, 9, 9, 11, 2, 3, 4, 11, 9, 0, 0, 0, 0));\n-        check_to_vec(vec!(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10));\n-        check_to_vec(vec!(10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0));\n-        check_to_vec(vec!(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 0, 1, 2));\n-        check_to_vec(vec!(5, 4, 3, 2, 1, 5, 4, 3, 2, 1, 5, 4, 3, 2, 1));\n+        check_to_vec(vec![]);\n+        check_to_vec(vec![5]);\n+        check_to_vec(vec![3, 2]);\n+        check_to_vec(vec![2, 3]);\n+        check_to_vec(vec![5, 1, 2]);\n+        check_to_vec(vec![1, 100, 2, 3]);\n+        check_to_vec(vec![1, 3, 5, 7, 9, 2, 4, 6, 8, 0]);\n+        check_to_vec(vec![2, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1]);\n+        check_to_vec(vec![9, 11, 9, 9, 9, 9, 11, 2, 3, 4, 11, 9, 0, 0, 0, 0]);\n+        check_to_vec(vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n+        check_to_vec(vec![10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]);\n+        check_to_vec(vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 0, 1, 2]);\n+        check_to_vec(vec![5, 4, 3, 2, 1, 5, 4, 3, 2, 1, 5, 4, 3, 2, 1]);\n     }\n \n     #[test]\n     fn test_empty_pop() {\n-        let mut heap = BinaryHeap::<int>::new();\n+        let mut heap = BinaryHeap::<i32>::new();\n         assert!(heap.pop().is_none());\n     }\n \n     #[test]\n     fn test_empty_peek() {\n-        let empty = BinaryHeap::<int>::new();\n+        let empty = BinaryHeap::<i32>::new();\n         assert!(empty.peek().is_none());\n     }\n \n     #[test]\n     fn test_empty_replace() {\n-        let mut heap = BinaryHeap::<int>::new();\n+        let mut heap = BinaryHeap::new();\n         assert!(heap.replace(5).is_none());\n     }\n \n     #[test]\n     fn test_from_iter() {\n-        let xs = vec!(9u, 8, 7, 6, 5, 4, 3, 2, 1);\n+        let xs = vec![9, 8, 7, 6, 5, 4, 3, 2, 1];\n \n-        let mut q: BinaryHeap<uint> = xs.iter().rev().map(|&x| x).collect();\n+        let mut q: BinaryHeap<_> = xs.iter().rev().cloned().collect();\n \n         for &x in &xs {\n             assert_eq!(q.pop().unwrap(), x);\n@@ -891,8 +891,7 @@ mod tests {\n \n     #[test]\n     fn test_drain() {\n-        let mut q: BinaryHeap<_> =\n-            [9u, 8, 7, 6, 5, 4, 3, 2, 1].iter().cloned().collect();\n+        let mut q: BinaryHeap<_> = [9, 8, 7, 6, 5, 4, 3, 2, 1].iter().cloned().collect();\n \n         assert_eq!(q.drain().take(5).count(), 5);\n "}, {"sha": "8ba0eb9b7efe5180e5e9d3236796b0af26ab1a03", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 248, "deletions": 248, "changes": 496, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -18,7 +18,7 @@\n // rather `or` and `and`.\n \n // (1) Be careful, most things can overflow here because the amount of bits in\n-//     memory can overflow `uint`.\n+//     memory can overflow `usize`.\n // (2) Make sure that the underlying vector has no excess length:\n //     E. g. `nbits == 16`, `storage.len() == 2` would be excess length,\n //     because the last word isn't used at all. This is important because some\n@@ -54,7 +54,7 @@\n //!     bv.set(0, false);\n //!     bv.set(1, false);\n //!\n-//!     for i in iter::range_inclusive(2, (max_prime as f64).sqrt() as uint) {\n+//!     for i in iter::range_inclusive(2, (max_prime as f64).sqrt() as usize) {\n //!         // if i is a prime\n //!         if bv[i] {\n //!             // Mark all multiples of i as non-prime (any multiples below i * i\n@@ -66,7 +66,7 @@\n //! };\n //!\n //! // Simple primality tests below our max bound\n-//! let print_primes = 20u;\n+//! let print_primes = 20;\n //! print!(\"The primes below {} are: \", print_primes);\n //! for x in 0..print_primes {\n //!     if primes.contains(&x) {\n@@ -93,7 +93,7 @@ use core::iter::{self, FromIterator, IntoIterator};\n use core::num::Int;\n use core::ops::Index;\n use core::slice;\n-use core::{u8, u32, uint};\n+use core::{u8, u32, usize};\n use bitv_set; //so meta\n \n use Vec;\n@@ -162,15 +162,15 @@ pub struct Bitv {\n     /// Internal representation of the bit vector\n     storage: Vec<u32>,\n     /// The number of valid bits in the internal representation\n-    nbits: uint\n+    nbits: usize\n }\n \n // FIXME(Gankro): NopeNopeNopeNopeNope (wait for IndexGet to be a thing)\n-impl Index<uint> for Bitv {\n+impl Index<usize> for Bitv {\n     type Output = bool;\n \n     #[inline]\n-    fn index(&self, i: &uint) -> &bool {\n+    fn index(&self, i: &usize) -> &bool {\n         if self.get(*i).expect(\"index out of bounds\") {\n             &TRUE\n         } else {\n@@ -180,15 +180,15 @@ impl Index<uint> for Bitv {\n }\n \n /// Computes how many blocks are needed to store that many bits\n-fn blocks_for_bits(bits: uint) -> uint {\n+fn blocks_for_bits(bits: usize) -> usize {\n     // If we want 17 bits, dividing by 32 will produce 0. So we add 1 to make sure we\n     // reserve enough. But if we want exactly a multiple of 32, this will actually allocate\n     // one too many. So we need to check if that's the case. We can do that by computing if\n     // bitwise AND by `32 - 1` is 0. But LLVM should be able to optimize the semantically\n     // superior modulo operator on a power of two to this.\n     //\n     // Note that we can technically avoid this branch with the expression\n-    // `(nbits + u32::BITS - 1) / 32::BITS`, but if nbits is almost uint::MAX this will overflow.\n+    // `(nbits + u32::BITS - 1) / 32::BITS`, but if nbits is almost usize::MAX this will overflow.\n     if bits % u32::BITS == 0 {\n         bits / u32::BITS\n     } else {\n@@ -197,7 +197,7 @@ fn blocks_for_bits(bits: uint) -> uint {\n }\n \n /// Computes the bitmask for the final word of the vector\n-fn mask_for_bits(bits: uint) -> u32 {\n+fn mask_for_bits(bits: usize) -> u32 {\n     // Note especially that a perfect multiple of u32::BITS should mask all 1s.\n     !0u32 >> (u32::BITS - bits % u32::BITS) % u32::BITS\n }\n@@ -266,13 +266,13 @@ impl Bitv {\n     /// ```\n     /// use std::collections::Bitv;\n     ///\n-    /// let mut bv = Bitv::from_elem(10u, false);\n-    /// assert_eq!(bv.len(), 10u);\n+    /// let mut bv = Bitv::from_elem(10, false);\n+    /// assert_eq!(bv.len(), 10);\n     /// for x in bv.iter() {\n     ///     assert_eq!(x, false);\n     /// }\n     /// ```\n-    pub fn from_elem(nbits: uint, bit: bool) -> Bitv {\n+    pub fn from_elem(nbits: usize, bit: bool) -> Bitv {\n         let nblocks = blocks_for_bits(nbits);\n         let mut bitv = Bitv {\n             storage: repeat(if bit { !0u32 } else { 0u32 }).take(nblocks).collect(),\n@@ -290,7 +290,7 @@ impl Bitv {\n     /// It is important to note that this function does not specify the\n     /// *length* of the returned bitvector, but only the *capacity*.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn with_capacity(nbits: uint) -> Bitv {\n+    pub fn with_capacity(nbits: usize) -> Bitv {\n         Bitv {\n             storage: Vec::with_capacity(blocks_for_bits(nbits)),\n             nbits: 0,\n@@ -351,9 +351,9 @@ impl Bitv {\n     /// let bv = Bitv::from_fn(5, |i| { i % 2 == 0 });\n     /// assert!(bv.eq_vec(&[true, false, true, false, true]));\n     /// ```\n-    pub fn from_fn<F>(len: uint, mut f: F) -> Bitv where F: FnMut(uint) -> bool {\n+    pub fn from_fn<F>(len: usize, mut f: F) -> Bitv where F: FnMut(usize) -> bool {\n         let mut bitv = Bitv::from_elem(len, false);\n-        for i in 0u..len {\n+        for i in 0..len {\n             bitv.set(i, f(i));\n         }\n         bitv\n@@ -376,7 +376,7 @@ impl Bitv {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get(&self, i: uint) -> Option<bool> {\n+    pub fn get(&self, i: usize) -> Option<bool> {\n         if i >= self.nbits {\n             return None;\n         }\n@@ -405,7 +405,7 @@ impl Bitv {\n     #[inline]\n     #[unstable(feature = \"collections\",\n                reason = \"panic semantics are likely to change in the future\")]\n-    pub fn set(&mut self, i: uint, x: bool) {\n+    pub fn set(&mut self, i: usize, x: bool) {\n         assert!(i < self.nbits);\n         let w = i / u32::BITS;\n         let b = i % u32::BITS;\n@@ -649,7 +649,7 @@ impl Bitv {\n     /// assert_eq!(bv.to_bytes(), vec!(0b00100000, 0b10000000));\n     /// ```\n     pub fn to_bytes(&self) -> Vec<u8> {\n-        fn bit(bitv: &Bitv, byte: uint, bit: uint) -> u8 {\n+        fn bit(bitv: &Bitv, byte: usize, bit: usize) -> u8 {\n             let offset = byte * 8 + bit;\n             if offset >= bitv.nbits {\n                 0\n@@ -709,7 +709,7 @@ impl Bitv {\n     /// assert!(bv.eq_vec(&[false, true]));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn truncate(&mut self, len: uint) {\n+    pub fn truncate(&mut self, len: usize) {\n         if len < self.len() {\n             self.nbits = len;\n             // This fixes (2).\n@@ -723,7 +723,7 @@ impl Bitv {\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the new capacity overflows `uint`.\n+    /// Panics if the new capacity overflows `usize`.\n     ///\n     /// # Examples\n     ///\n@@ -736,7 +736,7 @@ impl Bitv {\n     /// assert!(bv.capacity() >= 13);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn reserve(&mut self, additional: uint) {\n+    pub fn reserve(&mut self, additional: usize) {\n         let desired_cap = self.len().checked_add(additional).expect(\"capacity overflow\");\n         let storage_len = self.storage.len();\n         if desired_cap > self.capacity() {\n@@ -753,7 +753,7 @@ impl Bitv {\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the new capacity overflows `uint`.\n+    /// Panics if the new capacity overflows `usize`.\n     ///\n     /// # Examples\n     ///\n@@ -766,7 +766,7 @@ impl Bitv {\n     /// assert!(bv.capacity() >= 13);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn reserve_exact(&mut self, additional: uint) {\n+    pub fn reserve_exact(&mut self, additional: usize) {\n         let desired_cap = self.len().checked_add(additional).expect(\"capacity overflow\");\n         let storage_len = self.storage.len();\n         if desired_cap > self.capacity() {\n@@ -788,15 +788,15 @@ impl Bitv {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn capacity(&self) -> uint {\n-        self.storage.capacity().checked_mul(u32::BITS).unwrap_or(uint::MAX)\n+    pub fn capacity(&self) -> usize {\n+        self.storage.capacity().checked_mul(u32::BITS).unwrap_or(usize::MAX)\n     }\n \n     /// Grows the `Bitv` in-place, adding `n` copies of `value` to the `Bitv`.\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the new len overflows a `uint`.\n+    /// Panics if the new len overflows a `usize`.\n     ///\n     /// # Examples\n     ///\n@@ -808,7 +808,7 @@ impl Bitv {\n     /// assert_eq!(bv.len(), 10);\n     /// assert_eq!(bv.to_bytes(), vec!(0b01001011, 0b11000000));\n     /// ```\n-    pub fn grow(&mut self, n: uint, value: bool) {\n+    pub fn grow(&mut self, n: usize, value: bool) {\n         // Note: we just bulk set all the bits in the last word in this fn in multiple places\n         // which is technically wrong if not all of these bits are to be used. However, at the end\n         // of this fn we call `fix_last_block` at the end of this fn, which should fix this.\n@@ -901,7 +901,7 @@ impl Bitv {\n     /// Return the total number of bits in this vector\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> uint { self.nbits }\n+    pub fn len(&self) -> usize { self.nbits }\n \n     /// Returns true if there are no bits in this vector\n     #[inline]\n@@ -1012,8 +1012,8 @@ impl cmp::Eq for Bitv {}\n #[derive(Clone)]\n pub struct Iter<'a> {\n     bitv: &'a Bitv,\n-    next_idx: uint,\n-    end_idx: uint,\n+    next_idx: usize,\n+    end_idx: usize,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1031,7 +1031,7 @@ impl<'a> Iterator for Iter<'a> {\n         }\n     }\n \n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let rem = self.end_idx - self.next_idx;\n         (rem, Some(rem))\n     }\n@@ -1056,12 +1056,12 @@ impl<'a> ExactSizeIterator for Iter<'a> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> RandomAccessIterator for Iter<'a> {\n     #[inline]\n-    fn indexable(&self) -> uint {\n+    fn indexable(&self) -> usize {\n         self.end_idx - self.next_idx\n     }\n \n     #[inline]\n-    fn idx(&mut self, index: uint) -> Option<bool> {\n+    fn idx(&mut self, index: usize) -> Option<bool> {\n         if index >= self.indexable() {\n             None\n         } else {\n@@ -1083,7 +1083,7 @@ impl<'a> IntoIterator for &'a Bitv {\n ///\n /// It should also be noted that the amount of storage necessary for holding a\n /// set of objects is proportional to the maximum of the objects when viewed\n-/// as a `uint`.\n+/// as a `usize`.\n ///\n /// # Examples\n ///\n@@ -1130,18 +1130,18 @@ impl Default for BitvSet {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl FromIterator<uint> for BitvSet {\n-    fn from_iter<I:Iterator<Item=uint>>(iterator: I) -> BitvSet {\n+impl FromIterator<usize> for BitvSet {\n+    fn from_iter<I:Iterator<Item=usize>>(iterator: I) -> BitvSet {\n         let mut ret = BitvSet::new();\n         ret.extend(iterator);\n         ret\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Extend<uint> for BitvSet {\n+impl Extend<usize> for BitvSet {\n     #[inline]\n-    fn extend<I: Iterator<Item=uint>>(&mut self, iterator: I) {\n+    fn extend<I: Iterator<Item=usize>>(&mut self, iterator: I) {\n         for i in iterator {\n             self.insert(i);\n         }\n@@ -1207,7 +1207,7 @@ impl BitvSet {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn with_capacity(nbits: uint) -> BitvSet {\n+    pub fn with_capacity(nbits: usize) -> BitvSet {\n         let bitv = Bitv::from_elem(nbits, false);\n         BitvSet::from_bitv(bitv)\n     }\n@@ -1245,7 +1245,7 @@ impl BitvSet {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn capacity(&self) -> uint {\n+    pub fn capacity(&self) -> usize {\n         self.bitv.capacity()\n     }\n \n@@ -1266,7 +1266,7 @@ impl BitvSet {\n     /// assert!(s.capacity() >= 10);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn reserve_len(&mut self, len: uint) {\n+    pub fn reserve_len(&mut self, len: usize) {\n         let cur_len = self.bitv.len();\n         if len >= cur_len {\n             self.bitv.reserve(len - cur_len);\n@@ -1292,7 +1292,7 @@ impl BitvSet {\n     /// assert!(s.capacity() >= 10);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn reserve_len_exact(&mut self, len: uint) {\n+    pub fn reserve_len_exact(&mut self, len: usize) {\n         let cur_len = self.bitv.len();\n         if len >= cur_len {\n             self.bitv.reserve_exact(len - cur_len);\n@@ -1415,7 +1415,7 @@ impl BitvSet {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> bitv_set::Iter {\n-        SetIter {set: self, next_idx: 0u}\n+        SetIter {set: self, next_idx: 0}\n     }\n \n     /// Iterator over each u32 stored in `self` union `other`.\n@@ -1443,12 +1443,12 @@ impl BitvSet {\n             set: self,\n             other: other,\n             merge: or,\n-            current_word: 0u32,\n-            next_idx: 0u\n+            current_word: 0,\n+            next_idx: 0\n         })\n     }\n \n-    /// Iterator over each uint stored in `self` intersect `other`.\n+    /// Iterator over each usize stored in `self` intersect `other`.\n     /// See [intersect_with](#method.intersect_with) for an efficient in-place version.\n     ///\n     /// # Examples\n@@ -1473,12 +1473,12 @@ impl BitvSet {\n             set: self,\n             other: other,\n             merge: bitand,\n-            current_word: 0u32,\n+            current_word: 0,\n             next_idx: 0\n         }.take(min))\n     }\n \n-    /// Iterator over each uint stored in the `self` setminus `other`.\n+    /// Iterator over each usize stored in the `self` setminus `other`.\n     /// See [difference_with](#method.difference_with) for an efficient in-place version.\n     ///\n     /// # Examples\n@@ -1510,7 +1510,7 @@ impl BitvSet {\n             set: self,\n             other: other,\n             merge: diff,\n-            current_word: 0u32,\n+            current_word: 0,\n             next_idx: 0\n         })\n     }\n@@ -1541,7 +1541,7 @@ impl BitvSet {\n             set: self,\n             other: other,\n             merge: bitxor,\n-            current_word: 0u32,\n+            current_word: 0,\n             next_idx: 0\n         })\n     }\n@@ -1651,7 +1651,7 @@ impl BitvSet {\n     /// Return the number of set bits in this set.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> uint  {\n+    pub fn len(&self) -> usize  {\n         self.bitv.blocks().fold(0, |acc, n| acc + n.count_ones())\n     }\n \n@@ -1672,7 +1672,7 @@ impl BitvSet {\n     /// Returns `true` if this set contains the specified integer.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn contains(&self, value: &uint) -> bool {\n+    pub fn contains(&self, value: &usize) -> bool {\n         let bitv = &self.bitv;\n         *value < bitv.nbits && bitv[*value]\n     }\n@@ -1709,7 +1709,7 @@ impl BitvSet {\n     /// Adds a value to the set. Returns `true` if the value was not already\n     /// present in the set.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn insert(&mut self, value: uint) -> bool {\n+    pub fn insert(&mut self, value: usize) -> bool {\n         if self.contains(&value) {\n             return false;\n         }\n@@ -1727,7 +1727,7 @@ impl BitvSet {\n     /// Removes a value from the set. Returns `true` if the value was\n     /// present in the set.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn remove(&mut self, value: &uint) -> bool {\n+    pub fn remove(&mut self, value: &usize) -> bool {\n         if !self.contains(value) {\n             return false;\n         }\n@@ -1767,7 +1767,7 @@ impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for BitvSet {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SetIter<'a> {\n     set: &'a BitvSet,\n-    next_idx: uint\n+    next_idx: usize\n }\n \n /// An iterator combining two `BitvSet` iterators.\n@@ -1777,7 +1777,7 @@ struct TwoBitPositions<'a> {\n     other: &'a BitvSet,\n     merge: fn(u32, u32) -> u32,\n     current_word: u32,\n-    next_idx: uint\n+    next_idx: usize\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1791,9 +1791,9 @@ pub struct SymmetricDifference<'a>(TwoBitPositions<'a>);\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for SetIter<'a> {\n-    type Item = uint;\n+    type Item = usize;\n \n-    fn next(&mut self) -> Option<uint> {\n+    fn next(&mut self) -> Option<usize> {\n         while self.next_idx < self.set.bitv.len() {\n             let idx = self.next_idx;\n             self.next_idx += 1;\n@@ -1807,16 +1807,16 @@ impl<'a> Iterator for SetIter<'a> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         (0, Some(self.set.bitv.len() - self.next_idx))\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for TwoBitPositions<'a> {\n-    type Item = uint;\n+    type Item = usize;\n \n-    fn next(&mut self) -> Option<uint> {\n+    fn next(&mut self) -> Option<usize> {\n         while self.next_idx < self.set.bitv.len() ||\n               self.next_idx < self.other.bitv.len() {\n             let bit_idx = self.next_idx % u32::BITS;\n@@ -1844,42 +1844,42 @@ impl<'a> Iterator for TwoBitPositions<'a> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let cap = cmp::max(self.set.bitv.len(), self.other.bitv.len());\n         (0, Some(cap - self.next_idx))\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for Union<'a> {\n-    type Item = uint;\n+    type Item = usize;\n \n-    #[inline] fn next(&mut self) -> Option<uint> { self.0.next() }\n-    #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.0.size_hint() }\n+    #[inline] fn next(&mut self) -> Option<usize> { self.0.next() }\n+    #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.0.size_hint() }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for Intersection<'a> {\n-    type Item = uint;\n+    type Item = usize;\n \n-    #[inline] fn next(&mut self) -> Option<uint> { self.0.next() }\n-    #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.0.size_hint() }\n+    #[inline] fn next(&mut self) -> Option<usize> { self.0.next() }\n+    #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.0.size_hint() }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for Difference<'a> {\n-    type Item = uint;\n+    type Item = usize;\n \n-    #[inline] fn next(&mut self) -> Option<uint> { self.0.next() }\n-    #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.0.size_hint() }\n+    #[inline] fn next(&mut self) -> Option<usize> { self.0.next() }\n+    #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.0.size_hint() }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for SymmetricDifference<'a> {\n-    type Item = uint;\n+    type Item = usize;\n \n-    #[inline] fn next(&mut self) -> Option<uint> { self.0.next() }\n-    #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.0.size_hint() }\n+    #[inline] fn next(&mut self) -> Option<usize> { self.0.next() }\n+    #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.0.size_hint() }\n }\n \n impl<'a> IntoIterator for &'a BitvSet {\n@@ -1902,7 +1902,7 @@ mod tests {\n         let zerolen = Bitv::new();\n         assert_eq!(format!(\"{:?}\", zerolen), \"\");\n \n-        let eightbits = Bitv::from_elem(8u, false);\n+        let eightbits = Bitv::from_elem(8, false);\n         assert_eq!(format!(\"{:?}\", eightbits), \"00000000\")\n     }\n \n@@ -1916,10 +1916,10 @@ mod tests {\n \n     #[test]\n     fn test_1_element() {\n-        let mut act = Bitv::from_elem(1u, false);\n+        let mut act = Bitv::from_elem(1, false);\n         assert!(act.eq_vec(&[false]));\n         assert!(act.none() && !act.all());\n-        act = Bitv::from_elem(1u, true);\n+        act = Bitv::from_elem(1, true);\n         assert!(act.eq_vec(&[true]));\n         assert!(!act.none() && act.all());\n     }\n@@ -1938,42 +1938,42 @@ mod tests {\n         let mut act;\n         // all 0\n \n-        act = Bitv::from_elem(10u, false);\n+        act = Bitv::from_elem(10, false);\n         assert!((act.eq_vec(\n                     &[false, false, false, false, false, false, false, false, false, false])));\n         assert!(act.none() && !act.all());\n         // all 1\n \n-        act = Bitv::from_elem(10u, true);\n+        act = Bitv::from_elem(10, true);\n         assert!((act.eq_vec(&[true, true, true, true, true, true, true, true, true, true])));\n         assert!(!act.none() && act.all());\n         // mixed\n \n-        act = Bitv::from_elem(10u, false);\n-        act.set(0u, true);\n-        act.set(1u, true);\n-        act.set(2u, true);\n-        act.set(3u, true);\n-        act.set(4u, true);\n+        act = Bitv::from_elem(10, false);\n+        act.set(0, true);\n+        act.set(1, true);\n+        act.set(2, true);\n+        act.set(3, true);\n+        act.set(4, true);\n         assert!((act.eq_vec(&[true, true, true, true, true, false, false, false, false, false])));\n         assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::from_elem(10u, false);\n-        act.set(5u, true);\n-        act.set(6u, true);\n-        act.set(7u, true);\n-        act.set(8u, true);\n-        act.set(9u, true);\n+        act = Bitv::from_elem(10, false);\n+        act.set(5, true);\n+        act.set(6, true);\n+        act.set(7, true);\n+        act.set(8, true);\n+        act.set(9, true);\n         assert!((act.eq_vec(&[false, false, false, false, false, true, true, true, true, true])));\n         assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::from_elem(10u, false);\n-        act.set(0u, true);\n-        act.set(3u, true);\n-        act.set(6u, true);\n-        act.set(9u, true);\n+        act = Bitv::from_elem(10, false);\n+        act.set(0, true);\n+        act.set(3, true);\n+        act.set(6, true);\n+        act.set(9, true);\n         assert!((act.eq_vec(&[true, false, false, true, false, false, true, false, false, true])));\n         assert!(!act.none() && !act.all());\n     }\n@@ -1983,73 +1983,73 @@ mod tests {\n         let mut act;\n         // all 0\n \n-        act = Bitv::from_elem(31u, false);\n+        act = Bitv::from_elem(31, false);\n         assert!(act.eq_vec(\n                 &[false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false]));\n         assert!(act.none() && !act.all());\n         // all 1\n \n-        act = Bitv::from_elem(31u, true);\n+        act = Bitv::from_elem(31, true);\n         assert!(act.eq_vec(\n                 &[true, true, true, true, true, true, true, true, true, true, true, true, true,\n                   true, true, true, true, true, true, true, true, true, true, true, true, true,\n                   true, true, true, true, true]));\n         assert!(!act.none() && act.all());\n         // mixed\n \n-        act = Bitv::from_elem(31u, false);\n-        act.set(0u, true);\n-        act.set(1u, true);\n-        act.set(2u, true);\n-        act.set(3u, true);\n-        act.set(4u, true);\n-        act.set(5u, true);\n-        act.set(6u, true);\n-        act.set(7u, true);\n+        act = Bitv::from_elem(31, false);\n+        act.set(0, true);\n+        act.set(1, true);\n+        act.set(2, true);\n+        act.set(3, true);\n+        act.set(4, true);\n+        act.set(5, true);\n+        act.set(6, true);\n+        act.set(7, true);\n         assert!(act.eq_vec(\n                 &[true, true, true, true, true, true, true, true, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false]));\n         assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::from_elem(31u, false);\n-        act.set(16u, true);\n-        act.set(17u, true);\n-        act.set(18u, true);\n-        act.set(19u, true);\n-        act.set(20u, true);\n-        act.set(21u, true);\n-        act.set(22u, true);\n-        act.set(23u, true);\n+        act = Bitv::from_elem(31, false);\n+        act.set(16, true);\n+        act.set(17, true);\n+        act.set(18, true);\n+        act.set(19, true);\n+        act.set(20, true);\n+        act.set(21, true);\n+        act.set(22, true);\n+        act.set(23, true);\n         assert!(act.eq_vec(\n                 &[false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, true, true, true, true, true, true, true, true,\n                   false, false, false, false, false, false, false]));\n         assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::from_elem(31u, false);\n-        act.set(24u, true);\n-        act.set(25u, true);\n-        act.set(26u, true);\n-        act.set(27u, true);\n-        act.set(28u, true);\n-        act.set(29u, true);\n-        act.set(30u, true);\n+        act = Bitv::from_elem(31, false);\n+        act.set(24, true);\n+        act.set(25, true);\n+        act.set(26, true);\n+        act.set(27, true);\n+        act.set(28, true);\n+        act.set(29, true);\n+        act.set(30, true);\n         assert!(act.eq_vec(\n                 &[false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, true, true, true, true, true, true, true]));\n         assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::from_elem(31u, false);\n-        act.set(3u, true);\n-        act.set(17u, true);\n-        act.set(30u, true);\n+        act = Bitv::from_elem(31, false);\n+        act.set(3, true);\n+        act.set(17, true);\n+        act.set(30, true);\n         assert!(act.eq_vec(\n                 &[false, false, false, true, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, true, false, false, false, false, false, false,\n@@ -2062,75 +2062,75 @@ mod tests {\n         let mut act;\n         // all 0\n \n-        act = Bitv::from_elem(32u, false);\n+        act = Bitv::from_elem(32, false);\n         assert!(act.eq_vec(\n                 &[false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false]));\n         assert!(act.none() && !act.all());\n         // all 1\n \n-        act = Bitv::from_elem(32u, true);\n+        act = Bitv::from_elem(32, true);\n         assert!(act.eq_vec(\n                 &[true, true, true, true, true, true, true, true, true, true, true, true, true,\n                   true, true, true, true, true, true, true, true, true, true, true, true, true,\n                   true, true, true, true, true, true]));\n         assert!(!act.none() && act.all());\n         // mixed\n \n-        act = Bitv::from_elem(32u, false);\n-        act.set(0u, true);\n-        act.set(1u, true);\n-        act.set(2u, true);\n-        act.set(3u, true);\n-        act.set(4u, true);\n-        act.set(5u, true);\n-        act.set(6u, true);\n-        act.set(7u, true);\n+        act = Bitv::from_elem(32, false);\n+        act.set(0, true);\n+        act.set(1, true);\n+        act.set(2, true);\n+        act.set(3, true);\n+        act.set(4, true);\n+        act.set(5, true);\n+        act.set(6, true);\n+        act.set(7, true);\n         assert!(act.eq_vec(\n                 &[true, true, true, true, true, true, true, true, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false]));\n         assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::from_elem(32u, false);\n-        act.set(16u, true);\n-        act.set(17u, true);\n-        act.set(18u, true);\n-        act.set(19u, true);\n-        act.set(20u, true);\n-        act.set(21u, true);\n-        act.set(22u, true);\n-        act.set(23u, true);\n+        act = Bitv::from_elem(32, false);\n+        act.set(16, true);\n+        act.set(17, true);\n+        act.set(18, true);\n+        act.set(19, true);\n+        act.set(20, true);\n+        act.set(21, true);\n+        act.set(22, true);\n+        act.set(23, true);\n         assert!(act.eq_vec(\n                 &[false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, true, true, true, true, true, true, true, true,\n                   false, false, false, false, false, false, false, false]));\n         assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::from_elem(32u, false);\n-        act.set(24u, true);\n-        act.set(25u, true);\n-        act.set(26u, true);\n-        act.set(27u, true);\n-        act.set(28u, true);\n-        act.set(29u, true);\n-        act.set(30u, true);\n-        act.set(31u, true);\n+        act = Bitv::from_elem(32, false);\n+        act.set(24, true);\n+        act.set(25, true);\n+        act.set(26, true);\n+        act.set(27, true);\n+        act.set(28, true);\n+        act.set(29, true);\n+        act.set(30, true);\n+        act.set(31, true);\n         assert!(act.eq_vec(\n                 &[false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, true, true, true, true, true, true, true, true]));\n         assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::from_elem(32u, false);\n-        act.set(3u, true);\n-        act.set(17u, true);\n-        act.set(30u, true);\n-        act.set(31u, true);\n+        act = Bitv::from_elem(32, false);\n+        act.set(3, true);\n+        act.set(17, true);\n+        act.set(30, true);\n+        act.set(31, true);\n         assert!(act.eq_vec(\n                 &[false, false, false, true, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, true, false, false, false, false, false, false,\n@@ -2143,76 +2143,76 @@ mod tests {\n         let mut act;\n         // all 0\n \n-        act = Bitv::from_elem(33u, false);\n+        act = Bitv::from_elem(33, false);\n         assert!(act.eq_vec(\n                 &[false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false]));\n         assert!(act.none() && !act.all());\n         // all 1\n \n-        act = Bitv::from_elem(33u, true);\n+        act = Bitv::from_elem(33, true);\n         assert!(act.eq_vec(\n                 &[true, true, true, true, true, true, true, true, true, true, true, true, true,\n                   true, true, true, true, true, true, true, true, true, true, true, true, true,\n                   true, true, true, true, true, true, true]));\n         assert!(!act.none() && act.all());\n         // mixed\n \n-        act = Bitv::from_elem(33u, false);\n-        act.set(0u, true);\n-        act.set(1u, true);\n-        act.set(2u, true);\n-        act.set(3u, true);\n-        act.set(4u, true);\n-        act.set(5u, true);\n-        act.set(6u, true);\n-        act.set(7u, true);\n+        act = Bitv::from_elem(33, false);\n+        act.set(0, true);\n+        act.set(1, true);\n+        act.set(2, true);\n+        act.set(3, true);\n+        act.set(4, true);\n+        act.set(5, true);\n+        act.set(6, true);\n+        act.set(7, true);\n         assert!(act.eq_vec(\n                 &[true, true, true, true, true, true, true, true, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false]));\n         assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::from_elem(33u, false);\n-        act.set(16u, true);\n-        act.set(17u, true);\n-        act.set(18u, true);\n-        act.set(19u, true);\n-        act.set(20u, true);\n-        act.set(21u, true);\n-        act.set(22u, true);\n-        act.set(23u, true);\n+        act = Bitv::from_elem(33, false);\n+        act.set(16, true);\n+        act.set(17, true);\n+        act.set(18, true);\n+        act.set(19, true);\n+        act.set(20, true);\n+        act.set(21, true);\n+        act.set(22, true);\n+        act.set(23, true);\n         assert!(act.eq_vec(\n                 &[false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, true, true, true, true, true, true, true, true,\n                   false, false, false, false, false, false, false, false, false]));\n         assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::from_elem(33u, false);\n-        act.set(24u, true);\n-        act.set(25u, true);\n-        act.set(26u, true);\n-        act.set(27u, true);\n-        act.set(28u, true);\n-        act.set(29u, true);\n-        act.set(30u, true);\n-        act.set(31u, true);\n+        act = Bitv::from_elem(33, false);\n+        act.set(24, true);\n+        act.set(25, true);\n+        act.set(26, true);\n+        act.set(27, true);\n+        act.set(28, true);\n+        act.set(29, true);\n+        act.set(30, true);\n+        act.set(31, true);\n         assert!(act.eq_vec(\n                 &[false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, true, true, true, true, true, true, true, true, false]));\n         assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::from_elem(33u, false);\n-        act.set(3u, true);\n-        act.set(17u, true);\n-        act.set(30u, true);\n-        act.set(31u, true);\n-        act.set(32u, true);\n+        act = Bitv::from_elem(33, false);\n+        act.set(3, true);\n+        act.set(17, true);\n+        act.set(30, true);\n+        act.set(31, true);\n+        act.set(32, true);\n         assert!(act.eq_vec(\n                 &[false, false, false, true, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, true, false, false, false, false, false, false,\n@@ -2222,15 +2222,15 @@ mod tests {\n \n     #[test]\n     fn test_equal_differing_sizes() {\n-        let v0 = Bitv::from_elem(10u, false);\n-        let v1 = Bitv::from_elem(11u, false);\n+        let v0 = Bitv::from_elem(10, false);\n+        let v1 = Bitv::from_elem(11, false);\n         assert!(v0 != v1);\n     }\n \n     #[test]\n     fn test_equal_greatly_differing_sizes() {\n-        let v0 = Bitv::from_elem(10u, false);\n-        let v1 = Bitv::from_elem(110u, false);\n+        let v0 = Bitv::from_elem(10, false);\n+        let v1 = Bitv::from_elem(110, false);\n         assert!(v0 != v1);\n     }\n \n@@ -2248,12 +2248,12 @@ mod tests {\n     #[test]\n     fn test_equal_sneaky_big() {\n         let mut a = Bitv::from_elem(100, false);\n-        for i in 0u..100 {\n+        for i in 0..100 {\n             a.set(i, true);\n         }\n \n         let mut b = Bitv::from_elem(100, true);\n-        for i in 0u..100 {\n+        for i in 0..100 {\n             b.set(i, true);\n         }\n \n@@ -2288,7 +2288,7 @@ mod tests {\n \n     #[test]\n     fn test_to_bools() {\n-        let bools = vec!(false, false, true, false, false, true, true, false);\n+        let bools = vec![false, false, true, false, false, true, true, false];\n         assert_eq!(Bitv::from_bytes(&[0b00100110]).iter().collect::<Vec<bool>>(), bools);\n     }\n \n@@ -2299,7 +2299,7 @@ mod tests {\n \n         assert_eq!(bitv.iter().collect::<Vec<bool>>(), bools);\n \n-        let long = (0i32..10000).map(|i| i % 2 == 0).collect::<Vec<_>>();\n+        let long: Vec<_> = (0i32..10000).map(|i| i % 2 == 0).collect();\n         let bitv: Bitv = long.iter().map(|n| *n).collect();\n         assert_eq!(bitv.iter().collect::<Vec<bool>>(), long)\n     }\n@@ -2350,8 +2350,8 @@ mod tests {\n \n     #[test]\n     fn test_bitv_lt() {\n-        let mut a = Bitv::from_elem(5u, false);\n-        let mut b = Bitv::from_elem(5u, false);\n+        let mut a = Bitv::from_elem(5, false);\n+        let mut b = Bitv::from_elem(5, false);\n \n         assert!(!(a < b) && !(b < a));\n         b.set(2, true);\n@@ -2366,8 +2366,8 @@ mod tests {\n \n     #[test]\n     fn test_ord() {\n-        let mut a = Bitv::from_elem(5u, false);\n-        let mut b = Bitv::from_elem(5u, false);\n+        let mut a = Bitv::from_elem(5, false);\n+        let mut b = Bitv::from_elem(5, false);\n \n         assert!(a <= b && a >= b);\n         a.set(1, true);\n@@ -2530,20 +2530,20 @@ mod bitv_bench {\n \n     use super::Bitv;\n \n-    static BENCH_BITS : uint = 1 << 14;\n+    static BENCH_BITS : usize = 1 << 14;\n \n     fn rng() -> rand::IsaacRng {\n         let seed: &[_] = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 0];\n         rand::SeedableRng::from_seed(seed)\n     }\n \n     #[bench]\n-    fn bench_uint_small(b: &mut Bencher) {\n+    fn bench_usize_small(b: &mut Bencher) {\n         let mut r = rng();\n-        let mut bitv = 0 as uint;\n+        let mut bitv = 0 as usize;\n         b.iter(|| {\n-            for _ in 0u..100 {\n-                bitv |= 1 << ((r.next_u32() as uint) % u32::BITS);\n+            for _ in 0..100 {\n+                bitv |= 1 << ((r.next_u32() as usize) % u32::BITS);\n             }\n             black_box(&bitv);\n         });\n@@ -2554,8 +2554,8 @@ mod bitv_bench {\n         let mut r = rng();\n         let mut bitv = Bitv::from_elem(BENCH_BITS, false);\n         b.iter(|| {\n-            for _ in 0u..100 {\n-                bitv.set((r.next_u32() as uint) % BENCH_BITS, true);\n+            for _ in 0..100 {\n+                bitv.set((r.next_u32() as usize) % BENCH_BITS, true);\n             }\n             black_box(&bitv);\n         });\n@@ -2566,8 +2566,8 @@ mod bitv_bench {\n         let mut r = rng();\n         let mut bitv = Bitv::from_elem(BENCH_BITS, false);\n         b.iter(|| {\n-            for _ in 0u..100 {\n-                bitv.set((r.next_u32() as uint) % BENCH_BITS, r.gen());\n+            for _ in 0..100 {\n+                bitv.set((r.next_u32() as usize) % BENCH_BITS, r.gen());\n             }\n             black_box(&bitv);\n         });\n@@ -2578,8 +2578,8 @@ mod bitv_bench {\n         let mut r = rng();\n         let mut bitv = Bitv::from_elem(u32::BITS, false);\n         b.iter(|| {\n-            for _ in 0u..100 {\n-                bitv.set((r.next_u32() as uint) % u32::BITS, true);\n+            for _ in 0..100 {\n+                bitv.set((r.next_u32() as usize) % u32::BITS, true);\n             }\n             black_box(&bitv);\n         });\n@@ -2598,10 +2598,10 @@ mod bitv_bench {\n     fn bench_bitv_small_iter(b: &mut Bencher) {\n         let bitv = Bitv::from_elem(u32::BITS, false);\n         b.iter(|| {\n-            let mut sum = 0u;\n-            for _ in 0u..10 {\n+            let mut sum = 0;\n+            for _ in 0..10 {\n                 for pres in &bitv {\n-                    sum += pres as uint;\n+                    sum += pres as usize;\n                 }\n             }\n             sum\n@@ -2612,9 +2612,9 @@ mod bitv_bench {\n     fn bench_bitv_big_iter(b: &mut Bencher) {\n         let bitv = Bitv::from_elem(BENCH_BITS, false);\n         b.iter(|| {\n-            let mut sum = 0u;\n+            let mut sum = 0;\n             for pres in &bitv {\n-                sum += pres as uint;\n+                sum += pres as usize;\n             }\n             sum\n         })\n@@ -2645,9 +2645,9 @@ mod bitv_set_test {\n     }\n \n     #[test]\n-    fn test_bitv_set_from_uints() {\n-        let uints = vec![0, 2, 2, 3];\n-        let a: BitvSet = uints.into_iter().collect();\n+    fn test_bitv_set_from_usizes() {\n+        let usizes = vec![0, 2, 2, 3];\n+        let a: BitvSet = usizes.into_iter().collect();\n         let mut b = BitvSet::new();\n         b.insert(0);\n         b.insert(2);\n@@ -2657,16 +2657,16 @@ mod bitv_set_test {\n \n     #[test]\n     fn test_bitv_set_iterator() {\n-        let uints = vec![0, 2, 2, 3];\n-        let bitv: BitvSet = uints.into_iter().collect();\n+        let usizes = vec![0, 2, 2, 3];\n+        let bitv: BitvSet = usizes.into_iter().collect();\n \n-        let idxs: Vec<uint> = bitv.iter().collect();\n+        let idxs: Vec<_> = bitv.iter().collect();\n         assert_eq!(idxs, vec![0, 2, 3]);\n \n-        let long: BitvSet = (0u..10000).filter(|&n| n % 2 == 0).collect();\n-        let real = range_step(0, 10000, 2).collect::<Vec<uint>>();\n+        let long: BitvSet = (0..10000).filter(|&n| n % 2 == 0).collect();\n+        let real: Vec<_> = range_step(0, 10000, 2).collect();\n \n-        let idxs: Vec<uint> = long.iter().collect();\n+        let idxs: Vec<_> = long.iter().collect();\n         assert_eq!(idxs, real);\n     }\n \n@@ -2677,8 +2677,8 @@ mod bitv_set_test {\n         for &b in &bools {\n             for &l in &lengths {\n                 let bitset = BitvSet::from_bitv(Bitv::from_elem(l, b));\n-                assert_eq!(bitset.contains(&1u), b);\n-                assert_eq!(bitset.contains(&(l-1u)), b);\n+                assert_eq!(bitset.contains(&1), b);\n+                assert_eq!(bitset.contains(&(l-1)), b);\n                 assert!(!bitset.contains(&l));\n             }\n         }\n@@ -2731,7 +2731,7 @@ mod bitv_set_test {\n         assert!(b.insert(3));\n \n         let expected = [3, 5, 11, 77];\n-        let actual = a.intersection(&b).collect::<Vec<uint>>();\n+        let actual: Vec<_> = a.intersection(&b).collect();\n         assert_eq!(actual, expected);\n     }\n \n@@ -2750,7 +2750,7 @@ mod bitv_set_test {\n         assert!(b.insert(200));\n \n         let expected = [1, 5, 500];\n-        let actual = a.difference(&b).collect::<Vec<uint>>();\n+        let actual: Vec<_> = a.difference(&b).collect();\n         assert_eq!(actual, expected);\n     }\n \n@@ -2771,7 +2771,7 @@ mod bitv_set_test {\n         assert!(b.insert(220));\n \n         let expected = [1, 5, 11, 14, 220];\n-        let actual = a.symmetric_difference(&b).collect::<Vec<uint>>();\n+        let actual: Vec<_> = a.symmetric_difference(&b).collect();\n         assert_eq!(actual, expected);\n     }\n \n@@ -2796,7 +2796,7 @@ mod bitv_set_test {\n         assert!(b.insert(19));\n \n         let expected = [1, 3, 5, 9, 11, 13, 19, 24, 160, 200];\n-        let actual = a.union(&b).collect::<Vec<uint>>();\n+        let actual: Vec<_> = a.union(&b).collect();\n         assert_eq!(actual, expected);\n     }\n \n@@ -3025,7 +3025,7 @@ mod bitv_set_bench {\n \n     use super::{Bitv, BitvSet};\n \n-    static BENCH_BITS : uint = 1 << 14;\n+    static BENCH_BITS : usize = 1 << 14;\n \n     fn rng() -> rand::IsaacRng {\n         let seed: &[_] = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 0];\n@@ -3037,8 +3037,8 @@ mod bitv_set_bench {\n         let mut r = rng();\n         let mut bitv = BitvSet::new();\n         b.iter(|| {\n-            for _ in 0u..100 {\n-                bitv.insert((r.next_u32() as uint) % u32::BITS);\n+            for _ in 0..100 {\n+                bitv.insert((r.next_u32() as usize) % u32::BITS);\n             }\n             black_box(&bitv);\n         });\n@@ -3049,8 +3049,8 @@ mod bitv_set_bench {\n         let mut r = rng();\n         let mut bitv = BitvSet::new();\n         b.iter(|| {\n-            for _ in 0u..100 {\n-                bitv.insert((r.next_u32() as uint) % BENCH_BITS);\n+            for _ in 0..100 {\n+                bitv.insert((r.next_u32() as usize) % BENCH_BITS);\n             }\n             black_box(&bitv);\n         });\n@@ -3061,9 +3061,9 @@ mod bitv_set_bench {\n         let bitv = BitvSet::from_bitv(Bitv::from_fn(BENCH_BITS,\n                                               |idx| {idx % 3 == 0}));\n         b.iter(|| {\n-            let mut sum = 0u;\n+            let mut sum = 0;\n             for idx in &bitv {\n-                sum += idx as uint;\n+                sum += idx as usize;\n             }\n             sum\n         })"}, {"sha": "1b6057d4c728660d1e046776ea5718c08064e854", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 86, "deletions": 109, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -15,7 +15,7 @@\n // writing (August 2014) freely licensed under the following Creative Commons Attribution\n // License: [CC BY 2.5 CA](http://creativecommons.org/licenses/by/2.5/ca/).\n \n-pub use self::Entry::*;\n+use self::Entry::*;\n \n use core::prelude::*;\n \n@@ -63,36 +63,20 @@ use super::node::{self, Node, Found, GoDown};\n /// would like to further explore choosing the optimal search strategy based on the choice of B,\n /// and possibly other factors. Using linear search, searching for a random element is expected\n /// to take O(B log<sub>B</sub>n) comparisons, which is generally worse than a BST. In practice,\n-/// however, performance is excellent. `BTreeMap` is able to readily outperform `TreeMap` under\n-/// many workloads, and is competitive where it doesn't. BTreeMap also generally *scales* better\n-/// than TreeMap, making it more appropriate for large datasets.\n-///\n-/// However, `TreeMap` may still be more appropriate to use in many contexts. If elements are very\n-/// large or expensive to compare, `TreeMap` may be more appropriate. It won't allocate any\n-/// more space than is needed, and will perform the minimal number of comparisons necessary.\n-/// `TreeMap` also provides much better performance stability guarantees. Generally, very few\n-/// changes need to be made to update a BST, and two updates are expected to take about the same\n-/// amount of time on roughly equal sized BSTs. However a B-Tree's performance is much more\n-/// amortized. If a node is overfull, it must be split into two nodes. If a node is underfull, it\n-/// may be merged with another. Both of these operations are relatively expensive to perform, and\n-/// it's possible to force one to occur at every single level of the tree in a single insertion or\n-/// deletion. In fact, a malicious or otherwise unlucky sequence of insertions and deletions can\n-/// force this degenerate behaviour to occur on every operation. While the total amount of work\n-/// done on each operation isn't *catastrophic*, and *is* still bounded by O(B log<sub>B</sub>n),\n-/// it is certainly much slower when it does.\n+/// however, performance is excellent.\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct BTreeMap<K, V> {\n     root: Node<K, V>,\n-    length: uint,\n-    depth: uint,\n-    b: uint,\n+    length: usize,\n+    depth: usize,\n+    b: usize,\n }\n \n /// An abstract base over-which all other BTree iterators are built.\n struct AbsIter<T> {\n     traversals: RingBuf<T>,\n-    size: uint,\n+    size: usize,\n }\n \n /// An iterator over a BTreeMap's entries.\n@@ -171,7 +155,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// Makes a new empty BTreeMap with the given B.\n     ///\n     /// B cannot be less than 2.\n-    pub fn with_b(b: uint) -> BTreeMap<K, V> {\n+    pub fn with_b(b: usize) -> BTreeMap<K, V> {\n         assert!(b > 1, \"B must be greater than 1\");\n         BTreeMap {\n             length: 0,\n@@ -189,7 +173,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// use std::collections::BTreeMap;\n     ///\n     /// let mut a = BTreeMap::new();\n-    /// a.insert(1u, \"a\");\n+    /// a.insert(1, \"a\");\n     /// a.clear();\n     /// assert!(a.is_empty());\n     /// ```\n@@ -219,7 +203,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// use std::collections::BTreeMap;\n     ///\n     /// let mut map = BTreeMap::new();\n-    /// map.insert(1u, \"a\");\n+    /// map.insert(1, \"a\");\n     /// assert_eq!(map.get(&1), Some(&\"a\"));\n     /// assert_eq!(map.get(&2), None);\n     /// ```\n@@ -251,7 +235,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// use std::collections::BTreeMap;\n     ///\n     /// let mut map = BTreeMap::new();\n-    /// map.insert(1u, \"a\");\n+    /// map.insert(1, \"a\");\n     /// assert_eq!(map.contains_key(&1), true);\n     /// assert_eq!(map.contains_key(&2), false);\n     /// ```\n@@ -271,7 +255,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// use std::collections::BTreeMap;\n     ///\n     /// let mut map = BTreeMap::new();\n-    /// map.insert(1u, \"a\");\n+    /// map.insert(1, \"a\");\n     /// match map.get_mut(&1) {\n     ///     Some(x) => *x = \"b\",\n     ///     None => (),\n@@ -333,7 +317,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// use std::collections::BTreeMap;\n     ///\n     /// let mut map = BTreeMap::new();\n-    /// assert_eq!(map.insert(37u, \"a\"), None);\n+    /// assert_eq!(map.insert(37, \"a\"), None);\n     /// assert_eq!(map.is_empty(), false);\n     ///\n     /// map.insert(37, \"b\");\n@@ -445,7 +429,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// use std::collections::BTreeMap;\n     ///\n     /// let mut map = BTreeMap::new();\n-    /// map.insert(1u, \"a\");\n+    /// map.insert(1, \"a\");\n     /// assert_eq!(map.remove(&1), Some(\"a\"));\n     /// assert_eq!(map.remove(&1), None);\n     /// ```\n@@ -1001,7 +985,7 @@ impl<K, V, E, T> Iterator for AbsIter<T> where\n         }\n     }\n \n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         (self.size, Some(self.size))\n     }\n }\n@@ -1038,7 +1022,7 @@ impl<'a, K, V> Iterator for Iter<'a, K, V> {\n     type Item = (&'a K, &'a V);\n \n     fn next(&mut self) -> Option<(&'a K, &'a V)> { self.inner.next() }\n-    fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> DoubleEndedIterator for Iter<'a, K, V> {\n@@ -1052,7 +1036,7 @@ impl<'a, K, V> Iterator for IterMut<'a, K, V> {\n     type Item = (&'a K, &'a mut V);\n \n     fn next(&mut self) -> Option<(&'a K, &'a mut V)> { self.inner.next() }\n-    fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> DoubleEndedIterator for IterMut<'a, K, V> {\n@@ -1066,7 +1050,7 @@ impl<K, V> Iterator for IntoIter<K, V> {\n     type Item = (K, V);\n \n     fn next(&mut self) -> Option<(K, V)> { self.inner.next() }\n-    fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V> DoubleEndedIterator for IntoIter<K, V> {\n@@ -1080,7 +1064,7 @@ impl<'a, K, V> Iterator for Keys<'a, K, V> {\n     type Item = &'a K;\n \n     fn next(&mut self) -> Option<(&'a K)> { self.inner.next() }\n-    fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> DoubleEndedIterator for Keys<'a, K, V> {\n@@ -1095,7 +1079,7 @@ impl<'a, K, V> Iterator for Values<'a, K, V> {\n     type Item = &'a V;\n \n     fn next(&mut self) -> Option<(&'a V)> { self.inner.next() }\n-    fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> DoubleEndedIterator for Values<'a, K, V> {\n@@ -1137,47 +1121,41 @@ impl<'a, K: Ord, V> Entry<'a, K, V> {\n impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n     /// Sets the value of the entry with the VacantEntry's key,\n     /// and returns a mutable reference to it.\n-    #[unstable(feature = \"collections\",\n-               reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(self, value: V) -> &'a mut V {\n         self.stack.insert(self.key, value)\n     }\n }\n \n impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n     /// Gets a reference to the value in the entry.\n-    #[unstable(feature = \"collections\",\n-               reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get(&self) -> &V {\n         self.stack.peek()\n     }\n \n     /// Gets a mutable reference to the value in the entry.\n-    #[unstable(feature = \"collections\",\n-               reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut(&mut self) -> &mut V {\n         self.stack.peek_mut()\n     }\n \n     /// Converts the entry into a mutable reference to its value.\n-    #[unstable(feature = \"collections\",\n-               reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_mut(self) -> &'a mut V {\n         self.stack.into_top()\n     }\n \n     /// Sets the value of the entry with the OccupiedEntry's key,\n     /// and returns the entry's old value.\n-    #[unstable(feature = \"collections\",\n-               reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(&mut self, mut value: V) -> V {\n         mem::swap(self.stack.peek_mut(), &mut value);\n         value\n     }\n \n     /// Takes the value of the entry out of the map, and returns it.\n-    #[unstable(feature = \"collections\",\n-               reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove(self) -> V {\n         self.stack.remove()\n     }\n@@ -1192,16 +1170,16 @@ impl<K, V> BTreeMap<K, V> {\n     /// use std::collections::BTreeMap;\n     ///\n     /// let mut map = BTreeMap::new();\n-    /// map.insert(1u, \"a\");\n-    /// map.insert(2u, \"b\");\n-    /// map.insert(3u, \"c\");\n+    /// map.insert(1, \"a\");\n+    /// map.insert(2, \"b\");\n+    /// map.insert(3, \"c\");\n     ///\n     /// for (key, value) in map.iter() {\n     ///     println!(\"{}: {}\", key, value);\n     /// }\n     ///\n     /// let (first_key, first_value) = map.iter().next().unwrap();\n-    /// assert_eq!((*first_key, *first_value), (1u, \"a\"));\n+    /// assert_eq!((*first_key, *first_value), (1, \"a\"));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<K, V> {\n@@ -1225,9 +1203,9 @@ impl<K, V> BTreeMap<K, V> {\n     /// use std::collections::BTreeMap;\n     ///\n     /// let mut map = BTreeMap::new();\n-    /// map.insert(\"a\", 1u);\n-    /// map.insert(\"b\", 2u);\n-    /// map.insert(\"c\", 3u);\n+    /// map.insert(\"a\", 1);\n+    /// map.insert(\"b\", 2);\n+    /// map.insert(\"c\", 3);\n     ///\n     /// // add 10 to the value if the key isn't \"a\"\n     /// for (key, value) in map.iter_mut() {\n@@ -1257,9 +1235,9 @@ impl<K, V> BTreeMap<K, V> {\n     /// use std::collections::BTreeMap;\n     ///\n     /// let mut map = BTreeMap::new();\n-    /// map.insert(1u, \"a\");\n-    /// map.insert(2u, \"b\");\n-    /// map.insert(3u, \"c\");\n+    /// map.insert(1, \"a\");\n+    /// map.insert(2, \"b\");\n+    /// map.insert(3, \"c\");\n     ///\n     /// for (key, value) in map.into_iter() {\n     ///     println!(\"{}: {}\", key, value);\n@@ -1286,11 +1264,11 @@ impl<K, V> BTreeMap<K, V> {\n     /// use std::collections::BTreeMap;\n     ///\n     /// let mut a = BTreeMap::new();\n-    /// a.insert(1u, \"a\");\n-    /// a.insert(2u, \"b\");\n+    /// a.insert(1, \"a\");\n+    /// a.insert(2, \"b\");\n     ///\n-    /// let keys: Vec<uint> = a.keys().cloned().collect();\n-    /// assert_eq!(keys, vec![1u,2,]);\n+    /// let keys: Vec<usize> = a.keys().cloned().collect();\n+    /// assert_eq!(keys, vec![1,2,]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn keys<'a>(&'a self) -> Keys<'a, K, V> {\n@@ -1308,8 +1286,8 @@ impl<K, V> BTreeMap<K, V> {\n     /// use std::collections::BTreeMap;\n     ///\n     /// let mut a = BTreeMap::new();\n-    /// a.insert(1u, \"a\");\n-    /// a.insert(2u, \"b\");\n+    /// a.insert(1, \"a\");\n+    /// a.insert(2, \"b\");\n     ///\n     /// let values: Vec<&str> = a.values().cloned().collect();\n     /// assert_eq!(values, vec![\"a\",\"b\"]);\n@@ -1331,11 +1309,11 @@ impl<K, V> BTreeMap<K, V> {\n     ///\n     /// let mut a = BTreeMap::new();\n     /// assert_eq!(a.len(), 0);\n-    /// a.insert(1u, \"a\");\n+    /// a.insert(1, \"a\");\n     /// assert_eq!(a.len(), 1);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> uint { self.length }\n+    pub fn len(&self) -> usize { self.length }\n \n     /// Return true if the map contains no elements.\n     ///\n@@ -1346,7 +1324,7 @@ impl<K, V> BTreeMap<K, V> {\n     ///\n     /// let mut a = BTreeMap::new();\n     /// assert!(a.is_empty());\n-    /// a.insert(1u, \"a\");\n+    /// a.insert(1, \"a\");\n     /// assert!(!a.is_empty());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1496,13 +1474,13 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// use std::collections::Bound::{Included, Unbounded};\n     ///\n     /// let mut map = BTreeMap::new();\n-    /// map.insert(3u, \"a\");\n-    /// map.insert(5u, \"b\");\n-    /// map.insert(8u, \"c\");\n+    /// map.insert(3, \"a\");\n+    /// map.insert(5, \"b\");\n+    /// map.insert(8, \"c\");\n     /// for (&key, &value) in map.range(Included(&4), Included(&8)) {\n     ///     println!(\"{}: {}\", key, value);\n     /// }\n-    /// assert_eq!(Some((&5u, &\"b\")), map.range(Included(&4), Unbounded).next());\n+    /// assert_eq!(Some((&5, &\"b\")), map.range(Included(&4), Unbounded).next());\n     /// ```\n     #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n@@ -1546,7 +1524,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// use std::collections::BTreeMap;\n     /// use std::collections::btree_map::Entry;\n     ///\n-    /// let mut count: BTreeMap<&str, uint> = BTreeMap::new();\n+    /// let mut count: BTreeMap<&str, usize> = BTreeMap::new();\n     ///\n     /// // count the number of occurrences of letters in the vec\n     /// for x in vec![\"a\",\"b\",\"a\",\"c\",\"a\",\"b\"].iter() {\n@@ -1561,12 +1539,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     ///     }\n     /// }\n     ///\n-    /// assert_eq!(count[\"a\"], 3u);\n+    /// assert_eq!(count[\"a\"], 3);\n     /// ```\n-    /// The key must have the same ordering before or after `.to_owned()` is called.\n-    #[unstable(feature = \"collections\",\n-               reason = \"precise API still under development\")]\n-    pub fn entry<'a>(&'a mut self, mut key: K) -> Entry<'a, K, V> {\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn entry(&mut self, mut key: K) -> Entry<K, V> {\n         // same basic logic of `swap` and `pop`, blended together\n         let mut stack = stack::PartialSearchStack::new(self);\n         loop {\n@@ -1616,13 +1592,14 @@ mod test {\n     use prelude::*;\n     use std::iter::range_inclusive;\n \n-    use super::{BTreeMap, Occupied, Vacant};\n+    use super::BTreeMap;\n+    use super::Entry::{Occupied, Vacant};\n     use Bound::{self, Included, Excluded, Unbounded};\n \n     #[test]\n     fn test_basic_large() {\n         let mut map = BTreeMap::new();\n-        let size = 10000u;\n+        let size = 10000;\n         assert_eq!(map.len(), 0);\n \n         for i in 0..size {\n@@ -1669,7 +1646,7 @@ mod test {\n         let mut map = BTreeMap::new();\n         assert_eq!(map.remove(&1), None);\n         assert_eq!(map.get(&1), None);\n-        assert_eq!(map.insert(1u, 1u), None);\n+        assert_eq!(map.insert(1, 1), None);\n         assert_eq!(map.get(&1), Some(&1));\n         assert_eq!(map.insert(1, 2), Some(1));\n         assert_eq!(map.get(&1), Some(&2));\n@@ -1682,12 +1659,12 @@ mod test {\n \n     #[test]\n     fn test_iter() {\n-        let size = 10000u;\n+        let size = 10000;\n \n         // Forwards\n-        let mut map: BTreeMap<uint, uint> = (0..size).map(|i| (i, i)).collect();\n+        let mut map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n \n-        fn test<T>(size: uint, mut iter: T) where T: Iterator<Item=(uint, uint)> {\n+        fn test<T>(size: usize, mut iter: T) where T: Iterator<Item=(usize, usize)> {\n             for i in 0..size {\n                 assert_eq!(iter.size_hint(), (size - i, Some(size - i)));\n                 assert_eq!(iter.next().unwrap(), (i, i));\n@@ -1702,12 +1679,12 @@ mod test {\n \n     #[test]\n     fn test_iter_rev() {\n-        let size = 10000u;\n+        let size = 10000;\n \n         // Forwards\n-        let mut map: BTreeMap<uint, uint> = (0..size).map(|i| (i, i)).collect();\n+        let mut map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n \n-        fn test<T>(size: uint, mut iter: T) where T: Iterator<Item=(uint, uint)> {\n+        fn test<T>(size: usize, mut iter: T) where T: Iterator<Item=(usize, usize)> {\n             for i in 0..size {\n                 assert_eq!(iter.size_hint(), (size - i, Some(size - i)));\n                 assert_eq!(iter.next().unwrap(), (size - i - 1, size - i - 1));\n@@ -1722,13 +1699,13 @@ mod test {\n \n     #[test]\n     fn test_iter_mixed() {\n-        let size = 10000u;\n+        let size = 10000;\n \n         // Forwards\n-        let mut map: BTreeMap<uint, uint> = (0..size).map(|i| (i, i)).collect();\n+        let mut map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n \n-        fn test<T>(size: uint, mut iter: T)\n-                where T: Iterator<Item=(uint, uint)> + DoubleEndedIterator {\n+        fn test<T>(size: usize, mut iter: T)\n+                where T: Iterator<Item=(usize, usize)> + DoubleEndedIterator {\n             for i in 0..size / 4 {\n                 assert_eq!(iter.size_hint(), (size - i * 2, Some(size - i * 2)));\n                 assert_eq!(iter.next().unwrap(), (i, i));\n@@ -1748,13 +1725,13 @@ mod test {\n \n     #[test]\n     fn test_range_small() {\n-        let size = 5u;\n+        let size = 5;\n \n         // Forwards\n-        let map: BTreeMap<uint, uint> = (0..size).map(|i| (i, i)).collect();\n+        let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n \n-        let mut j = 0u;\n-        for ((&k, &v), i) in map.range(Included(&2), Unbounded).zip(2u..size) {\n+        let mut j = 0;\n+        for ((&k, &v), i) in map.range(Included(&2), Unbounded).zip(2..size) {\n             assert_eq!(k, i);\n             assert_eq!(v, i);\n             j += 1;\n@@ -1764,10 +1741,10 @@ mod test {\n \n     #[test]\n     fn test_range_1000() {\n-        let size = 1000u;\n-        let map: BTreeMap<uint, uint> = (0..size).map(|i| (i, i)).collect();\n+        let size = 1000;\n+        let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n \n-        fn test(map: &BTreeMap<uint, uint>, size: uint, min: Bound<&uint>, max: Bound<&uint>) {\n+        fn test(map: &BTreeMap<u32, u32>, size: u32, min: Bound<&u32>, max: Bound<&u32>) {\n             let mut kvs = map.range(min, max).map(|(&k, &v)| (k, v));\n             let mut pairs = (0..size).map(|i| (i, i));\n \n@@ -1787,8 +1764,8 @@ mod test {\n \n     #[test]\n     fn test_range() {\n-        let size = 200u;\n-        let map: BTreeMap<uint, uint> = (0..size).map(|i| (i, i)).collect();\n+        let size = 200;\n+        let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n \n         for i in 0..size {\n             for j in i..size {\n@@ -1808,7 +1785,7 @@ mod test {\n     fn test_entry(){\n         let xs = [(1, 10), (2, 20), (3, 30), (4, 40), (5, 50), (6, 60)];\n \n-        let mut map: BTreeMap<int, int> = xs.iter().map(|&x| x).collect();\n+        let mut map: BTreeMap<_, _> = xs.iter().map(|&x| x).collect();\n \n         // Existing key (insert)\n         match map.entry(1) {\n@@ -1872,15 +1849,15 @@ mod bench {\n \n     #[bench]\n     pub fn insert_rand_100(b: &mut Bencher) {\n-        let mut m : BTreeMap<uint,uint> = BTreeMap::new();\n+        let mut m = BTreeMap::new();\n         insert_rand_n(100, &mut m, b,\n                       |m, i| { m.insert(i, 1); },\n                       |m, i| { m.remove(&i); });\n     }\n \n     #[bench]\n     pub fn insert_rand_10_000(b: &mut Bencher) {\n-        let mut m : BTreeMap<uint,uint> = BTreeMap::new();\n+        let mut m = BTreeMap::new();\n         insert_rand_n(10_000, &mut m, b,\n                       |m, i| { m.insert(i, 1); },\n                       |m, i| { m.remove(&i); });\n@@ -1889,15 +1866,15 @@ mod bench {\n     // Insert seq\n     #[bench]\n     pub fn insert_seq_100(b: &mut Bencher) {\n-        let mut m : BTreeMap<uint,uint> = BTreeMap::new();\n+        let mut m = BTreeMap::new();\n         insert_seq_n(100, &mut m, b,\n                      |m, i| { m.insert(i, 1); },\n                      |m, i| { m.remove(&i); });\n     }\n \n     #[bench]\n     pub fn insert_seq_10_000(b: &mut Bencher) {\n-        let mut m : BTreeMap<uint,uint> = BTreeMap::new();\n+        let mut m = BTreeMap::new();\n         insert_seq_n(10_000, &mut m, b,\n                      |m, i| { m.insert(i, 1); },\n                      |m, i| { m.remove(&i); });\n@@ -1906,15 +1883,15 @@ mod bench {\n     // Find rand\n     #[bench]\n     pub fn find_rand_100(b: &mut Bencher) {\n-        let mut m : BTreeMap<uint,uint> = BTreeMap::new();\n+        let mut m = BTreeMap::new();\n         find_rand_n(100, &mut m, b,\n                     |m, i| { m.insert(i, 1); },\n                     |m, i| { m.get(&i); });\n     }\n \n     #[bench]\n     pub fn find_rand_10_000(b: &mut Bencher) {\n-        let mut m : BTreeMap<uint,uint> = BTreeMap::new();\n+        let mut m = BTreeMap::new();\n         find_rand_n(10_000, &mut m, b,\n                     |m, i| { m.insert(i, 1); },\n                     |m, i| { m.get(&i); });\n@@ -1923,22 +1900,22 @@ mod bench {\n     // Find seq\n     #[bench]\n     pub fn find_seq_100(b: &mut Bencher) {\n-        let mut m : BTreeMap<uint,uint> = BTreeMap::new();\n+        let mut m = BTreeMap::new();\n         find_seq_n(100, &mut m, b,\n                    |m, i| { m.insert(i, 1); },\n                    |m, i| { m.get(&i); });\n     }\n \n     #[bench]\n     pub fn find_seq_10_000(b: &mut Bencher) {\n-        let mut m : BTreeMap<uint,uint> = BTreeMap::new();\n+        let mut m = BTreeMap::new();\n         find_seq_n(10_000, &mut m, b,\n                    |m, i| { m.insert(i, 1); },\n                    |m, i| { m.get(&i); });\n     }\n \n-    fn bench_iter(b: &mut Bencher, size: uint) {\n-        let mut map = BTreeMap::<uint, uint>::new();\n+    fn bench_iter(b: &mut Bencher, size: i32) {\n+        let mut map = BTreeMap::<i32, i32>::new();\n         let mut rng = weak_rng();\n \n         for _ in 0..size {"}, {"sha": "bfe74cc6fb46cfbfe12855ff343bf88e400bfd2d", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 62, "deletions": 62, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -65,7 +65,7 @@ pub struct Node<K, V> {\n     //\n     // Note: instead of accessing this field directly, please call the `len()` method, which should\n     // be more stable in the face of representation changes.\n-    _len: uint,\n+    _len: usize,\n \n     // FIXME(gereeter) It shouldn't be necessary to store the capacity in every node, as it should\n     // be constant throughout the tree. Once a solution to this is found, it might be possible to\n@@ -74,7 +74,7 @@ pub struct Node<K, V> {\n     //\n     // Note: instead of accessing this field directly, please call the `capacity()` method, which\n     // should be more stable in the face of representation changes.\n-    _capacity: uint,\n+    _capacity: usize,\n }\n \n struct NodeSlice<'a, K: 'a, V: 'a> {\n@@ -102,7 +102,7 @@ struct MutNodeSlice<'a, K: 'a, V: 'a> {\n ///\n /// Fails if `target_alignment` is not a power of two.\n #[inline]\n-fn round_up_to_next(unrounded: uint, target_alignment: uint) -> uint {\n+fn round_up_to_next(unrounded: usize, target_alignment: usize) -> usize {\n     assert!(num::UnsignedInt::is_power_of_two(target_alignment));\n     (unrounded + target_alignment - 1) & !(target_alignment - 1)\n }\n@@ -120,10 +120,10 @@ fn test_rounding() {\n // Returns a tuple of (val_offset, edge_offset),\n // from the start of a mallocated array.\n #[inline]\n-fn calculate_offsets(keys_size: uint,\n-                     vals_size: uint, vals_align: uint,\n-                     edges_align: uint)\n-                     -> (uint, uint) {\n+fn calculate_offsets(keys_size: usize,\n+                     vals_size: usize, vals_align: usize,\n+                     edges_align: usize)\n+                     -> (usize, usize) {\n     let vals_offset = round_up_to_next(keys_size, vals_align);\n     let end_of_vals = vals_offset + vals_size;\n \n@@ -135,10 +135,10 @@ fn calculate_offsets(keys_size: uint,\n // Returns a tuple of (minimum required alignment, array_size),\n // from the start of a mallocated array.\n #[inline]\n-fn calculate_allocation(keys_size: uint, keys_align: uint,\n-                        vals_size: uint, vals_align: uint,\n-                        edges_size: uint, edges_align: uint)\n-                        -> (uint, uint) {\n+fn calculate_allocation(keys_size: usize, keys_align: usize,\n+                        vals_size: usize, vals_align: usize,\n+                        edges_size: usize, edges_align: usize)\n+                        -> (usize, usize) {\n     let (_, edges_offset) = calculate_offsets(keys_size,\n                                               vals_size, vals_align,\n                                                          edges_align);\n@@ -159,7 +159,7 @@ fn test_offset_calculation() {\n     assert_eq!(calculate_offsets(6, 12, 4, 8), (8, 24));\n }\n \n-fn calculate_allocation_generic<K, V>(capacity: uint, is_leaf: bool) -> (uint, uint) {\n+fn calculate_allocation_generic<K, V>(capacity: usize, is_leaf: bool) -> (usize, usize) {\n     let (keys_size, keys_align) = (capacity * mem::size_of::<K>(), mem::min_align_of::<K>());\n     let (vals_size, vals_align) = (capacity * mem::size_of::<V>(), mem::min_align_of::<V>());\n     let (edges_size, edges_align) = if is_leaf {\n@@ -175,7 +175,7 @@ fn calculate_allocation_generic<K, V>(capacity: uint, is_leaf: bool) -> (uint, u\n     )\n }\n \n-fn calculate_offsets_generic<K, V>(capacity: uint, is_leaf: bool) -> (uint, uint) {\n+fn calculate_offsets_generic<K, V>(capacity: usize, is_leaf: bool) -> (usize, usize) {\n     let keys_size = capacity * mem::size_of::<K>();\n     let vals_size = capacity * mem::size_of::<V>();\n     let vals_align = mem::min_align_of::<V>();\n@@ -203,16 +203,16 @@ impl<T> RawItems<T> {\n         RawItems::from_parts(slice.as_ptr(), slice.len())\n     }\n \n-    unsafe fn from_parts(ptr: *const T, len: uint) -> RawItems<T> {\n+    unsafe fn from_parts(ptr: *const T, len: usize) -> RawItems<T> {\n         if mem::size_of::<T>() == 0 {\n             RawItems {\n                 head: ptr,\n-                tail: (ptr as uint + len) as *const T,\n+                tail: (ptr as usize + len) as *const T,\n             }\n         } else {\n             RawItems {\n                 head: ptr,\n-                tail: ptr.offset(len as int),\n+                tail: ptr.offset(len as isize),\n             }\n         }\n     }\n@@ -221,7 +221,7 @@ impl<T> RawItems<T> {\n         ptr::write(self.tail as *mut T, val);\n \n         if mem::size_of::<T>() == 0 {\n-            self.tail = (self.tail as uint + 1) as *const T;\n+            self.tail = (self.tail as usize + 1) as *const T;\n         } else {\n             self.tail = self.tail.offset(1);\n         }\n@@ -239,7 +239,7 @@ impl<T> Iterator for RawItems<T> {\n                 let ret = Some(ptr::read(self.head));\n \n                 if mem::size_of::<T>() == 0 {\n-                    self.head = (self.head as uint + 1) as *const T;\n+                    self.head = (self.head as usize + 1) as *const T;\n                 } else {\n                     self.head = self.head.offset(1);\n                 }\n@@ -257,7 +257,7 @@ impl<T> DoubleEndedIterator for RawItems<T> {\n         } else {\n             unsafe {\n                 if mem::size_of::<T>() == 0 {\n-                    self.tail = (self.tail as uint - 1) as *const T;\n+                    self.tail = (self.tail as usize - 1) as *const T;\n                 } else {\n                     self.tail = self.tail.offset(-1);\n                 }\n@@ -299,7 +299,7 @@ impl<K, V> Drop for Node<K, V> {\n impl<K, V> Node<K, V> {\n     /// Make a new internal node. The caller must initialize the result to fix the invariant that\n     /// there are `len() + 1` edges.\n-    unsafe fn new_internal(capacity: uint) -> Node<K, V> {\n+    unsafe fn new_internal(capacity: usize) -> Node<K, V> {\n         let (alignment, size) = calculate_allocation_generic::<K, V>(capacity, false);\n \n         let buffer = heap::allocate(size, alignment);\n@@ -309,15 +309,15 @@ impl<K, V> Node<K, V> {\n \n         Node {\n             keys: Unique(buffer as *mut K),\n-            vals: Unique(buffer.offset(vals_offset as int) as *mut V),\n-            edges: Unique(buffer.offset(edges_offset as int) as *mut Node<K, V>),\n+            vals: Unique(buffer.offset(vals_offset as isize) as *mut V),\n+            edges: Unique(buffer.offset(edges_offset as isize) as *mut Node<K, V>),\n             _len: 0,\n             _capacity: capacity,\n         }\n     }\n \n     /// Make a new leaf node\n-    fn new_leaf(capacity: uint) -> Node<K, V> {\n+    fn new_leaf(capacity: usize) -> Node<K, V> {\n         let (alignment, size) = calculate_allocation_generic::<K, V>(capacity, true);\n \n         let buffer = unsafe { heap::allocate(size, alignment) };\n@@ -327,7 +327,7 @@ impl<K, V> Node<K, V> {\n \n         Node {\n             keys: Unique(buffer as *mut K),\n-            vals: Unique(unsafe { buffer.offset(vals_offset as int) as *mut V }),\n+            vals: Unique(unsafe { buffer.offset(vals_offset as isize) as *mut V }),\n             edges: Unique(ptr::null_mut()),\n             _len: 0,\n             _capacity: capacity,\n@@ -479,15 +479,15 @@ impl<K: Clone, V: Clone> Clone for Node<K, V> {\n ///\n /// ```rust,ignore\n /// struct Nasty<'a> {\n-///     first: &'a Node<uint, uint>,\n-///     second: &'a Node<uint, uint>,\n+///     first: &'a Node<usize, usize>,\n+///     second: &'a Node<usize, usize>,\n ///     flag: &'a Cell<bool>,\n /// }\n ///\n /// impl<'a> Deref for Nasty<'a> {\n-///     type Target = Node<uint, uint>;\n+///     type Target = Node<usize, usize>;\n ///\n-///     fn deref(&self) -> &Node<uint, uint> {\n+///     fn deref(&self) -> &Node<usize, usize> {\n ///         if self.flag.get() {\n ///             &*self.second\n ///         } else {\n@@ -524,7 +524,7 @@ impl<K: Clone, V: Clone> Clone for Node<K, V> {\n #[derive(Copy)]\n pub struct Handle<NodeRef, Type, NodeType> {\n     node: NodeRef,\n-    index: uint\n+    index: usize\n }\n \n pub mod handle {\n@@ -546,7 +546,7 @@ impl<K: Ord, V> Node<K, V> {\n                   -> SearchResult<NodeRef> where Q: BorrowFrom<K> + Ord {\n         // FIXME(Gankro): Tune when to search linear or binary based on B (and maybe K/V).\n         // For the B configured as of this writing (B = 6), binary search was *significantly*\n-        // worse for uints.\n+        // worse for usizes.\n         match node.as_slices_internal().search_linear(key) {\n             (index, true) => Found(Handle { node: node, index: index }),\n             (index, false) => GoDown(Handle { node: node, index: index }),\n@@ -557,12 +557,12 @@ impl<K: Ord, V> Node<K, V> {\n // Public interface\n impl <K, V> Node<K, V> {\n     /// Make a leaf root from scratch\n-    pub fn make_leaf_root(b: uint) -> Node<K, V> {\n+    pub fn make_leaf_root(b: usize) -> Node<K, V> {\n         Node::new_leaf(capacity_from_b(b))\n     }\n \n     /// Make an internal root and swap it with an old root\n-    pub fn make_internal_root(left_and_out: &mut Node<K,V>, b: uint, key: K, value: V,\n+    pub fn make_internal_root(left_and_out: &mut Node<K,V>, b: usize, key: K, value: V,\n             right: Node<K,V>) {\n         let node = mem::replace(left_and_out, unsafe { Node::new_internal(capacity_from_b(b)) });\n         left_and_out._len = 1;\n@@ -575,12 +575,12 @@ impl <K, V> Node<K, V> {\n     }\n \n     /// How many key-value pairs the node contains\n-    pub fn len(&self) -> uint {\n+    pub fn len(&self) -> usize {\n         self._len\n     }\n \n     /// How many key-value pairs the node can fit\n-    pub fn capacity(&self) -> uint {\n+    pub fn capacity(&self) -> usize {\n         self._capacity\n     }\n \n@@ -669,7 +669,7 @@ impl<'a, K: 'a, V: 'a> Handle<&'a mut Node<K, V>, handle::Edge, handle::Internal\n \n impl<K, V, NodeRef: Deref<Target=Node<K, V>>> Handle<NodeRef, handle::Edge, handle::Internal> {\n     // This doesn't exist because there are no uses for it,\n-    // but is fine to add, analagous to edge_mut.\n+    // but is fine to add, analogous to edge_mut.\n     //\n     // /// Returns a reference to the edge pointed-to by this handle. This should not be\n     // /// confused with `node`, which references the parent node of what is returned here.\n@@ -1038,7 +1038,7 @@ impl<K, V> Node<K, V> {\n     /// # Panics (in debug build)\n     ///\n     /// Panics if the given index is out of bounds.\n-    pub fn kv_handle(&mut self, index: uint) -> Handle<&mut Node<K, V>, handle::KV,\n+    pub fn kv_handle(&mut self, index: usize) -> Handle<&mut Node<K, V>, handle::KV,\n                                                        handle::LeafOrInternal> {\n         // Necessary for correctness, but in a private module\n         debug_assert!(index < self.len(), \"kv_handle index out of bounds\");\n@@ -1114,15 +1114,15 @@ impl<K, V> Node<K, V> {\n \n     // This must be followed by insert_edge on an internal node.\n     #[inline]\n-    unsafe fn insert_kv(&mut self, index: uint, key: K, val: V) -> &mut V {\n+    unsafe fn insert_kv(&mut self, index: usize, key: K, val: V) -> &mut V {\n         ptr::copy_memory(\n-            self.keys_mut().as_mut_ptr().offset(index as int + 1),\n-            self.keys().as_ptr().offset(index as int),\n+            self.keys_mut().as_mut_ptr().offset(index as isize + 1),\n+            self.keys().as_ptr().offset(index as isize),\n             self.len() - index\n         );\n         ptr::copy_memory(\n-            self.vals_mut().as_mut_ptr().offset(index as int + 1),\n-            self.vals().as_ptr().offset(index as int),\n+            self.vals_mut().as_mut_ptr().offset(index as isize + 1),\n+            self.vals().as_ptr().offset(index as isize),\n             self.len() - index\n         );\n \n@@ -1136,10 +1136,10 @@ impl<K, V> Node<K, V> {\n \n     // This can only be called immediately after a call to insert_kv.\n     #[inline]\n-    unsafe fn insert_edge(&mut self, index: uint, edge: Node<K, V>) {\n+    unsafe fn insert_edge(&mut self, index: usize, edge: Node<K, V>) {\n         ptr::copy_memory(\n-            self.edges_mut().as_mut_ptr().offset(index as int + 1),\n-            self.edges().as_ptr().offset(index as int),\n+            self.edges_mut().as_mut_ptr().offset(index as isize + 1),\n+            self.edges().as_ptr().offset(index as isize),\n             self.len() - index\n         );\n         ptr::write(self.edges_mut().get_unchecked_mut(index), edge);\n@@ -1166,18 +1166,18 @@ impl<K, V> Node<K, V> {\n \n     // This must be followed by remove_edge on an internal node.\n     #[inline]\n-    unsafe fn remove_kv(&mut self, index: uint) -> (K, V) {\n+    unsafe fn remove_kv(&mut self, index: usize) -> (K, V) {\n         let key = ptr::read(self.keys().get_unchecked(index));\n         let val = ptr::read(self.vals().get_unchecked(index));\n \n         ptr::copy_memory(\n-            self.keys_mut().as_mut_ptr().offset(index as int),\n-            self.keys().as_ptr().offset(index as int + 1),\n+            self.keys_mut().as_mut_ptr().offset(index as isize),\n+            self.keys().as_ptr().offset(index as isize + 1),\n             self.len() - index - 1\n         );\n         ptr::copy_memory(\n-            self.vals_mut().as_mut_ptr().offset(index as int),\n-            self.vals().as_ptr().offset(index as int + 1),\n+            self.vals_mut().as_mut_ptr().offset(index as isize),\n+            self.vals().as_ptr().offset(index as isize + 1),\n             self.len() - index - 1\n         );\n \n@@ -1188,12 +1188,12 @@ impl<K, V> Node<K, V> {\n \n     // This can only be called immediately after a call to remove_kv.\n     #[inline]\n-    unsafe fn remove_edge(&mut self, index: uint) -> Node<K, V> {\n+    unsafe fn remove_edge(&mut self, index: usize) -> Node<K, V> {\n         let edge = ptr::read(self.edges().get_unchecked(index));\n \n         ptr::copy_memory(\n-            self.edges_mut().as_mut_ptr().offset(index as int),\n-            self.edges().as_ptr().offset(index as int + 1),\n+            self.edges_mut().as_mut_ptr().offset(index as isize),\n+            self.edges().as_ptr().offset(index as isize + 1),\n             self.len() - index + 1\n         );\n \n@@ -1220,18 +1220,18 @@ impl<K, V> Node<K, V> {\n             let right_offset = self.len() - right.len();\n             ptr::copy_nonoverlapping_memory(\n                 right.keys_mut().as_mut_ptr(),\n-                self.keys().as_ptr().offset(right_offset as int),\n+                self.keys().as_ptr().offset(right_offset as isize),\n                 right.len()\n             );\n             ptr::copy_nonoverlapping_memory(\n                 right.vals_mut().as_mut_ptr(),\n-                self.vals().as_ptr().offset(right_offset as int),\n+                self.vals().as_ptr().offset(right_offset as isize),\n                 right.len()\n             );\n             if !self.is_leaf() {\n                 ptr::copy_nonoverlapping_memory(\n                     right.edges_mut().as_mut_ptr(),\n-                    self.edges().as_ptr().offset(right_offset as int),\n+                    self.edges().as_ptr().offset(right_offset as isize),\n                     right.len() + 1\n                 );\n             }\n@@ -1260,18 +1260,18 @@ impl<K, V> Node<K, V> {\n             ptr::write(self.vals_mut().get_unchecked_mut(old_len), val);\n \n             ptr::copy_nonoverlapping_memory(\n-                self.keys_mut().as_mut_ptr().offset(old_len as int + 1),\n+                self.keys_mut().as_mut_ptr().offset(old_len as isize + 1),\n                 right.keys().as_ptr(),\n                 right.len()\n             );\n             ptr::copy_nonoverlapping_memory(\n-                self.vals_mut().as_mut_ptr().offset(old_len as int + 1),\n+                self.vals_mut().as_mut_ptr().offset(old_len as isize + 1),\n                 right.vals().as_ptr(),\n                 right.len()\n             );\n             if !self.is_leaf() {\n                 ptr::copy_nonoverlapping_memory(\n-                    self.edges_mut().as_mut_ptr().offset(old_len as int + 1),\n+                    self.edges_mut().as_mut_ptr().offset(old_len as isize + 1),\n                     right.edges().as_ptr(),\n                     right.len() + 1\n                 );\n@@ -1284,12 +1284,12 @@ impl<K, V> Node<K, V> {\n }\n \n /// Get the capacity of a node from the order of the parent B-Tree\n-fn capacity_from_b(b: uint) -> uint {\n+fn capacity_from_b(b: usize) -> usize {\n     2 * b - 1\n }\n \n /// Get the minimum load of a node from its capacity\n-fn min_load_from_capacity(cap: uint) -> uint {\n+fn min_load_from_capacity(cap: usize) -> usize {\n     // B - 1\n     cap / 2\n }\n@@ -1334,7 +1334,7 @@ struct MoveTraversalImpl<K, V> {\n \n     // For deallocation when we are done iterating.\n     ptr: *mut u8,\n-    capacity: uint,\n+    capacity: usize,\n     is_leaf: bool\n }\n \n@@ -1490,7 +1490,7 @@ macro_rules! node_slice_impl {\n      $as_slices_internal:ident, $index:ident, $iter:ident) => {\n         impl<'a, K: Ord + 'a, V: 'a> $NodeSlice<'a, K, V> {\n             /// Performs linear search in a slice. Returns a tuple of (index, is_exact_match).\n-            fn search_linear<Q: ?Sized>(&self, key: &Q) -> (uint, bool)\n+            fn search_linear<Q: ?Sized>(&self, key: &Q) -> (usize, bool)\n                     where Q: BorrowFrom<K> + Ord {\n                 for (i, k) in self.keys.iter().enumerate() {\n                     match key.cmp(BorrowFrom::borrow_from(k)) {"}, {"sha": "c888a261f9d21851e426c654c687eca504b0a283", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 57, "deletions": 59, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -101,7 +101,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// B cannot be less than 2.\n     #[unstable(feature = \"collections\",\n                reason = \"probably want this to be on the type, eventually\")]\n-    pub fn with_b(b: uint) -> BTreeSet<T> {\n+    pub fn with_b(b: usize) -> BTreeSet<T> {\n         BTreeSet { map: BTreeMap::with_b(b) }\n     }\n }\n@@ -114,14 +114,14 @@ impl<T> BTreeSet<T> {\n     /// ```\n     /// use std::collections::BTreeSet;\n     ///\n-    /// let set: BTreeSet<uint> = [1u, 2, 3, 4].iter().map(|&x| x).collect();\n+    /// let set: BTreeSet<usize> = [1, 2, 3, 4].iter().map(|&x| x).collect();\n     ///\n     /// for x in set.iter() {\n     ///     println!(\"{}\", x);\n     /// }\n     ///\n-    /// let v: Vec<uint> = set.iter().map(|&x| x).collect();\n-    /// assert_eq!(v, vec![1u,2,3,4]);\n+    /// let v: Vec<usize> = set.iter().map(|&x| x).collect();\n+    /// assert_eq!(v, vec![1,2,3,4]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<T> {\n@@ -135,10 +135,10 @@ impl<T> BTreeSet<T> {\n     /// ```\n     /// use std::collections::BTreeSet;\n     ///\n-    /// let set: BTreeSet<uint> = [1u, 2, 3, 4].iter().map(|&x| x).collect();\n+    /// let set: BTreeSet<usize> = [1, 2, 3, 4].iter().map(|&x| x).collect();\n     ///\n-    /// let v: Vec<uint> = set.into_iter().collect();\n-    /// assert_eq!(v, vec![1u,2,3,4]);\n+    /// let v: Vec<usize> = set.into_iter().collect();\n+    /// assert_eq!(v, vec![1,2,3,4]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<T> {\n@@ -162,13 +162,13 @@ impl<T: Ord> BTreeSet<T> {\n     /// use std::collections::Bound::{Included, Unbounded};\n     ///\n     /// let mut set = BTreeSet::new();\n-    /// set.insert(3u);\n-    /// set.insert(5u);\n-    /// set.insert(8u);\n+    /// set.insert(3);\n+    /// set.insert(5);\n+    /// set.insert(8);\n     /// for &elem in set.range(Included(&4), Included(&8)) {\n     ///     println!(\"{}\", elem);\n     /// }\n-    /// assert_eq!(Some(&5u), set.range(Included(&4), Unbounded).next());\n+    /// assert_eq!(Some(&5), set.range(Included(&4), Unbounded).next());\n     /// ```\n     #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n@@ -189,15 +189,15 @@ impl<T: Ord> BTreeSet<T> {\n     /// use std::collections::BTreeSet;\n     ///\n     /// let mut a = BTreeSet::new();\n-    /// a.insert(1u);\n-    /// a.insert(2u);\n+    /// a.insert(1);\n+    /// a.insert(2);\n     ///\n     /// let mut b = BTreeSet::new();\n-    /// b.insert(2u);\n-    /// b.insert(3u);\n+    /// b.insert(2);\n+    /// b.insert(3);\n     ///\n-    /// let diff: Vec<uint> = a.difference(&b).cloned().collect();\n-    /// assert_eq!(diff, vec![1u]);\n+    /// let diff: Vec<usize> = a.difference(&b).cloned().collect();\n+    /// assert_eq!(diff, vec![1]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn difference<'a>(&'a self, other: &'a BTreeSet<T>) -> Difference<'a, T> {\n@@ -212,15 +212,15 @@ impl<T: Ord> BTreeSet<T> {\n     /// use std::collections::BTreeSet;\n     ///\n     /// let mut a = BTreeSet::new();\n-    /// a.insert(1u);\n-    /// a.insert(2u);\n+    /// a.insert(1);\n+    /// a.insert(2);\n     ///\n     /// let mut b = BTreeSet::new();\n-    /// b.insert(2u);\n-    /// b.insert(3u);\n+    /// b.insert(2);\n+    /// b.insert(3);\n     ///\n-    /// let sym_diff: Vec<uint> = a.symmetric_difference(&b).cloned().collect();\n-    /// assert_eq!(sym_diff, vec![1u,3]);\n+    /// let sym_diff: Vec<usize> = a.symmetric_difference(&b).cloned().collect();\n+    /// assert_eq!(sym_diff, vec![1,3]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn symmetric_difference<'a>(&'a self, other: &'a BTreeSet<T>)\n@@ -236,15 +236,15 @@ impl<T: Ord> BTreeSet<T> {\n     /// use std::collections::BTreeSet;\n     ///\n     /// let mut a = BTreeSet::new();\n-    /// a.insert(1u);\n-    /// a.insert(2u);\n+    /// a.insert(1);\n+    /// a.insert(2);\n     ///\n     /// let mut b = BTreeSet::new();\n-    /// b.insert(2u);\n-    /// b.insert(3u);\n+    /// b.insert(2);\n+    /// b.insert(3);\n     ///\n-    /// let intersection: Vec<uint> = a.intersection(&b).cloned().collect();\n-    /// assert_eq!(intersection, vec![2u]);\n+    /// let intersection: Vec<usize> = a.intersection(&b).cloned().collect();\n+    /// assert_eq!(intersection, vec![2]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn intersection<'a>(&'a self, other: &'a BTreeSet<T>)\n@@ -260,13 +260,13 @@ impl<T: Ord> BTreeSet<T> {\n     /// use std::collections::BTreeSet;\n     ///\n     /// let mut a = BTreeSet::new();\n-    /// a.insert(1u);\n+    /// a.insert(1);\n     ///\n     /// let mut b = BTreeSet::new();\n-    /// b.insert(2u);\n+    /// b.insert(2);\n     ///\n-    /// let union: Vec<uint> = a.union(&b).cloned().collect();\n-    /// assert_eq!(union, vec![1u,2]);\n+    /// let union: Vec<usize> = a.union(&b).cloned().collect();\n+    /// assert_eq!(union, vec![1,2]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn union<'a>(&'a self, other: &'a BTreeSet<T>) -> Union<'a, T> {\n@@ -286,7 +286,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(v.len(), 1);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> uint { self.map.len() }\n+    pub fn len(&self) -> usize { self.map.len() }\n \n     /// Returns true if the set contains no elements\n     ///\n@@ -625,7 +625,7 @@ impl<'a, T> Iterator for Iter<'a, T> {\n     type Item = &'a T;\n \n     fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n-    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n@@ -640,7 +640,7 @@ impl<T> Iterator for IntoIter<T> {\n     type Item = T;\n \n     fn next(&mut self) -> Option<T> { self.iter.next() }\n-    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> DoubleEndedIterator for IntoIter<T> {\n@@ -770,23 +770,23 @@ mod test {\n     }\n \n     struct Counter<'a, 'b> {\n-        i: &'a mut uint,\n-        expected: &'b [int],\n+        i: &'a mut usize,\n+        expected: &'b [i32],\n     }\n \n-    impl<'a, 'b, 'c> FnMut<(&'c int,)> for Counter<'a, 'b> {\n+    impl<'a, 'b, 'c> FnMut<(&'c i32,)> for Counter<'a, 'b> {\n         type Output = bool;\n \n-        extern \"rust-call\" fn call_mut(&mut self, (&x,): (&'c int,)) -> bool {\n+        extern \"rust-call\" fn call_mut(&mut self, (&x,): (&'c i32,)) -> bool {\n             assert_eq!(x, self.expected[*self.i]);\n             *self.i += 1;\n             true\n         }\n     }\n \n-    fn check<F>(a: &[int], b: &[int], expected: &[int], f: F) where\n+    fn check<F>(a: &[i32], b: &[i32], expected: &[i32], f: F) where\n         // FIXME Replace Counter with `Box<FnMut(_) -> _>`\n-        F: FnOnce(&BTreeSet<int>, &BTreeSet<int>, Counter) -> bool,\n+        F: FnOnce(&BTreeSet<i32>, &BTreeSet<i32>, Counter) -> bool,\n     {\n         let mut set_a = BTreeSet::new();\n         let mut set_b = BTreeSet::new();\n@@ -801,7 +801,7 @@ mod test {\n \n     #[test]\n     fn test_intersection() {\n-        fn check_intersection(a: &[int], b: &[int], expected: &[int]) {\n+        fn check_intersection(a: &[i32], b: &[i32], expected: &[i32]) {\n             check(a, b, expected, |x, y, f| x.intersection(y).all(f))\n         }\n \n@@ -817,7 +817,7 @@ mod test {\n \n     #[test]\n     fn test_difference() {\n-        fn check_difference(a: &[int], b: &[int], expected: &[int]) {\n+        fn check_difference(a: &[i32], b: &[i32], expected: &[i32]) {\n             check(a, b, expected, |x, y, f| x.difference(y).all(f))\n         }\n \n@@ -834,8 +834,7 @@ mod test {\n \n     #[test]\n     fn test_symmetric_difference() {\n-        fn check_symmetric_difference(a: &[int], b: &[int],\n-                                      expected: &[int]) {\n+        fn check_symmetric_difference(a: &[i32], b: &[i32], expected: &[i32]) {\n             check(a, b, expected, |x, y, f| x.symmetric_difference(y).all(f))\n         }\n \n@@ -849,8 +848,7 @@ mod test {\n \n     #[test]\n     fn test_union() {\n-        fn check_union(a: &[int], b: &[int],\n-                                      expected: &[int]) {\n+        fn check_union(a: &[i32], b: &[i32], expected: &[i32]) {\n             check(a, b, expected, |x, y, f| x.union(y).all(f))\n         }\n \n@@ -865,9 +863,9 @@ mod test {\n     #[test]\n     fn test_zip() {\n         let mut x = BTreeSet::new();\n-        x.insert(5u);\n-        x.insert(12u);\n-        x.insert(11u);\n+        x.insert(5);\n+        x.insert(12);\n+        x.insert(11);\n \n         let mut y = BTreeSet::new();\n         y.insert(\"foo\");\n@@ -878,21 +876,21 @@ mod test {\n         let mut z = x.iter().zip(y.iter());\n \n         // FIXME: #5801: this needs a type hint to compile...\n-        let result: Option<(&uint, & &'static str)> = z.next();\n-        assert_eq!(result.unwrap(), (&5u, &(\"bar\")));\n+        let result: Option<(&usize, & &'static str)> = z.next();\n+        assert_eq!(result.unwrap(), (&5, &(\"bar\")));\n \n-        let result: Option<(&uint, & &'static str)> = z.next();\n-        assert_eq!(result.unwrap(), (&11u, &(\"foo\")));\n+        let result: Option<(&usize, & &'static str)> = z.next();\n+        assert_eq!(result.unwrap(), (&11, &(\"foo\")));\n \n-        let result: Option<(&uint, & &'static str)> = z.next();\n+        let result: Option<(&usize, & &'static str)> = z.next();\n         assert!(result.is_none());\n     }\n \n     #[test]\n     fn test_from_iter() {\n         let xs = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n \n-        let set: BTreeSet<int> = xs.iter().map(|&x| x).collect();\n+        let set: BTreeSet<_> = xs.iter().cloned().collect();\n \n         for x in &xs {\n             assert!(set.contains(x));\n@@ -901,8 +899,8 @@ mod test {\n \n     #[test]\n     fn test_show() {\n-        let mut set: BTreeSet<int> = BTreeSet::new();\n-        let empty: BTreeSet<int> = BTreeSet::new();\n+        let mut set = BTreeSet::new();\n+        let empty = BTreeSet::<i32>::new();\n \n         set.insert(1);\n         set.insert(2);"}, {"sha": "748230c5d24cf9765a1dc9ba12fe5c0b64c0ab92", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 36, "deletions": 38, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -35,7 +35,7 @@ use core::ptr;\n /// A doubly-linked list.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct DList<T> {\n-    length: uint,\n+    length: usize,\n     list_head: Link<T>,\n     list_tail: Rawlink<Node<T>>,\n }\n@@ -61,7 +61,7 @@ struct Node<T> {\n pub struct Iter<'a, T:'a> {\n     head: &'a Link<T>,\n     tail: Rawlink<Node<T>>,\n-    nelem: uint,\n+    nelem: usize,\n }\n \n // FIXME #19839: deriving is too aggressive on the bounds (T doesn't need to be Clone).\n@@ -82,7 +82,7 @@ pub struct IterMut<'a, T:'a> {\n     list: &'a mut DList<T>,\n     head: Rawlink<Node<T>>,\n     tail: Rawlink<Node<T>>,\n-    nelem: uint,\n+    nelem: usize,\n }\n \n /// An iterator over mutable references to the items of a `DList`.\n@@ -345,7 +345,7 @@ impl<T> DList<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> uint {\n+    pub fn len(&self) -> usize {\n         self.length\n     }\n \n@@ -578,7 +578,7 @@ impl<T> DList<T> {\n     /// assert_eq!(splitted.pop_front(), None);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn split_off(&mut self, at: uint) -> DList<T> {\n+    pub fn split_off(&mut self, at: usize) -> DList<T> {\n         let len = self.len();\n         assert!(at < len, \"Cannot split off at a nonexistent index\");\n         if at == 0 {\n@@ -659,7 +659,7 @@ impl<'a, A> Iterator for Iter<'a, A> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         (self.nelem, Some(self.nelem))\n     }\n }\n@@ -701,7 +701,7 @@ impl<'a, A> Iterator for IterMut<'a, A> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         (self.nelem, Some(self.nelem))\n     }\n }\n@@ -810,7 +810,7 @@ impl<A> Iterator for IntoIter<A> {\n     fn next(&mut self) -> Option<A> { self.list.pop_front() }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         (self.list.length, Some(self.list.length))\n     }\n }\n@@ -935,11 +935,11 @@ mod tests {\n     use super::{DList, Node};\n \n     pub fn check_links<T>(list: &DList<T>) {\n-        let mut len = 0u;\n+        let mut len = 0;\n         let mut last_ptr: Option<&Node<T>> = None;\n         let mut node_ptr: &Node<T>;\n         match list.list_head {\n-            None => { assert_eq!(0u, list.length); return }\n+            None => { assert_eq!(0, list.length); return }\n             Some(ref node) => node_ptr = &**node,\n         }\n         loop {\n@@ -968,7 +968,7 @@ mod tests {\n \n     #[test]\n     fn test_basic() {\n-        let mut m: DList<Box<int>> = DList::new();\n+        let mut m = DList::new();\n         assert_eq!(m.pop_front(), None);\n         assert_eq!(m.pop_back(), None);\n         assert_eq!(m.pop_front(), None);\n@@ -1007,7 +1007,7 @@ mod tests {\n     }\n \n     #[cfg(test)]\n-    fn generate_test() -> DList<int> {\n+    fn generate_test() -> DList<i32> {\n         list_from(&[0,1,2,3,4,5,6])\n     }\n \n@@ -1020,7 +1020,7 @@ mod tests {\n     fn test_append() {\n         // Empty to empty\n         {\n-            let mut m: DList<int> = DList::new();\n+            let mut m = DList::<i32>::new();\n             let mut n = DList::new();\n             m.append(&mut n);\n             check_links(&m);\n@@ -1122,7 +1122,7 @@ mod tests {\n     fn test_iterator() {\n         let m = generate_test();\n         for (i, elt) in m.iter().enumerate() {\n-            assert_eq!(i as int, *elt);\n+            assert_eq!(i as i32, *elt);\n         }\n         let mut n = DList::new();\n         assert_eq!(n.iter().next(), None);\n@@ -1170,7 +1170,7 @@ mod tests {\n     fn test_rev_iter() {\n         let m = generate_test();\n         for (i, elt) in m.iter().rev().enumerate() {\n-            assert_eq!((6 - i) as int, *elt);\n+            assert_eq!((6 - i) as i32, *elt);\n         }\n         let mut n = DList::new();\n         assert_eq!(n.iter().rev().next(), None);\n@@ -1187,7 +1187,7 @@ mod tests {\n         let mut m = generate_test();\n         let mut len = m.len();\n         for (i, elt) in m.iter_mut().enumerate() {\n-            assert_eq!(i as int, *elt);\n+            assert_eq!(i as i32, *elt);\n             len -= 1;\n         }\n         assert_eq!(len, 0);\n@@ -1245,14 +1245,14 @@ mod tests {\n         }\n         check_links(&m);\n         assert_eq!(m.len(), 3 + len * 2);\n-        assert_eq!(m.into_iter().collect::<Vec<int>>(), vec![-2,0,1,2,3,4,5,6,7,8,9,0,1]);\n+        assert_eq!(m.into_iter().collect::<Vec<_>>(), vec![-2,0,1,2,3,4,5,6,7,8,9,0,1]);\n     }\n \n     #[test]\n     fn test_mut_rev_iter() {\n         let mut m = generate_test();\n         for (i, elt) in m.iter_mut().rev().enumerate() {\n-            assert_eq!((6-i) as int, *elt);\n+            assert_eq!((6 - i) as i32, *elt);\n         }\n         let mut n = DList::new();\n         assert!(n.iter_mut().rev().next().is_none());\n@@ -1268,13 +1268,13 @@ mod tests {\n         Thread::scoped(move || {\n             check_links(&n);\n             let a: &[_] = &[&1,&2,&3];\n-            assert_eq!(a, n.iter().collect::<Vec<&int>>());\n+            assert_eq!(a, n.iter().collect::<Vec<_>>());\n         }).join().ok().unwrap();\n     }\n \n     #[test]\n     fn test_eq() {\n-        let mut n: DList<u8> = list_from(&[]);\n+        let mut n = list_from(&[]);\n         let mut m = list_from(&[]);\n         assert!(n == m);\n         n.push_front(1);\n@@ -1307,7 +1307,7 @@ mod tests {\n \n     #[test]\n     fn test_ord() {\n-        let n: DList<int> = list_from(&[]);\n+        let n = list_from(&[]);\n         let m = list_from(&[1,2,3]);\n         assert!(n < m);\n         assert!(m > n);\n@@ -1349,7 +1349,7 @@ mod tests {\n \n     #[test]\n     fn test_fuzz() {\n-        for _ in 0u..25 {\n+        for _ in 0..25 {\n             fuzz_test(3);\n             fuzz_test(16);\n             fuzz_test(189);\n@@ -1358,18 +1358,16 @@ mod tests {\n \n     #[test]\n     fn test_show() {\n-        let list: DList<i32> = (0..10).collect();\n+        let list: DList<_> = (0..10).collect();\n         assert_eq!(format!(\"{:?}\", list), \"DList [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n \n-        let list: DList<&str> = vec![\"just\", \"one\", \"test\", \"more\"].iter()\n-                                                                   .map(|&s| s)\n-                                                                   .collect();\n+        let list: DList<_> = vec![\"just\", \"one\", \"test\", \"more\"].iter().cloned().collect();\n         assert_eq!(format!(\"{:?}\", list), \"DList [\\\"just\\\", \\\"one\\\", \\\"test\\\", \\\"more\\\"]\");\n     }\n \n     #[cfg(test)]\n-    fn fuzz_test(sz: int) {\n-        let mut m: DList<int> = DList::new();\n+    fn fuzz_test(sz: i32) {\n+        let mut m: DList<_> = DList::new();\n         let mut v = vec![];\n         for i in 0..sz {\n             check_links(&m);\n@@ -1398,7 +1396,7 @@ mod tests {\n \n         check_links(&m);\n \n-        let mut i = 0u;\n+        let mut i = 0;\n         for (a, &b) in m.into_iter().zip(v.iter()) {\n             i += 1;\n             assert_eq!(a, b);\n@@ -1410,29 +1408,29 @@ mod tests {\n     fn bench_collect_into(b: &mut test::Bencher) {\n         let v = &[0; 64];\n         b.iter(|| {\n-            let _: DList<int> = v.iter().map(|x| *x).collect();\n+            let _: DList<_> = v.iter().cloned().collect();\n         })\n     }\n \n     #[bench]\n     fn bench_push_front(b: &mut test::Bencher) {\n-        let mut m: DList<int> = DList::new();\n+        let mut m: DList<_> = DList::new();\n         b.iter(|| {\n             m.push_front(0);\n         })\n     }\n \n     #[bench]\n     fn bench_push_back(b: &mut test::Bencher) {\n-        let mut m: DList<int> = DList::new();\n+        let mut m: DList<_> = DList::new();\n         b.iter(|| {\n             m.push_back(0);\n         })\n     }\n \n     #[bench]\n     fn bench_push_back_pop_back(b: &mut test::Bencher) {\n-        let mut m: DList<int> = DList::new();\n+        let mut m: DList<_> = DList::new();\n         b.iter(|| {\n             m.push_back(0);\n             m.pop_back();\n@@ -1441,7 +1439,7 @@ mod tests {\n \n     #[bench]\n     fn bench_push_front_pop_front(b: &mut test::Bencher) {\n-        let mut m: DList<int> = DList::new();\n+        let mut m: DList<_> = DList::new();\n         b.iter(|| {\n             m.push_front(0);\n             m.pop_front();\n@@ -1451,31 +1449,31 @@ mod tests {\n     #[bench]\n     fn bench_iter(b: &mut test::Bencher) {\n         let v = &[0; 128];\n-        let m: DList<int> = v.iter().map(|&x|x).collect();\n+        let m: DList<_> = v.iter().cloned().collect();\n         b.iter(|| {\n             assert!(m.iter().count() == 128);\n         })\n     }\n     #[bench]\n     fn bench_iter_mut(b: &mut test::Bencher) {\n         let v = &[0; 128];\n-        let mut m: DList<int> = v.iter().map(|&x|x).collect();\n+        let mut m: DList<_> = v.iter().cloned().collect();\n         b.iter(|| {\n             assert!(m.iter_mut().count() == 128);\n         })\n     }\n     #[bench]\n     fn bench_iter_rev(b: &mut test::Bencher) {\n         let v = &[0; 128];\n-        let m: DList<int> = v.iter().map(|&x|x).collect();\n+        let m: DList<_> = v.iter().cloned().collect();\n         b.iter(|| {\n             assert!(m.iter().rev().count() == 128);\n         })\n     }\n     #[bench]\n     fn bench_iter_mut_rev(b: &mut test::Bencher) {\n         let v = &[0; 128];\n-        let mut m: DList<int> = v.iter().map(|&x|x).collect();\n+        let mut m: DList<_> = v.iter().cloned().collect();\n         b.iter(|| {\n             assert!(m.iter_mut().rev().count() == 128);\n         })"}, {"sha": "da146506077478a22dd1ff58e56f17393cb785c2", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -26,7 +26,7 @@ use core::ops::{Sub, BitOr, BitAnd, BitXor};\n pub struct EnumSet<E> {\n     // We must maintain the invariant that no bits are set\n     // for which no variant exists\n-    bits: uint\n+    bits: usize\n }\n \n impl<E> Copy for EnumSet<E> {}\n@@ -47,37 +47,37 @@ impl<E:CLike + fmt::Debug> fmt::Debug for EnumSet<E> {\n     }\n }\n \n-/// An interface for casting C-like enum to uint and back.\n+/// An interface for casting C-like enum to usize and back.\n /// A typically implementation is as below.\n ///\n /// ```{rust,ignore}\n-/// #[repr(uint)]\n+/// #[repr(usize)]\n /// enum Foo {\n ///     A, B, C\n /// }\n ///\n /// impl CLike for Foo {\n-///     fn to_uint(&self) -> uint {\n-///         *self as uint\n+///     fn to_usize(&self) -> usize {\n+///         *self as usize\n ///     }\n ///\n-///     fn from_uint(v: uint) -> Foo {\n+///     fn from_usize(v: usize) -> Foo {\n ///         unsafe { mem::transmute(v) }\n ///     }\n /// }\n /// ```\n pub trait CLike {\n-    /// Converts a C-like enum to a `uint`.\n-    fn to_uint(&self) -> uint;\n-    /// Converts a `uint` to a C-like enum.\n-    fn from_uint(uint) -> Self;\n+    /// Converts a C-like enum to a `usize`.\n+    fn to_usize(&self) -> usize;\n+    /// Converts a `usize` to a C-like enum.\n+    fn from_usize(usize) -> Self;\n }\n \n-fn bit<E:CLike>(e: &E) -> uint {\n-    use core::uint;\n-    let value = e.to_uint();\n-    assert!(value < uint::BITS,\n-            \"EnumSet only supports up to {} variants.\", uint::BITS - 1);\n+fn bit<E:CLike>(e: &E) -> usize {\n+    use core::usize;\n+    let value = e.to_usize();\n+    assert!(value < usize::BITS,\n+            \"EnumSet only supports up to {} variants.\", usize::BITS - 1);\n     1 << value\n }\n \n@@ -92,7 +92,7 @@ impl<E:CLike> EnumSet<E> {\n     /// Returns the number of elements in the given `EnumSet`.\n     #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n-    pub fn len(&self) -> uint {\n+    pub fn len(&self) -> usize {\n         self.bits.count_ones()\n     }\n \n@@ -205,8 +205,8 @@ impl<E:CLike> BitXor for EnumSet<E> {\n \n /// An iterator over an EnumSet\n pub struct Iter<E> {\n-    index: uint,\n-    bits: uint,\n+    index: usize,\n+    bits: usize,\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n@@ -220,7 +220,7 @@ impl<E> Clone for Iter<E> {\n }\n \n impl<E:CLike> Iter<E> {\n-    fn new(bits: uint) -> Iter<E> {\n+    fn new(bits: usize) -> Iter<E> {\n         Iter { index: 0, bits: bits }\n     }\n }\n@@ -237,13 +237,13 @@ impl<E:CLike> Iterator for Iter<E> {\n             self.index += 1;\n             self.bits >>= 1;\n         }\n-        let elem = CLike::from_uint(self.index);\n+        let elem = CLike::from_usize(self.index);\n         self.index += 1;\n         self.bits >>= 1;\n         Some(elem)\n     }\n \n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let exact = self.bits.count_ones();\n         (exact, Some(exact))\n     }\n@@ -282,17 +282,17 @@ mod test {\n     use super::{EnumSet, CLike};\n \n     #[derive(Copy, PartialEq, Debug)]\n-    #[repr(uint)]\n+    #[repr(usize)]\n     enum Foo {\n         A, B, C\n     }\n \n     impl CLike for Foo {\n-        fn to_uint(&self) -> uint {\n-            *self as uint\n+        fn to_usize(&self) -> usize {\n+            *self as usize\n         }\n \n-        fn from_uint(v: uint) -> Foo {\n+        fn from_usize(v: usize) -> Foo {\n             unsafe { mem::transmute(v) }\n         }\n     }\n@@ -486,7 +486,7 @@ mod test {\n     fn test_overflow() {\n         #[allow(dead_code)]\n         #[derive(Copy)]\n-        #[repr(uint)]\n+        #[repr(usize)]\n         enum Bar {\n             V00, V01, V02, V03, V04, V05, V06, V07, V08, V09,\n             V10, V11, V12, V13, V14, V15, V16, V17, V18, V19,\n@@ -498,11 +498,11 @@ mod test {\n         }\n \n         impl CLike for Bar {\n-            fn to_uint(&self) -> uint {\n-                *self as uint\n+            fn to_usize(&self) -> usize {\n+                *self as usize\n             }\n \n-            fn from_uint(v: uint) -> Bar {\n+            fn from_usize(v: usize) -> Bar {\n                 unsafe { mem::transmute(v) }\n             }\n         }"}, {"sha": "57c799785e82d2ae46ba0bb1adf7fcb27f922957", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -26,7 +26,6 @@\n #![feature(box_syntax)]\n #![feature(core)]\n #![feature(hash)]\n-#![feature(int_uint)]\n #![feature(staged_api)]\n #![feature(unboxed_closures)]\n #![feature(unicode)]"}, {"sha": "f5df7018153c4a039955460a061e122ae2405183", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 108, "deletions": 116, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -32,8 +32,8 @@ use std::cmp;\n \n use alloc::heap;\n \n-static INITIAL_CAPACITY: uint = 7u; // 2^3 - 1\n-static MINIMUM_CAPACITY: uint = 1u; // 2 - 1\n+static INITIAL_CAPACITY: usize = 7; // 2^3 - 1\n+static MINIMUM_CAPACITY: usize = 1; // 2 - 1\n \n /// `RingBuf` is a circular buffer, which can be used as a double-ended queue efficiently.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -44,9 +44,9 @@ pub struct RingBuf<T> {\n     // If tail == head the buffer is empty. The length of the ringbuf\n     // is defined as the distance between the two.\n \n-    tail: uint,\n-    head: uint,\n-    cap: uint,\n+    tail: usize,\n+    head: usize,\n+    cap: usize,\n     ptr: *mut T\n }\n \n@@ -59,7 +59,7 @@ unsafe impl<T: Sync> Sync for RingBuf<T> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Clone> Clone for RingBuf<T> {\n     fn clone(&self) -> RingBuf<T> {\n-        self.iter().map(|t| t.clone()).collect()\n+        self.iter().cloned().collect()\n     }\n }\n \n@@ -99,14 +99,14 @@ impl<T> RingBuf<T> {\n \n     /// Moves an element out of the buffer\n     #[inline]\n-    unsafe fn buffer_read(&mut self, off: uint) -> T {\n-        ptr::read(self.ptr.offset(off as int))\n+    unsafe fn buffer_read(&mut self, off: usize) -> T {\n+        ptr::read(self.ptr.offset(off as isize))\n     }\n \n     /// Writes an element into the buffer, moving it.\n     #[inline]\n-    unsafe fn buffer_write(&mut self, off: uint, t: T) {\n-        ptr::write(self.ptr.offset(off as int), t);\n+    unsafe fn buffer_write(&mut self, off: usize, t: T) {\n+        ptr::write(self.ptr.offset(off as isize), t);\n     }\n \n     /// Returns true iff the buffer is at capacity\n@@ -115,31 +115,31 @@ impl<T> RingBuf<T> {\n \n     /// Returns the index in the underlying buffer for a given logical element index.\n     #[inline]\n-    fn wrap_index(&self, idx: uint) -> uint { wrap_index(idx, self.cap) }\n+    fn wrap_index(&self, idx: usize) -> usize { wrap_index(idx, self.cap) }\n \n     /// Copies a contiguous block of memory len long from src to dst\n     #[inline]\n-    unsafe fn copy(&self, dst: uint, src: uint, len: uint) {\n+    unsafe fn copy(&self, dst: usize, src: usize, len: usize) {\n         debug_assert!(dst + len <= self.cap, \"dst={} src={} len={} cap={}\", dst, src, len,\n                       self.cap);\n         debug_assert!(src + len <= self.cap, \"dst={} src={} len={} cap={}\", dst, src, len,\n                       self.cap);\n         ptr::copy_memory(\n-            self.ptr.offset(dst as int),\n-            self.ptr.offset(src as int),\n+            self.ptr.offset(dst as isize),\n+            self.ptr.offset(src as isize),\n             len);\n     }\n \n     /// Copies a contiguous block of memory len long from src to dst\n     #[inline]\n-    unsafe fn copy_nonoverlapping(&self, dst: uint, src: uint, len: uint) {\n+    unsafe fn copy_nonoverlapping(&self, dst: usize, src: usize, len: usize) {\n         debug_assert!(dst + len <= self.cap, \"dst={} src={} len={} cap={}\", dst, src, len,\n                       self.cap);\n         debug_assert!(src + len <= self.cap, \"dst={} src={} len={} cap={}\", dst, src, len,\n                       self.cap);\n         ptr::copy_nonoverlapping_memory(\n-            self.ptr.offset(dst as int),\n-            self.ptr.offset(src as int),\n+            self.ptr.offset(dst as isize),\n+            self.ptr.offset(src as isize),\n             len);\n     }\n }\n@@ -153,7 +153,7 @@ impl<T> RingBuf<T> {\n \n     /// Creates an empty `RingBuf` with space for at least `n` elements.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn with_capacity(n: uint) -> RingBuf<T> {\n+    pub fn with_capacity(n: usize) -> RingBuf<T> {\n         // +1 since the ringbuffer always leaves one space empty\n         let cap = cmp::max(n + 1, MINIMUM_CAPACITY + 1).next_power_of_two();\n         assert!(cap > n, \"capacity overflow\");\n@@ -192,10 +192,10 @@ impl<T> RingBuf<T> {\n     /// assert_eq!(buf.get(1).unwrap(), &4);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get(&self, i: uint) -> Option<&T> {\n+    pub fn get(&self, i: usize) -> Option<&T> {\n         if i < self.len() {\n             let idx = self.wrap_index(self.tail + i);\n-            unsafe { Some(&*self.ptr.offset(idx as int)) }\n+            unsafe { Some(&*self.ptr.offset(idx as isize)) }\n         } else {\n             None\n         }\n@@ -222,10 +222,10 @@ impl<T> RingBuf<T> {\n     /// assert_eq!(buf[1], 7);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get_mut(&mut self, i: uint) -> Option<&mut T> {\n+    pub fn get_mut(&mut self, i: usize) -> Option<&mut T> {\n         if i < self.len() {\n             let idx = self.wrap_index(self.tail + i);\n-            unsafe { Some(&mut *self.ptr.offset(idx as int)) }\n+            unsafe { Some(&mut *self.ptr.offset(idx as isize)) }\n         } else {\n             None\n         }\n@@ -251,13 +251,13 @@ impl<T> RingBuf<T> {\n     /// assert_eq!(buf[2], 3);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn swap(&mut self, i: uint, j: uint) {\n+    pub fn swap(&mut self, i: usize, j: usize) {\n         assert!(i < self.len());\n         assert!(j < self.len());\n         let ri = self.wrap_index(self.tail + i);\n         let rj = self.wrap_index(self.tail + j);\n         unsafe {\n-            ptr::swap(self.ptr.offset(ri as int), self.ptr.offset(rj as int))\n+            ptr::swap(self.ptr.offset(ri as isize), self.ptr.offset(rj as isize))\n         }\n     }\n \n@@ -274,7 +274,7 @@ impl<T> RingBuf<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn capacity(&self) -> uint { self.cap - 1 }\n+    pub fn capacity(&self) -> usize { self.cap - 1 }\n \n     /// Reserves the minimum capacity for exactly `additional` more elements to be inserted in the\n     /// given `RingBuf`. Does nothing if the capacity is already sufficient.\n@@ -285,7 +285,7 @@ impl<T> RingBuf<T> {\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the new capacity overflows `uint`.\n+    /// Panics if the new capacity overflows `usize`.\n     ///\n     /// # Examples\n     ///\n@@ -297,7 +297,7 @@ impl<T> RingBuf<T> {\n     /// assert!(buf.capacity() >= 11);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn reserve_exact(&mut self, additional: uint) {\n+    pub fn reserve_exact(&mut self, additional: usize) {\n         self.reserve(additional);\n     }\n \n@@ -306,7 +306,7 @@ impl<T> RingBuf<T> {\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the new capacity overflows `uint`.\n+    /// Panics if the new capacity overflows `usize`.\n     ///\n     /// # Examples\n     ///\n@@ -318,7 +318,7 @@ impl<T> RingBuf<T> {\n     /// assert!(buf.capacity() >= 11);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn reserve(&mut self, additional: uint) {\n+    pub fn reserve(&mut self, additional: usize) {\n         let new_len = self.len() + additional;\n         assert!(new_len + 1 > self.len(), \"capacity overflow\");\n         if new_len > self.capacity() {\n@@ -388,7 +388,7 @@ impl<T> RingBuf<T> {\n     /// use std::collections::RingBuf;\n     ///\n     /// let mut buf = RingBuf::with_capacity(15);\n-    /// buf.extend(0u..4);\n+    /// buf.extend(0..4);\n     /// assert_eq!(buf.capacity(), 15);\n     /// buf.shrink_to_fit();\n     /// assert!(buf.capacity() >= 4);\n@@ -482,7 +482,7 @@ impl<T> RingBuf<T> {\n     /// ```\n     #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification; waiting on panic semantics\")]\n-    pub fn truncate(&mut self, len: uint) {\n+    pub fn truncate(&mut self, len: usize) {\n         for _ in len..self.len() {\n             self.pop_back();\n         }\n@@ -529,13 +529,13 @@ impl<T> RingBuf<T> {\n     /// assert_eq!(&buf.iter_mut().collect::<Vec<&mut i32>>()[], b);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn iter_mut<'a>(&'a mut self) -> IterMut<'a, T> {\n+    pub fn iter_mut(&mut self) -> IterMut<T> {\n         IterMut {\n             tail: self.tail,\n             head: self.head,\n             cap: self.cap,\n             ptr: self.ptr,\n-            marker: marker::ContravariantLifetime::<'a>,\n+            marker: marker::ContravariantLifetime,\n         }\n     }\n \n@@ -552,7 +552,7 @@ impl<T> RingBuf<T> {\n     #[inline]\n     #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n-    pub fn as_slices<'a>(&'a self) -> (&'a [T], &'a [T]) {\n+    pub fn as_slices(&self) -> (&[T], &[T]) {\n         unsafe {\n             let contiguous = self.is_contiguous();\n             let buf = self.buffer_as_slice();\n@@ -572,7 +572,7 @@ impl<T> RingBuf<T> {\n     #[inline]\n     #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n-    pub fn as_mut_slices<'a>(&'a mut self) -> (&'a mut [T], &'a mut [T]) {\n+    pub fn as_mut_slices(&mut self) -> (&mut [T], &mut [T]) {\n         unsafe {\n             let contiguous = self.is_contiguous();\n             let head = self.head;\n@@ -604,7 +604,7 @@ impl<T> RingBuf<T> {\n     /// assert_eq!(v.len(), 1);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> uint { count(self.tail, self.head, self.cap) }\n+    pub fn len(&self) -> usize { count(self.tail, self.head, self.cap) }\n \n     /// Returns true if the buffer contains no elements\n     ///\n@@ -878,7 +878,7 @@ impl<T> RingBuf<T> {\n     /// ```\n     #[unstable(feature = \"collections\",\n                reason = \"the naming of this function may be altered\")]\n-    pub fn swap_back_remove(&mut self, index: uint) -> Option<T> {\n+    pub fn swap_back_remove(&mut self, index: usize) -> Option<T> {\n         let length = self.len();\n         if length > 0 && index < length - 1 {\n             self.swap(index, length - 1);\n@@ -911,7 +911,7 @@ impl<T> RingBuf<T> {\n     /// ```\n     #[unstable(feature = \"collections\",\n                reason = \"the naming of this function may be altered\")]\n-    pub fn swap_front_remove(&mut self, index: uint) -> Option<T> {\n+    pub fn swap_front_remove(&mut self, index: usize) -> Option<T> {\n         let length = self.len();\n         if length > 0 && index < length && index != 0 {\n             self.swap(index, 0);\n@@ -939,7 +939,7 @@ impl<T> RingBuf<T> {\n     /// buf.insert(1,11);\n     /// assert_eq!(Some(&11), buf.get(1));\n     /// ```\n-    pub fn insert(&mut self, i: uint, t: T) {\n+    pub fn insert(&mut self, i: usize, t: T) {\n         assert!(i <= self.len(), \"index out of bounds\");\n         if self.is_full() {\n             self.reserve(1);\n@@ -1144,7 +1144,7 @@ impl<T> RingBuf<T> {\n     /// assert_eq!(Some(&15), buf.get(2));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn remove(&mut self, i: uint) -> Option<T> {\n+    pub fn remove(&mut self, i: usize) -> Option<T> {\n         if self.is_empty() || self.len() <= i {\n             return None;\n         }\n@@ -1312,7 +1312,7 @@ impl<T: Clone> RingBuf<T> {\n     /// ```\n     #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification; waiting on panic semantics\")]\n-    pub fn resize(&mut self, new_len: uint, value: T) {\n+    pub fn resize(&mut self, new_len: usize, value: T) {\n         let len = self.len();\n \n         if new_len > len {\n@@ -1325,14 +1325,14 @@ impl<T: Clone> RingBuf<T> {\n \n /// Returns the index in the underlying buffer for a given logical element index.\n #[inline]\n-fn wrap_index(index: uint, size: uint) -> uint {\n+fn wrap_index(index: usize, size: usize) -> usize {\n     // size is always a power of 2\n     index & (size - 1)\n }\n \n /// Calculate the number of elements left to be read in the buffer\n #[inline]\n-fn count(tail: uint, head: uint, size: uint) -> uint {\n+fn count(tail: usize, head: usize, size: usize) -> usize {\n     // size is always a power of 2\n     (head - tail) & (size - 1)\n }\n@@ -1341,8 +1341,8 @@ fn count(tail: uint, head: uint, size: uint) -> uint {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T:'a> {\n     ring: &'a [T],\n-    tail: uint,\n-    head: uint\n+    tail: usize,\n+    head: usize\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n@@ -1371,7 +1371,7 @@ impl<'a, T> Iterator for Iter<'a, T> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let len = count(self.tail, self.head, self.ring.len());\n         (len, Some(len))\n     }\n@@ -1395,13 +1395,13 @@ impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> RandomAccessIterator for Iter<'a, T> {\n     #[inline]\n-    fn indexable(&self) -> uint {\n+    fn indexable(&self) -> usize {\n         let (len, _) = self.size_hint();\n         len\n     }\n \n     #[inline]\n-    fn idx(&mut self, j: uint) -> Option<&'a T> {\n+    fn idx(&mut self, j: usize) -> Option<&'a T> {\n         if j >= self.indexable() {\n             None\n         } else {\n@@ -1418,9 +1418,9 @@ impl<'a, T> RandomAccessIterator for Iter<'a, T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, T:'a> {\n     ptr: *mut T,\n-    tail: uint,\n-    head: uint,\n-    cap: uint,\n+    tail: usize,\n+    head: usize,\n+    cap: usize,\n     marker: marker::ContravariantLifetime<'a>,\n }\n \n@@ -1437,12 +1437,12 @@ impl<'a, T> Iterator for IterMut<'a, T> {\n         self.tail = wrap_index(self.tail + 1, self.cap);\n \n         unsafe {\n-            Some(&mut *self.ptr.offset(tail as int))\n+            Some(&mut *self.ptr.offset(tail as isize))\n         }\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let len = count(self.tail, self.head, self.cap);\n         (len, Some(len))\n     }\n@@ -1458,7 +1458,7 @@ impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n         self.head = wrap_index(self.head - 1, self.cap);\n \n         unsafe {\n-            Some(&mut *self.ptr.offset(self.head as int))\n+            Some(&mut *self.ptr.offset(self.head as isize))\n         }\n     }\n }\n@@ -1482,7 +1482,7 @@ impl<T> Iterator for IntoIter<T> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let len = self.inner.len();\n         (len, Some(len))\n     }\n@@ -1526,7 +1526,7 @@ impl<'a, T: 'a> Iterator for Drain<'a, T> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let len = self.inner.len();\n         (len, Some(len))\n     }\n@@ -1580,21 +1580,21 @@ impl<S: Writer + Hasher, A: Hash<S>> Hash<S> for RingBuf<A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A> Index<uint> for RingBuf<A> {\n+impl<A> Index<usize> for RingBuf<A> {\n     type Output = A;\n \n     #[inline]\n-    fn index<'a>(&'a self, i: &uint) -> &'a A {\n+    fn index(&self, i: &usize) -> &A {\n         self.get(*i).expect(\"Out of bounds access\")\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A> IndexMut<uint> for RingBuf<A> {\n+impl<A> IndexMut<usize> for RingBuf<A> {\n     type Output = A;\n \n     #[inline]\n-    fn index_mut<'a>(&'a mut self, i: &uint) -> &'a mut A {\n+    fn index_mut(&mut self, i: &usize) -> &mut A {\n         self.get_mut(*i).expect(\"Out of bounds access\")\n     }\n }\n@@ -1673,13 +1673,13 @@ mod tests {\n     #[allow(deprecated)]\n     fn test_simple() {\n         let mut d = RingBuf::new();\n-        assert_eq!(d.len(), 0u);\n+        assert_eq!(d.len(), 0);\n         d.push_front(17);\n         d.push_front(42);\n         d.push_back(137);\n-        assert_eq!(d.len(), 3u);\n+        assert_eq!(d.len(), 3);\n         d.push_back(137);\n-        assert_eq!(d.len(), 4u);\n+        assert_eq!(d.len(), 4);\n         assert_eq!(*d.front().unwrap(), 42);\n         assert_eq!(*d.back().unwrap(), 137);\n         let mut i = d.pop_front();\n@@ -1690,15 +1690,15 @@ mod tests {\n         assert_eq!(i, Some(137));\n         i = d.pop_back();\n         assert_eq!(i, Some(17));\n-        assert_eq!(d.len(), 0u);\n+        assert_eq!(d.len(), 0);\n         d.push_back(3);\n-        assert_eq!(d.len(), 1u);\n+        assert_eq!(d.len(), 1);\n         d.push_front(2);\n-        assert_eq!(d.len(), 2u);\n+        assert_eq!(d.len(), 2);\n         d.push_back(4);\n-        assert_eq!(d.len(), 3u);\n+        assert_eq!(d.len(), 3);\n         d.push_front(1);\n-        assert_eq!(d.len(), 4u);\n+        assert_eq!(d.len(), 4);\n         debug!(\"{}\", d[0]);\n         debug!(\"{}\", d[1]);\n         debug!(\"{}\", d[2]);\n@@ -1743,29 +1743,29 @@ mod tests {\n     #[test]\n     fn test_push_front_grow() {\n         let mut deq = RingBuf::new();\n-        for i in 0u..66 {\n+        for i in 0..66 {\n             deq.push_front(i);\n         }\n         assert_eq!(deq.len(), 66);\n \n-        for i in 0u..66 {\n+        for i in 0..66 {\n             assert_eq!(deq[i], 65 - i);\n         }\n \n         let mut deq = RingBuf::new();\n-        for i in 0u..66 {\n+        for i in 0..66 {\n             deq.push_back(i);\n         }\n \n-        for i in 0u..66 {\n+        for i in 0..66 {\n             assert_eq!(deq[i], i);\n         }\n     }\n \n     #[test]\n     fn test_index() {\n         let mut deq = RingBuf::new();\n-        for i in 1u..4 {\n+        for i in 1..4 {\n             deq.push_front(i);\n         }\n         assert_eq!(deq[1], 2);\n@@ -1775,7 +1775,7 @@ mod tests {\n     #[should_fail]\n     fn test_index_out_of_bounds() {\n         let mut deq = RingBuf::new();\n-        for i in 1u..4 {\n+        for i in 1..4 {\n             deq.push_front(i);\n         }\n         deq[3];\n@@ -1784,7 +1784,7 @@ mod tests {\n     #[bench]\n     fn bench_new(b: &mut test::Bencher) {\n         b.iter(|| {\n-            let ring: RingBuf<u64> = RingBuf::new();\n+            let ring: RingBuf<i32> = RingBuf::new();\n             test::black_box(ring);\n         })\n     }\n@@ -1815,7 +1815,7 @@ mod tests {\n \n     #[bench]\n     fn bench_pop_back_100(b: &mut test::Bencher) {\n-        let mut deq: RingBuf<i32> = RingBuf::with_capacity(101);\n+        let mut deq= RingBuf::<i32>::with_capacity(101);\n \n         b.iter(|| {\n             deq.head = 100;\n@@ -1828,7 +1828,7 @@ mod tests {\n \n     #[bench]\n     fn bench_pop_front_100(b: &mut test::Bencher) {\n-        let mut deq: RingBuf<i32> = RingBuf::with_capacity(101);\n+        let mut deq = RingBuf::<i32>::with_capacity(101);\n \n         b.iter(|| {\n             deq.head = 100;\n@@ -1852,7 +1852,7 @@ mod tests {\n \n     #[bench]\n     fn bench_iter_1000(b: &mut test::Bencher) {\n-        let ring: RingBuf<i32> = (0..1000).collect();\n+        let ring: RingBuf<_> = (0..1000).collect();\n \n         b.iter(|| {\n             let mut sum = 0;\n@@ -1865,7 +1865,7 @@ mod tests {\n \n     #[bench]\n     fn bench_mut_iter_1000(b: &mut test::Bencher) {\n-        let mut ring: RingBuf<i32> = (0..1000).collect();\n+        let mut ring: RingBuf<_> = (0..1000).collect();\n \n         b.iter(|| {\n             let mut sum = 0;\n@@ -1978,33 +1978,25 @@ mod tests {\n     #[test]\n     fn test_reserve_exact() {\n         let mut d = RingBuf::new();\n-        d.push_back(0u64);\n-        d.reserve_exact(50);\n-        assert!(d.capacity() >= 51);\n-        let mut d = RingBuf::new();\n-        d.push_back(0u32);\n+        d.push_back(0);\n         d.reserve_exact(50);\n         assert!(d.capacity() >= 51);\n     }\n \n     #[test]\n     fn test_reserve() {\n         let mut d = RingBuf::new();\n-        d.push_back(0u64);\n-        d.reserve(50);\n-        assert!(d.capacity() >= 51);\n-        let mut d = RingBuf::new();\n-        d.push_back(0u32);\n+        d.push_back(0);\n         d.reserve(50);\n         assert!(d.capacity() >= 51);\n     }\n \n     #[test]\n     fn test_swap() {\n-        let mut d: RingBuf<i32> = (0..5).collect();\n+        let mut d: RingBuf<_> = (0..5).collect();\n         d.pop_front();\n         d.swap(0, 3);\n-        assert_eq!(d.iter().map(|&x|x).collect::<Vec<i32>>(), vec!(4, 2, 3, 1));\n+        assert_eq!(d.iter().cloned().collect::<Vec<_>>(), vec!(4, 2, 3, 1));\n     }\n \n     #[test]\n@@ -2018,15 +2010,15 @@ mod tests {\n         }\n         {\n             let b: &[_] = &[&0,&1,&2,&3,&4];\n-            assert_eq!(d.iter().collect::<Vec<&i32>>(), b);\n+            assert_eq!(d.iter().collect::<Vec<_>>(), b);\n         }\n \n         for i in 6..9 {\n             d.push_front(i);\n         }\n         {\n             let b: &[_] = &[&8,&7,&6,&0,&1,&2,&3,&4];\n-            assert_eq!(d.iter().collect::<Vec<&i32>>(), b);\n+            assert_eq!(d.iter().collect::<Vec<_>>(), b);\n         }\n \n         let mut it = d.iter();\n@@ -2049,14 +2041,14 @@ mod tests {\n         }\n         {\n             let b: &[_] = &[&4,&3,&2,&1,&0];\n-            assert_eq!(d.iter().rev().collect::<Vec<&i32>>(), b);\n+            assert_eq!(d.iter().rev().collect::<Vec<_>>(), b);\n         }\n \n         for i in 6..9 {\n             d.push_front(i);\n         }\n         let b: &[_] = &[&4,&3,&2,&1,&0,&6,&7,&8];\n-        assert_eq!(d.iter().rev().collect::<Vec<&i32>>(), b);\n+        assert_eq!(d.iter().rev().collect::<Vec<_>>(), b);\n     }\n \n     #[test]\n@@ -2070,16 +2062,16 @@ mod tests {\n         assert_eq!(d.pop_front(), Some(1));\n         d.push_back(4);\n \n-        assert_eq!(d.iter_mut().rev().map(|x| *x).collect::<Vec<i32>>(),\n-                   vec!(4, 3, 2));\n+        assert_eq!(d.iter_mut().rev().cloned().collect::<Vec<_>>(),\n+                   vec![4, 3, 2]);\n     }\n \n     #[test]\n     fn test_mut_iter() {\n         let mut d = RingBuf::new();\n         assert!(d.iter_mut().next().is_none());\n \n-        for i in 0u..3 {\n+        for i in 0..3 {\n             d.push_front(i);\n         }\n \n@@ -2102,7 +2094,7 @@ mod tests {\n         let mut d = RingBuf::new();\n         assert!(d.iter_mut().rev().next().is_none());\n \n-        for i in 0u..3 {\n+        for i in 0..3 {\n             d.push_front(i);\n         }\n \n@@ -2141,7 +2133,7 @@ mod tests {\n             }\n \n             let b = vec![0,1,2,3,4];\n-            assert_eq!(d.into_iter().collect::<Vec<i32>>(), b);\n+            assert_eq!(d.into_iter().collect::<Vec<_>>(), b);\n         }\n \n         // wrapped iter\n@@ -2155,7 +2147,7 @@ mod tests {\n             }\n \n             let b = vec![8,7,6,0,1,2,3,4];\n-            assert_eq!(d.into_iter().collect::<Vec<i32>>(), b);\n+            assert_eq!(d.into_iter().collect::<Vec<_>>(), b);\n         }\n \n         // partially used\n@@ -2224,7 +2216,7 @@ mod tests {\n \n         // partially used\n         {\n-            let mut d: RingBuf<i32> = RingBuf::new();\n+            let mut d: RingBuf<_> = RingBuf::new();\n             for i in 0..5 {\n                 d.push_back(i);\n             }\n@@ -2250,12 +2242,12 @@ mod tests {\n     fn test_from_iter() {\n         use core::iter;\n         let v = vec!(1,2,3,4,5,6,7);\n-        let deq: RingBuf<i32> = v.iter().map(|&x| x).collect();\n-        let u: Vec<i32> = deq.iter().map(|&x| x).collect();\n+        let deq: RingBuf<_> = v.iter().cloned().collect();\n+        let u: Vec<_> = deq.iter().cloned().collect();\n         assert_eq!(u, v);\n \n-        let seq = iter::count(0u, 2).take(256);\n-        let deq: RingBuf<uint> = seq.collect();\n+        let seq = iter::count(0, 2).take(256);\n+        let deq: RingBuf<_> = seq.collect();\n         for (i, &x) in deq.iter().enumerate() {\n             assert_eq!(2*i, x);\n         }\n@@ -2269,14 +2261,14 @@ mod tests {\n         d.push_front(42);\n         d.push_back(137);\n         d.push_back(137);\n-        assert_eq!(d.len(), 4u);\n+        assert_eq!(d.len(), 4);\n         let mut e = d.clone();\n-        assert_eq!(e.len(), 4u);\n+        assert_eq!(e.len(), 4);\n         while !d.is_empty() {\n             assert_eq!(d.pop_back(), e.pop_back());\n         }\n-        assert_eq!(d.len(), 0u);\n-        assert_eq!(e.len(), 0u);\n+        assert_eq!(d.len(), 0);\n+        assert_eq!(e.len(), 0);\n     }\n \n     #[test]\n@@ -2333,18 +2325,18 @@ mod tests {\n \n     #[test]\n     fn test_show() {\n-        let ringbuf: RingBuf<i32> = (0..10).collect();\n+        let ringbuf: RingBuf<_> = (0..10).collect();\n         assert_eq!(format!(\"{:?}\", ringbuf), \"RingBuf [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n \n-        let ringbuf: RingBuf<&str> = vec![\"just\", \"one\", \"test\", \"more\"].iter()\n-                                                                        .map(|&s| s)\n+        let ringbuf: RingBuf<_> = vec![\"just\", \"one\", \"test\", \"more\"].iter()\n+                                                                        .cloned()\n                                                                         .collect();\n         assert_eq!(format!(\"{:?}\", ringbuf), \"RingBuf [\\\"just\\\", \\\"one\\\", \\\"test\\\", \\\"more\\\"]\");\n     }\n \n     #[test]\n     fn test_drop() {\n-        static mut drops: uint = 0;\n+        static mut drops: i32 = 0;\n         struct Elem;\n         impl Drop for Elem {\n             fn drop(&mut self) {\n@@ -2364,7 +2356,7 @@ mod tests {\n \n     #[test]\n     fn test_drop_with_pop() {\n-        static mut drops: uint = 0;\n+        static mut drops: i32 = 0;\n         struct Elem;\n         impl Drop for Elem {\n             fn drop(&mut self) {\n@@ -2388,7 +2380,7 @@ mod tests {\n \n     #[test]\n     fn test_drop_clear() {\n-        static mut drops: uint = 0;\n+        static mut drops: i32 = 0;\n         struct Elem;\n         impl Drop for Elem {\n             fn drop(&mut self) {"}, {"sha": "679754be7490ee35edc70196650968529b6662aa", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 330, "deletions": 332, "changes": 662, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -26,7 +26,7 @@\n //! block of memory that a mutable slice points to:\n //!\n //! ```rust\n-//! let x: &mut[int] = &mut [1, 2, 3];\n+//! let x: &mut[i32] = &mut [1, 2, 3];\n //! x[1] = 7;\n //! assert_eq!(x[0], 1);\n //! assert_eq!(x[1], 7);\n@@ -169,25 +169,25 @@ pub trait SliceExt {\n     /// ```\n     #[unstable(feature = \"collections\",\n                reason = \"uncertain about this API approach\")]\n-    fn move_from(&mut self, src: Vec<Self::Item>, start: uint, end: uint) -> uint;\n+    fn move_from(&mut self, src: Vec<Self::Item>, start: usize, end: usize) -> usize;\n \n     /// Deprecated: use `&s[start .. end]` notation instead.\n     #[unstable(feature = \"collections\",\n                reason = \"will be replaced by slice syntax\")]\n     #[deprecated(since = \"1.0.0\", reason = \"use &s[start .. end] instead\")]\n-    fn slice(&self, start: uint, end: uint) -> &[Self::Item];\n+    fn slice(&self, start: usize, end: usize) -> &[Self::Item];\n \n     /// Deprecated: use `&s[start..]` notation instead.\n     #[unstable(feature = \"collections\",\n                reason = \"will be replaced by slice syntax\")]\n     #[deprecated(since = \"1.0.0\", reason = \"use &s[start..] instead\")]\n-    fn slice_from(&self, start: uint) -> &[Self::Item];\n+    fn slice_from(&self, start: usize) -> &[Self::Item];\n \n     /// Deprecated: use `&s[..end]` notation instead.\n     #[unstable(feature = \"collections\",\n                reason = \"will be replaced by slice syntax\")]\n     #[deprecated(since = \"1.0.0\", reason = \"use &s[..end] instead\")]\n-    fn slice_to(&self, end: uint) -> &[Self::Item];\n+    fn slice_to(&self, end: usize) -> &[Self::Item];\n \n     /// Divides one slice into two at an index.\n     ///\n@@ -206,7 +206,7 @@ pub trait SliceExt {\n     /// assert_eq!([30, 20, 50], v2);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn split_at(&self, mid: uint) -> (&[Self::Item], &[Self::Item]);\n+    fn split_at(&self, mid: usize) -> (&[Self::Item], &[Self::Item]);\n \n     /// Returns an iterator over the slice.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -246,7 +246,7 @@ pub trait SliceExt {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn splitn<F>(&self, n: uint, pred: F) -> SplitN<Self::Item, F>\n+    fn splitn<F>(&self, n: usize, pred: F) -> SplitN<Self::Item, F>\n                  where F: FnMut(&Self::Item) -> bool;\n \n     /// Returns an iterator over subslices separated by elements that match\n@@ -266,7 +266,7 @@ pub trait SliceExt {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn rsplitn<F>(&self, n: uint, pred: F) -> RSplitN<Self::Item, F>\n+    fn rsplitn<F>(&self, n: usize, pred: F) -> RSplitN<Self::Item, F>\n                   where F: FnMut(&Self::Item) -> bool;\n \n     /// Returns an iterator over all contiguous windows of length\n@@ -289,7 +289,7 @@ pub trait SliceExt {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn windows(&self, size: uint) -> Windows<Self::Item>;\n+    fn windows(&self, size: usize) -> Windows<Self::Item>;\n \n     /// Returns an iterator over `size` elements of the slice at a\n     /// time. The chunks do not overlap. If `size` does not divide the\n@@ -312,7 +312,7 @@ pub trait SliceExt {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn chunks(&self, size: uint) -> Chunks<Self::Item>;\n+    fn chunks(&self, size: usize) -> Chunks<Self::Item>;\n \n     /// Returns the element of a slice at the given index, or `None` if the\n     /// index is out of bounds.\n@@ -325,7 +325,7 @@ pub trait SliceExt {\n     /// assert_eq!(None, v.get(3));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn get(&self, index: uint) -> Option<&Self::Item>;\n+    fn get(&self, index: usize) -> Option<&Self::Item>;\n \n     /// Returns the first element of a slice, or `None` if it is empty.\n     ///\n@@ -366,7 +366,7 @@ pub trait SliceExt {\n     /// Returns a pointer to the element at the given index, without doing\n     /// bounds checking.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    unsafe fn get_unchecked(&self, index: uint) -> &Self::Item;\n+    unsafe fn get_unchecked(&self, index: usize) -> &Self::Item;\n \n     /// Returns an unsafe pointer to the slice's buffer\n     ///\n@@ -411,7 +411,7 @@ pub trait SliceExt {\n     /// assert!(match r { Ok(1...4) => true, _ => false, });\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn binary_search_by<F>(&self, f: F) -> Result<uint, uint> where\n+    fn binary_search_by<F>(&self, f: F) -> Result<usize, usize> where\n         F: FnMut(&Self::Item) -> Ordering;\n \n     /// Return the number of elements in the slice\n@@ -423,7 +423,7 @@ pub trait SliceExt {\n     /// assert_eq!(a.len(), 3);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn len(&self) -> uint;\n+    fn len(&self) -> usize;\n \n     /// Returns true if the slice has a length of 0\n     ///\n@@ -439,7 +439,7 @@ pub trait SliceExt {\n     /// Returns a mutable reference to the element at the given index,\n     /// or `None` if the index is out of bounds\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn get_mut(&mut self, index: uint) -> Option<&mut Self::Item>;\n+    fn get_mut(&mut self, index: usize) -> Option<&mut Self::Item>;\n \n     /// Work with `self` as a mut slice.\n     /// Primarily intended for getting a &mut [T] from a [T; N].\n@@ -450,19 +450,19 @@ pub trait SliceExt {\n     #[unstable(feature = \"collections\",\n                reason = \"will be replaced by slice syntax\")]\n     #[deprecated(since = \"1.0.0\", reason = \"use &mut s[start .. end] instead\")]\n-    fn slice_mut(&mut self, start: uint, end: uint) -> &mut [Self::Item];\n+    fn slice_mut(&mut self, start: usize, end: usize) -> &mut [Self::Item];\n \n     /// Deprecated: use `&mut s[start ..]` instead.\n     #[unstable(feature = \"collections\",\n                reason = \"will be replaced by slice syntax\")]\n     #[deprecated(since = \"1.0.0\", reason = \"use &mut s[start ..] instead\")]\n-    fn slice_from_mut(&mut self, start: uint) -> &mut [Self::Item];\n+    fn slice_from_mut(&mut self, start: usize) -> &mut [Self::Item];\n \n     /// Deprecated: use `&mut s[.. end]` instead.\n     #[unstable(feature = \"collections\",\n                reason = \"will be replaced by slice syntax\")]\n     #[deprecated(since = \"1.0.0\", reason = \"use &mut s[.. end] instead\")]\n-    fn slice_to_mut(&mut self, end: uint) -> &mut [Self::Item];\n+    fn slice_to_mut(&mut self, end: usize) -> &mut [Self::Item];\n \n     /// Returns an iterator that allows modifying each value\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -496,15 +496,15 @@ pub trait SliceExt {\n     /// `pred`, limited to splitting at most `n` times.  The matched element is\n     /// not contained in the subslices.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn splitn_mut<F>(&mut self, n: uint, pred: F) -> SplitNMut<Self::Item, F>\n+    fn splitn_mut<F>(&mut self, n: usize, pred: F) -> SplitNMut<Self::Item, F>\n                      where F: FnMut(&Self::Item) -> bool;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred` limited to splitting at most `n` times. This starts at the end of\n     /// the slice and works backwards.  The matched element is not contained in\n     /// the subslices.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn rsplitn_mut<F>(&mut self,  n: uint, pred: F) -> RSplitNMut<Self::Item, F>\n+    fn rsplitn_mut<F>(&mut self,  n: usize, pred: F) -> RSplitNMut<Self::Item, F>\n                       where F: FnMut(&Self::Item) -> bool;\n \n     /// Returns an iterator over `chunk_size` elements of the slice at a time.\n@@ -516,7 +516,7 @@ pub trait SliceExt {\n     ///\n     /// Panics if `chunk_size` is 0.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn chunks_mut(&mut self, chunk_size: uint) -> ChunksMut<Self::Item>;\n+    fn chunks_mut(&mut self, chunk_size: usize) -> ChunksMut<Self::Item>;\n \n     /// Swaps two elements in a slice.\n     ///\n@@ -537,7 +537,7 @@ pub trait SliceExt {\n     /// assert!(v == [\"a\", \"d\", \"c\", \"b\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn swap(&mut self, a: uint, b: uint);\n+    fn swap(&mut self, a: usize, b: usize);\n \n     /// Divides one `&mut` into two at an index.\n     ///\n@@ -574,7 +574,7 @@ pub trait SliceExt {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn split_at_mut(&mut self, mid: uint) -> (&mut [Self::Item], &mut [Self::Item]);\n+    fn split_at_mut(&mut self, mid: usize) -> (&mut [Self::Item], &mut [Self::Item]);\n \n     /// Reverse the order of elements in a slice, in place.\n     ///\n@@ -590,7 +590,7 @@ pub trait SliceExt {\n \n     /// Returns an unsafe mutable pointer to the element in index\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    unsafe fn get_unchecked_mut(&mut self, index: uint) -> &mut Self::Item;\n+    unsafe fn get_unchecked_mut(&mut self, index: usize) -> &mut Self::Item;\n \n     /// Return an unsafe mutable pointer to the slice's buffer.\n     ///\n@@ -652,7 +652,7 @@ pub trait SliceExt {\n     /// assert!(dst == [3, 4, 5]);\n     /// ```\n     #[unstable(feature = \"collections\")]\n-    fn clone_from_slice(&mut self, &[Self::Item]) -> uint where Self::Item: Clone;\n+    fn clone_from_slice(&mut self, &[Self::Item]) -> usize where Self::Item: Clone;\n \n     /// Sorts the slice, in place.\n     ///\n@@ -693,12 +693,12 @@ pub trait SliceExt {\n     /// assert!(match r { Ok(1...4) => true, _ => false, });\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn binary_search(&self, x: &Self::Item) -> Result<uint, uint> where Self::Item: Ord;\n+    fn binary_search(&self, x: &Self::Item) -> Result<usize, usize> where Self::Item: Ord;\n \n     /// Deprecated: use `binary_search` instead.\n     #[unstable(feature = \"collections\")]\n     #[deprecated(since = \"1.0.0\", reason = \"use binary_search instead\")]\n-    fn binary_search_elem(&self, x: &Self::Item) -> Result<uint, uint> where Self::Item: Ord {\n+    fn binary_search_elem(&self, x: &Self::Item) -> Result<usize, usize> where Self::Item: Ord {\n         self.binary_search(x)\n     }\n \n@@ -744,11 +744,11 @@ pub trait SliceExt {\n \n     /// Find the first index containing a matching value.\n     #[unstable(feature = \"collections\")]\n-    fn position_elem(&self, t: &Self::Item) -> Option<uint> where Self::Item: PartialEq;\n+    fn position_elem(&self, t: &Self::Item) -> Option<usize> where Self::Item: PartialEq;\n \n     /// Find the last index containing a matching value.\n     #[unstable(feature = \"collections\")]\n-    fn rposition_elem(&self, t: &Self::Item) -> Option<uint> where Self::Item: PartialEq;\n+    fn rposition_elem(&self, t: &Self::Item) -> Option<usize> where Self::Item: PartialEq;\n \n     /// Returns true if the slice contains an element with the given value.\n     ///\n@@ -805,35 +805,35 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    fn move_from(&mut self, mut src: Vec<T>, start: uint, end: uint) -> uint {\n+    fn move_from(&mut self, mut src: Vec<T>, start: usize, end: usize) -> usize {\n         for (a, b) in self.iter_mut().zip(src[start .. end].iter_mut()) {\n             mem::swap(a, b);\n         }\n         cmp::min(self.len(), end-start)\n     }\n \n     #[inline]\n-    fn slice<'a>(&'a self, start: uint, end: uint) -> &'a [T] {\n+    fn slice(&self, start: usize, end: usize) -> &[T] {\n         &self[start .. end]\n     }\n \n     #[inline]\n-    fn slice_from<'a>(&'a self, start: uint) -> &'a [T] {\n+    fn slice_from(&self, start: usize) -> &[T] {\n         &self[start ..]\n     }\n \n     #[inline]\n-    fn slice_to<'a>(&'a self, end: uint) -> &'a [T] {\n+    fn slice_to(&self, end: usize) -> &[T] {\n         &self[.. end]\n     }\n \n     #[inline]\n-    fn split_at<'a>(&'a self, mid: uint) -> (&'a [T], &'a [T]) {\n+    fn split_at(&self, mid: usize) -> (&[T], &[T]) {\n         core_slice::SliceExt::split_at(self, mid)\n     }\n \n     #[inline]\n-    fn iter<'a>(&'a self) -> Iter<'a, T> {\n+    fn iter(&self) -> Iter<T> {\n         core_slice::SliceExt::iter(self)\n     }\n \n@@ -844,54 +844,54 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    fn splitn<F>(&self, n: uint, pred: F) -> SplitN<T, F>\n+    fn splitn<F>(&self, n: usize, pred: F) -> SplitN<T, F>\n                  where F: FnMut(&T) -> bool {\n         core_slice::SliceExt::splitn(self, n, pred)\n     }\n \n     #[inline]\n-    fn rsplitn<F>(&self, n: uint, pred: F) -> RSplitN<T, F>\n+    fn rsplitn<F>(&self, n: usize, pred: F) -> RSplitN<T, F>\n                   where F: FnMut(&T) -> bool {\n         core_slice::SliceExt::rsplitn(self, n, pred)\n     }\n \n     #[inline]\n-    fn windows<'a>(&'a self, size: uint) -> Windows<'a, T> {\n+    fn windows(&self, size: usize) -> Windows<T> {\n         core_slice::SliceExt::windows(self, size)\n     }\n \n     #[inline]\n-    fn chunks<'a>(&'a self, size: uint) -> Chunks<'a, T> {\n+    fn chunks(&self, size: usize) -> Chunks<T> {\n         core_slice::SliceExt::chunks(self, size)\n     }\n \n     #[inline]\n-    fn get<'a>(&'a self, index: uint) -> Option<&'a T> {\n+    fn get(&self, index: usize) -> Option<&T> {\n         core_slice::SliceExt::get(self, index)\n     }\n \n     #[inline]\n-    fn first<'a>(&'a self) -> Option<&'a T> {\n+    fn first(&self) -> Option<&T> {\n         core_slice::SliceExt::first(self)\n     }\n \n     #[inline]\n-    fn tail<'a>(&'a self) -> &'a [T] {\n+    fn tail(&self) -> &[T] {\n         core_slice::SliceExt::tail(self)\n     }\n \n     #[inline]\n-    fn init<'a>(&'a self) -> &'a [T] {\n+    fn init(&self) -> &[T] {\n         core_slice::SliceExt::init(self)\n     }\n \n     #[inline]\n-    fn last<'a>(&'a self) -> Option<&'a T> {\n+    fn last(&self) -> Option<&T> {\n         core_slice::SliceExt::last(self)\n     }\n \n     #[inline]\n-    unsafe fn get_unchecked<'a>(&'a self, index: uint) -> &'a T {\n+    unsafe fn get_unchecked(&self, index: usize) -> &T {\n         core_slice::SliceExt::get_unchecked(self, index)\n     }\n \n@@ -901,13 +901,13 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    fn binary_search_by<F>(&self, f: F) -> Result<uint, uint>\n+    fn binary_search_by<F>(&self, f: F) -> Result<usize, usize>\n                         where F: FnMut(&T) -> Ordering {\n         core_slice::SliceExt::binary_search_by(self, f)\n     }\n \n     #[inline]\n-    fn len(&self) -> uint {\n+    fn len(&self) -> usize {\n         core_slice::SliceExt::len(self)\n     }\n \n@@ -917,52 +917,52 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    fn get_mut<'a>(&'a mut self, index: uint) -> Option<&'a mut T> {\n+    fn get_mut(&mut self, index: usize) -> Option<&mut T> {\n         core_slice::SliceExt::get_mut(self, index)\n     }\n \n     #[inline]\n-    fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n+    fn as_mut_slice(&mut self) -> &mut [T] {\n         core_slice::SliceExt::as_mut_slice(self)\n     }\n \n     #[inline]\n-    fn slice_mut<'a>(&'a mut self, start: uint, end: uint) -> &'a mut [T] {\n+    fn slice_mut(&mut self, start: usize, end: usize) -> &mut [T] {\n         &mut self[start .. end]\n     }\n \n     #[inline]\n-    fn slice_from_mut<'a>(&'a mut self, start: uint) -> &'a mut [T] {\n+    fn slice_from_mut(&mut self, start: usize) -> &mut [T] {\n         &mut self[start ..]\n     }\n \n     #[inline]\n-    fn slice_to_mut<'a>(&'a mut self, end: uint) -> &'a mut [T] {\n+    fn slice_to_mut(&mut self, end: usize) -> &mut [T] {\n         &mut self[.. end]\n     }\n \n     #[inline]\n-    fn iter_mut<'a>(&'a mut self) -> IterMut<'a, T> {\n+    fn iter_mut(&mut self) -> IterMut<T> {\n         core_slice::SliceExt::iter_mut(self)\n     }\n \n     #[inline]\n-    fn first_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n+    fn first_mut(&mut self) -> Option<&mut T> {\n         core_slice::SliceExt::first_mut(self)\n     }\n \n     #[inline]\n-    fn tail_mut<'a>(&'a mut self) -> &'a mut [T] {\n+    fn tail_mut(&mut self) -> &mut [T] {\n         core_slice::SliceExt::tail_mut(self)\n     }\n \n     #[inline]\n-    fn init_mut<'a>(&'a mut self) -> &'a mut [T] {\n+    fn init_mut(&mut self) -> &mut [T] {\n         core_slice::SliceExt::init_mut(self)\n     }\n \n     #[inline]\n-    fn last_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n+    fn last_mut(&mut self) -> Option<&mut T> {\n         core_slice::SliceExt::last_mut(self)\n     }\n \n@@ -973,29 +973,29 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    fn splitn_mut<F>(&mut self, n: uint, pred: F) -> SplitNMut<T, F>\n+    fn splitn_mut<F>(&mut self, n: usize, pred: F) -> SplitNMut<T, F>\n                      where F: FnMut(&T) -> bool {\n         core_slice::SliceExt::splitn_mut(self, n, pred)\n     }\n \n     #[inline]\n-    fn rsplitn_mut<F>(&mut self,  n: uint, pred: F) -> RSplitNMut<T, F>\n+    fn rsplitn_mut<F>(&mut self,  n: usize, pred: F) -> RSplitNMut<T, F>\n                       where F: FnMut(&T) -> bool {\n         core_slice::SliceExt::rsplitn_mut(self, n, pred)\n     }\n \n     #[inline]\n-    fn chunks_mut<'a>(&'a mut self, chunk_size: uint) -> ChunksMut<'a, T> {\n+    fn chunks_mut(&mut self, chunk_size: usize) -> ChunksMut<T> {\n         core_slice::SliceExt::chunks_mut(self, chunk_size)\n     }\n \n     #[inline]\n-    fn swap(&mut self, a: uint, b: uint) {\n+    fn swap(&mut self, a: usize, b: usize) {\n         core_slice::SliceExt::swap(self, a, b)\n     }\n \n     #[inline]\n-    fn split_at_mut<'a>(&'a mut self, mid: uint) -> (&'a mut [T], &'a mut [T]) {\n+    fn split_at_mut(&mut self, mid: usize) -> (&mut [T], &mut [T]) {\n         core_slice::SliceExt::split_at_mut(self, mid)\n     }\n \n@@ -1005,7 +1005,7 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    unsafe fn get_unchecked_mut<'a>(&'a mut self, index: uint) -> &'a mut T {\n+    unsafe fn get_unchecked_mut(&mut self, index: usize) -> &mut T {\n         core_slice::SliceExt::get_unchecked_mut(self, index)\n     }\n \n@@ -1030,7 +1030,7 @@ impl<T> SliceExt for [T] {\n         }\n     }\n \n-    fn clone_from_slice(&mut self, src: &[T]) -> uint where T: Clone {\n+    fn clone_from_slice(&mut self, src: &[T]) -> usize where T: Clone {\n         core_slice::SliceExt::clone_from_slice(self, src)\n     }\n \n@@ -1039,7 +1039,7 @@ impl<T> SliceExt for [T] {\n         self.sort_by(|a, b| a.cmp(b))\n     }\n \n-    fn binary_search(&self, x: &T) -> Result<uint, uint> where T: Ord {\n+    fn binary_search(&self, x: &T) -> Result<usize, usize> where T: Ord {\n         core_slice::SliceExt::binary_search(self, x)\n     }\n \n@@ -1051,11 +1051,11 @@ impl<T> SliceExt for [T] {\n         core_slice::SliceExt::prev_permutation(self)\n     }\n \n-    fn position_elem(&self, t: &T) -> Option<uint> where T: PartialEq {\n+    fn position_elem(&self, t: &T) -> Option<usize> where T: PartialEq {\n         core_slice::SliceExt::position_elem(self, t)\n     }\n \n-    fn rposition_elem(&self, t: &T) -> Option<uint> where T: PartialEq {\n+    fn rposition_elem(&self, t: &T) -> Option<usize> where T: PartialEq {\n         core_slice::SliceExt::rposition_elem(self, t)\n     }\n \n@@ -1117,7 +1117,7 @@ pub trait SliceConcatExt<T: ?Sized, U> {\n \n impl<T: Clone, V: AsSlice<T>> SliceConcatExt<T, Vec<T>> for [V] {\n     fn concat(&self) -> Vec<T> {\n-        let size = self.iter().fold(0u, |acc, v| acc + v.as_slice().len());\n+        let size = self.iter().fold(0, |acc, v| acc + v.as_slice().len());\n         let mut result = Vec::with_capacity(size);\n         for v in self {\n             result.push_all(v.as_slice())\n@@ -1126,7 +1126,7 @@ impl<T: Clone, V: AsSlice<T>> SliceConcatExt<T, Vec<T>> for [V] {\n     }\n \n     fn connect(&self, sep: &T) -> Vec<T> {\n-        let size = self.iter().fold(0u, |acc, v| acc + v.as_slice().len());\n+        let size = self.iter().fold(0, |acc, v| acc + v.as_slice().len());\n         let mut result = Vec::with_capacity(size + self.len());\n         let mut first = true;\n         for v in self {\n@@ -1154,13 +1154,13 @@ pub struct ElementSwaps {\n     /// If `true`, emit the last swap that returns the sequence to initial\n     /// state.\n     emit_reset: bool,\n-    swaps_made : uint,\n+    swaps_made : usize,\n }\n \n impl ElementSwaps {\n     /// Creates an `ElementSwaps` iterator for a sequence of `length` elements.\n     #[unstable(feature = \"collections\")]\n-    pub fn new(length: uint) -> ElementSwaps {\n+    pub fn new(length: usize) -> ElementSwaps {\n         // Initialize `sdir` with a direction that position should move in\n         // (all negative at the beginning) and the `size` of the\n         // element (equal to the original index).\n@@ -1201,17 +1201,17 @@ enum Direction { Pos, Neg }\n /// An `Index` and `Direction` together.\n #[derive(Copy, Clone)]\n struct SizeDirection {\n-    size: uint,\n+    size: usize,\n     dir: Direction,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Iterator for ElementSwaps {\n-    type Item = (uint, uint);\n+    type Item = (usize, usize);\n \n     #[inline]\n-    fn next(&mut self) -> Option<(uint, uint)> {\n-        fn new_pos(i: uint, s: Direction) -> uint {\n+    fn next(&mut self) -> Option<(usize, usize)> {\n+        fn new_pos(i: usize, s: Direction) -> usize {\n             i + match s { Pos => 1, Neg => -1 }\n         }\n \n@@ -1253,7 +1253,7 @@ impl Iterator for ElementSwaps {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         // For a vector of size n, there are exactly n! permutations.\n         let n = (2..self.sdir.len() + 1).product();\n         (n - self.swaps_made, Some(n - self.swaps_made))\n@@ -1292,7 +1292,7 @@ impl<T: Clone> Iterator for Permutations<T> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         self.swaps.size_hint()\n     }\n }\n@@ -1302,7 +1302,7 @@ impl<T: Clone> Iterator for Permutations<T> {\n ////////////////////////////////////////////////////////////////////////////////\n \n fn insertion_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Ordering {\n-    let len = v.len() as int;\n+    let len = v.len() as isize;\n     let buf_v = v.as_mut_ptr();\n \n     // 1 <= i < len;\n@@ -1333,7 +1333,7 @@ fn insertion_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> O\n                 let tmp = ptr::read(read_ptr);\n                 ptr::copy_memory(buf_v.offset(j + 1),\n                                  &*buf_v.offset(j),\n-                                 (i - j) as uint);\n+                                 (i - j) as usize);\n                 ptr::copy_nonoverlapping_memory(buf_v.offset(j),\n                                                 &tmp,\n                                                 1);\n@@ -1345,8 +1345,8 @@ fn insertion_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> O\n \n fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Ordering {\n     // warning: this wildly uses unsafe.\n-    static BASE_INSERTION: uint = 32;\n-    static LARGE_INSERTION: uint = 16;\n+    static BASE_INSERTION: usize = 32;\n+    static LARGE_INSERTION: usize = 16;\n \n     // FIXME #12092: smaller insertion runs seems to make sorting\n     // vectors of large elements a little faster on some platforms,\n@@ -1372,7 +1372,7 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Order\n     let mut working_space = Vec::with_capacity(2 * len);\n     // these both are buffers of length `len`.\n     let mut buf_dat = working_space.as_mut_ptr();\n-    let mut buf_tmp = unsafe {buf_dat.offset(len as int)};\n+    let mut buf_tmp = unsafe {buf_dat.offset(len as isize)};\n \n     // length `len`.\n     let buf_v = v.as_ptr();\n@@ -1388,17 +1388,17 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Order\n         // start <= i < len;\n         for i in start..cmp::min(start + insertion, len) {\n             // j satisfies: start <= j <= i;\n-            let mut j = i as int;\n+            let mut j = i as isize;\n             unsafe {\n                 // `i` is in bounds.\n-                let read_ptr = buf_v.offset(i as int);\n+                let read_ptr = buf_v.offset(i as isize);\n \n                 // find where to insert, we need to do strict <,\n                 // rather than <=, to maintain stability.\n \n                 // start <= j - 1 < len, so .offset(j - 1) is in\n                 // bounds.\n-                while j > start as int &&\n+                while j > start as isize &&\n                         compare(&*read_ptr, &*buf_dat.offset(j - 1)) == Less {\n                     j -= 1;\n                 }\n@@ -1411,7 +1411,7 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Order\n                 // `.offset(j)` is always in bounds.\n                 ptr::copy_memory(buf_dat.offset(j + 1),\n                                  &*buf_dat.offset(j),\n-                                 i - j as uint);\n+                                 i - j as usize);\n                 ptr::copy_nonoverlapping_memory(buf_dat.offset(j), read_ptr, 1);\n             }\n         }\n@@ -1432,24 +1432,24 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Order\n                 // the end of the first run & start of the\n                 // second. Offset of `len` is defined, since this is\n                 // precisely one byte past the end of the object.\n-                let right_start = buf_dat.offset(cmp::min(start + width, len) as int);\n+                let right_start = buf_dat.offset(cmp::min(start + width, len) as isize);\n                 // end of the second. Similar reasoning to the above re safety.\n                 let right_end_idx = cmp::min(start + 2 * width, len);\n-                let right_end = buf_dat.offset(right_end_idx as int);\n+                let right_end = buf_dat.offset(right_end_idx as isize);\n \n                 // the pointers to the elements under consideration\n                 // from the two runs.\n \n                 // both of these are in bounds.\n-                let mut left = buf_dat.offset(start as int);\n+                let mut left = buf_dat.offset(start as isize);\n                 let mut right = right_start;\n \n                 // where we're putting the results, it is a run of\n                 // length `2*width`, so we step it once for each step\n                 // of either `left` or `right`.  `buf_tmp` has length\n                 // `len`, so these are in bounds.\n-                let mut out = buf_tmp.offset(start as int);\n-                let out_end = buf_tmp.offset(right_end_idx as int);\n+                let mut out = buf_tmp.offset(start as isize);\n+                let out_end = buf_tmp.offset(right_end_idx as isize);\n \n                 while out < out_end {\n                     // Either the left or the right run are exhausted,\n@@ -1459,11 +1459,11 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Order\n                     // case).\n                     if left == right_start {\n                         // the number remaining in this run.\n-                        let elems = (right_end as uint - right as uint) / mem::size_of::<T>();\n+                        let elems = (right_end as usize - right as usize) / mem::size_of::<T>();\n                         ptr::copy_nonoverlapping_memory(out, &*right, elems);\n                         break;\n                     } else if right == right_end {\n-                        let elems = (right_start as uint - left as uint) / mem::size_of::<T>();\n+                        let elems = (right_start as usize - left as usize) / mem::size_of::<T>();\n                         ptr::copy_nonoverlapping_memory(out, &*left, elems);\n                         break;\n                     }\n@@ -1507,7 +1507,7 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Order\n #[cfg(test)]\n mod tests {\n     use core::cmp::Ordering::{Greater, Less, Equal};\n-    use core::prelude::{Some, None, range, Clone};\n+    use core::prelude::{Some, None, Clone};\n     use core::prelude::{Iterator, IteratorExt};\n     use core::prelude::{AsSlice};\n     use core::prelude::Ord;\n@@ -1520,62 +1520,62 @@ mod tests {\n     use vec::Vec;\n     use super::{ElementSwaps, SliceConcatExt, SliceExt};\n \n-    fn square(n: uint) -> uint { n * n }\n+    fn square(n: usize) -> usize { n * n }\n \n-    fn is_odd(n: &uint) -> bool { *n % 2u == 1u }\n+    fn is_odd(n: &usize) -> bool { *n % 2 == 1 }\n \n     #[test]\n     fn test_from_fn() {\n         // Test on-stack from_fn.\n-        let mut v = (0u..3).map(square).collect::<Vec<_>>();\n+        let mut v: Vec<_> = (0..3).map(square).collect();\n         {\n             let v = v;\n-            assert_eq!(v.len(), 3u);\n-            assert_eq!(v[0], 0u);\n-            assert_eq!(v[1], 1u);\n-            assert_eq!(v[2], 4u);\n+            assert_eq!(v.len(), 3);\n+            assert_eq!(v[0], 0);\n+            assert_eq!(v[1], 1);\n+            assert_eq!(v[2], 4);\n         }\n \n         // Test on-heap from_fn.\n-        v = (0u..5).map(square).collect::<Vec<_>>();\n+        v = (0..5).map(square).collect();\n         {\n             let v = v;\n-            assert_eq!(v.len(), 5u);\n-            assert_eq!(v[0], 0u);\n-            assert_eq!(v[1], 1u);\n-            assert_eq!(v[2], 4u);\n-            assert_eq!(v[3], 9u);\n-            assert_eq!(v[4], 16u);\n+            assert_eq!(v.len(), 5);\n+            assert_eq!(v[0], 0);\n+            assert_eq!(v[1], 1);\n+            assert_eq!(v[2], 4);\n+            assert_eq!(v[3], 9);\n+            assert_eq!(v[4], 16);\n         }\n     }\n \n     #[test]\n     fn test_from_elem() {\n         // Test on-stack from_elem.\n-        let mut v = vec![10u, 10u];\n+        let mut v = vec![10, 10];\n         {\n             let v = v;\n-            assert_eq!(v.len(), 2u);\n-            assert_eq!(v[0], 10u);\n-            assert_eq!(v[1], 10u);\n+            assert_eq!(v.len(), 2);\n+            assert_eq!(v[0], 10);\n+            assert_eq!(v[1], 10);\n         }\n \n         // Test on-heap from_elem.\n-        v = vec![20u, 20u, 20u, 20u, 20u, 20u];\n+        v = vec![20; 6];\n         {\n-            let v = v;\n-            assert_eq!(v[0], 20u);\n-            assert_eq!(v[1], 20u);\n-            assert_eq!(v[2], 20u);\n-            assert_eq!(v[3], 20u);\n-            assert_eq!(v[4], 20u);\n-            assert_eq!(v[5], 20u);\n+            let v = v.as_slice();\n+            assert_eq!(v[0], 20);\n+            assert_eq!(v[1], 20);\n+            assert_eq!(v[2], 20);\n+            assert_eq!(v[3], 20);\n+            assert_eq!(v[4], 20);\n+            assert_eq!(v[5], 20);\n         }\n     }\n \n     #[test]\n     fn test_is_empty() {\n-        let xs: [int; 0] = [];\n+        let xs: [i32; 0] = [];\n         assert!(xs.is_empty());\n         assert!(![0].is_empty());\n     }\n@@ -1625,68 +1625,68 @@ mod tests {\n     #[test]\n     fn test_tail() {\n         let mut a = vec![11];\n-        let b: &[int] = &[];\n+        let b: &[i32] = &[];\n         assert_eq!(a.tail(), b);\n         a = vec![11, 12];\n-        let b: &[int] = &[12];\n+        let b: &[i32] = &[12];\n         assert_eq!(a.tail(), b);\n     }\n \n     #[test]\n     fn test_tail_mut() {\n         let mut a = vec![11];\n-        let b: &mut [int] = &mut [];\n+        let b: &mut [i32] = &mut [];\n         assert!(a.tail_mut() == b);\n         a = vec![11, 12];\n-        let b: &mut [int] = &mut [12];\n+        let b: &mut [_] = &mut [12];\n         assert!(a.tail_mut() == b);\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_tail_empty() {\n-        let a: Vec<int> = vec![];\n+        let a = Vec::<i32>::new();\n         a.tail();\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_tail_mut_empty() {\n-        let mut a: Vec<int> = vec![];\n+        let mut a = Vec::<i32>::new();\n         a.tail_mut();\n     }\n \n     #[test]\n     fn test_init() {\n         let mut a = vec![11];\n-        let b: &[int] = &[];\n+        let b: &[i32] = &[];\n         assert_eq!(a.init(), b);\n         a = vec![11, 12];\n-        let b: &[int] = &[11];\n+        let b: &[_] = &[11];\n         assert_eq!(a.init(), b);\n     }\n \n     #[test]\n     fn test_init_mut() {\n         let mut a = vec![11];\n-        let b: &mut [int] = &mut [];\n+        let b: &mut [i32] = &mut [];\n         assert!(a.init_mut() == b);\n         a = vec![11, 12];\n-        let b: &mut [int] = &mut [11];\n+        let b: &mut [_] = &mut [11];\n         assert!(a.init_mut() == b);\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_init_empty() {\n-        let a: Vec<int> = vec![];\n+        let a = Vec::<i32>::new();\n         a.init();\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_init_mut_empty() {\n-        let mut a: Vec<int> = vec![];\n+        let mut a = Vec::<i32>::new();\n         a.init_mut();\n     }\n \n@@ -1714,26 +1714,26 @@ mod tests {\n     fn test_slice() {\n         // Test fixed length vector.\n         let vec_fixed = [1, 2, 3, 4];\n-        let v_a = vec_fixed[1u..vec_fixed.len()].to_vec();\n-        assert_eq!(v_a.len(), 3u);\n-        let v_a = v_a;\n+        let v_a = vec_fixed[1..vec_fixed.len()].to_vec();\n+        assert_eq!(v_a.len(), 3);\n+\n         assert_eq!(v_a[0], 2);\n         assert_eq!(v_a[1], 3);\n         assert_eq!(v_a[2], 4);\n \n         // Test on stack.\n         let vec_stack: &[_] = &[1, 2, 3];\n-        let v_b = vec_stack[1u..3u].to_vec();\n-        assert_eq!(v_b.len(), 2u);\n-        let v_b = v_b;\n+        let v_b = vec_stack[1..3].to_vec();\n+        assert_eq!(v_b.len(), 2);\n+\n         assert_eq!(v_b[0], 2);\n         assert_eq!(v_b[1], 3);\n \n         // Test `Box<[T]>`\n         let vec_unique = vec![1, 2, 3, 4, 5, 6];\n-        let v_d = vec_unique[1u..6u].to_vec();\n-        assert_eq!(v_d.len(), 5u);\n-        let v_d = v_d;\n+        let v_d = vec_unique[1..6].to_vec();\n+        assert_eq!(v_d.len(), 5);\n+\n         assert_eq!(v_d[0], 2);\n         assert_eq!(v_d[1], 3);\n         assert_eq!(v_d[2], 4);\n@@ -1743,21 +1743,21 @@ mod tests {\n \n     #[test]\n     fn test_slice_from() {\n-        let vec: &[int] = &[1, 2, 3, 4];\n+        let vec: &[_] = &[1, 2, 3, 4];\n         assert_eq!(&vec[], vec);\n-        let b: &[int] = &[3, 4];\n+        let b: &[_] = &[3, 4];\n         assert_eq!(&vec[2..], b);\n-        let b: &[int] = &[];\n+        let b: &[_] = &[];\n         assert_eq!(&vec[4..], b);\n     }\n \n     #[test]\n     fn test_slice_to() {\n-        let vec: &[int] = &[1, 2, 3, 4];\n+        let vec: &[_] = &[1, 2, 3, 4];\n         assert_eq!(&vec[..4], vec);\n-        let b: &[int] = &[1, 2];\n+        let b: &[_] = &[1, 2];\n         assert_eq!(&vec[..2], b);\n-        let b: &[int] = &[];\n+        let b: &[_] = &[];\n         assert_eq!(&vec[..0], b);\n     }\n \n@@ -1813,12 +1813,12 @@ mod tests {\n         // Test on-stack push().\n         let mut v = vec![];\n         v.push(1);\n-        assert_eq!(v.len(), 1u);\n+        assert_eq!(v.len(), 1);\n         assert_eq!(v[0], 1);\n \n         // Test on-heap push().\n         v.push(2);\n-        assert_eq!(v.len(), 2u);\n+        assert_eq!(v.len(), 2);\n         assert_eq!(v[0], 1);\n         assert_eq!(v[1], 2);\n     }\n@@ -1843,19 +1843,19 @@ mod tests {\n \n     #[test]\n     fn test_dedup() {\n-        fn case(a: Vec<uint>, b: Vec<uint>) {\n+        fn case(a: Vec<i32>, b: Vec<i32>) {\n             let mut v = a;\n             v.dedup();\n             assert_eq!(v, b);\n         }\n         case(vec![], vec![]);\n-        case(vec![1u], vec![1]);\n-        case(vec![1u,1], vec![1]);\n-        case(vec![1u,2,3], vec![1,2,3]);\n-        case(vec![1u,1,2,3], vec![1,2,3]);\n-        case(vec![1u,2,2,3], vec![1,2,3]);\n-        case(vec![1u,2,3,3], vec![1,2,3]);\n-        case(vec![1u,1,2,2,2,3,3], vec![1,2,3]);\n+        case(vec![1], vec![1]);\n+        case(vec![1,1], vec![1]);\n+        case(vec![1,2,3], vec![1,2,3]);\n+        case(vec![1,1,2,3], vec![1,2,3]);\n+        case(vec![1,2,2,3], vec![1,2,3]);\n+        case(vec![1,2,3,3], vec![1,2,3]);\n+        case(vec![1,1,2,2,2,3,3], vec![1,2,3]);\n     }\n \n     #[test]\n@@ -1888,9 +1888,9 @@ mod tests {\n \n     #[test]\n     fn test_retain() {\n-        let mut v = vec![1u, 2, 3, 4, 5];\n+        let mut v = vec![1, 2, 3, 4, 5];\n         v.retain(is_odd);\n-        assert_eq!(v, vec![1u, 3, 5]);\n+        assert_eq!(v, vec![1, 3, 5]);\n     }\n \n     #[test]\n@@ -1913,7 +1913,7 @@ mod tests {\n     #[test]\n     fn test_permutations() {\n         {\n-            let v: [int; 0] = [];\n+            let v: [i32; 0] = [];\n             let mut it = v.permutations();\n             let (min_size, max_opt) = it.size_hint();\n             assert_eq!(min_size, 1);\n@@ -1965,56 +1965,56 @@ mod tests {\n \n     #[test]\n     fn test_lexicographic_permutations() {\n-        let v : &mut[int] = &mut[1, 2, 3, 4, 5];\n+        let v : &mut[_] = &mut[1, 2, 3, 4, 5];\n         assert!(v.prev_permutation() == false);\n         assert!(v.next_permutation());\n-        let b: &mut[int] = &mut[1, 2, 3, 5, 4];\n+        let b: &mut[_] = &mut[1, 2, 3, 5, 4];\n         assert!(v == b);\n         assert!(v.prev_permutation());\n-        let b: &mut[int] = &mut[1, 2, 3, 4, 5];\n+        let b: &mut[_] = &mut[1, 2, 3, 4, 5];\n         assert!(v == b);\n         assert!(v.next_permutation());\n         assert!(v.next_permutation());\n-        let b: &mut[int] = &mut[1, 2, 4, 3, 5];\n+        let b: &mut[_] = &mut[1, 2, 4, 3, 5];\n         assert!(v == b);\n         assert!(v.next_permutation());\n-        let b: &mut[int] = &mut[1, 2, 4, 5, 3];\n+        let b: &mut[_] = &mut[1, 2, 4, 5, 3];\n         assert!(v == b);\n \n-        let v : &mut[int] = &mut[1, 0, 0, 0];\n+        let v : &mut[_] = &mut[1, 0, 0, 0];\n         assert!(v.next_permutation() == false);\n         assert!(v.prev_permutation());\n-        let b: &mut[int] = &mut[0, 1, 0, 0];\n+        let b: &mut[_] = &mut[0, 1, 0, 0];\n         assert!(v == b);\n         assert!(v.prev_permutation());\n-        let b: &mut[int] = &mut[0, 0, 1, 0];\n+        let b: &mut[_] = &mut[0, 0, 1, 0];\n         assert!(v == b);\n         assert!(v.prev_permutation());\n-        let b: &mut[int] = &mut[0, 0, 0, 1];\n+        let b: &mut[_] = &mut[0, 0, 0, 1];\n         assert!(v == b);\n         assert!(v.prev_permutation() == false);\n     }\n \n     #[test]\n     fn test_lexicographic_permutations_empty_and_short() {\n-        let empty : &mut[int] = &mut[];\n+        let empty : &mut[i32] = &mut[];\n         assert!(empty.next_permutation() == false);\n-        let b: &mut[int] = &mut[];\n+        let b: &mut[i32] = &mut[];\n         assert!(empty == b);\n         assert!(empty.prev_permutation() == false);\n         assert!(empty == b);\n \n-        let one_elem : &mut[int] = &mut[4];\n+        let one_elem : &mut[_] = &mut[4];\n         assert!(one_elem.prev_permutation() == false);\n-        let b: &mut[int] = &mut[4];\n+        let b: &mut[_] = &mut[4];\n         assert!(one_elem == b);\n         assert!(one_elem.next_permutation() == false);\n         assert!(one_elem == b);\n \n-        let two_elem : &mut[int] = &mut[1, 2];\n+        let two_elem : &mut[_] = &mut[1, 2];\n         assert!(two_elem.prev_permutation() == false);\n-        let b : &mut[int] = &mut[1, 2];\n-        let c : &mut[int] = &mut[2, 1];\n+        let b : &mut[_] = &mut[1, 2];\n+        let c : &mut[_] = &mut[2, 1];\n         assert!(two_elem == b);\n         assert!(two_elem.next_permutation());\n         assert!(two_elem == c);\n@@ -2031,9 +2031,9 @@ mod tests {\n         assert!([].position_elem(&1).is_none());\n \n         let v1 = vec![1, 2, 3, 3, 2, 5];\n-        assert_eq!(v1.position_elem(&1), Some(0u));\n-        assert_eq!(v1.position_elem(&2), Some(1u));\n-        assert_eq!(v1.position_elem(&5), Some(5u));\n+        assert_eq!(v1.position_elem(&1), Some(0));\n+        assert_eq!(v1.position_elem(&2), Some(1));\n+        assert_eq!(v1.position_elem(&5), Some(5));\n         assert!(v1.position_elem(&4).is_none());\n     }\n \n@@ -2084,24 +2084,23 @@ mod tests {\n \n     #[test]\n     fn test_reverse() {\n-        let mut v: Vec<int> = vec![10, 20];\n+        let mut v = vec![10, 20];\n         assert_eq!(v[0], 10);\n         assert_eq!(v[1], 20);\n         v.reverse();\n         assert_eq!(v[0], 20);\n         assert_eq!(v[1], 10);\n \n-        let mut v3: Vec<int> = vec![];\n+        let mut v3 = Vec::<i32>::new();\n         v3.reverse();\n         assert!(v3.is_empty());\n     }\n \n     #[test]\n     fn test_sort() {\n-        for len in 4u..25 {\n+        for len in 4..25 {\n             for _ in 0..100 {\n-                let mut v = thread_rng().gen_iter::<uint>().take(len)\n-                                      .collect::<Vec<uint>>();\n+                let mut v: Vec<_> = thread_rng().gen_iter::<i32>().take(len).collect();\n                 let mut v1 = v.clone();\n \n                 v.sort();\n@@ -2116,30 +2115,30 @@ mod tests {\n         }\n \n         // shouldn't panic\n-        let mut v: [uint; 0] = [];\n+        let mut v: [i32; 0] = [];\n         v.sort();\n \n-        let mut v = [0xDEADBEEFu];\n+        let mut v = [0xDEADBEEFu64];\n         v.sort();\n         assert!(v == [0xDEADBEEF]);\n     }\n \n     #[test]\n     fn test_sort_stability() {\n         for len in 4..25 {\n-            for _ in 0u..10 {\n+            for _ in 0..10 {\n                 let mut counts = [0; 10];\n \n                 // create a vector like [(6, 1), (5, 1), (6, 2), ...],\n                 // where the first item of each tuple is random, but\n                 // the second item represents which occurrence of that\n                 // number this element is, i.e. the second elements\n                 // will occur in sorted order.\n-                let mut v = (0..len).map(|_| {\n-                        let n = thread_rng().gen::<uint>() % 10;\n+                let mut v: Vec<_> = (0..len).map(|_| {\n+                        let n = thread_rng().gen::<usize>() % 10;\n                         counts[n] += 1;\n                         (n, counts[n])\n-                    }).collect::<Vec<(uint, int)>>();\n+                    }).collect();\n \n                 // only sort on the first element, so an unstable sort\n                 // may mix up the counts.\n@@ -2157,28 +2156,28 @@ mod tests {\n \n     #[test]\n     fn test_concat() {\n-        let v: [Vec<int>; 0] = [];\n-        let c: Vec<int> = v.concat();\n+        let v: [Vec<i32>; 0] = [];\n+        let c = v.concat();\n         assert_eq!(c, []);\n-        let d: Vec<int> = [vec![1], vec![2,3]].concat();\n+        let d = [vec![1], vec![2,3]].concat();\n         assert_eq!(d, vec![1, 2, 3]);\n \n-        let v: [&[int]; 2] = [&[1], &[2, 3]];\n+        let v: &[&[_]] = &[&[1], &[2, 3]];\n         assert_eq!(v.connect(&0), vec![1, 0, 2, 3]);\n-        let v: [&[int]; 3] = [&[1], &[2], &[3]];\n+        let v: &[&[_]] = &[&[1], &[2], &[3]];\n         assert_eq!(v.connect(&0), vec![1, 0, 2, 0, 3]);\n     }\n \n     #[test]\n     fn test_connect() {\n-        let v: [Vec<int>; 0] = [];\n+        let v: [Vec<i32>; 0] = [];\n         assert_eq!(v.connect(&0), vec![]);\n         assert_eq!([vec![1], vec![2, 3]].connect(&0), vec![1, 0, 2, 3]);\n         assert_eq!([vec![1], vec![2], vec![3]].connect(&0), vec![1, 0, 2, 0, 3]);\n \n-        let v: [&[int]; 2] = [&[1], &[2, 3]];\n+        let v: [&[_]; 2] = [&[1], &[2, 3]];\n         assert_eq!(v.connect(&0), vec![1, 0, 2, 3]);\n-        let v: [&[int]; 3] = [&[1], &[2], &[3]];\n+        let v: [&[_]; 3] = [&[1], &[2], &[3]];\n         assert_eq!(v.connect(&0), vec![1, 0, 2, 0, 3]);\n     }\n \n@@ -2210,13 +2209,13 @@ mod tests {\n \n     #[test]\n     fn test_remove() {\n-        let mut a = vec![1,2,3,4];\n+        let mut a = vec![1, 2, 3, 4];\n \n         assert_eq!(a.remove(2), 3);\n-        assert_eq!(a, vec![1,2,4]);\n+        assert_eq!(a, vec![1, 2, 4]);\n \n         assert_eq!(a.remove(2), 4);\n-        assert_eq!(a, vec![1,2]);\n+        assert_eq!(a, vec![1, 2]);\n \n         assert_eq!(a.remove(0), 1);\n         assert_eq!(a, vec![2]);\n@@ -2235,19 +2234,16 @@ mod tests {\n \n     #[test]\n     fn test_capacity() {\n-        let mut v = vec![0u64];\n-        v.reserve_exact(10u);\n-        assert!(v.capacity() >= 11u);\n-        let mut v = vec![0u32];\n-        v.reserve_exact(10u);\n-        assert!(v.capacity() >= 11u);\n+        let mut v = vec![0];\n+        v.reserve_exact(10);\n+        assert!(v.capacity() >= 11);\n     }\n \n     #[test]\n     fn test_slice_2() {\n         let v = vec![1, 2, 3, 4, 5];\n-        let v = v.slice(1u, 3u);\n-        assert_eq!(v.len(), 2u);\n+        let v = v.slice(1, 3);\n+        assert_eq!(v.len(), 2);\n         assert_eq!(v[0], 2);\n         assert_eq!(v[1], 3);\n     }\n@@ -2257,7 +2253,7 @@ mod tests {\n     fn test_permute_fail() {\n         let v = [(box 0, Rc::new(0)), (box 0, Rc::new(0)),\n                  (box 0, Rc::new(0)), (box 0, Rc::new(0))];\n-        let mut i = 0u;\n+        let mut i = 0;\n         for _ in v.permutations() {\n             if i == 2 {\n                 panic!()\n@@ -2268,15 +2264,15 @@ mod tests {\n \n     #[test]\n     fn test_total_ord() {\n-        let c: &[int] = &[1, 2, 3];\n+        let c = &[1, 2, 3];\n         [1, 2, 3, 4][].cmp(c) == Greater;\n-        let c: &[int] = &[1, 2, 3, 4];\n+        let c = &[1, 2, 3, 4];\n         [1, 2, 3][].cmp(c) == Less;\n-        let c: &[int] = &[1, 2, 3, 6];\n+        let c = &[1, 2, 3, 6];\n         [1, 2, 3, 4][].cmp(c) == Equal;\n-        let c: &[int] = &[1, 2, 3, 4, 5, 6];\n+        let c = &[1, 2, 3, 4, 5, 6];\n         [1, 2, 3, 4, 5, 5, 5, 5][].cmp(c) == Less;\n-        let c: &[int] = &[1, 2, 3, 4];\n+        let c = &[1, 2, 3, 4];\n         [2, 2][].cmp(c) == Greater;\n     }\n \n@@ -2378,7 +2374,7 @@ mod tests {\n \n     #[test]\n     fn test_mut_rev_iterator() {\n-        let mut xs = [1u, 2, 3, 4, 5];\n+        let mut xs = [1, 2, 3, 4, 5];\n         for (i,x) in xs.iter_mut().rev().enumerate() {\n             *x += i;\n         }\n@@ -2387,129 +2383,130 @@ mod tests {\n \n     #[test]\n     fn test_move_iterator() {\n-        let xs = vec![1u,2,3,4,5];\n-        assert_eq!(xs.into_iter().fold(0, |a: uint, b: uint| 10*a + b), 12345);\n+        let xs = vec![1,2,3,4,5];\n+        assert_eq!(xs.into_iter().fold(0, |a: usize, b: usize| 10*a + b), 12345);\n     }\n \n     #[test]\n     fn test_move_rev_iterator() {\n-        let xs = vec![1u,2,3,4,5];\n-        assert_eq!(xs.into_iter().rev().fold(0, |a: uint, b: uint| 10*a + b), 54321);\n+        let xs = vec![1,2,3,4,5];\n+        assert_eq!(xs.into_iter().rev().fold(0, |a: usize, b: usize| 10*a + b), 54321);\n     }\n \n     #[test]\n     fn test_splitator() {\n         let xs = &[1,2,3,4,5];\n \n-        let splits: &[&[int]] = &[&[1], &[3], &[5]];\n-        assert_eq!(xs.split(|x| *x % 2 == 0).collect::<Vec<&[int]>>(),\n+        let splits: &[&[_]] = &[&[1], &[3], &[5]];\n+        assert_eq!(xs.split(|x| *x % 2 == 0).collect::<Vec<_>>(),\n                    splits);\n-        let splits: &[&[int]] = &[&[], &[2,3,4,5]];\n-        assert_eq!(xs.split(|x| *x == 1).collect::<Vec<&[int]>>(),\n+        let splits: &[&[_]] = &[&[], &[2,3,4,5]];\n+        assert_eq!(xs.split(|x| *x == 1).collect::<Vec<_>>(),\n                    splits);\n-        let splits: &[&[int]] = &[&[1,2,3,4], &[]];\n-        assert_eq!(xs.split(|x| *x == 5).collect::<Vec<&[int]>>(),\n+        let splits: &[&[_]] = &[&[1,2,3,4], &[]];\n+        assert_eq!(xs.split(|x| *x == 5).collect::<Vec<_>>(),\n                    splits);\n-        let splits: &[&[int]] = &[&[1,2,3,4,5]];\n-        assert_eq!(xs.split(|x| *x == 10).collect::<Vec<&[int]>>(),\n+        let splits: &[&[_]] = &[&[1,2,3,4,5]];\n+        assert_eq!(xs.split(|x| *x == 10).collect::<Vec<_>>(),\n                    splits);\n-        let splits: &[&[int]] = &[&[], &[], &[], &[], &[], &[]];\n-        assert_eq!(xs.split(|_| true).collect::<Vec<&[int]>>(),\n+        let splits: &[&[_]] = &[&[], &[], &[], &[], &[], &[]];\n+        assert_eq!(xs.split(|_| true).collect::<Vec<&[i32]>>(),\n                    splits);\n \n-        let xs: &[int] = &[];\n-        let splits: &[&[int]] = &[&[]];\n-        assert_eq!(xs.split(|x| *x == 5).collect::<Vec<&[int]>>(), splits);\n+        let xs: &[i32] = &[];\n+        let splits: &[&[i32]] = &[&[]];\n+        assert_eq!(xs.split(|x| *x == 5).collect::<Vec<&[i32]>>(), splits);\n     }\n \n     #[test]\n     fn test_splitnator() {\n         let xs = &[1,2,3,4,5];\n \n-        let splits: &[&[int]] = &[&[1,2,3,4,5]];\n-        assert_eq!(xs.splitn(0, |x| *x % 2 == 0).collect::<Vec<&[int]>>(),\n+        let splits: &[&[_]] = &[&[1,2,3,4,5]];\n+        assert_eq!(xs.splitn(0, |x| *x % 2 == 0).collect::<Vec<_>>(),\n                    splits);\n-        let splits: &[&[int]] = &[&[1], &[3,4,5]];\n-        assert_eq!(xs.splitn(1, |x| *x % 2 == 0).collect::<Vec<&[int]>>(),\n+        let splits: &[&[_]] = &[&[1], &[3,4,5]];\n+        assert_eq!(xs.splitn(1, |x| *x % 2 == 0).collect::<Vec<_>>(),\n                    splits);\n-        let splits: &[&[int]] = &[&[], &[], &[], &[4,5]];\n-        assert_eq!(xs.splitn(3, |_| true).collect::<Vec<&[int]>>(),\n+        let splits: &[&[_]] = &[&[], &[], &[], &[4,5]];\n+        assert_eq!(xs.splitn(3, |_| true).collect::<Vec<_>>(),\n                    splits);\n \n-        let xs: &[int] = &[];\n-        let splits: &[&[int]] = &[&[]];\n-        assert_eq!(xs.splitn(1, |x| *x == 5).collect::<Vec<&[int]>>(), splits);\n+        let xs: &[i32] = &[];\n+        let splits: &[&[i32]] = &[&[]];\n+        assert_eq!(xs.splitn(1, |x| *x == 5).collect::<Vec<_>>(), splits);\n     }\n \n     #[test]\n     fn test_splitnator_mut() {\n         let xs = &mut [1,2,3,4,5];\n \n-        let splits: &[&mut [int]] = &[&mut [1,2,3,4,5]];\n-        assert_eq!(xs.splitn_mut(0, |x| *x % 2 == 0).collect::<Vec<&mut [int]>>(),\n+        let splits: &[&mut[_]] = &[&mut [1,2,3,4,5]];\n+        assert_eq!(xs.splitn_mut(0, |x| *x % 2 == 0).collect::<Vec<_>>(),\n                    splits);\n-        let splits: &[&mut [int]] = &[&mut [1], &mut [3,4,5]];\n-        assert_eq!(xs.splitn_mut(1, |x| *x % 2 == 0).collect::<Vec<&mut [int]>>(),\n+        let splits: &[&mut[_]] = &[&mut [1], &mut [3,4,5]];\n+        assert_eq!(xs.splitn_mut(1, |x| *x % 2 == 0).collect::<Vec<_>>(),\n                    splits);\n-        let splits: &[&mut [int]] = &[&mut [], &mut [], &mut [], &mut [4,5]];\n-        assert_eq!(xs.splitn_mut(3, |_| true).collect::<Vec<&mut [int]>>(),\n+        let splits: &[&mut[_]] = &[&mut [], &mut [], &mut [], &mut [4,5]];\n+        assert_eq!(xs.splitn_mut(3, |_| true).collect::<Vec<_>>(),\n                    splits);\n \n-        let xs: &mut [int] = &mut [];\n-        let splits: &[&mut [int]] = &[&mut []];\n-        assert_eq!(xs.splitn_mut(1, |x| *x == 5).collect::<Vec<&mut [int]>>(),\n+        let xs: &mut [i32] = &mut [];\n+        let splits: &[&mut[i32]] = &[&mut []];\n+        assert_eq!(xs.splitn_mut(1, |x| *x == 5).collect::<Vec<_>>(),\n                    splits);\n     }\n \n     #[test]\n     fn test_rsplitator() {\n         let xs = &[1,2,3,4,5];\n \n-        let splits: &[&[int]] = &[&[5], &[3], &[1]];\n-        assert_eq!(xs.split(|x| *x % 2 == 0).rev().collect::<Vec<&[int]>>(),\n+        let splits: &[&[_]] = &[&[5], &[3], &[1]];\n+        assert_eq!(xs.split(|x| *x % 2 == 0).rev().collect::<Vec<_>>(),\n                    splits);\n-        let splits: &[&[int]] = &[&[2,3,4,5], &[]];\n-        assert_eq!(xs.split(|x| *x == 1).rev().collect::<Vec<&[int]>>(),\n+        let splits: &[&[_]] = &[&[2,3,4,5], &[]];\n+        assert_eq!(xs.split(|x| *x == 1).rev().collect::<Vec<_>>(),\n                    splits);\n-        let splits: &[&[int]] = &[&[], &[1,2,3,4]];\n-        assert_eq!(xs.split(|x| *x == 5).rev().collect::<Vec<&[int]>>(),\n+        let splits: &[&[_]] = &[&[], &[1,2,3,4]];\n+        assert_eq!(xs.split(|x| *x == 5).rev().collect::<Vec<_>>(),\n                    splits);\n-        let splits: &[&[int]] = &[&[1,2,3,4,5]];\n-        assert_eq!(xs.split(|x| *x == 10).rev().collect::<Vec<&[int]>>(),\n+        let splits: &[&[_]] = &[&[1,2,3,4,5]];\n+        assert_eq!(xs.split(|x| *x == 10).rev().collect::<Vec<_>>(),\n                    splits);\n \n-        let xs: &[int] = &[];\n-        let splits: &[&[int]] = &[&[]];\n-        assert_eq!(xs.split(|x| *x == 5).rev().collect::<Vec<&[int]>>(), splits);\n+        let xs: &[i32] = &[];\n+        let splits: &[&[i32]] = &[&[]];\n+        assert_eq!(xs.split(|x| *x == 5).rev().collect::<Vec<&[i32]>>(), splits);\n     }\n \n     #[test]\n     fn test_rsplitnator() {\n         let xs = &[1,2,3,4,5];\n \n-        let splits: &[&[int]] = &[&[1,2,3,4,5]];\n-        assert_eq!(xs.rsplitn(0, |x| *x % 2 == 0).collect::<Vec<&[int]>>(),\n+        let splits: &[&[_]] = &[&[1,2,3,4,5]];\n+        assert_eq!(xs.rsplitn(0, |x| *x % 2 == 0).collect::<Vec<_>>(),\n                    splits);\n-        let splits: &[&[int]] = &[&[5], &[1,2,3]];\n-        assert_eq!(xs.rsplitn(1, |x| *x % 2 == 0).collect::<Vec<&[int]>>(),\n+        let splits: &[&[_]] = &[&[5], &[1,2,3]];\n+        assert_eq!(xs.rsplitn(1, |x| *x % 2 == 0).collect::<Vec<_>>(),\n                    splits);\n-        let splits: &[&[int]] = &[&[], &[], &[], &[1,2]];\n-        assert_eq!(xs.rsplitn(3, |_| true).collect::<Vec<&[int]>>(),\n+        let splits: &[&[_]] = &[&[], &[], &[], &[1,2]];\n+        assert_eq!(xs.rsplitn(3, |_| true).collect::<Vec<_>>(),\n                    splits);\n \n-        let xs: &[int] = &[];\n-        let splits: &[&[int]] = &[&[]];\n-        assert_eq!(xs.rsplitn(1, |x| *x == 5).collect::<Vec<&[int]>>(), splits);\n+        let xs: &[i32]  = &[];\n+        let splits: &[&[i32]] = &[&[]];\n+        assert_eq!(xs.rsplitn(1, |x| *x == 5).collect::<Vec<&[i32]>>(), splits);\n     }\n \n     #[test]\n     fn test_windowsator() {\n         let v = &[1,2,3,4];\n \n-        let wins: &[&[int]] = &[&[1,2], &[2,3], &[3,4]];\n-        assert_eq!(v.windows(2).collect::<Vec<&[int]>>(), wins);\n-        let wins: &[&[int]] = &[&[1,2,3], &[2,3,4]];\n-        assert_eq!(v.windows(3).collect::<Vec<&[int]>>(), wins);\n+        let wins: &[&[_]] = &[&[1,2], &[2,3], &[3,4]];\n+        assert_eq!(v.windows(2).collect::<Vec<_>>(), wins);\n+\n+        let wins: &[&[_]] = &[&[1,2,3], &[2,3,4]];\n+        assert_eq!(v.windows(3).collect::<Vec<_>>(), wins);\n         assert!(v.windows(6).next().is_none());\n     }\n \n@@ -2528,22 +2525,23 @@ mod tests {\n \n         assert_eq!(v.chunks(2).len(), 3);\n \n-        let chunks: &[&[int]] = &[&[1,2], &[3,4], &[5]];\n-        assert_eq!(v.chunks(2).collect::<Vec<&[int]>>(), chunks);\n-        let chunks: &[&[int]] = &[&[1,2,3], &[4,5]];\n-        assert_eq!(v.chunks(3).collect::<Vec<&[int]>>(), chunks);\n-        let chunks: &[&[int]] = &[&[1,2,3,4,5]];\n-        assert_eq!(v.chunks(6).collect::<Vec<&[int]>>(), chunks);\n+        let chunks: &[&[_]] = &[&[1,2], &[3,4], &[5]];\n+        assert_eq!(v.chunks(2).collect::<Vec<_>>(), chunks);\n+        let chunks: &[&[_]] = &[&[1,2,3], &[4,5]];\n+        assert_eq!(v.chunks(3).collect::<Vec<_>>(), chunks);\n+        let chunks: &[&[_]] = &[&[1,2,3,4,5]];\n+        assert_eq!(v.chunks(6).collect::<Vec<_>>(), chunks);\n \n-        let chunks: &[&[int]] = &[&[5], &[3,4], &[1,2]];\n-        assert_eq!(v.chunks(2).rev().collect::<Vec<&[int]>>(), chunks);\n+        let chunks: &[&[_]] = &[&[5], &[3,4], &[1,2]];\n+        assert_eq!(v.chunks(2).rev().collect::<Vec<_>>(), chunks);\n         let mut it = v.chunks(2);\n         assert_eq!(it.indexable(), 3);\n-        let chunk: &[int] = &[1,2];\n+\n+        let chunk: &[_] = &[1,2];\n         assert_eq!(it.idx(0).unwrap(), chunk);\n-        let chunk: &[int] = &[3,4];\n+        let chunk: &[_] = &[3,4];\n         assert_eq!(it.idx(1).unwrap(), chunk);\n-        let chunk: &[int] = &[5];\n+        let chunk: &[_] = &[5];\n         assert_eq!(it.idx(2).unwrap(), chunk);\n         assert_eq!(it.idx(3), None);\n     }\n@@ -2591,20 +2589,20 @@ mod tests {\n                 assert_eq!(format!(\"{:?}\", x), x_str);\n             })\n         }\n-        let empty: Vec<int> = vec![];\n+        let empty = Vec::<i32>::new();\n         test_show_vec!(empty, \"[]\");\n         test_show_vec!(vec![1], \"[1]\");\n         test_show_vec!(vec![1, 2, 3], \"[1, 2, 3]\");\n-        test_show_vec!(vec![vec![], vec![1u], vec![1u, 1u]],\n+        test_show_vec!(vec![vec![], vec![1], vec![1, 1]],\n                        \"[[], [1], [1, 1]]\");\n \n-        let empty_mut: &mut [int] = &mut[];\n+        let empty_mut: &mut [i32] = &mut[];\n         test_show_vec!(empty_mut, \"[]\");\n-        let v: &mut[int] = &mut[1];\n+        let v = &mut[1];\n         test_show_vec!(v, \"[1]\");\n-        let v: &mut[int] = &mut[1, 2, 3];\n+        let v = &mut[1, 2, 3];\n         test_show_vec!(v, \"[1, 2, 3]\");\n-        let v: &mut [&mut[uint]] = &mut[&mut[], &mut[1u], &mut[1u, 1u]];\n+        let v: &mut[&mut[_]] = &mut[&mut[], &mut[1], &mut[1, 1]];\n         test_show_vec!(v, \"[[], [1], [1, 1]]\");\n     }\n \n@@ -2617,8 +2615,8 @@ mod tests {\n             }}\n         }\n \n-        t!(&[int]);\n-        t!(Vec<int>);\n+        t!(&[i32]);\n+        t!(Vec<i32>);\n     }\n \n     #[test]\n@@ -2680,7 +2678,7 @@ mod tests {\n     fn test_iter_zero_sized() {\n         let mut v = vec![Foo, Foo, Foo];\n         assert_eq!(v.len(), 3);\n-        let mut cnt = 0u;\n+        let mut cnt = 0;\n \n         for f in &v {\n             assert!(*f == Foo);\n@@ -2830,15 +2828,15 @@ mod tests {\n         let h = x.last_mut();\n         assert_eq!(*h.unwrap(), 5);\n \n-        let y: &mut [int] = &mut [];\n+        let y: &mut [i32] = &mut [];\n         assert!(y.last_mut().is_none());\n     }\n \n     #[test]\n     fn test_to_vec() {\n-        let xs = box [1u, 2, 3];\n+        let xs = box [1, 2, 3];\n         let ys = xs.to_vec();\n-        assert_eq!(ys, [1u, 2, 3]);\n+        assert_eq!(ys, [1, 2, 3]);\n     }\n }\n \n@@ -2855,7 +2853,7 @@ mod bench {\n     fn iterator(b: &mut Bencher) {\n         // peculiar numbers to stop LLVM from optimising the summation\n         // out.\n-        let v = (0u..100).map(|i| i ^ (i << 1) ^ (i >> 1)).collect::<Vec<_>>();\n+        let v: Vec<_> = (0..100).map(|i| i ^ (i << 1) ^ (i >> 1)).collect();\n \n         b.iter(|| {\n             let mut sum = 0;\n@@ -2869,7 +2867,7 @@ mod bench {\n \n     #[bench]\n     fn mut_iterator(b: &mut Bencher) {\n-        let mut v = repeat(0).take(100).collect::<Vec<_>>();\n+        let mut v: Vec<_> = repeat(0).take(100).collect();\n \n         b.iter(|| {\n             let mut i = 0;\n@@ -2882,25 +2880,25 @@ mod bench {\n \n     #[bench]\n     fn concat(b: &mut Bencher) {\n-        let xss: Vec<Vec<uint>> =\n-            (0..100u).map(|i| (0..i).collect()).collect();\n+        let xss: Vec<Vec<i32>> =\n+            (0..100).map(|i| (0..i).collect()).collect();\n         b.iter(|| {\n             xss.concat();\n         });\n     }\n \n     #[bench]\n     fn connect(b: &mut Bencher) {\n-        let xss: Vec<Vec<uint>> =\n-            (0..100u).map(|i| (0..i).collect()).collect();\n+        let xss: Vec<Vec<i32>> =\n+            (0..100).map(|i| (0..i).collect()).collect();\n         b.iter(|| {\n             xss.connect(&0)\n         });\n     }\n \n     #[bench]\n     fn push(b: &mut Bencher) {\n-        let mut vec: Vec<uint> = vec![];\n+        let mut vec = Vec::<i32>::new();\n         b.iter(|| {\n             vec.push(0);\n             black_box(&vec);\n@@ -2909,24 +2907,24 @@ mod bench {\n \n     #[bench]\n     fn starts_with_same_vector(b: &mut Bencher) {\n-        let vec: Vec<uint> = (0u..100).collect();\n+        let vec: Vec<_> = (0..100).collect();\n         b.iter(|| {\n             vec.starts_with(&vec)\n         })\n     }\n \n     #[bench]\n     fn starts_with_single_element(b: &mut Bencher) {\n-        let vec: Vec<uint> = vec![0];\n+        let vec: Vec<_> = vec![0];\n         b.iter(|| {\n             vec.starts_with(&vec)\n         })\n     }\n \n     #[bench]\n     fn starts_with_diff_one_element_at_end(b: &mut Bencher) {\n-        let vec: Vec<uint> = (0u..100).collect();\n-        let mut match_vec: Vec<uint> = (0u..99).collect();\n+        let vec: Vec<_> = (0..100).collect();\n+        let mut match_vec: Vec<_> = (0..99).collect();\n         match_vec.push(0);\n         b.iter(|| {\n             vec.starts_with(&match_vec)\n@@ -2935,24 +2933,24 @@ mod bench {\n \n     #[bench]\n     fn ends_with_same_vector(b: &mut Bencher) {\n-        let vec: Vec<uint> = (0u..100).collect();\n+        let vec: Vec<_> = (0..100).collect();\n         b.iter(|| {\n             vec.ends_with(&vec)\n         })\n     }\n \n     #[bench]\n     fn ends_with_single_element(b: &mut Bencher) {\n-        let vec: Vec<uint> = vec![0];\n+        let vec: Vec<_> = vec![0];\n         b.iter(|| {\n             vec.ends_with(&vec)\n         })\n     }\n \n     #[bench]\n     fn ends_with_diff_one_element_at_beginning(b: &mut Bencher) {\n-        let vec: Vec<uint> = (0u..100).collect();\n-        let mut match_vec: Vec<uint> = (0u..100).collect();\n+        let vec: Vec<_> = (0..100).collect();\n+        let mut match_vec: Vec<_> = (0..100).collect();\n         match_vec[0] = 200;\n         b.iter(|| {\n             vec.starts_with(&match_vec)\n@@ -2961,9 +2959,9 @@ mod bench {\n \n     #[bench]\n     fn contains_last_element(b: &mut Bencher) {\n-        let vec: Vec<uint> = (0u..100).collect();\n+        let vec: Vec<_> = (0..100).collect();\n         b.iter(|| {\n-            vec.contains(&99u)\n+            vec.contains(&99)\n         })\n     }\n \n@@ -2977,7 +2975,7 @@ mod bench {\n     #[bench]\n     fn zero_1kb_set_memory(b: &mut Bencher) {\n         b.iter(|| {\n-            let mut v: Vec<uint> = Vec::with_capacity(1024);\n+            let mut v = Vec::<u8>::with_capacity(1024);\n             unsafe {\n                 let vp = v.as_mut_ptr();\n                 ptr::set_memory(vp, 0, 1024);\n@@ -2990,11 +2988,11 @@ mod bench {\n     #[bench]\n     fn zero_1kb_loop_set(b: &mut Bencher) {\n         b.iter(|| {\n-            let mut v: Vec<uint> = Vec::with_capacity(1024);\n+            let mut v = Vec::<u8>::with_capacity(1024);\n             unsafe {\n                 v.set_len(1024);\n             }\n-            for i in 0u..1024 {\n+            for i in 0..1024 {\n                 v[i] = 0;\n             }\n         });\n@@ -3003,7 +3001,7 @@ mod bench {\n     #[bench]\n     fn zero_1kb_mut_iter(b: &mut Bencher) {\n         b.iter(|| {\n-            let mut v = Vec::with_capacity(1024);\n+            let mut v = Vec::<u8>::with_capacity(1024);\n             unsafe {\n                 v.set_len(1024);\n             }\n@@ -3018,10 +3016,10 @@ mod bench {\n     fn random_inserts(b: &mut Bencher) {\n         let mut rng = weak_rng();\n         b.iter(|| {\n-            let mut v = repeat((0u, 0u)).take(30).collect::<Vec<_>>();\n-            for _ in 0u..100 {\n+            let mut v: Vec<_> = repeat((0, 0)).take(30).collect();\n+            for _ in 0..100 {\n                 let l = v.len();\n-                v.insert(rng.gen::<uint>() % (l + 1),\n+                v.insert(rng.gen::<usize>() % (l + 1),\n                          (1, 1));\n             }\n         })\n@@ -3030,10 +3028,10 @@ mod bench {\n     fn random_removes(b: &mut Bencher) {\n         let mut rng = weak_rng();\n         b.iter(|| {\n-            let mut v = repeat((0u, 0u)).take(130).collect::<Vec<_>>();\n-            for _ in 0u..100 {\n+            let mut v: Vec<_> = repeat((0, 0)).take(130).collect();\n+            for _ in 0..100 {\n                 let l = v.len();\n-                v.remove(rng.gen::<uint>() % l);\n+                v.remove(rng.gen::<usize>() % l);\n             }\n         })\n     }\n@@ -3042,7 +3040,7 @@ mod bench {\n     fn sort_random_small(b: &mut Bencher) {\n         let mut rng = weak_rng();\n         b.iter(|| {\n-            let mut v = rng.gen_iter::<u64>().take(5).collect::<Vec<u64>>();\n+            let mut v: Vec<_> = rng.gen_iter::<u64>().take(5).collect();\n             v.sort();\n         });\n         b.bytes = 5 * mem::size_of::<u64>() as u64;\n@@ -3052,7 +3050,7 @@ mod bench {\n     fn sort_random_medium(b: &mut Bencher) {\n         let mut rng = weak_rng();\n         b.iter(|| {\n-            let mut v = rng.gen_iter::<u64>().take(100).collect::<Vec<u64>>();\n+            let mut v: Vec<_> = rng.gen_iter::<u64>().take(100).collect();\n             v.sort();\n         });\n         b.bytes = 100 * mem::size_of::<u64>() as u64;\n@@ -3062,22 +3060,22 @@ mod bench {\n     fn sort_random_large(b: &mut Bencher) {\n         let mut rng = weak_rng();\n         b.iter(|| {\n-            let mut v = rng.gen_iter::<u64>().take(10000).collect::<Vec<u64>>();\n+            let mut v: Vec<_> = rng.gen_iter::<u64>().take(10000).collect();\n             v.sort();\n         });\n         b.bytes = 10000 * mem::size_of::<u64>() as u64;\n     }\n \n     #[bench]\n     fn sort_sorted(b: &mut Bencher) {\n-        let mut v = (0u..10000).collect::<Vec<_>>();\n+        let mut v: Vec<_> = (0..10000).collect();\n         b.iter(|| {\n             v.sort();\n         });\n         b.bytes = (v.len() * mem::size_of_val(&v[0])) as u64;\n     }\n \n-    type BigSortable = (u64,u64,u64,u64);\n+    type BigSortable = (u64, u64, u64, u64);\n \n     #[bench]\n     fn sort_big_random_small(b: &mut Bencher) {\n@@ -3114,7 +3112,7 @@ mod bench {\n \n     #[bench]\n     fn sort_big_sorted(b: &mut Bencher) {\n-        let mut v = (0..10000u).map(|i| (i, i, i, i)).collect::<Vec<_>>();\n+        let mut v: Vec<BigSortable> = (0..10000).map(|i| (i, i, i, i)).collect();\n         b.iter(|| {\n             v.sort();\n         });"}, {"sha": "65c397359f4ea5c5e7384937df2966d568430b36", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 112, "deletions": 112, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -241,7 +241,7 @@ impl<'a> Iterator for Decompositions<'a> {\n         }\n     }\n \n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let (lower, _) = self.iter.size_hint();\n         (lower, None)\n     }\n@@ -367,7 +367,7 @@ impl<'a> Iterator for Utf16Units<'a> {\n     fn next(&mut self) -> Option<u16> { self.encoder.next() }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) { self.encoder.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.encoder.size_hint() }\n }\n \n /*\n@@ -464,7 +464,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     #[inline]\n     #[unstable(feature = \"collections\",\n                reason = \"this functionality may be moved to libunicode\")]\n-    fn nfd_chars<'a>(&'a self) -> Decompositions<'a> {\n+    fn nfd_chars(&self) -> Decompositions {\n         Decompositions {\n             iter: self[].chars(),\n             buffer: Vec::new(),\n@@ -478,7 +478,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     #[inline]\n     #[unstable(feature = \"collections\",\n                reason = \"this functionality may be moved to libunicode\")]\n-    fn nfkd_chars<'a>(&'a self) -> Decompositions<'a> {\n+    fn nfkd_chars(&self) -> Decompositions {\n         Decompositions {\n             iter: self[].chars(),\n             buffer: Vec::new(),\n@@ -492,7 +492,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     #[inline]\n     #[unstable(feature = \"collections\",\n                reason = \"this functionality may be moved to libunicode\")]\n-    fn nfc_chars<'a>(&'a self) -> Recompositions<'a> {\n+    fn nfc_chars(&self) -> Recompositions {\n         Recompositions {\n             iter: self.nfd_chars(),\n             state: Composing,\n@@ -507,7 +507,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     #[inline]\n     #[unstable(feature = \"collections\",\n                reason = \"this functionality may be moved to libunicode\")]\n-    fn nfkc_chars<'a>(&'a self) -> Recompositions<'a> {\n+    fn nfkc_chars(&self) -> Recompositions {\n         Recompositions {\n             iter: self.nfkd_chars(),\n             state: Composing,\n@@ -629,7 +629,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// assert_eq!(v, vec![\"\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn splitn<P: CharEq>(&self, count: uint, pat: P) -> SplitN<P> {\n+    fn splitn<P: CharEq>(&self, count: usize, pat: P) -> SplitN<P> {\n         core_str::StrExt::splitn(&self[], count, pat)\n     }\n \n@@ -679,7 +679,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// assert_eq!(v, vec![\"leopard\", \"tiger\", \"lionX\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn rsplitn<P: CharEq>(&self, count: uint, pat: P) -> RSplitN<P> {\n+    fn rsplitn<P: CharEq>(&self, count: usize, pat: P) -> RSplitN<P> {\n         core_str::StrExt::rsplitn(&self[], count, pat)\n     }\n \n@@ -694,13 +694,13 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let v: Vec<(uint, uint)> = \"abcXXXabcYYYabc\".match_indices(\"abc\").collect();\n+    /// let v: Vec<(usize, usize)> = \"abcXXXabcYYYabc\".match_indices(\"abc\").collect();\n     /// assert_eq!(v, vec![(0,3), (6,9), (12,15)]);\n     ///\n-    /// let v: Vec<(uint, uint)> = \"1abcabc2\".match_indices(\"abc\").collect();\n+    /// let v: Vec<(usize, usize)> = \"1abcabc2\".match_indices(\"abc\").collect();\n     /// assert_eq!(v, vec![(1,4), (4,7)]);\n     ///\n-    /// let v: Vec<(uint, uint)> = \"ababa\".match_indices(\"aba\").collect();\n+    /// let v: Vec<(usize, usize)> = \"ababa\".match_indices(\"aba\").collect();\n     /// assert_eq!(v, vec![(0, 3)]); // only the first `aba`\n     /// ```\n     #[unstable(feature = \"collections\",\n@@ -762,19 +762,19 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     #[unstable(feature = \"collections\",\n                reason = \"use slice notation [a..b] instead\")]\n     #[deprecated(since = \"1.0.0\", reason = \"use slice notation [a..b] instead\")]\n-    fn slice(&self, begin: uint, end: uint) -> &str;\n+    fn slice(&self, begin: usize, end: usize) -> &str;\n \n     /// Deprecated: use `s[a..]` instead.\n     #[unstable(feature = \"collections\",\n                reason = \"use slice notation [a..b] instead\")]\n     #[deprecated(since = \"1.0.0\", reason = \"use slice notation [a..] instead\")]\n-    fn slice_from(&self, begin: uint) -> &str;\n+    fn slice_from(&self, begin: usize) -> &str;\n \n     /// Deprecated: use `s[..a]` instead.\n     #[unstable(feature = \"collections\",\n                reason = \"use slice notation [a..b] instead\")]\n     #[deprecated(since = \"1.0.0\", reason = \"use slice notation [..a] instead\")]\n-    fn slice_to(&self, end: uint) -> &str;\n+    fn slice_to(&self, end: usize) -> &str;\n \n     /// Returns a slice of the string from the character range\n     /// [`begin`..`end`).\n@@ -801,7 +801,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```\n     #[unstable(feature = \"collections\",\n                reason = \"may have yet to prove its worth\")]\n-    fn slice_chars(&self, begin: uint, end: uint) -> &str {\n+    fn slice_chars(&self, begin: usize, end: usize) -> &str {\n         core_str::StrExt::slice_chars(&self[], begin, end)\n     }\n \n@@ -812,7 +812,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// Caller must check both UTF-8 character boundaries and the boundaries of\n     /// the entire slice as well.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    unsafe fn slice_unchecked(&self, begin: uint, end: uint) -> &str {\n+    unsafe fn slice_unchecked(&self, begin: usize, end: usize) -> &str {\n         core_str::StrExt::slice_unchecked(&self[], begin, end)\n     }\n \n@@ -925,7 +925,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```\n     #[unstable(feature = \"collections\",\n                reason = \"naming is uncertain with container conventions\")]\n-    fn is_char_boundary(&self, index: uint) -> bool {\n+    fn is_char_boundary(&self, index: usize) -> bool {\n         core_str::StrExt::is_char_boundary(&self[], index)\n     }\n \n@@ -945,7 +945,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// use std::str::CharRange;\n     ///\n     /// let s = \"\u4e2d\u534eVi\u1ec7t Nam\";\n-    /// let mut i = 0u;\n+    /// let mut i = 0;\n     /// while i < s.len() {\n     ///     let CharRange {ch, next} = s.char_range_at(i);\n     ///     println!(\"{}: {}\", i, ch);\n@@ -975,7 +975,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     ///\n     /// # Return value\n     ///\n-    /// A record {ch: char, next: uint} containing the char value and the byte\n+    /// A record {ch: char, next: usize} containing the char value and the byte\n     /// index of the next Unicode character.\n     ///\n     /// # Panics\n@@ -984,7 +984,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// If `i` is not the index of the beginning of a valid UTF-8 character.\n     #[unstable(feature = \"collections\",\n                reason = \"naming is uncertain with container conventions\")]\n-    fn char_range_at(&self, start: uint) -> CharRange {\n+    fn char_range_at(&self, start: usize) -> CharRange {\n         core_str::StrExt::char_range_at(&self[], start)\n     }\n \n@@ -1000,7 +1000,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// If `i` is not an index following a valid UTF-8 character.\n     #[unstable(feature = \"collections\",\n                reason = \"naming is uncertain with container conventions\")]\n-    fn char_range_at_reverse(&self, start: uint) -> CharRange {\n+    fn char_range_at_reverse(&self, start: usize) -> CharRange {\n         core_str::StrExt::char_range_at_reverse(&self[], start)\n     }\n \n@@ -1021,7 +1021,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// If `i` is not the index of the beginning of a valid UTF-8 character.\n     #[unstable(feature = \"collections\",\n                reason = \"naming is uncertain with container conventions\")]\n-    fn char_at(&self, i: uint) -> char {\n+    fn char_at(&self, i: usize) -> char {\n         core_str::StrExt::char_at(&self[], i)\n     }\n \n@@ -1033,7 +1033,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// If `i` is not an index following a valid UTF-8 character.\n     #[unstable(feature = \"collections\",\n                reason = \"naming is uncertain with container conventions\")]\n-    fn char_at_reverse(&self, i: uint) -> char {\n+    fn char_at_reverse(&self, i: usize) -> char {\n         core_str::StrExt::char_at_reverse(&self[], i)\n     }\n \n@@ -1073,7 +1073,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// assert_eq!(s.find(x), None);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn find<P: CharEq>(&self, pat: P) -> Option<uint> {\n+    fn find<P: CharEq>(&self, pat: P) -> Option<usize> {\n         core_str::StrExt::find(&self[], pat)\n     }\n \n@@ -1101,7 +1101,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// assert_eq!(s.rfind(x), None);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn rfind<P: CharEq>(&self, pat: P) -> Option<uint> {\n+    fn rfind<P: CharEq>(&self, pat: P) -> Option<usize> {\n         core_str::StrExt::rfind(&self[], pat)\n     }\n \n@@ -1126,7 +1126,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```\n     #[unstable(feature = \"collections\",\n                reason = \"might get removed in favor of a more generic find in the future\")]\n-    fn find_str(&self, needle: &str) -> Option<uint> {\n+    fn find_str(&self, needle: &str) -> Option<usize> {\n         core_str::StrExt::find_str(&self[], needle)\n     }\n \n@@ -1170,7 +1170,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```\n     #[unstable(feature = \"collections\",\n                reason = \"awaiting convention about comparability of arbitrary slices\")]\n-    fn subslice_offset(&self, inner: &str) -> uint {\n+    fn subslice_offset(&self, inner: &str) -> usize {\n         core_str::StrExt::subslice_offset(&self[], inner)\n     }\n \n@@ -1202,7 +1202,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    fn len(&self) -> uint {\n+    fn len(&self) -> usize {\n         core_str::StrExt::len(&self[])\n     }\n \n@@ -1264,8 +1264,8 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let gr_inds = \"a\u0310e\u0301o\u0308\u0332\\r\\n\".grapheme_indices(true).collect::<Vec<(uint, &str)>>();\n-    /// let b: &[_] = &[(0u, \"a\u0310\"), (3, \"e\u0301\"), (6, \"o\u0308\u0332\"), (11, \"\\r\\n\")];\n+    /// let gr_inds = \"a\u0310e\u0301o\u0308\u0332\\r\\n\".grapheme_indices(true).collect::<Vec<(usize, &str)>>();\n+    /// let b: &[_] = &[(0, \"a\u0310\"), (3, \"e\u0301\"), (6, \"o\u0308\u0332\"), (11, \"\\r\\n\")];\n     /// assert_eq!(gr_inds.as_slice(), b);\n     /// ```\n     #[unstable(feature = \"collections\",\n@@ -1301,7 +1301,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// `is_cjk` = `false`) if the locale is unknown.\n     #[unstable(feature = \"collections\",\n                reason = \"this functionality may only be provided by libunicode\")]\n-    fn width(&self, is_cjk: bool) -> uint {\n+    fn width(&self, is_cjk: bool) -> usize {\n         UnicodeStr::width(&self[], is_cjk)\n     }\n \n@@ -1326,15 +1326,15 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl StrExt for str {\n-    fn slice(&self, begin: uint, end: uint) -> &str {\n+    fn slice(&self, begin: usize, end: usize) -> &str {\n         &self[begin..end]\n     }\n \n-    fn slice_from(&self, begin: uint) -> &str {\n+    fn slice_from(&self, begin: usize) -> &str {\n         &self[begin..]\n     }\n \n-    fn slice_to(&self, end: uint) -> &str {\n+    fn slice_to(&self, end: usize) -> &str {\n         &self[..end]\n     }\n }\n@@ -1357,51 +1357,51 @@ mod tests {\n \n     #[test]\n     fn test_len() {\n-        assert_eq!(\"\".len(), 0u);\n-        assert_eq!(\"hello world\".len(), 11u);\n-        assert_eq!(\"\\x63\".len(), 1u);\n-        assert_eq!(\"\\u{a2}\".len(), 2u);\n-        assert_eq!(\"\\u{3c0}\".len(), 2u);\n-        assert_eq!(\"\\u{2620}\".len(), 3u);\n-        assert_eq!(\"\\u{1d11e}\".len(), 4u);\n-\n-        assert_eq!(\"\".chars().count(), 0u);\n-        assert_eq!(\"hello world\".chars().count(), 11u);\n-        assert_eq!(\"\\x63\".chars().count(), 1u);\n-        assert_eq!(\"\\u{a2}\".chars().count(), 1u);\n-        assert_eq!(\"\\u{3c0}\".chars().count(), 1u);\n-        assert_eq!(\"\\u{2620}\".chars().count(), 1u);\n-        assert_eq!(\"\\u{1d11e}\".chars().count(), 1u);\n-        assert_eq!(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".chars().count(), 19u);\n-\n-        assert_eq!(\"\uff48\uff45\uff4c\uff4c\uff4f\".width(false), 10u);\n-        assert_eq!(\"\uff48\uff45\uff4c\uff4c\uff4f\".width(true), 10u);\n-        assert_eq!(\"\\0\\0\\0\\0\\0\".width(false), 0u);\n-        assert_eq!(\"\\0\\0\\0\\0\\0\".width(true), 0u);\n-        assert_eq!(\"\".width(false), 0u);\n-        assert_eq!(\"\".width(true), 0u);\n-        assert_eq!(\"\\u{2081}\\u{2082}\\u{2083}\\u{2084}\".width(false), 4u);\n-        assert_eq!(\"\\u{2081}\\u{2082}\\u{2083}\\u{2084}\".width(true), 8u);\n+        assert_eq!(\"\".len(), 0);\n+        assert_eq!(\"hello world\".len(), 11);\n+        assert_eq!(\"\\x63\".len(), 1);\n+        assert_eq!(\"\\u{a2}\".len(), 2);\n+        assert_eq!(\"\\u{3c0}\".len(), 2);\n+        assert_eq!(\"\\u{2620}\".len(), 3);\n+        assert_eq!(\"\\u{1d11e}\".len(), 4);\n+\n+        assert_eq!(\"\".chars().count(), 0);\n+        assert_eq!(\"hello world\".chars().count(), 11);\n+        assert_eq!(\"\\x63\".chars().count(), 1);\n+        assert_eq!(\"\\u{a2}\".chars().count(), 1);\n+        assert_eq!(\"\\u{3c0}\".chars().count(), 1);\n+        assert_eq!(\"\\u{2620}\".chars().count(), 1);\n+        assert_eq!(\"\\u{1d11e}\".chars().count(), 1);\n+        assert_eq!(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".chars().count(), 19);\n+\n+        assert_eq!(\"\uff48\uff45\uff4c\uff4c\uff4f\".width(false), 10);\n+        assert_eq!(\"\uff48\uff45\uff4c\uff4c\uff4f\".width(true), 10);\n+        assert_eq!(\"\\0\\0\\0\\0\\0\".width(false), 0);\n+        assert_eq!(\"\\0\\0\\0\\0\\0\".width(true), 0);\n+        assert_eq!(\"\".width(false), 0);\n+        assert_eq!(\"\".width(true), 0);\n+        assert_eq!(\"\\u{2081}\\u{2082}\\u{2083}\\u{2084}\".width(false), 4);\n+        assert_eq!(\"\\u{2081}\\u{2082}\\u{2083}\\u{2084}\".width(true), 8);\n     }\n \n     #[test]\n     fn test_find() {\n-        assert_eq!(\"hello\".find('l'), Some(2u));\n-        assert_eq!(\"hello\".find(|c:char| c == 'o'), Some(4u));\n+        assert_eq!(\"hello\".find('l'), Some(2));\n+        assert_eq!(\"hello\".find(|c:char| c == 'o'), Some(4));\n         assert!(\"hello\".find('x').is_none());\n         assert!(\"hello\".find(|c:char| c == 'x').is_none());\n-        assert_eq!(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".find('\u534e'), Some(30u));\n-        assert_eq!(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".find(|c: char| c == '\u534e'), Some(30u));\n+        assert_eq!(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".find('\u534e'), Some(30));\n+        assert_eq!(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".find(|c: char| c == '\u534e'), Some(30));\n     }\n \n     #[test]\n     fn test_rfind() {\n-        assert_eq!(\"hello\".rfind('l'), Some(3u));\n-        assert_eq!(\"hello\".rfind(|c:char| c == 'o'), Some(4u));\n+        assert_eq!(\"hello\".rfind('l'), Some(3));\n+        assert_eq!(\"hello\".rfind(|c:char| c == 'o'), Some(4));\n         assert!(\"hello\".rfind('x').is_none());\n         assert!(\"hello\".rfind(|c:char| c == 'x').is_none());\n-        assert_eq!(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".rfind('\u534e'), Some(30u));\n-        assert_eq!(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".rfind(|c: char| c == '\u534e'), Some(30u));\n+        assert_eq!(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".rfind('\u534e'), Some(30));\n+        assert_eq!(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".rfind(|c: char| c == '\u534e'), Some(30));\n     }\n \n     #[test]\n@@ -1424,37 +1424,37 @@ mod tests {\n     #[test]\n     fn test_find_str() {\n         // byte positions\n-        assert_eq!(\"\".find_str(\"\"), Some(0u));\n+        assert_eq!(\"\".find_str(\"\"), Some(0));\n         assert!(\"banana\".find_str(\"apple pie\").is_none());\n \n         let data = \"abcabc\";\n-        assert_eq!(data[0u..6u].find_str(\"ab\"), Some(0u));\n-        assert_eq!(data[2u..6u].find_str(\"ab\"), Some(3u - 2u));\n-        assert!(data[2u..4u].find_str(\"ab\").is_none());\n+        assert_eq!(data[0..6].find_str(\"ab\"), Some(0));\n+        assert_eq!(data[2..6].find_str(\"ab\"), Some(3 - 2));\n+        assert!(data[2..4].find_str(\"ab\").is_none());\n \n         let string = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n         let mut data = String::from_str(string);\n         data.push_str(string);\n         assert!(data.find_str(\"\u0e44\u0e17\u534e\").is_none());\n-        assert_eq!(data[0u..43u].find_str(\"\"), Some(0u));\n-        assert_eq!(data[6u..43u].find_str(\"\"), Some(6u - 6u));\n+        assert_eq!(data[0..43].find_str(\"\"), Some(0));\n+        assert_eq!(data[6..43].find_str(\"\"), Some(6 - 6));\n \n-        assert_eq!(data[0u..43u].find_str(\"\u0e1b\u0e23\u0e30\"), Some( 0u));\n-        assert_eq!(data[0u..43u].find_str(\"\u0e17\u0e28\u0e44\"), Some(12u));\n-        assert_eq!(data[0u..43u].find_str(\"\u0e22\u4e2d\"), Some(24u));\n-        assert_eq!(data[0u..43u].find_str(\"i\u1ec7t\"), Some(34u));\n-        assert_eq!(data[0u..43u].find_str(\"Nam\"), Some(40u));\n+        assert_eq!(data[0..43].find_str(\"\u0e1b\u0e23\u0e30\"), Some( 0));\n+        assert_eq!(data[0..43].find_str(\"\u0e17\u0e28\u0e44\"), Some(12));\n+        assert_eq!(data[0..43].find_str(\"\u0e22\u4e2d\"), Some(24));\n+        assert_eq!(data[0..43].find_str(\"i\u1ec7t\"), Some(34));\n+        assert_eq!(data[0..43].find_str(\"Nam\"), Some(40));\n \n-        assert_eq!(data[43u..86u].find_str(\"\u0e1b\u0e23\u0e30\"), Some(43u - 43u));\n-        assert_eq!(data[43u..86u].find_str(\"\u0e17\u0e28\u0e44\"), Some(55u - 43u));\n-        assert_eq!(data[43u..86u].find_str(\"\u0e22\u4e2d\"), Some(67u - 43u));\n-        assert_eq!(data[43u..86u].find_str(\"i\u1ec7t\"), Some(77u - 43u));\n-        assert_eq!(data[43u..86u].find_str(\"Nam\"), Some(83u - 43u));\n+        assert_eq!(data[43..86].find_str(\"\u0e1b\u0e23\u0e30\"), Some(43 - 43));\n+        assert_eq!(data[43..86].find_str(\"\u0e17\u0e28\u0e44\"), Some(55 - 43));\n+        assert_eq!(data[43..86].find_str(\"\u0e22\u4e2d\"), Some(67 - 43));\n+        assert_eq!(data[43..86].find_str(\"i\u1ec7t\"), Some(77 - 43));\n+        assert_eq!(data[43..86].find_str(\"Nam\"), Some(83 - 43));\n     }\n \n     #[test]\n     fn test_slice_chars() {\n-        fn t(a: &str, b: &str, start: uint) {\n+        fn t(a: &str, b: &str, start: usize) {\n             assert_eq!(a.slice_chars(start, start + b.chars().count()), b);\n         }\n         t(\"\", \"\", 0);\n@@ -1527,7 +1527,7 @@ mod tests {\n         assert_eq!(\"bc\", unsafe {\"abc\".slice_unchecked(1, 3)});\n         assert_eq!(\"\", unsafe {\"abc\".slice_unchecked(1, 1)});\n         fn a_million_letter_a() -> String {\n-            let mut i = 0u;\n+            let mut i = 0;\n             let mut rs = String::new();\n             while i < 100000 {\n                 rs.push_str(\"aaaaaaaaaa\");\n@@ -1536,7 +1536,7 @@ mod tests {\n             rs\n         }\n         fn half_a_million_letter_a() -> String {\n-            let mut i = 0u;\n+            let mut i = 0;\n             let mut rs = String::new();\n             while i < 100000 {\n                 rs.push_str(\"aaaaa\");\n@@ -1547,7 +1547,7 @@ mod tests {\n         let letters = a_million_letter_a();\n         assert!(half_a_million_letter_a() ==\n             unsafe {String::from_str(letters.slice_unchecked(\n-                                     0u,\n+                                     0,\n                                      500000))});\n     }\n \n@@ -1644,7 +1644,7 @@ mod tests {\n         assert_eq!(\"\u534e\", data.slice(30, 33));\n \n         fn a_million_letter_x() -> String {\n-            let mut i = 0u;\n+            let mut i = 0;\n             let mut rs = String::new();\n             while i < 100000 {\n                 rs.push_str(\"\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\");\n@@ -1653,7 +1653,7 @@ mod tests {\n             rs\n         }\n         fn half_a_million_letter_x() -> String {\n-            let mut i = 0u;\n+            let mut i = 0;\n             let mut rs = String::new();\n             while i < 100000 {\n                 rs.push_str(\"\u534e\u534e\u534e\u534e\u534e\");\n@@ -1663,23 +1663,23 @@ mod tests {\n         }\n         let letters = a_million_letter_x();\n         assert!(half_a_million_letter_x() ==\n-            String::from_str(letters.slice(0u, 3u * 500000u)));\n+            String::from_str(letters.slice(0, 3 * 500000)));\n     }\n \n     #[test]\n     fn test_slice_2() {\n         let ss = \"\u4e2d\u534eVi\u1ec7t Nam\";\n \n-        assert_eq!(\"\u534e\", ss.slice(3u, 6u));\n-        assert_eq!(\"Vi\u1ec7t Nam\", ss.slice(6u, 16u));\n+        assert_eq!(\"\u534e\", ss.slice(3, 6));\n+        assert_eq!(\"Vi\u1ec7t Nam\", ss.slice(6, 16));\n \n-        assert_eq!(\"ab\", \"abc\".slice(0u, 2u));\n-        assert_eq!(\"bc\", \"abc\".slice(1u, 3u));\n-        assert_eq!(\"\", \"abc\".slice(1u, 1u));\n+        assert_eq!(\"ab\", \"abc\".slice(0, 2));\n+        assert_eq!(\"bc\", \"abc\".slice(1, 3));\n+        assert_eq!(\"\", \"abc\".slice(1, 1));\n \n-        assert_eq!(\"\u4e2d\", ss.slice(0u, 3u));\n-        assert_eq!(\"\u534eV\", ss.slice(3u, 7u));\n-        assert_eq!(\"\", ss.slice(3u, 3u));\n+        assert_eq!(\"\u4e2d\", ss.slice(0, 3));\n+        assert_eq!(\"\u534eV\", ss.slice(3, 7));\n+        assert_eq!(\"\", ss.slice(3, 3));\n         /*0: \u4e2d\n           3: \u534e\n           6: V\n@@ -1695,7 +1695,7 @@ mod tests {\n     #[test]\n     #[should_fail]\n     fn test_slice_fail() {\n-        \"\u4e2d\u534eVi\u1ec7t Nam\".slice(0u, 2u);\n+        \"\u4e2d\u534eVi\u1ec7t Nam\".slice(0, 2);\n     }\n \n     #[test]\n@@ -1961,17 +1961,17 @@ mod tests {\n \n         let v: Vec<u8> = s1.as_bytes().to_vec();\n         let s2: String = String::from_str(from_utf8(&v).unwrap());\n-        let mut i: uint = 0u;\n-        let n1: uint = s1.len();\n-        let n2: uint = v.len();\n+        let mut i = 0;\n+        let n1 = s1.len();\n+        let n2 = v.len();\n         assert_eq!(n1, n2);\n         while i < n1 {\n             let a: u8 = s1.as_bytes()[i];\n             let b: u8 = s2.as_bytes()[i];\n             debug!(\"{}\", a);\n             debug!(\"{}\", b);\n             assert_eq!(a, b);\n-            i += 1u;\n+            i += 1;\n         }\n     }\n \n@@ -2093,7 +2093,7 @@ mod tests {\n         let v = ['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n \n         let mut pos = 0;\n-        let mut it = s.chars();\n+        let it = s.chars();\n \n         for c in it {\n             assert_eq!(c, v[pos]);\n@@ -2108,7 +2108,7 @@ mod tests {\n         let v = ['m', 'a', 'N', ' ', 't', '\u1ec7','i','V','\u534e','\u4e2d','\u0e22','\u0e17','\u0e44','\u0e28'];\n \n         let mut pos = 0;\n-        let mut it = s.chars().rev();\n+        let it = s.chars().rev();\n \n         for c in it {\n             assert_eq!(c, v[pos]);\n@@ -2188,7 +2188,7 @@ mod tests {\n         let v = ['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n \n         let mut pos = 0;\n-        let mut it = s.char_indices();\n+        let it = s.char_indices();\n \n         for c in it {\n             assert_eq!(c, (p[pos], v[pos]));\n@@ -2205,7 +2205,7 @@ mod tests {\n         let v = ['m', 'a', 'N', ' ', 't', '\u1ec7','i','V','\u534e','\u4e2d','\u0e22','\u0e17','\u0e44','\u0e28'];\n \n         let mut pos = 0;\n-        let mut it = s.char_indices().rev();\n+        let it = s.char_indices().rev();\n \n         for c in it {\n             assert_eq!(c, (p[pos], v[pos]));\n@@ -2725,11 +2725,11 @@ mod tests {\n \n         // test the indices iterators\n         let s = \"a\u0310e\u0301o\u0308\u0332\\r\\n\";\n-        let gr_inds = s.grapheme_indices(true).collect::<Vec<(uint, &str)>>();\n-        let b: &[_] = &[(0u, \"a\u0310\"), (3, \"e\u0301\"), (6, \"o\u0308\u0332\"), (11, \"\\r\\n\")];\n+        let gr_inds = s.grapheme_indices(true).collect::<Vec<(usize, &str)>>();\n+        let b: &[_] = &[(0, \"a\u0310\"), (3, \"e\u0301\"), (6, \"o\u0308\u0332\"), (11, \"\\r\\n\")];\n         assert_eq!(gr_inds, b);\n-        let gr_inds = s.grapheme_indices(true).rev().collect::<Vec<(uint, &str)>>();\n-        let b: &[_] = &[(11, \"\\r\\n\"), (6, \"o\u0308\u0332\"), (3, \"e\u0301\"), (0u, \"a\u0310\")];\n+        let gr_inds = s.grapheme_indices(true).rev().collect::<Vec<(usize, &str)>>();\n+        let b: &[_] = &[(11, \"\\r\\n\"), (6, \"o\u0308\u0332\"), (3, \"e\u0301\"), (0, \"a\u0310\")];\n         assert_eq!(gr_inds, b);\n         let mut gr_inds_iter = s.grapheme_indices(true);\n         {\n@@ -2785,7 +2785,7 @@ mod tests {\n \n     #[test]\n     fn test_str_container() {\n-        fn sum_len(v: &[&str]) -> uint {\n+        fn sum_len(v: &[&str]) -> usize {\n             v.iter().map(|x| x.len()).sum()\n         }\n "}, {"sha": "63483d30dd202a46e3fbbedd95646bcb55a3c14c", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 31, "deletions": 32, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -49,7 +49,6 @@ pub struct FromUtf8Error {\n \n /// A possible error value from the `String::from_utf16` function.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(missing_copy_implementations)]\n #[derive(Debug)]\n pub struct FromUtf16Error(());\n \n@@ -80,7 +79,7 @@ impl String {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn with_capacity(capacity: uint) -> String {\n+    pub fn with_capacity(capacity: usize) -> String {\n         String {\n             vec: Vec::with_capacity(capacity),\n         }\n@@ -157,10 +156,10 @@ impl String {\n         static TAG_CONT_U8: u8 = 128u8;\n         static REPLACEMENT: &'static [u8] = b\"\\xEF\\xBF\\xBD\"; // U+FFFD in UTF-8\n         let total = v.len();\n-        fn unsafe_get(xs: &[u8], i: uint) -> u8 {\n+        fn unsafe_get(xs: &[u8], i: usize) -> u8 {\n             unsafe { *xs.get_unchecked(i) }\n         }\n-        fn safe_get(xs: &[u8], i: uint, total: uint) -> u8 {\n+        fn safe_get(xs: &[u8], i: usize, total: usize) -> u8 {\n             if i >= total {\n                 0\n             } else {\n@@ -319,7 +318,7 @@ impl String {\n     /// * We assume that the `Vec` contains valid UTF-8.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub unsafe fn from_raw_parts(buf: *mut u8, length: uint, capacity: uint) -> String {\n+    pub unsafe fn from_raw_parts(buf: *mut u8, length: usize, capacity: usize) -> String {\n         String {\n             vec: Vec::from_raw_parts(buf, length, capacity),\n         }\n@@ -375,7 +374,7 @@ impl String {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn capacity(&self) -> uint {\n+    pub fn capacity(&self) -> usize {\n         self.vec.capacity()\n     }\n \n@@ -385,7 +384,7 @@ impl String {\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the new capacity overflows `uint`.\n+    /// Panics if the new capacity overflows `usize`.\n     ///\n     /// # Examples\n     ///\n@@ -396,7 +395,7 @@ impl String {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn reserve(&mut self, additional: uint) {\n+    pub fn reserve(&mut self, additional: usize) {\n         self.vec.reserve(additional)\n     }\n \n@@ -410,7 +409,7 @@ impl String {\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the new capacity overflows `uint`.\n+    /// Panics if the new capacity overflows `usize`.\n     ///\n     /// # Examples\n     ///\n@@ -421,7 +420,7 @@ impl String {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn reserve_exact(&mut self, additional: uint) {\n+    pub fn reserve_exact(&mut self, additional: usize) {\n         self.vec.reserve_exact(additional)\n     }\n \n@@ -469,7 +468,7 @@ impl String {\n             // Attempt to not use an intermediate buffer by just pushing bytes\n             // directly onto this string.\n             let slice = RawSlice {\n-                data: self.vec.as_ptr().offset(cur_len as int),\n+                data: self.vec.as_ptr().offset(cur_len as isize),\n                 len: 4,\n             };\n             let used = ch.encode_utf8(mem::transmute(slice)).unwrap_or(0);\n@@ -488,7 +487,7 @@ impl String {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn as_bytes<'a>(&'a self) -> &'a [u8] {\n+    pub fn as_bytes(&self) -> &[u8] {\n         &self.vec\n     }\n \n@@ -508,7 +507,7 @@ impl String {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn truncate(&mut self, new_len: uint) {\n+    pub fn truncate(&mut self, new_len: usize) {\n         assert!(self.is_char_boundary(new_len));\n         self.vec.truncate(new_len)\n     }\n@@ -563,14 +562,14 @@ impl String {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn remove(&mut self, idx: uint) -> char {\n+    pub fn remove(&mut self, idx: usize) -> char {\n         let len = self.len();\n         assert!(idx <= len);\n \n         let CharRange { ch, next } = self.char_range_at(idx);\n         unsafe {\n-            ptr::copy_memory(self.vec.as_mut_ptr().offset(idx as int),\n-                             self.vec.as_ptr().offset(next as int),\n+            ptr::copy_memory(self.vec.as_mut_ptr().offset(idx as isize),\n+                             self.vec.as_ptr().offset(next as isize),\n                              len - next);\n             self.vec.set_len(len - (next - idx));\n         }\n@@ -590,7 +589,7 @@ impl String {\n     /// this function will panic.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn insert(&mut self, idx: uint, ch: char) {\n+    pub fn insert(&mut self, idx: usize, ch: char) {\n         let len = self.len();\n         assert!(idx <= len);\n         assert!(self.is_char_boundary(idx));\n@@ -599,10 +598,10 @@ impl String {\n         let amt = ch.encode_utf8(&mut bits).unwrap();\n \n         unsafe {\n-            ptr::copy_memory(self.vec.as_mut_ptr().offset((idx + amt) as int),\n-                             self.vec.as_ptr().offset(idx as int),\n+            ptr::copy_memory(self.vec.as_mut_ptr().offset((idx + amt) as isize),\n+                             self.vec.as_ptr().offset(idx as isize),\n                              len - idx);\n-            ptr::copy_memory(self.vec.as_mut_ptr().offset(idx as int),\n+            ptr::copy_memory(self.vec.as_mut_ptr().offset(idx as isize),\n                              bits.as_ptr(),\n                              amt);\n             self.vec.set_len(len + amt);\n@@ -627,7 +626,7 @@ impl String {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub unsafe fn as_mut_vec<'a>(&'a mut self) -> &'a mut Vec<u8> {\n+    pub unsafe fn as_mut_vec(&mut self) -> &mut Vec<u8> {\n         &mut self.vec\n     }\n \n@@ -641,7 +640,7 @@ impl String {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> uint { self.vec.len() }\n+    pub fn len(&self) -> usize { self.vec.len() }\n \n     /// Returns true if the string contains no bytes\n     ///\n@@ -803,7 +802,7 @@ impl<'a, 'b> PartialEq<CowString<'a>> for &'b str {\n impl Str for String {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn as_slice<'a>(&'a self) -> &'a str {\n+    fn as_slice(&self) -> &str {\n         unsafe { mem::transmute(&*self.vec) }\n     }\n }\n@@ -854,26 +853,26 @@ impl<'a> Add<&'a str> for String {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl ops::Index<ops::Range<uint>> for String {\n+impl ops::Index<ops::Range<usize>> for String {\n     type Output = str;\n     #[inline]\n-    fn index(&self, index: &ops::Range<uint>) -> &str {\n+    fn index(&self, index: &ops::Range<usize>) -> &str {\n         &self[][*index]\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl ops::Index<ops::RangeTo<uint>> for String {\n+impl ops::Index<ops::RangeTo<usize>> for String {\n     type Output = str;\n     #[inline]\n-    fn index(&self, index: &ops::RangeTo<uint>) -> &str {\n+    fn index(&self, index: &ops::RangeTo<usize>) -> &str {\n         &self[][*index]\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl ops::Index<ops::RangeFrom<uint>> for String {\n+impl ops::Index<ops::RangeFrom<usize>> for String {\n     type Output = str;\n     #[inline]\n-    fn index(&self, index: &ops::RangeFrom<uint>) -> &str {\n+    fn index(&self, index: &ops::RangeFrom<usize>) -> &str {\n         &self[][*index]\n     }\n }\n@@ -891,7 +890,7 @@ impl ops::Deref for String {\n     type Target = str;\n \n     #[inline]\n-    fn deref<'a>(&'a self) -> &'a str {\n+    fn deref(&self) -> &str {\n         unsafe { mem::transmute(&self.vec[]) }\n     }\n }\n@@ -1298,7 +1297,7 @@ mod tests {\n     fn test_simple_types() {\n         assert_eq!(1.to_string(), \"1\");\n         assert_eq!((-1).to_string(), \"-1\");\n-        assert_eq!(200u.to_string(), \"200\");\n+        assert_eq!(200.to_string(), \"200\");\n         assert_eq!(2u8.to_string(), \"2\");\n         assert_eq!(true.to_string(), \"true\");\n         assert_eq!(false.to_string(), \"false\");\n@@ -1307,7 +1306,7 @@ mod tests {\n \n     #[test]\n     fn test_vectors() {\n-        let x: Vec<int> = vec![];\n+        let x: Vec<i32> = vec![];\n         assert_eq!(format!(\"{:?}\", x), \"[]\");\n         assert_eq!(format!(\"{:?}\", vec![1]), \"[1]\");\n         assert_eq!(format!(\"{:?}\", vec![1, 2, 3]), \"[1, 2, 3]\");"}, {"sha": "62640e1e25032274d99c0fc965c290ac24ebdec2", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 149, "deletions": 149, "changes": 298, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -66,7 +66,7 @@ use core::ops;\n use core::ptr;\n use core::raw::Slice as RawSlice;\n use core::slice;\n-use core::uint;\n+use core::usize;\n \n /// A growable list type, written `Vec<T>` but pronounced 'vector.'\n ///\n@@ -138,8 +138,8 @@ use core::uint;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Vec<T> {\n     ptr: NonZero<*mut T>,\n-    len: uint,\n-    cap: uint,\n+    len: usize,\n+    cap: usize,\n }\n \n unsafe impl<T: Send> Send for Vec<T> { }\n@@ -196,9 +196,9 @@ impl<T> Vec<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn with_capacity(capacity: uint) -> Vec<T> {\n+    pub fn with_capacity(capacity: usize) -> Vec<T> {\n         if mem::size_of::<T>() == 0 {\n-            Vec { ptr: unsafe { NonZero::new(EMPTY as *mut T) }, len: 0, cap: uint::MAX }\n+            Vec { ptr: unsafe { NonZero::new(EMPTY as *mut T) }, len: 0, cap: usize::MAX }\n         } else if capacity == 0 {\n             Vec::new()\n         } else {\n@@ -234,7 +234,7 @@ impl<T> Vec<T> {\n     ///         mem::forget(v);\n     ///\n     ///         // Overwrite memory with 4, 5, 6\n-    ///         for i in 0..len as int {\n+    ///         for i in 0..len as isize {\n     ///             ptr::write(p.offset(i), 4 + i);\n     ///         }\n     ///\n@@ -245,8 +245,8 @@ impl<T> Vec<T> {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub unsafe fn from_raw_parts(ptr: *mut T, length: uint,\n-                                 capacity: uint) -> Vec<T> {\n+    pub unsafe fn from_raw_parts(ptr: *mut T, length: usize,\n+                                 capacity: usize) -> Vec<T> {\n         Vec { ptr: NonZero::new(ptr), len: length, cap: capacity }\n     }\n \n@@ -258,7 +258,7 @@ impl<T> Vec<T> {\n     #[inline]\n     #[unstable(feature = \"collections\",\n                reason = \"may be better expressed via composition\")]\n-    pub unsafe fn from_raw_buf(ptr: *const T, elts: uint) -> Vec<T> {\n+    pub unsafe fn from_raw_buf(ptr: *const T, elts: usize) -> Vec<T> {\n         let mut dst = Vec::with_capacity(elts);\n         dst.set_len(elts);\n         ptr::copy_nonoverlapping_memory(dst.as_mut_ptr(), ptr, elts);\n@@ -276,7 +276,7 @@ impl<T> Vec<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn capacity(&self) -> uint {\n+    pub fn capacity(&self) -> usize {\n         self.cap\n     }\n \n@@ -285,7 +285,7 @@ impl<T> Vec<T> {\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the new capacity overflows `uint`.\n+    /// Panics if the new capacity overflows `usize`.\n     ///\n     /// # Examples\n     ///\n@@ -295,9 +295,9 @@ impl<T> Vec<T> {\n     /// assert!(vec.capacity() >= 11);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn reserve(&mut self, additional: uint) {\n+    pub fn reserve(&mut self, additional: usize) {\n         if self.cap - self.len < additional {\n-            let err_msg = \"Vec::reserve: `uint` overflow\";\n+            let err_msg = \"Vec::reserve: `usize` overflow\";\n             let new_cap = self.len.checked_add(additional).expect(err_msg)\n                 .checked_next_power_of_two().expect(err_msg);\n             self.grow_capacity(new_cap);\n@@ -314,7 +314,7 @@ impl<T> Vec<T> {\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the new capacity overflows `uint`.\n+    /// Panics if the new capacity overflows `usize`.\n     ///\n     /// # Examples\n     ///\n@@ -324,10 +324,10 @@ impl<T> Vec<T> {\n     /// assert!(vec.capacity() >= 11);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn reserve_exact(&mut self, additional: uint) {\n+    pub fn reserve_exact(&mut self, additional: usize) {\n         if self.cap - self.len < additional {\n             match self.len.checked_add(additional) {\n-                None => panic!(\"Vec::reserve: `uint` overflow\"),\n+                None => panic!(\"Vec::reserve: `usize` overflow\"),\n                 Some(new_cap) => self.grow_capacity(new_cap)\n             }\n         }\n@@ -401,7 +401,7 @@ impl<T> Vec<T> {\n     /// assert_eq!(vec, vec![1, 2]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn truncate(&mut self, len: uint) {\n+    pub fn truncate(&mut self, len: usize) {\n         unsafe {\n             // drop any extra elements\n             while len < self.len {\n@@ -425,7 +425,7 @@ impl<T> Vec<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n+    pub fn as_mut_slice(&mut self) -> &mut [T] {\n         unsafe {\n             mem::transmute(RawSlice {\n                 data: *self.ptr,\n@@ -455,9 +455,9 @@ impl<T> Vec<T> {\n             let cap = self.cap;\n             let begin = ptr as *const T;\n             let end = if mem::size_of::<T>() == 0 {\n-                (ptr as uint + self.len()) as *const T\n+                (ptr as usize + self.len()) as *const T\n             } else {\n-                ptr.offset(self.len() as int) as *const T\n+                ptr.offset(self.len() as isize) as *const T\n             };\n             mem::forget(self);\n             IntoIter { allocation: ptr, cap: cap, ptr: begin, end: end }\n@@ -473,14 +473,14 @@ impl<T> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// let mut v = vec![1u, 2, 3, 4];\n+    /// let mut v = vec![1, 2, 3, 4];\n     /// unsafe {\n     ///     v.set_len(1);\n     /// }\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub unsafe fn set_len(&mut self, len: uint) {\n+    pub unsafe fn set_len(&mut self, len: usize) {\n         self.len = len;\n     }\n \n@@ -506,7 +506,7 @@ impl<T> Vec<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn swap_remove(&mut self, index: uint) -> T {\n+    pub fn swap_remove(&mut self, index: usize) -> T {\n         let length = self.len();\n         self.swap(index, length - 1);\n         self.pop().unwrap()\n@@ -530,7 +530,7 @@ impl<T> Vec<T> {\n     /// assert_eq!(vec, vec![1, 4, 2, 3, 5]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn insert(&mut self, index: uint, element: T) {\n+    pub fn insert(&mut self, index: usize, element: T) {\n         let len = self.len();\n         assert!(index <= len);\n         // space for the new element\n@@ -539,7 +539,7 @@ impl<T> Vec<T> {\n         unsafe { // infallible\n             // The spot to put the new value\n             {\n-                let p = self.as_mut_ptr().offset(index as int);\n+                let p = self.as_mut_ptr().offset(index as isize);\n                 // Shift everything over to make space. (Duplicating the\n                 // `index`th element into two consecutive places.)\n                 ptr::copy_memory(p.offset(1), &*p, len - index);\n@@ -566,14 +566,14 @@ impl<T> Vec<T> {\n     /// assert_eq!(v, vec![1, 3]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn remove(&mut self, index: uint) -> T {\n+    pub fn remove(&mut self, index: usize) -> T {\n         let len = self.len();\n         assert!(index < len);\n         unsafe { // infallible\n             let ret;\n             {\n                 // the place we are taking from.\n-                let ptr = self.as_mut_ptr().offset(index as int);\n+                let ptr = self.as_mut_ptr().offset(index as isize);\n                 // copy it out, unsafely having a copy of the value on\n                 // the stack and in the vector at the same time.\n                 ret = ptr::read(ptr);\n@@ -602,11 +602,11 @@ impl<T> Vec<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn retain<F>(&mut self, mut f: F) where F: FnMut(&T) -> bool {\n         let len = self.len();\n-        let mut del = 0u;\n+        let mut del = 0;\n         {\n             let v = &mut **self;\n \n-            for i in 0u..len {\n+            for i in 0..len {\n                 if !f(&v[i]) {\n                     del += 1;\n                 } else if del > 0 {\n@@ -623,7 +623,7 @@ impl<T> Vec<T> {\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the number of elements in the vector overflows a `uint`.\n+    /// Panics if the number of elements in the vector overflows a `usize`.\n     ///\n     /// # Examples\n     ///\n@@ -655,7 +655,7 @@ impl<T> Vec<T> {\n         }\n \n         unsafe {\n-            let end = (*self.ptr).offset(self.len as int);\n+            let end = (*self.ptr).offset(self.len as isize);\n             ptr::write(&mut *end, value);\n             self.len += 1;\n         }\n@@ -687,7 +687,7 @@ impl<T> Vec<T> {\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the number of elements in the vector overflows a `uint`.\n+    /// Panics if the number of elements in the vector overflows a `usize`.\n     ///\n     /// # Examples\n     /// ```rust\n@@ -737,13 +737,13 @@ impl<T> Vec<T> {\n     #[inline]\n     #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n-    pub fn drain<'a>(&'a mut self) -> Drain<'a, T> {\n+    pub fn drain(&mut self) -> Drain<T> {\n         unsafe {\n             let begin = *self.ptr as *const T;\n             let end = if mem::size_of::<T>() == 0 {\n-                (*self.ptr as uint + self.len()) as *const T\n+                (*self.ptr as usize + self.len()) as *const T\n             } else {\n-                (*self.ptr).offset(self.len() as int) as *const T\n+                (*self.ptr).offset(self.len() as isize) as *const T\n             };\n             self.set_len(0);\n             Drain {\n@@ -781,7 +781,7 @@ impl<T> Vec<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> uint { self.len }\n+    pub fn len(&self) -> usize { self.len }\n \n     /// Returns `true` if the vector contains no elements.\n     ///\n@@ -808,7 +808,7 @@ impl<T> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// let v = vec![0u, 1, 2];\n+    /// let v = vec![0, 1, 2];\n     /// let w = v.map_in_place(|i| i + 3);\n     /// assert_eq!(w.as_slice(), [3, 4, 5].as_slice());\n     ///\n@@ -835,7 +835,7 @@ impl<T> Vec<T> {\n             // types are passed to the allocator by `Vec`.\n             assert!(mem::min_align_of::<T>() == mem::min_align_of::<U>());\n \n-            // This `as int` cast is safe, because the size of the elements of the\n+            // This `as isize` cast is safe, because the size of the elements of the\n             // vector is not 0, and:\n             //\n             // 1) If the size of the elements in the vector is 1, the `int` may\n@@ -850,9 +850,9 @@ impl<T> Vec<T> {\n             //        After `array.offset(offset)`: 0x9.\n             //        (0x1 + 0x8 = 0x1 - 0x8)\n             //\n-            // 2) If the size of the elements in the vector is >1, the `uint` ->\n+            // 2) If the size of the elements in the vector is >1, the `usize` ->\n             //    `int` conversion can't overflow.\n-            let offset = vec.len() as int;\n+            let offset = vec.len() as isize;\n             let start = vec.as_mut_ptr();\n \n             let mut pv = PartialVecNonZeroSized {\n@@ -977,8 +977,8 @@ impl<T> Vec<T> {\n                     let u = f(t);\n \n                     // Forget the `U` and increment `num_u`. This increment\n-                    // cannot overflow the `uint` as we only do this for a\n-                    // number of times that fits into a `uint` (and start with\n+                    // cannot overflow the `usize` as we only do this for a\n+                    // number of times that fits into a `usize` (and start with\n                     // `0`). Again, we should not panic between these steps.\n                     mem::forget(u);\n                     pv.num_u += 1;\n@@ -1052,7 +1052,7 @@ impl<T: Clone> Vec<T> {\n     /// ```\n     #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification; waiting for dust to settle\")]\n-    pub fn resize(&mut self, new_len: uint, value: T) {\n+    pub fn resize(&mut self, new_len: usize, value: T) {\n         let len = self.len();\n \n         if new_len > len {\n@@ -1179,8 +1179,8 @@ impl<T: PartialEq> Vec<T> {\n             let mut w = 1;\n \n             while r < ln {\n-                let p_r = p.offset(r as int);\n-                let p_wm1 = p.offset((w - 1) as int);\n+                let p_r = p.offset(r as isize);\n+                let p_wm1 = p.offset((w - 1) as isize);\n                 if *p_r != *p_wm1 {\n                     if r != w {\n                         let p_w = p_wm1.offset(1);\n@@ -1205,7 +1205,7 @@ impl<T> Vec<T> {\n     ///\n     /// If the capacity for `self` is already equal to or greater than the\n     /// requested capacity, then no action is taken.\n-    fn grow_capacity(&mut self, capacity: uint) {\n+    fn grow_capacity(&mut self, capacity: usize) {\n         if mem::size_of::<T>() == 0 { return }\n \n         if capacity > self.cap {\n@@ -1223,7 +1223,7 @@ impl<T> Vec<T> {\n \n // FIXME: #13996: need a way to mark the return value as `noalias`\n #[inline(never)]\n-unsafe fn alloc_or_realloc<T>(ptr: *mut T, old_size: uint, size: uint) -> *mut T {\n+unsafe fn alloc_or_realloc<T>(ptr: *mut T, old_size: usize, size: usize) -> *mut T {\n     if old_size == 0 {\n         allocate(size, mem::min_align_of::<T>()) as *mut T\n     } else {\n@@ -1232,7 +1232,7 @@ unsafe fn alloc_or_realloc<T>(ptr: *mut T, old_size: uint, size: uint) -> *mut T\n }\n \n #[inline]\n-unsafe fn dealloc<T>(ptr: *mut T, len: uint) {\n+unsafe fn dealloc<T>(ptr: *mut T, len: usize) {\n     if mem::size_of::<T>() != 0 {\n         deallocate(ptr as *mut u8,\n                    len * mem::size_of::<T>(),\n@@ -1274,49 +1274,49 @@ impl<S: hash::Writer + hash::Hasher, T: Hash<S>> Hash<S> for Vec<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Index<uint> for Vec<T> {\n+impl<T> Index<usize> for Vec<T> {\n     type Output = T;\n \n     #[inline]\n-    fn index<'a>(&'a self, index: &uint) -> &'a T {\n+    fn index(&self, index: &usize) -> &T {\n         // NB built-in indexing via `&[T]`\n         &(**self)[*index]\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> IndexMut<uint> for Vec<T> {\n+impl<T> IndexMut<usize> for Vec<T> {\n     type Output = T;\n \n     #[inline]\n-    fn index_mut<'a>(&'a mut self, index: &uint) -> &'a mut T {\n+    fn index_mut(&mut self, index: &usize) -> &mut T {\n         // NB built-in indexing via `&mut [T]`\n         &mut (**self)[*index]\n     }\n }\n \n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ops::Index<ops::Range<uint>> for Vec<T> {\n+impl<T> ops::Index<ops::Range<usize>> for Vec<T> {\n     type Output = [T];\n     #[inline]\n-    fn index(&self, index: &ops::Range<uint>) -> &[T] {\n+    fn index(&self, index: &ops::Range<usize>) -> &[T] {\n         Index::index(&**self, index)\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ops::Index<ops::RangeTo<uint>> for Vec<T> {\n+impl<T> ops::Index<ops::RangeTo<usize>> for Vec<T> {\n     type Output = [T];\n     #[inline]\n-    fn index(&self, index: &ops::RangeTo<uint>) -> &[T] {\n+    fn index(&self, index: &ops::RangeTo<usize>) -> &[T] {\n         Index::index(&**self, index)\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ops::Index<ops::RangeFrom<uint>> for Vec<T> {\n+impl<T> ops::Index<ops::RangeFrom<usize>> for Vec<T> {\n     type Output = [T];\n     #[inline]\n-    fn index(&self, index: &ops::RangeFrom<uint>) -> &[T] {\n+    fn index(&self, index: &ops::RangeFrom<usize>) -> &[T] {\n         Index::index(&**self, index)\n     }\n }\n@@ -1330,26 +1330,26 @@ impl<T> ops::Index<ops::RangeFull> for Vec<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ops::IndexMut<ops::Range<uint>> for Vec<T> {\n+impl<T> ops::IndexMut<ops::Range<usize>> for Vec<T> {\n     type Output = [T];\n     #[inline]\n-    fn index_mut(&mut self, index: &ops::Range<uint>) -> &mut [T] {\n+    fn index_mut(&mut self, index: &ops::Range<usize>) -> &mut [T] {\n         IndexMut::index_mut(&mut **self, index)\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ops::IndexMut<ops::RangeTo<uint>> for Vec<T> {\n+impl<T> ops::IndexMut<ops::RangeTo<usize>> for Vec<T> {\n     type Output = [T];\n     #[inline]\n-    fn index_mut(&mut self, index: &ops::RangeTo<uint>) -> &mut [T] {\n+    fn index_mut(&mut self, index: &ops::RangeTo<usize>) -> &mut [T] {\n         IndexMut::index_mut(&mut **self, index)\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ops::IndexMut<ops::RangeFrom<uint>> for Vec<T> {\n+impl<T> ops::IndexMut<ops::RangeFrom<usize>> for Vec<T> {\n     type Output = [T];\n     #[inline]\n-    fn index_mut(&mut self, index: &ops::RangeFrom<uint>) -> &mut [T] {\n+    fn index_mut(&mut self, index: &ops::RangeFrom<usize>) -> &mut [T] {\n         IndexMut::index_mut(&mut **self, index)\n     }\n }\n@@ -1366,12 +1366,12 @@ impl<T> ops::IndexMut<ops::RangeFull> for Vec<T> {\n impl<T> ops::Deref for Vec<T> {\n     type Target = [T];\n \n-    fn deref<'a>(&'a self) -> &'a [T] { self.as_slice() }\n+    fn deref(&self) -> &[T] { self.as_slice() }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::DerefMut for Vec<T> {\n-    fn deref_mut<'a>(&'a mut self) -> &'a mut [T] { self.as_mut_slice() }\n+    fn deref_mut(&mut self) -> &mut [T] { self.as_mut_slice() }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1519,7 +1519,7 @@ impl<T> AsSlice<T> for Vec<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn as_slice<'a>(&'a self) -> &'a [T] {\n+    fn as_slice(&self) -> &[T] {\n         unsafe {\n             mem::transmute(RawSlice {\n                 data: *self.ptr,\n@@ -1609,7 +1609,7 @@ impl<'a, T> IntoCow<'a, Vec<T>, [T]> for &'a [T] where T: Clone {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<T> {\n     allocation: *mut T, // the block of memory allocated for the vector\n-    cap: uint, // the capacity of the vector\n+    cap: usize, // the capacity of the vector\n     ptr: *const T,\n     end: *const T\n }\n@@ -1636,7 +1636,7 @@ impl<T> Iterator for IntoIter<T> {\n     type Item = T;\n \n     #[inline]\n-    fn next<'a>(&'a mut self) -> Option<T> {\n+    fn next(&mut self) -> Option<T> {\n         unsafe {\n             if self.ptr == self.end {\n                 None\n@@ -1645,10 +1645,10 @@ impl<T> Iterator for IntoIter<T> {\n                     // purposefully don't use 'ptr.offset' because for\n                     // vectors with 0-size elements this would return the\n                     // same pointer.\n-                    self.ptr = mem::transmute(self.ptr as uint + 1);\n+                    self.ptr = mem::transmute(self.ptr as usize + 1);\n \n                     // Use a non-null pointer value\n-                    Some(ptr::read(mem::transmute(1u)))\n+                    Some(ptr::read(EMPTY as *mut T))\n                 } else {\n                     let old = self.ptr;\n                     self.ptr = self.ptr.offset(1);\n@@ -1660,8 +1660,8 @@ impl<T> Iterator for IntoIter<T> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        let diff = (self.end as uint) - (self.ptr as uint);\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let diff = (self.end as usize) - (self.ptr as usize);\n         let size = mem::size_of::<T>();\n         let exact = diff / (if size == 0 {1} else {size});\n         (exact, Some(exact))\n@@ -1671,17 +1671,17 @@ impl<T> Iterator for IntoIter<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> DoubleEndedIterator for IntoIter<T> {\n     #[inline]\n-    fn next_back<'a>(&'a mut self) -> Option<T> {\n+    fn next_back(&mut self) -> Option<T> {\n         unsafe {\n             if self.end == self.ptr {\n                 None\n             } else {\n                 if mem::size_of::<T>() == 0 {\n                     // See above for why 'ptr.offset' isn't used\n-                    self.end = mem::transmute(self.end as uint - 1);\n+                    self.end = mem::transmute(self.end as usize - 1);\n \n                     // Use a non-null pointer value\n-                    Some(ptr::read(mem::transmute(1u)))\n+                    Some(ptr::read(EMPTY as *mut T))\n                 } else {\n                     self.end = self.end.offset(-1);\n \n@@ -1733,10 +1733,10 @@ impl<'a, T> Iterator for Drain<'a, T> {\n                     // purposefully don't use 'ptr.offset' because for\n                     // vectors with 0-size elements this would return the\n                     // same pointer.\n-                    self.ptr = mem::transmute(self.ptr as uint + 1);\n+                    self.ptr = mem::transmute(self.ptr as usize + 1);\n \n                     // Use a non-null pointer value\n-                    Some(ptr::read(mem::transmute(1u)))\n+                    Some(ptr::read(EMPTY as *mut T))\n                 } else {\n                     let old = self.ptr;\n                     self.ptr = self.ptr.offset(1);\n@@ -1748,8 +1748,8 @@ impl<'a, T> Iterator for Drain<'a, T> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        let diff = (self.end as uint) - (self.ptr as uint);\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let diff = (self.end as usize) - (self.ptr as usize);\n         let size = mem::size_of::<T>();\n         let exact = diff / (if size == 0 {1} else {size});\n         (exact, Some(exact))\n@@ -1766,10 +1766,10 @@ impl<'a, T> DoubleEndedIterator for Drain<'a, T> {\n             } else {\n                 if mem::size_of::<T>() == 0 {\n                     // See above for why 'ptr.offset' isn't used\n-                    self.end = mem::transmute(self.end as uint - 1);\n+                    self.end = mem::transmute(self.end as usize - 1);\n \n                     // Use a non-null pointer value\n-                    Some(ptr::read(mem::transmute(1u)))\n+                    Some(ptr::read(EMPTY as *mut T))\n                 } else {\n                     self.end = self.end.offset(-1);\n \n@@ -1862,8 +1862,8 @@ struct PartialVecNonZeroSized<T,U> {\n /// When the destructor of this struct runs, all `num_t` `T`s and `num_u` `U`s\n /// are destructed.\n struct PartialVecZeroSized<T,U> {\n-    num_t: uint,\n-    num_u: uint,\n+    num_t: usize,\n+    num_u: usize,\n     marker_t: InvariantType<T>,\n     marker_u: InvariantType<U>,\n }\n@@ -1920,7 +1920,7 @@ mod tests {\n     use super::as_vec;\n \n     struct DropCounter<'a> {\n-        count: &'a mut int\n+        count: &'a mut u32\n     }\n \n     #[unsafe_destructor]\n@@ -1949,7 +1949,7 @@ mod tests {\n \n     #[test]\n     fn test_small_vec_struct() {\n-        assert!(size_of::<Vec<u8>>() == size_of::<uint>() * 3);\n+        assert!(size_of::<Vec<u8>>() == size_of::<usize>() * 3);\n     }\n \n     #[test]\n@@ -2020,7 +2020,7 @@ mod tests {\n \n     #[test]\n     fn test_slice_from_mut() {\n-        let mut values = vec![1u8,2,3,4,5];\n+        let mut values = vec![1, 2, 3, 4, 5];\n         {\n             let slice = &mut values[2 ..];\n             assert!(slice == [3, 4, 5]);\n@@ -2034,7 +2034,7 @@ mod tests {\n \n     #[test]\n     fn test_slice_to_mut() {\n-        let mut values = vec![1u8,2,3,4,5];\n+        let mut values = vec![1, 2, 3, 4, 5];\n         {\n             let slice = &mut values[.. 2];\n             assert!(slice == [1, 2]);\n@@ -2048,7 +2048,7 @@ mod tests {\n \n     #[test]\n     fn test_split_at_mut() {\n-        let mut values = vec![1u8,2,3,4,5];\n+        let mut values = vec![1, 2, 3, 4, 5];\n         {\n             let (left, right) = values.split_at_mut(2);\n             {\n@@ -2068,12 +2068,12 @@ mod tests {\n             }\n         }\n \n-        assert!(values == vec![2u8, 3, 5, 6, 7]);\n+        assert!(values == vec![2, 3, 5, 6, 7]);\n     }\n \n     #[test]\n     fn test_clone() {\n-        let v: Vec<int> = vec!();\n+        let v: Vec<i32> = vec![];\n         let w = vec!(1, 2, 3);\n \n         assert_eq!(v, v.clone());\n@@ -2108,9 +2108,9 @@ mod tests {\n \n     #[test]\n     fn test_retain() {\n-        let mut vec = vec![1u, 2, 3, 4];\n+        let mut vec = vec![1, 2, 3, 4];\n         vec.retain(|&x| x % 2 == 0);\n-        assert!(vec == vec![2u, 4]);\n+        assert!(vec == vec![2, 4]);\n     }\n \n     #[test]\n@@ -2146,10 +2146,10 @@ mod tests {\n \n     #[test]\n     fn test_partition() {\n-        assert_eq!(vec![].into_iter().partition(|x: &int| *x < 3), (vec![], vec![]));\n-        assert_eq!(vec![1, 2, 3].into_iter().partition(|x: &int| *x < 4), (vec![1, 2, 3], vec![]));\n-        assert_eq!(vec![1, 2, 3].into_iter().partition(|x: &int| *x < 2), (vec![1], vec![2, 3]));\n-        assert_eq!(vec![1, 2, 3].into_iter().partition(|x: &int| *x < 0), (vec![], vec![1, 2, 3]));\n+        assert_eq!(vec![].into_iter().partition(|x: &i32| *x < 3), (vec![], vec![]));\n+        assert_eq!(vec![1, 2, 3].into_iter().partition(|x| *x < 4), (vec![1, 2, 3], vec![]));\n+        assert_eq!(vec![1, 2, 3].into_iter().partition(|x| *x < 2), (vec![1], vec![2, 3]));\n+        assert_eq!(vec![1, 2, 3].into_iter().partition(|x| *x < 0), (vec![], vec![1, 2, 3]));\n     }\n \n     #[test]\n@@ -2169,21 +2169,21 @@ mod tests {\n             // Test on-stack copy-from-buf.\n             let a = [1, 2, 3];\n             let ptr = a.as_ptr();\n-            let b = Vec::from_raw_buf(ptr, 3u);\n+            let b = Vec::from_raw_buf(ptr, 3);\n             assert_eq!(b, vec![1, 2, 3]);\n \n             // Test on-heap copy-from-buf.\n             let c = vec![1, 2, 3, 4, 5];\n             let ptr = c.as_ptr();\n-            let d = Vec::from_raw_buf(ptr, 5u);\n+            let d = Vec::from_raw_buf(ptr, 5);\n             assert_eq!(d, vec![1, 2, 3, 4, 5]);\n         }\n     }\n \n     #[test]\n     fn test_vec_truncate_drop() {\n-        static mut drops: uint = 0;\n-        struct Elem(int);\n+        static mut drops: u32 = 0;\n+        struct Elem(i32);\n         impl Drop for Elem {\n             fn drop(&mut self) {\n                 unsafe { drops += 1; }\n@@ -2201,7 +2201,7 @@ mod tests {\n     #[test]\n     #[should_fail]\n     fn test_vec_truncate_fail() {\n-        struct BadElem(int);\n+        struct BadElem(i32);\n         impl Drop for BadElem {\n             fn drop(&mut self) {\n                 let BadElem(ref mut x) = *self;\n@@ -2217,62 +2217,62 @@ mod tests {\n \n     #[test]\n     fn test_index() {\n-        let vec = vec!(1, 2, 3);\n+        let vec = vec![1, 2, 3];\n         assert!(vec[1] == 2);\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_index_out_of_bounds() {\n-        let vec = vec!(1, 2, 3);\n+        let vec = vec![1, 2, 3];\n         let _ = vec[3];\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_slice_out_of_bounds_1() {\n-        let x: Vec<int> = vec![1, 2, 3, 4, 5];\n+        let x = vec![1, 2, 3, 4, 5];\n         &x[-1..];\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_slice_out_of_bounds_2() {\n-        let x: Vec<int> = vec![1, 2, 3, 4, 5];\n+        let x = vec![1, 2, 3, 4, 5];\n         &x[..6];\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_slice_out_of_bounds_3() {\n-        let x: Vec<int> = vec![1, 2, 3, 4, 5];\n+        let x = vec![1, 2, 3, 4, 5];\n         &x[-1..4];\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_slice_out_of_bounds_4() {\n-        let x: Vec<int> = vec![1, 2, 3, 4, 5];\n+        let x = vec![1, 2, 3, 4, 5];\n         &x[1..6];\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_slice_out_of_bounds_5() {\n-        let x: Vec<int> = vec![1, 2, 3, 4, 5];\n+        let x = vec![1, 2, 3, 4, 5];\n         &x[3..2];\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_swap_remove_empty() {\n-        let mut vec: Vec<uint> = vec!();\n+        let mut vec= Vec::<i32>::new();\n         vec.swap_remove(0);\n     }\n \n     #[test]\n     fn test_move_iter_unwrap() {\n-        let mut vec: Vec<uint> = Vec::with_capacity(7);\n+        let mut vec = Vec::with_capacity(7);\n         vec.push(1);\n         vec.push(2);\n         let ptr = vec.as_ptr();\n@@ -2285,14 +2285,14 @@ mod tests {\n     #[test]\n     #[should_fail]\n     fn test_map_in_place_incompatible_types_fail() {\n-        let v = vec![0u, 1, 2];\n+        let v = vec![0, 1, 2];\n         v.map_in_place(|_| ());\n     }\n \n     #[test]\n     fn test_map_in_place() {\n-        let v = vec![0u, 1, 2];\n-        assert_eq!(v.map_in_place(|i: uint| i as int - 1), [-1, 0, 1]);\n+        let v = vec![0, 1, 2];\n+        assert_eq!(v.map_in_place(|i: u32| i as i32 - 1), [-1, 0, 1]);\n     }\n \n     #[test]\n@@ -2318,7 +2318,7 @@ mod tests {\n                 DROP_COUNTER.fetch_add(1, Ordering::Relaxed);\n             }\n         }\n-        const NUM_ELEMENTS: uint = 2;\n+        const NUM_ELEMENTS: usize = 2;\n         static DROP_COUNTER: AtomicUsize = ATOMIC_USIZE_INIT;\n \n         let v = repeat(Nothing).take(NUM_ELEMENTS).collect::<Vec<_>>();\n@@ -2334,7 +2334,7 @@ mod tests {\n     #[test]\n     fn test_move_items() {\n         let vec = vec![1, 2, 3];\n-        let mut vec2 : Vec<i32> = vec![];\n+        let mut vec2 = vec![];\n         for i in vec {\n             vec2.push(i);\n         }\n@@ -2344,7 +2344,7 @@ mod tests {\n     #[test]\n     fn test_move_items_reverse() {\n         let vec = vec![1, 2, 3];\n-        let mut vec2 : Vec<i32> = vec![];\n+        let mut vec2 = vec![];\n         for i in vec.into_iter().rev() {\n             vec2.push(i);\n         }\n@@ -2354,7 +2354,7 @@ mod tests {\n     #[test]\n     fn test_move_items_zero_sized() {\n         let vec = vec![(), (), ()];\n-        let mut vec2 : Vec<()> = vec![];\n+        let mut vec2 = vec![];\n         for i in vec {\n             vec2.push(i);\n         }\n@@ -2364,7 +2364,7 @@ mod tests {\n     #[test]\n     fn test_drain_items() {\n         let mut vec = vec![1, 2, 3];\n-        let mut vec2: Vec<i32> = vec![];\n+        let mut vec2 = vec![];\n         for i in vec.drain() {\n             vec2.push(i);\n         }\n@@ -2375,18 +2375,18 @@ mod tests {\n     #[test]\n     fn test_drain_items_reverse() {\n         let mut vec = vec![1, 2, 3];\n-        let mut vec2: Vec<i32> = vec![];\n+        let mut vec2 = vec![];\n         for i in vec.drain().rev() {\n             vec2.push(i);\n         }\n         assert_eq!(vec, []);\n-        assert_eq!(vec2, [ 3, 2, 1 ]);\n+        assert_eq!(vec2, [3, 2, 1]);\n     }\n \n     #[test]\n     fn test_drain_items_zero_sized() {\n         let mut vec = vec![(), (), ()];\n-        let mut vec2: Vec<()> = vec![];\n+        let mut vec2 = vec![];\n         for i in vec.drain() {\n             vec2.push(i);\n         }\n@@ -2396,9 +2396,9 @@ mod tests {\n \n     #[test]\n     fn test_into_boxed_slice() {\n-        let xs = vec![1u, 2, 3];\n+        let xs = vec![1, 2, 3];\n         let ys = xs.into_boxed_slice();\n-        assert_eq!(ys, [1u, 2, 3]);\n+        assert_eq!(ys, [1, 2, 3]);\n     }\n \n     #[test]\n@@ -2421,17 +2421,17 @@ mod tests {\n     #[bench]\n     fn bench_new(b: &mut Bencher) {\n         b.iter(|| {\n-            let v: Vec<uint> = Vec::new();\n+            let v: Vec<u32> = Vec::new();\n             assert_eq!(v.len(), 0);\n             assert_eq!(v.capacity(), 0);\n         })\n     }\n \n-    fn do_bench_with_capacity(b: &mut Bencher, src_len: uint) {\n+    fn do_bench_with_capacity(b: &mut Bencher, src_len: usize) {\n         b.bytes = src_len as u64;\n \n         b.iter(|| {\n-            let v: Vec<uint> = Vec::with_capacity(src_len);\n+            let v: Vec<u32> = Vec::with_capacity(src_len);\n             assert_eq!(v.len(), 0);\n             assert_eq!(v.capacity(), src_len);\n         })\n@@ -2457,7 +2457,7 @@ mod tests {\n         do_bench_with_capacity(b, 1000)\n     }\n \n-    fn do_bench_from_fn(b: &mut Bencher, src_len: uint) {\n+    fn do_bench_from_fn(b: &mut Bencher, src_len: usize) {\n         b.bytes = src_len as u64;\n \n         b.iter(|| {\n@@ -2487,11 +2487,11 @@ mod tests {\n         do_bench_from_fn(b, 1000)\n     }\n \n-    fn do_bench_from_elem(b: &mut Bencher, src_len: uint) {\n+    fn do_bench_from_elem(b: &mut Bencher, src_len: usize) {\n         b.bytes = src_len as u64;\n \n         b.iter(|| {\n-            let dst: Vec<uint> = repeat(5).take(src_len).collect();\n+            let dst: Vec<usize> = repeat(5).take(src_len).collect();\n             assert_eq!(dst.len(), src_len);\n             assert!(dst.iter().all(|x| *x == 5));\n         })\n@@ -2517,8 +2517,8 @@ mod tests {\n         do_bench_from_elem(b, 1000)\n     }\n \n-    fn do_bench_from_slice(b: &mut Bencher, src_len: uint) {\n-        let src: Vec<uint> = FromIterator::from_iter(0..src_len);\n+    fn do_bench_from_slice(b: &mut Bencher, src_len: usize) {\n+        let src: Vec<_> = FromIterator::from_iter(0..src_len);\n \n         b.bytes = src_len as u64;\n \n@@ -2549,13 +2549,13 @@ mod tests {\n         do_bench_from_slice(b, 1000)\n     }\n \n-    fn do_bench_from_iter(b: &mut Bencher, src_len: uint) {\n-        let src: Vec<uint> = FromIterator::from_iter(0..src_len);\n+    fn do_bench_from_iter(b: &mut Bencher, src_len: usize) {\n+        let src: Vec<_> = FromIterator::from_iter(0..src_len);\n \n         b.bytes = src_len as u64;\n \n         b.iter(|| {\n-            let dst: Vec<uint> = FromIterator::from_iter(src.clone().into_iter());\n+            let dst: Vec<_> = FromIterator::from_iter(src.clone().into_iter());\n             assert_eq!(dst.len(), src_len);\n             assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n         });\n@@ -2581,9 +2581,9 @@ mod tests {\n         do_bench_from_iter(b, 1000)\n     }\n \n-    fn do_bench_extend(b: &mut Bencher, dst_len: uint, src_len: uint) {\n-        let dst: Vec<uint> = FromIterator::from_iter(0..dst_len);\n-        let src: Vec<uint> = FromIterator::from_iter(dst_len..dst_len + src_len);\n+    fn do_bench_extend(b: &mut Bencher, dst_len: usize, src_len: usize) {\n+        let dst: Vec<_> = FromIterator::from_iter(0..dst_len);\n+        let src: Vec<_> = FromIterator::from_iter(dst_len..dst_len + src_len);\n \n         b.bytes = src_len as u64;\n \n@@ -2630,9 +2630,9 @@ mod tests {\n         do_bench_extend(b, 1000, 1000)\n     }\n \n-    fn do_bench_push_all(b: &mut Bencher, dst_len: uint, src_len: uint) {\n-        let dst: Vec<uint> = FromIterator::from_iter(0..dst_len);\n-        let src: Vec<uint> = FromIterator::from_iter(dst_len..dst_len + src_len);\n+    fn do_bench_push_all(b: &mut Bencher, dst_len: usize, src_len: usize) {\n+        let dst: Vec<_> = FromIterator::from_iter(0..dst_len);\n+        let src: Vec<_> = FromIterator::from_iter(dst_len..dst_len + src_len);\n \n         b.bytes = src_len as u64;\n \n@@ -2679,9 +2679,9 @@ mod tests {\n         do_bench_push_all(b, 1000, 1000)\n     }\n \n-    fn do_bench_push_all_move(b: &mut Bencher, dst_len: uint, src_len: uint) {\n-        let dst: Vec<uint> = FromIterator::from_iter(0u..dst_len);\n-        let src: Vec<uint> = FromIterator::from_iter(dst_len..dst_len + src_len);\n+    fn do_bench_push_all_move(b: &mut Bencher, dst_len: usize, src_len: usize) {\n+        let dst: Vec<_> = FromIterator::from_iter(0..dst_len);\n+        let src: Vec<_> = FromIterator::from_iter(dst_len..dst_len + src_len);\n \n         b.bytes = src_len as u64;\n \n@@ -2728,8 +2728,8 @@ mod tests {\n         do_bench_push_all_move(b, 1000, 1000)\n     }\n \n-    fn do_bench_clone(b: &mut Bencher, src_len: uint) {\n-        let src: Vec<uint> = FromIterator::from_iter(0..src_len);\n+    fn do_bench_clone(b: &mut Bencher, src_len: usize) {\n+        let src: Vec<usize> = FromIterator::from_iter(0..src_len);\n \n         b.bytes = src_len as u64;\n \n@@ -2760,9 +2760,9 @@ mod tests {\n         do_bench_clone(b, 1000)\n     }\n \n-    fn do_bench_clone_from(b: &mut Bencher, times: uint, dst_len: uint, src_len: uint) {\n-        let dst: Vec<uint> = FromIterator::from_iter(0..src_len);\n-        let src: Vec<uint> = FromIterator::from_iter(dst_len..dst_len + src_len);\n+    fn do_bench_clone_from(b: &mut Bencher, times: usize, dst_len: usize, src_len: usize) {\n+        let dst: Vec<_> = FromIterator::from_iter(0..src_len);\n+        let src: Vec<_> = FromIterator::from_iter(dst_len..dst_len + src_len);\n \n         b.bytes = (times * src_len) as u64;\n "}, {"sha": "65592d138c72c63758fd6028db83c3e249529908", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 89, "deletions": 97, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -13,7 +13,7 @@\n \n #![allow(missing_docs)]\n \n-pub use self::Entry::*;\n+use self::Entry::*;\n \n use core::prelude::*;\n \n@@ -29,8 +29,6 @@ use core::ops::{Index, IndexMut};\n use {vec, slice};\n use vec::Vec;\n \n-// FIXME(conventions): capacity management???\n-\n /// A map optimized for small integer keys.\n ///\n /// # Examples\n@@ -117,7 +115,7 @@ impl<S: Writer + Hasher, V: Hash<S>> Hash<S> for VecMap<V> {\n     fn hash(&self, state: &mut S) {\n         // In order to not traverse the `VecMap` twice, count the elements\n         // during iteration.\n-        let mut count: uint = 0;\n+        let mut count: usize = 0;\n         for elt in self {\n             elt.hash(state);\n             count += 1;\n@@ -148,7 +146,7 @@ impl<V> VecMap<V> {\n     /// let mut map: VecMap<&str> = VecMap::with_capacity(10);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn with_capacity(capacity: uint) -> VecMap<V> {\n+    pub fn with_capacity(capacity: usize) -> VecMap<V> {\n         VecMap { v: Vec::with_capacity(capacity) }\n     }\n \n@@ -164,7 +162,7 @@ impl<V> VecMap<V> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn capacity(&self) -> uint {\n+    pub fn capacity(&self) -> usize {\n         self.v.capacity()\n     }\n \n@@ -183,7 +181,7 @@ impl<V> VecMap<V> {\n     /// assert!(map.capacity() >= 10);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn reserve_len(&mut self, len: uint) {\n+    pub fn reserve_len(&mut self, len: usize) {\n         let cur_len = self.v.len();\n         if len >= cur_len {\n             self.v.reserve(len - cur_len);\n@@ -207,19 +205,19 @@ impl<V> VecMap<V> {\n     /// assert!(map.capacity() >= 10);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn reserve_len_exact(&mut self, len: uint) {\n+    pub fn reserve_len_exact(&mut self, len: usize) {\n         let cur_len = self.v.len();\n         if len >= cur_len {\n             self.v.reserve_exact(len - cur_len);\n         }\n     }\n \n     /// Returns an iterator visiting all keys in ascending order of the keys.\n-    /// The iterator's element type is `uint`.\n+    /// The iterator's element type is `usize`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn keys<'r>(&'r self) -> Keys<'r, V> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n-        let first: fn((uint, &'r V)) -> uint = first; // coerce to fn pointer\n+        let first: fn((usize, &'r V)) -> usize = first; // coerce to fn pointer\n \n         Keys { iter: self.iter().map(first) }\n     }\n@@ -229,13 +227,13 @@ impl<V> VecMap<V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn values<'r>(&'r self) -> Values<'r, V> {\n         fn second<A, B>((_, b): (A, B)) -> B { b }\n-        let second: fn((uint, &'r V)) -> &'r V = second; // coerce to fn pointer\n+        let second: fn((usize, &'r V)) -> &'r V = second; // coerce to fn pointer\n \n         Values { iter: self.iter().map(second) }\n     }\n \n     /// Returns an iterator visiting all key-value pairs in ascending order of the keys.\n-    /// The iterator's element type is `(uint, &'r V)`.\n+    /// The iterator's element type is `(usize, &'r V)`.\n     ///\n     /// # Examples\n     ///\n@@ -263,7 +261,7 @@ impl<V> VecMap<V> {\n \n     /// Returns an iterator visiting all key-value pairs in ascending order of the keys,\n     /// with mutable references to the values.\n-    /// The iterator's element type is `(uint, &'r mut V)`.\n+    /// The iterator's element type is `(usize, &'r mut V)`.\n     ///\n     /// # Examples\n     ///\n@@ -294,7 +292,7 @@ impl<V> VecMap<V> {\n \n     /// Returns an iterator visiting all key-value pairs in ascending order of\n     /// the keys, consuming the original `VecMap`.\n-    /// The iterator's element type is `(uint, &'r V)`.\n+    /// The iterator's element type is `(usize, &'r V)`.\n     ///\n     /// # Examples\n     ///\n@@ -306,23 +304,23 @@ impl<V> VecMap<V> {\n     /// map.insert(3, \"c\");\n     /// map.insert(2, \"b\");\n     ///\n-    /// let vec: Vec<(uint, &str)> = map.into_iter().collect();\n+    /// let vec: Vec<(usize, &str)> = map.into_iter().collect();\n     ///\n     /// assert_eq!(vec, vec![(1, \"a\"), (2, \"b\"), (3, \"c\")]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<V> {\n-        fn filter<A>((i, v): (uint, Option<A>)) -> Option<(uint, A)> {\n+        fn filter<A>((i, v): (usize, Option<A>)) -> Option<(usize, A)> {\n             v.map(|v| (i, v))\n         }\n-        let filter: fn((uint, Option<V>)) -> Option<(uint, V)> = filter; // coerce to fn ptr\n+        let filter: fn((usize, Option<V>)) -> Option<(usize, V)> = filter; // coerce to fn ptr\n \n         IntoIter { iter: self.v.into_iter().enumerate().filter_map(filter) }\n     }\n \n     /// Returns an iterator visiting all key-value pairs in ascending order of\n     /// the keys, emptying (but not consuming) the original `VecMap`.\n-    /// The iterator's element type is `(uint, &'r V)`. Keeps the allocated memory for reuse.\n+    /// The iterator's element type is `(usize, &'r V)`. Keeps the allocated memory for reuse.\n     ///\n     /// # Examples\n     ///\n@@ -334,17 +332,17 @@ impl<V> VecMap<V> {\n     /// map.insert(3, \"c\");\n     /// map.insert(2, \"b\");\n     ///\n-    /// let vec: Vec<(uint, &str)> = map.drain().collect();\n+    /// let vec: Vec<(usize, &str)> = map.drain().collect();\n     ///\n     /// assert_eq!(vec, vec![(1, \"a\"), (2, \"b\"), (3, \"c\")]);\n     /// ```\n     #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn drain<'a>(&'a mut self) -> Drain<'a, V> {\n-        fn filter<A>((i, v): (uint, Option<A>)) -> Option<(uint, A)> {\n+        fn filter<A>((i, v): (usize, Option<A>)) -> Option<(usize, A)> {\n             v.map(|v| (i, v))\n         }\n-        let filter: fn((uint, Option<V>)) -> Option<(uint, V)> = filter; // coerce to fn ptr\n+        let filter: fn((usize, Option<V>)) -> Option<(usize, V)> = filter; // coerce to fn ptr\n \n         Drain { iter: self.v.drain().enumerate().filter_map(filter) }\n     }\n@@ -362,7 +360,7 @@ impl<V> VecMap<V> {\n     /// assert_eq!(a.len(), 1);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> uint {\n+    pub fn len(&self) -> usize {\n         self.v.iter().filter(|elt| elt.is_some()).count()\n     }\n \n@@ -411,7 +409,7 @@ impl<V> VecMap<V> {\n     /// assert_eq!(map.get(&2), None);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get(&self, key: &uint) -> Option<&V> {\n+    pub fn get(&self, key: &usize) -> Option<&V> {\n         if *key < self.v.len() {\n             match self.v[*key] {\n               Some(ref value) => Some(value),\n@@ -436,7 +434,7 @@ impl<V> VecMap<V> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn contains_key(&self, key: &uint) -> bool {\n+    pub fn contains_key(&self, key: &usize) -> bool {\n         self.get(key).is_some()\n     }\n \n@@ -456,7 +454,7 @@ impl<V> VecMap<V> {\n     /// assert_eq!(map[1], \"b\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get_mut(&mut self, key: &uint) -> Option<&mut V> {\n+    pub fn get_mut(&mut self, key: &usize) -> Option<&mut V> {\n         if *key < self.v.len() {\n             match *(&mut self.v[*key]) {\n               Some(ref mut value) => Some(value),\n@@ -484,7 +482,7 @@ impl<V> VecMap<V> {\n     /// assert_eq!(map[37], \"c\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn insert(&mut self, key: uint, value: V) -> Option<V> {\n+    pub fn insert(&mut self, key: usize, value: V) -> Option<V> {\n         let len = self.v.len();\n         if len <= key {\n             self.v.extend((0..key - len + 1).map(|_| None));\n@@ -506,7 +504,7 @@ impl<V> VecMap<V> {\n     /// assert_eq!(map.remove(&1), None);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn remove(&mut self, key: &uint) -> Option<V> {\n+    pub fn remove(&mut self, key: &usize) -> Option<V> {\n         if *key >= self.v.len() {\n             return None;\n         }\n@@ -539,8 +537,7 @@ impl<V> VecMap<V> {\n     ///\n     /// assert_eq!(count[1], 3);\n     /// ```\n-    #[unstable(feature = \"collections\",\n-               reason = \"precise API still under development\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn entry(&mut self, key: usize) -> Entry<V> {\n         // FIXME(Gankro): this is basically the dumbest implementation of\n         // entry possible, because weird non-lexical borrows issues make it\n@@ -576,8 +573,7 @@ impl<'a, V> Entry<'a, V> {\n impl<'a, V> VacantEntry<'a, V> {\n     /// Sets the value of the entry with the VacantEntry's key,\n     /// and returns a mutable reference to it.\n-    #[unstable(feature = \"collections\",\n-               reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(self, value: V) -> &'a mut V {\n         let index = self.index;\n         self.map.insert(index, value);\n@@ -587,41 +583,36 @@ impl<'a, V> VacantEntry<'a, V> {\n \n impl<'a, V> OccupiedEntry<'a, V> {\n     /// Gets a reference to the value in the entry.\n-    #[unstable(feature = \"collections\",\n-               reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get(&self) -> &V {\n         let index = self.index;\n         &self.map[index]\n     }\n \n     /// Gets a mutable reference to the value in the entry.\n-    #[unstable(feature = \"collections\",\n-               reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut(&mut self) -> &mut V {\n         let index = self.index;\n         &mut self.map[index]\n     }\n \n     /// Converts the entry into a mutable reference to its value.\n-    #[unstable(feature = \"collections\",\n-               reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_mut(self) -> &'a mut V {\n         let index = self.index;\n         &mut self.map[index]\n     }\n \n     /// Sets the value of the entry with the OccupiedEntry's key,\n     /// and returns the entry's old value.\n-    #[unstable(feature = \"collections\",\n-               reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(&mut self, value: V) -> V {\n         let index = self.index;\n         self.map.insert(index, value).unwrap()\n     }\n \n     /// Takes the value of the entry out of the map, and returns it.\n-    #[unstable(feature = \"collections\",\n-               reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove(self) -> V {\n         let index = self.index;\n         self.map.remove(&index).unwrap()\n@@ -669,8 +660,8 @@ impl<V: fmt::Debug> fmt::Debug for VecMap<V> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<V> FromIterator<(uint, V)> for VecMap<V> {\n-    fn from_iter<Iter: Iterator<Item=(uint, V)>>(iter: Iter) -> VecMap<V> {\n+impl<V> FromIterator<(usize, V)> for VecMap<V> {\n+    fn from_iter<Iter: Iterator<Item=(usize, V)>>(iter: Iter) -> VecMap<V> {\n         let mut map = VecMap::new();\n         map.extend(iter);\n         map\n@@ -702,29 +693,29 @@ impl<'a, T> IntoIterator for &'a mut VecMap<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<V> Extend<(uint, V)> for VecMap<V> {\n-    fn extend<Iter: Iterator<Item=(uint, V)>>(&mut self, iter: Iter) {\n+impl<V> Extend<(usize, V)> for VecMap<V> {\n+    fn extend<Iter: Iterator<Item=(usize, V)>>(&mut self, iter: Iter) {\n         for (k, v) in iter {\n             self.insert(k, v);\n         }\n     }\n }\n \n-impl<V> Index<uint> for VecMap<V> {\n+impl<V> Index<usize> for VecMap<V> {\n     type Output = V;\n \n     #[inline]\n-    fn index<'a>(&'a self, i: &uint) -> &'a V {\n+    fn index<'a>(&'a self, i: &usize) -> &'a V {\n         self.get(i).expect(\"key not present\")\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<V> IndexMut<uint> for VecMap<V> {\n+impl<V> IndexMut<usize> for VecMap<V> {\n     type Output = V;\n \n     #[inline]\n-    fn index_mut<'a>(&'a mut self, i: &uint) -> &'a mut V {\n+    fn index_mut<'a>(&'a mut self, i: &usize) -> &'a mut V {\n         self.get_mut(i).expect(\"key not present\")\n     }\n }\n@@ -757,7 +748,7 @@ macro_rules! iterator {\n             }\n \n             #[inline]\n-            fn size_hint(&self) -> (uint, Option<uint>) {\n+            fn size_hint(&self) -> (usize, Option<usize>) {\n                 (0, Some(self.back - self.front))\n             }\n         }\n@@ -794,8 +785,8 @@ macro_rules! double_ended_iterator {\n /// An iterator over the key-value pairs of a map.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, V:'a> {\n-    front: uint,\n-    back: uint,\n+    front: usize,\n+    back: usize,\n     iter: slice::Iter<'a, Option<V>>\n }\n \n@@ -810,25 +801,25 @@ impl<'a, V> Clone for Iter<'a, V> {\n     }\n }\n \n-iterator! { impl Iter -> (uint, &'a V), as_ref }\n-double_ended_iterator! { impl Iter -> (uint, &'a V), as_ref }\n+iterator! { impl Iter -> (usize, &'a V), as_ref }\n+double_ended_iterator! { impl Iter -> (usize, &'a V), as_ref }\n \n /// An iterator over the key-value pairs of a map, with the\n /// values being mutable.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, V:'a> {\n-    front: uint,\n-    back: uint,\n+    front: usize,\n+    back: usize,\n     iter: slice::IterMut<'a, Option<V>>\n }\n \n-iterator! { impl IterMut -> (uint, &'a mut V), as_mut }\n-double_ended_iterator! { impl IterMut -> (uint, &'a mut V), as_mut }\n+iterator! { impl IterMut -> (usize, &'a mut V), as_mut }\n+double_ended_iterator! { impl IterMut -> (usize, &'a mut V), as_mut }\n \n /// An iterator over the keys of a map.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Keys<'a, V: 'a> {\n-    iter: Map<Iter<'a, V>, fn((uint, &'a V)) -> uint>\n+    iter: Map<Iter<'a, V>, fn((usize, &'a V)) -> usize>\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n@@ -843,7 +834,7 @@ impl<'a, V> Clone for Keys<'a, V> {\n /// An iterator over the values of a map.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Values<'a, V: 'a> {\n-    iter: Map<Iter<'a, V>, fn((uint, &'a V)) -> &'a V>\n+    iter: Map<Iter<'a, V>, fn((usize, &'a V)) -> &'a V>\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n@@ -860,47 +851,47 @@ impl<'a, V> Clone for Values<'a, V> {\n pub struct IntoIter<V> {\n     iter: FilterMap<\n     Enumerate<vec::IntoIter<Option<V>>>,\n-    fn((uint, Option<V>)) -> Option<(uint, V)>>\n+    fn((usize, Option<V>)) -> Option<(usize, V)>>\n }\n \n #[unstable(feature = \"collections\")]\n pub struct Drain<'a, V> {\n     iter: FilterMap<\n     Enumerate<vec::Drain<'a, Option<V>>>,\n-    fn((uint, Option<V>)) -> Option<(uint, V)>>\n+    fn((usize, Option<V>)) -> Option<(usize, V)>>\n }\n \n #[unstable(feature = \"collections\")]\n impl<'a, V> Iterator for Drain<'a, V> {\n-    type Item = (uint, V);\n+    type Item = (usize, V);\n \n-    fn next(&mut self) -> Option<(uint, V)> { self.iter.next() }\n-    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+    fn next(&mut self) -> Option<(usize, V)> { self.iter.next() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n \n #[unstable(feature = \"collections\")]\n impl<'a, V> DoubleEndedIterator for Drain<'a, V> {\n-    fn next_back(&mut self) -> Option<(uint, V)> { self.iter.next_back() }\n+    fn next_back(&mut self) -> Option<(usize, V)> { self.iter.next_back() }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, V> Iterator for Keys<'a, V> {\n-    type Item = uint;\n+    type Item = usize;\n \n-    fn next(&mut self) -> Option<uint> { self.iter.next() }\n-    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+    fn next(&mut self) -> Option<usize> { self.iter.next() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, V> DoubleEndedIterator for Keys<'a, V> {\n-    fn next_back(&mut self) -> Option<uint> { self.iter.next_back() }\n+    fn next_back(&mut self) -> Option<usize> { self.iter.next_back() }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, V> Iterator for Values<'a, V> {\n     type Item = &'a V;\n \n     fn next(&mut self) -> Option<(&'a V)> { self.iter.next() }\n-    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, V> DoubleEndedIterator for Values<'a, V> {\n@@ -909,22 +900,23 @@ impl<'a, V> DoubleEndedIterator for Values<'a, V> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<V> Iterator for IntoIter<V> {\n-    type Item = (uint, V);\n+    type Item = (usize, V);\n \n-    fn next(&mut self) -> Option<(uint, V)> { self.iter.next() }\n-    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+    fn next(&mut self) -> Option<(usize, V)> { self.iter.next() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<V> DoubleEndedIterator for IntoIter<V> {\n-    fn next_back(&mut self) -> Option<(uint, V)> { self.iter.next_back() }\n+    fn next_back(&mut self) -> Option<(usize, V)> { self.iter.next_back() }\n }\n \n #[cfg(test)]\n mod test_map {\n     use prelude::*;\n     use core::hash::{hash, SipHasher};\n \n-    use super::{VecMap, Occupied, Vacant};\n+    use super::VecMap;\n+    use super::Entry::{Occupied, Vacant};\n \n     #[test]\n     fn test_get_mut() {\n@@ -990,7 +982,7 @@ mod test_map {\n         map.insert(1, 'a');\n         map.insert(2, 'b');\n         map.insert(3, 'c');\n-        let keys = map.keys().collect::<Vec<uint>>();\n+        let keys: Vec<_> = map.keys().collect();\n         assert_eq!(keys.len(), 3);\n         assert!(keys.contains(&1));\n         assert!(keys.contains(&2));\n@@ -1003,7 +995,7 @@ mod test_map {\n         map.insert(1, 'a');\n         map.insert(2, 'b');\n         map.insert(3, 'c');\n-        let values = map.values().map(|&v| v).collect::<Vec<char>>();\n+        let values: Vec<_> = map.values().cloned().collect();\n         assert_eq!(values.len(), 3);\n         assert!(values.contains(&'a'));\n         assert!(values.contains(&'b'));\n@@ -1062,7 +1054,7 @@ mod test_map {\n         assert!(m.insert(10, 11).is_none());\n \n         for (k, v) in &mut m {\n-            *v += k as int;\n+            *v += k as isize;\n         }\n \n         let mut it = m.iter();\n@@ -1104,7 +1096,7 @@ mod test_map {\n         assert!(m.insert(10, 11).is_none());\n \n         for (k, v) in m.iter_mut().rev() {\n-            *v += k as int;\n+            *v += k as isize;\n         }\n \n         let mut it = m.iter();\n@@ -1137,7 +1129,7 @@ mod test_map {\n         map.insert(3, \"c\");\n         map.insert(2, \"b\");\n \n-        let vec: Vec<(usize, &str)> = map.drain().collect();\n+        let vec: Vec<_> = map.drain().collect();\n \n         assert_eq!(vec, vec![(1, \"a\"), (2, \"b\"), (3, \"c\")]);\n         assert_eq!(map.len(), 0);\n@@ -1146,7 +1138,7 @@ mod test_map {\n     #[test]\n     fn test_show() {\n         let mut map = VecMap::new();\n-        let empty = VecMap::<int>::new();\n+        let empty = VecMap::<i32>::new();\n \n         map.insert(1, 2);\n         map.insert(3, 4);\n@@ -1195,7 +1187,7 @@ mod test_map {\n         let mut b = VecMap::new();\n \n         assert!(!(a < b) && !(b < a));\n-        assert!(b.insert(2u, 5).is_none());\n+        assert!(b.insert(2, 5).is_none());\n         assert!(a < b);\n         assert!(a.insert(2, 7).is_none());\n         assert!(!(a < b) && b < a);\n@@ -1213,7 +1205,7 @@ mod test_map {\n         let mut b = VecMap::new();\n \n         assert!(a <= b && a >= b);\n-        assert!(a.insert(1u, 1).is_none());\n+        assert!(a.insert(1, 1).is_none());\n         assert!(a > b && a >= b);\n         assert!(b < a && b <= a);\n         assert!(b.insert(2, 2).is_none());\n@@ -1245,9 +1237,9 @@ mod test_map {\n \n     #[test]\n     fn test_from_iter() {\n-        let xs: Vec<(uint, char)> = vec![(1u, 'a'), (2, 'b'), (3, 'c'), (4, 'd'), (5, 'e')];\n+        let xs = vec![(1, 'a'), (2, 'b'), (3, 'c'), (4, 'd'), (5, 'e')];\n \n-        let map: VecMap<char> = xs.iter().map(|&x| x).collect();\n+        let map: VecMap<_> = xs.iter().cloned().collect();\n \n         for &(k, v) in &xs {\n             assert_eq!(map.get(&k), Some(&v));\n@@ -1256,7 +1248,7 @@ mod test_map {\n \n     #[test]\n     fn test_index() {\n-        let mut map: VecMap<int> = VecMap::new();\n+        let mut map = VecMap::new();\n \n         map.insert(1, 2);\n         map.insert(2, 1);\n@@ -1268,7 +1260,7 @@ mod test_map {\n     #[test]\n     #[should_fail]\n     fn test_index_nonexistent() {\n-        let mut map: VecMap<int> = VecMap::new();\n+        let mut map = VecMap::new();\n \n         map.insert(1, 2);\n         map.insert(2, 1);\n@@ -1281,7 +1273,7 @@ mod test_map {\n     fn test_entry(){\n         let xs = [(1, 10), (2, 20), (3, 30), (4, 40), (5, 50), (6, 60)];\n \n-        let mut map: VecMap<i32> = xs.iter().map(|&x| x).collect();\n+        let mut map: VecMap<_> = xs.iter().cloned().collect();\n \n         // Existing key (insert)\n         match map.entry(1) {\n@@ -1337,15 +1329,15 @@ mod bench {\n \n     #[bench]\n     pub fn insert_rand_100(b: &mut Bencher) {\n-        let mut m : VecMap<uint> = VecMap::new();\n+        let mut m = VecMap::new();\n         insert_rand_n(100, &mut m, b,\n                       |m, i| { m.insert(i, 1); },\n                       |m, i| { m.remove(&i); });\n     }\n \n     #[bench]\n     pub fn insert_rand_10_000(b: &mut Bencher) {\n-        let mut m : VecMap<uint> = VecMap::new();\n+        let mut m = VecMap::new();\n         insert_rand_n(10_000, &mut m, b,\n                       |m, i| { m.insert(i, 1); },\n                       |m, i| { m.remove(&i); });\n@@ -1354,15 +1346,15 @@ mod bench {\n     // Insert seq\n     #[bench]\n     pub fn insert_seq_100(b: &mut Bencher) {\n-        let mut m : VecMap<uint> = VecMap::new();\n+        let mut m = VecMap::new();\n         insert_seq_n(100, &mut m, b,\n                      |m, i| { m.insert(i, 1); },\n                      |m, i| { m.remove(&i); });\n     }\n \n     #[bench]\n     pub fn insert_seq_10_000(b: &mut Bencher) {\n-        let mut m : VecMap<uint> = VecMap::new();\n+        let mut m = VecMap::new();\n         insert_seq_n(10_000, &mut m, b,\n                      |m, i| { m.insert(i, 1); },\n                      |m, i| { m.remove(&i); });\n@@ -1371,15 +1363,15 @@ mod bench {\n     // Find rand\n     #[bench]\n     pub fn find_rand_100(b: &mut Bencher) {\n-        let mut m : VecMap<uint> = VecMap::new();\n+        let mut m = VecMap::new();\n         find_rand_n(100, &mut m, b,\n                     |m, i| { m.insert(i, 1); },\n                     |m, i| { m.get(&i); });\n     }\n \n     #[bench]\n     pub fn find_rand_10_000(b: &mut Bencher) {\n-        let mut m : VecMap<uint> = VecMap::new();\n+        let mut m = VecMap::new();\n         find_rand_n(10_000, &mut m, b,\n                     |m, i| { m.insert(i, 1); },\n                     |m, i| { m.get(&i); });\n@@ -1388,15 +1380,15 @@ mod bench {\n     // Find seq\n     #[bench]\n     pub fn find_seq_100(b: &mut Bencher) {\n-        let mut m : VecMap<uint> = VecMap::new();\n+        let mut m = VecMap::new();\n         find_seq_n(100, &mut m, b,\n                    |m, i| { m.insert(i, 1); },\n                    |m, i| { m.get(&i); });\n     }\n \n     #[bench]\n     pub fn find_seq_10_000(b: &mut Bencher) {\n-        let mut m : VecMap<uint> = VecMap::new();\n+        let mut m = VecMap::new();\n         find_seq_n(10_000, &mut m, b,\n                    |m, i| { m.insert(i, 1); },\n                    |m, i| { m.get(&i); });"}, {"sha": "d405d0d28beb3636fbac2387771a037a4f9f02cf", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -30,7 +30,6 @@ use super::{Hasher, Writer};\n /// strong, this implementation has not been reviewed for such purposes.\n /// As such, all cryptographic uses of this implementation are strongly\n /// discouraged.\n-#[allow(missing_copy_implementations)]\n pub struct SipHasher {\n     k0: u64,\n     k1: u64,"}, {"sha": "f3b42e4f0a5775db7c8c6d0deca663e3b368a59f", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -260,7 +260,7 @@ pub trait IteratorExt: Iterator + Sized {\n     }\n \n     /// Creates an iterator that applies the predicate to each element returned\n-    /// by this iterator. The only elements that will be yieled are those that\n+    /// by this iterator. The only elements that will be yielded are those that\n     /// make the predicate evaluate to `true`.\n     ///\n     /// # Examples"}, {"sha": "2d14b31748e5f13c126078895e3dac9a04f1a230", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -396,7 +396,6 @@ pub struct InvariantLifetime<'a>;\n            reason = \"likely to change with new variance strategy\")]\n #[lang=\"no_copy_bound\"]\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]\n-#[allow(missing_copy_implementations)]\n pub struct NoCopy;\n \n /// A type which is considered managed by the GC. This is typically\n@@ -405,5 +404,4 @@ pub struct NoCopy;\n            reason = \"likely to change with new variance strategy\")]\n #[lang=\"managed_bound\"]\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]\n-#[allow(missing_copy_implementations)]\n pub struct Managed;"}, {"sha": "51bf3c1648f568482abce0ad2ea1e54c6269435a", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -331,8 +331,9 @@ pub unsafe fn copy_lifetime<'a, S: ?Sized, T: ?Sized + 'a>(_ptr: &'a S,\n #[unstable(feature = \"core\",\n            reason = \"this function may be removed in the future due to its \\\n                      questionable utility\")]\n-pub unsafe fn copy_mut_lifetime<'a, S: ?Sized, T: ?Sized + 'a>(_ptr: &'a mut S,\n-                                                            ptr: &mut T)\n-                                                            -> &'a mut T {\n+pub unsafe fn copy_mut_lifetime<'a, S: ?Sized, T: ?Sized + 'a>(_ptr: &'a S,\n+                                                               ptr: &mut T)\n+                                                              -> &'a mut T\n+{\n     transmute(ptr)\n }"}, {"sha": "ba1eae551ff2a15f9dba0fa52253c0b10b346dbd", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -190,7 +190,7 @@ pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T {\n     src\n }\n \n-/// Reads the value from `src` without dropping it. This leaves the\n+/// Reads the value from `src` without moving it. This leaves the\n /// memory in `src` unchanged.\n ///\n /// # Safety"}, {"sha": "013b7f27839dabd518ea39a4585cafa9aae8c1e5", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -149,7 +149,6 @@ impl FromStr for bool {\n \n /// An error returned when parsing a `bool` from a string fails.\n #[derive(Debug, Clone, PartialEq)]\n-#[allow(missing_copy_implementations)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct ParseBoolError { _priv: () }\n "}, {"sha": "2d94ddaef18355fe146551e0bb40e6598544003c", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -278,7 +278,6 @@\n #![feature(collections)]\n #![feature(core)]\n #![feature(io)]\n-#![feature(path)]\n \n use self::LabelText::*;\n \n@@ -287,8 +286,6 @@ use std::old_io;\n use std::string::CowString;\n use std::vec::CowVec;\n \n-pub mod maybe_owned_vec;\n-\n /// The text for a graphviz label on a node or edge.\n pub enum LabelText<'a> {\n     /// This kind of label preserves the text directly as is."}, {"sha": "1c931856fa17c5a9e9c9d82be30304d8e41fe715", "filename": "src/libgraphviz/maybe_owned_vec.rs", "status": "removed", "additions": 0, "deletions": 165, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/b75b21cb9b187a6f836da61769a8110354fd6dad/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b21cb9b187a6f836da61769a8110354fd6dad/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Fmaybe_owned_vec.rs?ref=b75b21cb9b187a6f836da61769a8110354fd6dad", "patch": "@@ -1,165 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![unstable(feature = \"rustc_private\")]\n-#![deprecated(since = \"1.0.0\", reason = \"use std::vec::CowVec\")]\n-\n-pub use self::MaybeOwnedVector::*;\n-\n-use std::cmp::Ordering;\n-use std::default::Default;\n-use std::fmt;\n-use std::iter::FromIterator;\n-use std::old_path::BytesContainer;\n-use std::slice;\n-\n-// Note 1: It is not clear whether the flexibility of providing both\n-// the `Growable` and `FixedLen` variants is sufficiently useful.\n-// Consider restricting to just a two variant enum.\n-\n-// Note 2: Once Dynamically Sized Types (DST) lands, it might be\n-// reasonable to replace this with something like `enum MaybeOwned<'a,\n-// U: ?Sized>{ Owned(Box<U>), Borrowed(&'a U) }`; and then `U` could be\n-// instantiated with `[T]` or `str`, etc.  Of course, that would imply\n-// removing the `Growable` variant, which relates to note 1 above.\n-// Alternatively, we might add `MaybeOwned` for the general case but\n-// keep some form of `MaybeOwnedVector` to avoid unnecessary copying\n-// of the contents of `Vec<T>`, since we anticipate that to be a\n-// frequent way to dynamically construct a vector.\n-\n-/// MaybeOwnedVector<'a,T> abstracts over `Vec<T>`, `&'a [T]`.\n-///\n-/// Some clients will have a pre-allocated vector ready to hand off in\n-/// a slice; others will want to create the set on the fly and hand\n-/// off ownership, via `Growable`.\n-pub enum MaybeOwnedVector<'a,T:'a> {\n-    Growable(Vec<T>),\n-    Borrowed(&'a [T]),\n-}\n-\n-/// Trait for moving into a `MaybeOwnedVector`\n-pub trait IntoMaybeOwnedVector<'a,T> {\n-    /// Moves self into a `MaybeOwnedVector`\n-    fn into_maybe_owned(self) -> MaybeOwnedVector<'a,T>;\n-}\n-\n-#[allow(deprecated)]\n-impl<'a,T:'a> IntoMaybeOwnedVector<'a,T> for Vec<T> {\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn into_maybe_owned(self) -> MaybeOwnedVector<'a,T> { Growable(self) }\n-}\n-\n-#[allow(deprecated)]\n-impl<'a,T> IntoMaybeOwnedVector<'a,T> for &'a [T] {\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn into_maybe_owned(self) -> MaybeOwnedVector<'a,T> { Borrowed(self) }\n-}\n-\n-impl<'a,T> MaybeOwnedVector<'a,T> {\n-    pub fn iter(&'a self) -> slice::Iter<'a,T> {\n-        match self {\n-            &Growable(ref v) => v.as_slice().iter(),\n-            &Borrowed(ref v) => v.iter(),\n-        }\n-    }\n-\n-    pub fn len(&self) -> uint { self.as_slice().len() }\n-\n-    #[allow(deprecated)]\n-    pub fn is_empty(&self) -> bool { self.len() == 0 }\n-}\n-\n-impl<'a, T: PartialEq> PartialEq for MaybeOwnedVector<'a, T> {\n-    fn eq(&self, other: &MaybeOwnedVector<T>) -> bool {\n-        self.as_slice() == other.as_slice()\n-    }\n-}\n-\n-impl<'a, T: Eq> Eq for MaybeOwnedVector<'a, T> {}\n-\n-impl<'a, T: PartialOrd> PartialOrd for MaybeOwnedVector<'a, T> {\n-    fn partial_cmp(&self, other: &MaybeOwnedVector<T>) -> Option<Ordering> {\n-        self.as_slice().partial_cmp(other.as_slice())\n-    }\n-}\n-\n-impl<'a, T: Ord> Ord for MaybeOwnedVector<'a, T> {\n-    fn cmp(&self, other: &MaybeOwnedVector<T>) -> Ordering {\n-        self.as_slice().cmp(other.as_slice())\n-    }\n-}\n-\n-// The `Vector` trait is provided in the prelude and is implemented on\n-// both `&'a [T]` and `Vec<T>`, so it makes sense to try to support it\n-// seamlessly.  The other vector related traits from the prelude do\n-// not appear to be implemented on both `&'a [T]` and `Vec<T>`.  (It\n-// is possible that this is an oversight in some cases.)\n-//\n-// In any case, with `Vector` in place, the client can just use\n-// `as_slice` if they prefer that over `match`.\n-\n-impl<'b,T> AsSlice<T> for MaybeOwnedVector<'b,T> {\n-    fn as_slice<'a>(&'a self) -> &'a [T] {\n-        match self {\n-            &Growable(ref v) => v.as_slice(),\n-            &Borrowed(ref v) => v.as_slice(),\n-        }\n-    }\n-}\n-\n-impl<'a,T> FromIterator<T> for MaybeOwnedVector<'a,T> {\n-    #[allow(deprecated)]\n-    fn from_iter<I:Iterator<Item=T>>(iterator: I) -> MaybeOwnedVector<'a,T> {\n-        // If we are building from scratch, might as well build the\n-        // most flexible variant.\n-        Growable(iterator.collect())\n-    }\n-}\n-\n-impl<'a,T:fmt::Debug> fmt::Debug for MaybeOwnedVector<'a,T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.as_slice().fmt(f)\n-    }\n-}\n-\n-impl<'a, T: Clone> Clone for MaybeOwnedVector<'a, T> {\n-    #[allow(deprecated)]\n-    fn clone(&self) -> MaybeOwnedVector<'a, T> {\n-        match *self {\n-            Growable(ref v) => Growable(v.clone()),\n-            Borrowed(v) => Borrowed(v)\n-        }\n-    }\n-}\n-\n-impl<'a, T> Default for MaybeOwnedVector<'a, T> {\n-    #[allow(deprecated)]\n-    fn default() -> MaybeOwnedVector<'a, T> {\n-        Growable(Vec::new())\n-    }\n-}\n-\n-impl<'a> BytesContainer for MaybeOwnedVector<'a, u8> {\n-    fn container_as_bytes(&self) -> &[u8] {\n-        self.as_slice()\n-    }\n-}\n-\n-impl<'a,T:Clone> MaybeOwnedVector<'a,T> {\n-    /// Convert `self` into a growable `Vec`, not making a copy if possible.\n-    pub fn into_vec(self) -> Vec<T> {\n-        match self {\n-            Growable(v) => v,\n-            Borrowed(v) => v.to_vec(),\n-        }\n-    }\n-}"}, {"sha": "b643b04035f2ac20e402f9dedc2ef8fccce7f021", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -332,15 +332,12 @@ pub mod types {\n             /// variants, because the compiler complains about the repr attribute\n             /// otherwise.\n             #[repr(u8)]\n-            #[allow(missing_copy_implementations)]\n             pub enum c_void {\n                 __variant1,\n                 __variant2,\n             }\n \n-            #[allow(missing_copy_implementations)]\n             pub enum FILE {}\n-            #[allow(missing_copy_implementations)]\n             pub enum fpos_t {}\n         }\n         pub mod c99 {\n@@ -354,9 +351,7 @@ pub mod types {\n             pub type uint64_t = u64;\n         }\n         pub mod posix88 {\n-            #[allow(missing_copy_implementations)]\n             pub enum DIR {}\n-            #[allow(missing_copy_implementations)]\n             pub enum dirent_t {}\n         }\n         pub mod posix01 {}"}, {"sha": "0a64da6f137bd2b56a22289a7f667aa43b48f005", "filename": "src/librand/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -387,7 +387,6 @@ pub trait SeedableRng<Seed>: Rng {\n /// [1]: Marsaglia, George (July 2003). [\"Xorshift\n /// RNGs\"](http://www.jstatsoft.org/v08/i14/paper). *Journal of\n /// Statistical Software*. Vol. 8 (Issue 14).\n-#[allow(missing_copy_implementations)]\n #[derive(Clone)]\n pub struct XorShiftRng {\n     x: u32,"}, {"sha": "a808b417b4c6b29768ac9b894bf39cee5871725f", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -14,9 +14,9 @@ register_long_diagnostics! {\n     E0001: r##\"\n     This error suggests that the expression arm corresponding to the noted pattern\n     will never be reached as for all possible values of the expression being matched,\n-    one of the preceeding patterns will match.\n+    one of the preceding patterns will match.\n \n-    This means that perhaps some of the preceeding patterns are too general, this\n+    This means that perhaps some of the preceding patterns are too general, this\n     one is too specific or the ordering is incorrect.\n \"##,\n "}, {"sha": "e0566a1aabedaf7eb103cb51c5805245759ae5dc", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -2018,6 +2018,12 @@ declare_lint! {\n     \"unused or unknown features found in crate-level #[feature] directives\"\n }\n \n+declare_lint! {\n+    pub STABLE_FEATURES,\n+    Warn,\n+    \"stable features found in #[feature] directive\"\n+}\n+\n declare_lint! {\n     pub UNKNOWN_CRATE_TYPES,\n     Deny,\n@@ -2038,7 +2044,7 @@ declare_lint! {\n \n declare_lint! {\n     pub MISSING_COPY_IMPLEMENTATIONS,\n-    Warn,\n+    Allow,\n     \"detects potentially-forgotten implementations of `Copy`\"\n }\n \n@@ -2060,6 +2066,7 @@ impl LintPass for HardwiredLints {\n             UNREACHABLE_CODE,\n             WARNINGS,\n             UNUSED_FEATURES,\n+            STABLE_FEATURES,\n             UNKNOWN_CRATE_TYPES,\n             VARIANT_SIZE_DIFFERENCES,\n             FAT_PTR_TRANSMUTES"}, {"sha": "1a7308a4f1885e9165ec7589822c02bc93a0976f", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -224,7 +224,6 @@ pub struct RegionVarBindings<'a, 'tcx: 'a> {\n }\n \n #[derive(Debug)]\n-#[allow(missing_copy_implementations)]\n pub struct RegionSnapshot {\n     length: uint,\n     skolemization_count: u32,"}, {"sha": "a0681e7e20c8a1207da0c896998b4c053fd6e6aa", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 38, "deletions": 15, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -201,16 +201,17 @@ impl Index {\n /// Cross-references the feature names of unstable APIs with enabled\n /// features and possibly prints errors. Returns a list of all\n /// features used.\n-pub fn check_unstable_api_usage(tcx: &ty::ctxt) -> FnvHashSet<InternedString> {\n-    let ref active_lib_features = tcx.sess.features.borrow().lib_features;\n+pub fn check_unstable_api_usage(tcx: &ty::ctxt)\n+                                -> FnvHashMap<InternedString, attr::StabilityLevel> {\n+    let ref active_lib_features = tcx.sess.features.borrow().declared_lib_features;\n \n     // Put the active features into a map for quick lookup\n     let active_features = active_lib_features.iter().map(|&(ref s, _)| s.clone()).collect();\n \n     let mut checker = Checker {\n         tcx: tcx,\n         active_features: active_features,\n-        used_features: FnvHashSet()\n+        used_features: FnvHashMap()\n     };\n \n     let krate = tcx.map.krate();\n@@ -223,7 +224,7 @@ pub fn check_unstable_api_usage(tcx: &ty::ctxt) -> FnvHashSet<InternedString> {\n struct Checker<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n     active_features: FnvHashSet<InternedString>,\n-    used_features: FnvHashSet<InternedString>\n+    used_features: FnvHashMap<InternedString, attr::StabilityLevel>\n }\n \n impl<'a, 'tcx> Checker<'a, 'tcx> {\n@@ -234,7 +235,7 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n \n         match *stab {\n             Some(Stability { level: attr::Unstable, ref feature, ref reason, .. }) => {\n-                self.used_features.insert(feature.clone());\n+                self.used_features.insert(feature.clone(), attr::Unstable);\n \n                 if !self.active_features.contains(feature) {\n                     let msg = match *reason {\n@@ -247,7 +248,9 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                                       feature.get(), span, &msg[]);\n                 }\n             }\n-            Some(..) => {\n+            Some(Stability { level, ref feature, .. }) => {\n+                self.used_features.insert(feature.clone(), level);\n+\n                 // Stable APIs are always ok to call and deprecated APIs are\n                 // handled by a lint.\n             }\n@@ -433,17 +436,37 @@ pub fn lookup(tcx: &ty::ctxt, id: DefId) -> Option<Stability> {\n /// Given the list of enabled features that were not language features (i.e. that\n /// were expected to be library features), and the list of features used from\n /// libraries, identify activated features that don't exist and error about them.\n-pub fn check_unused_features(sess: &Session,\n-                             used_lib_features: &FnvHashSet<InternedString>) {\n-    let ref lib_features = sess.features.borrow().lib_features;\n-    let mut active_lib_features: FnvHashMap<InternedString, Span>\n-        = lib_features.clone().into_iter().collect();\n-\n-    for used_feature in used_lib_features {\n-        active_lib_features.remove(used_feature);\n+pub fn check_unused_or_stable_features(sess: &Session,\n+                                       lib_features_used: &FnvHashMap<InternedString,\n+                                                                      attr::StabilityLevel>) {\n+    let ref declared_lib_features = sess.features.borrow().declared_lib_features;\n+    let mut remaining_lib_features: FnvHashMap<InternedString, Span>\n+        = declared_lib_features.clone().into_iter().collect();\n+\n+    let stable_msg = \"this feature is stable. attribute no longer needed\";\n+\n+    for &span in sess.features.borrow().declared_stable_lang_features.iter() {\n+        sess.add_lint(lint::builtin::STABLE_FEATURES,\n+                      ast::CRATE_NODE_ID,\n+                      span,\n+                      stable_msg.to_string());\n+    }\n+\n+    for (used_lib_feature, level) in lib_features_used.iter() {\n+        match remaining_lib_features.remove(used_lib_feature) {\n+            Some(span) => {\n+                if *level == attr::Stable {\n+                    sess.add_lint(lint::builtin::STABLE_FEATURES,\n+                                  ast::CRATE_NODE_ID,\n+                                  span,\n+                                  stable_msg.to_string());\n+                }\n+            }\n+            None => ( /* used but undeclared, handled during the previous ast visit */ )\n+        }\n     }\n \n-    for (_, &span) in &active_lib_features {\n+    for (_, &span) in remaining_lib_features.iter() {\n         sess.add_lint(lint::builtin::UNUSED_FEATURES,\n                       ast::CRATE_NODE_ID,\n                       span,"}, {"sha": "3a7522cafee90f283354aa24e520dd40c52211ca", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -59,7 +59,6 @@ pub fn impl_can_satisfy(infcx: &InferCtxt,\n             |o| selcx.evaluate_obligation(o))\n }\n \n-#[allow(missing_copy_implementations)]\n pub enum OrphanCheckErr<'tcx> {\n     NoLocalInputType,\n     UncoveredTy(Ty<'tcx>),"}, {"sha": "f00781fd65c89d62a135ba519b3848028d5cbd59", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 2, "deletions": 21, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -775,7 +775,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                      -> bool\n     {\n         // In general, it's a good idea to cache results, even\n-        // ambigious ones, to save us some trouble later. But we have\n+        // ambiguous ones, to save us some trouble later. But we have\n         // to be careful not to cache results that could be\n         // invalidated later by advances in inference. Normally, this\n         // is not an issue, because any inference variables whose\n@@ -1273,7 +1273,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     ///\n     /// - The impl is conditional, in which case we may not have winnowed it out\n     ///   because we don't know if the conditions apply, but the where clause is basically\n-    ///   telling us taht there is some impl, though not necessarily the one we see.\n+    ///   telling us that there is some impl, though not necessarily the one we see.\n     ///\n     /// In both cases we prefer to take the where clause, which is\n     /// essentially harmless.  See issue #18453 for more details of\n@@ -1335,25 +1335,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 // the where clauses are in scope.\n                 true\n             }\n-            (&ParamCandidate(ref bound1), &ParamCandidate(ref bound2)) => {\n-                self.infcx.probe(|_| {\n-                    let bound1 =\n-                        project::normalize_with_depth(self,\n-                                                      stack.obligation.cause.clone(),\n-                                                      stack.obligation.recursion_depth+1,\n-                                                      bound1);\n-                    let bound2 =\n-                        project::normalize_with_depth(self,\n-                                                      stack.obligation.cause.clone(),\n-                                                      stack.obligation.recursion_depth+1,\n-                                                      bound2);\n-                    let origin =\n-                        infer::RelateOutputImplTypes(stack.obligation.cause.span);\n-                    self.infcx\n-                        .sub_poly_trait_refs(false, origin, bound1.value, bound2.value)\n-                        .is_ok()\n-                })\n-            }\n             _ => {\n                 false\n             }"}, {"sha": "573efa727569ec915629143df38a9524917c98b7", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 47, "deletions": 9, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -11,17 +11,58 @@\n use middle::subst::{Substs, VecPerParamSpace};\n use middle::infer::InferCtxt;\n use middle::ty::{self, Ty, AsPredicate, ToPolyTraitRef};\n-use std::collections::HashSet;\n use std::fmt;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap::Span;\n use util::common::ErrorReported;\n+use util::nodemap::FnvHashSet;\n use util::ppaux::Repr;\n \n use super::{Obligation, ObligationCause, PredicateObligation,\n             VtableImpl, VtableParam, VtableImplData};\n \n+struct PredicateSet<'a,'tcx:'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n+    set: FnvHashSet<ty::Predicate<'tcx>>,\n+}\n+\n+impl<'a,'tcx> PredicateSet<'a,'tcx> {\n+    fn new(tcx: &'a ty::ctxt<'tcx>) -> PredicateSet<'a,'tcx> {\n+        PredicateSet { tcx: tcx, set: FnvHashSet() }\n+    }\n+\n+    fn insert(&mut self, pred: &ty::Predicate<'tcx>) -> bool {\n+        // We have to be careful here because we want\n+        //\n+        //    for<'a> Foo<&'a int>\n+        //\n+        // and\n+        //\n+        //    for<'b> Foo<&'b int>\n+        //\n+        // to be considered equivalent. So normalize all late-bound\n+        // regions before we throw things into the underlying set.\n+        let normalized_pred = match *pred {\n+            ty::Predicate::Trait(ref data) =>\n+                ty::Predicate::Trait(ty::anonymize_late_bound_regions(self.tcx, data)),\n+\n+            ty::Predicate::Equate(ref data) =>\n+                ty::Predicate::Equate(ty::anonymize_late_bound_regions(self.tcx, data)),\n+\n+            ty::Predicate::RegionOutlives(ref data) =>\n+                ty::Predicate::RegionOutlives(ty::anonymize_late_bound_regions(self.tcx, data)),\n+\n+            ty::Predicate::TypeOutlives(ref data) =>\n+                ty::Predicate::TypeOutlives(ty::anonymize_late_bound_regions(self.tcx, data)),\n+\n+            ty::Predicate::Projection(ref data) =>\n+                ty::Predicate::Projection(ty::anonymize_late_bound_regions(self.tcx, data)),\n+        };\n+        self.set.insert(normalized_pred)\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // `Elaboration` iterator\n ///////////////////////////////////////////////////////////////////////////\n@@ -36,7 +77,7 @@ use super::{Obligation, ObligationCause, PredicateObligation,\n pub struct Elaborator<'cx, 'tcx:'cx> {\n     tcx: &'cx ty::ctxt<'tcx>,\n     stack: Vec<StackEntry<'tcx>>,\n-    visited: HashSet<ty::Predicate<'tcx>>,\n+    visited: PredicateSet<'cx,'tcx>,\n }\n \n struct StackEntry<'tcx> {\n@@ -65,14 +106,11 @@ pub fn elaborate_trait_refs<'cx, 'tcx>(\n \n pub fn elaborate_predicates<'cx, 'tcx>(\n     tcx: &'cx ty::ctxt<'tcx>,\n-    predicates: Vec<ty::Predicate<'tcx>>)\n+    mut predicates: Vec<ty::Predicate<'tcx>>)\n     -> Elaborator<'cx, 'tcx>\n {\n-    let visited: HashSet<ty::Predicate<'tcx>> =\n-        predicates.iter()\n-                  .map(|b| (*b).clone())\n-                  .collect();\n-\n+    let mut visited = PredicateSet::new(tcx);\n+    predicates.retain(|pred| visited.insert(pred));\n     let entry = StackEntry { position: 0, predicates: predicates };\n     Elaborator { tcx: tcx, stack: vec![entry], visited: visited }\n }\n@@ -94,7 +132,7 @@ impl<'cx, 'tcx> Elaborator<'cx, 'tcx> {\n                 // recursion in some cases.  One common case is when\n                 // people define `trait Sized: Sized { }` rather than `trait\n                 // Sized { }`.\n-                predicates.retain(|r| self.visited.insert(r.clone()));\n+                predicates.retain(|r| self.visited.insert(r));\n \n                 self.stack.push(StackEntry { position: 0,\n                                              predicates: predicates });"}, {"sha": "b78334613486efb879769a93d2d019e9030d24bd", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -1591,10 +1591,10 @@ pub fn region_existential_bound<'tcx>(r: ty::Region) -> ExistentialBounds<'tcx>\n }\n \n impl CLike for BuiltinBound {\n-    fn to_uint(&self) -> uint {\n+    fn to_usize(&self) -> uint {\n         *self as uint\n     }\n-    fn from_uint(v: uint) -> BuiltinBound {\n+    fn from_usize(v: uint) -> BuiltinBound {\n         unsafe { mem::transmute(v) }\n     }\n }\n@@ -2520,7 +2520,7 @@ impl FlagComputation {\n     fn add_bound_computation(&mut self, computation: &FlagComputation) {\n         self.add_flags(computation.flags);\n \n-        // The types that contributed to `computation` occured within\n+        // The types that contributed to `computation` occurred within\n         // a region binder, so subtract one from the region depth\n         // within when adding the depth to `self`.\n         let depth = computation.depth;"}, {"sha": "efd2392e453ed65a8018bc59095a92485b441d8f", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -132,7 +132,6 @@ pub enum UnstableFeatures {\n }\n \n #[derive(Clone, PartialEq, Eq)]\n-#[allow(missing_copy_implementations)]\n pub enum PrintRequest {\n     FileNames,\n     Sysroot,\n@@ -290,7 +289,6 @@ macro_rules! options {\n      $($opt:ident : $t:ty = ($init:expr, $parse:ident, $desc:expr)),* ,) =>\n (\n     #[derive(Clone)]\n-    #[allow(missing_copy_implementations)]\n     pub struct $struct_name { $(pub $opt: $t),* }\n \n     pub fn $defaultfn() -> $struct_name {"}, {"sha": "f8e3defe19d632ac9c6b40ec63edc804f384ed1f", "filename": "src/librustc/util/nodemap.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc%2Futil%2Fnodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc%2Futil%2Fnodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fnodemap.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -46,7 +46,6 @@ pub fn DefIdSet() -> DefIdSet { FnvHashSet() }\n ///\n /// This uses FNV hashing, as described here:\n /// http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function\n-#[allow(missing_copy_implementations)]\n pub struct FnvHasher(u64);\n \n impl Default for FnvHasher {"}, {"sha": "8fbc682246f470078c18e5f6025ccbfc2e61b4d7", "filename": "src/librustc/util/snapshot_vec.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -46,7 +46,6 @@ pub struct SnapshotVec<D:SnapshotVecDelegate> {\n }\n \n // Snapshots are tokens that should be created/consumed linearly.\n-#[allow(missing_copy_implementations)]\n pub struct Snapshot {\n     // Length of the undo log at the time the snapshot was taken.\n     length: uint,"}, {"sha": "682a5f2f5ace6d28232772f48d0bca01baac3f2a", "filename": "src/librustc_borrowck/borrowck/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc_borrowck%2Fborrowck%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc_borrowck%2Fborrowck%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fdoc.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -142,7 +142,7 @@\n //! which contains an empty set of actions, still has a purpose---it\n //! prevents moves from `LV`. I chose not to make `MOVE` a fourth kind of\n //! action because that would imply that sometimes moves are permitted\n-//! from restrictived values, which is not the case.\n+//! from restricted values, which is not the case.\n //!\n //! #### Example\n //!"}, {"sha": "cdfb1f5030e2dceefd46a5d119dc1f4629f07b38", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -464,7 +464,6 @@ pub fn opt_loan_path<'tcx>(cmt: &mc::cmt<'tcx>) -> Option<Rc<LoanPath<'tcx>>> {\n \n // Errors that can occur\n #[derive(PartialEq)]\n-#[allow(missing_copy_implementations)]\n pub enum bckerr_code {\n     err_mutbl,\n     err_out_of_scope(ty::Region, ty::Region), // superscope, subscope"}, {"sha": "eca20ef55fa069d10afdd67d476d3047bb2895aa", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -171,7 +171,7 @@ pub fn source_name(input: &Input) -> String {\n /// CompileController is used to customise compilation, it allows compilation to\n /// be stopped and/or to call arbitrary code at various points in compilation.\n /// It also allows for various flags to be set to influence what information gets\n-/// colelcted during compilation.\n+/// collected during compilation.\n ///\n /// This is a somewhat higher level controller than a Session - the Session\n /// controls what happens in each phase, whereas the CompileController controls\n@@ -668,8 +668,8 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n         time(time_passes, \"stability checking\", (), |_|\n              stability::check_unstable_api_usage(&ty_cx));\n \n-    time(time_passes, \"unused feature checking\", (), |_|\n-         stability::check_unused_features(\n+    time(time_passes, \"unused lib feature checking\", (), |_|\n+         stability::check_unused_or_stable_features(\n              &ty_cx.sess, lib_features_used));\n \n     time(time_passes, \"lint checking\", (), |_|"}, {"sha": "878070e98e7e8b7072a189681027f92b20f2aa94", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -436,73 +436,50 @@ pub enum DiagnosticKind {\n }\n \n // Opaque pointer types\n-#[allow(missing_copy_implementations)]\n pub enum Module_opaque {}\n pub type ModuleRef = *mut Module_opaque;\n-#[allow(missing_copy_implementations)]\n pub enum Context_opaque {}\n pub type ContextRef = *mut Context_opaque;\n-#[allow(missing_copy_implementations)]\n pub enum Type_opaque {}\n pub type TypeRef = *mut Type_opaque;\n-#[allow(missing_copy_implementations)]\n pub enum Value_opaque {}\n pub type ValueRef = *mut Value_opaque;\n-#[allow(missing_copy_implementations)]\n pub enum Metadata_opaque {}\n pub type MetadataRef = *mut Metadata_opaque;\n-#[allow(missing_copy_implementations)]\n pub enum BasicBlock_opaque {}\n pub type BasicBlockRef = *mut BasicBlock_opaque;\n-#[allow(missing_copy_implementations)]\n pub enum Builder_opaque {}\n pub type BuilderRef = *mut Builder_opaque;\n-#[allow(missing_copy_implementations)]\n pub enum ExecutionEngine_opaque {}\n pub type ExecutionEngineRef = *mut ExecutionEngine_opaque;\n-#[allow(missing_copy_implementations)]\n pub enum RustJITMemoryManager_opaque {}\n pub type RustJITMemoryManagerRef = *mut RustJITMemoryManager_opaque;\n-#[allow(missing_copy_implementations)]\n pub enum MemoryBuffer_opaque {}\n pub type MemoryBufferRef = *mut MemoryBuffer_opaque;\n-#[allow(missing_copy_implementations)]\n pub enum PassManager_opaque {}\n pub type PassManagerRef = *mut PassManager_opaque;\n-#[allow(missing_copy_implementations)]\n pub enum PassManagerBuilder_opaque {}\n pub type PassManagerBuilderRef = *mut PassManagerBuilder_opaque;\n-#[allow(missing_copy_implementations)]\n pub enum Use_opaque {}\n pub type UseRef = *mut Use_opaque;\n-#[allow(missing_copy_implementations)]\n pub enum TargetData_opaque {}\n pub type TargetDataRef = *mut TargetData_opaque;\n-#[allow(missing_copy_implementations)]\n pub enum ObjectFile_opaque {}\n pub type ObjectFileRef = *mut ObjectFile_opaque;\n-#[allow(missing_copy_implementations)]\n pub enum SectionIterator_opaque {}\n pub type SectionIteratorRef = *mut SectionIterator_opaque;\n-#[allow(missing_copy_implementations)]\n pub enum Pass_opaque {}\n pub type PassRef = *mut Pass_opaque;\n-#[allow(missing_copy_implementations)]\n pub enum TargetMachine_opaque {}\n pub type TargetMachineRef = *mut TargetMachine_opaque;\n-#[allow(missing_copy_implementations)]\n pub enum Archive_opaque {}\n pub type ArchiveRef = *mut Archive_opaque;\n-#[allow(missing_copy_implementations)]\n pub enum Twine_opaque {}\n pub type TwineRef = *mut Twine_opaque;\n-#[allow(missing_copy_implementations)]\n pub enum DiagnosticInfo_opaque {}\n pub type DiagnosticInfoRef = *mut DiagnosticInfo_opaque;\n-#[allow(missing_copy_implementations)]\n pub enum DebugLoc_opaque {}\n pub type DebugLocRef = *mut DebugLoc_opaque;\n-#[allow(missing_copy_implementations)]\n pub enum SMDiagnostic_opaque {}\n pub type SMDiagnosticRef = *mut SMDiagnostic_opaque;\n \n@@ -513,7 +490,6 @@ pub mod debuginfo {\n     pub use self::DIDescriptorFlags::*;\n     use super::{MetadataRef};\n \n-    #[allow(missing_copy_implementations)]\n     pub enum DIBuilder_opaque {}\n     pub type DIBuilderRef = *mut DIBuilder_opaque;\n \n@@ -2215,7 +2191,6 @@ pub fn get_param(llfn: ValueRef, index: c_uint) -> ValueRef {\n     }\n }\n \n-#[allow(missing_copy_implementations)]\n pub enum RustString_opaque {}\n pub type RustStringRef = *mut RustString_opaque;\n type RustStringRepr = *mut RefCell<Vec<u8>>;"}, {"sha": "7b6ee3a729776161c6b038a5c42f689324eb2d82", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -20,7 +20,7 @@ register_diagnostics! {\n     E0254, // import conflicts with imported crate in this module\n     E0255, // import conflicts with value in this module\n     E0256, // import conflicts with type in this module\n-    E0257, // inherent implementations are only allowen on types defined in the current module\n+    E0257, // inherent implementations are only allowed on types defined in the current module\n     E0258, // import conflicts with existing submodule\n     E0259, // an extern crate has already been imported into this module\n     E0260 // name conflicts with an external crate that has been imported into this module"}, {"sha": "a724cdc0229d2f465af8865f8cd1ae42951dda33", "filename": "src/librustc_trans/save/span_utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -69,8 +69,8 @@ impl<'a> SpanUtils<'a> {\n \n     pub fn snippet(&self, span: Span) -> String {\n         match self.sess.codemap().span_to_snippet(span) {\n-            Some(s) => s,\n-            None => String::new(),\n+            Ok(s) => s,\n+            Err(_) => String::new(),\n         }\n     }\n "}, {"sha": "1d7358b11c10ac72ea0a041160b6989f5814a46e", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -889,11 +889,13 @@ fn compile_guard<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n     }\n \n+    for (_, &binding_info) in &data.bindings_map {\n+        bcx.fcx.lllocals.borrow_mut().remove(&binding_info.id);\n+    }\n+\n     with_cond(bcx, Not(bcx, val, guard_expr.debug_loc()), |bcx| {\n-        // Guard does not match: remove all bindings from the lllocals table\n         for (_, &binding_info) in &data.bindings_map {\n             call_lifetime_end(bcx, binding_info.llmatch);\n-            bcx.fcx.lllocals.borrow_mut().remove(&binding_info.id);\n         }\n         match chk {\n             // If the default arm is the only one left, move on to the next"}, {"sha": "58c7a979c3d4d1290314fb01b3656552b6fbf0ed", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -1081,6 +1081,12 @@ pub fn with_cond<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n     F: FnOnce(Block<'blk, 'tcx>) -> Block<'blk, 'tcx>,\n {\n     let _icx = push_ctxt(\"with_cond\");\n+\n+    if bcx.unreachable.get() ||\n+            (common::is_const(val) && common::const_to_uint(val) == 0) {\n+        return bcx;\n+    }\n+\n     let fcx = bcx.fcx;\n     let next_cx = fcx.new_temp_block(\"next\");\n     let cond_cx = fcx.new_temp_block(\"cond\");"}, {"sha": "7652dba4bce220f5e527c704a95de886f79ff12b", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -241,8 +241,10 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, e: &ast::Expr)\n                                         ty::ty_vec(unit_ty, Some(len)) => {\n                                             let llunitty = type_of::type_of(cx, unit_ty);\n                                             let llptr = ptrcast(llconst, llunitty.ptr_to());\n-                                            assert!(cx.const_globals().borrow_mut()\n-                                                      .insert(llptr as int, llconst).is_none());\n+                                            let prev_const = cx.const_globals().borrow_mut()\n+                                                             .insert(llptr as int, llconst);\n+                                            assert!(prev_const.is_none() ||\n+                                                    prev_const == Some(llconst));\n                                             assert_eq!(abi::FAT_PTR_ADDR, 0);\n                                             assert_eq!(abi::FAT_PTR_EXTRA, 1);\n                                             llconst = C_struct(cx, &["}, {"sha": "4d4a2bf48548abf260677929750f807e28ec4881", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -1094,7 +1094,7 @@ pub fn get_cleanup_debug_loc_for_ast_node<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         // bodies), in which case we also just want to return the span of the\n         // whole expression.\n         let code_snippet = cx.sess().codemap().span_to_snippet(node_span);\n-        if let Some(code_snippet) = code_snippet {\n+        if let Ok(code_snippet) = code_snippet {\n             let bytes = code_snippet.as_bytes();\n \n             if bytes.len() > 0 && &bytes[bytes.len()-1..] == b\"}\" {"}, {"sha": "c1dd2338903c8b07886812d75823fd6945cd5fc4", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -365,7 +365,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         (_, \"init\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n             if !return_type_is_void(ccx, tp_ty) {\n-                // Just zero out the stack slot. (See comment on base::memzero for explaination)\n+                // Just zero out the stack slot. (See comment on base::memzero for explanation)\n                 zero_mem(bcx, llresult, tp_ty);\n             }\n             C_nil(ccx)"}, {"sha": "464522f167b472b6aa46667095e1b1ba999bc547", "filename": "src/librustc_trans/trans/value.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc_trans%2Ftrans%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc_trans%2Ftrans%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fvalue.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -150,7 +150,6 @@ impl Use {\n }\n \n /// Iterator for the users of a value\n-#[allow(missing_copy_implementations)]\n pub struct Users {\n     next: Option<Use>\n }"}, {"sha": "a5b938c7600c2c5eee6d7042fa9aa030eef5b609", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -159,11 +159,11 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     // vs 'b).  However, the normal subtyping rules on fn types handle\n     // this kind of equivalency just fine.\n     //\n-    // We now use these subsititions to ensure that all declared bounds are\n+    // We now use these substitutions to ensure that all declared bounds are\n     // satisfied by the implementation's method.\n     //\n     // We do this by creating a parameter environment which contains a\n-    // substition corresponding to impl_to_skol_substs. We then build\n+    // substitution corresponding to impl_to_skol_substs. We then build\n     // trait_to_skol_substs and use it to convert the predicates contained\n     // in the trait_m.generics to the skolemized form.\n     //"}, {"sha": "19287f19d8d504415029c333e02df817610634e0", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -288,7 +288,7 @@ pub fn select_all_fcx_obligations_and_apply_defaults(fcx: &FnCtxt) {\n pub fn select_all_fcx_obligations_or_error(fcx: &FnCtxt) {\n     debug!(\"select_all_fcx_obligations_or_error\");\n \n-    // upvar inference should have ensured that all deferrred call\n+    // upvar inference should have ensured that all deferred call\n     // resolutions are handled by now.\n     assert!(fcx.inh.deferred_call_resolutions.borrow().is_empty());\n "}, {"sha": "17cf92d39d8f542d332f7fab010e401280c7f3fd", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -108,7 +108,7 @@ register_diagnostics! {\n     E0189, // can only cast a boxed pointer to a boxed object\n     E0190, // can only cast a &-pointer to an &-object\n     E0191, // value of the associated type must be specified\n-    E0192, // negative imples are allowed just fo `Send` and `Sync`\n+    E0192, // negative imples are allowed just for `Send` and `Sync`\n     E0193, // cannot bound type where clause bounds may only be attached to types\n            // involving type parameters\n     E0194,\n@@ -119,7 +119,7 @@ register_diagnostics! {\n     E0199, // implementing trait is not unsafe\n     E0200, // trait requires an `unsafe impl` declaration\n     E0201, // duplicate method in trait impl\n-    E0202, // associated items are not allowed in inherint impls\n+    E0202, // associated items are not allowed in inherent impls\n     E0203, // type parameter has more than one relaxed default bound,\n            // and only one is supported\n     E0204, // trait `Copy` may not be implemented for this type; field"}, {"sha": "ccf392365cea0ee27ea5eadc44d9e3f161b98af9", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -83,7 +83,6 @@ This API is completely unstable and subject to change.\n #![feature(rustc_private)]\n #![feature(slicing_syntax, unsafe_destructor)]\n #![feature(staged_api)]\n-#![feature(std_misc)]\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;"}, {"sha": "60e969c4f99dd410c23f089fef3f56e9aa07e49a", "filename": "src/librustc_typeck/rscope.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc_typeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc_typeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Frscope.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -79,7 +79,6 @@ impl RegionScope for UnelidableRscope {\n // A scope in which any omitted region defaults to `default`. This is\n // used after the `->` in function signatures, but also for backwards\n // compatibility with object types. The latter use may go away.\n-#[allow(missing_copy_implementations)]\n pub struct SpecificRscope {\n     default: ty::Region\n }"}, {"sha": "567a388836f25e52c382b36616accb5d5ebf5918", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -192,7 +192,7 @@ use self::VarianceTerm::*;\n use self::ParamKind::*;\n \n use arena;\n-use arena::Arena;\n+use arena::TypedArena;\n use middle::resolve_lifetime as rl;\n use middle::subst;\n use middle::subst::{ParamSpace, FnSpace, TypeSpace, SelfSpace, VecPerParamSpace};\n@@ -210,7 +210,7 @@ use util::ppaux::Repr;\n \n pub fn infer_variance(tcx: &ty::ctxt) {\n     let krate = tcx.map.krate();\n-    let mut arena = arena::Arena::new();\n+    let mut arena = arena::TypedArena::new();\n     let terms_cx = determine_parameters_to_be_inferred(tcx, &mut arena, krate);\n     let constraints_cx = add_constraints_from_crate(terms_cx, krate);\n     solve_constraints(constraints_cx);\n@@ -254,7 +254,7 @@ impl<'a> fmt::Debug for VarianceTerm<'a> {\n \n struct TermsContext<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n-    arena: &'a Arena,\n+    arena: &'a TypedArena<VarianceTerm<'a>>,\n \n     empty_variances: Rc<ty::ItemVariances>,\n \n@@ -282,7 +282,7 @@ struct InferredInfo<'a> {\n }\n \n fn determine_parameters_to_be_inferred<'a, 'tcx>(tcx: &'a ty::ctxt<'tcx>,\n-                                                 arena: &'a mut Arena,\n+                                                 arena: &'a mut TypedArena<VarianceTerm<'a>>,\n                                                  krate: &ast::Crate)\n                                                  -> TermsContext<'a, 'tcx> {\n     let mut terms_cx = TermsContext {\n@@ -312,7 +312,7 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n                     index: uint,\n                     param_id: ast::NodeId) {\n         let inf_index = InferredIndex(self.inferred_infos.len());\n-        let term = self.arena.alloc(|| InferredTerm(inf_index));\n+        let term = self.arena.alloc(InferredTerm(inf_index));\n         self.inferred_infos.push(InferredInfo { item_id: item_id,\n                                                 kind: kind,\n                                                 space: space,\n@@ -455,10 +455,10 @@ fn add_constraints_from_crate<'a, 'tcx>(terms_cx: TermsContext<'a, 'tcx>,\n \n     let unsafe_lang_item = terms_cx.tcx.lang_items.unsafe_type();\n \n-    let covariant = terms_cx.arena.alloc(|| ConstantTerm(ty::Covariant));\n-    let contravariant = terms_cx.arena.alloc(|| ConstantTerm(ty::Contravariant));\n-    let invariant = terms_cx.arena.alloc(|| ConstantTerm(ty::Invariant));\n-    let bivariant = terms_cx.arena.alloc(|| ConstantTerm(ty::Bivariant));\n+    let covariant = terms_cx.arena.alloc(ConstantTerm(ty::Covariant));\n+    let contravariant = terms_cx.arena.alloc(ConstantTerm(ty::Contravariant));\n+    let invariant = terms_cx.arena.alloc(ConstantTerm(ty::Invariant));\n+    let bivariant = terms_cx.arena.alloc(ConstantTerm(ty::Bivariant));\n     let mut constraint_cx = ConstraintContext {\n         terms_cx: terms_cx,\n \n@@ -719,7 +719,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             }\n \n             _ => {\n-                &*self.terms_cx.arena.alloc(|| TransformTerm(v1, v2))\n+                &*self.terms_cx.arena.alloc(TransformTerm(v1, v2))\n             }\n         }\n     }"}, {"sha": "611251d4cfae114d895992a24def11931a680168", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -2301,8 +2301,8 @@ impl ToSource for syntax::codemap::Span {\n     fn to_src(&self, cx: &DocContext) -> String {\n         debug!(\"converting span {:?} to snippet\", self.clean(cx));\n         let sn = match cx.sess().codemap().span_to_snippet(*self) {\n-            Some(x) => x.to_string(),\n-            None    => \"\".to_string()\n+            Ok(x) => x.to_string(),\n+            Err(_) => \"\".to_string()\n         };\n         debug!(\"got snippet {}\", sn);\n         sn"}, {"sha": "53d3b069467d348e6ecc76c9509641758c944d52", "filename": "src/libserialize/collection_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibserialize%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibserialize%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fcollection_impls.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -136,7 +136,7 @@ impl<\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         let mut bits = 0;\n         for item in self {\n-            bits |= item.to_uint();\n+            bits |= item.to_usize();\n         }\n         s.emit_uint(bits)\n     }\n@@ -150,7 +150,7 @@ impl<\n         let mut set = EnumSet::new();\n         for bit in 0..uint::BITS {\n             if bits & (1 << bit) != 0 {\n-                set.insert(CLike::from_uint(1 << bit));\n+                set.insert(CLike::from_usize(1 << bit));\n             }\n         }\n         Ok(set)"}, {"sha": "ca506e8c36f50a7111063c15c152eacd226f25e1", "filename": "src/libstd/collections/hash/bench.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibstd%2Fcollections%2Fhash%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibstd%2Fcollections%2Fhash%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fbench.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -21,7 +21,7 @@ fn new_drop(b : &mut Bencher) {\n     use super::map::HashMap;\n \n     b.iter(|| {\n-        let m : HashMap<int, int> = HashMap::new();\n+        let m : HashMap<i32, i32> = HashMap::new();\n         assert_eq!(m.len(), 0);\n     })\n }"}, {"sha": "aec9446773f2ac5e5e46f2d9371cce50b0089beb", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 80, "deletions": 82, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -45,9 +45,9 @@ use super::table::BucketState::{\n };\n use super::state::HashState;\n \n-const INITIAL_LOG2_CAP: uint = 5;\n+const INITIAL_LOG2_CAP: usize = 5;\n #[unstable(feature = \"std_misc\")]\n-pub const INITIAL_CAPACITY: uint = 1 << INITIAL_LOG2_CAP; // 2^5\n+pub const INITIAL_CAPACITY: usize = 1 << INITIAL_LOG2_CAP; // 2^5\n \n /// The default behavior of HashMap implements a load factor of 90.9%.\n /// This behavior is characterized by the following condition:\n@@ -62,7 +62,7 @@ impl DefaultResizePolicy {\n     }\n \n     #[inline]\n-    fn min_capacity(&self, usable_size: uint) -> uint {\n+    fn min_capacity(&self, usable_size: usize) -> usize {\n         // Here, we are rephrasing the logic by specifying the lower limit\n         // on capacity:\n         //\n@@ -72,7 +72,7 @@ impl DefaultResizePolicy {\n \n     /// An inverse of `min_capacity`, approximately.\n     #[inline]\n-    fn usable_capacity(&self, cap: uint) -> uint {\n+    fn usable_capacity(&self, cap: usize) -> usize {\n         // As the number of entries approaches usable capacity,\n         // min_capacity(size) must be smaller than the internal capacity,\n         // so that the map is not resized:\n@@ -90,7 +90,7 @@ impl DefaultResizePolicy {\n fn test_resize_policy() {\n     use prelude::v1::*;\n     let rp = DefaultResizePolicy;\n-    for n in 0u..1000 {\n+    for n in 0..1000 {\n         assert!(rp.min_capacity(rp.usable_capacity(n)) <= n);\n         assert!(rp.usable_capacity(rp.min_capacity(n)) <= n);\n     }\n@@ -287,9 +287,9 @@ fn test_resize_policy() {\n /// // Use a HashMap to store the vikings' health points.\n /// let mut vikings = HashMap::new();\n ///\n-/// vikings.insert(Viking::new(\"Einar\", \"Norway\"), 25u);\n-/// vikings.insert(Viking::new(\"Olaf\", \"Denmark\"), 24u);\n-/// vikings.insert(Viking::new(\"Harald\", \"Iceland\"), 12u);\n+/// vikings.insert(Viking::new(\"Einar\", \"Norway\"), 25);\n+/// vikings.insert(Viking::new(\"Olaf\", \"Denmark\"), 24);\n+/// vikings.insert(Viking::new(\"Harald\", \"Iceland\"), 12);\n ///\n /// // Use derived implementation to print the status of the vikings.\n /// for (viking, health) in vikings.iter() {\n@@ -369,7 +369,7 @@ fn pop_internal<K, V>(starting_bucket: FullBucketMut<K, V>) -> (K, V) {\n ///\n /// `hash`, `k`, and `v` are the elements to \"robin hood\" into the hashtable.\n fn robin_hood<'a, K: 'a, V: 'a>(mut bucket: FullBucketMut<'a, K, V>,\n-                        mut ib: uint,\n+                        mut ib: usize,\n                         mut hash: SafeHash,\n                         mut k: K,\n                         mut v: V)\n@@ -515,7 +515,7 @@ impl<K: Hash<Hasher> + Eq, V> HashMap<K, V, RandomState> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn with_capacity(capacity: uint) -> HashMap<K, V, RandomState> {\n+    pub fn with_capacity(capacity: usize) -> HashMap<K, V, RandomState> {\n         HashMap::with_capacity_and_hash_state(capacity, Default::default())\n     }\n }\n@@ -537,7 +537,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     ///\n     /// let s = RandomState::new();\n     /// let mut map = HashMap::with_hash_state(s);\n-    /// map.insert(1, 2u);\n+    /// map.insert(1, 2);\n     /// ```\n     #[inline]\n     #[unstable(feature = \"std_misc\", reason = \"hasher stuff is unclear\")]\n@@ -565,11 +565,11 @@ impl<K, V, S, H> HashMap<K, V, S>\n     ///\n     /// let s = RandomState::new();\n     /// let mut map = HashMap::with_capacity_and_hash_state(10, s);\n-    /// map.insert(1, 2u);\n+    /// map.insert(1, 2);\n     /// ```\n     #[inline]\n     #[unstable(feature = \"std_misc\", reason = \"hasher stuff is unclear\")]\n-    pub fn with_capacity_and_hash_state(capacity: uint, hash_state: S)\n+    pub fn with_capacity_and_hash_state(capacity: usize, hash_state: S)\n                                         -> HashMap<K, V, S> {\n         let resize_policy = DefaultResizePolicy::new();\n         let min_cap = max(INITIAL_CAPACITY, resize_policy.min_capacity(capacity));\n@@ -593,7 +593,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn capacity(&self) -> uint {\n+    pub fn capacity(&self) -> usize {\n         self.resize_policy.usable_capacity(self.table.capacity())\n     }\n \n@@ -603,7 +603,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the new allocation size overflows `uint`.\n+    /// Panics if the new allocation size overflows `usize`.\n     ///\n     /// # Example\n     ///\n@@ -613,7 +613,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// map.reserve(10);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn reserve(&mut self, additional: uint) {\n+    pub fn reserve(&mut self, additional: usize) {\n         let new_size = self.len().checked_add(additional).expect(\"capacity overflow\");\n         let min_cap = self.resize_policy.min_capacity(new_size);\n \n@@ -631,7 +631,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     ///   1) Make sure the new capacity is enough for all the elements, accounting\n     ///      for the load factor.\n     ///   2) Ensure new_capacity is a power of two or zero.\n-    fn resize(&mut self, new_capacity: uint) {\n+    fn resize(&mut self, new_capacity: usize) {\n         assert!(self.table.size() <= new_capacity);\n         assert!(new_capacity.is_power_of_two() || new_capacity == 0);\n \n@@ -793,7 +793,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n \n             if (ib as int) < robin_ib {\n                 // Found a luckier bucket than me. Better steal his spot.\n-                return robin_hood(bucket, robin_ib as uint, hash, k, v);\n+                return robin_hood(bucket, robin_ib as usize, hash, k, v);\n             }\n \n             probe = bucket.next();\n@@ -929,10 +929,8 @@ impl<K, V, S, H> HashMap<K, V, S>\n     }\n \n     /// Gets the given key's corresponding entry in the map for in-place manipulation.\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"precise API still being fleshed out\")]\n-    pub fn entry<'a>(&'a mut self, key: K) -> Entry<'a, K, V>\n-    {\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn entry(&mut self, key: K) -> Entry<K, V> {\n         // Gotta resize now.\n         self.reserve(1);\n \n@@ -949,11 +947,11 @@ impl<K, V, S, H> HashMap<K, V, S>\n     ///\n     /// let mut a = HashMap::new();\n     /// assert_eq!(a.len(), 0);\n-    /// a.insert(1u, \"a\");\n+    /// a.insert(1, \"a\");\n     /// assert_eq!(a.len(), 1);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> uint { self.table.size() }\n+    pub fn len(&self) -> usize { self.table.size() }\n \n     /// Returns true if the map contains no elements.\n     ///\n@@ -964,7 +962,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     ///\n     /// let mut a = HashMap::new();\n     /// assert!(a.is_empty());\n-    /// a.insert(1u, \"a\");\n+    /// a.insert(1, \"a\");\n     /// assert!(!a.is_empty());\n     /// ```\n     #[inline]\n@@ -980,8 +978,8 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// use std::collections::HashMap;\n     ///\n     /// let mut a = HashMap::new();\n-    /// a.insert(1u, \"a\");\n-    /// a.insert(2u, \"b\");\n+    /// a.insert(1, \"a\");\n+    /// a.insert(2, \"b\");\n     ///\n     /// for (k, v) in a.drain().take(1) {\n     ///     assert!(k == 1 || k == 2);\n@@ -1011,7 +1009,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// use std::collections::HashMap;\n     ///\n     /// let mut a = HashMap::new();\n-    /// a.insert(1u, \"a\");\n+    /// a.insert(1, \"a\");\n     /// a.clear();\n     /// assert!(a.is_empty());\n     /// ```\n@@ -1033,7 +1031,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// use std::collections::HashMap;\n     ///\n     /// let mut map = HashMap::new();\n-    /// map.insert(1u, \"a\");\n+    /// map.insert(1, \"a\");\n     /// assert_eq!(map.get(&1), Some(&\"a\"));\n     /// assert_eq!(map.get(&2), None);\n     /// ```\n@@ -1056,7 +1054,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// use std::collections::HashMap;\n     ///\n     /// let mut map = HashMap::new();\n-    /// map.insert(1u, \"a\");\n+    /// map.insert(1, \"a\");\n     /// assert_eq!(map.contains_key(&1), true);\n     /// assert_eq!(map.contains_key(&2), false);\n     /// ```\n@@ -1079,7 +1077,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// use std::collections::HashMap;\n     ///\n     /// let mut map = HashMap::new();\n-    /// map.insert(1u, \"a\");\n+    /// map.insert(1, \"a\");\n     /// match map.get_mut(&1) {\n     ///     Some(x) => *x = \"b\",\n     ///     None => (),\n@@ -1102,7 +1100,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// use std::collections::HashMap;\n     ///\n     /// let mut map = HashMap::new();\n-    /// assert_eq!(map.insert(37u, \"a\"), None);\n+    /// assert_eq!(map.insert(37, \"a\"), None);\n     /// assert_eq!(map.is_empty(), false);\n     ///\n     /// map.insert(37, \"b\");\n@@ -1134,7 +1132,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// use std::collections::HashMap;\n     ///\n     /// let mut map = HashMap::new();\n-    /// map.insert(1u, \"a\");\n+    /// map.insert(1, \"a\");\n     /// assert_eq!(map.remove(&1), Some(\"a\"));\n     /// assert_eq!(map.remove(&1), None);\n     /// ```\n@@ -1188,7 +1186,7 @@ fn search_entry_hashed<'a, K: Eq, V>(table: &'a mut RawTable<K,V>, hash: SafeHas\n             return Vacant(VacantEntry {\n                 hash: hash,\n                 key: k,\n-                elem: NeqElem(bucket, robin_ib as uint),\n+                elem: NeqElem(bucket, robin_ib as usize),\n             });\n         }\n \n@@ -1371,7 +1369,7 @@ pub enum Entry<'a, K: 'a, V: 'a> {\n enum VacantEntryState<K, V, M> {\n     /// The index is occupied, but the key to insert has precedence,\n     /// and will kick the current one out on insertion.\n-    NeqElem(FullBucket<K, V, M>, uint),\n+    NeqElem(FullBucket<K, V, M>, usize),\n     /// The index is genuinely vacant.\n     NoElem(EmptyBucket<K, V, M>),\n }\n@@ -1496,43 +1494,45 @@ impl<'a, K, V> Entry<'a, K, V> {\n     }\n }\n \n-#[unstable(feature = \"std_misc\",\n-           reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     /// Gets a reference to the value in the entry.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get(&self) -> &V {\n         self.elem.read().1\n     }\n \n     /// Gets a mutable reference to the value in the entry.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut(&mut self) -> &mut V {\n         self.elem.read_mut().1\n     }\n \n     /// Converts the OccupiedEntry into a mutable reference to the value in the entry\n     /// with a lifetime bound to the map itself\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_mut(self) -> &'a mut V {\n         self.elem.into_mut_refs().1\n     }\n \n     /// Sets the value of the entry, and returns the entry's old value\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(&mut self, mut value: V) -> V {\n         let old_value = self.get_mut();\n         mem::swap(&mut value, old_value);\n         value\n     }\n \n     /// Takes the value out of the entry, and returns it\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove(self) -> V {\n         pop_internal(self.elem).1\n     }\n }\n \n-#[unstable(feature = \"std_misc\",\n-           reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n impl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> {\n     /// Sets the value of the entry with the VacantEntry's key,\n     /// and returns a mutable reference to it\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(self, value: V) -> &'a mut V {\n         match self.elem {\n             NeqElem(bucket, ib) => {\n@@ -1580,7 +1580,6 @@ impl<K, V, S, H> Extend<(K, V)> for HashMap<K, V, S>\n /// `Hasher`, but the hashers created by two different `RandomState`\n /// instances are unlikely to produce the same result for the same values.\n #[derive(Clone)]\n-#[allow(missing_copy_implementations)]\n #[unstable(feature = \"std_misc\",\n            reason = \"hashing an hash maps may be altered\")]\n pub struct RandomState {\n@@ -1623,7 +1622,6 @@ impl Default for RandomState {\n /// This is the default hasher used in a `HashMap` to hash keys. Types do not\n /// typically declare an ability to explicitly hash into this particular type,\n /// but rather in a `H: hash::Writer` type parameter.\n-#[allow(missing_copy_implementations)]\n #[unstable(feature = \"std_misc\",\n            reason = \"hashing an hash maps may be altered\")]\n pub struct Hasher { inner: SipHasher }\n@@ -1674,11 +1672,11 @@ mod test_map {\n \n     #[derive(Hash, PartialEq, Eq)]\n     struct Dropable {\n-        k: uint\n+        k: usize\n     }\n \n     impl Dropable {\n-        fn new(k: uint) -> Dropable {\n+        fn new(k: usize) -> Dropable {\n             DROP_VECTOR.with(|slot| {\n                 slot.borrow_mut()[k] += 1;\n             });\n@@ -1711,24 +1709,24 @@ mod test_map {\n             let mut m = HashMap::new();\n \n             DROP_VECTOR.with(|v| {\n-                for i in 0u..200 {\n+                for i in 0..200 {\n                     assert_eq!(v.borrow()[i], 0);\n                 }\n             });\n \n-            for i in 0u..100 {\n+            for i in 0..100 {\n                 let d1 = Dropable::new(i);\n                 let d2 = Dropable::new(i+100);\n                 m.insert(d1, d2);\n             }\n \n             DROP_VECTOR.with(|v| {\n-                for i in 0u..200 {\n+                for i in 0..200 {\n                     assert_eq!(v.borrow()[i], 1);\n                 }\n             });\n \n-            for i in 0u..50 {\n+            for i in 0..50 {\n                 let k = Dropable::new(i);\n                 let v = m.remove(&k);\n \n@@ -1741,20 +1739,20 @@ mod test_map {\n             }\n \n             DROP_VECTOR.with(|v| {\n-                for i in 0u..50 {\n+                for i in 0..50 {\n                     assert_eq!(v.borrow()[i], 0);\n                     assert_eq!(v.borrow()[i+100], 0);\n                 }\n \n-                for i in 50u..100 {\n+                for i in 50..100 {\n                     assert_eq!(v.borrow()[i], 1);\n                     assert_eq!(v.borrow()[i+100], 1);\n                 }\n             });\n         }\n \n         DROP_VECTOR.with(|v| {\n-            for i in 0u..200 {\n+            for i in 0..200 {\n                 assert_eq!(v.borrow()[i], 0);\n             }\n         });\n@@ -1770,19 +1768,19 @@ mod test_map {\n             let mut hm = HashMap::new();\n \n             DROP_VECTOR.with(|v| {\n-                for i in 0u..200 {\n+                for i in 0..200 {\n                     assert_eq!(v.borrow()[i], 0);\n                 }\n             });\n \n-            for i in 0u..100 {\n+            for i in 0..100 {\n                 let d1 = Dropable::new(i);\n                 let d2 = Dropable::new(i+100);\n                 hm.insert(d1, d2);\n             }\n \n             DROP_VECTOR.with(|v| {\n-                for i in 0u..200 {\n+                for i in 0..200 {\n                     assert_eq!(v.borrow()[i], 1);\n                 }\n             });\n@@ -1797,19 +1795,19 @@ mod test_map {\n             let mut half = hm.into_iter().take(50);\n \n             DROP_VECTOR.with(|v| {\n-                for i in 0u..200 {\n+                for i in 0..200 {\n                     assert_eq!(v.borrow()[i], 1);\n                 }\n             });\n \n             for _ in half.by_ref() {}\n \n             DROP_VECTOR.with(|v| {\n-                let nk = (0u..100).filter(|&i| {\n+                let nk = (0..100).filter(|&i| {\n                     v.borrow()[i] == 1\n                 }).count();\n \n-                let nv = (0u..100).filter(|&i| {\n+                let nv = (0..100).filter(|&i| {\n                     v.borrow()[i+100] == 1\n                 }).count();\n \n@@ -1819,7 +1817,7 @@ mod test_map {\n         };\n \n         DROP_VECTOR.with(|v| {\n-            for i in 0u..200 {\n+            for i in 0..200 {\n                 assert_eq!(v.borrow()[i], 0);\n             }\n         });\n@@ -1964,7 +1962,7 @@ mod test_map {\n     #[test]\n     fn test_iterate() {\n         let mut m = HashMap::with_capacity(4);\n-        for i in 0u..32 {\n+        for i in 0..32 {\n             assert!(m.insert(i, i*2).is_none());\n         }\n         assert_eq!(m.len(), 32);\n@@ -1981,8 +1979,8 @@ mod test_map {\n     #[test]\n     fn test_keys() {\n         let vec = vec![(1, 'a'), (2, 'b'), (3, 'c')];\n-        let map = vec.into_iter().collect::<HashMap<int, char>>();\n-        let keys = map.keys().map(|&k| k).collect::<Vec<int>>();\n+        let map: HashMap<_, _> = vec.into_iter().collect();\n+        let keys: Vec<_> = map.keys().cloned().collect();\n         assert_eq!(keys.len(), 3);\n         assert!(keys.contains(&1));\n         assert!(keys.contains(&2));\n@@ -1992,8 +1990,8 @@ mod test_map {\n     #[test]\n     fn test_values() {\n         let vec = vec![(1, 'a'), (2, 'b'), (3, 'c')];\n-        let map = vec.into_iter().collect::<HashMap<int, char>>();\n-        let values = map.values().map(|&v| v).collect::<Vec<char>>();\n+        let map: HashMap<_, _> = vec.into_iter().collect();\n+        let values: Vec<_> = map.values().cloned().collect();\n         assert_eq!(values.len(), 3);\n         assert!(values.contains(&'a'));\n         assert!(values.contains(&'b'));\n@@ -2031,8 +2029,8 @@ mod test_map {\n \n     #[test]\n     fn test_show() {\n-        let mut map: HashMap<int, int> = HashMap::new();\n-        let empty: HashMap<int, int> = HashMap::new();\n+        let mut map = HashMap::new();\n+        let empty: HashMap<i32, i32> = HashMap::new();\n \n         map.insert(1, 2);\n         map.insert(3, 4);\n@@ -2051,7 +2049,7 @@ mod test_map {\n         assert_eq!(m.len(), 0);\n         assert!(m.is_empty());\n \n-        let mut i = 0u;\n+        let mut i = 0;\n         let old_cap = m.table.capacity();\n         while old_cap == m.table.capacity() {\n             m.insert(i, i);\n@@ -2079,7 +2077,7 @@ mod test_map {\n \n         assert_eq!(cap, initial_cap * 2);\n \n-        let mut i = 0u;\n+        let mut i = 0;\n         for _ in 0..cap * 3 / 4 {\n             m.insert(i, i);\n             i += 1;\n@@ -2121,21 +2119,21 @@ mod test_map {\n     #[test]\n     fn test_reserve_shrink_to_fit() {\n         let mut m = HashMap::new();\n-        m.insert(0u, 0u);\n+        m.insert(0, 0);\n         m.remove(&0);\n         assert!(m.capacity() >= m.len());\n-        for i in 0us..128 {\n+        for i in 0..128 {\n             m.insert(i, i);\n         }\n         m.reserve(256);\n \n         let usable_cap = m.capacity();\n-        for i in 128us..128+256 {\n+        for i in 128..(128 + 256) {\n             m.insert(i, i);\n             assert_eq!(m.capacity(), usable_cap);\n         }\n \n-        for i in 100us..128+256 {\n+        for i in 100..(128 + 256) {\n             assert_eq!(m.remove(&i), Some(i));\n         }\n         m.shrink_to_fit();\n@@ -2144,7 +2142,7 @@ mod test_map {\n         assert!(!m.is_empty());\n         assert!(m.capacity() >= m.len());\n \n-        for i in 0us..100 {\n+        for i in 0..100 {\n             assert_eq!(m.remove(&i), Some(i));\n         }\n         m.shrink_to_fit();\n@@ -2159,7 +2157,7 @@ mod test_map {\n     fn test_from_iter() {\n         let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n \n-        let map: HashMap<int, int> = xs.iter().map(|&x| x).collect();\n+        let map: HashMap<_, _> = xs.iter().cloned().collect();\n \n         for &(k, v) in &xs {\n             assert_eq!(map.get(&k), Some(&v));\n@@ -2170,7 +2168,7 @@ mod test_map {\n     fn test_size_hint() {\n         let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n \n-        let map: HashMap<int, int> = xs.iter().map(|&x| x).collect();\n+        let map: HashMap<_, _>  = xs.iter().cloned().collect();\n \n         let mut iter = map.iter();\n \n@@ -2183,7 +2181,7 @@ mod test_map {\n     fn test_iter_len() {\n         let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n \n-        let map: HashMap<int, int> = xs.iter().map(|&x| x).collect();\n+        let map: HashMap<_, _>  = xs.iter().cloned().collect();\n \n         let mut iter = map.iter();\n \n@@ -2196,7 +2194,7 @@ mod test_map {\n     fn test_mut_size_hint() {\n         let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n \n-        let mut map: HashMap<int, int> = xs.iter().map(|&x| x).collect();\n+        let mut map: HashMap<_, _>  = xs.iter().cloned().collect();\n \n         let mut iter = map.iter_mut();\n \n@@ -2209,7 +2207,7 @@ mod test_map {\n     fn test_iter_mut_len() {\n         let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n \n-        let mut map: HashMap<int, int> = xs.iter().map(|&x| x).collect();\n+        let mut map: HashMap<_, _>  = xs.iter().cloned().collect();\n \n         let mut iter = map.iter_mut();\n \n@@ -2220,7 +2218,7 @@ mod test_map {\n \n     #[test]\n     fn test_index() {\n-        let mut map: HashMap<int, int> = HashMap::new();\n+        let mut map = HashMap::new();\n \n         map.insert(1, 2);\n         map.insert(2, 1);\n@@ -2232,7 +2230,7 @@ mod test_map {\n     #[test]\n     #[should_fail]\n     fn test_index_nonexistent() {\n-        let mut map: HashMap<int, int> = HashMap::new();\n+        let mut map = HashMap::new();\n \n         map.insert(1, 2);\n         map.insert(2, 1);\n@@ -2245,7 +2243,7 @@ mod test_map {\n     fn test_entry(){\n         let xs = [(1, 10), (2, 20), (3, 30), (4, 40), (5, 50), (6, 60)];\n \n-        let mut map: HashMap<int, int> = xs.iter().map(|&x| x).collect();\n+        let mut map: HashMap<_, _> = xs.iter().cloned().collect();\n \n         // Existing key (insert)\n         match map.entry(1) {\n@@ -2296,7 +2294,7 @@ mod test_map {\n     #[test]\n     fn test_entry_take_doesnt_corrupt() {\n         // Test for #19292\n-        fn check(m: &HashMap<int, ()>) {\n+        fn check(m: &HashMap<isize, ()>) {\n             for k in m.keys() {\n                 assert!(m.contains_key(k),\n                         \"{} is in keys() but not in the map?\", k);\n@@ -2307,12 +2305,12 @@ mod test_map {\n         let mut rng = weak_rng();\n \n         // Populate the map with some items.\n-        for _ in 0u..50 {\n+        for _ in 0..50 {\n             let x = rng.gen_range(-10, 10);\n             m.insert(x, ());\n         }\n \n-        for i in 0u..1000 {\n+        for i in 0..1000 {\n             let x = rng.gen_range(-10, 10);\n             match m.entry(x) {\n                 Vacant(_) => {},"}, {"sha": "e40f17f29e804d898c95390874922f788afe0c35", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -76,15 +76,15 @@ use super::state::HashState;\n /// #[derive(Hash, Eq, PartialEq, Debug)]\n /// struct Viking<'a> {\n ///     name: &'a str,\n-///     power: uint,\n+///     power: usize,\n /// }\n ///\n /// let mut vikings = HashSet::new();\n ///\n-/// vikings.insert(Viking { name: \"Einar\", power: 9u });\n-/// vikings.insert(Viking { name: \"Einar\", power: 9u });\n-/// vikings.insert(Viking { name: \"Olaf\", power: 4u });\n-/// vikings.insert(Viking { name: \"Harald\", power: 8u });\n+/// vikings.insert(Viking { name: \"Einar\", power: 9 });\n+/// vikings.insert(Viking { name: \"Einar\", power: 9 });\n+/// vikings.insert(Viking { name: \"Olaf\", power: 4 });\n+/// vikings.insert(Viking { name: \"Harald\", power: 8 });\n ///\n /// // Use derived implementation to print the vikings.\n /// for x in vikings.iter() {\n@@ -123,7 +123,7 @@ impl<T: Hash<Hasher> + Eq> HashSet<T, RandomState> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn with_capacity(capacity: uint) -> HashSet<T, RandomState> {\n+    pub fn with_capacity(capacity: usize) -> HashSet<T, RandomState> {\n         HashSet { map: HashMap::with_capacity(capacity) }\n     }\n }\n@@ -146,7 +146,7 @@ impl<T, S, H> HashSet<T, S>\n     ///\n     /// let s = RandomState::new();\n     /// let mut set = HashSet::with_hash_state(s);\n-    /// set.insert(2u);\n+    /// set.insert(2);\n     /// ```\n     #[inline]\n     #[unstable(feature = \"std_misc\", reason = \"hasher stuff is unclear\")]\n@@ -169,12 +169,12 @@ impl<T, S, H> HashSet<T, S>\n     /// use std::collections::hash_map::RandomState;\n     ///\n     /// let s = RandomState::new();\n-    /// let mut set = HashSet::with_capacity_and_hash_state(10u, s);\n+    /// let mut set = HashSet::with_capacity_and_hash_state(10, s);\n     /// set.insert(1);\n     /// ```\n     #[inline]\n     #[unstable(feature = \"std_misc\", reason = \"hasher stuff is unclear\")]\n-    pub fn with_capacity_and_hash_state(capacity: uint, hash_state: S)\n+    pub fn with_capacity_and_hash_state(capacity: usize, hash_state: S)\n                                         -> HashSet<T, S> {\n         HashSet {\n             map: HashMap::with_capacity_and_hash_state(capacity, hash_state),\n@@ -192,7 +192,7 @@ impl<T, S, H> HashSet<T, S>\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn capacity(&self) -> uint {\n+    pub fn capacity(&self) -> usize {\n         self.map.capacity()\n     }\n \n@@ -202,7 +202,7 @@ impl<T, S, H> HashSet<T, S>\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the new allocation size overflows `uint`.\n+    /// Panics if the new allocation size overflows `usize`.\n     ///\n     /// # Example\n     ///\n@@ -212,7 +212,7 @@ impl<T, S, H> HashSet<T, S>\n     /// set.reserve(10);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn reserve(&mut self, additional: uint) {\n+    pub fn reserve(&mut self, additional: usize) {\n         self.map.reserve(additional)\n     }\n \n@@ -398,11 +398,11 @@ impl<T, S, H> HashSet<T, S>\n     ///\n     /// let mut v = HashSet::new();\n     /// assert_eq!(v.len(), 0);\n-    /// v.insert(1u);\n+    /// v.insert(1);\n     /// assert_eq!(v.len(), 1);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> uint { self.map.len() }\n+    pub fn len(&self) -> usize { self.map.len() }\n \n     /// Returns true if the set contains no elements\n     ///\n@@ -413,7 +413,7 @@ impl<T, S, H> HashSet<T, S>\n     ///\n     /// let mut v = HashSet::new();\n     /// assert!(v.is_empty());\n-    /// v.insert(1u);\n+    /// v.insert(1);\n     /// assert!(!v.is_empty());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -438,7 +438,7 @@ impl<T, S, H> HashSet<T, S>\n     /// use std::collections::HashSet;\n     ///\n     /// let mut v = HashSet::new();\n-    /// v.insert(1u);\n+    /// v.insert(1);\n     /// v.clear();\n     /// assert!(v.is_empty());\n     /// ```\n@@ -456,7 +456,7 @@ impl<T, S, H> HashSet<T, S>\n     /// ```\n     /// use std::collections::HashSet;\n     ///\n-    /// let set: HashSet<uint> = [1, 2, 3].iter().map(|&x| x).collect();\n+    /// let set: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n     /// assert_eq!(set.contains(&1), true);\n     /// assert_eq!(set.contains(&4), false);\n     /// ```\n@@ -475,8 +475,8 @@ impl<T, S, H> HashSet<T, S>\n     /// ```\n     /// use std::collections::HashSet;\n     ///\n-    /// let a: HashSet<uint> = [1, 2, 3].iter().map(|&x| x).collect();\n-    /// let mut b: HashSet<uint> = HashSet::new();\n+    /// let a: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n+    /// let mut b = HashSet::new();\n     ///\n     /// assert_eq!(a.is_disjoint(&b), true);\n     /// b.insert(4);\n@@ -496,8 +496,8 @@ impl<T, S, H> HashSet<T, S>\n     /// ```\n     /// use std::collections::HashSet;\n     ///\n-    /// let sup: HashSet<uint> = [1, 2, 3].iter().map(|&x| x).collect();\n-    /// let mut set: HashSet<uint> = HashSet::new();\n+    /// let sup: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n+    /// let mut set = HashSet::new();\n     ///\n     /// assert_eq!(set.is_subset(&sup), true);\n     /// set.insert(2);\n@@ -517,8 +517,8 @@ impl<T, S, H> HashSet<T, S>\n     /// ```\n     /// use std::collections::HashSet;\n     ///\n-    /// let sub: HashSet<uint> = [1, 2].iter().map(|&x| x).collect();\n-    /// let mut set: HashSet<uint> = HashSet::new();\n+    /// let sub: HashSet<_> = [1, 2].iter().cloned().collect();\n+    /// let mut set = HashSet::new();\n     ///\n     /// assert_eq!(set.is_superset(&sub), false);\n     ///\n@@ -545,7 +545,7 @@ impl<T, S, H> HashSet<T, S>\n     ///\n     /// let mut set = HashSet::new();\n     ///\n-    /// assert_eq!(set.insert(2u), true);\n+    /// assert_eq!(set.insert(2), true);\n     /// assert_eq!(set.insert(2), false);\n     /// assert_eq!(set.len(), 1);\n     /// ```\n@@ -566,7 +566,7 @@ impl<T, S, H> HashSet<T, S>\n     ///\n     /// let mut set = HashSet::new();\n     ///\n-    /// set.insert(2u);\n+    /// set.insert(2);\n     /// assert_eq!(set.remove(&2), true);\n     /// assert_eq!(set.remove(&2), false);\n     /// ```\n@@ -670,10 +670,10 @@ impl<'a, 'b, T, S, H> BitOr<&'b HashSet<T, S>> for &'a HashSet<T, S>\n     /// ```\n     /// use std::collections::HashSet;\n     ///\n-    /// let a: HashSet<int> = vec![1, 2, 3].into_iter().collect();\n-    /// let b: HashSet<int> = vec![3, 4, 5].into_iter().collect();\n+    /// let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n+    /// let b: HashSet<_> = vec![3, 4, 5].into_iter().collect();\n     ///\n-    /// let set: HashSet<int> = &a | &b;\n+    /// let set = &a | &b;\n     ///\n     /// let mut i = 0;\n     /// let expected = [1, 2, 3, 4, 5];\n@@ -703,10 +703,10 @@ impl<'a, 'b, T, S, H> BitAnd<&'b HashSet<T, S>> for &'a HashSet<T, S>\n     /// ```\n     /// use std::collections::HashSet;\n     ///\n-    /// let a: HashSet<int> = vec![1, 2, 3].into_iter().collect();\n-    /// let b: HashSet<int> = vec![2, 3, 4].into_iter().collect();\n+    /// let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n+    /// let b: HashSet<_> = vec![2, 3, 4].into_iter().collect();\n     ///\n-    /// let set: HashSet<int> = &a & &b;\n+    /// let set = &a & &b;\n     ///\n     /// let mut i = 0;\n     /// let expected = [2, 3];\n@@ -736,10 +736,10 @@ impl<'a, 'b, T, S, H> BitXor<&'b HashSet<T, S>> for &'a HashSet<T, S>\n     /// ```\n     /// use std::collections::HashSet;\n     ///\n-    /// let a: HashSet<int> = vec![1, 2, 3].into_iter().collect();\n-    /// let b: HashSet<int> = vec![3, 4, 5].into_iter().collect();\n+    /// let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n+    /// let b: HashSet<_> = vec![3, 4, 5].into_iter().collect();\n     ///\n-    /// let set: HashSet<int> = &a ^ &b;\n+    /// let set = &a ^ &b;\n     ///\n     /// let mut i = 0;\n     /// let expected = [1, 2, 4, 5];\n@@ -769,10 +769,10 @@ impl<'a, 'b, T, S, H> Sub<&'b HashSet<T, S>> for &'a HashSet<T, S>\n     /// ```\n     /// use std::collections::HashSet;\n     ///\n-    /// let a: HashSet<int> = vec![1, 2, 3].into_iter().collect();\n-    /// let b: HashSet<int> = vec![3, 4, 5].into_iter().collect();\n+    /// let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n+    /// let b: HashSet<_> = vec![3, 4, 5].into_iter().collect();\n     ///\n-    /// let set: HashSet<int> = &a - &b;\n+    /// let set = &a - &b;\n     ///\n     /// let mut i = 0;\n     /// let expected = [1, 2];\n@@ -1029,7 +1029,7 @@ mod test_set {\n     #[test]\n     fn test_iterate() {\n         let mut a = HashSet::new();\n-        for i in 0u..32 {\n+        for i in 0..32 {\n             assert!(a.insert(i));\n         }\n         let mut observed: u32 = 0;\n@@ -1152,7 +1152,7 @@ mod test_set {\n     fn test_from_iter() {\n         let xs = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n \n-        let set: HashSet<int> = xs.iter().map(|&x| x).collect();\n+        let set: HashSet<_> = xs.iter().cloned().collect();\n \n         for x in &xs {\n             assert!(set.contains(x));\n@@ -1198,8 +1198,8 @@ mod test_set {\n \n     #[test]\n     fn test_show() {\n-        let mut set: HashSet<int> = HashSet::new();\n-        let empty: HashSet<int> = HashSet::new();\n+        let mut set = HashSet::new();\n+        let empty = HashSet::<i32>::new();\n \n         set.insert(1);\n         set.insert(2);\n@@ -1212,19 +1212,19 @@ mod test_set {\n \n     #[test]\n     fn test_trivial_drain() {\n-        let mut s = HashSet::<int>::new();\n+        let mut s = HashSet::<i32>::new();\n         for _ in s.drain() {}\n         assert!(s.is_empty());\n         drop(s);\n \n-        let mut s = HashSet::<int>::new();\n+        let mut s = HashSet::<i32>::new();\n         drop(s.drain());\n         assert!(s.is_empty());\n     }\n \n     #[test]\n     fn test_drain() {\n-        let mut s: HashSet<i32> = (1..100).collect();\n+        let mut s: HashSet<_> = (1..100).collect();\n \n         // try this a bunch of times to make sure we don't screw up internal state.\n         for _ in 0..20 {"}, {"sha": "0bb6bd4cf356a24c93cdcc388068a0d41900a1c5", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -67,8 +67,8 @@ const EMPTY_BUCKET: u64 = 0u64;\n /// but in general is just a tricked out `Vec<Option<u64, K, V>>`.\n #[unsafe_no_drop_flag]\n pub struct RawTable<K, V> {\n-    capacity: uint,\n-    size:     uint,\n+    capacity: usize,\n+    size:     usize,\n     hashes:   *mut u64,\n     // Because K/V do not appear directly in any of the types in the struct,\n     // inform rustc that in fact instances of K and V are reachable from here.\n@@ -88,21 +88,21 @@ impl<K,V> Copy for RawBucket<K,V> {}\n \n pub struct Bucket<K, V, M> {\n     raw:   RawBucket<K, V>,\n-    idx:   uint,\n+    idx:   usize,\n     table: M\n }\n \n impl<K,V,M:Copy> Copy for Bucket<K,V,M> {}\n \n pub struct EmptyBucket<K, V, M> {\n     raw:   RawBucket<K, V>,\n-    idx:   uint,\n+    idx:   usize,\n     table: M\n }\n \n pub struct FullBucket<K, V, M> {\n     raw:   RawBucket<K, V>,\n-    idx:   uint,\n+    idx:   usize,\n     table: M\n }\n \n@@ -190,7 +190,7 @@ impl<K, V, M> FullBucket<K, V, M> {\n         self.table\n     }\n     /// Get the raw index.\n-    pub fn index(&self) -> uint {\n+    pub fn index(&self) -> usize {\n         self.idx\n     }\n }\n@@ -212,21 +212,21 @@ impl<K, V, M> Bucket<K, V, M> {\n         self.table\n     }\n     /// Get the raw index.\n-    pub fn index(&self) -> uint {\n+    pub fn index(&self) -> usize {\n         self.idx\n     }\n }\n \n impl<K, V, M: Deref<Target=RawTable<K, V>>> Bucket<K, V, M> {\n     pub fn new(table: M, hash: SafeHash) -> Bucket<K, V, M> {\n-        Bucket::at_index(table, hash.inspect() as uint)\n+        Bucket::at_index(table, hash.inspect() as usize)\n     }\n \n-    pub fn at_index(table: M, ib_index: uint) -> Bucket<K, V, M> {\n+    pub fn at_index(table: M, ib_index: usize) -> Bucket<K, V, M> {\n         let ib_index = ib_index & (table.capacity() - 1);\n         Bucket {\n             raw: unsafe {\n-               table.first_bucket_raw().offset(ib_index as int)\n+               table.first_bucket_raw().offset(ib_index as isize)\n             },\n             idx: ib_index,\n             table: table\n@@ -276,7 +276,7 @@ impl<K, V, M: Deref<Target=RawTable<K, V>>> Bucket<K, V, M> {\n         // ... and it's zero at all other times.\n         let maybe_wraparound_dist = (self.idx ^ (self.idx + 1)) & self.table.capacity();\n         // Finally, we obtain the offset 1 or the offset -cap + 1.\n-        let dist = 1 - (maybe_wraparound_dist as int);\n+        let dist = 1 - (maybe_wraparound_dist as isize);\n \n         self.idx += 1;\n \n@@ -366,11 +366,11 @@ impl<K, V, M: Deref<Target=RawTable<K, V>>> FullBucket<K, V, M> {\n     ///\n     /// In the cited blog posts above, this is called the \"distance to\n     /// initial bucket\", or DIB. Also known as \"probe count\".\n-    pub fn distance(&self) -> uint {\n+    pub fn distance(&self) -> usize {\n         // Calculates the distance one has to travel when going from\n         // `hash mod capacity` onwards to `idx mod capacity`, wrapping around\n         // if the destination is not reached before the end of the table.\n-        (self.idx - self.hash().inspect() as uint) & (self.table.capacity() - 1)\n+        (self.idx - self.hash().inspect() as usize) & (self.table.capacity() - 1)\n     }\n \n     #[inline]\n@@ -503,7 +503,7 @@ impl<K, V, M: Deref<Target=RawTable<K, V>>> GapThenFull<K, V, M> {\n /// # Panics\n ///\n /// Panics if `target_alignment` is not a power of two.\n-fn round_up_to_next(unrounded: uint, target_alignment: uint) -> uint {\n+fn round_up_to_next(unrounded: usize, target_alignment: usize) -> usize {\n     assert!(target_alignment.is_power_of_two());\n     (unrounded + target_alignment - 1) & !(target_alignment - 1)\n }\n@@ -520,10 +520,10 @@ fn test_rounding() {\n \n // Returns a tuple of (key_offset, val_offset),\n // from the start of a mallocated array.\n-fn calculate_offsets(hashes_size: uint,\n-                     keys_size: uint, keys_align: uint,\n-                     vals_align: uint)\n-                     -> (uint, uint) {\n+fn calculate_offsets(hashes_size: usize,\n+                     keys_size: usize, keys_align: usize,\n+                     vals_align: usize)\n+                     -> (usize, usize) {\n     let keys_offset = round_up_to_next(hashes_size, keys_align);\n     let end_of_keys = keys_offset + keys_size;\n \n@@ -534,10 +534,10 @@ fn calculate_offsets(hashes_size: uint,\n \n // Returns a tuple of (minimum required malloc alignment, hash_offset,\n // array_size), from the start of a mallocated array.\n-fn calculate_allocation(hash_size: uint, hash_align: uint,\n-                        keys_size: uint, keys_align: uint,\n-                        vals_size: uint, vals_align: uint)\n-                        -> (uint, uint, uint) {\n+fn calculate_allocation(hash_size: usize, hash_align: usize,\n+                        keys_size: usize, keys_align: usize,\n+                        vals_size: usize, vals_align: usize)\n+                        -> (usize, usize, usize) {\n     let hash_offset = 0;\n     let (_, vals_offset) = calculate_offsets(hash_size,\n                                              keys_size, keys_align,\n@@ -562,7 +562,7 @@ fn test_offset_calculation() {\n impl<K, V> RawTable<K, V> {\n     /// Does not initialize the buckets. The caller should ensure they,\n     /// at the very least, set every hash to EMPTY_BUCKET.\n-    unsafe fn new_uninitialized(capacity: uint) -> RawTable<K, V> {\n+    unsafe fn new_uninitialized(capacity: usize) -> RawTable<K, V> {\n         if capacity == 0 {\n             return RawTable {\n                 size: 0,\n@@ -601,7 +601,7 @@ impl<K, V> RawTable<K, V> {\n         let buffer = allocate(size, malloc_alignment);\n         if buffer.is_null() { ::alloc::oom() }\n \n-        let hashes = buffer.offset(hash_offset as int) as *mut u64;\n+        let hashes = buffer.offset(hash_offset as isize) as *mut u64;\n \n         RawTable {\n             capacity: capacity,\n@@ -623,15 +623,15 @@ impl<K, V> RawTable<K, V> {\n         unsafe {\n             RawBucket {\n                 hash: self.hashes,\n-                key:  buffer.offset(keys_offset as int) as *mut K,\n-                val:  buffer.offset(vals_offset as int) as *mut V\n+                key:  buffer.offset(keys_offset as isize) as *mut K,\n+                val:  buffer.offset(vals_offset as isize) as *mut V\n             }\n         }\n     }\n \n     /// Creates a new raw table from a given capacity. All buckets are\n     /// initially empty.\n-    pub fn new(capacity: uint) -> RawTable<K, V> {\n+    pub fn new(capacity: usize) -> RawTable<K, V> {\n         unsafe {\n             let ret = RawTable::new_uninitialized(capacity);\n             zero_memory(ret.hashes, capacity);\n@@ -640,21 +640,21 @@ impl<K, V> RawTable<K, V> {\n     }\n \n     /// The hashtable's capacity, similar to a vector's.\n-    pub fn capacity(&self) -> uint {\n+    pub fn capacity(&self) -> usize {\n         self.capacity\n     }\n \n     /// The number of elements ever `put` in the hashtable, minus the number\n     /// of elements ever `take`n.\n-    pub fn size(&self) -> uint {\n+    pub fn size(&self) -> usize {\n         self.size\n     }\n \n     fn raw_buckets(&self) -> RawBuckets<K, V> {\n         RawBuckets {\n             raw: self.first_bucket_raw(),\n             hashes_end: unsafe {\n-                self.hashes.offset(self.capacity as int)\n+                self.hashes.offset(self.capacity as isize)\n             },\n             marker: marker::ContravariantLifetime,\n         }\n@@ -705,7 +705,7 @@ impl<K, V> RawTable<K, V> {\n     unsafe fn rev_move_buckets(&mut self) -> RevMoveBuckets<K, V> {\n         let raw_bucket = self.first_bucket_raw();\n         RevMoveBuckets {\n-            raw: raw_bucket.offset(self.capacity as int),\n+            raw: raw_bucket.offset(self.capacity as isize),\n             hashes_end: raw_bucket.hash,\n             elems_left: self.size,\n             marker:     marker::ContravariantLifetime,\n@@ -758,7 +758,7 @@ impl<'a, K, V> Iterator for RawBuckets<'a, K, V> {\n struct RevMoveBuckets<'a, K, V> {\n     raw: RawBucket<K, V>,\n     hashes_end: *mut u64,\n-    elems_left: uint,\n+    elems_left: usize,\n     marker: marker::ContravariantLifetime<'a>,\n }\n \n@@ -791,7 +791,7 @@ impl<'a, K, V> Iterator for RevMoveBuckets<'a, K, V> {\n /// Iterator over shared references to entries in a table.\n pub struct Iter<'a, K: 'a, V: 'a> {\n     iter: RawBuckets<'a, K, V>,\n-    elems_left: uint,\n+    elems_left: usize,\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n@@ -808,7 +808,7 @@ impl<'a, K, V> Clone for Iter<'a, K, V> {\n /// Iterator over mutable references to entries in a table.\n pub struct IterMut<'a, K: 'a, V: 'a> {\n     iter: RawBuckets<'a, K, V>,\n-    elems_left: uint,\n+    elems_left: usize,\n }\n \n /// Iterator over the entries in a table, consuming the table."}, {"sha": "55924bc73a8d5e2f6b4d9dc65b6425bbc8cccc56", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -209,7 +209,7 @@\n //! all the contents of the collection.\n //!\n //! ```\n-//! let vec = vec![1u, 2, 3, 4];\n+//! let vec = vec![1, 2, 3, 4];\n //! for x in vec.iter() {\n //!    println!(\"vec contained {}\", x);\n //! }\n@@ -219,7 +219,7 @@\n //! This is great for mutating all the contents of the collection.\n //!\n //! ```\n-//! let mut vec = vec![1u, 2, 3, 4];\n+//! let mut vec = vec![1, 2, 3, 4];\n //! for x in vec.iter_mut() {\n //!    *x += 1;\n //! }\n@@ -234,15 +234,15 @@\n //! previous section to do this as efficiently as possible.\n //!\n //! ```\n-//! let mut vec1 = vec![1u, 2, 3, 4];\n-//! let vec2 = vec![10u, 20, 30, 40];\n+//! let mut vec1 = vec![1, 2, 3, 4];\n+//! let vec2 = vec![10, 20, 30, 40];\n //! vec1.extend(vec2.into_iter());\n //! ```\n //!\n //! ```\n //! use std::collections::RingBuf;\n //!\n-//! let vec = vec![1u, 2, 3, 4];\n+//! let vec = vec![1, 2, 3, 4];\n //! let buf: RingBuf<uint> = vec.into_iter().collect();\n //! ```\n //!\n@@ -253,7 +253,7 @@\n //! iterators as the way to iterate over them in reverse order.\n //!\n //! ```\n-//! let vec = vec![1u, 2, 3, 4];\n+//! let vec = vec![1, 2, 3, 4];\n //! for x in vec.iter().rev() {\n //!    println!(\"vec contained {}\", x);\n //! }\n@@ -299,21 +299,21 @@\n //! #### Counting the number of times each character in a string occurs\n //!\n //! ```\n-//! use std::collections::btree_map::{BTreeMap, Occupied, Vacant};\n+//! use std::collections::btree_map::{BTreeMap, Entry};\n //!\n //! let mut count = BTreeMap::new();\n //! let message = \"she sells sea shells by the sea shore\";\n //!\n //! for c in message.chars() {\n //!     match count.entry(c) {\n-//!         Vacant(entry) => { entry.insert(1u); },\n-//!         Occupied(mut entry) => *entry.get_mut() += 1,\n+//!         Entry::Vacant(entry) => { entry.insert(1); },\n+//!         Entry::Occupied(mut entry) => *entry.get_mut() += 1,\n //!     }\n //! }\n //!\n //! assert_eq!(count.get(&'s'), Some(&8));\n //!\n-//! println!(\"Number of occurences of each character\");\n+//! println!(\"Number of occurrences of each character\");\n //! for (char, count) in count.iter() {\n //!     println!(\"{}: {}\", char, count);\n //! }\n@@ -326,7 +326,7 @@\n //! #### Tracking the inebriation of customers at a bar\n //!\n //! ```\n-//! use std::collections::btree_map::{BTreeMap, Occupied, Vacant};\n+//! use std::collections::btree_map::{BTreeMap, Entry};\n //!\n //! // A client of the bar. They have an id and a blood alcohol level.\n //! struct Person { id: u32, blood_alcohol: f32 };\n@@ -341,8 +341,8 @@\n //!     // If this is the first time we've seen this customer, initialize them\n //!     // with no blood alcohol. Otherwise, just retrieve them.\n //!     let person = match blood_alcohol.entry(id) {\n-//!         Vacant(entry) => entry.insert(Person{id: id, blood_alcohol: 0.0}),\n-//!         Occupied(entry) => entry.into_mut(),\n+//!         Entry::Vacant(entry) => entry.insert(Person{id: id, blood_alcohol: 0.0}),\n+//!         Entry::Occupied(entry) => entry.into_mut(),\n //!     };\n //!\n //!     // Reduce their blood alcohol level. It takes time to order and drink a beer!"}, {"sha": "bee9a0d00337b4fa2f9a9130bd5c525ada3cec88", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -22,7 +22,6 @@ use mem;\n use env;\n use str;\n \n-#[allow(missing_copy_implementations)]\n pub struct DynamicLibrary {\n     handle: *mut u8\n }"}, {"sha": "e73797bc66c7f377324b8bb1e6e9fca25d808e7b", "filename": "src/libstd/env.rs", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -337,7 +337,7 @@ pub fn temp_dir() -> Path {\n ///\n /// # Errors\n ///\n-/// Acquring the path to the current executable is a platform-specific operation\n+/// Acquiring the path to the current executable is a platform-specific operation\n /// that can fail for a good number of reasons. Some errors can include, but not\n /// be limited to filesystem operations failing or general syscall failures.\n ///\n@@ -562,6 +562,38 @@ pub mod consts {\n     pub const EXE_EXTENSION: &'static str = \"\";\n }\n \n+/// Constants associated with the current target\n+#[cfg(target_os = \"openbsd\")]\n+pub mod consts {\n+    pub use super::arch_consts::ARCH;\n+\n+    pub const FAMILY: &'static str = \"unix\";\n+\n+    /// A string describing the specific operating system in use: in this\n+    /// case, `dragonfly`.\n+    pub const OS: &'static str = \"openbsd\";\n+\n+    /// Specifies the filename prefix used for shared libraries on this\n+    /// platform: in this case, `lib`.\n+    pub const DLL_PREFIX: &'static str = \"lib\";\n+\n+    /// Specifies the filename suffix used for shared libraries on this\n+    /// platform: in this case, `.so`.\n+    pub const DLL_SUFFIX: &'static str = \".so\";\n+\n+    /// Specifies the file extension used for shared libraries on this\n+    /// platform that goes after the dot: in this case, `so`.\n+    pub const DLL_EXTENSION: &'static str = \"so\";\n+\n+    /// Specifies the filename suffix used for executable binaries on this\n+    /// platform: in this case, the empty string.\n+    pub const EXE_SUFFIX: &'static str = \"\";\n+\n+    /// Specifies the file extension, if any, used for executable binaries\n+    /// on this platform: in this case, the empty string.\n+    pub const EXE_EXTENSION: &'static str = \"\";\n+}\n+\n /// Constants associated with the current target\n #[cfg(target_os = \"android\")]\n pub mod consts {"}, {"sha": "2668baba095b875f7436d5ff675827f577be8518", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -96,7 +96,7 @@ fn with_end_to_cap<F>(v: &mut Vec<u8>, f: F) -> Result<usize>\n //\n // To this end, we use an RAII guard (to protect against panics) which updates\n // the length of the string when it is dropped. This guard initially truncates\n-// the string to the prior length and only afer we've validated that the\n+// the string to the prior length and only after we've validated that the\n // new contents are valid UTF-8 do we allow it to set a longer length.\n //\n // The unsafety in this function is twofold:\n@@ -663,7 +663,7 @@ impl<T> Take<T> {\n     ///\n     /// # Note\n     ///\n-    /// This instance may reach EOF after reading fewer bytes than indiccated by\n+    /// This instance may reach EOF after reading fewer bytes than indicated by\n     /// this method if the underlying `Read` instance reaches EOF.\n     pub fn limit(&self) -> u64 { self.limit }\n }"}, {"sha": "1a61769445664f83e14bbab9f4116cb85ac65e9a", "filename": "src/libstd/os.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -759,7 +759,6 @@ pub fn page_size() -> uint {\n ///\n /// The memory map is released (unmapped) when the destructor is run, so don't\n /// let it leave scope by accident if you want it to stick around.\n-#[allow(missing_copy_implementations)]\n pub struct MemoryMap {\n     data: *mut u8,\n     len: uint,\n@@ -1289,6 +1288,8 @@ pub mod consts {\n }\n \n #[cfg(target_os = \"openbsd\")]\n+#[deprecated(since = \"1.0.0\", reason = \"renamed to env::consts\")]\n+#[unstable(feature = \"os\")]\n pub mod consts {\n     pub use os::arch_consts::ARCH;\n "}, {"sha": "cb2138630307feea8463ca6c02e1fec9eda0b95b", "filename": "src/libstd/path.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -922,7 +922,7 @@ impl PathBuf {\n     ///\n     /// If `self.file_name()` is `None`, does nothing and returns `false`.\n     ///\n-    /// Otherwise, returns `tru`; if `self.exension()` is `None`, the extension\n+    /// Otherwise, returns `true`; if `self.extension()` is `None`, the extension\n     /// is added; otherwise it is replaced.\n     pub fn set_extension<S: ?Sized + AsOsStr>(&mut self, extension: &S) -> bool {\n         if self.file_name().is_none() { return false; }\n@@ -1062,7 +1062,7 @@ impl Path {\n         PathBuf::new(self)\n     }\n \n-    /// A path is *absolute* if it is indepedent of the current directory.\n+    /// A path is *absolute* if it is independent of the current directory.\n     ///\n     /// * On Unix, a path is absolute if it starts with the root, so\n     /// `is_absolute` and `has_root` are equivalent."}, {"sha": "535af08c96c70d70f25245008dddf8f5570a3b1c", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -206,7 +206,6 @@ mod imp {\n     /// - iOS: calls SecRandomCopyBytes as /dev/(u)random is sandboxed.\n     ///\n     /// This does not block.\n-    #[allow(missing_copy_implementations)]\n     pub struct OsRng {\n         // dummy field to ensure that this struct cannot be constructed outside of this module\n         _dummy: (),"}, {"sha": "e064663b9e76f3931ed28f1e8ee69b86cb163bb8", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -98,8 +98,8 @@ thread_local! { static PANICKING: Cell<bool> = Cell::new(false) }\n \n /// Invoke a closure, capturing the cause of panic if one occurs.\n ///\n-/// This function will return `None` if the closure did not panic, and will\n-/// return `Some(cause)` if the closure panics. The `cause` returned is the\n+/// This function will return `Ok(())` if the closure did not panic, and will\n+/// return `Err(cause)` if the closure panics. The `cause` returned is the\n /// object with which panic was originally invoked.\n ///\n /// This function also is unsafe for a variety of reasons:\n@@ -390,13 +390,10 @@ pub mod eabi {\n     use libc::{c_void, c_int};\n \n     #[repr(C)]\n-    #[allow(missing_copy_implementations)]\n     pub struct EXCEPTION_RECORD;\n     #[repr(C)]\n-    #[allow(missing_copy_implementations)]\n     pub struct CONTEXT;\n     #[repr(C)]\n-    #[allow(missing_copy_implementations)]\n     pub struct DISPATCHER_CONTEXT;\n \n     #[repr(C)]"}, {"sha": "703dca4d29bf95f7293e501a889b328e4c4b1b7e", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -88,7 +88,6 @@ pub fn default_sched_threads() -> uint {\n pub const ENFORCE_SANITY: bool = true || !cfg!(rtopt) || cfg!(rtdebug) ||\n                                   cfg!(rtassert);\n \n-#[allow(missing_copy_implementations)]\n pub struct Stdio(libc::c_int);\n \n #[allow(non_upper_case_globals)]"}, {"sha": "cca376f7b6d05397776202005627afd0c6153b7c", "filename": "src/libstd/sync/barrier.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibstd%2Fsync%2Fbarrier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibstd%2Fsync%2Fbarrier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fbarrier.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -46,7 +46,6 @@ struct BarrierState {\n ///\n /// Currently this opaque structure only has one method, `.is_leader()`. Only\n /// one thread will receive a result that will return `true` from this function.\n-#[allow(missing_copy_implementations)]\n pub struct BarrierWaitResult(bool);\n \n impl Barrier {"}, {"sha": "2e60d684d6823aeb82a8c4248ad9fe8053a809ea", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Multi-producer, single-consumer communication primitives threads\n+//! Multi-producer, single-consumer FIFO queue communication primitives.\n //!\n //! This module provides message-based communication over channels, concretely\n //! defined among three types:"}, {"sha": "eb45681fa626d6e3018447c676efe23b688ce478", "filename": "src/libstd/sync/mpsc/oneshot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -45,7 +45,7 @@ use core::mem;\n use sync::atomic::{AtomicUsize, Ordering};\n \n // Various states you can find a port in.\n-const EMPTY: uint = 0;          // initial state: no data, no blocked reciever\n+const EMPTY: uint = 0;          // initial state: no data, no blocked receiver\n const DATA: uint = 1;           // data ready for receiver to take\n const DISCONNECTED: uint = 2;   // channel is disconnected OR upgraded\n // Any other value represents a pointer to a SignalToken value. The"}, {"sha": "d9bc37d312e86038ff1542a50396e188a50c1a9a", "filename": "src/libstd/sync/poison.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibstd%2Fsync%2Fpoison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibstd%2Fsync%2Fpoison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fpoison.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -42,7 +42,6 @@ impl Flag {\n     }\n }\n \n-#[allow(missing_copy_implementations)]\n pub struct Guard {\n     panicking: bool,\n }"}, {"sha": "892004714659d461aa971d5bd14874956b0a1e8b", "filename": "src/libstd/sys/common/wtf8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -84,7 +84,7 @@ impl CodePoint {\n \n     /// Create a new `CodePoint` from a `char`.\n     ///\n-    /// Since all Unicode scalar values are code points, this always succeds.\n+    /// Since all Unicode scalar values are code points, this always succeeds.\n     #[inline]\n     pub fn from_char(value: char) -> CodePoint {\n         CodePoint { value: value as u32 }"}, {"sha": "22194145252ee6ac1641a1dc8e789dfedbaaf799", "filename": "src/libstd/sys/unix/c.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fc.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -74,6 +74,8 @@ pub const _SC_GETPW_R_SIZE_MAX: libc::c_int = 70;\n #[cfg(any(target_os = \"macos\",\n           target_os = \"freebsd\"))]\n pub const _SC_GETPW_R_SIZE_MAX: libc::c_int = 71;\n+#[cfg(target_os = \"openbsd\")]\n+pub const _SC_GETPW_R_SIZE_MAX: libc::c_int = 101;\n #[cfg(target_os = \"android\")]\n pub const _SC_GETPW_R_SIZE_MAX: libc::c_int = 0x0048;\n \n@@ -91,7 +93,8 @@ pub struct passwd {\n \n #[repr(C)]\n #[cfg(any(target_os = \"macos\",\n-          target_os = \"freebsd\"))]\n+          target_os = \"freebsd\",\n+          target_os = \"openbsd\"))]\n pub struct passwd {\n     pub pw_name: *mut libc::c_char,\n     pub pw_passwd: *mut libc::c_char,"}, {"sha": "b191eda583c9b82d4a57a3ea6da3f35d7d7b9fb0", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -47,13 +47,9 @@ pub fn errno() -> i32 {\n     }\n \n     #[cfg(target_os = \"openbsd\")]\n-    fn errno_location() -> *const c_int {\n-        extern {\n-            fn __errno() -> *const c_int;\n-        }\n-        unsafe {\n-            __errno()\n-        }\n+    unsafe fn errno_location() -> *const c_int {\n+        extern { fn __errno() -> *const c_int; }\n+        __errno()\n     }\n \n     #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n@@ -197,23 +193,23 @@ pub fn current_exe() -> IoResult<Path> {\n }\n \n #[cfg(target_os = \"openbsd\")]\n-pub fn load_self() -> Option<Vec<u8>> {\n+pub fn current_exe() -> IoResult<Path> {\n     use sync::{StaticMutex, MUTEX_INIT};\n \n     static LOCK: StaticMutex = MUTEX_INIT;\n \n     extern {\n-        fn rust_load_self() -> *const c_char;\n+        fn rust_current_exe() -> *const c_char;\n     }\n \n     let _guard = LOCK.lock();\n \n     unsafe {\n-        let v = rust_load_self();\n+        let v = rust_current_exe();\n         if v.is_null() {\n-            None\n+            Err(IoError::last_error())\n         } else {\n-            Some(ffi::c_str_to_bytes(&v).to_vec())\n+            Ok(Path::new(ffi::c_str_to_bytes(&v).to_vec()))\n         }\n     }\n }\n@@ -333,7 +329,8 @@ pub fn args() -> Args {\n #[cfg(any(target_os = \"linux\",\n           target_os = \"android\",\n           target_os = \"freebsd\",\n-          target_os = \"dragonfly\"))]\n+          target_os = \"dragonfly\",\n+          target_os = \"openbsd\"))]\n pub fn args() -> Args {\n     use rt;\n     let bytes = rt::args::clone().unwrap_or(Vec::new());"}, {"sha": "0c24ab1fa09b4e964f1f424f5c4d117e8e4e93bc", "filename": "src/libstd/sys/windows/thread_local.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -191,7 +191,7 @@ unsafe fn unregister_dtor(key: Key) -> bool {\n // # What's up with this callback?\n //\n // The callback specified receives a number of parameters from... someone!\n-// (the kernel? the runtime? I'm not qute sure!) There are a few events that\n+// (the kernel? the runtime? I'm not quite sure!) There are a few events that\n // this gets invoked for, but we're currently only interested on when a\n // thread or a process \"detaches\" (exits). The process part happens for the\n // last thread and the thread part happens for any normal thread."}, {"sha": "42ef3459a0ed7cf931f191e300a7940ca87b21e9", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -232,7 +232,7 @@ impl Duration {\n         secs_part.checked_add(nanos_part as i64)\n     }\n \n-    /// Add two durations, returning `None` if overflow occured.\n+    /// Add two durations, returning `None` if overflow occurred.\n     #[unstable(feature = \"std_misc\")]\n     pub fn checked_add(&self, rhs: &Duration) -> Option<Duration> {\n         let mut secs = try_opt!(self.secs.checked_add(rhs.secs));\n@@ -247,7 +247,7 @@ impl Duration {\n         if d < MIN || d > MAX { None } else { Some(d) }\n     }\n \n-    /// Subtract two durations, returning `None` if overflow occured.\n+    /// Subtract two durations, returning `None` if overflow occurred.\n     #[unstable(feature = \"std_misc\")]\n     pub fn checked_sub(&self, rhs: &Duration) -> Option<Duration> {\n         let mut secs = try_opt!(self.secs.checked_sub(rhs.secs));"}, {"sha": "3231342cb50c8f37524ca7d44ee66fb163d56344", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 46, "deletions": 8, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -437,18 +437,35 @@ impl CodeMap {\n         FileLines {file: lo.file, lines: lines}\n     }\n \n-    pub fn span_to_snippet(&self, sp: Span) -> Option<String> {\n+    pub fn span_to_snippet(&self, sp: Span) -> Result<String, SpanSnippetError> {\n+        if sp.lo > sp.hi {\n+            return Err(SpanSnippetError::IllFormedSpan(sp));\n+        }\n+\n         let begin = self.lookup_byte_offset(sp.lo);\n         let end = self.lookup_byte_offset(sp.hi);\n \n-        // FIXME #8256: this used to be an assert but whatever precondition\n-        // it's testing isn't true for all spans in the AST, so to allow the\n-        // caller to not have to panic (and it can't catch it since the CodeMap\n-        // isn't sendable), return None\n         if begin.fm.start_pos != end.fm.start_pos {\n-            None\n+            return Err(SpanSnippetError::DistinctSources(DistinctSources {\n+                begin: (begin.fm.name.clone(),\n+                        begin.fm.start_pos),\n+                end: (end.fm.name.clone(),\n+                      end.fm.start_pos)\n+            }));\n         } else {\n-            Some((&begin.fm.src[begin.pos.to_usize()..end.pos.to_usize()]).to_string())\n+            let start = begin.pos.to_usize();\n+            let limit = end.pos.to_usize();\n+            if start > limit || limit > begin.fm.src.len() {\n+                return Err(SpanSnippetError::MalformedForCodemap(\n+                    MalformedCodemapPositions {\n+                        name: begin.fm.name.clone(),\n+                        source_len: begin.fm.src.len(),\n+                        begin_pos: begin.pos,\n+                        end_pos: end.pos,\n+                    }));\n+            }\n+\n+            return Ok((&begin.fm.src[start..limit]).to_string())\n         }\n     }\n \n@@ -622,6 +639,27 @@ impl CodeMap {\n     }\n }\n \n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub enum SpanSnippetError {\n+    IllFormedSpan(Span),\n+    DistinctSources(DistinctSources),\n+    MalformedForCodemap(MalformedCodemapPositions),\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub struct DistinctSources {\n+    begin: (String, BytePos),\n+    end: (String, BytePos)\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub struct MalformedCodemapPositions {\n+    name: String,\n+    source_len: usize,\n+    begin_pos: BytePos,\n+    end_pos: BytePos\n+}\n+\n #[cfg(test)]\n mod test {\n     use super::*;\n@@ -773,7 +811,7 @@ mod test {\n         let span = Span {lo: BytePos(12), hi: BytePos(23), expn_id: NO_EXPANSION};\n         let snippet = cm.span_to_snippet(span);\n \n-        assert_eq!(snippet, Some(\"second line\".to_string()));\n+        assert_eq!(snippet, Ok(\"second line\".to_string()));\n     }\n \n     #[test]"}, {"sha": "a93ddbb23793b8257fba5309be59e5906c0a0684", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -109,7 +109,7 @@ static KNOWN_FEATURES: &'static [(&'static str, &'static str, Status)] = &[\n     // int and uint are now deprecated\n     (\"int_uint\", \"1.0.0\", Active),\n \n-    // macro reexport needs more discusion and stabilization\n+    // macro reexport needs more discussion and stabilization\n     (\"macro_reexport\", \"1.0.0\", Active),\n \n     // These are used to test this portion of the compiler, they don't actually\n@@ -149,7 +149,10 @@ pub struct Features {\n     pub old_orphan_check: bool,\n     pub simd_ffi: bool,\n     pub unmarked_api: bool,\n-    pub lib_features: Vec<(InternedString, Span)>\n+    /// spans of #![feature] attrs for stable language features. for error reporting\n+    pub declared_stable_lang_features: Vec<Span>,\n+    /// #![feature] attrs for non-language (library) features\n+    pub declared_lib_features: Vec<(InternedString, Span)>\n }\n \n impl Features {\n@@ -162,7 +165,8 @@ impl Features {\n             old_orphan_check: false,\n             simd_ffi: false,\n             unmarked_api: false,\n-            lib_features: Vec::new()\n+            declared_stable_lang_features: Vec::new(),\n+            declared_lib_features: Vec::new()\n         }\n     }\n }\n@@ -511,6 +515,7 @@ fn check_crate_inner<F>(cm: &CodeMap, span_handler: &SpanHandler, krate: &ast::C\n         cm: cm,\n     };\n \n+    let mut accepted_features = Vec::new();\n     let mut unknown_features = Vec::new();\n \n     for attr in &krate.attrs {\n@@ -550,8 +555,7 @@ fn check_crate_inner<F>(cm: &CodeMap, span_handler: &SpanHandler, krate: &ast::C\n                             span_handler.span_err(mi.span, \"feature has been removed\");\n                         }\n                         Some(&(_, _, Accepted)) => {\n-                            span_handler.span_warn(mi.span, \"feature has been added to Rust, \\\n-                                                             directive not necessary\");\n+                            accepted_features.push(mi.span);\n                         }\n                         None => {\n                             unknown_features.push((name, mi.span));\n@@ -572,7 +576,8 @@ fn check_crate_inner<F>(cm: &CodeMap, span_handler: &SpanHandler, krate: &ast::C\n         old_orphan_check: cx.has_feature(\"old_orphan_check\"),\n         simd_ffi: cx.has_feature(\"simd_ffi\"),\n         unmarked_api: cx.has_feature(\"unmarked_api\"),\n-        lib_features: unknown_features\n+        declared_stable_lang_features: accepted_features,\n+        declared_lib_features: unknown_features\n     }\n }\n "}, {"sha": "694da9b8b28fee0a43e87a1d9792ff549517829b", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -560,7 +560,7 @@ fn filtered_float_lit(data: token::InternedString, suffix: Option<&str>,\n }\n pub fn float_lit(s: &str, suffix: Option<&str>, sd: &SpanHandler, sp: Span) -> ast::Lit_ {\n     debug!(\"float_lit: {:?}, {:?}\", s, suffix);\n-    // FIXME #2252: bounds checking float literals is defered until trans\n+    // FIXME #2252: bounds checking float literals is deferred until trans\n     let s = s.chars().filter(|&c| c != '_').collect::<String>();\n     let data = token::intern_and_get_ident(&*s);\n     filtered_float_lit(data, suffix, sd, sp)\n@@ -1233,8 +1233,8 @@ mod test {\n         let span = tts.iter().rev().next().unwrap().get_span();\n \n         match sess.span_diagnostic.cm.span_to_snippet(span) {\n-            Some(s) => assert_eq!(&s[], \"{ body }\"),\n-            None => panic!(\"could not get snippet\"),\n+            Ok(s) => assert_eq!(&s[], \"{ body }\"),\n+            Err(_) => panic!(\"could not get snippet\"),\n         }\n     }\n }"}, {"sha": "1df2e762ee748de0177a9778f3caef2f2c64fd52", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -63,15 +63,15 @@ impl<'a> ParserObsoleteMethods for parser::Parser<'a> {\n                 \"use a `move ||` expression instead\",\n             ),\n             ObsoleteSyntax::ClosureType => (\n-                \"`|usize| -> bool` closure type syntax\",\n+                \"`|usize| -> bool` closure type\",\n                 \"use unboxed closures instead, no type annotation needed\"\n             ),\n             ObsoleteSyntax::ClosureKind => (\n-                \"`:`, `&mut:`, or `&:` syntax\",\n+                \"`:`, `&mut:`, or `&:`\",\n                 \"rely on inference instead\"\n             ),\n             ObsoleteSyntax::Sized => (\n-                \"`Sized? T` syntax for removing the `Sized` bound\",\n+                \"`Sized? T` for removing the `Sized` bound\",\n                 \"write `T: ?Sized` instead\"\n             ),\n         };"}, {"sha": "b756602ead4f43286408ad769742f79e4fc32934", "filename": "src/rt/rust_builtin.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Frt%2Frust_builtin.c", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Frt%2Frust_builtin.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.c?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -205,7 +205,7 @@ int *__dfly_error(void) { return __error(); }\n #include <sys/sysctl.h>\n #include <limits.h>\n \n-const char * rust_load_self() {\n+const char * rust_current_exe() {\n     static char *self = NULL;\n \n     if (self == NULL) {"}, {"sha": "6ee8230e9f8baeab4b1bd35d05c521fcc488caaf", "filename": "src/rustbook/javascript.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Frustbook%2Fjavascript.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Frustbook%2Fjavascript.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fjavascript.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -43,7 +43,7 @@ document.addEventListener(\"DOMContentLoaded\", function(event) {\n   // of each of the sections.\n   // It works by extracting the current page based on the url and iterates over\n   // the menu links until it finds the menu item for the current page. We then\n-  // create a copy of the preceeding and following menu links and add the\n+  // create a copy of the preceding and following menu links and add the\n   // correct css class and insert them into the bottom of the page.\n   var toc = document.getElementById('toc').getElementsByTagName('a');\n   var href = document.location.pathname.split('/').pop();"}, {"sha": "944383199543f3972925bfc6a50a0325d02d1c4b", "filename": "src/test/bench/shootout-reverse-complement.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -90,12 +90,12 @@ impl Tables {\n         }\n     }\n \n-    /// Retreives the complement for `i`.\n+    /// Retrieves the complement for `i`.\n     fn cpl8(&self, i: u8) -> u8 {\n         self.table8[i as uint]\n     }\n \n-    /// Retreives the complement for `i`.\n+    /// Retrieves the complement for `i`.\n     fn cpl16(&self, i: u16) -> u16 {\n         self.table16[i as uint]\n     }"}, {"sha": "e68c3e30b9a7b08f5a4da6c097a0e929fc644c07", "filename": "src/test/compile-fail/assoc-inherent.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Ftest%2Fcompile-fail%2Fassoc-inherent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Ftest%2Fcompile-fail%2Fassoc-inherent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassoc-inherent.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Test associated types are forbidden in inherant impls.\n+// Test associated types are forbidden in inherent impls.\n \n struct Foo;\n "}, {"sha": "5baafd4153159f3f6b27b31c5b0042720c51484e", "filename": "src/test/compile-fail/gated-bad-feature.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Ftest%2Fcompile-fail%2Fgated-bad-feature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Ftest%2Fcompile-fail%2Fgated-bad-feature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fgated-bad-feature.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -20,4 +20,3 @@\n #![feature = \"foo\"] //~ ERROR: malformed feature\n \n #![feature(test_removed_feature)] //~ ERROR: feature has been removed\n-#![feature(test_accepted_feature)] //~ WARNING: feature has been added"}, {"sha": "f768d6c00ecdb1df44ed1d4e34e31db1866ac42b", "filename": "src/test/compile-fail/issue-21974.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Ftest%2Fcompile-fail%2Fissue-21974.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Ftest%2Fcompile-fail%2Fissue-21974.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-21974.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that (for now) we report an ambiguity error here, because\n+// specific trait relationships are ignored for the purposes of trait\n+// matching. This behavior should likely be improved such that this\n+// test passes. See #21974 for more details.\n+\n+trait Foo {\n+    fn foo(self);\n+}\n+\n+fn foo<'a,'b,T>(x: &'a T, y: &'b T)\n+    where &'a T : Foo,\n+          &'b T : Foo\n+{\n+    x.foo(); //~ ERROR type annotations required\n+    y.foo();\n+}\n+\n+fn main() { }"}, {"sha": "465a38111babcc63e81360df74680502e6fe02f0", "filename": "src/test/compile-fail/issue-7364.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Ftest%2Fcompile-fail%2Fissue-7364.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Ftest%2Fcompile-fail%2Fissue-7364.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7364.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -12,7 +12,7 @@\n \n use std::cell::RefCell;\n \n-// Regresion test for issue 7364\n+// Regression test for issue 7364\n static boxed: Box<RefCell<isize>> = box RefCell::new(0);\n //~^ ERROR statics are not allowed to have custom pointers\n //~| ERROR: the trait `core::marker::Sync` is not implemented for the type"}, {"sha": "7424a45d04405aa2ea2997a43304c5fa12467c18", "filename": "src/test/compile-fail/issue-9243.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Ftest%2Fcompile-fail%2Fissue-9243.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Ftest%2Fcompile-fail%2Fissue-9243.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-9243.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Regresion test for issue 9243\n+// Regression test for issue 9243\n \n struct Test {\n     mem: isize,"}, {"sha": "b1bb28f7ce7164e920bf5c043f3eae8a5782d49e", "filename": "src/test/compile-fail/lint-dead-code-1.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Ftest%2Fcompile-fail%2Flint-dead-code-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Ftest%2Fcompile-fail%2Flint-dead-code-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-dead-code-1.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -12,7 +12,6 @@\n #![allow(unused_variables)]\n #![allow(non_camel_case_types)]\n #![allow(non_upper_case_globals)]\n-#![allow(missing_copy_implementations)]\n #![deny(dead_code)]\n #![feature(core)]\n "}, {"sha": "3b96fd64fa200e8f3d397bd69e6283a4f066fdfc", "filename": "src/test/compile-fail/lint-missing-doc.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Ftest%2Fcompile-fail%2Flint-missing-doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Ftest%2Fcompile-fail%2Flint-missing-doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-missing-doc.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -12,7 +12,6 @@\n // injected intrinsics by the compiler.\n #![deny(missing_docs)]\n #![allow(dead_code)]\n-#![allow(missing_copy_implementations)]\n \n //! Some garbage docs for the crate here\n #![doc=\"More garbage\"]"}, {"sha": "ddc9081e33bb6f235a45a633d6cc65e6e6e32292", "filename": "src/test/compile-fail/missing_debug_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Ftest%2Fcompile-fail%2Fmissing_debug_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Ftest%2Fcompile-fail%2Fmissing_debug_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmissing_debug_impls.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -10,7 +10,7 @@\n \n // compile-flags: --crate-type lib\n #![deny(missing_debug_implementations)]\n-#![allow(unused, missing_copy_implementations)]\n+#![allow(unused)]\n \n use std::fmt;\n "}, {"sha": "30eb4112c3fb2e40a0814f1baff9baf825163d3c", "filename": "src/test/compile-fail/stable-features.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Ftest%2Fcompile-fail%2Fstable-features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Ftest%2Fcompile-fail%2Fstable-features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstable-features.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Testing that the stable_features lint catches use of stable\n+// language and lib features.\n+\n+#![deny(stable_features)]\n+#![feature(test_accepted_feature)] //~ ERROR this feature is stable\n+#![feature(rust1)] //~ ERROR this feature is stable\n+\n+fn main() {\n+    let _foo: Vec<()> = Vec::new();\n+}"}, {"sha": "b8c52378554bacef36952bf19fc48cdc511e477e", "filename": "src/test/run-make/alloc-extern-crates/Makefile", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Ftest%2Frun-make%2Falloc-extern-crates%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Ftest%2Frun-make%2Falloc-extern-crates%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Falloc-extern-crates%2FMakefile?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -0,0 +1,5 @@\n+-include ../tools.mk\n+\n+all:\n+\t$(RUSTC) fakealloc.rs\n+\t$(RUSTC) ../../../liballoc/lib.rs --cfg feature=\\\"external_crate\\\" --extern external=$(TMPDIR)/$(shell $(RUSTC) --print file-names fakealloc.rs)"}, {"sha": "563a527b9419493492d8e20916fd22d7fb44cfb4", "filename": "src/test/run-make/alloc-extern-crates/fakealloc.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Ftest%2Frun-make%2Falloc-extern-crates%2Ffakealloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Ftest%2Frun-make%2Falloc-extern-crates%2Ffakealloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Falloc-extern-crates%2Ffakealloc.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"rlib\"]\n+#![no_std]\n+#![feature(core)]\n+extern crate core;\n+\n+\n+#[inline]\n+pub unsafe fn allocate(_size: usize, _align: usize) -> *mut u8 { 0 as *mut u8 }\n+\n+#[inline]\n+pub unsafe fn deallocate(_ptr: *mut u8, _old_size: usize, _align: usize) { }\n+\n+#[inline]\n+pub unsafe fn reallocate(_ptr: *mut u8, _old_size: usize, _size: usize, _align: usize) -> *mut u8 {\n+    0 as *mut u8\n+}\n+\n+#[inline]\n+pub unsafe fn reallocate_inplace(_ptr: *mut u8, old_size: usize, _size: usize,\n+                                    _align: usize) -> usize { old_size }\n+\n+#[inline]\n+pub fn usable_size(size: usize, _align: usize) -> usize { size }\n+\n+#[inline]\n+pub fn stats_print() { }"}, {"sha": "d90219b4221ebcc83a68a62abb6245a2b08c02a5", "filename": "src/test/run-make/save-analysis/foo.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -17,7 +17,6 @@ extern crate graphviz;\n \n extern crate \"flate\" as myflate;\n \n-use graphviz::maybe_owned_vec::MaybeOwnedVector;\n use std::collections::{HashMap,HashSet};\n use std::cell::RefCell;\n use std::old_io::stdio::println;\n@@ -35,7 +34,7 @@ use std::mem::size_of;\n static uni: &'static str = \"Les Mis\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9rables\";\n static yy: usize = 25us;\n \n-static bob: Option<graphviz::maybe_owned_vec::MaybeOwnedVector<'static, isize>> = None;\n+static bob: Option<std::vec::CowVec<'static, isize>> = None;\n \n // buglink test - see issue #1337.\n "}, {"sha": "8b7ea61dc77e9cec9d560c2ea9f88485bf955a91", "filename": "src/test/run-pass/associated-types-duplicate-binding-in-env-hrtb.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Ftest%2Frun-pass%2Fassociated-types-duplicate-binding-in-env-hrtb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Ftest%2Frun-pass%2Fassociated-types-duplicate-binding-in-env-hrtb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-duplicate-binding-in-env-hrtb.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that we do not report ambiguities when equivalent predicates\n+// (modulo bound lifetime names) appears in the environment\n+// twice. Issue #21965.\n+\n+fn foo<T>(t: T) -> i32\n+    where T : for<'a> Fn(&'a u8) -> i32,\n+          T : for<'b> Fn(&'b u8) -> i32,\n+{\n+    t(&3)\n+}\n+\n+fn main() {\n+}"}, {"sha": "62ac21879520bf324e29fa056a0a6cb4e144672d", "filename": "src/test/run-pass/associated-types-duplicate-binding-in-env.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Ftest%2Frun-pass%2Fassociated-types-duplicate-binding-in-env.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Ftest%2Frun-pass%2Fassociated-types-duplicate-binding-in-env.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-duplicate-binding-in-env.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that we do not report ambiguities when the same predicate\n+// appears in the environment twice. Issue #21965.\n+\n+trait Foo {\n+    type B;\n+\n+    fn get() -> Self::B;\n+}\n+\n+fn foo<T>() -> ()\n+    where T : Foo<B=()>, T : Foo<B=()>\n+{\n+    <T as Foo>::get()\n+}\n+\n+fn main() {\n+}"}, {"sha": "d6e6f23191e240dd0e26096f0423277dd399011a", "filename": "src/test/run-pass/issue-21891.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Ftest%2Frun-pass%2Fissue-21891.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Ftest%2Frun-pass%2Fissue-21891.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-21891.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+static foo: [uint; 3] = [1, 2, 3];\n+\n+static slice_1: &'static [uint] = &foo;\n+static slice_2: &'static [uint] = &foo;\n+\n+fn main() {}"}, {"sha": "9e36b1f5082d03dad3f1a48bc3ed9a38326eb600", "filename": "src/test/run-pass/issue-7660.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Ftest%2Frun-pass%2Fissue-7660.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Ftest%2Frun-pass%2Fissue-7660.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-7660.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Regresion test for issue 7660\n+// Regression test for issue 7660\n // rvalue lifetime too short when equivalent `match` works\n \n extern crate collections;"}, {"sha": "bf789d5364500df680752103028111dccdb92c33", "filename": "src/test/run-pass/regions-mock-tcx.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Ftest%2Frun-pass%2Fregions-mock-tcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3732a12e896ab98aa27eaffab99a78bbaf837e4/src%2Ftest%2Frun-pass%2Fregions-mock-tcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-mock-tcx.rs?ref=d3732a12e896ab98aa27eaffab99a78bbaf837e4", "patch": "@@ -21,7 +21,7 @@ extern crate libc;\n \n use TypeStructure::{TypeInt, TypeFunction};\n use AstKind::{ExprInt, ExprVar, ExprLambda};\n-use arena::Arena;\n+use arena::TypedArena;\n use std::collections::HashMap;\n use std::mem;\n \n@@ -45,17 +45,20 @@ impl<'tcx> PartialEq for TypeStructure<'tcx> {\n \n impl<'tcx> Eq for TypeStructure<'tcx> {}\n \n+type TyArena<'tcx> = TypedArena<TypeStructure<'tcx>>;\n+type AstArena<'ast> = TypedArena<AstStructure<'ast>>;\n+\n struct TypeContext<'tcx, 'ast> {\n-    ty_arena: &'tcx Arena,\n+    ty_arena: &'tcx TyArena<'tcx>,\n     types: Vec<Type<'tcx>> ,\n     type_table: HashMap<NodeId, Type<'tcx>>,\n \n-    ast_arena: &'ast Arena,\n+    ast_arena: &'ast AstArena<'ast>,\n     ast_counter: uint,\n }\n \n impl<'tcx,'ast> TypeContext<'tcx, 'ast> {\n-    fn new(ty_arena: &'tcx Arena, ast_arena: &'ast Arena)\n+    fn new(ty_arena: &'tcx TyArena<'tcx>, ast_arena: &'ast AstArena<'ast>)\n            -> TypeContext<'tcx, 'ast> {\n         TypeContext { ty_arena: ty_arena,\n                       types: Vec::new(),\n@@ -72,7 +75,7 @@ impl<'tcx,'ast> TypeContext<'tcx, 'ast> {\n             }\n         }\n \n-        let ty = self.ty_arena.alloc(|| s);\n+        let ty = self.ty_arena.alloc(s);\n         self.types.push(ty);\n         ty\n     }\n@@ -85,7 +88,7 @@ impl<'tcx,'ast> TypeContext<'tcx, 'ast> {\n     fn ast(&mut self, a: AstKind<'ast>) -> Ast<'ast> {\n         let id = self.ast_counter;\n         self.ast_counter += 1;\n-        self.ast_arena.alloc(|| AstStructure { id: NodeId {id:id}, kind: a })\n+        self.ast_arena.alloc(AstStructure { id: NodeId {id:id}, kind: a })\n     }\n }\n \n@@ -127,8 +130,8 @@ fn compute_types<'tcx,'ast>(tcx: &mut TypeContext<'tcx,'ast>,\n }\n \n pub fn main() {\n-    let ty_arena = arena::Arena::new();\n-    let ast_arena = arena::Arena::new();\n+    let ty_arena = TypedArena::new();\n+    let ast_arena = TypedArena::new();\n     let mut tcx = TypeContext::new(&ty_arena, &ast_arena);\n     let ast = tcx.ast(ExprInt);\n     let ty = compute_types(&mut tcx, ast);"}]}