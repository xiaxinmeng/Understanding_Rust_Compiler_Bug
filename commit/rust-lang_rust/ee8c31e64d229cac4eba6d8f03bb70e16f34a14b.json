{"sha": "ee8c31e64d229cac4eba6d8f03bb70e16f34a14b", "node_id": "C_kwDOAAsO6NoAKGVlOGMzMWU2NGQyMjljYWM0ZWJhNmQ4ZjAzYmI3MGUxNmYzNGExNGI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-22T08:32:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-22T08:32:41Z"}, "message": "Auto merge of #100868 - Dylan-DPC:rollup-a1hfi1r, r=Dylan-DPC\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #93162 (Std module docs improvements)\n - #99386 (Add tests that check `Vec::retain` predicate execution order.)\n - #99915 (Recover keywords in trait bounds)\n - #100694 (Migrate rustc_ast_passes diagnostics to `SessionDiagnostic` and translatable messages (first part))\n - #100757 (Catch overflow early)\n\nFailed merges:\n\n - #99917 (Move Error trait into core)\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "0c9ff6127f19cacf68070cea3a978ca3a01d9c4d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c9ff6127f19cacf68070cea3a978ca3a01d9c4d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b", "html_url": "https://github.com/rust-lang/rust/commit/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9bb589cd678e034d194193fa892942315b10e2a", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9bb589cd678e034d194193fa892942315b10e2a", "html_url": "https://github.com/rust-lang/rust/commit/a9bb589cd678e034d194193fa892942315b10e2a"}, {"sha": "88e39b2c2e875d78f8c04fe8c6a52a6a48632af5", "url": "https://api.github.com/repos/rust-lang/rust/commits/88e39b2c2e875d78f8c04fe8c6a52a6a48632af5", "html_url": "https://github.com/rust-lang/rust/commit/88e39b2c2e875d78f8c04fe8c6a52a6a48632af5"}], "stats": {"total": 1299, "additions": 957, "deletions": 342}, "files": [{"sha": "cb245ce0ff828ef01c6b0cea39b7beec89a5fc85", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=ee8c31e64d229cac4eba6d8f03bb70e16f34a14b", "patch": "@@ -3595,6 +3595,7 @@ dependencies = [\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n  \"rustc_feature\",\n+ \"rustc_macros\",\n  \"rustc_parse\",\n  \"rustc_session\",\n  \"rustc_span\","}, {"sha": "37eff9207c128688b02768b9bddfac6c9b360719", "filename": "compiler/rustc_ast_passes/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/compiler%2Frustc_ast_passes%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/compiler%2Frustc_ast_passes%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2FCargo.toml?ref=ee8c31e64d229cac4eba6d8f03bb70e16f34a14b", "patch": "@@ -11,6 +11,7 @@ rustc_attr = { path = \"../rustc_attr\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_errors = { path = \"../rustc_errors\" }\n rustc_feature = { path = \"../rustc_feature\" }\n+rustc_macros = { path = \"../rustc_macros\" }\n rustc_parse = { path = \"../rustc_parse\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }"}, {"sha": "b337e5328c5df6af4c75ae61acfd3739ca616360", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 80, "deletions": 168, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=ee8c31e64d229cac4eba6d8f03bb70e16f34a14b", "patch": "@@ -13,7 +13,7 @@ use rustc_ast::walk_list;\n use rustc_ast::*;\n use rustc_ast_pretty::pprust::{self, State};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::{error_code, pluralize, struct_span_err, Applicability, Diagnostic};\n+use rustc_errors::{error_code, fluent, pluralize, struct_span_err, Applicability};\n use rustc_parse::validate_attr;\n use rustc_session::lint::builtin::{\n     DEPRECATED_WHERE_CLAUSE_LOCATION, MISSING_ABI, PATTERNS_IN_FNS_WITHOUT_BODY,\n@@ -27,6 +27,8 @@ use rustc_target::spec::abi;\n use std::mem;\n use std::ops::{Deref, DerefMut};\n \n+use crate::errors::*;\n+\n const MORE_EXTERN: &str =\n     \"for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\";\n \n@@ -117,23 +119,7 @@ impl<'a> AstValidator<'a> {\n \n     /// Emits an error banning the `let` expression provided in the given location.\n     fn ban_let_expr(&self, expr: &'a Expr, forbidden_let_reason: ForbiddenLetReason) {\n-        let err = \"`let` expressions are not supported here\";\n-        let mut diag = self.session.struct_span_err(expr.span, err);\n-        diag.note(\"only supported directly in conditions of `if` and `while` expressions\");\n-        match forbidden_let_reason {\n-            ForbiddenLetReason::GenericForbidden => {}\n-            ForbiddenLetReason::NotSupportedOr(span) => {\n-                diag.span_note(span, \"`||` operators are not supported in let chain expressions\");\n-            }\n-            ForbiddenLetReason::NotSupportedParentheses(span) => {\n-                diag.span_note(\n-                    span,\n-                    \"`let`s wrapped in parentheses are not supported in a context with let \\\n-                    chains\",\n-                );\n-            }\n-        }\n-        diag.emit();\n+        self.session.emit_err(ForbiddenLet { span: expr.span, reason: forbidden_let_reason });\n     }\n \n     fn check_gat_where(\n@@ -163,7 +149,7 @@ impl<'a> AstValidator<'a> {\n                 DEPRECATED_WHERE_CLAUSE_LOCATION,\n                 id,\n                 where_clauses.0.1,\n-                \"where clause not allowed here\",\n+                fluent::ast_passes::deprecated_where_clause_location,\n                 BuiltinLintDiagnostics::DeprecatedWhereclauseLocation(\n                     where_clauses.1.1.shrink_to_hi(),\n                     suggestion,\n@@ -193,10 +179,7 @@ impl<'a> AstValidator<'a> {\n             AssocConstraintKind::Equality { .. } => {}\n             AssocConstraintKind::Bound { .. } => {\n                 if self.is_assoc_ty_bound_banned {\n-                    self.err_handler().span_err(\n-                        constraint.span,\n-                        \"associated type bounds are not allowed within structs, enums, or unions\",\n-                    );\n+                    self.session.emit_err(ForbiddenAssocConstraint { span: constraint.span });\n                 }\n             }\n         }\n@@ -268,31 +251,26 @@ impl<'a> AstValidator<'a> {\n     fn check_lifetime(&self, ident: Ident) {\n         let valid_names = [kw::UnderscoreLifetime, kw::StaticLifetime, kw::Empty];\n         if !valid_names.contains(&ident.name) && ident.without_first_quote().is_reserved() {\n-            self.err_handler().span_err(ident.span, \"lifetimes cannot use keyword names\");\n+            self.session.emit_err(KeywordLifetime { span: ident.span });\n         }\n     }\n \n     fn check_label(&self, ident: Ident) {\n         if ident.without_first_quote().is_reserved() {\n-            self.err_handler()\n-                .span_err(ident.span, &format!(\"invalid label name `{}`\", ident.name));\n+            self.session.emit_err(InvalidLabel { span: ident.span, name: ident.name });\n         }\n     }\n \n-    fn invalid_visibility(&self, vis: &Visibility, note: Option<&str>) {\n+    fn invalid_visibility(&self, vis: &Visibility, note: Option<InvalidVisibilityNote>) {\n         if let VisibilityKind::Inherited = vis.kind {\n             return;\n         }\n \n-        let mut err =\n-            struct_span_err!(self.session, vis.span, E0449, \"unnecessary visibility qualifier\");\n-        if vis.kind.is_pub() {\n-            err.span_label(vis.span, \"`pub` not permitted here because it's implied\");\n-        }\n-        if let Some(note) = note {\n-            err.note(note);\n-        }\n-        err.emit();\n+        self.session.emit_err(InvalidVisibility {\n+            span: vis.span,\n+            implied: if vis.kind.is_pub() { Some(vis.span) } else { None },\n+            note,\n+        });\n     }\n \n     fn check_decl_no_pat(decl: &FnDecl, mut report_err: impl FnMut(Span, Option<Ident>, bool)) {\n@@ -309,29 +287,13 @@ impl<'a> AstValidator<'a> {\n \n     fn check_trait_fn_not_async(&self, fn_span: Span, asyncness: Async) {\n         if let Async::Yes { span, .. } = asyncness {\n-            struct_span_err!(\n-                self.session,\n-                fn_span,\n-                E0706,\n-                \"functions in traits cannot be declared `async`\"\n-            )\n-            .span_label(span, \"`async` because of this\")\n-            .note(\"`async` trait functions are not currently supported\")\n-            .note(\"consider using the `async-trait` crate: https://crates.io/crates/async-trait\")\n-            .emit();\n+            self.session.emit_err(TraitFnAsync { fn_span, span });\n         }\n     }\n \n     fn check_trait_fn_not_const(&self, constness: Const) {\n         if let Const::Yes(span) = constness {\n-            struct_span_err!(\n-                self.session,\n-                span,\n-                E0379,\n-                \"functions in traits cannot be declared const\"\n-            )\n-            .span_label(span, \"functions in traits cannot be const\")\n-            .emit();\n+            self.session.emit_err(TraitFnConst { span });\n         }\n     }\n \n@@ -344,19 +306,15 @@ impl<'a> AstValidator<'a> {\n                 GenericParamKind::Lifetime { .. } => {\n                     if !param.bounds.is_empty() {\n                         let spans: Vec<_> = param.bounds.iter().map(|b| b.span()).collect();\n-                        self.err_handler()\n-                            .span_err(spans, \"lifetime bounds cannot be used in this context\");\n+                        self.session.emit_err(ForbiddenLifetimeBound { spans });\n                     }\n                     None\n                 }\n                 _ => Some(param.ident.span),\n             })\n             .collect();\n         if !non_lt_param_spans.is_empty() {\n-            self.err_handler().span_err(\n-                non_lt_param_spans,\n-                \"only lifetime parameters can be used in this context\",\n-            );\n+            self.session.emit_err(ForbiddenNonLifetimeParam { spans: non_lt_param_spans });\n         }\n     }\n \n@@ -373,30 +331,21 @@ impl<'a> AstValidator<'a> {\n         let max_num_args: usize = u16::MAX.into();\n         if fn_decl.inputs.len() > max_num_args {\n             let Param { span, .. } = fn_decl.inputs[0];\n-            self.err_handler().span_fatal(\n-                span,\n-                &format!(\"function can not have more than {} arguments\", max_num_args),\n-            );\n+            self.session.emit_fatal(FnParamTooMany { span, max_num_args });\n         }\n     }\n \n     fn check_decl_cvaradic_pos(&self, fn_decl: &FnDecl) {\n         match &*fn_decl.inputs {\n             [Param { ty, span, .. }] => {\n                 if let TyKind::CVarArgs = ty.kind {\n-                    self.err_handler().span_err(\n-                        *span,\n-                        \"C-variadic function must be declared with at least one named argument\",\n-                    );\n+                    self.session.emit_err(FnParamCVarArgsOnly { span: *span });\n                 }\n             }\n             [ps @ .., _] => {\n                 for Param { ty, span, .. } in ps {\n                     if let TyKind::CVarArgs = ty.kind {\n-                        self.err_handler().span_err(\n-                            *span,\n-                            \"`...` must be the last argument of a C-variadic function\",\n-                        );\n+                        self.session.emit_err(FnParamCVarArgsNotLast { span: *span });\n                     }\n                 }\n             }\n@@ -423,82 +372,38 @@ impl<'a> AstValidator<'a> {\n             })\n             .for_each(|attr| {\n                 if attr.is_doc_comment() {\n-                    self.err_handler()\n-                        .struct_span_err(\n-                            attr.span,\n-                            \"documentation comments cannot be applied to function parameters\",\n-                        )\n-                        .span_label(attr.span, \"doc comments are not allowed here\")\n-                        .emit();\n+                    self.session.emit_err(FnParamDocComment { span: attr.span });\n                 } else {\n-                    self.err_handler().span_err(\n-                        attr.span,\n-                        \"allow, cfg, cfg_attr, deny, expect, \\\n-                forbid, and warn are the only allowed built-in attributes in function parameters\",\n-                    );\n+                    self.session.emit_err(FnParamForbiddenAttr { span: attr.span });\n                 }\n             });\n     }\n \n     fn check_decl_self_param(&self, fn_decl: &FnDecl, self_semantic: SelfSemantic) {\n         if let (SelfSemantic::No, [param, ..]) = (self_semantic, &*fn_decl.inputs) {\n             if param.is_self() {\n-                self.err_handler()\n-                    .struct_span_err(\n-                        param.span,\n-                        \"`self` parameter is only allowed in associated functions\",\n-                    )\n-                    .span_label(param.span, \"not semantically valid as function parameter\")\n-                    .note(\"associated functions are those in `impl` or `trait` definitions\")\n-                    .emit();\n+                self.session.emit_err(FnParamForbiddenSelf { span: param.span });\n             }\n         }\n     }\n \n     fn check_defaultness(&self, span: Span, defaultness: Defaultness) {\n         if let Defaultness::Default(def_span) = defaultness {\n             let span = self.session.source_map().guess_head_span(span);\n-            self.err_handler()\n-                .struct_span_err(span, \"`default` is only allowed on items in trait impls\")\n-                .span_label(def_span, \"`default` because of this\")\n-                .emit();\n+            self.session.emit_err(ForbiddenDefault { span, def_span });\n         }\n     }\n \n-    fn error_item_without_body(&self, sp: Span, ctx: &str, msg: &str, sugg: &str) {\n-        self.error_item_without_body_with_help(sp, ctx, msg, sugg, |_| ());\n-    }\n-\n-    fn error_item_without_body_with_help(\n-        &self,\n-        sp: Span,\n-        ctx: &str,\n-        msg: &str,\n-        sugg: &str,\n-        help: impl FnOnce(&mut Diagnostic),\n-    ) {\n+    /// If `sp` ends with a semicolon, returns it as a `Span`\n+    /// Otherwise, returns `sp.shrink_to_hi()`\n+    fn ending_semi_or_hi(&self, sp: Span) -> Span {\n         let source_map = self.session.source_map();\n         let end = source_map.end_point(sp);\n-        let replace_span = if source_map.span_to_snippet(end).map(|s| s == \";\").unwrap_or(false) {\n+\n+        if source_map.span_to_snippet(end).map(|s| s == \";\").unwrap_or(false) {\n             end\n         } else {\n             sp.shrink_to_hi()\n-        };\n-        let mut err = self.err_handler().struct_span_err(sp, msg);\n-        err.span_suggestion(\n-            replace_span,\n-            &format!(\"provide a definition for the {}\", ctx),\n-            sugg,\n-            Applicability::HasPlaceholders,\n-        );\n-        help(&mut err);\n-        err.emit();\n-    }\n-\n-    fn check_impl_item_provided<T>(&self, sp: Span, body: &Option<T>, ctx: &str, sugg: &str) {\n-        if body.is_none() {\n-            let msg = format!(\"associated {} in `impl` without body\", ctx);\n-            self.error_item_without_body(sp, ctx, &msg, sugg);\n         }\n     }\n \n@@ -1168,7 +1073,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n \n                 self.invalid_visibility(\n                     &item.vis,\n-                    Some(\"place qualifiers on individual impl items instead\"),\n+                    Some(InvalidVisibilityNote::IndividualImplItems),\n                 );\n                 if let Unsafe::Yes(span) = unsafety {\n                     error(span, \"unsafe\").code(error_code!(E0197)).emit();\n@@ -1191,37 +1096,23 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 self.check_defaultness(item.span, defaultness);\n \n                 if body.is_none() {\n-                    let msg = \"free function without a body\";\n-                    let ext = sig.header.ext;\n-\n-                    let f = |e: &mut Diagnostic| {\n-                        if let Extern::Implicit(start_span) | Extern::Explicit(_, start_span) = &ext\n-                        {\n-                            let start_suggestion = if let Extern::Explicit(abi, _) = ext {\n-                                format!(\"extern \\\"{}\\\" {{\", abi.symbol_unescaped)\n-                            } else {\n-                                \"extern {\".to_owned()\n-                            };\n-\n-                            let end_suggestion = \" }\".to_owned();\n-                            let end_span = item.span.shrink_to_hi();\n-\n-                            e\n-                            .multipart_suggestion(\n-                                \"if you meant to declare an externally defined function, use an `extern` block\",\n-                                vec![(*start_span, start_suggestion), (end_span, end_suggestion)],\n-                                Applicability::MaybeIncorrect,\n-                             );\n-                        }\n-                    };\n-\n-                    self.error_item_without_body_with_help(\n-                        item.span,\n-                        \"function\",\n-                        msg,\n-                        \" { <body> }\",\n-                        f,\n-                    );\n+                    self.session.emit_err(FnWithoutBody {\n+                        span: item.span,\n+                        replace_span: self.ending_semi_or_hi(item.span),\n+                        extern_block_suggestion: match sig.header.ext {\n+                            Extern::None => None,\n+                            Extern::Implicit(start_span) => Some(ExternBlockSuggestion {\n+                                start_span,\n+                                end_span: item.span.shrink_to_hi(),\n+                                abi: None,\n+                            }),\n+                            Extern::Explicit(abi, start_span) => Some(ExternBlockSuggestion {\n+                                start_span,\n+                                end_span: item.span.shrink_to_hi(),\n+                                abi: Some(abi.symbol_unescaped),\n+                            }),\n+                        },\n+                    });\n                 }\n \n                 self.visit_vis(&item.vis);\n@@ -1236,7 +1127,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 let old_item = mem::replace(&mut self.extern_mod, Some(item));\n                 self.invalid_visibility(\n                     &item.vis,\n-                    Some(\"place qualifiers on individual foreign items instead\"),\n+                    Some(InvalidVisibilityNote::IndividualForeignItems),\n                 );\n                 if let Unsafe::Yes(span) = unsafety {\n                     self.err_handler().span_err(span, \"extern block cannot be declared unsafe\");\n@@ -1327,12 +1218,16 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             }\n             ItemKind::Const(def, .., None) => {\n                 self.check_defaultness(item.span, def);\n-                let msg = \"free constant item without body\";\n-                self.error_item_without_body(item.span, \"constant\", msg, \" = <expr>;\");\n+                self.session.emit_err(ConstWithoutBody {\n+                    span: item.span,\n+                    replace_span: self.ending_semi_or_hi(item.span),\n+                });\n             }\n             ItemKind::Static(.., None) => {\n-                let msg = \"free static item without body\";\n-                self.error_item_without_body(item.span, \"static\", msg, \" = <expr>;\");\n+                self.session.emit_err(StaticWithoutBody {\n+                    span: item.span,\n+                    replace_span: self.ending_semi_or_hi(item.span),\n+                });\n             }\n             ItemKind::TyAlias(box TyAlias {\n                 defaultness,\n@@ -1343,8 +1238,10 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             }) => {\n                 self.check_defaultness(item.span, defaultness);\n                 if ty.is_none() {\n-                    let msg = \"free type alias without body\";\n-                    self.error_item_without_body(item.span, \"type\", msg, \" = <type>;\");\n+                    self.session.emit_err(TyAliasWithoutBody {\n+                        span: item.span,\n+                        replace_span: self.ending_semi_or_hi(item.span),\n+                    });\n                 }\n                 self.check_type_no_bounds(bounds, \"this context\");\n                 if where_clauses.1.0 {\n@@ -1648,10 +1545,20 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         if ctxt == AssocCtxt::Impl {\n             match &item.kind {\n                 AssocItemKind::Const(_, _, body) => {\n-                    self.check_impl_item_provided(item.span, body, \"constant\", \" = <expr>;\");\n+                    if body.is_none() {\n+                        self.session.emit_err(AssocConstWithoutBody {\n+                            span: item.span,\n+                            replace_span: self.ending_semi_or_hi(item.span),\n+                        });\n+                    }\n                 }\n                 AssocItemKind::Fn(box Fn { body, .. }) => {\n-                    self.check_impl_item_provided(item.span, body, \"function\", \" { <body> }\");\n+                    if body.is_none() {\n+                        self.session.emit_err(AssocFnWithoutBody {\n+                            span: item.span,\n+                            replace_span: self.ending_semi_or_hi(item.span),\n+                        });\n+                    }\n                 }\n                 AssocItemKind::TyAlias(box TyAlias {\n                     generics,\n@@ -1661,7 +1568,12 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     ty,\n                     ..\n                 }) => {\n-                    self.check_impl_item_provided(item.span, ty, \"type\", \" = <type>;\");\n+                    if ty.is_none() {\n+                        self.session.emit_err(AssocTypeWithoutBody {\n+                            span: item.span,\n+                            replace_span: self.ending_semi_or_hi(item.span),\n+                        });\n+                    }\n                     self.check_type_no_bounds(bounds, \"`impl`s\");\n                     if ty.is_some() {\n                         self.check_gat_where(\n@@ -1876,7 +1788,7 @@ pub fn check_crate(session: &Session, krate: &Crate, lints: &mut LintBuffer) ->\n \n /// Used to forbid `let` expressions in certain syntactic locations.\n #[derive(Clone, Copy)]\n-enum ForbiddenLetReason {\n+pub(crate) enum ForbiddenLetReason {\n     /// `let` is not valid and the source environment is not important\n     GenericForbidden,\n     /// A let chain with the `||` operator"}, {"sha": "16ba14e9092168fda7ddcc2d768f1d9dbb176dff", "filename": "compiler/rustc_ast_passes/src/errors.rs", "status": "added", "additions": 248, "deletions": 0, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/compiler%2Frustc_ast_passes%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/compiler%2Frustc_ast_passes%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ferrors.rs?ref=ee8c31e64d229cac4eba6d8f03bb70e16f34a14b", "patch": "@@ -0,0 +1,248 @@\n+//! Errors emitted by ast_passes.\n+\n+use rustc_errors::{fluent, AddSubdiagnostic, Applicability, Diagnostic};\n+use rustc_macros::{SessionDiagnostic, SessionSubdiagnostic};\n+use rustc_span::{Span, Symbol};\n+\n+use crate::ast_validation::ForbiddenLetReason;\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::forbidden_let)]\n+#[note]\n+pub struct ForbiddenLet {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub(crate) reason: ForbiddenLetReason,\n+}\n+\n+impl AddSubdiagnostic for ForbiddenLetReason {\n+    fn add_to_diagnostic(self, diag: &mut Diagnostic) {\n+        match self {\n+            Self::GenericForbidden => {}\n+            Self::NotSupportedOr(span) => {\n+                diag.span_note(span, fluent::ast_passes::not_supported_or);\n+            }\n+            Self::NotSupportedParentheses(span) => {\n+                diag.span_note(span, fluent::ast_passes::not_supported_parentheses);\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::forbidden_assoc_constraint)]\n+pub struct ForbiddenAssocConstraint {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::keyword_lifetime)]\n+pub struct KeywordLifetime {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::invalid_label)]\n+pub struct InvalidLabel {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::invalid_visibility, code = \"E0449\")]\n+pub struct InvalidVisibility {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label(ast_passes::implied)]\n+    pub implied: Option<Span>,\n+    #[subdiagnostic]\n+    pub note: Option<InvalidVisibilityNote>,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+pub enum InvalidVisibilityNote {\n+    #[note(ast_passes::individual_impl_items)]\n+    IndividualImplItems,\n+    #[note(ast_passes::individual_foreign_items)]\n+    IndividualForeignItems,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::trait_fn_async, code = \"E0706\")]\n+#[note]\n+#[note(ast_passes::note2)]\n+pub struct TraitFnAsync {\n+    #[primary_span]\n+    pub fn_span: Span,\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::trait_fn_const, code = \"E0379\")]\n+pub struct TraitFnConst {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::forbidden_lifetime_bound)]\n+pub struct ForbiddenLifetimeBound {\n+    #[primary_span]\n+    pub spans: Vec<Span>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::forbidden_non_lifetime_param)]\n+pub struct ForbiddenNonLifetimeParam {\n+    #[primary_span]\n+    pub spans: Vec<Span>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::fn_param_too_many)]\n+pub struct FnParamTooMany {\n+    #[primary_span]\n+    pub span: Span,\n+    pub max_num_args: usize,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::fn_param_c_var_args_only)]\n+pub struct FnParamCVarArgsOnly {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::fn_param_c_var_args_not_last)]\n+pub struct FnParamCVarArgsNotLast {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::fn_param_doc_comment)]\n+pub struct FnParamDocComment {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::fn_param_forbidden_attr)]\n+pub struct FnParamForbiddenAttr {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::fn_param_forbidden_self)]\n+#[note]\n+pub struct FnParamForbiddenSelf {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::forbidden_default)]\n+pub struct ForbiddenDefault {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label]\n+    pub def_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::assoc_const_without_body)]\n+pub struct AssocConstWithoutBody {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(code = \" = <expr>;\", applicability = \"has-placeholders\")]\n+    pub replace_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::assoc_fn_without_body)]\n+pub struct AssocFnWithoutBody {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(code = \" {{ <body> }}\", applicability = \"has-placeholders\")]\n+    pub replace_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::assoc_type_without_body)]\n+pub struct AssocTypeWithoutBody {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(code = \" = <type>;\", applicability = \"has-placeholders\")]\n+    pub replace_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::const_without_body)]\n+pub struct ConstWithoutBody {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(code = \" = <expr>;\", applicability = \"has-placeholders\")]\n+    pub replace_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::static_without_body)]\n+pub struct StaticWithoutBody {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(code = \" = <expr>;\", applicability = \"has-placeholders\")]\n+    pub replace_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::ty_alias_without_body)]\n+pub struct TyAliasWithoutBody {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(code = \" = <type>;\", applicability = \"has-placeholders\")]\n+    pub replace_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::fn_without_body)]\n+pub struct FnWithoutBody {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(code = \" {{ <body> }}\", applicability = \"has-placeholders\")]\n+    pub replace_span: Span,\n+    #[subdiagnostic]\n+    pub extern_block_suggestion: Option<ExternBlockSuggestion>,\n+}\n+\n+pub struct ExternBlockSuggestion {\n+    pub start_span: Span,\n+    pub end_span: Span,\n+    pub abi: Option<Symbol>,\n+}\n+\n+impl AddSubdiagnostic for ExternBlockSuggestion {\n+    fn add_to_diagnostic(self, diag: &mut Diagnostic) {\n+        let start_suggestion = if let Some(abi) = self.abi {\n+            format!(\"extern \\\"{}\\\" {{\", abi)\n+        } else {\n+            \"extern {\".to_owned()\n+        };\n+        let end_suggestion = \" }\".to_owned();\n+\n+        diag.multipart_suggestion(\n+            fluent::ast_passes::extern_block_suggestion,\n+            vec![(self.start_span, start_suggestion), (self.end_span, end_suggestion)],\n+            Applicability::MaybeIncorrect,\n+        );\n+    }\n+}"}, {"sha": "6a8262989850cb23d6417bba225117c062d45547", "filename": "compiler/rustc_ast_passes/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs?ref=ee8c31e64d229cac4eba6d8f03bb70e16f34a14b", "patch": "@@ -12,6 +12,7 @@\n #![recursion_limit = \"256\"]\n \n pub mod ast_validation;\n+mod errors;\n pub mod feature_gate;\n pub mod node_count;\n pub mod show_span;"}, {"sha": "fd517c1e1213682b6227395cc3e80b1d484a9a43", "filename": "compiler/rustc_builtin_macros/src/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs?ref=ee8c31e64d229cac4eba6d8f03bb70e16f34a14b", "patch": "@@ -1176,7 +1176,7 @@ fn create_lints_for_named_arguments_used_positionally(cx: &mut Context<'_, '_>)\n \n         cx.ecx.buffered_early_lint.push(BufferedEarlyLint {\n             span: MultiSpan::from_span(named_arg.positional_named_arg_span),\n-            msg: msg.clone(),\n+            msg: msg.into(),\n             node_id: ast::CRATE_NODE_ID,\n             lint_id: LintId::of(&NAMED_ARGUMENTS_USED_POSITIONALLY),\n             diagnostic: BuiltinLintDiagnostics::NamedArgumentUsedPositionally {"}, {"sha": "db91a886c725e4ab9a0ebf0c52dd2df426fe28b5", "filename": "compiler/rustc_error_messages/locales/en-US/ast_passes.ftl", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fast_passes.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fast_passes.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fast_passes.ftl?ref=ee8c31e64d229cac4eba6d8f03bb70e16f34a14b", "patch": "@@ -0,0 +1,93 @@\n+ast_passes_forbidden_let =\n+    `let` expressions are not supported here\n+    .note = only supported directly in conditions of `if` and `while` expressions\n+    .not_supported_or = `||` operators are not supported in let chain expressions\n+    .not_supported_parentheses = `let`s wrapped in parentheses are not supported in a context with let chains\n+\n+ast_passes_deprecated_where_clause_location =\n+    where clause not allowed here\n+\n+ast_passes_forbidden_assoc_constraint =\n+    associated type bounds are not allowed within structs, enums, or unions\n+\n+ast_passes_keyword_lifetime =\n+    lifetimes cannot use keyword names\n+\n+ast_passes_invalid_label =\n+    invalid label name `{$name}`\n+\n+ast_passes_invalid_visibility =\n+    unnecessary visibility qualifier\n+    .implied = `pub` not permitted here because it's implied\n+    .individual_impl_items = place qualifiers on individual impl items instead\n+    .individual_foreign_items = place qualifiers on individual foreign items instead\n+\n+ast_passes_trait_fn_async =\n+    functions in traits cannot be declared `async`\n+    .label = `async` because of this\n+    .note = `async` trait functions are not currently supported\n+    .note2 = consider using the `async-trait` crate: https://crates.io/crates/async-trait\n+\n+ast_passes_trait_fn_const =\n+    functions in traits cannot be declared const\n+    .label = functions in traits cannot be const\n+\n+ast_passes_forbidden_lifetime_bound =\n+    lifetime bounds cannot be used in this context\n+\n+ast_passes_forbidden_non_lifetime_param =\n+    only lifetime parameters can be used in this context\n+\n+ast_passes_fn_param_too_many =\n+    function can not have more than {$max_num_args} arguments\n+\n+ast_passes_fn_param_c_var_args_only =\n+    C-variadic function must be declared with at least one named argument\n+\n+ast_passes_fn_param_c_var_args_not_last =\n+    `...` must be the last argument of a C-variadic function\n+\n+ast_passes_fn_param_doc_comment =\n+    documentation comments cannot be applied to function parameters\n+    .label = doc comments are not allowed here\n+\n+ast_passes_fn_param_forbidden_attr =\n+    allow, cfg, cfg_attr, deny, expect, forbid, and warn are the only allowed built-in attributes in function parameters\n+\n+ast_passes_fn_param_forbidden_self =\n+    `self` parameter is only allowed in associated functions\n+    .label = not semantically valid as function parameter\n+    .note = associated functions are those in `impl` or `trait` definitions\n+\n+ast_passes_forbidden_default =\n+    `default` is only allowed on items in trait impls\n+    .label = `default` because of this\n+\n+ast_passes_assoc_const_without_body =\n+    associated constant in `impl` without body\n+    .suggestion = provide a definition for the constant\n+\n+ast_passes_assoc_fn_without_body =\n+    associated function in `impl` without body\n+    .suggestion = provide a definition for the function\n+\n+ast_passes_assoc_type_without_body =\n+    associated type in `impl` without body\n+    .suggestion = provide a definition for the type\n+\n+ast_passes_const_without_body =\n+    free constant item without body\n+    .suggestion = provide a definition for the constant\n+\n+ast_passes_static_without_body =\n+    free static item without body\n+    .suggestion = provide a definition for the static\n+\n+ast_passes_ty_alias_without_body =\n+    free type alias without body\n+    .suggestion = provide a definition for the type\n+\n+ast_passes_fn_without_body =\n+    free function without a body\n+    .suggestion = provide a definition for the function\n+    .extern_block_suggestion = if you meant to declare an externally defined function, use an `extern` block"}, {"sha": "3569c7f0630649d36721b26478892c5f4579aebc", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=ee8c31e64d229cac4eba6d8f03bb70e16f34a14b", "patch": "@@ -32,6 +32,7 @@ pub use unic_langid::{langid, LanguageIdentifier};\n \n // Generates `DEFAULT_LOCALE_RESOURCES` static and `fluent_generated` module.\n fluent_messages! {\n+    ast_passes => \"../locales/en-US/ast_passes.ftl\",\n     borrowck => \"../locales/en-US/borrowck.ftl\",\n     builtin_macros => \"../locales/en-US/builtin_macros.ftl\",\n     const_eval => \"../locales/en-US/const_eval.ftl\","}, {"sha": "cdb5b3c4284a8d37afc0dd2f6bb7b4f8c3006937", "filename": "compiler/rustc_lint/src/early.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fearly.rs?ref=ee8c31e64d229cac4eba6d8f03bb70e16f34a14b", "patch": "@@ -45,7 +45,7 @@ impl<'a, T: EarlyLintPass> EarlyContextAndPass<'a, T> {\n                 lint_id.lint,\n                 Some(span),\n                 |lint| {\n-                    lint.build(&msg).emit();\n+                    lint.build(msg).emit();\n                 },\n                 diagnostic,\n             );"}, {"sha": "9e7cbba9511b206a85a76a6150a4af9bf483dc6c", "filename": "compiler/rustc_lint_defs/src/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs?ref=ee8c31e64d229cac4eba6d8f03bb70e16f34a14b", "patch": "@@ -9,7 +9,7 @@ pub use self::Level::*;\n use rustc_ast::node_id::{NodeId, NodeMap};\n use rustc_ast::{AttrId, Attribute};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher, ToStableHashKey};\n-use rustc_error_messages::MultiSpan;\n+use rustc_error_messages::{DiagnosticMessage, MultiSpan};\n use rustc_hir::HashStableContext;\n use rustc_hir::HirId;\n use rustc_span::edition::Edition;\n@@ -491,7 +491,7 @@ pub struct BufferedEarlyLint {\n     pub span: MultiSpan,\n \n     /// The lint message.\n-    pub msg: String,\n+    pub msg: DiagnosticMessage,\n \n     /// The `NodeId` of the AST node that generated the lint.\n     pub node_id: NodeId,\n@@ -520,11 +520,11 @@ impl LintBuffer {\n         lint: &'static Lint,\n         node_id: NodeId,\n         span: MultiSpan,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         diagnostic: BuiltinLintDiagnostics,\n     ) {\n         let lint_id = LintId::of(lint);\n-        let msg = msg.to_string();\n+        let msg = msg.into();\n         self.add_early_lint(BufferedEarlyLint { lint_id, node_id, span, msg, diagnostic });\n     }\n \n@@ -537,7 +537,7 @@ impl LintBuffer {\n         lint: &'static Lint,\n         id: NodeId,\n         sp: impl Into<MultiSpan>,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n     ) {\n         self.add_lint(lint, id, sp.into(), msg, BuiltinLintDiagnostics::Normal)\n     }\n@@ -547,7 +547,7 @@ impl LintBuffer {\n         lint: &'static Lint,\n         id: NodeId,\n         sp: impl Into<MultiSpan>,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         diagnostic: BuiltinLintDiagnostics,\n     ) {\n         self.add_lint(lint, id, sp.into(), msg, diagnostic)"}, {"sha": "ad9ecd39b9e85a29989670027afba4cdeed1bf97", "filename": "compiler/rustc_macros/src/diagnostics/utils.rs", "status": "modified", "additions": 32, "deletions": 27, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs?ref=ee8c31e64d229cac4eba6d8f03bb70e16f34a14b", "patch": "@@ -235,35 +235,40 @@ pub(crate) trait HasFieldMap {\n         // the referenced fields. Leaves `it` sitting on the closing brace of the format string, so\n         // the next call to `it.next()` retrieves the next character.\n         while let Some(c) = it.next() {\n-            if c == '{' && *it.peek().unwrap_or(&'\\0') != '{' {\n-                let mut eat_argument = || -> Option<String> {\n-                    let mut result = String::new();\n-                    // Format specifiers look like:\n-                    //\n-                    //   format   := '{' [ argument ] [ ':' format_spec ] '}' .\n-                    //\n-                    // Therefore, we only need to eat until ':' or '}' to find the argument.\n-                    while let Some(c) = it.next() {\n-                        result.push(c);\n-                        let next = *it.peek().unwrap_or(&'\\0');\n-                        if next == '}' {\n-                            break;\n-                        } else if next == ':' {\n-                            // Eat the ':' character.\n-                            assert_eq!(it.next().unwrap(), ':');\n-                            break;\n-                        }\n-                    }\n-                    // Eat until (and including) the matching '}'\n-                    while it.next()? != '}' {\n-                        continue;\n+            if c != '{' {\n+                continue;\n+            }\n+            if *it.peek().unwrap_or(&'\\0') == '{' {\n+                assert_eq!(it.next().unwrap(), '{');\n+                continue;\n+            }\n+            let mut eat_argument = || -> Option<String> {\n+                let mut result = String::new();\n+                // Format specifiers look like:\n+                //\n+                //   format   := '{' [ argument ] [ ':' format_spec ] '}' .\n+                //\n+                // Therefore, we only need to eat until ':' or '}' to find the argument.\n+                while let Some(c) = it.next() {\n+                    result.push(c);\n+                    let next = *it.peek().unwrap_or(&'\\0');\n+                    if next == '}' {\n+                        break;\n+                    } else if next == ':' {\n+                        // Eat the ':' character.\n+                        assert_eq!(it.next().unwrap(), ':');\n+                        break;\n                     }\n-                    Some(result)\n-                };\n-\n-                if let Some(referenced_field) = eat_argument() {\n-                    referenced_fields.insert(referenced_field);\n                 }\n+                // Eat until (and including) the matching '}'\n+                while it.next()? != '}' {\n+                    continue;\n+                }\n+                Some(result)\n+            };\n+\n+            if let Some(referenced_field) = eat_argument() {\n+                referenced_fields.insert(referenced_field);\n             }\n         }\n "}, {"sha": "4a2cf74905bf593617d8a3b40b05b449ae2db664", "filename": "compiler/rustc_parse/src/parser/ty.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs?ref=ee8c31e64d229cac4eba6d8f03bb70e16f34a14b", "patch": "@@ -640,7 +640,13 @@ impl<'a> Parser<'a> {\n         let mut bounds = Vec::new();\n         let mut negative_bounds = Vec::new();\n \n-        while self.can_begin_bound() || self.token.is_keyword(kw::Dyn) {\n+        while self.can_begin_bound()\n+            // Continue even if we find a keyword.\n+            // This is necessary for error recover on, for example, `impl fn()`.\n+            //\n+            // The only keyword that can go after generic bounds is `where`, so stop if it's it.\n+            || (self.token.is_reserved_ident() && !self.token.is_keyword(kw::Where))\n+        {\n             if self.token.is_keyword(kw::Dyn) {\n                 // Account for `&dyn Trait + dyn Other`.\n                 self.struct_span_err(self.token.span, \"invalid `dyn` keyword\")\n@@ -803,6 +809,20 @@ impl<'a> Parser<'a> {\n             self.expect_keyword(kw::Const)?;\n             let span = tilde.to(self.prev_token.span);\n             self.sess.gated_spans.gate(sym::const_trait_impl, span);\n+            Some(span)\n+        } else if self.eat_keyword(kw::Const) {\n+            let span = self.prev_token.span;\n+            self.sess.gated_spans.gate(sym::const_trait_impl, span);\n+\n+            self.struct_span_err(span, \"const bounds must start with `~`\")\n+                .span_suggestion(\n+                    span.shrink_to_lo(),\n+                    \"add `~`\",\n+                    \"~\",\n+                    Applicability::MachineApplicable,\n+                )\n+                .emit();\n+\n             Some(span)\n         } else {\n             None"}, {"sha": "17866dc6bddcbf2cbb89adf7d1a4df188efa4abe", "filename": "compiler/rustc_session/src/parse.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fparse.rs?ref=ee8c31e64d229cac4eba6d8f03bb70e16f34a14b", "patch": "@@ -360,6 +360,17 @@ impl ParseSess {\n         self.create_warning(warning).emit()\n     }\n \n+    pub fn create_fatal<'a>(\n+        &'a self,\n+        fatal: impl SessionDiagnostic<'a, !>,\n+    ) -> DiagnosticBuilder<'a, !> {\n+        fatal.into_diagnostic(self)\n+    }\n+\n+    pub fn emit_fatal<'a>(&'a self, fatal: impl SessionDiagnostic<'a, !>) -> ! {\n+        self.create_fatal(fatal).emit()\n+    }\n+\n     #[rustc_lint_diagnostics]\n     pub fn struct_err(\n         &self,\n@@ -373,6 +384,11 @@ impl ParseSess {\n         self.span_diagnostic.struct_warn(msg)\n     }\n \n+    #[rustc_lint_diagnostics]\n+    pub fn struct_fatal(&self, msg: impl Into<DiagnosticMessage>) -> DiagnosticBuilder<'_, !> {\n+        self.span_diagnostic.struct_fatal(msg)\n+    }\n+\n     #[rustc_lint_diagnostics]\n     pub fn struct_diagnostic<G: EmissionGuarantee>(\n         &self,"}, {"sha": "4972ae2014d506e3ce200d4baa5a7f4f20a917bf", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=ee8c31e64d229cac4eba6d8f03bb70e16f34a14b", "patch": "@@ -482,6 +482,15 @@ impl Session {\n     pub fn emit_warning<'a>(&'a self, warning: impl SessionDiagnostic<'a, ()>) {\n         self.parse_sess.emit_warning(warning)\n     }\n+    pub fn create_fatal<'a>(\n+        &'a self,\n+        fatal: impl SessionDiagnostic<'a, !>,\n+    ) -> DiagnosticBuilder<'a, !> {\n+        self.parse_sess.create_fatal(fatal)\n+    }\n+    pub fn emit_fatal<'a>(&'a self, fatal: impl SessionDiagnostic<'a, !>) -> ! {\n+        self.parse_sess.emit_fatal(fatal)\n+    }\n     #[inline]\n     pub fn err_count(&self) -> usize {\n         self.diagnostic().err_count()"}, {"sha": "aeaccffd5f5f77a0132d4e957a56545143060e08", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=ee8c31e64d229cac4eba6d8f03bb70e16f34a14b", "patch": "@@ -554,6 +554,18 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n                     .flatten()\n                     .unwrap_or_else(|| ty::Term::Ty(ty.super_fold_with(self)))\n                 };\n+                // For cases like #95134 we would like to catch overflows early\n+                // otherwise they slip away away and cause ICE.\n+                let recursion_limit = self.tcx().recursion_limit();\n+                if !recursion_limit.value_within_limit(self.depth) {\n+                    let obligation = Obligation::with_depth(\n+                        self.cause.clone(),\n+                        recursion_limit.0,\n+                        self.param_env,\n+                        ty,\n+                    );\n+                    self.selcx.infcx().report_overflow_error(&obligation, true);\n+                }\n                 debug!(\n                     ?self.depth,\n                     ?ty,"}, {"sha": "6955d863c99e792df84660d50d14203ceb9b9848", "filename": "library/alloc/src/boxed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/library%2Falloc%2Fsrc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/library%2Falloc%2Fsrc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed.rs?ref=ee8c31e64d229cac4eba6d8f03bb70e16f34a14b", "patch": "@@ -1,4 +1,4 @@\n-//! A pointer type for heap allocation.\n+//! The `Box<T>` type for heap allocation.\n //!\n //! [`Box<T>`], casually referred to as a 'box', provides the simplest form of\n //! heap allocation in Rust. Boxes provide ownership for this allocation, and"}, {"sha": "bcd3f49e208928b9119ac40af6d3a822dddf7f3a", "filename": "library/alloc/src/slice.rs", "status": "modified", "additions": 5, "deletions": 75, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/library%2Falloc%2Fsrc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/library%2Falloc%2Fsrc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fslice.rs?ref=ee8c31e64d229cac4eba6d8f03bb70e16f34a14b", "patch": "@@ -1,82 +1,12 @@\n-//! A dynamically-sized view into a contiguous sequence, `[T]`.\n+//! Utilities for the slice primitive type.\n //!\n //! *[See also the slice primitive type](slice).*\n //!\n-//! Slices are a view into a block of memory represented as a pointer and a\n-//! length.\n+//! Most of the structs in this module are iterator types which can only be created\n+//! using a certain function. For example, `slice.iter()` yields an [`Iter`].\n //!\n-//! ```\n-//! // slicing a Vec\n-//! let vec = vec![1, 2, 3];\n-//! let int_slice = &vec[..];\n-//! // coercing an array to a slice\n-//! let str_slice: &[&str] = &[\"one\", \"two\", \"three\"];\n-//! ```\n-//!\n-//! Slices are either mutable or shared. The shared slice type is `&[T]`,\n-//! while the mutable slice type is `&mut [T]`, where `T` represents the element\n-//! type. For example, you can mutate the block of memory that a mutable slice\n-//! points to:\n-//!\n-//! ```\n-//! let x = &mut [1, 2, 3];\n-//! x[1] = 7;\n-//! assert_eq!(x, &[1, 7, 3]);\n-//! ```\n-//!\n-//! Here are some of the things this module contains:\n-//!\n-//! ## Structs\n-//!\n-//! There are several structs that are useful for slices, such as [`Iter`], which\n-//! represents iteration over a slice.\n-//!\n-//! ## Trait Implementations\n-//!\n-//! There are several implementations of common traits for slices. Some examples\n-//! include:\n-//!\n-//! * [`Clone`]\n-//! * [`Eq`], [`Ord`] - for slices whose element type are [`Eq`] or [`Ord`].\n-//! * [`Hash`] - for slices whose element type is [`Hash`].\n-//!\n-//! ## Iteration\n-//!\n-//! The slices implement `IntoIterator`. The iterator yields references to the\n-//! slice elements.\n-//!\n-//! ```\n-//! let numbers = &[0, 1, 2];\n-//! for n in numbers {\n-//!     println!(\"{n} is a number!\");\n-//! }\n-//! ```\n-//!\n-//! The mutable slice yields mutable references to the elements:\n-//!\n-//! ```\n-//! let mut scores = [7, 8, 9];\n-//! for score in &mut scores[..] {\n-//!     *score += 1;\n-//! }\n-//! ```\n-//!\n-//! This iterator yields mutable references to the slice's elements, so while\n-//! the element type of the slice is `i32`, the element type of the iterator is\n-//! `&mut i32`.\n-//!\n-//! * [`.iter`] and [`.iter_mut`] are the explicit methods to return the default\n-//!   iterators.\n-//! * Further methods that return iterators are [`.split`], [`.splitn`],\n-//!   [`.chunks`], [`.windows`] and more.\n-//!\n-//! [`Hash`]: core::hash::Hash\n-//! [`.iter`]: slice::iter\n-//! [`.iter_mut`]: slice::iter_mut\n-//! [`.split`]: slice::split\n-//! [`.splitn`]: slice::splitn\n-//! [`.chunks`]: slice::chunks\n-//! [`.windows`]: slice::windows\n+//! A few functions are provided to create a slice from a value reference\n+//! or from a raw pointer.\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n // Many of the usings in this module are only used in the test configuration.\n // It's cleaner to just turn off the unused_imports warning than to fix them."}, {"sha": "b28d20cda179ec32054515d56dad13d303e387ee", "filename": "library/alloc/src/str.rs", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/library%2Falloc%2Fsrc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/library%2Falloc%2Fsrc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstr.rs?ref=ee8c31e64d229cac4eba6d8f03bb70e16f34a14b", "patch": "@@ -1,26 +1,6 @@\n-//! Unicode string slices.\n+//! Utilities for the `str` primitive type.\n //!\n //! *[See also the `str` primitive type](str).*\n-//!\n-//! The `&str` type is one of the two main string types, the other being `String`.\n-//! Unlike its `String` counterpart, its contents are borrowed.\n-//!\n-//! # Basic Usage\n-//!\n-//! A basic string declaration of `&str` type:\n-//!\n-//! ```\n-//! let hello_world = \"Hello, World!\";\n-//! ```\n-//!\n-//! Here we have declared a string literal, also known as a string slice.\n-//! String literals have a static lifetime, which means the string `hello_world`\n-//! is guaranteed to be valid for the duration of the entire program.\n-//! We can explicitly specify `hello_world`'s lifetime as well:\n-//!\n-//! ```\n-//! let hello_world: &'static str = \"Hello, world!\";\n-//! ```\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n // Many of the usings in this module are only used in the test configuration."}, {"sha": "5be4d5f1279e555de2cc1ad125e1fdfc82c4bd22", "filename": "library/alloc/tests/vec.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/library%2Falloc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/library%2Falloc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec.rs?ref=ee8c31e64d229cac4eba6d8f03bb70e16f34a14b", "patch": "@@ -293,6 +293,22 @@ fn test_retain() {\n     assert_eq!(vec, [2, 4]);\n }\n \n+#[test]\n+fn test_retain_predicate_order() {\n+    for to_keep in [true, false] {\n+        let mut number_of_executions = 0;\n+        let mut vec = vec![1, 2, 3, 4];\n+        let mut next_expected = 1;\n+        vec.retain(|&x| {\n+            assert_eq!(next_expected, x);\n+            next_expected += 1;\n+            number_of_executions += 1;\n+            to_keep\n+        });\n+        assert_eq!(number_of_executions, 4);\n+    }\n+}\n+\n #[test]\n fn test_retain_pred_panic_with_hole() {\n     let v = (0..5).map(Rc::new).collect::<Vec<_>>();\n@@ -354,6 +370,35 @@ fn test_retain_drop_panic() {\n     assert!(v.iter().all(|r| Rc::strong_count(r) == 1));\n }\n \n+#[test]\n+fn test_retain_maybeuninits() {\n+    // This test aimed to be run under miri.\n+    use core::mem::MaybeUninit;\n+    let mut vec: Vec<_> = [1i32, 2, 3, 4].map(|v| MaybeUninit::new(vec![v])).into();\n+    vec.retain(|x| {\n+        // SAFETY: Retain must visit every element of Vec in original order and exactly once.\n+        // Our values is initialized at creation of Vec.\n+        let v = unsafe { x.assume_init_ref()[0] };\n+        if v & 1 == 0 {\n+            return true;\n+        }\n+        // SAFETY: Value is initialized.\n+        // Value wouldn't be dropped by `Vec::retain`\n+        // because `MaybeUninit` doesn't drop content.\n+        drop(unsafe { x.assume_init_read() });\n+        false\n+    });\n+    let vec: Vec<i32> = vec\n+        .into_iter()\n+        .map(|x| unsafe {\n+            // SAFETY: All values dropped in retain predicate must be removed by `Vec::retain`.\n+            // Remaining values are initialized.\n+            x.assume_init()[0]\n+        })\n+        .collect();\n+    assert_eq!(vec, [2, 4]);\n+}\n+\n #[test]\n fn test_dedup() {\n     fn case(a: Vec<i32>, b: Vec<i32>) {"}, {"sha": "e54f6c912d5945eacdc096a27c4b5b52222a6575", "filename": "library/core/src/any.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/library%2Fcore%2Fsrc%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/library%2Fcore%2Fsrc%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fany.rs?ref=ee8c31e64d229cac4eba6d8f03bb70e16f34a14b", "patch": "@@ -1,7 +1,4 @@\n-//! This module contains the `Any` trait, which enables dynamic typing\n-//! of any `'static` type through runtime reflection. It also contains the\n-//! `Provider` trait and accompanying API, which enable trait objects to provide\n-//! data based on typed requests, an alternate form of runtime reflection.\n+//! Utilities for dynamic typing or type reflection.\n //!\n //! # `Any` and `TypeId`\n //!"}, {"sha": "db5bfcab9d2b163c1a3e6e07234fd7a9682019d4", "filename": "library/core/src/array/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fmod.rs?ref=ee8c31e64d229cac4eba6d8f03bb70e16f34a14b", "patch": "@@ -1,4 +1,4 @@\n-//! Helper functions and types for fixed-length arrays.\n+//! Utilities for the array primitive type.\n //!\n //! *[See also the array primitive type](array).*\n "}, {"sha": "8378611eb18c306b237f9f568610fc5a91cfbd58", "filename": "library/core/src/borrow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/library%2Fcore%2Fsrc%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/library%2Fcore%2Fsrc%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fborrow.rs?ref=ee8c31e64d229cac4eba6d8f03bb70e16f34a14b", "patch": "@@ -1,4 +1,4 @@\n-//! A module for working with borrowed data.\n+//! Utilities for working with borrowed data.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}, {"sha": "a4bdd38f6553095c91a26e2ba4691c8d6a26ae63", "filename": "library/core/src/char/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/library%2Fcore%2Fsrc%2Fchar%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/library%2Fcore%2Fsrc%2Fchar%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fchar%2Fmod.rs?ref=ee8c31e64d229cac4eba6d8f03bb70e16f34a14b", "patch": "@@ -1,4 +1,6 @@\n-//! A character type.\n+//! Utilities for the `char` primitive type.\n+//!\n+//! *[See also the `char` primitive type](primitive@char).*\n //!\n //! The `char` type represents a single character. More specifically, since\n //! 'character' isn't a well-defined concept in Unicode, `char` is a '[Unicode"}, {"sha": "8a30bb6745060c22a01c947752bbc15e45ff2a6f", "filename": "library/core/src/cmp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/library%2Fcore%2Fsrc%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/library%2Fcore%2Fsrc%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcmp.rs?ref=ee8c31e64d229cac4eba6d8f03bb70e16f34a14b", "patch": "@@ -1,6 +1,6 @@\n-//! Functionality for ordering and comparison.\n+//! Utilities for comparing and ordering values.\n //!\n-//! This module contains various tools for ordering and comparing values. In\n+//! This module contains various tools for comparing and ordering values. In\n //! summary:\n //!\n //! * [`Eq`] and [`PartialEq`] are traits that allow you to define total and"}, {"sha": "b53cd6074b5327d18e6044b11a27cffc3eb2a7df", "filename": "library/core/src/default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/library%2Fcore%2Fsrc%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/library%2Fcore%2Fsrc%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fdefault.rs?ref=ee8c31e64d229cac4eba6d8f03bb70e16f34a14b", "patch": "@@ -1,4 +1,4 @@\n-//! The `Default` trait for types which may have meaningful default values.\n+//! The `Default` trait for types with a default value.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}, {"sha": "509a6c3cac545fc82d36416bde877b01ee419eff", "filename": "library/core/src/num/f32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs?ref=ee8c31e64d229cac4eba6d8f03bb70e16f34a14b", "patch": "@@ -1,4 +1,4 @@\n-//! Constants specific to the `f32` single-precision floating point type.\n+//! Constants for the `f32` single-precision floating point type.\n //!\n //! *[See also the `f32` primitive type][f32].*\n //!"}, {"sha": "5aeaa4b9ada441c95f6523caf09f999fb5d67a8c", "filename": "library/core/src/num/f64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs?ref=ee8c31e64d229cac4eba6d8f03bb70e16f34a14b", "patch": "@@ -1,4 +1,4 @@\n-//! Constants specific to the `f64` double-precision floating point type.\n+//! Constants for the `f64` double-precision floating point type.\n //!\n //! *[See also the `f64` primitive type][f64].*\n //!"}, {"sha": "2b2ef64fdb1c3f31cacc27592ee7fc8f43d5d108", "filename": "library/core/src/primitive_docs.rs", "status": "modified", "additions": 53, "deletions": 8, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/library%2Fcore%2Fsrc%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/library%2Fcore%2Fsrc%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fprimitive_docs.rs?ref=ee8c31e64d229cac4eba6d8f03bb70e16f34a14b", "patch": "@@ -801,11 +801,53 @@ mod prim_array {}\n /// assert_eq!(2 * pointer_size, std::mem::size_of::<Box<[u8]>>());\n /// assert_eq!(2 * pointer_size, std::mem::size_of::<Rc<[u8]>>());\n /// ```\n+///\n+/// ## Trait Implementations\n+///\n+/// Some traits are implemented for slices if the element type implements\n+/// that trait. This includes [`Eq`], [`Hash`] and [`Ord`].\n+///\n+/// ## Iteration\n+///\n+/// The slices implement `IntoIterator`. The iterator yields references to the\n+/// slice elements.\n+///\n+/// ```\n+/// let numbers: &[i32] = &[0, 1, 2];\n+/// for n in numbers {\n+///     println!(\"{n} is a number!\");\n+/// }\n+/// ```\n+///\n+/// The mutable slice yields mutable references to the elements:\n+///\n+/// ```\n+/// let mut scores: &mut [i32] = &mut [7, 8, 9];\n+/// for score in scores {\n+///     *score += 1;\n+/// }\n+/// ```\n+///\n+/// This iterator yields mutable references to the slice's elements, so while\n+/// the element type of the slice is `i32`, the element type of the iterator is\n+/// `&mut i32`.\n+///\n+/// * [`.iter`] and [`.iter_mut`] are the explicit methods to return the default\n+///   iterators.\n+/// * Further methods that return iterators are [`.split`], [`.splitn`],\n+///   [`.chunks`], [`.windows`] and more.\n+///\n+/// [`Hash`]: core::hash::Hash\n+/// [`.iter`]: slice::iter\n+/// [`.iter_mut`]: slice::iter_mut\n+/// [`.split`]: slice::split\n+/// [`.splitn`]: slice::splitn\n+/// [`.chunks`]: slice::chunks\n+/// [`.windows`]: slice::windows\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n mod prim_slice {}\n \n #[doc(primitive = \"str\")]\n-//\n /// String slices.\n ///\n /// *[See also the `std::str` module](crate::str).*\n@@ -816,19 +858,22 @@ mod prim_slice {}\n ///\n /// String slices are always valid UTF-8.\n ///\n-/// # Examples\n+/// # Basic Usage\n ///\n /// String literals are string slices:\n ///\n /// ```\n-/// let hello = \"Hello, world!\";\n-///\n-/// // with an explicit type annotation\n-/// let hello: &'static str = \"Hello, world!\";\n+/// let hello_world = \"Hello, World!\";\n /// ```\n ///\n-/// They are `'static` because they're stored directly in the final binary, and\n-/// so will be valid for the `'static` duration.\n+/// Here we have declared a string slice initialized with a string literal.\n+/// String literals have a static lifetime, which means the string `hello_world`\n+/// is guaranteed to be valid for the duration of the entire program.\n+/// We can explicitly specify `hello_world`'s lifetime as well:\n+///\n+/// ```\n+/// let hello_world: &'static str = \"Hello, world!\";\n+/// ```\n ///\n /// # Representation\n ///"}, {"sha": "4fbcfd85d7c04060cf8612577c32709eecc154ed", "filename": "library/std/src/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/library%2Fstd%2Fsrc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/library%2Fstd%2Fsrc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ferror.rs?ref=ee8c31e64d229cac4eba6d8f03bb70e16f34a14b", "patch": "@@ -1,4 +1,4 @@\n-//! Interfaces for working with Errors.\n+//! The `Error` trait provides common functionality for errors.\n //!\n //! # Error Handling In Rust\n //!"}, {"sha": "3dd5b12507fb2b136692e8e7220fda047d4fb261", "filename": "library/std/src/f32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/library%2Fstd%2Fsrc%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/library%2Fstd%2Fsrc%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ff32.rs?ref=ee8c31e64d229cac4eba6d8f03bb70e16f34a14b", "patch": "@@ -1,4 +1,4 @@\n-//! Constants specific to the `f32` single-precision floating point type.\n+//! Constants for the `f32` single-precision floating point type.\n //!\n //! *[See also the `f32` primitive type](primitive@f32).*\n //!"}, {"sha": "31351a87978c918dcaec443c092ef60b5b853272", "filename": "library/std/src/f64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/library%2Fstd%2Fsrc%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/library%2Fstd%2Fsrc%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ff64.rs?ref=ee8c31e64d229cac4eba6d8f03bb70e16f34a14b", "patch": "@@ -1,4 +1,4 @@\n-//! Constants specific to the `f64` double-precision floating point type.\n+//! Constants for the `f64` double-precision floating point type.\n //!\n //! *[See also the `f64` primitive type](primitive@f64).*\n //!"}, {"sha": "2b2ef64fdb1c3f31cacc27592ee7fc8f43d5d108", "filename": "library/std/src/primitive_docs.rs", "status": "modified", "additions": 53, "deletions": 8, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprimitive_docs.rs?ref=ee8c31e64d229cac4eba6d8f03bb70e16f34a14b", "patch": "@@ -801,11 +801,53 @@ mod prim_array {}\n /// assert_eq!(2 * pointer_size, std::mem::size_of::<Box<[u8]>>());\n /// assert_eq!(2 * pointer_size, std::mem::size_of::<Rc<[u8]>>());\n /// ```\n+///\n+/// ## Trait Implementations\n+///\n+/// Some traits are implemented for slices if the element type implements\n+/// that trait. This includes [`Eq`], [`Hash`] and [`Ord`].\n+///\n+/// ## Iteration\n+///\n+/// The slices implement `IntoIterator`. The iterator yields references to the\n+/// slice elements.\n+///\n+/// ```\n+/// let numbers: &[i32] = &[0, 1, 2];\n+/// for n in numbers {\n+///     println!(\"{n} is a number!\");\n+/// }\n+/// ```\n+///\n+/// The mutable slice yields mutable references to the elements:\n+///\n+/// ```\n+/// let mut scores: &mut [i32] = &mut [7, 8, 9];\n+/// for score in scores {\n+///     *score += 1;\n+/// }\n+/// ```\n+///\n+/// This iterator yields mutable references to the slice's elements, so while\n+/// the element type of the slice is `i32`, the element type of the iterator is\n+/// `&mut i32`.\n+///\n+/// * [`.iter`] and [`.iter_mut`] are the explicit methods to return the default\n+///   iterators.\n+/// * Further methods that return iterators are [`.split`], [`.splitn`],\n+///   [`.chunks`], [`.windows`] and more.\n+///\n+/// [`Hash`]: core::hash::Hash\n+/// [`.iter`]: slice::iter\n+/// [`.iter_mut`]: slice::iter_mut\n+/// [`.split`]: slice::split\n+/// [`.splitn`]: slice::splitn\n+/// [`.chunks`]: slice::chunks\n+/// [`.windows`]: slice::windows\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n mod prim_slice {}\n \n #[doc(primitive = \"str\")]\n-//\n /// String slices.\n ///\n /// *[See also the `std::str` module](crate::str).*\n@@ -816,19 +858,22 @@ mod prim_slice {}\n ///\n /// String slices are always valid UTF-8.\n ///\n-/// # Examples\n+/// # Basic Usage\n ///\n /// String literals are string slices:\n ///\n /// ```\n-/// let hello = \"Hello, world!\";\n-///\n-/// // with an explicit type annotation\n-/// let hello: &'static str = \"Hello, world!\";\n+/// let hello_world = \"Hello, World!\";\n /// ```\n ///\n-/// They are `'static` because they're stored directly in the final binary, and\n-/// so will be valid for the `'static` duration.\n+/// Here we have declared a string slice initialized with a string literal.\n+/// String literals have a static lifetime, which means the string `hello_world`\n+/// is guaranteed to be valid for the duration of the entire program.\n+/// We can explicitly specify `hello_world`'s lifetime as well:\n+///\n+/// ```\n+/// let hello_world: &'static str = \"Hello, world!\";\n+/// ```\n ///\n /// # Representation\n ///"}, {"sha": "f6cda3de5c763138558a318195c6bbdc462bdfda", "filename": "src/test/ui/issues/issue-23122-2.stderr", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/src%2Ftest%2Fui%2Fissues%2Fissue-23122-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/src%2Ftest%2Fui%2Fissues%2Fissue-23122-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23122-2.stderr?ref=ee8c31e64d229cac4eba6d8f03bb70e16f34a14b", "patch": "@@ -1,15 +1,10 @@\n-error[E0275]: overflow evaluating the requirement `<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<T as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next: Sized`\n+error[E0275]: overflow evaluating the requirement `<T as Next>::Next`\n   --> $DIR/issue-23122-2.rs:10:17\n    |\n LL |     type Next = <GetNext<T::Next> as Next>::Next;\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`issue_23122_2`)\n-note: required for `GetNext<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<T as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next>` to implement `Next`\n-  --> $DIR/issue-23122-2.rs:9:15\n-   |\n-LL | impl<T: Next> Next for GetNext<T> {\n-   |               ^^^^     ^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "fa037e5937dcaccfed179d0277b30eb85efe5c21", "filename": "src/test/ui/parser/kw-in-trait-bounds.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/src%2Ftest%2Fui%2Fparser%2Fkw-in-trait-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/src%2Ftest%2Fui%2Fparser%2Fkw-in-trait-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fkw-in-trait-bounds.rs?ref=ee8c31e64d229cac4eba6d8f03bb70e16f34a14b", "patch": "@@ -0,0 +1,47 @@\n+// edition:2018\n+\n+fn _f<F: fn(), G>(_: impl fn(), _: &dyn fn())\n+//~^ ERROR expected identifier, found keyword `fn`\n+//~| ERROR expected identifier, found keyword `fn`\n+//~| ERROR expected identifier, found keyword `fn`\n+//~| ERROR cannot find trait `r#fn` in this scope\n+//~| ERROR cannot find trait `r#fn` in this scope\n+//~| ERROR cannot find trait `r#fn` in this scope\n+//~| HELP  a trait with a similar name exists\n+//~| HELP  a trait with a similar name exists\n+//~| HELP  a trait with a similar name exists\n+//~| HELP  escape `fn` to use it as an identifier\n+//~| HELP  escape `fn` to use it as an identifier\n+//~| HELP  escape `fn` to use it as an identifier\n+where\n+G: fn(),\n+    //~^ ERROR expected identifier, found keyword `fn`\n+    //~| ERROR cannot find trait `r#fn` in this scope\n+    //~| HELP  a trait with a similar name exists\n+    //~| HELP  escape `fn` to use it as an identifier\n+{}\n+\n+fn _g<A: struct, B>(_: impl struct, _: &dyn struct)\n+//~^ ERROR expected identifier, found keyword `struct`\n+//~| ERROR expected identifier, found keyword `struct`\n+//~| ERROR expected identifier, found keyword `struct`\n+//~| ERROR cannot find trait `r#struct` in this scope\n+//~| ERROR cannot find trait `r#struct` in this scope\n+//~| ERROR cannot find trait `r#struct` in this scope\n+//~| HELP  a trait with a similar name exists\n+//~| HELP  a trait with a similar name exists\n+//~| HELP  a trait with a similar name exists\n+//~| HELP  escape `struct` to use it as an identifier\n+//~| HELP  escape `struct` to use it as an identifier\n+//~| HELP  escape `struct` to use it as an identifier\n+where\n+    B: struct,\n+    //~^ ERROR expected identifier, found keyword `struct`\n+    //~| ERROR cannot find trait `r#struct` in this scope\n+    //~| HELP  a trait with a similar name exists\n+    //~| HELP  escape `struct` to use it as an identifier\n+{}\n+\n+trait Struct {}\n+\n+fn main() {}"}, {"sha": "28196c7ce2de838d1b9d557bb547179014be2994", "filename": "src/test/ui/parser/kw-in-trait-bounds.stderr", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/src%2Ftest%2Fui%2Fparser%2Fkw-in-trait-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/src%2Ftest%2Fui%2Fparser%2Fkw-in-trait-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fkw-in-trait-bounds.stderr?ref=ee8c31e64d229cac4eba6d8f03bb70e16f34a14b", "patch": "@@ -0,0 +1,171 @@\n+error: expected identifier, found keyword `fn`\n+  --> $DIR/kw-in-trait-bounds.rs:3:10\n+   |\n+LL | fn _f<F: fn(), G>(_: impl fn(), _: &dyn fn())\n+   |          ^^ expected identifier, found keyword\n+   |\n+help: escape `fn` to use it as an identifier\n+   |\n+LL | fn _f<F: r#fn(), G>(_: impl fn(), _: &dyn fn())\n+   |          ++\n+\n+error: expected identifier, found keyword `fn`\n+  --> $DIR/kw-in-trait-bounds.rs:3:27\n+   |\n+LL | fn _f<F: fn(), G>(_: impl fn(), _: &dyn fn())\n+   |                           ^^ expected identifier, found keyword\n+   |\n+help: escape `fn` to use it as an identifier\n+   |\n+LL | fn _f<F: fn(), G>(_: impl r#fn(), _: &dyn fn())\n+   |                           ++\n+\n+error: expected identifier, found keyword `fn`\n+  --> $DIR/kw-in-trait-bounds.rs:3:41\n+   |\n+LL | fn _f<F: fn(), G>(_: impl fn(), _: &dyn fn())\n+   |                                         ^^ expected identifier, found keyword\n+   |\n+help: escape `fn` to use it as an identifier\n+   |\n+LL | fn _f<F: fn(), G>(_: impl fn(), _: &dyn r#fn())\n+   |                                         ++\n+\n+error: expected identifier, found keyword `fn`\n+  --> $DIR/kw-in-trait-bounds.rs:17:4\n+   |\n+LL | G: fn(),\n+   |    ^^ expected identifier, found keyword\n+   |\n+help: escape `fn` to use it as an identifier\n+   |\n+LL | G: r#fn(),\n+   |    ++\n+\n+error: expected identifier, found keyword `struct`\n+  --> $DIR/kw-in-trait-bounds.rs:24:10\n+   |\n+LL | fn _g<A: struct, B>(_: impl struct, _: &dyn struct)\n+   |          ^^^^^^ expected identifier, found keyword\n+   |\n+help: escape `struct` to use it as an identifier\n+   |\n+LL | fn _g<A: r#struct, B>(_: impl struct, _: &dyn struct)\n+   |          ++\n+\n+error: expected identifier, found keyword `struct`\n+  --> $DIR/kw-in-trait-bounds.rs:24:29\n+   |\n+LL | fn _g<A: struct, B>(_: impl struct, _: &dyn struct)\n+   |                             ^^^^^^ expected identifier, found keyword\n+   |\n+help: escape `struct` to use it as an identifier\n+   |\n+LL | fn _g<A: struct, B>(_: impl r#struct, _: &dyn struct)\n+   |                             ++\n+\n+error: expected identifier, found keyword `struct`\n+  --> $DIR/kw-in-trait-bounds.rs:24:45\n+   |\n+LL | fn _g<A: struct, B>(_: impl struct, _: &dyn struct)\n+   |                                             ^^^^^^ expected identifier, found keyword\n+   |\n+help: escape `struct` to use it as an identifier\n+   |\n+LL | fn _g<A: struct, B>(_: impl struct, _: &dyn r#struct)\n+   |                                             ++\n+\n+error: expected identifier, found keyword `struct`\n+  --> $DIR/kw-in-trait-bounds.rs:38:8\n+   |\n+LL |     B: struct,\n+   |        ^^^^^^ expected identifier, found keyword\n+   |\n+help: escape `struct` to use it as an identifier\n+   |\n+LL |     B: r#struct,\n+   |        ++\n+\n+error[E0405]: cannot find trait `r#fn` in this scope\n+  --> $DIR/kw-in-trait-bounds.rs:3:10\n+   |\n+LL | fn _f<F: fn(), G>(_: impl fn(), _: &dyn fn())\n+   |          ^^ help: a trait with a similar name exists (notice the capitalization): `Fn`\n+   |\n+  ::: $SRC_DIR/core/src/ops/function.rs:LL:COL\n+   |\n+LL | pub trait Fn<Args>: FnMut<Args> {\n+   | ------------------------------- similarly named trait `Fn` defined here\n+\n+error[E0405]: cannot find trait `r#fn` in this scope\n+  --> $DIR/kw-in-trait-bounds.rs:17:4\n+   |\n+LL | G: fn(),\n+   |    ^^ help: a trait with a similar name exists (notice the capitalization): `Fn`\n+   |\n+  ::: $SRC_DIR/core/src/ops/function.rs:LL:COL\n+   |\n+LL | pub trait Fn<Args>: FnMut<Args> {\n+   | ------------------------------- similarly named trait `Fn` defined here\n+\n+error[E0405]: cannot find trait `r#fn` in this scope\n+  --> $DIR/kw-in-trait-bounds.rs:3:27\n+   |\n+LL | fn _f<F: fn(), G>(_: impl fn(), _: &dyn fn())\n+   |                           ^^ help: a trait with a similar name exists (notice the capitalization): `Fn`\n+   |\n+  ::: $SRC_DIR/core/src/ops/function.rs:LL:COL\n+   |\n+LL | pub trait Fn<Args>: FnMut<Args> {\n+   | ------------------------------- similarly named trait `Fn` defined here\n+\n+error[E0405]: cannot find trait `r#fn` in this scope\n+  --> $DIR/kw-in-trait-bounds.rs:3:41\n+   |\n+LL | fn _f<F: fn(), G>(_: impl fn(), _: &dyn fn())\n+   |                                         ^^ help: a trait with a similar name exists (notice the capitalization): `Fn`\n+   |\n+  ::: $SRC_DIR/core/src/ops/function.rs:LL:COL\n+   |\n+LL | pub trait Fn<Args>: FnMut<Args> {\n+   | ------------------------------- similarly named trait `Fn` defined here\n+\n+error[E0405]: cannot find trait `r#struct` in this scope\n+  --> $DIR/kw-in-trait-bounds.rs:24:10\n+   |\n+LL | fn _g<A: struct, B>(_: impl struct, _: &dyn struct)\n+   |          ^^^^^^ help: a trait with a similar name exists (notice the capitalization): `Struct`\n+...\n+LL | trait Struct {}\n+   | ------------ similarly named trait `Struct` defined here\n+\n+error[E0405]: cannot find trait `r#struct` in this scope\n+  --> $DIR/kw-in-trait-bounds.rs:38:8\n+   |\n+LL |     B: struct,\n+   |        ^^^^^^ help: a trait with a similar name exists (notice the capitalization): `Struct`\n+...\n+LL | trait Struct {}\n+   | ------------ similarly named trait `Struct` defined here\n+\n+error[E0405]: cannot find trait `r#struct` in this scope\n+  --> $DIR/kw-in-trait-bounds.rs:24:29\n+   |\n+LL | fn _g<A: struct, B>(_: impl struct, _: &dyn struct)\n+   |                             ^^^^^^ help: a trait with a similar name exists (notice the capitalization): `Struct`\n+...\n+LL | trait Struct {}\n+   | ------------ similarly named trait `Struct` defined here\n+\n+error[E0405]: cannot find trait `r#struct` in this scope\n+  --> $DIR/kw-in-trait-bounds.rs:24:45\n+   |\n+LL | fn _g<A: struct, B>(_: impl struct, _: &dyn struct)\n+   |                                             ^^^^^^ help: a trait with a similar name exists (notice the capitalization): `Struct`\n+...\n+LL | trait Struct {}\n+   | ------------ similarly named trait `Struct` defined here\n+\n+error: aborting due to 16 previous errors\n+\n+For more information about this error, try `rustc --explain E0405`."}, {"sha": "32f25faf3e8baaff1a721cae42784dc089a667d4", "filename": "src/test/ui/recursion/issue-83150.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/src%2Ftest%2Fui%2Frecursion%2Fissue-83150.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/src%2Ftest%2Fui%2Frecursion%2Fissue-83150.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frecursion%2Fissue-83150.stderr?ref=ee8c31e64d229cac4eba6d8f03bb70e16f34a14b", "patch": "@@ -9,9 +9,11 @@ LL |     func(&mut iter.map(|x| x + 1))\n    = note: `#[warn(unconditional_recursion)]` on by default\n    = help: a `loop` may express intention better if this is on purpose\n \n-error[E0275]: overflow evaluating the requirement `Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut std::ops::Range<u8>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>: Iterator`\n+error[E0275]: overflow evaluating the requirement `<std::ops::Range<u8> as Iterator>::Item`\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`issue_83150`)\n+   = note: required for `Map<&mut std::ops::Range<u8>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>` to implement `Iterator`\n+   = note: 64 redundant requirements hidden\n    = note: required for `&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut std::ops::Range<u8>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>, [closure@$DIR/issue-83150.rs:11:24: 11:27]>` to implement `Iterator`\n \n error: aborting due to previous error; 1 warning emitted"}, {"sha": "adc9c6ee2d967d4781586e6215579ba6db1c046e", "filename": "src/test/ui/recursion/issue-95134.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/src%2Ftest%2Fui%2Frecursion%2Fissue-95134.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/src%2Ftest%2Fui%2Frecursion%2Fissue-95134.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frecursion%2Fissue-95134.rs?ref=ee8c31e64d229cac4eba6d8f03bb70e16f34a14b", "patch": "@@ -0,0 +1,28 @@\n+// build-fail\n+// compile-flags: -Copt-level=0\n+//~^^ ERROR overflow evaluating the requirement\n+\n+pub fn encode_num<Writer: ExampleWriter>(n: u32, mut writer: Writer) -> Result<(), Writer::Error> {\n+    if n > 15 {\n+        encode_num(n / 16, &mut writer)?;\n+    }\n+    Ok(())\n+}\n+\n+pub trait ExampleWriter {\n+    type Error;\n+}\n+\n+impl<'a, T: ExampleWriter> ExampleWriter for &'a mut T {\n+    type Error = T::Error;\n+}\n+\n+struct EmptyWriter;\n+\n+impl ExampleWriter for EmptyWriter {\n+    type Error = ();\n+}\n+\n+fn main() {\n+    encode_num(69, &mut EmptyWriter).unwrap();\n+}"}, {"sha": "57a498694b7c1215aa79b48e2bb95772d873c0fe", "filename": "src/test/ui/recursion/issue-95134.stderr", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/src%2Ftest%2Fui%2Frecursion%2Fissue-95134.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/src%2Ftest%2Fui%2Frecursion%2Fissue-95134.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frecursion%2Fissue-95134.stderr?ref=ee8c31e64d229cac4eba6d8f03bb70e16f34a14b", "patch": "@@ -0,0 +1,7 @@\n+error[E0275]: overflow evaluating the requirement `<EmptyWriter as ExampleWriter>::Error`\n+   |\n+   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`issue_95134`)\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0275`."}, {"sha": "d63381b5f2cc9a8b92121c8ad7af9b9a205b943f", "filename": "src/test/ui/rfc-2632-const-trait-impl/without-tilde.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fwithout-tilde.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fwithout-tilde.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fwithout-tilde.rs?ref=ee8c31e64d229cac4eba6d8f03bb70e16f34a14b", "patch": "@@ -3,4 +3,4 @@\n #![feature(const_trait_impl)]\n \n struct S<T: const Tr>;\n-//~^ ERROR expected one of `!`, `(`, `,`, `=`, `>`, `?`, `for`, `~`, lifetime, or path\n+//~^ ERROR const bounds must start with `~`"}, {"sha": "31300354a573791ff479ab8421229be97734e27d", "filename": "src/test/ui/rfc-2632-const-trait-impl/without-tilde.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fwithout-tilde.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fwithout-tilde.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fwithout-tilde.stderr?ref=ee8c31e64d229cac4eba6d8f03bb70e16f34a14b", "patch": "@@ -1,8 +1,10 @@\n-error: expected one of `!`, `(`, `,`, `=`, `>`, `?`, `for`, `~`, lifetime, or path, found keyword `const`\n+error: const bounds must start with `~`\n   --> $DIR/without-tilde.rs:5:13\n    |\n LL | struct S<T: const Tr>;\n-   |             ^^^^^ expected one of 10 possible tokens\n+   |             -^^^^\n+   |             |\n+   |             help: add `~`: `~`\n \n error: aborting due to previous error\n "}]}