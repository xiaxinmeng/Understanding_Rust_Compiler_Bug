{"sha": "e1c9efcba48f098482ee6033835a4fe321268709", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxYzllZmNiYTQ4ZjA5ODQ4MmVlNjAzMzgzNWE0ZmUzMjEyNjg3MDk=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-08-17T20:48:53Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-08-18T03:22:48Z"}, "message": "Refactor `value_determined` -> `value_result`, `type_determined` -> `type_result`.", "tree": {"sha": "4f0e4da00e40b78bfde1895aadd510cb59874acc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f0e4da00e40b78bfde1895aadd510cb59874acc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e1c9efcba48f098482ee6033835a4fe321268709", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e1c9efcba48f098482ee6033835a4fe321268709", "html_url": "https://github.com/rust-lang/rust/commit/e1c9efcba48f098482ee6033835a4fe321268709", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e1c9efcba48f098482ee6033835a4fe321268709/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7608bbdea869b061a65c996cac6c15d840436a7c", "url": "https://api.github.com/repos/rust-lang/rust/commits/7608bbdea869b061a65c996cac6c15d840436a7c", "html_url": "https://github.com/rust-lang/rust/commit/7608bbdea869b061a65c996cac6c15d840436a7c"}], "stats": {"total": 85, "additions": 45, "deletions": 40}, "files": [{"sha": "6e1128c67735eccaccc34f94b649f9981643dc47", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 45, "deletions": 40, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/e1c9efcba48f098482ee6033835a4fe321268709/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1c9efcba48f098482ee6033835a4fe321268709/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=e1c9efcba48f098482ee6033835a4fe321268709", "patch": "@@ -38,23 +38,23 @@ impl<'a> Resolver<'a> {\n \n /// Contains data for specific types of import directives.\n #[derive(Clone, Debug)]\n-pub enum ImportDirectiveSubclass {\n+pub enum ImportDirectiveSubclass<'a> {\n     SingleImport {\n         target: Name,\n         source: Name,\n-        type_determined: Cell<bool>,\n-        value_determined: Cell<bool>,\n+        value_result: Cell<Result<&'a NameBinding<'a>, bool /* determined? */>>,\n+        type_result: Cell<Result<&'a NameBinding<'a>, bool /* determined? */>>,\n     },\n     GlobImport { is_prelude: bool },\n }\n \n-impl ImportDirectiveSubclass {\n+impl<'a> ImportDirectiveSubclass<'a> {\n     pub fn single(target: Name, source: Name) -> Self {\n         SingleImport {\n             target: target,\n             source: source,\n-            type_determined: Cell::new(false),\n-            value_determined: Cell::new(false),\n+            type_result: Cell::new(Err(false)),\n+            value_result: Cell::new(Err(false)),\n         }\n     }\n }\n@@ -66,7 +66,7 @@ pub struct ImportDirective<'a> {\n     parent: Module<'a>,\n     module_path: Vec<Name>,\n     target_module: Cell<Option<Module<'a>>>, // the resolution of `module_path`\n-    subclass: ImportDirectiveSubclass,\n+    subclass: ImportDirectiveSubclass<'a>,\n     span: Span,\n     vis: ty::Visibility, // see note in ImportResolutionPerNamespace about how to use this\n }\n@@ -235,7 +235,7 @@ impl<'a> Resolver<'a> {\n     // Add an import directive to the current module.\n     pub fn add_import_directive(&mut self,\n                                 module_path: Vec<Name>,\n-                                subclass: ImportDirectiveSubclass,\n+                                subclass: ImportDirectiveSubclass<'a>,\n                                 span: Span,\n                                 id: NodeId,\n                                 vis: ty::Visibility) {\n@@ -488,30 +488,35 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         };\n \n         directive.target_module.set(Some(target_module));\n-        let (source, target, value_determined, type_determined) = match directive.subclass {\n-            SingleImport { source, target, ref value_determined, ref type_determined } =>\n-                (source, target, value_determined, type_determined),\n+        let (source, target, value_result, type_result) = match directive.subclass {\n+            SingleImport { source, target, ref value_result, ref type_result } =>\n+                (source, target, value_result, type_result),\n             GlobImport { .. } => return self.resolve_glob_import(target_module, directive),\n         };\n \n-        // We need to resolve both namespaces for this to succeed.\n-        let span = directive.span;\n-        let value_result =\n-            self.resolve_name_in_module(target_module, source, ValueNS, false, Some(span));\n-        let type_result =\n-            self.resolve_name_in_module(target_module, source, TypeNS, false, Some(span));\n-\n         let mut privacy_error = true;\n-        for &(ns, result, determined) in &[(ValueNS, &value_result, value_determined),\n-                                           (TypeNS, &type_result, type_determined)] {\n-            match *result {\n-                Failed(..) if !determined.get() => {\n-                    determined.set(true);\n+        for &(ns, result) in &[(ValueNS, value_result), (TypeNS, type_result)] {\n+            let was_determined = if let Err(false) = result.get() {\n+                result.set({\n+                    let span = Some(directive.span);\n+                    match self.resolve_name_in_module(target_module, source, ns, false, span) {\n+                        Success(binding) => Ok(binding),\n+                        Indeterminate => Err(false),\n+                        Failed(_) => Err(true),\n+                    }\n+                });\n+                false\n+            } else {\n+                true\n+            };\n+\n+            match result.get() {\n+                Err(true) if !was_determined => {\n                     self.update_resolution(module, target, ns, |_, resolution| {\n                         resolution.single_imports.directive_failed()\n                     });\n                 }\n-                Success(binding) if !binding.is_importable() => {\n+                Ok(binding) if !binding.is_importable() => {\n                     let msg = format!(\"`{}` is not directly importable\", target);\n                     struct_span_err!(self.session, directive.span, E0253, \"{}\", &msg)\n                         .span_label(directive.span, &format!(\"cannot be imported directly\"))\n@@ -521,9 +526,8 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                     self.import_dummy_binding(directive);\n                     return Success(());\n                 }\n-                Success(binding) if !self.is_accessible(binding.vis) => {}\n-                Success(binding) if !determined.get() => {\n-                    determined.set(true);\n+                Ok(binding) if !self.is_accessible(binding.vis) => {}\n+                Ok(binding) if !was_determined => {\n                     let imported_binding = self.import(binding, directive);\n                     let conflict = self.try_define(module, target, ns, imported_binding);\n                     if let Err(old_binding) = conflict {\n@@ -532,14 +536,15 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                     }\n                     privacy_error = false;\n                 }\n-                Success(_) => privacy_error = false,\n+                Ok(_) => privacy_error = false,\n                 _ => {}\n             }\n         }\n \n-        match (&value_result, &type_result) {\n-            (&Indeterminate, _) | (_, &Indeterminate) => return Indeterminate,\n-            (&Failed(_), &Failed(_)) => {\n+        let (value_result, type_result) = (value_result.get(), type_result.get());\n+        match (value_result, type_result) {\n+            (Err(false), _) | (_, Err(false)) => return Indeterminate,\n+            (Err(true), Err(true)) => {\n                 let resolutions = target_module.resolutions.borrow();\n                 let names = resolutions.iter().filter_map(|(&(ref name, _), resolution)| {\n                     if *name == source { return None; } // Never suggest the same name\n@@ -565,17 +570,17 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         }\n \n         if privacy_error {\n-            for &(ns, result) in &[(ValueNS, &value_result), (TypeNS, &type_result)] {\n-                let binding = match *result { Success(binding) => binding, _ => continue };\n+            for &(ns, result) in &[(ValueNS, value_result), (TypeNS, type_result)] {\n+                let binding = match result { Ok(binding) => binding, _ => continue };\n                 self.privacy_errors.push(PrivacyError(directive.span, source, binding));\n                 let imported_binding = self.import(binding, directive);\n                 let _ = self.try_define(module, target, ns, imported_binding);\n             }\n         }\n \n-        match (&value_result, &type_result) {\n-            (&Success(binding), _) if !binding.pseudo_vis().is_at_least(directive.vis, self) &&\n-                                      self.is_accessible(binding.vis) => {\n+        match (value_result, type_result) {\n+            (Ok(binding), _) if !binding.pseudo_vis().is_at_least(directive.vis, self) &&\n+                                self.is_accessible(binding.vis) => {\n                 let msg = format!(\"`{}` is private, and cannot be reexported\", source);\n                 let note_msg = format!(\"consider marking `{}` as `pub` in the imported module\",\n                                         source);\n@@ -584,8 +589,8 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                     .emit();\n             }\n \n-            (_, &Success(binding)) if !binding.pseudo_vis().is_at_least(directive.vis, self) &&\n-                                      self.is_accessible(binding.vis) => {\n+            (_, Ok(binding)) if !binding.pseudo_vis().is_at_least(directive.vis, self) &&\n+                                self.is_accessible(binding.vis) => {\n                 if binding.is_extern_crate() {\n                     let msg = format!(\"extern crate `{}` is private, and cannot be reexported \\\n                                        (error E0364), consider declaring with `pub`\",\n@@ -607,9 +612,9 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         // Record what this import resolves to for later uses in documentation,\n         // this may resolve to either a value or a type, but for documentation\n         // purposes it's good enough to just favor one over the other.\n-        let def = match type_result.success().and_then(NameBinding::def) {\n+        let def = match type_result.ok().and_then(NameBinding::def) {\n             Some(def) => def,\n-            None => value_result.success().and_then(NameBinding::def).unwrap(),\n+            None => value_result.ok().and_then(NameBinding::def).unwrap(),\n         };\n         let path_resolution = PathResolution::new(def);\n         self.def_map.insert(directive.id, path_resolution);"}]}