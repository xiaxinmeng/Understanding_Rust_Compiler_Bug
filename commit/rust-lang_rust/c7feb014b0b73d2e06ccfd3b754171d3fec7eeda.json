{"sha": "c7feb014b0b73d2e06ccfd3b754171d3fec7eeda", "node_id": "C_kwDOAAsO6NoAKGM3ZmViMDE0YjBiNzNkMmUwNmNjZmQzYjc1NDE3MWQzZmVjN2VlZGE", "commit": {"author": {"name": "carbotaniuman", "email": "41451839+carbotaniuman@users.noreply.github.com", "date": "2022-06-16T01:53:44Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-06-24T20:10:23Z"}, "message": "Maybe this wil work", "tree": {"sha": "887655f9a57c1bf857450baf3e1962fcffed3d3f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/887655f9a57c1bf857450baf3e1962fcffed3d3f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c7feb014b0b73d2e06ccfd3b754171d3fec7eeda", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c7feb014b0b73d2e06ccfd3b754171d3fec7eeda", "html_url": "https://github.com/rust-lang/rust/commit/c7feb014b0b73d2e06ccfd3b754171d3fec7eeda", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c7feb014b0b73d2e06ccfd3b754171d3fec7eeda/comments", "author": {"login": "carbotaniuman", "id": 41451839, "node_id": "MDQ6VXNlcjQxNDUxODM5", "avatar_url": "https://avatars.githubusercontent.com/u/41451839?v=4", "gravatar_id": "", "url": "https://api.github.com/users/carbotaniuman", "html_url": "https://github.com/carbotaniuman", "followers_url": "https://api.github.com/users/carbotaniuman/followers", "following_url": "https://api.github.com/users/carbotaniuman/following{/other_user}", "gists_url": "https://api.github.com/users/carbotaniuman/gists{/gist_id}", "starred_url": "https://api.github.com/users/carbotaniuman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/carbotaniuman/subscriptions", "organizations_url": "https://api.github.com/users/carbotaniuman/orgs", "repos_url": "https://api.github.com/users/carbotaniuman/repos", "events_url": "https://api.github.com/users/carbotaniuman/events{/privacy}", "received_events_url": "https://api.github.com/users/carbotaniuman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "57ce47b72814f8147d2cddb87628b17aa1084e74", "url": "https://api.github.com/repos/rust-lang/rust/commits/57ce47b72814f8147d2cddb87628b17aa1084e74", "html_url": "https://github.com/rust-lang/rust/commit/57ce47b72814f8147d2cddb87628b17aa1084e74"}], "stats": {"total": 68, "additions": 44, "deletions": 24}, "files": [{"sha": "d28c6425cd42ca26cce26a65b02dc5e72126546b", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 27, "deletions": 22, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/c7feb014b0b73d2e06ccfd3b754171d3fec7eeda/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7feb014b0b73d2e06ccfd3b754171d3fec7eeda/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=c7feb014b0b73d2e06ccfd3b754171d3fec7eeda", "patch": "@@ -485,8 +485,7 @@ impl<'tcx> Stack {\n             }\n         } else {\n             self.borrows.clear();\n-            // TODO\n-            // self.borrows.push(ItemOrUnknown::Unknown(global.next_ptr_id));\n+            self.unknown_bottom = Some(global.next_ptr_id);\n         }\n \n         // Done.\n@@ -541,6 +540,20 @@ impl<'tcx> Stack {\n         let access =\n             if new.perm.grants(AccessKind::Write) { AccessKind::Write } else { AccessKind::Read };\n \n+        // Now we figure out which item grants our parent (`derived_from`) this kind of access.\n+        // We use that to determine where to put the new item.\n+        let granting_idx =\n+        self.find_granting(access, derived_from, exposed_tags).map_err(|_| {\n+            alloc_history.grant_error(\n+                derived_from,\n+                new,\n+                alloc_id,\n+                alloc_range,\n+                offset,\n+                self,\n+            )\n+        })?;\n+\n         // Compute where to put the new item.\n         // Either way, we ensure that we insert the new item in a way such that between\n         // `derived_from` and the new one, there are only items *compatible with* `derived_from`.\n@@ -550,25 +563,17 @@ impl<'tcx> Stack {\n                 \"this case only makes sense for stack-like accesses\"\n             );\n \n-            // Now we figure out which item grants our parent (`derived_from`) this kind of access.\n-            // We use that to determine where to put the new item.\n-            let granting_idx =\n-                self.find_granting(access, derived_from, exposed_tags).map_err(|_| {\n-                    alloc_history.grant_error(\n-                        derived_from,\n-                        new,\n-                        alloc_id,\n-                        alloc_range,\n-                        offset,\n-                        self,\n-                    )\n-                })?;\n-\n-            // SharedReadWrite can coexist with \"existing loans\", meaning they don't act like a write\n-            // access.  Instead of popping the stack, we insert the item at the place the stack would\n-            // be popped to (i.e., we insert it above all the write-compatible items).\n-            // This ensures F2b by adding the new item below any potentially existing `SharedReadOnly`.\n-            self.find_first_write_incompatible(granting_idx)\n+            if derived_from.is_some() {\n+                // SharedReadWrite can coexist with \"existing loans\", meaning they don't act like a write\n+                // access.  Instead of popping the stack, we insert the item at the place the stack would\n+                // be popped to (i.e., we insert it above all the write-compatible items).\n+                // This ensures F2b by adding the new item below any potentially existing `SharedReadOnly`.\n+                self.find_first_write_incompatible(granting_idx)\n+            } else {\n+                // TODO: is this correct\n+                self.borrows.clear();\n+                0\n+            }\n         } else {\n             // A \"safe\" reborrow for a pointer that actually expects some aliasing guarantees.\n             // Here, creating a reference actually counts as an access.\n@@ -590,7 +595,7 @@ impl<'tcx> Stack {\n             self.borrows.len()\n         };\n         // Put the new item there. As an optimization, deduplicate if it is equal to one of its new neighbors.\n-        if self.borrows[new_idx - 1] == new || self.borrows.get(new_idx) == Some(&new) {\n+        if self.borrows.get(new_idx) == Some(&new) || new_idx > 0 && self.borrows.get(new_idx - 1) == Some(&new) {\n             // Optimization applies, done.\n             trace!(\"reborrow: avoiding adding redundant item {:?}\", new);\n         } else {"}, {"sha": "6a22d9a74392f574ad2643e32243e39314af7291", "filename": "src/stacked_borrows/diagnostics.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c7feb014b0b73d2e06ccfd3b754171d3fec7eeda/src%2Fstacked_borrows%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7feb014b0b73d2e06ccfd3b754171d3fec7eeda/src%2Fstacked_borrows%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows%2Fdiagnostics.rs?ref=c7feb014b0b73d2e06ccfd3b754171d3fec7eeda", "patch": "@@ -4,6 +4,8 @@ use rustc_middle::mir::interpret::{AllocId, AllocRange};\n use rustc_span::{Span, SpanData};\n use rustc_target::abi::Size;\n \n+use core::fmt::Debug;\n+\n use crate::helpers::{CurrentSpan, HexRange};\n use crate::stacked_borrows::{err_sb_ub, AccessKind, Permission};\n use crate::Item;\n@@ -204,9 +206,16 @@ impl AllocHistory {\n         error_offset: Size,\n         stack: &Stack,\n     ) -> InterpError<'tcx> {\n+        // TODO: Fix this properly\n+        let z = &derived_from;\n+        let f = if let Some(ref t) = z {\n+            t as &dyn Debug\n+        } else {\n+            &\"<wildcard>\" as &dyn Debug\n+        };\n         let action = format!(\n             \"trying to reborrow {:?} for {:?} permission at {}[{:#x}]\",\n-            derived_from,\n+            f,\n             new.perm,\n             alloc_id,\n             error_offset.bytes(),\n@@ -230,10 +239,16 @@ impl AllocHistory {\n         error_offset: Size,\n         stack: &Stack,\n     ) -> InterpError<'tcx> {\n+        let z = &tag;\n+        let f = if let Some(ref t) = z {\n+            t as &dyn Debug\n+        } else {\n+            &\"<wildcard>\" as &dyn Debug\n+        };\n         let action = format!(\n             \"attempting a {} using {:?} at {}[{:#x}]\",\n             access,\n-            tag,\n+            f,\n             alloc_id,\n             error_offset.bytes(),\n         );"}]}