{"sha": "5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwOTJjNmIwMWFjYmZmNjA5MzVhNWU2ZDg0ZjgzYjZjNzNjMWNhNWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-22T16:58:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-22T16:58:57Z"}, "message": "Auto merge of #49264 - kennytm:rollup, r=kennytm\n\nRollup of 23 pull requests\n\n- Successful merges: #48374, #48596, #48759, #48939, #49029, #49069, #49093, #49109, #49117, #49140, #49158, #49188, #49189, #49209, #49211, #49216, #49225, #49231, #49234, #49242, #49244, #49105, #49038\n- Failed merges:", "tree": {"sha": "bdc8568384c95b430e9bb324b82a876d98b1f56a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bdc8568384c95b430e9bb324b82a876d98b1f56a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "html_url": "https://github.com/rust-lang/rust/commit/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b176285ba775f86301040fc624acb96b4499f562", "url": "https://api.github.com/repos/rust-lang/rust/commits/b176285ba775f86301040fc624acb96b4499f562", "html_url": "https://github.com/rust-lang/rust/commit/b176285ba775f86301040fc624acb96b4499f562"}, {"sha": "2c6f911463efa6c2d87e5566fc1cd77a7d26509a", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c6f911463efa6c2d87e5566fc1cd77a7d26509a", "html_url": "https://github.com/rust-lang/rust/commit/2c6f911463efa6c2d87e5566fc1cd77a7d26509a"}], "stats": {"total": 2686, "additions": 1548, "deletions": 1138}, "files": [{"sha": "41ea0c9afa87cc97c93973e6f3ad5109031393fc", "filename": ".travis.yml", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -318,8 +318,6 @@ before_deploy:\n \n deploy:\n   - provider: s3\n-    edge:\n-      branch: s3-eager-autoload\n     bucket: rust-lang-ci2\n     skip_cleanup: true\n     local_dir: deploy\n@@ -336,8 +334,6 @@ deploy:\n   # this is the same as the above deployment provider except that it uploads to\n   # a slightly different directory and has a different trigger\n   - provider: s3\n-    edge:\n-      branch: s3-eager-autoload\n     bucket: rust-lang-ci2\n     skip_cleanup: true\n     local_dir: deploy\n@@ -355,8 +351,6 @@ deploy:\n   # try branch. Travis does not appear to provide a way to use \"or\" in these\n   # conditions.\n   - provider: s3\n-    edge:\n-      branch: s3-eager-autoload\n     bucket: rust-lang-ci2\n     skip_cleanup: true\n     local_dir: deploy\n@@ -371,8 +365,6 @@ deploy:\n       condition: $DEPLOY = 1\n \n   - provider: s3\n-    edge:\n-      branch: s3-eager-autoload\n     bucket: rust-lang-ci2\n     skip_cleanup: true\n     local_dir: deploy"}, {"sha": "51c36c99858b8851892bcc103109944f94545d43", "filename": "RELEASES.md", "status": "modified", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -1,3 +1,103 @@\n+Version 1.25.0 (2018-03-29)\n+==========================\n+\n+Language\n+--------\n+- [Stabilised `#[repr(align(x))]`.][47006] [RFC 1358]\n+- [You can now use nested groups of imports.][47948]\n+  e.g. `use std::{fs::File, io::Read, path::{Path, PathBuf}};`\n+- [You can now have `|` at the start of a match arm.][47947] e.g.\n+```rust\n+enum Foo { A, B, C }\n+\n+fn main() {\n+    let x = Foo::A;\n+    match x {\n+        | Foo::A\n+        | Foo::B => println!(\"AB\"),\n+        | Foo::C => println!(\"C\"),\n+    }\n+}\n+```\n+\n+Compiler\n+--------\n+- [Upgraded to LLVM 6.][47828]\n+- [Added `-C lto=val` option.][47521]\n+- [Added `i586-unknown-linux-musl` target][47282]\n+\n+Libraries\n+---------\n+- [Impl Send for `process::Command` on Unix.][47760]\n+- [Impl PartialEq and Eq for `ParseCharError`.][47790]\n+- [`UnsafeCell::into_inner` is now safe.][47204]\n+- [Implement libstd for CloudABI.][47268]\n+- [`Float::{from_bits, to_bits}` is now available in libcore.][46931]\n+- [Implement `AsRef<Path>` for Component][46985]\n+- [Implemented `Write` for `Cursor<&mut Vec<T>>`][46830]\n+- [Moved `Duration` to libcore.][46666]\n+\n+Stabilized APIs\n+---------------\n+- [`Location::column`]\n+- [`ptr::NonNull`]\n+\n+The following functions can now be used in a constant expression.\n+eg. `static MINUTE: Duration = Duration::from_secs(60);`\n+- [`Duration::new`][47300]\n+- [`Duration::from_secs`][47300]\n+- [`Duration::from_millis`][47300]\n+- [`Duration::from_micros`][47300]\n+- [`Duration::from_nanos`][47300]\n+\n+Cargo\n+-----\n+- [`cargo new` no longer removes `rust` or `rs` prefixs/suffixs.][cargo/5013]\n+- [`cargo new` now defaults to creating a binary crate, instead of a\n+  library crate.][cargo/5029]\n+\n+Misc\n+----\n+- [Rust by example is now shipped with new releases][46196]\n+\n+Compatibility Notes\n+-------------------\n+- [Deprecated `net::lookup_host`.][47510]\n+- [`rustdoc` has switched to pulldown as the default markdown renderer.][47398]\n+- The borrow checker was sometimes incorrectly permitting overlapping borrows\n+  around indexing operations (see [#47349][47349]). This has been fixed (which also\n+  enabled some correct code that used to cause errors (e.g. [#33903][33903] and [#46095][46095]).\n+- [Removed deprecated unstable attribute `#[simd]`.][47251]\n+\n+[33903]: https://github.com/rust-lang/rust/pull/33903\n+[47947]: https://github.com/rust-lang/rust/pull/47947\n+[47948]: https://github.com/rust-lang/rust/pull/47948\n+[47760]: https://github.com/rust-lang/rust/pull/47760\n+[47790]: https://github.com/rust-lang/rust/pull/47790\n+[47828]: https://github.com/rust-lang/rust/pull/47828\n+[47398]: https://github.com/rust-lang/rust/pull/47398\n+[47510]: https://github.com/rust-lang/rust/pull/47510\n+[47521]: https://github.com/rust-lang/rust/pull/47521\n+[47204]: https://github.com/rust-lang/rust/pull/47204\n+[47251]: https://github.com/rust-lang/rust/pull/47251\n+[47268]: https://github.com/rust-lang/rust/pull/47268\n+[47282]: https://github.com/rust-lang/rust/pull/47282\n+[47300]: https://github.com/rust-lang/rust/pull/47300\n+[47349]: https://github.com/rust-lang/rust/pull/47349\n+[46931]: https://github.com/rust-lang/rust/pull/46931\n+[46985]: https://github.com/rust-lang/rust/pull/46985\n+[47006]: https://github.com/rust-lang/rust/pull/47006\n+[46830]: https://github.com/rust-lang/rust/pull/46830\n+[46095]: https://github.com/rust-lang/rust/pull/46095\n+[46666]: https://github.com/rust-lang/rust/pull/46666\n+[46196]: https://github.com/rust-lang/rust/pull/46196\n+[cargo/5013]: https://github.com/rust-lang/cargo/pull/5013\n+[cargo/5029]: https://github.com/rust-lang/cargo/pull/5029\n+[RFC 1358]: https://github.com/rust-lang/rfcs/pull/1358\n+[`Location::column`]: https://doc.rust-lang.org/std/panic/struct.Location.html#method.column\n+[`ptr::NonNull`]: https://doc.rust-lang.org/std/ptr/struct.NonNull.html\n+\n+\n Version 1.24.0 (2018-02-15)\n ==========================\n "}, {"sha": "a398bcc973746fffb4595ba726a2c1d7630f9365", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -310,12 +310,14 @@ impl<'a> Builder<'a> {\n                 test::UiFullDeps, test::RunPassFullDeps, test::RunFailFullDeps,\n                 test::CompileFailFullDeps, test::IncrementalFullDeps, test::Rustdoc, test::Pretty,\n                 test::RunPassPretty, test::RunFailPretty, test::RunPassValgrindPretty,\n-                test::RunPassFullDepsPretty, test::RunFailFullDepsPretty, test::RunMake,\n+                test::RunPassFullDepsPretty, test::RunFailFullDepsPretty,\n                 test::Crate, test::CrateLibrustc, test::CrateRustdoc, test::Linkcheck,\n                 test::Cargotest, test::Cargo, test::Rls, test::ErrorIndex, test::Distcheck,\n                 test::Nomicon, test::Reference, test::RustdocBook, test::RustByExample,\n                 test::TheBook, test::UnstableBook,\n-                test::Rustfmt, test::Miri, test::Clippy, test::RustdocJS, test::RustdocTheme),\n+                test::Rustfmt, test::Miri, test::Clippy, test::RustdocJS, test::RustdocTheme,\n+                // Run run-make last, since these won't pass without make on Windows\n+                test::RunMake),\n             Kind::Bench => describe!(test::Crate, test::CrateLibrustc),\n             Kind::Doc => describe!(doc::UnstableBook, doc::UnstableBookGen, doc::TheBook,\n                 doc::Standalone, doc::Std, doc::Test, doc::Rustc, doc::ErrorIndex, doc::Nomicon,"}, {"sha": "f2664e6d196c7afcab810ab0ee15f5e30b14eb64", "filename": "src/ci/init_repo.sh", "status": "modified", "additions": 29, "deletions": 43, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Fci%2Finit_repo.sh", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Fci%2Finit_repo.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Finit_repo.sh?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -17,6 +17,7 @@ ci_dir=$(cd $(dirname $0) && pwd)\n . \"$ci_dir/shared.sh\"\n \n travis_fold start init_repo\n+travis_time_start\n \n REPO_DIR=\"$1\"\n CACHE_DIR=\"$2\"\n@@ -42,54 +43,39 @@ if grep -q RUST_RELEASE_CHANNEL=beta src/ci/run.sh; then\n   git fetch origin --unshallow beta master\n fi\n \n-travis_fold start update_cache\n-travis_time_start\n-\n-# Update the cache (a pristine copy of the rust source master)\n-retry sh -c \"rm -rf $cache_src_dir && mkdir -p $cache_src_dir && \\\n-    git clone --depth 1 https://github.com/rust-lang/rust.git $cache_src_dir\"\n-if [ -d $cache_src_dir/src/llvm ]; then\n-  (cd $cache_src_dir && git rm src/llvm)\n-fi\n-if [ -d $cache_src_dir/src/llvm-emscripten ]; then\n-  (cd $cache_src_dir && git rm src/llvm-emscripten)\n-fi\n-retry sh -c \"cd $cache_src_dir && \\\n-    git submodule deinit -f . && git submodule sync && git submodule update --init\"\n-\n-travis_fold end update_cache\n-travis_time_finish\n+function fetch_submodule {\n+    local module=$1\n+    local cached=\"download-${module//\\//-}.tar.gz\"\n+    retry sh -c \"rm -f $cached && \\\n+        curl -sSL -o $cached $2\"\n+    mkdir $module\n+    touch \"$module/.git\"\n+    tar -C $module --strip-components=1 -xf $cached\n+    rm $cached\n+}\n \n-travis_fold start update_submodules\n-travis_time_start\n-\n-# Update the submodules of the repo we're in, using the pristine repo as\n-# a cache for any object files\n-# No, `git submodule foreach` won't work:\n-# http://stackoverflow.com/questions/12641469/list-submodules-in-a-git-repository\n+included=\"src/llvm src/llvm-emscripten src/doc/book src/doc/rust-by-example\"\n modules=\"$(git config --file .gitmodules --get-regexp '\\.path$' | cut -d' ' -f2)\"\n-for module in $modules; do\n-    if [ \"$module\" = src/llvm ] || [ \"$module\" = src/llvm-emscripten ]; then\n+modules=($modules)\n+use_git=\"\"\n+urls=\"$(git config --file .gitmodules --get-regexp '\\.url$' | cut -d' ' -f2)\"\n+urls=($urls)\n+for i in ${!modules[@]}; do\n+    module=${modules[$i]}\n+    if [[ \" $included \" = *\" $module \"* ]]; then\n         commit=\"$(git ls-tree HEAD $module | awk '{print $3}')\"\n         git rm $module\n-        retry sh -c \"rm -f $commit.tar.gz && \\\n-            curl -sSL -O https://github.com/rust-lang/llvm/archive/$commit.tar.gz\"\n-        tar -C src/ -xf \"$commit.tar.gz\"\n-        rm \"$commit.tar.gz\"\n-        mv \"src/llvm-$commit\" $module\n-        continue\n-    fi\n-    if [ ! -e \"$cache_src_dir/$module/.git\" ]; then\n-        echo \"WARNING: $module not found in pristine repo\"\n-        retry sh -c \"git submodule deinit -f $module && \\\n-            git submodule update --init --recursive $module\"\n+        url=${urls[$i]}\n+        url=${url/\\.git/}\n+        fetch_submodule $module \"$url/archive/$commit.tar.gz\" &\n         continue\n+    else\n+        use_git=\"$use_git $module\"\n     fi\n-    retry sh -c \"git submodule deinit -f $module && \\\n-        git submodule update --init --recursive --reference $cache_src_dir/$module $module\"\n done\n-\n-travis_fold end update_submodules\n-travis_time_finish\n-\n+retry sh -c \"git submodule deinit -f $use_git && \\\n+    git submodule sync && \\\n+    git submodule update -j 16 --init --recursive $use_git\"\n+wait\n travis_fold end init_repo\n+travis_time_finish"}, {"sha": "9a26043c92c13a34508af873771f2da3dc5ec578", "filename": "src/ci/run.sh", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Fci%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Fci%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Frun.sh?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -107,15 +107,7 @@ fi\n travis_fold end log-system-info\n \n if [ ! -z \"$SCRIPT\" ]; then\n-  # FIXME(#49246): Re-enable these tools after #49246 has been merged and thus fixing the cache.\n-  if [ \"$DEPLOY_ALT\" = 1 ]; then\n-    sh -x -c \"$SCRIPT \\\n-       --exclude src/tools/rls \\\n-       --exclude src/tools/rustfmt \\\n-       --exclude src/tools/clippy\"\n-  else\n-    sh -x -c \"$SCRIPT\"\n-  fi\n+  sh -x -c \"$SCRIPT\"\n else\n   do_make() {\n     travis_fold start \"make-$1\""}, {"sha": "3f679d81f08de9bd59a5019ddfd12033ebd59310", "filename": "src/liballoc/tests/slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Fliballoc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Fliballoc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fslice.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -1351,7 +1351,7 @@ fn test_copy_from_slice_dst_shorter() {\n const MAX_LEN: usize = 80;\n \n static DROP_COUNTS: [AtomicUsize; MAX_LEN] = [\n-    // FIXME #5244: AtomicUsize is not Copy.\n+    // FIXME(RFC 1109): AtomicUsize is not Copy.\n     AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n     AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n     AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),"}, {"sha": "7324df95bc5d5691306ba78924148e593abb4ed4", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 3, "deletions": 22, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -48,25 +48,6 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use fmt;\n-\n-/// A type used as the error type for implementations of fallible conversion\n-/// traits in cases where conversions cannot actually fail.\n-///\n-/// Because `Infallible` has no variants, a value of this type can never exist.\n-/// It is used only to satisfy trait signatures that expect an error type, and\n-/// signals to both the compiler and the user that the error case is impossible.\n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n-#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]\n-pub enum Infallible {}\n-\n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n-impl fmt::Display for Infallible {\n-    fn fmt(&self, _: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-        }\n-    }\n-}\n /// A cheap reference-to-reference conversion. Used to convert a value to a\n /// reference value within generic code.\n ///\n@@ -382,7 +363,7 @@ impl<'a, T: ?Sized, U: ?Sized> AsRef<U> for &'a mut T where T: AsRef<U>\n     }\n }\n \n-// FIXME (#23442): replace the above impls for &/&mut with the following more general one:\n+// FIXME (#45742): replace the above impls for &/&mut with the following more general one:\n // // As lifts over Deref\n // impl<D: ?Sized + Deref, U: ?Sized> AsRef<U> for D where D::Target: AsRef<U> {\n //     fn as_ref(&self) -> &U {\n@@ -399,7 +380,7 @@ impl<'a, T: ?Sized, U: ?Sized> AsMut<U> for &'a mut T where T: AsMut<U>\n     }\n }\n \n-// FIXME (#23442): replace the above impl for &mut with the following more general one:\n+// FIXME (#45742): replace the above impl for &mut with the following more general one:\n // // AsMut lifts over DerefMut\n // impl<D: ?Sized + Deref, U: ?Sized> AsMut<U> for D where D::Target: AsMut<U> {\n //     fn as_mut(&mut self) -> &mut U {\n@@ -438,7 +419,7 @@ impl<T, U> TryInto<U> for T where U: TryFrom<T>\n // with an uninhabited error type.\n #[unstable(feature = \"try_from\", issue = \"33417\")]\n impl<T, U> TryFrom<U> for T where T: From<U> {\n-    type Error = Infallible;\n+    type Error = !;\n \n     fn try_from(value: U) -> Result<Self, Self::Error> {\n         Ok(T::from(value))"}, {"sha": "1e8476d3880c8a4fc197c0c95e647ebca69ccf62", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -1872,7 +1872,7 @@ impl<I: Iterator> Iterator for Peekable<I> {\n \n     #[inline]\n     fn nth(&mut self, n: usize) -> Option<I::Item> {\n-        // FIXME(#6393): merge these when borrow-checking gets better.\n+        // FIXME(#43234): merge these when borrow-checking gets better.\n         if n == 0 {\n             match self.peeked.take() {\n                 Some(v) => v,"}, {"sha": "4583e45bb12ebeebe3008fc1eeaaa8cd2941f737", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -12,7 +12,7 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use convert::{Infallible, TryFrom};\n+use convert::TryFrom;\n use fmt;\n use intrinsics;\n use ops;\n@@ -3596,10 +3596,9 @@ impl fmt::Display for TryFromIntError {\n }\n \n #[unstable(feature = \"try_from\", issue = \"33417\")]\n-impl From<Infallible> for TryFromIntError {\n-    fn from(infallible: Infallible) -> TryFromIntError {\n-        match infallible {\n-        }\n+impl From<!> for TryFromIntError {\n+    fn from(never: !) -> TryFromIntError {\n+        never\n     }\n }\n \n@@ -3608,7 +3607,7 @@ macro_rules! try_from_unbounded {\n     ($source:ty, $($target:ty),*) => {$(\n         #[unstable(feature = \"try_from\", issue = \"33417\")]\n         impl TryFrom<$source> for $target {\n-            type Error = Infallible;\n+            type Error = !;\n \n             #[inline]\n             fn try_from(value: $source) -> Result<Self, Self::Error> {\n@@ -3719,7 +3718,7 @@ try_from_lower_bounded!(isize, usize);\n #[cfg(target_pointer_width = \"16\")]\n mod ptr_try_from_impls {\n     use super::TryFromIntError;\n-    use convert::{Infallible, TryFrom};\n+    use convert::TryFrom;\n \n     try_from_upper_bounded!(usize, u8);\n     try_from_unbounded!(usize, u16, u32, u64, u128);\n@@ -3745,7 +3744,7 @@ mod ptr_try_from_impls {\n #[cfg(target_pointer_width = \"32\")]\n mod ptr_try_from_impls {\n     use super::TryFromIntError;\n-    use convert::{Infallible, TryFrom};\n+    use convert::TryFrom;\n \n     try_from_upper_bounded!(usize, u8, u16);\n     try_from_unbounded!(usize, u32, u64, u128);\n@@ -3771,7 +3770,7 @@ mod ptr_try_from_impls {\n #[cfg(target_pointer_width = \"64\")]\n mod ptr_try_from_impls {\n     use super::TryFromIntError;\n-    use convert::{Infallible, TryFrom};\n+    use convert::TryFrom;\n \n     try_from_upper_bounded!(usize, u8, u16, u32);\n     try_from_unbounded!(usize, u64, u128);"}, {"sha": "1185b7acaae1f3101d34307983185843208ae8f0", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -165,6 +165,37 @@ Section: Creating a string\n ///\n /// [`String`]: ../../std/string/struct.String.html#method.from_utf8\n /// [`&str`]: ../../std/str/fn.from_utf8.html\n+///\n+/// # Examples\n+///\n+/// This error type\u2019s methods can be used to create functionality\n+/// similar to `String::from_utf8_lossy` without allocating heap memory:\n+///\n+/// ```\n+/// fn from_utf8_lossy<F>(mut input: &[u8], mut push: F) where F: FnMut(&str) {\n+///     loop {\n+///         match ::std::str::from_utf8(input) {\n+///             Ok(valid) => {\n+///                 push(valid);\n+///                 break\n+///             }\n+///             Err(error) => {\n+///                 let (valid, after_valid) = input.split_at(error.valid_up_to());\n+///                 unsafe {\n+///                     push(::std::str::from_utf8_unchecked(valid))\n+///                 }\n+///                 push(\"\\u{FFFD}\");\n+///\n+///                 if let Some(invalid_sequence_length) = error.error_len() {\n+///                     input = &after_valid[invalid_sequence_length..]\n+///                 } else {\n+///                     break\n+///                 }\n+///             }\n+///         }\n+///     }\n+/// }\n+/// ```\n #[derive(Copy, Eq, PartialEq, Clone, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Utf8Error {"}, {"sha": "fe5ed5d49422439147d860657366c6d16b061cd8", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 401, "deletions": 364, "changes": 765, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -948,6 +948,7 @@ macro_rules! atomic_int {\n      $stable_from:meta,\n      $stable_nand:meta,\n      $s_int_type:expr, $int_ref:expr,\n+     $extra_feature:expr,\n      $int_type:ident $atomic_type:ident $atomic_init:ident) => {\n         /// An integer type which can be safely shared between threads.\n         ///\n@@ -959,12 +960,7 @@ macro_rules! atomic_int {\n         /// ). For more about the differences between atomic types and\n         /// non-atomic types, please see the [module-level documentation].\n         ///\n-        /// Please note that examples are shared between atomic variants of\n-        /// primitive integer types, so it's normal that they are all\n-        /// demonstrating [`AtomicIsize`].\n-        ///\n         /// [module-level documentation]: index.html\n-        /// [`AtomicIsize`]: struct.AtomicIsize.html\n         #[$stable]\n         pub struct $atomic_type {\n             v: UnsafeCell<$int_type>,\n@@ -1001,395 +997,426 @@ macro_rules! atomic_int {\n         unsafe impl Sync for $atomic_type {}\n \n         impl $atomic_type {\n-            /// Creates a new atomic integer.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::AtomicIsize;\n-            ///\n-            /// let atomic_forty_two  = AtomicIsize::new(42);\n-            /// ```\n-            #[inline]\n-            #[$stable]\n-            pub const fn new(v: $int_type) -> Self {\n-                $atomic_type {v: UnsafeCell::new(v)}\n+            doc_comment! {\n+                concat!(\"Creates a new atomic integer.\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::\", stringify!($atomic_type), \";\n+\n+let atomic_forty_two = \", stringify!($atomic_type), \"::new(42);\n+```\"),\n+                #[inline]\n+                #[$stable]\n+                pub const fn new(v: $int_type) -> Self {\n+                    $atomic_type {v: UnsafeCell::new(v)}\n+                }\n             }\n \n-            /// Returns a mutable reference to the underlying integer.\n-            ///\n-            /// This is safe because the mutable reference guarantees that no other threads are\n-            /// concurrently accessing the atomic data.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::{AtomicIsize, Ordering};\n-            ///\n-            /// let mut some_isize = AtomicIsize::new(10);\n-            /// assert_eq!(*some_isize.get_mut(), 10);\n-            /// *some_isize.get_mut() = 5;\n-            /// assert_eq!(some_isize.load(Ordering::SeqCst), 5);\n-            /// ```\n-            #[inline]\n-            #[$stable_access]\n-            pub fn get_mut(&mut self) -> &mut $int_type {\n-                unsafe { &mut *self.v.get() }\n+            doc_comment! {\n+                concat!(\"Returns a mutable reference to the underlying integer.\n+\n+This is safe because the mutable reference guarantees that no other threads are\n+concurrently accessing the atomic data.\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let mut some_var = \", stringify!($atomic_type), \"::new(10);\n+assert_eq!(*some_var.get_mut(), 10);\n+*some_var.get_mut() = 5;\n+assert_eq!(some_var.load(Ordering::SeqCst), 5);\n+```\"),\n+                #[inline]\n+                #[$stable_access]\n+                pub fn get_mut(&mut self) -> &mut $int_type {\n+                    unsafe { &mut *self.v.get() }\n+                }\n             }\n \n-            /// Consumes the atomic and returns the contained value.\n-            ///\n-            /// This is safe because passing `self` by value guarantees that no other threads are\n-            /// concurrently accessing the atomic data.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::AtomicIsize;\n-            ///\n-            /// let some_isize = AtomicIsize::new(5);\n-            /// assert_eq!(some_isize.into_inner(), 5);\n-            /// ```\n-            #[inline]\n-            #[$stable_access]\n-            pub fn into_inner(self) -> $int_type {\n-                self.v.into_inner()\n+            doc_comment! {\n+                concat!(\"Consumes the atomic and returns the contained value.\n+\n+This is safe because passing `self` by value guarantees that no other threads are\n+concurrently accessing the atomic data.\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::\", stringify!($atomic_type), \";\n+\n+let some_var = \", stringify!($atomic_type), \"::new(5);\n+assert_eq!(some_var.into_inner(), 5);\n+```\"),\n+                #[inline]\n+                #[$stable_access]\n+                pub fn into_inner(self) -> $int_type {\n+                    self.v.into_inner()\n+                }\n             }\n \n-            /// Loads a value from the atomic integer.\n-            ///\n-            /// `load` takes an [`Ordering`] argument which describes the memory ordering of this\n-            /// operation.\n-            ///\n-            /// # Panics\n-            ///\n-            /// Panics if `order` is [`Release`] or [`AcqRel`].\n-            ///\n-            /// [`Ordering`]: enum.Ordering.html\n-            /// [`Release`]: enum.Ordering.html#variant.Release\n-            /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::{AtomicIsize, Ordering};\n-            ///\n-            /// let some_isize = AtomicIsize::new(5);\n-            ///\n-            /// assert_eq!(some_isize.load(Ordering::Relaxed), 5);\n-            /// ```\n-            #[inline]\n-            #[$stable]\n-            pub fn load(&self, order: Ordering) -> $int_type {\n-                unsafe { atomic_load(self.v.get(), order) }\n+            doc_comment! {\n+                concat!(\"Loads a value from the atomic integer.\n+\n+`load` takes an [`Ordering`] argument which describes the memory ordering of this operation.\n+\n+# Panics\n+\n+Panics if `order` is [`Release`] or [`AcqRel`].\n+\n+[`Ordering`]: enum.Ordering.html\n+[`Release`]: enum.Ordering.html#variant.Release\n+[`AcqRel`]: enum.Ordering.html#variant.AcqRel\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let some_var = \", stringify!($atomic_type), \"::new(5);\n+\n+assert_eq!(some_var.load(Ordering::Relaxed), 5);\n+```\"),\n+                #[inline]\n+                #[$stable]\n+                pub fn load(&self, order: Ordering) -> $int_type {\n+                    unsafe { atomic_load(self.v.get(), order) }\n+                }\n             }\n \n-            /// Stores a value into the atomic integer.\n-            ///\n-            /// `store` takes an [`Ordering`] argument which describes the memory ordering of this\n-            /// operation.\n-            ///\n-            /// [`Ordering`]: enum.Ordering.html\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::{AtomicIsize, Ordering};\n-            ///\n-            /// let some_isize = AtomicIsize::new(5);\n-            ///\n-            /// some_isize.store(10, Ordering::Relaxed);\n-            /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n-            /// ```\n-            ///\n-            /// # Panics\n-            ///\n-            /// Panics if `order` is [`Acquire`] or [`AcqRel`].\n-            ///\n-            /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n-            /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n-            #[inline]\n-            #[$stable]\n-            pub fn store(&self, val: $int_type, order: Ordering) {\n-                unsafe { atomic_store(self.v.get(), val, order); }\n+            doc_comment! {\n+                concat!(\"Stores a value into the atomic integer.\n+\n+`store` takes an [`Ordering`] argument which describes the memory ordering of this operation.\n+\n+[`Ordering`]: enum.Ordering.html\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let some_var = \", stringify!($atomic_type), \"::new(5);\n+\n+some_var.store(10, Ordering::Relaxed);\n+assert_eq!(some_var.load(Ordering::Relaxed), 10);\n+```\n+\n+# Panics\n+\n+Panics if `order` is [`Acquire`] or [`AcqRel`].\n+\n+[`Acquire`]: enum.Ordering.html#variant.Acquire\n+[`AcqRel`]: enum.Ordering.html#variant.AcqRel\"),\n+                #[inline]\n+                #[$stable]\n+                pub fn store(&self, val: $int_type, order: Ordering) {\n+                    unsafe { atomic_store(self.v.get(), val, order); }\n+                }\n             }\n \n-            /// Stores a value into the atomic integer, returning the previous value.\n-            ///\n-            /// `swap` takes an [`Ordering`] argument which describes the memory ordering of this\n-            /// operation.\n-            ///\n-            /// [`Ordering`]: enum.Ordering.html\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::{AtomicIsize, Ordering};\n-            ///\n-            /// let some_isize = AtomicIsize::new(5);\n-            ///\n-            /// assert_eq!(some_isize.swap(10, Ordering::Relaxed), 5);\n-            /// ```\n-            #[inline]\n-            #[$stable]\n-            pub fn swap(&self, val: $int_type, order: Ordering) -> $int_type {\n-                unsafe { atomic_swap(self.v.get(), val, order) }\n+            doc_comment! {\n+                concat!(\"Stores a value into the atomic integer, returning the previous value.\n+\n+`swap` takes an [`Ordering`] argument which describes the memory ordering of this operation.\n+\n+[`Ordering`]: enum.Ordering.html\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let some_var = \", stringify!($atomic_type), \"::new(5);\n+\n+assert_eq!(some_var.swap(10, Ordering::Relaxed), 5);\n+```\"),\n+                #[inline]\n+                #[$stable]\n+                pub fn swap(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    unsafe { atomic_swap(self.v.get(), val, order) }\n+                }\n             }\n \n-            /// Stores a value into the atomic integer if the current value is the same as the\n-            /// `current` value.\n-            ///\n-            /// The return value is always the previous value. If it is equal to `current`, then the\n-            /// value was updated.\n-            ///\n-            /// `compare_and_swap` also takes an [`Ordering`] argument which describes the memory\n-            /// ordering of this operation.\n-            ///\n-            /// [`Ordering`]: enum.Ordering.html\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::{AtomicIsize, Ordering};\n-            ///\n-            /// let some_isize = AtomicIsize::new(5);\n-            ///\n-            /// assert_eq!(some_isize.compare_and_swap(5, 10, Ordering::Relaxed), 5);\n-            /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n-            ///\n-            /// assert_eq!(some_isize.compare_and_swap(6, 12, Ordering::Relaxed), 10);\n-            /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n-            /// ```\n-            #[inline]\n-            #[$stable]\n-            pub fn compare_and_swap(&self,\n-                                    current: $int_type,\n-                                    new: $int_type,\n-                                    order: Ordering) -> $int_type {\n-                match self.compare_exchange(current,\n-                                            new,\n-                                            order,\n-                                            strongest_failure_ordering(order)) {\n-                    Ok(x) => x,\n-                    Err(x) => x,\n+            doc_comment! {\n+                concat!(\"Stores a value into the atomic integer if the current value is the same as\n+the `current` value.\n+\n+The return value is always the previous value. If it is equal to `current`, then the\n+value was updated.\n+\n+`compare_and_swap` also takes an [`Ordering`] argument which describes the memory\n+ordering of this operation.\n+\n+[`Ordering`]: enum.Ordering.html\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let some_var = \", stringify!($atomic_type), \"::new(5);\n+\n+assert_eq!(some_var.compare_and_swap(5, 10, Ordering::Relaxed), 5);\n+assert_eq!(some_var.load(Ordering::Relaxed), 10);\n+\n+assert_eq!(some_var.compare_and_swap(6, 12, Ordering::Relaxed), 10);\n+assert_eq!(some_var.load(Ordering::Relaxed), 10);\n+```\"),\n+                #[inline]\n+                #[$stable]\n+                pub fn compare_and_swap(&self,\n+                                        current: $int_type,\n+                                        new: $int_type,\n+                                        order: Ordering) -> $int_type {\n+                    match self.compare_exchange(current,\n+                                                new,\n+                                                order,\n+                                                strongest_failure_ordering(order)) {\n+                        Ok(x) => x,\n+                        Err(x) => x,\n+                    }\n                 }\n             }\n \n-            /// Stores a value into the atomic integer if the current value is the same as the\n-            /// `current` value.\n-            ///\n-            /// The return value is a result indicating whether the new value was written and\n-            /// containing the previous value. On success this value is guaranteed to be equal to\n-            /// `current`.\n-            ///\n-            /// `compare_exchange` takes two [`Ordering`] arguments to describe the memory\n-            /// ordering of this operation. The first describes the required ordering if\n-            /// the operation succeeds while the second describes the required ordering when\n-            /// the operation fails. The failure ordering can't be [`Release`] or [`AcqRel`] and\n-            /// must be equivalent or weaker than the success ordering.\n-            ///\n-            /// [`Ordering`]: enum.Ordering.html\n-            /// [`Release`]: enum.Ordering.html#variant.Release\n-            /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::{AtomicIsize, Ordering};\n-            ///\n-            /// let some_isize = AtomicIsize::new(5);\n-            ///\n-            /// assert_eq!(some_isize.compare_exchange(5, 10,\n-            ///                                        Ordering::Acquire,\n-            ///                                        Ordering::Relaxed),\n-            ///            Ok(5));\n-            /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n-            ///\n-            /// assert_eq!(some_isize.compare_exchange(6, 12,\n-            ///                                        Ordering::SeqCst,\n-            ///                                        Ordering::Acquire),\n-            ///            Err(10));\n-            /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n-            /// ```\n-            #[inline]\n-            #[$stable_cxchg]\n-            pub fn compare_exchange(&self,\n-                                    current: $int_type,\n-                                    new: $int_type,\n-                                    success: Ordering,\n-                                    failure: Ordering) -> Result<$int_type, $int_type> {\n-                unsafe { atomic_compare_exchange(self.v.get(), current, new, success, failure) }\n+            doc_comment! {\n+                concat!(\"Stores a value into the atomic integer if the current value is the same as\n+the `current` value.\n+\n+The return value is a result indicating whether the new value was written and\n+containing the previous value. On success this value is guaranteed to be equal to\n+`current`.\n+\n+`compare_exchange` takes two [`Ordering`] arguments to describe the memory\n+ordering of this operation. The first describes the required ordering if\n+the operation succeeds while the second describes the required ordering when\n+the operation fails. The failure ordering can't be [`Release`] or [`AcqRel`] and\n+must be equivalent or weaker than the success ordering.\n+\n+[`Ordering`]: enum.Ordering.html\n+[`Release`]: enum.Ordering.html#variant.Release\n+[`AcqRel`]: enum.Ordering.html#variant.AcqRel\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let some_var = \", stringify!($atomic_type), \"::new(5);\n+\n+assert_eq!(some_var.compare_exchange(5, 10,\n+                                     Ordering::Acquire,\n+                                     Ordering::Relaxed),\n+           Ok(5));\n+assert_eq!(some_var.load(Ordering::Relaxed), 10);\n+\n+assert_eq!(some_var.compare_exchange(6, 12,\n+                                     Ordering::SeqCst,\n+                                     Ordering::Acquire),\n+           Err(10));\n+assert_eq!(some_var.load(Ordering::Relaxed), 10);\n+```\"),\n+                #[inline]\n+                #[$stable_cxchg]\n+                pub fn compare_exchange(&self,\n+                                        current: $int_type,\n+                                        new: $int_type,\n+                                        success: Ordering,\n+                                        failure: Ordering) -> Result<$int_type, $int_type> {\n+                    unsafe { atomic_compare_exchange(self.v.get(), current, new, success, failure) }\n+                }\n             }\n \n-            /// Stores a value into the atomic integer if the current value is the same as the\n-            /// `current` value.\n-            ///\n-            /// Unlike [`compare_exchange`], this function is allowed to spuriously fail even\n-            /// when the comparison succeeds, which can result in more efficient code on some\n-            /// platforms. The return value is a result indicating whether the new value was\n-            /// written and containing the previous value.\n-            ///\n-            /// `compare_exchange_weak` takes two [`Ordering`] arguments to describe the memory\n-            /// ordering of this operation. The first describes the required ordering if the\n-            /// operation succeeds while the second describes the required ordering when the\n-            /// operation fails. The failure ordering can't be [`Release`] or [`AcqRel`] and\n-            /// must be equivalent or weaker than the success ordering.\n-            ///\n-            /// [`compare_exchange`]: #method.compare_exchange\n-            /// [`Ordering`]: enum.Ordering.html\n-            /// [`Release`]: enum.Ordering.html#variant.Release\n-            /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::{AtomicIsize, Ordering};\n-            ///\n-            /// let val = AtomicIsize::new(4);\n-            ///\n-            /// let mut old = val.load(Ordering::Relaxed);\n-            /// loop {\n-            ///     let new = old * 2;\n-            ///     match val.compare_exchange_weak(old, new, Ordering::SeqCst, Ordering::Relaxed) {\n-            ///         Ok(_) => break,\n-            ///         Err(x) => old = x,\n-            ///     }\n-            /// }\n-            /// ```\n-            #[inline]\n-            #[$stable_cxchg]\n-            pub fn compare_exchange_weak(&self,\n-                                         current: $int_type,\n-                                         new: $int_type,\n-                                         success: Ordering,\n-                                         failure: Ordering) -> Result<$int_type, $int_type> {\n-                unsafe {\n-                    atomic_compare_exchange_weak(self.v.get(), current, new, success, failure)\n+            doc_comment! {\n+                concat!(\"Stores a value into the atomic integer if the current value is the same as\n+the `current` value.\n+\n+Unlike [`compare_exchange`], this function is allowed to spuriously fail even\n+when the comparison succeeds, which can result in more efficient code on some\n+platforms. The return value is a result indicating whether the new value was\n+written and containing the previous value.\n+\n+`compare_exchange_weak` takes two [`Ordering`] arguments to describe the memory\n+ordering of this operation. The first describes the required ordering if the\n+operation succeeds while the second describes the required ordering when the\n+operation fails. The failure ordering can't be [`Release`] or [`AcqRel`] and\n+must be equivalent or weaker than the success ordering.\n+\n+[`compare_exchange`]: #method.compare_exchange\n+[`Ordering`]: enum.Ordering.html\n+[`Release`]: enum.Ordering.html#variant.Release\n+[`AcqRel`]: enum.Ordering.html#variant.AcqRel\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let val = \", stringify!($atomic_type), \"::new(4);\n+\n+let mut old = val.load(Ordering::Relaxed);\n+loop {\n+    let new = old * 2;\n+    match val.compare_exchange_weak(old, new, Ordering::SeqCst, Ordering::Relaxed) {\n+        Ok(_) => break,\n+        Err(x) => old = x,\n+    }\n+}\n+```\"),\n+                #[inline]\n+                #[$stable_cxchg]\n+                pub fn compare_exchange_weak(&self,\n+                                             current: $int_type,\n+                                             new: $int_type,\n+                                             success: Ordering,\n+                                             failure: Ordering) -> Result<$int_type, $int_type> {\n+                    unsafe {\n+                        atomic_compare_exchange_weak(self.v.get(), current, new, success, failure)\n+                    }\n                 }\n             }\n \n-            /// Adds to the current value, returning the previous value.\n-            ///\n-            /// This operation wraps around on overflow.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::{AtomicIsize, Ordering};\n-            ///\n-            /// let foo = AtomicIsize::new(0);\n-            /// assert_eq!(foo.fetch_add(10, Ordering::SeqCst), 0);\n-            /// assert_eq!(foo.load(Ordering::SeqCst), 10);\n-            /// ```\n-            #[inline]\n-            #[$stable]\n-            pub fn fetch_add(&self, val: $int_type, order: Ordering) -> $int_type {\n-                unsafe { atomic_add(self.v.get(), val, order) }\n+            doc_comment! {\n+                concat!(\"Adds to the current value, returning the previous value.\n+\n+This operation wraps around on overflow.\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let foo = \", stringify!($atomic_type), \"::new(0);\n+assert_eq!(foo.fetch_add(10, Ordering::SeqCst), 0);\n+assert_eq!(foo.load(Ordering::SeqCst), 10);\n+```\"),\n+                #[inline]\n+                #[$stable]\n+                pub fn fetch_add(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    unsafe { atomic_add(self.v.get(), val, order) }\n+                }\n             }\n \n-            /// Subtracts from the current value, returning the previous value.\n-            ///\n-            /// This operation wraps around on overflow.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::{AtomicIsize, Ordering};\n-            ///\n-            /// let foo = AtomicIsize::new(0);\n-            /// assert_eq!(foo.fetch_sub(10, Ordering::SeqCst), 0);\n-            /// assert_eq!(foo.load(Ordering::SeqCst), -10);\n-            /// ```\n-            #[inline]\n-            #[$stable]\n-            pub fn fetch_sub(&self, val: $int_type, order: Ordering) -> $int_type {\n-                unsafe { atomic_sub(self.v.get(), val, order) }\n+            doc_comment! {\n+                concat!(\"Subtracts from the current value, returning the previous value.\n+\n+This operation wraps around on overflow.\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let foo = \", stringify!($atomic_type), \"::new(20);\n+assert_eq!(foo.fetch_sub(10, Ordering::SeqCst), 20);\n+assert_eq!(foo.load(Ordering::SeqCst), 10);\n+```\"),\n+                #[inline]\n+                #[$stable]\n+                pub fn fetch_sub(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    unsafe { atomic_sub(self.v.get(), val, order) }\n+                }\n             }\n \n-            /// Bitwise \"and\" with the current value.\n-            ///\n-            /// Performs a bitwise \"and\" operation on the current value and the argument `val`, and\n-            /// sets the new value to the result.\n-            ///\n-            /// Returns the previous value.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::{AtomicIsize, Ordering};\n-            ///\n-            /// let foo = AtomicIsize::new(0b101101);\n-            /// assert_eq!(foo.fetch_and(0b110011, Ordering::SeqCst), 0b101101);\n-            /// assert_eq!(foo.load(Ordering::SeqCst), 0b100001);\n-            #[inline]\n-            #[$stable]\n-            pub fn fetch_and(&self, val: $int_type, order: Ordering) -> $int_type {\n-                unsafe { atomic_and(self.v.get(), val, order) }\n+            doc_comment! {\n+                concat!(\"Bitwise \\\"and\\\" with the current value.\n+\n+Performs a bitwise \\\"and\\\" operation on the current value and the argument `val`, and\n+sets the new value to the result.\n+\n+Returns the previous value.\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let foo = \", stringify!($atomic_type), \"::new(0b101101);\n+assert_eq!(foo.fetch_and(0b110011, Ordering::SeqCst), 0b101101);\n+assert_eq!(foo.load(Ordering::SeqCst), 0b100001);\n+```\"),\n+                #[inline]\n+                #[$stable]\n+                pub fn fetch_and(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    unsafe { atomic_and(self.v.get(), val, order) }\n+                }\n             }\n \n-            /// Bitwise \"nand\" with the current value.\n-            ///\n-            /// Performs a bitwise \"nand\" operation on the current value and the argument `val`, and\n-            /// sets the new value to the result.\n-            ///\n-            /// Returns the previous value.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// #![feature(atomic_nand)]\n-            ///\n-            /// use std::sync::atomic::{AtomicIsize, Ordering};\n-            ///\n-            /// let foo = AtomicIsize::new(0xf731);\n-            /// assert_eq!(foo.fetch_nand(0x137f, Ordering::SeqCst), 0xf731);\n-            /// assert_eq!(foo.load(Ordering::SeqCst), !(0xf731 & 0x137f));\n-            #[inline]\n-            #[$stable_nand]\n-            pub fn fetch_nand(&self, val: $int_type, order: Ordering) -> $int_type {\n-                unsafe { atomic_nand(self.v.get(), val, order) }\n+            doc_comment! {\n+                concat!(\"Bitwise \\\"nand\\\" with the current value.\n+\n+Performs a bitwise \\\"nand\\\" operation on the current value and the argument `val`, and\n+sets the new value to the result.\n+\n+Returns the previous value.\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"#![feature(atomic_nand)]\n+\n+use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let foo = \", stringify!($atomic_type), \"::new(0x13);\n+assert_eq!(foo.fetch_nand(0x31, Ordering::SeqCst), 0x13);\n+assert_eq!(foo.load(Ordering::SeqCst), !(0x13 & 0x31));\n+```\"),\n+                #[inline]\n+                #[$stable_nand]\n+                pub fn fetch_nand(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    unsafe { atomic_nand(self.v.get(), val, order) }\n+                }\n             }\n \n-            /// Bitwise \"or\" with the current value.\n-            ///\n-            /// Performs a bitwise \"or\" operation on the current value and the argument `val`, and\n-            /// sets the new value to the result.\n-            ///\n-            /// Returns the previous value.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::{AtomicIsize, Ordering};\n-            ///\n-            /// let foo = AtomicIsize::new(0b101101);\n-            /// assert_eq!(foo.fetch_or(0b110011, Ordering::SeqCst), 0b101101);\n-            /// assert_eq!(foo.load(Ordering::SeqCst), 0b111111);\n-            #[inline]\n-            #[$stable]\n-            pub fn fetch_or(&self, val: $int_type, order: Ordering) -> $int_type {\n-                unsafe { atomic_or(self.v.get(), val, order) }\n+            doc_comment! {\n+                concat!(\"Bitwise \\\"or\\\" with the current value.\n+\n+Performs a bitwise \\\"or\\\" operation on the current value and the argument `val`, and\n+sets the new value to the result.\n+\n+Returns the previous value.\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let foo = \", stringify!($atomic_type), \"::new(0b101101);\n+assert_eq!(foo.fetch_or(0b110011, Ordering::SeqCst), 0b101101);\n+assert_eq!(foo.load(Ordering::SeqCst), 0b111111);\n+```\"),\n+                #[inline]\n+                #[$stable]\n+                pub fn fetch_or(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    unsafe { atomic_or(self.v.get(), val, order) }\n+                }\n             }\n \n-            /// Bitwise \"xor\" with the current value.\n-            ///\n-            /// Performs a bitwise \"xor\" operation on the current value and the argument `val`, and\n-            /// sets the new value to the result.\n-            ///\n-            /// Returns the previous value.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::{AtomicIsize, Ordering};\n-            ///\n-            /// let foo = AtomicIsize::new(0b101101);\n-            /// assert_eq!(foo.fetch_xor(0b110011, Ordering::SeqCst), 0b101101);\n-            /// assert_eq!(foo.load(Ordering::SeqCst), 0b011110);\n-            #[inline]\n-            #[$stable]\n-            pub fn fetch_xor(&self, val: $int_type, order: Ordering) -> $int_type {\n-                unsafe { atomic_xor(self.v.get(), val, order) }\n+            doc_comment! {\n+                concat!(\"Bitwise \\\"xor\\\" with the current value.\n+\n+Performs a bitwise \\\"xor\\\" operation on the current value and the argument `val`, and\n+sets the new value to the result.\n+\n+Returns the previous value.\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let foo = \", stringify!($atomic_type), \"::new(0b101101);\n+assert_eq!(foo.fetch_xor(0b110011, Ordering::SeqCst), 0b101101);\n+assert_eq!(foo.load(Ordering::SeqCst), 0b011110);\n+```\"),\n+                #[inline]\n+                #[$stable]\n+                pub fn fetch_xor(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    unsafe { atomic_xor(self.v.get(), val, order) }\n+                }\n             }\n         }\n     }\n@@ -1404,6 +1431,7 @@ atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"i8\", \"../../../std/primitive.i8.html\",\n+    \"#![feature(integer_atomics)]\\n\\n\",\n     i8 AtomicI8 ATOMIC_I8_INIT\n }\n #[cfg(target_has_atomic = \"8\")]\n@@ -1415,6 +1443,7 @@ atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"u8\", \"../../../std/primitive.u8.html\",\n+    \"#![feature(integer_atomics)]\\n\\n\",\n     u8 AtomicU8 ATOMIC_U8_INIT\n }\n #[cfg(target_has_atomic = \"16\")]\n@@ -1426,6 +1455,7 @@ atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"i16\", \"../../../std/primitive.i16.html\",\n+    \"#![feature(integer_atomics)]\\n\\n\",\n     i16 AtomicI16 ATOMIC_I16_INIT\n }\n #[cfg(target_has_atomic = \"16\")]\n@@ -1437,6 +1467,7 @@ atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"u16\", \"../../../std/primitive.u16.html\",\n+    \"#![feature(integer_atomics)]\\n\\n\",\n     u16 AtomicU16 ATOMIC_U16_INIT\n }\n #[cfg(target_has_atomic = \"32\")]\n@@ -1448,6 +1479,7 @@ atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"i32\", \"../../../std/primitive.i32.html\",\n+    \"#![feature(integer_atomics)]\\n\\n\",\n     i32 AtomicI32 ATOMIC_I32_INIT\n }\n #[cfg(target_has_atomic = \"32\")]\n@@ -1459,6 +1491,7 @@ atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"u32\", \"../../../std/primitive.u32.html\",\n+    \"#![feature(integer_atomics)]\\n\\n\",\n     u32 AtomicU32 ATOMIC_U32_INIT\n }\n #[cfg(target_has_atomic = \"64\")]\n@@ -1470,6 +1503,7 @@ atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"i64\", \"../../../std/primitive.i64.html\",\n+    \"#![feature(integer_atomics)]\\n\\n\",\n     i64 AtomicI64 ATOMIC_I64_INIT\n }\n #[cfg(target_has_atomic = \"64\")]\n@@ -1481,6 +1515,7 @@ atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"u64\", \"../../../std/primitive.u64.html\",\n+    \"#![feature(integer_atomics)]\\n\\n\",\n     u64 AtomicU64 ATOMIC_U64_INIT\n }\n #[cfg(target_has_atomic = \"ptr\")]\n@@ -1492,6 +1527,7 @@ atomic_int!{\n     stable(feature = \"atomic_from\", since = \"1.23.0\"),\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"isize\", \"../../../std/primitive.isize.html\",\n+    \"\",\n     isize AtomicIsize ATOMIC_ISIZE_INIT\n }\n #[cfg(target_has_atomic = \"ptr\")]\n@@ -1503,6 +1539,7 @@ atomic_int!{\n     stable(feature = \"atomic_from\", since = \"1.23.0\"),\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"usize\", \"../../../std/primitive.usize.html\",\n+    \"\",\n     usize AtomicUsize ATOMIC_USIZE_INIT\n }\n "}, {"sha": "950222dbcfa3fe8d303097e6832e0af6af648196", "filename": "src/libcore/tests/ascii.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibcore%2Ftests%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibcore%2Ftests%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fascii.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use core::char::from_u32;\n-use std::ascii::AsciiExt;\n \n #[test]\n fn test_is_ascii() {\n@@ -143,8 +142,6 @@ macro_rules! assert_all {\n                            stringify!($what), b);\n                 }\n             }\n-            assert!($str.$what());\n-            assert!($str.as_bytes().$what());\n         )+\n     }};\n     ($what:ident, $($str:tt),+,) => (assert_all!($what,$($str),+))"}, {"sha": "1e2e4e5a69fa1ad0b9ef05757976eabc03b236bc", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -579,6 +579,9 @@ define_dep_nodes!( <'tcx>\n     [] GetPanicStrategy(CrateNum),\n     [] IsNoBuiltins(CrateNum),\n     [] ImplDefaultness(DefId),\n+    [] CheckItemWellFormed(DefId),\n+    [] CheckTraitItemWellFormed(DefId),\n+    [] CheckImplItemWellFormed(DefId),\n     [] ReachableNonGenerics(CrateNum),\n     [] NativeLibraries(CrateNum),\n     [] PluginRegistrarFn(CrateNum),"}, {"sha": "d60c22064d3a0cd0ee3900a1dec51d175e28ea58", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -476,10 +476,8 @@ impl DepGraph {\n             fingerprints.resize(current_dep_graph.nodes.len(), Fingerprint::ZERO);\n         }\n \n-        let nodes: IndexVec<_, (DepNode, Fingerprint)> =\n-            current_dep_graph.nodes.iter_enumerated().map(|(idx, &dep_node)| {\n-            (dep_node, fingerprints[idx])\n-        }).collect();\n+        let fingerprints = fingerprints.clone().convert_index_type();\n+        let nodes = current_dep_graph.nodes.clone().convert_index_type();\n \n         let total_edge_count: usize = current_dep_graph.edges.iter()\n                                                              .map(|v| v.len())\n@@ -503,6 +501,7 @@ impl DepGraph {\n \n         SerializedDepGraph {\n             nodes,\n+            fingerprints,\n             edge_list_indices,\n             edge_list_data,\n         }"}, {"sha": "669a99019aa60176de63f093266766a75d8638a4", "filename": "src/librustc/dep_graph/prev.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustc%2Fdep_graph%2Fprev.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustc%2Fdep_graph%2Fprev.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fprev.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -23,7 +23,7 @@ impl PreviousDepGraph {\n     pub fn new(data: SerializedDepGraph) -> PreviousDepGraph {\n         let index: FxHashMap<_, _> = data.nodes\n             .iter_enumerated()\n-            .map(|(idx, &(dep_node, _))| (dep_node, idx))\n+            .map(|(idx, &dep_node)| (dep_node, idx))\n             .collect();\n         PreviousDepGraph { data, index }\n     }\n@@ -41,7 +41,7 @@ impl PreviousDepGraph {\n \n     #[inline]\n     pub fn index_to_node(&self, dep_node_index: SerializedDepNodeIndex) -> DepNode {\n-        self.data.nodes[dep_node_index].0\n+        self.data.nodes[dep_node_index]\n     }\n \n     #[inline]\n@@ -58,14 +58,14 @@ impl PreviousDepGraph {\n     pub fn fingerprint_of(&self, dep_node: &DepNode) -> Option<Fingerprint> {\n         self.index\n             .get(dep_node)\n-            .map(|&node_index| self.data.nodes[node_index].1)\n+            .map(|&node_index| self.data.fingerprints[node_index])\n     }\n \n     #[inline]\n     pub fn fingerprint_by_index(&self,\n                                 dep_node_index: SerializedDepNodeIndex)\n                                 -> Fingerprint {\n-        self.data.nodes[dep_node_index].1\n+        self.data.fingerprints[dep_node_index]\n     }\n \n     pub fn node_count(&self) -> usize {"}, {"sha": "60fc813a25d51eda38da1293b1a8943a89c35225", "filename": "src/librustc/dep_graph/serialized.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustc%2Fdep_graph%2Fserialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustc%2Fdep_graph%2Fserialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fserialized.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -20,7 +20,10 @@ newtype_index!(SerializedDepNodeIndex);\n #[derive(Debug, RustcEncodable, RustcDecodable)]\n pub struct SerializedDepGraph {\n     /// The set of all DepNodes in the graph\n-    pub nodes: IndexVec<SerializedDepNodeIndex, (DepNode, Fingerprint)>,\n+    pub nodes: IndexVec<SerializedDepNodeIndex, DepNode>,\n+    /// The set of all Fingerprints in the graph. Each Fingerprint corresponds to\n+    /// the DepNode at the same index in the nodes vector.\n+    pub fingerprints: IndexVec<SerializedDepNodeIndex, Fingerprint>,\n     /// For each DepNode, stores the list of edges originating from that\n     /// DepNode. Encoded as a [start, end) pair indexing into edge_list_data,\n     /// which holds the actual DepNodeIndices of the target nodes.\n@@ -35,6 +38,7 @@ impl SerializedDepGraph {\n     pub fn new() -> SerializedDepGraph {\n         SerializedDepGraph {\n             nodes: IndexVec::new(),\n+            fingerprints: IndexVec::new(),\n             edge_list_indices: IndexVec::new(),\n             edge_list_data: Vec::new(),\n         }"}, {"sha": "f6bdfde15fc5ff962cf7f6f12ab90e49a0febe64", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -809,7 +809,7 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_attrs(&mut self, attrs: &Vec<Attribute>) -> hir::HirVec<Attribute> {\n+    fn lower_attrs(&mut self, attrs: &[Attribute]) -> hir::HirVec<Attribute> {\n         attrs.iter().map(|a| self.lower_attr(a)).collect::<Vec<_>>().into()\n     }\n \n@@ -1019,6 +1019,7 @@ impl<'a> LoweringContext<'a> {\n                             span,\n                             pure_wrt_drop: false,\n                             synthetic: Some(hir::SyntheticTyParamKind::ImplTrait),\n+                            attrs: P::new(),\n                         });\n \n                         hir::TyPath(hir::QPath::Resolved(None, P(hir::Path {\n@@ -1585,6 +1586,7 @@ impl<'a> LoweringContext<'a> {\n                                .filter(|attr| attr.check_name(\"rustc_synthetic\"))\n                                .map(|_| hir::SyntheticTyParamKind::ImplTrait)\n                                .nth(0),\n+            attrs: self.lower_attrs(&tp.attrs),\n         }\n     }\n "}, {"sha": "e8bcbfbb77a1791cb03d6d65352566accc740c8a", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -962,6 +962,7 @@ impl<'hir> Map<'hir> {\n             Some(NodeField(ref f)) => Some(&f.attrs[..]),\n             Some(NodeExpr(ref e)) => Some(&*e.attrs),\n             Some(NodeStmt(ref s)) => Some(s.node.attrs()),\n+            Some(NodeTyParam(tp)) => Some(&tp.attrs[..]),\n             // unit/tuple structs take the attributes straight from\n             // the struct definition.\n             Some(NodeStructCtor(_)) => {"}, {"sha": "d6810b2468bccbed8dc1d332e42847db7b3da388", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -414,6 +414,7 @@ pub struct TyParam {\n     pub span: Span,\n     pub pure_wrt_drop: bool,\n     pub synthetic: Option<SyntheticTyParamKind>,\n+    pub attrs: HirVec<Attribute>,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]"}, {"sha": "774b1442b7101cd0da9aea15ede223d57231ed9b", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -203,7 +203,8 @@ impl_stable_hash_for!(struct hir::TyParam {\n     default,\n     span,\n     pure_wrt_drop,\n-    synthetic\n+    synthetic,\n+    attrs\n });\n \n impl_stable_hash_for!(enum hir::GenericParam {"}, {"sha": "6c3b4efb932ad891923f0bce0c88fa90ec4a2c7c", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -299,6 +299,10 @@ define_maps! { <'tcx>\n \n     [] fn impl_defaultness: ImplDefaultness(DefId) -> hir::Defaultness,\n \n+    [] fn check_item_well_formed: CheckItemWellFormed(DefId) -> (),\n+    [] fn check_trait_item_well_formed: CheckTraitItemWellFormed(DefId) -> (),\n+    [] fn check_impl_item_well_formed: CheckImplItemWellFormed(DefId) -> (),\n+\n     // The DefIds of all non-generic functions and statics in the given crate\n     // that can be reached from outside the crate.\n     //"}, {"sha": "4170fa7679716034468fdf9e8cb52d32403f1eed", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -871,6 +871,9 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::GetPanicStrategy => { force!(panic_strategy, krate!()); }\n         DepKind::IsNoBuiltins => { force!(is_no_builtins, krate!()); }\n         DepKind::ImplDefaultness => { force!(impl_defaultness, def_id!()); }\n+        DepKind::CheckItemWellFormed => { force!(check_item_well_formed, def_id!()); }\n+        DepKind::CheckTraitItemWellFormed => { force!(check_trait_item_well_formed, def_id!()); }\n+        DepKind::CheckImplItemWellFormed => { force!(check_impl_item_well_formed, def_id!()); }\n         DepKind::ReachableNonGenerics => { force!(reachable_non_generics, krate!()); }\n         DepKind::NativeLibraries => { force!(native_libraries, krate!()); }\n         DepKind::PluginRegistrarFn => { force!(plugin_registrar_fn, krate!()); }"}, {"sha": "cbb3ff5171592be599cc292b6e07b477c627a949", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -503,6 +503,13 @@ impl<I: Idx, T> IndexVec<I, T> {\n             (c1, c2)\n         }\n     }\n+\n+    pub fn convert_index_type<Ix: Idx>(self) -> IndexVec<Ix, T> {\n+        IndexVec {\n+            raw: self.raw,\n+            _marker: PhantomData,\n+        }\n+    }\n }\n \n impl<I: Idx, T: Clone> IndexVec<I, T> {"}, {"sha": "a5bc1106ba0b00fc24264b5378cd5711274e69ea", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -162,7 +162,7 @@ fn encode_dep_graph(tcx: TyCtxt,\n \n         let mut counts: FxHashMap<_, Stat> = FxHashMap();\n \n-        for (i, &(node, _)) in serialized_graph.nodes.iter_enumerated() {\n+        for (i, &node) in serialized_graph.nodes.iter_enumerated() {\n             let stat = counts.entry(node.kind).or_insert(Stat {\n                 kind: node.kind,\n                 node_counter: 0,"}, {"sha": "7281fb59663881ee222345491332af71b5721070", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -117,10 +117,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     // Evaluate the initializer, if present.\n                     if let Some(init) = initializer {\n                         unpack!(block = this.in_opt_scope(\n-                            opt_destruction_scope.map(|de|(de, source_info)), block, move |this| {\n+                            opt_destruction_scope.map(|de|(de, source_info)), block, |this| {\n                                 let scope = (init_scope, source_info);\n-                                this.in_scope(scope, lint_level, block, move |this| {\n-                                    // FIXME #30046                             ^~~~\n+                                this.in_scope(scope, lint_level, block, |this| {\n                                     this.expr_into_pattern(block, pattern, init)\n                                 })\n                             }));"}, {"sha": "47f6f61072e13acb232e5edc8c74249bf3fa56c0", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -339,6 +339,14 @@ impl<'mir, 'tcx> super::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         cid: GlobalId<'tcx>,\n     ) -> EvalResult<'tcx, AllocId> {\n+        let alloc = ecx\n+                    .tcx\n+                    .interpret_interner\n+                    .get_cached(cid.instance.def_id());\n+        // Don't evaluate when already cached to prevent cycles\n+        if let Some(alloc) = alloc {\n+            return Ok(alloc)\n+        }\n         // ensure the static is computed\n         ecx.const_eval(cid)?;\n         Ok(ecx"}, {"sha": "456f5fd75db09772ea8949c7c887c71a1ad0cb54", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 10, "deletions": 22, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -197,29 +197,17 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             },\n \n             Static(ref static_) => {\n-                let alloc = self\n-                    .tcx\n-                    .interpret_interner\n-                    .get_cached(static_.def_id);\n                 let layout = self.layout_of(self.place_ty(mir_place))?;\n-                if let Some(alloc) = alloc {\n-                    Place::Ptr {\n-                        ptr: MemoryPointer::new(alloc, 0).into(),\n-                        align: layout.align,\n-                        extra: PlaceExtra::None,\n-                    }\n-                } else {\n-                    let instance = ty::Instance::mono(*self.tcx, static_.def_id);\n-                    let cid = GlobalId {\n-                        instance,\n-                        promoted: None\n-                    };\n-                    let alloc = Machine::init_static(self, cid)?;\n-                    Place::Ptr {\n-                        ptr: MemoryPointer::new(alloc, 0).into(),\n-                        align: layout.align,\n-                        extra: PlaceExtra::None,\n-                    }\n+                let instance = ty::Instance::mono(*self.tcx, static_.def_id);\n+                let cid = GlobalId {\n+                    instance,\n+                    promoted: None\n+                };\n+                let alloc = Machine::init_static(self, cid)?;\n+                Place::Ptr {\n+                    ptr: MemoryPointer::new(alloc, 0).into(),\n+                    align: layout.align,\n+                    extra: PlaceExtra::None,\n                 }\n             }\n "}, {"sha": "19f33ef5d45a83f6a6b4b964c613f6574bfa924b", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -177,7 +177,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n                 });\n             }\n             DropStyle::Conditional => {\n-                let unwind = self.unwind; // FIXME(#6393)\n+                let unwind = self.unwind; // FIXME(#43234)\n                 let succ = self.succ;\n                 let drop_bb = self.complete_drop(Some(DropFlagMode::Deep), succ, unwind);\n                 self.elaborator.patch().patch_terminator(bb, TerminatorKind::Goto {\n@@ -268,7 +268,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         // Clear the \"master\" drop flag at the end. This is needed\n         // because the \"master\" drop protects the ADT's discriminant,\n         // which is invalidated after the ADT is dropped.\n-        let (succ, unwind) = (self.succ, self.unwind); // FIXME(#6393)\n+        let (succ, unwind) = (self.succ, self.unwind); // FIXME(#43234)\n         (\n             self.drop_flag_reset_block(DropFlagMode::Shallow, succ, unwind),\n             unwind.map(|unwind| {\n@@ -344,7 +344,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         let interior = self.place.clone().deref();\n         let interior_path = self.elaborator.deref_subpath(self.path);\n \n-        let succ = self.succ; // FIXME(#6393)\n+        let succ = self.succ; // FIXME(#43234)\n         let unwind = self.unwind;\n         let succ = self.box_free_block(ty, succ, unwind);\n         let unwind_succ = self.unwind.map(|unwind| {\n@@ -717,7 +717,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n                            ptr_based)\n         });\n \n-        let succ = self.succ; // FIXME(#6393)\n+        let succ = self.succ; // FIXME(#43234)\n         let loop_block = self.drop_loop(\n             succ,\n             cur,\n@@ -798,7 +798,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n                 self.open_drop_for_adt(def, substs)\n             }\n             ty::TyDynamic(..) => {\n-                let unwind = self.unwind; // FIXME(#6393)\n+                let unwind = self.unwind; // FIXME(#43234)\n                 let succ = self.succ;\n                 self.complete_drop(Some(DropFlagMode::Deep), succ, unwind)\n             }\n@@ -849,7 +849,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n \n     fn elaborated_drop_block<'a>(&mut self) -> BasicBlock {\n         debug!(\"elaborated_drop_block({:?})\", self);\n-        let unwind = self.unwind; // FIXME(#6393)\n+        let unwind = self.unwind; // FIXME(#43234)\n         let succ = self.succ;\n         let blk = self.drop_block(succ, unwind);\n         self.elaborate_drop(blk);\n@@ -882,7 +882,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n             args: vec![Operand::Move(self.place.clone())],\n             destination: Some((unit_temp, target)),\n             cleanup: None\n-        }; // FIXME(#6393)\n+        }; // FIXME(#43234)\n         let free_block = self.new_block(unwind, call);\n \n         let block_start = Location { block: free_block, statement_index: 0 };"}, {"sha": "76cbc670969880406426610d06338ec1d461dd86", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -373,10 +373,14 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n             }\n         }\n         hir::ExprMethodCall(..) => {\n-            let def_id = v.tables.type_dependent_defs()[e.hir_id].def_id();\n-            match v.tcx.associated_item(def_id).container {\n-                ty::ImplContainer(_) => v.handle_const_fn_call(def_id, node_ty),\n-                ty::TraitContainer(_) => v.promotable = false\n+            if let Some(def) = v.tables.type_dependent_defs().get(e.hir_id) {\n+                let def_id = def.def_id();\n+                match v.tcx.associated_item(def_id).container {\n+                    ty::ImplContainer(_) => v.handle_const_fn_call(def_id, node_ty),\n+                    ty::TraitContainer(_) => v.promotable = false\n+                }\n+            } else {\n+                v.tcx.sess.delay_span_bug(e.span, \"no type-dependent def for method call\");\n             }\n         }\n         hir::ExprStruct(..) => {"}, {"sha": "644a2ffe3c379bfc9c7864bfe8e7c51502c0132e", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 3, "deletions": 22, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -1025,28 +1025,9 @@ fn import_path_to_string(names: &[SpannedIdent],\n         if names.is_empty() {\n             import_directive_subclass_to_string(subclass)\n         } else {\n-            // FIXME: Remove this entire logic after #48116 is fixed.\n-            //\n-            // Note that this code looks a little wonky, it's currently here to\n-            // hopefully help debug #48116, but otherwise isn't intended to\n-            // cause any problems.\n-            let x = format!(\n-                \"{}::{}\",\n-                names_to_string(names),\n-                import_directive_subclass_to_string(subclass),\n-            );\n-            if names.is_empty() || x.starts_with(\"::\") {\n-                span_bug!(\n-                    span,\n-                    \"invalid name `{}` at {:?}; global = {}, names = {:?}, subclass = {:?}\",\n-                    x,\n-                    span,\n-                    global,\n-                    names,\n-                    subclass\n-                );\n-            }\n-            return x\n+            format!(\"{}::{}\",\n+                    names_to_string(names),\n+                    import_directive_subclass_to_string(subclass))\n         }\n     }\n }"}, {"sha": "1092e826a35f96c643a9c9e25d620d28a08172c1", "filename": "src/librustc_traits/lowering.rs", "status": "modified", "additions": 45, "deletions": 4, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustc_traits%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustc_traits%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -12,6 +12,7 @@ use rustc::hir::{self, ImplPolarity};\n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc::ty::{self, TyCtxt};\n+use rustc::ty::subst::Substs;\n use rustc::traits::{QuantifierKind, Goal, DomainGoal, Clause, WhereClauseAtom};\n use syntax::ast;\n use rustc_data_structures::sync::Lrc;\n@@ -104,29 +105,69 @@ crate fn program_clauses_for<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefI\n     let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n     let item = tcx.hir.expect_item(node_id);\n     match item.node {\n+        hir::ItemTrait(..) => program_clauses_for_trait(tcx, def_id),\n         hir::ItemImpl(..) => program_clauses_for_impl(tcx, def_id),\n \n         // FIXME: other constructions e.g. traits, associated types...\n         _ => Lrc::new(vec![]),\n     }\n }\n \n+fn program_clauses_for_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n+    -> Lrc<Vec<Clause<'tcx>>>\n+{\n+    // Rule Implemented-From-Env (see rustc guide)\n+    //\n+    // `trait Trait<P1..Pn> where WC { .. } // P0 == Self`\n+    //\n+    // ```\n+    // forall<Self, P1..Pn> {\n+    //   Implemented(Self: Trait<P1..Pn>) :- FromEnv(Self: Trait<P1..Pn>)\n+    // }\n+    // ```\n+\n+    // `Self: Trait<P1..Pn>`\n+    let trait_pred = ty::TraitPredicate {\n+        trait_ref: ty::TraitRef {\n+            def_id,\n+            substs: Substs::identity_for_item(tcx, def_id)\n+        }\n+    };\n+    // `FromEnv(Self: Trait<P1..Pn>)`\n+    let from_env = Goal::DomainGoal(DomainGoal::FromEnv(trait_pred.lower()));\n+    // `Implemented(Self: Trait<P1..Pn>)`\n+    let impl_trait = DomainGoal::Holds(WhereClauseAtom::Implemented(trait_pred));\n+\n+    // `Implemented(Self: Trait<P1..Pn>) :- FromEnv(Self: Trait<P1..Pn>)`\n+    let clause = Clause::Implies(vec![from_env], impl_trait);\n+    Lrc::new(vec![clause])\n+}\n+\n fn program_clauses_for_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n     -> Lrc<Vec<Clause<'tcx>>>\n {\n     if let ImplPolarity::Negative = tcx.impl_polarity(def_id) {\n         return Lrc::new(vec![]);\n     }\n \n-    // Rule Implemented-From-Impl\n+    // Rule Implemented-From-Impl (see rustc guide)\n+    //\n+    // `impl<P0..Pn> Trait<A1..An> for A0 where WC { .. }`\n     //\n-    // (see rustc guide)\n+    // ```\n+    // forall<P0..Pn> {\n+    //   Implemented(A0: Trait<A1..An>) :- WC\n+    // }\n+    // ```\n \n     let trait_ref = tcx.impl_trait_ref(def_id).unwrap();\n-    let trait_ref = ty::TraitPredicate { trait_ref }.lower();\n+    // `Implemented(A0: Trait<A1..An>)`\n+    let trait_pred = ty::TraitPredicate { trait_ref }.lower();\n+     // `WC`\n     let where_clauses = tcx.predicates_of(def_id).predicates.lower();\n \n-    let clause = Clause::Implies(where_clauses, trait_ref);\n+     // `Implemented(A0: Trait<A1..An>) :- WC`\n+    let clause = Clause::Implies(where_clauses, trait_pred);\n     Lrc::new(vec![clause])\n }\n "}, {"sha": "040d9455334bc9ede85ff33901506f72683c1be3", "filename": "src/librustc_trans/attributes.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustc_trans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustc_trans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fattributes.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -148,9 +148,17 @@ fn cstr(s: &'static str) -> &CStr {\n pub fn provide(providers: &mut Providers) {\n     providers.target_features_whitelist = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);\n-        Lrc::new(llvm_util::target_feature_whitelist(tcx.sess)\n-            .iter()\n-            .map(|c| c.to_string())\n-            .collect())\n+        if tcx.sess.opts.actually_rustdoc {\n+            // rustdoc needs to be able to document functions that use all the features, so\n+            // whitelist them all\n+            Lrc::new(llvm_util::all_known_features()\n+                .map(|c| c.to_string())\n+                .collect())\n+        } else {\n+            Lrc::new(llvm_util::target_feature_whitelist(tcx.sess)\n+                .iter()\n+                .map(|c| c.to_string())\n+                .collect())\n+        }\n     };\n }"}, {"sha": "91eabb9998f4a6425d7ae0b1105424bf250688b6", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -1036,7 +1036,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     pub fn vector_reduce_fmin(&self, src: ValueRef) -> ValueRef {\n         self.count_insn(\"vector.reduce.fmin\");\n         unsafe {\n-            let instr = llvm::LLVMRustBuildVectorReduceFMin(self.llbuilder, src, true);\n+            let instr = llvm::LLVMRustBuildVectorReduceFMin(self.llbuilder, src, /*NoNaNs:*/ false);\n             if instr.is_null() {\n                 bug!(\"LLVMRustBuildVectorReduceFMin is not available in LLVM version < 5.0\");\n             }\n@@ -1046,7 +1046,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     pub fn vector_reduce_fmax(&self, src: ValueRef) -> ValueRef {\n         self.count_insn(\"vector.reduce.fmax\");\n         unsafe {\n-            let instr = llvm::LLVMRustBuildVectorReduceFMax(self.llbuilder, src, true);\n+            let instr = llvm::LLVMRustBuildVectorReduceFMax(self.llbuilder, src, /*NoNaNs:*/ false);\n             if instr.is_null() {\n                 bug!(\"LLVMRustBuildVectorReduceFMax is not available in LLVM version < 5.0\");\n             }\n@@ -1056,7 +1056,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     pub fn vector_reduce_fmin_fast(&self, src: ValueRef) -> ValueRef {\n         self.count_insn(\"vector.reduce.fmin_fast\");\n         unsafe {\n-            let instr = llvm::LLVMRustBuildVectorReduceFMin(self.llbuilder, src, false);\n+            let instr = llvm::LLVMRustBuildVectorReduceFMin(self.llbuilder, src, /*NoNaNs:*/ true);\n             if instr.is_null() {\n                 bug!(\"LLVMRustBuildVectorReduceFMin is not available in LLVM version < 5.0\");\n             }\n@@ -1067,7 +1067,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     pub fn vector_reduce_fmax_fast(&self, src: ValueRef) -> ValueRef {\n         self.count_insn(\"vector.reduce.fmax_fast\");\n         unsafe {\n-            let instr = llvm::LLVMRustBuildVectorReduceFMax(self.llbuilder, src, false);\n+            let instr = llvm::LLVMRustBuildVectorReduceFMax(self.llbuilder, src, /*NoNaNs:*/ true);\n             if instr.is_null() {\n                 bug!(\"LLVMRustBuildVectorReduceFMax is not available in LLVM version < 5.0\");\n             }"}, {"sha": "5113b65a5c4700231f9e573711669abe549426ac", "filename": "src/librustc_trans/llvm_util.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustc_trans%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustc_trans%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fllvm_util.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -107,6 +107,20 @@ const POWERPC_WHITELIST: &'static [&'static str] = &[\"altivec\",\n \n const MIPS_WHITELIST: &'static [&'static str] = &[\"fp64\", \"msa\"];\n \n+/// When rustdoc is running, provide a list of all known features so that all their respective\n+/// primtives may be documented.\n+///\n+/// IMPORTANT: If you're adding another whitelist to the above lists, make sure to add it to this\n+/// iterator!\n+pub fn all_known_features() -> impl Iterator<Item=&'static str> {\n+    ARM_WHITELIST.iter().cloned()\n+        .chain(AARCH64_WHITELIST.iter().cloned())\n+        .chain(X86_WHITELIST.iter().cloned())\n+        .chain(HEXAGON_WHITELIST.iter().cloned())\n+        .chain(POWERPC_WHITELIST.iter().cloned())\n+        .chain(MIPS_WHITELIST.iter().cloned())\n+}\n+\n pub fn to_llvm_feature<'a>(sess: &Session, s: &'a str) -> &'a str {\n     let arch = if sess.target.target.arch == \"x86_64\" {\n         \"x86\""}, {"sha": "47bbd67fb5c70840cc5fdf85e8cfca77338df991", "filename": "src/librustc_trans_utils/symbol_names_test.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustc_trans_utils%2Fsymbol_names_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustc_trans_utils%2Fsymbol_names_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Fsymbol_names_test.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -15,7 +15,6 @@\n //! paths etc in all kinds of annoying scenarios.\n \n use rustc::hir;\n-use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::ty::TyCtxt;\n use syntax::ast;\n \n@@ -34,8 +33,7 @@ pub fn report_symbol_names<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n \n     tcx.dep_graph.with_ignore(|| {\n         let mut visitor = SymbolNamesTest { tcx: tcx };\n-        // FIXME(#37712) could use ItemLikeVisitor if trait items were item-like\n-        tcx.hir.krate().visit_all_item_likes(&mut visitor.as_deep_visitor());\n+        tcx.hir.krate().visit_all_item_likes(&mut visitor);\n     })\n }\n \n@@ -66,23 +64,16 @@ impl<'a, 'tcx> SymbolNamesTest<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for SymbolNamesTest<'a, 'tcx> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::None\n-    }\n-\n+impl<'a, 'tcx> hir::itemlikevisit::ItemLikeVisitor<'tcx> for SymbolNamesTest<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         self.process_attrs(item.id);\n-        intravisit::walk_item(self, item);\n     }\n \n-    fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem) {\n-        self.process_attrs(ti.id);\n-        intravisit::walk_trait_item(self, ti)\n+    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n+        self.process_attrs(trait_item.id);\n     }\n \n-    fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem) {\n-        self.process_attrs(ii.id);\n-        intravisit::walk_impl_item(self, ii)\n+    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n+        self.process_attrs(impl_item.id);\n     }\n }"}, {"sha": "69879bbe85d6e4e50d22af815d071c08be95a4f2", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -718,13 +718,28 @@ fn typeck_item_bodies<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum\n     })?)\n }\n \n+fn check_item_well_formed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n+    wfcheck::check_item_well_formed(tcx, def_id);\n+}\n+\n+fn check_trait_item_well_formed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n+    wfcheck::check_trait_item(tcx, def_id);\n+}\n+\n+fn check_impl_item_well_formed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n+    wfcheck::check_impl_item(tcx, def_id);\n+}\n+\n pub fn provide(providers: &mut Providers) {\n     *providers = Providers {\n         typeck_item_bodies,\n         typeck_tables_of,\n         has_typeck_tables,\n         adt_destructor,\n         used_trait_imports,\n+        check_item_well_formed,\n+        check_trait_item_well_formed,\n+        check_impl_item_well_formed,\n         ..*providers\n     };\n }\n@@ -2869,27 +2884,21 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let origin = self.misc(call_span);\n                 let ures = self.at(&origin, self.param_env).sup(ret_ty, formal_ret);\n \n-                // FIXME(#15760) can't use try! here, FromError doesn't default\n+                // FIXME(#27336) can't use ? here, Try::from_error doesn't default\n                 // to identity so the resulting type is not constrained.\n                 match ures {\n                     Ok(ok) => {\n                         // Process any obligations locally as much as\n                         // we can.  We don't care if some things turn\n                         // out unconstrained or ambiguous, as we're\n                         // just trying to get hints here.\n-                        let result = self.save_and_restore_in_snapshot_flag(|_| {\n+                        self.save_and_restore_in_snapshot_flag(|_| {\n                             let mut fulfill = FulfillmentContext::new();\n-                            let ok = ok; // FIXME(#30046)\n                             for obligation in ok.obligations {\n                                 fulfill.register_predicate_obligation(self, obligation);\n                             }\n                             fulfill.select_where_possible(self)\n-                        });\n-\n-                        match result {\n-                            Ok(()) => { }\n-                            Err(_) => return Err(()),\n-                        }\n+                        }).map_err(|_| ())?;\n                     }\n                     Err(_) => return Err(()),\n                 }"}, {"sha": "406ff9463a03c314f4da185ca068dd0ae2c24a37", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 520, "deletions": 506, "changes": 1026, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -26,17 +26,11 @@ use errors::{DiagnosticBuilder, DiagnosticId};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir;\n \n-pub struct CheckTypeWellFormedVisitor<'a, 'tcx:'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    code: ObligationCauseCode<'tcx>,\n-}\n-\n /// Helper type of a temporary returned by .for_item(...).\n /// Necessary because we can't write the following bound:\n /// F: for<'b, 'tcx> where 'gcx: 'tcx FnOnce(FnCtxt<'b, 'gcx, 'tcx>).\n struct CheckWfFcxBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     inherited: super::InheritedBuilder<'a, 'gcx, 'tcx>,\n-    code: ObligationCauseCode<'gcx>,\n     id: ast::NodeId,\n     span: Span,\n     param_env: ty::ParamEnv<'tcx>,\n@@ -45,585 +39,597 @@ struct CheckWfFcxBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n impl<'a, 'gcx, 'tcx> CheckWfFcxBuilder<'a, 'gcx, 'tcx> {\n     fn with_fcx<F>(&'tcx mut self, f: F) where\n         F: for<'b> FnOnce(&FnCtxt<'b, 'gcx, 'tcx>,\n-                          &mut CheckTypeWellFormedVisitor<'b, 'gcx>) -> Vec<Ty<'tcx>>\n+                         TyCtxt<'b, 'gcx, 'gcx>) -> Vec<Ty<'tcx>>\n     {\n-        let code = self.code.clone();\n         let id = self.id;\n         let span = self.span;\n         let param_env = self.param_env;\n         self.inherited.enter(|inh| {\n             let fcx = FnCtxt::new(&inh, param_env, id);\n-            let wf_tys = f(&fcx, &mut CheckTypeWellFormedVisitor {\n-                tcx: fcx.tcx.global_tcx(),\n-                code,\n-            });\n+            let wf_tys = f(&fcx, fcx.tcx.global_tcx());\n             fcx.select_all_obligations_or_error();\n             fcx.regionck_item(id, span, &wf_tys);\n         });\n     }\n }\n \n-impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'gcx, 'gcx>)\n-               -> CheckTypeWellFormedVisitor<'a, 'gcx> {\n-        CheckTypeWellFormedVisitor {\n-            tcx,\n-            code: ObligationCauseCode::MiscObligation\n-        }\n-    }\n-\n-    /// Checks that the field types (in a struct def'n) or argument types (in an enum def'n) are\n-    /// well-formed, meaning that they do not require any constraints not declared in the struct\n-    /// definition itself. For example, this definition would be illegal:\n-    ///\n-    ///     struct Ref<'a, T> { x: &'a T }\n-    ///\n-    /// because the type did not declare that `T:'a`.\n-    ///\n-    /// We do this check as a pre-pass before checking fn bodies because if these constraints are\n-    /// not included it frequently leads to confusing errors in fn bodies. So it's better to check\n-    /// the types first.\n-    fn check_item_well_formed(&mut self, item: &hir::Item) {\n-        let tcx = self.tcx;\n-        debug!(\"check_item_well_formed(it.id={}, it.name={})\",\n-               item.id,\n-               tcx.item_path_str(tcx.hir.local_def_id(item.id)));\n-\n-        match item.node {\n-            // Right now we check that every default trait implementation\n-            // has an implementation of itself. Basically, a case like:\n-            //\n-            // `impl Trait for T {}`\n-            //\n-            // has a requirement of `T: Trait` which was required for default\n-            // method implementations. Although this could be improved now that\n-            // there's a better infrastructure in place for this, it's being left\n-            // for a follow-up work.\n-            //\n-            // Since there's such a requirement, we need to check *just* positive\n-            // implementations, otherwise things like:\n-            //\n-            // impl !Send for T {}\n-            //\n-            // won't be allowed unless there's an *explicit* implementation of `Send`\n-            // for `T`\n-            hir::ItemImpl(_, polarity, defaultness, _, ref trait_ref, ref self_ty, _) => {\n-                let is_auto = tcx.impl_trait_ref(tcx.hir.local_def_id(item.id))\n-                                 .map_or(false, |trait_ref| tcx.trait_is_auto(trait_ref.def_id));\n-                if let (hir::Defaultness::Default { .. }, true) = (defaultness, is_auto) {\n-                    tcx.sess.span_err(item.span, \"impls of auto traits cannot be default\");\n-                }\n-                if polarity == hir::ImplPolarity::Positive {\n-                    self.check_impl(item, self_ty, trait_ref);\n-                } else {\n-                    // FIXME(#27579) what amount of WF checking do we need for neg impls?\n-                    if trait_ref.is_some() && !is_auto {\n-                        span_err!(tcx.sess, item.span, E0192,\n-                                  \"negative impls are only allowed for \\\n-                                   auto traits (e.g., `Send` and `Sync`)\")\n-                    }\n-                }\n-            }\n-            hir::ItemFn(..) => {\n-                self.check_item_fn(item);\n-            }\n-            hir::ItemStatic(..) => {\n-                self.check_item_type(item);\n+/// Checks that the field types (in a struct def'n) or argument types (in an enum def'n) are\n+/// well-formed, meaning that they do not require any constraints not declared in the struct\n+/// definition itself. For example, this definition would be illegal:\n+///\n+///     struct Ref<'a, T> { x: &'a T }\n+///\n+/// because the type did not declare that `T:'a`.\n+///\n+/// We do this check as a pre-pass before checking fn bodies because if these constraints are\n+/// not included it frequently leads to confusing errors in fn bodies. So it's better to check\n+/// the types first.\n+pub fn check_item_well_formed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n+    let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n+    let item = tcx.hir.expect_item(node_id);\n+\n+    debug!(\"check_item_well_formed(it.id={}, it.name={})\",\n+            item.id,\n+            tcx.item_path_str(def_id));\n+\n+    match item.node {\n+        // Right now we check that every default trait implementation\n+        // has an implementation of itself. Basically, a case like:\n+        //\n+        // `impl Trait for T {}`\n+        //\n+        // has a requirement of `T: Trait` which was required for default\n+        // method implementations. Although this could be improved now that\n+        // there's a better infrastructure in place for this, it's being left\n+        // for a follow-up work.\n+        //\n+        // Since there's such a requirement, we need to check *just* positive\n+        // implementations, otherwise things like:\n+        //\n+        // impl !Send for T {}\n+        //\n+        // won't be allowed unless there's an *explicit* implementation of `Send`\n+        // for `T`\n+        hir::ItemImpl(_, polarity, defaultness, _, ref trait_ref, ref self_ty, _) => {\n+            let is_auto = tcx.impl_trait_ref(tcx.hir.local_def_id(item.id))\n+                                .map_or(false, |trait_ref| tcx.trait_is_auto(trait_ref.def_id));\n+            if let (hir::Defaultness::Default { .. }, true) = (defaultness, is_auto) {\n+                tcx.sess.span_err(item.span, \"impls of auto traits cannot be default\");\n             }\n-            hir::ItemConst(..) => {\n-                self.check_item_type(item);\n+            if polarity == hir::ImplPolarity::Positive {\n+                check_impl(tcx, item, self_ty, trait_ref);\n+            } else {\n+                // FIXME(#27579) what amount of WF checking do we need for neg impls?\n+                if trait_ref.is_some() && !is_auto {\n+                    span_err!(tcx.sess, item.span, E0192,\n+                                \"negative impls are only allowed for \\\n+                                auto traits (e.g., `Send` and `Sync`)\")\n+                }\n             }\n-            hir::ItemStruct(ref struct_def, ref ast_generics) => {\n-                self.check_type_defn(item, false, |fcx| {\n-                    vec![fcx.non_enum_variant(struct_def)]\n-                });\n+        }\n+        hir::ItemFn(..) => {\n+            check_item_fn(tcx, item);\n+        }\n+        hir::ItemStatic(..) => {\n+            check_item_type(tcx, item);\n+        }\n+        hir::ItemConst(..) => {\n+            check_item_type(tcx, item);\n+        }\n+        hir::ItemStruct(ref struct_def, ref ast_generics) => {\n+            check_type_defn(tcx, item, false, |fcx| {\n+                vec![fcx.non_enum_variant(struct_def)]\n+            });\n \n-                self.check_variances_for_type_defn(item, ast_generics);\n-            }\n-            hir::ItemUnion(ref struct_def, ref ast_generics) => {\n-                self.check_type_defn(item, true, |fcx| {\n-                    vec![fcx.non_enum_variant(struct_def)]\n-                });\n+            check_variances_for_type_defn(tcx, item, ast_generics);\n+        }\n+        hir::ItemUnion(ref struct_def, ref ast_generics) => {\n+            check_type_defn(tcx, item, true, |fcx| {\n+                vec![fcx.non_enum_variant(struct_def)]\n+            });\n \n-                self.check_variances_for_type_defn(item, ast_generics);\n-            }\n-            hir::ItemEnum(ref enum_def, ref ast_generics) => {\n-                self.check_type_defn(item, true, |fcx| {\n-                    fcx.enum_variants(enum_def)\n-                });\n+            check_variances_for_type_defn(tcx, item, ast_generics);\n+        }\n+        hir::ItemEnum(ref enum_def, ref ast_generics) => {\n+            check_type_defn(tcx, item, true, |fcx| {\n+                fcx.enum_variants(enum_def)\n+            });\n \n-                self.check_variances_for_type_defn(item, ast_generics);\n-            }\n-            hir::ItemTrait(..) => {\n-                self.check_trait(item);\n-            }\n-            _ => {}\n+            check_variances_for_type_defn(tcx, item, ast_generics);\n         }\n+        hir::ItemTrait(..) => {\n+            check_trait(tcx, item);\n+        }\n+        _ => {}\n     }\n+}\n \n-    fn check_associated_item(&mut self,\n-                             item_id: ast::NodeId,\n-                             span: Span,\n-                             sig_if_method: Option<&hir::MethodSig>) {\n-        let code = self.code.clone();\n-        self.for_id(item_id, span).with_fcx(|fcx, this| {\n-            let item = fcx.tcx.associated_item(fcx.tcx.hir.local_def_id(item_id));\n-\n-            let (mut implied_bounds, self_ty) = match item.container {\n-                ty::TraitContainer(_) => (vec![], fcx.tcx.mk_self_type()),\n-                ty::ImplContainer(def_id) => (fcx.impl_implied_bounds(def_id, span),\n-                                              fcx.tcx.type_of(def_id))\n-            };\n+pub fn check_trait_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n+    let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n+    let trait_item = tcx.hir.expect_trait_item(node_id);\n+\n+    let method_sig = match trait_item.node {\n+        hir::TraitItemKind::Method(ref sig, _) => Some(sig),\n+        _ => None\n+    };\n+    check_associated_item(tcx, trait_item.id, trait_item.span, method_sig);\n+}\n+\n+pub fn check_impl_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n+    let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n+    let impl_item = tcx.hir.expect_impl_item(node_id);\n+\n+    let method_sig = match impl_item.node {\n+        hir::ImplItemKind::Method(ref sig, _) => Some(sig),\n+        _ => None\n+    };\n+    check_associated_item(tcx, impl_item.id, impl_item.span, method_sig);\n+}\n+\n+fn check_associated_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                            item_id: ast::NodeId,\n+                            span: Span,\n+                            sig_if_method: Option<&hir::MethodSig>) {\n+    let code = ObligationCauseCode::MiscObligation;\n+    for_id(tcx, item_id, span).with_fcx(|fcx, tcx| {\n+        let item = fcx.tcx.associated_item(fcx.tcx.hir.local_def_id(item_id));\n+\n+        let (mut implied_bounds, self_ty) = match item.container {\n+            ty::TraitContainer(_) => (vec![], fcx.tcx.mk_self_type()),\n+            ty::ImplContainer(def_id) => (fcx.impl_implied_bounds(def_id, span),\n+                                            fcx.tcx.type_of(def_id))\n+        };\n \n-            match item.kind {\n-                ty::AssociatedKind::Const => {\n+        match item.kind {\n+            ty::AssociatedKind::Const => {\n+                let ty = fcx.tcx.type_of(item.def_id);\n+                let ty = fcx.normalize_associated_types_in(span, &ty);\n+                fcx.register_wf_obligation(ty, span, code.clone());\n+            }\n+            ty::AssociatedKind::Method => {\n+                reject_shadowing_type_parameters(fcx.tcx, item.def_id);\n+                let sig = fcx.tcx.fn_sig(item.def_id);\n+                let sig = fcx.normalize_associated_types_in(span, &sig);\n+                check_fn_or_method(tcx, fcx, span, sig,\n+                                        item.def_id, &mut implied_bounds);\n+                let sig_if_method = sig_if_method.expect(\"bad signature for method\");\n+                check_method_receiver(fcx, sig_if_method, &item, self_ty);\n+            }\n+            ty::AssociatedKind::Type => {\n+                if item.defaultness.has_value() {\n                     let ty = fcx.tcx.type_of(item.def_id);\n                     let ty = fcx.normalize_associated_types_in(span, &ty);\n                     fcx.register_wf_obligation(ty, span, code.clone());\n                 }\n-                ty::AssociatedKind::Method => {\n-                    reject_shadowing_type_parameters(fcx.tcx, item.def_id);\n-                    let sig = fcx.tcx.fn_sig(item.def_id);\n-                    let sig = fcx.normalize_associated_types_in(span, &sig);\n-                    this.check_fn_or_method(fcx, span, sig,\n-                                            item.def_id, &mut implied_bounds);\n-                    let sig_if_method = sig_if_method.expect(\"bad signature for method\");\n-                    this.check_method_receiver(fcx, sig_if_method, &item, self_ty);\n-                }\n-                ty::AssociatedKind::Type => {\n-                    if item.defaultness.has_value() {\n-                        let ty = fcx.tcx.type_of(item.def_id);\n-                        let ty = fcx.normalize_associated_types_in(span, &ty);\n-                        fcx.register_wf_obligation(ty, span, code.clone());\n-                    }\n-                }\n             }\n+        }\n \n-            implied_bounds\n-        })\n-    }\n-\n-    fn for_item<'tcx>(&self, item: &hir::Item)\n-                      -> CheckWfFcxBuilder<'a, 'gcx, 'tcx> {\n-        self.for_id(item.id, item.span)\n-    }\n+        implied_bounds\n+    })\n+}\n \n-    fn for_id<'tcx>(&self, id: ast::NodeId, span: Span)\n+fn for_item<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>, item: &hir::Item)\n                     -> CheckWfFcxBuilder<'a, 'gcx, 'tcx> {\n-        let def_id = self.tcx.hir.local_def_id(id);\n-        CheckWfFcxBuilder {\n-            inherited: Inherited::build(self.tcx, def_id),\n-            code: self.code.clone(),\n-            id,\n-            span,\n-            param_env: self.tcx.param_env(def_id),\n-        }\n+    for_id(tcx, item.id, item.span)\n+}\n+\n+fn for_id<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>, id: ast::NodeId, span: Span)\n+                -> CheckWfFcxBuilder<'a, 'gcx, 'tcx> {\n+    let def_id = tcx.hir.local_def_id(id);\n+    CheckWfFcxBuilder {\n+        inherited: Inherited::build(tcx, def_id),\n+        id,\n+        span,\n+        param_env: tcx.param_env(def_id),\n     }\n+}\n \n-    /// In a type definition, we check that to ensure that the types of the fields are well-formed.\n-    fn check_type_defn<F>(&mut self, item: &hir::Item, all_sized: bool, mut lookup_fields: F)\n-        where F: for<'fcx, 'tcx> FnMut(&FnCtxt<'fcx, 'gcx, 'tcx>) -> Vec<AdtVariant<'tcx>>\n-    {\n-        self.for_item(item).with_fcx(|fcx, this| {\n-            let variants = lookup_fields(fcx);\n-            let def_id = fcx.tcx.hir.local_def_id(item.id);\n-            let packed = fcx.tcx.adt_def(def_id).repr.packed();\n-\n-            for variant in &variants {\n-                // For DST, or when drop needs to copy things around, all\n-                // intermediate types must be sized.\n-                let needs_drop_copy = || {\n-                    packed && {\n-                        let ty = variant.fields.last().unwrap().ty;\n-                        let ty = fcx.tcx.erase_regions(&ty).lift_to_tcx(this.tcx)\n-                            .unwrap_or_else(|| {\n-                                span_bug!(item.span, \"inference variables in {:?}\", ty)\n-                            });\n-                        ty.needs_drop(this.tcx, this.tcx.param_env(def_id))\n-                    }\n-                };\n-                let unsized_len = if\n-                    all_sized ||\n-                    variant.fields.is_empty() ||\n-                    needs_drop_copy()\n-                {\n-                    0\n-                } else {\n-                    1\n-                };\n-                for field in &variant.fields[..variant.fields.len() - unsized_len] {\n-                    fcx.register_bound(\n-                        field.ty,\n-                        fcx.tcx.require_lang_item(lang_items::SizedTraitLangItem),\n-                        traits::ObligationCause::new(field.span,\n-                                                     fcx.body_id,\n-                                                     traits::FieldSized(match item.node.adt_kind() {\n-                                                        Some(i) => i,\n-                                                        None => bug!(),\n-                                                     })));\n+/// In a type definition, we check that to ensure that the types of the fields are well-formed.\n+fn check_type_defn<'a, 'tcx, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                item: &hir::Item, all_sized: bool, mut lookup_fields: F)\n+    where F: for<'fcx, 'gcx, 'tcx2> FnMut(&FnCtxt<'fcx, 'gcx, 'tcx2>) -> Vec<AdtVariant<'tcx2>>\n+{\n+    for_item(tcx, item).with_fcx(|fcx, fcx_tcx| {\n+        let variants = lookup_fields(fcx);\n+        let def_id = fcx.tcx.hir.local_def_id(item.id);\n+        let packed = fcx.tcx.adt_def(def_id).repr.packed();\n+\n+        for variant in &variants {\n+            // For DST, or when drop needs to copy things around, all\n+            // intermediate types must be sized.\n+            let needs_drop_copy = || {\n+                packed && {\n+                    let ty = variant.fields.last().unwrap().ty;\n+                    let ty = fcx.tcx.erase_regions(&ty).lift_to_tcx(fcx_tcx)\n+                        .unwrap_or_else(|| {\n+                            span_bug!(item.span, \"inference variables in {:?}\", ty)\n+                        });\n+                    ty.needs_drop(fcx_tcx, fcx_tcx.param_env(def_id))\n                 }\n+            };\n+            let unsized_len = if\n+                all_sized ||\n+                variant.fields.is_empty() ||\n+                needs_drop_copy()\n+            {\n+                0\n+            } else {\n+                1\n+            };\n+            for field in &variant.fields[..variant.fields.len() - unsized_len] {\n+                fcx.register_bound(\n+                    field.ty,\n+                    fcx.tcx.require_lang_item(lang_items::SizedTraitLangItem),\n+                    traits::ObligationCause::new(field.span,\n+                                                    fcx.body_id,\n+                                                    traits::FieldSized(match item.node.adt_kind() {\n+                                                    Some(i) => i,\n+                                                    None => bug!(),\n+                                                    })));\n+            }\n \n-                // All field types must be well-formed.\n-                for field in &variant.fields {\n-                    fcx.register_wf_obligation(field.ty, field.span, this.code.clone())\n-                }\n+            // All field types must be well-formed.\n+            for field in &variant.fields {\n+                fcx.register_wf_obligation(field.ty, field.span,\n+                    ObligationCauseCode::MiscObligation)\n             }\n+        }\n \n-            self.check_where_clauses(fcx, item.span, def_id);\n+        check_where_clauses(tcx, fcx, item.span, def_id);\n \n-            vec![] // no implied bounds in a struct def'n\n-        });\n-    }\n+        vec![] // no implied bounds in a struct def'n\n+    });\n+}\n \n-    fn check_trait(&mut self, item: &hir::Item) {\n-        let trait_def_id = self.tcx.hir.local_def_id(item.id);\n-        self.for_item(item).with_fcx(|fcx, _| {\n-            self.check_where_clauses(fcx, item.span, trait_def_id);\n-            vec![]\n-        });\n-    }\n+fn check_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item: &hir::Item) {\n+    let trait_def_id = tcx.hir.local_def_id(item.id);\n+    for_item(tcx, item).with_fcx(|fcx, _| {\n+        check_where_clauses(tcx, fcx, item.span, trait_def_id);\n+        vec![]\n+    });\n+}\n \n-    fn check_item_fn(&mut self, item: &hir::Item) {\n-        self.for_item(item).with_fcx(|fcx, this| {\n-            let def_id = fcx.tcx.hir.local_def_id(item.id);\n-            let sig = fcx.tcx.fn_sig(def_id);\n-            let sig = fcx.normalize_associated_types_in(item.span, &sig);\n-            let mut implied_bounds = vec![];\n-            this.check_fn_or_method(fcx, item.span, sig,\n-                                    def_id, &mut implied_bounds);\n-            implied_bounds\n-        })\n-    }\n+fn check_item_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item: &hir::Item) {\n+    for_item(tcx, item).with_fcx(|fcx, tcx| {\n+        let def_id = fcx.tcx.hir.local_def_id(item.id);\n+        let sig = fcx.tcx.fn_sig(def_id);\n+        let sig = fcx.normalize_associated_types_in(item.span, &sig);\n+        let mut implied_bounds = vec![];\n+        check_fn_or_method(tcx, fcx, item.span, sig,\n+                                def_id, &mut implied_bounds);\n+        implied_bounds\n+    })\n+}\n \n-    fn check_item_type(&mut self,\n-                       item: &hir::Item)\n-    {\n-        debug!(\"check_item_type: {:?}\", item);\n+fn check_item_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                    item: &hir::Item)\n+{\n+    debug!(\"check_item_type: {:?}\", item);\n \n-        self.for_item(item).with_fcx(|fcx, this| {\n-            let ty = fcx.tcx.type_of(fcx.tcx.hir.local_def_id(item.id));\n-            let item_ty = fcx.normalize_associated_types_in(item.span, &ty);\n+    for_item(tcx, item).with_fcx(|fcx, _this| {\n+        let ty = fcx.tcx.type_of(fcx.tcx.hir.local_def_id(item.id));\n+        let item_ty = fcx.normalize_associated_types_in(item.span, &ty);\n \n-            fcx.register_wf_obligation(item_ty, item.span, this.code.clone());\n+        fcx.register_wf_obligation(item_ty, item.span, ObligationCauseCode::MiscObligation);\n \n-            vec![] // no implied bounds in a const etc\n-        });\n-    }\n+        vec![] // no implied bounds in a const etc\n+    });\n+}\n \n-    fn check_impl(&mut self,\n-                  item: &hir::Item,\n-                  ast_self_ty: &hir::Ty,\n-                  ast_trait_ref: &Option<hir::TraitRef>)\n-    {\n-        debug!(\"check_impl: {:?}\", item);\n-\n-        self.for_item(item).with_fcx(|fcx, this| {\n-            let item_def_id = fcx.tcx.hir.local_def_id(item.id);\n-\n-            match *ast_trait_ref {\n-                Some(ref ast_trait_ref) => {\n-                    let trait_ref = fcx.tcx.impl_trait_ref(item_def_id).unwrap();\n-                    let trait_ref =\n-                        fcx.normalize_associated_types_in(\n-                            ast_trait_ref.path.span, &trait_ref);\n-                    let obligations =\n-                        ty::wf::trait_obligations(fcx,\n-                                                  fcx.param_env,\n-                                                  fcx.body_id,\n-                                                  &trait_ref,\n-                                                  ast_trait_ref.path.span);\n-                    for obligation in obligations {\n-                        fcx.register_predicate(obligation);\n-                    }\n-                }\n-                None => {\n-                    let self_ty = fcx.tcx.type_of(item_def_id);\n-                    let self_ty = fcx.normalize_associated_types_in(item.span, &self_ty);\n-                    fcx.register_wf_obligation(self_ty, ast_self_ty.span, this.code.clone());\n+fn check_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                item: &hir::Item,\n+                ast_self_ty: &hir::Ty,\n+                ast_trait_ref: &Option<hir::TraitRef>)\n+{\n+    debug!(\"check_impl: {:?}\", item);\n+\n+    for_item(tcx, item).with_fcx(|fcx, tcx| {\n+        let item_def_id = fcx.tcx.hir.local_def_id(item.id);\n+\n+        match *ast_trait_ref {\n+            Some(ref ast_trait_ref) => {\n+                let trait_ref = fcx.tcx.impl_trait_ref(item_def_id).unwrap();\n+                let trait_ref =\n+                    fcx.normalize_associated_types_in(\n+                        ast_trait_ref.path.span, &trait_ref);\n+                let obligations =\n+                    ty::wf::trait_obligations(fcx,\n+                                                fcx.param_env,\n+                                                fcx.body_id,\n+                                                &trait_ref,\n+                                                ast_trait_ref.path.span);\n+                for obligation in obligations {\n+                    fcx.register_predicate(obligation);\n                 }\n             }\n+            None => {\n+                let self_ty = fcx.tcx.type_of(item_def_id);\n+                let self_ty = fcx.normalize_associated_types_in(item.span, &self_ty);\n+                fcx.register_wf_obligation(self_ty, ast_self_ty.span,\n+                    ObligationCauseCode::MiscObligation);\n+            }\n+        }\n \n-            this.check_where_clauses(fcx, item.span, item_def_id);\n+        check_where_clauses(tcx, fcx, item.span, item_def_id);\n \n-            fcx.impl_implied_bounds(item_def_id, item.span)\n-        });\n-    }\n+        fcx.impl_implied_bounds(item_def_id, item.span)\n+    });\n+}\n \n-    /// Checks where clauses and inline bounds that are declared on def_id.\n-    fn check_where_clauses<'fcx, 'tcx>(&mut self,\n-                                       fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n-                                       span: Span,\n-                                       def_id: DefId) {\n-        use ty::subst::Subst;\n-        use rustc::ty::TypeFoldable;\n-\n-        let mut predicates = fcx.tcx.predicates_of(def_id);\n-        let mut substituted_predicates = Vec::new();\n-\n-        let generics = self.tcx.generics_of(def_id);\n-        let is_our_default = |def: &ty::TypeParameterDef|\n-                                def.has_default && def.index >= generics.parent_count() as u32;\n-\n-        // Check that concrete defaults are well-formed. See test `type-check-defaults.rs`.\n-        // For example this forbids the declaration:\n-        // struct Foo<T = Vec<[u32]>> { .. }\n-        // Here the default `Vec<[u32]>` is not WF because `[u32]: Sized` does not hold.\n-        for d in generics.types.iter().cloned().filter(is_our_default).map(|p| p.def_id) {\n-            let ty = fcx.tcx.type_of(d);\n-            // ignore dependent defaults -- that is, where the default of one type\n-            // parameter includes another (e.g., <T, U = T>). In those cases, we can't\n-            // be sure if it will error or not as user might always specify the other.\n-            if !ty.needs_subst() {\n-                fcx.register_wf_obligation(ty, fcx.tcx.def_span(d), self.code.clone());\n-            }\n+/// Checks where clauses and inline bounds that are declared on def_id.\n+fn check_where_clauses<'a, 'gcx, 'fcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n+                                    fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n+                                    span: Span,\n+                                    def_id: DefId) {\n+    use ty::subst::Subst;\n+    use rustc::ty::TypeFoldable;\n+\n+    let mut predicates = fcx.tcx.predicates_of(def_id);\n+    let mut substituted_predicates = Vec::new();\n+\n+    let generics = tcx.generics_of(def_id);\n+    let is_our_default = |def: &ty::TypeParameterDef|\n+                            def.has_default && def.index >= generics.parent_count() as u32;\n+\n+    // Check that concrete defaults are well-formed. See test `type-check-defaults.rs`.\n+    // For example this forbids the declaration:\n+    // struct Foo<T = Vec<[u32]>> { .. }\n+    // Here the default `Vec<[u32]>` is not WF because `[u32]: Sized` does not hold.\n+    for d in generics.types.iter().cloned().filter(is_our_default).map(|p| p.def_id) {\n+        let ty = fcx.tcx.type_of(d);\n+        // ignore dependent defaults -- that is, where the default of one type\n+        // parameter includes another (e.g., <T, U = T>). In those cases, we can't\n+        // be sure if it will error or not as user might always specify the other.\n+        if !ty.needs_subst() {\n+            fcx.register_wf_obligation(ty, fcx.tcx.def_span(d),\n+                ObligationCauseCode::MiscObligation);\n         }\n+    }\n \n-        // Check that trait predicates are WF when params are substituted by their defaults.\n-        // We don't want to overly constrain the predicates that may be written but we want to\n-        // catch cases where a default my never be applied such as `struct Foo<T: Copy = String>`.\n-        // Therefore we check if a predicate which contains a single type param\n-        // with a concrete default is WF with that default substituted.\n-        // For more examples see tests `defaults-well-formedness.rs` and `type-check-defaults.rs`.\n-        //\n-        // First we build the defaulted substitution.\n-        let substs = ty::subst::Substs::for_item(fcx.tcx, def_id, |def, _| {\n-                // All regions are identity.\n-                fcx.tcx.mk_region(ty::ReEarlyBound(def.to_early_bound_region_data()))\n-            }, |def, _| {\n-                // If the param has a default,\n-                if is_our_default(def) {\n-                    let default_ty = fcx.tcx.type_of(def.def_id);\n-                    // and it's not a dependent default\n-                    if !default_ty.needs_subst() {\n-                        // then substitute with the default.\n-                        return default_ty;\n-                    }\n+    // Check that trait predicates are WF when params are substituted by their defaults.\n+    // We don't want to overly constrain the predicates that may be written but we want to\n+    // catch cases where a default my never be applied such as `struct Foo<T: Copy = String>`.\n+    // Therefore we check if a predicate which contains a single type param\n+    // with a concrete default is WF with that default substituted.\n+    // For more examples see tests `defaults-well-formedness.rs` and `type-check-defaults.rs`.\n+    //\n+    // First we build the defaulted substitution.\n+    let substs = ty::subst::Substs::for_item(fcx.tcx, def_id, |def, _| {\n+            // All regions are identity.\n+            fcx.tcx.mk_region(ty::ReEarlyBound(def.to_early_bound_region_data()))\n+        }, |def, _| {\n+            // If the param has a default,\n+            if is_our_default(def) {\n+                let default_ty = fcx.tcx.type_of(def.def_id);\n+                // and it's not a dependent default\n+                if !default_ty.needs_subst() {\n+                    // then substitute with the default.\n+                    return default_ty;\n                 }\n-                // Mark unwanted params as err.\n-                fcx.tcx.types.err\n-            });\n-        // Now we build the substituted predicates.\n-        for &pred in predicates.predicates.iter() {\n-            struct CountParams { params: FxHashSet<u32> }\n-            impl<'tcx> ty::fold::TypeVisitor<'tcx> for CountParams {\n-                fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n-                    match t.sty {\n-                        ty::TyParam(p) => {\n-                            self.params.insert(p.idx);\n-                            t.super_visit_with(self)\n-                        }\n-                        _ => t.super_visit_with(self)\n+            }\n+            // Mark unwanted params as err.\n+            fcx.tcx.types.err\n+        });\n+    // Now we build the substituted predicates.\n+    for &pred in predicates.predicates.iter() {\n+        struct CountParams { params: FxHashSet<u32> }\n+        impl<'tcx> ty::fold::TypeVisitor<'tcx> for CountParams {\n+            fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n+                match t.sty {\n+                    ty::TyParam(p) => {\n+                        self.params.insert(p.idx);\n+                        t.super_visit_with(self)\n                     }\n+                    _ => t.super_visit_with(self)\n                 }\n             }\n-            let mut param_count = CountParams { params: FxHashSet() };\n-            pred.visit_with(&mut param_count);\n-            let substituted_pred = pred.subst(fcx.tcx, substs);\n-            // Don't check non-defaulted params, dependent defaults or preds with multiple params.\n-            if substituted_pred.references_error() || param_count.params.len() > 1 {\n-                continue;\n-            }\n-            // Avoid duplication of predicates that contain no parameters, for example.\n-            if !predicates.predicates.contains(&substituted_pred) {\n-                substituted_predicates.push(substituted_pred);\n-            }\n         }\n-\n-        predicates.predicates.extend(substituted_predicates);\n-        let predicates = predicates.instantiate_identity(fcx.tcx);\n-        let predicates = fcx.normalize_associated_types_in(span, &predicates);\n-\n-        let obligations =\n-            predicates.predicates\n-                      .iter()\n-                      .flat_map(|p| ty::wf::predicate_obligations(fcx,\n-                                                                  fcx.param_env,\n-                                                                  fcx.body_id,\n-                                                                  p,\n-                                                                  span));\n-\n-        for obligation in obligations {\n-            fcx.register_predicate(obligation);\n+        let mut param_count = CountParams { params: FxHashSet() };\n+        pred.visit_with(&mut param_count);\n+        let substituted_pred = pred.subst(fcx.tcx, substs);\n+        // Don't check non-defaulted params, dependent defaults or preds with multiple params.\n+        if substituted_pred.references_error() || param_count.params.len() > 1 {\n+            continue;\n+        }\n+        // Avoid duplication of predicates that contain no parameters, for example.\n+        if !predicates.predicates.contains(&substituted_pred) {\n+            substituted_predicates.push(substituted_pred);\n         }\n     }\n \n-    fn check_fn_or_method<'fcx, 'tcx>(&mut self,\n-                                      fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n-                                      span: Span,\n-                                      sig: ty::PolyFnSig<'tcx>,\n-                                      def_id: DefId,\n-                                      implied_bounds: &mut Vec<Ty<'tcx>>)\n-    {\n-        let sig = fcx.normalize_associated_types_in(span, &sig);\n-        let sig = fcx.tcx.liberate_late_bound_regions(def_id, &sig);\n-\n-        for input_ty in sig.inputs() {\n-            fcx.register_wf_obligation(&input_ty, span, self.code.clone());\n-        }\n-        implied_bounds.extend(sig.inputs());\n+    predicates.predicates.extend(substituted_predicates);\n+    let predicates = predicates.instantiate_identity(fcx.tcx);\n+    let predicates = fcx.normalize_associated_types_in(span, &predicates);\n+\n+    let obligations =\n+        predicates.predicates\n+                    .iter()\n+                    .flat_map(|p| ty::wf::predicate_obligations(fcx,\n+                                                                fcx.param_env,\n+                                                                fcx.body_id,\n+                                                                p,\n+                                                                span));\n+\n+    for obligation in obligations {\n+        fcx.register_predicate(obligation);\n+    }\n+}\n \n-        fcx.register_wf_obligation(sig.output(), span, self.code.clone());\n+fn check_fn_or_method<'a, 'fcx, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n+                                    fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n+                                    span: Span,\n+                                    sig: ty::PolyFnSig<'tcx>,\n+                                    def_id: DefId,\n+                                    implied_bounds: &mut Vec<Ty<'tcx>>)\n+{\n+    let sig = fcx.normalize_associated_types_in(span, &sig);\n+    let sig = fcx.tcx.liberate_late_bound_regions(def_id, &sig);\n+\n+    for input_ty in sig.inputs() {\n+        fcx.register_wf_obligation(&input_ty, span, ObligationCauseCode::MiscObligation);\n+    }\n+    implied_bounds.extend(sig.inputs());\n \n-        // FIXME(#25759) return types should not be implied bounds\n-        implied_bounds.push(sig.output());\n+    fcx.register_wf_obligation(sig.output(), span, ObligationCauseCode::MiscObligation);\n \n-        self.check_where_clauses(fcx, span, def_id);\n-    }\n+    // FIXME(#25759) return types should not be implied bounds\n+    implied_bounds.push(sig.output());\n \n-    fn check_method_receiver<'fcx, 'tcx>(&mut self,\n-                                         fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n-                                         method_sig: &hir::MethodSig,\n-                                         method: &ty::AssociatedItem,\n-                                         self_ty: Ty<'tcx>)\n-    {\n-        // check that the method has a valid receiver type, given the type `Self`\n-        debug!(\"check_method_receiver({:?}, self_ty={:?})\",\n-               method, self_ty);\n+    check_where_clauses(tcx, fcx, span, def_id);\n+}\n \n-        if !method.method_has_self_argument {\n-            return;\n-        }\n+fn check_method_receiver<'fcx, 'gcx, 'tcx>(fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n+                                           method_sig: &hir::MethodSig,\n+                                           method: &ty::AssociatedItem,\n+                                           self_ty: Ty<'tcx>)\n+{\n+    // check that the method has a valid receiver type, given the type `Self`\n+    debug!(\"check_method_receiver({:?}, self_ty={:?})\",\n+            method, self_ty);\n+\n+    if !method.method_has_self_argument {\n+        return;\n+    }\n \n-        let span = method_sig.decl.inputs[0].span;\n+    let span = method_sig.decl.inputs[0].span;\n \n-        let sig = fcx.tcx.fn_sig(method.def_id);\n-        let sig = fcx.normalize_associated_types_in(span, &sig);\n-        let sig = fcx.tcx.liberate_late_bound_regions(method.def_id, &sig);\n+    let sig = fcx.tcx.fn_sig(method.def_id);\n+    let sig = fcx.normalize_associated_types_in(span, &sig);\n+    let sig = fcx.tcx.liberate_late_bound_regions(method.def_id, &sig);\n \n-        debug!(\"check_method_receiver: sig={:?}\", sig);\n+    debug!(\"check_method_receiver: sig={:?}\", sig);\n \n-        let self_ty = fcx.normalize_associated_types_in(span, &self_ty);\n-        let self_ty = fcx.tcx.liberate_late_bound_regions(\n-            method.def_id,\n-            &ty::Binder(self_ty)\n-        );\n+    let self_ty = fcx.normalize_associated_types_in(span, &self_ty);\n+    let self_ty = fcx.tcx.liberate_late_bound_regions(\n+        method.def_id,\n+        &ty::Binder(self_ty)\n+    );\n \n-        let self_arg_ty = sig.inputs()[0];\n+    let self_arg_ty = sig.inputs()[0];\n \n-        let cause = fcx.cause(span, ObligationCauseCode::MethodReceiver);\n-        let self_arg_ty = fcx.normalize_associated_types_in(span, &self_arg_ty);\n-        let self_arg_ty = fcx.tcx.liberate_late_bound_regions(\n-            method.def_id,\n-            &ty::Binder(self_arg_ty)\n-        );\n+    let cause = fcx.cause(span, ObligationCauseCode::MethodReceiver);\n+    let self_arg_ty = fcx.normalize_associated_types_in(span, &self_arg_ty);\n+    let self_arg_ty = fcx.tcx.liberate_late_bound_regions(\n+        method.def_id,\n+        &ty::Binder(self_arg_ty)\n+    );\n \n-        let mut autoderef = fcx.autoderef(span, self_arg_ty).include_raw_pointers();\n+    let mut autoderef = fcx.autoderef(span, self_arg_ty).include_raw_pointers();\n \n-        loop {\n-            if let Some((potential_self_ty, _)) = autoderef.next() {\n-                debug!(\"check_method_receiver: potential self type `{:?}` to match `{:?}`\",\n-                    potential_self_ty, self_ty);\n+    loop {\n+        if let Some((potential_self_ty, _)) = autoderef.next() {\n+            debug!(\"check_method_receiver: potential self type `{:?}` to match `{:?}`\",\n+                potential_self_ty, self_ty);\n \n-                if fcx.infcx.can_eq(fcx.param_env, self_ty, potential_self_ty).is_ok() {\n-                    autoderef.finalize();\n-                    if let Some(mut err) = fcx.demand_eqtype_with_origin(\n-                        &cause, self_ty, potential_self_ty) {\n-                        err.emit();\n-                    }\n-                    break\n+            if fcx.infcx.can_eq(fcx.param_env, self_ty, potential_self_ty).is_ok() {\n+                autoderef.finalize();\n+                if let Some(mut err) = fcx.demand_eqtype_with_origin(\n+                    &cause, self_ty, potential_self_ty) {\n+                    err.emit();\n                 }\n-            } else {\n-                fcx.tcx.sess.diagnostic().mut_span_err(\n-                    span, &format!(\"invalid `self` type: {:?}\", self_arg_ty))\n-                .note(&format!(\"type must be `{:?}` or a type that dereferences to it\", self_ty))\n-                .help(\"consider changing to `self`, `&self`, `&mut self`, or `self: Box<Self>`\")\n-                .code(DiagnosticId::Error(\"E0307\".into()))\n-                .emit();\n-                return\n+                break\n             }\n+        } else {\n+            fcx.tcx.sess.diagnostic().mut_span_err(\n+                span, &format!(\"invalid `self` type: {:?}\", self_arg_ty))\n+            .note(&format!(\"type must be `{:?}` or a type that dereferences to it\", self_ty))\n+            .help(\"consider changing to `self`, `&self`, `&mut self`, or `self: Box<Self>`\")\n+            .code(DiagnosticId::Error(\"E0307\".into()))\n+            .emit();\n+            return\n         }\n+    }\n \n-        let is_self_ty = |ty| fcx.infcx.can_eq(fcx.param_env, self_ty, ty).is_ok();\n-        let self_kind = ExplicitSelf::determine(self_arg_ty, is_self_ty);\n-\n-        if !fcx.tcx.features().arbitrary_self_types {\n-            match self_kind {\n-                ExplicitSelf::ByValue |\n-                ExplicitSelf::ByReference(_, _) |\n-                ExplicitSelf::ByBox => (),\n-\n-                ExplicitSelf::ByRawPointer(_) => {\n-                    feature_gate::feature_err(\n-                        &fcx.tcx.sess.parse_sess,\n-                        \"arbitrary_self_types\",\n-                        span,\n-                        GateIssue::Language,\n-                        \"raw pointer `self` is unstable\")\n-                    .help(\"consider changing to `self`, `&self`, `&mut self`, or `self: Box<Self>`\")\n-                    .emit();\n-                }\n+    let is_self_ty = |ty| fcx.infcx.can_eq(fcx.param_env, self_ty, ty).is_ok();\n+    let self_kind = ExplicitSelf::determine(self_arg_ty, is_self_ty);\n+\n+    if !fcx.tcx.features().arbitrary_self_types {\n+        match self_kind {\n+            ExplicitSelf::ByValue |\n+            ExplicitSelf::ByReference(_, _) |\n+            ExplicitSelf::ByBox => (),\n+\n+            ExplicitSelf::ByRawPointer(_) => {\n+                feature_gate::feature_err(\n+                    &fcx.tcx.sess.parse_sess,\n+                    \"arbitrary_self_types\",\n+                    span,\n+                    GateIssue::Language,\n+                    \"raw pointer `self` is unstable\")\n+                .help(\"consider changing to `self`, `&self`, `&mut self`, or `self: Box<Self>`\")\n+                .emit();\n+            }\n \n-                ExplicitSelf::Other => {\n-                    feature_gate::feature_err(\n-                        &fcx.tcx.sess.parse_sess,\n-                        \"arbitrary_self_types\",\n-                        span,\n-                        GateIssue::Language,\"arbitrary `self` types are unstable\")\n-                    .help(\"consider changing to `self`, `&self`, `&mut self`, or `self: Box<Self>`\")\n-                    .emit();\n-                }\n+            ExplicitSelf::Other => {\n+                feature_gate::feature_err(\n+                    &fcx.tcx.sess.parse_sess,\n+                    \"arbitrary_self_types\",\n+                    span,\n+                    GateIssue::Language,\"arbitrary `self` types are unstable\")\n+                .help(\"consider changing to `self`, `&self`, `&mut self`, or `self: Box<Self>`\")\n+                .emit();\n             }\n         }\n     }\n+}\n \n-    fn check_variances_for_type_defn(&self,\n-                                     item: &hir::Item,\n-                                     ast_generics: &hir::Generics)\n-    {\n-        let item_def_id = self.tcx.hir.local_def_id(item.id);\n-        let ty = self.tcx.type_of(item_def_id);\n-        if self.tcx.has_error_field(ty) {\n-            return;\n-        }\n-\n-        let ty_predicates = self.tcx.predicates_of(item_def_id);\n-        assert_eq!(ty_predicates.parent, None);\n-        let variances = self.tcx.variances_of(item_def_id);\n+fn check_variances_for_type_defn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                    item: &hir::Item,\n+                                    ast_generics: &hir::Generics)\n+{\n+    let item_def_id = tcx.hir.local_def_id(item.id);\n+    let ty = tcx.type_of(item_def_id);\n+    if tcx.has_error_field(ty) {\n+        return;\n+    }\n \n-        let mut constrained_parameters: FxHashSet<_> =\n-            variances.iter().enumerate()\n-                     .filter(|&(_, &variance)| variance != ty::Bivariant)\n-                     .map(|(index, _)| Parameter(index as u32))\n-                     .collect();\n+    let ty_predicates = tcx.predicates_of(item_def_id);\n+    assert_eq!(ty_predicates.parent, None);\n+    let variances = tcx.variances_of(item_def_id);\n \n-        identify_constrained_type_params(self.tcx,\n-                                         ty_predicates.predicates.as_slice(),\n-                                         None,\n-                                         &mut constrained_parameters);\n+    let mut constrained_parameters: FxHashSet<_> =\n+        variances.iter().enumerate()\n+                    .filter(|&(_, &variance)| variance != ty::Bivariant)\n+                    .map(|(index, _)| Parameter(index as u32))\n+                    .collect();\n \n-        for (index, _) in variances.iter().enumerate() {\n-            if constrained_parameters.contains(&Parameter(index as u32)) {\n-                continue;\n-            }\n+    identify_constrained_type_params(tcx,\n+                                        ty_predicates.predicates.as_slice(),\n+                                        None,\n+                                        &mut constrained_parameters);\n \n-            let (span, name) = match ast_generics.params[index] {\n-                hir::GenericParam::Lifetime(ref ld) => (ld.lifetime.span, ld.lifetime.name.name()),\n-                hir::GenericParam::Type(ref tp) => (tp.span, tp.name),\n-            };\n-            self.report_bivariance(span, name);\n+    for (index, _) in variances.iter().enumerate() {\n+        if constrained_parameters.contains(&Parameter(index as u32)) {\n+            continue;\n         }\n+\n+        let (span, name) = match ast_generics.params[index] {\n+            hir::GenericParam::Lifetime(ref ld) => (ld.lifetime.span, ld.lifetime.name.name()),\n+            hir::GenericParam::Type(ref tp) => (tp.span, tp.name),\n+        };\n+        report_bivariance(tcx, span, name);\n     }\n+}\n \n-    fn report_bivariance(&self,\n-                         span: Span,\n-                         param_name: ast::Name)\n-    {\n-        let mut err = error_392(self.tcx, span, param_name);\n-\n-        let suggested_marker_id = self.tcx.lang_items().phantom_data();\n-        match suggested_marker_id {\n-            Some(def_id) => {\n-                err.help(\n-                    &format!(\"consider removing `{}` or using a marker such as `{}`\",\n-                             param_name,\n-                             self.tcx.item_path_str(def_id)));\n-            }\n-            None => {\n-                // no lang items, no help!\n-            }\n+fn report_bivariance<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                        span: Span,\n+                        param_name: ast::Name)\n+{\n+    let mut err = error_392(tcx, span, param_name);\n+\n+    let suggested_marker_id = tcx.lang_items().phantom_data();\n+    match suggested_marker_id {\n+        Some(def_id) => {\n+            err.help(\n+                &format!(\"consider removing `{}` or using a marker such as `{}`\",\n+                            param_name,\n+                            tcx.item_path_str(def_id)));\n+        }\n+        None => {\n+            // no lang items, no help!\n         }\n-        err.emit();\n     }\n+    err.emit();\n }\n \n fn reject_shadowing_type_parameters(tcx: TyCtxt, def_id: DefId) {\n@@ -648,34 +654,42 @@ fn reject_shadowing_type_parameters(tcx: TyCtxt, def_id: DefId) {\n     }\n }\n \n+pub struct CheckTypeWellFormedVisitor<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+}\n+\n+impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'gcx, 'gcx>)\n+               -> CheckTypeWellFormedVisitor<'a, 'gcx> {\n+        CheckTypeWellFormedVisitor {\n+            tcx,\n+        }\n+    }\n+}\n+\n impl<'a, 'tcx, 'v> Visitor<'v> for CheckTypeWellFormedVisitor<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'v> {\n         NestedVisitorMap::None\n     }\n \n     fn visit_item(&mut self, i: &hir::Item) {\n         debug!(\"visit_item: {:?}\", i);\n-        self.check_item_well_formed(i);\n+        let def_id = self.tcx.hir.local_def_id(i.id);\n+        ty::maps::queries::check_item_well_formed::ensure(self.tcx, def_id);\n         intravisit::walk_item(self, i);\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &'v hir::TraitItem) {\n         debug!(\"visit_trait_item: {:?}\", trait_item);\n-        let method_sig = match trait_item.node {\n-            hir::TraitItemKind::Method(ref sig, _) => Some(sig),\n-            _ => None\n-        };\n-        self.check_associated_item(trait_item.id, trait_item.span, method_sig);\n+        let def_id = self.tcx.hir.local_def_id(trait_item.id);\n+        ty::maps::queries::check_trait_item_well_formed::ensure(self.tcx, def_id);\n         intravisit::walk_trait_item(self, trait_item)\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &'v hir::ImplItem) {\n         debug!(\"visit_impl_item: {:?}\", impl_item);\n-        let method_sig = match impl_item.node {\n-            hir::ImplItemKind::Method(ref sig, _) => Some(sig),\n-            _ => None\n-        };\n-        self.check_associated_item(impl_item.id, impl_item.span, method_sig);\n+        let def_id = self.tcx.hir.local_def_id(impl_item.id);\n+        ty::maps::queries::check_impl_item_well_formed::ensure(self.tcx, def_id);\n         intravisit::walk_impl_item(self, impl_item)\n     }\n }"}, {"sha": "c228f54217d34c7f583dff93ef4744cf867d942d", "filename": "src/librustdoc/clean/cfg.rs", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -138,7 +138,7 @@ impl Cfg {\n \n     /// Renders the configuration for human display, as a short HTML description.\n     pub(crate) fn render_short_html(&self) -> String {\n-        let mut msg = Html(self).to_string();\n+        let mut msg = ShortHtml(self).to_string();\n         if self.should_capitalize_first_letter() {\n             if let Some(i) = msg.find(|c: char| c.is_ascii_alphanumeric()) {\n                 msg[i .. i+1].make_ascii_uppercase();\n@@ -149,7 +149,13 @@ impl Cfg {\n \n     /// Renders the configuration for long display, as a long HTML description.\n     pub(crate) fn render_long_html(&self) -> String {\n-        let mut msg = format!(\"This is supported on <strong>{}</strong>\", Html(self));\n+        let on = if self.should_use_with_in_description() {\n+            \"with\"\n+        } else {\n+            \"on\"\n+        };\n+\n+        let mut msg = format!(\"This is supported {} <strong>{}</strong>\", on, Html(self));\n         if self.should_append_only_to_description() {\n             msg.push_str(\" only\");\n         }\n@@ -180,6 +186,13 @@ impl Cfg {\n             }\n         }\n     }\n+\n+    fn should_use_with_in_description(&self) -> bool {\n+        match *self {\n+            Cfg::Cfg(ref name, _) if name == &\"target_feature\" => true,\n+            _ => false,\n+        }\n+    }\n }\n \n impl ops::Not for Cfg {\n@@ -376,6 +389,8 @@ impl<'a> fmt::Display for Html<'a> {\n                     },\n                     (\"target_endian\", Some(endian)) => return write!(fmt, \"{}-endian\", endian),\n                     (\"target_pointer_width\", Some(bits)) => return write!(fmt, \"{}-bit\", bits),\n+                    (\"target_feature\", Some(feat)) =>\n+                        return write!(fmt, \"target feature <code>{}</code>\", feat),\n                     _ => \"\",\n                 };\n                 if !human_readable.is_empty() {\n@@ -390,6 +405,19 @@ impl<'a> fmt::Display for Html<'a> {\n     }\n }\n \n+struct ShortHtml<'a>(&'a Cfg);\n+\n+impl<'a> fmt::Display for ShortHtml<'a> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        match *self.0 {\n+            Cfg::Cfg(ref name, Some(ref vendor)) if name == &\"target_feature\" => {\n+                write!(fmt, \"<code>{}</code>\", vendor)\n+            },\n+            ref cfg => write!(fmt, \"{}\", Html(cfg)),\n+        }\n+    }\n+}\n+\n #[cfg(test)]\n mod test {\n     use super::Cfg;\n@@ -824,6 +852,10 @@ mod test {\n                 ).render_short_html(),\n                 \"(Debug-assertions enabled or Windows) and Unix\"\n             );\n+            assert_eq!(\n+                name_value_cfg(\"target_feature\", \"sse2\").render_short_html(),\n+                \"<code>sse2</code>\"\n+            );\n         })\n     }\n \n@@ -898,6 +930,10 @@ mod test {\n                 \"This is supported on <strong>(debug-assertions enabled or Windows) and Unix\\\n                 </strong> only.\"\n             );\n+            assert_eq!(\n+                name_value_cfg(\"target_feature\", \"sse2\").render_long_html(),\n+                \"This is supported with <strong>target feature <code>sse2</code></strong> only.\"\n+            );\n         })\n     }\n }"}, {"sha": "1a42b02140cd27b04b0a1626343af235522a3547", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -828,6 +828,19 @@ impl Attributes {\n             })\n         }).collect();\n \n+        // treat #[target_feature(enable = \"feat\")] attributes as if they were\n+        // #[doc(cfg(target_feature = \"feat\"))] attributes as well\n+        for attr in attrs.lists(\"target_feature\") {\n+            if attr.check_name(\"enable\") {\n+                if let Some(feat) = attr.value_str() {\n+                    let meta = attr::mk_name_value_item_str(\"target_feature\".into(), feat);\n+                    if let Ok(feat_cfg) = Cfg::parse(&meta) {\n+                        cfg &= feat_cfg;\n+                    }\n+                }\n+            }\n+        }\n+\n         Attributes {\n             doc_strings,\n             other_attrs,\n@@ -929,7 +942,7 @@ fn ambiguity_error(cx: &DocContext, attrs: &Attributes,\n                       select the {}\",\n                       disambig1, kind1, disambig2,\n                       kind2))\n-             .emit();\n+      .emit();\n }\n \n /// Given an enum variant's def, return the def of its enum and the associated fragment\n@@ -1074,6 +1087,7 @@ fn macro_resolve(cx: &DocContext, path_str: &str) -> Option<Def> {\n     }\n }\n \n+#[derive(Debug)]\n enum PathKind {\n     /// can be either value or type, not a macro\n     Unknown,\n@@ -1082,7 +1096,7 @@ enum PathKind {\n     /// values, functions, consts, statics, everything in the value namespace\n     Value,\n     /// types, traits, everything in the type namespace\n-    Type\n+    Type,\n }\n \n impl Clean<Attributes> for [ast::Attribute] {\n@@ -1091,12 +1105,13 @@ impl Clean<Attributes> for [ast::Attribute] {\n \n         if UnstableFeatures::from_environment().is_nightly_build() {\n             let dox = attrs.collapsed_doc_value().unwrap_or_else(String::new);\n-            for link in markdown_links(&dox) {\n+            for ori_link in markdown_links(&dox) {\n                 // bail early for real links\n-                if link.contains('/') {\n+                if ori_link.contains('/') {\n                     continue;\n                 }\n-                let (def, fragment)  = {\n+                let link = ori_link.replace(\"`\", \"\");\n+                let (def, fragment) = {\n                     let mut kind = PathKind::Unknown;\n                     let path_str = if let Some(prefix) =\n                         [\"struct@\", \"enum@\", \"type@\",\n@@ -1132,7 +1147,6 @@ impl Clean<Attributes> for [ast::Attribute] {\n                         continue;\n                     }\n \n-\n                     match kind {\n                         PathKind::Value => {\n                             if let Ok(def) = resolve(cx, path_str, true) {\n@@ -1206,9 +1220,8 @@ impl Clean<Attributes> for [ast::Attribute] {\n                     }\n                 };\n \n-\n                 let id = register_def(cx, def);\n-                attrs.links.push((link, id, fragment));\n+                attrs.links.push((ori_link, id, fragment));\n             }\n \n             cx.sess().abort_if_errors();"}, {"sha": "c09bd4cc84ae5222714bf7bb514a38d10c4998ec", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -27,6 +27,7 @@\n \n #![allow(non_camel_case_types)]\n \n+use rustc::session;\n use std::cell::RefCell;\n use std::collections::{HashMap, VecDeque};\n use std::default::Default;\n@@ -232,14 +233,14 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'a, I> {\n /// Make headings links with anchor ids and build up TOC.\n struct LinkReplacer<'a, 'b, I: Iterator<Item = Event<'a>>> {\n     inner: I,\n-    links: &'b [(String, String)]\n+    links: &'b [(String, String)],\n }\n \n impl<'a, 'b, I: Iterator<Item = Event<'a>>> LinkReplacer<'a, 'b, I> {\n     fn new(iter: I, links: &'b [(String, String)]) -> Self {\n         LinkReplacer {\n             inner: iter,\n-            links\n+            links,\n         }\n     }\n }\n@@ -434,7 +435,8 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for Footnotes<'a, I> {\n     }\n }\n \n-pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector, position: Span) {\n+pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector, position: Span,\n+                          sess: Option<&session::Session>) {\n     tests.set_position(position);\n \n     let mut parser = Parser::new(doc);\n@@ -484,6 +486,9 @@ pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector, position: Sp\n                                    line, filename, block_info.allow_fail);\n                     prev_offset = offset;\n                 } else {\n+                    if let Some(ref sess) = sess {\n+                        sess.span_warn(position, \"invalid start of a new code block\");\n+                    }\n                     break;\n                 }\n             }"}, {"sha": "3a55b279b5cc701914f4330513a1b53320976c65", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -152,7 +152,7 @@ pub fn test(input: &str, cfgs: Vec<String>, libs: SearchPaths, externs: Externs,\n                                        true, opts, maybe_sysroot, None,\n                                        Some(PathBuf::from(input)),\n                                        linker);\n-    find_testable_code(&input_str, &mut collector, DUMMY_SP);\n+    find_testable_code(&input_str, &mut collector, DUMMY_SP, None);\n     test_args.insert(0, \"rustdoctest\".to_string());\n     testing::test_main(&test_args, collector.tests,\n                        testing::Options::new().display_output(display_warnings));"}, {"sha": "3ce8bd4ebb4c1002f70e891ff7cd78930f6c924a", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -416,6 +416,7 @@ fn partition_source(s: &str) -> (String, String) {\n         let trimline = line.trim();\n         let header = trimline.is_whitespace() ||\n             trimline.starts_with(\"#![\") ||\n+            trimline.starts_with(\"#[macro_use] extern crate\") ||\n             trimline.starts_with(\"extern crate\");\n         if !header || after_header {\n             after_header = true;\n@@ -645,8 +646,10 @@ impl<'a, 'hir> HirCollector<'a, 'hir> {\n         // the collapse-docs pass won't combine sugared/raw doc attributes, or included files with\n         // anything else, this will combine them for us\n         if let Some(doc) = attrs.collapsed_doc_value() {\n-            markdown::find_testable_code(&doc, self.collector,\n-                                         attrs.span.unwrap_or(DUMMY_SP));\n+            markdown::find_testable_code(&doc,\n+                                         self.collector,\n+                                         attrs.span.unwrap_or(DUMMY_SP),\n+                                         Some(self.sess));\n         }\n \n         nested(self);\n@@ -825,6 +828,24 @@ assert_eq!(2+2, 4);\n         assert_eq!(output, (expected, 2));\n     }\n \n+    #[test]\n+    fn make_test_manual_extern_crate_with_macro_use() {\n+        let opts = TestOptions::default();\n+        let input =\n+\"#[macro_use] extern crate asdf;\n+use asdf::qwop;\n+assert_eq!(2+2, 4);\";\n+        let expected =\n+\"#![allow(unused)]\n+#[macro_use] extern crate asdf;\n+fn main() {\n+use asdf::qwop;\n+assert_eq!(2+2, 4);\n+}\".to_string();\n+        let output = make_test(input, Some(\"asdf\"), false, &opts);\n+        assert_eq!(output, (expected, 2));\n+    }\n+\n     #[test]\n     fn make_test_opts_attrs() {\n         //if you supplied some doctest attributes with #![doc(test(attr(...)))], it will use those"}, {"sha": "6472edb0aa7d3981c8629d98185955c0244f1d89", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -52,6 +52,7 @@ pub use core::ascii::{EscapeDefault, escape_default};\n ///\n /// [combining character]: https://en.wikipedia.org/wiki/Combining_character\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_deprecated(since = \"1.26.0\", reason = \"use inherent methods instead\")]\n pub trait AsciiExt {\n     /// Container type for copied ASCII characters.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -84,6 +85,7 @@ pub trait AsciiExt {\n     /// [`make_ascii_uppercase`]: #tymethod.make_ascii_uppercase\n     /// [`str::to_uppercase`]: ../primitive.str.html#method.to_uppercase\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[allow(deprecated)]\n     fn to_ascii_uppercase(&self) -> Self::Owned;\n \n     /// Makes a copy of the value in its ASCII lower case equivalent.\n@@ -104,6 +106,7 @@ pub trait AsciiExt {\n     /// [`make_ascii_lowercase`]: #tymethod.make_ascii_lowercase\n     /// [`str::to_lowercase`]: ../primitive.str.html#method.to_lowercase\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[allow(deprecated)]\n     fn to_ascii_lowercase(&self) -> Self::Owned;\n \n     /// Checks that two values are an ASCII case-insensitive match.\n@@ -162,6 +165,7 @@ pub trait AsciiExt {\n     /// This method will be deprecated in favor of the identically-named\n     /// inherent methods on `u8`, `char`, `[u8]` and `str`.\n     #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[rustc_deprecated(since = \"1.26.0\", reason = \"use inherent methods instead\")]\n     fn is_ascii_alphabetic(&self) -> bool { unimplemented!(); }\n \n     /// Checks if the value is an ASCII uppercase character:\n@@ -174,6 +178,7 @@ pub trait AsciiExt {\n     /// This method will be deprecated in favor of the identically-named\n     /// inherent methods on `u8`, `char`, `[u8]` and `str`.\n     #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[rustc_deprecated(since = \"1.26.0\", reason = \"use inherent methods instead\")]\n     fn is_ascii_uppercase(&self) -> bool { unimplemented!(); }\n \n     /// Checks if the value is an ASCII lowercase character:\n@@ -186,6 +191,7 @@ pub trait AsciiExt {\n     /// This method will be deprecated in favor of the identically-named\n     /// inherent methods on `u8`, `char`, `[u8]` and `str`.\n     #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[rustc_deprecated(since = \"1.26.0\", reason = \"use inherent methods instead\")]\n     fn is_ascii_lowercase(&self) -> bool { unimplemented!(); }\n \n     /// Checks if the value is an ASCII alphanumeric character:\n@@ -199,6 +205,7 @@ pub trait AsciiExt {\n     /// This method will be deprecated in favor of the identically-named\n     /// inherent methods on `u8`, `char`, `[u8]` and `str`.\n     #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[rustc_deprecated(since = \"1.26.0\", reason = \"use inherent methods instead\")]\n     fn is_ascii_alphanumeric(&self) -> bool { unimplemented!(); }\n \n     /// Checks if the value is an ASCII decimal digit:\n@@ -211,6 +218,7 @@ pub trait AsciiExt {\n     /// This method will be deprecated in favor of the identically-named\n     /// inherent methods on `u8`, `char`, `[u8]` and `str`.\n     #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[rustc_deprecated(since = \"1.26.0\", reason = \"use inherent methods instead\")]\n     fn is_ascii_digit(&self) -> bool { unimplemented!(); }\n \n     /// Checks if the value is an ASCII hexadecimal digit:\n@@ -224,6 +232,7 @@ pub trait AsciiExt {\n     /// This method will be deprecated in favor of the identically-named\n     /// inherent methods on `u8`, `char`, `[u8]` and `str`.\n     #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[rustc_deprecated(since = \"1.26.0\", reason = \"use inherent methods instead\")]\n     fn is_ascii_hexdigit(&self) -> bool { unimplemented!(); }\n \n     /// Checks if the value is an ASCII punctuation character:\n@@ -241,6 +250,7 @@ pub trait AsciiExt {\n     /// This method will be deprecated in favor of the identically-named\n     /// inherent methods on `u8`, `char`, `[u8]` and `str`.\n     #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[rustc_deprecated(since = \"1.26.0\", reason = \"use inherent methods instead\")]\n     fn is_ascii_punctuation(&self) -> bool { unimplemented!(); }\n \n     /// Checks if the value is an ASCII graphic character:\n@@ -253,6 +263,7 @@ pub trait AsciiExt {\n     /// This method will be deprecated in favor of the identically-named\n     /// inherent methods on `u8`, `char`, `[u8]` and `str`.\n     #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[rustc_deprecated(since = \"1.26.0\", reason = \"use inherent methods instead\")]\n     fn is_ascii_graphic(&self) -> bool { unimplemented!(); }\n \n     /// Checks if the value is an ASCII whitespace character:\n@@ -282,6 +293,7 @@ pub trait AsciiExt {\n     /// This method will be deprecated in favor of the identically-named\n     /// inherent methods on `u8`, `char`, `[u8]` and `str`.\n     #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[rustc_deprecated(since = \"1.26.0\", reason = \"use inherent methods instead\")]\n     fn is_ascii_whitespace(&self) -> bool { unimplemented!(); }\n \n     /// Checks if the value is an ASCII control character:\n@@ -294,6 +306,7 @@ pub trait AsciiExt {\n     /// This method will be deprecated in favor of the identically-named\n     /// inherent methods on `u8`, `char`, `[u8]` and `str`.\n     #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[rustc_deprecated(since = \"1.26.0\", reason = \"use inherent methods instead\")]\n     fn is_ascii_control(&self) -> bool { unimplemented!(); }\n }\n \n@@ -354,6 +367,7 @@ macro_rules! delegating_ascii_ctype_methods {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(deprecated)]\n impl AsciiExt for u8 {\n     type Owned = u8;\n \n@@ -362,6 +376,7 @@ impl AsciiExt for u8 {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(deprecated)]\n impl AsciiExt for char {\n     type Owned = char;\n \n@@ -370,6 +385,7 @@ impl AsciiExt for char {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(deprecated)]\n impl AsciiExt for [u8] {\n     type Owned = Vec<u8>;\n \n@@ -427,6 +443,7 @@ impl AsciiExt for [u8] {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(deprecated)]\n impl AsciiExt for str {\n     type Owned = String;\n "}, {"sha": "79bb6af168fa022d4113c432c10c5757ac759159", "filename": "src/libstd/error.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibstd%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibstd%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ferror.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -56,7 +56,6 @@ use any::TypeId;\n use borrow::Cow;\n use cell;\n use char;\n-use convert;\n use core::array;\n use fmt::{self, Debug, Display};\n use mem::transmute;\n@@ -371,14 +370,6 @@ impl Error for char::ParseCharError {\n     }\n }\n \n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n-impl Error for convert::Infallible {\n-    fn description(&self) -> &str {\n-        match *self {\n-        }\n-    }\n-}\n-\n // copied from any.rs\n impl Error + 'static {\n     /// Returns true if the boxed type is the same as `T`"}, {"sha": "33d7053852246a9bf4c63d02d94682f989f888ba", "filename": "src/libstd/num.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibstd%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibstd%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -169,7 +169,6 @@ mod tests {\n \n     macro_rules! test_checked_next_power_of_two {\n         ($test_name:ident, $T:ident) => (\n-            #[cfg_attr(target_os = \"emscripten\", ignore)] // FIXME(#39119)\n             fn $test_name() {\n                 #![test]\n                 assert_eq!((0 as $T).checked_next_power_of_two(), Some(1));"}, {"sha": "afa8e3e1369354f370d5cbf5442b09dd2f3ef53b", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -10,7 +10,6 @@\n \n #![unstable(feature = \"process_internals\", issue = \"0\")]\n \n-use ascii::AsciiExt;\n use collections::BTreeMap;\n use env::split_paths;\n use env;"}, {"sha": "78b2bb5fe6e2f9213f1886922e8d7e19f0c2edae", "filename": "src/libstd/sys_common/wtf8.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibstd%2Fsys_common%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibstd%2Fsys_common%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fwtf8.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -27,7 +27,6 @@\n \n use core::str::next_code_point;\n \n-use ascii::*;\n use borrow::Cow;\n use char;\n use fmt;\n@@ -871,24 +870,22 @@ impl Hash for Wtf8 {\n     }\n }\n \n-impl AsciiExt for Wtf8 {\n-    type Owned = Wtf8Buf;\n-\n-    fn is_ascii(&self) -> bool {\n+impl Wtf8 {\n+    pub fn is_ascii(&self) -> bool {\n         self.bytes.is_ascii()\n     }\n-    fn to_ascii_uppercase(&self) -> Wtf8Buf {\n+    pub fn to_ascii_uppercase(&self) -> Wtf8Buf {\n         Wtf8Buf { bytes: self.bytes.to_ascii_uppercase() }\n     }\n-    fn to_ascii_lowercase(&self) -> Wtf8Buf {\n+    pub fn to_ascii_lowercase(&self) -> Wtf8Buf {\n         Wtf8Buf { bytes: self.bytes.to_ascii_lowercase() }\n     }\n-    fn eq_ignore_ascii_case(&self, other: &Wtf8) -> bool {\n+    pub fn eq_ignore_ascii_case(&self, other: &Wtf8) -> bool {\n         self.bytes.eq_ignore_ascii_case(&other.bytes)\n     }\n \n-    fn make_ascii_uppercase(&mut self) { self.bytes.make_ascii_uppercase() }\n-    fn make_ascii_lowercase(&mut self) { self.bytes.make_ascii_lowercase() }\n+    pub fn make_ascii_uppercase(&mut self) { self.bytes.make_ascii_uppercase() }\n+    pub fn make_ascii_lowercase(&mut self) { self.bytes.make_ascii_lowercase() }\n }\n \n #[cfg(test)]"}, {"sha": "202dc03eaa41d511452cb28880e194460d610dc9", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -298,7 +298,6 @@ pub fn str_lit(lit: &str, diag: Option<(Span, &Handler)>) -> String {\n     debug!(\"parse_str_lit: given {}\", escape_default(lit));\n     let mut res = String::with_capacity(lit.len());\n \n-    // FIXME #8372: This could be a for-loop if it didn't borrow the iterator\n     let error = |i| format!(\"lexer should have rejected {} at {}\", lit, i);\n \n     /// Eat everything up to a non-whitespace\n@@ -503,7 +502,6 @@ pub fn byte_lit(lit: &str) -> (u8, usize) {\n pub fn byte_str_lit(lit: &str) -> Lrc<Vec<u8>> {\n     let mut res = Vec::with_capacity(lit.len());\n \n-    // FIXME #8372: This could be a for-loop if it didn't borrow the iterator\n     let error = |i| format!(\"lexer should have rejected {} at {}\", lit, i);\n \n     /// Eat everything up to a non-whitespace"}, {"sha": "5264b627e96137b0b933adce4c3bdcab30115ae5", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -628,8 +628,15 @@ fn path_node(ids: Vec<Ident>) -> ast::Path {\n }\n \n fn path_name_i(idents: &[Ident]) -> String {\n-    // FIXME: Bad copies (#2543 -- same for everything else that says \"bad\")\n-    idents.iter().map(|i| i.to_string()).collect::<Vec<String>>().join(\"::\")\n+    let mut path_name = \"\".to_string();\n+    let mut idents_iter = idents.iter().peekable();\n+    while let Some(ident) = idents_iter.next() {\n+        path_name.push_str(&ident.name.as_str());\n+        if let Some(_) = idents_iter.peek() {\n+            path_name.push_str(\"::\")\n+        }\n+    }\n+    path_name\n }\n \n fn mk_tests(cx: &TestCtxt) -> P<ast::Item> {\n@@ -682,7 +689,6 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> P<ast::Expr> {\n     // gensym information.\n \n     let span = ignored_span(cx, test.span);\n-    let path = test.path.clone();\n     let ecx = &cx.ext_cx;\n     let self_id = ecx.ident_of(\"self\");\n     let test_id = ecx.ident_of(\"test\");\n@@ -694,10 +700,11 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> P<ast::Expr> {\n     // creates $name: $expr\n     let field = |name, expr| ecx.field_imm(span, ecx.ident_of(name), expr);\n \n-    debug!(\"encoding {}\", path_name_i(&path[..]));\n-\n     // path to the #[test] function: \"foo::bar::baz\"\n-    let path_string = path_name_i(&path[..]);\n+    let path_string = path_name_i(&test.path[..]);\n+\n+    debug!(\"encoding {}\", path_string);\n+\n     let name_expr = ecx.expr_str(span, Symbol::intern(&path_string));\n \n     // self::test::StaticTestName($name_expr)\n@@ -744,7 +751,7 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> P<ast::Expr> {\n             diag.bug(\"expected to find top-level re-export name, but found None\");\n         }\n     };\n-    visible_path.extend(path);\n+    visible_path.extend_from_slice(&test.path[..]);\n \n     // Rather than directly give the test function to the test\n     // harness, we create a wrapper like one of the following:"}, {"sha": "bcb720e55861c38db47f2ebdf26b7198338cb39d", "filename": "src/stdsimd", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstdsimd?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -1 +1 @@\n-Subproject commit ab9356f2af650815d339d77306f0d09c44d531ad\n+Subproject commit bcb720e55861c38db47f2ebdf26b7198338cb39d"}, {"sha": "367d509cadfe3755e38ad0f17a79bbe3dfc80b3f", "filename": "src/test/codegen/abi-main-signature-16bit-c-int.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Ftest%2Fcodegen%2Fabi-main-signature-16bit-c-int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Ftest%2Fcodegen%2Fabi-main-signature-16bit-c-int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fabi-main-signature-16bit-c-int.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -19,6 +19,7 @@\n // ignore-mips\n // ignore-mips64\n // ignore-powerpc\n+// ignore-powerpc64\n // ignore-s390x\n // ignore-sparc\n // ignore-wasm32"}, {"sha": "d6dd3f356b5fe7b363d4799ab2f6c7eb75f45fb8", "filename": "src/test/codegen/fastcall-inreg.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Ftest%2Fcodegen%2Ffastcall-inreg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Ftest%2Fcodegen%2Ffastcall-inreg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Ffastcall-inreg.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -23,6 +23,8 @@\n // ignore-mips\n // ignore-mips64\n // ignore-msp430\n+// ignore-powerpc64\n+// ignore-powerpc64le\n // ignore-powerpc\n // ignore-r600\n // ignore-amdgcn"}, {"sha": "6b79e79fa0080df6e56c9c97fc9e60186e6ab24b", "filename": "src/test/codegen/global_asm.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Ftest%2Fcodegen%2Fglobal_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Ftest%2Fcodegen%2Fglobal_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fglobal_asm.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -19,6 +19,8 @@\n // ignore-mips\n // ignore-mips64\n // ignore-msp430\n+// ignore-powerpc64\n+// ignore-powerpc64le\n // ignore-powerpc\n // ignore-r600\n // ignore-amdgcn"}, {"sha": "3f73a1cabbf19630d0e2a583af34ca75860bafbb", "filename": "src/test/codegen/global_asm_include.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Ftest%2Fcodegen%2Fglobal_asm_include.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Ftest%2Fcodegen%2Fglobal_asm_include.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fglobal_asm_include.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -19,6 +19,8 @@\n // ignore-mips\n // ignore-mips64\n // ignore-msp430\n+// ignore-powerpc64\n+// ignore-powerpc64le\n // ignore-powerpc\n // ignore-r600\n // ignore-amdgcn"}, {"sha": "3e118a50d454e10dc0642dff7ce357e9afa250d9", "filename": "src/test/codegen/global_asm_x2.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Ftest%2Fcodegen%2Fglobal_asm_x2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Ftest%2Fcodegen%2Fglobal_asm_x2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fglobal_asm_x2.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -19,6 +19,8 @@\n // ignore-mips\n // ignore-mips64\n // ignore-msp430\n+// ignore-powerpc64\n+// ignore-powerpc64le\n // ignore-powerpc\n // ignore-r600\n // ignore-amdgcn"}, {"sha": "2eeed2b788ce2f68154dfa32243aa51bc7a6fc2a", "filename": "src/test/codegen/repr-transparent-aggregates-1.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Ftest%2Fcodegen%2Frepr-transparent-aggregates-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Ftest%2Fcodegen%2Frepr-transparent-aggregates-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Frepr-transparent-aggregates-1.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -14,6 +14,7 @@\n // ignore-mips\n // ignore-mips64\n // ignore-powerpc\n+// ignore-powerpc64\n // See repr-transparent.rs\n \n #![crate_type=\"lib\"]"}, {"sha": "af1707de6c02f52432cfc241cca0df4f9e06ad70", "filename": "src/test/run-make/tools.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Ftest%2Frun-make%2Ftools.mk", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Ftest%2Frun-make%2Ftools.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Ftools.mk?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -9,7 +9,7 @@ RUSTC_ORIGINAL := $(RUSTC)\n BARE_RUSTC := $(HOST_RPATH_ENV) '$(RUSTC)'\n BARE_RUSTDOC := $(HOST_RPATH_ENV) '$(RUSTDOC)'\n RUSTC := $(BARE_RUSTC) --out-dir $(TMPDIR) -L $(TMPDIR) $(RUSTFLAGS)\n-RUSTDOC := $(BARE_RUSTDOC)\n+RUSTDOC := $(BARE_RUSTDOC) -L $(TARGET_RPATH_DIR)\n ifdef RUSTC_LINKER\n RUSTC := $(RUSTC) -Clinker=$(RUSTC_LINKER)\n RUSTDOC := $(RUSTDOC) --linker $(RUSTC_LINKER) -Z unstable-options"}, {"sha": "d3ba477fa573e7ca9937253deb520ac8f0adcc72", "filename": "src/test/run-pass/issue-10683.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Ftest%2Frun-pass%2Fissue-10683.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Ftest%2Frun-pass%2Fissue-10683.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-10683.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -10,8 +10,6 @@\n \n // pretty-expanded FIXME #23616\n \n-use std::ascii::AsciiExt;\n-\n static NAME: &'static str = \"hello world\";\n \n fn main() {"}, {"sha": "29a5f6dd24bd0c0f874fc32fb33c9461e33b25b0", "filename": "src/test/run-pass/issue-27889.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Ftest%2Frun-pass%2Fissue-27889.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Ftest%2Frun-pass%2Fissue-27889.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-27889.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -10,7 +10,6 @@\n \n // Test that a field can have the same name in different variants\n // of an enum\n-// FIXME #27889\n \n pub enum Foo {\n     X { foo: u32 },"}, {"sha": "e21e487fedd1c81d5618a491e3530b3a75f99907", "filename": "src/test/run-pass/issue-28561.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Ftest%2Frun-pass%2Fissue-28561.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Ftest%2Frun-pass%2Fissue-28561.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-28561.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -45,7 +45,7 @@ struct Array<T> {\n     f32: [T; 32],\n }\n \n-// FIXME(#7622): merge with `Array` once `[T; N]: Clone` where `T: Clone`\n+// FIXME(#44580): merge with `Array` once `[T; N]: Clone` where `T: Clone`\n #[derive(Clone, Copy)]\n struct CopyArray<T: Copy> {\n     f00: [T; 00],"}, {"sha": "1633711e83d9afa2fd9af978773c867ca1f31e50", "filename": "src/test/rustdoc/check-styled-link.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Ftest%2Frustdoc%2Fcheck-styled-link.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Ftest%2Frustdoc%2Fcheck-styled-link.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fcheck-styled-link.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_name = \"foo\"]\n+\n+pub struct Foo;\n+\n+// @has foo/struct.Bar.html '//a[@href=\"../foo/struct.Foo.html\"]' 'Foo'\n+\n+/// Code-styled reference to [`Foo`].\n+pub struct Bar;"}, {"sha": "ea8a13b034beb244eaf4a716864f1317ec70f07d", "filename": "src/test/rustdoc/doc-cfg.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Ftest%2Frustdoc%2Fdoc-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Ftest%2Frustdoc%2Fdoc-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fdoc-cfg.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #![feature(doc_cfg)]\n+#![feature(target_feature, cfg_target_feature)]\n \n // @has doc_cfg/struct.Portable.html\n // @!has - '//*[@id=\"main\"]/*[@class=\"stability\"]/*[@class=\"stab portability\"]' ''\n@@ -45,3 +46,26 @@ pub mod unix_only {\n         fn unix_and_arm_only_function() {}\n     }\n }\n+\n+// tagging a function with `#[target_feature]` creates a doc(cfg(target_feature)) node for that\n+// item as well\n+\n+// the portability header is different on the module view versus the full view\n+// @has doc_cfg/index.html\n+// @matches - '//*[@class=\" module-item\"]//*[@class=\"stab portability\"]' '\\Aavx\\Z'\n+\n+// @has doc_cfg/fn.uses_target_feature.html\n+// @has - '//*[@id=\"main\"]/*[@class=\"stability\"]/*[@class=\"stab portability\"]' \\\n+//        'This is supported with target feature avx only.'\n+#[target_feature(enable = \"avx\")]\n+pub unsafe fn uses_target_feature() {\n+    content::should::be::irrelevant();\n+}\n+\n+// @has doc_cfg/fn.uses_cfg_target_feature.html\n+// @has - '//*[@id=\"main\"]/*[@class=\"stability\"]/*[@class=\"stab portability\"]' \\\n+//        'This is supported with target feature avx only.'\n+#[doc(cfg(target_feature = \"avx\"))]\n+pub fn uses_cfg_target_feature() {\n+    uses_target_feature();\n+}"}, {"sha": "010cb77edc3f10e87c2ad921edde77d4e93042f2", "filename": "src/test/ui/chalkify/lower_trait.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Ftest%2Fui%2Fchalkify%2Flower_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Ftest%2Fui%2Fchalkify%2Flower_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_trait.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+\n+#[rustc_dump_program_clauses] //~ ERROR Implemented(Self: Foo<S, T, U>) :-\n+trait Foo<S, T, U> {\n+    fn s(S) -> S;\n+    fn t(T) -> T;\n+    fn u(U) -> U;\n+}\n+\n+fn main() {\n+    println!(\"hello\");\n+}"}, {"sha": "6da1e2fd8edd8f810a1b858fc32c970536286fcd", "filename": "src/test/ui/chalkify/lower_trait.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Ftest%2Fui%2Fchalkify%2Flower_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Ftest%2Fui%2Fchalkify%2Flower_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_trait.stderr?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -0,0 +1,8 @@\n+error: Implemented(Self: Foo<S, T, U>) :- FromEnv(Self: Foo<S, T, U>).\n+  --> $DIR/lower_trait.rs:13:1\n+   |\n+LL | #[rustc_dump_program_clauses] //~ ERROR Implemented(Self: Foo<S, T, U>) :-\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "64264999fd2f1c671a175077f0a65f35ae2d17b7", "filename": "src/test/ui/type-dependent-def-issue-49241.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Ftest%2Fui%2Ftype-dependent-def-issue-49241.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Ftest%2Fui%2Ftype-dependent-def-issue-49241.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-dependent-def-issue-49241.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let v = vec![0];\n+    const l: usize = v.count(); //~ ERROR can't capture dynamic environment in a fn item\n+    let s: [u32; l] = v.into_iter().collect(); //~ ERROR constant evaluation error\n+}"}, {"sha": "f00edccae5d50f585ac06ffcd1224ca4adc2ba1f", "filename": "src/test/ui/type-dependent-def-issue-49241.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Ftest%2Fui%2Ftype-dependent-def-issue-49241.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Ftest%2Fui%2Ftype-dependent-def-issue-49241.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-dependent-def-issue-49241.stderr?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -0,0 +1,18 @@\n+error[E0434]: can't capture dynamic environment in a fn item\n+  --> $DIR/type-dependent-def-issue-49241.rs:13:22\n+   |\n+LL |     const l: usize = v.count(); //~ ERROR can't capture dynamic environment in a fn item\n+   |                      ^\n+   |\n+   = help: use the `|| { ... }` closure form instead\n+\n+error[E0080]: constant evaluation error\n+  --> $DIR/type-dependent-def-issue-49241.rs:14:18\n+   |\n+LL |     let s: [u32; l] = v.into_iter().collect(); //~ ERROR constant evaluation error\n+   |                  ^ encountered constants with type errors, stopping evaluation\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors occurred: E0080, E0434.\n+For more information about an error, try `rustc --explain E0080`."}, {"sha": "43220af4893bbcd97efb776f6af9961e68c4f9a0", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -1324,6 +1324,8 @@ impl<'test> TestCx<'test> {\n         let mut rustdoc = Command::new(rustdoc_path);\n \n         rustdoc\n+            .arg(\"-L\")\n+            .arg(self.config.run_lib_path.to_str().unwrap())\n             .arg(\"-L\")\n             .arg(aux_dir)\n             .arg(\"-o\")\n@@ -2358,11 +2360,6 @@ impl<'test> TestCx<'test> {\n     }\n \n     fn run_rmake_test(&self) {\n-        // FIXME(#11094): we should fix these tests\n-        if self.config.host != self.config.target {\n-            return;\n-        }\n-\n         let cwd = env::current_dir().unwrap();\n         let src_root = self.config\n             .src_base"}, {"sha": "c612f0117aaf7f311365369302807cea21eef268", "filename": "src/tools/compiletest/src/util.rs", "status": "modified", "additions": 26, "deletions": 7, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5092c6b01acbff60935a5e6d84f83b6c73c1ca5e/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs?ref=5092c6b01acbff60935a5e6d84f83b6c73c1ca5e", "patch": "@@ -14,42 +14,59 @@ use common::Config;\n /// Conversion table from triple OS name to Rust SYSNAME\n const OS_TABLE: &'static [(&'static str, &'static str)] = &[\n     (\"android\", \"android\"),\n+    (\"androideabi\", \"android\"),\n     (\"bitrig\", \"bitrig\"),\n     (\"cloudabi\", \"cloudabi\"),\n     (\"darwin\", \"macos\"),\n     (\"dragonfly\", \"dragonfly\"),\n+    (\"emscripten\", \"emscripten\"),\n     (\"freebsd\", \"freebsd\"),\n+    (\"fuchsia\", \"fuchsia\"),\n     (\"haiku\", \"haiku\"),\n     (\"ios\", \"ios\"),\n+    (\"l4re\", \"l4re\"),\n     (\"linux\", \"linux\"),\n     (\"mingw32\", \"windows\"),\n     (\"netbsd\", \"netbsd\"),\n     (\"openbsd\", \"openbsd\"),\n+    (\"redox\", \"redox\"),\n+    (\"solaris\", \"solaris\"),\n     (\"win32\", \"windows\"),\n     (\"windows\", \"windows\"),\n-    (\"solaris\", \"solaris\"),\n-    (\"emscripten\", \"emscripten\"),\n ];\n \n const ARCH_TABLE: &'static [(&'static str, &'static str)] = &[\n     (\"aarch64\", \"aarch64\"),\n     (\"amd64\", \"x86_64\"),\n     (\"arm\", \"arm\"),\n     (\"arm64\", \"aarch64\"),\n+    (\"armv4t\", \"arm\"),\n+    (\"armv5te\", \"arm\"),\n+    (\"armv7\", \"arm\"),\n+    (\"armv7s\", \"arm\"),\n+    (\"asmjs\", \"asmjs\"),\n     (\"hexagon\", \"hexagon\"),\n     (\"i386\", \"x86\"),\n     (\"i586\", \"x86\"),\n     (\"i686\", \"x86\"),\n-    (\"mips64\", \"mips64\"),\n     (\"mips\", \"mips\"),\n+    (\"mips64\", \"mips64\"),\n+    (\"mips64el\", \"mips64\"),\n+    (\"mipsel\", \"mips\"),\n     (\"msp430\", \"msp430\"),\n     (\"powerpc\", \"powerpc\"),\n+    (\"powerpc64\", \"powerpc64\"),\n+    (\"powerpc64le\", \"powerpc64\"),\n     (\"s390x\", \"s390x\"),\n     (\"sparc\", \"sparc\"),\n+    (\"sparc64\", \"sparc64\"),\n+    (\"sparcv9\", \"sparc64\"),\n+    (\"thumbv6m\", \"thumb\"),\n+    (\"thumbv7em\", \"thumb\"),\n+    (\"thumbv7m\", \"thumb\"),\n+    (\"wasm32\", \"wasm32\"),\n     (\"x86_64\", \"x86_64\"),\n     (\"xcore\", \"xcore\"),\n-    (\"asmjs\", \"asmjs\"),\n-    (\"wasm32\", \"wasm32\"),\n ];\n \n pub fn matches_os(triple: &str, name: &str) -> bool {\n@@ -58,16 +75,18 @@ pub fn matches_os(triple: &str, name: &str) -> bool {\n     if triple == \"wasm32-unknown-unknown\" {\n         return name == \"emscripten\" || name == \"wasm32-bare\"\n     }\n+    let triple: Vec<_> = triple.split('-').collect();\n     for &(triple_os, os) in OS_TABLE {\n-        if triple.contains(triple_os) {\n+        if triple.contains(&triple_os) {\n             return os == name;\n         }\n     }\n     panic!(\"Cannot determine OS from triple\");\n }\n pub fn get_arch(triple: &str) -> &'static str {\n+    let triple: Vec<_> = triple.split('-').collect();\n     for &(triple_arch, arch) in ARCH_TABLE {\n-        if triple.contains(triple_arch) {\n+        if triple.contains(&triple_arch) {\n             return arch;\n         }\n     }"}]}