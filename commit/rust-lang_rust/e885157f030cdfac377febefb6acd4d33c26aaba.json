{"sha": "e885157f030cdfac377febefb6acd4d33c26aaba", "node_id": "C_kwDOAAsO6NoAKGU4ODUxNTdmMDMwY2RmYWMzNzdmZWJlZmI2YWNkNGQzM2MyNmFhYmE", "commit": {"author": {"name": "Ding Xiang Fei", "email": "dingxiangfei2009@protonmail.ch", "date": "2022-04-01T13:12:18Z"}, "committer": {"name": "Ding Xiang Fei", "email": "dingxiangfei2009@protonmail.ch", "date": "2022-05-22T08:46:50Z"}, "message": "factor out the rvalue lifetime rule\n\nremove region_scope_tree from RegionCtxt\n\nApply suggestions from code review\n\nCo-authored-by: Niko Matsakis <niko@alum.mit.edu>", "tree": {"sha": "5e1241ac8752fb508b83434eb1aad6d880f0ce25", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e1241ac8752fb508b83434eb1aad6d880f0ce25"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e885157f030cdfac377febefb6acd4d33c26aaba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e885157f030cdfac377febefb6acd4d33c26aaba", "html_url": "https://github.com/rust-lang/rust/commit/e885157f030cdfac377febefb6acd4d33c26aaba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e885157f030cdfac377febefb6acd4d33c26aaba/comments", "author": {"login": "dingxiangfei2009", "id": 6884440, "node_id": "MDQ6VXNlcjY4ODQ0NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/6884440?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dingxiangfei2009", "html_url": "https://github.com/dingxiangfei2009", "followers_url": "https://api.github.com/users/dingxiangfei2009/followers", "following_url": "https://api.github.com/users/dingxiangfei2009/following{/other_user}", "gists_url": "https://api.github.com/users/dingxiangfei2009/gists{/gist_id}", "starred_url": "https://api.github.com/users/dingxiangfei2009/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dingxiangfei2009/subscriptions", "organizations_url": "https://api.github.com/users/dingxiangfei2009/orgs", "repos_url": "https://api.github.com/users/dingxiangfei2009/repos", "events_url": "https://api.github.com/users/dingxiangfei2009/events{/privacy}", "received_events_url": "https://api.github.com/users/dingxiangfei2009/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dingxiangfei2009", "id": 6884440, "node_id": "MDQ6VXNlcjY4ODQ0NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/6884440?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dingxiangfei2009", "html_url": "https://github.com/dingxiangfei2009", "followers_url": "https://api.github.com/users/dingxiangfei2009/followers", "following_url": "https://api.github.com/users/dingxiangfei2009/following{/other_user}", "gists_url": "https://api.github.com/users/dingxiangfei2009/gists{/gist_id}", "starred_url": "https://api.github.com/users/dingxiangfei2009/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dingxiangfei2009/subscriptions", "organizations_url": "https://api.github.com/users/dingxiangfei2009/orgs", "repos_url": "https://api.github.com/users/dingxiangfei2009/repos", "events_url": "https://api.github.com/users/dingxiangfei2009/events{/privacy}", "received_events_url": "https://api.github.com/users/dingxiangfei2009/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc965c7300bb05dc11461d7de509e88804392c74", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc965c7300bb05dc11461d7de509e88804392c74", "html_url": "https://github.com/rust-lang/rust/commit/fc965c7300bb05dc11461d7de509e88804392c74"}], "stats": {"total": 122, "additions": 76, "deletions": 46}, "files": [{"sha": "e2b82f9fd02ad2552bf5bd8910705e7fdc13a381", "filename": "clippy_lints/src/loops/needless_range_loop.rs", "status": "modified", "additions": 53, "deletions": 23, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/e885157f030cdfac377febefb6acd4d33c26aaba/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e885157f030cdfac377febefb6acd4d33c26aaba/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs?ref=e885157f030cdfac377febefb6acd4d33c26aaba", "patch": "@@ -3,7 +3,9 @@ use clippy_utils::diagnostics::{multispan_sugg, span_lint_and_then};\n use clippy_utils::source::snippet;\n use clippy_utils::ty::has_iter_method;\n use clippy_utils::visitors::is_local_used;\n-use clippy_utils::{contains_name, higher, is_integer_const, match_trait_method, paths, sugg, SpanlessEq};\n+use clippy_utils::{\n+    contains_name, higher, is_integer_const, match_trait_method, paths, sugg, SpanlessEq,\n+};\n use if_chain::if_chain;\n use rustc_ast::ast;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -27,12 +29,7 @@ pub(super) fn check<'tcx>(\n     body: &'tcx Expr<'_>,\n     expr: &'tcx Expr<'_>,\n ) {\n-    if let Some(higher::Range {\n-        start: Some(start),\n-        ref end,\n-        limits,\n-    }) = higher::Range::hir(arg)\n-    {\n+    if let Some(higher::Range { start: Some(start), ref end, limits }) = higher::Range::hir(arg) {\n         // the var must be a single name\n         if let PatKind::Binding(_, canonical_id, ident, _) = pat.kind {\n             let mut visitor = VarVisitor {\n@@ -58,7 +55,11 @@ pub(super) fn check<'tcx>(\n                 // ensure that the indexed variable was declared before the loop, see #601\n                 if let Some(indexed_extent) = indexed_extent {\n                     let parent_def_id = cx.tcx.hir().get_parent_item(expr.hir_id);\n-                    let region_scope_tree = cx.tcx.region_scope_tree(parent_def_id);\n+                    let parent_body_id = cx\n+                        .tcx\n+                        .hir()\n+                        .body_owned_by(cx.tcx.hir().local_def_id_to_hir_id(parent_def_id));\n+                    let region_scope_tree = &cx.tcx.typeck_body(parent_body_id).region_scope_tree;\n                     let pat_extent = region_scope_tree.var_scope(pat.hir_id.local_id).unwrap();\n                     if region_scope_tree.is_subscope_of(indexed_extent, pat_extent) {\n                         return;\n@@ -107,17 +108,22 @@ pub(super) fn check<'tcx>(\n                         }\n                     }\n \n-                    if is_len_call(end, indexed) || is_end_eq_array_len(cx, end, limits, indexed_ty) {\n+                    if is_len_call(end, indexed) || is_end_eq_array_len(cx, end, limits, indexed_ty)\n+                    {\n                         String::new()\n-                    } else if visitor.indexed_mut.contains(&indexed) && contains_name(indexed, take_expr) {\n+                    } else if visitor.indexed_mut.contains(&indexed)\n+                        && contains_name(indexed, take_expr)\n+                    {\n                         return;\n                     } else {\n                         match limits {\n                             ast::RangeLimits::Closed => {\n                                 let take_expr = sugg::Sugg::hir(cx, take_expr, \"<count>\");\n                                 format!(\".take({})\", take_expr + sugg::ONE)\n-                            },\n-                            ast::RangeLimits::HalfOpen => format!(\".take({})\", snippet(cx, take_expr.span, \"..\")),\n+                            }\n+                            ast::RangeLimits::HalfOpen => {\n+                                format!(\".take({})\", snippet(cx, take_expr.span, \"..\"))\n+                            }\n                         }\n                     }\n                 } else {\n@@ -143,7 +149,10 @@ pub(super) fn check<'tcx>(\n                         cx,\n                         NEEDLESS_RANGE_LOOP,\n                         arg.span,\n-                        &format!(\"the loop variable `{}` is used to index `{}`\", ident.name, indexed),\n+                        &format!(\n+                            \"the loop variable `{}` is used to index `{}`\",\n+                            ident.name, indexed\n+                        ),\n                         |diag| {\n                             multispan_sugg(\n                                 diag,\n@@ -152,7 +161,10 @@ pub(super) fn check<'tcx>(\n                                     (pat.span, format!(\"({}, <item>)\", ident.name)),\n                                     (\n                                         arg.span,\n-                                        format!(\"{}.{}().enumerate(){}{}\", indexed, method, method_1, method_2),\n+                                        format!(\n+                                            \"{}.{}().enumerate(){}{}\",\n+                                            indexed, method, method_1, method_2\n+                                        ),\n                                     ),\n                                 ],\n                             );\n@@ -169,7 +181,10 @@ pub(super) fn check<'tcx>(\n                         cx,\n                         NEEDLESS_RANGE_LOOP,\n                         arg.span,\n-                        &format!(\"the loop variable `{}` is only used to index `{}`\", ident.name, indexed),\n+                        &format!(\n+                            \"the loop variable `{}` is only used to index `{}`\",\n+                            ident.name, indexed\n+                        ),\n                         |diag| {\n                             multispan_sugg(\n                                 diag,\n@@ -246,7 +261,12 @@ struct VarVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> VarVisitor<'a, 'tcx> {\n-    fn check(&mut self, idx: &'tcx Expr<'_>, seqexpr: &'tcx Expr<'_>, expr: &'tcx Expr<'_>) -> bool {\n+    fn check(\n+        &mut self,\n+        idx: &'tcx Expr<'_>,\n+        seqexpr: &'tcx Expr<'_>,\n+        expr: &'tcx Expr<'_>,\n+    ) -> bool {\n         if_chain! {\n             // the indexed container is referenced by a name\n             if let ExprKind::Path(ref seqpath) = seqexpr.kind;\n@@ -262,7 +282,16 @@ impl<'a, 'tcx> VarVisitor<'a, 'tcx> {\n                 match res {\n                     Res::Local(hir_id) => {\n                         let parent_def_id = self.cx.tcx.hir().get_parent_item(expr.hir_id);\n-                        let extent = self.cx.tcx.region_scope_tree(parent_def_id).var_scope(hir_id.local_id).unwrap();\n+                        let parent_body_id = self.cx\n+                            .tcx\n+                            .hir()\n+                            .body_owned_by(self.cx.tcx.hir().local_def_id_to_hir_id(parent_def_id));\n+                        let extent = self.cx\n+                            .tcx\n+                            .typeck_body(parent_body_id)\n+                            .region_scope_tree\n+                            .var_scope(hir_id.local_id)\n+                            .unwrap();\n                         if index_used_directly {\n                             self.indexed_directly.insert(\n                                 seqvar.segments[0].ident.name,\n@@ -331,13 +360,13 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n                 self.visit_expr(lhs);\n                 self.prefer_mutable = false;\n                 self.visit_expr(rhs);\n-            },\n+            }\n             ExprKind::AddrOf(BorrowKind::Ref, mutbl, expr) => {\n                 if mutbl == Mutability::Mut {\n                     self.prefer_mutable = true;\n                 }\n                 self.visit_expr(expr);\n-            },\n+            }\n             ExprKind::Call(f, args) => {\n                 self.visit_expr(f);\n                 for expr in args {\n@@ -350,10 +379,11 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n                     }\n                     self.visit_expr(expr);\n                 }\n-            },\n+            }\n             ExprKind::MethodCall(_, args, _) => {\n                 let def_id = self.cx.typeck_results().type_dependent_def_id(expr.hir_id).unwrap();\n-                for (ty, expr) in iter::zip(self.cx.tcx.fn_sig(def_id).inputs().skip_binder(), args) {\n+                for (ty, expr) in iter::zip(self.cx.tcx.fn_sig(def_id).inputs().skip_binder(), args)\n+                {\n                     self.prefer_mutable = false;\n                     if let ty::Ref(_, _, mutbl) = *ty.kind() {\n                         if mutbl == Mutability::Mut {\n@@ -362,11 +392,11 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n                     }\n                     self.visit_expr(expr);\n                 }\n-            },\n+            }\n             ExprKind::Closure(_, _, body_id, ..) => {\n                 let body = self.cx.tcx.hir().body(body_id);\n                 self.visit_expr(&body.value);\n-            },\n+            }\n             _ => walk_expr(self, expr),\n         }\n         self.prefer_mutable = old;"}, {"sha": "db32b8d740b3ed26573392add794115279f1d862", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e885157f030cdfac377febefb6acd4d33c26aaba/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e885157f030cdfac377febefb6acd4d33c26aaba/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=e885157f030cdfac377febefb6acd4d33c26aaba", "patch": "@@ -5,7 +5,9 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def::Res;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::hir_id::ItemLocalId;\n-use rustc_hir::{Block, Body, BodyOwnerKind, Expr, ExprKind, HirId, Let, Node, Pat, PatKind, QPath, UnOp};\n+use rustc_hir::{\n+    Block, Body, BodyOwnerKind, Expr, ExprKind, HirId, Let, Node, Pat, PatKind, QPath, UnOp,\n+};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::{Span, Symbol};\n@@ -139,27 +141,31 @@ impl<'tcx> LateLintPass<'tcx> for Shadow {\n \n     fn check_body(&mut self, cx: &LateContext<'_>, body: &Body<'_>) {\n         let hir = cx.tcx.hir();\n-        if !matches!(\n-            hir.body_owner_kind(hir.body_owner_def_id(body.id())),\n-            BodyOwnerKind::Closure\n-        ) {\n+        if !matches!(hir.body_owner_kind(hir.body_owner_def_id(body.id())), BodyOwnerKind::Closure)\n+        {\n             self.bindings.push(FxHashMap::default());\n         }\n     }\n \n     fn check_body_post(&mut self, cx: &LateContext<'_>, body: &Body<'_>) {\n         let hir = cx.tcx.hir();\n-        if !matches!(\n-            hir.body_owner_kind(hir.body_owner_def_id(body.id())),\n-            BodyOwnerKind::Closure\n-        ) {\n+        if !matches!(hir.body_owner_kind(hir.body_owner_def_id(body.id())), BodyOwnerKind::Closure)\n+        {\n             self.bindings.pop();\n         }\n     }\n }\n \n-fn is_shadow(cx: &LateContext<'_>, owner: LocalDefId, first: ItemLocalId, second: ItemLocalId) -> bool {\n-    let scope_tree = cx.tcx.region_scope_tree(owner.to_def_id());\n+fn is_shadow(\n+    cx: &LateContext<'_>,\n+    owner: LocalDefId,\n+    first: ItemLocalId,\n+    second: ItemLocalId,\n+) -> bool {\n+    let scope_tree = &cx\n+        .tcx\n+        .typeck_body(cx.tcx.hir().body_owned_by(cx.tcx.hir().local_def_id_to_hir_id(owner)))\n+        .region_scope_tree;\n     let first_scope = scope_tree.var_scope(first).unwrap();\n     let second_scope = scope_tree.var_scope(second).unwrap();\n     scope_tree.is_subscope_of(second_scope, first_scope)\n@@ -174,15 +180,16 @@ fn lint_shadow(cx: &LateContext<'_>, pat: &Pat<'_>, shadowed: HirId, span: Span)\n                 snippet(cx, expr.span, \"..\")\n             );\n             (SHADOW_SAME, msg)\n-        },\n+        }\n         Some(expr) if is_local_used(cx, expr, shadowed) => {\n             let msg = format!(\"`{}` is shadowed\", snippet(cx, pat.span, \"_\"));\n             (SHADOW_REUSE, msg)\n-        },\n+        }\n         _ => {\n-            let msg = format!(\"`{}` shadows a previous, unrelated binding\", snippet(cx, pat.span, \"_\"));\n+            let msg =\n+                format!(\"`{}` shadows a previous, unrelated binding\", snippet(cx, pat.span, \"_\"));\n             (SHADOW_UNRELATED, msg)\n-        },\n+        }\n     };\n     span_lint_and_note(\n         cx,\n@@ -211,14 +218,7 @@ fn is_self_shadow(cx: &LateContext<'_>, pat: &Pat<'_>, mut expr: &Expr<'_>, hir_\n         expr = match expr.kind {\n             ExprKind::Box(e)\n             | ExprKind::AddrOf(_, _, e)\n-            | ExprKind::Block(\n-                &Block {\n-                    stmts: [],\n-                    expr: Some(e),\n-                    ..\n-                },\n-                _,\n-            )\n+            | ExprKind::Block(&Block { stmts: [], expr: Some(e), .. }, _)\n             | ExprKind::Unary(UnOp::Deref, e) => e,\n             ExprKind::Path(QPath::Resolved(None, path)) => break path.res == Res::Local(hir_id),\n             _ => break false,"}]}