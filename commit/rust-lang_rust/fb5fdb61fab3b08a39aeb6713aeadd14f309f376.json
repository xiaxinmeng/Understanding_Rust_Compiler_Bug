{"sha": "fb5fdb61fab3b08a39aeb6713aeadd14f309f376", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiNWZkYjYxZmFiM2IwOGEzOWFlYjY3MTNhZWFkZDE0ZjMwOWYzNzY=", "commit": {"author": {"name": "Ravi Shankar", "email": "wafflespeanut@gmail.com", "date": "2015-10-11T16:49:01Z"}, "committer": {"name": "Ravi Shankar", "email": "wafflespeanut@gmail.com", "date": "2015-10-12T13:42:59Z"}, "message": "whup the while_let_loop for ignoring expressions!", "tree": {"sha": "0810ad5156919147437b6e9aa5902272a59336aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0810ad5156919147437b6e9aa5902272a59336aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb5fdb61fab3b08a39aeb6713aeadd14f309f376", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb5fdb61fab3b08a39aeb6713aeadd14f309f376", "html_url": "https://github.com/rust-lang/rust/commit/fb5fdb61fab3b08a39aeb6713aeadd14f309f376", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb5fdb61fab3b08a39aeb6713aeadd14f309f376/comments", "author": {"login": "wafflespeanut", "id": 6691262, "node_id": "MDQ6VXNlcjY2OTEyNjI=", "avatar_url": "https://avatars.githubusercontent.com/u/6691262?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wafflespeanut", "html_url": "https://github.com/wafflespeanut", "followers_url": "https://api.github.com/users/wafflespeanut/followers", "following_url": "https://api.github.com/users/wafflespeanut/following{/other_user}", "gists_url": "https://api.github.com/users/wafflespeanut/gists{/gist_id}", "starred_url": "https://api.github.com/users/wafflespeanut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wafflespeanut/subscriptions", "organizations_url": "https://api.github.com/users/wafflespeanut/orgs", "repos_url": "https://api.github.com/users/wafflespeanut/repos", "events_url": "https://api.github.com/users/wafflespeanut/events{/privacy}", "received_events_url": "https://api.github.com/users/wafflespeanut/received_events", "type": "User", "site_admin": false}, "committer": {"login": "wafflespeanut", "id": 6691262, "node_id": "MDQ6VXNlcjY2OTEyNjI=", "avatar_url": "https://avatars.githubusercontent.com/u/6691262?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wafflespeanut", "html_url": "https://github.com/wafflespeanut", "followers_url": "https://api.github.com/users/wafflespeanut/followers", "following_url": "https://api.github.com/users/wafflespeanut/following{/other_user}", "gists_url": "https://api.github.com/users/wafflespeanut/gists{/gist_id}", "starred_url": "https://api.github.com/users/wafflespeanut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wafflespeanut/subscriptions", "organizations_url": "https://api.github.com/users/wafflespeanut/orgs", "repos_url": "https://api.github.com/users/wafflespeanut/repos", "events_url": "https://api.github.com/users/wafflespeanut/events{/privacy}", "received_events_url": "https://api.github.com/users/wafflespeanut/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0bb4cbe85959b5d1cf4e1bb72481e55ebd9a1efe", "url": "https://api.github.com/repos/rust-lang/rust/commits/0bb4cbe85959b5d1cf4e1bb72481e55ebd9a1efe", "html_url": "https://github.com/rust-lang/rust/commit/0bb4cbe85959b5d1cf4e1bb72481e55ebd9a1efe"}], "stats": {"total": 53, "additions": 33, "deletions": 20}, "files": [{"sha": "5657f08fdef1bb839958cb809ee3d1e2410cab6d", "filename": "src/loops.rs", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/fb5fdb61fab3b08a39aeb6713aeadd14f309f376/src%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb5fdb61fab3b08a39aeb6713aeadd14f309f376/src%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Floops.rs?ref=fb5fdb61fab3b08a39aeb6713aeadd14f309f376", "patch": "@@ -163,25 +163,31 @@ impl LateLintPass for LoopsPass {\n         // (also matches an explicit \"match\" instead of \"if let\")\n         // (even if the \"match\" or \"if let\" is used for declaration)\n         if let ExprLoop(ref block, _) = expr.node {\n-            // extract the first statement (if any) in a block\n-            let inner_stmt = extract_expr_from_first_stmt(block);\n-            // extract a single expression\n+            // extract the expression from the first statement (if any) in a block\n+            let inner_stmt_expr = extract_expr_from_first_stmt(block);\n+            // extract the first expression (if any) from the block\n             let inner_expr = extract_first_expr(block);\n-            let extracted = match inner_stmt {\n-                Some(_) => inner_stmt,\n-                None => inner_expr,\n+            let (extracted, collect_expr) = match inner_stmt_expr {\n+                Some(_) => (inner_stmt_expr, true),     // check if an expression exists in the first statement\n+                None => (inner_expr, false),    // if not, let's go for the first expression in the block\n             };\n \n             if let Some(inner) = extracted {\n-                // collect remaining expressions below the match\n-                let other_stuff = block.stmts\n-                                  .iter()\n-                                  .skip(1)\n-                                  .map(|stmt| {\n-                                      format!(\"{}\", snippet(cx, stmt.span, \"..\"))\n-                                  }).collect::<Vec<String>>();\n-\n                 if let ExprMatch(ref matchexpr, ref arms, ref source) = inner.node {\n+                    // collect the remaining statements below the match\n+                    let mut other_stuff = block.stmts\n+                                          .iter()\n+                                          .skip(1)\n+                                          .map(|stmt| {\n+                                              format!(\"{}\", snippet(cx, stmt.span, \"..\"))\n+                                          }).collect::<Vec<String>>();\n+                    if collect_expr {           // if we have a statement which has a match,\n+                        match block.expr {      // then collect the expression (without semicolon) below it\n+                            Some(ref expr) => other_stuff.push(format!(\"{}\", snippet(cx, expr.span, \"..\"))),\n+                            None => (),\n+                        }\n+                    }\n+\n                     // ensure \"if let\" compatible match structure\n                     match *source {\n                         MatchSource::Normal | MatchSource::IfLetDesugar{..} => if\n@@ -192,7 +198,7 @@ impl LateLintPass for LoopsPass {\n                             is_break_expr(&arms[1].body)\n                         {\n                             if in_external_macro(cx, expr.span) { return; }\n-                            let loop_body = match inner_stmt {\n+                            let loop_body = match inner_stmt_expr {\n                                 // FIXME: should probably be an ellipsis\n                                 // tabbing and newline is probably a bad idea, especially for large blocks\n                                 Some(_) => Cow::Owned(format!(\"{{\\n    {}\\n}}\", other_stuff.join(\"\\n    \"))),\n@@ -310,9 +316,9 @@ fn is_iterable_array(ty: ty::Ty) -> bool {\n \n /// If a block begins with a statement (possibly a `let` binding) and has an expression, return it.\n fn extract_expr_from_first_stmt(block: &Block) -> Option<&Expr> {\n-    match block.expr {\n-        Some(_) => None,\n-        None if !block.stmts.is_empty() => match block.stmts[0].node {\n+    match block.stmts.is_empty() {\n+        true => None,\n+        false => match block.stmts[0].node {\n             StmtDecl(ref decl, _) => match decl.node {\n                 DeclLocal(ref local) => match local.init {\n                     Some(ref expr) => Some(expr),\n@@ -322,7 +328,6 @@ fn extract_expr_from_first_stmt(block: &Block) -> Option<&Expr> {\n             },\n             _ => None,\n         },\n-        _ => None,\n     }\n }\n "}, {"sha": "c8444ee0a57d8dee44462dfb0728c2a4eb42ffa2", "filename": "tests/compile-fail/while_loop.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb5fdb61fab3b08a39aeb6713aeadd14f309f376/tests%2Fcompile-fail%2Fwhile_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb5fdb61fab3b08a39aeb6713aeadd14f309f376/tests%2Fcompile-fail%2Fwhile_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fwhile_loop.rs?ref=fb5fdb61fab3b08a39aeb6713aeadd14f309f376", "patch": "@@ -33,6 +33,14 @@ fn main() {\n         let _x = x;\n         let _str = \"foo\";\n     }\n+    loop { //~ERROR\n+        let x = match y {\n+            Some(x) => x,\n+            None => break,\n+        };\n+        { let _a = \"bar\"; };\n+        { let _b = \"foobar\"; }\n+    }\n     loop { // no error, else branch does something other than break\n         match y {\n             Some(_x) => true,\n@@ -53,7 +61,7 @@ fn main() {\n // cause this function to trigger it\n fn no_panic<T>(slice: &[T]) {\n     let mut iter = slice.iter();\n-    loop {\n+    loop { //~ERROR\n         let _ = match iter.next() {\n             Some(ele) => ele,\n             None => break"}]}