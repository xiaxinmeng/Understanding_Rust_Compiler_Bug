{"sha": "e96e6e2c89265613e136369ccf314c408e1eb002", "node_id": "C_kwDOAAsO6NoAKGU5NmU2ZTJjODkyNjU2MTNlMTM2MzY5Y2NmMzE0YzQwOGUxZWIwMDI", "commit": {"author": {"name": "flip1995", "email": "philipp.krones@embecosm.com", "date": "2022-04-21T13:02:54Z"}, "committer": {"name": "Philipp Krones", "email": "hello@philkrones.com", "date": "2022-06-14T12:50:52Z"}, "message": "Add metadata generation for vtables when using VFE\n\nThis adds the typeid and `vcall_visibility` metadata to vtables when the\n-Cvirtual-function-elimination flag is set.\n\nThe typeid is generated in the same way as for the\n`llvm.type.checked.load` intrinsic from the trait_ref.\n\nThe offset that is added to the typeid is always 0. This is because LLVM\nassumes that vtables are constructed according to the definition in the\nItanium ABI. This includes an \"address point\" of the vtable. In C++ this\nis the offset in the vtable where information for RTTI is placed. Since\nthere is no RTTI information in Rust's vtables, this \"address point\" is\nalways 0. This \"address point\" in combination with the offset passed to\nthe `llvm.type.checked.load` intrinsic determines the final function\nthat should be loaded from the vtable in the\n`WholeProgramDevirtualization` pass in LLVM. That's why the\n`llvm.type.checked.load` intrinsics are generated with the typeid of the\ntrait, rather than with that of the function that is called. This\nmatches what `clang` does for C++.\n\nThe vcall_visibility metadata depends on three factors:\n\n1. LTO level: Currently this is always fat LTO, because LLVM only\n   supports this optimization with fat LTO.\n2. Visibility of the trait: If the trait is publicly visible, VFE\n   can only act on its vtables after linking.\n3. Number of CGUs: if there is more than one CGU, also vtables with\n   restricted visibility could be seen outside of the CGU, so VFE can\n   only act on them after linking.\n\nTo reflect this, there are three visibility levels: Public, LinkageUnit,\nand TranslationUnit.", "tree": {"sha": "a393d89ac7cc97ad83826dba9c84586f1d22fdac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a393d89ac7cc97ad83826dba9c84586f1d22fdac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e96e6e2c89265613e136369ccf314c408e1eb002", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEij1UXJ/PQTcb99vTHKDfKvWdaKUFAmKohCwACgkQHKDfKvWd\naKXCtxAAqmrkkJHXZphv956Q+Npj7r5SdUxsOFSRPikziZ9UXrvhr0+hIzRROYxR\nvStewEKt84D5svFL77hVl5y1ys6Zt+VHZl6Nr3T5h2Bgl/U83kgYwUgjSJ97kgtc\nI+3lE5MElYicBgpNVUDV2/0EqgizYcoN8Rkuue2Is2ZzrAUCHv5GJMaxQAI6R2d9\nxhMGvE9GXYvXGGcxBiIYFNwfaQIru2Aki0XlDZaeM0/1wAjLZQP4wt6aSVcv5mpW\nDBtv92qA52Y7UAIXjnht/YlyiKVHZFwSsBHNEncpjQTK8Q4SpiKIprQ4+VXSYL55\natNKM0XtX2sPrwphcBH/qTPVBNeAnP3HVKBgvIP+EqA0B/d7kAJq3ElAcpTWxYzL\nBXJ9paMPdSbdyodH4zkYJ7mqTXxEwXaAnltUbyFT0OyZfqy1WG4wEKlIg8WwyBi5\n41PC47vN+ZEiEWfN9cv/ltNrkIlC6Nlzqeo5qQsSJQn2Z6Z8bh97JnuEJMQEawwW\nmY92QqVluT9mNMMNkEFrtdv4ciH64VdhpnmHtEEuBIsMJMgGYq9yvYY4DnMr207/\n2bf/RGaKt5na5YkByBKKKwg94LUIQMCZ2rxnCPkSUK+SDwDyGzqLBki9l2dtFcVf\nW1Ew+gZMX7j/kB191210a+EwHefnpqMBLZjNVbKFx0yqjjS1vXs=\n=0LEO\n-----END PGP SIGNATURE-----", "payload": "tree a393d89ac7cc97ad83826dba9c84586f1d22fdac\nparent e1c1d0f8c2fde787e346420b47c9205f52dc04d6\nauthor flip1995 <philipp.krones@embecosm.com> 1650546174 +0100\ncommitter Philipp Krones <hello@philkrones.com> 1655211052 +0200\n\nAdd metadata generation for vtables when using VFE\n\nThis adds the typeid and `vcall_visibility` metadata to vtables when the\n-Cvirtual-function-elimination flag is set.\n\nThe typeid is generated in the same way as for the\n`llvm.type.checked.load` intrinsic from the trait_ref.\n\nThe offset that is added to the typeid is always 0. This is because LLVM\nassumes that vtables are constructed according to the definition in the\nItanium ABI. This includes an \"address point\" of the vtable. In C++ this\nis the offset in the vtable where information for RTTI is placed. Since\nthere is no RTTI information in Rust's vtables, this \"address point\" is\nalways 0. This \"address point\" in combination with the offset passed to\nthe `llvm.type.checked.load` intrinsic determines the final function\nthat should be loaded from the vtable in the\n`WholeProgramDevirtualization` pass in LLVM. That's why the\n`llvm.type.checked.load` intrinsics are generated with the typeid of the\ntrait, rather than with that of the function that is called. This\nmatches what `clang` does for C++.\n\nThe vcall_visibility metadata depends on three factors:\n\n1. LTO level: Currently this is always fat LTO, because LLVM only\n   supports this optimization with fat LTO.\n2. Visibility of the trait: If the trait is publicly visible, VFE\n   can only act on its vtables after linking.\n3. Number of CGUs: if there is more than one CGU, also vtables with\n   restricted visibility could be seen outside of the CGU, so VFE can\n   only act on them after linking.\n\nTo reflect this, there are three visibility levels: Public, LinkageUnit,\nand TranslationUnit.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e96e6e2c89265613e136369ccf314c408e1eb002", "html_url": "https://github.com/rust-lang/rust/commit/e96e6e2c89265613e136369ccf314c408e1eb002", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e96e6e2c89265613e136369ccf314c408e1eb002/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1c1d0f8c2fde787e346420b47c9205f52dc04d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1c1d0f8c2fde787e346420b47c9205f52dc04d6", "html_url": "https://github.com/rust-lang/rust/commit/e1c1d0f8c2fde787e346420b47c9205f52dc04d6"}], "stats": {"total": 113, "additions": 106, "deletions": 7}, "files": [{"sha": "f586e9facc62a2ead2a4b31a7d6aa0200388c4d0", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e96e6e2c89265613e136369ccf314c408e1eb002/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/e96e6e2c89265613e136369ccf314c408e1eb002/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=e96e6e2c89265613e136369ccf314c408e1eb002", "patch": "@@ -3695,6 +3695,7 @@ dependencies = [\n  \"rustc_serialize\",\n  \"rustc_session\",\n  \"rustc_span\",\n+ \"rustc_symbol_mangling\",\n  \"rustc_target\",\n  \"smallvec\",\n  \"tracing\","}, {"sha": "9bded25c09e0772da148c703bfab75cd86c43d07", "filename": "compiler/rustc_codegen_llvm/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e96e6e2c89265613e136369ccf314c408e1eb002/compiler%2Frustc_codegen_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e96e6e2c89265613e136369ccf314c408e1eb002/compiler%2Frustc_codegen_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2FCargo.toml?ref=e96e6e2c89265613e136369ccf314c408e1eb002", "patch": "@@ -19,6 +19,7 @@ rustc-demangle = \"0.1.21\"\n rustc_arena = { path = \"../rustc_arena\" }\n rustc_attr = { path = \"../rustc_attr\" }\n rustc_codegen_ssa = { path = \"../rustc_codegen_ssa\" }\n+rustc_symbol_mangling = { path = \"../rustc_symbol_mangling\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_errors = { path = \"../rustc_errors\" }\n rustc_fs_util = { path = \"../rustc_fs_util\" }"}, {"sha": "d5f39a456706626758adec25f43f642ab787e704", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 92, "deletions": 7, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/e96e6e2c89265613e136369ccf314c408e1eb002/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e96e6e2c89265613e136369ccf314c408e1eb002/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=e96e6e2c89265613e136369ccf314c408e1eb002", "patch": "@@ -30,20 +30,21 @@ use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::bug;\n use rustc_middle::mir::{self, GeneratorLayout};\n-use rustc_middle::ty::layout::LayoutOf;\n-use rustc_middle::ty::layout::TyAndLayout;\n+use rustc_middle::ty::layout::{LayoutOf, TyAndLayout};\n use rustc_middle::ty::subst::GenericArgKind;\n-use rustc_middle::ty::{self, AdtKind, Instance, ParamEnv, Ty, TyCtxt};\n-use rustc_session::config::{self, DebugInfo};\n+use rustc_middle::ty::{\n+    self, AdtKind, Instance, ParamEnv, PolyExistentialTraitRef, Ty, TyCtxt, Visibility,\n+};\n+use rustc_session::config::{self, DebugInfo, Lto};\n use rustc_span::symbol::Symbol;\n use rustc_span::FileName;\n-use rustc_span::FileNameDisplayPreference;\n-use rustc_span::{self, SourceFile};\n+use rustc_span::{self, FileNameDisplayPreference, SourceFile};\n+use rustc_symbol_mangling::typeid_for_trait_ref;\n use rustc_target::abi::{Align, Size};\n use smallvec::smallvec;\n use tracing::debug;\n \n-use libc::{c_longlong, c_uint};\n+use libc::{c_char, c_longlong, c_uint};\n use std::borrow::Cow;\n use std::fmt::{self, Write};\n use std::hash::{Hash, Hasher};\n@@ -1468,6 +1469,84 @@ fn build_vtable_type_di_node<'ll, 'tcx>(\n     .di_node\n }\n \n+fn vcall_visibility_metadata<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    ty: Ty<'tcx>,\n+    trait_ref: Option<PolyExistentialTraitRef<'tcx>>,\n+    vtable: &'ll Value,\n+) {\n+    enum VCallVisibility {\n+        Public = 0,\n+        LinkageUnit = 1,\n+        TranslationUnit = 2,\n+    }\n+\n+    let Some(trait_ref) = trait_ref else { return };\n+\n+    let trait_ref_self = trait_ref.with_self_ty(cx.tcx, ty);\n+    let trait_ref_self = cx.tcx.erase_regions(trait_ref_self);\n+    let trait_def_id = trait_ref_self.def_id();\n+    let trait_vis = cx.tcx.visibility(trait_def_id);\n+\n+    let cgus = cx.sess().codegen_units();\n+    let single_cgu = cgus == 1;\n+\n+    let lto = cx.sess().lto();\n+\n+    // Since LLVM requires full LTO for the virtual function elimination optimization to apply,\n+    // only the `Lto::Fat` cases are relevant currently.\n+    let vcall_visibility = match (lto, trait_vis, single_cgu) {\n+        // If there is not LTO and the visibility in public, we have to assume that the vtable can\n+        // be seen from anywhere. With multiple CGUs, the vtable is quasi-public.\n+        (Lto::No | Lto::ThinLocal, Visibility::Public, _)\n+        | (Lto::No, Visibility::Restricted(_) | Visibility::Invisible, false) => {\n+            VCallVisibility::Public\n+        }\n+        // With LTO and a quasi-public visibility, the usages of the functions of the vtable are\n+        // all known by the `LinkageUnit`.\n+        // FIXME: LLVM only supports this optimization for `Lto::Fat` currently. Once it also\n+        // supports `Lto::Thin` the `VCallVisibility` may have to be adjusted for those.\n+        (Lto::Fat | Lto::Thin, Visibility::Public, _)\n+        | (\n+            Lto::ThinLocal | Lto::Thin | Lto::Fat,\n+            Visibility::Restricted(_) | Visibility::Invisible,\n+            false,\n+        ) => VCallVisibility::LinkageUnit,\n+        // If there is only one CGU, private vtables can only be seen by that CGU/translation unit\n+        // and therefore we know of all usages of functions in the vtable.\n+        (_, Visibility::Restricted(_) | Visibility::Invisible, true) => {\n+            VCallVisibility::TranslationUnit\n+        }\n+    };\n+\n+    let trait_ref_typeid = typeid_for_trait_ref(cx.tcx, trait_ref);\n+\n+    unsafe {\n+        let typeid = llvm::LLVMMDStringInContext(\n+            cx.llcx,\n+            trait_ref_typeid.as_ptr() as *const c_char,\n+            trait_ref_typeid.as_bytes().len() as c_uint,\n+        );\n+        let v = [cx.const_usize(0), typeid];\n+        llvm::LLVMRustGlobalAddMetadata(\n+            vtable,\n+            llvm::MD_type as c_uint,\n+            llvm::LLVMValueAsMetadata(llvm::LLVMMDNodeInContext(\n+                cx.llcx,\n+                v.as_ptr(),\n+                v.len() as c_uint,\n+            )),\n+        );\n+        let vcall_visibility = llvm::LLVMValueAsMetadata(cx.const_u64(vcall_visibility as u64));\n+        let vcall_visibility_metadata = llvm::LLVMMDNodeInContext2(cx.llcx, &vcall_visibility, 1);\n+        llvm::LLVMGlobalSetMetadata(\n+            vtable,\n+            llvm::MetadataType::MD_vcall_visibility as c_uint,\n+            vcall_visibility_metadata,\n+        );\n+    }\n+}\n+\n /// Creates debug information for the given vtable, which is for the\n /// given type.\n ///\n@@ -1478,6 +1557,12 @@ pub fn create_vtable_di_node<'ll, 'tcx>(\n     poly_trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>,\n     vtable: &'ll Value,\n ) {\n+    // FIXME(flip1995): The virtual function elimination optimization only works with full LTO in\n+    // LLVM at the moment.\n+    if cx.sess().opts.debugging_opts.virtual_function_elimination && cx.sess().lto() == Lto::Fat {\n+        vcall_visibility_metadata(cx, ty, poly_trait_ref, vtable);\n+    }\n+\n     if cx.dbg_cx.is_none() {\n         return;\n     }"}, {"sha": "b831423994f240b9505700567c13e8dfa84a05e3", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e96e6e2c89265613e136369ccf314c408e1eb002/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e96e6e2c89265613e136369ccf314c408e1eb002/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=e96e6e2c89265613e136369ccf314c408e1eb002", "patch": "@@ -442,6 +442,7 @@ pub enum MetadataType {\n     MD_nonnull = 11,\n     MD_align = 17,\n     MD_type = 19,\n+    MD_vcall_visibility = 28,\n     MD_noundef = 29,\n }\n \n@@ -1067,6 +1068,7 @@ extern \"C\" {\n     pub fn LLVMReplaceAllUsesWith<'a>(OldVal: &'a Value, NewVal: &'a Value);\n     pub fn LLVMSetMetadata<'a>(Val: &'a Value, KindID: c_uint, Node: &'a Value);\n     pub fn LLVMGlobalSetMetadata<'a>(Val: &'a Value, KindID: c_uint, Metadata: &'a Metadata);\n+    pub fn LLVMRustGlobalAddMetadata<'a>(Val: &'a Value, KindID: c_uint, Metadata: &'a Metadata);\n     pub fn LLVMValueAsMetadata(Node: &Value) -> &Metadata;\n \n     // Operations on constants of any type\n@@ -1080,6 +1082,11 @@ extern \"C\" {\n         Vals: *const &'a Value,\n         Count: c_uint,\n     ) -> &'a Value;\n+    pub fn LLVMMDNodeInContext2<'a>(\n+        C: &'a Context,\n+        Vals: *const &'a Metadata,\n+        Count: size_t,\n+    ) -> &'a Metadata;\n     pub fn LLVMAddNamedMetadataOperand<'a>(M: &'a Module, Name: *const c_char, Val: &'a Value);\n \n     // Operations on scalar constants"}, {"sha": "a52d534024206e4c68c4912172965c4fa79a9282", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e96e6e2c89265613e136369ccf314c408e1eb002/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/e96e6e2c89265613e136369ccf314c408e1eb002/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=e96e6e2c89265613e136369ccf314c408e1eb002", "patch": "@@ -681,6 +681,11 @@ extern \"C\" LLVMValueRef LLVMRustMetadataAsValue(LLVMContextRef C, LLVMMetadataRe\n   return wrap(MetadataAsValue::get(*unwrap(C), unwrap(MD)));\n }\n \n+extern \"C\" void LLVMRustGlobalAddMetadata(\n+    LLVMValueRef Global, unsigned Kind, LLVMMetadataRef MD) {\n+  unwrap<GlobalObject>(Global)->addMetadata(Kind, *unwrap<MDNode>(MD));\n+}\n+\n extern \"C\" LLVMRustDIBuilderRef LLVMRustDIBuilderCreate(LLVMModuleRef M) {\n   return new DIBuilder(*unwrap(M));\n }"}]}