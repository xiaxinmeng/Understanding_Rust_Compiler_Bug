{"sha": "51ea0504578c00b6754b666032c19366a197a480", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxZWEwNTA0NTc4YzAwYjY3NTRiNjY2MDMyYzE5MzY2YTE5N2E0ODA=", "commit": {"author": {"name": "Tim Neumann", "email": "mail@timnn.me", "date": "2016-09-25T16:55:04Z"}, "committer": {"name": "Tim Neumann", "email": "mail@timnn.me", "date": "2016-09-26T04:59:06Z"}, "message": "reject macros with empty repetitions", "tree": {"sha": "6f6def132307adb4fa5616718b93b5c1354df444", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f6def132307adb4fa5616718b93b5c1354df444"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/51ea0504578c00b6754b666032c19366a197a480", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/51ea0504578c00b6754b666032c19366a197a480", "html_url": "https://github.com/rust-lang/rust/commit/51ea0504578c00b6754b666032c19366a197a480", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/51ea0504578c00b6754b666032c19366a197a480/comments", "author": {"login": "TimNN", "id": 1178249, "node_id": "MDQ6VXNlcjExNzgyNDk=", "avatar_url": "https://avatars.githubusercontent.com/u/1178249?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TimNN", "html_url": "https://github.com/TimNN", "followers_url": "https://api.github.com/users/TimNN/followers", "following_url": "https://api.github.com/users/TimNN/following{/other_user}", "gists_url": "https://api.github.com/users/TimNN/gists{/gist_id}", "starred_url": "https://api.github.com/users/TimNN/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TimNN/subscriptions", "organizations_url": "https://api.github.com/users/TimNN/orgs", "repos_url": "https://api.github.com/users/TimNN/repos", "events_url": "https://api.github.com/users/TimNN/events{/privacy}", "received_events_url": "https://api.github.com/users/TimNN/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TimNN", "id": 1178249, "node_id": "MDQ6VXNlcjExNzgyNDk=", "avatar_url": "https://avatars.githubusercontent.com/u/1178249?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TimNN", "html_url": "https://github.com/TimNN", "followers_url": "https://api.github.com/users/TimNN/followers", "following_url": "https://api.github.com/users/TimNN/following{/other_user}", "gists_url": "https://api.github.com/users/TimNN/gists{/gist_id}", "starred_url": "https://api.github.com/users/TimNN/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TimNN/subscriptions", "organizations_url": "https://api.github.com/users/TimNN/orgs", "repos_url": "https://api.github.com/users/TimNN/repos", "events_url": "https://api.github.com/users/TimNN/events{/privacy}", "received_events_url": "https://api.github.com/users/TimNN/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "95abee1a680f008fb97472294dd376a66e06d311", "url": "https://api.github.com/repos/rust-lang/rust/commits/95abee1a680f008fb97472294dd376a66e06d311", "html_url": "https://github.com/rust-lang/rust/commit/95abee1a680f008fb97472294dd376a66e06d311"}], "stats": {"total": 101, "additions": 100, "deletions": 1}, "files": [{"sha": "cb92f61ebaac648344da5af8c6887633a0b0b2c8", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/51ea0504578c00b6754b666032c19366a197a480/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51ea0504578c00b6754b666032c19366a197a480/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=51ea0504578c00b6754b666032c19366a197a480", "patch": "@@ -332,7 +332,7 @@ pub fn compile(sess: &ParseSess, def: &ast::MacroDef) -> SyntaxExtension {\n                     (**tt).clone()\n                 }\n                 _ => sess.span_diagnostic.span_bug(def.span, \"wrong-structured lhs\")\n-            }).collect()\n+            }).collect::<Vec<TokenTree>>()\n         }\n         _ => sess.span_diagnostic.span_bug(def.span, \"wrong-structured lhs\")\n     };\n@@ -351,6 +351,11 @@ pub fn compile(sess: &ParseSess, def: &ast::MacroDef) -> SyntaxExtension {\n         valid &= check_rhs(sess, rhs);\n     }\n \n+    // don't abort iteration early, so that errors for multiple lhses can be reported\n+    for lhs in &lhses {\n+        valid &= check_lhs_no_empty_seq(sess, &[lhs.clone()])\n+    }\n+\n     let exp: Box<_> = Box::new(MacroRulesMacroExpander {\n         name: def.ident,\n         imported_from: def.imported_from,\n@@ -377,6 +382,38 @@ fn check_lhs_nt_follows(sess: &ParseSess, lhs: &TokenTree) -> bool {\n     // after parsing/expansion. we can report every error in every macro this way.\n }\n \n+/// Check that the lhs contains no repetition which could match an empty token\n+/// tree, because then the matcher would hang indefinitely.\n+fn check_lhs_no_empty_seq(sess: &ParseSess, tts: &[TokenTree]) -> bool {\n+    for tt in tts {\n+        match *tt {\n+            TokenTree::Token(_, _) => (),\n+            TokenTree::Delimited(_, ref del) => if !check_lhs_no_empty_seq(sess, &del.tts) {\n+                return false;\n+            },\n+            TokenTree::Sequence(span, ref seq) => {\n+                if seq.separator.is_none() {\n+                    if seq.tts.iter().all(|seq_tt| {\n+                        match *seq_tt {\n+                            TokenTree::Sequence(_, ref sub_seq) =>\n+                                sub_seq.op == tokenstream::KleeneOp::ZeroOrMore,\n+                            _ => false,\n+                        }\n+                    }) {\n+                        sess.span_diagnostic.span_err(span, \"repetition matches empty token tree\");\n+                        return false;\n+                    }\n+                }\n+                if !check_lhs_no_empty_seq(sess, &seq.tts) {\n+                    return false;\n+                }\n+            }\n+        }\n+    }\n+\n+    true\n+}\n+\n fn check_rhs(sess: &ParseSess, rhs: &TokenTree) -> bool {\n     match *rhs {\n         TokenTree::Delimited(..) => return true,"}, {"sha": "b7b5553dc74e469c5f16ee287489156bb7c6de81", "filename": "src/test/compile-fail/issue-5067.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/51ea0504578c00b6754b666032c19366a197a480/src%2Ftest%2Fcompile-fail%2Fissue-5067.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51ea0504578c00b6754b666032c19366a197a480/src%2Ftest%2Fcompile-fail%2Fissue-5067.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5067.rs?ref=51ea0504578c00b6754b666032c19366a197a480", "patch": "@@ -0,0 +1,62 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+macro_rules! foo {\n+    ( $()* ) => {};\n+    //~^ ERROR repetition matches empty token tree\n+    ( $()+ ) => {};\n+    //~^ ERROR repetition matches empty token tree\n+\n+    ( $(),* ) => {}; // PASS\n+    ( $(),+ ) => {}; // PASS\n+\n+    ( [$()*] ) => {};\n+    //~^ ERROR repetition matches empty token tree\n+    ( [$()+] ) => {};\n+    //~^ ERROR repetition matches empty token tree\n+\n+    ( [$(),*] ) => {}; // PASS\n+    ( [$(),+] ) => {}; // PASS\n+\n+    ( $($()* $(),* $(a)* $(a),* )* ) => {};\n+    //~^ ERROR repetition matches empty token tree\n+    ( $($()* $(),* $(a)* $(a),* )+ ) => {};\n+    //~^ ERROR repetition matches empty token tree\n+\n+    ( $(a     $(),* $(a)* $(a),* )* ) => {}; // PASS\n+    ( $($(a)+ $(),* $(a)* $(a),* )+ ) => {}; // PASS\n+\n+    ( $(a $()+)* ) => {};\n+    //~^ ERROR repetition matches empty token tree\n+    ( $(a $()*)+ ) => {};\n+    //~^ ERROR repetition matches empty token tree\n+}\n+\n+\n+// --- Original Issue --- //\n+\n+macro_rules! make_vec {\n+    (a $e1:expr $($(, a $e2:expr)*)*) => ([$e1 $($(, $e2)*)*]);\n+    //~^ ERROR repetition matches empty token tree\n+}\n+\n+fn main() {\n+    let _ = make_vec!(a 1, a 2, a 3);\n+}\n+\n+\n+// --- Minified Issue --- //\n+\n+macro_rules! m {\n+    ( $()* ) => {}\n+    //~^ ERROR repetition matches empty token tree\n+}\n+\n+m!();"}]}