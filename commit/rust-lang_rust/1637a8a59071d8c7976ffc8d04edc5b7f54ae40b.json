{"sha": "1637a8a59071d8c7976ffc8d04edc5b7f54ae40b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2MzdhOGE1OTA3MWQ4Yzc5NzZmZmM4ZDA0ZWRjNWI3ZjU0YWU0MGI=", "commit": {"author": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2019-11-11T06:14:39Z"}, "committer": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2019-11-11T06:14:39Z"}, "message": "Add quote macro", "tree": {"sha": "8f1cf805126f644c5c5104076a0337366aa4a559", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f1cf805126f644c5c5104076a0337366aa4a559"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1637a8a59071d8c7976ffc8d04edc5b7f54ae40b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1637a8a59071d8c7976ffc8d04edc5b7f54ae40b", "html_url": "https://github.com/rust-lang/rust/commit/1637a8a59071d8c7976ffc8d04edc5b7f54ae40b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1637a8a59071d8c7976ffc8d04edc5b7f54ae40b/comments", "author": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c46768d13dd34bbe878cc62eca4af873ffbb7c22", "url": "https://api.github.com/repos/rust-lang/rust/commits/c46768d13dd34bbe878cc62eca4af873ffbb7c22", "html_url": "https://github.com/rust-lang/rust/commit/c46768d13dd34bbe878cc62eca4af873ffbb7c22"}], "stats": {"total": 262, "additions": 262, "deletions": 0}, "files": [{"sha": "21d666f1315110ae2ba8e6c325007f01cbd244d3", "filename": "crates/ra_hir_expand/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1637a8a59071d8c7976ffc8d04edc5b7f54ae40b/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1637a8a59071d8c7976ffc8d04edc5b7f54ae40b/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Flib.rs?ref=1637a8a59071d8c7976ffc8d04edc5b7f54ae40b", "patch": "@@ -11,6 +11,7 @@ pub mod name;\n pub mod hygiene;\n pub mod diagnostics;\n pub mod builtin_macro;\n+pub mod quote;\n \n use std::hash::{Hash, Hasher};\n use std::sync::Arc;"}, {"sha": "9cd17f0e35453d83c9933da7673b3eb311dc5739", "filename": "crates/ra_hir_expand/src/quote.rs", "status": "added", "additions": 261, "deletions": 0, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/1637a8a59071d8c7976ffc8d04edc5b7f54ae40b/crates%2Fra_hir_expand%2Fsrc%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1637a8a59071d8c7976ffc8d04edc5b7f54ae40b/crates%2Fra_hir_expand%2Fsrc%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fquote.rs?ref=1637a8a59071d8c7976ffc8d04edc5b7f54ae40b", "patch": "@@ -0,0 +1,261 @@\n+//! A simplified version of quote-crate like quasi quote macro\n+\n+// A helper macro quote macro\n+// FIXME:\n+// 1. Not all puncts are handled\n+// 2. #()* pattern repetition not supported now\n+//    * But we can do it manually, see `test_quote_derive_copy_hack`\n+#[doc(hidden)]\n+#[macro_export]\n+macro_rules! __quote {\n+    () => {\n+        Vec::<tt::TokenTree>::new()\n+    };\n+\n+    ( @SUBTREE $delim:ident $($tt:tt)* ) => {\n+        {\n+            let children = $crate::__quote!($($tt)*);\n+            let subtree = tt::Subtree {\n+                delimiter: tt::Delimiter::$delim,\n+                token_trees: $crate::quote::IntoTt::to_tokens(children),\n+            };\n+            subtree\n+        }\n+    };\n+\n+    ( @PUNCT $first:literal ) => {\n+        {\n+            vec![\n+                tt::Leaf::Punct(tt::Punct {\n+                    char: $first,\n+                    spacing: tt::Spacing::Alone,\n+                }).into()\n+            ]\n+        }\n+    };\n+\n+    ( @PUNCT $first:literal, $sec:literal ) => {\n+        {\n+            vec![\n+                tt::Leaf::Punct(tt::Punct {\n+                    char: $first,\n+                    spacing: tt::Spacing::Joint,\n+                }).into(),\n+                tt::Leaf::Punct(tt::Punct {\n+                    char: $sec,\n+                    spacing: tt::Spacing::Alone,\n+                }).into()\n+            ]\n+        }\n+    };\n+\n+    // hash variable\n+    ( # $first:ident $($tail:tt)* ) => {\n+        {\n+            let token = $crate::quote::ToTokenTree::to_token($first);\n+            let mut tokens = vec![token.into()];\n+            let mut tail_tokens = $crate::quote::IntoTt::to_tokens($crate::__quote!($($tail)*));\n+            tokens.append(&mut tail_tokens);\n+            tokens\n+        }\n+    };\n+\n+    // Brace\n+    ( { $($tt:tt)* } ) => { $crate::__quote!(@SUBTREE Brace $($tt)*) };\n+    // Bracket\n+    ( [ $($tt:tt)* ] ) => { $crate::__quote!(@SUBTREE Bracket $($tt)*) };\n+    // Parenthesis\n+    ( ( $($tt:tt)* ) ) => { $crate::__quote!(@SUBTREE Parenthesis $($tt)*) };\n+\n+    // Literal\n+    ( $tt:literal ) => { vec![$crate::quote::ToTokenTree::to_token($tt).into()] };\n+    // Ident\n+    ( $tt:ident ) => {\n+        vec![ {\n+            tt::Leaf::Ident(tt::Ident {\n+                text: stringify!($tt).into(),\n+                id: tt::TokenId::unspecified(),\n+            }).into()\n+        }]\n+    };\n+\n+    // Puncts\n+    // FIXME: Not all puncts are handled\n+    ( -> ) => {$crate::__quote!(@PUNCT '-', '>')};\n+    ( & ) => {$crate::__quote!(@PUNCT '&')};\n+    ( , ) => {$crate::__quote!(@PUNCT ',')};\n+    ( : ) => {$crate::__quote!(@PUNCT ':')};\n+    ( . ) => {$crate::__quote!(@PUNCT '.')};\n+\n+    ( $first:tt $($tail:tt)+ ) => {\n+        {\n+            let mut tokens = $crate::quote::IntoTt::to_tokens($crate::__quote!($first));\n+            let mut tail_tokens = $crate::quote::IntoTt::to_tokens($crate::__quote!($($tail)*));\n+\n+            tokens.append(&mut tail_tokens);\n+            tokens\n+        }\n+    };\n+}\n+\n+/// FIXME:\n+/// It probably should implement in proc-macro\n+#[macro_export]\n+macro_rules! quote {\n+    ( $($tt:tt)* ) => {\n+        $crate::quote::IntoTt::to_subtree($crate::__quote!($($tt)*))\n+    }\n+}\n+\n+pub(crate) trait IntoTt {\n+    fn to_subtree(self) -> tt::Subtree;\n+    fn to_tokens(self) -> Vec<tt::TokenTree>;\n+}\n+\n+impl IntoTt for Vec<tt::TokenTree> {\n+    fn to_subtree(self) -> tt::Subtree {\n+        tt::Subtree { delimiter: tt::Delimiter::None, token_trees: self }\n+    }\n+\n+    fn to_tokens(self) -> Vec<tt::TokenTree> {\n+        self\n+    }\n+}\n+\n+impl IntoTt for tt::Subtree {\n+    fn to_subtree(self) -> tt::Subtree {\n+        self\n+    }\n+\n+    fn to_tokens(self) -> Vec<tt::TokenTree> {\n+        vec![tt::TokenTree::Subtree(self)]\n+    }\n+}\n+\n+pub(crate) trait ToTokenTree {\n+    fn to_token(self) -> tt::TokenTree;\n+}\n+\n+impl ToTokenTree for tt::TokenTree {\n+    fn to_token(self) -> tt::TokenTree {\n+        self\n+    }\n+}\n+\n+impl ToTokenTree for tt::Subtree {\n+    fn to_token(self) -> tt::TokenTree {\n+        self.into()\n+    }\n+}\n+\n+macro_rules! impl_to_to_tokentrees {\n+    ($($ty:ty => $this:ident $im:block);*) => {\n+        $(\n+            impl ToTokenTree for $ty {\n+                fn to_token($this) -> tt::TokenTree {\n+                    let leaf: tt::Leaf = $im.into();\n+                    leaf.into()\n+                }\n+            }\n+\n+            impl ToTokenTree for &$ty {\n+                fn to_token($this) -> tt::TokenTree {\n+                    let leaf: tt::Leaf = $im.clone().into();\n+                    leaf.into()\n+                }\n+            }\n+        )*\n+    }\n+}\n+\n+impl_to_to_tokentrees! {\n+    u32 => self { tt::Literal{text: self.to_string().into()} };\n+    usize => self { tt::Literal{text: self.to_string().into()}};\n+    i32 => self { tt::Literal{text: self.to_string().into()}};\n+    &str => self { tt::Literal{text: self.to_string().into()}};\n+    String => self { tt::Literal{text: self.into()}};\n+    tt::Leaf => self { self };\n+    tt::Literal => self { self };\n+    tt::Ident => self { self };\n+    tt::Punct => self { self }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    #[test]\n+    fn test_quote_delimiters() {\n+        assert_eq!(quote!({}).to_string(), \"{}\");\n+        assert_eq!(quote!(()).to_string(), \"()\");\n+        assert_eq!(quote!([]).to_string(), \"[]\");\n+    }\n+\n+    #[test]\n+    fn test_quote_idents() {\n+        assert_eq!(quote!(32).to_string(), \"32\");\n+        assert_eq!(quote!(struct).to_string(), \"struct\");\n+    }\n+\n+    #[test]\n+    fn test_quote_hash_simple_literal() {\n+        let a = 20;\n+        assert_eq!(quote!(#a).to_string(), \"20\");\n+        let s: String = \"hello\".into();\n+        assert_eq!(quote!(#s).to_string(), \"hello\");\n+    }\n+\n+    fn mk_ident(name: &str) -> tt::Ident {\n+        tt::Ident { text: name.into(), id: tt::TokenId::unspecified() }\n+    }\n+\n+    #[test]\n+    fn test_quote_hash_token_tree() {\n+        let a = mk_ident(\"hello\");\n+\n+        let quoted = quote!(#a);\n+        assert_eq!(quoted.to_string(), \"hello\");\n+        let t = format!(\"{:?}\", quoted);\n+        assert_eq!(t, \"Subtree { delimiter: None, token_trees: [Leaf(Ident(Ident { text: \\\"hello\\\", id: TokenId(4294967295) }))] }\");\n+    }\n+\n+    #[test]\n+    fn test_quote_simple_derive_copy() {\n+        let name = mk_ident(\"Foo\");\n+\n+        let quoted = quote! {\n+            impl Clone for #name {\n+                fn clone(&self) -> Self {\n+                    Self {}\n+                }\n+            }\n+        };\n+\n+        assert_eq!(quoted.to_string(), \"impl Clone for Foo {fn clone (& self) -> Self {Self {}}}\");\n+    }\n+\n+    #[test]\n+    fn test_quote_derive_copy_hack() {\n+        // Assume the given struct is:\n+        // struct Foo {\n+        //  name: String,\n+        //  id: u32,\n+        // }\n+        let struct_name = mk_ident(\"Foo\");\n+        let fields = [mk_ident(\"name\"), mk_ident(\"id\")];\n+        let fields = fields\n+            .into_iter()\n+            .map(|it| quote!(#it: self.#it.clone(), ).token_trees.clone())\n+            .flatten();\n+\n+        let list = tt::Subtree { delimiter: tt::Delimiter::Brace, token_trees: fields.collect() };\n+\n+        let quoted = quote! {\n+            impl Clone for #struct_name {\n+                fn clone(&self) -> Self {\n+                    Self #list\n+                }\n+            }\n+        };\n+\n+        assert_eq!(quoted.to_string(), \"impl Clone for Foo {fn clone (& self) -> Self {Self {name : self . name . clone () , id : self . id . clone () ,}}}\");\n+    }\n+}"}]}