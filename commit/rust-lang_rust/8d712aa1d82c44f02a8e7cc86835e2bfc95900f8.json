{"sha": "8d712aa1d82c44f02a8e7cc86835e2bfc95900f8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkNzEyYWExZDgyYzQ0ZjAyYThlN2NjODY4MzVlMmJmYzk1OTAwZjg=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-10-19T03:03:32Z"}, "committer": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-10-19T08:47:46Z"}, "message": "Rollup merge of #55144 - ljedrz:cleanup_resolve, r=petrochenkov\n\nCleanup resolve\n\n- improve/remove allocations\n- `truncate` instead of `pop`ping in a loop\n- improve common patterns", "tree": {"sha": "1f3bf88ccc8774367ba400601c79371df87952e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f3bf88ccc8774367ba400601c79371df87952e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d712aa1d82c44f02a8e7cc86835e2bfc95900f8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZ1R8CLMp8f2GxWoQ/vbIBR0OATwFAlvJmjIACgkQ/vbIBR0O\nATyNJhAApI8n8UKdCEcgeUVJmDh2g3+e4SgivVmJdcQ7spXKiA964NArvAQbRC4I\nv8jhhvWoPfK2eRvYchGCvoR3FmwQ61F0IQegu5C2J4vk70GTd3oCq+3x/RSVntZI\nmw4l76hAolBkp81knRBlKehU4gz/J6dKR4KNKMOv2kRNCblLgdhqPaz6DKgJFFzI\ny+eIBXmlEeXY79WYA+uZOaIljzGVHvok03e6bN4ZJf4H/mmWtKm38lIlwolRDS1i\nifjeEsnl+zuDJ7aojUFegRdKOpzQ+q8yE569CjWpiODeJSqekZR/sq6ZxxA+h45i\nZUClsOgq6eQpMnMUFMNIfA5BTpKy2rHDIaJsUAM8UJI7PBH8C/kx8kn0BeB7JpOj\npT527TlwI4fjbA9RrOKbtCFXSwiBvslZRUk/LD1MTeTdzAFnzdi/uQNkmGh/4n58\nUvhwdap4FFOusJfUHLrS21RBC7YlT8ynMz6rgXRsTRyNEHn1aieQxRaAkhzlWNCE\nIf6DFmO3Sg3Db4jK0kxp/PNH7r4dTEs9DXxI5D987hrRrQ4te6cKP/9ue5Xw6V8q\nrOs+BPQ5Jomn4lfyHsnsHT0RMpqZQR/uP9bm5gRx2xLFQrCVjQXL3Hf7HBAvQ79V\nN7T2JPHUzuu2CnrfbPPLYHlD/6icOQ5G79G54wvJ4v6GXE1IhKE=\n=F/8e\n-----END PGP SIGNATURE-----", "payload": "tree 1f3bf88ccc8774367ba400601c79371df87952e2\nparent 89ebc6ce4f7bcec8e0cdffe95bf8a92bbdfe04e5\nparent 89c20b78d68345040d68f0b475276687d10fdc92\nauthor kennytm <kennytm@gmail.com> 1539918212 +0800\ncommitter kennytm <kennytm@gmail.com> 1539938866 +0800\n\nRollup merge of #55144 - ljedrz:cleanup_resolve, r=petrochenkov\n\nCleanup resolve\n\n- improve/remove allocations\n- `truncate` instead of `pop`ping in a loop\n- improve common patterns\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d712aa1d82c44f02a8e7cc86835e2bfc95900f8", "html_url": "https://github.com/rust-lang/rust/commit/8d712aa1d82c44f02a8e7cc86835e2bfc95900f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d712aa1d82c44f02a8e7cc86835e2bfc95900f8/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89ebc6ce4f7bcec8e0cdffe95bf8a92bbdfe04e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/89ebc6ce4f7bcec8e0cdffe95bf8a92bbdfe04e5", "html_url": "https://github.com/rust-lang/rust/commit/89ebc6ce4f7bcec8e0cdffe95bf8a92bbdfe04e5"}, {"sha": "89c20b78d68345040d68f0b475276687d10fdc92", "url": "https://api.github.com/repos/rust-lang/rust/commits/89c20b78d68345040d68f0b475276687d10fdc92", "html_url": "https://github.com/rust-lang/rust/commit/89c20b78d68345040d68f0b475276687d10fdc92"}], "stats": {"total": 259, "additions": 116, "deletions": 143}, "files": [{"sha": "e2f5829d14ff7ae3cab5698fdd7d8ede62a745b3", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8d712aa1d82c44f02a8e7cc86835e2bfc95900f8/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d712aa1d82c44f02a8e7cc86835e2bfc95900f8/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=8d712aa1d82c44f02a8e7cc86835e2bfc95900f8", "patch": "@@ -139,7 +139,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n         let prefix_iter = || parent_prefix.iter().cloned()\n             .chain(use_tree.prefix.segments.iter().map(|seg| seg.ident));\n-        let prefix_start = prefix_iter().nth(0);\n+        let prefix_start = prefix_iter().next();\n         let starts_with_non_keyword = prefix_start.map_or(false, |ident| {\n             !ident.is_path_segment_keyword()\n         });\n@@ -1048,13 +1048,10 @@ impl<'a, 'b, 'cl> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b, 'cl> {\n \n     fn visit_token(&mut self, t: Token) {\n         if let Token::Interpolated(nt) = t {\n-            match nt.0 {\n-                token::NtExpr(ref expr) => {\n-                    if let ast::ExprKind::Mac(..) = expr.node {\n-                        self.visit_invoc(expr.id);\n-                    }\n+            if let token::NtExpr(ref expr) = nt.0 {\n+                if let ast::ExprKind::Mac(..) = expr.node {\n+                    self.visit_invoc(expr.id);\n                 }\n-                _ => {}\n             }\n         }\n     }"}, {"sha": "6f3135b37cf05746dd3e9d5b903d3972f1a10ae7", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8d712aa1d82c44f02a8e7cc86835e2bfc95900f8/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d712aa1d82c44f02a8e7cc86835e2bfc95900f8/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=8d712aa1d82c44f02a8e7cc86835e2bfc95900f8", "patch": "@@ -109,7 +109,7 @@ impl<'a, 'b, 'cl> Visitor<'a> for UnusedImportCheckVisitor<'a, 'b, 'cl> {\n                 self.item_span\n             };\n \n-            if items.len() == 0 {\n+            if items.is_empty() {\n                 self.unused_imports\n                     .entry(self.base_id)\n                     .or_default()\n@@ -170,7 +170,7 @@ pub fn check_crate(resolver: &mut Resolver, krate: &ast::Crate) {\n \n     for (id, spans) in &visitor.unused_imports {\n         let len = spans.len();\n-        let mut spans = spans.values().map(|s| *s).collect::<Vec<Span>>();\n+        let mut spans = spans.values().cloned().collect::<Vec<Span>>();\n         spans.sort();\n         let ms = MultiSpan::from_spans(spans.clone());\n         let mut span_snippets = spans.iter()\n@@ -183,7 +183,7 @@ pub fn check_crate(resolver: &mut Resolver, krate: &ast::Crate) {\n         span_snippets.sort();\n         let msg = format!(\"unused import{}{}\",\n                           if len > 1 { \"s\" } else { \"\" },\n-                          if span_snippets.len() > 0 {\n+                          if !span_snippets.is_empty() {\n                               format!(\": {}\", span_snippets.join(\", \"))\n                           } else {\n                               String::new()"}, {"sha": "bf3fbdc2c5ad5740fd26b52d371843f67f0edd05", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 33, "deletions": 50, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/8d712aa1d82c44f02a8e7cc86835e2bfc95900f8/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d712aa1d82c44f02a8e7cc86835e2bfc95900f8/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=8d712aa1d82c44f02a8e7cc86835e2bfc95900f8", "patch": "@@ -1633,19 +1633,17 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n                 *def = module.def().unwrap(),\n             PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 =>\n                 *def = path_res.base_def(),\n-            PathResult::NonModule(..) => match self.resolve_path(\n-                None,\n-                &path,\n-                None,\n-                true,\n-                span,\n-                CrateLint::No,\n-            ) {\n-                PathResult::Failed(span, msg, _) => {\n+            PathResult::NonModule(..) =>\n+                if let PathResult::Failed(span, msg, _) = self.resolve_path(\n+                    None,\n+                    &path,\n+                    None,\n+                    true,\n+                    span,\n+                    CrateLint::No,\n+                ) {\n                     error_callback(self, span, ResolutionError::FailedToResolve(&msg));\n-                }\n-                _ => {}\n-            },\n+                },\n             PathResult::Module(ModuleOrUniformRoot::UniformRoot(_)) |\n             PathResult::Indeterminate => unreachable!(),\n             PathResult::Failed(span, msg, _) => {\n@@ -2357,7 +2355,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                     span: prefix.span.to(use_tree.prefix.span),\n                 };\n \n-                if items.len() == 0 {\n+                if items.is_empty() {\n                     // Resolve prefix of an import with empty braces (issue #28388).\n                     self.smart_resolve_path_with_crate_lint(\n                         id,\n@@ -2696,7 +2694,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n \n                 let map_j = self.binding_mode_map(&q);\n                 for (&key, &binding_i) in &map_i {\n-                    if map_j.len() == 0 {                   // Account for missing bindings when\n+                    if map_j.is_empty() {                   // Account for missing bindings when\n                         let binding_error = missing_vars    // map_j has none.\n                             .entry(key.name)\n                             .or_insert(BindingError {\n@@ -2757,9 +2755,8 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         // This has to happen *after* we determine which pat_idents are variants\n         self.check_consistent_bindings(&arm.pats);\n \n-        match arm.guard {\n-            Some(ast::Guard::If(ref expr)) => self.visit_expr(expr),\n-            _ => {}\n+        if let Some(ast::Guard::If(ref expr)) = arm.guard {\n+            self.visit_expr(expr)\n         }\n         self.visit_expr(&arm.body);\n \n@@ -3000,14 +2997,14 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             // Make the base error.\n             let expected = source.descr_expected();\n             let path_str = names_to_string(path);\n-            let item_str = path[path.len() - 1];\n+            let item_str = path.last().unwrap();\n             let code = source.error_code(def.is_some());\n             let (base_msg, fallback_label, base_span) = if let Some(def) = def {\n                 (format!(\"expected {}, found {} `{}`\", expected, def.kind_name(), path_str),\n                  format!(\"not a {}\", expected),\n                  span)\n             } else {\n-                let item_span = path[path.len() - 1].span;\n+                let item_span = path.last().unwrap().span;\n                 let (mod_prefix, mod_str) = if path.len() == 1 {\n                     (String::new(), \"this scope\".to_string())\n                 } else if path.len() == 2 && path[0].name == keywords::CrateRoot.name() {\n@@ -3030,10 +3027,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             let mut err = this.session.struct_span_err_with_code(base_span, &base_msg, code);\n \n             // Emit help message for fake-self from other languages like `this`(javascript)\n-            let fake_self: Vec<Ident> = [\"this\", \"my\"].iter().map(\n-                |s| Ident::from_str(*s)\n-            ).collect();\n-            if fake_self.contains(&item_str)\n+            if [\"this\", \"my\"].contains(&&*item_str.as_str())\n                 && this.self_value_is_available(path[0].span, span) {\n                 err.span_suggestion_with_applicability(\n                     span,\n@@ -3374,7 +3368,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                             );\n                         }\n                         break;\n-                    } else if snippet.trim().len() != 0  {\n+                    } else if !snippet.trim().is_empty() {\n                         debug!(\"tried to find type ascription `:` token, couldn't find it\");\n                         break;\n                     }\n@@ -3936,7 +3930,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             }\n             _ => {}\n         }\n-        return def;\n+        def\n     }\n \n     fn lookup_assoc_candidate<FilterFn>(&mut self,\n@@ -4386,10 +4380,9 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         where FilterFn: Fn(Def) -> bool\n     {\n         let mut candidates = Vec::new();\n-        let mut worklist = Vec::new();\n         let mut seen_modules = FxHashSet();\n         let not_local_module = crate_name != keywords::Crate.ident();\n-        worklist.push((start_module, Vec::<ast::PathSegment>::new(), not_local_module));\n+        let mut worklist = vec![(start_module, Vec::<ast::PathSegment>::new(), not_local_module)];\n \n         while let Some((in_module,\n                         path_segments,\n@@ -4476,33 +4469,24 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                                           -> Vec<ImportSuggestion>\n         where FilterFn: Fn(Def) -> bool\n     {\n-        let mut suggestions = vec![];\n-\n-        suggestions.extend(\n-            self.lookup_import_candidates_from_module(\n-                lookup_name, namespace, self.graph_root, keywords::Crate.ident(), &filter_fn\n-            )\n-        );\n+        let mut suggestions = self.lookup_import_candidates_from_module(\n+            lookup_name, namespace, self.graph_root, keywords::Crate.ident(), &filter_fn);\n \n         if self.session.rust_2018() {\n             let extern_prelude_names = self.extern_prelude.clone();\n             for &name in extern_prelude_names.iter() {\n                 let ident = Ident::with_empty_ctxt(name);\n-                match self.crate_loader.maybe_process_path_extern(name, ident.span) {\n-                    Some(crate_id) => {\n-                        let crate_root = self.get_module(DefId {\n-                            krate: crate_id,\n-                            index: CRATE_DEF_INDEX,\n-                        });\n-                        self.populate_module_if_necessary(&crate_root);\n+                if let Some(crate_id) = self.crate_loader.maybe_process_path_extern(name,\n+                                                                                    ident.span)\n+                {\n+                    let crate_root = self.get_module(DefId {\n+                        krate: crate_id,\n+                        index: CRATE_DEF_INDEX,\n+                    });\n+                    self.populate_module_if_necessary(&crate_root);\n \n-                        suggestions.extend(\n-                            self.lookup_import_candidates_from_module(\n-                                lookup_name, namespace, crate_root, ident, &filter_fn\n-                            )\n-                        );\n-                    }\n-                    None => {}\n+                    suggestions.extend(self.lookup_import_candidates_from_module(\n+                        lookup_name, namespace, crate_root, ident, &filter_fn));\n                 }\n             }\n         }\n@@ -4515,9 +4499,8 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                    -> Option<(Module<'a>, ImportSuggestion)>\n     {\n         let mut result = None;\n-        let mut worklist = Vec::new();\n         let mut seen_modules = FxHashSet();\n-        worklist.push((self.graph_root, Vec::new()));\n+        let mut worklist = vec![(self.graph_root, Vec::new())];\n \n         while let Some((in_module, path_segments)) = worklist.pop() {\n             // abort if the module is already found"}, {"sha": "28284a45bcdd5f03098cf665c25e79013840cb28", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8d712aa1d82c44f02a8e7cc86835e2bfc95900f8/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d712aa1d82c44f02a8e7cc86835e2bfc95900f8/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=8d712aa1d82c44f02a8e7cc86835e2bfc95900f8", "patch": "@@ -203,9 +203,7 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n         self.current_module = invocation.module.get();\n         self.current_module.unresolved_invocations.borrow_mut().remove(&mark);\n         self.current_module.unresolved_invocations.borrow_mut().extend(derives);\n-        for &derive in derives {\n-            self.invocations.insert(derive, invocation);\n-        }\n+        self.invocations.extend(derives.iter().map(|&derive| (derive, invocation)));\n         let mut visitor = BuildReducedGraphVisitor {\n             resolver: self,\n             current_legacy_scope: invocation.parent_legacy_scope.get(),\n@@ -277,11 +275,12 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n                     if traits.is_empty() {\n                         attrs.remove(i);\n                     } else {\n-                        let mut tokens = Vec::new();\n+                        let mut tokens = Vec::with_capacity(traits.len() - 1);\n                         for (j, path) in traits.iter().enumerate() {\n                             if j > 0 {\n                                 tokens.push(TokenTree::Token(attrs[i].span, Token::Comma).into());\n                             }\n+                            tokens.reserve((path.segments.len() * 2).saturating_sub(1));\n                             for (k, segment) in path.segments.iter().enumerate() {\n                                 if k > 0 {\n                                     tokens.push(TokenTree::Token(path.span, Token::ModSep).into());"}, {"sha": "d5d772e13591475cb6293b496241755a697cb073", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 73, "deletions": 79, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/8d712aa1d82c44f02a8e7cc86835e2bfc95900f8/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d712aa1d82c44f02a8e7cc86835e2bfc95900f8/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=8d712aa1d82c44f02a8e7cc86835e2bfc95900f8", "patch": "@@ -672,7 +672,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                 };\n \n                 let has_explicit_self =\n-                    import.module_path.len() > 0 &&\n+                    !import.module_path.is_empty() &&\n                     import.module_path[0].name == keywords::SelfValue.name();\n \n                 self.per_ns(|_, ns| {\n@@ -703,9 +703,8 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                 if let SingleImport { source, ref result, .. } = import.subclass {\n                     if source.name == \"self\" {\n                         // Silence `unresolved import` error if E0429 is already emitted\n-                        match result.value_ns.get() {\n-                            Err(Determined) => continue,\n-                            _ => {},\n+                        if let Err(Determined) = result.value_ns.get() {\n+                            continue;\n                         }\n                     }\n                 }\n@@ -822,20 +821,19 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n     fn throw_unresolved_import_error(&self, error_vec: Vec<(Span, String, String)>,\n                                      span: Option<MultiSpan>) {\n         let max_span_label_msg_count = 10;  // upper limit on number of span_label message.\n-        let (span,msg) = match error_vec.is_empty() {\n-            true => (span.unwrap(), \"unresolved import\".to_string()),\n-            false => {\n-                let span = MultiSpan::from_spans(error_vec.clone().into_iter()\n-                                    .map(|elem: (Span, String, String)| { elem.0 }\n-                                    ).collect());\n-                let path_vec: Vec<String> = error_vec.clone().into_iter()\n-                                .map(|elem: (Span, String, String)| { format!(\"`{}`\", elem.1) }\n-                                ).collect();\n-                let path = path_vec.join(\", \");\n-                let msg = format!(\"unresolved import{} {}\",\n-                                if path_vec.len() > 1 { \"s\" } else { \"\" },  path);\n-                (span, msg)\n-            }\n+        let (span, msg) = if error_vec.is_empty() {\n+            (span.unwrap(), \"unresolved import\".to_string())\n+        } else {\n+            let span = MultiSpan::from_spans(error_vec.clone().into_iter()\n+                .map(|elem: (Span, String, String)| { elem.0 })\n+                .collect());\n+            let path_vec: Vec<String> = error_vec.clone().into_iter()\n+                .map(|elem: (Span, String, String)| { format!(\"`{}`\", elem.1) })\n+                .collect();\n+            let path = path_vec.join(\", \");\n+            let msg = format!(\"unresolved import{} {}\",\n+                if path_vec.len() > 1 { \"s\" } else { \"\" }, path);\n+            (span, msg)\n         };\n         let mut err = struct_span_err!(self.resolver.session, span, E0432, \"{}\", &msg);\n         for span_error in error_vec.into_iter().take(max_span_label_msg_count) {\n@@ -1026,9 +1024,8 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n         if all_ns_err {\n             let mut all_ns_failed = true;\n             self.per_ns(|this, ns| if !type_ns_only || ns == TypeNS {\n-                match this.resolve_ident_in_module(module, ident, ns, record_used, span) {\n-                    Ok(_) => all_ns_failed = false,\n-                    _ => {}\n+                if this.resolve_ident_in_module(module, ident, ns, record_used, span).is_ok() {\n+                    all_ns_failed = false;\n                 }\n             });\n \n@@ -1247,65 +1244,62 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                 }\n             }\n \n-            match binding.kind {\n-                NameBindingKind::Import { binding: orig_binding, directive, .. } => {\n-                    if ns == TypeNS && orig_binding.is_variant() &&\n-                        !orig_binding.vis.is_at_least(binding.vis, &*self) {\n-                            let msg = match directive.subclass {\n-                                ImportDirectiveSubclass::SingleImport { .. } => {\n-                                    format!(\"variant `{}` is private and cannot be re-exported\",\n-                                            ident)\n-                                },\n-                                ImportDirectiveSubclass::GlobImport { .. } => {\n-                                    let msg = \"enum is private and its variants \\\n-                                               cannot be re-exported\".to_owned();\n-                                    let error_id = (DiagnosticMessageId::ErrorId(0), // no code?!\n-                                                    Some(binding.span),\n-                                                    msg.clone());\n-                                    let fresh = self.session.one_time_diagnostics\n-                                        .borrow_mut().insert(error_id);\n-                                    if !fresh {\n-                                        continue;\n-                                    }\n-                                    msg\n-                                },\n-                                ref s @ _ => bug!(\"unexpected import subclass {:?}\", s)\n-                            };\n-                            let mut err = self.session.struct_span_err(binding.span, &msg);\n-\n-                            let imported_module = match directive.imported_module.get() {\n-                                Some(ModuleOrUniformRoot::Module(module)) => module,\n-                                _ => bug!(\"module should exist\"),\n-                            };\n-                            let resolutions = imported_module.parent.expect(\"parent should exist\")\n-                                .resolutions.borrow();\n-                            let enum_path_segment_index = directive.module_path.len() - 1;\n-                            let enum_ident = directive.module_path[enum_path_segment_index];\n-\n-                            let enum_resolution = resolutions.get(&(enum_ident, TypeNS))\n-                                .expect(\"resolution should exist\");\n-                            let enum_span = enum_resolution.borrow()\n-                                .binding.expect(\"binding should exist\")\n-                                .span;\n-                            let enum_def_span = self.session.source_map().def_span(enum_span);\n-                            let enum_def_snippet = self.session.source_map()\n-                                .span_to_snippet(enum_def_span).expect(\"snippet should exist\");\n-                            // potentially need to strip extant `crate`/`pub(path)` for suggestion\n-                            let after_vis_index = enum_def_snippet.find(\"enum\")\n-                                .expect(\"`enum` keyword should exist in snippet\");\n-                            let suggestion = format!(\"pub {}\",\n-                                                     &enum_def_snippet[after_vis_index..]);\n-\n-                            self.session\n-                                .diag_span_suggestion_once(&mut err,\n-                                                           DiagnosticMessageId::ErrorId(0),\n-                                                           enum_def_span,\n-                                                           \"consider making the enum public\",\n-                                                           suggestion);\n-                            err.emit();\n-                    }\n+            if let NameBindingKind::Import { binding: orig_binding, directive, .. } = binding.kind {\n+                if ns == TypeNS && orig_binding.is_variant() &&\n+                    !orig_binding.vis.is_at_least(binding.vis, &*self) {\n+                        let msg = match directive.subclass {\n+                            ImportDirectiveSubclass::SingleImport { .. } => {\n+                                format!(\"variant `{}` is private and cannot be re-exported\",\n+                                        ident)\n+                            },\n+                            ImportDirectiveSubclass::GlobImport { .. } => {\n+                                let msg = \"enum is private and its variants \\\n+                                           cannot be re-exported\".to_owned();\n+                                let error_id = (DiagnosticMessageId::ErrorId(0), // no code?!\n+                                                Some(binding.span),\n+                                                msg.clone());\n+                                let fresh = self.session.one_time_diagnostics\n+                                    .borrow_mut().insert(error_id);\n+                                if !fresh {\n+                                    continue;\n+                                }\n+                                msg\n+                            },\n+                            ref s @ _ => bug!(\"unexpected import subclass {:?}\", s)\n+                        };\n+                        let mut err = self.session.struct_span_err(binding.span, &msg);\n+\n+                        let imported_module = match directive.imported_module.get() {\n+                            Some(ModuleOrUniformRoot::Module(module)) => module,\n+                            _ => bug!(\"module should exist\"),\n+                        };\n+                        let resolutions = imported_module.parent.expect(\"parent should exist\")\n+                            .resolutions.borrow();\n+                        let enum_path_segment_index = directive.module_path.len() - 1;\n+                        let enum_ident = directive.module_path[enum_path_segment_index];\n+\n+                        let enum_resolution = resolutions.get(&(enum_ident, TypeNS))\n+                            .expect(\"resolution should exist\");\n+                        let enum_span = enum_resolution.borrow()\n+                            .binding.expect(\"binding should exist\")\n+                            .span;\n+                        let enum_def_span = self.session.source_map().def_span(enum_span);\n+                        let enum_def_snippet = self.session.source_map()\n+                            .span_to_snippet(enum_def_span).expect(\"snippet should exist\");\n+                        // potentially need to strip extant `crate`/`pub(path)` for suggestion\n+                        let after_vis_index = enum_def_snippet.find(\"enum\")\n+                            .expect(\"`enum` keyword should exist in snippet\");\n+                        let suggestion = format!(\"pub {}\",\n+                                                 &enum_def_snippet[after_vis_index..]);\n+\n+                        self.session\n+                            .diag_span_suggestion_once(&mut err,\n+                                                       DiagnosticMessageId::ErrorId(0),\n+                                                       enum_def_span,\n+                                                       \"consider making the enum public\",\n+                                                       suggestion);\n+                        err.emit();\n                 }\n-                _ => {}\n             }\n         }\n "}]}