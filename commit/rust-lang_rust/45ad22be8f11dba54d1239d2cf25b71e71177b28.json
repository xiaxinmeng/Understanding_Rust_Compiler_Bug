{"sha": "45ad22be8f11dba54d1239d2cf25b71e71177b28", "node_id": "C_kwDOAAsO6NoAKDQ1YWQyMmJlOGYxMWRiYTU0ZDEyMzlkMmNmMjViNzFlNzExNzdiMjg", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-04-03T12:50:56Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-08-30T17:04:04Z"}, "message": "Encode type in the main loop.", "tree": {"sha": "1a35129d346de7d3023ea2edbf5ca3d1094cbf65", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1a35129d346de7d3023ea2edbf5ca3d1094cbf65"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/45ad22be8f11dba54d1239d2cf25b71e71177b28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/45ad22be8f11dba54d1239d2cf25b71e71177b28", "html_url": "https://github.com/rust-lang/rust/commit/45ad22be8f11dba54d1239d2cf25b71e71177b28", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/45ad22be8f11dba54d1239d2cf25b71e71177b28/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "230a8ee364b693c286a2187e56239cd2cc3be318", "url": "https://api.github.com/repos/rust-lang/rust/commits/230a8ee364b693c286a2187e56239cd2cc3be318", "html_url": "https://github.com/rust-lang/rust/commit/230a8ee364b693c286a2187e56239cd2cc3be318"}], "stats": {"total": 111, "additions": 55, "deletions": 56}, "files": [{"sha": "649bb6e94456647d53575ddc19f5128667365702", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 55, "deletions": 56, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/45ad22be8f11dba54d1239d2cf25b71e71177b28/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45ad22be8f11dba54d1239d2cf25b71e71177b28/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=45ad22be8f11dba54d1239d2cf25b71e71177b28", "patch": "@@ -1020,6 +1020,54 @@ fn should_encode_generics(def_kind: DefKind) -> bool {\n     }\n }\n \n+fn should_encode_type(tcx: TyCtxt<'_>, def_id: LocalDefId, def_kind: DefKind) -> bool {\n+    match def_kind {\n+        DefKind::Struct\n+        | DefKind::Union\n+        | DefKind::Enum\n+        | DefKind::Variant\n+        | DefKind::Ctor(..)\n+        | DefKind::Field\n+        | DefKind::Fn\n+        | DefKind::Const\n+        | DefKind::Static(..)\n+        | DefKind::TyAlias\n+        | DefKind::OpaqueTy\n+        | DefKind::ForeignTy\n+        | DefKind::Impl\n+        | DefKind::AssocFn\n+        | DefKind::AssocConst\n+        | DefKind::Closure\n+        | DefKind::Generator\n+        | DefKind::ConstParam\n+        | DefKind::AnonConst\n+        | DefKind::InlineConst => true,\n+\n+        DefKind::AssocTy => {\n+            let assoc_item = tcx.associated_item(def_id);\n+            match assoc_item.container {\n+                ty::AssocItemContainer::ImplContainer => true,\n+                ty::AssocItemContainer::TraitContainer => assoc_item.defaultness(tcx).has_value(),\n+            }\n+        }\n+        DefKind::TyParam => {\n+            let hir::Node::GenericParam(param) = tcx.hir().get_by_def_id(def_id) else { bug!() };\n+            let hir::GenericParamKind::Type { default, .. } = param.kind else { bug!() };\n+            default.is_some()\n+        }\n+\n+        DefKind::Trait\n+        | DefKind::TraitAlias\n+        | DefKind::Mod\n+        | DefKind::ForeignMod\n+        | DefKind::Macro(..)\n+        | DefKind::Use\n+        | DefKind::LifetimeParam\n+        | DefKind::GlobalAsm\n+        | DefKind::ExternCrate => false,\n+    }\n+}\n+\n impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     fn encode_attrs(&mut self, def_id: LocalDefId) {\n         let mut attrs = self\n@@ -1076,6 +1124,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     record_array!(self.tables.inferred_outlives_of[def_id] <- inferred_outlives);\n                 }\n             }\n+            if should_encode_type(tcx, local_id, def_kind) {\n+                record!(self.tables.type_of[def_id] <- self.tcx.type_of(def_id));\n+            }\n             if let DefKind::TyParam | DefKind::ConstParam = def_kind {\n                 if let Some(default) = self.tcx.object_lifetime_default(def_id) {\n                     record!(self.tables.object_lifetime_default[def_id] <- default);\n@@ -1097,11 +1148,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn encode_item_type(&mut self, def_id: DefId) {\n-        debug!(\"EncodeContext::encode_item_type({:?})\", def_id);\n-        record!(self.tables.type_of[def_id] <- self.tcx.type_of(def_id));\n-    }\n-\n     fn encode_enum_variant_info(&mut self, def: ty::AdtDef<'tcx>, index: VariantIdx) {\n         let tcx = self.tcx;\n         let variant = &def.variant(index);\n@@ -1121,7 +1167,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             assert!(f.did.is_local());\n             f.did.index\n         }));\n-        self.encode_item_type(def_id);\n         if variant.ctor_kind == CtorKind::Fn {\n             // FIXME(eddyb) encode signature only in `encode_enum_variant_ctor`.\n             if let Some(ctor_def_id) = variant.ctor_def_id {\n@@ -1146,7 +1191,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         record!(self.tables.kind[def_id] <- EntryKind::Variant(self.lazy(data)));\n         self.tables.constness.set(def_id.index, hir::Constness::Const);\n-        self.encode_item_type(def_id);\n         if variant.ctor_kind == CtorKind::Fn {\n             record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n         }\n@@ -1212,7 +1256,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         debug!(\"EncodeContext::encode_field({:?})\", def_id);\n \n         record!(self.tables.kind[def_id] <- EntryKind::Field);\n-        self.encode_item_type(def_id);\n     }\n \n     fn encode_struct_ctor(&mut self, adt_def: ty::AdtDef<'tcx>, def_id: DefId) {\n@@ -1230,7 +1273,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         record!(self.tables.repr_options[def_id] <- adt_def.repr());\n         self.tables.constness.set(def_id.index, hir::Constness::Const);\n         record!(self.tables.kind[def_id] <- EntryKind::Struct(self.lazy(data)));\n-        self.encode_item_type(def_id);\n         if variant.ctor_kind == CtorKind::Fn {\n             record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n         }\n@@ -1285,16 +1327,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 record!(self.tables.kind[def_id] <- EntryKind::AssocType(ty::AssocItemContainer::TraitContainer));\n             }\n         }\n-        match trait_item.kind {\n-            ty::AssocKind::Const | ty::AssocKind::Fn => {\n-                self.encode_item_type(def_id);\n-            }\n-            ty::AssocKind::Type => {\n-                if ast_item.defaultness.has_value() {\n-                    self.encode_item_type(def_id);\n-                }\n-            }\n-        }\n         if trait_item.kind == ty::AssocKind::Fn {\n             record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n         }\n@@ -1341,7 +1373,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 record!(self.tables.kind[def_id] <- EntryKind::AssocType(ty::AssocItemContainer::ImplContainer));\n             }\n         }\n-        self.encode_item_type(def_id);\n         if let Some(trait_item_def_id) = impl_item.trait_item_def_id {\n             self.tables.trait_item_def_id.set(def_id.index, trait_item_def_id.into());\n         }\n@@ -1590,18 +1621,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             }\n             _ => {}\n         }\n-        match item.kind {\n-            hir::ItemKind::Static(..)\n-            | hir::ItemKind::Const(..)\n-            | hir::ItemKind::Fn(..)\n-            | hir::ItemKind::TyAlias(..)\n-            | hir::ItemKind::OpaqueTy(..)\n-            | hir::ItemKind::Enum(..)\n-            | hir::ItemKind::Struct(..)\n-            | hir::ItemKind::Union(..)\n-            | hir::ItemKind::Impl { .. } => self.encode_item_type(def_id),\n-            _ => {}\n-        }\n         if let hir::ItemKind::Fn(..) = item.kind {\n             record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n             if tcx.is_intrinsic(def_id) {\n@@ -1615,13 +1634,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn encode_info_for_generic_param(&mut self, def_id: DefId, kind: EntryKind, encode_type: bool) {\n-        record!(self.tables.kind[def_id] <- kind);\n-        if encode_type {\n-            self.encode_item_type(def_id);\n-        }\n-    }\n-\n     fn encode_info_for_closure(&mut self, hir_id: hir::HirId) {\n         let def_id = self.tcx.hir().local_def_id(hir_id);\n         debug!(\"EncodeContext::encode_info_for_closure({:?})\", def_id);\n@@ -1638,16 +1650,13 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 record!(self.tables.generator_diagnostic_data[def_id.to_def_id()]  <- generator_diagnostic_data);\n             }\n \n-            ty::Closure(..) => {\n+            ty::Closure(_, substs) => {\n                 record!(self.tables.kind[def_id.to_def_id()] <- EntryKind::Closure);\n+                record!(self.tables.fn_sig[def_id.to_def_id()] <- substs.as_closure().sig());\n             }\n \n             _ => bug!(\"closure that is neither generator nor closure\"),\n         }\n-        self.encode_item_type(def_id.to_def_id());\n-        if let ty::Closure(def_id, substs) = *ty.kind() {\n-            record!(self.tables.fn_sig[def_id] <- substs.as_closure().sig());\n-        }\n     }\n \n     fn encode_info_for_anon_const(&mut self, id: hir::HirId) {\n@@ -1660,7 +1669,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         record!(self.tables.kind[def_id.to_def_id()] <- EntryKind::AnonConst);\n         record!(self.tables.mir_const_qualif[def_id.to_def_id()] <- qualifs);\n         record!(self.tables.rendered_const[def_id.to_def_id()] <- const_data);\n-        self.encode_item_type(def_id.to_def_id());\n     }\n \n     fn encode_native_libraries(&mut self) -> LazyArray<NativeLib> {\n@@ -1997,6 +2005,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 };\n                 self.tables.constness.set(def_id.index, constness);\n                 record!(self.tables.kind[def_id] <- EntryKind::ForeignFn);\n+                record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n             }\n             hir::ForeignItemKind::Static(..) => {\n                 record!(self.tables.kind[def_id] <- EntryKind::ForeignStatic);\n@@ -2005,9 +2014,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 record!(self.tables.kind[def_id] <- EntryKind::ForeignType);\n             }\n         }\n-        self.encode_item_type(def_id);\n         if let hir::ForeignItemKind::Fn(..) = nitem.kind {\n-            record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n             if tcx.is_intrinsic(def_id) {\n                 self.tables.is_intrinsic.set(def_id.index, ());\n             }\n@@ -2061,17 +2068,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         for param in generics.params {\n             let def_id = self.tcx.hir().local_def_id(param.hir_id);\n             match param.kind {\n-                GenericParamKind::Lifetime { .. } => continue,\n-                GenericParamKind::Type { default, .. } => {\n-                    self.encode_info_for_generic_param(\n-                        def_id.to_def_id(),\n-                        EntryKind::TypeParam,\n-                        default.is_some(),\n-                    );\n-                }\n+                GenericParamKind::Lifetime { .. } | GenericParamKind::Type { .. } => {}\n                 GenericParamKind::Const { ref default, .. } => {\n                     let def_id = def_id.to_def_id();\n-                    self.encode_info_for_generic_param(def_id, EntryKind::ConstParam, true);\n                     if default.is_some() {\n                         record!(self.tables.const_param_default[def_id] <- self.tcx.const_param_default(def_id))\n                     }"}]}