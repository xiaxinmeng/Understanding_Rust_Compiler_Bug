{"sha": "7ee90cc7be7b74fd8e63ef79a19844343ad1dd9c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlZTkwY2M3YmU3Yjc0ZmQ4ZTYzZWY3OWExOTg0NDM0M2FkMWRkOWM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-04-25T03:16:53Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-04-25T04:08:49Z"}, "message": "syntax: Rename is_word to is_keyword, etc.", "tree": {"sha": "680df6317b1bec4ba359ebc81b21f2e679501410", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/680df6317b1bec4ba359ebc81b21f2e679501410"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7ee90cc7be7b74fd8e63ef79a19844343ad1dd9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7ee90cc7be7b74fd8e63ef79a19844343ad1dd9c", "html_url": "https://github.com/rust-lang/rust/commit/7ee90cc7be7b74fd8e63ef79a19844343ad1dd9c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7ee90cc7be7b74fd8e63ef79a19844343ad1dd9c/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a0c564817508604fcb738e15966f2d279139d8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a0c564817508604fcb738e15966f2d279139d8c", "html_url": "https://github.com/rust-lang/rust/commit/5a0c564817508604fcb738e15966f2d279139d8c"}], "stats": {"total": 189, "additions": 97, "deletions": 92}, "files": [{"sha": "d0a20dab5a96481d763827c7681a75767117afb2", "filename": "src/librustsyntax/parse/common.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7ee90cc7be7b74fd8e63ef79a19844343ad1dd9c/src%2Flibrustsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ee90cc7be7b74fd8e63ef79a19844343ad1dd9c/src%2Flibrustsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse%2Fcommon.rs?ref=7ee90cc7be7b74fd8e63ef79a19844343ad1dd9c", "patch": "@@ -58,15 +58,15 @@ fn require_keyword(p: parser, word: str) {\n     }\n }\n \n-fn is_word(p: parser, word: str) -> bool {\n+fn is_keyword(p: parser, word: str) -> bool {\n     require_keyword(p, word);\n     ret alt p.token {\n           token::IDENT(sid, false) { str::eq(word, p.get_str(sid)) }\n           _ { false }\n         };\n }\n \n-fn eat_word(p: parser, word: str) -> bool {\n+fn eat_keyword(p: parser, word: str) -> bool {\n     require_keyword(p, word);\n     alt p.token {\n       token::IDENT(sid, false) {\n@@ -79,9 +79,9 @@ fn eat_word(p: parser, word: str) -> bool {\n     }\n }\n \n-fn expect_word(p: parser, word: str) {\n+fn expect_keyword(p: parser, word: str) {\n     require_keyword(p, word);\n-    if !eat_word(p, word) {\n+    if !eat_keyword(p, word) {\n         p.fatal(\"expecting \" + word + \", found \" +\n                     token_to_str(p.reader, p.token));\n     }"}, {"sha": "c43fb5810efeda9e7827f7fcb4611a58e6459028", "filename": "src/librustsyntax/parse/parser.rs", "status": "modified", "additions": 93, "deletions": 88, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/7ee90cc7be7b74fd8e63ef79a19844343ad1dd9c/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ee90cc7be7b74fd8e63ef79a19844343ad1dd9c/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse%2Fparser.rs?ref=7ee90cc7be7b74fd8e63ef79a19844343ad1dd9c", "patch": "@@ -387,15 +387,15 @@ fn parse_ty(p: parser, colons_before_params: bool) -> @ast::ty {\n         let region = parse_region(p);\n         let mt = parse_mt(p);\n         ast::ty_rptr(region, mt)\n-    } else if eat_word(p, \"fn\") {\n+    } else if eat_keyword(p, \"fn\") {\n         let proto = parse_fn_ty_proto(p);\n         alt proto {\n           ast::proto_bare { p.warn(\"fn is deprecated, use native fn\"); }\n           _ { /* fallthrough */ }\n         }\n         ast::ty_fn(proto, parse_ty_fn(p))\n-    } else if eat_word(p, \"native\") {\n-        expect_word(p, \"fn\");\n+    } else if eat_keyword(p, \"native\") {\n+        expect_keyword(p, \"fn\");\n         ast::ty_fn(ast::proto_bare, parse_ty_fn(p))\n     } else if p.token == token::MOD_SEP || is_ident(p.token) {\n         let path = parse_path(p);\n@@ -518,9 +518,9 @@ fn lit_from_token(p: parser, tok: token::token) -> ast::lit_ {\n \n fn parse_lit(p: parser) -> ast::lit {\n     let lo = p.span.lo;\n-    let lit = if eat_word(p, \"true\") {\n+    let lit = if eat_keyword(p, \"true\") {\n         ast::lit_bool(true)\n-    } else if eat_word(p, \"false\") {\n+    } else if eat_keyword(p, \"false\") {\n         ast::lit_bool(false)\n     } else {\n         let tok = p.token;\n@@ -562,11 +562,11 @@ fn parse_path_and_ty_param_substs(p: parser, colons: bool) -> @ast::path {\n }\n \n fn parse_mutability(p: parser) -> ast::mutability {\n-    if eat_word(p, \"mut\") {\n+    if eat_keyword(p, \"mut\") {\n         ast::m_mutbl\n-    } else if eat_word(p, \"mut\") {\n+    } else if eat_keyword(p, \"mut\") {\n         ast::m_mutbl\n-    } else if eat_word(p, \"const\") {\n+    } else if eat_keyword(p, \"const\") {\n         ast::m_const\n     } else {\n         ast::m_imm\n@@ -654,12 +654,14 @@ fn parse_bottom_expr(p: parser) -> pexpr {\n         ret mk_pexpr(p, lo, hi, ast::expr_tup(es));\n     } else if p.token == token::LBRACE {\n         p.bump();\n-        if is_word(p, \"mut\") ||\n+        if is_keyword(p, \"mut\") ||\n                is_plain_ident(p.token) && p.look_ahead(1u) == token::COLON {\n             let mut fields = [parse_field(p, token::COLON)];\n             let mut base = none;\n             while p.token != token::RBRACE {\n-                if eat_word(p, \"with\") { base = some(parse_expr(p)); break; }\n+                if eat_keyword(p, \"with\") {\n+                    base = some(parse_expr(p)); break;\n+                }\n                 expect(p, token::COMMA);\n                 if p.token == token::RBRACE {\n                     // record ends by an optional trailing comma\n@@ -676,36 +678,36 @@ fn parse_bottom_expr(p: parser) -> pexpr {\n             let blk = parse_block_tail(p, lo, ast::default_blk);\n             ret mk_pexpr(p, blk.span.lo, blk.span.hi, ast::expr_block(blk));\n         }\n-    } else if eat_word(p, \"new\") {\n+    } else if eat_keyword(p, \"new\") {\n         expect(p, token::LPAREN);\n         let r = parse_expr(p);\n         expect(p, token::RPAREN);\n         let v = parse_expr(p);\n         ret mk_pexpr(p, lo, p.span.hi,\n                      ast::expr_new(r, p.get_id(), v));\n-    } else if eat_word(p, \"if\") {\n+    } else if eat_keyword(p, \"if\") {\n         ret pexpr(parse_if_expr(p));\n-    } else if eat_word(p, \"for\") {\n+    } else if eat_keyword(p, \"for\") {\n         ret pexpr(parse_for_expr(p));\n-    } else if eat_word(p, \"while\") {\n+    } else if eat_keyword(p, \"while\") {\n         ret pexpr(parse_while_expr(p));\n-    } else if eat_word(p, \"do\") {\n+    } else if eat_keyword(p, \"do\") {\n         ret pexpr(parse_do_while_expr(p));\n-    } else if eat_word(p, \"loop\") {\n+    } else if eat_keyword(p, \"loop\") {\n         ret pexpr(parse_loop_expr(p));\n-    } else if eat_word(p, \"alt\") {\n+    } else if eat_keyword(p, \"alt\") {\n         ret pexpr(parse_alt_expr(p));\n-    } else if eat_word(p, \"fn\") {\n+    } else if eat_keyword(p, \"fn\") {\n         let proto = parse_fn_ty_proto(p);\n         alt proto {\n           ast::proto_bare { p.fatal(\"fn expr are deprecated, use fn@\"); }\n           ast::proto_any { p.fatal(\"fn* cannot be used in an expression\"); }\n           _ { /* fallthrough */ }\n         }\n         ret pexpr(parse_fn_expr(p, proto));\n-    } else if eat_word(p, \"unchecked\") {\n+    } else if eat_keyword(p, \"unchecked\") {\n         ret pexpr(parse_block_expr(p, lo, ast::unchecked_blk));\n-    } else if eat_word(p, \"unsafe\") {\n+    } else if eat_keyword(p, \"unsafe\") {\n         ret pexpr(parse_block_expr(p, lo, ast::unsafe_blk));\n     } else if p.token == token::LBRACKET {\n         p.bump();\n@@ -737,69 +739,69 @@ fn parse_bottom_expr(p: parser) -> pexpr {\n         let ex_ext = parse_syntax_ext(p);\n         hi = ex_ext.span.hi;\n         ex = ex_ext.node;\n-    } else if eat_word(p, \"bind\") {\n+    } else if eat_keyword(p, \"bind\") {\n         let e = parse_expr_res(p, RESTRICT_NO_CALL_EXPRS);\n         let es =\n             parse_seq(token::LPAREN, token::RPAREN, seq_sep(token::COMMA),\n                       parse_expr_or_hole, p);\n         hi = es.span.hi;\n         ex = ast::expr_bind(e, es.node);\n-    } else if eat_word(p, \"fail\") {\n+    } else if eat_keyword(p, \"fail\") {\n         if can_begin_expr(p.token) {\n             let e = parse_expr(p);\n             hi = e.span.hi;\n             ex = ast::expr_fail(some(e));\n         } else { ex = ast::expr_fail(none); }\n-    } else if eat_word(p, \"log\") {\n+    } else if eat_keyword(p, \"log\") {\n         expect(p, token::LPAREN);\n         let lvl = parse_expr(p);\n         expect(p, token::COMMA);\n         let e = parse_expr(p);\n         ex = ast::expr_log(2, lvl, e);\n         hi = p.span.hi;\n         expect(p, token::RPAREN);\n-    } else if eat_word(p, \"assert\") {\n+    } else if eat_keyword(p, \"assert\") {\n         let e = parse_expr(p);\n         ex = ast::expr_assert(e);\n         hi = e.span.hi;\n-    } else if eat_word(p, \"check\") {\n+    } else if eat_keyword(p, \"check\") {\n         /* Should be a predicate (pure boolean function) applied to\n            arguments that are all either slot variables or literals.\n            but the typechecker enforces that. */\n         let e = parse_expr(p);\n         hi = e.span.hi;\n         ex = ast::expr_check(ast::checked_expr, e);\n-    } else if eat_word(p, \"claim\") {\n+    } else if eat_keyword(p, \"claim\") {\n         /* Same rules as check, except that if check-claims\n          is enabled (a command-line flag), then the parser turns\n         claims into check */\n \n         let e = parse_expr(p);\n         hi = e.span.hi;\n         ex = ast::expr_check(ast::claimed_expr, e);\n-    } else if eat_word(p, \"ret\") {\n+    } else if eat_keyword(p, \"ret\") {\n         if can_begin_expr(p.token) {\n             let e = parse_expr(p);\n             hi = e.span.hi;\n             ex = ast::expr_ret(some(e));\n         } else { ex = ast::expr_ret(none); }\n-    } else if eat_word(p, \"break\") {\n+    } else if eat_keyword(p, \"break\") {\n         ex = ast::expr_break;\n         hi = p.span.hi;\n-    } else if eat_word(p, \"cont\") {\n+    } else if eat_keyword(p, \"cont\") {\n         ex = ast::expr_cont;\n         hi = p.span.hi;\n-    } else if eat_word(p, \"be\") {\n+    } else if eat_keyword(p, \"be\") {\n         let e = parse_expr(p);\n         hi = e.span.hi;\n         ex = ast::expr_be(e);\n-    } else if eat_word(p, \"copy\") {\n+    } else if eat_keyword(p, \"copy\") {\n         let e = parse_expr(p);\n         ex = ast::expr_copy(e);\n         hi = e.span.hi;\n     } else if p.token == token::MOD_SEP ||\n-                  is_ident(p.token) && !is_word(p, \"true\") &&\n-                      !is_word(p, \"false\") {\n+                  is_ident(p.token) && !is_keyword(p, \"true\") &&\n+                      !is_keyword(p, \"false\") {\n         check_bad_word(p);\n         let pth = parse_path_and_ty_param_substs(p, true);\n         hi = pth.span.hi;\n@@ -1051,7 +1053,7 @@ fn parse_more_binops(p: parser, plhs: pexpr, min_prec: int) ->\n             ret parse_more_binops(p, bin, min_prec);\n         }\n     }\n-    if as_prec > min_prec && eat_word(p, \"as\") {\n+    if as_prec > min_prec && eat_keyword(p, \"as\") {\n         let rhs = parse_ty(p, true);\n         let _as =\n             mk_pexpr(p, lhs.span.lo, rhs.span.hi, ast::expr_cast(lhs, rhs));\n@@ -1115,7 +1117,7 @@ fn parse_if_expr_1(p: parser) ->\n     let thn = parse_block(p);\n     let mut els: option<@ast::expr> = none;\n     let mut hi = thn.span.hi;\n-    if eat_word(p, \"else\") {\n+    if eat_keyword(p, \"else\") {\n         let elexpr = parse_else_expr(p);\n         els = some(elexpr);\n         hi = elexpr.span.hi;\n@@ -1124,7 +1126,7 @@ fn parse_if_expr_1(p: parser) ->\n }\n \n fn parse_if_expr(p: parser) -> @ast::expr {\n-    if eat_word(p, \"check\") {\n+    if eat_keyword(p, \"check\") {\n         let q = parse_if_expr_1(p);\n         ret mk_expr(p, q.lo, q.hi, ast::expr_if_check(q.cond, q.then, q.els));\n     } else {\n@@ -1171,10 +1173,10 @@ fn parse_capture_clause(p: parser) -> @ast::capture_clause {\n \n     if eat(p, token::LBRACKET) {\n         while !eat(p, token::RBRACKET) {\n-            if eat_word(p, \"copy\") {\n+            if eat_keyword(p, \"copy\") {\n                 copies += eat_ident_list(p);\n                 expect_opt_trailing_semi(p);\n-            } else if eat_word(p, \"move\") {\n+            } else if eat_keyword(p, \"move\") {\n                 moves += eat_ident_list(p);\n                 expect_opt_trailing_semi(p);\n             } else {\n@@ -1204,7 +1206,7 @@ fn parse_fn_block_expr(p: parser) -> @ast::expr {\n }\n \n fn parse_else_expr(p: parser) -> @ast::expr {\n-    if eat_word(p, \"if\") {\n+    if eat_keyword(p, \"if\") {\n         ret parse_if_expr(p);\n     } else {\n         let blk = parse_block(p);\n@@ -1240,7 +1242,7 @@ fn parse_while_expr(p: parser) -> @ast::expr {\n fn parse_do_while_expr(p: parser) -> @ast::expr {\n     let lo = p.last_span.lo;\n     let body = parse_block_no_value(p);\n-    expect_word(p, \"while\");\n+    expect_keyword(p, \"while\");\n     let cond = parse_expr(p);\n     let mut hi = cond.span.hi;\n     ret mk_expr(p, lo, hi, ast::expr_do_while(body, cond));\n@@ -1255,15 +1257,15 @@ fn parse_loop_expr(p: parser) -> @ast::expr {\n \n fn parse_alt_expr(p: parser) -> @ast::expr {\n     let lo = p.last_span.lo;\n-    let mode = if eat_word(p, \"check\") { ast::alt_check }\n+    let mode = if eat_keyword(p, \"check\") { ast::alt_check }\n                else { ast::alt_exhaustive };\n     let discriminant = parse_expr(p);\n     expect(p, token::LBRACE);\n     let mut arms: [ast::arm] = [];\n     while p.token != token::RBRACE {\n         let pats = parse_pats(p);\n         let mut guard = none;\n-        if eat_word(p, \"if\") { guard = some(parse_expr(p)); }\n+        if eat_keyword(p, \"if\") { guard = some(parse_expr(p)); }\n         let blk = parse_block(p);\n         arms += [{pats: pats, guard: guard, body: blk}];\n     }\n@@ -1402,9 +1404,9 @@ fn parse_pat(p: parser) -> @ast::pat {\n         }\n       }\n       tok {\n-        if !is_ident(tok) || is_word(p, \"true\") || is_word(p, \"false\") {\n+        if !is_ident(tok) || is_keyword(p, \"true\") || is_keyword(p, \"false\") {\n             let val = parse_expr_res(p, RESTRICT_NO_BAR_OP);\n-            if eat_word(p, \"to\") {\n+            if eat_keyword(p, \"to\") {\n                 let end = parse_expr_res(p, RESTRICT_NO_BAR_OP);\n                 hi = end.span.hi;\n                 pat = ast::pat_range(val, end);\n@@ -1478,7 +1480,7 @@ fn parse_local(p: parser, is_mutbl: bool,\n }\n \n fn parse_let(p: parser) -> @ast::decl {\n-    let is_mutbl = eat_word(p, \"mut\");\n+    let is_mutbl = eat_keyword(p, \"mut\");\n     let lo = p.span.lo;\n     let mut locals = [parse_local(p, is_mutbl, true)];\n     while eat(p, token::COMMA) {\n@@ -1491,7 +1493,7 @@ fn parse_let(p: parser) -> @ast::decl {\n fn parse_instance_var(p:parser, pr: ast::privacy) -> @ast::class_member {\n     let mut is_mutbl = ast::class_immutable;\n     let lo = p.span.lo;\n-    if eat_word(p, \"mut\") {\n+    if eat_keyword(p, \"mut\") {\n         is_mutbl = ast::class_mutable;\n     }\n     if !is_plain_ident(p.token) {\n@@ -1513,9 +1515,9 @@ fn parse_stmt(p: parser, first_item_attrs: [ast::attribute]) -> @ast::stmt {\n     }\n \n     let lo = p.span.lo;\n-    if is_word(p, \"let\") {\n+    if is_keyword(p, \"let\") {\n         check_expected_item(p, first_item_attrs);\n-        expect_word(p, \"let\");\n+        expect_keyword(p, \"let\");\n         let decl = parse_let(p);\n         ret @spanned(lo, decl.span.hi, ast::stmt_decl(decl, p.get_id()));\n     } else {\n@@ -1575,11 +1577,11 @@ fn parse_inner_attrs_and_block(\n     }\n \n     let lo = p.span.lo;\n-    if eat_word(p, \"unchecked\") {\n+    if eat_keyword(p, \"unchecked\") {\n         expect(p, token::LBRACE);\n         let {inner, next} = maybe_parse_inner_attrs_and_next(p, parse_attrs);\n         ret (inner, parse_block_tail_(p, lo, ast::unchecked_blk, next));\n-    } else if eat_word(p, \"unsafe\") {\n+    } else if eat_keyword(p, \"unsafe\") {\n         expect(p, token::LBRACE);\n         let {inner, next} = maybe_parse_inner_attrs_and_next(p, parse_attrs);\n         ret (inner, parse_block_tail_(p, lo, ast::unsafe_blk, next));\n@@ -1668,8 +1670,8 @@ fn parse_ty_param(p: parser) -> ast::ty_param {\n     let ident = parse_ident(p);\n     if eat(p, token::COLON) {\n         while p.token != token::COMMA && p.token != token::GT {\n-            if eat_word(p, \"send\") { bounds += [ast::bound_send]; }\n-            else if eat_word(p, \"copy\") { bounds += [ast::bound_copy]; }\n+            if eat_keyword(p, \"send\") { bounds += [ast::bound_send]; }\n+            else if eat_keyword(p, \"copy\") { bounds += [ast::bound_copy]; }\n             else { bounds += [ast::bound_iface(parse_ty(p, false))]; }\n         }\n     }\n@@ -1789,11 +1791,11 @@ fn parse_item_iface(p: parser, attrs: [ast::attribute]) -> @ast::item {\n //    impl name<T> for [T] { ... }\n fn parse_item_impl(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     let lo = p.last_span.lo;\n-    let mut (ident, tps) = if !is_word(p, \"of\") {\n+    let mut (ident, tps) = if !is_keyword(p, \"of\") {\n         if p.token == token::LT { (none, parse_ty_params(p)) }\n         else { (some(parse_ident(p)), parse_ty_params(p)) }\n     } else { (none, []) };\n-    let ifce = if eat_word(p, \"of\") {\n+    let ifce = if eat_keyword(p, \"of\") {\n         let path = parse_path_and_ty_param_substs(p, false);\n         if option::is_none(ident) {\n             ident = some(vec::last(path.idents));\n@@ -1802,9 +1804,9 @@ fn parse_item_impl(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     } else { none };\n     let ident = alt ident {\n         some(name) { name }\n-        none { expect_word(p, \"of\"); fail; }\n+        none { expect_keyword(p, \"of\"); fail; }\n     };\n-    expect_word(p, \"for\");\n+    expect_keyword(p, \"for\");\n     let ty = parse_ty(p, false);\n     let mut meths = [];\n     expect(p, token::LBRACE);\n@@ -1868,7 +1870,7 @@ fn parse_item_class(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     let rp = parse_region_param(p);\n     let ty_params = parse_ty_params(p);\n     let class_path = ident_to_path_tys(p, class_name, ty_params);\n-    let ifaces : [@ast::iface_ref] = if eat_word(p, \"implements\")\n+    let ifaces : [@ast::iface_ref] = if eat_keyword(p, \"implements\")\n                                        { parse_iface_ref_list(p) }\n                                     else { [] };\n     expect(p, token::LBRACE);\n@@ -1904,7 +1906,7 @@ fn parse_item_class(p: parser, attrs: [ast::attribute]) -> @ast::item {\n \n fn parse_single_class_item(p: parser, privcy: ast::privacy)\n     -> @ast::class_member {\n-   if eat_word(p, \"let\") {\n+   if eat_keyword(p, \"let\") {\n       let a_var = parse_instance_var(p, privcy);\n       expect(p, token::SEMI);\n       ret a_var;\n@@ -1922,7 +1924,7 @@ enum class_contents { ctor_decl(ast::fn_decl, ast::blk, codemap::span),\n \n fn parse_class_item(p:parser, class_name_with_tps: @ast::path)\n     -> class_contents {\n-    if eat_word(p, \"new\") {\n+    if eat_keyword(p, \"new\") {\n         let lo = p.last_span.lo;\n         // Can ctors have attrs?\n             // result type is always the type of the class\n@@ -1934,7 +1936,7 @@ fn parse_class_item(p:parser, class_name_with_tps: @ast::path)\n         let body = parse_block(p);\n         ret ctor_decl(decl, body, mk_sp(lo, p.last_span.hi));\n     }\n-    else if eat_word(p, \"priv\") {\n+    else if eat_keyword(p, \"priv\") {\n             expect(p, token::LBRACE);\n             let mut results = [];\n             while p.token != token::RBRACE {\n@@ -2016,9 +2018,12 @@ fn parse_item_native_fn(p: parser, attrs: [ast::attribute],\n }\n \n fn parse_fn_purity(p: parser) -> ast::purity {\n-    if eat_word(p, \"fn\") { ast::impure_fn }\n-    else if eat_word(p, \"pure\") { expect_word(p, \"fn\"); ast::pure_fn }\n-    else if eat_word(p, \"unsafe\") { expect_word(p, \"fn\"); ast::unsafe_fn }\n+    if eat_keyword(p, \"fn\") { ast::impure_fn }\n+    else if eat_keyword(p, \"pure\") { expect_keyword(p, \"fn\"); ast::pure_fn }\n+    else if eat_keyword(p, \"unsafe\") {\n+        expect_keyword(p, \"fn\");\n+        ast::unsafe_fn\n+    }\n     else { unexpected(p); }\n }\n \n@@ -2047,7 +2052,7 @@ fn parse_native_mod_items(p: parser, first_item_attrs: [ast::attribute]) ->\n \n fn parse_item_native_mod(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     let lo = p.last_span.lo;\n-    expect_word(p, \"mod\");\n+    expect_keyword(p, \"mod\");\n     let id = parse_ident(p);\n     expect(p, token::LBRACE);\n     let more_attrs = parse_inner_attrs_and_next(p);\n@@ -2178,36 +2183,36 @@ fn fn_expr_lookahead(tok: token::token) -> bool {\n }\n \n fn parse_item(p: parser, attrs: [ast::attribute]) -> option<@ast::item> {\n-    if eat_word(p, \"const\") {\n+    if eat_keyword(p, \"const\") {\n         ret some(parse_item_const(p, attrs));\n-    } else if is_word(p, \"fn\") && !fn_expr_lookahead(p.look_ahead(1u)) {\n+    } else if is_keyword(p, \"fn\") && !fn_expr_lookahead(p.look_ahead(1u)) {\n         p.bump();\n         ret some(parse_item_fn(p, ast::impure_fn, attrs));\n-    } else if eat_word(p, \"pure\") {\n-        expect_word(p, \"fn\");\n+    } else if eat_keyword(p, \"pure\") {\n+        expect_keyword(p, \"fn\");\n         ret some(parse_item_fn(p, ast::pure_fn, attrs));\n-    } else if is_word(p, \"unsafe\") && p.look_ahead(1u) != token::LBRACE {\n+    } else if is_keyword(p, \"unsafe\") && p.look_ahead(1u) != token::LBRACE {\n         p.bump();\n-        expect_word(p, \"fn\");\n+        expect_keyword(p, \"fn\");\n         ret some(parse_item_fn(p, ast::unsafe_fn, attrs));\n-    } else if eat_word(p, \"crust\") {\n-        expect_word(p, \"fn\");\n+    } else if eat_keyword(p, \"crust\") {\n+        expect_keyword(p, \"fn\");\n         ret some(parse_item_fn(p, ast::crust_fn, attrs));\n-    } else if eat_word(p, \"mod\") {\n+    } else if eat_keyword(p, \"mod\") {\n         ret some(parse_item_mod(p, attrs));\n-    } else if eat_word(p, \"native\") {\n+    } else if eat_keyword(p, \"native\") {\n         ret some(parse_item_native_mod(p, attrs));\n-    } if eat_word(p, \"type\") {\n+    } if eat_keyword(p, \"type\") {\n         ret some(parse_item_type(p, attrs));\n-    } else if eat_word(p, \"enum\") {\n+    } else if eat_keyword(p, \"enum\") {\n         ret some(parse_item_enum(p, attrs));\n-    } else if eat_word(p, \"iface\") {\n+    } else if eat_keyword(p, \"iface\") {\n         ret some(parse_item_iface(p, attrs));\n-    } else if eat_word(p, \"impl\") {\n+    } else if eat_keyword(p, \"impl\") {\n         ret some(parse_item_impl(p, attrs));\n-    } else if eat_word(p, \"resource\") {\n+    } else if eat_keyword(p, \"resource\") {\n         ret some(parse_item_res(p, attrs));\n-    } else if eat_word(p, \"class\") {\n+    } else if eat_keyword(p, \"class\") {\n         ret some(parse_item_class(p, attrs));\n     }\n else { ret none; }\n@@ -2298,11 +2303,11 @@ fn parse_view_paths(p: parser) -> [@ast::view_path] {\n fn parse_view_item(p: parser) -> @ast::view_item {\n     let lo = p.span.lo;\n     let the_item =\n-        if eat_word(p, \"use\") {\n+        if eat_keyword(p, \"use\") {\n             parse_use(p)\n-        } else if eat_word(p, \"import\") {\n+        } else if eat_keyword(p, \"import\") {\n             ast::view_item_import(parse_view_paths(p))\n-        } else if eat_word(p, \"export\") {\n+        } else if eat_keyword(p, \"export\") {\n             ast::view_item_export(parse_view_paths(p))\n         } else {\n             fail\n@@ -2313,7 +2318,7 @@ fn parse_view_item(p: parser) -> @ast::view_item {\n }\n \n fn is_view_item(p: parser) -> bool {\n-    is_word(p, \"use\") || is_word(p, \"import\") || is_word(p, \"export\")\n+    is_keyword(p, \"use\") || is_keyword(p, \"import\") || is_keyword(p, \"export\")\n }\n \n fn maybe_parse_view(\n@@ -2327,7 +2332,7 @@ fn maybe_parse_view_import_only(\n     p: parser,\n     first_item_attrs: [ast::attribute]) -> [@ast::view_item] {\n \n-    maybe_parse_view_while(p, first_item_attrs, bind is_word(_, \"import\"))\n+    maybe_parse_view_while(p, first_item_attrs, bind is_keyword(_, \"import\"))\n }\n \n fn maybe_parse_view_while(\n@@ -2385,8 +2390,8 @@ fn parse_crate_directive(p: parser, first_outer_attr: [ast::attribute]) ->\n     let expect_mod = vec::len(outer_attrs) > 0u;\n \n     let lo = p.span.lo;\n-    if expect_mod || is_word(p, \"mod\") {\n-        expect_word(p, \"mod\");\n+    if expect_mod || is_keyword(p, \"mod\") {\n+        expect_keyword(p, \"mod\");\n         let id = parse_ident(p);\n         alt p.token {\n           // mod x = \"foo.rs\";\n@@ -2424,7 +2429,7 @@ fn parse_crate_directives(p: parser, term: token::token,\n     // seeing the terminator next, so if we do see it then fail the same way\n     // parse_crate_directive would\n     if vec::len(first_outer_attr) > 0u && p.token == term {\n-        expect_word(p, \"mod\");\n+        expect_keyword(p, \"mod\");\n     }\n \n     let mut cdirs: [@ast::crate_directive] = [];"}]}