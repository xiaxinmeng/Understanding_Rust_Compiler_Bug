{"sha": "daffdd86749bc2d62b50ff9e0c869032d7932373", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhZmZkZDg2NzQ5YmMyZDYyYjUwZmY5ZTBjODY5MDMyZDc5MzIzNzM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-02-17T08:38:09Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-02-17T08:38:09Z"}, "message": "Merge #3179\n\n3179: Introduce AsMacroCall trait r=matklad a=edwin0cheng\n\nThis PR introduce `AsMacroCall` trait to help convert `ast::MacroCall` to `MacroCallId`. The main goal here is to centralize various conversions to single place and make implementing eager macro calls without further ado.\r\n\r\n```rust\r\npub trait AsMacroCall {\r\n    fn as_call_id(\r\n        &self,\r\n        db: &(impl db::DefDatabase + AstDatabase),\r\n        resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\r\n    ) -> Option<MacroCallId>;\r\n}\r\n```\n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>", "tree": {"sha": "49405ddd5a074867664141717772c3dd8aece308", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/49405ddd5a074867664141717772c3dd8aece308"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/daffdd86749bc2d62b50ff9e0c869032d7932373", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeSlDxCRBK7hj4Ov3rIwAAdHIIAEiJYrsd1KQi2vqGJgDpk6/q\nO4aIuyIZ9sJBNAdlHBfMoAZr+5P1d3B0HM/s5wgeO6SFVhRCtGmNlIyMhm2KUPlh\nU8MaWSdZc5sfAEtAJK5K+YJB0a10iGxfKf/jZUsi2SjXCQyb1eIRS2LrO5ZMQhOH\nQEIcQoXOq/6/Z/H0fdG48UNGdj6vuyyPBFh4mllTdzrWEu1y+LdPRxNvPNVPm9aP\nvKmPR+DQZ75ug6g15Ad2BqXZoL0EIvcvWhpLz4JibfKnbecB6JVwA7CQbm/fkBEj\nksD8c9DoeMevTHThzWPFKBFykHQIRAwpBxhNZQ7ULulZoCa801JIMs60yKx7TWo=\n=F4F6\n-----END PGP SIGNATURE-----\n", "payload": "tree 49405ddd5a074867664141717772c3dd8aece308\nparent 32fc890de87e25c342b7c141ef98b07cb1471128\nparent 2d4e79e1e6e39719d566bb58e04a7839588238fe\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1581928689 +0000\ncommitter GitHub <noreply@github.com> 1581928689 +0000\n\nMerge #3179\n\n3179: Introduce AsMacroCall trait r=matklad a=edwin0cheng\n\nThis PR introduce `AsMacroCall` trait to help convert `ast::MacroCall` to `MacroCallId`. The main goal here is to centralize various conversions to single place and make implementing eager macro calls without further ado.\r\n\r\n```rust\r\npub trait AsMacroCall {\r\n    fn as_call_id(\r\n        &self,\r\n        db: &(impl db::DefDatabase + AstDatabase),\r\n        resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\r\n    ) -> Option<MacroCallId>;\r\n}\r\n```\n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/daffdd86749bc2d62b50ff9e0c869032d7932373", "html_url": "https://github.com/rust-lang/rust/commit/daffdd86749bc2d62b50ff9e0c869032d7932373", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/daffdd86749bc2d62b50ff9e0c869032d7932373/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "32fc890de87e25c342b7c141ef98b07cb1471128", "url": "https://api.github.com/repos/rust-lang/rust/commits/32fc890de87e25c342b7c141ef98b07cb1471128", "html_url": "https://github.com/rust-lang/rust/commit/32fc890de87e25c342b7c141ef98b07cb1471128"}, {"sha": "2d4e79e1e6e39719d566bb58e04a7839588238fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d4e79e1e6e39719d566bb58e04a7839588238fe", "html_url": "https://github.com/rust-lang/rust/commit/2d4e79e1e6e39719d566bb58e04a7839588238fe"}], "stats": {"total": 210, "additions": 130, "deletions": 80}, "files": [{"sha": "94d5b4cfd73a5c6ca600b919a9642759ec4e09a7", "filename": "crates/ra_hir/src/source_analyzer.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/daffdd86749bc2d62b50ff9e0c869032d7932373/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daffdd86749bc2d62b50ff9e0c869032d7932373/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs?ref=daffdd86749bc2d62b50ff9e0c869032d7932373", "patch": "@@ -15,11 +15,9 @@ use hir_def::{\n     },\n     expr::{ExprId, PatId},\n     resolver::{self, resolver_for_scope, Resolver, TypeNs, ValueNs},\n-    DefWithBodyId, TraitId,\n-};\n-use hir_expand::{\n-    hygiene::Hygiene, name::AsName, AstId, HirFileId, InFile, MacroCallId, MacroCallKind,\n+    AsMacroCall, DefWithBodyId, TraitId,\n };\n+use hir_expand::{hygiene::Hygiene, name::AsName, HirFileId, InFile, MacroCallId};\n use hir_ty::{InEnvironment, InferenceResult, TraitEnvironment};\n use ra_syntax::{\n     ast::{self, AstNode},\n@@ -363,12 +361,10 @@ impl SourceAnalyzer {\n         db: &impl HirDatabase,\n         macro_call: InFile<&ast::MacroCall>,\n     ) -> Option<Expansion> {\n-        let def = self.resolve_macro_call(db, macro_call)?.id;\n-        let ast_id = AstId::new(\n-            macro_call.file_id,\n-            db.ast_id_map(macro_call.file_id).ast_id(macro_call.value),\n-        );\n-        Some(Expansion { macro_call_id: def.as_call_id(db, MacroCallKind::FnLike(ast_id)) })\n+        let macro_call_id = macro_call.as_call_id(db, |path| {\n+            self.resolver.resolve_path_as_macro(db, &path).map(|it| it.into())\n+        })?;\n+        Some(Expansion { macro_call_id })\n     }\n }\n "}, {"sha": "010d35e55b1b22c7a34b7afd1ee41438dd710f0d", "filename": "crates/ra_hir_def/src/body.rs", "status": "modified", "additions": 22, "deletions": 32, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/daffdd86749bc2d62b50ff9e0c869032d7932373/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daffdd86749bc2d62b50ff9e0c869032d7932373/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody.rs?ref=daffdd86749bc2d62b50ff9e0c869032d7932373", "patch": "@@ -7,9 +7,7 @@ use std::{mem, ops::Index, sync::Arc};\n \n use drop_bomb::DropBomb;\n use either::Either;\n-use hir_expand::{\n-    ast_id_map::AstIdMap, hygiene::Hygiene, AstId, HirFileId, InFile, MacroCallKind, MacroDefId,\n-};\n+use hir_expand::{ast_id_map::AstIdMap, hygiene::Hygiene, AstId, HirFileId, InFile, MacroDefId};\n use ra_arena::{map::ArenaMap, Arena};\n use ra_prof::profile;\n use ra_syntax::{ast, AstNode, AstPtr};\n@@ -23,7 +21,7 @@ use crate::{\n     nameres::CrateDefMap,\n     path::{ModPath, Path},\n     src::HasSource,\n-    DefWithBodyId, HasModule, Lookup, ModuleId,\n+    AsMacroCall, DefWithBodyId, HasModule, Lookup, ModuleId,\n };\n \n pub(crate) struct Expander {\n@@ -51,30 +49,26 @@ impl Expander {\n         db: &DB,\n         macro_call: ast::MacroCall,\n     ) -> Option<(Mark, T)> {\n-        let ast_id = AstId::new(\n-            self.current_file_id,\n-            db.ast_id_map(self.current_file_id).ast_id(&macro_call),\n-        );\n-\n-        if let Some(path) = macro_call.path().and_then(|path| self.parse_mod_path(path)) {\n-            if let Some(def) = self.resolve_path_as_macro(db, &path) {\n-                let call_id = def.as_call_id(db, MacroCallKind::FnLike(ast_id));\n-                let file_id = call_id.as_file();\n-                if let Some(node) = db.parse_or_expand(file_id) {\n-                    if let Some(expr) = T::cast(node) {\n-                        log::debug!(\"macro expansion {:#?}\", expr.syntax());\n-\n-                        let mark = Mark {\n-                            file_id: self.current_file_id,\n-                            ast_id_map: mem::take(&mut self.ast_id_map),\n-                            bomb: DropBomb::new(\"expansion mark dropped\"),\n-                        };\n-                        self.hygiene = Hygiene::new(db, file_id);\n-                        self.current_file_id = file_id;\n-                        self.ast_id_map = db.ast_id_map(file_id);\n-\n-                        return Some((mark, expr));\n-                    }\n+        let macro_call = InFile::new(self.current_file_id, &macro_call);\n+\n+        if let Some(call_id) =\n+            macro_call.as_call_id(db, |path| self.resolve_path_as_macro(db, &path))\n+        {\n+            let file_id = call_id.as_file();\n+            if let Some(node) = db.parse_or_expand(file_id) {\n+                if let Some(expr) = T::cast(node) {\n+                    log::debug!(\"macro expansion {:#?}\", expr.syntax());\n+\n+                    let mark = Mark {\n+                        file_id: self.current_file_id,\n+                        ast_id_map: mem::take(&mut self.ast_id_map),\n+                        bomb: DropBomb::new(\"expansion mark dropped\"),\n+                    };\n+                    self.hygiene = Hygiene::new(db, file_id);\n+                    self.current_file_id = file_id;\n+                    self.ast_id_map = db.ast_id_map(file_id);\n+\n+                    return Some((mark, expr));\n                 }\n             }\n         }\n@@ -99,10 +93,6 @@ impl Expander {\n         Path::from_src(path, &self.hygiene)\n     }\n \n-    fn parse_mod_path(&mut self, path: ast::Path) -> Option<ModPath> {\n-        ModPath::from_src(path, &self.hygiene)\n-    }\n-\n     fn resolve_path_as_macro(&self, db: &impl DefDatabase, path: &ModPath) -> Option<MacroDefId> {\n         self.crate_def_map\n             .resolve_path(db, self.module.local_id, path, BuiltinShadowMode::Other)"}, {"sha": "aa0b558b8e5c6dc17d41cb1a49e58fb0d54f9726", "filename": "crates/ra_hir_def/src/lib.rs", "status": "modified", "additions": 62, "deletions": 1, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/daffdd86749bc2d62b50ff9e0c869032d7932373/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daffdd86749bc2d62b50ff9e0c869032d7932373/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flib.rs?ref=daffdd86749bc2d62b50ff9e0c869032d7932373", "patch": "@@ -46,7 +46,10 @@ mod marks;\n \n use std::hash::Hash;\n \n-use hir_expand::{ast_id_map::FileAstId, AstId, HirFileId, InFile, MacroDefId};\n+use hir_expand::{\n+    ast_id_map::FileAstId, db::AstDatabase, hygiene::Hygiene, AstId, HirFileId, InFile,\n+    MacroCallId, MacroCallKind, MacroDefId,\n+};\n use ra_arena::{impl_arena_id, RawId};\n use ra_db::{impl_intern_key, salsa, CrateId};\n use ra_syntax::{ast, AstNode};\n@@ -413,3 +416,61 @@ impl HasModule for StaticLoc {\n         self.container.module(db)\n     }\n }\n+\n+/// A helper trait for converting to MacroCallId\n+pub trait AsMacroCall {\n+    fn as_call_id(\n+        &self,\n+        db: &(impl db::DefDatabase + AstDatabase),\n+        resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n+    ) -> Option<MacroCallId>;\n+}\n+\n+impl AsMacroCall for InFile<&ast::MacroCall> {\n+    fn as_call_id(\n+        &self,\n+        db: &(impl db::DefDatabase + AstDatabase),\n+        resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n+    ) -> Option<MacroCallId> {\n+        let ast_id = AstId::new(self.file_id, db.ast_id_map(self.file_id).ast_id(self.value));\n+        let h = Hygiene::new(db, self.file_id);\n+        let path = path::ModPath::from_src(self.value.path()?, &h)?;\n+\n+        AstIdWithPath::new(ast_id.file_id, ast_id.value, path).as_call_id(db, resolver)\n+    }\n+}\n+\n+/// Helper wrapper for `AstId` with `ModPath`\n+#[derive(Clone, Debug, Eq, PartialEq)]\n+struct AstIdWithPath<T: ast::AstNode> {\n+    pub ast_id: AstId<T>,\n+    pub path: path::ModPath,\n+}\n+\n+impl<T: ast::AstNode> AstIdWithPath<T> {\n+    pub fn new(file_id: HirFileId, ast_id: FileAstId<T>, path: path::ModPath) -> AstIdWithPath<T> {\n+        AstIdWithPath { ast_id: AstId::new(file_id, ast_id), path }\n+    }\n+}\n+\n+impl AsMacroCall for AstIdWithPath<ast::MacroCall> {\n+    fn as_call_id(\n+        &self,\n+        db: &impl AstDatabase,\n+        resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n+    ) -> Option<MacroCallId> {\n+        let def = resolver(self.path.clone())?;\n+        Some(def.as_call_id(db, MacroCallKind::FnLike(self.ast_id.clone())))\n+    }\n+}\n+\n+impl AsMacroCall for AstIdWithPath<ast::ModuleItem> {\n+    fn as_call_id(\n+        &self,\n+        db: &impl AstDatabase,\n+        resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n+    ) -> Option<MacroCallId> {\n+        let def = resolver(self.path.clone())?;\n+        Some(def.as_call_id(db, MacroCallKind::Attr(self.ast_id.clone())))\n+    }\n+}"}, {"sha": "51c65a5d77ae29980f3535fc85744e198f6bcd0e", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "modified", "additions": 40, "deletions": 37, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/daffdd86749bc2d62b50ff9e0c869032d7932373/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daffdd86749bc2d62b50ff9e0c869032d7932373/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=daffdd86749bc2d62b50ff9e0c869032d7932373", "patch": "@@ -7,7 +7,7 @@ use hir_expand::{\n     builtin_derive::find_builtin_derive,\n     builtin_macro::find_builtin_macro,\n     name::{name, AsName, Name},\n-    HirFileId, MacroCallId, MacroCallKind, MacroDefId, MacroDefKind,\n+    HirFileId, MacroCallId, MacroDefId, MacroDefKind,\n };\n use ra_cfg::CfgOptions;\n use ra_db::{CrateId, FileId};\n@@ -25,8 +25,9 @@ use crate::{\n     path::{ImportAlias, ModPath, PathKind},\n     per_ns::PerNs,\n     visibility::Visibility,\n-    AdtId, AstId, ConstLoc, ContainerId, EnumLoc, EnumVariantId, FunctionLoc, ImplLoc, Intern,\n-    LocalModuleId, ModuleDefId, ModuleId, StaticLoc, StructLoc, TraitLoc, TypeAliasLoc, UnionLoc,\n+    AdtId, AsMacroCall, AstId, AstIdWithPath, ConstLoc, ContainerId, EnumLoc, EnumVariantId,\n+    FunctionLoc, ImplLoc, Intern, LocalModuleId, ModuleDefId, ModuleId, StaticLoc, StructLoc,\n+    TraitLoc, TypeAliasLoc, UnionLoc,\n };\n \n pub(super) fn collect_defs(db: &impl DefDatabase, mut def_map: CrateDefMap) -> CrateDefMap {\n@@ -99,11 +100,16 @@ struct ImportDirective {\n #[derive(Clone, Debug, Eq, PartialEq)]\n struct MacroDirective {\n     module_id: LocalModuleId,\n-    ast_id: AstId<ast::MacroCall>,\n-    path: ModPath,\n+    ast_id: AstIdWithPath<ast::MacroCall>,\n     legacy: Option<MacroCallId>,\n }\n \n+#[derive(Clone, Debug, Eq, PartialEq)]\n+struct DeriveDirective {\n+    module_id: LocalModuleId,\n+    ast_id: AstIdWithPath<ast::ModuleItem>,\n+}\n+\n /// Walks the tree of module recursively\n struct DefCollector<'a, DB> {\n     db: &'a DB,\n@@ -112,7 +118,7 @@ struct DefCollector<'a, DB> {\n     unresolved_imports: Vec<ImportDirective>,\n     resolved_imports: Vec<ImportDirective>,\n     unexpanded_macros: Vec<MacroDirective>,\n-    unexpanded_attribute_macros: Vec<(LocalModuleId, AstId<ast::ModuleItem>, ModPath)>,\n+    unexpanded_attribute_macros: Vec<DeriveDirective>,\n     mod_dirs: FxHashMap<LocalModuleId, ModDir>,\n     cfg_options: &'a CfgOptions,\n }\n@@ -515,29 +521,28 @@ where\n                 return false;\n             }\n \n-            let resolved_res = self.def_map.resolve_path_fp_with_macro(\n-                self.db,\n-                ResolveMode::Other,\n-                directive.module_id,\n-                &directive.path,\n-                BuiltinShadowMode::Module,\n-            );\n-\n-            if let Some(def) = resolved_res.resolved_def.take_macros() {\n-                let call_id = def.as_call_id(self.db, MacroCallKind::FnLike(directive.ast_id));\n+            if let Some(call_id) = directive.ast_id.as_call_id(self.db, |path| {\n+                let resolved_res = self.def_map.resolve_path_fp_with_macro(\n+                    self.db,\n+                    ResolveMode::Other,\n+                    directive.module_id,\n+                    &path,\n+                    BuiltinShadowMode::Module,\n+                );\n+                resolved_res.resolved_def.take_macros()\n+            }) {\n                 resolved.push((directive.module_id, call_id));\n                 res = ReachedFixedPoint::No;\n                 return false;\n             }\n \n             true\n         });\n-        attribute_macros.retain(|(module_id, ast_id, path)| {\n-            let resolved_res = self.resolve_attribute_macro(path);\n-\n-            if let Some(def) = resolved_res {\n-                let call_id = def.as_call_id(self.db, MacroCallKind::Attr(*ast_id));\n-                resolved.push((*module_id, call_id));\n+        attribute_macros.retain(|directive| {\n+            if let Some(call_id) =\n+                directive.ast_id.as_call_id(self.db, |path| self.resolve_attribute_macro(&path))\n+            {\n+                resolved.push((directive.module_id, call_id));\n                 res = ReachedFixedPoint::No;\n                 return false;\n             }\n@@ -833,20 +838,22 @@ where\n                 };\n                 let path = ModPath::from_tt_ident(ident);\n \n-                let ast_id = AstId::new(self.file_id, def.kind.ast_id());\n-                self.def_collector.unexpanded_attribute_macros.push((self.module_id, ast_id, path));\n+                let ast_id = AstIdWithPath::new(self.file_id, def.kind.ast_id(), path);\n+                self.def_collector\n+                    .unexpanded_attribute_macros\n+                    .push(DeriveDirective { module_id: self.module_id, ast_id });\n             }\n         }\n     }\n \n     fn collect_macro(&mut self, mac: &raw::MacroData) {\n-        let ast_id = AstId::new(self.file_id, mac.ast_id);\n+        let mut ast_id = AstIdWithPath::new(self.file_id, mac.ast_id, mac.path.clone());\n \n         // Case 0: builtin macros\n         if mac.builtin {\n             if let Some(name) = &mac.name {\n                 let krate = self.def_collector.def_map.krate;\n-                if let Some(macro_id) = find_builtin_macro(name, krate, ast_id) {\n+                if let Some(macro_id) = find_builtin_macro(name, krate, ast_id.ast_id) {\n                     self.def_collector.define_macro(\n                         self.module_id,\n                         name.clone(),\n@@ -862,7 +869,7 @@ where\n         if is_macro_rules(&mac.path) {\n             if let Some(name) = &mac.name {\n                 let macro_id = MacroDefId {\n-                    ast_id: Some(ast_id),\n+                    ast_id: Some(ast_id.ast_id),\n                     krate: Some(self.def_collector.def_map.krate),\n                     kind: MacroDefKind::Declarative,\n                 };\n@@ -872,15 +879,13 @@ where\n         }\n \n         // Case 2: try to resolve in legacy scope and expand macro_rules\n-        if let Some(macro_def) = mac.path.as_ident().and_then(|name| {\n-            self.def_collector.def_map[self.module_id].scope.get_legacy_macro(&name)\n+        if let Some(macro_call_id) = ast_id.as_call_id(self.def_collector.db, |path| {\n+            path.as_ident().and_then(|name| {\n+                self.def_collector.def_map[self.module_id].scope.get_legacy_macro(&name)\n+            })\n         }) {\n-            let macro_call_id =\n-                macro_def.as_call_id(self.def_collector.db, MacroCallKind::FnLike(ast_id));\n-\n             self.def_collector.unexpanded_macros.push(MacroDirective {\n                 module_id: self.module_id,\n-                path: mac.path.clone(),\n                 ast_id,\n                 legacy: Some(macro_call_id),\n             });\n@@ -890,14 +895,12 @@ where\n \n         // Case 3: resolve in module scope, expand during name resolution.\n         // We rewrite simple path `macro_name` to `self::macro_name` to force resolve in module scope only.\n-        let mut path = mac.path.clone();\n-        if path.is_ident() {\n-            path.kind = PathKind::Super(0);\n+        if ast_id.path.is_ident() {\n+            ast_id.path.kind = PathKind::Super(0);\n         }\n \n         self.def_collector.unexpanded_macros.push(MacroDirective {\n             module_id: self.module_id,\n-            path,\n             ast_id,\n             legacy: None,\n         });"}]}