{"sha": "b590e3062ce20d551366d3f045d5637bd2c34e63", "node_id": "C_kwDOAAsO6NoAKGI1OTBlMzA2MmNlMjBkNTUxMzY2ZDNmMDQ1ZDU2MzdiZDJjMzRlNjM", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-04-20T19:08:06Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-04-27T20:03:19Z"}, "message": "Refactor generic collection.", "tree": {"sha": "3079bd273933b35e105d951cdd9dd13ef5aa2915", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3079bd273933b35e105d951cdd9dd13ef5aa2915"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b590e3062ce20d551366d3f045d5637bd2c34e63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b590e3062ce20d551366d3f045d5637bd2c34e63", "html_url": "https://github.com/rust-lang/rust/commit/b590e3062ce20d551366d3f045d5637bd2c34e63", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b590e3062ce20d551366d3f045d5637bd2c34e63/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6857a8d14e1eeddda1e575f0d124ba2e6dbae0eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/6857a8d14e1eeddda1e575f0d124ba2e6dbae0eb", "html_url": "https://github.com/rust-lang/rust/commit/6857a8d14e1eeddda1e575f0d124ba2e6dbae0eb"}], "stats": {"total": 93, "additions": 37, "deletions": 56}, "files": [{"sha": "7ae9709e4d61815c56b545e999b855ce9a5f2457", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b590e3062ce20d551366d3f045d5637bd2c34e63/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b590e3062ce20d551366d3f045d5637bd2c34e63/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=b590e3062ce20d551366d3f045d5637bd2c34e63", "patch": "@@ -299,7 +299,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         this.lower_maybe_async_body(span, &decl, asyncness, body.as_deref());\n \n                     let (generics, decl) =\n-                        this.add_in_band_defs(generics, fn_def_id, |this, idty| {\n+                        this.add_implicit_generics(generics, fn_def_id, |this, idty| {\n                             let ret_id = asyncness.opt_return_id();\n                             this.lower_fn_decl(&decl, Some((id, idty)), FnDeclKind::Fn, ret_id)\n                         });\n@@ -417,7 +417,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 // parent lifetime.\n                 let lowered_trait_def_id = hir_id.expect_owner();\n                 let (generics, (trait_ref, lowered_ty)) =\n-                    self.add_in_band_defs(ast_generics, lowered_trait_def_id, |this, _| {\n+                    self.add_implicit_generics(ast_generics, lowered_trait_def_id, |this, _| {\n                         let trait_ref = trait_ref.as_ref().map(|trait_ref| {\n                             this.lower_trait_ref(\n                                 trait_ref,\n@@ -743,7 +743,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 ForeignItemKind::Fn(box Fn { ref sig, ref generics, .. }) => {\n                     let fdec = &sig.decl;\n                     let (generics, (fn_dec, fn_args)) =\n-                        self.add_in_band_defs(generics, def_id, |this, _| {\n+                        self.add_implicit_generics(generics, def_id, |this, _| {\n                             (\n                                 // Disallow `impl Trait` in foreign items.\n                                 this.lower_fn_decl(fdec, None, FnDeclKind::ExternFn, None),\n@@ -1345,7 +1345,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     ) -> (hir::Generics<'hir>, hir::FnSig<'hir>) {\n         let fn_def_id = self.resolver.local_def_id(id);\n         let header = self.lower_fn_header(sig.header);\n-        let (generics, decl) = self.add_in_band_defs(generics, fn_def_id, |this, idty| {\n+        let (generics, decl) = self.add_implicit_generics(generics, fn_def_id, |this, idty| {\n             this.lower_fn_decl(&sig.decl, Some((id, idty)), kind, is_async)\n         });\n         (generics, hir::FnSig { header, decl, span: self.lower_span(sig.span) })"}, {"sha": "b9e6c2516e030d7802975b6b226554dc16d7583e", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 33, "deletions": 52, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/b590e3062ce20d551366d3f045d5637bd2c34e63/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b590e3062ce20d551366d3f045d5637bd2c34e63/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=b590e3062ce20d551366d3f045d5637bd2c34e63", "patch": "@@ -173,7 +173,7 @@ pub enum LifetimeRes {\n     Fresh {\n         /// Id of the generic parameter that introduced it.\n         param: LocalDefId,\n-        /// Id to create the HirId.\n+        /// Id to create the HirId.  This is used when creating the `Fresh` lifetime parameters.\n         introducer: Option<NodeId>,\n         /// Id of the introducing place. See `Param`.\n         binder: NodeId,\n@@ -693,27 +693,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         Ident::new(ident.name, self.lower_span(ident.span))\n     }\n \n-    /// Creates a new `hir::GenericParam` for every new lifetime and\n-    /// type parameter encountered while evaluating `f`. Definitions\n-    /// are created with the parent provided. If no `parent_id` is\n-    /// provided, no definitions will be returned.\n-    fn collect_in_band_defs<T>(\n-        &mut self,\n-        parent_def_id: LocalDefId,\n-        f: impl FnOnce(&mut Self) -> T,\n-    ) -> (FxIndexMap<NodeId, Span>, T) {\n-        let lifetime_stash = std::mem::take(&mut self.lifetimes_to_define);\n-        let was_collecting =\n-            std::mem::replace(&mut self.is_collecting_anonymous_lifetimes, Some(parent_def_id));\n-\n-        let res = f(self);\n-\n-        self.is_collecting_anonymous_lifetimes = was_collecting;\n-        let lifetimes_to_define = std::mem::replace(&mut self.lifetimes_to_define, lifetime_stash);\n-\n-        (lifetimes_to_define, res)\n-    }\n-\n     /// Converts a lifetime into a new generic parameter.\n     fn fresh_lifetime_to_generic_param(\n         &mut self,\n@@ -733,9 +712,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     /// Evaluates `f` with the lifetimes in `params` in-scope.\n-    /// This is used to track which lifetimes have already been defined, and\n-    /// which are new in-band lifetimes that need to have a definition created\n-    /// for them.\n+    /// This is used to track which lifetimes have already been defined,\n+    /// which need to be duplicated for async fns.\n     fn with_in_scope_lifetime_defs<T>(\n         &mut self,\n         params: &[GenericParam],\n@@ -758,37 +736,41 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         res\n     }\n \n-    /// Appends in-band lifetime defs and argument-position `impl\n-    /// Trait` defs to the existing set of generics.\n-    fn add_in_band_defs<T>(\n+    /// Creates a new `hir::GenericParam` for every new `Fresh` lifetime and\n+    /// universal `impl Trait` type parameter encountered while evaluating `f`.\n+    /// Definitions are created with the provided `parent_def_id`.\n+    fn add_implicit_generics<T>(\n         &mut self,\n         generics: &Generics,\n         parent_def_id: LocalDefId,\n         f: impl FnOnce(&mut Self, &mut Vec<hir::GenericParam<'hir>>) -> T,\n     ) -> (hir::Generics<'hir>, T) {\n-        let (lifetimes_to_define, (mut lowered_generics, impl_trait_defs, res)) = self\n-            .collect_in_band_defs(parent_def_id, |this| {\n-                this.with_in_scope_lifetime_defs(&generics.params, |this| {\n-                    let mut impl_trait_defs = Vec::new();\n-                    // Note: it is necessary to lower generics *before* calling `f`.\n-                    // When lowering `async fn`, there's a final step when lowering\n-                    // the return type that assumes that all in-scope lifetimes have\n-                    // already been added to either `in_scope_lifetimes` or\n-                    // `lifetimes_to_define`. If we swapped the order of these two,\n-                    // in-band-lifetimes introduced by generics or where-clauses\n-                    // wouldn't have been added yet.\n-                    let generics = this.lower_generics_mut(\n-                        generics,\n-                        ImplTraitContext::Universal(\n-                            &mut impl_trait_defs,\n-                            this.current_hir_id_owner,\n-                        ),\n-                    );\n-                    let res = f(this, &mut impl_trait_defs);\n-                    (generics, impl_trait_defs, res)\n-                })\n+        let lifetime_stash = std::mem::take(&mut self.lifetimes_to_define);\n+        let was_collecting =\n+            std::mem::replace(&mut self.is_collecting_anonymous_lifetimes, Some(parent_def_id));\n+\n+        let mut impl_trait_defs = Vec::new();\n+\n+        let (mut lowered_generics, res) =\n+            self.with_in_scope_lifetime_defs(&generics.params, |this| {\n+                // Note: it is necessary to lower generics *before* calling `f`.\n+                // When lowering `async fn`, there's a final step when lowering\n+                // the return type that assumes that all in-scope lifetimes have\n+                // already been added to either `in_scope_lifetimes` or\n+                // `lifetimes_to_define`. If we swapped the order of these two,\n+                // fresh lifetimes introduced by generics or where-clauses\n+                // wouldn't have been added yet.\n+                let generics = this.lower_generics_mut(\n+                    generics,\n+                    ImplTraitContext::Universal(&mut impl_trait_defs, this.current_hir_id_owner),\n+                );\n+                let res = f(this, &mut impl_trait_defs);\n+                (generics, res)\n             });\n \n+        self.is_collecting_anonymous_lifetimes = was_collecting;\n+        let lifetimes_to_define = std::mem::replace(&mut self.lifetimes_to_define, lifetime_stash);\n+\n         lowered_generics.params.extend(\n             lifetimes_to_define\n                 .into_iter()\n@@ -1700,15 +1682,14 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // Calculate all the lifetimes that should be captured\n         // by the opaque type. This should include all in-scope\n         // lifetime parameters, including those defined in-band.\n-        //\n \n         // Input lifetime like `'a`:\n         let mut captures = FxHashMap::default();\n         for &(p_name, def_id) in &self.in_scope_lifetimes {\n             let Ident { name, span } = p_name.ident();\n             let node_id = self.resolver.next_node_id();\n \n-            // Add a definition for the in-band lifetime def.\n+            // Add a definition for the in scope lifetime def.\n             self.resolver.create_def(\n                 opaque_ty_def_id,\n                 node_id,\n@@ -1735,7 +1716,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             let def_id = self.resolver.local_def_id(node_id);\n             let new_node_id = self.resolver.next_node_id();\n \n-            // Add a definition for the in-band lifetime def.\n+            // Add a definition for the `Fresh` lifetime def.\n             let new_def_id = self.resolver.create_def(\n                 opaque_ty_def_id,\n                 new_node_id,"}]}