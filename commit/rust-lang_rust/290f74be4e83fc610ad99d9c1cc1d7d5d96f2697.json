{"sha": "290f74be4e83fc610ad99d9c1cc1d7d5d96f2697", "node_id": "C_kwDOAAsO6NoAKDI5MGY3NGJlNGU4M2ZjNjEwYWQ5OWQ5YzFjYzFkN2Q1ZDk2ZjI2OTc", "commit": {"author": {"name": "Samuel E. Moelius III", "email": "sam@moeli.us", "date": "2021-11-30T10:52:01Z"}, "committer": {"name": "Samuel E. Moelius III", "email": "sam@moeli.us", "date": "2021-12-13T11:31:17Z"}, "message": "Address review comments\n\n* Share a list of methods with `implicit_clone`\n* Ensure no overlap with `redundant_clone`", "tree": {"sha": "7ff1faae8b56a6c9be726c80bcfcdc04488cddde", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7ff1faae8b56a6c9be726c80bcfcdc04488cddde"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/290f74be4e83fc610ad99d9c1cc1d7d5d96f2697", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/290f74be4e83fc610ad99d9c1cc1d7d5d96f2697", "html_url": "https://github.com/rust-lang/rust/commit/290f74be4e83fc610ad99d9c1cc1d7d5d96f2697", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/290f74be4e83fc610ad99d9c1cc1d7d5d96f2697/comments", "author": {"login": "smoelius", "id": 35515885, "node_id": "MDQ6VXNlcjM1NTE1ODg1", "avatar_url": "https://avatars.githubusercontent.com/u/35515885?v=4", "gravatar_id": "", "url": "https://api.github.com/users/smoelius", "html_url": "https://github.com/smoelius", "followers_url": "https://api.github.com/users/smoelius/followers", "following_url": "https://api.github.com/users/smoelius/following{/other_user}", "gists_url": "https://api.github.com/users/smoelius/gists{/gist_id}", "starred_url": "https://api.github.com/users/smoelius/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/smoelius/subscriptions", "organizations_url": "https://api.github.com/users/smoelius/orgs", "repos_url": "https://api.github.com/users/smoelius/repos", "events_url": "https://api.github.com/users/smoelius/events{/privacy}", "received_events_url": "https://api.github.com/users/smoelius/received_events", "type": "User", "site_admin": false}, "committer": {"login": "smoelius", "id": 35515885, "node_id": "MDQ6VXNlcjM1NTE1ODg1", "avatar_url": "https://avatars.githubusercontent.com/u/35515885?v=4", "gravatar_id": "", "url": "https://api.github.com/users/smoelius", "html_url": "https://github.com/smoelius", "followers_url": "https://api.github.com/users/smoelius/followers", "following_url": "https://api.github.com/users/smoelius/following{/other_user}", "gists_url": "https://api.github.com/users/smoelius/gists{/gist_id}", "starred_url": "https://api.github.com/users/smoelius/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/smoelius/subscriptions", "organizations_url": "https://api.github.com/users/smoelius/orgs", "repos_url": "https://api.github.com/users/smoelius/repos", "events_url": "https://api.github.com/users/smoelius/events{/privacy}", "received_events_url": "https://api.github.com/users/smoelius/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "468c86e4a3fa31b8c670422ea63875428e899b7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/468c86e4a3fa31b8c670422ea63875428e899b7f", "html_url": "https://github.com/rust-lang/rust/commit/468c86e4a3fa31b8c670422ea63875428e899b7f"}], "stats": {"total": 227, "additions": 160, "deletions": 67}, "files": [{"sha": "ff7904ce5822f3175cbb99d50fe1dd5b95c8cec0", "filename": "clippy_lints/src/methods/implicit_clone.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/290f74be4e83fc610ad99d9c1cc1d7d5d96f2697/clippy_lints%2Fsrc%2Fmethods%2Fimplicit_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/290f74be4e83fc610ad99d9c1cc1d7d5d96f2697/clippy_lints%2Fsrc%2Fmethods%2Fimplicit_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fimplicit_clone.rs?ref=290f74be4e83fc610ad99d9c1cc1d7d5d96f2697", "patch": "@@ -12,15 +12,7 @@ use super::IMPLICIT_CLONE;\n pub fn check(cx: &LateContext<'_>, method_name: &str, expr: &hir::Expr<'_>, recv: &hir::Expr<'_>, span: Span) {\n     if_chain! {\n         if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n-        if match method_name {\n-            \"to_os_string\" => is_diag_item_method(cx, method_def_id, sym::OsStr),\n-            \"to_owned\" => is_diag_trait_item(cx, method_def_id, sym::ToOwned),\n-            \"to_path_buf\" => is_diag_item_method(cx, method_def_id, sym::Path),\n-            \"to_vec\" => cx.tcx.impl_of_method(method_def_id)\n-                .map(|impl_did| Some(impl_did) == cx.tcx.lang_items().slice_alloc_impl())\n-                == Some(true),\n-            _ => false,\n-        };\n+        if is_clone_like(cx, method_name, method_def_id);\n         let return_type = cx.typeck_results().expr_ty(expr);\n         let input_type = cx.typeck_results().expr_ty(recv).peel_refs();\n         if let Some(ty_name) = input_type.ty_adt_def().map(|adt_def| cx.tcx.item_name(adt_def.did));\n@@ -38,3 +30,19 @@ pub fn check(cx: &LateContext<'_>, method_name: &str, expr: &hir::Expr<'_>, recv\n         }\n     }\n }\n+\n+/// Returns true if the named method can be used to clone the receiver.\n+pub fn is_clone_like(cx: &LateContext<'_>, method_name: &str, method_def_id: hir::def_id::DefId) -> bool {\n+    match method_name {\n+        \"to_os_string\" => is_diag_item_method(cx, method_def_id, sym::OsStr),\n+        \"to_owned\" => is_diag_trait_item(cx, method_def_id, sym::ToOwned),\n+        \"to_path_buf\" => is_diag_item_method(cx, method_def_id, sym::Path),\n+        \"to_vec\" => {\n+            cx.tcx\n+                .impl_of_method(method_def_id)\n+                .map(|impl_did| Some(impl_did) == cx.tcx.lang_items().slice_alloc_impl())\n+                == Some(true)\n+        },\n+        _ => false,\n+    }\n+}"}, {"sha": "b380f734bff8e01779e31e72db21762b6c768767", "filename": "clippy_lints/src/methods/unnecessary_to_owned.rs", "status": "modified", "additions": 50, "deletions": 26, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/290f74be4e83fc610ad99d9c1cc1d7d5d96f2697/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/290f74be4e83fc610ad99d9c1cc1d7d5d96f2697/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs?ref=290f74be4e83fc610ad99d9c1cc1d7d5d96f2697", "patch": "@@ -1,7 +1,8 @@\n+use super::implicit_clone::is_clone_like;\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::{implements_trait, is_copy, peel_mid_ty_refs};\n-use clippy_utils::{get_parent_expr, match_def_path, paths};\n+use clippy_utils::{get_parent_expr, is_diag_item_method, is_diag_trait_item};\n use rustc_errors::Applicability;\n use rustc_hir::{def_id::DefId, BorrowKind, Expr, ExprKind};\n use rustc_lint::LateContext;\n@@ -14,28 +15,17 @@ use std::cmp::max;\n \n use super::UNNECESSARY_TO_OWNED;\n \n-const TO_OWNED_LIKE_PATHS: &[&[&str]] = &[\n-    &paths::COW_INTO_OWNED,\n-    &paths::OS_STR_TO_OS_STRING,\n-    &paths::PATH_TO_PATH_BUF,\n-    &paths::SLICE_TO_VEC,\n-    &paths::TO_OWNED_METHOD,\n-    &paths::TO_STRING_METHOD,\n-];\n-\n pub fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>, method_name: Symbol, args: &'tcx [Expr<'tcx>]) {\n     if_chain! {\n         if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n-        if TO_OWNED_LIKE_PATHS\n-            .iter()\n-            .any(|path| match_def_path(cx, method_def_id, path));\n+        if is_to_owned_like(cx, method_name, method_def_id);\n         if let [receiver] = args;\n         then {\n             // At this point, we know the call is of a `to_owned`-like function. The functions\n             // `check_addr_of_expr` and `check_call_arg` determine whether the call is unnecessary\n             // based on its context, that is, whether it is a referent in an `AddrOf` expression or\n             // an argument in a function call.\n-            if check_addr_of_expr(cx, expr, method_name, receiver) {\n+            if check_addr_of_expr(cx, expr, method_name, method_def_id, receiver) {\n                 return;\n             }\n             check_call_arg(cx, expr, method_name, receiver);\n@@ -45,10 +35,12 @@ pub fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>, method_name: Symbol\n \n /// Checks whether `expr` is a referent in an `AddrOf` expression and, if so, determines whether its\n /// call of a `to_owned`-like function is unnecessary.\n+#[allow(clippy::too_many_lines)]\n fn check_addr_of_expr(\n     cx: &LateContext<'tcx>,\n     expr: &'tcx Expr<'tcx>,\n     method_name: Symbol,\n+    method_def_id: DefId,\n     receiver: &'tcx Expr<'tcx>,\n ) -> bool {\n     if_chain! {\n@@ -100,14 +92,17 @@ fn check_addr_of_expr(\n             ] => Some(target_ty),\n             _ => None,\n         };\n+        let receiver_ty = cx.typeck_results().expr_ty(receiver);\n+        // Only flag cases where the receiver is copyable or the method is `Cow::into_owned`. This\n+        // restriction is to ensure there is not overlap between `redundant_clone` and this lint.\n+        if is_copy(cx, receiver_ty) || is_cow_into_owned(cx, method_name, method_def_id);\n+        if let Some(receiver_snippet) = snippet_opt(cx, receiver.span);\n         then {\n             let (target_ty, n_target_refs) = peel_mid_ty_refs(target_ty);\n-            let receiver_ty = cx.typeck_results().expr_ty(receiver);\n             let (receiver_ty, n_receiver_refs) = peel_mid_ty_refs(receiver_ty);\n             if_chain! {\n                 if receiver_ty == target_ty;\n                 if n_target_refs >= n_receiver_refs;\n-                if let Some(receiver_snippet) = snippet_opt(cx, receiver.span);\n                 then {\n                     span_lint_and_sugg(\n                         cx,\n@@ -122,21 +117,32 @@ fn check_addr_of_expr(\n                 }\n             }\n             if implements_deref_trait(cx, receiver_ty, target_ty) {\n-                span_lint_and_sugg(\n-                    cx,\n-                    UNNECESSARY_TO_OWNED,\n-                    expr.span.with_lo(receiver.span.hi()),\n-                    &format!(\"unnecessary use of `{}`\", method_name),\n-                    \"remove this\",\n-                    String::new(),\n-                    Applicability::MachineApplicable,\n-                );\n+                if n_receiver_refs > 0 {\n+                    span_lint_and_sugg(\n+                        cx,\n+                        UNNECESSARY_TO_OWNED,\n+                        parent.span,\n+                        &format!(\"unnecessary use of `{}`\", method_name),\n+                        \"use\",\n+                        receiver_snippet,\n+                        Applicability::MachineApplicable,\n+                    );\n+                } else {\n+                    span_lint_and_sugg(\n+                        cx,\n+                        UNNECESSARY_TO_OWNED,\n+                        expr.span.with_lo(receiver.span.hi()),\n+                        &format!(\"unnecessary use of `{}`\", method_name),\n+                        \"remove this\",\n+                        String::new(),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n                 return true;\n             }\n             if_chain! {\n                 if let Some(as_ref_trait_id) = cx.tcx.get_diagnostic_item(sym::AsRef);\n                 if implements_trait(cx, receiver_ty, as_ref_trait_id, &[GenericArg::from(target_ty)]);\n-                if let Some(receiver_snippet) = snippet_opt(cx, receiver.span);\n                 then {\n                     span_lint_and_sugg(\n                         cx,\n@@ -326,3 +332,21 @@ fn implements_deref_trait(cx: &LateContext<'tcx>, ty: Ty<'tcx>, deref_target_ty:\n         }\n     }\n }\n+\n+/// Returns true if the named method can be used to convert the receiver to its \"owned\"\n+/// representation.\n+fn is_to_owned_like(cx: &LateContext<'_>, method_name: Symbol, method_def_id: DefId) -> bool {\n+    is_clone_like(cx, &*method_name.as_str(), method_def_id)\n+        || is_cow_into_owned(cx, method_name, method_def_id)\n+        || is_to_string(cx, method_name, method_def_id)\n+}\n+\n+/// Returns true if the named method is `Cow::into_owned`.\n+fn is_cow_into_owned(cx: &LateContext<'_>, method_name: Symbol, method_def_id: DefId) -> bool {\n+    method_name.as_str() == \"into_owned\" && is_diag_item_method(cx, method_def_id, sym::Cow)\n+}\n+\n+/// Returns true if the named method is `ToString::to_string`.\n+fn is_to_string(cx: &LateContext<'_>, method_name: Symbol, method_def_id: DefId) -> bool {\n+    method_name.as_str() == \"to_string\" && is_diag_trait_item(cx, method_def_id, sym::ToString)\n+}"}, {"sha": "6171823abbbd04fa7142aecaad1231c654150ff2", "filename": "clippy_utils/src/paths.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/290f74be4e83fc610ad99d9c1cc1d7d5d96f2697/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/290f74be4e83fc610ad99d9c1cc1d7d5d96f2697/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=290f74be4e83fc610ad99d9c1cc1d7d5d96f2697", "patch": "@@ -36,7 +36,6 @@ pub const CLONE_TRAIT_METHOD: [&str; 4] = [\"core\", \"clone\", \"Clone\", \"clone\"];\n pub const CMP_MAX: [&str; 3] = [\"core\", \"cmp\", \"max\"];\n pub const CMP_MIN: [&str; 3] = [\"core\", \"cmp\", \"min\"];\n pub const COW: [&str; 3] = [\"alloc\", \"borrow\", \"Cow\"];\n-pub const COW_INTO_OWNED: [&str; 4] = [\"alloc\", \"borrow\", \"Cow\", \"into_owned\"];\n pub const CSTRING_AS_C_STR: [&str; 5] = [\"std\", \"ffi\", \"c_str\", \"CString\", \"as_c_str\"];\n pub const DEFAULT_TRAIT_METHOD: [&str; 4] = [\"core\", \"default\", \"Default\", \"default\"];\n pub const DEREF_MUT_TRAIT_METHOD: [&str; 5] = [\"core\", \"ops\", \"deref\", \"DerefMut\", \"deref_mut\"];\n@@ -171,7 +170,6 @@ pub const SLICE_FROM_RAW_PARTS: [&str; 4] = [\"core\", \"slice\", \"raw\", \"from_raw_p\n pub const SLICE_FROM_RAW_PARTS_MUT: [&str; 4] = [\"core\", \"slice\", \"raw\", \"from_raw_parts_mut\"];\n pub const SLICE_INTO_VEC: [&str; 4] = [\"alloc\", \"slice\", \"<impl [T]>\", \"into_vec\"];\n pub const SLICE_ITER: [&str; 4] = [\"core\", \"slice\", \"iter\", \"Iter\"];\n-pub const SLICE_TO_VEC: [&str; 4] = [\"alloc\", \"slice\", \"<impl [T]>\", \"to_vec\"];\n pub const STDERR: [&str; 4] = [\"std\", \"io\", \"stdio\", \"stderr\"];\n pub const STDOUT: [&str; 4] = [\"std\", \"io\", \"stdio\", \"stdout\"];\n pub const CONVERT_IDENTITY: [&str; 3] = [\"core\", \"convert\", \"identity\"];"}, {"sha": "bd9ef1fff42fde9a5b205a8a18ac1a1272358913", "filename": "tests/ui/unnecessary_to_owned.fixed", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/290f74be4e83fc610ad99d9c1cc1d7d5d96f2697/tests%2Fui%2Funnecessary_to_owned.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/290f74be4e83fc610ad99d9c1cc1d7d5d96f2697/tests%2Fui%2Funnecessary_to_owned.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_to_owned.fixed?ref=290f74be4e83fc610ad99d9c1cc1d7d5d96f2697", "patch": "@@ -1,15 +1,14 @@\n // run-rustfix\n \n #![allow(clippy::ptr_arg)]\n-// Some of the expressions that `redundant_clone` flags overlap with ours. Enabling it interferes\n-// with `rustfix`.\n-#![allow(clippy::redundant_clone)]\n-// `needless_borrow` is for checking the fixed code.\n+// `needless_borrow` is to ensure there are no needles borrows in the fixed code.\n #![warn(clippy::needless_borrow)]\n+// `redundant_clone` is to ensure there is no overlap between that lint and this one.\n+#![warn(clippy::redundant_clone)]\n #![warn(clippy::unnecessary_to_owned)]\n \n use std::borrow::Cow;\n-use std::ffi::{CStr, OsStr};\n+use std::ffi::{CStr, CString, OsStr, OsString};\n use std::ops::Deref;\n \n #[derive(Clone)]\n@@ -51,6 +50,7 @@ fn main() {\n     let array_ref = &[\"x\"];\n     let slice = &[\"x\"][..];\n     let x = X(String::from(\"x\"));\n+    let x_ref = &x;\n \n     require_c_str(&Cow::from(c_str));\n     require_c_str(c_str);\n@@ -66,17 +66,17 @@ fn main() {\n     require_str(s);\n     require_str(&Cow::from(s));\n     require_str(s);\n-    require_str(x.as_ref());\n+    require_str(x_ref.as_ref());\n \n     require_slice(slice);\n     require_slice(&Cow::from(slice));\n     require_slice(array.as_ref());\n     require_slice(array_ref.as_ref());\n     require_slice(slice);\n-    require_slice(&x);\n+    require_slice(x_ref);\n \n     require_x(&Cow::<X>::Owned(x.clone()));\n-    require_x(&x);\n+    require_x(x_ref);\n \n     require_deref_c_str(c_str);\n     require_deref_os_str(os_str);\n@@ -118,16 +118,23 @@ fn main() {\n     require_as_ref_slice_str(array_ref, s);\n     require_as_ref_slice_str(slice, s);\n \n-    let _ = x.join(&x);\n+    let _ = x.join(x_ref);\n \n     // negative tests\n     require_string(&s.to_string());\n     require_string(&Cow::from(s).into_owned());\n     require_string(&s.to_owned());\n-    require_string(&x.to_string());\n+    require_string(&x_ref.to_string());\n \n     // `X` isn't copy.\n+    require_slice(&x.to_owned());\n     require_deref_slice(x.to_owned());\n+\n+    // The following should be flagged by `redundant_clone`, but not by this lint.\n+    require_c_str(&CString::from_vec_with_nul(vec![0]).unwrap());\n+    require_os_str(&OsString::from(\"x\"));\n+    require_path(&std::path::PathBuf::from(\"x\"));\n+    require_str(&String::from(\"x\"));\n }\n \n fn require_c_str(_: &CStr) {}"}, {"sha": "1bf30e2289361cdde8ea3803361a089dc6024b4c", "filename": "tests/ui/unnecessary_to_owned.rs", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/290f74be4e83fc610ad99d9c1cc1d7d5d96f2697/tests%2Fui%2Funnecessary_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/290f74be4e83fc610ad99d9c1cc1d7d5d96f2697/tests%2Fui%2Funnecessary_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_to_owned.rs?ref=290f74be4e83fc610ad99d9c1cc1d7d5d96f2697", "patch": "@@ -1,15 +1,14 @@\n // run-rustfix\n \n #![allow(clippy::ptr_arg)]\n-// Some of the expressions that `redundant_clone` flags overlap with ours. Enabling it interferes\n-// with `rustfix`.\n-#![allow(clippy::redundant_clone)]\n-// `needless_borrow` is for checking the fixed code.\n+// `needless_borrow` is to ensure there are no needles borrows in the fixed code.\n #![warn(clippy::needless_borrow)]\n+// `redundant_clone` is to ensure there is no overlap between that lint and this one.\n+#![warn(clippy::redundant_clone)]\n #![warn(clippy::unnecessary_to_owned)]\n \n use std::borrow::Cow;\n-use std::ffi::{CStr, OsStr};\n+use std::ffi::{CStr, CString, OsStr, OsString};\n use std::ops::Deref;\n \n #[derive(Clone)]\n@@ -51,6 +50,7 @@ fn main() {\n     let array_ref = &[\"x\"];\n     let slice = &[\"x\"][..];\n     let x = X(String::from(\"x\"));\n+    let x_ref = &x;\n \n     require_c_str(&Cow::from(c_str).into_owned());\n     require_c_str(&c_str.to_owned());\n@@ -66,17 +66,17 @@ fn main() {\n     require_str(&s.to_string());\n     require_str(&Cow::from(s).into_owned());\n     require_str(&s.to_owned());\n-    require_str(&x.to_string());\n+    require_str(&x_ref.to_string());\n \n     require_slice(&slice.to_vec());\n     require_slice(&Cow::from(slice).into_owned());\n     require_slice(&array.to_owned());\n     require_slice(&array_ref.to_owned());\n     require_slice(&slice.to_owned());\n-    require_slice(&x.to_owned());\n+    require_slice(&x_ref.to_owned());\n \n     require_x(&Cow::<X>::Owned(x.clone()).into_owned());\n-    require_x(&x.to_owned());\n+    require_x(&x_ref.to_owned());\n \n     require_deref_c_str(c_str.to_owned());\n     require_deref_os_str(os_str.to_owned());\n@@ -118,16 +118,23 @@ fn main() {\n     require_as_ref_slice_str(array_ref.to_owned(), s.to_owned());\n     require_as_ref_slice_str(slice.to_owned(), s.to_owned());\n \n-    let _ = x.join(&x.to_string());\n+    let _ = x.join(&x_ref.to_string());\n \n     // negative tests\n     require_string(&s.to_string());\n     require_string(&Cow::from(s).into_owned());\n     require_string(&s.to_owned());\n-    require_string(&x.to_string());\n+    require_string(&x_ref.to_string());\n \n     // `X` isn't copy.\n+    require_slice(&x.to_owned());\n     require_deref_slice(x.to_owned());\n+\n+    // The following should be flagged by `redundant_clone`, but not by this lint.\n+    require_c_str(&CString::from_vec_with_nul(vec![0]).unwrap().to_owned());\n+    require_os_str(&OsString::from(\"x\").to_os_string());\n+    require_path(&std::path::PathBuf::from(\"x\").to_path_buf());\n+    require_str(&String::from(\"x\").to_string());\n }\n \n fn require_c_str(_: &CStr) {}"}, {"sha": "83cc53ef3a2a599668d2dbf4e6e26b9c382304b0", "filename": "tests/ui/unnecessary_to_owned.stderr", "status": "modified", "additions": 59, "deletions": 10, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/290f74be4e83fc610ad99d9c1cc1d7d5d96f2697/tests%2Fui%2Funnecessary_to_owned.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/290f74be4e83fc610ad99d9c1cc1d7d5d96f2697/tests%2Fui%2Funnecessary_to_owned.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_to_owned.stderr?ref=290f74be4e83fc610ad99d9c1cc1d7d5d96f2697", "patch": "@@ -1,3 +1,52 @@\n+error: redundant clone\n+  --> $DIR/unnecessary_to_owned.rs:134:64\n+   |\n+LL |     require_c_str(&CString::from_vec_with_nul(vec![0]).unwrap().to_owned());\n+   |                                                                ^^^^^^^^^^^ help: remove this\n+   |\n+   = note: `-D clippy::redundant-clone` implied by `-D warnings`\n+note: this value is dropped without further use\n+  --> $DIR/unnecessary_to_owned.rs:134:20\n+   |\n+LL |     require_c_str(&CString::from_vec_with_nul(vec![0]).unwrap().to_owned());\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: redundant clone\n+  --> $DIR/unnecessary_to_owned.rs:135:40\n+   |\n+LL |     require_os_str(&OsString::from(\"x\").to_os_string());\n+   |                                        ^^^^^^^^^^^^^^^ help: remove this\n+   |\n+note: this value is dropped without further use\n+  --> $DIR/unnecessary_to_owned.rs:135:21\n+   |\n+LL |     require_os_str(&OsString::from(\"x\").to_os_string());\n+   |                     ^^^^^^^^^^^^^^^^^^^\n+\n+error: redundant clone\n+  --> $DIR/unnecessary_to_owned.rs:136:48\n+   |\n+LL |     require_path(&std::path::PathBuf::from(\"x\").to_path_buf());\n+   |                                                ^^^^^^^^^^^^^^ help: remove this\n+   |\n+note: this value is dropped without further use\n+  --> $DIR/unnecessary_to_owned.rs:136:19\n+   |\n+LL |     require_path(&std::path::PathBuf::from(\"x\").to_path_buf());\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: redundant clone\n+  --> $DIR/unnecessary_to_owned.rs:137:35\n+   |\n+LL |     require_str(&String::from(\"x\").to_string());\n+   |                                   ^^^^^^^^^^^^ help: remove this\n+   |\n+note: this value is dropped without further use\n+  --> $DIR/unnecessary_to_owned.rs:137:18\n+   |\n+LL |     require_str(&String::from(\"x\").to_string());\n+   |                  ^^^^^^^^^^^^^^^^^\n+\n error: unnecessary use of `into_owned`\n   --> $DIR/unnecessary_to_owned.rs:55:36\n    |\n@@ -69,8 +118,8 @@ LL |     require_str(&s.to_owned());\n error: unnecessary use of `to_string`\n   --> $DIR/unnecessary_to_owned.rs:69:17\n    |\n-LL |     require_str(&x.to_string());\n-   |                 ^^^^^^^^^^^^^^ help: use: `x.as_ref()`\n+LL |     require_str(&x_ref.to_string());\n+   |                 ^^^^^^^^^^^^^^^^^^ help: use: `x_ref.as_ref()`\n \n error: unnecessary use of `to_vec`\n   --> $DIR/unnecessary_to_owned.rs:71:19\n@@ -103,10 +152,10 @@ LL |     require_slice(&slice.to_owned());\n    |                   ^^^^^^^^^^^^^^^^^ help: use: `slice`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:76:21\n+  --> $DIR/unnecessary_to_owned.rs:76:19\n    |\n-LL |     require_slice(&x.to_owned());\n-   |                     ^^^^^^^^^^^ help: remove this\n+LL |     require_slice(&x_ref.to_owned());\n+   |                   ^^^^^^^^^^^^^^^^^ help: use: `x_ref`\n \n error: unnecessary use of `into_owned`\n   --> $DIR/unnecessary_to_owned.rs:78:42\n@@ -117,8 +166,8 @@ LL |     require_x(&Cow::<X>::Owned(x.clone()).into_owned());\n error: unnecessary use of `to_owned`\n   --> $DIR/unnecessary_to_owned.rs:79:15\n    |\n-LL |     require_x(&x.to_owned());\n-   |               ^^^^^^^^^^^^^ help: use: `&x`\n+LL |     require_x(&x_ref.to_owned());\n+   |               ^^^^^^^^^^^^^^^^^ help: use: `x_ref`\n \n error: unnecessary use of `to_owned`\n   --> $DIR/unnecessary_to_owned.rs:81:25\n@@ -375,8 +424,8 @@ LL |     require_as_ref_slice_str(slice.to_owned(), s.to_owned());\n error: unnecessary use of `to_string`\n   --> $DIR/unnecessary_to_owned.rs:121:20\n    |\n-LL |     let _ = x.join(&x.to_string());\n-   |                    ^^^^^^^^^^^^^^ help: use: `&x`\n+LL |     let _ = x.join(&x_ref.to_string());\n+   |                    ^^^^^^^^^^^^^^^^^^ help: use: `x_ref`\n \n-error: aborting due to 63 previous errors\n+error: aborting due to 67 previous errors\n "}]}