{"sha": "c8b2ec8c20be44ae19d15e90ff812745f029899e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4YjJlYzhjMjBiZTQ0YWUxOWQxNWU5MGZmODEyNzQ1ZjAyOTg5OWU=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2020-04-12T10:28:24Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2020-04-13T13:57:28Z"}, "message": "Add support for bounds on associated types in trait definitions\n\nE.g.\n```\ntrait Trait {\n    type Item: SomeOtherTrait;\n}\n```\nNote that these don't simply desugar to where clauses; as I understand it, where\nclauses have to be proved by the *user* of the trait, but these bounds are proved\nby the *implementor*. (Also, where clauses on associated types are unstable.)", "tree": {"sha": "98ed585238a37d722159a489db24e0514ae562ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/98ed585238a37d722159a489db24e0514ae562ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c8b2ec8c20be44ae19d15e90ff812745f029899e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c8b2ec8c20be44ae19d15e90ff812745f029899e", "html_url": "https://github.com/rust-lang/rust/commit/c8b2ec8c20be44ae19d15e90ff812745f029899e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c8b2ec8c20be44ae19d15e90ff812745f029899e/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c388130f5ffbcbe7d3131213a24d12d02f769b87", "url": "https://api.github.com/repos/rust-lang/rust/commits/c388130f5ffbcbe7d3131213a24d12d02f769b87", "html_url": "https://github.com/rust-lang/rust/commit/c388130f5ffbcbe7d3131213a24d12d02f769b87"}], "stats": {"total": 124, "additions": 113, "deletions": 11}, "files": [{"sha": "5dfde75d93e6c4ca123da8078656b2f64f247835", "filename": "crates/ra_hir_def/src/data.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c8b2ec8c20be44ae19d15e90ff812745f029899e/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8b2ec8c20be44ae19d15e90ff812745f029899e/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdata.rs?ref=c8b2ec8c20be44ae19d15e90ff812745f029899e", "patch": "@@ -9,7 +9,8 @@ use hir_expand::{\n };\n use ra_prof::profile;\n use ra_syntax::ast::{\n-    self, AstNode, ImplItem, ModuleItemOwner, NameOwner, TypeAscriptionOwner, VisibilityOwner,\n+    self, AstNode, ImplItem, ModuleItemOwner, NameOwner, TypeAscriptionOwner, TypeBoundsOwner,\n+    VisibilityOwner,\n };\n \n use crate::{\n@@ -106,6 +107,7 @@ pub struct TypeAliasData {\n     pub name: Name,\n     pub type_ref: Option<TypeRef>,\n     pub visibility: RawVisibility,\n+    pub bounds: Vec<TypeBound>,\n }\n \n impl TypeAliasData {\n@@ -118,9 +120,17 @@ impl TypeAliasData {\n         let name = node.value.name().map_or_else(Name::missing, |n| n.as_name());\n         let type_ref = node.value.type_ref().map(TypeRef::from_ast);\n         let vis_default = RawVisibility::default_for_container(loc.container);\n-        let visibility =\n-            RawVisibility::from_ast_with_default(db, vis_default, node.map(|n| n.visibility()));\n-        Arc::new(TypeAliasData { name, type_ref, visibility })\n+        let visibility = RawVisibility::from_ast_with_default(\n+            db,\n+            vis_default,\n+            node.as_ref().map(|n| n.visibility()),\n+        );\n+        let bounds = if let Some(bound_list) = node.value.type_bound_list() {\n+            bound_list.bounds().map(TypeBound::from_ast).collect()\n+        } else {\n+            Vec::new()\n+        };\n+        Arc::new(TypeAliasData { name, type_ref, visibility, bounds })\n     }\n }\n "}, {"sha": "af8c63d64f406460033194700de73986aea6a49b", "filename": "crates/ra_hir_ty/src/tests/traits.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c8b2ec8c20be44ae19d15e90ff812745f029899e/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8b2ec8c20be44ae19d15e90ff812745f029899e/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=c8b2ec8c20be44ae19d15e90ff812745f029899e", "patch": "@@ -2022,6 +2022,33 @@ fn main() {\n     );\n }\n \n+#[test]\n+fn associated_type_bound() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+pub trait Trait {\n+    type Item: OtherTrait<u32>;\n+}\n+pub trait OtherTrait<T> {\n+    fn foo(&self) -> T;\n+}\n+\n+// this is just a workaround for chalk#234\n+pub struct S<T>;\n+impl<T: Trait> Trait for S<T> {\n+    type Item = <T as Trait>::Item;\n+}\n+\n+fn test<T: Trait>() {\n+    let y: <S<T> as Trait>::Item = no_matter;\n+    y.foo()<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"u32\");\n+}\n+\n #[test]\n fn dyn_trait_through_chalk() {\n     let t = type_at("}, {"sha": "44fbdb19701594c3eefd87876d44338b42a559f5", "filename": "crates/ra_hir_ty/src/traits.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c8b2ec8c20be44ae19d15e90ff812745f029899e/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8b2ec8c20be44ae19d15e90ff812745f029899e/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs?ref=c8b2ec8c20be44ae19d15e90ff812745f029899e", "patch": "@@ -194,13 +194,16 @@ fn solve(\n         }\n         remaining > 0\n     };\n-    let mut solve = || solver.solve_limited(&context, goal, should_continue);\n+    let mut solve = || {\n+        let solution = solver.solve_limited(&context, goal, should_continue);\n+        log::debug!(\"solve({:?}) => {:?}\", goal, solution);\n+        solution\n+    };\n     // don't set the TLS for Chalk unless Chalk debugging is active, to make\n     // extra sure we only use it for debugging\n     let solution =\n         if is_chalk_debug() { chalk::tls::set_current_program(db, solve) } else { solve() };\n \n-    log::debug!(\"solve({:?}) => {:?}\", goal, solution);\n     solution\n }\n "}, {"sha": "12ffa69a00659475cf666ee27dd5e337f7adfe74", "filename": "crates/ra_hir_ty/src/traits/chalk.rs", "status": "modified", "additions": 67, "deletions": 5, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/c8b2ec8c20be44ae19d15e90ff812745f029899e/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8b2ec8c20be44ae19d15e90ff812745f029899e/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=c8b2ec8c20be44ae19d15e90ff812745f029899e", "patch": "@@ -626,6 +626,55 @@ fn convert_where_clauses(\n     result\n }\n \n+fn generic_predicate_to_inline_bound(\n+    db: &dyn HirDatabase,\n+    pred: &GenericPredicate,\n+    self_ty: &Ty,\n+) -> Option<chalk_rust_ir::InlineBound<Interner>> {\n+    // An InlineBound is like a GenericPredicate, except the self type is left out.\n+    // We don't have a special type for this, but Chalk does.\n+    match pred {\n+        GenericPredicate::Implemented(trait_ref) => {\n+            if &trait_ref.substs[0] != self_ty {\n+                // we can only convert predicates back to type bounds if they\n+                // have the expected self type\n+                return None;\n+            }\n+            let args_no_self = trait_ref.substs[1..]\n+                .iter()\n+                .map(|ty| ty.clone().to_chalk(db).cast(&Interner))\n+                .collect();\n+            let trait_bound =\n+                chalk_rust_ir::TraitBound { trait_id: trait_ref.trait_.to_chalk(db), args_no_self };\n+            Some(chalk_rust_ir::InlineBound::TraitBound(trait_bound))\n+        }\n+        GenericPredicate::Projection(proj) => {\n+            if &proj.projection_ty.parameters[0] != self_ty {\n+                return None;\n+            }\n+            let trait_ = match proj.projection_ty.associated_ty.lookup(db.upcast()).container {\n+                AssocContainerId::TraitId(t) => t,\n+                _ => panic!(\"associated type not in trait\"),\n+            };\n+            let args_no_self = proj.projection_ty.parameters[1..]\n+                .iter()\n+                .map(|ty| ty.clone().to_chalk(db).cast(&Interner))\n+                .collect();\n+            let alias_eq_bound = chalk_rust_ir::AliasEqBound {\n+                value: proj.ty.clone().to_chalk(db),\n+                trait_bound: chalk_rust_ir::TraitBound {\n+                    trait_id: trait_.to_chalk(db),\n+                    args_no_self,\n+                },\n+                associated_ty_id: proj.projection_ty.associated_ty.to_chalk(db),\n+                parameters: Vec::new(), // FIXME we don't support generic associated types yet\n+            };\n+            Some(chalk_rust_ir::InlineBound::AliasEqBound(alias_eq_bound))\n+        }\n+        GenericPredicate::Error => None,\n+    }\n+}\n+\n impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n     fn associated_ty_data(&self, id: AssocTypeId) -> Arc<AssociatedTyDatum> {\n         self.db.associated_ty_data(id)\n@@ -708,12 +757,25 @@ pub(crate) fn associated_ty_data_query(\n         AssocContainerId::TraitId(t) => t,\n         _ => panic!(\"associated type not in trait\"),\n     };\n+\n+    // Lower bounds -- we could/should maybe move this to a separate query in `lower`\n+    let type_alias_data = db.type_alias_data(type_alias);\n     let generic_params = generics(db.upcast(), type_alias.into());\n-    let bound_data = chalk_rust_ir::AssociatedTyDatumBound {\n-        // FIXME add bounds and where clauses\n-        bounds: vec![],\n-        where_clauses: vec![],\n-    };\n+    let bound_vars = Substs::bound_vars(&generic_params);\n+    let resolver = hir_def::resolver::HasResolver::resolver(type_alias, db.upcast());\n+    let ctx = crate::TyLoweringContext::new(db, &resolver)\n+        .with_type_param_mode(crate::lower::TypeParamLoweringMode::Variable);\n+    let self_ty = Ty::Bound(crate::BoundVar::new(crate::DebruijnIndex::INNERMOST, 0));\n+    let bounds = type_alias_data\n+        .bounds\n+        .iter()\n+        .flat_map(|bound| GenericPredicate::from_type_bound(&ctx, bound, self_ty.clone()))\n+        .filter_map(|pred| generic_predicate_to_inline_bound(db, &pred, &self_ty))\n+        .map(|bound| make_binders(bound.shifted_in(&Interner), 0))\n+        .collect();\n+\n+    let where_clauses = convert_where_clauses(db, type_alias.into(), &bound_vars);\n+    let bound_data = chalk_rust_ir::AssociatedTyDatumBound { bounds, where_clauses };\n     let datum = AssociatedTyDatum {\n         trait_id: trait_.to_chalk(db),\n         id,"}]}