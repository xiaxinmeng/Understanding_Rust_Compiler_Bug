{"sha": "64548250e7c740d0376d638214df65fb2ace35f1", "node_id": "C_kwDOAAsO6NoAKDY0NTQ4MjUwZTdjNzQwZDAzNzZkNjM4MjE0ZGY2NWZiMmFjZTM1ZjE", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-02-06T18:53:51Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-02-07T17:20:18Z"}, "message": "Split out `match_same_arms`", "tree": {"sha": "d7e5e1dff6131d6dcea26ea3d6f723fdce124ae1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d7e5e1dff6131d6dcea26ea3d6f723fdce124ae1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64548250e7c740d0376d638214df65fb2ace35f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64548250e7c740d0376d638214df65fb2ace35f1", "html_url": "https://github.com/rust-lang/rust/commit/64548250e7c740d0376d638214df65fb2ace35f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64548250e7c740d0376d638214df65fb2ace35f1/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e41a6fc042cdd40f415eba4288d5c5e1161266b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/e41a6fc042cdd40f415eba4288d5c5e1161266b1", "html_url": "https://github.com/rust-lang/rust/commit/e41a6fc042cdd40f415eba4288d5c5e1161266b1"}], "stats": {"total": 232, "additions": 119, "deletions": 113}, "files": [{"sha": "7efbd540fdb4d0b1b72e7a435216731015d5eb67", "filename": "clippy_lints/src/matches/match_same_arms.rs", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/64548250e7c740d0376d638214df65fb2ace35f1/clippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64548250e7c740d0376d638214df65fb2ace35f1/clippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs?ref=64548250e7c740d0376d638214df65fb2ace35f1", "patch": "@@ -0,0 +1,112 @@\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::source::snippet;\n+use clippy_utils::{path_to_local, search_same, SpanlessEq, SpanlessHash};\n+use rustc_hir::{Arm, Expr, ExprKind, HirId, HirIdMap, HirIdSet, MatchSource, Pat, PatKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::TyS;\n+use std::collections::hash_map::Entry;\n+\n+use super::MATCH_SAME_ARMS;\n+\n+pub(crate) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) {\n+    if let ExprKind::Match(_, arms, MatchSource::Normal) = expr.kind {\n+        let hash = |&(_, arm): &(usize, &Arm<'_>)| -> u64 {\n+            let mut h = SpanlessHash::new(cx);\n+            h.hash_expr(arm.body);\n+            h.finish()\n+        };\n+\n+        let eq = |&(lindex, lhs): &(usize, &Arm<'_>), &(rindex, rhs): &(usize, &Arm<'_>)| -> bool {\n+            let min_index = usize::min(lindex, rindex);\n+            let max_index = usize::max(lindex, rindex);\n+\n+            let mut local_map: HirIdMap<HirId> = HirIdMap::default();\n+            let eq_fallback = |a: &Expr<'_>, b: &Expr<'_>| {\n+                if_chain! {\n+                    if let Some(a_id) = path_to_local(a);\n+                    if let Some(b_id) = path_to_local(b);\n+                    let entry = match local_map.entry(a_id) {\n+                        Entry::Vacant(entry) => entry,\n+                        // check if using the same bindings as before\n+                        Entry::Occupied(entry) => return *entry.get() == b_id,\n+                    };\n+                    // the names technically don't have to match; this makes the lint more conservative\n+                    if cx.tcx.hir().name(a_id) == cx.tcx.hir().name(b_id);\n+                    if TyS::same_type(cx.typeck_results().expr_ty(a), cx.typeck_results().expr_ty(b));\n+                    if pat_contains_local(lhs.pat, a_id);\n+                    if pat_contains_local(rhs.pat, b_id);\n+                    then {\n+                        entry.insert(b_id);\n+                        true\n+                    } else {\n+                        false\n+                    }\n+                }\n+            };\n+            // Arms with a guard are ignored, those can\u2019t always be merged together\n+            // This is also the case for arms in-between each there is an arm with a guard\n+            (min_index..=max_index).all(|index| arms[index].guard.is_none())\n+                && SpanlessEq::new(cx)\n+                    .expr_fallback(eq_fallback)\n+                    .eq_expr(lhs.body, rhs.body)\n+                // these checks could be removed to allow unused bindings\n+                && bindings_eq(lhs.pat, local_map.keys().copied().collect())\n+                && bindings_eq(rhs.pat, local_map.values().copied().collect())\n+        };\n+\n+        let indexed_arms: Vec<(usize, &Arm<'_>)> = arms.iter().enumerate().collect();\n+        for (&(_, i), &(_, j)) in search_same(&indexed_arms, hash, eq) {\n+            span_lint_and_then(\n+                cx,\n+                MATCH_SAME_ARMS,\n+                j.body.span,\n+                \"this `match` has identical arm bodies\",\n+                |diag| {\n+                    diag.span_note(i.body.span, \"same as this\");\n+\n+                    // Note: this does not use `span_suggestion` on purpose:\n+                    // there is no clean way\n+                    // to remove the other arm. Building a span and suggest to replace it to \"\"\n+                    // makes an even more confusing error message. Also in order not to make up a\n+                    // span for the whole pattern, the suggestion is only shown when there is only\n+                    // one pattern. The user should know about `|` if they are already using it\u2026\n+\n+                    let lhs = snippet(cx, i.pat.span, \"<pat1>\");\n+                    let rhs = snippet(cx, j.pat.span, \"<pat2>\");\n+\n+                    if let PatKind::Wild = j.pat.kind {\n+                        // if the last arm is _, then i could be integrated into _\n+                        // note that i.pat cannot be _, because that would mean that we're\n+                        // hiding all the subsequent arms, and rust won't compile\n+                        diag.span_note(\n+                            i.body.span,\n+                            &format!(\n+                                \"`{}` has the same arm body as the `_` wildcard, consider removing it\",\n+                                lhs\n+                            ),\n+                        );\n+                    } else {\n+                        diag.span_help(i.pat.span, &format!(\"consider refactoring into `{} | {}`\", lhs, rhs,))\n+                            .help(\"...or consider changing the match arm bodies\");\n+                    }\n+                },\n+            );\n+        }\n+    }\n+}\n+\n+fn pat_contains_local(pat: &Pat<'_>, id: HirId) -> bool {\n+    let mut result = false;\n+    pat.walk_short(|p| {\n+        result |= matches!(p.kind, PatKind::Binding(_, binding_id, ..) if binding_id == id);\n+        !result\n+    });\n+    result\n+}\n+\n+/// Returns true if all the bindings in the `Pat` are in `ids` and vice versa\n+fn bindings_eq(pat: &Pat<'_>, mut ids: HirIdSet) -> bool {\n+    let mut result = true;\n+    pat.each_binding_or_first(&mut |_, id, _, _| result &= ids.remove(&id));\n+    result && ids.is_empty()\n+}"}, {"sha": "529f759ba0e32035ac4d00e845d2aca16a51097d", "filename": "clippy_lints/src/matches/mod.rs", "status": "modified", "additions": 7, "deletions": 113, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/64548250e7c740d0376d638214df65fb2ace35f1/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64548250e7c740d0376d638214df65fb2ace35f1/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs?ref=64548250e7c740d0376d638214df65fb2ace35f1", "patch": "@@ -3,37 +3,35 @@ use clippy_utils::diagnostics::{\n     multispan_sugg, span_lint_and_help, span_lint_and_note, span_lint_and_sugg, span_lint_and_then,\n };\n use clippy_utils::macros::{is_panic, root_macro_call};\n+use clippy_utils::paths;\n use clippy_utils::peel_blocks_with_stmt;\n use clippy_utils::source::{expr_block, indent_of, snippet, snippet_block, snippet_opt, snippet_with_applicability};\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::{implements_trait, is_type_diagnostic_item, match_type, peel_mid_ty_refs};\n use clippy_utils::visitors::is_local_used;\n use clippy_utils::{\n     get_parent_expr, is_lang_ctor, is_lint_allowed, is_refutable, is_unit_expr, is_wild, meets_msrv, msrvs,\n-    path_to_local, path_to_local_id, peel_blocks, peel_hir_pat_refs, peel_n_hir_expr_refs, recurse_or_patterns,\n-    strip_pat_refs,\n+    path_to_local_id, peel_blocks, peel_hir_pat_refs, peel_n_hir_expr_refs, recurse_or_patterns, strip_pat_refs,\n };\n-use clippy_utils::{paths, search_same, SpanlessEq, SpanlessHash};\n use core::iter::once;\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n use rustc_hir::{\n-    self as hir, Arm, BindingAnnotation, Block, BorrowKind, Expr, ExprKind, HirId, Local, MatchSource, Mutability,\n-    Node, Pat, PatKind, PathSegment, QPath, RangeEnd, TyKind,\n+    self as hir, Arm, BindingAnnotation, Block, BorrowKind, Expr, ExprKind, Local, MatchSource, Mutability, Node, Pat,\n+    PatKind, PathSegment, QPath, RangeEnd, TyKind,\n };\n-use rustc_hir::{HirIdMap, HirIdSet};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::{self, Ty, TyS, VariantDef};\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::{sym, symbol::kw, Span};\n use std::cmp::{max, Ordering};\n-use std::collections::hash_map::Entry;\n \n mod match_like_matches;\n+mod match_same_arms;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -624,10 +622,10 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n \n         if meets_msrv(self.msrv.as_ref(), &msrvs::MATCHES_MACRO) {\n             if !match_like_matches::check(cx, expr) {\n-                lint_match_arms(cx, expr);\n+                match_same_arms::check(cx, expr);\n             }\n         } else {\n-            lint_match_arms(cx, expr);\n+            match_same_arms::check(cx, expr);\n         }\n \n         if let ExprKind::Match(ex, arms, MatchSource::Normal) = expr.kind {\n@@ -2185,107 +2183,3 @@ fn test_overlapping() {\n         ],)\n     );\n }\n-\n-/// Implementation of `MATCH_SAME_ARMS`.\n-fn lint_match_arms<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) {\n-    if let ExprKind::Match(_, arms, MatchSource::Normal) = expr.kind {\n-        let hash = |&(_, arm): &(usize, &Arm<'_>)| -> u64 {\n-            let mut h = SpanlessHash::new(cx);\n-            h.hash_expr(arm.body);\n-            h.finish()\n-        };\n-\n-        let eq = |&(lindex, lhs): &(usize, &Arm<'_>), &(rindex, rhs): &(usize, &Arm<'_>)| -> bool {\n-            let min_index = usize::min(lindex, rindex);\n-            let max_index = usize::max(lindex, rindex);\n-\n-            let mut local_map: HirIdMap<HirId> = HirIdMap::default();\n-            let eq_fallback = |a: &Expr<'_>, b: &Expr<'_>| {\n-                if_chain! {\n-                    if let Some(a_id) = path_to_local(a);\n-                    if let Some(b_id) = path_to_local(b);\n-                    let entry = match local_map.entry(a_id) {\n-                        Entry::Vacant(entry) => entry,\n-                        // check if using the same bindings as before\n-                        Entry::Occupied(entry) => return *entry.get() == b_id,\n-                    };\n-                    // the names technically don't have to match; this makes the lint more conservative\n-                    if cx.tcx.hir().name(a_id) == cx.tcx.hir().name(b_id);\n-                    if TyS::same_type(cx.typeck_results().expr_ty(a), cx.typeck_results().expr_ty(b));\n-                    if pat_contains_local(lhs.pat, a_id);\n-                    if pat_contains_local(rhs.pat, b_id);\n-                    then {\n-                        entry.insert(b_id);\n-                        true\n-                    } else {\n-                        false\n-                    }\n-                }\n-            };\n-            // Arms with a guard are ignored, those can\u2019t always be merged together\n-            // This is also the case for arms in-between each there is an arm with a guard\n-            (min_index..=max_index).all(|index| arms[index].guard.is_none())\n-                && SpanlessEq::new(cx)\n-                    .expr_fallback(eq_fallback)\n-                    .eq_expr(lhs.body, rhs.body)\n-                // these checks could be removed to allow unused bindings\n-                && bindings_eq(lhs.pat, local_map.keys().copied().collect())\n-                && bindings_eq(rhs.pat, local_map.values().copied().collect())\n-        };\n-\n-        let indexed_arms: Vec<(usize, &Arm<'_>)> = arms.iter().enumerate().collect();\n-        for (&(_, i), &(_, j)) in search_same(&indexed_arms, hash, eq) {\n-            span_lint_and_then(\n-                cx,\n-                MATCH_SAME_ARMS,\n-                j.body.span,\n-                \"this `match` has identical arm bodies\",\n-                |diag| {\n-                    diag.span_note(i.body.span, \"same as this\");\n-\n-                    // Note: this does not use `span_suggestion` on purpose:\n-                    // there is no clean way\n-                    // to remove the other arm. Building a span and suggest to replace it to \"\"\n-                    // makes an even more confusing error message. Also in order not to make up a\n-                    // span for the whole pattern, the suggestion is only shown when there is only\n-                    // one pattern. The user should know about `|` if they are already using it\u2026\n-\n-                    let lhs = snippet(cx, i.pat.span, \"<pat1>\");\n-                    let rhs = snippet(cx, j.pat.span, \"<pat2>\");\n-\n-                    if let PatKind::Wild = j.pat.kind {\n-                        // if the last arm is _, then i could be integrated into _\n-                        // note that i.pat cannot be _, because that would mean that we're\n-                        // hiding all the subsequent arms, and rust won't compile\n-                        diag.span_note(\n-                            i.body.span,\n-                            &format!(\n-                                \"`{}` has the same arm body as the `_` wildcard, consider removing it\",\n-                                lhs\n-                            ),\n-                        );\n-                    } else {\n-                        diag.span_help(i.pat.span, &format!(\"consider refactoring into `{} | {}`\", lhs, rhs,))\n-                            .help(\"...or consider changing the match arm bodies\");\n-                    }\n-                },\n-            );\n-        }\n-    }\n-}\n-\n-fn pat_contains_local(pat: &Pat<'_>, id: HirId) -> bool {\n-    let mut result = false;\n-    pat.walk_short(|p| {\n-        result |= matches!(p.kind, PatKind::Binding(_, binding_id, ..) if binding_id == id);\n-        !result\n-    });\n-    result\n-}\n-\n-/// Returns true if all the bindings in the `Pat` are in `ids` and vice versa\n-fn bindings_eq(pat: &Pat<'_>, mut ids: HirIdSet) -> bool {\n-    let mut result = true;\n-    pat.each_binding_or_first(&mut |_, id, _, _| result &= ids.remove(&id));\n-    result && ids.is_empty()\n-}"}]}