{"sha": "c891fa326d28818582a653e588463c45f82e5795", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4OTFmYTMyNmQyODgxODU4MmE2NTNlNTg4NDYzYzQ1ZjgyZTU3OTU=", "commit": {"author": {"name": "novalis", "email": "novalis@novalis.org", "date": "2013-09-05T20:15:45Z"}, "committer": {"name": "novalis", "email": "novalis@novalis.org", "date": "2013-09-07T03:30:17Z"}, "message": "Fix #6031.  Allow symbolic log levels, not just numbers.", "tree": {"sha": "e00894edbe70b9a49e6c6c2e5e6b85c720cf32ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e00894edbe70b9a49e6c6c2e5e6b85c720cf32ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c891fa326d28818582a653e588463c45f82e5795", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c891fa326d28818582a653e588463c45f82e5795", "html_url": "https://github.com/rust-lang/rust/commit/c891fa326d28818582a653e588463c45f82e5795", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c891fa326d28818582a653e588463c45f82e5795/comments", "author": {"login": "novalis", "id": 77003, "node_id": "MDQ6VXNlcjc3MDAz", "avatar_url": "https://avatars.githubusercontent.com/u/77003?v=4", "gravatar_id": "", "url": "https://api.github.com/users/novalis", "html_url": "https://github.com/novalis", "followers_url": "https://api.github.com/users/novalis/followers", "following_url": "https://api.github.com/users/novalis/following{/other_user}", "gists_url": "https://api.github.com/users/novalis/gists{/gist_id}", "starred_url": "https://api.github.com/users/novalis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/novalis/subscriptions", "organizations_url": "https://api.github.com/users/novalis/orgs", "repos_url": "https://api.github.com/users/novalis/repos", "events_url": "https://api.github.com/users/novalis/events{/privacy}", "received_events_url": "https://api.github.com/users/novalis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "novalis", "id": 77003, "node_id": "MDQ6VXNlcjc3MDAz", "avatar_url": "https://avatars.githubusercontent.com/u/77003?v=4", "gravatar_id": "", "url": "https://api.github.com/users/novalis", "html_url": "https://github.com/novalis", "followers_url": "https://api.github.com/users/novalis/followers", "following_url": "https://api.github.com/users/novalis/following{/other_user}", "gists_url": "https://api.github.com/users/novalis/gists{/gist_id}", "starred_url": "https://api.github.com/users/novalis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/novalis/subscriptions", "organizations_url": "https://api.github.com/users/novalis/orgs", "repos_url": "https://api.github.com/users/novalis/repos", "events_url": "https://api.github.com/users/novalis/events{/privacy}", "received_events_url": "https://api.github.com/users/novalis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12bca20d781cf4f6810c1cfc1666c1adb1d5d97f", "url": "https://api.github.com/repos/rust-lang/rust/commits/12bca20d781cf4f6810c1cfc1666c1adb1d5d97f", "html_url": "https://github.com/rust-lang/rust/commit/12bca20d781cf4f6810c1cfc1666c1adb1d5d97f"}], "stats": {"total": 79, "additions": 58, "deletions": 21}, "files": [{"sha": "3c6157e44ba6f111b2b56978c0b05deddbd4d7d3", "filename": "doc/rust.md", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c891fa326d28818582a653e588463c45f82e5795/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/c891fa326d28818582a653e588463c45f82e5795/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=c891fa326d28818582a653e588463c45f82e5795", "patch": "@@ -3385,9 +3385,11 @@ The path to a module consists of the crate name, any parent modules,\n then the module itself, all separated by double colons (`::`).  The\n optional log level can be appended to the module path with an equals\n sign (`=`) followed by the log level, from 1 to 4, inclusive. Level 1\n-is the error level, 2 is warning, 3 info, and 4 debug. Any logs\n-less than or equal to the specified level will be output. If not\n-specified then log level 4 is assumed.\n+is the error level, 2 is warning, 3 info, and 4 debug. You can also\n+use the symbolic constants `error`, `warn`, `info`, and `debug`.  Any\n+logs less than or equal to the specified level will be output. If not\n+specified then log level 4 is assumed.  However, debug messages are\n+only available if `--cfg=debug` is passed to `rustc`.\n \n As an example, to see all the logs generated by the compiler, you would set\n `RUST_LOG` to `rustc`, which is the crate name (as specified in its `link`"}, {"sha": "a9fd43c23afbe51244c1166404dd9b91d991bc9e", "filename": "src/libstd/rt/logging.rs", "status": "modified", "additions": 53, "deletions": 18, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/c891fa326d28818582a653e588463c45f82e5795/src%2Flibstd%2Frt%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c891fa326d28818582a653e588463c45f82e5795/src%2Flibstd%2Frt%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flogging.rs?ref=c891fa326d28818582a653e588463c45f82e5795", "patch": "@@ -10,11 +10,12 @@\n use cast::transmute;\n use either::*;\n use libc::{c_void, uintptr_t, c_char, exit, STDERR_FILENO};\n-use option::{Some, None};\n+use option::{Some, None, Option};\n use rt::util::dumb_println;\n use str::StrSlice;\n use str::raw::from_c_str;\n use u32;\n+use u32::{min};\n use unstable::raw::Closure;\n use vec::ImmutableVector;\n \n@@ -30,7 +31,6 @@ struct ModEntry{\n     log_level: *mut u32\n }\n \n-static MAX_LOG_DIRECTIVES: u32 = 255;\n static MAX_LOG_LEVEL: u32 = 255;\n static DEFAULT_LOG_LEVEL: u32 = 1;\n \n@@ -68,42 +68,68 @@ fn iter_crate_map(map: *u8, f: &fn(*mut ModEntry)) {\n                     data: *c_void);\n     }\n }\n+static log_level_names : &'static[&'static str] = &'static[\"error\", \"warn\", \"info\", \"debug\"];\n+\n+/// Parse an individual log level that is either a number or a symbolic log level\n+fn parse_log_level(level: &str) -> Option<u32> {\n+    let num = u32::from_str(level);\n+    let mut log_level;\n+    match (num) {\n+        Some(num) => {\n+            if num < MAX_LOG_LEVEL {\n+                log_level = Some(num);\n+            } else {\n+                log_level = Some(MAX_LOG_LEVEL);\n+            }\n+        }\n+        _ => {\n+            let position = log_level_names.iter().position(|&name| name == level);\n+            match (position) {\n+                Some(position) => {\n+                    log_level = Some(min(MAX_LOG_LEVEL, (position + 1) as u32))\n+                },\n+                _ => {\n+                    log_level = None;\n+                }\n+            }\n+        }\n+    }\n+    log_level\n+}\n+\n \n /// Parse a logging specification string (e.g: \"crate1,crate2::mod3,crate3::x=1\")\n /// and return a vector with log directives.\n-/// Valid log levels are 0-255, with the most likely ones being 0-3 (defined in std::).\n+/// Valid log levels are 0-255, with the most likely ones being 1-4 (defined in std::).\n+/// Also supports string log levels of error, warn, info, and debug\n+\n fn parse_logging_spec(spec: ~str) -> ~[LogDirective]{\n     let mut dirs = ~[];\n     for s in spec.split_iter(',') {\n         let parts: ~[&str] = s.split_iter('=').collect();\n-        let mut loglevel;\n+        let mut log_level;\n         match parts.len() {\n-            1 => loglevel = MAX_LOG_LEVEL,\n+            1 => log_level = MAX_LOG_LEVEL,\n             2 => {\n-                let num = u32::from_str(parts[1]);\n-                match (num) {\n+                let possible_log_level = parse_log_level(parts[1]);\n+                match possible_log_level {\n                     Some(num) => {\n-                        if num < MAX_LOG_LEVEL {\n-                            loglevel = num;\n-                        } else {\n-                            loglevel = MAX_LOG_LEVEL;\n-                        }\n-                    }\n+                        log_level = num;\n+                    },\n                     _ => {\n-                         dumb_println(fmt!(\"warning: invalid logging spec \\\n-                                           '%s', ignoring it\", s));\n-                         loop;\n+                        dumb_println(fmt!(\"warning: invalid logging spec \\\n+                                           '%s', ignoring it\", parts[1]));\n+                        loop;\n                     }\n                 }\n-                if loglevel > MAX_LOG_LEVEL { loglevel = MAX_LOG_LEVEL}\n             },\n             _ => {\n                 dumb_println(fmt!(\"warning: invalid logging spec '%s',\\\n                                   ignoring it\", s));\n                 loop;\n             }\n         }\n-        let dir = LogDirective {name: parts[0].to_owned(), level: loglevel};\n+        let dir = LogDirective {name: parts[0].to_owned(), level: log_level};\n         dirs.push(dir);\n     }\n     return dirs;\n@@ -268,6 +294,15 @@ fn parse_logging_spec_invalid_log_level() {\n     assert_eq!(dirs[0].level, 4);\n }\n \n+#[test]\n+fn parse_logging_spec_string_log_level() {\n+    // test parse_logging_spec with 'warn' as log level\n+    let dirs: ~[LogDirective] = parse_logging_spec(~\"crate1::mod1=wrong,crate2=warn\");\n+    assert_eq!(dirs.len(), 1);\n+    assert!(dirs[0].name == ~\"crate2\");\n+    assert_eq!(dirs[0].level, 2);\n+}\n+\n // Tests for update_entry\n #[test]\n fn update_entry_match_full_path() {"}]}