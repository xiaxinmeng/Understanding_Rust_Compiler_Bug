{"sha": "20ec72830a91aba82fcaa3dc0d9593b5978ab8ab", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwZWM3MjgzMGE5MWFiYTgyZmNhYTNkYzBkOTU5M2I1OTc4YWI4YWI=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-03-16T00:45:38Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-03-16T00:50:22Z"}, "message": "Address FIXMEs in extfmt / add issue numbers", "tree": {"sha": "2fb815838bfdeccfbd1b1853da6dd620a1292c68", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2fb815838bfdeccfbd1b1853da6dd620a1292c68"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/20ec72830a91aba82fcaa3dc0d9593b5978ab8ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/20ec72830a91aba82fcaa3dc0d9593b5978ab8ab", "html_url": "https://github.com/rust-lang/rust/commit/20ec72830a91aba82fcaa3dc0d9593b5978ab8ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/20ec72830a91aba82fcaa3dc0d9593b5978ab8ab/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce3f369047108e8cf28f16cd75f2301e61e6f019", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce3f369047108e8cf28f16cd75f2301e61e6f019", "html_url": "https://github.com/rust-lang/rust/commit/ce3f369047108e8cf28f16cd75f2301e61e6f019"}], "stats": {"total": 64, "additions": 35, "deletions": 29}, "files": [{"sha": "187be9a3909bf9f548fb6087816bc780dbf01ef8", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 24, "deletions": 29, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/20ec72830a91aba82fcaa3dc0d9593b5978ab8ab/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ec72830a91aba82fcaa3dc0d9593b5978ab8ab/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=20ec72830a91aba82fcaa3dc0d9593b5978ab8ab", "patch": "@@ -53,7 +53,7 @@ mod ct {\n         ty_octal,\n         ty_float,\n         ty_poly,\n-        // FIXME: More types\n+        // FIXME: More types (Issue #1992)\n     }\n     enum flag {\n         flag_left_justify,\n@@ -275,31 +275,32 @@ mod rt {\n         // FIXME: This is a hack to avoid creating 0-length vec exprs,\n         // which have some difficulty typechecking currently. See\n         // comments in front::extfmt::make_flags\n+        // (once #1993 is addressed, this won't be necessary)\n         flag_none,\n     }\n     enum count { count_is(int), count_implied, }\n     enum ty { ty_default, ty_bits, ty_hex_upper, ty_hex_lower, ty_octal, }\n \n     // FIXME: May not want to use a vector here for flags;\n-    // instead just use a bool per flag\n+    // instead just use a bool per flag (see Issue #1993)\n     type conv = {flags: [flag], width: count, precision: count, ty: ty};\n \n     fn conv_int(cv: conv, i: int) -> str {\n         let radix = 10u;\n         let prec = get_int_precision(cv);\n-        let mut s = int_to_str_prec(i, radix, prec);\n+        let mut s : str = int_to_str_prec(i, radix, prec);\n         if 0 <= i {\n             if have_flag(cv.flags, flag_sign_always) {\n-                s = \"+\" + s;\n+                str::unshift_char(s, '+');\n             } else if have_flag(cv.flags, flag_space_for_sign) {\n-                s = \" \" + s;\n+                str::unshift_char(s, ' ');\n             }\n         }\n         ret pad(cv, s, pad_signed);\n     }\n     fn conv_uint(cv: conv, u: uint) -> str {\n         let prec = get_int_precision(cv);\n-        let rs =\n+        let mut rs =\n             alt cv.ty {\n               ty_default { uint_to_str_prec(u, 10u, prec) }\n               ty_hex_lower { uint_to_str_prec(u, 16u, prec) }\n@@ -317,12 +318,13 @@ mod rt {\n         ret conv_str(cv, s);\n     }\n     fn conv_char(cv: conv, c: char) -> str {\n-        ret pad(cv, str::from_char(c), pad_nozero);\n+        let mut s = str::from_char(c);\n+        ret pad(cv, s, pad_nozero);\n     }\n     fn conv_str(cv: conv, s: str) -> str unsafe {\n         // For strings, precision is the maximum characters\n         // displayed\n-        let unpadded = alt cv.precision {\n+        let mut unpadded = alt cv.precision {\n           count_implied { s }\n           count_is(max) {\n             if max as uint < str::char_len(s) {\n@@ -371,7 +373,7 @@ mod rt {\n                 let len = str::char_len(s);\n                 if len < prec {\n                     let diff = prec - len;\n-                    let pad = str_init_elt(diff, '0');\n+                    let pad = str::init_elt(diff, '0');\n                     pad + s\n                 } else { s }\n             };\n@@ -382,28 +384,21 @@ mod rt {\n               count_implied { 1u }\n             };\n     }\n-\n-    // FIXME: This might be useful in str: but needs to be utf8 safe first\n-    fn str_init_elt(n_elts: uint, c: char) -> str {\n-        let svec = vec::from_elem::<u8>(n_elts, c as u8);\n-\n-        ret str::from_bytes(svec);\n-    }\n     enum pad_mode { pad_signed, pad_unsigned, pad_nozero, }\n-    fn pad(cv: conv, s: str, mode: pad_mode) -> str unsafe {\n-        let uwidth = alt cv.width {\n+    fn pad(cv: conv, &s: str, mode: pad_mode) -> str unsafe {\n+        let uwidth : uint = alt cv.width {\n           count_implied { ret s; }\n           count_is(width) {\n-            // FIXME: Maybe width should be uint\n-            width as uint\n+              // FIXME: width should probably be uint (see Issue #1996)\n+              width as uint\n           }\n         };\n         let strlen = str::char_len(s);\n         if uwidth <= strlen { ret s; }\n         let mut padchar = ' ';\n         let diff = uwidth - strlen;\n         if have_flag(cv.flags, flag_left_justify) {\n-            let padstr = str_init_elt(diff, padchar);\n+            let padstr = str::init_elt(diff, padchar);\n             ret s + padstr;\n         }\n         let {might_zero_pad, signed} = alt mode {\n@@ -423,20 +418,20 @@ mod rt {\n                 false\n             }\n         };\n-        let padstr = str_init_elt(diff, padchar);\n+        let padstr = str::init_elt(diff, padchar);\n         // This is completely heinous. If we have a signed value then\n         // potentially rip apart the intermediate result and insert some\n         // zeros. It may make sense to convert zero padding to a precision\n         // instead.\n \n         if signed && zero_padding && str::len(s) > 0u {\n-            let head = s[0];\n-            if head == '+' as u8 || head == '-' as u8 || head == ' ' as u8 {\n-                let headstr = str::from_bytes([head]);\n-                // FIXME: not UTF-8 safe\n-                let bytelen = str::len(s);\n-                let numpart = str::slice(s, 1u, bytelen);\n-                ret headstr + padstr + numpart;\n+            let head = str::shift_char(s);\n+            if head == '+' || head == '-' || head == ' ' {\n+                let headstr = str::init_elt(1u, head);\n+                ret headstr + padstr + s;\n+            }\n+            else {\n+                str::unshift_char(s, head);\n             }\n         }\n         ret padstr + s;"}, {"sha": "05b097079d94a48d21747dd8410bf97517073dd8", "filename": "src/libcore/str.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/20ec72830a91aba82fcaa3dc0d9593b5978ab8ab/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ec72830a91aba82fcaa3dc0d9593b5978ab8ab/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=20ec72830a91aba82fcaa3dc0d9593b5978ab8ab", "patch": "@@ -20,6 +20,7 @@ export\n    push_char,\n    concat,\n    connect,\n+   init_elt,\n \n    // Reinterpretation\n    as_bytes,\n@@ -240,6 +241,16 @@ fn connect(v: [str], sep: str) -> str {\n     ret s;\n }\n \n+#[doc = \"Returns a string of <n_elts> repetitions of <c>, which must be \\\n+           UTF-8\"]\n+fn init_elt(n_elts: uint, c: char) -> str {\n+  let mut rslt = \"\";\n+  uint::range(0u, n_elts) {|_i|\n+      push_char(rslt, c);\n+  }\n+  rslt\n+}\n+\n /*\n Section: Adding to and removing from a string\n */"}]}