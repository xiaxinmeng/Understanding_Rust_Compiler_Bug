{"sha": "7919e4208b0a7937a1407523c7f4181aca8c85b7", "node_id": "C_kwDOAAsO6NoAKDc5MTllNDIwOGIwYTc5MzdhMTQwNzUyM2M3ZjQxODFhY2E4Yzg1Yjc", "commit": {"author": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2022-02-21T22:30:42Z"}, "committer": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2022-07-03T04:15:15Z"}, "message": "Fix slice::ChunksMut aliasing", "tree": {"sha": "8892a9dea7f522e23ec2807c9a7da95a6778ed3c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8892a9dea7f522e23ec2807c9a7da95a6778ed3c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7919e4208b0a7937a1407523c7f4181aca8c85b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7919e4208b0a7937a1407523c7f4181aca8c85b7", "html_url": "https://github.com/rust-lang/rust/commit/7919e4208b0a7937a1407523c7f4181aca8c85b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7919e4208b0a7937a1407523c7f4181aca8c85b7/comments", "author": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f98537eb7b5f42c246a52c550813c3cff336069", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f98537eb7b5f42c246a52c550813c3cff336069", "html_url": "https://github.com/rust-lang/rust/commit/5f98537eb7b5f42c246a52c550813c3cff336069"}], "stats": {"total": 215, "additions": 143, "deletions": 72}, "files": [{"sha": "d085b5166677f0e0908f1b8101286147214f0768", "filename": "library/core/src/slice/iter.rs", "status": "modified", "additions": 99, "deletions": 72, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/7919e4208b0a7937a1407523c7f4181aca8c85b7/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7919e4208b0a7937a1407523c7f4181aca8c85b7/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs?ref=7919e4208b0a7937a1407523c7f4181aca8c85b7", "patch": "@@ -1629,14 +1629,15 @@ unsafe impl<'a, T> TrustedRandomAccessNoCoerce for Chunks<'a, T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n pub struct ChunksMut<'a, T: 'a> {\n-    v: &'a mut [T],\n+    v: *mut [T],\n     chunk_size: usize,\n+    _marker: PhantomData<&'a mut T>,\n }\n \n impl<'a, T: 'a> ChunksMut<'a, T> {\n     #[inline]\n     pub(super) fn new(slice: &'a mut [T], size: usize) -> Self {\n-        Self { v: slice, chunk_size: size }\n+        Self { v: slice, chunk_size: size, _marker: PhantomData }\n     }\n }\n \n@@ -1650,10 +1651,11 @@ impl<'a, T> Iterator for ChunksMut<'a, T> {\n             None\n         } else {\n             let sz = cmp::min(self.v.len(), self.chunk_size);\n-            let tmp = mem::replace(&mut self.v, &mut []);\n-            let (head, tail) = tmp.split_at_mut(sz);\n+            // SAFETY: sz cannot exceed the slice length based on the calculation above\n+            let (head, tail) = unsafe { self.v.split_at_mut(sz) };\n             self.v = tail;\n-            Some(head)\n+            // SAFETY: Nothing points to or will point to the contents of this slice\n+            Some(unsafe { &mut *head })\n         }\n     }\n \n@@ -1685,11 +1687,13 @@ impl<'a, T> Iterator for ChunksMut<'a, T> {\n                 Some(sum) => cmp::min(self.v.len(), sum),\n                 None => self.v.len(),\n             };\n-            let tmp = mem::replace(&mut self.v, &mut []);\n-            let (head, tail) = tmp.split_at_mut(end);\n-            let (_, nth) = head.split_at_mut(start);\n+            // SAFETY: end is inbounds because we compared above against self.v.len()\n+            let (head, tail) = unsafe { self.v.split_at_mut(end) };\n+            // SAFETY: start is inbounds because\n+            let (_, nth) = unsafe { head.split_at_mut(start) };\n             self.v = tail;\n-            Some(nth)\n+            // SAFETY: Nothing points to or will point to the contents of this slice\n+            Some(unsafe { &mut *nth })\n         }\n     }\n \n@@ -1699,7 +1703,8 @@ impl<'a, T> Iterator for ChunksMut<'a, T> {\n             None\n         } else {\n             let start = (self.v.len() - 1) / self.chunk_size * self.chunk_size;\n-            Some(&mut self.v[start..])\n+            // SAFETY: Nothing points to or will point to the contents of this slice\n+            Some(unsafe { &mut *self.v.get_unchecked_mut(start..) })\n         }\n     }\n \n@@ -1727,12 +1732,12 @@ impl<'a, T> DoubleEndedIterator for ChunksMut<'a, T> {\n         } else {\n             let remainder = self.v.len() % self.chunk_size;\n             let sz = if remainder != 0 { remainder } else { self.chunk_size };\n-            let tmp = mem::replace(&mut self.v, &mut []);\n-            let tmp_len = tmp.len();\n+            let len = self.v.len();\n             // SAFETY: Similar to `Chunks::next_back`\n-            let (head, tail) = unsafe { tmp.split_at_mut_unchecked(tmp_len - sz) };\n+            let (head, tail) = unsafe { self.v.split_at_mut_unchecked(len - sz) };\n             self.v = head;\n-            Some(tail)\n+            // SAFETY: Nothing points to or will point to the contents of this slice\n+            Some(unsafe { &mut *tail })\n         }\n     }\n \n@@ -1748,10 +1753,12 @@ impl<'a, T> DoubleEndedIterator for ChunksMut<'a, T> {\n                 Some(res) => cmp::min(self.v.len(), res),\n                 None => self.v.len(),\n             };\n-            let (temp, _tail) = mem::replace(&mut self.v, &mut []).split_at_mut(end);\n-            let (head, nth_back) = temp.split_at_mut(start);\n+            // SAFETY: end is inbounds because we compared above against self.v.len()\n+            let (temp, _tail) = unsafe { self.v.split_at_mut(end) };\n+            let (head, nth_back) = unsafe { temp.split_at_mut(start) };\n             self.v = head;\n-            Some(nth_back)\n+            // SAFETY: Nothing points to or will point to the contents of this slice\n+            Some(unsafe { &mut *nth_back })\n         }\n     }\n }\n@@ -1957,9 +1964,10 @@ unsafe impl<'a, T> TrustedRandomAccessNoCoerce for ChunksExact<'a, T> {\n #[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n pub struct ChunksExactMut<'a, T: 'a> {\n-    v: &'a mut [T],\n-    rem: &'a mut [T],\n+    v: *mut [T],\n+    rem: &'a mut [T], // The iterator never yields from here, so this can be unique\n     chunk_size: usize,\n+    _marker: PhantomData<&'a mut T>,\n }\n \n impl<'a, T> ChunksExactMut<'a, T> {\n@@ -1969,7 +1977,7 @@ impl<'a, T> ChunksExactMut<'a, T> {\n         let fst_len = slice.len() - rem;\n         // SAFETY: 0 <= fst_len <= slice.len() by construction above\n         let (fst, snd) = unsafe { slice.split_at_mut_unchecked(fst_len) };\n-        Self { v: fst, rem: snd, chunk_size }\n+        Self { v: fst, rem: snd, chunk_size, _marker: PhantomData }\n     }\n \n     /// Returns the remainder of the original slice that is not going to be\n@@ -1991,10 +1999,11 @@ impl<'a, T> Iterator for ChunksExactMut<'a, T> {\n         if self.v.len() < self.chunk_size {\n             None\n         } else {\n-            let tmp = mem::replace(&mut self.v, &mut []);\n-            let (head, tail) = tmp.split_at_mut(self.chunk_size);\n+            // SAFETY: self.chunk_size is inbounds because we compared above against self.v.len()\n+            let (head, tail) = unsafe { self.v.split_at_mut(self.chunk_size) };\n             self.v = tail;\n-            Some(head)\n+            // SAFETY: Nothing points to or will point to the contents of this slice\n+            Some(unsafe { &mut *head })\n         }\n     }\n \n@@ -2016,8 +2025,7 @@ impl<'a, T> Iterator for ChunksExactMut<'a, T> {\n             self.v = &mut [];\n             None\n         } else {\n-            let tmp = mem::replace(&mut self.v, &mut []);\n-            let (_, snd) = tmp.split_at_mut(start);\n+            let (_, snd) = unsafe { self.v.split_at_mut(start) };\n             self.v = snd;\n             self.next()\n         }\n@@ -2042,11 +2050,11 @@ impl<'a, T> DoubleEndedIterator for ChunksExactMut<'a, T> {\n         if self.v.len() < self.chunk_size {\n             None\n         } else {\n-            let tmp = mem::replace(&mut self.v, &mut []);\n-            let tmp_len = tmp.len();\n-            let (head, tail) = tmp.split_at_mut(tmp_len - self.chunk_size);\n+            // SAFETY: This subtraction is inbounds because of the check above\n+            let (head, tail) = unsafe { self.v.split_at_mut(self.v.len() - self.chunk_size) };\n             self.v = head;\n-            Some(tail)\n+            // SAFETY: Nothing points to or will point to the contents of this slice\n+            Some(unsafe { &mut *tail })\n         }\n     }\n \n@@ -2059,10 +2067,11 @@ impl<'a, T> DoubleEndedIterator for ChunksExactMut<'a, T> {\n         } else {\n             let start = (len - 1 - n) * self.chunk_size;\n             let end = start + self.chunk_size;\n-            let (temp, _tail) = mem::replace(&mut self.v, &mut []).split_at_mut(end);\n-            let (head, nth_back) = temp.split_at_mut(start);\n+            let (temp, _tail) = unsafe { mem::replace(&mut self.v, &mut []).split_at_mut(end) };\n+            let (head, nth_back) = unsafe { temp.split_at_mut(start) };\n             self.v = head;\n-            Some(nth_back)\n+            // SAFETY: Nothing points to or will point to the contents of this slice\n+            Some(unsafe { &mut *nth_back })\n         }\n     }\n }\n@@ -2646,14 +2655,15 @@ unsafe impl<'a, T> TrustedRandomAccessNoCoerce for RChunks<'a, T> {\n #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n pub struct RChunksMut<'a, T: 'a> {\n-    v: &'a mut [T],\n+    v: *mut [T],\n     chunk_size: usize,\n+    _marker: PhantomData<&'a mut T>,\n }\n \n impl<'a, T: 'a> RChunksMut<'a, T> {\n     #[inline]\n     pub(super) fn new(slice: &'a mut [T], size: usize) -> Self {\n-        Self { v: slice, chunk_size: size }\n+        Self { v: slice, chunk_size: size, _marker: PhantomData }\n     }\n }\n \n@@ -2667,16 +2677,16 @@ impl<'a, T> Iterator for RChunksMut<'a, T> {\n             None\n         } else {\n             let sz = cmp::min(self.v.len(), self.chunk_size);\n-            let tmp = mem::replace(&mut self.v, &mut []);\n-            let tmp_len = tmp.len();\n+            let len = self.v.len();\n             // SAFETY: split_at_mut_unchecked just requires the argument be less\n             // than the length. This could only happen if the expression\n-            // `tmp_len - sz` overflows. This could only happen if `sz >\n-            // tmp_len`, which is impossible as we initialize it as the `min` of\n-            // `self.v.len()` (e.g. `tmp_len`) and `self.chunk_size`.\n-            let (head, tail) = unsafe { tmp.split_at_mut_unchecked(tmp_len - sz) };\n+            // `len - sz` overflows. This could only happen if `sz >\n+            // len`, which is impossible as we initialize it as the `min` of\n+            // `self.v.len()` (e.g. `len`) and `self.chunk_size`.\n+            let (head, tail) = unsafe { self.v.split_at_mut_unchecked(len - sz) };\n             self.v = head;\n-            Some(tail)\n+            // SAFETY: Nothing points to or will point to the contents of this slice\n+            Some(unsafe { &mut *tail })\n         }\n     }\n \n@@ -2710,11 +2720,11 @@ impl<'a, T> Iterator for RChunksMut<'a, T> {\n                 Some(sum) => sum,\n                 None => 0,\n             };\n-            let tmp = mem::replace(&mut self.v, &mut []);\n-            let (head, tail) = tmp.split_at_mut(start);\n-            let (nth, _) = tail.split_at_mut(end - start);\n+            let (head, tail) = unsafe { self.v.split_at_mut(start) };\n+            let (nth, _) = unsafe { tail.split_at_mut(end - start) };\n             self.v = head;\n-            Some(nth)\n+            // SAFETY: Nothing points to or will point to the contents of this slice\n+            Some(unsafe { &mut *nth })\n         }\n     }\n \n@@ -2725,7 +2735,8 @@ impl<'a, T> Iterator for RChunksMut<'a, T> {\n         } else {\n             let rem = self.v.len() % self.chunk_size;\n             let end = if rem == 0 { self.chunk_size } else { rem };\n-            Some(&mut self.v[0..end])\n+            // SAFETY: Nothing points to or will point to the contents of this slice\n+            Some(unsafe { &mut *self.v.get_unchecked_mut(0..end) })\n         }\n     }\n \n@@ -2750,11 +2761,11 @@ impl<'a, T> DoubleEndedIterator for RChunksMut<'a, T> {\n         } else {\n             let remainder = self.v.len() % self.chunk_size;\n             let sz = if remainder != 0 { remainder } else { self.chunk_size };\n-            let tmp = mem::replace(&mut self.v, &mut []);\n             // SAFETY: Similar to `Chunks::next_back`\n-            let (head, tail) = unsafe { tmp.split_at_mut_unchecked(sz) };\n+            let (head, tail) = unsafe { self.v.split_at_mut_unchecked(sz) };\n             self.v = tail;\n-            Some(head)\n+            // SAFETY: Nothing points to or will point to the contents of this slice\n+            Some(unsafe { &mut *head })\n         }\n     }\n \n@@ -2769,10 +2780,11 @@ impl<'a, T> DoubleEndedIterator for RChunksMut<'a, T> {\n             let offset_from_end = (len - 1 - n) * self.chunk_size;\n             let end = self.v.len() - offset_from_end;\n             let start = end.saturating_sub(self.chunk_size);\n-            let (tmp, tail) = mem::replace(&mut self.v, &mut []).split_at_mut(end);\n-            let (_, nth_back) = tmp.split_at_mut(start);\n+            let (tmp, tail) = unsafe { self.v.split_at_mut(end) };\n+            let (_, nth_back) = unsafe { tmp.split_at_mut(start) };\n             self.v = tail;\n-            Some(nth_back)\n+            // SAFETY: Nothing points to or will point to the contents of this slice\n+            Some(unsafe { &mut *nth_back })\n         }\n     }\n }\n@@ -2898,8 +2910,7 @@ impl<'a, T> Iterator for RChunksExact<'a, T> {\n     unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {\n         let end = self.v.len() - idx * self.chunk_size;\n         let start = end - self.chunk_size;\n-        // SAFETY:\n-        // SAFETY: mostmy identical to `Chunks::__iterator_get_unchecked`.\n+        // SAFETY: mostly identical to `Chunks::__iterator_get_unchecked`.\n         unsafe { from_raw_parts(self.v.as_ptr().add(start), self.chunk_size) }\n     }\n }\n@@ -2982,7 +2993,7 @@ unsafe impl<'a, T> TrustedRandomAccessNoCoerce for RChunksExact<'a, T> {\n #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n pub struct RChunksExactMut<'a, T: 'a> {\n-    v: &'a mut [T],\n+    v: *mut [T],\n     rem: &'a mut [T],\n     chunk_size: usize,\n }\n@@ -3015,11 +3026,11 @@ impl<'a, T> Iterator for RChunksExactMut<'a, T> {\n         if self.v.len() < self.chunk_size {\n             None\n         } else {\n-            let tmp = mem::replace(&mut self.v, &mut []);\n-            let tmp_len = tmp.len();\n-            let (head, tail) = tmp.split_at_mut(tmp_len - self.chunk_size);\n+            let len = self.v.len();\n+            let (head, tail) = unsafe { self.v.split_at_mut(len - self.chunk_size) };\n             self.v = head;\n-            Some(tail)\n+            // SAFETY: Nothing points to or will point to the contents of this slice\n+            Some(unsafe { &mut *tail })\n         }\n     }\n \n@@ -3041,9 +3052,8 @@ impl<'a, T> Iterator for RChunksExactMut<'a, T> {\n             self.v = &mut [];\n             None\n         } else {\n-            let tmp = mem::replace(&mut self.v, &mut []);\n-            let tmp_len = tmp.len();\n-            let (fst, _) = tmp.split_at_mut(tmp_len - end);\n+            let len = self.v.len();\n+            let (fst, _) = unsafe { self.v.split_at_mut(len - end) };\n             self.v = fst;\n             self.next()\n         }\n@@ -3069,10 +3079,10 @@ impl<'a, T> DoubleEndedIterator for RChunksExactMut<'a, T> {\n         if self.v.len() < self.chunk_size {\n             None\n         } else {\n-            let tmp = mem::replace(&mut self.v, &mut []);\n-            let (head, tail) = tmp.split_at_mut(self.chunk_size);\n+            let (head, tail) = unsafe { self.v.split_at_mut(self.chunk_size) };\n             self.v = tail;\n-            Some(head)\n+            // SAFETY: Nothing points to or will point to the contents of this slice\n+            Some(unsafe { &mut *head })\n         }\n     }\n \n@@ -3088,10 +3098,11 @@ impl<'a, T> DoubleEndedIterator for RChunksExactMut<'a, T> {\n             let offset = (len - n) * self.chunk_size;\n             let start = self.v.len() - offset;\n             let end = start + self.chunk_size;\n-            let (tmp, tail) = mem::replace(&mut self.v, &mut []).split_at_mut(end);\n-            let (_, nth_back) = tmp.split_at_mut(start);\n+            let (tmp, tail) = unsafe { self.v.split_at_mut(end) };\n+            let (_, nth_back) = unsafe { tmp.split_at_mut(start) };\n             self.v = tail;\n-            Some(nth_back)\n+            // SAFETY: Nothing points to or will point to the contents of this slice\n+            Some(unsafe { &mut *nth_back })\n         }\n     }\n }\n@@ -3174,7 +3185,11 @@ where\n             let mut len = 1;\n             let mut iter = self.slice.windows(2);\n             while let Some([l, r]) = iter.next() {\n-                if (self.predicate)(l, r) { len += 1 } else { break }\n+                if (self.predicate)(l, r) {\n+                    len += 1\n+                } else {\n+                    break;\n+                }\n             }\n             let (head, tail) = self.slice.split_at(len);\n             self.slice = tail;\n@@ -3206,7 +3221,11 @@ where\n             let mut len = 1;\n             let mut iter = self.slice.windows(2);\n             while let Some([l, r]) = iter.next_back() {\n-                if (self.predicate)(l, r) { len += 1 } else { break }\n+                if (self.predicate)(l, r) {\n+                    len += 1\n+                } else {\n+                    break;\n+                }\n             }\n             let (head, tail) = self.slice.split_at(self.slice.len() - len);\n             self.slice = head;\n@@ -3261,7 +3280,11 @@ where\n             let mut len = 1;\n             let mut iter = self.slice.windows(2);\n             while let Some([l, r]) = iter.next() {\n-                if (self.predicate)(l, r) { len += 1 } else { break }\n+                if (self.predicate)(l, r) {\n+                    len += 1\n+                } else {\n+                    break;\n+                }\n             }\n             let slice = mem::take(&mut self.slice);\n             let (head, tail) = slice.split_at_mut(len);\n@@ -3294,7 +3317,11 @@ where\n             let mut len = 1;\n             let mut iter = self.slice.windows(2);\n             while let Some([l, r]) = iter.next_back() {\n-                if (self.predicate)(l, r) { len += 1 } else { break }\n+                if (self.predicate)(l, r) {\n+                    len += 1\n+                } else {\n+                    break;\n+                }\n             }\n             let slice = mem::take(&mut self.slice);\n             let (head, tail) = slice.split_at_mut(slice.len() - len);"}, {"sha": "6d1516958f39bd49b38217d196bcb1d11fb16c8c", "filename": "library/core/tests/slice.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/7919e4208b0a7937a1407523c7f4181aca8c85b7/library%2Fcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7919e4208b0a7937a1407523c7f4181aca8c85b7/library%2Fcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fslice.rs?ref=7919e4208b0a7937a1407523c7f4181aca8c85b7", "patch": "@@ -409,6 +409,50 @@ fn test_chunks_mut_zip() {\n     assert_eq!(v1, [13, 14, 19, 20, 14]);\n }\n \n+#[test]\n+fn test_chunks_mut_zip_aliasing() {\n+    let v1: &mut [i32] = &mut [0, 1, 2, 3, 4];\n+    let v2: &[i32] = &[6, 7, 8, 9, 10];\n+\n+    let mut it = v1.chunks_mut(2).zip(v2.chunks(2));\n+    let first = it.next().unwrap();\n+    let _ = it.next().unwrap();\n+    assert_eq!(first, (&mut [0, 1][..], &[6, 7][..]));\n+}\n+\n+#[test]\n+fn test_chunks_exact_mut_zip_aliasing() {\n+    let v1: &mut [i32] = &mut [0, 1, 2, 3, 4];\n+    let v2: &[i32] = &[6, 7, 8, 9, 10];\n+\n+    let mut it = v1.chunks_exact_mut(2).zip(v2.chunks(2));\n+    let first = it.next().unwrap();\n+    let _ = it.next().unwrap();\n+    assert_eq!(first, (&mut [0, 1][..], &[6, 7][..]));\n+}\n+\n+#[test]\n+fn test_rchunks_mut_zip_aliasing() {\n+    let v1: &mut [i32] = &mut [0, 1, 2, 3, 4];\n+    let v2: &[i32] = &[6, 7, 8, 9, 10];\n+\n+    let mut it = v1.rchunks_mut(2).zip(v2.chunks(2));\n+    let first = it.next().unwrap();\n+    let _ = it.next().unwrap();\n+    assert_eq!(first, (&mut [3, 4][..], &[6, 7][..]));\n+}\n+\n+#[test]\n+fn test_rchunks_exact_mut_zip_aliasing() {\n+    let v1: &mut [i32] = &mut [0, 1, 2, 3, 4];\n+    let v2: &[i32] = &[6, 7, 8, 9, 10];\n+\n+    let mut it = v1.rchunks_exact_mut(2).zip(v2.chunks(2));\n+    let first = it.next().unwrap();\n+    let _ = it.next().unwrap();\n+    assert_eq!(first, (&mut [3, 4][..], &[6, 7][..]));\n+}\n+\n #[test]\n fn test_chunks_exact_count() {\n     let v: &[i32] = &[0, 1, 2, 3, 4, 5];"}]}