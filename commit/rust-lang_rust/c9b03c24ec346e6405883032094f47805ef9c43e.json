{"sha": "c9b03c24ec346e6405883032094f47805ef9c43e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5YjAzYzI0ZWMzNDZlNjQwNTg4MzAzMjA5NGY0NzgwNWVmOWM0M2U=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-12T20:13:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-12T20:13:23Z"}, "message": "Auto merge of #23265 - eddyb:meth-ast-refactor, r=nikomatsakis\n\nThe end result is that common fields (id, name, attributes, etc.) are stored in now-structures `ImplItem` and `TraitItem`.\r\nThe signature of a method is no longer duplicated between methods with a body (default/impl) and those without, they now share `MethodSig`.\r\n\r\nThis is also a [breaking-change] because of minor bugfixes and changes to syntax extensions:\r\n* `pub fn` methods in a trait no longer parse - remove the `pub`, it has no meaning anymore\r\n* `MacResult::make_methods` is now `make_impl_items` and the return type has changed accordingly\r\n* `quote_method` is gone, because `P<ast::Method>` doesn't exist and it couldn't represent a full method anyways - could be replaced by `quote_impl_item`/`quote_trait_item` in the future, but I do hope we realize how silly that combinatorial macro expansion is and settle on a single `quote` macro + some type hints - or just no types at all (only token-trees)\r\n\r\nr? @nikomatsakis This is necessary (hopefully also sufficient) for associated constants.", "tree": {"sha": "cbb2bb6a0cd2a2e65b2cacd87d31bd8737f02e7d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cbb2bb6a0cd2a2e65b2cacd87d31bd8737f02e7d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c9b03c24ec346e6405883032094f47805ef9c43e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c9b03c24ec346e6405883032094f47805ef9c43e", "html_url": "https://github.com/rust-lang/rust/commit/c9b03c24ec346e6405883032094f47805ef9c43e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c9b03c24ec346e6405883032094f47805ef9c43e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "538840bc2d1b634a2a34b2c8bd72d99894058b66", "url": "https://api.github.com/repos/rust-lang/rust/commits/538840bc2d1b634a2a34b2c8bd72d99894058b66", "html_url": "https://github.com/rust-lang/rust/commit/538840bc2d1b634a2a34b2c8bd72d99894058b66"}, {"sha": "9da918548d77182ca64f375fb6da24036d5ad60c", "url": "https://api.github.com/repos/rust-lang/rust/commits/9da918548d77182ca64f375fb6da24036d5ad60c", "html_url": "https://github.com/rust-lang/rust/commit/9da918548d77182ca64f375fb6da24036d5ad60c"}], "stats": {"total": 4091, "additions": 1516, "deletions": 2575}, "files": [{"sha": "9aa6395b7b278b11b21bdf2c198340e956c4390b", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 16, "deletions": 25, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -519,28 +519,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n \n     fn visit_fn(&mut self, fk: FnKind<'v>, decl: &'v ast::FnDecl,\n                 body: &'v ast::Block, span: Span, id: ast::NodeId) {\n-        match fk {\n-            visit::FkMethod(_, _, m) => {\n-                self.with_lint_attrs(&m.attrs, |cx| {\n-                    run_lints!(cx, check_fn, fk, decl, body, span, id);\n-                    cx.visit_ids(|v| {\n-                        v.visit_fn(fk, decl, body, span, id);\n-                    });\n-                    visit::walk_fn(cx, fk, decl, body, span);\n-                })\n-            },\n-            _ => {\n-                run_lints!(self, check_fn, fk, decl, body, span, id);\n-                visit::walk_fn(self, fk, decl, body, span);\n-            }\n-        }\n-    }\n-\n-    fn visit_ty_method(&mut self, t: &ast::TypeMethod) {\n-        self.with_lint_attrs(&t.attrs, |cx| {\n-            run_lints!(cx, check_ty_method, t);\n-            visit::walk_ty_method(cx, t);\n-        })\n+        run_lints!(self, check_fn, fk, decl, body, span, id);\n+        visit::walk_fn(self, fk, decl, body, span);\n     }\n \n     fn visit_struct_def(&mut self,\n@@ -611,9 +591,20 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n         visit::walk_generics(self, g);\n     }\n \n-    fn visit_trait_item(&mut self, m: &ast::TraitItem) {\n-        run_lints!(self, check_trait_item, m);\n-        visit::walk_trait_item(self, m);\n+    fn visit_trait_item(&mut self, trait_item: &ast::TraitItem) {\n+        self.with_lint_attrs(&trait_item.attrs, |cx| {\n+            run_lints!(cx, check_trait_item, trait_item);\n+            cx.visit_ids(|v| v.visit_trait_item(trait_item));\n+            visit::walk_trait_item(cx, trait_item);\n+        });\n+    }\n+\n+    fn visit_impl_item(&mut self, impl_item: &ast::ImplItem) {\n+        self.with_lint_attrs(&impl_item.attrs, |cx| {\n+            run_lints!(cx, check_impl_item, impl_item);\n+            cx.visit_ids(|v| v.visit_impl_item(impl_item));\n+            visit::walk_impl_item(cx, impl_item);\n+        });\n     }\n \n     fn visit_opt_lifetime_ref(&mut self, sp: Span, lt: &Option<ast::Lifetime>) {"}, {"sha": "23f9cbc3a4b9cd37391b80598ee2c52a97840bd5", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -143,8 +143,8 @@ pub trait LintPass {\n     fn check_generics(&mut self, _: &Context, _: &ast::Generics) { }\n     fn check_fn(&mut self, _: &Context,\n         _: FnKind, _: &ast::FnDecl, _: &ast::Block, _: Span, _: ast::NodeId) { }\n-    fn check_ty_method(&mut self, _: &Context, _: &ast::TypeMethod) { }\n     fn check_trait_item(&mut self, _: &Context, _: &ast::TraitItem) { }\n+    fn check_impl_item(&mut self, _: &Context, _: &ast::ImplItem) { }\n     fn check_struct_def(&mut self, _: &Context,\n         _: &ast::StructDef, _: ast::Ident, _: &ast::Generics, _: ast::NodeId) { }\n     fn check_struct_def_post(&mut self, _: &Context,"}, {"sha": "611d8bc27d19d5fa849827a7d0cd1b9e18714411", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 36, "deletions": 68, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -808,7 +808,7 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                     impl_path: PathElems,\n                                     is_default_impl: bool,\n                                     parent_id: NodeId,\n-                                    ast_item_opt: Option<&ast::ImplItem>) {\n+                                    impl_item_opt: Option<&ast::ImplItem>) {\n \n     debug!(\"encode_info_for_method: {:?} {:?}\", m.def_id,\n            token::get_name(m.name));\n@@ -826,21 +826,20 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n \n     let elem = ast_map::PathName(m.name);\n     encode_path(rbml_w, impl_path.chain(Some(elem).into_iter()));\n-    match ast_item_opt {\n-        Some(&ast::MethodImplItem(ref ast_method)) => {\n-            encode_attributes(rbml_w, &ast_method.attrs);\n+    if let Some(impl_item) = impl_item_opt {\n+        if let ast::MethodImplItem(ref sig, _) = impl_item.node {\n+            encode_attributes(rbml_w, &impl_item.attrs);\n             let scheme = ty::lookup_item_type(ecx.tcx, m.def_id);\n             let any_types = !scheme.generics.types.is_empty();\n-            if any_types || is_default_impl || attr::requests_inline(&ast_method.attrs) {\n+            if any_types || is_default_impl || attr::requests_inline(&impl_item.attrs) {\n                 encode_inlined_item(ecx, rbml_w, IIImplItemRef(local_def(parent_id),\n-                                                               ast_item_opt.unwrap()));\n+                                                               impl_item));\n             }\n             if !any_types {\n                 encode_symbol(ecx, rbml_w, m.def_id.node);\n             }\n-            encode_method_argument_names(rbml_w, ast_method.pe_fn_decl());\n+            encode_method_argument_names(rbml_w, &sig.decl);\n         }\n-        Some(_) | None => {}\n     }\n \n     rbml_w.end_tag();\n@@ -851,7 +850,7 @@ fn encode_info_for_associated_type(ecx: &EncodeContext,\n                                    associated_type: &ty::AssociatedType,\n                                    impl_path: PathElems,\n                                    parent_id: NodeId,\n-                                   typedef_opt: Option<P<ast::Typedef>>) {\n+                                   impl_item_opt: Option<&ast::ImplItem>) {\n     debug!(\"encode_info_for_associated_type({:?},{:?})\",\n            associated_type.def_id,\n            token::get_name(associated_type.name));\n@@ -873,13 +872,9 @@ fn encode_info_for_associated_type(ecx: &EncodeContext,\n     let elem = ast_map::PathName(associated_type.name);\n     encode_path(rbml_w, impl_path.chain(Some(elem).into_iter()));\n \n-    match typedef_opt {\n-        None => {}\n-        Some(typedef) => {\n-            encode_attributes(rbml_w, &typedef.attrs);\n-            encode_type(ecx, rbml_w, ty::node_id_to_type(ecx.tcx,\n-                                                         typedef.id));\n-        }\n+    if let Some(ii) = impl_item_opt {\n+        encode_attributes(rbml_w, &ii.attrs);\n+        encode_type(ecx, rbml_w, ty::node_id_to_type(ecx.tcx, ii.id));\n     }\n \n     rbml_w.end_tag();\n@@ -1226,7 +1221,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         let num_implemented_methods = ast_items.len();\n         for (i, &trait_item_def_id) in items.iter().enumerate() {\n             let ast_item = if i < num_implemented_methods {\n-                Some(&ast_items[i])\n+                Some(&*ast_items[i])\n             } else {\n                 None\n             };\n@@ -1236,11 +1231,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                 pos: rbml_w.mark_stable_position(),\n             });\n \n-            let trait_item_type =\n-                ty::impl_or_trait_item(tcx, trait_item_def_id.def_id());\n-            match (trait_item_type, ast_item) {\n-                (ty::MethodTraitItem(ref method_type),\n-                 Some(&ast::MethodImplItem(_))) => {\n+            match ty::impl_or_trait_item(tcx, trait_item_def_id.def_id()) {\n+                ty::MethodTraitItem(ref method_type) => {\n                     encode_info_for_method(ecx,\n                                            rbml_w,\n                                            &**method_type,\n@@ -1249,31 +1241,13 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                                            item.id,\n                                            ast_item)\n                 }\n-                (ty::MethodTraitItem(ref method_type), _) => {\n-                    encode_info_for_method(ecx,\n-                                           rbml_w,\n-                                           &**method_type,\n-                                           path.clone(),\n-                                           false,\n-                                           item.id,\n-                                           None)\n-                }\n-                (ty::TypeTraitItem(ref associated_type),\n-                 Some(&ast::TypeImplItem(ref typedef))) => {\n-                    encode_info_for_associated_type(ecx,\n-                                                    rbml_w,\n-                                                    &**associated_type,\n-                                                    path.clone(),\n-                                                    item.id,\n-                                                    Some((*typedef).clone()))\n-                }\n-                (ty::TypeTraitItem(ref associated_type), _) => {\n+                ty::TypeTraitItem(ref associated_type) => {\n                     encode_info_for_associated_type(ecx,\n                                                     rbml_w,\n                                                     &**associated_type,\n                                                     path.clone(),\n                                                     item.id,\n-                                                    None)\n+                                                    ast_item)\n                 }\n             }\n         }\n@@ -1387,35 +1361,29 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n             encode_parent_sort(rbml_w, 't');\n \n-            let trait_item = &ms[i];\n-            let encode_trait_item = |rbml_w: &mut Encoder| {\n-                // If this is a static method, we've already\n-                // encoded this.\n-                if is_nonstatic_method {\n-                    // FIXME: I feel like there is something funny\n-                    // going on.\n-                    encode_bounds_and_type_for_item(rbml_w, ecx, item_def_id.def_id().local_id());\n-                }\n-            };\n-            match trait_item {\n-                &ast::RequiredMethod(ref m) => {\n-                    encode_attributes(rbml_w, &m.attrs);\n-                    encode_trait_item(rbml_w);\n-                    encode_item_sort(rbml_w, 'r');\n-                    encode_method_argument_names(rbml_w, &*m.decl);\n-                }\n+            let trait_item = &*ms[i];\n+            encode_attributes(rbml_w, &trait_item.attrs);\n+            match trait_item.node {\n+                ast::MethodTraitItem(ref sig, ref body) => {\n+                    // If this is a static method, we've already\n+                    // encoded this.\n+                    if is_nonstatic_method {\n+                        // FIXME: I feel like there is something funny\n+                        // going on.\n+                        encode_bounds_and_type_for_item(rbml_w, ecx,\n+                            item_def_id.def_id().local_id());\n+                    }\n \n-                &ast::ProvidedMethod(ref m) => {\n-                    encode_attributes(rbml_w, &m.attrs);\n-                    encode_trait_item(rbml_w);\n-                    encode_item_sort(rbml_w, 'p');\n-                    encode_inlined_item(ecx, rbml_w, IITraitItemRef(def_id, trait_item));\n-                    encode_method_argument_names(rbml_w, &*m.pe_fn_decl());\n+                    if body.is_some() {\n+                        encode_item_sort(rbml_w, 'p');\n+                        encode_inlined_item(ecx, rbml_w, IITraitItemRef(def_id, trait_item));\n+                    } else {\n+                        encode_item_sort(rbml_w, 'r');\n+                    }\n+                    encode_method_argument_names(rbml_w, &sig.decl);\n                 }\n \n-                &ast::TypeTraitItem(ref associated_type) => {\n-                    encode_attributes(rbml_w,\n-                                      &associated_type.attrs);\n+                ast::TypeTraitItem(..) => {\n                     encode_item_sort(rbml_w, 't');\n                 }\n             }"}, {"sha": "fb5b934c2cd8d9b4010dceca1fd0d60aaa7f8630", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 13, "deletions": 50, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -32,7 +32,6 @@ use middle::ty::{self, Ty, MethodCall, MethodCallee, MethodOrigin};\n use util::ppaux::ty_to_string;\n \n use syntax::{ast, ast_map, ast_util, codemap, fold};\n-use syntax::ast_util::PostExpansionMethod;\n use syntax::codemap::Span;\n use syntax::fold::Folder;\n use syntax::parse::token;\n@@ -81,11 +80,8 @@ pub fn encode_inlined_item(ecx: &e::EncodeContext,\n     let id = match ii {\n         e::IIItemRef(i) => i.id,\n         e::IIForeignRef(i) => i.id,\n-        e::IITraitItemRef(_, &ast::ProvidedMethod(ref m)) => m.id,\n-        e::IITraitItemRef(_, &ast::RequiredMethod(ref m)) => m.id,\n-        e::IITraitItemRef(_, &ast::TypeTraitItem(ref ti)) => ti.ty_param.id,\n-        e::IIImplItemRef(_, &ast::MethodImplItem(ref m)) => m.id,\n-        e::IIImplItemRef(_, &ast::TypeImplItem(ref ti)) => ti.id,\n+        e::IITraitItemRef(_, ti) => ti.id,\n+        e::IIImplItemRef(_, ii) => ii.id,\n     };\n     debug!(\"> Encoding inlined item: {} ({:?})\",\n            ecx.tcx.map.path_to_string(id),\n@@ -157,19 +153,8 @@ pub fn decode_inlined_item<'tcx>(cdata: &cstore::crate_metadata,\n         let ident = match *ii {\n             ast::IIItem(ref i) => i.ident,\n             ast::IIForeign(ref i) => i.ident,\n-            ast::IITraitItem(_, ref ti) => {\n-                match *ti {\n-                    ast::ProvidedMethod(ref m) => m.pe_ident(),\n-                    ast::RequiredMethod(ref ty_m) => ty_m.ident,\n-                    ast::TypeTraitItem(ref ti) => ti.ty_param.ident,\n-                }\n-            },\n-            ast::IIImplItem(_, ref m) => {\n-                match *m {\n-                    ast::MethodImplItem(ref m) => m.pe_ident(),\n-                    ast::TypeImplItem(ref ti) => ti.ident,\n-                }\n-            }\n+            ast::IITraitItem(_, ref ti) => ti.ident,\n+            ast::IIImplItem(_, ref ii) => ii.ident\n         };\n         debug!(\"Fn named: {}\", token::get_ident(ident));\n         debug!(\"< Decoded inlined fn: {}::{}\",\n@@ -412,38 +397,16 @@ fn simplify_ast(ii: e::InlinedItemRef) -> ast::InlinedItem {\n                             .expect_one(\"expected one item\"))\n         }\n         e::IITraitItemRef(d, ti) => {\n-            ast::IITraitItem(d, match *ti {\n-                ast::ProvidedMethod(ref m) => {\n-                    ast::ProvidedMethod(\n-                        fold::noop_fold_method(m.clone(), &mut fld)\n-                            .expect_one(\"noop_fold_method must produce \\\n-                                         exactly one method\"))\n-                }\n-                ast::RequiredMethod(ref ty_m) => {\n-                    ast::RequiredMethod(\n-                        fold::noop_fold_type_method(ty_m.clone(), &mut fld))\n-                }\n-                ast::TypeTraitItem(ref associated_type) => {\n-                    ast::TypeTraitItem(\n-                        P(fold::noop_fold_associated_type(\n-                            (**associated_type).clone(),\n-                            &mut fld)))\n-                }\n-            })\n+            ast::IITraitItem(d,\n+                fold::noop_fold_trait_item(P(ti.clone()), &mut fld)\n+                    .expect_one(\"noop_fold_trait_item must produce \\\n+                                 exactly one trait item\"))\n         }\n-        e::IIImplItemRef(d, m) => {\n-            ast::IIImplItem(d, match *m {\n-                ast::MethodImplItem(ref m) => {\n-                    ast::MethodImplItem(\n-                        fold::noop_fold_method(m.clone(), &mut fld)\n-                            .expect_one(\"noop_fold_method must produce \\\n-                                         exactly one method\"))\n-                }\n-                ast::TypeImplItem(ref td) => {\n-                    ast::TypeImplItem(\n-                        P(fold::noop_fold_typedef((**td).clone(), &mut fld)))\n-                }\n-            })\n+        e::IIImplItemRef(d, ii) => {\n+            ast::IIImplItem(d,\n+                fold::noop_fold_impl_item(P(ii.clone()), &mut fld)\n+                    .expect_one(\"noop_fold_impl_item must produce \\\n+                                 exactly one impl item\"))\n         }\n         e::IIForeignRef(i) => {\n             ast::IIForeign(fold::noop_fold_foreign_item(P(i.clone()), &mut fld))"}, {"sha": "5efea66ab0c6cc751cff9f1550057df4657780f7", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 30, "deletions": 34, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -18,7 +18,7 @@ use util::nodemap::NodeSet;\n \n use std::collections::HashSet;\n use syntax::{ast, ast_map, codemap};\n-use syntax::ast_util::{local_def, is_local, PostExpansionMethod};\n+use syntax::ast_util::{local_def, is_local};\n use syntax::attr::{self, AttrMetaMethods};\n use syntax::visit::{self, Visitor};\n \n@@ -228,16 +228,11 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                     _ => ()\n                 }\n             }\n-            ast_map::NodeTraitItem(trait_method) => {\n-                visit::walk_trait_item(self, trait_method);\n+            ast_map::NodeTraitItem(trait_item) => {\n+                visit::walk_trait_item(self, trait_item);\n             }\n             ast_map::NodeImplItem(impl_item) => {\n-                match *impl_item {\n-                    ast::MethodImplItem(ref method) => {\n-                        visit::walk_method_helper(self, method);\n-                    }\n-                    ast::TypeImplItem(_) => {}\n-                }\n+                visit::walk_impl_item(self, impl_item);\n             }\n             ast_map::NodeForeignItem(foreign_item) => {\n                 visit::walk_foreign_item(self, &*foreign_item);\n@@ -355,35 +350,36 @@ impl<'v> Visitor<'v> for LifeSeeder {\n             ast::ItemEnum(ref enum_def, _) if allow_dead_code => {\n                 self.worklist.extend(enum_def.variants.iter().map(|variant| variant.node.id));\n             }\n-            ast::ItemImpl(_, _, _, Some(ref _trait_ref), _, ref impl_items) => {\n+            ast::ItemTrait(_, _, _, ref trait_items) => {\n+                for trait_item in trait_items {\n+                    match trait_item.node {\n+                        ast::MethodTraitItem(_, Some(_)) => {\n+                            if has_allow_dead_code_or_lang_attr(&trait_item.attrs) {\n+                                self.worklist.push(trait_item.id);\n+                            }\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+            }\n+            ast::ItemImpl(_, _, _, ref opt_trait, _, ref impl_items) => {\n                 for impl_item in impl_items {\n-                    match *impl_item {\n-                        ast::MethodImplItem(ref method) => {\n-                            self.worklist.push(method.id);\n+                    match impl_item.node {\n+                        ast::MethodImplItem(..) => {\n+                            if opt_trait.is_some() ||\n+                                    has_allow_dead_code_or_lang_attr(&impl_item.attrs) {\n+                                self.worklist.push(impl_item.id);\n+                            }\n                         }\n                         ast::TypeImplItem(_) => {}\n+                        ast::MacImplItem(_) => panic!(\"unexpanded macro\")\n                     }\n                 }\n             }\n             _ => ()\n         }\n         visit::walk_item(self, item);\n     }\n-\n-    fn visit_fn(&mut self, fk: visit::FnKind<'v>,\n-                _: &'v ast::FnDecl, block: &'v ast::Block,\n-                _: codemap::Span, id: ast::NodeId) {\n-        // Check for method here because methods are not ast::Item\n-        match fk {\n-            visit::FkMethod(_, _, method) => {\n-                if has_allow_dead_code_or_lang_attr(&method.attrs) {\n-                    self.worklist.push(id);\n-                }\n-            }\n-            _ => ()\n-        }\n-        visit::walk_block(self, block);\n-    }\n }\n \n fn create_and_seed_worklist(tcx: &ty::ctxt,\n@@ -561,7 +557,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n                 span: codemap::Span, id: ast::NodeId) {\n         // Have to warn method here because methods are not ast::Item\n         match fk {\n-            visit::FkMethod(name, _, _) => {\n+            visit::FkMethod(name, _) => {\n                 if !self.symbol_is_live(id, None) {\n                     self.warn_dead_code(id, span, name, \"method\");\n                 }\n@@ -582,12 +578,12 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n \n     // Overwrite so that we don't warn the trait method itself.\n     fn visit_trait_item(&mut self, trait_method: &ast::TraitItem) {\n-        match *trait_method {\n-            ast::ProvidedMethod(ref method) => {\n-                visit::walk_block(self, &*method.pe_body())\n+        match trait_method.node {\n+            ast::MethodTraitItem(_, Some(ref body)) => {\n+                visit::walk_block(self, body)\n             }\n-            ast::RequiredMethod(_) => {}\n-            ast::TypeTraitItem(_) => {}\n+            ast::MethodTraitItem(_, None) |\n+            ast::TypeTraitItem(..) => {}\n         }\n     }\n }"}, {"sha": "378f3db0823391064cc40409021c97497134dddd", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -18,7 +18,6 @@ use middle::ty::MethodCall;\n use util::ppaux;\n \n use syntax::ast;\n-use syntax::ast_util::PostExpansionMethod;\n use syntax::codemap::Span;\n use syntax::visit;\n use syntax::visit::Visitor;\n@@ -90,8 +89,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n         let (is_item_fn, is_unsafe_fn) = match fn_kind {\n             visit::FkItemFn(_, _, fn_style, _) =>\n                 (true, fn_style == ast::Unsafety::Unsafe),\n-            visit::FkMethod(_, _, method) =>\n-                (true, method.pe_unsafety() == ast::Unsafety::Unsafe),\n+            visit::FkMethod(_, sig) =>\n+                (true, sig.unsafety == ast::Unsafety::Unsafe),\n             _ => (false, false),\n         };\n "}, {"sha": "1ca56596a014732f6840441a3987b3d5d7ab85d0", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -83,7 +83,7 @@ use std::rc::Rc;\n use std::string::String;\n use syntax::ast;\n use syntax::ast_map;\n-use syntax::ast_util::{name_to_dummy_lifetime, PostExpansionMethod};\n+use syntax::ast_util::name_to_dummy_lifetime;\n use syntax::owned_slice::OwnedSlice;\n use syntax::codemap;\n use syntax::parse::token;\n@@ -841,33 +841,34 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                 ast_map::NodeItem(ref item) => {\n                     match item.node {\n                         ast::ItemFn(ref fn_decl, pur, _, ref gen, _) => {\n-                            Some((&**fn_decl, gen, pur, item.ident, None, item.span))\n+                            Some((fn_decl, gen, pur, item.ident, None, item.span))\n                         },\n                         _ => None\n                     }\n                 }\n-                ast_map::NodeImplItem(ref item) => {\n-                    match **item {\n-                        ast::MethodImplItem(ref m) => {\n-                            Some((m.pe_fn_decl(),\n-                                  m.pe_generics(),\n-                                  m.pe_unsafety(),\n-                                  m.pe_ident(),\n-                                  Some(&m.pe_explicit_self().node),\n-                                  m.span))\n+                ast_map::NodeImplItem(item) => {\n+                    match item.node {\n+                        ast::MethodImplItem(ref sig, _) => {\n+                            Some((&sig.decl,\n+                                  &sig.generics,\n+                                  sig.unsafety,\n+                                  item.ident,\n+                                  Some(&sig.explicit_self.node),\n+                                  item.span))\n                         }\n                         ast::TypeImplItem(_) => None,\n+                        ast::MacImplItem(_) => self.tcx.sess.bug(\"unexpanded macro\")\n                     }\n                 },\n-                ast_map::NodeTraitItem(ref item) => {\n-                    match **item {\n-                        ast::ProvidedMethod(ref m) => {\n-                            Some((m.pe_fn_decl(),\n-                                  m.pe_generics(),\n-                                  m.pe_unsafety(),\n-                                  m.pe_ident(),\n-                                  Some(&m.pe_explicit_self().node),\n-                                  m.span))\n+                ast_map::NodeTraitItem(item) => {\n+                    match item.node {\n+                        ast::MethodTraitItem(ref sig, Some(_)) => {\n+                            Some((&sig.decl,\n+                                  &sig.generics,\n+                                  sig.unsafety,\n+                                  item.ident,\n+                                  Some(&sig.explicit_self.node),\n+                                  item.span))\n                         }\n                         _ => None\n                     }\n@@ -1730,12 +1731,13 @@ fn lifetimes_in_scope(tcx: &ty::ctxt,\n                 _ => None\n             },\n             ast_map::NodeImplItem(ii) => {\n-                match *ii {\n-                    ast::MethodImplItem(ref m) => {\n-                        taken.push_all(&m.pe_generics().lifetimes);\n-                        Some(m.id)\n+                match ii.node {\n+                    ast::MethodImplItem(ref sig, _) => {\n+                        taken.push_all(&sig.generics.lifetimes);\n+                        Some(ii.id)\n                     }\n                     ast::TypeImplItem(_) => None,\n+                    ast::MacImplItem(_) => tcx.sess.bug(\"unexpanded macro\")\n                 }\n             }\n             _ => None"}, {"sha": "7ded344414ce698bf328818b6ea1ef645553bd0d", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -25,7 +25,7 @@ use std::collections::HashSet;\n use syntax::abi;\n use syntax::ast;\n use syntax::ast_map;\n-use syntax::ast_util::{is_local, PostExpansionMethod};\n+use syntax::ast_util::is_local;\n use syntax::attr;\n use syntax::visit::Visitor;\n use syntax::visit;\n@@ -53,10 +53,11 @@ fn item_might_be_inlined(item: &ast::Item) -> bool {\n     }\n }\n \n-fn method_might_be_inlined(tcx: &ty::ctxt, method: &ast::Method,\n+fn method_might_be_inlined(tcx: &ty::ctxt, sig: &ast::MethodSig,\n+                           impl_item: &ast::ImplItem,\n                            impl_src: ast::DefId) -> bool {\n-    if attr::requests_inline(&method.attrs) ||\n-        generics_require_inlining(method.pe_generics()) {\n+    if attr::requests_inline(&impl_item.attrs) ||\n+        generics_require_inlining(&sig.generics) {\n         return true\n     }\n     if is_local(impl_src) {\n@@ -66,13 +67,13 @@ fn method_might_be_inlined(tcx: &ty::ctxt, method: &ast::Method,\n                     item_might_be_inlined(&*item)\n                 }\n                 Some(..) | None => {\n-                    tcx.sess.span_bug(method.span, \"impl did is not an item\")\n+                    tcx.sess.span_bug(impl_item.span, \"impl did is not an item\")\n                 }\n             }\n         }\n     } else {\n-        tcx.sess.span_bug(method.span, \"found a foreign impl as a parent of a \\\n-                                        local method\")\n+        tcx.sess.span_bug(impl_item.span, \"found a foreign impl as a parent \\\n+                                           of a local method\")\n     }\n }\n \n@@ -181,17 +182,16 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                 }\n             }\n             Some(ast_map::NodeTraitItem(trait_method)) => {\n-                match *trait_method {\n-                    ast::RequiredMethod(_) => false,\n-                    ast::ProvidedMethod(_) => true,\n-                    ast::TypeTraitItem(_) => false,\n+                match trait_method.node {\n+                    ast::MethodTraitItem(_, ref body) => body.is_some(),\n+                    ast::TypeTraitItem(..) => false,\n                 }\n             }\n             Some(ast_map::NodeImplItem(impl_item)) => {\n-                match *impl_item {\n-                    ast::MethodImplItem(ref method) => {\n-                        if generics_require_inlining(method.pe_generics()) ||\n-                                attr::requests_inline(&method.attrs) {\n+                match impl_item.node {\n+                    ast::MethodImplItem(ref sig, _) => {\n+                        if generics_require_inlining(&sig.generics) ||\n+                                attr::requests_inline(&impl_item.attrs) {\n                             true\n                         } else {\n                             let impl_did = self.tcx\n@@ -213,6 +213,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                         }\n                     }\n                     ast::TypeImplItem(_) => false,\n+                    ast::MacImplItem(_) => self.tcx.sess.bug(\"unexpanded macro\")\n                 }\n             }\n             Some(_) => false,\n@@ -301,25 +302,26 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                 }\n             }\n             ast_map::NodeTraitItem(trait_method) => {\n-                match *trait_method {\n-                    ast::RequiredMethod(..) => {\n+                match trait_method.node {\n+                    ast::MethodTraitItem(_, None) => {\n                         // Keep going, nothing to get exported\n                     }\n-                    ast::ProvidedMethod(ref method) => {\n-                        visit::walk_block(self, &*method.pe_body());\n+                    ast::MethodTraitItem(_, Some(ref body)) => {\n+                        visit::walk_block(self, body);\n                     }\n-                    ast::TypeTraitItem(_) => {}\n+                    ast::TypeTraitItem(..) => {}\n                 }\n             }\n             ast_map::NodeImplItem(impl_item) => {\n-                match *impl_item {\n-                    ast::MethodImplItem(ref method) => {\n+                match impl_item.node {\n+                    ast::MethodImplItem(ref sig, ref body) => {\n                         let did = self.tcx.map.get_parent_did(search_item);\n-                        if method_might_be_inlined(self.tcx, &**method, did) {\n-                            visit::walk_block(self, method.pe_body())\n+                        if method_might_be_inlined(self.tcx, sig, impl_item, did) {\n+                            visit::walk_block(self, body)\n                         }\n                     }\n                     ast::TypeImplItem(_) => {}\n+                    ast::MacImplItem(_) => self.tcx.sess.bug(\"unexpanded macro\")\n                 }\n             }\n             // Nothing to recurse on for these"}, {"sha": "e33a255343161b17769f70912d74badd77e7d394", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -142,12 +142,16 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n     fn visit_fn(&mut self, fk: visit::FnKind<'v>, fd: &'v ast::FnDecl,\n                 b: &'v ast::Block, s: Span, _: ast::NodeId) {\n         match fk {\n-            visit::FkItemFn(_, generics, _, _) |\n-            visit::FkMethod(_, generics, _) => {\n+            visit::FkItemFn(_, generics, _, _) => {\n                 self.visit_early_late(subst::FnSpace, generics, |this| {\n                     visit::walk_fn(this, fk, fd, b, s)\n                 })\n             }\n+            visit::FkMethod(_, sig) => {\n+                self.visit_early_late(subst::FnSpace, &sig.generics, |this| {\n+                    visit::walk_fn(this, fk, fd, b, s)\n+                })\n+            }\n             visit::FkFnBlock(..) => {\n                 visit::walk_fn(self, fk, fd, b, s)\n             }\n@@ -185,10 +189,14 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n         }\n     }\n \n-    fn visit_ty_method(&mut self, m: &ast::TypeMethod) {\n-        self.visit_early_late(\n-            subst::FnSpace, &m.generics,\n-            |this| visit::walk_ty_method(this, m))\n+    fn visit_trait_item(&mut self, trait_item: &ast::TraitItem) {\n+        if let ast::MethodTraitItem(ref sig, None) = trait_item.node {\n+            self.visit_early_late(\n+                subst::FnSpace, &sig.generics,\n+                |this| visit::walk_trait_item(this, trait_item))\n+        } else {\n+            visit::walk_trait_item(self, trait_item);\n+        }\n     }\n \n     fn visit_block(&mut self, b: &ast::Block) {"}, {"sha": "01766b0de085f0c4d32d5f2b70aec2a3d6257366", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 13, "deletions": 36, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -22,11 +22,10 @@ use syntax::codemap::{Span, DUMMY_SP};\n use syntax::{attr, visit};\n use syntax::ast;\n use syntax::ast::{Attribute, Block, Crate, DefId, FnDecl, NodeId, Variant};\n-use syntax::ast::{Item, RequiredMethod, ProvidedMethod, TraitItem};\n-use syntax::ast::{TypeMethod, Method, Generics, StructField, TypeTraitItem};\n+use syntax::ast::{Item, Generics, StructField};\n use syntax::ast_util::is_local;\n use syntax::attr::{Stability, AttrMetaMethods};\n-use syntax::visit::{FnKind, FkMethod, Visitor};\n+use syntax::visit::{FnKind, Visitor};\n use syntax::feature_gate::emit_feature_warn;\n use util::nodemap::{NodeMap, DefIdMap, FnvHashSet, FnvHashMap};\n use util::ppaux::Repr;\n@@ -124,31 +123,20 @@ impl<'a, 'v> Visitor<'v> for Annotator<'a> {\n         }\n     }\n \n-    fn visit_fn(&mut self, fk: FnKind<'v>, _: &'v FnDecl,\n-                _: &'v Block, sp: Span, _: NodeId) {\n-        if let FkMethod(_, _, meth) = fk {\n-            // Methods are not already annotated, so we annotate it\n-            self.annotate(meth.id, true, &meth.attrs, sp, |_| {}, true);\n-        }\n+    fn visit_fn(&mut self, _: FnKind<'v>, _: &'v FnDecl,\n+                _: &'v Block, _: Span, _: NodeId) {\n         // Items defined in a function body have no reason to have\n         // a stability attribute, so we don't recurse.\n     }\n \n-    fn visit_trait_item(&mut self, t: &TraitItem) {\n-        let (id, attrs, sp) = match *t {\n-            RequiredMethod(TypeMethod {id, ref attrs, span, ..}) => (id, attrs, span),\n-\n-            // work around lack of pattern matching for @ types\n-            ProvidedMethod(ref method) => {\n-                match **method {\n-                    Method {ref attrs, id, span, ..} => (id, attrs, span),\n-                }\n-            }\n+    fn visit_trait_item(&mut self, ti: &ast::TraitItem) {\n+        self.annotate(ti.id, true, &ti.attrs, ti.span,\n+                      |v| visit::walk_trait_item(v, ti), true);\n+    }\n \n-            TypeTraitItem(ref typedef) => (typedef.ty_param.id, &typedef.attrs,\n-                                           typedef.ty_param.span),\n-        };\n-        self.annotate(id, true, attrs, sp, |v| visit::walk_trait_item(v, t), true);\n+    fn visit_impl_item(&mut self, ii: &ast::ImplItem) {\n+        self.annotate(ii.id, true, &ii.attrs, ii.span,\n+                      |v| visit::walk_impl_item(v, ii), true);\n     }\n \n     fn visit_variant(&mut self, var: &Variant, g: &'v Generics) {\n@@ -335,22 +323,11 @@ pub fn check_item(tcx: &ty::ctxt, item: &ast::Item, warn_about_defns: bool,\n             let trait_items = ty::trait_items(tcx, trait_did);\n \n             for impl_item in impl_items {\n-                let (ident, span) = match *impl_item {\n-                    ast::MethodImplItem(ref method) => {\n-                        (match method.node {\n-                            ast::MethDecl(ident, _, _, _, _, _, _, _) => ident,\n-                            ast::MethMac(..) => unreachable!(),\n-                        }, method.span)\n-                    }\n-                    ast::TypeImplItem(ref typedef) => {\n-                        (typedef.ident, typedef.span)\n-                    }\n-                };\n                 let item = trait_items.iter().find(|item| {\n-                    item.name() == ident.name\n+                    item.name() == impl_item.ident.name\n                 }).unwrap();\n                 if warn_about_defns {\n-                    maybe_do_stability_check(tcx, item.def_id(), span, cb);\n+                    maybe_do_stability_check(tcx, item.def_id(), impl_item.span, cb);\n                 }\n             }\n         }"}, {"sha": "8705e56b09425bbf6d81e483da51e9febc29d967", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 29, "deletions": 44, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -82,7 +82,7 @@ use syntax::abi;\n use syntax::ast::{CrateNum, DefId, Ident, ItemTrait, LOCAL_CRATE};\n use syntax::ast::{MutImmutable, MutMutable, Name, NamedField, NodeId};\n use syntax::ast::{StmtExpr, StmtSemi, StructField, UnnamedField, Visibility};\n-use syntax::ast_util::{self, is_local, lit_is_str, local_def, PostExpansionMethod};\n+use syntax::ast_util::{self, is_local, lit_is_str, local_def};\n use syntax::attr::{self, AttrMetaMethods};\n use syntax::codemap::Span;\n use syntax::parse::token::{self, InternedString, special_idents};\n@@ -2286,19 +2286,19 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n     pub fn for_item(cx: &'a ctxt<'tcx>, id: NodeId) -> ParameterEnvironment<'a, 'tcx> {\n         match cx.map.find(id) {\n             Some(ast_map::NodeImplItem(ref impl_item)) => {\n-                match **impl_item {\n-                    ast::MethodImplItem(ref method) => {\n+                match impl_item.node {\n+                    ast::MethodImplItem(_, ref body) => {\n                         let method_def_id = ast_util::local_def(id);\n                         match ty::impl_or_trait_item(cx, method_def_id) {\n                             MethodTraitItem(ref method_ty) => {\n                                 let method_generics = &method_ty.generics;\n                                 let method_bounds = &method_ty.predicates;\n                                 construct_parameter_environment(\n                                     cx,\n-                                    method.span,\n+                                    impl_item.span,\n                                     method_generics,\n                                     method_bounds,\n-                                    method.pe_body().id)\n+                                    body.id)\n                             }\n                             TypeTraitItem(_) => {\n                                 cx.sess\n@@ -2313,29 +2313,30 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                                      can't create a parameter environment \\\n                                      for type impl items\")\n                     }\n+                    ast::MacImplItem(_) => cx.sess.bug(\"unexpanded macro\")\n                 }\n             }\n-            Some(ast_map::NodeTraitItem(trait_method)) => {\n-                match *trait_method {\n-                    ast::RequiredMethod(ref required) => {\n-                        cx.sess.span_bug(required.span,\n+            Some(ast_map::NodeTraitItem(trait_item)) => {\n+                match trait_item.node {\n+                    ast::MethodTraitItem(_, None) => {\n+                        cx.sess.span_bug(trait_item.span,\n                                          \"ParameterEnvironment::for_item():\n                                           can't create a parameter \\\n                                           environment for required trait \\\n                                           methods\")\n                     }\n-                    ast::ProvidedMethod(ref method) => {\n+                    ast::MethodTraitItem(_, Some(ref body)) => {\n                         let method_def_id = ast_util::local_def(id);\n                         match ty::impl_or_trait_item(cx, method_def_id) {\n                             MethodTraitItem(ref method_ty) => {\n                                 let method_generics = &method_ty.generics;\n                                 let method_bounds = &method_ty.predicates;\n                                 construct_parameter_environment(\n                                     cx,\n-                                    method.span,\n+                                    trait_item.span,\n                                     method_generics,\n                                     method_bounds,\n-                                    method.pe_body().id)\n+                                    body.id)\n                             }\n                             TypeTraitItem(_) => {\n                                 cx.sess\n@@ -2345,7 +2346,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                             }\n                         }\n                     }\n-                    ast::TypeTraitItem(_) => {\n+                    ast::TypeTraitItem(..) => {\n                         cx.sess.bug(\"ParameterEnvironment::from_item(): \\\n                                      can't create a parameter environment \\\n                                      for type trait items\")\n@@ -5080,39 +5081,23 @@ pub fn provided_source(cx: &ctxt, id: ast::DefId) -> Option<ast::DefId> {\n pub fn provided_trait_methods<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                                     -> Vec<Rc<Method<'tcx>>> {\n     if is_local(id) {\n-        match cx.map.find(id.node) {\n-            Some(ast_map::NodeItem(item)) => {\n-                match item.node {\n-                    ItemTrait(_, _, _, ref ms) => {\n-                        let (_, p) =\n-                            ast_util::split_trait_methods(&ms[..]);\n-                        p.iter()\n-                         .map(|m| {\n-                            match impl_or_trait_item(\n-                                    cx,\n-                                    ast_util::local_def(m.id)) {\n-                                MethodTraitItem(m) => m,\n-                                TypeTraitItem(_) => {\n-                                    cx.sess.bug(\"provided_trait_methods(): \\\n-                                                 split_trait_methods() put \\\n-                                                 associated types in the \\\n-                                                 provided method bucket?!\")\n-                                }\n-                            }\n-                         }).collect()\n-                    }\n-                    _ => {\n-                        cx.sess.bug(&format!(\"provided_trait_methods: `{:?}` is \\\n-                                             not a trait\",\n-                                            id))\n+        if let ItemTrait(_, _, _, ref ms) = cx.map.expect_item(id.node).node {\n+            ms.iter().filter_map(|ti| {\n+                if let ast::MethodTraitItem(_, Some(_)) = ti.node {\n+                    match impl_or_trait_item(cx, ast_util::local_def(ti.id)) {\n+                        MethodTraitItem(m) => Some(m),\n+                        TypeTraitItem(_) => {\n+                            cx.sess.bug(\"provided_trait_methods(): \\\n+                                         associated type found from \\\n+                                         looking up ProvidedMethod?!\")\n+                        }\n                     }\n+                } else {\n+                    None\n                 }\n-            }\n-            _ => {\n-                cx.sess.bug(&format!(\"provided_trait_methods: `{:?}` is not a \\\n-                                     trait\",\n-                                    id))\n-            }\n+            }).collect()\n+        } else {\n+            cx.sess.bug(&format!(\"provided_trait_methods: `{:?}` is not a trait\", id))\n         }\n     } else {\n         csearch::get_provided_trait_methods(cx, id)"}, {"sha": "3a0b5832c9f5b626abfab415b74d7afcc9eda8cd", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -828,14 +828,11 @@ impl<'tcx> Repr<'tcx> for ty::TraitDef<'tcx> {\n \n impl<'tcx> Repr<'tcx> for ast::TraitItem {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        match *self {\n-            ast::RequiredMethod(ref data) => format!(\"RequiredMethod({}, id={})\",\n-                                                     data.ident, data.id),\n-            ast::ProvidedMethod(ref data) => format!(\"ProvidedMethod(id={})\",\n-                                                     data.id),\n-            ast::TypeTraitItem(ref data) => format!(\"TypeTraitItem({}, id={})\",\n-                                                     data.ty_param.ident, data.ty_param.id),\n-        }\n+        let kind = match self.node {\n+            ast::MethodTraitItem(..) => \"MethodTraitItem\",\n+            ast::TypeTraitItem(..) => \"TypeTraitItem\",\n+        };\n+        format!(\"{}({}, id={})\", kind, self.ident, self.id)\n     }\n }\n "}, {"sha": "467b7c1ca381987badf30c6c629cefdead924a30", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -188,8 +188,8 @@ mod svh_visitor {\n         SawTy,\n         SawGenerics,\n         SawFn,\n-        SawTyMethod,\n-        SawTraitMethod,\n+        SawTraitItem,\n+        SawImplItem,\n         SawStructField,\n         SawVariant,\n         SawExplicitSelf,\n@@ -463,12 +463,12 @@ mod svh_visitor {\n             SawFn.hash(self.st); visit::walk_fn(self, fk, fd, b, s)\n         }\n \n-        fn visit_ty_method(&mut self, t: &TypeMethod) {\n-            SawTyMethod.hash(self.st); visit::walk_ty_method(self, t)\n+        fn visit_trait_item(&mut self, ti: &TraitItem) {\n+            SawTraitItem.hash(self.st); visit::walk_trait_item(self, ti)\n         }\n \n-        fn visit_trait_item(&mut self, t: &TraitItem) {\n-            SawTraitMethod.hash(self.st); visit::walk_trait_item(self, t)\n+        fn visit_impl_item(&mut self, ii: &ImplItem) {\n+            SawImplItem.hash(self.st); visit::walk_impl_item(self, ii)\n         }\n \n         fn visit_struct_field(&mut self, s: &StructField) {"}, {"sha": "f3abcb4376c9851b9997a350f3733cb5fd276516", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 3, "deletions": 19, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -26,7 +26,6 @@ use rustc::util::ppaux::{Repr, UserString};\n use std::mem;\n use std::rc::Rc;\n use syntax::ast;\n-use syntax::ast_map;\n use syntax::attr::AttrMetaMethods;\n use syntax::codemap::Span;\n \n@@ -119,24 +118,9 @@ pub fn instrument_move_fragments<'tcx>(this: &MoveData<'tcx>,\n                                        tcx: &ty::ctxt<'tcx>,\n                                        sp: Span,\n                                        id: ast::NodeId) {\n-    let (span_err, print) = {\n-        let attrs : &[ast::Attribute];\n-        attrs = match tcx.map.find(id) {\n-            Some(ast_map::NodeItem(ref item)) =>\n-                &item.attrs,\n-            Some(ast_map::NodeImplItem(&ast::MethodImplItem(ref m))) =>\n-                &m.attrs,\n-            Some(ast_map::NodeTraitItem(&ast::ProvidedMethod(ref m))) =>\n-                &m.attrs,\n-            _ => &[],\n-        };\n-\n-        let span_err =\n-            attrs.iter().any(|a| a.check_name(\"rustc_move_fragments\"));\n-        let print = tcx.sess.opts.debugging_opts.print_move_fragments;\n-\n-        (span_err, print)\n-    };\n+    let span_err = tcx.map.attrs(id).iter()\n+                          .any(|a| a.check_name(\"rustc_move_fragments\"));\n+    let print = tcx.sess.opts.debugging_opts.print_move_fragments;\n \n     if !span_err && !print { return; }\n "}, {"sha": "074591fb927d2abb11714f4a5a30c40b12aa1424", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 54, "deletions": 73, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -46,13 +46,12 @@ use std::{cmp, slice};\n use std::{i8, i16, i32, i64, u8, u16, u32, u64, f32, f64};\n \n use syntax::{abi, ast, ast_map};\n-use syntax::ast_util::is_shift_binop;\n+use syntax::ast_util::{self, is_shift_binop, local_def};\n use syntax::attr::{self, AttrMetaMethods};\n use syntax::codemap::{self, Span};\n use syntax::feature_gate::{KNOWN_ATTRIBUTES, AttributeType};\n use syntax::parse::token;\n use syntax::ast::{TyIs, TyUs, TyI8, TyU8, TyI16, TyU16, TyI32, TyU32, TyI64, TyU64};\n-use syntax::ast_util;\n use syntax::ptr::P;\n use syntax::visit::{self, Visitor};\n \n@@ -879,36 +878,18 @@ enum MethodContext {\n     PlainImpl\n }\n \n-fn method_context(cx: &Context, m: &ast::Method) -> MethodContext {\n-    let did = ast::DefId {\n-        krate: ast::LOCAL_CRATE,\n-        node: m.id\n-    };\n-\n-    match cx.tcx.impl_or_trait_items.borrow().get(&did).cloned() {\n-        None => cx.sess().span_bug(m.span, \"missing method descriptor?!\"),\n-        Some(ty::MethodTraitItem(md)) => {\n-            match md.container {\n-                ty::TraitContainer(..) => MethodContext::TraitDefaultImpl,\n-                ty::ImplContainer(cid) => {\n-                    match ty::impl_trait_ref(cx.tcx, cid) {\n-                        Some(..) => MethodContext::TraitImpl,\n-                        None => MethodContext::PlainImpl\n-                    }\n+fn method_context(cx: &Context, id: ast::NodeId, span: Span) -> MethodContext {\n+    match cx.tcx.impl_or_trait_items.borrow().get(&local_def(id)) {\n+        None => cx.sess().span_bug(span, \"missing method descriptor?!\"),\n+        Some(item) => match item.container() {\n+            ty::TraitContainer(..) => MethodContext::TraitDefaultImpl,\n+            ty::ImplContainer(cid) => {\n+                match ty::impl_trait_ref(cx.tcx, cid) {\n+                    Some(_) => MethodContext::TraitImpl,\n+                    None => MethodContext::PlainImpl\n                 }\n             }\n-        },\n-        Some(ty::TypeTraitItem(typedef)) => {\n-            match typedef.container {\n-                ty::TraitContainer(..) => MethodContext::TraitDefaultImpl,\n-                ty::ImplContainer(cid) => {\n-                    match ty::impl_trait_ref(cx.tcx, cid) {\n-                        Some(..) => MethodContext::TraitImpl,\n-                        None => MethodContext::PlainImpl\n-                    }\n-                }\n-            }\n-        },\n+        }\n     }\n }\n \n@@ -999,9 +980,9 @@ impl LintPass for NonSnakeCase {\n \n     fn check_fn(&mut self, cx: &Context,\n                 fk: visit::FnKind, _: &ast::FnDecl,\n-                _: &ast::Block, span: Span, _: ast::NodeId) {\n+                _: &ast::Block, span: Span, id: ast::NodeId) {\n         match fk {\n-            visit::FkMethod(ident, _, m) => match method_context(cx, m) {\n+            visit::FkMethod(ident, _) => match method_context(cx, id, span) {\n                 MethodContext::PlainImpl => {\n                     self.check_snake_case(cx, \"method\", ident, span)\n                 },\n@@ -1023,8 +1004,10 @@ impl LintPass for NonSnakeCase {\n         }\n     }\n \n-    fn check_ty_method(&mut self, cx: &Context, t: &ast::TypeMethod) {\n-        self.check_snake_case(cx, \"trait method\", t.ident, t.span);\n+    fn check_trait_item(&mut self, cx: &Context, trait_item: &ast::TraitItem) {\n+        if let ast::MethodTraitItem(_, None) = trait_item.node {\n+            self.check_snake_case(cx, \"trait method\", trait_item.ident, trait_item.span);\n+        }\n     }\n \n     fn check_lifetime_def(&mut self, cx: &Context, t: &ast::LifetimeDef) {\n@@ -1335,19 +1318,22 @@ impl LintPass for UnsafeCode {\n             visit::FkItemFn(_, _, ast::Unsafety::Unsafe, _) =>\n                 cx.span_lint(UNSAFE_CODE, span, \"declaration of an `unsafe` function\"),\n \n-            visit::FkMethod(_, _, m) => {\n-                if let ast::Method_::MethDecl(_, _, _, _, ast::Unsafety::Unsafe, _, _, _) = m.node {\n-                    cx.span_lint(UNSAFE_CODE, m.span, \"implementation of an `unsafe` method\")\n+            visit::FkMethod(_, sig) => {\n+                if sig.unsafety == ast::Unsafety::Unsafe {\n+                    cx.span_lint(UNSAFE_CODE, span, \"implementation of an `unsafe` method\")\n                 }\n             },\n \n             _ => (),\n         }\n     }\n \n-    fn check_ty_method(&mut self, cx: &Context, ty_method: &ast::TypeMethod) {\n-        if let ast::TypeMethod { unsafety: ast::Unsafety::Unsafe, span, ..} = *ty_method {\n-            cx.span_lint(UNSAFE_CODE, span, \"declaration of an `unsafe` method\")\n+    fn check_trait_item(&mut self, cx: &Context, trait_item: &ast::TraitItem) {\n+        if let ast::MethodTraitItem(ref sig, None) = trait_item.node {\n+            if sig.unsafety == ast::Unsafety::Unsafe {\n+                cx.span_lint(UNSAFE_CODE, trait_item.span,\n+                             \"declaration of an `unsafe` method\")\n+            }\n         }\n     }\n }\n@@ -1576,30 +1562,30 @@ impl LintPass for MissingDoc {\n         self.check_missing_docs_attrs(cx, Some(it.id), &it.attrs, it.span, desc);\n     }\n \n-    fn check_fn(&mut self, cx: &Context, fk: visit::FnKind, _: &ast::FnDecl,\n-                _: &ast::Block, _: Span, _: ast::NodeId) {\n-        if let visit::FkMethod(_, _, m) = fk {\n-            // If the method is an impl for a trait, don't doc.\n-            if method_context(cx, m) == MethodContext::TraitImpl {\n-                return;\n-            }\n-\n-            // Otherwise, doc according to privacy. This will also check\n-            // doc for default methods defined on traits.\n-            self.check_missing_docs_attrs(cx, Some(m.id), &m.attrs, m.span, \"a method\");\n-        }\n-    }\n-\n-    fn check_ty_method(&mut self, cx: &Context, tm: &ast::TypeMethod) {\n-        self.check_missing_docs_attrs(cx, Some(tm.id), &tm.attrs, tm.span, \"a type method\");\n+    fn check_trait_item(&mut self, cx: &Context, trait_item: &ast::TraitItem) {\n+        let desc = match trait_item.node {\n+            ast::MethodTraitItem(..) => \"a trait method\",\n+            ast::TypeTraitItem(..) => \"an associated type\"\n+        };\n+        self.check_missing_docs_attrs(cx, Some(trait_item.id),\n+                                      &trait_item.attrs,\n+                                      trait_item.span, desc);\n     }\n \n-    fn check_trait_item(&mut self, cx: &Context, it: &ast::TraitItem) {\n-        if let ast::TraitItem::TypeTraitItem(ref ty) = *it {\n-            let assoc_ty = &ty.ty_param;\n-            self.check_missing_docs_attrs(cx, Some(assoc_ty.id), &ty.attrs,\n-                                          assoc_ty.span, \"an associated type\");\n+    fn check_impl_item(&mut self, cx: &Context, impl_item: &ast::ImplItem) {\n+        // If the method is an impl for a trait, don't doc.\n+        if method_context(cx, impl_item.id, impl_item.span) == MethodContext::TraitImpl {\n+            return;\n         }\n+\n+        let desc = match impl_item.node {\n+            ast::MethodImplItem(..) => \"a method\",\n+            ast::TypeImplItem(_) => \"an associated type\",\n+            ast::MacImplItem(_) => \"an impl item macro\"\n+        };\n+        self.check_missing_docs_attrs(cx, Some(impl_item.id),\n+                                      &impl_item.attrs,\n+                                      impl_item.span, desc);\n     }\n \n     fn check_struct_field(&mut self, cx: &Context, sf: &ast::StructField) {\n@@ -1644,27 +1630,22 @@ impl LintPass for MissingCopyImplementations {\n         if !cx.exported_items.contains(&item.id) {\n             return;\n         }\n-        if cx.tcx\n-             .destructor_for_type\n-             .borrow()\n-             .contains_key(&ast_util::local_def(item.id)) {\n+        if cx.tcx.destructor_for_type.borrow().contains_key(&local_def(item.id)) {\n             return;\n         }\n         let ty = match item.node {\n             ast::ItemStruct(_, ref ast_generics) => {\n                 if ast_generics.is_parameterized() {\n                     return;\n                 }\n-                ty::mk_struct(cx.tcx,\n-                              ast_util::local_def(item.id),\n+                ty::mk_struct(cx.tcx, local_def(item.id),\n                               cx.tcx.mk_substs(Substs::empty()))\n             }\n             ast::ItemEnum(_, ref ast_generics) => {\n                 if ast_generics.is_parameterized() {\n                     return;\n                 }\n-                ty::mk_enum(cx.tcx,\n-                            ast_util::local_def(item.id),\n+                ty::mk_enum(cx.tcx, local_def(item.id),\n                             cx.tcx.mk_substs(Substs::empty()))\n             }\n             _ => return,\n@@ -1828,13 +1809,13 @@ impl LintPass for UnconditionalRecursion {\n \n         let (name, checker) = match fn_kind {\n             visit::FkItemFn(name, _, _, _) => (name, id_refers_to_this_fn as F),\n-            visit::FkMethod(name, _, _) => (name, id_refers_to_this_method as F),\n+            visit::FkMethod(name, _) => (name, id_refers_to_this_method as F),\n             // closures can't recur, so they don't matter.\n             visit::FkFnBlock => return\n         };\n \n-        let impl_def_id = ty::impl_of_method(cx.tcx, ast_util::local_def(id))\n-            .unwrap_or(ast_util::local_def(ast::DUMMY_NODE_ID));\n+        let impl_def_id = ty::impl_of_method(cx.tcx, local_def(id))\n+            .unwrap_or(local_def(ast::DUMMY_NODE_ID));\n         assert!(ast_util::is_local(impl_def_id));\n         let impl_node_id = impl_def_id.node;\n \n@@ -1938,7 +1919,7 @@ impl LintPass for UnconditionalRecursion {\n                                       _: ast::Ident,\n                                       id: ast::NodeId) -> bool {\n             tcx.def_map.borrow().get(&id)\n-               .map_or(false, |def| def.def_id() == ast_util::local_def(fn_id))\n+               .map_or(false, |def| def.def_id() == local_def(fn_id))\n         }\n \n         // check if the method call `id` refers to method `method_id`"}, {"sha": "27f807ebe429b53cb7f0f8b6ca7e650164134348", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 50, "deletions": 103, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -48,7 +48,7 @@ use rustc::middle::ty::{self, Ty};\n use rustc::util::nodemap::{NodeMap, NodeSet};\n \n use syntax::{ast, ast_map};\n-use syntax::ast_util::{is_local, local_def, PostExpansionMethod};\n+use syntax::ast_util::{is_local, local_def};\n use syntax::codemap::Span;\n use syntax::parse::token;\n use syntax::visit::{self, Visitor};\n@@ -92,17 +92,9 @@ impl<'v> Visitor<'v> for ParentVisitor {\n             // method to the root. In this case, if the trait is private, then\n             // parent all the methods to the trait to indicate that they're\n             // private.\n-            ast::ItemTrait(_, _, _, ref methods) if item.vis != ast::Public => {\n-                for m in methods {\n-                    match *m {\n-                        ast::ProvidedMethod(ref m) => {\n-                            self.parents.insert(m.id, item.id);\n-                        }\n-                        ast::RequiredMethod(ref m) => {\n-                            self.parents.insert(m.id, item.id);\n-                        }\n-                        ast::TypeTraitItem(_) => {}\n-                    };\n+            ast::ItemTrait(_, _, _, ref trait_items) if item.vis != ast::Public => {\n+                for trait_item in trait_items {\n+                    self.parents.insert(trait_item.id, item.id);\n                 }\n             }\n \n@@ -280,41 +272,29 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n \n                 if public_ty || public_trait {\n                     for impl_item in impl_items {\n-                        match *impl_item {\n-                            ast::MethodImplItem(ref method) => {\n-                                let meth_public =\n-                                    match method.pe_explicit_self().node {\n-                                        ast::SelfStatic => public_ty,\n-                                        _ => true,\n-                                    } && method.pe_vis() == ast::Public;\n+                        match impl_item.node {\n+                            ast::MethodImplItem(ref sig, _) => {\n+                                let meth_public = match sig.explicit_self.node {\n+                                    ast::SelfStatic => public_ty,\n+                                    _ => true,\n+                                } && impl_item.vis == ast::Public;\n                                 if meth_public || tr.is_some() {\n-                                    self.exported_items.insert(method.id);\n+                                    self.exported_items.insert(impl_item.id);\n                                 }\n                             }\n-                            ast::TypeImplItem(_) => {}\n+                            ast::TypeImplItem(_) |\n+                            ast::MacImplItem(_) => {}\n                         }\n                     }\n                 }\n             }\n \n             // Default methods on traits are all public so long as the trait\n             // is public\n-            ast::ItemTrait(_, _, _, ref methods) if public_first => {\n-                for method in methods {\n-                    match *method {\n-                        ast::ProvidedMethod(ref m) => {\n-                            debug!(\"provided {}\", m.id);\n-                            self.exported_items.insert(m.id);\n-                        }\n-                        ast::RequiredMethod(ref m) => {\n-                            debug!(\"required {}\", m.id);\n-                            self.exported_items.insert(m.id);\n-                        }\n-                        ast::TypeTraitItem(ref t) => {\n-                            debug!(\"typedef {}\", t.ty_param.id);\n-                            self.exported_items.insert(t.ty_param.id);\n-                        }\n-                    }\n+            ast::ItemTrait(_, _, _, ref trait_items) if public_first => {\n+                for trait_item in trait_items {\n+                    debug!(\"trait item {}\", trait_item.id);\n+                    self.exported_items.insert(trait_item.id);\n                 }\n             }\n \n@@ -510,19 +490,20 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                 // FIXME(#10573) is this the right behavior? Why not consider\n                 //               where the method was defined?\n                 Some(ast_map::NodeImplItem(ii)) => {\n-                    match *ii {\n-                        ast::MethodImplItem(ref m) => {\n+                    match ii.node {\n+                        ast::MethodImplItem(..) => {\n                             let imp = self.tcx.map\n                                           .get_parent_did(closest_private_id);\n                             match ty::impl_trait_ref(self.tcx, imp) {\n                                 Some(..) => return Allowable,\n-                                _ if m.pe_vis() == ast::Public => {\n+                                _ if ii.vis == ast::Public => {\n                                     return Allowable\n                                 }\n-                                _ => m.pe_vis()\n+                                _ => ii.vis\n                             }\n                         }\n-                        ast::TypeImplItem(_) => return Allowable,\n+                        ast::TypeImplItem(_) |\n+                        ast::MacImplItem(_) => return Allowable,\n                     }\n                 }\n                 Some(ast_map::NodeTraitItem(_)) => {\n@@ -1088,12 +1069,7 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n                                 \"visibility qualifiers have no effect on trait \\\n                                  impls\");\n                 for impl_item in impl_items {\n-                    match *impl_item {\n-                        ast::MethodImplItem(ref m) => {\n-                            check_inherited(m.span, m.pe_vis(), \"\");\n-                        }\n-                        ast::TypeImplItem(_) => {}\n-                    }\n+                    check_inherited(impl_item.span, impl_item.vis, \"\");\n                 }\n             }\n \n@@ -1121,23 +1097,7 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n                 }\n             }\n \n-            ast::ItemTrait(_, _, _, ref methods) => {\n-                for m in methods {\n-                    match *m {\n-                        ast::ProvidedMethod(ref m) => {\n-                            check_inherited(m.span, m.pe_vis(),\n-                                            \"unnecessary visibility\");\n-                        }\n-                        ast::RequiredMethod(ref m) => {\n-                            check_inherited(m.span, m.vis,\n-                                            \"unnecessary visibility\");\n-                        }\n-                        ast::TypeTraitItem(_) => {}\n-                    }\n-                }\n-            }\n-\n-            ast::ItemDefaultImpl(..) |\n+            ast::ItemTrait(..) | ast::ItemDefaultImpl(..) |\n             ast::ItemConst(..) | ast::ItemStatic(..) | ast::ItemStruct(..) |\n             ast::ItemFn(..) | ast::ItemMod(..) | ast::ItemTy(..) |\n             ast::ItemExternCrate(_) | ast::ItemUse(_) | ast::ItemMac(..) => {}\n@@ -1165,11 +1125,12 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n         match item.node {\n             ast::ItemImpl(_, _, _, _, _, ref impl_items) => {\n                 for impl_item in impl_items {\n-                    match *impl_item {\n-                        ast::MethodImplItem(ref m) => {\n-                            check_inherited(tcx, m.span, m.pe_vis());\n+                    match impl_item.node {\n+                        ast::MethodImplItem(..) => {\n+                            check_inherited(tcx, impl_item.span, impl_item.vis);\n                         }\n-                        ast::TypeImplItem(_) => {}\n+                        ast::TypeImplItem(_) |\n+                        ast::MacImplItem(_) => {}\n                     }\n                 }\n             }\n@@ -1186,18 +1147,8 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n \n             ast::ItemStruct(ref def, _) => check_struct(&**def),\n \n-            ast::ItemTrait(_, _, _, ref methods) => {\n-                for m in methods {\n-                    match *m {\n-                        ast::RequiredMethod(..) => {}\n-                        ast::ProvidedMethod(ref m) => check_inherited(tcx, m.span,\n-                                                                m.pe_vis()),\n-                        ast::TypeTraitItem(_) => {}\n-                    }\n-                }\n-            }\n-\n-            ast::ItemDefaultImpl(..) | ast::ItemExternCrate(_) | ast::ItemUse(_) |\n+            ast::ItemExternCrate(_) | ast::ItemUse(_) |\n+            ast::ItemTrait(..) | ast::ItemDefaultImpl(..) |\n             ast::ItemStatic(..) | ast::ItemConst(..) |\n             ast::ItemFn(..) | ast::ItemMod(..) | ast::ItemTy(..) |\n             ast::ItemMac(..) => {}\n@@ -1352,11 +1303,12 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                     trait_ref.is_some() ||\n                     impl_items.iter()\n                               .any(|impl_item| {\n-                                  match *impl_item {\n-                                      ast::MethodImplItem(ref m) => {\n-                                          self.exported_items.contains(&m.id)\n+                                  match impl_item.node {\n+                                      ast::MethodImplItem(..) => {\n+                                          self.exported_items.contains(&impl_item.id)\n                                       }\n-                                      ast::TypeImplItem(_) => false,\n+                                      ast::TypeImplItem(_) |\n+                                      ast::MacImplItem(_) => false,\n                                   }\n                               });\n \n@@ -1369,12 +1321,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                     match *trait_ref {\n                         None => {\n                             for impl_item in impl_items {\n-                                match *impl_item {\n-                                    ast::MethodImplItem(ref method) => {\n-                                        visit::walk_method_helper(self, &**method)\n-                                    }\n-                                    ast::TypeImplItem(_) => {}\n-                                }\n+                                visit::walk_impl_item(self, impl_item);\n                             }\n                         }\n                         Some(ref tr) => {\n@@ -1395,11 +1342,12 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n \n                             // Those in 3. are warned with this call.\n                             for impl_item in impl_items {\n-                                match *impl_item {\n-                                    ast::MethodImplItem(..) => {},\n-                                    ast::TypeImplItem(ref typedef) => {\n-                                        self.visit_ty(&typedef.typ);\n+                                match impl_item.node {\n+                                    ast::TypeImplItem(ref ty) => {\n+                                        self.visit_ty(ty);\n                                     }\n+                                    ast::MethodImplItem(..) |\n+                                    ast::MacImplItem(_) => {},\n                                 }\n                             }\n                         }\n@@ -1409,17 +1357,16 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                     // methods will be visible as `Public::foo`.\n                     let mut found_pub_static = false;\n                     for impl_item in impl_items {\n-                        match *impl_item {\n-                            ast::MethodImplItem(ref method) => {\n-                                if method.pe_explicit_self().node ==\n-                                        ast::SelfStatic &&\n-                                        self.exported_items\n-                                            .contains(&method.id) {\n+                        match impl_item.node {\n+                            ast::MethodImplItem(ref sig, _) => {\n+                                if sig.explicit_self.node == ast::SelfStatic &&\n+                                   self.exported_items.contains(&impl_item.id) {\n                                     found_pub_static = true;\n-                                    visit::walk_method_helper(self, &**method);\n+                                    visit::walk_impl_item(self, impl_item);\n                                 }\n                             }\n-                            ast::TypeImplItem(_) => {}\n+                            ast::TypeImplItem(_) |\n+                            ast::MacImplItem(_) => {}\n                         }\n                     }\n                     if found_pub_static {"}, {"sha": "1cbbcad9550904de917aa6b95d5a72aa8cdef0ab", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 16, "deletions": 37, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -48,7 +48,7 @@ use syntax::ast::UnnamedField;\n use syntax::ast::{Variant, ViewPathGlob, ViewPathList, ViewPathSimple};\n use syntax::ast::{Visibility};\n use syntax::ast;\n-use syntax::ast_util::{self, local_def};\n+use syntax::ast_util::local_def;\n use syntax::attr::AttrMetaMethods;\n use syntax::parse::token::{self, special_idents};\n use syntax::codemap::{Span, DUMMY_SP};\n@@ -525,49 +525,28 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n                 // Add the names of all the items to the trait info.\n                 for trait_item in items {\n-                    let (name, trait_item_id) = match *trait_item {\n-                        ast::RequiredMethod(_) |\n-                        ast::ProvidedMethod(_) => {\n-                            let ty_m = ast_util::trait_item_to_ty_method(trait_item);\n-\n-                            let name = ty_m.ident.name;\n-\n-                            // Add it as a name in the trait module.\n-                            let def = DefMethod(local_def(ty_m.id),\n+                    let name_bindings = self.add_child(trait_item.ident.name,\n+                                        &module_parent,\n+                                        ForbidDuplicateTypesAndValues,\n+                                        trait_item.span);\n+\n+                    match trait_item.node {\n+                        ast::MethodTraitItem(..) => {\n+                            let def = DefMethod(local_def(trait_item.id),\n                                                 FromTrait(local_def(item.id)));\n-\n-                            let method_name_bindings =\n-                                self.add_child(name,\n-                                               &module_parent,\n-                                               ForbidDuplicateTypesAndValues,\n-                                               ty_m.span);\n                             // NB: not IMPORTABLE\n-                            method_name_bindings.define_value(def,\n-                                                              ty_m.span,\n-                                                              PUBLIC);\n-\n-                            (name, local_def(ty_m.id))\n+                            name_bindings.define_value(def, trait_item.span, PUBLIC);\n                         }\n-                        ast::TypeTraitItem(ref associated_type) => {\n+                        ast::TypeTraitItem(..) => {\n                             let def = DefAssociatedTy(local_def(item.id),\n-                                                      local_def(associated_type.ty_param.id));\n-\n-                            let name_bindings =\n-                                self.add_child(associated_type.ty_param.ident.name,\n-                                               &module_parent,\n-                                               ForbidDuplicateTypesAndValues,\n-                                               associated_type.ty_param.span);\n+                                                      local_def(trait_item.id));\n                             // NB: not IMPORTABLE\n-                            name_bindings.define_type(def,\n-                                                      associated_type.ty_param.span,\n-                                                      PUBLIC);\n-\n-                            (associated_type.ty_param.ident.name,\n-                             local_def(associated_type.ty_param.id))\n+                            name_bindings.define_type(def, trait_item.span, PUBLIC);\n                         }\n-                    };\n+                    }\n \n-                    self.trait_item_map.insert((name, def_id), trait_item_id);\n+                    self.trait_item_map.insert((trait_item.ident.name, def_id),\n+                                               local_def(trait_item.id));\n                 }\n \n                 name_bindings.define_type(DefTrait(def_id), sp, modifiers);"}, {"sha": "e49fdc9c5d3564edc39a0b25356ca1e853866f19", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 30, "deletions": 35, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -82,10 +82,11 @@ use syntax::ast::{TyRptr, TyStr, TyUs, TyU8, TyU16, TyU32, TyU64, TyUint};\n use syntax::ast::{TypeImplItem};\n use syntax::ast;\n use syntax::ast_map;\n-use syntax::ast_util::{PostExpansionMethod, local_def, walk_pat};\n+use syntax::ast_util::{local_def, walk_pat};\n use syntax::attr::AttrMetaMethods;\n use syntax::ext::mtwt;\n use syntax::parse::token::{self, special_names, special_idents};\n+use syntax::ptr::P;\n use syntax::codemap::{self, Span, Pos};\n use syntax::visit::{self, Visitor};\n \n@@ -241,9 +242,9 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n                 self.visit_generics(generics);\n                 ItemRibKind\n             }\n-            visit::FkMethod(_, generics, method) => {\n-                self.visit_generics(generics);\n-                self.visit_explicit_self(method.pe_explicit_self());\n+            visit::FkMethod(_, sig) => {\n+                self.visit_generics(&sig.generics);\n+                self.visit_explicit_self(&sig.explicit_self);\n                 MethodRibKind\n             }\n             visit::FkFnBlock(..) => ClosureRibKind(node_id)\n@@ -2806,27 +2807,21 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     this.visit_generics(generics);\n                     visit::walk_ty_param_bounds_helper(this, bounds);\n \n-                    for trait_item in &(*trait_items) {\n+                    for trait_item in trait_items {\n                         // Create a new rib for the trait_item-specific type\n                         // parameters.\n                         //\n                         // FIXME #4951: Do we need a node ID here?\n \n-                        let type_parameters = match *trait_item {\n-                            ast::RequiredMethod(ref ty_m) => {\n-                                HasTypeParameters(&ty_m.generics,\n-                                                  FnSpace,\n-                                                  MethodRibKind)\n-                            }\n-                            ast::ProvidedMethod(ref m) => {\n-                                HasTypeParameters(m.pe_generics(),\n+                        let type_parameters = match trait_item.node {\n+                            ast::MethodTraitItem(ref sig, _) => {\n+                                HasTypeParameters(&sig.generics,\n                                                   FnSpace,\n                                                   MethodRibKind)\n                             }\n-                            ast::TypeTraitItem(ref assoc_ty) => {\n-                                let ty_param = &assoc_ty.ty_param;\n-                                this.check_if_primitive_type_name(ty_param.ident.name,\n-                                                                  ty_param.span);\n+                            ast::TypeTraitItem(..) => {\n+                                this.check_if_primitive_type_name(trait_item.ident.name,\n+                                                                  trait_item.span);\n                                 NoTypeParameters\n                             }\n                         };\n@@ -3049,7 +3044,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                               generics: &Generics,\n                               opt_trait_reference: &Option<TraitRef>,\n                               self_type: &Ty,\n-                              impl_items: &[ImplItem]) {\n+                              impl_items: &[P<ImplItem>]) {\n         // If applicable, create a rib for the type parameters.\n         self.with_type_parameter_rib(HasTypeParameters(generics,\n                                                        TypeSpace,\n@@ -3065,31 +3060,32 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n                 this.with_current_self_type(self_type, |this| {\n                     for impl_item in impl_items {\n-                        match *impl_item {\n-                            MethodImplItem(ref method) => {\n+                        match impl_item.node {\n+                            MethodImplItem(ref sig, _) => {\n                                 // If this is a trait impl, ensure the method\n                                 // exists in trait\n-                                this.check_trait_item(method.pe_ident().name,\n-                                                      method.span);\n+                                this.check_trait_item(impl_item.ident.name,\n+                                                      impl_item.span);\n \n                                 // We also need a new scope for the method-\n                                 // specific type parameters.\n                                 let type_parameters =\n-                                    HasTypeParameters(method.pe_generics(),\n+                                    HasTypeParameters(&sig.generics,\n                                                       FnSpace,\n                                                       MethodRibKind);\n                                 this.with_type_parameter_rib(type_parameters, |this| {\n-                                    visit::walk_method_helper(this, &**method);\n+                                    visit::walk_impl_item(this, impl_item);\n                                 });\n                             }\n-                            TypeImplItem(ref typedef) => {\n+                            TypeImplItem(ref ty) => {\n                                 // If this is a trait impl, ensure the method\n                                 // exists in trait\n-                                this.check_trait_item(typedef.ident.name,\n-                                                      typedef.span);\n+                                this.check_trait_item(impl_item.ident.name,\n+                                                      impl_item.span);\n \n-                                this.visit_ty(&*typedef.typ);\n+                                this.visit_ty(ty);\n                             }\n+                            ast::MacImplItem(_) => {}\n                         }\n                     }\n                 });\n@@ -3953,19 +3949,18 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         fn is_static_method(this: &Resolver, did: DefId) -> bool {\n             if did.krate == ast::LOCAL_CRATE {\n-                let explicit_self = match this.ast_map.get(did.node) {\n-                    ast_map::NodeTraitItem(m) => match *m {\n-                        ast::RequiredMethod(ref m) => &m.explicit_self,\n-                        ast::ProvidedMethod(ref m) => m.pe_explicit_self(),\n+                let sig = match this.ast_map.get(did.node) {\n+                    ast_map::NodeTraitItem(trait_item) => match trait_item.node {\n+                        ast::MethodTraitItem(ref sig, _) => sig,\n                         _ => return false\n                     },\n-                    ast_map::NodeImplItem(m) => match *m {\n-                        ast::MethodImplItem(ref m) => m.pe_explicit_self(),\n+                    ast_map::NodeImplItem(impl_item) => match impl_item.node {\n+                        ast::MethodImplItem(ref sig, _) => sig,\n                         _ => return false\n                     },\n                     _ => return false\n                 };\n-                explicit_self.node == ast::SelfStatic\n+                sig.explicit_self.node == ast::SelfStatic\n             } else {\n                 csearch::is_static_method(&this.session.cstore, did)\n             }"}, {"sha": "83bb5efb425d26564f746145dcba376b4086f67b", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 67, "deletions": 118, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -37,7 +37,7 @@ use std::env;\n use std::fs::{self, File};\n use std::path::{Path, PathBuf};\n \n-use syntax::ast_util::{self, PostExpansionMethod};\n+use syntax::ast_util;\n use syntax::ast::{self, NodeId, DefId};\n use syntax::ast_map::NodeItem;\n use syntax::attr;\n@@ -284,16 +284,19 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         }\n     }\n \n-    fn process_method(&mut self, method: &ast::Method) {\n-        if generated_code(method.span) {\n+    fn process_method(&mut self, sig: &ast::MethodSig,\n+                      body: Option<&ast::Block>,\n+                      id: ast::NodeId, ident: ast::Ident,\n+                      span: Span) {\n+        if generated_code(span) {\n             return;\n         }\n \n         let mut scope_id;\n         // The qualname for a method is the trait name or name of the struct in an impl in\n         // which the method is declared in, followed by the method's name.\n         let qualname = match ty::impl_of_method(&self.analysis.ty_cx,\n-                                                ast_util::local_def(method.id)) {\n+                                                ast_util::local_def(id)) {\n             Some(impl_id) => match self.analysis.ty_cx.map.get(impl_id.node) {\n                 NodeItem(item) => {\n                     scope_id = item.id;\n@@ -303,7 +306,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                             result.push_str(&ty_to_string(&**ty));\n \n                             match ty::trait_of_item(&self.analysis.ty_cx,\n-                                                    ast_util::local_def(method.id)) {\n+                                                    ast_util::local_def(id)) {\n                                 Some(def_id) => {\n                                     result.push_str(\" as \");\n                                     result.push_str(\n@@ -315,93 +318,93 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                             result\n                         }\n                         _ => {\n-                            self.sess.span_bug(method.span,\n-                                               &format!(\"Container {} for method {} not an impl?\",\n-                                                       impl_id.node, method.id));\n+                            self.sess.span_bug(span,\n+                                &format!(\"Container {} for method {} not an impl?\",\n+                                         impl_id.node, id));\n                         },\n                     }\n                 },\n                 _ => {\n-                    self.sess.span_bug(method.span,\n-                                       &format!(\n-                                           \"Container {} for method {} is not a node item {:?}\",\n-                                           impl_id.node,\n-                                           method.id,\n-                                           self.analysis.ty_cx.map.get(impl_id.node)));\n+                    self.sess.span_bug(span,\n+                        &format!(\"Container {} for method {} is not a node item {:?}\",\n+                                 impl_id.node, id, self.analysis.ty_cx.map.get(impl_id.node)));\n                 },\n             },\n             None => match ty::trait_of_item(&self.analysis.ty_cx,\n-                                            ast_util::local_def(method.id)) {\n+                                            ast_util::local_def(id)) {\n                 Some(def_id) => {\n                     scope_id = def_id.node;\n                     match self.analysis.ty_cx.map.get(def_id.node) {\n                         NodeItem(_) => {\n                             format!(\"::{}\", ty::item_path_str(&self.analysis.ty_cx, def_id))\n                         }\n                         _ => {\n-                            self.sess.span_bug(method.span,\n-                                               &format!(\"Could not find container {} for method {}\",\n-                                                       def_id.node, method.id));\n+                            self.sess.span_bug(span,\n+                                &format!(\"Could not find container {} for method {}\",\n+                                         def_id.node, id));\n                         }\n                     }\n                 },\n                 None => {\n-                    self.sess.span_bug(method.span,\n-                                       &format!(\"Could not find container for method {}\",\n-                                               method.id));\n+                    self.sess.span_bug(span,\n+                        &format!(\"Could not find container for method {}\", id));\n                 },\n             },\n         };\n \n-        let qualname = format!(\"{}::{}\", qualname, &get_ident(method.pe_ident()));\n-        let qualname = &qualname[..];\n+        let qualname = &format!(\"{}::{}\", qualname, &get_ident(ident));\n \n         // record the decl for this def (if it has one)\n         let decl_id = ty::trait_item_of_item(&self.analysis.ty_cx,\n-                                             ast_util::local_def(method.id))\n+                                             ast_util::local_def(id))\n             .and_then(|def_id| {\n                 if match def_id {\n                     ty::MethodTraitItemId(def_id) => {\n-                        def_id.node != 0 && def_id != ast_util::local_def(method.id)\n+                        def_id.node != 0 && def_id != ast_util::local_def(id)\n                     }\n                     ty::TypeTraitItemId(_) => false,\n                 } {\n-                    Some(def_id)\n+                    Some(def_id.def_id())\n                 } else {\n                     None\n                 }\n             });\n-        let decl_id = match decl_id {\n-            None => None,\n-            Some(id) => Some(id.def_id()),\n-        };\n \n-        let sub_span = self.span.sub_span_after_keyword(method.span, keywords::Fn);\n-        self.fmt.method_str(method.span,\n-                            sub_span,\n-                            method.id,\n-                            qualname,\n-                            decl_id,\n-                            scope_id);\n-\n-        self.process_formals(&method.pe_fn_decl().inputs, qualname);\n+        let sub_span = self.span.sub_span_after_keyword(span, keywords::Fn);\n+        if body.is_some() {\n+            self.fmt.method_str(span,\n+                                sub_span,\n+                                id,\n+                                qualname,\n+                                decl_id,\n+                                scope_id);\n+            self.process_formals(&sig.decl.inputs, qualname);\n+        } else {\n+            self.fmt.method_decl_str(span,\n+                                     sub_span,\n+                                     id,\n+                                     qualname,\n+                                     scope_id);\n+        }\n \n         // walk arg and return types\n-        for arg in &method.pe_fn_decl().inputs {\n-            self.visit_ty(&*arg.ty);\n+        for arg in &sig.decl.inputs {\n+            self.visit_ty(&arg.ty);\n         }\n \n-        if let ast::Return(ref ret_ty) = method.pe_fn_decl().output {\n-            self.visit_ty(&**ret_ty);\n+        if let ast::Return(ref ret_ty) = sig.decl.output {\n+            self.visit_ty(ret_ty);\n         }\n \n         // walk the fn body\n-        self.nest(method.id, |v| v.visit_block(&*method.pe_body()));\n+        if let Some(body) = body {\n+            self.nest(id, |v| v.visit_block(body));\n+        }\n \n-        self.process_generic_params(method.pe_generics(),\n-                                    method.span,\n+        self.process_generic_params(&sig.generics,\n+                                    span,\n                                     qualname,\n-                                    method.id);\n+                                    id);\n     }\n \n     fn process_trait_ref(&mut self,\n@@ -656,7 +659,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                     type_parameters: &ast::Generics,\n                     trait_ref: &Option<ast::TraitRef>,\n                     typ: &ast::Ty,\n-                    impl_items: &Vec<ast::ImplItem>) {\n+                    impl_items: &[P<ast::ImplItem>]) {\n         let trait_id = trait_ref.as_ref().and_then(|tr| self.lookup_type_ref(tr.ref_id));\n         match typ.node {\n             // Common case impl for a struct or something basic.\n@@ -698,22 +701,15 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n \n         self.process_generic_params(type_parameters, item.span, \"\", item.id);\n         for impl_item in impl_items {\n-            match *impl_item {\n-                ast::MethodImplItem(ref method) => {\n-                    visit::walk_method_helper(self, &**method)\n-                }\n-                ast::TypeImplItem(ref typedef) => {\n-                    visit::walk_ty(self, &*typedef.typ)\n-                }\n-            }\n+            visit::walk_impl_item(self, impl_item);\n         }\n     }\n \n     fn process_trait(&mut self,\n                      item: &ast::Item,\n                      generics: &ast::Generics,\n                      trait_refs: &OwnedSlice<ast::TyParamBound>,\n-                     methods: &Vec<ast::TraitItem>) {\n+                     methods: &[P<ast::TraitItem>]) {\n         let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n         let val = self.span.snippet(item.span);\n         let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Trait);\n@@ -1233,71 +1229,24 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n         }\n     }\n \n-    // We don't actually index functions here, that is done in visit_item/ItemFn.\n-    // Here we just visit methods.\n-    fn visit_fn(&mut self,\n-                fk: visit::FnKind<'v>,\n-                fd: &'v ast::FnDecl,\n-                b: &'v ast::Block,\n-                s: Span,\n-                _: ast::NodeId) {\n-        if generated_code(s) {\n-            return;\n-        }\n-\n-        match fk {\n-            visit::FkMethod(_, _, method) => self.process_method(method),\n-            _ => visit::walk_fn(self, fk, fd, b, s),\n+    fn visit_trait_item(&mut self, trait_item: &ast::TraitItem) {\n+        match trait_item.node {\n+            ast::MethodTraitItem(ref sig, ref body) => {\n+                self.process_method(sig, body.as_ref().map(|x| &**x),\n+                                    trait_item.id, trait_item.ident, trait_item.span);\n+            }\n+            ast::TypeTraitItem(..) => {}\n         }\n     }\n \n-    fn visit_trait_item(&mut self, tm: &ast::TraitItem) {\n-        match *tm {\n-            ast::RequiredMethod(ref method_type) => {\n-                if generated_code(method_type.span) {\n-                    return;\n-                }\n-\n-                let mut scope_id;\n-                let mut qualname = match ty::trait_of_item(&self.analysis.ty_cx,\n-                                                           ast_util::local_def(method_type.id)) {\n-                    Some(def_id) => {\n-                        scope_id = def_id.node;\n-                        format!(\"::{}::\", ty::item_path_str(&self.analysis.ty_cx, def_id))\n-                    },\n-                    None => {\n-                        self.sess.span_bug(method_type.span,\n-                                           &format!(\"Could not find trait for method {}\",\n-                                                   method_type.id));\n-                    },\n-                };\n-\n-                qualname.push_str(&get_ident(method_type.ident));\n-                let qualname = &qualname[..];\n-\n-                let sub_span = self.span.sub_span_after_keyword(method_type.span, keywords::Fn);\n-                self.fmt.method_decl_str(method_type.span,\n-                                         sub_span,\n-                                         method_type.id,\n-                                         qualname,\n-                                         scope_id);\n-\n-                // walk arg and return types\n-                for arg in &method_type.decl.inputs {\n-                    self.visit_ty(&*arg.ty);\n-                }\n-\n-                if let ast::Return(ref ret_ty) = method_type.decl.output {\n-                    self.visit_ty(&**ret_ty);\n-                }\n-\n-                self.process_generic_params(&method_type.generics,\n-                                            method_type.span,\n-                                            qualname,\n-                                            method_type.id);\n+    fn visit_impl_item(&mut self, impl_item: &ast::ImplItem) {\n+        match impl_item.node {\n+            ast::MethodImplItem(ref sig, ref body) => {\n+                self.process_method(sig, Some(body), impl_item.id,\n+                                    impl_item.ident, impl_item.span);\n             }\n-            ast::ProvidedMethod(ref method) => self.process_method(&**method),\n-            ast::TypeTraitItem(_) => {}\n+            ast::TypeImplItem(_) |\n+            ast::MacImplItem(_) => {}\n         }\n     }\n "}, {"sha": "74326d4ea919c0e41c821478059f81a7a03f6c00", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 41, "deletions": 48, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -1268,47 +1268,35 @@ fn build_cfg(tcx: &ty::ctxt, id: ast::NodeId) -> (ast::NodeId, Option<cfg::CFG>)\n                 _ => tcx.sess.bug(\"unexpected item variant in has_nested_returns\")\n             }\n         }\n-        Some(ast_map::NodeTraitItem(trait_method)) => {\n-            match *trait_method {\n-                ast::ProvidedMethod(ref m) => {\n-                    match m.node {\n-                        ast::MethDecl(_, _, _, _, _, _, ref blk, _) => {\n-                            blk\n-                        }\n-                        ast::MethMac(_) => tcx.sess.bug(\"unexpanded macro\")\n-                    }\n-                }\n-                ast::RequiredMethod(_) => {\n+        Some(ast_map::NodeTraitItem(trait_item)) => {\n+            match trait_item.node {\n+                ast::MethodTraitItem(_, Some(ref body)) => body,\n+                ast::MethodTraitItem(_, None) => {\n                     tcx.sess.bug(\"unexpected variant: required trait method \\\n                                   in has_nested_returns\")\n                 }\n-                ast::TypeTraitItem(_) => {\n-                    tcx.sess.bug(\"unexpected variant: type trait item in \\\n+                ast::TypeTraitItem(..) => {\n+                    tcx.sess.bug(\"unexpected variant: associated type trait item in \\\n                                   has_nested_returns\")\n                 }\n             }\n         }\n-        Some(ast_map::NodeImplItem(ii)) => {\n-            match *ii {\n-                ast::MethodImplItem(ref m) => {\n-                    match m.node {\n-                        ast::MethDecl(_, _, _, _, _, _, ref blk, _) => {\n-                            blk\n-                        }\n-                        ast::MethMac(_) => tcx.sess.bug(\"unexpanded macro\")\n-                    }\n-                }\n+        Some(ast_map::NodeImplItem(impl_item)) => {\n+            match impl_item.node {\n+                ast::MethodImplItem(_, ref body) => body,\n                 ast::TypeImplItem(_) => {\n-                    tcx.sess.bug(\"unexpected variant: type impl item in \\\n+                    tcx.sess.bug(\"unexpected variant: associated type impl item in \\\n+                                  has_nested_returns\")\n+                }\n+                ast::MacImplItem(_) => {\n+                    tcx.sess.bug(\"unexpected variant: unexpanded macro impl item in \\\n                                   has_nested_returns\")\n                 }\n             }\n         }\n         Some(ast_map::NodeExpr(e)) => {\n             match e.node {\n-                ast::ExprClosure(_, _, ref blk) => {\n-                    blk\n-                }\n+                ast::ExprClosure(_, _, ref blk) => blk,\n                 _ => tcx.sess.bug(\"unexpected expr variant in has_nested_returns\")\n             }\n         }\n@@ -1322,7 +1310,7 @@ fn build_cfg(tcx: &ty::ctxt, id: ast::NodeId) -> (ast::NodeId, Option<cfg::CFG>)\n                                    tcx.map.path_to_string(id)))\n     };\n \n-    (blk.id, Some(cfg::CFG::new(tcx, &**blk)))\n+    (blk.id, Some(cfg::CFG::new(tcx, blk)))\n }\n \n // Checks for the presence of \"nested returns\" in a function.\n@@ -2818,26 +2806,31 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n             v\n         }\n \n-        ast_map::NodeTraitItem(trait_method) => {\n+        ast_map::NodeTraitItem(trait_item) => {\n             debug!(\"get_item_val(): processing a NodeTraitItem\");\n-            match *trait_method {\n-                ast::RequiredMethod(_) | ast::TypeTraitItem(_) => {\n-                    ccx.sess().bug(\"unexpected variant: required trait \\\n-                                    method in get_item_val()\");\n+            match trait_item.node {\n+                ast::MethodTraitItem(_, None) | ast::TypeTraitItem(..) => {\n+                    ccx.sess().span_bug(trait_item.span,\n+                        \"unexpected variant: required trait method in get_item_val()\");\n                 }\n-                ast::ProvidedMethod(ref m) => {\n-                    register_method(ccx, id, &**m)\n+                ast::MethodTraitItem(_, Some(_)) => {\n+                    register_method(ccx, id, &trait_item.attrs, trait_item.span)\n                 }\n             }\n         }\n \n-        ast_map::NodeImplItem(ii) => {\n-            match *ii {\n-                ast::MethodImplItem(ref m) => register_method(ccx, id, &**m),\n-                ast::TypeImplItem(ref typedef) => {\n-                    ccx.sess().span_bug(typedef.span,\n-                                        \"unexpected variant: required impl \\\n-                                         method in get_item_val()\")\n+        ast_map::NodeImplItem(impl_item) => {\n+            match impl_item.node {\n+                ast::MethodImplItem(..) => {\n+                    register_method(ccx, id, &impl_item.attrs, impl_item.span)\n+                }\n+                ast::TypeImplItem(_) => {\n+                    ccx.sess().span_bug(impl_item.span,\n+                        \"unexpected variant: associated type in get_item_val()\")\n+                }\n+                ast::MacImplItem(_) => {\n+                    ccx.sess().span_bug(impl_item.span,\n+                        \"unexpected variant: unexpanded macro in get_item_val()\")\n                 }\n             }\n         }\n@@ -2925,21 +2918,21 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n }\n \n fn register_method(ccx: &CrateContext, id: ast::NodeId,\n-                   m: &ast::Method) -> ValueRef {\n+                   attrs: &[ast::Attribute], span: Span) -> ValueRef {\n     let mty = ty::node_id_to_type(ccx.tcx(), id);\n \n-    let sym = exported_name(ccx, id, mty, &m.attrs);\n+    let sym = exported_name(ccx, id, mty, &attrs);\n \n     if let ty::ty_bare_fn(_, ref f) = mty.sty {\n         let llfn = if f.abi == Rust || f.abi == RustCall {\n-            register_fn(ccx, m.span, sym, id, mty)\n+            register_fn(ccx, span, sym, id, mty)\n         } else {\n-            foreign::register_rust_fn_with_foreign_abi(ccx, m.span, sym, id)\n+            foreign::register_rust_fn_with_foreign_abi(ccx, span, sym, id)\n         };\n-        set_llvm_fn_attrs(ccx, &m.attrs, llfn);\n+        set_llvm_fn_attrs(ccx, &attrs, llfn);\n         return llfn;\n     } else {\n-        ccx.sess().span_bug(m.span, \"expected bare rust function\");\n+        ccx.sess().span_bug(span, \"expected bare rust function\");\n     }\n }\n "}, {"sha": "b5ab2c28251274562108433cfd20abd0eaec862e", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 28, "deletions": 24, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -217,7 +217,6 @@ use std::rc::{Rc, Weak};\n use syntax::util::interner::Interner;\n use syntax::codemap::{Span, Pos};\n use syntax::{ast, codemap, ast_util, ast_map, attr};\n-use syntax::ast_util::PostExpansionMethod;\n use syntax::parse::token::{self, special_idents};\n \n const DW_LANG_RUST: c_uint = 0x9000;\n@@ -1292,45 +1291,50 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             match item.node {\n                 ast::ItemFn(ref fn_decl, _, _, ref generics, ref top_level_block) => {\n-                    (item.ident, &**fn_decl, generics, &**top_level_block, item.span, true)\n+                    (item.ident, fn_decl, generics, top_level_block, item.span, true)\n                 }\n                 _ => {\n                     cx.sess().span_bug(item.span,\n                         \"create_function_debug_context: item bound to non-function\");\n                 }\n             }\n         }\n-        ast_map::NodeImplItem(ref item) => {\n-            match **item {\n-                ast::MethodImplItem(ref method) => {\n-                    if contains_nodebug_attribute(&method.attrs) {\n+        ast_map::NodeImplItem(impl_item) => {\n+            match impl_item.node {\n+                ast::MethodImplItem(ref sig, ref body) => {\n+                    if contains_nodebug_attribute(&impl_item.attrs) {\n                         return FunctionDebugContext::FunctionWithoutDebugInfo;\n                     }\n \n-                    (method.pe_ident(),\n-                     method.pe_fn_decl(),\n-                     method.pe_generics(),\n-                     method.pe_body(),\n-                     method.span,\n+                    (impl_item.ident,\n+                     &sig.decl,\n+                     &sig.generics,\n+                     body,\n+                     impl_item.span,\n                      true)\n                 }\n-                ast::TypeImplItem(ref typedef) => {\n-                    cx.sess().span_bug(typedef.span,\n+                ast::TypeImplItem(_) => {\n+                    cx.sess().span_bug(impl_item.span,\n                                        \"create_function_debug_context() \\\n                                         called on associated type?!\")\n                 }\n+                ast::MacImplItem(_) => {\n+                    cx.sess().span_bug(impl_item.span,\n+                                       \"create_function_debug_context() \\\n+                                        called on unexpanded macro?!\")\n+                }\n             }\n         }\n         ast_map::NodeExpr(ref expr) => {\n             match expr.node {\n                 ast::ExprClosure(_, ref fn_decl, ref top_level_block) => {\n                     let name = format!(\"fn{}\", token::gensym(\"fn\"));\n                     let name = token::str_to_ident(&name[..]);\n-                    (name, &**fn_decl,\n+                    (name, fn_decl,\n                         // This is not quite right. It should actually inherit\n                         // the generics of the enclosing function.\n                         &empty_generics,\n-                        &**top_level_block,\n+                        top_level_block,\n                         expr.span,\n                         // Don't try to lookup the item path:\n                         false)\n@@ -1339,18 +1343,18 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                         \"create_function_debug_context: expected an expr_fn_block here\")\n             }\n         }\n-        ast_map::NodeTraitItem(ref trait_method) => {\n-            match **trait_method {\n-                ast::ProvidedMethod(ref method) => {\n-                    if contains_nodebug_attribute(&method.attrs) {\n+        ast_map::NodeTraitItem(trait_item) => {\n+            match trait_item.node {\n+                ast::MethodTraitItem(ref sig, Some(ref body)) => {\n+                    if contains_nodebug_attribute(&trait_item.attrs) {\n                         return FunctionDebugContext::FunctionWithoutDebugInfo;\n                     }\n \n-                    (method.pe_ident(),\n-                     method.pe_fn_decl(),\n-                     method.pe_generics(),\n-                     method.pe_body(),\n-                     method.span,\n+                    (trait_item.ident,\n+                     &sig.decl,\n+                     &sig.generics,\n+                     body,\n+                     trait_item.span,\n                      true)\n                 }\n                 _ => {"}, {"sha": "2034c6223c13410d0d77b964d1043cda27309b86", "filename": "src/librustc_trans/trans/inline.rs", "status": "modified", "additions": 35, "deletions": 49, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Finline.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -17,7 +17,7 @@ use trans::common::*;\n use middle::ty;\n \n use syntax::ast;\n-use syntax::ast_util::{local_def, PostExpansionMethod};\n+use syntax::ast_util::local_def;\n \n fn instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n     -> Option<ast::DefId> {\n@@ -42,7 +42,7 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n             ccx.tcx(), fn_id,\n             Box::new(|a,b,c,d| astencode::decode_inlined_item(a, b, c, d)));\n \n-    let inline_def = match csearch_result {\n+    let inline_id = match csearch_result {\n         csearch::FoundAst::NotFound => {\n             ccx.external().borrow_mut().insert(fn_id, None);\n             return None;\n@@ -88,12 +88,12 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n                 None => {}\n             }\n \n-            local_def(item.id)\n+            item.id\n         }\n         csearch::FoundAst::Found(&ast::IIForeign(ref item)) => {\n             ccx.external().borrow_mut().insert(fn_id, Some(item.id));\n             ccx.external_srcs().borrow_mut().insert(item.id, fn_id);\n-            local_def(item.id)\n+            item.id\n         }\n         csearch::FoundAst::FoundParent(parent_id, &ast::IIItem(ref item)) => {\n             ccx.external().borrow_mut().insert(parent_id, Some(item.id));\n@@ -122,67 +122,53 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n                                  non-enum, non-struct parent\")\n           }\n           trans_item(ccx, &**item);\n-          local_def(my_id)\n+          my_id\n         }\n         csearch::FoundAst::FoundParent(_, _) => {\n             ccx.sess().bug(\"maybe_get_item_ast returned a FoundParent \\\n              with a non-item parent\");\n         }\n         csearch::FoundAst::Found(&ast::IITraitItem(_, ref trait_item)) => {\n-            match *trait_item {\n-                ast::RequiredMethod(_) => ccx.sess().bug(\"found RequiredMethod IITraitItem\"),\n-                ast::ProvidedMethod(ref mth) => {\n-                    ccx.external().borrow_mut().insert(fn_id, Some(mth.id));\n-                    ccx.external_srcs().borrow_mut().insert(mth.id, fn_id);\n-\n-                    ccx.stats().n_inlines.set(ccx.stats().n_inlines.get() + 1);\n-\n-                    // If this is a default method, we can't look up the\n-                    // impl type. But we aren't going to translate anyways, so\n-                    // don't.\n-                    local_def(mth.id)\n-                }\n-                ast::TypeTraitItem(_) => {\n-                    ccx.sess().bug(\"found TypeTraitItem IITraitItem\")\n-                }\n-            }\n+            ccx.external().borrow_mut().insert(fn_id, Some(trait_item.id));\n+            ccx.external_srcs().borrow_mut().insert(trait_item.id, fn_id);\n+\n+            ccx.stats().n_inlines.set(ccx.stats().n_inlines.get() + 1);\n+\n+            // If this is a default method, we can't look up the\n+            // impl type. But we aren't going to translate anyways, so\n+            // don't.\n+            trait_item.id\n         }\n         csearch::FoundAst::Found(&ast::IIImplItem(impl_did, ref impl_item)) => {\n-            match *impl_item {\n-                ast::MethodImplItem(ref mth) => {\n-                    ccx.external().borrow_mut().insert(fn_id, Some(mth.id));\n-                    ccx.external_srcs().borrow_mut().insert(mth.id, fn_id);\n+            ccx.external().borrow_mut().insert(fn_id, Some(impl_item.id));\n+            ccx.external_srcs().borrow_mut().insert(impl_item.id, fn_id);\n \n-                    ccx.stats().n_inlines.set(ccx.stats().n_inlines.get() + 1);\n-\n-                    let impl_tpt = ty::lookup_item_type(ccx.tcx(), impl_did);\n-                    let unparameterized = impl_tpt.generics.types.is_empty() &&\n-                            mth.pe_generics().ty_params.is_empty();\n+            ccx.stats().n_inlines.set(ccx.stats().n_inlines.get() + 1);\n \n+            // Translate monomorphic impl methods immediately.\n+            if let ast::MethodImplItem(ref sig, ref body) = impl_item.node {\n+                let impl_tpt = ty::lookup_item_type(ccx.tcx(), impl_did);\n+                if impl_tpt.generics.types.is_empty() &&\n+                        sig.generics.ty_params.is_empty() {\n                     let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n-                    if unparameterized {\n-                        let llfn = get_item_val(ccx, mth.id);\n-                        trans_fn(ccx,\n-                                 &*mth.pe_fn_decl(),\n-                                 &*mth.pe_body(),\n-                                 llfn,\n-                                 empty_substs,\n-                                 mth.id,\n-                                 &[]);\n-                        // Use InternalLinkage so LLVM can optimize more\n-                        // aggressively.\n-                        SetLinkage(llfn, InternalLinkage);\n-                    }\n-                    local_def(mth.id)\n-                }\n-                ast::TypeImplItem(_) => {\n-                    ccx.sess().bug(\"found TypeImplItem IIImplItem\")\n+                    let llfn = get_item_val(ccx, impl_item.id);\n+                    trans_fn(ccx,\n+                             &sig.decl,\n+                             body,\n+                             llfn,\n+                             empty_substs,\n+                             impl_item.id,\n+                             &[]);\n+                    // Use InternalLinkage so LLVM can optimize more aggressively.\n+                    SetLinkage(llfn, InternalLinkage);\n                 }\n             }\n+\n+            impl_item.id\n         }\n     };\n \n-    return Some(inline_def);\n+    Some(local_def(inline_id))\n }\n \n pub fn get_local_instance(ccx: &CrateContext, fn_id: ast::DefId)"}, {"sha": "ba3798d7d8028e1ff79afce6e86a5aafbe77c33e", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 21, "deletions": 36, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -41,8 +41,8 @@ use std::rc::Rc;\n use syntax::abi::{Rust, RustCall};\n use syntax::parse::token;\n use syntax::{ast, ast_map, attr, visit};\n-use syntax::ast_util::PostExpansionMethod;\n use syntax::codemap::DUMMY_SP;\n+use syntax::ptr::P;\n \n // drop_glue pointer, size, align.\n const VTABLE_OFFSET: uint = 3;\n@@ -53,55 +53,50 @@ const VTABLE_OFFSET: uint = 3;\n /// see `trans::base::lval_static_fn()` or `trans::base::monomorphic_fn()`.\n pub fn trans_impl(ccx: &CrateContext,\n                   name: ast::Ident,\n-                  impl_items: &[ast::ImplItem],\n+                  impl_items: &[P<ast::ImplItem>],\n                   generics: &ast::Generics,\n                   id: ast::NodeId) {\n     let _icx = push_ctxt(\"meth::trans_impl\");\n     let tcx = ccx.tcx();\n \n     debug!(\"trans_impl(name={}, id={})\", name.repr(tcx), id);\n \n+    let mut v = TransItemVisitor { ccx: ccx };\n+\n     // Both here and below with generic methods, be sure to recurse and look for\n     // items that we need to translate.\n     if !generics.ty_params.is_empty() {\n-        let mut v = TransItemVisitor{ ccx: ccx };\n         for impl_item in impl_items {\n-            match *impl_item {\n-                ast::MethodImplItem(ref method) => {\n-                    visit::walk_method_helper(&mut v, &**method);\n+            match impl_item.node {\n+                ast::MethodImplItem(..) => {\n+                    visit::walk_impl_item(&mut v, impl_item);\n                 }\n-                ast::TypeImplItem(_) => {}\n+                ast::TypeImplItem(_) |\n+                ast::MacImplItem(_) => {}\n             }\n         }\n         return;\n     }\n     for impl_item in impl_items {\n-        match *impl_item {\n-            ast::MethodImplItem(ref method) => {\n-                if method.pe_generics().ty_params.len() == 0 {\n-                    let trans_everywhere = attr::requests_inline(&method.attrs);\n+        match impl_item.node {\n+            ast::MethodImplItem(ref sig, ref body) => {\n+                if sig.generics.ty_params.len() == 0 {\n+                    let trans_everywhere = attr::requests_inline(&impl_item.attrs);\n                     for (ref ccx, is_origin) in ccx.maybe_iter(trans_everywhere) {\n-                        let llfn = get_item_val(ccx, method.id);\n+                        let llfn = get_item_val(ccx, impl_item.id);\n                         let empty_substs = tcx.mk_substs(Substs::trans_empty());\n-                        trans_fn(ccx,\n-                                 method.pe_fn_decl(),\n-                                 method.pe_body(),\n-                                 llfn,\n-                                 empty_substs,\n-                                 method.id,\n-                                 &[]);\n+                        trans_fn(ccx, &sig.decl, body, llfn,\n+                                 empty_substs, impl_item.id, &[]);\n                         update_linkage(ccx,\n                                        llfn,\n-                                       Some(method.id),\n+                                       Some(impl_item.id),\n                                        if is_origin { OriginalTranslation } else { InlinedCopy });\n                     }\n                 }\n-                let mut v = TransItemVisitor {\n-                    ccx: ccx,\n-                };\n-                visit::walk_method_helper(&mut v, &**method);\n+                visit::walk_impl_item(&mut v, impl_item);\n             }\n-            ast::TypeImplItem(_) => {}\n+            ast::TypeImplItem(_) |\n+            ast::MacImplItem(_) => {}\n         }\n     }\n }\n@@ -189,17 +184,7 @@ pub fn trans_static_method_callee<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let mname = if method_id.krate == ast::LOCAL_CRATE {\n         match tcx.map.get(method_id.node) {\n-            ast_map::NodeTraitItem(method) => {\n-                let ident = match *method {\n-                    ast::RequiredMethod(ref m) => m.ident,\n-                    ast::ProvidedMethod(ref m) => m.pe_ident(),\n-                    ast::TypeTraitItem(_) => {\n-                        tcx.sess.bug(\"trans_static_method_callee() on \\\n-                                      an associated type?!\")\n-                    }\n-                };\n-                ident.name\n-            }\n+            ast_map::NodeTraitItem(trait_item) => trait_item.ident.name,\n             _ => panic!(\"callee is not a trait method\")\n         }\n     } else {"}, {"sha": "2083e737f89b117e0f984535712aec0fb866fba4", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -29,7 +29,7 @@ use util::ppaux::Repr;\n use syntax::abi;\n use syntax::ast;\n use syntax::ast_map;\n-use syntax::ast_util::{local_def, PostExpansionMethod};\n+use syntax::ast_util::local_def;\n use syntax::attr;\n use syntax::codemap::DUMMY_SP;\n use std::hash::{Hasher, Hash, SipHasher};\n@@ -216,35 +216,38 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             }\n             d\n         }\n-        ast_map::NodeImplItem(ii) => {\n-            match *ii {\n-                ast::MethodImplItem(ref mth) => {\n+        ast_map::NodeImplItem(impl_item) => {\n+            match impl_item.node {\n+                ast::MethodImplItem(ref sig, ref body) => {\n                     let d = mk_lldecl(abi::Rust);\n-                    let needs_body = setup_lldecl(d, &mth.attrs);\n+                    let needs_body = setup_lldecl(d, &impl_item.attrs);\n                     if needs_body {\n                         trans_fn(ccx,\n-                                 mth.pe_fn_decl(),\n-                                 mth.pe_body(),\n+                                 &sig.decl,\n+                                 body,\n                                  d,\n                                  psubsts,\n-                                 mth.id,\n+                                 impl_item.id,\n                                  &[]);\n                     }\n                     d\n                 }\n                 ast::TypeImplItem(_) => {\n                     ccx.sess().bug(\"can't monomorphize an associated type\")\n                 }\n+                ast::MacImplItem(_) => {\n+                    ccx.sess().bug(\"can't monomorphize an unexpanded macro\")\n+                }\n             }\n         }\n-        ast_map::NodeTraitItem(method) => {\n-            match *method {\n-                ast::ProvidedMethod(ref mth) => {\n+        ast_map::NodeTraitItem(trait_item) => {\n+            match trait_item.node {\n+                ast::MethodTraitItem(ref sig, Some(ref body)) => {\n                     let d = mk_lldecl(abi::Rust);\n-                    let needs_body = setup_lldecl(d, &mth.attrs);\n+                    let needs_body = setup_lldecl(d, &trait_item.attrs);\n                     if needs_body {\n-                        trans_fn(ccx, mth.pe_fn_decl(), mth.pe_body(), d,\n-                                 psubsts, mth.id, &[]);\n+                        trans_fn(ccx, &sig.decl, body, d,\n+                                 psubsts, trait_item.id, &[]);\n                     }\n                     d\n                 }"}, {"sha": "28e7027b2124a2e2135e7d0b4007851de08b46ff", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 9, "deletions": 17, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -1095,14 +1095,9 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n         // by type collection, which may be in progress at this point.\n         match this.tcx().map.expect_item(trait_did.node).node {\n             ast::ItemTrait(_, _, _, ref trait_items) => {\n-                trait_items.iter().filter_map(|i| {\n-                    if let ast::TypeTraitItem(ref assoc) = *i {\n-                        if assoc.ty_param.ident.name == assoc_name {\n-                            return Some(ast_util::local_def(assoc.ty_param.id));\n-                        }\n-                    }\n-                    None\n-                }).next().expect(\"missing associated type\")\n+                let item = trait_items.iter().find(|i| i.ident.name == assoc_name)\n+                                      .expect(\"missing associated type\");\n+                ast_util::local_def(item.id)\n             }\n             _ => unreachable!()\n         }\n@@ -1447,22 +1442,19 @@ struct SelfInfo<'a, 'tcx> {\n }\n \n pub fn ty_of_method<'tcx>(this: &AstConv<'tcx>,\n-                          unsafety: ast::Unsafety,\n-                          untransformed_self_ty: Ty<'tcx>,\n-                          explicit_self: &ast::ExplicitSelf,\n-                          decl: &ast::FnDecl,\n-                          abi: abi::Abi)\n+                          sig: &ast::MethodSig,\n+                          untransformed_self_ty: Ty<'tcx>)\n                           -> (ty::BareFnTy<'tcx>, ty::ExplicitSelfCategory) {\n     let self_info = Some(SelfInfo {\n         untransformed_self_ty: untransformed_self_ty,\n-        explicit_self: explicit_self,\n+        explicit_self: &sig.explicit_self,\n     });\n     let (bare_fn_ty, optional_explicit_self_category) =\n         ty_of_method_or_bare_fn(this,\n-                                unsafety,\n-                                abi,\n+                                sig.unsafety,\n+                                sig.abi,\n                                 self_info,\n-                                decl);\n+                                &sig.decl);\n     (bare_fn_ty, optional_explicit_self_category.unwrap())\n }\n "}, {"sha": "41951ab2b620087368480fe58f69cf0dcf12517b", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 49, "deletions": 47, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -119,8 +119,8 @@ use std::iter::repeat;\n use std::slice;\n use syntax::{self, abi, attr};\n use syntax::attr::AttrMetaMethods;\n-use syntax::ast::{self, ProvidedMethod, RequiredMethod, TypeTraitItem, DefId, Visibility};\n-use syntax::ast_util::{self, local_def, PostExpansionMethod};\n+use syntax::ast::{self, DefId, Visibility};\n+use syntax::ast_util::{self, local_def};\n use syntax::codemap::{self, Span};\n use syntax::owned_slice::OwnedSlice;\n use syntax::parse::token;\n@@ -739,30 +739,33 @@ pub fn check_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n           }\n \n         for impl_item in impl_items {\n-            match *impl_item {\n-                ast::MethodImplItem(ref m) => {\n-                    check_method_body(ccx, &impl_pty.generics, &**m);\n+            match impl_item.node {\n+                ast::MethodImplItem(ref sig, ref body) => {\n+                    check_method_body(ccx, &impl_pty.generics, sig, body,\n+                                      impl_item.id, impl_item.span);\n                 }\n-                ast::TypeImplItem(_) => {\n+                ast::TypeImplItem(_) |\n+                ast::MacImplItem(_) => {\n                     // Nothing to do here.\n                 }\n             }\n         }\n \n       }\n-      ast::ItemTrait(_, ref generics, _, ref trait_methods) => {\n+      ast::ItemTrait(_, ref generics, _, ref trait_items) => {\n         check_trait_on_unimplemented(ccx, generics, it);\n         let trait_def = ty::lookup_trait_def(ccx.tcx, local_def(it.id));\n-        for trait_method in trait_methods {\n-            match *trait_method {\n-                RequiredMethod(..) => {\n+        for trait_item in trait_items {\n+            match trait_item.node {\n+                ast::MethodTraitItem(_, None) => {\n                     // Nothing to do, since required methods don't have\n                     // bodies to check.\n                 }\n-                ProvidedMethod(ref m) => {\n-                    check_method_body(ccx, &trait_def.generics, &**m);\n+                ast::MethodTraitItem(ref sig, Some(ref body)) => {\n+                    check_method_body(ccx, &trait_def.generics, sig, body,\n+                                      trait_item.id, trait_item.span);\n                 }\n-                TypeTraitItem(_) => {\n+                ast::TypeTraitItem(..) => {\n                     // Nothing to do.\n                 }\n             }\n@@ -855,38 +858,33 @@ fn check_trait_on_unimplemented<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n /// * `method`: the method definition\n fn check_method_body<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                item_generics: &ty::Generics<'tcx>,\n-                               method: &'tcx ast::Method) {\n-    debug!(\"check_method_body(item_generics={}, method.id={})\",\n-            item_generics.repr(ccx.tcx),\n-            method.id);\n-    let param_env = ParameterEnvironment::for_item(ccx.tcx, method.id);\n-\n-    let fty = ty::node_id_to_type(ccx.tcx, method.id);\n+                               sig: &'tcx ast::MethodSig,\n+                               body: &'tcx ast::Block,\n+                               id: ast::NodeId, span: Span) {\n+    debug!(\"check_method_body(item_generics={}, id={})\",\n+            item_generics.repr(ccx.tcx), id);\n+    let param_env = ParameterEnvironment::for_item(ccx.tcx, id);\n+\n+    let fty = ty::node_id_to_type(ccx.tcx, id);\n     debug!(\"check_method_body: fty={}\", fty.repr(ccx.tcx));\n \n-    check_bare_fn(ccx,\n-                  &*method.pe_fn_decl(),\n-                  &*method.pe_body(),\n-                  method.id,\n-                  method.span,\n-                  fty,\n-                  param_env);\n+    check_bare_fn(ccx, &sig.decl, body, id, span, fty, param_env);\n }\n \n fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                             impl_span: Span,\n                                             impl_trait_ref: &ty::TraitRef<'tcx>,\n-                                            impl_items: &[ast::ImplItem]) {\n+                                            impl_items: &[P<ast::ImplItem>]) {\n     // Locate trait methods\n     let tcx = ccx.tcx;\n     let trait_items = ty::trait_items(tcx, impl_trait_ref.def_id);\n \n     // Check existing impl methods to see if they are both present in trait\n     // and compatible with trait signature\n     for impl_item in impl_items {\n-        match *impl_item {\n-            ast::MethodImplItem(ref impl_method) => {\n-                let impl_method_def_id = local_def(impl_method.id);\n+        match impl_item.node {\n+            ast::MethodImplItem(_, ref body) => {\n+                let impl_method_def_id = local_def(impl_item.id);\n                 let impl_item_ty = ty::impl_or_trait_item(ccx.tcx,\n                                                           impl_method_def_id);\n \n@@ -902,16 +900,16 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                              &ty::MethodTraitItem(ref impl_method_ty)) => {\n                                 compare_impl_method(ccx.tcx,\n                                                     &**impl_method_ty,\n-                                                    impl_method.span,\n-                                                    impl_method.pe_body().id,\n+                                                    impl_item.span,\n+                                                    body.id,\n                                                     &**trait_method_ty,\n                                                     &*impl_trait_ref);\n                             }\n                             _ => {\n                                 // This is span_bug as it should have already been\n                                 // caught in resolve.\n                                 tcx.sess.span_bug(\n-                                    impl_method.span,\n+                                    impl_item.span,\n                                     &format!(\"item `{}` is of a different kind from its trait `{}`\",\n                                              token::get_name(impl_item_ty.name()),\n                                              impl_trait_ref.repr(tcx)));\n@@ -922,15 +920,15 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                         // This is span_bug as it should have already been\n                         // caught in resolve.\n                         tcx.sess.span_bug(\n-                            impl_method.span,\n+                            impl_item.span,\n                             &format!(\"method `{}` is not a member of trait `{}`\",\n                                      token::get_name(impl_item_ty.name()),\n                                      impl_trait_ref.repr(tcx)));\n                     }\n                 }\n             }\n-            ast::TypeImplItem(ref typedef) => {\n-                let typedef_def_id = local_def(typedef.id);\n+            ast::TypeImplItem(_) => {\n+                let typedef_def_id = local_def(impl_item.id);\n                 let typedef_ty = ty::impl_or_trait_item(ccx.tcx,\n                                                         typedef_def_id);\n \n@@ -947,7 +945,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                 // This is `span_bug` as it should have\n                                 // already been caught in resolve.\n                                 tcx.sess.span_bug(\n-                                    typedef.span,\n+                                    impl_item.span,\n                                     &format!(\"item `{}` is of a different kind from its trait `{}`\",\n                                              token::get_name(typedef_ty.name()),\n                                              impl_trait_ref.repr(tcx)));\n@@ -958,7 +956,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                         // This is `span_bug` as it should have already been\n                         // caught in resolve.\n                         tcx.sess.span_bug(\n-                            typedef.span,\n+                            impl_item.span,\n                             &format!(\n                                 \"associated type `{}` is not a member of \\\n                                  trait `{}`\",\n@@ -967,6 +965,8 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                     }\n                 }\n             }\n+            ast::MacImplItem(_) => tcx.sess.span_bug(impl_item.span,\n+                                                     \"unexpanded macro\")\n         }\n     }\n \n@@ -978,11 +978,12 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             ty::MethodTraitItem(ref trait_method) => {\n                 let is_implemented =\n                     impl_items.iter().any(|ii| {\n-                        match *ii {\n-                            ast::MethodImplItem(ref m) => {\n-                                m.pe_ident().name == trait_method.name\n+                        match ii.node {\n+                            ast::MethodImplItem(..) => {\n+                                ii.ident.name == trait_method.name\n                             }\n-                            ast::TypeImplItem(_) => false,\n+                            ast::TypeImplItem(_) |\n+                            ast::MacImplItem(_) => false,\n                         }\n                     });\n                 let is_provided =\n@@ -993,11 +994,12 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             }\n             ty::TypeTraitItem(ref associated_type) => {\n                 let is_implemented = impl_items.iter().any(|ii| {\n-                    match *ii {\n-                        ast::TypeImplItem(ref typedef) => {\n-                            typedef.ident.name == associated_type.name\n+                    match ii.node {\n+                        ast::TypeImplItem(_) => {\n+                            ii.ident.name == associated_type.name\n                         }\n-                        ast::MethodImplItem(_) => false,\n+                        ast::MethodImplItem(..) |\n+                        ast::MacImplItem(_) => false,\n                     }\n                 });\n                 if !is_implemented {"}, {"sha": "adbf4c6b210e83a345146680bb601525da776f89", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -498,28 +498,24 @@ impl<'ccx, 'tcx, 'v> Visitor<'v> for CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         visit::walk_fn(self, fk, fd, b, span)\n     }\n \n-    fn visit_trait_item(&mut self, t: &'v ast::TraitItem) {\n-        match t {\n-            &ast::TraitItem::ProvidedMethod(_) |\n-            &ast::TraitItem::TypeTraitItem(_) => {},\n-            &ast::TraitItem::RequiredMethod(ref method) => {\n-                match ty::impl_or_trait_item(self.tcx(), local_def(method.id)) {\n-                    ty::ImplOrTraitItem::MethodTraitItem(ty_method) => {\n-                        reject_non_type_param_bounds(\n-                            self.tcx(),\n-                            method.span,\n-                            &ty_method.predicates);\n-                        reject_shadowing_type_parameters(\n-                            self.tcx(),\n-                            method.span,\n-                            &ty_method.generics);\n-                    }\n-                    _ => {}\n+    fn visit_trait_item(&mut self, trait_item: &'v ast::TraitItem) {\n+        if let ast::MethodTraitItem(_, None) = trait_item.node {\n+            match ty::impl_or_trait_item(self.tcx(), local_def(trait_item.id)) {\n+                ty::ImplOrTraitItem::MethodTraitItem(ty_method) => {\n+                    reject_non_type_param_bounds(\n+                        self.tcx(),\n+                        trait_item.span,\n+                        &ty_method.predicates);\n+                    reject_shadowing_type_parameters(\n+                        self.tcx(),\n+                        trait_item.span,\n+                        &ty_method.generics);\n                 }\n+                _ => {}\n             }\n         }\n \n-        visit::walk_trait_item(self, t)\n+        visit::walk_trait_item(self, trait_item)\n     }\n }\n "}, {"sha": "6b0fb8ac71af0479f8b3ab85cc304448da19fac6", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -275,20 +275,22 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n     // Converts an implementation in the AST to a vector of items.\n     fn create_impl_from_item(&self, item: &Item) -> Vec<ImplOrTraitItemId> {\n         match item.node {\n-            ItemImpl(_, _, _, ref opt_trait, _, ref ast_items) => {\n+            ItemImpl(_, _, _, ref opt_trait, _, ref impl_items) => {\n                 let mut items: Vec<ImplOrTraitItemId> =\n-                        ast_items.iter()\n-                                 .map(|ast_item| {\n-                            match *ast_item {\n-                                ast::MethodImplItem(ref ast_method) => {\n-                                    MethodTraitItemId(\n-                                        local_def(ast_method.id))\n-                                }\n-                                ast::TypeImplItem(ref typedef) => {\n-                                    TypeTraitItemId(local_def(typedef.id))\n-                                }\n-                            }\n-                        }).collect();\n+                        impl_items.iter().map(|impl_item| {\n+                    match impl_item.node {\n+                        ast::MethodImplItem(..) => {\n+                            MethodTraitItemId(local_def(impl_item.id))\n+                        }\n+                        ast::TypeImplItem(_) => {\n+                            TypeTraitItemId(local_def(impl_item.id))\n+                        }\n+                        ast::MacImplItem(_) => {\n+                            self.crate_context.tcx.sess.span_bug(impl_item.span,\n+                                                                 \"unexpanded macro\");\n+                        }\n+                    }\n+                }).collect();\n \n                 if opt_trait.is_some() {\n                     let trait_ref = ty::impl_id_to_trait_ref(self.crate_context.tcx,"}, {"sha": "23726805767978baca036df89d988257381450b2", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 182, "deletions": 347, "changes": 529, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -89,7 +89,7 @@ use std::rc::Rc;\n use syntax::abi;\n use syntax::ast;\n use syntax::ast_map;\n-use syntax::ast_util::{local_def, PostExpansionMethod};\n+use syntax::ast_util::local_def;\n use syntax::codemap::Span;\n use syntax::parse::token::{special_idents};\n use syntax::parse::token;\n@@ -621,160 +621,52 @@ fn get_enum_variant_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n-fn collect_trait_methods<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                   trait_id: ast::NodeId,\n-                                   trait_def: &ty::TraitDef<'tcx>,\n-                                   trait_predicates: &ty::GenericPredicates<'tcx>) {\n-    let tcx = ccx.tcx;\n-    if let ast_map::NodeItem(item) = tcx.map.get(trait_id) {\n-        if let ast::ItemTrait(_, _, _, ref trait_items) = item.node {\n-            // For each method, construct a suitable ty::Method and\n-            // store it into the `tcx.impl_or_trait_items` table:\n-            for trait_item in trait_items {\n-                match *trait_item {\n-                    ast::RequiredMethod(_) |\n-                    ast::ProvidedMethod(_) => {\n-                        let ty_method = Rc::new(match *trait_item {\n-                            ast::RequiredMethod(ref m) => {\n-                                ty_method_of_trait_method(\n-                                    ccx,\n-                                    trait_id,\n-                                    &trait_def.generics,\n-                                    &trait_predicates,\n-                                    &trait_items[..],\n-                                    &m.id,\n-                                    &m.ident.name,\n-                                    &m.explicit_self,\n-                                    m.abi,\n-                                    &m.generics,\n-                                    &m.unsafety,\n-                                    &*m.decl)\n-                            }\n-                            ast::ProvidedMethod(ref m) => {\n-                                ty_method_of_trait_method(\n-                                    ccx,\n-                                    trait_id,\n-                                    &trait_def.generics,\n-                                    &trait_predicates,\n-                                    &trait_items[..],\n-                                    &m.id,\n-                                    &m.pe_ident().name,\n-                                    m.pe_explicit_self(),\n-                                    m.pe_abi(),\n-                                    m.pe_generics(),\n-                                    &m.pe_unsafety(),\n-                                    &*m.pe_fn_decl())\n-                            }\n-                            ast::TypeTraitItem(ref at) => {\n-                                tcx.sess.span_bug(at.ty_param.span,\n-                                                  \"there shouldn't be a type trait item here\")\n-                            }\n-                        });\n-\n-                        debug!(\"ty_method_of_trait_method yielded {} for method {} of trait {}\",\n-                               ty_method.repr(ccx.tcx),\n-                               trait_item.repr(ccx.tcx),\n-                               local_def(trait_id).repr(ccx.tcx));\n-\n-                        make_method_ty(ccx, &*ty_method);\n-\n-                        tcx.impl_or_trait_items\n-                            .borrow_mut()\n-                            .insert(ty_method.def_id, ty::MethodTraitItem(ty_method));\n-                    }\n-                    ast::TypeTraitItem(ref ast_associated_type) => {\n-                        let trait_did = local_def(trait_id);\n-                        let associated_type = ty::AssociatedType {\n-                            name: ast_associated_type.ty_param.ident.name,\n-                            vis: ast::Public,\n-                            def_id: local_def(ast_associated_type.ty_param.id),\n-                            container: TraitContainer(trait_did),\n-                        };\n-\n-                        let trait_item = ty::TypeTraitItem(Rc::new(associated_type));\n-                        tcx.impl_or_trait_items\n-                            .borrow_mut()\n-                            .insert(associated_type.def_id, trait_item);\n-                    }\n-                }\n-            }\n-\n-            // Add an entry mapping\n-            let trait_item_def_ids =\n-                Rc::new(trait_items.iter().map(|ti| {\n-                    match *ti {\n-                        ast::RequiredMethod(ref ty_method) => {\n-                            ty::MethodTraitItemId(local_def(ty_method.id))\n-                        }\n-                        ast::ProvidedMethod(ref method) => {\n-                            ty::MethodTraitItemId(local_def(method.id))\n-                        }\n-                        ast::TypeTraitItem(ref typedef) => {\n-                            ty::TypeTraitItemId(local_def(typedef.ty_param.id))\n-                        }\n-                    }\n-                }).collect());\n+fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                            container: ImplOrTraitItemContainer,\n+                            sig: &ast::MethodSig,\n+                            id: ast::NodeId,\n+                            ident: ast::Ident,\n+                            vis: ast::Visibility,\n+                            untransformed_rcvr_ty: Ty<'tcx>,\n+                            rcvr_ty_generics: &ty::Generics<'tcx>,\n+                            rcvr_ty_predicates: &ty::GenericPredicates<'tcx>) {\n+    let ty_generics = ty_generics_for_fn(ccx, &sig.generics, rcvr_ty_generics);\n+\n+    let ty_generic_predicates =\n+        ty_generic_predicates_for_fn(ccx, &sig.generics, rcvr_ty_predicates);\n+\n+    let (fty, explicit_self_category) =\n+        astconv::ty_of_method(&ccx.icx(&(rcvr_ty_predicates, &sig.generics)),\n+                              sig, untransformed_rcvr_ty);\n+\n+    let def_id = local_def(id);\n+    let ty_method = ty::Method::new(ident.name,\n+                                    ty_generics,\n+                                    ty_generic_predicates,\n+                                    fty,\n+                                    explicit_self_category,\n+                                    vis,\n+                                    def_id,\n+                                    container,\n+                                    None);\n+\n+    let fty = ty::mk_bare_fn(ccx.tcx, Some(def_id),\n+                             ccx.tcx.mk_bare_fn(ty_method.fty.clone()));\n+    debug!(\"method {} (id {}) has type {}\",\n+            ident.repr(ccx.tcx), id, fty.repr(ccx.tcx));\n+    ccx.tcx.tcache.borrow_mut().insert(def_id,TypeScheme {\n+        generics: ty_method.generics.clone(),\n+        ty: fty\n+    });\n+    ccx.tcx.predicates.borrow_mut().insert(def_id, ty_method.predicates.clone());\n \n-            let trait_def_id = local_def(trait_id);\n-            tcx.trait_item_def_ids.borrow_mut().insert(trait_def_id, trait_item_def_ids);\n-        }\n-    }\n+    write_ty_to_tcx(ccx.tcx, id, fty);\n \n-    fn make_method_ty<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, m: &ty::Method<'tcx>) {\n-        ccx.tcx.tcache.borrow_mut().insert(\n-            m.def_id,\n-            TypeScheme {\n-                generics: m.generics.clone(),\n-                ty: ty::mk_bare_fn(ccx.tcx, Some(m.def_id), ccx.tcx.mk_bare_fn(m.fty.clone()))\n-            });\n-        ccx.tcx.predicates.borrow_mut().insert(\n-            m.def_id,\n-            m.predicates.clone());\n-    }\n-\n-    fn ty_method_of_trait_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                           trait_id: ast::NodeId,\n-                                           trait_generics: &ty::Generics<'tcx>,\n-                                           trait_bounds: &ty::GenericPredicates<'tcx>,\n-                                           _trait_items: &[ast::TraitItem],\n-                                           m_id: &ast::NodeId,\n-                                           m_name: &ast::Name,\n-                                           m_explicit_self: &ast::ExplicitSelf,\n-                                           m_abi: abi::Abi,\n-                                           m_generics: &ast::Generics,\n-                                           m_unsafety: &ast::Unsafety,\n-                                           m_decl: &ast::FnDecl)\n-                                           -> ty::Method<'tcx>\n-    {\n-        let ty_generics =\n-            ty_generics_for_fn(ccx, m_generics, trait_generics);\n-\n-        let ty_generic_predicates =\n-            ty_generic_predicates_for_fn(ccx, m_generics, trait_bounds);\n-\n-        let (fty, explicit_self_category) = {\n-            let trait_self_ty = ty::mk_self_type(ccx.tcx);\n-            astconv::ty_of_method(&ccx.icx(&(trait_bounds, m_generics)),\n-                                  *m_unsafety,\n-                                  trait_self_ty,\n-                                  m_explicit_self,\n-                                  m_decl,\n-                                  m_abi)\n-        };\n+    debug!(\"writing method type: def_id={:?} mty={}\",\n+            def_id, ty_method.repr(ccx.tcx));\n \n-        ty::Method::new(\n-            *m_name,\n-            ty_generics,\n-            ty_generic_predicates,\n-            fty,\n-            explicit_self_category,\n-            // assume public, because this is only invoked on trait methods\n-            ast::Public,\n-            local_def(*m_id),\n-            TraitContainer(local_def(trait_id)),\n-            None\n-        )\n-    }\n+    ccx.tcx.impl_or_trait_items.borrow_mut().insert(def_id,\n+        ty::MethodTraitItem(Rc::new(ty_method)));\n }\n \n fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n@@ -817,29 +709,28 @@ fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n }\n \n fn convert_associated_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                     trait_def: &ty::TraitDef<'tcx>,\n-                                     associated_type: &ast::AssociatedType)\n+                                     container: ImplOrTraitItemContainer,\n+                                     ident: ast::Ident,\n+                                     id: ast::NodeId,\n+                                     vis: ast::Visibility)\n {\n     let associated_type = Rc::new(ty::AssociatedType {\n-        name: associated_type.ty_param.ident.name,\n-        vis: ast::Public,\n-        def_id: local_def(associated_type.ty_param.id),\n-        container: TraitContainer(trait_def.trait_ref.def_id),\n+        name: ident.name,\n+        vis: vis,\n+        def_id: local_def(id),\n+        container: container\n     });\n-    ccx.tcx\n-       .impl_or_trait_items\n-       .borrow_mut()\n-       .insert(associated_type.def_id, ty::TypeTraitItem(associated_type));\n+    ccx.tcx.impl_or_trait_items.borrow_mut()\n+       .insert(local_def(id), ty::TypeTraitItem(associated_type));\n }\n \n fn convert_methods<'a,'tcx,'i,I>(ccx: &CrateCtxt<'a, 'tcx>,\n                                  container: ImplOrTraitItemContainer,\n-                                 ms: I,\n+                                 methods: I,\n                                  untransformed_rcvr_ty: Ty<'tcx>,\n                                  rcvr_ty_generics: &ty::Generics<'tcx>,\n-                                 rcvr_ty_predicates: &ty::GenericPredicates<'tcx>,\n-                                 rcvr_visibility: ast::Visibility)\n-                                 where I: Iterator<Item=&'i ast::Method>\n+                                 rcvr_ty_predicates: &ty::GenericPredicates<'tcx>)\n+    where I: Iterator<Item=(&'i ast::MethodSig, ast::NodeId, ast::Ident, ast::Visibility, Span)>\n {\n     debug!(\"convert_methods(untransformed_rcvr_ty={}, rcvr_ty_generics={}, rcvr_ty_predicates={})\",\n            untransformed_rcvr_ty.repr(ccx.tcx),\n@@ -848,81 +739,20 @@ fn convert_methods<'a,'tcx,'i,I>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     let tcx = ccx.tcx;\n     let mut seen_methods = FnvHashSet();\n-    for m in ms {\n-        if !seen_methods.insert(m.pe_ident().repr(tcx)) {\n-            span_err!(tcx.sess, m.span, E0201, \"duplicate method in trait impl\");\n+    for (sig, id, ident, vis, span) in methods {\n+        if !seen_methods.insert(ident.name) {\n+            span_err!(tcx.sess, span, E0201, \"duplicate method\");\n         }\n \n-        let m_def_id = local_def(m.id);\n-\n-        let mty = Rc::new(ty_of_method(ccx,\n-                                       container,\n-                                       m,\n-                                       untransformed_rcvr_ty,\n-                                       rcvr_ty_generics,\n-                                       rcvr_ty_predicates,\n-                                       rcvr_visibility));\n-        let fty = ty::mk_bare_fn(tcx, Some(m_def_id), tcx.mk_bare_fn(mty.fty.clone()));\n-        debug!(\"method {} (id {}) has type {}\",\n-                m.pe_ident().repr(tcx),\n-                m.id,\n-                fty.repr(tcx));\n-        tcx.tcache.borrow_mut().insert(\n-            m_def_id,\n-            TypeScheme {\n-                generics: mty.generics.clone(),\n-                ty: fty\n-            });\n-        tcx.predicates.borrow_mut().insert(m_def_id, mty.predicates.clone());\n-\n-        write_ty_to_tcx(tcx, m.id, fty);\n-\n-        debug!(\"writing method type: def_id={:?} mty={}\",\n-               mty.def_id, mty.repr(ccx.tcx));\n-\n-        tcx.impl_or_trait_items\n-           .borrow_mut()\n-           .insert(mty.def_id, ty::MethodTraitItem(mty));\n-    }\n-\n-    fn ty_of_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                              container: ImplOrTraitItemContainer,\n-                              m: &ast::Method,\n-                              untransformed_rcvr_ty: Ty<'tcx>,\n-                              rcvr_ty_generics: &ty::Generics<'tcx>,\n-                              rcvr_ty_predicates: &ty::GenericPredicates<'tcx>,\n-                              rcvr_visibility: ast::Visibility)\n-                              -> ty::Method<'tcx>\n-    {\n-        let m_ty_generics =\n-            ty_generics_for_fn(ccx, m.pe_generics(), rcvr_ty_generics);\n-\n-        let m_ty_generic_predicates =\n-            ty_generic_predicates_for_fn(ccx, m.pe_generics(), rcvr_ty_predicates);\n-\n-        let (fty, explicit_self_category) =\n-            astconv::ty_of_method(&ccx.icx(&(rcvr_ty_predicates, m.pe_generics())),\n-                                  m.pe_unsafety(),\n-                                  untransformed_rcvr_ty,\n-                                  m.pe_explicit_self(),\n-                                  &*m.pe_fn_decl(),\n-                                  m.pe_abi());\n-\n-        // if the method specifies a visibility, use that, otherwise\n-        // inherit the visibility from the impl (so `foo` in `pub impl\n-        // { fn foo(); }` is public, but private in `priv impl { fn\n-        // foo(); }`).\n-        let method_vis = m.pe_vis().inherit_from(rcvr_visibility);\n-\n-        ty::Method::new(m.pe_ident().name,\n-                        m_ty_generics,\n-                        m_ty_generic_predicates,\n-                        fty,\n-                        explicit_self_category,\n-                        method_vis,\n-                        local_def(m.id),\n-                        container,\n-                        None)\n+        convert_method(ccx,\n+                       container,\n+                       sig,\n+                       id,\n+                       ident,\n+                       vis,\n+                       untransformed_rcvr_ty,\n+                       rcvr_ty_generics,\n+                       rcvr_ty_predicates);\n     }\n }\n \n@@ -1014,62 +844,67 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n                 it.vis\n             };\n \n-            let mut methods = Vec::new();\n+            // Convert all the associated types.\n             for impl_item in impl_items {\n-                match *impl_item {\n-                    ast::MethodImplItem(ref method) => {\n-                        methods.push(&**method);\n-                    }\n-                    ast::TypeImplItem(ref typedef) => {\n+                match impl_item.node {\n+                    ast::TypeImplItem(ref ty) => {\n                         if opt_trait_ref.is_none() {\n-                            span_err!(tcx.sess, typedef.span, E0202,\n+                            span_err!(tcx.sess, impl_item.span, E0202,\n                                               \"associated items are not allowed in inherent impls\");\n                         }\n \n-                        let typ = ccx.icx(&ty_predicates).to_ty(&ExplicitRscope, &*typedef.typ);\n-                        tcx.tcache.borrow_mut().insert(local_def(typedef.id),\n+                        convert_associated_type(ccx, ImplContainer(local_def(it.id)),\n+                                                impl_item.ident, impl_item.id, impl_item.vis);\n+\n+                        let typ = ccx.icx(&ty_predicates).to_ty(&ExplicitRscope, ty);\n+                        tcx.tcache.borrow_mut().insert(local_def(impl_item.id),\n                                                        TypeScheme {\n                                                            generics: ty::Generics::empty(),\n                                                            ty: typ,\n                                                        });\n-                        tcx.predicates.borrow_mut().insert(local_def(typedef.id),\n+                        tcx.predicates.borrow_mut().insert(local_def(impl_item.id),\n                                                            ty::GenericPredicates::empty());\n-                        write_ty_to_tcx(tcx, typedef.id, typ);\n-\n-                        let associated_type = Rc::new(ty::AssociatedType {\n-                            name: typedef.ident.name,\n-                            vis: typedef.vis,\n-                            def_id: local_def(typedef.id),\n-                            container: ty::ImplContainer(local_def(it.id)),\n-                        });\n-                        tcx.impl_or_trait_items\n-                           .borrow_mut()\n-                           .insert(local_def(typedef.id),\n-                                   ty::TypeTraitItem(associated_type));\n+                        write_ty_to_tcx(tcx, impl_item.id, typ);\n                     }\n+                    ast::MethodImplItem(..) |\n+                    ast::MacImplItem(_) => {}\n                 }\n             }\n \n+            let methods = impl_items.iter().filter_map(|ii| {\n+                match ii.node {\n+                    ast::MethodImplItem(ref sig, _) => {\n+                        // if the method specifies a visibility, use that, otherwise\n+                        // inherit the visibility from the impl (so `foo` in `pub impl\n+                        // { fn foo(); }` is public, but private in `priv impl { fn\n+                        // foo(); }`).\n+                        let method_vis = ii.vis.inherit_from(parent_visibility);\n+                        Some((sig, ii.id, ii.ident, method_vis, ii.span))\n+                    }\n+                    ast::TypeImplItem(_) |\n+                    ast::MacImplItem(_) => None\n+                }\n+            });\n             convert_methods(ccx,\n                             ImplContainer(local_def(it.id)),\n-                            methods.into_iter(),\n+                            methods,\n                             selfty,\n                             &ty_generics,\n-                            &ty_predicates,\n-                            parent_visibility);\n+                            &ty_predicates);\n \n             for impl_item in impl_items {\n-                match *impl_item {\n-                    ast::MethodImplItem(ref method) => {\n-                        let body_id = method.pe_body().id;\n+                match impl_item.node {\n+                    ast::MethodImplItem(ref sig, ref body) => {\n+                        let body_id = body.id;\n                         check_method_self_type(ccx,\n                                                &BindingRscope::new(),\n-                                               ccx.method_ty(method.id),\n+                                               ccx.method_ty(impl_item.id),\n                                                selfty,\n-                                               method.pe_explicit_self(),\n+                                               &sig.explicit_self,\n                                                body_id);\n                     }\n-                    ast::TypeImplItem(..) => { }\n+                    ast::TypeImplItem(_) |\n+                    ast::MacImplItem(_) => {}\n                 }\n             }\n \n@@ -1091,57 +926,64 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n             let _: Result<(), ErrorReported> = // any error is already reported, can ignore\n                 ccx.ensure_super_predicates(it.span, local_def(it.id));\n             convert_trait_predicates(ccx, it);\n-            let trait_predicates = ty::lookup_predicates(ccx.tcx, local_def(it.id));\n+            let trait_predicates = ty::lookup_predicates(tcx, local_def(it.id));\n \n             debug!(\"convert: trait_bounds={:?}\", trait_predicates);\n \n-            // Run convert_methods on the provided methods.\n-            let untransformed_rcvr_ty = ty::mk_self_type(tcx);\n+            // Convert all the associated types.\n+            for trait_item in trait_items {\n+                match trait_item.node {\n+                    ast::MethodTraitItem(..) => {}\n+                    ast::TypeTraitItem(..) => {\n+                        convert_associated_type(ccx, TraitContainer(local_def(it.id)),\n+                                                trait_item.ident, trait_item.id, ast::Public);\n+                    }\n+                }\n+            };\n+\n+            let methods = trait_items.iter().filter_map(|ti| {\n+                let sig = match ti.node {\n+                    ast::MethodTraitItem(ref sig, _) => sig,\n+                    ast::TypeTraitItem(..) => return None,\n+                };\n+                Some((sig, ti.id, ti.ident, ast::Inherited, ti.span))\n+            });\n+\n+            // Run convert_methods on the trait methods.\n             convert_methods(ccx,\n                             TraitContainer(local_def(it.id)),\n-                            trait_items.iter().filter_map(|m| match *m {\n-                                ast::RequiredMethod(_) => None,\n-                                ast::ProvidedMethod(ref m) => Some(&**m),\n-                                ast::TypeTraitItem(_) => None,\n-                            }),\n-                            untransformed_rcvr_ty,\n+                            methods,\n+                            ty::mk_self_type(tcx),\n                             &trait_def.generics,\n-                            &trait_predicates,\n-                            it.vis);\n+                            &trait_predicates);\n \n-            // We need to do this *after* converting methods, since\n-            // convert_methods produces a tcache entry that is wrong for\n-            // static trait methods. This is somewhat unfortunate.\n-            collect_trait_methods(ccx, it.id, &*trait_def, &trait_predicates);\n+            // Add an entry mapping\n+            let trait_item_def_ids = Rc::new(trait_items.iter().map(|trait_item| {\n+                let def_id = local_def(trait_item.id);\n+                match trait_item.node {\n+                    ast::MethodTraitItem(..) => {\n+                        ty::MethodTraitItemId(def_id)\n+                    }\n+                    ast::TypeTraitItem(..) => {\n+                        ty::TypeTraitItemId(def_id)\n+                    }\n+                }\n+            }).collect());\n+            tcx.trait_item_def_ids.borrow_mut().insert(local_def(it.id), trait_item_def_ids);\n \n             // This must be done after `collect_trait_methods` so that\n             // we have a method type stored for every method.\n             for trait_item in trait_items {\n-                let self_type = ty::mk_self_type(tcx);\n-                match *trait_item {\n-                    ast::RequiredMethod(ref type_method) => {\n-                        let rscope = BindingRscope::new();\n-                        check_method_self_type(ccx,\n-                                               &rscope,\n-                                               ccx.method_ty(type_method.id),\n-                                               self_type,\n-                                               &type_method.explicit_self,\n-                                               it.id)\n-                    }\n-                    ast::ProvidedMethod(ref method) => {\n-                        check_method_self_type(ccx,\n-                                               &BindingRscope::new(),\n-                                               ccx.method_ty(method.id),\n-                                               self_type,\n-                                               method.pe_explicit_self(),\n-                                               it.id)\n-                    }\n-                    ast::TypeTraitItem(ref associated_type) => {\n-                        convert_associated_type(ccx,\n-                                                &*trait_def,\n-                                                &**associated_type);\n-                    }\n-                }\n+                let sig = match trait_item.node {\n+                    ast::MethodTraitItem(ref sig, _) => sig,\n+                    ast::TypeTraitItem(..) => continue\n+                };\n+                check_method_self_type(ccx,\n+                                       &BindingRscope::new(),\n+                                       ccx.method_ty(trait_item.id),\n+                                       ty::mk_self_type(tcx),\n+                                       &sig.explicit_self,\n+                                       it.id)\n             }\n         },\n         ast::ItemStruct(ref struct_def, _) => {\n@@ -1351,15 +1193,12 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     let ty_generics = ty_generics_for_trait(ccx, it.id, substs, generics);\n \n-    let associated_type_names: Vec<_> =\n-        items.iter()\n-             .filter_map(|item| {\n-                 match *item {\n-                     ast::RequiredMethod(_) | ast::ProvidedMethod(_) => None,\n-                     ast::TypeTraitItem(ref data) => Some(data.ty_param.ident.name),\n-                 }\n-             })\n-             .collect();\n+    let associated_type_names: Vec<_> = items.iter().filter_map(|trait_item| {\n+        match trait_item.node {\n+            ast::MethodTraitItem(..) => None,\n+            ast::TypeTraitItem(..) => Some(trait_item.ident.name),\n+        }\n+    }).collect();\n \n     let trait_ref = Rc::new(ty::TraitRef {\n         def_id: def_id,\n@@ -1426,13 +1265,12 @@ fn trait_defines_associated_type_named(ccx: &CrateCtxt,\n         _ => ccx.tcx.sess.bug(&format!(\"trait_node_id {} is not a trait\", trait_node_id))\n     };\n \n-    trait_items.iter()\n-               .any(|trait_item| {\n-                   match *trait_item {\n-                       ast::TypeTraitItem(ref t) => t.ty_param.ident.name == assoc_name,\n-                       ast::RequiredMethod(..) | ast::ProvidedMethod(..) => false,\n-                   }\n-               })\n+    trait_items.iter().any(|trait_item| {\n+        match trait_item.node {\n+            ast::TypeTraitItem(..) => trait_item.ident.name == assoc_name,\n+            ast::MethodTraitItem(..) => false,\n+        }\n+    })\n }\n \n fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item) {\n@@ -1484,32 +1322,29 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item)\n                                                  ast_generics: &ast::Generics,\n                                                  trait_predicates: &ty::GenericPredicates<'tcx>,\n                                                  self_trait_ref: &Rc<ty::TraitRef<'tcx>>,\n-                                                 trait_items: &[ast::TraitItem])\n+                                                 trait_items: &[P<ast::TraitItem>])\n                                                  -> Vec<ty::Predicate<'tcx>>\n     {\n-        trait_items\n-            .iter()\n-            .flat_map(|trait_item| {\n-                let assoc_type_def = match *trait_item {\n-                    ast::TypeTraitItem(ref assoc_type) => &assoc_type.ty_param,\n-                    ast::RequiredMethod(..) | ast::ProvidedMethod(..) => {\n-                        return vec!().into_iter();\n-                    }\n-                };\n+        trait_items.iter().flat_map(|trait_item| {\n+            let bounds = match trait_item.node {\n+                ast::TypeTraitItem(ref bounds, _) => bounds,\n+                ast::MethodTraitItem(..) => {\n+                    return vec!().into_iter();\n+                }\n+            };\n \n-                let assoc_ty = ty::mk_projection(ccx.tcx,\n-                                                 self_trait_ref.clone(),\n-                                                 assoc_type_def.ident.name);\n+            let assoc_ty = ty::mk_projection(ccx.tcx,\n+                                             self_trait_ref.clone(),\n+                                             trait_item.ident.name);\n \n-                let bounds = compute_bounds(&ccx.icx(&(ast_generics, trait_predicates)),\n-                                            assoc_ty,\n-                                            &*assoc_type_def.bounds,\n-                                            SizedByDefault::Yes,\n-                                            assoc_type_def.span);\n+            let bounds = compute_bounds(&ccx.icx(&(ast_generics, trait_predicates)),\n+                                        assoc_ty,\n+                                        bounds,\n+                                        SizedByDefault::Yes,\n+                                        trait_item.span);\n \n-                ty::predicates(ccx.tcx, assoc_ty, &bounds).into_iter()\n-            })\n-            .collect()\n+            ty::predicates(ccx.tcx, assoc_ty, &bounds).into_iter()\n+        }).collect()\n     }\n }\n "}, {"sha": "9f7b68f38fa6ee980f963bb22d669aa95576e55c", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -147,29 +147,13 @@ pub fn record_extern_fqn(cx: &DocContext, did: ast::DefId, kind: clean::TypeKind\n \n pub fn build_external_trait(cx: &DocContext, tcx: &ty::ctxt,\n                             did: ast::DefId) -> clean::Trait {\n-    use clean::TraitMethod;\n-\n     let def = ty::lookup_trait_def(tcx, did);\n     let trait_items = ty::trait_items(tcx, did).clean(cx);\n-    let provided = ty::provided_trait_methods(tcx, did);\n-    let items = trait_items.into_iter().map(|trait_item| {\n-        match trait_item.inner {\n-            clean::TyMethodItem(_) => {\n-                if provided.iter().any(|a| a.def_id == trait_item.def_id) {\n-                    TraitMethod::ProvidedMethod(trait_item)\n-                } else {\n-                    TraitMethod::RequiredMethod(trait_item)\n-                }\n-            },\n-            clean::AssociatedTypeItem(_) => TraitMethod::TypeTraitItem(trait_item),\n-            _ => unreachable!()\n-        }\n-    });\n     let predicates = ty::lookup_predicates(tcx, did);\n     clean::Trait {\n         unsafety: def.unsafety,\n         generics: (&def.generics, &predicates, subst::TypeSpace).clean(cx),\n-        items: items.collect(),\n+        items: trait_items,\n         bounds: vec![], // supertraits can be found in the list of predicates\n     }\n }"}, {"sha": "e91e95961c521157153c54280f455c3c7980c727", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 77, "deletions": 149, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -11,7 +11,6 @@\n //! This module contains the \"cleaned\" pieces of the AST, and the functions\n //! that clean them.\n \n-pub use self::ImplMethod::*;\n pub use self::Type::*;\n pub use self::PrimitiveType::*;\n pub use self::TypeKind::*;\n@@ -24,13 +23,11 @@ pub use self::Attribute::*;\n pub use self::TyParamBound::*;\n pub use self::SelfTy::*;\n pub use self::FunctionRetTy::*;\n-pub use self::TraitMethod::*;\n \n use syntax;\n use syntax::abi;\n use syntax::ast;\n use syntax::ast_util;\n-use syntax::ast_util::PostExpansionMethod;\n use syntax::attr;\n use syntax::attr::{AttributeMethods, AttrMetaMethods};\n use syntax::codemap;\n@@ -70,7 +67,7 @@ pub trait Clean<T> {\n     fn clean(&self, cx: &DocContext) -> T;\n }\n \n-impl<T: Clean<U>, U> Clean<Vec<U>> for Vec<T> {\n+impl<T: Clean<U>, U> Clean<Vec<U>> for [T] {\n     fn clean(&self, cx: &DocContext) -> Vec<U> {\n         self.iter().map(|x| x.clean(cx)).collect()\n     }\n@@ -339,7 +336,7 @@ pub enum ItemEnum {\n     ForeignStaticItem(Static),\n     MacroItem(Macro),\n     PrimitiveItem(PrimitiveType),\n-    AssociatedTypeItem(TyParam),\n+    AssociatedTypeItem(Vec<TyParamBound>, Option<Type>),\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n@@ -951,34 +948,26 @@ pub struct Method {\n     pub abi: abi::Abi\n }\n \n-impl Clean<Item> for ast::Method {\n-    fn clean(&self, cx: &DocContext) -> Item {\n-        let all_inputs = &self.pe_fn_decl().inputs;\n-        let inputs = match self.pe_explicit_self().node {\n+impl Clean<Method> for ast::MethodSig {\n+    fn clean(&self, cx: &DocContext) -> Method {\n+        let all_inputs = &self.decl.inputs;\n+        let inputs = match self.explicit_self.node {\n             ast::SelfStatic => &**all_inputs,\n             _ => &all_inputs[1..]\n         };\n         let decl = FnDecl {\n             inputs: Arguments {\n-                values: inputs.iter().map(|x| x.clean(cx)).collect(),\n+                values: inputs.clean(cx),\n             },\n-            output: self.pe_fn_decl().output.clean(cx),\n+            output: self.decl.output.clean(cx),\n             attrs: Vec::new()\n         };\n-        Item {\n-            name: Some(self.pe_ident().clean(cx)),\n-            attrs: self.attrs.clean(cx),\n-            source: self.span.clean(cx),\n-            def_id: ast_util::local_def(self.id),\n-            visibility: self.pe_vis().clean(cx),\n-            stability: get_stability(cx, ast_util::local_def(self.id)),\n-            inner: MethodItem(Method {\n-                generics: self.pe_generics().clean(cx),\n-                self_: self.pe_explicit_self().node.clean(cx),\n-                unsafety: self.pe_unsafety().clone(),\n-                decl: decl,\n-                abi: self.pe_abi()\n-            }),\n+        Method {\n+            generics: self.generics.clean(cx),\n+            self_: self.explicit_self.node.clean(cx),\n+            unsafety: self.unsafety.clone(),\n+            decl: decl,\n+            abi: self.abi\n         }\n     }\n }\n@@ -992,33 +981,25 @@ pub struct TyMethod {\n     pub abi: abi::Abi\n }\n \n-impl Clean<Item> for ast::TypeMethod {\n-    fn clean(&self, cx: &DocContext) -> Item {\n+impl Clean<TyMethod> for ast::MethodSig {\n+    fn clean(&self, cx: &DocContext) -> TyMethod {\n         let inputs = match self.explicit_self.node {\n             ast::SelfStatic => &*self.decl.inputs,\n             _ => &self.decl.inputs[1..]\n         };\n         let decl = FnDecl {\n             inputs: Arguments {\n-                values: inputs.iter().map(|x| x.clean(cx)).collect(),\n+                values: inputs.clean(cx),\n             },\n             output: self.decl.output.clean(cx),\n             attrs: Vec::new()\n         };\n-        Item {\n-            name: Some(self.ident.clean(cx)),\n-            attrs: self.attrs.clean(cx),\n-            source: self.span.clean(cx),\n-            def_id: ast_util::local_def(self.id),\n-            visibility: None,\n-            stability: get_stability(cx, ast_util::local_def(self.id)),\n-            inner: TyMethodItem(TyMethod {\n-                unsafety: self.unsafety.clone(),\n-                decl: decl,\n-                self_: self.explicit_self.node.clean(cx),\n-                generics: self.generics.clean(cx),\n-                abi: self.abi\n-            }),\n+        TyMethod {\n+            unsafety: self.unsafety.clone(),\n+            decl: decl,\n+            self_: self.explicit_self.node.clean(cx),\n+            generics: self.generics.clean(cx),\n+            abi: self.abi\n         }\n     }\n }\n@@ -1166,7 +1147,7 @@ impl Clean<FunctionRetTy> for ast::FunctionRetTy {\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Trait {\n     pub unsafety: ast::Unsafety,\n-    pub items: Vec<TraitMethod>,\n+    pub items: Vec<Item>,\n     pub generics: Generics,\n     pub bounds: Vec<TyParamBound>,\n }\n@@ -1205,64 +1186,59 @@ impl Clean<PolyTrait> for ast::PolyTraitRef {\n     }\n }\n \n-/// An item belonging to a trait, whether a method or associated. Could be named\n-/// TraitItem except that's already taken by an exported enum variant.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n-pub enum TraitMethod {\n-    RequiredMethod(Item),\n-    ProvidedMethod(Item),\n-    TypeTraitItem(Item), // an associated type\n-}\n-\n-impl TraitMethod {\n-    pub fn is_req(&self) -> bool {\n-        match self {\n-            &RequiredMethod(..) => true,\n-            _ => false,\n-        }\n-    }\n-    pub fn is_def(&self) -> bool {\n-        match self {\n-            &ProvidedMethod(..) => true,\n-            _ => false,\n-        }\n-    }\n-    pub fn is_type(&self) -> bool {\n-        match self {\n-            &TypeTraitItem(..) => true,\n-            _ => false,\n-        }\n-    }\n-    pub fn item<'a>(&'a self) -> &'a Item {\n-        match *self {\n-            RequiredMethod(ref item) => item,\n-            ProvidedMethod(ref item) => item,\n-            TypeTraitItem(ref item) => item,\n-        }\n-    }\n-}\n-\n-impl Clean<TraitMethod> for ast::TraitItem {\n-    fn clean(&self, cx: &DocContext) -> TraitMethod {\n-        match self {\n-            &ast::RequiredMethod(ref t) => RequiredMethod(t.clean(cx)),\n-            &ast::ProvidedMethod(ref t) => ProvidedMethod(t.clean(cx)),\n-            &ast::TypeTraitItem(ref t) => TypeTraitItem(t.clean(cx)),\n+impl Clean<Item> for ast::TraitItem {\n+    fn clean(&self, cx: &DocContext) -> Item {\n+        let inner = match self.node {\n+            ast::MethodTraitItem(ref sig, Some(_)) => {\n+                MethodItem(sig.clean(cx))\n+            }\n+            ast::MethodTraitItem(ref sig, None) => {\n+                TyMethodItem(sig.clean(cx))\n+            }\n+            ast::TypeTraitItem(ref bounds, ref default) => {\n+                AssociatedTypeItem(bounds.clean(cx), default.clean(cx))\n+            }\n+        };\n+        Item {\n+            name: Some(self.ident.clean(cx)),\n+            attrs: self.attrs.clean(cx),\n+            source: self.span.clean(cx),\n+            def_id: ast_util::local_def(self.id),\n+            visibility: None,\n+            stability: get_stability(cx, ast_util::local_def(self.id)),\n+            inner: inner\n         }\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n-pub enum ImplMethod {\n-    MethodImplItem(Item),\n-    TypeImplItem(Item),\n-}\n-\n-impl Clean<ImplMethod> for ast::ImplItem {\n-    fn clean(&self, cx: &DocContext) -> ImplMethod {\n-        match self {\n-            &ast::MethodImplItem(ref t) => MethodImplItem(t.clean(cx)),\n-            &ast::TypeImplItem(ref t) => TypeImplItem(t.clean(cx)),\n+impl Clean<Item> for ast::ImplItem {\n+    fn clean(&self, cx: &DocContext) -> Item {\n+        let inner = match self.node {\n+            ast::MethodImplItem(ref sig, _) => {\n+                MethodItem(sig.clean(cx))\n+            }\n+            ast::TypeImplItem(ref ty) => TypedefItem(Typedef {\n+                type_: ty.clean(cx),\n+                generics: Generics {\n+                    lifetimes: Vec::new(),\n+                    type_params: Vec::new(),\n+                    where_predicates: Vec::new()\n+                },\n+            }),\n+            ast::MacImplItem(_) => {\n+                MacroItem(Macro {\n+                    source: self.span.to_src(cx),\n+                })\n+            }\n+        };\n+        Item {\n+            name: Some(self.ident.clean(cx)),\n+            source: self.span.clean(cx),\n+            attrs: self.attrs.clean(cx),\n+            def_id: ast_util::local_def(self.id),\n+            visibility: self.vis.clean(cx),\n+            stability: get_stability(cx, ast_util::local_def(self.id)),\n+            inner: inner\n         }\n     }\n }\n@@ -2128,12 +2104,7 @@ impl Clean<Item> for doctree::Impl {\n                 generics: self.generics.clean(cx),\n                 trait_: self.trait_.clean(cx),\n                 for_: self.for_.clean(cx),\n-                items: self.items.clean(cx).into_iter().map(|ti| {\n-                        match ti {\n-                            MethodImplItem(i) => i,\n-                            TypeImplItem(i) => i,\n-                        }\n-                    }).collect(),\n+                items: self.items.clean(cx),\n                 derived: detect_derived(&self.attrs),\n                 polarity: Some(self.polarity.clean(cx)),\n             }),\n@@ -2500,65 +2471,22 @@ impl Clean<Stability> for attr::Stability {\n     }\n }\n \n-impl Clean<Item> for ast::AssociatedType {\n-    fn clean(&self, cx: &DocContext) -> Item {\n-        Item {\n-            source: self.ty_param.span.clean(cx),\n-            name: Some(self.ty_param.ident.clean(cx)),\n-            attrs: self.attrs.clean(cx),\n-            inner: AssociatedTypeItem(self.ty_param.clean(cx)),\n-            visibility: None,\n-            def_id: ast_util::local_def(self.ty_param.id),\n-            stability: None,\n-        }\n-    }\n-}\n-\n impl Clean<Item> for ty::AssociatedType {\n     fn clean(&self, cx: &DocContext) -> Item {\n         Item {\n             source: DUMMY_SP.clean(cx),\n             name: Some(self.name.clean(cx)),\n             attrs: Vec::new(),\n-            inner: AssociatedTypeItem(TyParam {\n-                name: self.name.clean(cx),\n-                did: ast::DefId {\n-                    krate: 0,\n-                    node: ast::DUMMY_NODE_ID\n-                },\n-                // FIXME(#20727): bounds are missing and need to be filled in from the\n-                // predicates on the trait itself\n-                bounds: vec![],\n-                default: None,\n-            }),\n+            // FIXME(#20727): bounds are missing and need to be filled in from the\n+            // predicates on the trait itself\n+            inner: AssociatedTypeItem(vec![], None),\n             visibility: None,\n             def_id: self.def_id,\n             stability: None,\n         }\n     }\n }\n \n-impl Clean<Item> for ast::Typedef {\n-    fn clean(&self, cx: &DocContext) -> Item {\n-        Item {\n-            source: self.span.clean(cx),\n-            name: Some(self.ident.clean(cx)),\n-            attrs: self.attrs.clean(cx),\n-            inner: TypedefItem(Typedef {\n-                type_: self.typ.clean(cx),\n-                generics: Generics {\n-                    lifetimes: Vec::new(),\n-                    type_params: Vec::new(),\n-                    where_predicates: Vec::new()\n-                },\n-            }),\n-            visibility: None,\n-            def_id: ast_util::local_def(self.id),\n-            stability: None,\n-        }\n-    }\n-}\n-\n impl<'a> Clean<Typedef> for (ty::TypeScheme<'a>, ty::GenericPredicates<'a>, ParamSpace) {\n     fn clean(&self, cx: &DocContext) -> Typedef {\n         let (ref ty_scheme, ref predicates, ps) = *self;"}, {"sha": "5a4deaa2e726672eab0bb6f9675aef25c0a8a779", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -174,7 +174,7 @@ pub struct Constant {\n pub struct Trait {\n     pub unsafety: ast::Unsafety,\n     pub name: Ident,\n-    pub items: Vec<ast::TraitItem>, //should be TraitItem\n+    pub items: Vec<P<ast::TraitItem>>, //should be TraitItem\n     pub generics: ast::Generics,\n     pub bounds: Vec<ast::TyParamBound>,\n     pub attrs: Vec<ast::Attribute>,\n@@ -190,7 +190,7 @@ pub struct Impl {\n     pub generics: ast::Generics,\n     pub trait_: Option<ast::TraitRef>,\n     pub for_: P<ast::Ty>,\n-    pub items: Vec<ast::ImplItem>,\n+    pub items: Vec<P<ast::ImplItem>>,\n     pub attrs: Vec<ast::Attribute>,\n     pub whence: Span,\n     pub vis: ast::Visibility,"}, {"sha": "cdeeacfb78397f0d6bc9028ebbeb093e1bfc6795", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 2, "deletions": 26, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -40,37 +40,13 @@ pub trait DocFolder : Sized {\n                 EnumItem(i)\n             },\n             TraitItem(mut i) => {\n-                fn vtrm<T: DocFolder>(this: &mut T, trm: TraitMethod)\n-                        -> Option<TraitMethod> {\n-                    match trm {\n-                        RequiredMethod(it) => {\n-                            match this.fold_item(it) {\n-                                Some(x) => return Some(RequiredMethod(x)),\n-                                None => return None,\n-                            }\n-                        },\n-                        ProvidedMethod(it) => {\n-                            match this.fold_item(it) {\n-                                Some(x) => return Some(ProvidedMethod(x)),\n-                                None => return None,\n-                            }\n-                        },\n-                        TypeTraitItem(it) => {\n-                            match this.fold_item(it) {\n-                                Some(x) => return Some(TypeTraitItem(x)),\n-                                None => return None,\n-                            }\n-                        }\n-                    }\n-                }\n                 let mut foo = Vec::new(); swap(&mut foo, &mut i.items);\n-                i.items.extend(foo.into_iter().filter_map(|x| vtrm(self, x)));\n+                i.items.extend(foo.into_iter().filter_map(|x| self.fold_item(x)));\n                 TraitItem(i)\n             },\n             ImplItem(mut i) => {\n                 let mut foo = Vec::new(); swap(&mut foo, &mut i.items);\n-                i.items.extend(foo.into_iter()\n-                                  .filter_map(|x| self.fold_item(x)));\n+                i.items.extend(foo.into_iter().filter_map(|x| self.fold_item(x)));\n                 ImplItem(i)\n             },\n             VariantItem(i) => {"}, {"sha": "dba7b16eceecbe922861ed7d3274e009a6d49cde", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 30, "deletions": 22, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -1685,33 +1685,39 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                   bounds,\n                   WhereClause(&t.generics)));\n \n-    let types = t.items.iter().filter(|m| m.is_type()).collect::<Vec<_>>();\n-    let required = t.items.iter().filter(|m| m.is_req()).collect::<Vec<_>>();\n-    let provided = t.items.iter().filter(|m| m.is_def()).collect::<Vec<_>>();\n+    let types = t.items.iter().filter(|m| {\n+        match m.inner { clean::AssociatedTypeItem(..) => true, _ => false }\n+    }).collect::<Vec<_>>();\n+    let required = t.items.iter().filter(|m| {\n+        match m.inner { clean::TyMethodItem(_) => true, _ => false }\n+    }).collect::<Vec<_>>();\n+    let provided = t.items.iter().filter(|m| {\n+        match m.inner { clean::MethodItem(_) => true, _ => false }\n+    }).collect::<Vec<_>>();\n \n     if t.items.len() == 0 {\n         try!(write!(w, \"{{ }}\"));\n     } else {\n         try!(write!(w, \"{{\\n\"));\n         for t in &types {\n             try!(write!(w, \"    \"));\n-            try!(render_method(w, t.item()));\n+            try!(render_method(w, t));\n             try!(write!(w, \";\\n\"));\n         }\n         if types.len() > 0 && required.len() > 0 {\n             try!(w.write_str(\"\\n\"));\n         }\n         for m in &required {\n             try!(write!(w, \"    \"));\n-            try!(render_method(w, m.item()));\n+            try!(render_method(w, m));\n             try!(write!(w, \";\\n\"));\n         }\n         if required.len() > 0 && provided.len() > 0 {\n             try!(w.write_str(\"\\n\"));\n         }\n         for m in &provided {\n             try!(write!(w, \"    \"));\n-            try!(render_method(w, m.item()));\n+            try!(render_method(w, m));\n             try!(write!(w, \" {{ ... }}\\n\"));\n         }\n         try!(write!(w, \"}}\"));\n@@ -1721,15 +1727,15 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     // Trait documentation\n     try!(document(w, it));\n \n-    fn trait_item(w: &mut fmt::Formatter, m: &clean::TraitMethod)\n+    fn trait_item(w: &mut fmt::Formatter, m: &clean::Item)\n                   -> fmt::Result {\n         try!(write!(w, \"<h3 id='{}.{}' class='method'>{}<code>\",\n-                    shortty(m.item()),\n-                    *m.item().name.as_ref().unwrap(),\n-                    ConciseStability(&m.item().stability)));\n-        try!(render_method(w, m.item()));\n+                    shortty(m),\n+                    *m.name.as_ref().unwrap(),\n+                    ConciseStability(&m.stability)));\n+        try!(render_method(w, m));\n         try!(write!(w, \"</code></h3>\"));\n-        try!(document(w, m.item()));\n+        try!(document(w, m));\n         Ok(())\n     }\n \n@@ -1798,12 +1804,14 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n }\n \n fn assoc_type(w: &mut fmt::Formatter, it: &clean::Item,\n-              typ: &clean::TyParam) -> fmt::Result {\n+              bounds: &Vec<clean::TyParamBound>,\n+              default: &Option<clean::Type>)\n+              -> fmt::Result {\n     try!(write!(w, \"type {}\", it.name.as_ref().unwrap()));\n-    if typ.bounds.len() > 0 {\n-        try!(write!(w, \": {}\", TyParamBounds(&*typ.bounds)))\n+    if bounds.len() > 0 {\n+        try!(write!(w, \": {}\", TyParamBounds(bounds)))\n     }\n-    if let Some(ref default) = typ.default {\n+    if let Some(ref default) = *default {\n         try!(write!(w, \" = {}\", default));\n     }\n     Ok(())\n@@ -1839,8 +1847,8 @@ fn render_method(w: &mut fmt::Formatter, meth: &clean::Item) -> fmt::Result {\n         clean::MethodItem(ref m) => {\n             method(w, meth, m.unsafety, m.abi, &m.generics, &m.self_, &m.decl)\n         }\n-        clean::AssociatedTypeItem(ref typ) => {\n-            assoc_type(w, meth, typ)\n+        clean::AssociatedTypeItem(ref bounds, ref default) => {\n+            assoc_type(w, meth, bounds, default)\n         }\n         _ => panic!(\"render_method called on non-method\")\n     }\n@@ -2138,13 +2146,13 @@ fn render_impl(w: &mut fmt::Formatter, i: &Impl) -> fmt::Result {\n                 try!(write!(w, \"type {} = {}\", name, tydef.type_));\n                 try!(write!(w, \"</code></h4>\\n\"));\n             }\n-            clean::AssociatedTypeItem(ref typaram) => {\n+            clean::AssociatedTypeItem(ref bounds, ref default) => {\n                 let name = item.name.as_ref().unwrap();\n                 try!(write!(w, \"<h4 id='assoc_type.{}' class='{}'>{}<code>\",\n                             *name,\n                             shortty(item),\n                             ConciseStability(&item.stability)));\n-                try!(assoc_type(w, item, typaram));\n+                try!(assoc_type(w, item, bounds, default));\n                 try!(write!(w, \"</code></h4>\\n\"));\n             }\n             _ => panic!(\"can't make docs for trait item with name {:?}\", item.name)\n@@ -2167,13 +2175,13 @@ fn render_impl(w: &mut fmt::Formatter, i: &Impl) -> fmt::Result {\n                               t: &clean::Trait,\n                               i: &clean::Impl) -> fmt::Result {\n         for trait_item in &t.items {\n-            let n = trait_item.item().name.clone();\n+            let n = trait_item.name.clone();\n             match i.items.iter().find(|m| { m.name == n }) {\n                 Some(..) => continue,\n                 None => {}\n             }\n \n-            try!(doctraititem(w, trait_item.item(), false));\n+            try!(doctraititem(w, trait_item, false));\n         }\n         Ok(())\n     }"}, {"sha": "0726a822b59b7a469d11092e6ba9f13e3cf23b0e", "filename": "src/librustdoc/stability_summary.rs", "status": "modified", "additions": 11, "deletions": 23, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustdoc%2Fstability_summary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibrustdoc%2Fstability_summary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fstability_summary.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -20,8 +20,8 @@ use syntax::attr::{Unstable, Stable};\n use syntax::ast::Public;\n \n use clean::{Crate, Item, ModuleItem, Module, EnumItem, Enum};\n-use clean::{ImplItem, Impl, Trait, TraitItem, TraitMethod, ProvidedMethod, RequiredMethod};\n-use clean::{TypeTraitItem, ExternCrateItem, ImportItem, PrimitiveItem, Stability};\n+use clean::{ImplItem, Impl, Trait, TraitItem};\n+use clean::{ExternCrateItem, ImportItem, PrimitiveItem, Stability};\n \n use html::render::cache;\n \n@@ -140,11 +140,11 @@ fn summarize_item(item: &Item) -> (Counts, Option<ModuleSummary>) {\n     // considered to have no children.\n     match item.inner {\n         // Require explicit `pub` to be visible\n-        ImplItem(Impl { items: ref subitems, trait_: None, .. }) => {\n-            let subcounts = subitems.iter().filter(|i| visible(*i))\n-                                           .map(summarize_item)\n-                                           .map(|s| s.0)\n-                                           .fold(Counts::zero(), |acc, x| acc + x);\n+        ImplItem(Impl { ref items, trait_: None, .. }) => {\n+            let subcounts = items.iter().filter(|i| visible(*i))\n+                                        .map(summarize_item)\n+                                        .map(|s| s.0)\n+                                        .fold(Counts::zero(), |acc, x| acc + x);\n             (subcounts, None)\n         }\n         // `pub` automatically\n@@ -154,22 +154,10 @@ fn summarize_item(item: &Item) -> (Counts, Option<ModuleSummary>) {\n                                            .fold(Counts::zero(), |acc, x| acc + x);\n             (item_counts + subcounts, None)\n         }\n-        TraitItem(Trait {\n-            items: ref trait_items,\n-            ..\n-        }) => {\n-            fn extract_item<'a>(trait_item: &'a TraitMethod) -> &'a Item {\n-                match *trait_item {\n-                    ProvidedMethod(ref item) |\n-                    RequiredMethod(ref item) |\n-                    TypeTraitItem(ref item) => item\n-                }\n-            }\n-            let subcounts = trait_items.iter()\n-                                       .map(extract_item)\n-                                       .map(summarize_item)\n-                                       .map(|s| s.0)\n-                                       .fold(Counts::zero(), |acc, x| acc + x);\n+        TraitItem(Trait { ref items, .. }) => {\n+            let subcounts = items.iter().map(summarize_item)\n+                                        .map(|s| s.0)\n+                                        .fold(Counts::zero(), |acc, x| acc + x);\n             (item_counts + subcounts, None)\n         }\n         ModuleItem(Module { ref items, .. }) => {"}, {"sha": "657ffcaece9f85f3fd7020f230703caad296e6e6", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 28, "deletions": 54, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -22,7 +22,7 @@ pub use self::Expr_::*;\n pub use self::FloatTy::*;\n pub use self::FunctionRetTy::*;\n pub use self::ForeignItem_::*;\n-pub use self::ImplItem::*;\n+pub use self::ImplItem_::*;\n pub use self::InlinedItem::*;\n pub use self::IntTy::*;\n pub use self::Item_::*;\n@@ -33,7 +33,6 @@ pub use self::LocalSource::*;\n pub use self::Mac_::*;\n pub use self::MacStmtStyle::*;\n pub use self::MetaItem_::*;\n-pub use self::Method_::*;\n pub use self::Mutability::*;\n pub use self::Pat_::*;\n pub use self::PathListItem_::*;\n@@ -44,7 +43,7 @@ pub use self::Stmt_::*;\n pub use self::StrStyle::*;\n pub use self::StructFieldKind::*;\n pub use self::TokenTree::*;\n-pub use self::TraitItem::*;\n+pub use self::TraitItem_::*;\n pub use self::Ty_::*;\n pub use self::TyParamBound::*;\n pub use self::UintTy::*;\n@@ -1058,53 +1057,51 @@ pub struct TypeField {\n     pub span: Span,\n }\n \n-/// Represents a required method in a trait declaration,\n-/// one without a default implementation\n+/// Represents a method's signature in a trait declaration,\n+/// or in an implementation.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub struct TypeMethod {\n-    pub ident: Ident,\n-    pub attrs: Vec<Attribute>,\n+pub struct MethodSig {\n     pub unsafety: Unsafety,\n     pub abi: Abi,\n     pub decl: P<FnDecl>,\n     pub generics: Generics,\n     pub explicit_self: ExplicitSelf,\n-    pub id: NodeId,\n-    pub span: Span,\n-    pub vis: Visibility,\n }\n \n /// Represents a method declaration in a trait declaration, possibly including\n /// a default implementation A trait method is either required (meaning it\n /// doesn't have an implementation, just a signature) or provided (meaning it\n /// has a default implementation).\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum TraitItem {\n-    RequiredMethod(TypeMethod),\n-    ProvidedMethod(P<Method>),\n-    TypeTraitItem(P<AssociatedType>),\n-}\n-\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum ImplItem {\n-    MethodImplItem(P<Method>),\n-    TypeImplItem(P<Typedef>),\n+pub struct TraitItem {\n+    pub id: NodeId,\n+    pub ident: Ident,\n+    pub attrs: Vec<Attribute>,\n+    pub node: TraitItem_,\n+    pub span: Span,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub struct AssociatedType {\n-    pub attrs: Vec<Attribute>,\n-    pub ty_param: TyParam,\n+pub enum TraitItem_ {\n+    MethodTraitItem(MethodSig, Option<P<Block>>),\n+    TypeTraitItem(TyParamBounds, Option<P<Ty>>),\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub struct Typedef {\n+pub struct ImplItem {\n     pub id: NodeId,\n-    pub span: Span,\n     pub ident: Ident,\n     pub vis: Visibility,\n     pub attrs: Vec<Attribute>,\n-    pub typ: P<Ty>,\n+    pub node: ImplItem_,\n+    pub span: Span,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum ImplItem_ {\n+    MethodImplItem(MethodSig, P<Block>),\n+    TypeImplItem(P<Ty>),\n+    MacImplItem(Mac),\n }\n \n #[derive(Clone, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n@@ -1418,29 +1415,6 @@ pub enum ExplicitSelf_ {\n \n pub type ExplicitSelf = Spanned<ExplicitSelf_>;\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub struct Method {\n-    pub attrs: Vec<Attribute>,\n-    pub id: NodeId,\n-    pub span: Span,\n-    pub node: Method_,\n-}\n-\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum Method_ {\n-    /// Represents a method declaration\n-    MethDecl(Ident,\n-             Generics,\n-             Abi,\n-             ExplicitSelf,\n-             Unsafety,\n-             P<FnDecl>,\n-             P<Block>,\n-             Visibility),\n-    /// Represents a macro in method position\n-    MethMac(Mac),\n-}\n-\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Mod {\n     /// A span from the first token past `{` to the last token until `}`.\n@@ -1659,7 +1633,7 @@ pub enum Item_ {\n     ItemTrait(Unsafety,\n               Generics,\n               TyParamBounds,\n-              Vec<TraitItem>),\n+              Vec<P<TraitItem>>),\n \n     // Default trait implementations\n     // `impl Trait for ..`\n@@ -1669,7 +1643,7 @@ pub enum Item_ {\n              Generics,\n              Option<TraitRef>, // (optional) trait this impl implements\n              P<Ty>, // self\n-             Vec<ImplItem>),\n+             Vec<P<ImplItem>>),\n     /// A macro invocation (which includes macro definition)\n     ItemMac(Mac),\n }\n@@ -1726,8 +1700,8 @@ impl ForeignItem_ {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum InlinedItem {\n     IIItem(P<Item>),\n-    IITraitItem(DefId /* impl id */, TraitItem),\n-    IIImplItem(DefId /* impl id */, ImplItem),\n+    IITraitItem(DefId /* impl id */, P<TraitItem>),\n+    IIImplItem(DefId /* impl id */, P<ImplItem>),\n     IIForeign(P<ForeignItem>),\n }\n "}, {"sha": "16a339cdcb530b22e99d455cc76ab740f06ae4f8", "filename": "src/libsyntax/ast_map/blocks.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibsyntax%2Fast_map%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibsyntax%2Fast_map%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fblocks.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -28,7 +28,6 @@ use ast::{Block, FnDecl, NodeId};\n use ast;\n use ast_map::{Node};\n use ast_map;\n-use ast_util::PostExpansionMethod;\n use codemap::Span;\n use visit;\n \n@@ -65,7 +64,7 @@ impl MaybeFnLike for ast::Item {\n \n impl MaybeFnLike for ast::TraitItem {\n     fn is_fn_like(&self) -> bool {\n-        match *self { ast::ProvidedMethod(_) => true, _ => false, }\n+        match self.node { ast::MethodTraitItem(_, Some(_)) => true, _ => false, }\n     }\n }\n \n@@ -156,25 +155,25 @@ impl<'a> FnLikeNode<'a> {\n \n     pub fn body(self) -> &'a Block {\n         self.handle(|i: ItemFnParts<'a>|  &*i.body,\n-                    |m: &'a ast::Method|  m.pe_body(),\n+                    |_, _, _: &'a ast::MethodSig, body: &'a ast::Block, _|  body,\n                     |c: ClosureParts<'a>| c.body)\n     }\n \n     pub fn decl(self) -> &'a FnDecl {\n         self.handle(|i: ItemFnParts<'a>|  &*i.decl,\n-                    |m: &'a ast::Method|  m.pe_fn_decl(),\n+                    |_, _, sig: &'a ast::MethodSig, _, _|  &sig.decl,\n                     |c: ClosureParts<'a>| c.decl)\n     }\n \n     pub fn span(self) -> Span {\n         self.handle(|i: ItemFnParts|     i.span,\n-                    |m: &'a ast::Method| m.span,\n+                    |_, _, _: &'a ast::MethodSig, _, span| span,\n                     |c: ClosureParts|    c.span)\n     }\n \n     pub fn id(self) -> NodeId {\n         self.handle(|i: ItemFnParts|     i.id,\n-                    |m: &'a ast::Method| m.id,\n+                    |id, _, _: &'a ast::MethodSig, _, _| id,\n                     |c: ClosureParts|    c.id)\n     }\n \n@@ -185,15 +184,15 @@ impl<'a> FnLikeNode<'a> {\n         let closure = |_: ClosureParts| {\n             visit::FkFnBlock\n         };\n-        let method = |m: &'a ast::Method| {\n-            visit::FkMethod(m.pe_ident(), m.pe_generics(), m)\n+        let method = |_, ident, sig: &'a ast::MethodSig, _, _| {\n+            visit::FkMethod(ident, sig)\n         };\n         self.handle(item, method, closure)\n     }\n \n     fn handle<A, I, M, C>(self, item_fn: I, method: M, closure: C) -> A where\n         I: FnOnce(ItemFnParts<'a>) -> A,\n-        M: FnOnce(&'a ast::Method) -> A,\n+        M: FnOnce(NodeId, ast::Ident, &'a ast::MethodSig, &'a ast::Block, Span) -> A,\n         C: FnOnce(ClosureParts<'a>) -> A,\n     {\n         match self.node {\n@@ -205,14 +204,19 @@ impl<'a> FnLikeNode<'a> {\n                     }),\n                 _ => panic!(\"item FnLikeNode that is not fn-like\"),\n             },\n-            ast_map::NodeTraitItem(t) => match *t {\n-                ast::ProvidedMethod(ref m) => method(&**m),\n+            ast_map::NodeTraitItem(ti) => match ti.node {\n+                ast::MethodTraitItem(ref sig, Some(ref body)) => {\n+                    method(ti.id, ti.ident, sig, body, ti.span)\n+                }\n                 _ => panic!(\"trait method FnLikeNode that is not fn-like\"),\n             },\n             ast_map::NodeImplItem(ii) => {\n-                match *ii {\n-                    ast::MethodImplItem(ref m) => method(&**m),\n-                    ast::TypeImplItem(_) => {\n+                match ii.node {\n+                    ast::MethodImplItem(ref sig, ref body) => {\n+                        method(ii.id, ii.ident, sig, body, ii.span)\n+                    }\n+                    ast::TypeImplItem(_) |\n+                    ast::MacImplItem(_) => {\n                         panic!(\"impl method FnLikeNode that is not fn-like\")\n                     }\n                 }"}, {"sha": "48bb044cb1854cafba113fd3a9b56ff1c3aa3ec9", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 70, "deletions": 199, "changes": 269, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -19,7 +19,6 @@ use codemap::{DUMMY_SP, Span, Spanned};\n use fold::Folder;\n use parse::token;\n use print::pprust;\n-use ptr::P;\n use visit::{self, Visitor};\n \n use arena::TypedArena;\n@@ -375,35 +374,8 @@ impl<'ast> Map<'ast> {\n                 }\n             }\n             NodeForeignItem(i) => PathName(i.ident.name),\n-            NodeImplItem(ii) => {\n-                match *ii {\n-                    MethodImplItem(ref m) => {\n-                        match m.node {\n-                            MethDecl(ident, _, _, _, _, _, _, _) => {\n-                                PathName(ident.name)\n-                            }\n-                            MethMac(_) => {\n-                                panic!(\"no path elem for {:?}\", node)\n-                            }\n-                        }\n-                    }\n-                    TypeImplItem(ref t) => PathName(t.ident.name),\n-                }\n-            },\n-            NodeTraitItem(tm) => match *tm {\n-                RequiredMethod(ref m) => PathName(m.ident.name),\n-                ProvidedMethod(ref m) => {\n-                    match m.node {\n-                        MethDecl(ident, _, _, _, _, _, _, _) => {\n-                            PathName(ident.name)\n-                        }\n-                        MethMac(_) => panic!(\"no path elem for {:?}\", node),\n-                    }\n-                }\n-                TypeTraitItem(ref m) => {\n-                    PathName(m.ty_param.ident.name)\n-                }\n-            },\n+            NodeImplItem(ii) => PathName(ii.ident.name),\n+            NodeTraitItem(ti) => PathName(ti.ident.name),\n             NodeVariant(v) => PathName(v.node.name.name),\n             _ => panic!(\"no path elem for {:?}\", node)\n         }\n@@ -459,21 +431,12 @@ impl<'ast> Map<'ast> {\n \n     /// Given a node ID, get a list of of attributes associated with the AST\n     /// corresponding to the Node ID\n-    pub fn attrs(&self, id: NodeId) -> &[Attribute] {\n+    pub fn attrs(&self, id: NodeId) -> &'ast [Attribute] {\n         let attrs = match self.find(id) {\n             Some(NodeItem(i)) => Some(&i.attrs[..]),\n             Some(NodeForeignItem(fi)) => Some(&fi.attrs[..]),\n-            Some(NodeTraitItem(ref tm)) => match **tm {\n-                RequiredMethod(ref type_m) => Some(&type_m.attrs[..]),\n-                ProvidedMethod(ref m) => Some(&m.attrs[..]),\n-                TypeTraitItem(ref typ) => Some(&typ.attrs[..]),\n-            },\n-            Some(NodeImplItem(ref ii)) => {\n-                match **ii {\n-                    MethodImplItem(ref m) => Some(&m.attrs[..]),\n-                    TypeImplItem(ref t) => Some(&t.attrs[..]),\n-                }\n-            }\n+            Some(NodeTraitItem(ref ti)) => Some(&ti.attrs[..]),\n+            Some(NodeImplItem(ref ii)) => Some(&ii.attrs[..]),\n             Some(NodeVariant(ref v)) => Some(&v.node.attrs[..]),\n             // unit/tuple structs take the attributes straight from\n             // the struct definition.\n@@ -506,19 +469,8 @@ impl<'ast> Map<'ast> {\n         let sp = match self.find(id) {\n             Some(NodeItem(item)) => item.span,\n             Some(NodeForeignItem(foreign_item)) => foreign_item.span,\n-            Some(NodeTraitItem(trait_method)) => {\n-                match *trait_method {\n-                    RequiredMethod(ref type_method) => type_method.span,\n-                    ProvidedMethod(ref method) => method.span,\n-                    TypeTraitItem(ref typedef) => typedef.ty_param.span,\n-                }\n-            }\n-            Some(NodeImplItem(ref impl_item)) => {\n-                match **impl_item {\n-                    MethodImplItem(ref method) => method.span,\n-                    TypeImplItem(ref typedef) => typedef.span,\n-                }\n-            }\n+            Some(NodeTraitItem(trait_method)) => trait_method.span,\n+            Some(NodeImplItem(ref impl_item)) => impl_item.span,\n             Some(NodeVariant(variant)) => variant.span,\n             Some(NodeExpr(expr)) => expr.span,\n             Some(NodeStmt(stmt)) => stmt.span,\n@@ -651,31 +603,8 @@ impl<T:Named> Named for Spanned<T> { fn name(&self) -> Name { self.node.name() }\n impl Named for Item { fn name(&self) -> Name { self.ident.name } }\n impl Named for ForeignItem { fn name(&self) -> Name { self.ident.name } }\n impl Named for Variant_ { fn name(&self) -> Name { self.name.name } }\n-impl Named for TraitItem {\n-    fn name(&self) -> Name {\n-        match *self {\n-            RequiredMethod(ref tm) => tm.ident.name,\n-            ProvidedMethod(ref m) => m.name(),\n-            TypeTraitItem(ref at) => at.ty_param.ident.name,\n-        }\n-    }\n-}\n-impl Named for ImplItem {\n-    fn name(&self) -> Name {\n-        match *self {\n-            MethodImplItem(ref m) => m.name(),\n-            TypeImplItem(ref td) => td.ident.name,\n-        }\n-    }\n-}\n-impl Named for Method {\n-    fn name(&self) -> Name {\n-        match self.node {\n-            MethDecl(i, _, _, _, _, _, _, _) => i.name,\n-            MethMac(_) => panic!(\"encountered unexpanded method macro.\"),\n-        }\n-    }\n-}\n+impl Named for TraitItem { fn name(&self) -> Name { self.ident.name } }\n+impl Named for ImplItem { fn name(&self) -> Name { self.ident.name } }\n \n pub trait FoldOps {\n     fn new_id(&self, id: NodeId) -> NodeId {\n@@ -740,15 +669,8 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n         self.parent = i.id;\n         match i.node {\n             ItemImpl(_, _, _, _, _, ref impl_items) => {\n-                for impl_item in impl_items {\n-                    match *impl_item {\n-                        MethodImplItem(ref m) => {\n-                            self.insert(m.id, NodeImplItem(impl_item));\n-                        }\n-                        TypeImplItem(ref t) => {\n-                            self.insert(t.id, NodeImplItem(impl_item));\n-                        }\n-                    }\n+                for ii in impl_items {\n+                    self.insert(ii.id, NodeImplItem(ii));\n                 }\n             }\n             ItemEnum(ref enum_definition, _) => {\n@@ -777,18 +699,8 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n                     }\n                 }\n \n-                for tm in trait_items {\n-                    match *tm {\n-                        RequiredMethod(ref m) => {\n-                            self.insert(m.id, NodeTraitItem(tm));\n-                        }\n-                        ProvidedMethod(ref m) => {\n-                            self.insert(m.id, NodeTraitItem(tm));\n-                        }\n-                        TypeTraitItem(ref typ) => {\n-                            self.insert(typ.ty_param.id, NodeTraitItem(tm));\n-                        }\n-                    }\n+                for ti in trait_items {\n+                    self.insert(ti.id, NodeTraitItem(ti));\n                 }\n             }\n             _ => {}\n@@ -797,6 +709,20 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n         self.parent = parent;\n     }\n \n+    fn visit_trait_item(&mut self, ti: &'ast TraitItem) {\n+        let parent = self.parent;\n+        self.parent = ti.id;\n+        visit::walk_trait_item(self, ti);\n+        self.parent = parent;\n+    }\n+\n+    fn visit_impl_item(&mut self, ii: &'ast ImplItem) {\n+        let parent = self.parent;\n+        self.parent = ii.id;\n+        visit::walk_impl_item(self, ii);\n+        self.parent = parent;\n+    }\n+\n     fn visit_pat(&mut self, pat: &'ast Pat) {\n         self.insert(pat.id, match pat.node {\n             // Note: this is at least *potentially* a pattern...\n@@ -816,29 +742,10 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n         visit::walk_stmt(self, stmt);\n     }\n \n-    fn visit_ty_method(&mut self, m: &'ast TypeMethod) {\n-        let parent = self.parent;\n-        self.parent = m.id;\n-        self.visit_fn_decl(&*m.decl);\n-        visit::walk_ty_method(self, m);\n-        self.parent = parent;\n-    }\n-\n     fn visit_fn(&mut self, fk: visit::FnKind<'ast>, fd: &'ast FnDecl,\n-                b: &'ast Block, s: Span, id: NodeId) {\n-        match fk {\n-            visit::FkMethod(..) => {\n-                let parent = self.parent;\n-                self.parent = id;\n-                self.visit_fn_decl(fd);\n-                visit::walk_fn(self, fk, fd, b, s);\n-                self.parent = parent;\n-            }\n-            _ => {\n-                self.visit_fn_decl(fd);\n-                visit::walk_fn(self, fk, fd, b, s);\n-            }\n-        }\n+                b: &'ast Block, s: Span, _: NodeId) {\n+        self.visit_fn_decl(fd);\n+        visit::walk_fn(self, fk, fd, b, s);\n     }\n \n     fn visit_ty(&mut self, ty: &'ast Ty) {\n@@ -920,33 +827,14 @@ pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n     let mut fld = IdAndSpanUpdater { fold_ops: fold_ops };\n     let ii = match ii {\n         IIItem(i) => IIItem(fld.fold_item(i).expect_one(\"expected one item\")),\n-        IITraitItem(d, ti) => match ti {\n-            ProvidedMethod(m) => {\n-                IITraitItem(fld.fold_ops.new_def_id(d),\n-                            ProvidedMethod(fld.fold_method(m)\n-                                              .expect_one(\"expected one method\")))\n-            }\n-            RequiredMethod(ty_m) => {\n-                IITraitItem(fld.fold_ops.new_def_id(d),\n-                            RequiredMethod(fld.fold_type_method(ty_m)))\n-            }\n-            TypeTraitItem(at) => {\n-                IITraitItem(\n-                    fld.fold_ops.new_def_id(d),\n-                    TypeTraitItem(P(fld.fold_associated_type((*at).clone()))))\n-            }\n-        },\n-        IIImplItem(d, m) => match m {\n-            MethodImplItem(m) => {\n-                IIImplItem(fld.fold_ops.new_def_id(d),\n-                           MethodImplItem(fld.fold_method(m)\n-                                             .expect_one(\"expected one method\")))\n-            }\n-            TypeImplItem(t) => {\n-                IIImplItem(fld.fold_ops.new_def_id(d),\n-                           TypeImplItem(P(fld.fold_typedef((*t).clone()))))\n-            }\n-        },\n+        IITraitItem(d, ti) => {\n+            IITraitItem(fld.fold_ops.new_def_id(d),\n+                        fld.fold_trait_item(ti).expect_one(\"expected one trait item\"))\n+        }\n+        IIImplItem(d, ii) => {\n+            IIImplItem(fld.fold_ops.new_def_id(d),\n+                       fld.fold_impl_item(ii).expect_one(\"expected one impl item\"))\n+        }\n         IIForeign(i) => IIForeign(fld.fold_foreign_item(i))\n     };\n \n@@ -968,25 +856,14 @@ pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n     // add it to the table now. Likewise with foreign items.\n     match ii_parent.ii {\n         IIItem(_) => {}\n-        IITraitItem(_, ref trait_item) => {\n-            let trait_item_id = match *trait_item {\n-                ProvidedMethod(ref m) => m.id,\n-                RequiredMethod(ref m) => m.id,\n-                TypeTraitItem(ref ty) => ty.ty_param.id,\n-            };\n-\n-            collector.insert(trait_item_id, NodeTraitItem(trait_item));\n+        IITraitItem(_, ref ti) => {\n+            collector.insert(ti.id, NodeTraitItem(ti));\n         }\n-        IIImplItem(_, ref impl_item) => {\n-            let impl_item_id = match *impl_item {\n-                MethodImplItem(ref m) => m.id,\n-                TypeImplItem(ref ti) => ti.id,\n-            };\n-\n-            collector.insert(impl_item_id, NodeImplItem(impl_item));\n+        IIImplItem(_, ref ii) => {\n+            collector.insert(ii.id, NodeImplItem(ii));\n         }\n         IIForeign(ref i) => {\n-            collector.insert(i.id, NodeForeignItem(&**i));\n+            collector.insert(i.id, NodeForeignItem(i));\n         }\n     }\n     *map.map.borrow_mut() = collector.map;\n@@ -1002,8 +879,8 @@ impl<'a> NodePrinter for pprust::State<'a> {\n         match *node {\n             NodeItem(a)        => self.print_item(&*a),\n             NodeForeignItem(a) => self.print_foreign_item(&*a),\n-            NodeTraitItem(a)   => self.print_trait_method(&*a),\n-            NodeImplItem(a)    => self.print_impl_item(&*a),\n+            NodeTraitItem(a)   => self.print_trait_item(a),\n+            NodeImplItem(a)    => self.print_impl_item(a),\n             NodeVariant(a)     => self.print_variant(&*a),\n             NodeExpr(a)        => self.print_expr(&*a),\n             NodeStmt(a)        => self.print_stmt(&*a),\n@@ -1050,44 +927,38 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n             let path_str = map.path_to_str_with_ident(id, item.ident);\n             format!(\"foreign item {}{}\", path_str, id_str)\n         }\n-        Some(NodeImplItem(ref ii)) => {\n-            match **ii {\n-                MethodImplItem(ref m) => {\n-                    match m.node {\n-                        MethDecl(ident, _, _, _, _, _, _, _) =>\n-                            format!(\"method {} in {}{}\",\n-                                    token::get_ident(ident),\n-                                    map.path_to_string(id), id_str),\n-                        MethMac(ref mac) =>\n-                            format!(\"method macro {}{}\",\n-                                    pprust::mac_to_string(mac), id_str)\n-                    }\n-                }\n-                TypeImplItem(ref t) => {\n-                    format!(\"typedef {} in {}{}\",\n-                            token::get_ident(t.ident),\n-                            map.path_to_string(id),\n-                            id_str)\n-                }\n-            }\n-        }\n-        Some(NodeTraitItem(ref tm)) => {\n-            match **tm {\n-                RequiredMethod(_) | ProvidedMethod(_) => {\n-                    let m = ast_util::trait_item_to_ty_method(&**tm);\n+        Some(NodeImplItem(ii)) => {\n+            match ii.node {\n+                MethodImplItem(..) => {\n                     format!(\"method {} in {}{}\",\n-                            token::get_ident(m.ident),\n-                            map.path_to_string(id),\n-                            id_str)\n+                            token::get_ident(ii.ident),\n+                            map.path_to_string(id), id_str)\n                 }\n-                TypeTraitItem(ref t) => {\n-                    format!(\"type item {} in {}{}\",\n-                            token::get_ident(t.ty_param.ident),\n+                TypeImplItem(_) => {\n+                    format!(\"assoc type {} in {}{}\",\n+                            token::get_ident(ii.ident),\n                             map.path_to_string(id),\n                             id_str)\n                 }\n+                MacImplItem(ref mac) => {\n+                    format!(\"method macro {}{}\",\n+                            pprust::mac_to_string(mac), id_str)\n+                }\n             }\n         }\n+        Some(NodeTraitItem(ti)) => {\n+            let kind = match ti.node {\n+                MethodTraitItem(..) => \"trait method\",\n+                TypeTraitItem(..) => \"assoc type\",\n+//                 ConstTraitItem(..) => \"assoc constant\"\n+            };\n+\n+            format!(\"{} {} in {}{}\",\n+                    kind,\n+                    token::get_ident(ti.ident),\n+                    map.path_to_string(id),\n+                    id_str)\n+        }\n         Some(NodeVariant(ref variant)) => {\n             format!(\"variant {} in {}{}\",\n                     token::get_ident(variant.node.name),"}, {"sha": "cec824e79ff5a5afc3d55f7a3ccb9674f6e99394", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 12, "deletions": 112, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use abi::Abi;\n use ast::*;\n use ast;\n use ast_util;\n@@ -268,62 +267,6 @@ pub fn impl_pretty_name(trait_ref: &Option<TraitRef>, ty: Option<&Ty>) -> Ident\n     token::gensym_ident(&pretty[..])\n }\n \n-pub fn trait_method_to_ty_method(method: &Method) -> TypeMethod {\n-    match method.node {\n-        MethDecl(ident,\n-                 ref generics,\n-                 abi,\n-                 ref explicit_self,\n-                 unsafety,\n-                 ref decl,\n-                 _,\n-                 vis) => {\n-            TypeMethod {\n-                ident: ident,\n-                attrs: method.attrs.clone(),\n-                unsafety: unsafety,\n-                decl: (*decl).clone(),\n-                generics: generics.clone(),\n-                explicit_self: (*explicit_self).clone(),\n-                id: method.id,\n-                span: method.span,\n-                vis: vis,\n-                abi: abi,\n-            }\n-        },\n-        MethMac(_) => panic!(\"expected non-macro method declaration\")\n-    }\n-}\n-\n-/// extract a TypeMethod from a TraitItem. if the TraitItem is\n-/// a default, pull out the useful fields to make a TypeMethod\n-//\n-// NB: to be used only after expansion is complete, and macros are gone.\n-pub fn trait_item_to_ty_method(method: &TraitItem) -> TypeMethod {\n-    match *method {\n-        RequiredMethod(ref m) => (*m).clone(),\n-        ProvidedMethod(ref m) => trait_method_to_ty_method(&**m),\n-        TypeTraitItem(_) => {\n-            panic!(\"trait_method_to_ty_method(): expected method but found \\\n-                   typedef\")\n-        }\n-    }\n-}\n-\n-pub fn split_trait_methods(trait_methods: &[TraitItem])\n-                           -> (Vec<TypeMethod>, Vec<P<Method>> ) {\n-    let mut reqd = Vec::new();\n-    let mut provd = Vec::new();\n-    for trt_method in trait_methods {\n-        match *trt_method {\n-            RequiredMethod(ref tm) => reqd.push((*tm).clone()),\n-            ProvidedMethod(ref m) => provd.push((*m).clone()),\n-            TypeTraitItem(_) => {}\n-        }\n-    };\n-    (reqd, provd)\n-}\n-\n pub fn struct_field_visibility(field: ast::StructField) -> Visibility {\n     match field.node.kind {\n         ast::NamedField(_, v) | ast::UnnamedField(v) => v\n@@ -513,10 +456,12 @@ impl<'a, 'v, O: IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O> {\n         self.operation.visit_id(node_id);\n \n         match function_kind {\n-            visit::FkItemFn(_, generics, _, _) |\n-            visit::FkMethod(_, generics, _) => {\n+            visit::FkItemFn(_, generics, _, _) => {\n                 self.visit_generics_helper(generics)\n             }\n+            visit::FkMethod(_, sig) => {\n+                self.visit_generics_helper(&sig.generics)\n+            }\n             visit::FkFnBlock => {}\n         }\n \n@@ -552,13 +497,14 @@ impl<'a, 'v, O: IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O> {\n         visit::walk_struct_def(self, struct_def);\n     }\n \n-    fn visit_trait_item(&mut self, tm: &ast::TraitItem) {\n-        match *tm {\n-            ast::RequiredMethod(ref m) => self.operation.visit_id(m.id),\n-            ast::ProvidedMethod(ref m) => self.operation.visit_id(m.id),\n-            ast::TypeTraitItem(ref typ) => self.operation.visit_id(typ.ty_param.id),\n-        }\n-        visit::walk_trait_item(self, tm);\n+    fn visit_trait_item(&mut self, ti: &ast::TraitItem) {\n+        self.operation.visit_id(ti.id);\n+        visit::walk_trait_item(self, ti);\n+    }\n+\n+    fn visit_impl_item(&mut self, ii: &ast::ImplItem) {\n+        self.operation.visit_id(ii.id);\n+        visit::walk_impl_item(self, ii);\n     }\n \n     fn visit_lifetime_ref(&mut self, lifetime: &Lifetime) {\n@@ -701,52 +647,6 @@ pub fn lit_is_str(lit: &Lit) -> bool {\n     }\n }\n \n-/// Macro invocations are guaranteed not to occur after expansion is complete.\n-/// Extracting fields of a method requires a dynamic check to make sure that it's\n-/// not a macro invocation. This check is guaranteed to succeed, assuming\n-/// that the invocations are indeed gone.\n-pub trait PostExpansionMethod {\n-    fn pe_ident(&self) -> ast::Ident;\n-    fn pe_generics<'a>(&'a self) -> &'a ast::Generics;\n-    fn pe_abi(&self) -> Abi;\n-    fn pe_explicit_self<'a>(&'a self) -> &'a ast::ExplicitSelf;\n-    fn pe_unsafety(&self) -> ast::Unsafety;\n-    fn pe_fn_decl<'a>(&'a self) -> &'a ast::FnDecl;\n-    fn pe_body<'a>(&'a self) -> &'a ast::Block;\n-    fn pe_vis(&self) -> ast::Visibility;\n-}\n-\n-macro_rules! mf_method{\n-    ($meth_name:ident, $field_ty:ty, $field_pat:pat, $result:expr) => {\n-        fn $meth_name<'a>(&'a self) -> $field_ty {\n-            match self.node {\n-                $field_pat => $result,\n-                MethMac(_) => {\n-                    panic!(\"expected an AST without macro invocations\");\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-\n-impl PostExpansionMethod for Method {\n-    mf_method! { pe_ident,ast::Ident,MethDecl(ident,_,_,_,_,_,_,_),ident }\n-    mf_method! {\n-        pe_generics,&'a ast::Generics,\n-        MethDecl(_,ref generics,_,_,_,_,_,_),generics\n-    }\n-    mf_method! { pe_abi,Abi,MethDecl(_,_,abi,_,_,_,_,_),abi }\n-    mf_method! {\n-        pe_explicit_self,&'a ast::ExplicitSelf,\n-        MethDecl(_,_,_,ref explicit_self,_,_,_,_),explicit_self\n-    }\n-    mf_method! { pe_unsafety,ast::Unsafety,MethDecl(_,_,_,_,unsafety,_,_,_),unsafety }\n-    mf_method! { pe_fn_decl,&'a ast::FnDecl,MethDecl(_,_,_,_,_,ref decl,_,_),&**decl }\n-    mf_method! { pe_body,&'a ast::Block,MethDecl(_,_,_,_,_,_,ref body,_),&**body }\n-    mf_method! { pe_vis,ast::Visibility,MethDecl(_,_,_,_,_,_,_,vis),vis }\n-}\n-\n #[cfg(test)]\n mod test {\n     use ast::*;"}, {"sha": "489a7721d7ba770a117add88db41d25b25353fe8", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 2, "deletions": 21, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -118,13 +118,13 @@ fn fold_item_underscore<F>(cx: &mut Context<F>, item: ast::Item_) -> ast::Item_\n     let item = match item {\n         ast::ItemImpl(u, o, a, b, c, impl_items) => {\n             let impl_items = impl_items.into_iter()\n-                                       .filter(|ii| impl_item_in_cfg(cx, ii))\n+                                       .filter(|ii| (cx.in_cfg)(&ii.attrs))\n                                        .collect();\n             ast::ItemImpl(u, o, a, b, c, impl_items)\n         }\n         ast::ItemTrait(u, a, b, methods) => {\n             let methods = methods.into_iter()\n-                                 .filter(|m| trait_method_in_cfg(cx, m))\n+                                 .filter(|ti| (cx.in_cfg)(&ti.attrs))\n                                  .collect();\n             ast::ItemTrait(u, a, b, methods)\n         }\n@@ -246,25 +246,6 @@ fn foreign_item_in_cfg<F>(cx: &mut Context<F>, item: &ast::ForeignItem) -> bool\n     return (cx.in_cfg)(&item.attrs);\n }\n \n-fn trait_method_in_cfg<F>(cx: &mut Context<F>, meth: &ast::TraitItem) -> bool where\n-    F: FnMut(&[ast::Attribute]) -> bool\n-{\n-    match *meth {\n-        ast::RequiredMethod(ref meth) => (cx.in_cfg)(&meth.attrs),\n-        ast::ProvidedMethod(ref meth) => (cx.in_cfg)(&meth.attrs),\n-        ast::TypeTraitItem(ref typ) => (cx.in_cfg)(&typ.attrs),\n-    }\n-}\n-\n-fn impl_item_in_cfg<F>(cx: &mut Context<F>, impl_item: &ast::ImplItem) -> bool where\n-    F: FnMut(&[ast::Attribute]) -> bool\n-{\n-    match *impl_item {\n-        ast::MethodImplItem(ref meth) => (cx.in_cfg)(&meth.attrs),\n-        ast::TypeImplItem(ref typ) => (cx.in_cfg)(&typ.attrs),\n-    }\n-}\n-\n // Determine if an item should be translated in the current crate\n // configuration based on the item's attributes\n fn in_cfg(diagnostic: &SpanHandler, cfg: &[P<ast::MetaItem>], attrs: &[ast::Attribute]) -> bool {"}, {"sha": "35449bde0b2e086e870198f5874dc882838a8e23", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 20, "deletions": 43, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -77,51 +77,31 @@ impl<F> ItemModifier for F\n #[derive(Debug,Clone)]\n pub enum Annotatable {\n     Item(P<ast::Item>),\n-    TraitItem(ast::TraitItem),\n-    ImplItem(ast::ImplItem),\n+    TraitItem(P<ast::TraitItem>),\n+    ImplItem(P<ast::ImplItem>),\n }\n \n impl Annotatable {\n     pub fn attrs(&self) -> &[ast::Attribute] {\n         match *self {\n             Annotatable::Item(ref i) => &i.attrs,\n-            Annotatable::TraitItem(ref i) => match *i {\n-                ast::TraitItem::RequiredMethod(ref tm) => &tm.attrs,\n-                ast::TraitItem::ProvidedMethod(ref m) => &m.attrs,\n-                ast::TraitItem::TypeTraitItem(ref at) => &at.attrs,\n-            },\n-            Annotatable::ImplItem(ref i) => match *i {\n-                ast::ImplItem::MethodImplItem(ref m) => &m.attrs,\n-                ast::ImplItem::TypeImplItem(ref t) => &t.attrs,\n-            }\n+            Annotatable::TraitItem(ref ti) => &ti.attrs,\n+            Annotatable::ImplItem(ref ii) => &ii.attrs,\n         }\n     }\n \n     pub fn fold_attrs(self, attrs: Vec<ast::Attribute>) -> Annotatable {\n         match self {\n-            Annotatable::Item(i) => Annotatable::Item(P(ast::Item {\n+            Annotatable::Item(i) => Annotatable::Item(i.map(|i| ast::Item {\n                 attrs: attrs,\n-                ..(*i).clone()\n+                ..i\n+            })),\n+            Annotatable::TraitItem(i) => Annotatable::TraitItem(i.map(|ti| {\n+                ast::TraitItem { attrs: attrs, ..ti }\n+            })),\n+            Annotatable::ImplItem(i) => Annotatable::ImplItem(i.map(|ii| {\n+                ast::ImplItem { attrs: attrs, ..ii }\n             })),\n-            Annotatable::TraitItem(i) => match i {\n-                ast::TraitItem::RequiredMethod(tm) => Annotatable::TraitItem(\n-                    ast::TraitItem::RequiredMethod(\n-                        ast::TypeMethod { attrs: attrs, ..tm })),\n-                ast::TraitItem::ProvidedMethod(m) => Annotatable::TraitItem(\n-                    ast::TraitItem::ProvidedMethod(P(\n-                        ast::Method { attrs: attrs, ..(*m).clone() }))),\n-                ast::TraitItem::TypeTraitItem(at) => Annotatable::TraitItem(\n-                    ast::TraitItem::TypeTraitItem(P(\n-                        ast::AssociatedType { attrs: attrs, ..(*at).clone() }))),\n-            },\n-            Annotatable::ImplItem(i) => match i {\n-                ast::ImplItem::MethodImplItem(m) => Annotatable::ImplItem(\n-                    ast::ImplItem::MethodImplItem(P(\n-                        ast::Method { attrs: attrs, ..(*m).clone() }))),\n-                ast::ImplItem::TypeImplItem(t) => Annotatable::ImplItem(\n-                    ast::ImplItem::TypeImplItem(P(\n-                        ast::Typedef { attrs: attrs, ..(*t).clone() }))),\n-            }\n         }\n     }\n \n@@ -132,14 +112,14 @@ impl Annotatable {\n         }\n     }\n \n-    pub fn expect_trait_item(self) -> ast::TraitItem {\n+    pub fn expect_trait_item(self) -> P<ast::TraitItem> {\n         match self {\n             Annotatable::TraitItem(i) => i,\n             _ => panic!(\"expected Item\")\n         }\n     }\n \n-    pub fn expect_impl_item(self) -> ast::ImplItem {\n+    pub fn expect_impl_item(self) -> P<ast::ImplItem> {\n         match self {\n             Annotatable::ImplItem(i) => i,\n             _ => panic!(\"expected Item\")\n@@ -248,8 +228,8 @@ pub trait MacResult {\n         None\n     }\n \n-    /// Create zero or more methods.\n-    fn make_methods(self: Box<Self>) -> Option<SmallVector<P<ast::Method>>> {\n+    /// Create zero or more impl items.\n+    fn make_impl_items(self: Box<Self>) -> Option<SmallVector<P<ast::ImplItem>>> {\n         None\n     }\n \n@@ -295,7 +275,7 @@ make_MacEager! {\n     expr: P<ast::Expr>,\n     pat: P<ast::Pat>,\n     items: SmallVector<P<ast::Item>>,\n-    methods: SmallVector<P<ast::Method>>,\n+    impl_items: SmallVector<P<ast::ImplItem>>,\n     stmt: P<ast::Stmt>,\n }\n \n@@ -308,8 +288,8 @@ impl MacResult for MacEager {\n         self.items\n     }\n \n-    fn make_methods(self: Box<Self>) -> Option<SmallVector<P<ast::Method>>> {\n-        self.methods\n+    fn make_impl_items(self: Box<Self>) -> Option<SmallVector<P<ast::ImplItem>>> {\n+        self.impl_items\n     }\n \n     fn make_stmt(self: Box<Self>) -> Option<P<ast::Stmt>> {\n@@ -397,7 +377,7 @@ impl MacResult for DummyResult {\n             Some(SmallVector::zero())\n         }\n     }\n-    fn make_methods(self: Box<DummyResult>) -> Option<SmallVector<P<ast::Method>>> {\n+    fn make_impl_items(self: Box<DummyResult>) -> Option<SmallVector<P<ast::ImplItem>>> {\n         if self.expr_only {\n             None\n         } else {\n@@ -505,9 +485,6 @@ fn initial_syntax_expander_table<'feat>(ecfg: &expand::ExpansionConfig<'feat>)\n         syntax_expanders.insert(intern(\"quote_ty\"),\n                            builtin_normal_expander(\n                                 ext::quote::expand_quote_ty));\n-        syntax_expanders.insert(intern(\"quote_method\"),\n-                           builtin_normal_expander(\n-                                ext::quote::expand_quote_method));\n         syntax_expanders.insert(intern(\"quote_item\"),\n                            builtin_normal_expander(\n                                 ext::quote::expand_quote_item));"}, {"sha": "58b6d96607df777454cb9b841e60fddc4c77848e", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 18, "deletions": 24, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -386,22 +386,22 @@ impl<'a> TraitDef<'a> {\n                            cx: &mut ExtCtxt,\n                            type_ident: Ident,\n                            generics: &Generics,\n-                           methods: Vec<P<ast::Method>>) -> P<ast::Item> {\n+                           methods: Vec<P<ast::ImplItem>>) -> P<ast::Item> {\n         let trait_path = self.path.to_path(cx, self.span, type_ident, generics);\n \n-        // Transform associated types from `deriving::ty::Ty` into `ast::Typedef`\n+        // Transform associated types from `deriving::ty::Ty` into `ast::ImplItem`\n         let associated_types = self.associated_types.iter().map(|&(ident, ref type_def)| {\n-            P(ast::Typedef {\n+            P(ast::ImplItem {\n                 id: ast::DUMMY_NODE_ID,\n                 span: self.span,\n                 ident: ident,\n                 vis: ast::Inherited,\n                 attrs: Vec::new(),\n-                typ: type_def.to_ty(cx,\n+                node: ast::TypeImplItem(type_def.to_ty(cx,\n                     self.span,\n                     type_ident,\n                     generics\n-                ),\n+                )),\n             })\n         });\n \n@@ -510,14 +510,7 @@ impl<'a> TraitDef<'a> {\n                           trait_generics,\n                           opt_trait_ref,\n                           self_type,\n-                          methods.into_iter()\n-                                 .map(|method| {\n-                                     ast::MethodImplItem(method)\n-                                 }).chain(\n-                                     associated_types.map(|type_| {\n-                                         ast::TypeImplItem(type_)\n-                                     })\n-                                 ).collect()))\n+                          methods.into_iter().chain(associated_types).collect()))\n     }\n \n     fn expand_struct_def(&self,\n@@ -702,7 +695,7 @@ impl<'a> MethodDef<'a> {\n                      abi: Abi,\n                      explicit_self: ast::ExplicitSelf,\n                      arg_types: Vec<(Ident, P<ast::Ty>)> ,\n-                     body: P<Expr>) -> P<ast::Method> {\n+                     body: P<Expr>) -> P<ast::ImplItem> {\n         // create the generics that aren't for Self\n         let fn_generics = self.generics.to_generics(cx, trait_.span, type_ident, generics);\n \n@@ -725,18 +718,19 @@ impl<'a> MethodDef<'a> {\n         let body_block = cx.block_expr(body);\n \n         // Create the method.\n-        P(ast::Method {\n-            attrs: self.attributes.clone(),\n+        P(ast::ImplItem {\n             id: ast::DUMMY_NODE_ID,\n+            attrs: self.attributes.clone(),\n             span: trait_.span,\n-            node: ast::MethDecl(method_ident,\n-                                fn_generics,\n-                                abi,\n-                                explicit_self,\n-                                ast::Unsafety::Normal,\n-                                fn_decl,\n-                                body_block,\n-                                ast::Inherited)\n+            vis: ast::Inherited,\n+            ident: method_ident,\n+            node: ast::MethodImplItem(ast::MethodSig {\n+                generics: fn_generics,\n+                abi: abi,\n+                explicit_self: explicit_self,\n+                unsafety: ast::Unsafety::Normal,\n+                decl: fn_decl\n+            }, body_block)\n         })\n     }\n "}, {"sha": "ee2cf9017bbf34e38e47d917ef30a03c709e0db3", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 78, "deletions": 90, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -1174,51 +1174,33 @@ fn expand_annotatable(a: Annotatable,\n                 noop_fold_item(it, fld).into_iter().map(|i| Annotatable::Item(i)).collect()\n             }\n         },\n-        Annotatable::TraitItem(it) => match it {\n-            ast::TraitItem::ProvidedMethod(m) => {\n-                expand_method(m, fld).into_iter().map(|m|\n-                    Annotatable::TraitItem(ast::TraitItem::ProvidedMethod(m))).collect()\n-            }\n-            ast::TraitItem::RequiredMethod(m) => {\n-                SmallVector::one(Annotatable::TraitItem(\n-                    ast::TraitItem::RequiredMethod(fld.fold_type_method(m))))\n-            }\n-            ast::TraitItem::TypeTraitItem(t) => {\n-                SmallVector::one(Annotatable::TraitItem(\n-                    ast::TraitItem::TypeTraitItem(P(fld.fold_associated_type((*t).clone())))))\n-            }\n-        },\n-        Annotatable::ImplItem(it) => match it {\n-            ast::ImplItem::MethodImplItem(m) => {\n-                expand_method(m, fld).into_iter().map(|m|\n-                    Annotatable::ImplItem(ast::ImplItem::MethodImplItem(m))).collect()\n-            }\n-            ast::ImplItem::TypeImplItem(t) => {\n-                SmallVector::one(Annotatable::ImplItem(\n-                    ast::ImplItem::TypeImplItem(P(fld.fold_typedef((*t).clone())))))\n-            }\n+\n+        Annotatable::TraitItem(it) => match it.node {\n+            ast::MethodTraitItem(_, Some(_)) => SmallVector::one(it.map(|ti| ast::TraitItem {\n+                id: ti.id,\n+                ident: ti.ident,\n+                attrs: ti.attrs,\n+                node: match ti.node  {\n+                    ast::MethodTraitItem(sig, Some(body)) => {\n+                        let (sig, body) = expand_and_rename_method(sig, body, fld);\n+                        ast::MethodTraitItem(sig, Some(body))\n+                    }\n+                    _ => unreachable!()\n+                },\n+                span: fld.new_span(ti.span)\n+            })),\n+            _ => fold::noop_fold_trait_item(it, fld)\n+        }.into_iter().map(Annotatable::TraitItem).collect(),\n+\n+        Annotatable::ImplItem(ii) => {\n+            expand_impl_item(ii, fld).into_iter().map(Annotatable::ImplItem).collect()\n         }\n     };\n \n     new_items.push_all(decorator_items.into_iter().map(|i| Annotatable::Item(i)).collect());\n     new_items\n }\n \n-fn expand_trait_item(i: ast::TraitItem,\n-                     fld: &mut MacroExpander)\n-                     -> SmallVector<ast::TraitItem> {\n-    expand_annotatable(Annotatable::TraitItem(i), fld)\n-        .into_iter().map(|i| i.expect_trait_item()).collect()\n-\n-}\n-\n-fn expand_impl_item(i: ast::ImplItem,\n-                    fld: &mut MacroExpander)\n-                    -> SmallVector<ast::ImplItem> {\n-    expand_annotatable(Annotatable::ImplItem(i), fld)\n-        .into_iter().map(|i| i.expect_impl_item()).collect()\n-}\n-\n // partition the attributes into ItemModifiers and others\n fn modifiers(attrs: &Vec<ast::Attribute>,\n              fld: &MacroExpander)\n@@ -1292,62 +1274,56 @@ fn expand_item_multi_modifier(mut it: Annotatable,\n     expand_item_multi_modifier(it, fld)\n }\n \n-// expand a method\n-fn expand_method(m: P<ast::Method>, fld: &mut MacroExpander) -> SmallVector<P<ast::Method>> {\n-    m.and_then(|m| match m.node {\n-        ast::MethDecl(ident,\n-                      generics,\n-                      abi,\n-                      explicit_self,\n-                      fn_style,\n-                      decl,\n-                      body,\n-                      vis) => {\n-            let id = fld.new_id(m.id);\n-            let (rewritten_fn_decl, rewritten_body)\n-                = expand_and_rename_fn_decl_and_block(decl, body, fld);\n-            SmallVector::one(P(ast::Method {\n-                    attrs: fold::fold_attrs(m.attrs, fld),\n-                    id: id,\n-                    span: fld.new_span(m.span),\n-                    node: ast::MethDecl(fld.fold_ident(ident),\n-                                        noop_fold_generics(generics, fld),\n-                                        abi,\n-                                        fld.fold_explicit_self(explicit_self),\n-                                        fn_style,\n-                                        rewritten_fn_decl,\n-                                        rewritten_body,\n-                                        vis)\n-                }))\n-        },\n-        ast::MethMac(mac) => {\n-            let maybe_new_methods =\n-                expand_mac_invoc(mac, m.span,\n-                                 |r| r.make_methods(),\n-                                 |meths, mark| meths.move_map(|m| mark_method(m, mark)),\n+fn expand_impl_item(ii: P<ast::ImplItem>, fld: &mut MacroExpander)\n+                 -> SmallVector<P<ast::ImplItem>> {\n+    match ii.node {\n+        ast::MethodImplItem(..) => SmallVector::one(ii.map(|ii| ast::ImplItem {\n+            id: ii.id,\n+            ident: ii.ident,\n+            attrs: ii.attrs,\n+            vis: ii.vis,\n+            node: match ii.node  {\n+                ast::MethodImplItem(sig, body) => {\n+                    let (sig, body) = expand_and_rename_method(sig, body, fld);\n+                    ast::MethodImplItem(sig, body)\n+                }\n+                _ => unreachable!()\n+            },\n+            span: fld.new_span(ii.span)\n+        })),\n+        ast::MacImplItem(_) => {\n+            let (span, mac) = ii.and_then(|ii| match ii.node {\n+                ast::MacImplItem(mac) => (ii.span, mac),\n+                _ => unreachable!()\n+            });\n+            let maybe_new_items =\n+                expand_mac_invoc(mac, span,\n+                                 |r| r.make_impl_items(),\n+                                 |meths, mark| meths.move_map(|m| mark_impl_item(m, mark)),\n                                  fld);\n \n-            match maybe_new_methods {\n-                Some(methods) => {\n+            match maybe_new_items {\n+                Some(impl_items) => {\n                     // expand again if necessary\n-                    let new_methods = methods.into_iter()\n-                                             .flat_map(|m| fld.fold_method(m).into_iter())\n-                                             .collect();\n+                    let new_items = impl_items.into_iter().flat_map(|ii| {\n+                        expand_impl_item(ii, fld).into_iter()\n+                    }).collect();\n                     fld.cx.bt_pop();\n-                    new_methods\n+                    new_items\n                 }\n                 None => SmallVector::zero()\n             }\n         }\n-    })\n+        _ => fold::noop_fold_impl_item(ii, fld)\n+    }\n }\n \n /// Given a fn_decl and a block and a MacroExpander, expand the fn_decl, then use the\n /// PatIdents in its arguments to perform renaming in the FnDecl and\n /// the block, returning both the new FnDecl and the new Block.\n fn expand_and_rename_fn_decl_and_block(fn_decl: P<ast::FnDecl>, block: P<ast::Block>,\n                                        fld: &mut MacroExpander)\n-    -> (P<ast::FnDecl>, P<ast::Block>) {\n+                                       -> (P<ast::FnDecl>, P<ast::Block>) {\n     let expanded_decl = fld.fold_fn_decl(fn_decl);\n     let idents = fn_decl_arg_bindings(&*expanded_decl);\n     let renames =\n@@ -1361,6 +1337,20 @@ fn expand_and_rename_fn_decl_and_block(fn_decl: P<ast::FnDecl>, block: P<ast::Bl\n     (rewritten_fn_decl,rewritten_body)\n }\n \n+fn expand_and_rename_method(sig: ast::MethodSig, body: P<ast::Block>,\n+                            fld: &mut MacroExpander)\n+                            -> (ast::MethodSig, P<ast::Block>) {\n+    let (rewritten_fn_decl, rewritten_body)\n+        = expand_and_rename_fn_decl_and_block(sig.decl, body, fld);\n+    (ast::MethodSig {\n+        generics: fld.fold_generics(sig.generics),\n+        abi: sig.abi,\n+        explicit_self: fld.fold_explicit_self(sig.explicit_self),\n+        unsafety: sig.unsafety,\n+        decl: rewritten_fn_decl\n+    }, rewritten_body)\n+}\n+\n /// A tree-folder that performs macro expansion\n pub struct MacroExpander<'a, 'b:'a> {\n     pub cx: &'a mut ExtCtxt<'b>,\n@@ -1410,16 +1400,14 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n         expand_arm(arm, self)\n     }\n \n-    fn fold_trait_item(&mut self, i: ast::TraitItem) -> SmallVector<ast::TraitItem> {\n-        expand_trait_item(i, self)\n-    }\n-\n-    fn fold_impl_item(&mut self, i: ast::ImplItem) -> SmallVector<ast::ImplItem> {\n-        expand_impl_item(i, self)\n+    fn fold_trait_item(&mut self, i: P<ast::TraitItem>) -> SmallVector<P<ast::TraitItem>> {\n+        expand_annotatable(Annotatable::TraitItem(i), self)\n+            .into_iter().map(|i| i.expect_trait_item()).collect()\n     }\n \n-    fn fold_method(&mut self, method: P<ast::Method>) -> SmallVector<P<ast::Method>> {\n-        expand_method(method, self)\n+    fn fold_impl_item(&mut self, i: P<ast::ImplItem>) -> SmallVector<P<ast::ImplItem>> {\n+        expand_annotatable(Annotatable::ImplItem(i), self)\n+            .into_iter().map(|i| i.expect_impl_item()).collect()\n     }\n \n     fn fold_ty(&mut self, t: P<ast::Ty>) -> P<ast::Ty> {\n@@ -1565,9 +1553,9 @@ fn mark_item(expr: P<ast::Item>, m: Mrk) -> P<ast::Item> {\n }\n \n // apply a given mark to the given item. Used following the expansion of a macro.\n-fn mark_method(expr: P<ast::Method>, m: Mrk) -> P<ast::Method> {\n-    Marker{mark:m}.fold_method(expr)\n-        .expect_one(\"marking an item didn't return exactly one method\")\n+fn mark_impl_item(ii: P<ast::ImplItem>, m: Mrk) -> P<ast::ImplItem> {\n+    Marker{mark:m}.fold_impl_item(ii)\n+        .expect_one(\"marking an impl item didn't return exactly one impl item\")\n }\n \n /// Check that there are no macro invocations left in the AST:"}, {"sha": "48c045ee4f98f7b86568a8056e0ee374a99d4c41", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -176,7 +176,6 @@ pub mod rt {\n     impl_to_source! { ast::Arg, arg_to_string }\n     impl_to_source! { Generics, generics_to_string }\n     impl_to_source! { P<ast::Item>, item_to_string }\n-    impl_to_source! { P<ast::Method>, method_to_string }\n     impl_to_source! { P<ast::Stmt>, stmt_to_string }\n     impl_to_source! { P<ast::Expr>, expr_to_string }\n     impl_to_source! { P<ast::Pat>, pat_to_string }\n@@ -311,7 +310,6 @@ pub mod rt {\n     impl_to_tokens! { P<ast::Item> }\n     impl_to_tokens! { P<ast::Pat> }\n     impl_to_tokens! { ast::Arm }\n-    impl_to_tokens! { P<ast::Method> }\n     impl_to_tokens_lifetime! { &'a [P<ast::Item>] }\n     impl_to_tokens! { ast::Ty }\n     impl_to_tokens_lifetime! { &'a [ast::Ty] }\n@@ -446,15 +444,6 @@ pub fn expand_quote_ty(cx: &mut ExtCtxt,\n     base::MacEager::expr(expanded)\n }\n \n-pub fn expand_quote_method(cx: &mut ExtCtxt,\n-                           sp: Span,\n-                           tts: &[ast::TokenTree])\n-                           -> Box<base::MacResult+'static> {\n-    let expanded = expand_parse_call(cx, sp, \"parse_method_with_outer_attributes\",\n-                                     vec!(), tts);\n-    base::MacEager::expr(expanded)\n-}\n-\n pub fn expand_quote_stmt(cx: &mut ExtCtxt,\n                          sp: Span,\n                          tts: &[ast::TokenTree])"}, {"sha": "7575d4b5ecdbe68d40fac8bc3920d8513dcf1faa", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -71,7 +71,7 @@ impl<'a> MacResult for ParserAnyMacro<'a> {\n         loop {\n             let mut parser = self.parser.borrow_mut();\n             // so... do outer attributes attached to the macro invocation\n-            // just disappear? This question applies to make_methods, as\n+            // just disappear? This question applies to make_impl_items, as\n             // well.\n             match parser.parse_item_with_outer_attributes() {\n                 Some(item) => ret.push(item),\n@@ -82,15 +82,14 @@ impl<'a> MacResult for ParserAnyMacro<'a> {\n         Some(ret)\n     }\n \n-    fn make_methods(self: Box<ParserAnyMacro<'a>>) -> Option<SmallVector<P<ast::Method>>> {\n+    fn make_impl_items(self: Box<ParserAnyMacro<'a>>)\n+                       -> Option<SmallVector<P<ast::ImplItem>>> {\n         let mut ret = SmallVector::zero();\n         loop {\n             let mut parser = self.parser.borrow_mut();\n             match parser.token {\n                 token::Eof => break,\n-                _ => {\n-                    ret.push(parser.parse_method_with_outer_attributes());\n-                }\n+                _ => ret.push(parser.parse_impl_item_with_outer_attributes())\n             }\n         }\n         self.ensure_complete_parse(false);"}, {"sha": "105a61d085725e8c004f1f8200d3c5d50b877167", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 44, "deletions": 134, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -98,26 +98,18 @@ pub trait Folder : Sized {\n         noop_fold_item_underscore(i, self)\n     }\n \n-    fn fold_trait_item(&mut self, i: TraitItem) -> SmallVector<TraitItem> {\n+    fn fold_trait_item(&mut self, i: P<TraitItem>) -> SmallVector<P<TraitItem>> {\n         noop_fold_trait_item(i, self)\n     }\n \n-    fn fold_impl_item(&mut self, i: ImplItem) -> SmallVector<ImplItem> {\n+    fn fold_impl_item(&mut self, i: P<ImplItem>) -> SmallVector<P<ImplItem>> {\n         noop_fold_impl_item(i, self)\n     }\n \n     fn fold_fn_decl(&mut self, d: P<FnDecl>) -> P<FnDecl> {\n         noop_fold_fn_decl(d, self)\n     }\n \n-    fn fold_type_method(&mut self, m: TypeMethod) -> TypeMethod {\n-        noop_fold_type_method(m, self)\n-    }\n-\n-    fn fold_method(&mut self, m: P<Method>) -> SmallVector<P<Method>> {\n-        noop_fold_method(m, self)\n-    }\n-\n     fn fold_block(&mut self, b: P<Block>) -> P<Block> {\n         noop_fold_block(b, self)\n     }\n@@ -315,15 +307,6 @@ pub trait Folder : Sized {\n         noop_fold_where_predicate(where_predicate, self)\n     }\n \n-    fn fold_typedef(&mut self, typedef: Typedef) -> Typedef {\n-        noop_fold_typedef(typedef, self)\n-    }\n-\n-    fn fold_associated_type(&mut self, associated_type: AssociatedType)\n-                            -> AssociatedType {\n-        noop_fold_associated_type(associated_type, self)\n-    }\n-\n     fn new_id(&mut self, i: NodeId) -> NodeId {\n         i\n     }\n@@ -829,41 +812,6 @@ pub fn noop_fold_where_predicate<T: Folder>(\n     }\n }\n \n-pub fn noop_fold_typedef<T>(t: Typedef, folder: &mut T)\n-                            -> Typedef\n-                            where T: Folder {\n-    let new_id = folder.new_id(t.id);\n-    let new_span = folder.new_span(t.span);\n-    let new_attrs = t.attrs.iter().flat_map(|attr| {\n-        folder.fold_attribute((*attr).clone()).into_iter()\n-    }).collect();\n-    let new_ident = folder.fold_ident(t.ident);\n-    let new_type = folder.fold_ty(t.typ);\n-    ast::Typedef {\n-        ident: new_ident,\n-        typ: new_type,\n-        id: new_id,\n-        span: new_span,\n-        vis: t.vis,\n-        attrs: new_attrs,\n-    }\n-}\n-\n-pub fn noop_fold_associated_type<T>(at: AssociatedType, folder: &mut T)\n-                                    -> AssociatedType\n-                                    where T: Folder\n-{\n-    let new_attrs = at.attrs\n-                      .iter()\n-                      .flat_map(|attr| folder.fold_attribute((*attr).clone()).into_iter())\n-                      .collect();\n-    let new_param = folder.fold_ty_param(at.ty_param);\n-    ast::AssociatedType {\n-        attrs: new_attrs,\n-        ty_param: new_param,\n-    }\n-}\n-\n pub fn noop_fold_struct_def<T: Folder>(struct_def: P<StructDef>, fld: &mut T) -> P<StructDef> {\n     struct_def.map(|StructDef { fields, ctor_id }| StructDef {\n         fields: fields.move_map(|f| fld.fold_struct_field(f)),\n@@ -1018,61 +966,43 @@ pub fn noop_fold_item_underscore<T: Folder>(i: Item_, folder: &mut T) -> Item_ {\n     }\n }\n \n-pub fn noop_fold_trait_item<T: Folder>(i: TraitItem, folder: &mut T) -> SmallVector<TraitItem> {\n-    match i {\n-        RequiredMethod(m) => {\n-                SmallVector::one(RequiredMethod(\n-                        folder.fold_type_method(m)))\n-        }\n-        ProvidedMethod(method) => {\n-            folder.fold_method(method).into_iter()\n-                .map(|m| ProvidedMethod(m)).collect()\n-        }\n-        TypeTraitItem(at) => {\n-            SmallVector::one(TypeTraitItem(P(\n-                        folder.fold_associated_type(\n-                            (*at).clone()))))\n-        }\n-    }\n-}\n-\n-pub fn noop_fold_impl_item<T: Folder>(i: ImplItem, folder: &mut T) -> SmallVector<ImplItem> {\n-    match i {\n-        MethodImplItem(ref x) => {\n-            folder.fold_method((*x).clone()).into_iter().map(|m| MethodImplItem(m)).collect()\n-        }\n-        TypeImplItem(ref t) => {\n-            SmallVector::one(TypeImplItem(\n-                    P(folder.fold_typedef((**t).clone()))))\n-        }\n-    }\n+pub fn noop_fold_trait_item<T: Folder>(i: P<TraitItem>, folder: &mut T)\n+                                       -> SmallVector<P<TraitItem>> {\n+    SmallVector::one(i.map(|TraitItem {id, ident, attrs, node, span}| TraitItem {\n+        id: folder.new_id(id),\n+        ident: folder.fold_ident(ident),\n+        attrs: fold_attrs(attrs, folder),\n+        node: match node {\n+            MethodTraitItem(sig, body) => {\n+                MethodTraitItem(noop_fold_method_sig(sig, folder),\n+                                body.map(|x| folder.fold_block(x)))\n+            }\n+            TypeTraitItem(bounds, default) => {\n+                TypeTraitItem(folder.fold_bounds(bounds),\n+                              default.map(|x| folder.fold_ty(x)))\n+            }\n+        },\n+        span: folder.new_span(span)\n+    }))\n }\n \n-pub fn noop_fold_type_method<T: Folder>(m: TypeMethod, fld: &mut T) -> TypeMethod {\n-    let TypeMethod {\n-        id,\n-        ident,\n-        attrs,\n-        unsafety,\n-        abi,\n-        decl,\n-        generics,\n-        explicit_self,\n-        vis,\n-        span\n-    } = m;\n-    TypeMethod {\n-        id: fld.new_id(id),\n-        ident: fld.fold_ident(ident),\n-        attrs: fold_attrs(attrs, fld),\n-        unsafety: unsafety,\n-        abi: abi,\n-        decl: fld.fold_fn_decl(decl),\n-        generics: fld.fold_generics(generics),\n-        explicit_self: fld.fold_explicit_self(explicit_self),\n+pub fn noop_fold_impl_item<T: Folder>(i: P<ImplItem>, folder: &mut T)\n+                                      -> SmallVector<P<ImplItem>> {\n+    SmallVector::one(i.map(|ImplItem {id, ident, attrs, node, vis, span}| ImplItem {\n+        id: folder.new_id(id),\n+        ident: folder.fold_ident(ident),\n+        attrs: fold_attrs(attrs, folder),\n         vis: vis,\n-        span: fld.new_span(span)\n-    }\n+        node: match node  {\n+            MethodImplItem(sig, body) => {\n+                MethodImplItem(noop_fold_method_sig(sig, folder),\n+                               folder.fold_block(body))\n+            }\n+            TypeImplItem(ty) => TypeImplItem(folder.fold_ty(ty)),\n+            MacImplItem(mac) => MacImplItem(folder.fold_mac(mac))\n+        },\n+        span: folder.new_span(span)\n+    }))\n }\n \n pub fn noop_fold_mod<T: Folder>(Mod {inner, items}: Mod, folder: &mut T) -> Mod {\n@@ -1171,34 +1101,14 @@ pub fn noop_fold_foreign_item<T: Folder>(ni: P<ForeignItem>, folder: &mut T) ->\n     })\n }\n \n-// Default fold over a method.\n-// Invariant: produces exactly one method.\n-pub fn noop_fold_method<T: Folder>(m: P<Method>, folder: &mut T) -> SmallVector<P<Method>> {\n-    SmallVector::one(m.map(|Method {id, attrs, node, span}| Method {\n-        id: folder.new_id(id),\n-        attrs: fold_attrs(attrs, folder),\n-        node: match node {\n-            MethDecl(ident,\n-                     generics,\n-                     abi,\n-                     explicit_self,\n-                     unsafety,\n-                     decl,\n-                     body,\n-                     vis) => {\n-                MethDecl(folder.fold_ident(ident),\n-                         folder.fold_generics(generics),\n-                         abi,\n-                         folder.fold_explicit_self(explicit_self),\n-                         unsafety,\n-                         folder.fold_fn_decl(decl),\n-                         folder.fold_block(body),\n-                         vis)\n-            },\n-            MethMac(mac) => MethMac(folder.fold_mac(mac)),\n-        },\n-        span: folder.new_span(span)\n-    }))\n+pub fn noop_fold_method_sig<T: Folder>(sig: MethodSig, folder: &mut T) -> MethodSig {\n+    MethodSig {\n+        generics: folder.fold_generics(sig.generics),\n+        abi: sig.abi,\n+        explicit_self: folder.fold_explicit_self(sig.explicit_self),\n+        unsafety: sig.unsafety,\n+        decl: folder.fold_fn_decl(sig.decl)\n+    }\n }\n \n pub fn noop_fold_pat<T: Folder>(p: P<Pat>, folder: &mut T) -> P<Pat> {"}, {"sha": "39c43ff1e75b48a3ba894ff7bb4e8a50b50a9cdc", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 73, "deletions": 82, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -11,9 +11,9 @@\n pub use self::PathParsingMode::*;\n \n use abi;\n-use ast::{AssociatedType, BareFnTy};\n+use ast::{BareFnTy};\n use ast::{RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n-use ast::{ProvidedMethod, Public, Unsafety};\n+use ast::{Public, Unsafety};\n use ast::{Mod, BiAdd, Arg, Arm, Attribute, BindByRef, BindByValue};\n use ast::{BiBitAnd, BiBitOr, BiBitXor, BiRem, BiLt, BiGt, Block};\n use ast::{BlockCheckMode, CaptureByRef, CaptureByValue, CaptureClause};\n@@ -38,24 +38,22 @@ use ast::{LitBool, LitChar, LitByte, LitBinary};\n use ast::{LitStr, LitInt, Local, LocalLet};\n use ast::{MacStmtWithBraces, MacStmtWithSemicolon, MacStmtWithoutBraces};\n use ast::{MutImmutable, MutMutable, Mac_, MacInvocTT, MatchSource};\n-use ast::{Method, MutTy, BiMul, Mutability};\n+use ast::{MutTy, BiMul, Mutability};\n use ast::{MethodImplItem, NamedField, UnNeg, NoReturn, NodeId, UnNot};\n use ast::{Pat, PatEnum, PatIdent, PatLit, PatRange, PatRegion, PatStruct};\n use ast::{PatTup, PatBox, PatWild, PatWildMulti, PatWildSingle};\n-use ast::{PolyTraitRef};\n-use ast::{QSelf, RequiredMethod};\n+use ast::{PolyTraitRef, QSelf};\n use ast::{Return, BiShl, BiShr, Stmt, StmtDecl};\n use ast::{StmtExpr, StmtSemi, StmtMac, StructDef, StructField};\n use ast::{StructVariantKind, BiSub, StrStyle};\n use ast::{SelfExplicit, SelfRegion, SelfStatic, SelfValue};\n use ast::{Delimited, SequenceRepetition, TokenTree, TraitItem, TraitRef};\n use ast::{TtDelimited, TtSequence, TtToken};\n use ast::{TupleVariantKind, Ty, Ty_, TypeBinding};\n-use ast::{TyFixedLengthVec, TyBareFn};\n-use ast::{TyTypeof, TyInfer, TypeMethod};\n+use ast::{TyFixedLengthVec, TyBareFn, TyTypeof, TyInfer};\n use ast::{TyParam, TyParamBound, TyParen, TyPath, TyPolyTraitRef, TyPtr};\n use ast::{TyRptr, TyTup, TyU32, TyVec, UnUniq};\n-use ast::{TypeImplItem, TypeTraitItem, Typedef,};\n+use ast::{TypeImplItem, TypeTraitItem};\n use ast::{UnnamedField, UnsafeBlock};\n use ast::{ViewPath, ViewPathGlob, ViewPathList, ViewPathSimple};\n use ast::{Visibility, WhereClause};\n@@ -1244,52 +1242,53 @@ impl<'a> Parser<'a> {\n \n     /// Parses `type Foo;` in a trait declaration only. The `type` keyword has\n     /// already been parsed.\n-    fn parse_associated_type(&mut self, attrs: Vec<Attribute>)\n-                             -> AssociatedType\n-    {\n-        let ty_param = self.parse_ty_param();\n+    fn parse_assoc_ty_in_trait(&mut self, attrs: Vec<Attribute>)\n+                               -> P<TraitItem> {\n+        let TyParam {id, ident, bounds, default, span} = self.parse_ty_param();\n         self.expect(&token::Semi);\n-        AssociatedType {\n+        P(TraitItem {\n+            id: id,\n+            ident: ident,\n             attrs: attrs,\n-            ty_param: ty_param,\n-        }\n+            node: TypeTraitItem(bounds, default),\n+            span: span,\n+        })\n     }\n \n     /// Parses `type Foo = TYPE;` in an implementation declaration only. The\n     /// `type` keyword has already been parsed.\n-    fn parse_typedef(&mut self, attrs: Vec<Attribute>, vis: Visibility)\n-                     -> Typedef {\n+    fn parse_assoc_ty_in_impl(&mut self, attrs: Vec<Attribute>, vis: Visibility)\n+                              -> P<ImplItem> {\n         let lo = self.span.lo;\n         let ident = self.parse_ident();\n         self.expect(&token::Eq);\n         let typ = self.parse_ty_sum();\n         let hi = self.span.hi;\n         self.expect(&token::Semi);\n-        Typedef {\n+        P(ImplItem {\n             id: ast::DUMMY_NODE_ID,\n             span: mk_sp(lo, hi),\n             ident: ident,\n             vis: vis,\n             attrs: attrs,\n-            typ: typ,\n-        }\n+            node: TypeImplItem(typ),\n+        })\n     }\n \n     /// Parse the items in a trait declaration\n-    pub fn parse_trait_items(&mut self) -> Vec<TraitItem> {\n+    pub fn parse_trait_items(&mut self) -> Vec<P<TraitItem>> {\n         self.parse_unspanned_seq(\n             &token::OpenDelim(token::Brace),\n             &token::CloseDelim(token::Brace),\n             seq_sep_none(),\n             |p| {\n-            let attrs = p.parse_outer_attributes();\n+            let mut attrs = p.parse_outer_attributes();\n \n             if p.eat_keyword(keywords::Type) {\n-                TypeTraitItem(P(p.parse_associated_type(attrs)))\n+                p.parse_assoc_ty_in_trait(attrs)\n             } else {\n                 let lo = p.span.lo;\n \n-                let vis = p.parse_visibility();\n                 let style = p.parse_unsafety();\n                 let abi = if p.eat_keyword(keywords::Extern) {\n                     p.parse_opt_abi().unwrap_or(abi::C)\n@@ -1309,52 +1308,43 @@ impl<'a> Parser<'a> {\n                 });\n \n                 p.parse_where_clause(&mut generics);\n+                let sig = ast::MethodSig {\n+                    unsafety: style,\n+                    decl: d,\n+                    generics: generics,\n+                    abi: abi,\n+                    explicit_self: explicit_self,\n+                };\n \n                 let hi = p.last_span.hi;\n-                match p.token {\n+                let body = match p.token {\n                   token::Semi => {\n                     p.bump();\n                     debug!(\"parse_trait_methods(): parsing required method\");\n-                    RequiredMethod(TypeMethod {\n-                        ident: ident,\n-                        attrs: attrs,\n-                        unsafety: style,\n-                        decl: d,\n-                        generics: generics,\n-                        abi: abi,\n-                        explicit_self: explicit_self,\n-                        id: ast::DUMMY_NODE_ID,\n-                        span: mk_sp(lo, hi),\n-                        vis: vis,\n-                    })\n+                    None\n                   }\n                   token::OpenDelim(token::Brace) => {\n                     debug!(\"parse_trait_methods(): parsing provided method\");\n                     let (inner_attrs, body) =\n                         p.parse_inner_attrs_and_block();\n-                    let mut attrs = attrs;\n                     attrs.push_all(&inner_attrs[..]);\n-                    ProvidedMethod(P(ast::Method {\n-                        attrs: attrs,\n-                        id: ast::DUMMY_NODE_ID,\n-                        span: mk_sp(lo, hi),\n-                        node: ast::MethDecl(ident,\n-                                            generics,\n-                                            abi,\n-                                            explicit_self,\n-                                            style,\n-                                            d,\n-                                            body,\n-                                            vis)\n-                    }))\n+                    Some(body)\n                   }\n \n                   _ => {\n                       let token_str = p.this_token_to_string();\n                       p.fatal(&format!(\"expected `;` or `{{`, found `{}`\",\n                                        token_str)[..])\n                   }\n-                }\n+                };\n+\n+                P(TraitItem {\n+                    id: ast::DUMMY_NODE_ID,\n+                    ident: ident,\n+                    attrs: attrs,\n+                    node: ast::MethodTraitItem(sig, body),\n+                    span: mk_sp(lo, hi),\n+                })\n             }\n         })\n     }\n@@ -4635,11 +4625,15 @@ impl<'a> Parser<'a> {\n         (ident, ItemFn(decl, unsafety, abi, generics, body), Some(inner_attrs))\n     }\n \n-    /// Parse a method in a trait impl\n-    pub fn parse_method_with_outer_attributes(&mut self) -> P<Method> {\n+    /// Parse an impl item.\n+    pub fn parse_impl_item_with_outer_attributes(&mut self) -> P<ImplItem> {\n         let attrs = self.parse_outer_attributes();\n-        let visa = self.parse_visibility();\n-        self.parse_method(attrs, visa)\n+        let vis = self.parse_visibility();\n+        if self.eat_keyword(keywords::Type) {\n+            self.parse_assoc_ty_in_impl(attrs, vis)\n+        } else {\n+            self.parse_method(attrs, vis)\n+        }\n     }\n \n     fn complain_if_pub_macro(&mut self, visa: Visibility, span: Span) {\n@@ -4656,20 +4650,20 @@ impl<'a> Parser<'a> {\n     /// Parse a method in a trait impl, starting with `attrs` attributes.\n     pub fn parse_method(&mut self,\n                         attrs: Vec<Attribute>,\n-                        visa: Visibility)\n-                        -> P<Method> {\n+                        vis: Visibility)\n+                        -> P<ImplItem> {\n         let lo = self.span.lo;\n \n         // code copied from parse_macro_use_or_failure... abstraction!\n-        let (method_, hi, new_attrs) = {\n+        let (method_, hi, new_attrs, ident) = {\n             if !self.token.is_any_keyword()\n                 && self.look_ahead(1, |t| *t == token::Not)\n                 && (self.look_ahead(2, |t| *t == token::OpenDelim(token::Paren))\n                     || self.look_ahead(2, |t| *t == token::OpenDelim(token::Brace))) {\n                 // method macro.\n \n                 let last_span = self.last_span;\n-                self.complain_if_pub_macro(visa, last_span);\n+                self.complain_if_pub_macro(vis, last_span);\n \n                 let pth = self.parse_path(NoTypesAllowed);\n                 self.expect(&token::Not);\n@@ -4686,7 +4680,8 @@ impl<'a> Parser<'a> {\n                 if delim != token::Brace {\n                     self.expect(&token::Semi)\n                 }\n-                (ast::MethMac(m), self.span.hi, attrs)\n+                (ast::MacImplItem(m), self.span.hi, attrs,\n+                 token::special_idents::invalid)\n             } else {\n                 let unsafety = self.parse_unsafety();\n                 let abi = if self.eat_keyword(keywords::Extern) {\n@@ -4705,22 +4700,22 @@ impl<'a> Parser<'a> {\n                 let body_span = body.span;\n                 let mut new_attrs = attrs;\n                 new_attrs.push_all(&inner_attrs[..]);\n-                (ast::MethDecl(ident,\n-                               generics,\n-                               abi,\n-                               explicit_self,\n-                               unsafety,\n-                               decl,\n-                               body,\n-                               visa),\n-                 body_span.hi, new_attrs)\n+                (MethodImplItem(ast::MethodSig {\n+                    generics: generics,\n+                    abi: abi,\n+                    explicit_self: explicit_self,\n+                    unsafety: unsafety,\n+                    decl: decl\n+                 }, body), body_span.hi, new_attrs, ident)\n             }\n         };\n-        P(ast::Method {\n-            attrs: new_attrs,\n+        P(ImplItem {\n             id: ast::DUMMY_NODE_ID,\n-            span: mk_sp(lo, hi),\n+            attrs: new_attrs,\n+            vis: vis,\n+            ident: ident,\n             node: method_,\n+            span: mk_sp(lo, hi),\n         })\n     }\n \n@@ -4752,7 +4747,7 @@ impl<'a> Parser<'a> {\n         (ident, ItemTrait(unsafety, tps, bounds, meths), None)\n     }\n \n-    fn parse_impl_items(&mut self) -> (Vec<ImplItem>, Vec<Attribute>) {\n+    fn parse_impl_items(&mut self) -> (Vec<P<ImplItem>>, Vec<Attribute>) {\n         let mut impl_items = Vec::new();\n         self.expect(&token::OpenDelim(token::Brace));\n         let (inner_attrs, mut method_attrs) =\n@@ -4764,15 +4759,11 @@ impl<'a> Parser<'a> {\n             }\n \n             let vis = self.parse_visibility();\n-            if self.eat_keyword(keywords::Type) {\n-                impl_items.push(TypeImplItem(P(self.parse_typedef(\n-                            method_attrs,\n-                            vis))))\n+            impl_items.push(if self.eat_keyword(keywords::Type) {\n+                self.parse_assoc_ty_in_impl(method_attrs, vis)\n             } else {\n-                impl_items.push(MethodImplItem(self.parse_method(\n-                            method_attrs,\n-                            vis)));\n-            }\n+                self.parse_method(method_attrs, vis)\n+            });\n             method_attrs = vec![];\n         }\n         (impl_items, inner_attrs)"}, {"sha": "07303ba51ff7075bfaf6c732fd5b82689f53bc63", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 91, "deletions": 118, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -12,8 +12,7 @@ pub use self::AnnNode::*;\n \n use abi;\n use ast;\n-use ast::{MethodImplItem, RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n-use ast::{RequiredMethod, ProvidedMethod, TypeImplItem, TypeTraitItem};\n+use ast::{RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n use ast_util;\n use attr;\n use owned_slice::OwnedSlice;\n@@ -360,14 +359,6 @@ pub fn generics_to_string(generics: &ast::Generics) -> String {\n     $to_string(|s| s.print_generics(generics))\n }\n \n-pub fn ty_method_to_string(p: &ast::TypeMethod) -> String {\n-    $to_string(|s| s.print_ty_method(p))\n-}\n-\n-pub fn method_to_string(p: &ast::Method) -> String {\n-    $to_string(|s| s.print_method(p))\n-}\n-\n pub fn fn_block_to_string(p: &ast::FnDecl) -> String {\n     $to_string(|s| s.print_fn_block_args(p))\n }\n@@ -384,8 +375,9 @@ pub fn fun_to_string(decl: &ast::FnDecl, unsafety: ast::Unsafety, name: ast::Ide\n                   opt_explicit_self: Option<&ast::ExplicitSelf_>,\n                   generics: &ast::Generics) -> String {\n     $to_string(|s| {\n-        try!(s.print_fn(decl, Some(unsafety), abi::Rust,\n-                        name, generics, opt_explicit_self, ast::Inherited));\n+        try!(s.head(\"\"));\n+        try!(s.print_fn(decl, unsafety, abi::Rust, Some(name),\n+                        generics, opt_explicit_self, ast::Inherited));\n         try!(s.end()); // Close the head box\n         s.end() // Close the outer box\n     })\n@@ -768,8 +760,10 @@ impl<'a> State<'a> {\n         try!(self.print_outer_attributes(&item.attrs));\n         match item.node {\n             ast::ForeignItemFn(ref decl, ref generics) => {\n-                try!(self.print_fn(&**decl, None, abi::Rust, item.ident, generics,\n-                                   None, item.vis));\n+                try!(self.head(\"\"));\n+                try!(self.print_fn(&**decl, ast::Unsafety::Normal,\n+                                   abi::Rust, Some(item.ident),\n+                                   generics, None, item.vis));\n                 try!(self.end()); // end head-ibox\n                 try!(word(&mut self.s, \";\"));\n                 self.end() // end the outer fn box\n@@ -790,23 +784,24 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    fn print_associated_type(&mut self, typedef: &ast::AssociatedType)\n-                             -> io::Result<()>\n-    {\n-        try!(self.print_outer_attributes(&typedef.attrs));\n+    fn print_associated_type(&mut self,\n+                             ident: ast::Ident,\n+                             bounds: Option<&ast::TyParamBounds>,\n+                             ty: Option<&ast::Ty>)\n+                             -> io::Result<()> {\n         try!(self.word_space(\"type\"));\n-        try!(self.print_ty_param(&typedef.ty_param));\n+        try!(self.print_ident(ident));\n+        if let Some(bounds) = bounds {\n+            try!(self.print_bounds(\":\", bounds));\n+        }\n+        if let Some(ty) = ty {\n+            try!(space(&mut self.s));\n+            try!(self.word_space(\"=\"));\n+            try!(self.print_type(ty));\n+        }\n         word(&mut self.s, \";\")\n     }\n \n-    fn print_typedef(&mut self, typedef: &ast::Typedef) -> io::Result<()> {\n-        try!(self.word_space(\"type\"));\n-        try!(self.print_ident(typedef.ident));\n-        try!(space(&mut self.s));\n-        try!(self.word_space(\"=\"));\n-        try!(self.print_type(&*typedef.typ));\n-        word(&mut self.s, \";\")\n-    }\n \n     /// Pretty-print an item\n     pub fn print_item(&mut self, item: &ast::Item) -> io::Result<()> {\n@@ -869,11 +864,12 @@ impl<'a> State<'a> {\n                 try!(self.end()); // end the outer cbox\n             }\n             ast::ItemFn(ref decl, unsafety, abi, ref typarams, ref body) => {\n+                try!(self.head(\"\"));\n                 try!(self.print_fn(\n-                    &**decl,\n-                    Some(unsafety),\n+                    decl,\n+                    unsafety,\n                     abi,\n-                    item.ident,\n+                    Some(item.ident),\n                     typarams,\n                     None,\n                     item.vis\n@@ -977,18 +973,11 @@ impl<'a> State<'a> {\n                 try!(self.bopen());\n                 try!(self.print_inner_attributes(&item.attrs));\n                 for impl_item in impl_items {\n-                    match *impl_item {\n-                        ast::MethodImplItem(ref meth) => {\n-                            try!(self.print_method(&**meth));\n-                        }\n-                        ast::TypeImplItem(ref typ) => {\n-                            try!(self.print_typedef(&**typ));\n-                        }\n-                    }\n+                    try!(self.print_impl_item(impl_item));\n                 }\n                 try!(self.bclose(item.span));\n             }\n-            ast::ItemTrait(unsafety, ref generics, ref bounds, ref methods) => {\n+            ast::ItemTrait(unsafety, ref generics, ref bounds, ref trait_items) => {\n                 try!(self.head(\"\"));\n                 try!(self.print_visibility(item.vis));\n                 try!(self.print_unsafety(unsafety));\n@@ -1009,8 +998,8 @@ impl<'a> State<'a> {\n                 try!(self.print_where_clause(generics));\n                 try!(word(&mut self.s, \" \"));\n                 try!(self.bopen());\n-                for meth in methods {\n-                    try!(self.print_trait_method(meth));\n+                for trait_item in trait_items {\n+                    try!(self.print_trait_item(trait_item));\n                 }\n                 try!(self.bclose(item.span));\n             }\n@@ -1242,60 +1231,61 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_ty_method(&mut self, m: &ast::TypeMethod) -> io::Result<()> {\n-        try!(self.hardbreak_if_not_bol());\n-        try!(self.maybe_print_comment(m.span.lo));\n-        try!(self.print_outer_attributes(&m.attrs));\n-        try!(self.print_ty_fn(m.abi,\n-                              m.unsafety,\n-                              &*m.decl,\n-                              Some(m.ident),\n-                              &m.generics,\n-                              Some(&m.explicit_self.node)));\n-        word(&mut self.s, \";\")\n+    pub fn print_method_sig(&mut self,\n+                            ident: ast::Ident,\n+                            m: &ast::MethodSig,\n+                            vis: ast::Visibility)\n+                            -> io::Result<()> {\n+        self.print_fn(&m.decl,\n+                      m.unsafety,\n+                      m.abi,\n+                      Some(ident),\n+                      &m.generics,\n+                      Some(&m.explicit_self.node),\n+                      vis)\n     }\n \n-    pub fn print_trait_method(&mut self,\n-                              m: &ast::TraitItem) -> io::Result<()> {\n-        match *m {\n-            RequiredMethod(ref ty_m) => self.print_ty_method(ty_m),\n-            ProvidedMethod(ref m) => self.print_method(&**m),\n-            TypeTraitItem(ref t) => self.print_associated_type(&**t),\n+    pub fn print_trait_item(&mut self, ti: &ast::TraitItem)\n+                            -> io::Result<()> {\n+        try!(self.hardbreak_if_not_bol());\n+        try!(self.maybe_print_comment(ti.span.lo));\n+        try!(self.print_outer_attributes(&ti.attrs));\n+        match ti.node {\n+            ast::MethodTraitItem(ref sig, ref body) => {\n+                if body.is_some() {\n+                    try!(self.head(\"\"));\n+                }\n+                try!(self.print_method_sig(ti.ident, sig, ast::Inherited));\n+                if let Some(ref body) = *body {\n+                    try!(self.nbsp());\n+                    self.print_block_with_attrs(body, &ti.attrs)\n+                } else {\n+                    word(&mut self.s, \";\")\n+                }\n+            }\n+            ast::TypeTraitItem(ref bounds, ref default) => {\n+                self.print_associated_type(ti.ident, Some(bounds),\n+                                           default.as_ref().map(|ty| &**ty))\n+            }\n         }\n     }\n \n     pub fn print_impl_item(&mut self, ii: &ast::ImplItem) -> io::Result<()> {\n-        match *ii {\n-            MethodImplItem(ref m) => self.print_method(&**m),\n-            TypeImplItem(ref td) => self.print_typedef(&**td),\n-        }\n-    }\n-\n-    pub fn print_method(&mut self, meth: &ast::Method) -> io::Result<()> {\n         try!(self.hardbreak_if_not_bol());\n-        try!(self.maybe_print_comment(meth.span.lo));\n-        try!(self.print_outer_attributes(&meth.attrs));\n-        match meth.node {\n-            ast::MethDecl(ident,\n-                          ref generics,\n-                          abi,\n-                          ref explicit_self,\n-                          unsafety,\n-                          ref decl,\n-                          ref body,\n-                          vis) => {\n-                try!(self.print_fn(&**decl,\n-                                   Some(unsafety),\n-                                   abi,\n-                                   ident,\n-                                   generics,\n-                                   Some(&explicit_self.node),\n-                                   vis));\n-                try!(word(&mut self.s, \" \"));\n-                self.print_block_with_attrs(&**body, &meth.attrs)\n-            },\n-            ast::MethMac(codemap::Spanned { node: ast::MacInvocTT(ref pth, ref tts, _),\n-                                            ..}) => {\n+        try!(self.maybe_print_comment(ii.span.lo));\n+        try!(self.print_outer_attributes(&ii.attrs));\n+        match ii.node {\n+            ast::MethodImplItem(ref sig, ref body) => {\n+                try!(self.head(\"\"));\n+                try!(self.print_method_sig(ii.ident, sig, ii.vis));\n+                try!(self.nbsp());\n+                self.print_block_with_attrs(body, &ii.attrs)\n+            }\n+            ast::TypeImplItem(ref ty) => {\n+                self.print_associated_type(ii.ident, None, Some(ty))\n+            }\n+            ast::MacImplItem(codemap::Spanned { node: ast::MacInvocTT(ref pth, ref tts, _),\n+                                                ..}) => {\n                 // code copied from ItemMac:\n                 try!(self.print_path(pth, false, 0));\n                 try!(word(&mut self.s, \"! \"));\n@@ -2326,16 +2316,18 @@ impl<'a> State<'a> {\n \n     pub fn print_fn(&mut self,\n                     decl: &ast::FnDecl,\n-                    unsafety: Option<ast::Unsafety>,\n+                    unsafety: ast::Unsafety,\n                     abi: abi::Abi,\n-                    name: ast::Ident,\n+                    name: Option<ast::Ident>,\n                     generics: &ast::Generics,\n                     opt_explicit_self: Option<&ast::ExplicitSelf_>,\n                     vis: ast::Visibility) -> io::Result<()> {\n-        try!(self.head(\"\"));\n         try!(self.print_fn_header_info(unsafety, abi, vis));\n-        try!(self.nbsp());\n-        try!(self.print_ident(name));\n+\n+        if let Some(name) = name {\n+            try!(self.nbsp());\n+            try!(self.print_ident(name));\n+        }\n         try!(self.print_generics(generics));\n         try!(self.print_fn_args_and_ret(decl, opt_explicit_self));\n         self.print_where_clause(generics)\n@@ -2702,25 +2694,14 @@ impl<'a> State<'a> {\n                        abi: abi::Abi,\n                        unsafety: ast::Unsafety,\n                        decl: &ast::FnDecl,\n-                       id: Option<ast::Ident>,\n+                       name: Option<ast::Ident>,\n                        generics: &ast::Generics,\n                        opt_explicit_self: Option<&ast::ExplicitSelf_>)\n                        -> io::Result<()> {\n         try!(self.ibox(indent_unit));\n-        try!(self.print_fn_header_info(Some(unsafety), abi, ast::Inherited));\n-\n-        match id {\n-            Some(id) => {\n-                try!(word(&mut self.s, \" \"));\n-                try!(self.print_ident(id));\n-            }\n-            _ => ()\n-        }\n-\n-        try!(self.print_generics(generics));\n-        try!(zerobreak(&mut self.s));\n-        try!(self.print_fn_args_and_ret(decl, opt_explicit_self));\n-        try!(self.print_where_clause(generics));\n+        try!(self.print_fn(decl, unsafety, abi, name,\n+                           generics, opt_explicit_self,\n+                           ast::Inherited));\n         self.end()\n     }\n \n@@ -2942,14 +2923,6 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_opt_unsafety(&mut self,\n-                            opt_unsafety: Option<ast::Unsafety>) -> io::Result<()> {\n-        match opt_unsafety {\n-            Some(unsafety) => self.print_unsafety(unsafety),\n-            None => Ok(())\n-        }\n-    }\n-\n     pub fn print_opt_abi_and_extern_if_nondefault(&mut self,\n                                                   opt_abi: Option<abi::Abi>)\n         -> io::Result<()> {\n@@ -2975,11 +2948,11 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_fn_header_info(&mut self,\n-                                opt_unsafety: Option<ast::Unsafety>,\n+                                unsafety: ast::Unsafety,\n                                 abi: abi::Abi,\n                                 vis: ast::Visibility) -> io::Result<()> {\n         try!(word(&mut self.s, &visibility_qualified(vis, \"\")));\n-        try!(self.print_opt_unsafety(opt_unsafety));\n+        try!(self.print_unsafety(unsafety));\n \n         if abi != abi::Rust {\n             try!(self.word_nbsp(\"extern\"));"}, {"sha": "638ddd3ea2e5b5523d7160c9e29dc60f4dd46ce6", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 45, "deletions": 76, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -38,7 +38,7 @@ pub enum FnKind<'a> {\n     FkItemFn(Ident, &'a Generics, Unsafety, Abi),\n \n     /// fn foo(&self)\n-    FkMethod(Ident, &'a Generics, &'a Method),\n+    FkMethod(Ident, &'a MethodSig),\n \n     /// |x, y| ...\n     /// proc(x, y) ...\n@@ -77,8 +77,8 @@ pub trait Visitor<'v> : Sized {\n     fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl, b: &'v Block, s: Span, _: NodeId) {\n         walk_fn(self, fk, fd, b, s)\n     }\n-    fn visit_ty_method(&mut self, t: &'v TypeMethod) { walk_ty_method(self, t) }\n-    fn visit_trait_item(&mut self, t: &'v TraitItem) { walk_trait_item(self, t) }\n+    fn visit_trait_item(&mut self, ti: &'v TraitItem) { walk_trait_item(self, ti) }\n+    fn visit_impl_item(&mut self, ii: &'v ImplItem) { walk_impl_item(self, ii) }\n     fn visit_trait_ref(&mut self, t: &'v TraitRef) { walk_trait_ref(self, t) }\n     fn visit_ty_param_bound(&mut self, bounds: &'v TyParamBound) {\n         walk_ty_param_bound(self, bounds)\n@@ -143,13 +143,7 @@ pub fn walk_inlined_item<'v,V>(visitor: &mut V, item: &'v InlinedItem)\n         IIItem(ref i) => visitor.visit_item(&**i),\n         IIForeign(ref i) => visitor.visit_foreign_item(&**i),\n         IITraitItem(_, ref ti) => visitor.visit_trait_item(ti),\n-        IIImplItem(_, MethodImplItem(ref m)) => {\n-            walk_method_helper(visitor, &**m)\n-        }\n-        IIImplItem(_, TypeImplItem(ref typedef)) => {\n-            visitor.visit_ident(typedef.span, typedef.ident);\n-            visitor.visit_ty(&*typedef.typ);\n-        }\n+        IIImplItem(_, ref ii) => visitor.visit_impl_item(ii),\n     }\n }\n \n@@ -202,8 +196,6 @@ pub fn walk_explicit_self<'v, V: Visitor<'v>>(visitor: &mut V,\n     }\n }\n \n-/// Like with walk_method_helper this doesn't correspond to a method\n-/// in Visitor, and so it gets a _helper suffix.\n pub fn walk_poly_trait_ref<'v, V>(visitor: &mut V,\n                                   trait_ref: &'v PolyTraitRef,\n                                   _modifier: &'v TraitBoundModifier)\n@@ -213,8 +205,6 @@ pub fn walk_poly_trait_ref<'v, V>(visitor: &mut V,\n     visitor.visit_trait_ref(&trait_ref.trait_ref);\n }\n \n-/// Like with walk_method_helper this doesn't correspond to a method\n-/// in Visitor, and so it gets a _helper suffix.\n pub fn walk_trait_ref<'v,V>(visitor: &mut V,\n                                    trait_ref: &'v TraitRef)\n     where V: Visitor<'v>\n@@ -294,15 +284,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n             }\n             visitor.visit_ty(&**typ);\n             for impl_item in impl_items {\n-                match *impl_item {\n-                    MethodImplItem(ref method) => {\n-                        walk_method_helper(visitor, &**method)\n-                    }\n-                    TypeImplItem(ref typedef) => {\n-                        visitor.visit_ident(typedef.span, typedef.ident);\n-                        visitor.visit_ty(&*typedef.typ);\n-                    }\n-                }\n+                visitor.visit_impl_item(impl_item);\n             }\n         }\n         ItemStruct(ref struct_definition, ref generics) => {\n@@ -561,15 +543,11 @@ pub fn walk_ty_param_bound<'v, V: Visitor<'v>>(visitor: &mut V,\n     }\n }\n \n-pub fn walk_ty_param<'v, V: Visitor<'v>>(visitor: &mut V, param: &'v TyParam) {\n-    visitor.visit_ident(param.span, param.ident);\n-    walk_ty_param_bounds_helper(visitor, &param.bounds);\n-    walk_ty_opt(visitor, &param.default);\n-}\n-\n pub fn walk_generics<'v, V: Visitor<'v>>(visitor: &mut V, generics: &'v Generics) {\n-    for type_parameter in &*generics.ty_params {\n-        walk_ty_param(visitor, type_parameter);\n+    for param in &*generics.ty_params {\n+        visitor.visit_ident(param.span, param.ident);\n+        walk_ty_param_bounds_helper(visitor, &param.bounds);\n+        walk_ty_opt(visitor, &param.default);\n     }\n     walk_lifetime_decls_helper(visitor, &generics.lifetimes);\n     for predicate in &generics.where_clause.predicates {\n@@ -614,28 +592,6 @@ pub fn walk_fn_decl<'v, V: Visitor<'v>>(visitor: &mut V, function_declaration: &\n     walk_fn_ret_ty(visitor, &function_declaration.output)\n }\n \n-// Note: there is no visit_method() method in the visitor, instead override\n-// visit_fn() and check for FkMethod().  I named this visit_method_helper()\n-// because it is not a default impl of any method, though I doubt that really\n-// clarifies anything. - Niko\n-pub fn walk_method_helper<'v, V: Visitor<'v>>(visitor: &mut V, method: &'v Method) {\n-    match method.node {\n-        MethDecl(ident, ref generics, _, _, _, ref decl, ref body, _) => {\n-            visitor.visit_ident(method.span, ident);\n-            visitor.visit_fn(FkMethod(ident, generics, method),\n-                             &**decl,\n-                             &**body,\n-                             method.span,\n-                             method.id);\n-            for attr in &method.attrs {\n-                visitor.visit_attribute(attr);\n-            }\n-\n-        },\n-        MethMac(ref mac) => visitor.visit_mac(mac)\n-    }\n-}\n-\n pub fn walk_fn<'v, V: Visitor<'v>>(visitor: &mut V,\n                                    function_kind: FnKind<'v>,\n                                    function_declaration: &'v FnDecl,\n@@ -647,40 +603,53 @@ pub fn walk_fn<'v, V: Visitor<'v>>(visitor: &mut V,\n         FkItemFn(_, generics, _, _) => {\n             visitor.visit_generics(generics);\n         }\n-        FkMethod(_, generics, method) => {\n-            visitor.visit_generics(generics);\n-            match method.node {\n-                MethDecl(_, _, _, ref explicit_self, _, _, _, _) =>\n-                    visitor.visit_explicit_self(explicit_self),\n-                MethMac(ref mac) =>\n-                    visitor.visit_mac(mac)\n-            }\n+        FkMethod(_, sig) => {\n+            visitor.visit_generics(&sig.generics);\n+            visitor.visit_explicit_self(&sig.explicit_self);\n         }\n         FkFnBlock(..) => {}\n     }\n \n     visitor.visit_block(function_body)\n }\n \n-pub fn walk_ty_method<'v, V: Visitor<'v>>(visitor: &mut V, method_type: &'v TypeMethod) {\n-    visitor.visit_ident(method_type.span, method_type.ident);\n-    visitor.visit_explicit_self(&method_type.explicit_self);\n-    for argument_type in &method_type.decl.inputs {\n-        visitor.visit_ty(&*argument_type.ty)\n-    }\n-    visitor.visit_generics(&method_type.generics);\n-    walk_fn_ret_ty(visitor, &method_type.decl.output);\n-    for attr in &method_type.attrs {\n+pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v TraitItem) {\n+    visitor.visit_ident(trait_item.span, trait_item.ident);\n+    for attr in &trait_item.attrs {\n         visitor.visit_attribute(attr);\n     }\n+    match trait_item.node {\n+        MethodTraitItem(ref sig, None) => {\n+            visitor.visit_explicit_self(&sig.explicit_self);\n+            visitor.visit_generics(&sig.generics);\n+            walk_fn_decl(visitor, &sig.decl);\n+        }\n+        MethodTraitItem(ref sig, Some(ref body)) => {\n+            visitor.visit_fn(FkMethod(trait_item.ident, sig), &sig.decl,\n+                             body, trait_item.span, trait_item.id);\n+        }\n+        TypeTraitItem(ref bounds, ref default) => {\n+            walk_ty_param_bounds_helper(visitor, bounds);\n+            walk_ty_opt(visitor, default);\n+        }\n+    }\n }\n \n-pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_method: &'v TraitItem) {\n-    match *trait_method {\n-        RequiredMethod(ref method_type) => visitor.visit_ty_method(method_type),\n-        ProvidedMethod(ref method) => walk_method_helper(visitor, &**method),\n-        TypeTraitItem(ref associated_type) => {\n-            walk_ty_param(visitor, &associated_type.ty_param);\n+pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplItem) {\n+    visitor.visit_ident(impl_item.span, impl_item.ident);\n+    for attr in &impl_item.attrs {\n+        visitor.visit_attribute(attr);\n+    }\n+    match impl_item.node {\n+        MethodImplItem(ref sig, ref body) => {\n+            visitor.visit_fn(FkMethod(impl_item.ident, sig), &sig.decl,\n+                             body, impl_item.span, impl_item.id);\n+        }\n+        TypeImplItem(ref ty) => {\n+            visitor.visit_ty(ty);\n+        }\n+        MacImplItem(ref mac) => {\n+            visitor.visit_mac(mac);\n         }\n     }\n }"}, {"sha": "36a34bc6c8b41a3e6189597d3de89e1681e29918", "filename": "src/test/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -16,7 +16,7 @@\n extern crate syntax;\n extern crate rustc;\n \n-use syntax::ast::{TokenTree, Item, MetaItem, ImplItem, TraitItem, Method};\n+use syntax::ast::{self, TokenTree, Item, MetaItem};\n use syntax::codemap::Span;\n use syntax::ext::base::*;\n use syntax::parse::token;\n@@ -82,14 +82,24 @@ fn expand_into_foo_multi(cx: &mut ExtCtxt,\n             }))\n         }\n         Annotatable::ImplItem(it) => {\n-            Annotatable::ImplItem(ImplItem::MethodImplItem(\n-                quote_method!(cx, fn foo(&self) -> i32 { 42 })\n-            ))\n+            quote_item!(cx, impl X { fn foo(&self) -> i32 { 42 } }).unwrap().and_then(|i| {\n+                match i.node {\n+                    ast::ItemImpl(_, _, _, _, _, mut items) => {\n+                        Annotatable::ImplItem(items.pop().expect(\"impl method not found\"))\n+                    }\n+                    _ => unreachable!(\"impl parsed to something other than impl\")\n+                }\n+            })\n         }\n         Annotatable::TraitItem(it) => {\n-            Annotatable::TraitItem(TraitItem::ProvidedMethod(\n-                quote_method!(cx, fn foo(&self) -> i32 { 0 })\n-            ))\n+            quote_item!(cx, trait X { fn foo(&self) -> i32 { 0 } }).unwrap().and_then(|i| {\n+                match i.node {\n+                    ast::ItemTrait(_, _, _, mut items) => {\n+                        Annotatable::TraitItem(items.pop().expect(\"trait method not found\"))\n+                    }\n+                    _ => unreachable!(\"trait parsed to something other than trait\")\n+                }\n+            })\n         }\n     }\n }"}, {"sha": "3b4def8c5086954ff69b1ee9973c3981d4067c26", "filename": "src/test/compile-fail/impl-duplicate-methods.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Ftest%2Fcompile-fail%2Fimpl-duplicate-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Ftest%2Fcompile-fail%2Fimpl-duplicate-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpl-duplicate-methods.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -11,7 +11,7 @@\n struct Foo;\n impl Foo {\n     fn orange(&self){}\n-    fn orange(&self){}   //~ ERROR error: duplicate method in trait impl\n+    fn orange(&self){}   //~ ERROR error: duplicate method\n }\n \n fn main() {}"}, {"sha": "553436607d159ca79a940c3bcb6da3ebb64a4b92", "filename": "src/test/compile-fail/issue-4265.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Ftest%2Fcompile-fail%2Fissue-4265.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Ftest%2Fcompile-fail%2Fissue-4265.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4265.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -17,7 +17,7 @@ impl Foo {\n         Foo { baz: 0 }.bar();\n     }\n \n-    fn bar() { //~ ERROR duplicate method in trait impl\n+    fn bar() { //~ ERROR duplicate method\n     }\n }\n "}, {"sha": "04db6c8c8f39c97798136e1af46f2f2136b79143", "filename": "src/test/compile-fail/lint-missing-doc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Ftest%2Fcompile-fail%2Flint-missing-doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Ftest%2Fcompile-fail%2Flint-missing-doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-missing-doc.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -59,8 +59,8 @@ trait B {\n }\n \n pub trait C { //~ ERROR: missing documentation for a trait\n-    fn foo(&self); //~ ERROR: missing documentation for a type method\n-    fn foo_with_impl(&self) {} //~ ERROR: missing documentation for a method\n+    fn foo(&self); //~ ERROR: missing documentation for a trait method\n+    fn foo_with_impl(&self) {} //~ ERROR: missing documentation for a trait method\n }\n \n #[allow(missing_docs)]"}, {"sha": "113393490cb6de18fb5c3c60dcdcaeca9a530a01", "filename": "src/test/compile-fail/unnecessary-private.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Ftest%2Fcompile-fail%2Funnecessary-private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Ftest%2Fcompile-fail%2Funnecessary-private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funnecessary-private.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -13,7 +13,7 @@ fn main() {\n     pub struct A; //~ ERROR: visibility has no effect\n     pub enum B {} //~ ERROR: visibility has no effect\n     pub trait C { //~ ERROR: visibility has no effect\n-        pub fn foo(&self) {} //~ ERROR: visibility has no effect\n+        fn foo(&self) {}\n     }\n     impl A {\n         pub fn foo(&self) {} //~ ERROR: visibility has no effect"}, {"sha": "59964d0df956c83233d3de29ee0e9e784b7fa3ff", "filename": "src/test/compile-fail/useless-priv.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Ftest%2Fcompile-fail%2Fuseless-priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Ftest%2Fcompile-fail%2Fuseless-priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuseless-priv.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -12,10 +12,7 @@ struct A { pub i: isize }\n pub enum C { pub Variant }      //~ ERROR: unnecessary `pub`\n \n pub trait E {\n-    pub fn foo(&self) {}         //~ ERROR: unnecessary visibility\n-}\n-trait F {\n-    pub fn foo(&self) {}     //~ ERROR: unnecessary visibility\n+    fn foo(&self);\n }\n \n impl E for A {"}, {"sha": "6496ffebbc849db8e73068b36942851516345dea", "filename": "src/test/parse-fail/issue-21153.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Ftest%2Fparse-fail%2Fissue-21153.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Ftest%2Fparse-fail%2Fissue-21153.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-21153.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n trait MyTrait<T>: Iterator {\n-    Item = T; //~ ERROR expected one of `extern`, `fn`, `pub`, `type`, or `unsafe`, found `Item`\n+    Item = T; //~ ERROR expected one of `extern`, `fn`, `type`, or `unsafe`, found `Item`\n }"}, {"sha": "02d76234d4e57d97d73d98ee1745b7f6cca84305", "filename": "src/test/parse-fail/trait-pub-assoc-ty.rs", "status": "renamed", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Ftest%2Fparse-fail%2Ftrait-pub-assoc-ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Ftest%2Fparse-fail%2Ftrait-pub-assoc-ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Ftrait-pub-assoc-ty.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,11 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub trait E {\n-    pub fn foo(&self);               //~ ERROR: unnecessary visibility\n-}\n-trait F {\n-    pub fn foo(&self);               //~ ERROR: unnecessary visibility\n+trait Foo {\n+    pub type Foo; //~ ERROR expected one of `extern`, `fn`, `type`, or `unsafe`, found `pub`\n }\n \n fn main() {}", "previous_filename": "src/test/compile-fail/useless-priv2.rs"}, {"sha": "e76802d2ea0f7bdeb1d5976c8ac10d83368de6ba", "filename": "src/test/parse-fail/trait-pub-method.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Ftest%2Fparse-fail%2Ftrait-pub-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Ftest%2Fparse-fail%2Ftrait-pub-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Ftrait-pub-method.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Foo {\n+    pub fn foo(); //~ ERROR expected one of `extern`, `fn`, `type`, or `unsafe`, found `pub`\n+}\n+\n+fn main() {}"}, {"sha": "7f7ed586878e545cdee92bbfb88db940dde379ba", "filename": "src/test/run-pass-fulldeps/quote-tokens.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b03c24ec346e6405883032094f47805ef9c43e/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs?ref=c9b03c24ec346e6405883032094f47805ef9c43e", "patch": "@@ -36,9 +36,6 @@ fn syntax_extension(cx: &ExtCtxt) {\n     let i: Option<P<syntax::ast::Item>> = quote_item!(cx, #[derive(Eq)] struct Foo; );\n     assert!(i.is_some());\n \n-    let _j: P<syntax::ast::Method> = quote_method!(cx, fn foo(&self) {});\n-    let _k: P<syntax::ast::Method> = quote_method!(cx, #[doc = \"hello\"] fn foo(&self) {});\n-\n     let _l: P<syntax::ast::Ty> = quote_ty!(cx, &int);\n \n     let _m: Vec<syntax::ast::TokenTree> = quote_matcher!(cx, $($foo:tt,)* bar);"}]}