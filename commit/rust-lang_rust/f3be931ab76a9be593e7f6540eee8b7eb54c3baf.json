{"sha": "f3be931ab76a9be593e7f6540eee8b7eb54c3baf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzYmU5MzFhYjc2YTliZTU5M2U3ZjY1NDBlZWU4YjdlYjU0YzNiYWY=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-11-30T18:30:30Z"}, "committer": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-11-30T18:30:30Z"}, "message": "Rollup merge of #56337 - phansch:fix_const_ice, r=oli-obk\n\nFix const_fn ICE with non-const function pointer\n\nFixes #56164", "tree": {"sha": "ef09b30c79cc4e1707c690e7b3ca3739b920d77a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef09b30c79cc4e1707c690e7b3ca3739b920d77a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3be931ab76a9be593e7f6540eee8b7eb54c3baf", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZ1R8CLMp8f2GxWoQ/vbIBR0OATwFAlwBgccACgkQ/vbIBR0O\nATzRrg/9GFaDt6ijRSVPl3yfZyKm3xW/8i1r6peomH71ZOggoDH4D6T0jU5SyCwx\nqCJnj5enNvMd3Vr9p2NPxYxrj/xTY+L9GyqDFsNGHnUd9mI9Pgy5vOX0+PFbIArl\na6fdHMS0mFuHkt7aPPQhV+6OlQ93I5ramKcs2dt98Wwsq+zuKz69AXdeCjt8LD/a\n2d4GmTTtN0FaABwH+899YEX4Xbnq1NzA5IpMdZ/Gbzb6gy5f9tfRrlVEhLIBhWZ9\nTihjdC+VFt10isVxwCqV/ugsWlPoKqtMUgFeNXi95oMcEM2j6X2KXOqH73j0RN8F\n2KZE01uaatdjuGpqfUf0Y8oyWnk8TGp4RXU/qrvDcz/q4AkroMJmA6KuQtGnCqFB\nrArjjukAoQX56baUikFHa9VxIVq2rC7KEta4RRoXmFleAT8J3Pdz+5d+x7lBYqYO\nXTAuyGnxEvpML9AFnKdUKainlFUFYDq3MVGYA6aCnhB4YfAH9GqoZQF2MixCDxVC\nlbHrt53gpiiey5trVGSL6ccm2ZIaMDmFq+Wnc65uOVqqafHSg5T+qNP2KBa782WA\nQ0LsNGD9lPyx8KvoM9xlbZ5l6xd/rdIBMYk9MDpzy0B18iv9Q2LW25opNKJvTc30\nS5p6YZHK0Y7YFpiWoZeaRQI/y2o6FZMya3ryYFSYTWBzfeUBl0Q=\n=G/fx\n-----END PGP SIGNATURE-----", "payload": "tree ef09b30c79cc4e1707c690e7b3ca3739b920d77a\nparent ecfe7216206c4ed4697a39ba80b3f0889350da8f\nparent 247ab496689d6a43995ed1cfd56b7fb2bafad095\nauthor kennytm <kennytm@gmail.com> 1543602630 +0800\ncommitter kennytm <kennytm@gmail.com> 1543602630 +0800\n\nRollup merge of #56337 - phansch:fix_const_ice, r=oli-obk\n\nFix const_fn ICE with non-const function pointer\n\nFixes #56164\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3be931ab76a9be593e7f6540eee8b7eb54c3baf", "html_url": "https://github.com/rust-lang/rust/commit/f3be931ab76a9be593e7f6540eee8b7eb54c3baf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3be931ab76a9be593e7f6540eee8b7eb54c3baf/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ecfe7216206c4ed4697a39ba80b3f0889350da8f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ecfe7216206c4ed4697a39ba80b3f0889350da8f", "html_url": "https://github.com/rust-lang/rust/commit/ecfe7216206c4ed4697a39ba80b3f0889350da8f"}, {"sha": "247ab496689d6a43995ed1cfd56b7fb2bafad095", "url": "https://api.github.com/repos/rust-lang/rust/commits/247ab496689d6a43995ed1cfd56b7fb2bafad095", "html_url": "https://github.com/rust-lang/rust/commit/247ab496689d6a43995ed1cfd56b7fb2bafad095"}], "stats": {"total": 287, "additions": 165, "deletions": 122}, "files": [{"sha": "bcee6d75b5a4a84974ee2dfdcc6d8c0dc94619bb", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 137, "deletions": 122, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/f3be931ab76a9be593e7f6540eee8b7eb54c3baf/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3be931ab76a9be593e7f6540eee8b7eb54c3baf/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=f3be931ab76a9be593e7f6540eee8b7eb54c3baf", "patch": "@@ -895,145 +895,160 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n             let mut is_shuffle = false;\n             let mut is_const_fn = false;\n             let mut is_promotable_const_fn = false;\n-            if let ty::FnDef(def_id, _) = fn_ty.sty {\n-                callee_def_id = Some(def_id);\n-                match self.tcx.fn_sig(def_id).abi() {\n-                    Abi::RustIntrinsic |\n-                    Abi::PlatformIntrinsic => {\n-                        assert!(!self.tcx.is_const_fn(def_id));\n-                        match &self.tcx.item_name(def_id).as_str()[..] {\n-                            | \"size_of\"\n-                            | \"min_align_of\"\n-                            | \"needs_drop\"\n-                            | \"type_id\"\n-                            | \"bswap\"\n-                            | \"bitreverse\"\n-                            | \"ctpop\"\n-                            | \"cttz\"\n-                            | \"cttz_nonzero\"\n-                            | \"ctlz\"\n-                            | \"ctlz_nonzero\"\n-                            | \"overflowing_add\"\n-                            | \"overflowing_sub\"\n-                            | \"overflowing_mul\"\n-                            | \"unchecked_shl\"\n-                            | \"unchecked_shr\"\n-                            | \"rotate_left\"\n-                            | \"rotate_right\"\n-                            | \"add_with_overflow\"\n-                            | \"sub_with_overflow\"\n-                            | \"mul_with_overflow\"\n-                            // no need to check feature gates, intrinsics are only callable from the\n-                            // libstd or with forever unstable feature gates\n-                            => is_const_fn = true,\n-                            // special intrinsic that can be called diretly without an intrinsic\n-                            // feature gate needs a language feature gate\n-                            \"transmute\" => {\n-                                // never promote transmute calls\n-                                if self.mode != Mode::Fn {\n-                                    is_const_fn = true;\n-                                    // const eval transmute calls only with the feature gate\n-                                    if !self.tcx.features().const_transmute {\n-                                        emit_feature_err(\n-                                            &self.tcx.sess.parse_sess, \"const_transmute\",\n-                                            self.span, GateIssue::Language,\n-                                            &format!(\"The use of std::mem::transmute() \\\n-                                            is gated in {}s\", self.mode));\n+            match fn_ty.sty {\n+                ty::FnDef(def_id, _) => {\n+                    callee_def_id = Some(def_id);\n+                    match self.tcx.fn_sig(def_id).abi() {\n+                        Abi::RustIntrinsic |\n+                        Abi::PlatformIntrinsic => {\n+                            assert!(!self.tcx.is_const_fn(def_id));\n+                            match &self.tcx.item_name(def_id).as_str()[..] {\n+                                | \"size_of\"\n+                                | \"min_align_of\"\n+                                | \"needs_drop\"\n+                                | \"type_id\"\n+                                | \"bswap\"\n+                                | \"bitreverse\"\n+                                | \"ctpop\"\n+                                | \"cttz\"\n+                                | \"cttz_nonzero\"\n+                                | \"ctlz\"\n+                                | \"ctlz_nonzero\"\n+                                | \"overflowing_add\"\n+                                | \"overflowing_sub\"\n+                                | \"overflowing_mul\"\n+                                | \"unchecked_shl\"\n+                                | \"unchecked_shr\"\n+                                | \"rotate_left\"\n+                                | \"rotate_right\"\n+                                | \"add_with_overflow\"\n+                                | \"sub_with_overflow\"\n+                                | \"mul_with_overflow\"\n+                                // no need to check feature gates, intrinsics are only callable\n+                                // from the libstd or with forever unstable feature gates\n+                                => is_const_fn = true,\n+                                // special intrinsic that can be called diretly without an intrinsic\n+                                // feature gate needs a language feature gate\n+                                \"transmute\" => {\n+                                    // never promote transmute calls\n+                                    if self.mode != Mode::Fn {\n+                                        is_const_fn = true;\n+                                        // const eval transmute calls only with the feature gate\n+                                        if !self.tcx.features().const_transmute {\n+                                            emit_feature_err(\n+                                                &self.tcx.sess.parse_sess, \"const_transmute\",\n+                                                self.span, GateIssue::Language,\n+                                                &format!(\"The use of std::mem::transmute() \\\n+                                                is gated in {}s\", self.mode));\n+                                        }\n                                     }\n                                 }\n-                            }\n \n-                            name if name.starts_with(\"simd_shuffle\") => {\n-                                is_shuffle = true;\n-                            }\n+                                name if name.starts_with(\"simd_shuffle\") => {\n+                                    is_shuffle = true;\n+                                }\n \n-                            _ => {}\n-                        }\n-                    }\n-                    _ => {\n-                        // in normal functions we only care about promotion\n-                        if self.mode == Mode::Fn {\n-                            // never promote const fn calls of\n-                            // functions without #[rustc_promotable]\n-                            if self.tcx.is_promotable_const_fn(def_id) {\n-                                is_const_fn = true;\n-                                is_promotable_const_fn = true;\n-                            } else if self.tcx.is_const_fn(def_id) {\n-                                is_const_fn = true;\n+                                _ => {}\n                             }\n-                        } else {\n-                            // stable const fn or unstable const fns with their feature gate\n-                            // active\n-                            if self.tcx.is_const_fn(def_id) {\n-                                is_const_fn = true;\n-                            } else if self.is_const_panic_fn(def_id) {\n-                                // check the const_panic feature gate\n-                                // FIXME: cannot allow this inside `allow_internal_unstable` because\n-                                // that would make `panic!` insta stable in constants, since the\n-                                // macro is marked with the attr\n-                                if self.tcx.features().const_panic {\n+                        }\n+                        _ => {\n+                            // in normal functions we only care about promotion\n+                            if self.mode == Mode::Fn {\n+                                // never promote const fn calls of\n+                                // functions without #[rustc_promotable]\n+                                if self.tcx.is_promotable_const_fn(def_id) {\n                                     is_const_fn = true;\n-                                } else {\n-                                    // don't allow panics in constants without the feature gate\n-                                    emit_feature_err(\n-                                        &self.tcx.sess.parse_sess,\n-                                        \"const_panic\",\n-                                        self.span,\n-                                        GateIssue::Language,\n-                                        &format!(\"panicking in {}s is unstable\", self.mode),\n-                                    );\n-                                }\n-                            } else if let Some(feature) = self.tcx.is_unstable_const_fn(def_id) {\n-                                // check `#[unstable]` const fns or `#[rustc_const_unstable]`\n-                                // functions without the feature gate active in this crate to report\n-                                // a better error message than the one below\n-                                if self.span.allows_unstable() {\n-                                    // `allow_internal_unstable` can make such calls stable\n+                                    is_promotable_const_fn = true;\n+                                } else if self.tcx.is_const_fn(def_id) {\n                                     is_const_fn = true;\n-                                } else {\n-                                    let mut err = self.tcx.sess.struct_span_err(self.span,\n-                                        &format!(\"`{}` is not yet stable as a const fn\",\n-                                                self.tcx.item_path_str(def_id)));\n-                                    help!(&mut err,\n-                                        \"in Nightly builds, add `#![feature({})]` \\\n-                                        to the crate attributes to enable\",\n-                                        feature);\n-                                    err.emit();\n                                 }\n                             } else {\n-                                // FIXME(#24111) Remove this check when const fn stabilizes\n-                                let (msg, note) = if let UnstableFeatures::Disallow =\n-                                        self.tcx.sess.opts.unstable_features {\n-                                    (format!(\"calls in {}s are limited to \\\n-                                            tuple structs and tuple variants\",\n-                                            self.mode),\n-                                    Some(\"a limited form of compile-time function \\\n-                                        evaluation is available on a nightly \\\n-                                        compiler via `const fn`\"))\n+                                // stable const fn or unstable const fns with their feature gate\n+                                // active\n+                                if self.tcx.is_const_fn(def_id) {\n+                                    is_const_fn = true;\n+                                } else if self.is_const_panic_fn(def_id) {\n+                                    // check the const_panic feature gate\n+                                    // FIXME: cannot allow this inside `allow_internal_unstable`\n+                                    // because that would make `panic!` insta stable in constants,\n+                                    // since the macro is marked with the attr\n+                                    if self.tcx.features().const_panic {\n+                                        is_const_fn = true;\n+                                    } else {\n+                                        // don't allow panics in constants without the feature gate\n+                                        emit_feature_err(\n+                                            &self.tcx.sess.parse_sess,\n+                                            \"const_panic\",\n+                                            self.span,\n+                                            GateIssue::Language,\n+                                            &format!(\"panicking in {}s is unstable\", self.mode),\n+                                        );\n+                                    }\n+                                } else if let Some(feat) = self.tcx.is_unstable_const_fn(def_id) {\n+                                    // check `#[unstable]` const fns or `#[rustc_const_unstable]`\n+                                    // functions without the feature gate active in this crate to\n+                                    // report a better error message than the one below\n+                                    if self.span.allows_unstable() {\n+                                        // `allow_internal_unstable` can make such calls stable\n+                                        is_const_fn = true;\n+                                    } else {\n+                                        let mut err = self.tcx.sess.struct_span_err(self.span,\n+                                            &format!(\"`{}` is not yet stable as a const fn\",\n+                                                    self.tcx.item_path_str(def_id)));\n+                                        help!(&mut err,\n+                                            \"in Nightly builds, add `#![feature({})]` \\\n+                                            to the crate attributes to enable\",\n+                                            feat);\n+                                        err.emit();\n+                                    }\n                                 } else {\n-                                    (format!(\"calls in {}s are limited \\\n-                                            to constant functions, \\\n-                                            tuple structs and tuple variants\",\n-                                            self.mode),\n-                                    None)\n-                                };\n-                                let mut err = struct_span_err!(\n-                                    self.tcx.sess,\n-                                    self.span,\n-                                    E0015,\n-                                    \"{}\",\n-                                    msg,\n-                                );\n-                                if let Some(note) = note {\n-                                    err.span_note(self.span, note);\n+                                    // FIXME(#24111) Remove this check when const fn stabilizes\n+                                    let (msg, note) = if let UnstableFeatures::Disallow =\n+                                            self.tcx.sess.opts.unstable_features {\n+                                        (format!(\"calls in {}s are limited to \\\n+                                                tuple structs and tuple variants\",\n+                                                self.mode),\n+                                        Some(\"a limited form of compile-time function \\\n+                                            evaluation is available on a nightly \\\n+                                            compiler via `const fn`\"))\n+                                    } else {\n+                                        (format!(\"calls in {}s are limited \\\n+                                                to constant functions, \\\n+                                                tuple structs and tuple variants\",\n+                                                self.mode),\n+                                        None)\n+                                    };\n+                                    let mut err = struct_span_err!(\n+                                        self.tcx.sess,\n+                                        self.span,\n+                                        E0015,\n+                                        \"{}\",\n+                                        msg,\n+                                    );\n+                                    if let Some(note) = note {\n+                                        err.span_note(self.span, note);\n+                                    }\n+                                    err.emit();\n                                 }\n-                                err.emit();\n                             }\n                         }\n                     }\n+                },\n+                ty::FnPtr(_) => {\n+                    if self.mode != Mode::Fn {\n+                        let mut err = self.tcx.sess.struct_span_err(\n+                            self.span,\n+                            &format!(\"function pointers are not allowed in const fn\"));\n+                        err.emit();\n+                    }\n+                },\n+                _ => {\n+                    self.not_const();\n+                    return\n                 }\n             }\n \n+\n             let constant_arguments = callee_def_id.and_then(|id| {\n                 args_required_const(self.tcx, id)\n             });"}, {"sha": "9d1a8b59463e7ecb07d866c9cf0dcd6e8f82e53f", "filename": "src/test/ui/consts/issue-56164.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f3be931ab76a9be593e7f6540eee8b7eb54c3baf/src%2Ftest%2Fui%2Fconsts%2Fissue-56164.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3be931ab76a9be593e7f6540eee8b7eb54c3baf/src%2Ftest%2Fui%2Fconsts%2Fissue-56164.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-56164.rs?ref=f3be931ab76a9be593e7f6540eee8b7eb54c3baf", "patch": "@@ -0,0 +1,13 @@\n+#![feature(const_fn)]\n+\n+const fn foo() { (||{})() }\n+//~^ ERROR calls in constant functions are limited to constant functions, tuple structs and tuple\n+// variants\n+\n+const fn bad(input: fn()) {\n+    input()\n+    //~^ ERROR function pointers are not allowed in const fn\n+}\n+\n+fn main() {\n+}"}, {"sha": "d3e9ce379aed702fcc6e51c39ada44b1029c4f53", "filename": "src/test/ui/consts/issue-56164.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f3be931ab76a9be593e7f6540eee8b7eb54c3baf/src%2Ftest%2Fui%2Fconsts%2Fissue-56164.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f3be931ab76a9be593e7f6540eee8b7eb54c3baf/src%2Ftest%2Fui%2Fconsts%2Fissue-56164.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-56164.stderr?ref=f3be931ab76a9be593e7f6540eee8b7eb54c3baf", "patch": "@@ -0,0 +1,15 @@\n+error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+  --> $DIR/issue-56164.rs:3:18\n+   |\n+LL | const fn foo() { (||{})() }\n+   |                  ^^^^^^^^\n+\n+error: function pointers are not allowed in const fn\n+  --> $DIR/issue-56164.rs:8:5\n+   |\n+LL |     input()\n+   |     ^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0015`."}]}