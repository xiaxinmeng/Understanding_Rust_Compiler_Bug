{"sha": "8a0c2c4e83c216811d96a4a5af9987431b75bd6f", "node_id": "C_kwDOAAsO6NoAKDhhMGMyYzRlODNjMjE2ODExZDk2YTRhNWFmOTk4NzQzMWI3NWJkNmY", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-02-14T04:39:36Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-02-28T05:03:56Z"}, "message": "move method out of nesting", "tree": {"sha": "7c468660475d53e1882696a7125911f11a9604d1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7c468660475d53e1882696a7125911f11a9604d1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a0c2c4e83c216811d96a4a5af9987431b75bd6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a0c2c4e83c216811d96a4a5af9987431b75bd6f", "html_url": "https://github.com/rust-lang/rust/commit/8a0c2c4e83c216811d96a4a5af9987431b75bd6f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a0c2c4e83c216811d96a4a5af9987431b75bd6f/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b07d59f794d8fffb628f82c9c8156f5457de5e49", "url": "https://api.github.com/repos/rust-lang/rust/commits/b07d59f794d8fffb628f82c9c8156f5457de5e49", "html_url": "https://github.com/rust-lang/rust/commit/b07d59f794d8fffb628f82c9c8156f5457de5e49"}], "stats": {"total": 179, "additions": 90, "deletions": 89}, "files": [{"sha": "1d1110776067b2ceef2c193cc733c0acdd9b894a", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 90, "deletions": 89, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/8a0c2c4e83c216811d96a4a5af9987431b75bd6f/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a0c2c4e83c216811d96a4a5af9987431b75bd6f/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=8a0c2c4e83c216811d96a4a5af9987431b75bd6f", "patch": "@@ -794,6 +794,94 @@ fn assoc_type(\n     }\n }\n \n+fn assoc_method(\n+    w: &mut Buffer,\n+    meth: &clean::Item,\n+    header: hir::FnHeader,\n+    g: &clean::Generics,\n+    d: &clean::FnDecl,\n+    link: AssocItemLink<'_>,\n+    parent: ItemType,\n+    cx: &Context<'_>,\n+    render_mode: RenderMode,\n+) {\n+    let name = meth.name.as_ref().unwrap();\n+    let href = match link {\n+        AssocItemLink::Anchor(Some(ref id)) => Some(format!(\"#{}\", id)),\n+        AssocItemLink::Anchor(None) => Some(format!(\"#{}.{}\", meth.type_(), name)),\n+        AssocItemLink::GotoSource(did, provided_methods) => {\n+            // We're creating a link from an impl-item to the corresponding\n+            // trait-item and need to map the anchored type accordingly.\n+            let ty = if provided_methods.contains(name) {\n+                ItemType::Method\n+            } else {\n+                ItemType::TyMethod\n+            };\n+\n+            match (href(did.expect_def_id(), cx), ty) {\n+                (Ok(p), ty) => Some(format!(\"{}#{}.{}\", p.0, ty, name)),\n+                (Err(HrefError::DocumentationNotBuilt), ItemType::TyMethod) => None,\n+                (Err(_), ty) => Some(format!(\"#{}.{}\", ty, name)),\n+            }\n+        }\n+    };\n+    let vis = meth.visibility.print_with_space(meth.def_id, cx).to_string();\n+    // FIXME: Once https://github.com/rust-lang/rust/issues/67792 is implemented, we can remove\n+    // this condition.\n+    let constness = match render_mode {\n+        RenderMode::Normal => {\n+            print_constness_with_space(&header.constness, meth.const_stability(cx.tcx()))\n+        }\n+        RenderMode::ForDeref { .. } => \"\",\n+    };\n+    let asyncness = header.asyncness.print_with_space();\n+    let unsafety = header.unsafety.print_with_space();\n+    let defaultness = print_default_space(meth.is_default());\n+    let abi = print_abi_with_space(header.abi).to_string();\n+\n+    // NOTE: `{:#}` does not print HTML formatting, `{}` does. So `g.print` can't be reused between the length calculation and `write!`.\n+    let generics_len = format!(\"{:#}\", g.print(cx)).len();\n+    let mut header_len = \"fn \".len()\n+        + vis.len()\n+        + constness.len()\n+        + asyncness.len()\n+        + unsafety.len()\n+        + defaultness.len()\n+        + abi.len()\n+        + name.as_str().len()\n+        + generics_len;\n+\n+    let (indent, indent_str, end_newline) = if parent == ItemType::Trait {\n+        header_len += 4;\n+        let indent_str = \"    \";\n+        render_attributes_in_pre(w, meth, indent_str);\n+        (4, indent_str, false)\n+    } else {\n+        render_attributes_in_code(w, meth);\n+        (0, \"\", true)\n+    };\n+    w.reserve(header_len + \"<a href=\\\"\\\" class=\\\"fnname\\\">{\".len() + \"</a>\".len());\n+    write!(\n+        w,\n+        \"{indent}{vis}{constness}{asyncness}{unsafety}{defaultness}{abi}fn <a {href} class=\\\"fnname\\\">{name}</a>\\\n+         {generics}{decl}{notable_traits}{where_clause}\",\n+        indent = indent_str,\n+        vis = vis,\n+        constness = constness,\n+        asyncness = asyncness,\n+        unsafety = unsafety,\n+        defaultness = defaultness,\n+        abi = abi,\n+        // links without a href are valid - https://www.w3schools.com/tags/att_a_href.asp\n+        href = href.map(|href| format!(\"href=\\\"{}\\\"\", href)).unwrap_or_else(|| \"\".to_string()),\n+        name = name,\n+        generics = g.print(cx),\n+        decl = d.full_print(header_len, indent, header.asyncness, cx),\n+        notable_traits = notable_traits_decl(d, cx),\n+        where_clause = print_where_clause(g, cx, indent, end_newline),\n+    )\n+}\n+\n /// Writes a span containing the versions at which an item became stable and/or const-stable. For\n /// example, if the item became stable at 1.0.0, and const-stable at 1.45.0, this function would\n /// write a span containing \"1.0.0 (const: 1.45.0)\".\n@@ -875,100 +963,13 @@ fn render_assoc_item(\n     cx: &Context<'_>,\n     render_mode: RenderMode,\n ) {\n-    fn method(\n-        w: &mut Buffer,\n-        meth: &clean::Item,\n-        header: hir::FnHeader,\n-        g: &clean::Generics,\n-        d: &clean::FnDecl,\n-        link: AssocItemLink<'_>,\n-        parent: ItemType,\n-        cx: &Context<'_>,\n-        render_mode: RenderMode,\n-    ) {\n-        let name = meth.name.as_ref().unwrap();\n-        let href = match link {\n-            AssocItemLink::Anchor(Some(ref id)) => Some(format!(\"#{}\", id)),\n-            AssocItemLink::Anchor(None) => Some(format!(\"#{}.{}\", meth.type_(), name)),\n-            AssocItemLink::GotoSource(did, provided_methods) => {\n-                // We're creating a link from an impl-item to the corresponding\n-                // trait-item and need to map the anchored type accordingly.\n-                let ty = if provided_methods.contains(name) {\n-                    ItemType::Method\n-                } else {\n-                    ItemType::TyMethod\n-                };\n-\n-                match (href(did.expect_def_id(), cx), ty) {\n-                    (Ok(p), ty) => Some(format!(\"{}#{}.{}\", p.0, ty, name)),\n-                    (Err(HrefError::DocumentationNotBuilt), ItemType::TyMethod) => None,\n-                    (Err(_), ty) => Some(format!(\"#{}.{}\", ty, name)),\n-                }\n-            }\n-        };\n-        let vis = meth.visibility.print_with_space(meth.def_id, cx).to_string();\n-        // FIXME: Once https://github.com/rust-lang/rust/issues/67792 is implemented, we can remove\n-        // this condition.\n-        let constness = match render_mode {\n-            RenderMode::Normal => {\n-                print_constness_with_space(&header.constness, meth.const_stability(cx.tcx()))\n-            }\n-            RenderMode::ForDeref { .. } => \"\",\n-        };\n-        let asyncness = header.asyncness.print_with_space();\n-        let unsafety = header.unsafety.print_with_space();\n-        let defaultness = print_default_space(meth.is_default());\n-        let abi = print_abi_with_space(header.abi).to_string();\n-\n-        // NOTE: `{:#}` does not print HTML formatting, `{}` does. So `g.print` can't be reused between the length calculation and `write!`.\n-        let generics_len = format!(\"{:#}\", g.print(cx)).len();\n-        let mut header_len = \"fn \".len()\n-            + vis.len()\n-            + constness.len()\n-            + asyncness.len()\n-            + unsafety.len()\n-            + defaultness.len()\n-            + abi.len()\n-            + name.as_str().len()\n-            + generics_len;\n-\n-        let (indent, indent_str, end_newline) = if parent == ItemType::Trait {\n-            header_len += 4;\n-            let indent_str = \"    \";\n-            render_attributes_in_pre(w, meth, indent_str);\n-            (4, indent_str, false)\n-        } else {\n-            render_attributes_in_code(w, meth);\n-            (0, \"\", true)\n-        };\n-        w.reserve(header_len + \"<a href=\\\"\\\" class=\\\"fnname\\\">{\".len() + \"</a>\".len());\n-        write!(\n-            w,\n-            \"{indent}{vis}{constness}{asyncness}{unsafety}{defaultness}{abi}fn <a {href} class=\\\"fnname\\\">{name}</a>\\\n-             {generics}{decl}{notable_traits}{where_clause}\",\n-            indent = indent_str,\n-            vis = vis,\n-            constness = constness,\n-            asyncness = asyncness,\n-            unsafety = unsafety,\n-            defaultness = defaultness,\n-            abi = abi,\n-            // links without a href are valid - https://www.w3schools.com/tags/att_a_href.asp\n-            href = href.map(|href| format!(\"href=\\\"{}\\\"\", href)).unwrap_or_else(|| \"\".to_string()),\n-            name = name,\n-            generics = g.print(cx),\n-            decl = d.full_print(header_len, indent, header.asyncness, cx),\n-            notable_traits = notable_traits_decl(d, cx),\n-            where_clause = print_where_clause(g, cx, indent, end_newline),\n-        )\n-    }\n     match *item.kind {\n         clean::StrippedItem(..) => {}\n         clean::TyMethodItem(ref m) => {\n-            method(w, item, m.header, &m.generics, &m.decl, link, parent, cx, render_mode)\n+            assoc_method(w, item, m.header, &m.generics, &m.decl, link, parent, cx, render_mode)\n         }\n         clean::MethodItem(ref m, _) => {\n-            method(w, item, m.header, &m.generics, &m.decl, link, parent, cx, render_mode)\n+            assoc_method(w, item, m.header, &m.generics, &m.decl, link, parent, cx, render_mode)\n         }\n         clean::AssocConstItem(ref ty, _) => {\n             assoc_const(w, item, ty, link, if parent == ItemType::Trait { \"    \" } else { \"\" }, cx)"}]}