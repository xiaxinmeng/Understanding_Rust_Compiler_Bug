{"sha": "c75001b2af7b7afab13850eaad0f83562d5d8195", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3NTAwMWIyYWY3YjdhZmFiMTM4NTBlYWFkMGY4MzU2MmQ1ZDgxOTU=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-10-07T09:45:04Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-10-07T09:45:04Z"}, "message": "Rollup merge of #36665 - kmcallister:arc-docs, r=steveklabnik\n\nUpdate Arc docs to match new Rc docs\n\n`Rc` docs were updated in #36571. This applies similar changes to `Arc` docs.\n\nr? @GuillaumeGomez", "tree": {"sha": "b3ff975ce498f6adc473178b008babda7d98d1ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b3ff975ce498f6adc473178b008babda7d98d1ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c75001b2af7b7afab13850eaad0f83562d5d8195", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c75001b2af7b7afab13850eaad0f83562d5d8195", "html_url": "https://github.com/rust-lang/rust/commit/c75001b2af7b7afab13850eaad0f83562d5d8195", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c75001b2af7b7afab13850eaad0f83562d5d8195/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "85e95cc801d982c8c603dc02dd544895401ac8bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/85e95cc801d982c8c603dc02dd544895401ac8bf", "html_url": "https://github.com/rust-lang/rust/commit/85e95cc801d982c8c603dc02dd544895401ac8bf"}, {"sha": "29d3e570a5ecb767aca977194fc8ab80277af312", "url": "https://api.github.com/repos/rust-lang/rust/commits/29d3e570a5ecb767aca977194fc8ab80277af312", "html_url": "https://github.com/rust-lang/rust/commit/29d3e570a5ecb767aca977194fc8ab80277af312"}], "stats": {"total": 458, "additions": 302, "deletions": 156}, "files": [{"sha": "7a07e007ce1c48eb8902dd4ba7d0e41fd5ccf75b", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 281, "deletions": 145, "changes": 426, "blob_url": "https://github.com/rust-lang/rust/blob/c75001b2af7b7afab13850eaad0f83562d5d8195/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c75001b2af7b7afab13850eaad0f83562d5d8195/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=c75001b2af7b7afab13850eaad0f83562d5d8195", "patch": "@@ -10,35 +10,11 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-//! Threadsafe reference-counted boxes (the `Arc<T>` type).\n+//! Thread-safe reference-counting pointers.\n //!\n-//! The `Arc<T>` type provides shared ownership of an immutable value through\n-//! atomic reference counting.\n+//! See the [`Arc<T>`][arc] documentation for more details.\n //!\n-//! `Weak<T>` is a weak reference to the `Arc<T>` box, and it is created by\n-//! the `downgrade` method.\n-//! # Examples\n-//!\n-//! Sharing some immutable data between threads:\n-//!\n-// Note that we **do not** run these tests here. The windows builders get super\n-// unhappy of a thread outlives the main thread and then exits at the same time\n-// (something deadlocks) so we just avoid this entirely by not running these\n-// tests.\n-//! ```no_run\n-//! use std::sync::Arc;\n-//! use std::thread;\n-//!\n-//! let five = Arc::new(5);\n-//!\n-//! for _ in 0..10 {\n-//!     let five = five.clone();\n-//!\n-//!     thread::spawn(move || {\n-//!         println!(\"{:?}\", five);\n-//!     });\n-//! }\n-//! ```\n+//! [arc]: struct.Arc.html\n \n use boxed::Box;\n \n@@ -62,71 +38,114 @@ use heap::deallocate;\n \n const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n \n-/// An atomically reference counted wrapper for shared state.\n-/// Destruction is deterministic, and will occur as soon as the last owner is\n-/// gone. It is marked as `Send` because it uses atomic reference counting.\n+/// A thread-safe reference-counting pointer.\n ///\n-/// If you do not need thread-safety, and just need shared ownership, consider\n-/// the [`Rc<T>` type](../rc/struct.Rc.html). It is the same as `Arc<T>`, but\n-/// does not use atomics, making it both thread-unsafe as well as significantly\n-/// faster when updating the reference count.\n+/// The type `Arc<T>` provides shared ownership of a value of type `T`,\n+/// allocated in the heap. Invoking [`clone`][clone] on `Arc` produces\n+/// a new pointer to the same value in the heap. When the last `Arc`\n+/// pointer to a given value is destroyed, the pointed-to value is\n+/// also destroyed.\n ///\n-/// Note: the inherent methods defined on `Arc<T>` are all associated functions,\n-/// which means that you have to call them as e.g.  `Arc::get_mut(&value)`\n-/// instead of `value.get_mut()`.  This is so that there are no conflicts with\n-/// methods on the inner type `T`, which are what you want to call in the\n-/// majority of cases.\n+/// Shared references in Rust disallow mutation by default, and `Arc` is no\n+/// exception. If you need to mutate through an `Arc`, use [`Mutex`][mutex],\n+/// [`RwLock`][rwlock], or one of the [`Atomic`][atomic] types.\n ///\n-/// # Examples\n+/// `Arc` uses atomic operations for reference counting, so `Arc`s can be\n+/// sent between threads. In other words, `Arc<T>` implements [`Send`][send]\n+/// as long as `T` implements `Send` and [`Sync`][sync]. The disadvantage is\n+/// that atomic operations are more expensive than ordinary memory accesses.\n+/// If you are not sharing reference-counted values between threads, consider\n+/// using [`rc::Rc`][rc] for lower overhead. `Rc` is a safe default, because\n+/// the compiler will catch any attempt to send an `Rc` between threads.\n+/// However, a library might choose `Arc` in order to give library consumers\n+/// more flexibility.\n+///\n+/// The [`downgrade`][downgrade] method can be used to create a non-owning\n+/// [`Weak`][weak] pointer. A `Weak` pointer can be [`upgrade`][upgrade]d\n+/// to an `Arc`, but this will return [`None`][option] if the value has\n+/// already been dropped.\n ///\n-/// In this example, a large vector of data will be shared by several threads. First we\n-/// wrap it with a `Arc::new` and then clone the `Arc<T>` reference for every thread (which will\n-/// increase the reference count atomically).\n+/// A cycle between `Arc` pointers will never be deallocated. For this reason,\n+/// `Weak` is used to break cycles. For example, a tree could have strong\n+/// `Arc` pointers from parent nodes to children, and `Weak` pointers from\n+/// children back to their parents.\n+///\n+/// `Arc<T>` automatically dereferences to `T` (via the [`Deref`][deref] trait),\n+/// so you can call `T`'s methods on a value of type `Arc<T>`. To avoid name\n+/// clashes with `T`'s methods, the methods of `Arc<T>` itself are [associated\n+/// functions][assoc], called using function-like syntax:\n ///\n /// ```\n /// use std::sync::Arc;\n-/// use std::thread;\n+/// let my_arc = Arc::new(());\n+///\n+/// Arc::downgrade(&my_arc);\n+/// ```\n ///\n-/// fn main() {\n-///     let numbers: Vec<_> = (0..100).collect();\n-///     let shared_numbers = Arc::new(numbers);\n+/// `Weak<T>` does not auto-dereference to `T`, because the value may have\n+/// already been destroyed.\n ///\n-///     for _ in 0..10 {\n-///         // prepare a copy of reference here and it will be moved to the thread\n-///         let child_numbers = shared_numbers.clone();\n+/// [arc]: struct.Arc.html\n+/// [weak]: struct.Weak.html\n+/// [rc]: ../../std/rc/struct.Rc.html\n+/// [clone]: ../../std/clone/trait.Clone.html#tymethod.clone\n+/// [mutex]: ../../std/sync/struct.Mutex.html\n+/// [rwlock]: ../../std/sync/struct.RwLock.html\n+/// [atomic]: ../../std/sync/atomic/index.html\n+/// [send]: ../../std/marker/trait.Send.html\n+/// [sync]: ../../std/marker/trait.Sync.html\n+/// [deref]: ../../std/ops/trait.Deref.html\n+/// [downgrade]: struct.Arc.html#method.downgrade\n+/// [upgrade]: struct.Weak.html#method.upgrade\n+/// [option]: ../../std/option/enum.Option.html\n+/// [assoc]: ../../book/method-syntax.html#associated-functions\n ///\n-///         thread::spawn(move || {\n-///             let local_numbers = &child_numbers[..];\n+/// # Examples\n ///\n-///             // Work with the local numbers\n-///         });\n-///     }\n-/// }\n-/// ```\n-/// You can also share mutable data between threads safely\n-/// by putting it inside `Mutex` and then share `Mutex` immutably\n-/// with `Arc<T>` as shown below.\n+/// Sharing some immutable data between threads:\n ///\n-// See comment at the top of this file for why the test is no_run\n+// Note that we **do not** run these tests here. The windows builders get super\n+// unhappy if a thread outlives the main thread and then exits at the same time\n+// (something deadlocks) so we just avoid this entirely by not running these\n+// tests.\n /// ```no_run\n-/// use std::sync::{Arc, Mutex};\n+/// use std::sync::Arc;\n /// use std::thread;\n ///\n-/// let five = Arc::new(Mutex::new(5));\n+/// let five = Arc::new(5);\n ///\n /// for _ in 0..10 {\n ///     let five = five.clone();\n ///\n ///     thread::spawn(move || {\n-///         let mut number = five.lock().unwrap();\n+///         println!(\"{:?}\", five);\n+///     });\n+/// }\n+/// ```\n ///\n-///         *number += 1;\n+/// Sharing a mutable `AtomicUsize`:\n ///\n-///         println!(\"{}\", *number); // prints 6\n+/// ```no_run\n+/// use std::sync::Arc;\n+/// use std::sync::atomic::{AtomicUsize, Ordering};\n+/// use std::thread;\n+///\n+/// let val = Arc::new(AtomicUsize::new(5));\n+///\n+/// for _ in 0..10 {\n+///     let val = val.clone();\n+///\n+///     thread::spawn(move || {\n+///         let v = val.fetch_add(1, Ordering::SeqCst);\n+///         println!(\"{:?}\", v);\n ///     });\n /// }\n /// ```\n-\n+///\n+/// See the [`rc` documentation][rc_examples] for more examples of reference\n+/// counting in general.\n+///\n+/// [rc_examples]: ../../std/rc/index.html#examples\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Arc<T: ?Sized> {\n     ptr: Shared<ArcInner<T>>,\n@@ -140,18 +159,18 @@ unsafe impl<T: ?Sized + Sync + Send> Sync for Arc<T> {}\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Arc<U>> for Arc<T> {}\n \n-/// A weak pointer to an `Arc`.\n+/// A weak version of [`Arc`][arc].\n ///\n-/// Weak pointers will not keep the data inside of the `Arc` alive, and can be\n-/// used to break cycles between `Arc` pointers.\n+/// `Weak` pointers do not count towards determining if the inner value\n+/// should be dropped.\n ///\n-/// A `Weak<T>` pointer can be upgraded to an `Arc<T>` pointer, but\n-/// will return `None` if the value has already been dropped.\n+/// The typical way to obtain a `Weak` pointer is to call\n+/// [`Arc::downgrade`][downgrade].\n ///\n-/// For example, a tree with parent pointers can be represented by putting the\n-/// nodes behind strong `Arc<T>` pointers, and then storing the parent pointers\n-/// as `Weak<T>` pointers.\n-\n+/// See the [`Arc`][arc] documentation for more details.\n+///\n+/// [arc]: struct.Arc.html\n+/// [downgrade]: struct.Arc.html#method.downgrade\n #[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n pub struct Weak<T: ?Sized> {\n     ptr: Shared<ArcInner<T>>,\n@@ -209,12 +228,15 @@ impl<T> Arc<T> {\n         Arc { ptr: unsafe { Shared::new(Box::into_raw(x)) } }\n     }\n \n-    /// Unwraps the contained value if the `Arc<T>` has exactly one strong reference.\n+    /// Returns the contained value, if the `Arc` has exactly one strong reference.\n     ///\n-    /// Otherwise, an `Err` is returned with the same `Arc<T>`.\n+    /// Otherwise, an [`Err`][result] is returned with the same `Arc` that was\n+    /// passed in.\n     ///\n     /// This will succeed even if there are outstanding weak references.\n     ///\n+    /// [result]: ../../std/result/enum.Result.html\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -225,7 +247,7 @@ impl<T> Arc<T> {\n     ///\n     /// let x = Arc::new(4);\n     /// let _y = x.clone();\n-    /// assert_eq!(Arc::try_unwrap(x), Err(Arc::new(4)));\n+    /// assert_eq!(*Arc::try_unwrap(x).unwrap_err(), 4);\n     /// ```\n     #[inline]\n     #[stable(feature = \"arc_unique\", since = \"1.4.0\")]\n@@ -251,7 +273,9 @@ impl<T> Arc<T> {\n }\n \n impl<T: ?Sized> Arc<T> {\n-    /// Downgrades the `Arc<T>` to a `Weak<T>` reference.\n+    /// Creates a new [`Weak`][weak] pointer to this value.\n+    ///\n+    /// [weak]: struct.Weak.html\n     ///\n     /// # Examples\n     ///\n@@ -289,15 +313,53 @@ impl<T: ?Sized> Arc<T> {\n         }\n     }\n \n-    /// Get the number of weak references to this value.\n+    /// Gets the number of [`Weak`][weak] pointers to this value.\n+    ///\n+    /// Be careful how you use this information, because another thread\n+    /// may change the weak count at any time.\n+    ///\n+    /// [weak]: struct.Weak.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(arc_counts)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::new(5);\n+    /// let _weak_five = Arc::downgrade(&five);\n+    ///\n+    /// // This assertion is deterministic because we haven't shared\n+    /// // the `Arc` or `Weak` between threads.\n+    /// assert_eq!(1, Arc::weak_count(&five));\n+    /// ```\n     #[inline]\n     #[unstable(feature = \"arc_counts\", reason = \"not clearly useful, and racy\",\n                issue = \"28356\")]\n     pub fn weak_count(this: &Self) -> usize {\n         this.inner().weak.load(SeqCst) - 1\n     }\n \n-    /// Get the number of strong references to this value.\n+    /// Gets the number of strong (`Arc`) pointers to this value.\n+    ///\n+    /// Be careful how you use this information, because another thread\n+    /// may change the strong count at any time.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(arc_counts)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::new(5);\n+    /// let _also_five = five.clone();\n+    ///\n+    /// // This assertion is deterministic because we haven't shared\n+    /// // the `Arc` between threads.\n+    /// assert_eq!(2, Arc::strong_count(&five));\n+    /// ```\n     #[inline]\n     #[unstable(feature = \"arc_counts\", reason = \"not clearly useful, and racy\",\n                issue = \"28356\")]\n@@ -334,8 +396,8 @@ impl<T: ?Sized> Arc<T> {\n     #[unstable(feature = \"ptr_eq\",\n                reason = \"newly added\",\n                issue = \"36497\")]\n-    /// Return whether two `Arc` references point to the same value\n-    /// (not just values that compare equal).\n+    /// Returns true if the two `Arc`s point to the same value (not\n+    /// just values that compare as equal).\n     ///\n     /// # Examples\n     ///\n@@ -360,9 +422,10 @@ impl<T: ?Sized> Arc<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Clone for Arc<T> {\n-    /// Makes a clone of the `Arc<T>`.\n+    /// Makes a clone of the `Arc` pointer.\n     ///\n-    /// This increases the strong reference count.\n+    /// This creates another pointer to the same inner value, increasing the\n+    /// strong reference count.\n     ///\n     /// # Examples\n     ///\n@@ -418,11 +481,17 @@ impl<T: ?Sized> Deref for Arc<T> {\n }\n \n impl<T: Clone> Arc<T> {\n-    /// Make a mutable reference into the given `Arc<T>`.\n-    /// If the `Arc<T>` has more than one strong reference, or any weak\n-    /// references, the inner data is cloned.\n+    /// Makes a mutable reference into the given `Arc`.\n+    ///\n+    /// If there are other `Arc` or [`Weak`][weak] pointers to the same value,\n+    /// then `make_mut` will invoke [`clone`][clone] on the inner value to\n+    /// ensure unique ownership. This is also referred to as clone-on-write.\n+    ///\n+    /// See also [`get_mut`][get_mut], which will fail rather than cloning.\n     ///\n-    /// This is also referred to as a copy-on-write.\n+    /// [weak]: struct.Weak.html\n+    /// [clone]: ../../std/clone/trait.Clone.html#tymethod.clone\n+    /// [get_mut]: struct.Arc.html#method.get_mut\n     ///\n     /// # Examples\n     ///\n@@ -437,10 +506,9 @@ impl<T: Clone> Arc<T> {\n     /// *Arc::make_mut(&mut data) += 1;         // Won't clone anything\n     /// *Arc::make_mut(&mut other_data) *= 2;   // Won't clone anything\n     ///\n-    /// // Note: data and other_data now point to different numbers\n+    /// // Now `data` and `other_data` point to different values.\n     /// assert_eq!(*data, 8);\n     /// assert_eq!(*other_data, 12);\n-    ///\n     /// ```\n     #[inline]\n     #[stable(feature = \"arc_unique\", since = \"1.4.0\")]\n@@ -499,8 +567,19 @@ impl<T: Clone> Arc<T> {\n }\n \n impl<T: ?Sized> Arc<T> {\n-    /// Returns a mutable reference to the contained value if the `Arc<T>` has\n-    /// one strong reference and no weak references.\n+    /// Returns a mutable reference to the inner value, if there are\n+    /// no other `Arc` or [`Weak`][weak] pointers to the same value.\n+    ///\n+    /// Returns [`None`][option] otherwise, because it is not safe to\n+    /// mutate a shared value.\n+    ///\n+    /// See also [`make_mut`][make_mut], which will [`clone`][clone]\n+    /// the inner value when it's shared.\n+    ///\n+    /// [weak]: struct.Weak.html\n+    /// [option]: ../../std/option/enum.Option.html\n+    /// [make_mut]: struct.Arc.html#method.make_mut\n+    /// [clone]: ../../std/clone/trait.Clone.html#tymethod.clone\n     ///\n     /// # Examples\n     ///\n@@ -562,30 +641,32 @@ impl<T: ?Sized> Arc<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Drop for Arc<T> {\n-    /// Drops the `Arc<T>`.\n+    /// Drops the `Arc`.\n     ///\n     /// This will decrement the strong reference count. If the strong reference\n-    /// count becomes zero and the only other references are `Weak<T>` ones,\n-    /// `drop`s the inner value.\n+    /// count reaches zero then the only other references (if any) are\n+    /// [`Weak`][weak], so we `drop` the inner value.\n+    ///\n+    /// [weak]: struct.Weak.html\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::sync::Arc;\n     ///\n-    /// {\n-    ///     let five = Arc::new(5);\n-    ///\n-    ///     // stuff\n+    /// struct Foo;\n     ///\n-    ///     drop(five); // explicit drop\n+    /// impl Drop for Foo {\n+    ///     fn drop(&mut self) {\n+    ///         println!(\"dropped!\");\n+    ///     }\n     /// }\n-    /// {\n-    ///     let five = Arc::new(5);\n     ///\n-    ///     // stuff\n+    /// let foo  = Arc::new(Foo);\n+    /// let foo2 = foo.clone();\n     ///\n-    /// } // implicit drop\n+    /// drop(foo);    // Doesn't print anything\n+    /// drop(foo2);   // Prints \"dropped!\"\n     /// ```\n     #[unsafe_destructor_blind_to_params]\n     #[inline]\n@@ -623,17 +704,22 @@ impl<T: ?Sized> Drop for Arc<T> {\n }\n \n impl<T> Weak<T> {\n-    /// Constructs a new `Weak<T>` without an accompanying instance of T.\n+    /// Constructs a new `Weak<T>`, without an accompanying instance of `T`.\n     ///\n-    /// This allocates memory for T, but does not initialize it. Calling\n-    /// Weak<T>::upgrade() on the return value always gives None.\n+    /// This allocates memory for `T`, but does not initialize it. Calling\n+    /// [`upgrade`][upgrade] on the return value always gives\n+    /// [`None`][option].\n+    ///\n+    /// [upgrade]: struct.Weak.html#method.upgrade\n+    /// [option]: ../../std/option/enum.Option.html\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::sync::Weak;\n     ///\n     /// let empty: Weak<i64> = Weak::new();\n+    /// assert!(empty.upgrade().is_none());\n     /// ```\n     #[stable(feature = \"downgraded_weak\", since = \"1.10.0\")]\n     pub fn new() -> Weak<T> {\n@@ -650,12 +736,13 @@ impl<T> Weak<T> {\n }\n \n impl<T: ?Sized> Weak<T> {\n-    /// Upgrades a weak reference to a strong reference.\n+    /// Upgrades the `Weak` pointer to an [`Arc`][arc], if possible.\n     ///\n-    /// Upgrades the `Weak<T>` reference to an `Arc<T>`, if possible.\n+    /// Returns [`None`][option] if the strong count has reached zero and the\n+    /// inner value was destroyed.\n     ///\n-    /// Returns `None` if there were no strong references and the data was\n-    /// destroyed.\n+    /// [arc]: struct.Arc.html\n+    /// [option]: ../../std/option/enum.Option.html\n     ///\n     /// # Examples\n     ///\n@@ -667,6 +754,13 @@ impl<T: ?Sized> Weak<T> {\n     /// let weak_five = Arc::downgrade(&five);\n     ///\n     /// let strong_five: Option<Arc<_>> = weak_five.upgrade();\n+    /// assert!(strong_five.is_some());\n+    ///\n+    /// // Destroy all strong pointers.\n+    /// drop(strong_five);\n+    /// drop(five);\n+    ///\n+    /// assert!(weak_five.upgrade().is_none());\n     /// ```\n     #[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n     pub fn upgrade(&self) -> Option<Arc<T>> {\n@@ -709,9 +803,10 @@ impl<T: ?Sized> Weak<T> {\n \n #[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n impl<T: ?Sized> Clone for Weak<T> {\n-    /// Makes a clone of the `Weak<T>`.\n+    /// Makes a clone of the `Weak` pointer.\n     ///\n-    /// This increases the weak reference count.\n+    /// This creates another pointer to the same inner value, increasing the\n+    /// weak reference count.\n     ///\n     /// # Examples\n     ///\n@@ -743,15 +838,31 @@ impl<T: ?Sized> Clone for Weak<T> {\n \n #[stable(feature = \"downgraded_weak\", since = \"1.10.0\")]\n impl<T> Default for Weak<T> {\n-    /// Constructs a new `Weak<T>` without an accompanying instance of T.\n+    /// Constructs a new `Weak<T>`, without an accompanying instance of `T`.\n+    ///\n+    /// This allocates memory for `T`, but does not initialize it. Calling\n+    /// [`upgrade`][upgrade] on the return value always gives\n+    /// [`None`][option].\n+    ///\n+    /// [upgrade]: struct.Weak.html#method.upgrade\n+    /// [option]: ../../std/option/enum.Option.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Weak;\n+    ///\n+    /// let empty: Weak<i64> = Default::default();\n+    /// assert!(empty.upgrade().is_none());\n+    /// ```\n     fn default() -> Weak<T> {\n         Weak::new()\n     }\n }\n \n #[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n impl<T: ?Sized> Drop for Weak<T> {\n-    /// Drops the `Weak<T>`.\n+    /// Drops the `Weak` pointer.\n     ///\n     /// This will decrement the weak reference count.\n     ///\n@@ -760,21 +871,22 @@ impl<T: ?Sized> Drop for Weak<T> {\n     /// ```\n     /// use std::sync::Arc;\n     ///\n-    /// {\n-    ///     let five = Arc::new(5);\n-    ///     let weak_five = Arc::downgrade(&five);\n-    ///\n-    ///     // stuff\n+    /// struct Foo;\n     ///\n-    ///     drop(weak_five); // explicit drop\n+    /// impl Drop for Foo {\n+    ///     fn drop(&mut self) {\n+    ///         println!(\"dropped!\");\n+    ///     }\n     /// }\n-    /// {\n-    ///     let five = Arc::new(5);\n-    ///     let weak_five = Arc::downgrade(&five);\n     ///\n-    ///     // stuff\n+    /// let foo = Arc::new(Foo);\n+    /// let weak_foo = Arc::downgrade(&foo);\n+    /// let other_weak_foo = weak_foo.clone();\n     ///\n-    /// } // implicit drop\n+    /// drop(weak_foo);   // Doesn't print anything\n+    /// drop(foo);        // Prints \"dropped!\"\n+    ///\n+    /// assert!(other_weak_foo.upgrade().is_none());\n     /// ```\n     fn drop(&mut self) {\n         let ptr = *self.ptr;\n@@ -796,9 +908,9 @@ impl<T: ?Sized> Drop for Weak<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + PartialEq> PartialEq for Arc<T> {\n-    /// Equality for two `Arc<T>`s.\n+    /// Equality for two `Arc`s.\n     ///\n-    /// Two `Arc<T>`s are equal if their inner value are equal.\n+    /// Two `Arc`s are equal if their inner values are equal.\n     ///\n     /// # Examples\n     ///\n@@ -807,15 +919,15 @@ impl<T: ?Sized + PartialEq> PartialEq for Arc<T> {\n     ///\n     /// let five = Arc::new(5);\n     ///\n-    /// five == Arc::new(5);\n+    /// assert!(five == Arc::new(5));\n     /// ```\n     fn eq(&self, other: &Arc<T>) -> bool {\n         *(*self) == *(*other)\n     }\n \n-    /// Inequality for two `Arc<T>`s.\n+    /// Inequality for two `Arc`s.\n     ///\n-    /// Two `Arc<T>`s are unequal if their inner value are unequal.\n+    /// Two `Arc`s are unequal if their inner values are unequal.\n     ///\n     /// # Examples\n     ///\n@@ -824,32 +936,33 @@ impl<T: ?Sized + PartialEq> PartialEq for Arc<T> {\n     ///\n     /// let five = Arc::new(5);\n     ///\n-    /// five != Arc::new(5);\n+    /// assert!(five != Arc::new(6));\n     /// ```\n     fn ne(&self, other: &Arc<T>) -> bool {\n         *(*self) != *(*other)\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + PartialOrd> PartialOrd for Arc<T> {\n-    /// Partial comparison for two `Arc<T>`s.\n+    /// Partial comparison for two `Arc`s.\n     ///\n     /// The two are compared by calling `partial_cmp()` on their inner values.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::sync::Arc;\n+    /// use std::cmp::Ordering;\n     ///\n     /// let five = Arc::new(5);\n     ///\n-    /// five.partial_cmp(&Arc::new(5));\n+    /// assert_eq!(Some(Ordering::Less), five.partial_cmp(&Arc::new(6)));\n     /// ```\n     fn partial_cmp(&self, other: &Arc<T>) -> Option<Ordering> {\n         (**self).partial_cmp(&**other)\n     }\n \n-    /// Less-than comparison for two `Arc<T>`s.\n+    /// Less-than comparison for two `Arc`s.\n     ///\n     /// The two are compared by calling `<` on their inner values.\n     ///\n@@ -860,13 +973,13 @@ impl<T: ?Sized + PartialOrd> PartialOrd for Arc<T> {\n     ///\n     /// let five = Arc::new(5);\n     ///\n-    /// five < Arc::new(5);\n+    /// assert!(five < Arc::new(6));\n     /// ```\n     fn lt(&self, other: &Arc<T>) -> bool {\n         *(*self) < *(*other)\n     }\n \n-    /// 'Less-than or equal to' comparison for two `Arc<T>`s.\n+    /// 'Less than or equal to' comparison for two `Arc`s.\n     ///\n     /// The two are compared by calling `<=` on their inner values.\n     ///\n@@ -877,13 +990,13 @@ impl<T: ?Sized + PartialOrd> PartialOrd for Arc<T> {\n     ///\n     /// let five = Arc::new(5);\n     ///\n-    /// five <= Arc::new(5);\n+    /// assert!(five <= Arc::new(5));\n     /// ```\n     fn le(&self, other: &Arc<T>) -> bool {\n         *(*self) <= *(*other)\n     }\n \n-    /// Greater-than comparison for two `Arc<T>`s.\n+    /// Greater-than comparison for two `Arc`s.\n     ///\n     /// The two are compared by calling `>` on their inner values.\n     ///\n@@ -894,13 +1007,13 @@ impl<T: ?Sized + PartialOrd> PartialOrd for Arc<T> {\n     ///\n     /// let five = Arc::new(5);\n     ///\n-    /// five > Arc::new(5);\n+    /// assert!(five > Arc::new(4));\n     /// ```\n     fn gt(&self, other: &Arc<T>) -> bool {\n         *(*self) > *(*other)\n     }\n \n-    /// 'Greater-than or equal to' comparison for two `Arc<T>`s.\n+    /// 'Greater than or equal to' comparison for two `Arc`s.\n     ///\n     /// The two are compared by calling `>=` on their inner values.\n     ///\n@@ -911,14 +1024,28 @@ impl<T: ?Sized + PartialOrd> PartialOrd for Arc<T> {\n     ///\n     /// let five = Arc::new(5);\n     ///\n-    /// five >= Arc::new(5);\n+    /// assert!(five >= Arc::new(5));\n     /// ```\n     fn ge(&self, other: &Arc<T>) -> bool {\n         *(*self) >= *(*other)\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + Ord> Ord for Arc<T> {\n+    /// Comparison for two `Arc`s.\n+    ///\n+    /// The two are compared by calling `cmp()` on their inner values.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    /// use std::cmp::Ordering;\n+    ///\n+    /// let five = Arc::new(5);\n+    ///\n+    /// assert_eq!(Ordering::Less, five.cmp(&Arc::new(6)));\n+    /// ```\n     fn cmp(&self, other: &Arc<T>) -> Ordering {\n         (**self).cmp(&**other)\n     }\n@@ -949,7 +1076,16 @@ impl<T: ?Sized> fmt::Pointer for Arc<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Default> Default for Arc<T> {\n-    /// Creates a new `Arc<T>`, with the `Default` value for T.\n+    /// Creates a new `Arc<T>`, with the `Default` value for `T`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// let x: Arc<i32> = Default::default();\n+    /// assert_eq!(*x, 0);\n+    /// ```\n     fn default() -> Arc<T> {\n         Arc::new(Default::default())\n     }"}, {"sha": "699f777138d0024c5914adfd9484d6691f399193", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c75001b2af7b7afab13850eaad0f83562d5d8195/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c75001b2af7b7afab13850eaad0f83562d5d8195/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=c75001b2af7b7afab13850eaad0f83562d5d8195", "patch": "@@ -12,12 +12,12 @@\n \n //! Single-threaded reference-counting pointers.\n //!\n-//! The type [`Rc<T>`][rc] provides shared ownership of a value, allocated\n-//! in the heap. Invoking [`clone`][clone] on `Rc` produces a new pointer\n-//! to the same value in the heap. When the last `Rc` pointer to a given\n-//! value is destroyed, the pointed-to value is also destroyed.\n+//! The type [`Rc<T>`][rc] provides shared ownership of a value of type `T`,\n+//! allocated in the heap. Invoking [`clone`][clone] on `Rc` produces a new\n+//! pointer to the same value in the heap. When the last `Rc` pointer to a\n+//! given value is destroyed, the pointed-to value is also destroyed.\n //!\n-//! Shared pointers in Rust disallow mutation by default, and `Rc` is no\n+//! Shared references in Rust disallow mutation by default, and `Rc` is no\n //! exception. If you need to mutate through an `Rc`, use [`Cell`][cell] or\n //! [`RefCell`][refcell].\n //!\n@@ -44,8 +44,9 @@\n //! functions][assoc], called using function-like syntax:\n //!\n //! ```\n-//! # use std::rc::Rc;\n-//! # let my_rc = Rc::new(());\n+//! use std::rc::Rc;\n+//! let my_rc = Rc::new(());\n+//!\n //! Rc::downgrade(&my_rc);\n //! ```\n //!\n@@ -294,10 +295,13 @@ impl<T> Rc<T> {\n \n     /// Returns the contained value, if the `Rc` has exactly one strong reference.\n     ///\n-    /// Otherwise, an `Err` is returned with the same `Rc` that was passed in.\n+    /// Otherwise, an [`Err`][result] is returned with the same `Rc` that was\n+    /// passed in.\n     ///\n     /// This will succeed even if there are outstanding weak references.\n     ///\n+    /// [result]: ../../std/result/enum.Result.html\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -331,7 +335,11 @@ impl<T> Rc<T> {\n         }\n     }\n \n-    /// Checks whether `Rc::try_unwrap` would return `Ok`.\n+    /// Checks whether [`Rc::try_unwrap`][try_unwrap] would return\n+    /// [`Ok`][result].\n+    ///\n+    /// [try_unwrap]: struct.Rc.html#method.try_unwrap\n+    /// [result]: ../../std/result/enum.Result.html\n     ///\n     /// # Examples\n     ///\n@@ -582,8 +590,10 @@ impl<T: ?Sized> Drop for Rc<T> {\n     /// Drops the `Rc`.\n     ///\n     /// This will decrement the strong reference count. If the strong reference\n-    /// count reaches zero then the only other references (if any) are `Weak`,\n-    /// so we `drop` the inner value.\n+    /// count reaches zero then the only other references (if any) are\n+    /// [`Weak`][weak], so we `drop` the inner value.\n+    ///\n+    /// [weak]: struct.Weak.html\n     ///\n     /// # Examples\n     ///"}]}