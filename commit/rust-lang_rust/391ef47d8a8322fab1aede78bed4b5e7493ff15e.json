{"sha": "391ef47d8a8322fab1aede78bed4b5e7493ff15e", "node_id": "C_kwDOAAsO6NoAKDM5MWVmNDdkOGE4MzIyZmFiMWFlZGU3OGJlZDRiNWU3NDkzZmYxNWU", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-03-09T20:15:10Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-03-10T19:22:58Z"}, "message": "Simplify typeck entry.", "tree": {"sha": "450842a5790449d2a792ec2c64f582a7b6c05868", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/450842a5790449d2a792ec2c64f582a7b6c05868"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/391ef47d8a8322fab1aede78bed4b5e7493ff15e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/391ef47d8a8322fab1aede78bed4b5e7493ff15e", "html_url": "https://github.com/rust-lang/rust/commit/391ef47d8a8322fab1aede78bed4b5e7493ff15e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/391ef47d8a8322fab1aede78bed4b5e7493ff15e/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "83da9a89d8316c76dd6262c6aa10b74e549308bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/83da9a89d8316c76dd6262c6aa10b74e549308bd", "html_url": "https://github.com/rust-lang/rust/commit/83da9a89d8316c76dd6262c6aa10b74e549308bd"}], "stats": {"total": 97, "additions": 46, "deletions": 51}, "files": [{"sha": "70124a77364063cabdc588366b36135f1a7204ed", "filename": "compiler/rustc_hir_typeck/src/lib.rs", "status": "modified", "additions": 46, "deletions": 51, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/391ef47d8a8322fab1aede78bed4b5e7493ff15e/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/391ef47d8a8322fab1aede78bed4b5e7493ff15e/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs?ref=391ef47d8a8322fab1aede78bed4b5e7493ff15e", "patch": "@@ -106,10 +106,9 @@ pub struct LocalTy<'tcx> {\n /// (notably closures), `typeck_results(def_id)` would wind up\n /// redirecting to the owning function.\n fn primary_body_of(\n-    tcx: TyCtxt<'_>,\n-    id: hir::HirId,\n+    node: Node<'_>,\n ) -> Option<(hir::BodyId, Option<&hir::Ty<'_>>, Option<&hir::FnSig<'_>>)> {\n-    match tcx.hir().get(id) {\n+    match node {\n         Node::Item(item) => match item.kind {\n             hir::ItemKind::Const(ty, body) | hir::ItemKind::Static(ty, _, body) => {\n                 Some((body, Some(ty), None))\n@@ -143,8 +142,7 @@ fn has_typeck_results(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     }\n \n     if let Some(def_id) = def_id.as_local() {\n-        let id = tcx.hir().local_def_id_to_hir_id(def_id);\n-        primary_body_of(tcx, id).is_some()\n+        primary_body_of(tcx.hir().get_by_def_id(def_id)).is_some()\n     } else {\n         false\n     }\n@@ -199,10 +197,11 @@ fn typeck_with_fallback<'tcx>(\n     }\n \n     let id = tcx.hir().local_def_id_to_hir_id(def_id);\n+    let node = tcx.hir().get(id);\n     let span = tcx.hir().span(id);\n \n     // Figure out what primary body this item has.\n-    let (body_id, body_ty, fn_sig) = primary_body_of(tcx, id).unwrap_or_else(|| {\n+    let (body_id, body_ty, fn_sig) = primary_body_of(node).unwrap_or_else(|| {\n         span_bug!(span, \"can't type-check body of {:?}\", def_id);\n     });\n     let body = tcx.hir().body(body_id);\n@@ -231,53 +230,49 @@ fn typeck_with_fallback<'tcx>(\n \n         check_fn(&mut fcx, fn_sig, decl, def_id, body, None);\n     } else {\n-        let expected_type = body_ty\n-            .and_then(|ty| match ty.kind {\n-                hir::TyKind::Infer => Some(fcx.astconv().ast_ty_to_ty(ty)),\n-                _ => None,\n-            })\n-            .unwrap_or_else(|| match tcx.hir().get(id) {\n-                Node::AnonConst(_) => match tcx.hir().get(tcx.hir().parent_id(id)) {\n-                    Node::Expr(&hir::Expr {\n-                        kind: hir::ExprKind::ConstBlock(ref anon_const),\n-                        ..\n-                    }) if anon_const.hir_id == id => fcx.next_ty_var(TypeVariableOrigin {\n+        let expected_type = if let Some(&hir::Ty { kind: hir::TyKind::Infer, span, .. }) = body_ty {\n+            Some(fcx.next_ty_var(TypeVariableOrigin {\n+                kind: TypeVariableOriginKind::TypeInference,\n+                span,\n+            }))\n+        } else if let Node::AnonConst(_) = node {\n+            match tcx.hir().get(tcx.hir().parent_id(id)) {\n+                Node::Expr(&hir::Expr {\n+                    kind: hir::ExprKind::ConstBlock(ref anon_const), ..\n+                }) if anon_const.hir_id == id => Some(fcx.next_ty_var(TypeVariableOrigin {\n+                    kind: TypeVariableOriginKind::TypeInference,\n+                    span,\n+                })),\n+                Node::Ty(&hir::Ty { kind: hir::TyKind::Typeof(ref anon_const), .. })\n+                    if anon_const.hir_id == id =>\n+                {\n+                    Some(fcx.next_ty_var(TypeVariableOrigin {\n                         kind: TypeVariableOriginKind::TypeInference,\n                         span,\n-                    }),\n-                    Node::Ty(&hir::Ty { kind: hir::TyKind::Typeof(ref anon_const), .. })\n-                        if anon_const.hir_id == id =>\n-                    {\n-                        fcx.next_ty_var(TypeVariableOrigin {\n-                            kind: TypeVariableOriginKind::TypeInference,\n-                            span,\n-                        })\n-                    }\n-                    Node::Expr(&hir::Expr { kind: hir::ExprKind::InlineAsm(asm), .. })\n-                    | Node::Item(&hir::Item { kind: hir::ItemKind::GlobalAsm(asm), .. }) => {\n-                        let operand_ty = asm.operands.iter().find_map(|(op, _op_sp)| match op {\n-                            hir::InlineAsmOperand::Const { anon_const }\n-                                if anon_const.hir_id == id =>\n-                            {\n-                                // Inline assembly constants must be integers.\n-                                Some(fcx.next_int_var())\n-                            }\n-                            hir::InlineAsmOperand::SymFn { anon_const }\n-                                if anon_const.hir_id == id =>\n-                            {\n-                                Some(fcx.next_ty_var(TypeVariableOrigin {\n-                                    kind: TypeVariableOriginKind::MiscVariable,\n-                                    span,\n-                                }))\n-                            }\n-                            _ => None,\n-                        });\n-                        operand_ty.unwrap_or_else(fallback)\n-                    }\n-                    _ => fallback(),\n-                },\n-                _ => fallback(),\n-            });\n+                    }))\n+                }\n+                Node::Expr(&hir::Expr { kind: hir::ExprKind::InlineAsm(asm), .. })\n+                | Node::Item(&hir::Item { kind: hir::ItemKind::GlobalAsm(asm), .. }) => {\n+                    asm.operands.iter().find_map(|(op, _op_sp)| match op {\n+                        hir::InlineAsmOperand::Const { anon_const } if anon_const.hir_id == id => {\n+                            // Inline assembly constants must be integers.\n+                            Some(fcx.next_int_var())\n+                        }\n+                        hir::InlineAsmOperand::SymFn { anon_const } if anon_const.hir_id == id => {\n+                            Some(fcx.next_ty_var(TypeVariableOrigin {\n+                                kind: TypeVariableOriginKind::MiscVariable,\n+                                span,\n+                            }))\n+                        }\n+                        _ => None,\n+                    })\n+                }\n+                _ => None,\n+            }\n+        } else {\n+            None\n+        };\n+        let expected_type = expected_type.unwrap_or_else(fallback);\n \n         let expected_type = fcx.normalize(body.value.span, expected_type);\n         fcx.require_type_is_sized(expected_type, body.value.span, traits::ConstSized);"}]}