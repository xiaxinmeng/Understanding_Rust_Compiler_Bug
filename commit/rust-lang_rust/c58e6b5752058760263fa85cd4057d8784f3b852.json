{"sha": "c58e6b5752058760263fa85cd4057d8784f3b852", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1OGU2YjU3NTIwNTg3NjAyNjNmYTg1Y2Q0MDU3ZDg3ODRmM2I4NTI=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-09-13T07:28:14Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-10-31T18:00:16Z"}, "message": "rustc_codegen_ssa: move local variable debuginfo to mir::debuginfo.", "tree": {"sha": "a4683091ac6bd55c6137d5fe2ce7c4ff5f594b83", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a4683091ac6bd55c6137d5fe2ce7c4ff5f594b83"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c58e6b5752058760263fa85cd4057d8784f3b852", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c58e6b5752058760263fa85cd4057d8784f3b852", "html_url": "https://github.com/rust-lang/rust/commit/c58e6b5752058760263fa85cd4057d8784f3b852", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c58e6b5752058760263fa85cd4057d8784f3b852/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5059a3c7d4afd00458d5bd2f033a0b9c91bd8bf8", "url": "https://api.github.com/repos/rust-lang/rust/commits/5059a3c7d4afd00458d5bd2f033a0b9c91bd8bf8", "html_url": "https://github.com/rust-lang/rust/commit/5059a3c7d4afd00458d5bd2f033a0b9c91bd8bf8"}], "stats": {"total": 468, "additions": 227, "deletions": 241}, "files": [{"sha": "2e5dc3db31af90c89ef94eecb8f408a655ecfbd4", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c58e6b5752058760263fa85cd4057d8784f3b852/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c58e6b5752058760263fa85cd4057d8784f3b852/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=c58e6b5752058760263fa85cd4057d8784f3b852", "patch": "@@ -7,6 +7,7 @@ use rustc_index::vec::{Idx, IndexVec};\n use rustc::mir::{self, Location, TerminatorKind};\n use rustc::mir::visit::{Visitor, PlaceContext, MutatingUseContext, NonMutatingUseContext};\n use rustc::mir::traversal;\n+use rustc::session::config::DebugInfo;\n use rustc::ty;\n use rustc::ty::layout::{LayoutOf, HasTyCtxt};\n use syntax_pos::DUMMY_SP;\n@@ -21,13 +22,20 @@ pub fn non_ssa_locals<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n \n     analyzer.visit_body(mir);\n \n-    for (index, (ty, span)) in mir.local_decls.iter()\n-        .map(|l| (l.ty, l.source_info.span))\n-        .enumerate()\n+    for (local, decl) in mir.local_decls.iter_enumerated()\n     {\n-        let ty = fx.monomorphize(&ty);\n-        debug!(\"local {} has type {:?}\", index, ty);\n-        let layout = fx.cx.spanned_layout_of(ty, span);\n+        // FIXME(eddyb): We should figure out how to use llvm.dbg.value instead\n+        // of putting everything in allocas just so we can use llvm.dbg.declare.\n+        if fx.cx.sess().opts.debuginfo == DebugInfo::Full {\n+            if mir.local_kind(local) == mir::LocalKind::Arg || decl.name.is_some() {\n+                analyzer.not_ssa(local);\n+                continue;\n+            }\n+        }\n+\n+        let ty = fx.monomorphize(&decl.ty);\n+        debug!(\"local {:?} has type `{}`\", local, ty);\n+        let layout = fx.cx.spanned_layout_of(ty, decl.source_info.span);\n         if fx.cx.is_backend_immediate(layout) {\n             // These sorts of types are immediates that we can store\n             // in an Value without an alloca.\n@@ -40,7 +48,7 @@ pub fn non_ssa_locals<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             // (e.g., structs) into an alloca unconditionally, just so\n             // that we don't have to deal with having two pathways\n             // (gep vs extractvalue etc).\n-            analyzer.not_ssa(mir::Local::new(index));\n+            analyzer.not_ssa(local);\n         }\n     }\n "}, {"sha": "d6b91c1f6bbb8b0518776107b3878a7dddfe3108", "filename": "src/librustc_codegen_ssa/mir/debuginfo.rs", "status": "modified", "additions": 178, "deletions": 1, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/c58e6b5752058760263fa85cd4057d8784f3b852/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c58e6b5752058760263fa85cd4057d8784f3b852/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs?ref=c58e6b5752058760263fa85cd4057d8784f3b852", "patch": "@@ -1,10 +1,16 @@\n+use rustc_index::vec::Idx;\n use rustc::hir::def_id::CrateNum;\n use rustc::mir;\n+use rustc::session::config::DebugInfo;\n+use rustc::ty::{self, UpvarSubsts};\n+use rustc::ty::layout::HasTyCtxt;\n+use rustc_target::abi::{Variants, VariantIdx};\n use crate::traits::*;\n \n use syntax_pos::{DUMMY_SP, BytePos, Span};\n+use syntax::symbol::kw;\n \n-use super::FunctionCx;\n+use super::{FunctionCx, LocalRef};\n \n pub enum FunctionDebugContext<D> {\n     RegularContext(FunctionDebugContextData<D>),\n@@ -142,4 +148,175 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             scope_metadata\n         }\n     }\n+\n+    pub fn debug_declare_locals(&self, bx: &mut Bx) {\n+        let tcx = self.cx.tcx();\n+        let upvar_debuginfo = &self.mir.__upvar_debuginfo_codegen_only_do_not_use;\n+\n+        if bx.sess().opts.debuginfo != DebugInfo::Full {\n+            return;\n+        }\n+\n+        for (local, local_ref) in self.locals.iter_enumerated() {\n+            if local == mir::RETURN_PLACE {\n+                continue;\n+            }\n+\n+            // FIXME(eddyb) add debuginfo for unsized places too.\n+            let place = match local_ref {\n+                LocalRef::Place(place) => place,\n+                _ => continue,\n+            };\n+\n+            let decl = &self.mir.local_decls[local];\n+            let (name, kind) = if self.mir.local_kind(local) == mir::LocalKind::Arg {\n+                let arg_index = local.index() - 1;\n+\n+                // Add debuginfo even to unnamed arguments.\n+                // FIXME(eddyb) is this really needed?\n+                let name = if arg_index == 0 && !upvar_debuginfo.is_empty() {\n+                    // Hide closure environments from debuginfo.\n+                    // FIXME(eddyb) shouldn't `ArgumentVariable` indices\n+                    // be offset to account for the hidden environment?\n+                    None\n+                } else {\n+                    Some(decl.name.unwrap_or(kw::Invalid))\n+                };\n+                (name, VariableKind::ArgumentVariable(arg_index + 1))\n+            } else {\n+                (decl.name, VariableKind::LocalVariable)\n+            };\n+            if let Some(name) = name {\n+                let (scope, span) = self.debug_loc(mir::SourceInfo {\n+                    span: decl.source_info.span,\n+                    scope: decl.visibility_scope,\n+                });\n+                if let Some(scope) = scope {\n+                    bx.declare_local(&self.debug_context, name, place.layout.ty, scope,\n+                        VariableAccess::DirectVariable { alloca: place.llval },\n+                        kind, span);\n+                }\n+            }\n+        }\n+\n+        // Declare closure captures as if they were local variables.\n+        // FIXME(eddyb) generalize this to `name => place` mappings.\n+        let upvar_scope = if !upvar_debuginfo.is_empty() {\n+            self.scopes[mir::OUTERMOST_SOURCE_SCOPE].scope_metadata\n+        } else {\n+            None\n+        };\n+        if let Some(scope) = upvar_scope {\n+            let place = match self.locals[mir::Local::new(1)] {\n+                LocalRef::Place(place) => place,\n+                _ => bug!(),\n+            };\n+\n+            let pin_did = tcx.lang_items().pin_type();\n+            let (closure_layout, env_ref) = match place.layout.ty.kind {\n+                ty::RawPtr(ty::TypeAndMut { ty, .. }) |\n+                ty::Ref(_, ty, _)  => (bx.layout_of(ty), true),\n+                ty::Adt(def, substs) if Some(def.did) == pin_did => {\n+                    match substs.type_at(0).kind {\n+                        ty::Ref(_, ty, _)  => (bx.layout_of(ty), true),\n+                        _ => (place.layout, false),\n+                    }\n+                }\n+                _ => (place.layout, false)\n+            };\n+\n+            let (def_id, upvar_substs) = match closure_layout.ty.kind {\n+                ty::Closure(def_id, substs) => (def_id, UpvarSubsts::Closure(substs)),\n+                ty::Generator(def_id, substs, _) => (def_id, UpvarSubsts::Generator(substs)),\n+                _ => bug!(\"upvar debuginfo with non-closure arg0 type `{}`\", closure_layout.ty)\n+            };\n+            let upvar_tys = upvar_substs.upvar_tys(def_id, tcx);\n+\n+            let extra_locals = {\n+                let upvars = upvar_debuginfo\n+                    .iter()\n+                    .zip(upvar_tys)\n+                    .enumerate()\n+                    .map(|(i, (upvar, ty))| {\n+                        (None, i, upvar.debug_name, upvar.by_ref, ty, scope, DUMMY_SP)\n+                    });\n+\n+                let generator_fields = self.mir.generator_layout.as_ref().map(|generator_layout| {\n+                    let (def_id, gen_substs) = match closure_layout.ty.kind {\n+                        ty::Generator(def_id, substs, _) => (def_id, substs),\n+                        _ => bug!(\"generator layout without generator substs\"),\n+                    };\n+                    let state_tys = gen_substs.as_generator().state_tys(def_id, tcx);\n+\n+                    generator_layout.variant_fields.iter()\n+                        .zip(state_tys)\n+                        .enumerate()\n+                        .flat_map(move |(variant_idx, (fields, tys))| {\n+                            let variant_idx = Some(VariantIdx::from(variant_idx));\n+                            fields.iter()\n+                                .zip(tys)\n+                                .enumerate()\n+                                .filter_map(move |(i, (field, ty))| {\n+                                    let decl = &generator_layout.\n+                                        __local_debuginfo_codegen_only_do_not_use[*field];\n+                                    if let Some(name) = decl.name {\n+                                        let ty = self.monomorphize(&ty);\n+                                        let (var_scope, var_span) = self.debug_loc(mir::SourceInfo {\n+                                            span: decl.source_info.span,\n+                                            scope: decl.visibility_scope,\n+                                        });\n+                                        let var_scope = var_scope.unwrap_or(scope);\n+                                        Some((variant_idx, i, name, false, ty, var_scope, var_span))\n+                                    } else {\n+                                        None\n+                                    }\n+                            })\n+                        })\n+                }).into_iter().flatten();\n+\n+                upvars.chain(generator_fields)\n+            };\n+\n+            for (variant_idx, field, name, by_ref, ty, var_scope, var_span) in extra_locals {\n+                let fields = match variant_idx {\n+                    Some(variant_idx) => {\n+                        match &closure_layout.variants {\n+                            Variants::Multiple { variants, .. } => {\n+                                &variants[variant_idx].fields\n+                            },\n+                            _ => bug!(\"variant index on univariant layout\"),\n+                        }\n+                    }\n+                    None => &closure_layout.fields,\n+                };\n+                let byte_offset_of_var_in_env = fields.offset(field).bytes();\n+\n+                let ops = bx.debuginfo_upvar_ops_sequence(byte_offset_of_var_in_env);\n+\n+                // The environment and the capture can each be indirect.\n+                let mut ops = if env_ref { &ops[..] } else { &ops[1..] };\n+\n+                let ty = if let (true, &ty::Ref(_, ty, _)) = (by_ref, &ty.kind) {\n+                    ty\n+                } else {\n+                    ops = &ops[..ops.len() - 1];\n+                    ty\n+                };\n+\n+                let variable_access = VariableAccess::IndirectVariable {\n+                    alloca: place.llval,\n+                    address_operations: &ops\n+                };\n+                bx.declare_local(\n+                    &self.debug_context,\n+                    name,\n+                    ty,\n+                    var_scope,\n+                    variable_access,\n+                    VariableKind::LocalVariable,\n+                    var_span\n+                );\n+            }\n+        }\n+    }\n }"}, {"sha": "8e9e21393738f2cf6b67eaf038a391eb32b5324f", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 30, "deletions": 233, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/c58e6b5752058760263fa85cd4057d8784f3b852/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c58e6b5752058760263fa85cd4057d8784f3b852/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=c58e6b5752058760263fa85cd4057d8784f3b852", "patch": "@@ -1,22 +1,17 @@\n-use rustc::ty::{self, Ty, TypeFoldable, UpvarSubsts, Instance};\n+use rustc::ty::{self, Ty, TypeFoldable, Instance};\n use rustc::ty::layout::{TyLayout, HasTyCtxt, FnTypeExt};\n use rustc::mir::{self, Body};\n-use rustc::session::config::DebugInfo;\n use rustc_target::abi::call::{FnType, PassMode};\n-use rustc_target::abi::{Variants, VariantIdx};\n use crate::base;\n use crate::traits::*;\n \n-use syntax_pos::DUMMY_SP;\n-use syntax::symbol::kw;\n-\n use std::iter;\n \n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n \n use self::analyze::CleanupKind;\n-use self::debuginfo::{VariableAccess, VariableKind, FunctionDebugContext};\n+use self::debuginfo::FunctionDebugContext;\n use self::place::PlaceRef;\n use rustc::mir::traversal;\n \n@@ -189,62 +184,38 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             let layout = bx.layout_of(fx.monomorphize(&decl.ty));\n             assert!(!layout.ty.has_erasable_regions());\n \n-            if let Some(name) = decl.name {\n-                // User variable\n-                let debug_scope = fx.scopes[decl.visibility_scope];\n-                let dbg = debug_scope.is_valid() &&\n-                    bx.sess().opts.debuginfo == DebugInfo::Full;\n+            if local == mir::RETURN_PLACE && fx.fn_ty.ret.is_indirect() {\n+                debug!(\"alloc: {:?} (return place) -> place\", local);\n+                let llretptr = bx.get_param(0);\n+                return LocalRef::Place(PlaceRef::new_sized(llretptr, layout));\n+            }\n \n-                if !memory_locals.contains(local) && !dbg {\n-                    debug!(\"alloc: {:?} ({}) -> operand\", local, name);\n-                    return LocalRef::new_operand(&mut bx, layout);\n-                }\n+            let decl_name = decl.name.map(|name| name.as_str());\n+            let decl_name = decl_name.as_ref().map(|name| &name[..]);\n+            let name;\n+            let name = if let Some(name) = decl_name {\n+                name\n+            } else {\n+                // FIXME(eddyb) compute something else for the name so no work is done\n+                // unless LLVM IR names are turned on (e.g. for `--emit=llvm-ir`).\n+                name = format!(\"{:?}\", local);\n+                &name\n+            };\n \n+            if memory_locals.contains(local) {\n                 debug!(\"alloc: {:?} ({}) -> place\", local, name);\n                 if layout.is_unsized() {\n-                    let indirect_place =\n-                        PlaceRef::alloca_unsized_indirect(&mut bx, layout);\n+                    let indirect_place = PlaceRef::alloca_unsized_indirect(&mut bx, layout);\n                     bx.set_var_name(indirect_place.llval, name);\n-                    // FIXME: add an appropriate debuginfo\n                     LocalRef::UnsizedPlace(indirect_place)\n                 } else {\n                     let place = PlaceRef::alloca(&mut bx, layout);\n                     bx.set_var_name(place.llval, name);\n-                    if dbg {\n-                        let (scope, span) = fx.debug_loc(mir::SourceInfo {\n-                            span: decl.source_info.span,\n-                            scope: decl.visibility_scope,\n-                        });\n-                        bx.declare_local(&fx.debug_context, name, layout.ty, scope.unwrap(),\n-                            VariableAccess::DirectVariable { alloca: place.llval },\n-                            VariableKind::LocalVariable, span);\n-                    }\n                     LocalRef::Place(place)\n                 }\n             } else {\n-                // Temporary or return place\n-                if local == mir::RETURN_PLACE && fx.fn_ty.ret.is_indirect() {\n-                    debug!(\"alloc: {:?} (return place) -> place\", local);\n-                    let llretptr = bx.get_param(0);\n-                    LocalRef::Place(PlaceRef::new_sized(llretptr, layout))\n-                } else if memory_locals.contains(local) {\n-                    debug!(\"alloc: {:?} -> place\", local);\n-                    if layout.is_unsized() {\n-                        let indirect_place = PlaceRef::alloca_unsized_indirect(&mut bx, layout);\n-                        bx.set_var_name(indirect_place.llval, format_args!(\"{:?}\", local));\n-                        LocalRef::UnsizedPlace(indirect_place)\n-                    } else {\n-                        let place = PlaceRef::alloca(&mut bx, layout);\n-                        bx.set_var_name(place.llval, format_args!(\"{:?}\", local));\n-                        LocalRef::Place(place)\n-                    }\n-                } else {\n-                    // If this is an immediate local, we do not create an\n-                    // alloca in advance. Instead we wait until we see the\n-                    // definition and update the operand there.\n-                    debug!(\"alloc: {:?} -> operand\", local);\n-                    LocalRef::new_operand(&mut bx, layout)\n-                }\n+                debug!(\"alloc: {:?} ({}) -> operand\", local, name);\n+                LocalRef::new_operand(&mut bx, layout)\n             }\n         };\n \n@@ -255,6 +226,9 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             .collect()\n     };\n \n+    // Apply debuginfo to the newly allocated locals.\n+    fx.debug_declare_locals(&mut bx);\n+\n     // Branch to the START block, if it's not the entry block.\n     if reentrant_start_block {\n         bx.br(fx.blocks[mir::START_BLOCK]);\n@@ -363,18 +337,9 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     memory_locals: &BitSet<mir::Local>,\n ) -> Vec<LocalRef<'tcx, Bx::Value>> {\n     let mir = fx.mir;\n-    let tcx = fx.cx.tcx();\n     let mut idx = 0;\n     let mut llarg_idx = fx.fn_ty.ret.is_indirect() as usize;\n \n-    // Get the argument scope, if it exists and if we need it.\n-    let arg_scope = fx.scopes[mir::OUTERMOST_SOURCE_SCOPE];\n-    let arg_scope = if bx.sess().opts.debuginfo == DebugInfo::Full {\n-        arg_scope.scope_metadata\n-    } else {\n-        None\n-    };\n-\n     mir.args_iter().enumerate().map(|(arg_index, local)| {\n         let arg_decl = &mir.local_decls[local];\n \n@@ -409,22 +374,6 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                 bx.store_fn_arg(arg, &mut llarg_idx, pr_field);\n             }\n \n-            // Now that we have one alloca that contains the aggregate value,\n-            // we can create one debuginfo entry for the argument.\n-            arg_scope.map(|scope| {\n-                let variable_access = VariableAccess::DirectVariable {\n-                    alloca: place.llval\n-                };\n-                bx.declare_local(\n-                    &fx.debug_context,\n-                    arg_decl.name.unwrap_or(kw::Invalid),\n-                    arg_ty, scope,\n-                    variable_access,\n-                    VariableKind::ArgumentVariable(arg_index + 1),\n-                    DUMMY_SP\n-                );\n-            });\n-\n             return LocalRef::Place(place);\n         }\n \n@@ -435,21 +384,6 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             bx.set_var_name(va_list.llval, name);\n             bx.va_start(va_list.llval);\n \n-            arg_scope.map(|scope| {\n-                let variable_access = VariableAccess::DirectVariable {\n-                    alloca: va_list.llval\n-                };\n-                bx.declare_local(\n-                    &fx.debug_context,\n-                    arg_decl.name.unwrap_or(kw::Invalid),\n-                    va_list.layout.ty,\n-                    scope,\n-                    variable_access,\n-                    VariableKind::ArgumentVariable(arg_index + 1),\n-                    DUMMY_SP\n-                );\n-            });\n-\n             return LocalRef::Place(va_list);\n         }\n \n@@ -459,7 +393,7 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             llarg_idx += 1;\n         }\n \n-        if arg_scope.is_none() && !memory_locals.contains(local) {\n+        if !memory_locals.contains(local) {\n             // We don't have to cast or keep the argument in the alloca.\n             // FIXME(eddyb): We should figure out how to use llvm.dbg.value instead\n             // of putting everything in allocas just so we can use llvm.dbg.declare.\n@@ -493,14 +427,14 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             }\n         }\n \n-        let place = if arg.is_sized_indirect() {\n+        if arg.is_sized_indirect() {\n             // Don't copy an indirect argument to an alloca, the caller\n             // already put it in a temporary alloca and gave it up.\n             // FIXME: lifetimes\n             let llarg = bx.get_param(llarg_idx);\n             bx.set_var_name(llarg, &name);\n             llarg_idx += 1;\n-            PlaceRef::new_sized(llarg, arg.layout)\n+            LocalRef::Place(PlaceRef::new_sized(llarg, arg.layout))\n         } else if arg.is_unsized_indirect() {\n             // As the storage for the indirect argument lives during\n             // the whole function call, we just copy the fat pointer.\n@@ -513,149 +447,12 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             let tmp = PlaceRef::alloca_unsized_indirect(bx, arg.layout);\n             bx.set_var_name(tmp.llval, name);\n             indirect_operand.store(bx, tmp);\n-            tmp\n+            LocalRef::UnsizedPlace(tmp)\n         } else {\n             let tmp = PlaceRef::alloca(bx, arg.layout);\n             bx.set_var_name(tmp.llval, name);\n             bx.store_fn_arg(arg, &mut llarg_idx, tmp);\n-            tmp\n-        };\n-        let upvar_debuginfo = &mir.__upvar_debuginfo_codegen_only_do_not_use;\n-        arg_scope.map(|scope| {\n-            // Is this a regular argument?\n-            if arg_index > 0 || upvar_debuginfo.is_empty() {\n-                // The Rust ABI passes indirect variables using a pointer and a manual copy, so we\n-                // need to insert a deref here, but the C ABI uses a pointer and a copy using the\n-                // byval attribute, for which LLVM always does the deref itself,\n-                // so we must not add it.\n-                let variable_access = VariableAccess::DirectVariable {\n-                    alloca: place.llval\n-                };\n-\n-                bx.declare_local(\n-                    &fx.debug_context,\n-                    arg_decl.name.unwrap_or(kw::Invalid),\n-                    arg.layout.ty,\n-                    scope,\n-                    variable_access,\n-                    VariableKind::ArgumentVariable(arg_index + 1),\n-                    DUMMY_SP\n-                );\n-                return;\n-            }\n-\n-            let pin_did = tcx.lang_items().pin_type();\n-            // Or is it the closure environment?\n-            let (closure_layout, env_ref) = match arg.layout.ty.kind {\n-                ty::RawPtr(ty::TypeAndMut { ty, .. }) |\n-                ty::Ref(_, ty, _)  => (bx.layout_of(ty), true),\n-                ty::Adt(def, substs) if Some(def.did) == pin_did => {\n-                    match substs.type_at(0).kind {\n-                        ty::Ref(_, ty, _)  => (bx.layout_of(ty), true),\n-                        _ => (arg.layout, false),\n-                    }\n-                }\n-                _ => (arg.layout, false)\n-            };\n-\n-            let (def_id, upvar_substs) = match closure_layout.ty.kind {\n-                ty::Closure(def_id, substs) => (def_id,\n-                    UpvarSubsts::Closure(substs)),\n-                ty::Generator(def_id, substs, _) => (def_id, UpvarSubsts::Generator(substs)),\n-                _ => bug!(\"upvar debuginfo with non-closure arg0 type `{}`\", closure_layout.ty)\n-            };\n-            let upvar_tys = upvar_substs.upvar_tys(def_id, tcx);\n-\n-            let extra_locals = {\n-                let upvars = upvar_debuginfo\n-                    .iter()\n-                    .zip(upvar_tys)\n-                    .enumerate()\n-                    .map(|(i, (upvar, ty))| {\n-                        (None, i, upvar.debug_name, upvar.by_ref, ty, scope, DUMMY_SP)\n-                    });\n-\n-                let generator_fields = mir.generator_layout.as_ref().map(|generator_layout| {\n-                    let (def_id, gen_substs) = match closure_layout.ty.kind {\n-                        ty::Generator(def_id, substs, _) => (def_id, substs),\n-                        _ => bug!(\"generator layout without generator substs\"),\n-                    };\n-                    let state_tys = gen_substs.as_generator().state_tys(def_id, tcx);\n-\n-                    generator_layout.variant_fields.iter()\n-                        .zip(state_tys)\n-                        .enumerate()\n-                        .flat_map(move |(variant_idx, (fields, tys))| {\n-                            let variant_idx = Some(VariantIdx::from(variant_idx));\n-                            fields.iter()\n-                                .zip(tys)\n-                                .enumerate()\n-                                .filter_map(move |(i, (field, ty))| {\n-                                    let decl = &generator_layout.\n-                                        __local_debuginfo_codegen_only_do_not_use[*field];\n-                                    if let Some(name) = decl.name {\n-                                        let ty = fx.monomorphize(&ty);\n-                                        let (var_scope, var_span) = fx.debug_loc(mir::SourceInfo {\n-                                            span: decl.source_info.span,\n-                                            scope: decl.visibility_scope,\n-                                        });\n-                                        let var_scope = var_scope.unwrap_or(scope);\n-                                        Some((variant_idx, i, name, false, ty, var_scope, var_span))\n-                                    } else {\n-                                        None\n-                                    }\n-                            })\n-                        })\n-                }).into_iter().flatten();\n-\n-                upvars.chain(generator_fields)\n-            };\n-\n-            for (variant_idx, field, name, by_ref, ty, var_scope, var_span) in extra_locals {\n-                let fields = match variant_idx {\n-                    Some(variant_idx) => {\n-                        match &closure_layout.variants {\n-                            Variants::Multiple { variants, .. } => {\n-                                &variants[variant_idx].fields\n-                            },\n-                            _ => bug!(\"variant index on univariant layout\"),\n-                        }\n-                    }\n-                    None => &closure_layout.fields,\n-                };\n-                let byte_offset_of_var_in_env = fields.offset(field).bytes();\n-\n-                let ops = bx.debuginfo_upvar_ops_sequence(byte_offset_of_var_in_env);\n-\n-                // The environment and the capture can each be indirect.\n-                let mut ops = if env_ref { &ops[..] } else { &ops[1..] };\n-\n-                let ty = if let (true, &ty::Ref(_, ty, _)) = (by_ref, &ty.kind) {\n-                    ty\n-                } else {\n-                    ops = &ops[..ops.len() - 1];\n-                    ty\n-                };\n-\n-                let variable_access = VariableAccess::IndirectVariable {\n-                    alloca: place.llval,\n-                    address_operations: &ops\n-                };\n-                bx.declare_local(\n-                    &fx.debug_context,\n-                    name,\n-                    ty,\n-                    var_scope,\n-                    variable_access,\n-                    VariableKind::LocalVariable,\n-                    var_span\n-                );\n-            }\n-        });\n-        if arg.is_unsized_indirect() {\n-            LocalRef::UnsizedPlace(place)\n-        } else {\n-            LocalRef::Place(place)\n+            LocalRef::Place(tmp)\n         }\n     }).collect()\n }"}, {"sha": "3e7c4ef49fb5aeab6452dcf7aa71f43235ae3712", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c58e6b5752058760263fa85cd4057d8784f3b852/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c58e6b5752058760263fa85cd4057d8784f3b852/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=c58e6b5752058760263fa85cd4057d8784f3b852", "patch": "@@ -68,6 +68,8 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n         }\n     }\n \n+    // FIXME(eddyb) pass something else for the name so no work is done\n+    // unless LLVM IR names are turned on (e.g. for `--emit=llvm-ir`).\n     pub fn alloca<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n         bx: &mut Bx,\n         layout: TyLayout<'tcx>,\n@@ -78,6 +80,8 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n     }\n \n     /// Returns a place for an indirect reference to an unsized place.\n+    // FIXME(eddyb) pass something else for the name so no work is done\n+    // unless LLVM IR names are turned on (e.g. for `--emit=llvm-ir`).\n     pub fn alloca_unsized_indirect<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n         bx: &mut Bx,\n         layout: TyLayout<'tcx>,"}]}