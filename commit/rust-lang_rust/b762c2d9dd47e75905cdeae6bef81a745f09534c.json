{"sha": "b762c2d9dd47e75905cdeae6bef81a745f09534c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3NjJjMmQ5ZGQ0N2U3NTkwNWNkZWFlNmJlZjgxYTc0NWYwOTUzNGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-01-14T03:27:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-01-14T03:27:35Z"}, "message": "Auto merge of #47223 - alexcrichton:new-target-feature, r=eddyb\n\nrustc: Tweak `#[target_feature]` syntax\n\nThis is an implementation of the `#[target_feature]` syntax-related changes of\n[RFC 2045][rfc]. Notably two changes have been implemented:\n\n* The new syntax is `#[target_feature(enable = \"..\")]` instead of\n  `#[target_feature = \"+..\"]`. The `enable` key is necessary instead of the `+`\n  to indicate that a feature is being enabled, and a sub-list is used for\n  possible expansion in the future. Additionally within this syntax the feature\n  names being enabled are now whitelisted against a known set of target feature\n  names that we know about.\n\n* The `#[target_feature]` attribute can only be applied to unsafe functions. It\n  was decided in the RFC that invoking an instruction possibly not defined for\n  the current processor is undefined behavior, so to enable this feature for now\n  it requires an `unsafe` intervention.\n\n[rfc]: https://github.com/rust-lang/rfcs/blob/master/text/2045-target-feature.md", "tree": {"sha": "39f62b3eebe164cc663973d8857b62531670e2ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39f62b3eebe164cc663973d8857b62531670e2ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b762c2d9dd47e75905cdeae6bef81a745f09534c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b762c2d9dd47e75905cdeae6bef81a745f09534c", "html_url": "https://github.com/rust-lang/rust/commit/b762c2d9dd47e75905cdeae6bef81a745f09534c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b762c2d9dd47e75905cdeae6bef81a745f09534c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "80e2e67f4c6fbbef5e4789df7fc96804e6a84196", "url": "https://api.github.com/repos/rust-lang/rust/commits/80e2e67f4c6fbbef5e4789df7fc96804e6a84196", "html_url": "https://github.com/rust-lang/rust/commit/80e2e67f4c6fbbef5e4789df7fc96804e6a84196"}, {"sha": "0ecaa67e9082b609bd8fd315b6cc41be7e8ee139", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ecaa67e9082b609bd8fd315b6cc41be7e8ee139", "html_url": "https://github.com/rust-lang/rust/commit/0ecaa67e9082b609bd8fd315b6cc41be7e8ee139"}], "stats": {"total": 323, "additions": 262, "deletions": 61}, "files": [{"sha": "14f54fbffac2e392c94e74680112c474d16d7b3f", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b762c2d9dd47e75905cdeae6bef81a745f09534c/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b762c2d9dd47e75905cdeae6bef81a745f09534c/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=b762c2d9dd47e75905cdeae6bef81a745f09534c", "patch": "@@ -634,6 +634,10 @@ define_dep_nodes!( <'tcx>\n     [] Null,\n \n     [] SubstituteNormalizeAndTestPredicates { key: (DefId, &'tcx Substs<'tcx>) },\n+\n+    [input] TargetFeaturesWhitelist,\n+    [] TargetFeaturesEnabled(DefId),\n+\n );\n \n trait DepNodeParams<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> : fmt::Debug {"}, {"sha": "4b528a0fdc7781c1c55dfa57f6858608bf241b66", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 38, "deletions": 28, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/b762c2d9dd47e75905cdeae6bef81a745f09534c/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b762c2d9dd47e75905cdeae6bef81a745f09534c/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=b762c2d9dd47e75905cdeae6bef81a745f09534c", "patch": "@@ -14,11 +14,10 @@\n //! conflicts between multiple such attributes attached to the same\n //! item.\n \n-use session::Session;\n+use ty::TyCtxt;\n \n-use syntax::ast;\n-use syntax::visit;\n-use syntax::visit::Visitor;\n+use hir;\n+use hir::intravisit::{self, Visitor, NestedVisitorMap};\n \n #[derive(Copy, Clone, PartialEq)]\n enum Target {\n@@ -30,45 +29,51 @@ enum Target {\n }\n \n impl Target {\n-    fn from_item(item: &ast::Item) -> Target {\n+    fn from_item(item: &hir::Item) -> Target {\n         match item.node {\n-            ast::ItemKind::Fn(..) => Target::Fn,\n-            ast::ItemKind::Struct(..) => Target::Struct,\n-            ast::ItemKind::Union(..) => Target::Union,\n-            ast::ItemKind::Enum(..) => Target::Enum,\n+            hir::ItemFn(..) => Target::Fn,\n+            hir::ItemStruct(..) => Target::Struct,\n+            hir::ItemUnion(..) => Target::Union,\n+            hir::ItemEnum(..) => Target::Enum,\n             _ => Target::Other,\n         }\n     }\n }\n \n-struct CheckAttrVisitor<'a> {\n-    sess: &'a Session,\n+struct CheckAttrVisitor<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n-impl<'a> CheckAttrVisitor<'a> {\n+impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n     /// Check any attribute.\n-    fn check_attributes(&self, item: &ast::Item, target: Target) {\n+    fn check_attributes(&self, item: &hir::Item, target: Target) {\n+        self.tcx.target_features_enabled(self.tcx.hir.local_def_id(item.id));\n+\n         for attr in &item.attrs {\n             if let Some(name) = attr.name() {\n                 if name == \"inline\" {\n                     self.check_inline(attr, item, target)\n                 }\n             }\n         }\n+\n         self.check_repr(item, target);\n     }\n \n     /// Check if an `#[inline]` is applied to a function.\n-    fn check_inline(&self, attr: &ast::Attribute, item: &ast::Item, target: Target) {\n+    fn check_inline(&self, attr: &hir::Attribute, item: &hir::Item, target: Target) {\n         if target != Target::Fn {\n-            struct_span_err!(self.sess, attr.span, E0518, \"attribute should be applied to function\")\n+            struct_span_err!(self.tcx.sess,\n+                             attr.span,\n+                             E0518,\n+                             \"attribute should be applied to function\")\n                 .span_label(item.span, \"not a function\")\n                 .emit();\n         }\n     }\n \n     /// Check if the `#[repr]` attributes on `item` are valid.\n-    fn check_repr(&self, item: &ast::Item, target: Target) {\n+    fn check_repr(&self, item: &hir::Item, target: Target) {\n         // Extract the names of all repr hints, e.g., [foo, bar, align] for:\n         // ```\n         // #[repr(foo)]\n@@ -144,7 +149,7 @@ impl<'a> CheckAttrVisitor<'a> {\n                 }\n                 _ => continue,\n             };\n-            struct_span_err!(self.sess, hint.span, E0517,\n+            struct_span_err!(self.tcx.sess, hint.span, E0517,\n                              \"attribute should be applied to {}\", allowed_targets)\n                 .span_label(item.span, format!(\"not {} {}\", article, allowed_targets))\n                 .emit();\n@@ -154,32 +159,37 @@ impl<'a> CheckAttrVisitor<'a> {\n         if (int_reprs > 1)\n            || (is_simd && is_c)\n            || (int_reprs == 1 && is_c && is_c_like_enum(item)) {\n-            // Just point at all repr hints. This is not ideal, but tracking precisely which ones\n-            // are at fault is a huge hassle.\n+            // Just point at all repr hints. This is not ideal, but tracking\n+            // precisely which ones are at fault is a huge hassle.\n             let spans: Vec<_> = hints.iter().map(|hint| hint.span).collect();\n-            span_warn!(self.sess, spans, E0566,\n+            span_warn!(self.tcx.sess, spans, E0566,\n                        \"conflicting representation hints\");\n         }\n     }\n }\n \n-impl<'a> Visitor<'a> for CheckAttrVisitor<'a> {\n-    fn visit_item(&mut self, item: &'a ast::Item) {\n+impl<'a, 'tcx> Visitor<'tcx> for CheckAttrVisitor<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::None\n+    }\n+\n+    fn visit_item(&mut self, item: &'tcx hir::Item) {\n         let target = Target::from_item(item);\n         self.check_attributes(item, target);\n-        visit::walk_item(self, item);\n+        intravisit::walk_item(self, item);\n     }\n }\n \n-pub fn check_crate(sess: &Session, krate: &ast::Crate) {\n-    visit::walk_crate(&mut CheckAttrVisitor { sess: sess }, krate);\n+pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    let mut checker = CheckAttrVisitor { tcx };\n+    tcx.hir.krate().visit_all_item_likes(&mut checker.as_deep_visitor());\n }\n \n-fn is_c_like_enum(item: &ast::Item) -> bool {\n-    if let ast::ItemKind::Enum(ref def, _) = item.node {\n+fn is_c_like_enum(item: &hir::Item) -> bool {\n+    if let hir::ItemEnum(ref def, _) = item.node {\n         for variant in &def.variants {\n             match variant.node.data {\n-                ast::VariantData::Unit(_) => { /* continue */ }\n+                hir::VariantData::Unit(_) => { /* continue */ }\n                 _ => { return false; }\n             }\n         }"}, {"sha": "8dedcb24c2fb61a8b50dca7a9d2232ab7941ae98", "filename": "src/librustc/ty/maps/config.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b762c2d9dd47e75905cdeae6bef81a745f09534c/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b762c2d9dd47e75905cdeae6bef81a745f09534c/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs?ref=b762c2d9dd47e75905cdeae6bef81a745f09534c", "patch": "@@ -631,6 +631,12 @@ impl<'tcx> QueryDescription<'tcx> for queries::substitute_normalize_and_test_pre\n     }\n }\n \n+impl<'tcx> QueryDescription<'tcx> for queries::target_features_whitelist<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"looking up the whitelist of target features\")\n+    }\n+}\n+\n macro_rules! impl_disk_cacheable_query(\n     ($query_name:ident, |$key:tt| $cond:expr) => {\n         impl<'tcx> QueryDescription<'tcx> for queries::$query_name<'tcx> {"}, {"sha": "e7e92b8a4288f87d73ba58fc98039102968a2f6c", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b762c2d9dd47e75905cdeae6bef81a745f09534c/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b762c2d9dd47e75905cdeae6bef81a745f09534c/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=b762c2d9dd47e75905cdeae6bef81a745f09534c", "patch": "@@ -360,6 +360,11 @@ define_maps! { <'tcx>\n \n     [] fn substitute_normalize_and_test_predicates:\n         substitute_normalize_and_test_predicates_node((DefId, &'tcx Substs<'tcx>)) -> bool,\n+\n+    [] fn target_features_whitelist:\n+        target_features_whitelist_node(CrateNum) -> Rc<FxHashSet<String>>,\n+    [] fn target_features_enabled: TargetFeaturesEnabled(DefId) -> Rc<Vec<String>>,\n+\n }\n \n //////////////////////////////////////////////////////////////////////\n@@ -505,3 +510,7 @@ fn substitute_normalize_and_test_predicates_node<'tcx>(key: (DefId, &'tcx Substs\n                                             -> DepConstructor<'tcx> {\n     DepConstructor::SubstituteNormalizeAndTestPredicates { key }\n }\n+\n+fn target_features_whitelist_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n+    DepConstructor::TargetFeaturesWhitelist\n+}"}, {"sha": "d670ecc2691ae2f4a93ca47a4b015938e8259064", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b762c2d9dd47e75905cdeae6bef81a745f09534c/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b762c2d9dd47e75905cdeae6bef81a745f09534c/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=b762c2d9dd47e75905cdeae6bef81a745f09534c", "patch": "@@ -917,6 +917,9 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         }\n         DepKind::IsTranslatedFunction => { force!(is_translated_function, def_id!()); }\n         DepKind::OutputFilenames => { force!(output_filenames, LOCAL_CRATE); }\n+\n+        DepKind::TargetFeaturesWhitelist => { force!(target_features_whitelist, LOCAL_CRATE); }\n+        DepKind::TargetFeaturesEnabled => { force!(target_features_enabled, def_id!()); }\n     }\n \n     true"}, {"sha": "73c1b698087fceb8f80c99e6b38c0dec1dc0db0d", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b762c2d9dd47e75905cdeae6bef81a745f09534c/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b762c2d9dd47e75905cdeae6bef81a745f09534c/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=b762c2d9dd47e75905cdeae6bef81a745f09534c", "patch": "@@ -210,10 +210,6 @@ pub fn compile_input(sess: &Session,\n                                     Ok(()));\n         }\n \n-        time(sess.time_passes(), \"attribute checking\", || {\n-            hir::check_attr::check_crate(sess, &expanded_crate);\n-        });\n-\n         let opt_crate = if control.keep_ast {\n             Some(&expanded_crate)\n         } else {\n@@ -1038,6 +1034,10 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(control: &CompileController,\n         // tcx available.\n         rustc_incremental::dep_graph_tcx_init(tcx);\n \n+        time(sess.time_passes(), \"attribute checking\", || {\n+            hir::check_attr::check_crate(tcx)\n+        });\n+\n         time(time_passes,\n              \"stability checking\",\n              || stability::check_unstable_api_usage(tcx));"}, {"sha": "f3105e03523a3ba657f451d4a0885a9dcc6d7bef", "filename": "src/librustc_trans/attributes.rs", "status": "modified", "additions": 109, "deletions": 13, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/b762c2d9dd47e75905cdeae6bef81a745f09534c/src%2Flibrustc_trans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b762c2d9dd47e75905cdeae6bef81a745f09534c/src%2Flibrustc_trans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fattributes.rs?ref=b762c2d9dd47e75905cdeae6bef81a745f09534c", "patch": "@@ -10,11 +10,18 @@\n //! Set and unset common attributes on LLVM values.\n \n use std::ffi::{CStr, CString};\n+use std::rc::Rc;\n \n+use rustc::hir::Unsafety;\n+use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::session::config::Sanitizer;\n+use rustc::ty::TyCtxt;\n+use rustc::ty::maps::Providers;\n+use rustc_data_structures::fx::FxHashSet;\n \n use llvm::{self, Attribute, ValueRef};\n use llvm::AttributePlace::Function;\n+use llvm_util;\n pub use syntax::attr::{self, InlineAttr};\n use syntax::ast;\n use context::CrateContext;\n@@ -94,23 +101,16 @@ pub fn set_probestack(ccx: &CrateContext, llfn: ValueRef) {\n \n /// Composite function which sets LLVM attributes for function depending on its AST (#[attribute])\n /// attributes.\n-pub fn from_fn_attrs(ccx: &CrateContext, attrs: &[ast::Attribute], llfn: ValueRef) {\n+pub fn from_fn_attrs(ccx: &CrateContext, llfn: ValueRef, id: DefId) {\n     use syntax::attr::*;\n-    inline(llfn, find_inline_attr(Some(ccx.sess().diagnostic()), attrs));\n+    let attrs = ccx.tcx().get_attrs(id);\n+    inline(llfn, find_inline_attr(Some(ccx.sess().diagnostic()), &attrs));\n \n     set_frame_pointer_elimination(ccx, llfn);\n     set_probestack(ccx, llfn);\n-    let mut target_features = vec![];\n-    for attr in attrs {\n-        if attr.check_name(\"target_feature\") {\n-            if let Some(val) = attr.value_str() {\n-                for feat in val.as_str().split(\",\").map(|f| f.trim()) {\n-                    if !feat.is_empty() && !feat.contains('\\0') {\n-                        target_features.push(feat.to_string());\n-                    }\n-                }\n-            }\n-        } else if attr.check_name(\"cold\") {\n+\n+    for attr in attrs.iter() {\n+        if attr.check_name(\"cold\") {\n             Attribute::Cold.apply_llfn(Function, llfn);\n         } else if attr.check_name(\"naked\") {\n             naked(llfn, true);\n@@ -123,6 +123,8 @@ pub fn from_fn_attrs(ccx: &CrateContext, attrs: &[ast::Attribute], llfn: ValueRe\n             unwind(llfn, false);\n         }\n     }\n+\n+    let target_features = ccx.tcx().target_features_enabled(id);\n     if !target_features.is_empty() {\n         let val = CString::new(target_features.join(\",\")).unwrap();\n         llvm::AddFunctionAttrStringValue(\n@@ -134,3 +136,97 @@ pub fn from_fn_attrs(ccx: &CrateContext, attrs: &[ast::Attribute], llfn: ValueRe\n fn cstr(s: &'static str) -> &CStr {\n     CStr::from_bytes_with_nul(s.as_bytes()).expect(\"null-terminated string\")\n }\n+\n+pub fn provide(providers: &mut Providers) {\n+    providers.target_features_whitelist = |tcx, cnum| {\n+        assert_eq!(cnum, LOCAL_CRATE);\n+        Rc::new(llvm_util::target_feature_whitelist(tcx.sess)\n+            .iter()\n+            .map(|c| c.to_str().unwrap().to_string())\n+            .collect())\n+    };\n+\n+    providers.target_features_enabled = |tcx, id| {\n+        let whitelist = tcx.target_features_whitelist(LOCAL_CRATE);\n+        let mut target_features = Vec::new();\n+        for attr in tcx.get_attrs(id).iter() {\n+            if !attr.check_name(\"target_feature\") {\n+                continue\n+            }\n+            if let Some(val) = attr.value_str() {\n+                for feat in val.as_str().split(\",\").map(|f| f.trim()) {\n+                    if !feat.is_empty() && !feat.contains('\\0') {\n+                        target_features.push(feat.to_string());\n+                    }\n+                }\n+                let msg = \"#[target_feature = \\\"..\\\"] is deprecated and will \\\n+                           eventually be removed, use \\\n+                           #[target_feature(enable = \\\"..\\\")] instead\";\n+                tcx.sess.span_warn(attr.span, &msg);\n+                continue\n+            }\n+\n+            if tcx.fn_sig(id).unsafety() == Unsafety::Normal {\n+                let msg = \"#[target_feature(..)] can only be applied to \\\n+                           `unsafe` function\";\n+                tcx.sess.span_err(attr.span, msg);\n+            }\n+            from_target_feature(tcx, attr, &whitelist, &mut target_features);\n+        }\n+        Rc::new(target_features)\n+    };\n+}\n+\n+fn from_target_feature(\n+    tcx: TyCtxt,\n+    attr: &ast::Attribute,\n+    whitelist: &FxHashSet<String>,\n+    target_features: &mut Vec<String>,\n+) {\n+    let list = match attr.meta_item_list() {\n+        Some(list) => list,\n+        None => {\n+            let msg = \"#[target_feature] attribute must be of the form \\\n+                       #[target_feature(..)]\";\n+            tcx.sess.span_err(attr.span, &msg);\n+            return\n+        }\n+    };\n+\n+    for item in list {\n+        if !item.check_name(\"enable\") {\n+            let msg = \"#[target_feature(..)] only accepts sub-keys of `enable` \\\n+                       currently\";\n+            tcx.sess.span_err(item.span, &msg);\n+            continue\n+        }\n+        let value = match item.value_str() {\n+            Some(list) => list,\n+            None => {\n+                let msg = \"#[target_feature] attribute must be of the form \\\n+                           #[target_feature(enable = \\\"..\\\")]\";\n+                tcx.sess.span_err(item.span, &msg);\n+                continue\n+            }\n+        };\n+        let value = value.as_str();\n+        for feature in value.split(',') {\n+            if whitelist.contains(feature) {\n+                target_features.push(format!(\"+{}\", feature));\n+                continue\n+            }\n+\n+            let msg = format!(\"the feature named `{}` is not valid for \\\n+                               this target\", feature);\n+            let mut err = tcx.sess.struct_span_err(item.span, &msg);\n+\n+            if feature.starts_with(\"+\") {\n+                let valid = whitelist.contains(&feature[1..]);\n+                if valid {\n+                    err.help(\"consider removing the leading `+` in the feature name\");\n+                }\n+            }\n+            err.emit();\n+        }\n+    }\n+}"}, {"sha": "ccbc6620ffe09b0755a488e3e254a1af06da0683", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b762c2d9dd47e75905cdeae6bef81a745f09534c/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b762c2d9dd47e75905cdeae6bef81a745f09534c/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=b762c2d9dd47e75905cdeae6bef81a745f09534c", "patch": "@@ -99,8 +99,7 @@ pub fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         if instance.def.is_inline(tcx) {\n             attributes::inline(llfn, attributes::InlineAttr::Hint);\n         }\n-        let attrs = instance.def.attrs(ccx.tcx());\n-        attributes::from_fn_attrs(ccx, &attrs, llfn);\n+        attributes::from_fn_attrs(ccx, llfn, instance.def.def_id());\n \n         let instance_def_id = instance.def_id();\n "}, {"sha": "974c268749b859a5620059aea0f6e6846963aaa7", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b762c2d9dd47e75905cdeae6bef81a745f09534c/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b762c2d9dd47e75905cdeae6bef81a745f09534c/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=b762c2d9dd47e75905cdeae6bef81a745f09534c", "patch": "@@ -167,6 +167,7 @@ impl rustc_trans_utils::trans_crate::TransCrate for LlvmTransCrate {\n         back::symbol_names::provide(providers);\n         back::symbol_export::provide(providers);\n         base::provide(providers);\n+        attributes::provide(providers);\n     }\n \n     fn provide_extern(providers: &mut ty::maps::Providers) {"}, {"sha": "8112a9eeab1ef4d8d622bd5dcfc5a561eccb153e", "filename": "src/librustc_trans/llvm_util.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b762c2d9dd47e75905cdeae6bef81a745f09534c/src%2Flibrustc_trans%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b762c2d9dd47e75905cdeae6bef81a745f09534c/src%2Flibrustc_trans%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fllvm_util.rs?ref=b762c2d9dd47e75905cdeae6bef81a745f09534c", "patch": "@@ -13,8 +13,8 @@ use back::write::create_target_machine;\n use llvm;\n use rustc::session::Session;\n use rustc::session::config::PrintRequest;\n-use libc::{c_int, c_char};\n-use std::ffi::CString;\n+use libc::c_int;\n+use std::ffi::{CStr, CString};\n \n use std::sync::atomic::{AtomicBool, Ordering};\n use std::sync::Once;\n@@ -97,8 +97,18 @@ const POWERPC_WHITELIST: &'static [&'static str] = &[\"altivec\\0\",\n const MIPS_WHITELIST: &'static [&'static str] = &[\"msa\\0\"];\n \n pub fn target_features(sess: &Session) -> Vec<Symbol> {\n+    let whitelist = target_feature_whitelist(sess);\n     let target_machine = create_target_machine(sess);\n+    let mut features = Vec::new();\n+    for feat in whitelist {\n+        if unsafe { llvm::LLVMRustHasFeature(target_machine, feat.as_ptr()) } {\n+            features.push(Symbol::intern(feat.to_str().unwrap()));\n+        }\n+    }\n+    features\n+}\n \n+pub fn target_feature_whitelist(sess: &Session) -> Vec<&CStr> {\n     let whitelist = match &*sess.target.target.arch {\n         \"arm\" => ARM_WHITELIST,\n         \"aarch64\" => AARCH64_WHITELIST,\n@@ -108,15 +118,9 @@ pub fn target_features(sess: &Session) -> Vec<Symbol> {\n         \"powerpc\" | \"powerpc64\" => POWERPC_WHITELIST,\n         _ => &[],\n     };\n-\n-    let mut features = Vec::new();\n-    for feat in whitelist {\n-        assert_eq!(feat.chars().last(), Some('\\0'));\n-        if unsafe { llvm::LLVMRustHasFeature(target_machine, feat.as_ptr() as *const c_char) } {\n-            features.push(Symbol::intern(&feat[..feat.len() - 1]));\n-        }\n-    }\n-    features\n+    whitelist.iter().map(|m| {\n+        CStr::from_bytes_with_nul(m.as_bytes()).unwrap()\n+    }).collect()\n }\n \n pub fn print_version() {"}, {"sha": "fa6a42e062d9fb5645f755a78b4f4ccc3222e995", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b762c2d9dd47e75905cdeae6bef81a745f09534c/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b762c2d9dd47e75905cdeae6bef81a745f09534c/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=b762c2d9dd47e75905cdeae6bef81a745f09534c", "patch": "@@ -199,7 +199,7 @@ fn predefine_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     if instance.def.is_inline(ccx.tcx()) {\n         attributes::inline(lldecl, attributes::InlineAttr::Hint);\n     }\n-    attributes::from_fn_attrs(ccx, &attrs, lldecl);\n+    attributes::from_fn_attrs(ccx, lldecl, instance.def.def_id());\n \n     ccx.instances().borrow_mut().insert(instance, lldecl);\n }"}, {"sha": "444c4176994c593a1eeee61592294e373f289a0c", "filename": "src/test/ui/feature-gate/issue-43106-gating-of-inline.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b762c2d9dd47e75905cdeae6bef81a745f09534c/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-inline.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b762c2d9dd47e75905cdeae6bef81a745f09534c/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-inline.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-inline.stderr?ref=b762c2d9dd47e75905cdeae6bef81a745f09534c", "patch": "@@ -1,3 +1,5 @@\n+error[E0601]: main function not found\n+\n error[E0518]: attribute should be applied to function\n   --> $DIR/issue-43106-gating-of-inline.rs:21:1\n    |\n@@ -37,7 +39,5 @@ error[E0518]: attribute should be applied to function\n 35 |     #[inline = \"2100\"] impl S { }\n    |     ^^^^^^^^^^^^^^^^^^ ---------- not a function\n \n-error[E0601]: main function not found\n-\n error: aborting due to 6 previous errors\n "}, {"sha": "e70d549ed573a43ea9dd095f8d7f272342a4f6d3", "filename": "src/test/ui/target-feature-wrong.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/b762c2d9dd47e75905cdeae6bef81a745f09534c/src%2Ftest%2Fui%2Ftarget-feature-wrong.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b762c2d9dd47e75905cdeae6bef81a745f09534c/src%2Ftest%2Fui%2Ftarget-feature-wrong.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftarget-feature-wrong.rs?ref=b762c2d9dd47e75905cdeae6bef81a745f09534c", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-arm\n+// ignore-aarch64\n+// ignore-wasm\n+// ignore-emscripten\n+\n+#![feature(target_feature)]\n+\n+#[target_feature = \"+sse2\"]\n+//~^ WARN: deprecated\n+#[target_feature(enable = \"foo\")]\n+//~^ ERROR: not valid for this target\n+#[target_feature(bar)]\n+//~^ ERROR: only accepts sub-keys\n+#[target_feature(disable = \"baz\")]\n+//~^ ERROR: only accepts sub-keys\n+unsafe fn foo() {}\n+\n+#[target_feature(enable = \"sse2\")]\n+//~^ ERROR: can only be applied to `unsafe` function\n+fn bar() {}\n+\n+fn main() {\n+    unsafe {\n+        foo();\n+        bar();\n+    }\n+}"}, {"sha": "c5534bf147d5c53ba55259dadb67515265ba845c", "filename": "src/test/ui/target-feature-wrong.stderr", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b762c2d9dd47e75905cdeae6bef81a745f09534c/src%2Ftest%2Fui%2Ftarget-feature-wrong.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b762c2d9dd47e75905cdeae6bef81a745f09534c/src%2Ftest%2Fui%2Ftarget-feature-wrong.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftarget-feature-wrong.stderr?ref=b762c2d9dd47e75905cdeae6bef81a745f09534c", "patch": "@@ -0,0 +1,32 @@\n+warning: #[target_feature = \"..\"] is deprecated and will eventually be removed, use #[target_feature(enable = \"..\")] instead\n+  --> $DIR/target-feature-wrong.rs:18:1\n+   |\n+18 | #[target_feature = \"+sse2\"]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: the feature named `foo` is not valid for this target\n+  --> $DIR/target-feature-wrong.rs:20:18\n+   |\n+20 | #[target_feature(enable = \"foo\")]\n+   |                  ^^^^^^^^^^^^^^\n+\n+error: #[target_feature(..)] only accepts sub-keys of `enable` currently\n+  --> $DIR/target-feature-wrong.rs:22:18\n+   |\n+22 | #[target_feature(bar)]\n+   |                  ^^^\n+\n+error: #[target_feature(..)] only accepts sub-keys of `enable` currently\n+  --> $DIR/target-feature-wrong.rs:24:18\n+   |\n+24 | #[target_feature(disable = \"baz\")]\n+   |                  ^^^^^^^^^^^^^^^\n+\n+error: #[target_feature(..)] can only be applied to `unsafe` function\n+  --> $DIR/target-feature-wrong.rs:28:1\n+   |\n+28 | #[target_feature(enable = \"sse2\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 4 previous errors\n+"}]}