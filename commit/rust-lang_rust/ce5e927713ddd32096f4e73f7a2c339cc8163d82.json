{"sha": "ce5e927713ddd32096f4e73f7a2c339cc8163d82", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlNWU5Mjc3MTNkZGQzMjA5NmY0ZTczZjdhMmMzMzljYzgxNjNkODI=", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-03-25T13:25:04Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-04-15T12:19:40Z"}, "message": "Improve `map_entry` lint\nFix false positives where the map is used before inserting into the map.\nFix false positives where two insertions happen.\nSuggest using `if let Entry::Vacant(e) = _.entry(_)` when `or_insert` might be a semantic change", "tree": {"sha": "45caf3b8751de82133aa642e9b77715249a5ea48", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/45caf3b8751de82133aa642e9b77715249a5ea48"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce5e927713ddd32096f4e73f7a2c339cc8163d82", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nComment: Created with Krypton\n\niF4EABYKAAYFAmB4L3EACgkQ2lnoZDo37QZYQAEAvImaRkFweIE+FxGaUFJIgYJP\nYcsole3QZGdwWbyjPRoA/RO1Y+qMIYLhLaPkJVXzIvrL1jwMTfCAWwtFoJ5KQCIP\n=jhEN\n-----END PGP SIGNATURE-----", "payload": "tree 45caf3b8751de82133aa642e9b77715249a5ea48\nparent b1c675f3fc682201cdb28719133285b878e2d157\nauthor Jason Newcomb <jsnewcomb@pm.me> 1616678704 -0400\ncommitter Jason Newcomb <jsnewcomb@pm.me> 1618489180 -0400\n\nImprove `map_entry` lint\nFix false positives where the map is used before inserting into the map.\nFix false positives where two insertions happen.\nSuggest using `if let Entry::Vacant(e) = _.entry(_)` when `or_insert` might be a semantic change\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce5e927713ddd32096f4e73f7a2c339cc8163d82", "html_url": "https://github.com/rust-lang/rust/commit/ce5e927713ddd32096f4e73f7a2c339cc8163d82", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce5e927713ddd32096f4e73f7a2c339cc8163d82/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1c675f3fc682201cdb28719133285b878e2d157", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1c675f3fc682201cdb28719133285b878e2d157", "html_url": "https://github.com/rust-lang/rust/commit/b1c675f3fc682201cdb28719133285b878e2d157"}], "stats": {"total": 1162, "additions": 882, "deletions": 280}, "files": [{"sha": "ca01d0a7f87581db2cef75ac7942cb9cb8fa62f0", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 368, "deletions": 121, "changes": 489, "blob_url": "https://github.com/rust-lang/rust/blob/ce5e927713ddd32096f4e73f7a2c339cc8163d82/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce5e927713ddd32096f4e73f7a2c339cc8163d82/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=ce5e927713ddd32096f4e73f7a2c339cc8163d82", "patch": "@@ -1,33 +1,33 @@\n-use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::source::{snippet, snippet_opt, snippet_with_applicability};\n-use clippy_utils::ty::{is_type_diagnostic_item, match_type};\n-use clippy_utils::SpanlessEq;\n-use clippy_utils::{get_item_name, paths};\n-use if_chain::if_chain;\n+use clippy_utils::{\n+    diagnostics::span_lint_and_sugg,\n+    is_expr_final_block_expr, is_expr_used_or_unified, match_def_path, paths, peel_hir_expr_while,\n+    source::{snippet_indent, snippet_with_applicability, snippet_with_context},\n+    SpanlessEq,\n+};\n use rustc_errors::Applicability;\n-use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n-use rustc_hir::{BorrowKind, Expr, ExprKind, UnOp};\n+use rustc_hir::{\n+    intravisit::{walk_expr, ErasedMap, NestedVisitorMap, Visitor},\n+    Expr, ExprKind, Guard, Local, Stmt, StmtKind, UnOp,\n+};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::hir::map::Map;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::source_map::Span;\n-use rustc_span::sym;\n+use rustc_span::{Span, SyntaxContext, DUMMY_SP};\n+use std::fmt::Write;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for uses of `contains_key` + `insert` on `HashMap`\n     /// or `BTreeMap`.\n     ///\n     /// **Why is this bad?** Using `entry` is more efficient.\n     ///\n-    /// **Known problems:** Some false negatives, eg.:\n+    /// **Known problems:** The suggestion may have type inference errors in some cases. e.g.\n     /// ```rust\n-    /// # use std::collections::HashMap;\n-    /// # let mut map = HashMap::new();\n-    /// # let v = 1;\n-    /// # let k = 1;\n-    /// if !map.contains_key(&k) {\n-    ///     map.insert(k.clone(), v);\n-    /// }\n+    /// let mut map = std::collections::HashMap::new();\n+    /// let _ = if !map.contains_key(&0) {\n+    ///     map.insert(0, 0)\n+    /// } else {\n+    ///     None\n+    /// };\n     /// ```\n     ///\n     /// **Example:**\n@@ -56,132 +56,379 @@ declare_clippy_lint! {\n declare_lint_pass!(HashMapPass => [MAP_ENTRY]);\n \n impl<'tcx> LateLintPass<'tcx> for HashMapPass {\n+    #[allow(clippy::too_many_lines)]\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let ExprKind::If(check, then_block, ref else_block) = expr.kind {\n-            if let ExprKind::Unary(UnOp::Not, check) = check.kind {\n-                if let Some((ty, map, key)) = check_cond(cx, check) {\n-                    // in case of `if !m.contains_key(&k) { m.insert(k, v); }`\n-                    // we can give a better error message\n-                    let sole_expr = {\n-                        else_block.is_none()\n-                            && if let ExprKind::Block(then_block, _) = then_block.kind {\n-                                (then_block.expr.is_some() as usize) + then_block.stmts.len() == 1\n-                            } else {\n-                                true\n-                            }\n-                        // XXXManishearth we can also check for if/else blocks containing `None`.\n-                    };\n+        let (cond_expr, then_expr, else_expr) = match expr.kind {\n+            ExprKind::If(c, t, e) => (c, t, e),\n+            _ => return,\n+        };\n+        let (map_ty, contains_expr) = match try_parse_contains(cx, cond_expr) {\n+            Some(x) => x,\n+            None => return,\n+        };\n \n-                    let mut visitor = InsertVisitor {\n-                        cx,\n-                        span: expr.span,\n-                        ty,\n-                        map,\n-                        key,\n-                        sole_expr,\n-                    };\n+        let then_search = match find_insert_calls(cx, &contains_expr, then_expr) {\n+            Some(x) => x,\n+            None => return,\n+        };\n \n-                    walk_expr(&mut visitor, then_block);\n-                }\n-            } else if let Some(else_block) = *else_block {\n-                if let Some((ty, map, key)) = check_cond(cx, check) {\n-                    let mut visitor = InsertVisitor {\n-                        cx,\n-                        span: expr.span,\n-                        ty,\n-                        map,\n-                        key,\n-                        sole_expr: false,\n+        let mut app = Applicability::MachineApplicable;\n+        let map_str = snippet_with_context(cx, contains_expr.map.span, contains_expr.call_ctxt, \"..\", &mut app).0;\n+        let key_str = snippet_with_context(cx, contains_expr.key.span, contains_expr.call_ctxt, \"..\", &mut app).0;\n+        let sugg = if !contains_expr.negated || else_expr.is_some() || then_search.insertions.is_empty() {\n+            return;\n+        } else {\n+            // if .. { insert }\n+            match then_search.as_single_insertion() {\n+                Some(insertion) if !insertion.value.can_have_side_effects() => {\n+                    format!(\n+                        \"{}.entry({}).or_insert({});\",\n+                        map_str,\n+                        key_str,\n+                        snippet_with_context(cx, insertion.value.span, insertion.call.span.ctxt(), \"..\", &mut app).0,\n+                    )\n+                },\n+                _ => {\n+                    let (body_str, entry_kind) = if contains_expr.negated {\n+                        (then_search.snippet_vacant(cx, then_expr.span, &mut app), \"Vacant(e)\")\n+                    } else {\n+                        (\n+                            then_search.snippet_occupied(cx, then_expr.span, &mut app),\n+                            \"Occupied(mut e)\",\n+                        )\n                     };\n-\n-                    walk_expr(&mut visitor, else_block);\n-                }\n+                    format!(\n+                        \"if let {}::{} = {}.entry({}) {}\",\n+                        map_ty.entry_path(),\n+                        entry_kind,\n+                        map_str,\n+                        key_str,\n+                        body_str,\n+                    )\n+                },\n             }\n+        };\n+\n+        span_lint_and_sugg(\n+            cx,\n+            MAP_ENTRY,\n+            expr.span,\n+            &format!(\"usage of `contains_key` followed by `insert` on a `{}`\", map_ty.name()),\n+            \"try this\",\n+            sugg,\n+            app,\n+        );\n+    }\n+}\n+\n+#[derive(Clone, Copy)]\n+enum MapType {\n+    Hash,\n+    BTree,\n+}\n+impl MapType {\n+    fn name(self) -> &'static str {\n+        match self {\n+            Self::Hash => \"HashMap\",\n+            Self::BTree => \"BTreeMap\",\n+        }\n+    }\n+    fn entry_path(self) -> &'staic str {\n+        match self {\n+            Self::Hash => \"std::collections::hash_map::Entry\",\n+            Self::BTree => \"std::collections::btree_map::Entry\",\n         }\n     }\n }\n \n-fn check_cond<'a>(cx: &LateContext<'_>, check: &'a Expr<'a>) -> Option<(&'static str, &'a Expr<'a>, &'a Expr<'a>)> {\n-    if_chain! {\n-        if let ExprKind::MethodCall(path, _, params, _) = check.kind;\n-        if params.len() >= 2;\n-        if path.ident.name == sym!(contains_key);\n-        if let ExprKind::AddrOf(BorrowKind::Ref, _, key) = params[1].kind;\n-        then {\n-            let map = &params[0];\n-            let obj_ty = cx.typeck_results().expr_ty(map).peel_refs();\n-\n-            return if match_type(cx, obj_ty, &paths::BTREEMAP) {\n-                Some((\"BTreeMap\", map, key))\n-            }\n-            else if is_type_diagnostic_item(cx, obj_ty, sym::hashmap_type) {\n-                Some((\"HashMap\", map, key))\n-            }\n-            else {\n-                None\n+struct ContainsExpr<'tcx> {\n+    negated: bool,\n+    map: &'tcx Expr<'tcx>,\n+    key: &'tcx Expr<'tcx>,\n+    call_ctxt: SyntaxContext,\n+}\n+fn try_parse_contains(cx: &LateContext<'_>, expr: &'tcx Expr<'_>) -> Option<(MapType, ContainsExpr<'tcx>)> {\n+    let mut negated = false;\n+    let expr = peel_hir_expr_while(expr, |e| match e.kind {\n+        ExprKind::Unary(UnOp::Not, e) => {\n+            negated = !negated;\n+            Some(e)\n+        },\n+        _ => None,\n+    });\n+    match expr.kind {\n+        ExprKind::MethodCall(\n+            _,\n+            _,\n+            [map, Expr {\n+                kind: ExprKind::AddrOf(_, _, key),\n+                span: key_span,\n+                ..\n+            }],\n+            _,\n+        ) if key_span.ctxt() == expr.span.ctxt() => {\n+            let id = cx.typeck_results().type_dependent_def_id(expr.hir_id)?;\n+            let expr = ContainsExpr {\n+                negated,\n+                map,\n+                key,\n+                call_ctxt: expr.span.ctxt(),\n             };\n+            if match_def_path(cx, id, &paths::BTREEMAP_CONTAINS_KEY) {\n+                Some((MapType::BTree, expr))\n+            } else if match_def_path(cx, id, &paths::HASHMAP_CONTAINS_KEY) {\n+                Some((MapType::Hash, expr))\n+            } else {\n+                None\n+            }\n+        },\n+        _ => None,\n+    }\n+}\n+\n+struct InsertExpr<'tcx> {\n+    map: &'tcx Expr<'tcx>,\n+    key: &'tcx Expr<'tcx>,\n+    value: &'tcx Expr<'tcx>,\n+}\n+fn try_parse_insert(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<InsertExpr<'tcx>> {\n+    if let ExprKind::MethodCall(_, _, [map, key, value], _) = expr.kind {\n+        let id = cx.typeck_results().type_dependent_def_id(expr.hir_id)?;\n+        if match_def_path(cx, id, &paths::BTREEMAP_INSERT) || match_def_path(cx, id, &paths::HASHMAP_INSERT) {\n+            Some(InsertExpr { map, key, value })\n+        } else {\n+            None\n         }\n+    } else {\n+        None\n     }\n+}\n \n-    None\n+#[derive(Clone, Copy)]\n+struct Insertion<'tcx> {\n+    call: &'tcx Expr<'tcx>,\n+    value: &'tcx Expr<'tcx>,\n }\n \n-struct InsertVisitor<'a, 'tcx, 'b> {\n-    cx: &'a LateContext<'tcx>,\n-    span: Span,\n-    ty: &'static str,\n-    map: &'b Expr<'b>,\n-    key: &'b Expr<'b>,\n-    sole_expr: bool,\n+// This visitor needs to do a multiple things:\n+// * Find all usages of the map. Only insertions into the map which share the same key are\n+//   permitted. All others will prevent the lint.\n+// * Determine if the final statement executed is an insertion. This is needed to use `insert_with`.\n+// * Determine if there's any sub-expression that can't be placed in a closure.\n+// * Determine if there's only a single insert statement. This is needed to give better suggestions.\n+\n+#[allow(clippy::struct_excessive_bools)]\n+struct InsertSearcher<'cx, 'i, 'tcx> {\n+    cx: &'cx LateContext<'tcx>,\n+    /// The map expression used in the contains call.\n+    map: &'tcx Expr<'tcx>,\n+    /// The key expression used in the contains call.\n+    key: &'tcx Expr<'tcx>,\n+    /// The context of the top level block. All insert calls must be in the same context.\n+    ctxt: SyntaxContext,\n+    /// Whether this expression can use the entry api.\n+    can_use_entry: bool,\n+    // A single insert expression has a slightly different suggestion.\n+    is_single_insert: bool,\n+    is_map_used: bool,\n+    insertions: &'i mut Vec<Insertion<'tcx>>,\n+}\n+impl<'tcx> InsertSearcher<'_, '_, 'tcx> {\n+    /// Visit the expression as a branch in control flow. Multiple insert calls can be used, but\n+    /// only if they are on separate code paths. This will return whether the map was used in the\n+    /// given expression.\n+    fn visit_cond_arm(&mut self, e: &'tcx Expr<'_>) -> bool {\n+        let is_map_used = self.is_map_used;\n+        self.visit_expr(e);\n+        let res = self.is_map_used;\n+        self.is_map_used = is_map_used;\n+        res\n+    }\n }\n+impl<'tcx> Visitor<'tcx> for InsertSearcher<'_, '_, 'tcx> {\n+    type Map = ErasedMap<'tcx>;\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n \n-impl<'a, 'tcx, 'b> Visitor<'tcx> for InsertVisitor<'a, 'tcx, 'b> {\n-    type Map = Map<'tcx>;\n+    fn visit_stmt(&mut self, stmt: &'tcx Stmt<'_>) {\n+        match stmt.kind {\n+            StmtKind::Semi(e) | StmtKind::Expr(e) => self.visit_expr(e),\n+            StmtKind::Local(Local { init: Some(e), .. }) => {\n+                self.is_single_insert = false;\n+                self.visit_expr(e);\n+            },\n+            _ => {\n+                self.is_single_insert = false;\n+            },\n+        }\n+    }\n \n     fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n-        if_chain! {\n-            if let ExprKind::MethodCall(path, _, params, _) = expr.kind;\n-            if params.len() == 3;\n-            if path.ident.name == sym!(insert);\n-            if get_item_name(self.cx, self.map) == get_item_name(self.cx, &params[0]);\n-            if SpanlessEq::new(self.cx).eq_expr(self.key, &params[1]);\n-            if snippet_opt(self.cx, self.map.span) == snippet_opt(self.cx, params[0].span);\n-            then {\n-                span_lint_and_then(self.cx, MAP_ENTRY, self.span,\n-                                   &format!(\"usage of `contains_key` followed by `insert` on a `{}`\", self.ty), |diag| {\n-                    if self.sole_expr {\n-                        let mut app = Applicability::MachineApplicable;\n-                        let help = format!(\"{}.entry({}).or_insert({});\",\n-                                           snippet_with_applicability(self.cx, self.map.span, \"map\", &mut app),\n-                                           snippet_with_applicability(self.cx, params[1].span, \"..\", &mut app),\n-                                           snippet_with_applicability(self.cx, params[2].span, \"..\", &mut app));\n-\n-                        diag.span_suggestion(\n-                            self.span,\n-                            \"consider using\",\n-                            help,\n-                            Applicability::MachineApplicable, // snippet\n-                        );\n+        if !self.can_use_entry {\n+            return;\n+        }\n+\n+        match try_parse_insert(self.cx, expr) {\n+            Some(insert_expr) if SpanlessEq::new(self.cx).eq_expr(self.map, insert_expr.map) => {\n+                // Multiple inserts, inserts with a different key, and inserts from a macro can't use the entry api.\n+                if self.is_map_used\n+                    || !SpanlessEq::new(self.cx).eq_expr(self.key, insert_expr.key)\n+                    || expr.span.ctxt() != self.ctxt\n+                {\n+                    self.can_use_entry = false;\n+                    return;\n+                }\n+\n+                self.insertions.push(Insertion {\n+                    call: expr,\n+                    value: insert_expr.value,\n+                });\n+                self.is_map_used = true;\n+\n+                // The value doesn't affect whether there is only a single insert expression.\n+                let is_single_insert = self.is_single_insert;\n+                self.visit_expr(insert_expr.value);\n+                self.is_single_insert = is_single_insert;\n+            },\n+            _ if SpanlessEq::new(self.cx).eq_expr(self.map, expr) => {\n+                self.is_map_used = true;\n+            },\n+            _ => match expr.kind {\n+                ExprKind::If(cond_expr, then_expr, Some(else_expr)) => {\n+                    self.is_single_insert = false;\n+                    self.visit_expr(cond_expr);\n+                    // Each branch may contain it's own insert expression.\n+                    let mut is_map_used = self.visit_cond_arm(then_expr);\n+                    is_map_used |= self.visit_cond_arm(else_expr);\n+                    self.is_map_used = is_map_used;\n+                },\n+                ExprKind::Match(scrutinee_expr, arms, _) => {\n+                    self.is_single_insert = false;\n+                    self.visit_expr(scrutinee_expr);\n+                    // Each branch may contain it's own insert expression.\n+                    let mut is_map_used = self.is_map_used;\n+                    for arm in arms {\n+                        if let Some(Guard::If(guard) | Guard::IfLet(_, guard)) = arm.guard {\n+                            self.visit_expr(guard)\n+                        }\n+                        is_map_used |= self.visit_cond_arm(arm.body);\n                     }\n-                    else {\n-                        let help = format!(\"consider using `{}.entry({})`\",\n-                                           snippet(self.cx, self.map.span, \"map\"),\n-                                           snippet(self.cx, params[1].span, \"..\"));\n-\n-                        diag.span_label(\n-                            self.span,\n-                            &help,\n-                        );\n+                    self.is_map_used = is_map_used;\n+                },\n+                ExprKind::Loop(block, ..) => {\n+                    // Don't allow insertions inside of a loop.\n+                    let insertions_len = self.insertions.len();\n+                    self.visit_block(block);\n+                    if self.insertions.len() != insertions_len {\n+                        self.can_use_entry = false;\n                     }\n-                });\n-            }\n+                },\n+                ExprKind::Block(block, _) => self.visit_block(block),\n+                ExprKind::InlineAsm(_) | ExprKind::LlvmInlineAsm(_) => {\n+                    self.can_use_entry = false;\n+                },\n+                _ => {\n+                    self.is_single_insert = false;\n+                    walk_expr(self, expr);\n+                },\n+            },\n         }\n+    }\n+}\n \n-        if !self.sole_expr {\n-            walk_expr(self, expr);\n+struct InsertSearchResults<'tcx> {\n+    insertions: Vec<Insertion<'tcx>>,\n+    is_single_insert: bool,\n+}\n+impl InsertSearchResults<'tcx> {\n+    fn as_single_insertion(&self) -> Option<Insertion<'tcx>> {\n+        self.is_single_insert.then(|| self.insertions[0])\n+    }\n+\n+    fn snippet_occupied(&self, cx: &LateContext<'_>, mut span: Span, app: &mut Applicability) -> String {\n+        let ctxt = span.ctxt();\n+        let mut res = String::new();\n+        for insertion in self.insertions.iter() {\n+            res.push_str(&snippet_with_applicability(\n+                cx,\n+                span.until(insertion.call.span),\n+                \"..\",\n+                app,\n+            ));\n+            if is_expr_used_or_unified(cx.tcx, insertion.call) {\n+                res.push_str(\"Some(e.insert(\");\n+                res.push_str(&snippet_with_context(cx, insertion.value.span, ctxt, \"..\", app).0);\n+                res.push_str(\"))\");\n+            } else {\n+                res.push_str(\"e.insert(\");\n+                res.push_str(&snippet_with_context(cx, insertion.value.span, ctxt, \"..\", app).0);\n+                res.push(')');\n+            }\n+            span = span.trim_start(insertion.call.span).unwrap_or(DUMMY_SP);\n         }\n+        res.push_str(&snippet_with_applicability(cx, span, \"..\", app));\n+        res\n     }\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n+\n+    fn snippet_vacant(&self, cx: &LateContext<'_>, mut span: Span, app: &mut Applicability) -> String {\n+        let ctxt = span.ctxt();\n+        let mut res = String::new();\n+        for insertion in self.insertions.iter() {\n+            res.push_str(&snippet_with_applicability(\n+                cx,\n+                span.until(insertion.call.span),\n+                \"..\",\n+                app,\n+            ));\n+            if is_expr_used_or_unified(cx.tcx, insertion.call) {\n+                if is_expr_final_block_expr(cx.tcx, insertion.call) {\n+                    let _ = write!(\n+                        res,\n+                        \"e.insert({});\\n{}None\",\n+                        snippet_with_context(cx, insertion.value.span, ctxt, \"..\", app).0,\n+                        snippet_indent(cx, insertion.call.span).as_deref().unwrap_or(\"\"),\n+                    );\n+                } else {\n+                    let _ = write!(\n+                        res,\n+                        \"{{ e.insert({}); None }}\",\n+                        snippet_with_context(cx, insertion.value.span, ctxt, \"..\", app).0,\n+                    );\n+                }\n+            } else {\n+                let _ = write!(\n+                    res,\n+                    \"e.insert({})\",\n+                    snippet_with_context(cx, insertion.value.span, ctxt, \"..\", app).0,\n+                );\n+            }\n+            span = span.trim_start(insertion.call.span).unwrap_or(DUMMY_SP);\n+        }\n+        res.push_str(&snippet_with_applicability(cx, span, \"..\", app));\n+        res\n     }\n }\n+fn find_insert_calls(\n+    cx: &LateContext<'tcx>,\n+    contains_expr: &ContainsExpr<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+) -> Option<InsertSearchResults<'tcx>> {\n+    let mut insertions = Vec::new();\n+    let mut s = InsertSearcher {\n+        cx,\n+        map: contains_expr.map,\n+        key: contains_expr.key,\n+        ctxt: expr.span.ctxt(),\n+        insertions: &mut insertions,\n+        is_map_used: false,\n+        can_use_entry: true,\n+        is_single_insert: true,\n+    };\n+    s.visit_expr(expr);\n+    let is_single_insert = s.is_single_insert;\n+    s.can_use_entry.then(|| InsertSearchResults {\n+        insertions,\n+        is_single_insert,\n+    })\n+}"}, {"sha": "0abee49f40ce33afb774cb0fa918a4d0a5a4a1b6", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 108, "deletions": 17, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/ce5e927713ddd32096f4e73f7a2c339cc8163d82/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce5e927713ddd32096f4e73f7a2c339cc8163d82/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=ce5e927713ddd32096f4e73f7a2c339cc8163d82", "patch": "@@ -63,9 +63,9 @@ use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::LangItem::{ResultErr, ResultOk};\n use rustc_hir::{\n-    def, Arm, BindingAnnotation, Block, Body, Constness, Expr, ExprKind, FnDecl, GenericArgs, HirId, Impl, ImplItem,\n-    ImplItemKind, Item, ItemKind, LangItem, MatchSource, Node, Param, Pat, PatKind, Path, PathSegment, QPath,\n-    TraitItem, TraitItemKind, TraitRef, TyKind,\n+    def, Arm, BindingAnnotation, Block, Body, Constness, Destination, Expr, ExprKind, FnDecl, GenericArgs, HirId, Impl,\n+    ImplItem, ImplItemKind, Item, ItemKind, LangItem, MatchSource, Node, Param, Pat, PatKind, Path, PathSegment, QPath,\n+    Stmt, StmtKind, TraitItem, TraitItemKind, TraitRef, TyKind,\n };\n use rustc_lint::{LateContext, Level, Lint, LintContext};\n use rustc_middle::hir::exports::Export;\n@@ -1245,6 +1245,82 @@ pub fn is_must_use_func_call(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     did.map_or(false, |did| must_use_attr(&cx.tcx.get_attrs(did)).is_some())\n }\n \n+pub fn get_expr_use_node(tcx: TyCtxt<'tcx>, expr: &Expr<'_>) -> Option<Node<'tcx>> {\n+    let map = tcx.hir();\n+    let mut child_id = expr.hir_id;\n+    let mut iter = map.parent_iter(child_id);\n+    loop {\n+        match iter.next() {\n+            None => break None,\n+            Some((id, Node::Block(_))) => child_id = id,\n+            Some((id, Node::Arm(arm))) if arm.body.hir_id == child_id => child_id = id,\n+            Some((_, Node::Expr(expr))) => match expr.kind {\n+                ExprKind::Break(\n+                    Destination {\n+                        target_id: Ok(dest), ..\n+                    },\n+                    _,\n+                ) => {\n+                    iter = map.parent_iter(dest);\n+                    child_id = dest;\n+                },\n+                ExprKind::DropTemps(_) | ExprKind::Block(..) => child_id = expr.hir_id,\n+                ExprKind::If(control_expr, ..) | ExprKind::Match(control_expr, ..)\n+                    if control_expr.hir_id != child_id =>\n+                {\n+                    child_id = expr.hir_id\n+                },\n+                _ => break Some(Node::Expr(expr)),\n+            },\n+            Some((_, node)) => break Some(node),\n+        }\n+    }\n+}\n+\n+pub fn is_expr_used(tcx: TyCtxt<'_>, expr: &Expr<'_>) -> bool {\n+    !matches!(\n+        get_expr_use_node(tcx, expr),\n+        Some(Node::Stmt(Stmt {\n+            kind: StmtKind::Expr(_) | StmtKind::Semi(_),\n+            ..\n+        }))\n+    )\n+}\n+\n+pub fn get_expr_use_or_unification_node(tcx: TyCtxt<'tcx>, expr: &Expr<'_>) -> Option<Node<'tcx>> {\n+    let map = tcx.hir();\n+    let mut child_id = expr.hir_id;\n+    let mut iter = map.parent_iter(child_id);\n+    loop {\n+        match iter.next() {\n+            None => break None,\n+            Some((id, Node::Block(_))) => child_id = id,\n+            Some((id, Node::Arm(arm))) if arm.body.hir_id == child_id => child_id = id,\n+            Some((_, Node::Expr(expr))) => match expr.kind {\n+                ExprKind::Match(_, [arm], _) if arm.hir_id == child_id => child_id = expr.hir_id,\n+                ExprKind::Block(..) | ExprKind::DropTemps(_) => child_id = expr.hir_id,\n+                ExprKind::If(_, then_expr, None) if then_expr.hir_id == child_id => break None,\n+                _ => break Some(Node::Expr(expr)),\n+            },\n+            Some((_, node)) => break Some(node),\n+        }\n+    }\n+}\n+\n+pub fn is_expr_used_or_unified(tcx: TyCtxt<'_>, expr: &Expr<'_>) -> bool {\n+    !matches!(\n+        get_expr_use_or_unification_node(tcx, expr),\n+        None | Some(Node::Stmt(Stmt {\n+            kind: StmtKind::Expr(_) | StmtKind::Semi(_),\n+            ..\n+        }))\n+    )\n+}\n+\n+pub fn is_expr_final_block_expr(tcx: TyCtxt<'_>, expr: &Expr<'_>) -> bool {\n+    matches!(get_parent_node(tcx, expr.hir_id), Some(Node::Block(..)))\n+}\n+\n pub fn is_no_std_crate(cx: &LateContext<'_>) -> bool {\n     cx.tcx.hir().attrs(hir::CRATE_HIR_ID).iter().any(|attr| {\n         if let ast::AttrKind::Normal(ref attr, _) = attr.kind {\n@@ -1414,28 +1490,43 @@ pub fn peel_hir_pat_refs(pat: &'a Pat<'a>) -> (&'a Pat<'a>, usize) {\n     peel(pat, 0)\n }\n \n+/// Peels of expressions while the given closure returns `Some`.\n+pub fn peel_hir_expr_while<'tcx>(\n+    mut expr: &'tcx Expr<'tcx>,\n+    mut f: impl FnMut(&'tcx Expr<'tcx>) -> Option<&'tcx Expr<'tcx>>,\n+) -> &'tcx Expr<'tcx> {\n+    while let Some(e) = f(expr) {\n+        expr = e;\n+    }\n+    expr\n+}\n+\n /// Peels off up to the given number of references on the expression. Returns the underlying\n /// expression and the number of references removed.\n pub fn peel_n_hir_expr_refs(expr: &'a Expr<'a>, count: usize) -> (&'a Expr<'a>, usize) {\n-    fn f(expr: &'a Expr<'a>, count: usize, target: usize) -> (&'a Expr<'a>, usize) {\n-        match expr.kind {\n-            ExprKind::AddrOf(_, _, expr) if count != target => f(expr, count + 1, target),\n-            _ => (expr, count),\n-        }\n-    }\n-    f(expr, 0, count)\n+    let mut remaining = count;\n+    let e = peel_hir_expr_while(expr, |e| match e.kind {\n+        ExprKind::AddrOf(BorrowKind::Ref, _, e) if remaining != 0 => {\n+            remaining -= 1;\n+            Some(e)\n+        },\n+        _ => None,\n+    });\n+    (e, count - remaining)\n }\n \n /// Peels off all references on the expression. Returns the underlying expression and the number of\n /// references removed.\n pub fn peel_hir_expr_refs(expr: &'a Expr<'a>) -> (&'a Expr<'a>, usize) {\n-    fn f(expr: &'a Expr<'a>, count: usize) -> (&'a Expr<'a>, usize) {\n-        match expr.kind {\n-            ExprKind::AddrOf(BorrowKind::Ref, _, expr) => f(expr, count + 1),\n-            _ => (expr, count),\n-        }\n-    }\n-    f(expr, 0)\n+    let mut count = 0;\n+    let e = peel_hir_expr_while(expr, |e| match e.kind {\n+        ExprKind::AddrOf(BorrowKind::Ref, _, e) => {\n+            count += 1;\n+            Some(e)\n+        },\n+        _ => None,\n+    });\n+    (e, count)\n }\n \n #[macro_export]"}, {"sha": "8066f6c223e72f8460bd40ef8d8fcfe0920af277", "filename": "clippy_utils/src/paths.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce5e927713ddd32096f4e73f7a2c339cc8163d82/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce5e927713ddd32096f4e73f7a2c339cc8163d82/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=ce5e927713ddd32096f4e73f7a2c339cc8163d82", "patch": "@@ -13,7 +13,9 @@ pub(super) const BEGIN_PANIC_FMT: [&str; 3] = [\"std\", \"panicking\", \"begin_panic_\n pub const BINARY_HEAP: [&str; 4] = [\"alloc\", \"collections\", \"binary_heap\", \"BinaryHeap\"];\n pub const BORROW_TRAIT: [&str; 3] = [\"core\", \"borrow\", \"Borrow\"];\n pub const BTREEMAP: [&str; 5] = [\"alloc\", \"collections\", \"btree\", \"map\", \"BTreeMap\"];\n+pub const BTREEMAP_CONTAINS_KEY: [&str; 6] = [\"alloc\", \"collections\", \"btree\", \"map\", \"BTreeMap\", \"contains_key\"];\n pub const BTREEMAP_ENTRY: [&str; 6] = [\"alloc\", \"collections\", \"btree\", \"map\", \"entry\", \"Entry\"];\n+pub const BTREEMAP_INSERT: [&str; 6] = [\"alloc\", \"collections\", \"btree\", \"map\", \"BTreeMap\", \"insert\"];\n pub const BTREESET: [&str; 5] = [\"alloc\", \"collections\", \"btree\", \"set\", \"BTreeSet\"];\n pub const CLONE_TRAIT_METHOD: [&str; 4] = [\"core\", \"clone\", \"Clone\", \"clone\"];\n pub const CMP_MAX: [&str; 3] = [\"core\", \"cmp\", \"max\"];\n@@ -45,7 +47,9 @@ pub const FROM_ITERATOR: [&str; 5] = [\"core\", \"iter\", \"traits\", \"collect\", \"From\n pub const FUTURE_FROM_GENERATOR: [&str; 3] = [\"core\", \"future\", \"from_generator\"];\n pub const HASH: [&str; 3] = [\"core\", \"hash\", \"Hash\"];\n pub const HASHMAP: [&str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"HashMap\"];\n+pub const HASHMAP_CONTAINS_KEY: [&str; 6] = [\"std\", \"collections\", \"hash\", \"map\", \"HashMap\", \"contains_key\"];\n pub const HASHMAP_ENTRY: [&str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"Entry\"];\n+pub const HASHMAP_INSERT: [&str; 6] = [\"std\", \"collections\", \"hash\", \"map\", \"HashMap\", \"insert\"];\n pub const HASHSET: [&str; 5] = [\"std\", \"collections\", \"hash\", \"set\", \"HashSet\"];\n #[cfg(feature = \"internal-lints\")]\n pub const IDENT: [&str; 3] = [\"rustc_span\", \"symbol\", \"Ident\"];"}, {"sha": "53180d1f9f54f699014b50c35f0d1e1eff33b9cc", "filename": "clippy_utils/src/source.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ce5e927713ddd32096f4e73f7a2c339cc8163d82/clippy_utils%2Fsrc%2Fsource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce5e927713ddd32096f4e73f7a2c339cc8163d82/clippy_utils%2Fsrc%2Fsource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fsource.rs?ref=ce5e927713ddd32096f4e73f7a2c339cc8163d82", "patch": "@@ -66,6 +66,15 @@ pub fn indent_of<T: LintContext>(cx: &T, span: Span) -> Option<usize> {\n     snippet_opt(cx, line_span(cx, span)).and_then(|snip| snip.find(|c: char| !c.is_whitespace()))\n }\n \n+/// Gets a snippet of the indentation of the line of a span\n+pub fn snippet_indent<T: LintContext>(cx: &T, span: Span) -> Option<String> {\n+    snippet_opt(cx, line_span(cx, span)).map(|mut s| {\n+        let len = s.len() - s.trim_start().len();\n+        s.truncate(len);\n+        s\n+    })\n+}\n+\n // If the snippet is empty, it's an attribute that was inserted during macro\n // expansion and we want to ignore those, because they could come from external\n // sources that the user has no control over."}, {"sha": "60371c9833c275181170e32f72b98affa067f11f", "filename": "tests/ui/entry.fixed", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/ce5e927713ddd32096f4e73f7a2c339cc8163d82/tests%2Fui%2Fentry.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/ce5e927713ddd32096f4e73f7a2c339cc8163d82/tests%2Fui%2Fentry.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry.fixed?ref=ce5e927713ddd32096f4e73f7a2c339cc8163d82", "patch": "@@ -0,0 +1,101 @@\n+// run-rustfix\n+\n+#![allow(unused, clippy::needless_pass_by_value, clippy::collapsible_if)]\n+#![warn(clippy::map_entry)]\n+\n+use std::collections::{BTreeMap, HashMap};\n+use std::hash::Hash;\n+\n+macro_rules! m {\n+    ($e:expr) => {{ $e }};\n+}\n+\n+fn foo() {}\n+\n+fn hash_map<K: Eq + Hash + Copy, V: Copy>(m: &mut HashMap<K, V>, k: K, v: V, v2: V) {\n+    m.entry(k).or_insert(v);\n+\n+    if let std::collections::hash_map::Entry::Vacant(e) = m.entry(k) {\n+        if true {\n+            e.insert(v);\n+        } else {\n+            e.insert(v2);\n+        }\n+    }\n+\n+    if let std::collections::hash_map::Entry::Vacant(e) = m.entry(k) {\n+        if true {\n+            e.insert(v);\n+        } else {\n+            e.insert(v2);\n+            return;\n+        }\n+    }\n+\n+    if let std::collections::hash_map::Entry::Vacant(e) = m.entry(k) {\n+        foo();\n+        e.insert(v);\n+    }\n+\n+    if let std::collections::hash_map::Entry::Vacant(e) = m.entry(k) {\n+        match 0 {\n+            1 if true => {\n+                e.insert(v);\n+            },\n+            _ => {\n+                e.insert(v2);\n+            },\n+        };\n+    }\n+\n+    if let std::collections::hash_map::Entry::Vacant(e) = m.entry(k) {\n+        match 0 {\n+            0 => {},\n+            1 => {\n+                e.insert(v);\n+            },\n+            _ => {\n+                e.insert(v2);\n+            },\n+        };\n+    }\n+\n+    if let std::collections::hash_map::Entry::Vacant(e) = m.entry(k) {\n+        foo();\n+        match 0 {\n+            0 if false => {\n+                e.insert(v);\n+            },\n+            1 => {\n+                foo();\n+                e.insert(v);\n+            },\n+            2 | 3 => {\n+                for _ in 0..2 {\n+                    foo();\n+                }\n+                if true {\n+                    e.insert(v);\n+                } else {\n+                    e.insert(v2);\n+                };\n+            },\n+            _ => {\n+                e.insert(v2);\n+            },\n+        }\n+    }\n+\n+    if let std::collections::hash_map::Entry::Vacant(e) = m.entry(m!(k)) {\n+        e.insert(m!(v));\n+    }\n+}\n+\n+fn btree_map<K: Eq + Ord + Copy, V: Copy>(m: &mut BTreeMap<K, V>, k: K, v: V, v2: V) {\n+    if let std::collections::btree_map::Entry::Vacant(e) = m.entry(k) {\n+        e.insert(v);\n+        foo();\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "4d3e241de78531fe14f710405bed19715f94a55b", "filename": "tests/ui/entry.rs", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/ce5e927713ddd32096f4e73f7a2c339cc8163d82/tests%2Fui%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce5e927713ddd32096f4e73f7a2c339cc8163d82/tests%2Fui%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry.rs?ref=ce5e927713ddd32096f4e73f7a2c339cc8163d82", "patch": "@@ -0,0 +1,103 @@\n+// run-rustfix\n+\n+#![allow(unused, clippy::needless_pass_by_value, clippy::collapsible_if)]\n+#![warn(clippy::map_entry)]\n+\n+use std::collections::{BTreeMap, HashMap};\n+use std::hash::Hash;\n+\n+macro_rules! m {\n+    ($e:expr) => {{ $e }};\n+}\n+\n+fn foo() {}\n+\n+fn hash_map<K: Eq + Hash + Copy, V: Copy>(m: &mut HashMap<K, V>, k: K, v: V, v2: V) {\n+    if !m.contains_key(&k) {\n+        m.insert(k, v);\n+    }\n+\n+    if !m.contains_key(&k) {\n+        if true {\n+            m.insert(k, v);\n+        } else {\n+            m.insert(k, v2);\n+        }\n+    }\n+\n+    if !m.contains_key(&k) {\n+        if true {\n+            m.insert(k, v);\n+        } else {\n+            m.insert(k, v2);\n+            return;\n+        }\n+    }\n+\n+    if !m.contains_key(&k) {\n+        foo();\n+        m.insert(k, v);\n+    }\n+\n+    if !m.contains_key(&k) {\n+        match 0 {\n+            1 if true => {\n+                m.insert(k, v);\n+            },\n+            _ => {\n+                m.insert(k, v2);\n+            },\n+        };\n+    }\n+\n+    if !m.contains_key(&k) {\n+        match 0 {\n+            0 => {},\n+            1 => {\n+                m.insert(k, v);\n+            },\n+            _ => {\n+                m.insert(k, v2);\n+            },\n+        };\n+    }\n+\n+    if !m.contains_key(&k) {\n+        foo();\n+        match 0 {\n+            0 if false => {\n+                m.insert(k, v);\n+            },\n+            1 => {\n+                foo();\n+                m.insert(k, v);\n+            },\n+            2 | 3 => {\n+                for _ in 0..2 {\n+                    foo();\n+                }\n+                if true {\n+                    m.insert(k, v);\n+                } else {\n+                    m.insert(k, v2);\n+                };\n+            },\n+            _ => {\n+                m.insert(k, v2);\n+            },\n+        }\n+    }\n+\n+    if !m.contains_key(&m!(k)) {\n+        m.insert(m!(k), m!(v));\n+    }\n+}\n+\n+fn btree_map<K: Eq + Ord + Copy, V: Copy>(m: &mut BTreeMap<K, V>, k: K, v: V, v2: V) {\n+    if !m.contains_key(&k) {\n+        m.insert(k, v);\n+        foo();\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "ab108ed6861e0227ea6874710d4dcc7efee084e6", "filename": "tests/ui/entry.stderr", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/ce5e927713ddd32096f4e73f7a2c339cc8163d82/tests%2Fui%2Fentry.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ce5e927713ddd32096f4e73f7a2c339cc8163d82/tests%2Fui%2Fentry.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry.stderr?ref=ce5e927713ddd32096f4e73f7a2c339cc8163d82", "patch": "@@ -0,0 +1,171 @@\n+error: usage of `contains_key` followed by `insert` on a `HashMap`\n+  --> $DIR/entry.rs:16:5\n+   |\n+LL | /     if !m.contains_key(&k) {\n+LL | |         m.insert(k, v);\n+LL | |     }\n+   | |_____^ help: try this: `m.entry(k).or_insert(v);`\n+   |\n+   = note: `-D clippy::map-entry` implied by `-D warnings`\n+\n+error: usage of `contains_key` followed by `insert` on a `HashMap`\n+  --> $DIR/entry.rs:20:5\n+   |\n+LL | /     if !m.contains_key(&k) {\n+LL | |         if true {\n+LL | |             m.insert(k, v);\n+LL | |         } else {\n+LL | |             m.insert(k, v2);\n+LL | |         }\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL |     if let std::collections::hash_map::Entry::Vacant(e) = m.entry(k) {\n+LL |         if true {\n+LL |             e.insert(v);\n+LL |         } else {\n+LL |             e.insert(v2);\n+LL |         }\n+ ...\n+\n+error: usage of `contains_key` followed by `insert` on a `HashMap`\n+  --> $DIR/entry.rs:28:5\n+   |\n+LL | /     if !m.contains_key(&k) {\n+LL | |         if true {\n+LL | |             m.insert(k, v);\n+LL | |         } else {\n+...  |\n+LL | |         }\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL |     if let std::collections::hash_map::Entry::Vacant(e) = m.entry(k) {\n+LL |         if true {\n+LL |             e.insert(v);\n+LL |         } else {\n+LL |             e.insert(v2);\n+LL |             return;\n+ ...\n+\n+error: usage of `contains_key` followed by `insert` on a `HashMap`\n+  --> $DIR/entry.rs:37:5\n+   |\n+LL | /     if !m.contains_key(&k) {\n+LL | |         foo();\n+LL | |         m.insert(k, v);\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL |     if let std::collections::hash_map::Entry::Vacant(e) = m.entry(k) {\n+LL |         foo();\n+LL |         e.insert(v);\n+LL |     }\n+   |\n+\n+error: usage of `contains_key` followed by `insert` on a `HashMap`\n+  --> $DIR/entry.rs:42:5\n+   |\n+LL | /     if !m.contains_key(&k) {\n+LL | |         match 0 {\n+LL | |             1 if true => {\n+LL | |                 m.insert(k, v);\n+...  |\n+LL | |         };\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL |     if let std::collections::hash_map::Entry::Vacant(e) = m.entry(k) {\n+LL |         match 0 {\n+LL |             1 if true => {\n+LL |                 e.insert(v);\n+LL |             },\n+LL |             _ => {\n+ ...\n+\n+error: usage of `contains_key` followed by `insert` on a `HashMap`\n+  --> $DIR/entry.rs:53:5\n+   |\n+LL | /     if !m.contains_key(&k) {\n+LL | |         match 0 {\n+LL | |             0 => {},\n+LL | |             1 => {\n+...  |\n+LL | |         };\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL |     if let std::collections::hash_map::Entry::Vacant(e) = m.entry(k) {\n+LL |         match 0 {\n+LL |             0 => {},\n+LL |             1 => {\n+LL |                 e.insert(v);\n+LL |             },\n+ ...\n+\n+error: usage of `contains_key` followed by `insert` on a `HashMap`\n+  --> $DIR/entry.rs:65:5\n+   |\n+LL | /     if !m.contains_key(&k) {\n+LL | |         foo();\n+LL | |         match 0 {\n+LL | |             0 if false => {\n+...  |\n+LL | |         }\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL |     if let std::collections::hash_map::Entry::Vacant(e) = m.entry(k) {\n+LL |         foo();\n+LL |         match 0 {\n+LL |             0 if false => {\n+LL |                 e.insert(v);\n+LL |             },\n+ ...\n+\n+error: usage of `contains_key` followed by `insert` on a `HashMap`\n+  --> $DIR/entry.rs:91:5\n+   |\n+LL | /     if !m.contains_key(&m!(k)) {\n+LL | |         m.insert(m!(k), m!(v));\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL |     if let std::collections::hash_map::Entry::Vacant(e) = m.entry(m!(k)) {\n+LL |         e.insert(m!(v));\n+LL |     }\n+   |\n+\n+error: usage of `contains_key` followed by `insert` on a `BTreeMap`\n+  --> $DIR/entry.rs:97:5\n+   |\n+LL | /     if !m.contains_key(&k) {\n+LL | |         m.insert(k, v);\n+LL | |         foo();\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL |     if let std::collections::btree_map::Entry::Vacant(e) = m.entry(k) {\n+LL |         e.insert(v);\n+LL |         foo();\n+LL |     }\n+   |\n+\n+error: aborting due to 9 previous errors\n+"}, {"sha": "dcdaae7e72430494a3224bb9f0312ab07e90f274", "filename": "tests/ui/entry_fixable.fixed", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b1c675f3fc682201cdb28719133285b878e2d157/tests%2Fui%2Fentry_fixable.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/b1c675f3fc682201cdb28719133285b878e2d157/tests%2Fui%2Fentry_fixable.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry_fixable.fixed?ref=b1c675f3fc682201cdb28719133285b878e2d157", "patch": "@@ -1,15 +0,0 @@\n-// run-rustfix\n-\n-#![allow(unused, clippy::needless_pass_by_value)]\n-#![warn(clippy::map_entry)]\n-\n-use std::collections::{BTreeMap, HashMap};\n-use std::hash::Hash;\n-\n-fn foo() {}\n-\n-fn insert_if_absent0<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, v: V) {\n-    m.entry(k).or_insert(v);\n-}\n-\n-fn main() {}"}, {"sha": "55d5b21568d0e03223089aad2e5990a3a104d9eb", "filename": "tests/ui/entry_fixable.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b1c675f3fc682201cdb28719133285b878e2d157/tests%2Fui%2Fentry_fixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c675f3fc682201cdb28719133285b878e2d157/tests%2Fui%2Fentry_fixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry_fixable.rs?ref=b1c675f3fc682201cdb28719133285b878e2d157", "patch": "@@ -1,17 +0,0 @@\n-// run-rustfix\n-\n-#![allow(unused, clippy::needless_pass_by_value)]\n-#![warn(clippy::map_entry)]\n-\n-use std::collections::{BTreeMap, HashMap};\n-use std::hash::Hash;\n-\n-fn foo() {}\n-\n-fn insert_if_absent0<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, v: V) {\n-    if !m.contains_key(&k) {\n-        m.insert(k, v);\n-    }\n-}\n-\n-fn main() {}"}, {"sha": "87403200ced5008788562ebe66b8c6c2ea918129", "filename": "tests/ui/entry_fixable.stderr", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b1c675f3fc682201cdb28719133285b878e2d157/tests%2Fui%2Fentry_fixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b1c675f3fc682201cdb28719133285b878e2d157/tests%2Fui%2Fentry_fixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry_fixable.stderr?ref=b1c675f3fc682201cdb28719133285b878e2d157", "patch": "@@ -1,12 +0,0 @@\n-error: usage of `contains_key` followed by `insert` on a `HashMap`\n-  --> $DIR/entry_fixable.rs:12:5\n-   |\n-LL | /     if !m.contains_key(&k) {\n-LL | |         m.insert(k, v);\n-LL | |     }\n-   | |_____^ help: consider using: `m.entry(k).or_insert(v);`\n-   |\n-   = note: `-D clippy::map-entry` implied by `-D warnings`\n-\n-error: aborting due to previous error\n-"}, {"sha": "beb2d5c97b1d98f32babdcb475ce7b8cc528bb7e", "filename": "tests/ui/entry_unfixable.rs", "status": "modified", "additions": 18, "deletions": 41, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/ce5e927713ddd32096f4e73f7a2c339cc8163d82/tests%2Fui%2Fentry_unfixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce5e927713ddd32096f4e73f7a2c339cc8163d82/tests%2Fui%2Fentry_unfixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry_unfixable.rs?ref=ce5e927713ddd32096f4e73f7a2c339cc8163d82", "patch": "@@ -4,50 +4,14 @@\n use std::collections::{BTreeMap, HashMap};\n use std::hash::Hash;\n \n-fn foo() {}\n-\n-fn insert_if_absent2<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, v: V) {\n-    if !m.contains_key(&k) {\n-        m.insert(k, v)\n-    } else {\n-        None\n-    };\n-}\n-\n-fn insert_if_present2<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, v: V) {\n-    if m.contains_key(&k) {\n-        None\n-    } else {\n-        m.insert(k, v)\n-    };\n-}\n-\n-fn insert_if_absent3<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, v: V) {\n-    if !m.contains_key(&k) {\n-        foo();\n-        m.insert(k, v)\n-    } else {\n-        None\n-    };\n-}\n-\n-fn insert_if_present3<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, v: V) {\n-    if m.contains_key(&k) {\n-        None\n-    } else {\n-        foo();\n-        m.insert(k, v)\n+macro_rules! m {\n+    ($map:expr, $key:expr, $value:expr) => {\n+        $map.insert($key, $value)\n     };\n+    ($e:expr) => {{ $e }};\n }\n \n-fn insert_in_btreemap<K: Ord, V>(m: &mut BTreeMap<K, V>, k: K, v: V) {\n-    if !m.contains_key(&k) {\n-        foo();\n-        m.insert(k, v)\n-    } else {\n-        None\n-    };\n-}\n+fn foo() {}\n \n // should not trigger\n fn insert_other_if_absent<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, o: K, v: V) {\n@@ -70,4 +34,17 @@ fn insert_from_different_map2<K: Eq + Hash, V>(m: &mut HashMap<K, V>, n: &mut Ha\n     }\n }\n \n+fn insert_in_macro<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, v: V) {\n+    if !m.contains_key(&k) {\n+        m!(m, k, v);\n+    }\n+}\n+\n+fn use_map_then_insert<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, v: V) {\n+    if !m.contains_key(&k) {\n+        let _ = m.len();\n+        m.insert(k, v);\n+    }\n+}\n+\n fn main() {}"}, {"sha": "e58c8d22dc45e2bc6303f3afeb8dd813ded7c42f", "filename": "tests/ui/entry_unfixable.stderr", "status": "removed", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/b1c675f3fc682201cdb28719133285b878e2d157/tests%2Fui%2Fentry_unfixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b1c675f3fc682201cdb28719133285b878e2d157/tests%2Fui%2Fentry_unfixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry_unfixable.stderr?ref=b1c675f3fc682201cdb28719133285b878e2d157", "patch": "@@ -1,57 +0,0 @@\n-error: usage of `contains_key` followed by `insert` on a `HashMap`\n-  --> $DIR/entry_unfixable.rs:10:5\n-   |\n-LL | /     if !m.contains_key(&k) {\n-LL | |         m.insert(k, v)\n-LL | |     } else {\n-LL | |         None\n-LL | |     };\n-   | |_____^ consider using `m.entry(k)`\n-   |\n-   = note: `-D clippy::map-entry` implied by `-D warnings`\n-\n-error: usage of `contains_key` followed by `insert` on a `HashMap`\n-  --> $DIR/entry_unfixable.rs:18:5\n-   |\n-LL | /     if m.contains_key(&k) {\n-LL | |         None\n-LL | |     } else {\n-LL | |         m.insert(k, v)\n-LL | |     };\n-   | |_____^ consider using `m.entry(k)`\n-\n-error: usage of `contains_key` followed by `insert` on a `HashMap`\n-  --> $DIR/entry_unfixable.rs:26:5\n-   |\n-LL | /     if !m.contains_key(&k) {\n-LL | |         foo();\n-LL | |         m.insert(k, v)\n-LL | |     } else {\n-LL | |         None\n-LL | |     };\n-   | |_____^ consider using `m.entry(k)`\n-\n-error: usage of `contains_key` followed by `insert` on a `HashMap`\n-  --> $DIR/entry_unfixable.rs:35:5\n-   |\n-LL | /     if m.contains_key(&k) {\n-LL | |         None\n-LL | |     } else {\n-LL | |         foo();\n-LL | |         m.insert(k, v)\n-LL | |     };\n-   | |_____^ consider using `m.entry(k)`\n-\n-error: usage of `contains_key` followed by `insert` on a `BTreeMap`\n-  --> $DIR/entry_unfixable.rs:44:5\n-   |\n-LL | /     if !m.contains_key(&k) {\n-LL | |         foo();\n-LL | |         m.insert(k, v)\n-LL | |     } else {\n-LL | |         None\n-LL | |     };\n-   | |_____^ consider using `m.entry(k)`\n-\n-error: aborting due to 5 previous errors\n-"}]}