{"sha": "607af7218b31ed00c8f613deedf8f4f7ae59cd13", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwN2FmNzIxOGIzMWVkMDBjOGY2MTNkZWVkZjhmNGY3YWU1OWNkMTM=", "commit": {"author": {"name": "Mark-Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-11-13T22:25:54Z"}, "committer": {"name": "Mark-Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-11-28T13:37:08Z"}, "message": "Refactor BuiltinBounds to Vec<DefId> on TraitObject.", "tree": {"sha": "4d9c0ececcfd5af4d2bd6fcf8067c291b8a3330c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d9c0ececcfd5af4d2bd6fcf8067c291b8a3330c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/607af7218b31ed00c8f613deedf8f4f7ae59cd13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/607af7218b31ed00c8f613deedf8f4f7ae59cd13", "html_url": "https://github.com/rust-lang/rust/commit/607af7218b31ed00c8f613deedf8f4f7ae59cd13", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/607af7218b31ed00c8f613deedf8f4f7ae59cd13/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "46c7a117f84954ce845c55c90db62952624638de", "url": "https://api.github.com/repos/rust-lang/rust/commits/46c7a117f84954ce845c55c90db62952624638de", "html_url": "https://github.com/rust-lang/rust/commit/46c7a117f84954ce845c55c90db62952624638de"}], "stats": {"total": 211, "additions": 126, "deletions": 85}, "files": [{"sha": "3ae0252e99020827746e846cd81379074595231d", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/607af7218b31ed00c8f613deedf8f4f7ae59cd13/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/607af7218b31ed00c8f613deedf8f4f7ae59cd13/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=607af7218b31ed00c8f613deedf8f4f7ae59cd13", "patch": "@@ -41,6 +41,7 @@ use ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n use traits;\n use ty::fast_reject;\n use ty::relate::TypeRelation;\n+use middle::lang_items;\n \n use rustc_data_structures::bitvec::BitVector;\n use rustc_data_structures::snapshot_vec::{SnapshotVecDelegate, SnapshotVec};\n@@ -49,6 +50,7 @@ use std::fmt;\n use std::marker::PhantomData;\n use std::mem;\n use std::rc::Rc;\n+use std::iter;\n use syntax::abi::Abi;\n use hir;\n use util::nodemap::FxHashMap;\n@@ -1516,16 +1518,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             let self_ty = this.tcx().erase_late_bound_regions(&obligation.self_ty());\n             let poly_trait_ref = match self_ty.sty {\n                 ty::TyTrait(ref data) => {\n-                    match this.tcx().lang_items.to_builtin_kind(obligation.predicate.def_id()) {\n-                        Some(bound @ ty::BoundSend) | Some(bound @ ty::BoundSync) => {\n-                            if data.builtin_bounds.contains(&bound) {\n-                                debug!(\"assemble_candidates_from_object_ty: matched builtin bound, \\\n-                                        pushing candidate\");\n-                                candidates.vec.push(BuiltinObjectCandidate);\n-                                return;\n-                            }\n-                        }\n-                        _ => {}\n+                    if data.auto_traits().any(|did| did == obligation.predicate.def_id()) {\n+                        debug!(\"assemble_candidates_from_object_ty: matched builtin bound, \\\n+                                    pushing candidate\");\n+                        candidates.vec.push(BuiltinObjectCandidate);\n+                        return;\n                     }\n \n                     match data.principal() {\n@@ -1616,7 +1613,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 // #2 (region bounds).\n                 match (data_a.principal(), data_b.principal()) {\n                     (Some(ref a), Some(ref b)) => a.def_id() == b.def_id() &&\n-                        data_a.builtin_bounds.is_superset(&data_b.builtin_bounds),\n+                        data_b.auto_traits()\n+                            // All of a's auto traits need to be in b's auto traits.\n+                            .all(|b| data_a.auto_traits().any(|a| a == b)),\n                     _ => false\n                 }\n             }\n@@ -2481,7 +2480,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 let new_trait = tcx.mk_trait(ty::TraitObject::new(\n                     data_a.principal(),\n                     data_b.region_bound,\n-                    data_b.builtin_bounds,\n+                    data_b.auto_traits().collect(),\n                     data_a.projection_bounds.clone(),\n                 ));\n                 let origin = TypeOrigin::Misc(obligation.cause.span);\n@@ -2504,10 +2503,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             // T -> Trait.\n             (_, &ty::TyTrait(ref data)) => {\n                 let mut object_dids =\n-                    data.builtin_bounds.iter().flat_map(|bound| {\n-                        tcx.lang_items.from_builtin_kind(bound).ok()\n-                    })\n-                    .chain(data.principal().map(|ref p| p.def_id()));\n+                    data.auto_traits().chain(data.principal().map(|ref p| p.def_id()));\n                 if let Some(did) = object_dids.find(|did| {\n                     !tcx.is_object_safe(*did)\n                 }) {\n@@ -2527,19 +2523,21 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 push(data.principal().unwrap().with_self_ty(tcx, source).to_predicate());\n \n                 // We can only make objects from sized types.\n-                let mut builtin_bounds = data.builtin_bounds;\n-                builtin_bounds.insert(ty::BoundSized);\n+                let trait_refs = data.auto_traits()\n+                    .chain(iter::once(\n+                            tcx.lang_items.require(lang_items::SizedTraitLangItem)\n+                            .unwrap_or_else(|msg| tcx.sess.fatal(&msg[..]))))\n+                    .map(|did| ty::TraitRef {\n+                        def_id: did,\n+                        substs: tcx.mk_substs_trait(source, &[]),\n+                    });\n \n                 // Create additional obligations for all the various builtin\n                 // bounds attached to the object cast. (In other words, if the\n                 // object type is Foo+Send, this would create an obligation\n                 // for the Send check.)\n-                for bound in &builtin_bounds {\n-                    if let Ok(tr) = tcx.trait_ref_for_builtin_bound(bound, source) {\n-                        push(tr.to_predicate());\n-                    } else {\n-                        return Err(Unimplemented);\n-                    }\n+                for tr in trait_refs {\n+                    push(tr.to_predicate());\n                 }\n \n                 // Create obligations for the projection predicates."}, {"sha": "569791a0776bfa10b61333122444c44e31779ab5", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/607af7218b31ed00c8f613deedf8f4f7ae59cd13/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/607af7218b31ed00c8f613deedf8f4f7ae59cd13/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=607af7218b31ed00c8f613deedf8f4f7ae59cd13", "patch": "@@ -428,7 +428,11 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n                     |relation| relation.relate_with_variance(ty::Contravariant,\n                                                              &a_obj.region_bound,\n                                                              &b_obj.region_bound))?;\n-            let nb = relation.relate(&a_obj.builtin_bounds, &b_obj.builtin_bounds)?;\n+            let nb = if !a_obj.auto_traits().eq(b_obj.auto_traits()) {\n+                return Err(TypeError::Sorts(expected_found(relation, &a, &b)));\n+            } else {\n+                a_obj.auto_traits().collect()\n+            };\n             let pb = relation.relate(&a_obj.projection_bounds, &b_obj.projection_bounds)?;\n             Ok(tcx.mk_trait(ty::TraitObject::new(principal, r, nb, pb)))\n         }"}, {"sha": "3064e337039d58d155df706c7e7832dde10a56fe", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/607af7218b31ed00c8f613deedf8f4f7ae59cd13/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/607af7218b31ed00c8f613deedf8f4f7ae59cd13/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=607af7218b31ed00c8f613deedf8f4f7ae59cd13", "patch": "@@ -432,7 +432,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::TraitObject<'tcx> {\n         ty::TraitObject::new(\n             self.principal().map(|p| p.fold_with(folder)),\n             self.region_bound.fold_with(folder),\n-            self.builtin_bounds,\n+            self.auto_traits().collect(),\n             self.projection_bounds.fold_with(folder),\n         )\n     }"}, {"sha": "22a7423b17765ad576a5a052f5911401ed05322d", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/607af7218b31ed00c8f613deedf8f4f7ae59cd13/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/607af7218b31ed00c8f613deedf8f4f7ae59cd13/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=607af7218b31ed00c8f613deedf8f4f7ae59cd13", "patch": "@@ -279,25 +279,29 @@ impl<'a, 'gcx, 'acx, 'tcx> ClosureSubsts<'tcx> {\n pub struct TraitObject<'tcx> {\n     principal: Option<PolyExistentialTraitRef<'tcx>>,\n     pub region_bound: &'tcx ty::Region,\n-    pub builtin_bounds: BuiltinBounds,\n+    auto_traits: Vec<DefId>,\n     pub projection_bounds: Vec<PolyExistentialProjection<'tcx>>,\n }\n \n impl<'tcx> TraitObject<'tcx> {\n     pub fn new(principal: Option<PolyExistentialTraitRef<'tcx>>, region_bound: &'tcx ty::Region,\n-               builtin_bounds: BuiltinBounds, projection_bounds: Vec<PolyExistentialProjection<'tcx>>)\n+               auto_traits: Vec<DefId>, projection_bounds: Vec<PolyExistentialProjection<'tcx>>)\n         -> Self {\n         TraitObject {\n             principal: principal,\n             region_bound: region_bound,\n-            builtin_bounds: builtin_bounds,\n+            auto_traits: auto_traits,\n             projection_bounds: projection_bounds,\n         }\n     }\n \n     pub fn principal(&self) -> Option<PolyExistentialTraitRef<'tcx>> {\n         self.principal\n     }\n+\n+    pub fn auto_traits<'a>(&'a self) -> impl Iterator<Item=DefId> + 'a {\n+        self.auto_traits.iter().cloned()\n+    }\n }\n \n /// A complete reference to a trait. These take numerous guises in syntax,\n@@ -833,18 +837,22 @@ impl CLike for BuiltinBound {\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn try_add_builtin_trait(self,\n-                                 trait_def_id: DefId,\n-                                 builtin_bounds: &mut EnumSet<BuiltinBound>)\n+                                 id: DefId,\n+                                 auto_traits: &mut Vec<DefId>)\n                                  -> bool\n     {\n-        //! Checks whether `trait_ref` refers to one of the builtin\n-        //! traits, like `Send`, and adds the corresponding\n-        //! bound to the set `builtin_bounds` if so. Returns true if `trait_ref`\n-        //! is a builtin trait.\n-\n-        match self.lang_items.to_builtin_kind(trait_def_id) {\n-            Some(bound) => { builtin_bounds.insert(bound); true }\n-            None => false\n+        //! Checks whether `id` refers to one of the builtin\n+        //! traits, like `Send`, and adds it to `auto_traits` if so.\n+        //! Returns true if `idf` refers to a builtin trait.\n+\n+        if Some(id) == self.lang_items.send_trait() ||\n+            Some(id) == self.lang_items.sized_trait() ||\n+            Some(id) == self.lang_items.copy_trait() ||\n+            Some(id) == self.lang_items.sync_trait() {\n+            auto_traits.push(id);\n+            true\n+        } else {\n+            false\n         }\n     }\n }"}, {"sha": "7253b88981f1b0b0ba60443bfc1387848a947f9f", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/607af7218b31ed00c8f613deedf8f4f7ae59cd13/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/607af7218b31ed00c8f613deedf8f4f7ae59cd13/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=607af7218b31ed00c8f613deedf8f4f7ae59cd13", "patch": "@@ -535,7 +535,9 @@ impl<'a, 'gcx, 'tcx, H: Hasher> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tc\n                 if let Some(ref p) = data.principal() {\n                     self.def_id(p.def_id());\n                 }\n-                self.hash(data.builtin_bounds);\n+                for d in data.auto_traits() {\n+                    self.def_id(d);\n+                }\n             }\n             TyTuple(tys) => {\n                 self.hash(tys.len());"}, {"sha": "b31046abf86a351225dc3c14ac7054aed7f26701", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/607af7218b31ed00c8f613deedf8f4f7ae59cd13/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/607af7218b31ed00c8f613deedf8f4f7ae59cd13/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=607af7218b31ed00c8f613deedf8f4f7ae59cd13", "patch": "@@ -298,7 +298,6 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n     /// is WF. Returns false if `ty0` is an unresolved type variable,\n     /// in which case we are not able to simplify at all.\n     fn compute(&mut self, ty0: Ty<'tcx>) -> bool {\n-        let tcx = self.infcx.tcx;\n         let mut subtys = ty0.walk();\n         while let Some(ty) = subtys.next() {\n             match ty.sty {\n@@ -391,15 +390,12 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                     let cause = self.cause(traits::MiscObligation);\n \n                     let component_traits =\n-                        data.builtin_bounds.iter().flat_map(|bound| {\n-                            tcx.lang_items.from_builtin_kind(bound).ok()\n-                        })\n-                        .chain(data.principal().map(|ref p| p.def_id()));\n+                        data.auto_traits().chain(data.principal().map(|ref p| p.def_id()));\n                     self.out.extend(\n-                        component_traits.map(|did| { traits::Obligation::new(\n+                        component_traits.map(|did| traits::Obligation::new(\n                             cause.clone(),\n                             ty::Predicate::ObjectSafe(did)\n-                        )})\n+                        ))\n                     );\n                 }\n \n@@ -493,7 +489,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n             let implicit_bounds =\n                 object_region_bounds(self.infcx.tcx,\n                                      data.principal().unwrap(),\n-                                     data.builtin_bounds);\n+                                     data.auto_traits());\n \n             let explicit_bound = data.region_bound;\n \n@@ -512,18 +508,25 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n /// they declare `trait SomeTrait : 'static`, for example, then\n /// `'static` would appear in the list. The hard work is done by\n /// `ty::required_region_bounds`, see that for more information.\n-pub fn object_region_bounds<'a, 'gcx, 'tcx>(\n+pub fn object_region_bounds<'a, 'gcx, 'tcx, I>(\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     principal: ty::PolyExistentialTraitRef<'tcx>,\n-    others: ty::BuiltinBounds)\n+    others: I)\n     -> Vec<&'tcx ty::Region>\n+    where I: Iterator<Item=DefId>\n {\n     // Since we don't actually *know* the self type for an object,\n     // this \"open(err)\" serves as a kind of dummy standin -- basically\n     // a skolemized type.\n     let open_ty = tcx.mk_infer(ty::FreshTy(0));\n \n-    let mut predicates = others.to_predicates(tcx, open_ty);\n+    let mut predicates = others.map(|d| {\n+        let trait_ref = ty::TraitRef {\n+            def_id: d,\n+            substs: tcx.mk_substs_trait(open_ty, &[])\n+        };\n+        trait_ref.to_predicate()\n+    }).collect::<Vec<_>>();\n     predicates.push(principal.with_self_ty(tcx, open_ty).to_predicate());\n \n     tcx.required_region_bounds(open_ty, predicates)"}, {"sha": "a3fa805699c9e601f3945f368ff8cced7d34794e", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/607af7218b31ed00c8f613deedf8f4f7ae59cd13/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/607af7218b31ed00c8f613deedf8f4f7ae59cd13/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=607af7218b31ed00c8f613deedf8f4f7ae59cd13", "patch": "@@ -349,13 +349,15 @@ impl<'tcx> fmt::Display for ty::TraitObject<'tcx> {\n             }).collect();\n \n             let tap = ty::Binder(TraitAndProjections(principal, projections));\n-            in_binder(f, tcx, &ty::Binder(\"\"), Some(tap))\n-        })?;\n+            in_binder(f, tcx, &ty::Binder(\"\"), Some(tap))?;\n \n-        // Builtin bounds.\n-        for bound in &self.builtin_bounds {\n-            write!(f, \" + {:?}\", bound)?;\n-        }\n+            // Builtin bounds.\n+            for did in self.auto_traits() {\n+                write!(f, \" + {}\", tcx.item_path_str(did))?;\n+            }\n+\n+            Ok(())\n+        })?;\n \n         // FIXME: It'd be nice to compute from context when this bound\n         // is implied, but that's non-trivial -- we'd perhaps have to\n@@ -474,10 +476,14 @@ impl<'tcx> fmt::Debug for ty::TraitObject<'tcx> {\n             write!(f, \"{}\", region_str)?;\n         }\n \n-        for bound in &self.builtin_bounds {\n-            maybe_continue(f)?;\n-            write!(f, \"{:?}\", bound)?;\n-        }\n+        ty::tls::with(|tcx| {\n+            for did in self.auto_traits() {\n+                maybe_continue(f)?;\n+                write!(f, \" + {}\", tcx.item_path_str(did))?;\n+            }\n+\n+            Ok(())\n+        })?;\n \n         for projection_bound in &self.projection_bounds {\n             maybe_continue(f)?;"}, {"sha": "bffd85c57f705ab24a004498c91df38d1025e922", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/607af7218b31ed00c8f613deedf8f4f7ae59cd13/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/607af7218b31ed00c8f613deedf8f4f7ae59cd13/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=607af7218b31ed00c8f613deedf8f4f7ae59cd13", "patch": "@@ -1043,7 +1043,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                                         trait_segment,\n                                                         &mut projection_bounds);\n \n-        let PartitionedBounds { builtin_bounds,\n+        let PartitionedBounds { auto_traits,\n                                 trait_bounds,\n                                 region_bounds } =\n             partitioned_bounds;\n@@ -1076,7 +1076,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             self.compute_object_lifetime_bound(span,\n                                                &region_bounds,\n                                                existential_principal,\n-                                               builtin_bounds);\n+                                               &auto_traits);\n \n         let region_bound = match region_bound {\n             Some(r) => r,\n@@ -1138,7 +1138,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let ty = tcx.mk_trait(ty::TraitObject::new(\n             Some(existential_principal),\n             region_bound,\n-            builtin_bounds,\n+            auto_traits,\n             existential_projections\n         ));\n         debug!(\"trait_object_type: {:?}\", ty);\n@@ -1923,16 +1923,16 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         span: Span,\n         explicit_region_bounds: &[&hir::Lifetime],\n         principal_trait_ref: ty::PolyExistentialTraitRef<'tcx>,\n-        builtin_bounds: ty::BuiltinBounds)\n+        auto_traits: &[DefId])\n         -> Option<&'tcx ty::Region> // if None, use the default\n     {\n         let tcx = self.tcx();\n \n         debug!(\"compute_opt_region_bound(explicit_region_bounds={:?}, \\\n-               principal_trait_ref={:?}, builtin_bounds={:?})\",\n+               principal_trait_ref={:?}, auto_traits={:?})\",\n                explicit_region_bounds,\n                principal_trait_ref,\n-               builtin_bounds);\n+               auto_traits);\n \n         if explicit_region_bounds.len() > 1 {\n             span_err!(tcx.sess, explicit_region_bounds[1].span, E0226,\n@@ -1953,7 +1953,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         // No explicit region bound specified. Therefore, examine trait\n         // bounds and see if we can derive region bounds from those.\n         let derived_region_bounds =\n-            object_region_bounds(tcx, principal_trait_ref, builtin_bounds);\n+            object_region_bounds(tcx, principal_trait_ref, auto_traits.into_iter().cloned());\n \n         // If there are no derived region bounds, then report back that we\n         // can find no region bound. The caller will use the default.\n@@ -1980,7 +1980,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n }\n \n pub struct PartitionedBounds<'a> {\n-    pub builtin_bounds: ty::BuiltinBounds,\n+    pub auto_traits: Vec<DefId>,\n     pub trait_bounds: Vec<&'a hir::PolyTraitRef>,\n     pub region_bounds: Vec<&'a hir::Lifetime>,\n }\n@@ -1992,16 +1992,15 @@ pub fn partition_bounds<'a, 'b, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                             ast_bounds: &'b [hir::TyParamBound])\n                                             -> PartitionedBounds<'b>\n {\n-    let mut builtin_bounds = ty::BuiltinBounds::empty();\n+    let mut auto_traits = Vec::new();\n     let mut region_bounds = Vec::new();\n     let mut trait_bounds = Vec::new();\n     for ast_bound in ast_bounds {\n         match *ast_bound {\n             hir::TraitTyParamBound(ref b, hir::TraitBoundModifier::None) => {\n                 match b.trait_ref.path.def {\n                     Def::Trait(trait_did) => {\n-                        if tcx.try_add_builtin_trait(trait_did,\n-                                                     &mut builtin_bounds) {\n+                        if tcx.try_add_builtin_trait(trait_did, &mut auto_traits) {\n                             let segments = &b.trait_ref.path.segments;\n                             let parameters = &segments[segments.len() - 1].parameters;\n                             if !parameters.types().is_empty() {\n@@ -2030,7 +2029,7 @@ pub fn partition_bounds<'a, 'b, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     }\n \n     PartitionedBounds {\n-        builtin_bounds: builtin_bounds,\n+        auto_traits: auto_traits,\n         trait_bounds: trait_bounds,\n         region_bounds: region_bounds,\n     }\n@@ -2105,7 +2104,7 @@ fn report_lifetime_number_error(tcx: TyCtxt, span: Span, number: usize, expected\n #[derive(PartialEq, Eq, Clone, Debug)]\n pub struct Bounds<'tcx> {\n     pub region_bounds: Vec<&'tcx ty::Region>,\n-    pub builtin_bounds: ty::BuiltinBounds,\n+    pub auto_traits: Vec<DefId>,\n     pub trait_bounds: Vec<ty::PolyTraitRef<'tcx>>,\n     pub projection_bounds: Vec<ty::PolyProjectionPredicate<'tcx>>,\n }\n@@ -2116,11 +2115,12 @@ impl<'a, 'gcx, 'tcx> Bounds<'tcx> {\n     {\n         let mut vec = Vec::new();\n \n-        for builtin_bound in &self.builtin_bounds {\n-            match tcx.trait_ref_for_builtin_bound(builtin_bound, param_ty) {\n-                Ok(trait_ref) => { vec.push(trait_ref.to_predicate()); }\n-                Err(ErrorReported) => { }\n-            }\n+        for trait_did in &self.auto_traits {\n+           let trait_ref = ty::TraitRef {\n+               def_id: *trait_did,\n+               substs: tcx.mk_substs_trait(param_ty, &[]),\n+           };\n+           vec.push(trait_ref.to_predicate());\n         }\n \n         for &region_bound in &self.region_bounds {"}, {"sha": "0f8fe32c8982e73e5e98e2308b7bdde4c6a53234", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/607af7218b31ed00c8f613deedf8f4f7ae59cd13/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/607af7218b31ed00c8f613deedf8f4f7ae59cd13/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=607af7218b31ed00c8f613deedf8f4f7ae59cd13", "patch": "@@ -1586,7 +1586,7 @@ fn convert_foreign_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n // Add the Sized bound, unless the type parameter is marked as `?Sized`.\n fn add_unsized_bound<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n-                                       bounds: &mut ty::BuiltinBounds,\n+                                       bounds: &mut Vec<DefId>,\n                                        ast_bounds: &[hir::TyParamBound],\n                                        span: Span)\n {\n@@ -1908,13 +1908,13 @@ pub fn compute_bounds<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n {\n     let tcx = astconv.tcx();\n     let PartitionedBounds {\n-        mut builtin_bounds,\n+        mut auto_traits,\n         trait_bounds,\n         region_bounds\n     } = partition_bounds(tcx, span, &ast_bounds);\n \n     if let SizedByDefault::Yes = sized_by_default {\n-        add_unsized_bound(astconv, &mut builtin_bounds, ast_bounds, span);\n+        add_unsized_bound(astconv, &mut auto_traits, ast_bounds, span);\n     }\n \n     let mut projection_bounds = vec![];\n@@ -1935,7 +1935,7 @@ pub fn compute_bounds<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n \n     Bounds {\n         region_bounds: region_bounds,\n-        builtin_bounds: builtin_bounds,\n+        auto_traits: auto_traits,\n         trait_bounds: trait_bounds,\n         projection_bounds: projection_bounds,\n     }"}, {"sha": "6b0f0ae12975c3c2d72b41ee01408ad2534f3d34", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/607af7218b31ed00c8f613deedf8f4f7ae59cd13/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/607af7218b31ed00c8f613deedf8f4f7ae59cd13/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=607af7218b31ed00c8f613deedf8f4f7ae59cd13", "patch": "@@ -1883,8 +1883,28 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n \n                     let mut typarams = vec![];\n                     obj.region_bound.clean(cx).map(|b| typarams.push(RegionBound(b)));\n-                    for bb in &obj.builtin_bounds {\n-                        typarams.push(bb.clean(cx));\n+                    for did in obj.auto_traits() {\n+                        let tcx = match cx.tcx_opt() {\n+                            Some(tcx) => tcx,\n+                            None => {\n+                                typarams.push(RegionBound(Lifetime::statik()));\n+                                continue;\n+                            }\n+                        };\n+                        let empty = tcx.intern_substs(&[]);\n+                        let path = external_path(cx, &tcx.item_name(did).as_str(),\n+                            Some(did), false, vec![], empty);\n+                        inline::record_extern_fqn(cx, did, TypeKind::Trait);\n+                        let bound = TraitBound(PolyTrait {\n+                            trait_: ResolvedPath {\n+                                path: path,\n+                                typarams: None,\n+                                did: did,\n+                                is_generic: false,\n+                            },\n+                            lifetimes: vec![]\n+                        }, hir::TraitBoundModifier::None);\n+                        typarams.push(bound);\n                     }\n \n                     let mut bindings = vec![];"}]}