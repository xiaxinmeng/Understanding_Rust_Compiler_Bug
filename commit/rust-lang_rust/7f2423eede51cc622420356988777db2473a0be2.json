{"sha": "7f2423eede51cc622420356988777db2473a0be2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmMjQyM2VlZGU1MWNjNjIyNDIwMzU2OTg4Nzc3ZGIyNDczYTBiZTI=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-08-07T12:43:43Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-08-11T10:11:38Z"}, "message": "Use ItemLocalId as key for node_types, node_substs, and adjustments in TypeckTables.", "tree": {"sha": "15338bec5c4128dd527c9a1cc6becae7911c9454", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15338bec5c4128dd527c9a1cc6becae7911c9454"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f2423eede51cc622420356988777db2473a0be2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f2423eede51cc622420356988777db2473a0be2", "html_url": "https://github.com/rust-lang/rust/commit/7f2423eede51cc622420356988777db2473a0be2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f2423eede51cc622420356988777db2473a0be2/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "783ccc443b88884a10eed564e0fdc3c1e6f974a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/783ccc443b88884a10eed564e0fdc3c1e6f974a4", "html_url": "https://github.com/rust-lang/rust/commit/783ccc443b88884a10eed564e0fdc3c1e6f974a4"}], "stats": {"total": 490, "additions": 282, "deletions": 208}, "files": [{"sha": "356d8209ce55c41cf187deb2108d9d3938301ce4", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=7f2423eede51cc622420356988777db2473a0be2", "patch": "@@ -904,8 +904,10 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_local(&mut self, l: &Local) -> P<hir::Local> {\n+        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(l.id);\n         P(hir::Local {\n-            id: self.lower_node_id(l.id).node_id,\n+            id: node_id,\n+            hir_id,\n             ty: l.ty.as_ref().map(|t| self.lower_ty(t)),\n             pat: self.lower_pat(&l.pat),\n             init: l.init.as_ref().map(|e| P(self.lower_expr(e))),\n@@ -2675,11 +2677,14 @@ impl<'a> LoweringContext<'a> {\n                     pat: P<hir::Pat>,\n                     source: hir::LocalSource)\n                     -> hir::Stmt {\n+        let LoweredNodeId { node_id, hir_id } = self.next_id();\n+\n         let local = P(hir::Local {\n             pat,\n             ty: None,\n             init: ex,\n-            id: self.next_id().node_id,\n+            id: node_id,\n+            hir_id,\n             span: sp,\n             attrs: ThinVec::new(),\n             source,"}, {"sha": "1831814b0f4c48443ce9784c24f999afd33f1745", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=7f2423eede51cc622420356988777db2473a0be2", "patch": "@@ -901,6 +901,7 @@ pub struct Local {\n     /// Initializer expression to set the value, if any\n     pub init: Option<P<Expr>>,\n     pub id: NodeId,\n+    pub hir_id: HirId,\n     pub span: Span,\n     pub attrs: ThinVec<Attribute>,\n     pub source: LocalSource,"}, {"sha": "218483232d673f66f362f9a565a1808f677a9681", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=7f2423eede51cc622420356988777db2473a0be2", "patch": "@@ -14,7 +14,7 @@ use hir::map::DefPathHash;\n use ich::{self, CachingCodemapView};\n use session::config::DebugInfoLevel::NoDebugInfo;\n use ty;\n-use util::nodemap::NodeMap;\n+use util::nodemap::{NodeMap, ItemLocalMap};\n \n use std::hash as std_hash;\n use std::collections::{HashMap, HashSet, BTreeMap};\n@@ -358,6 +358,18 @@ pub fn hash_stable_nodemap<'a, 'tcx, 'gcx, V, W>(\n     });\n }\n \n+pub fn hash_stable_itemlocalmap<'a, 'tcx, 'gcx, V, W>(\n+    hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+    hasher: &mut StableHasher<W>,\n+    map: &ItemLocalMap<V>)\n+    where V: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>,\n+          W: StableHasherResult,\n+{\n+    hash_stable_hashmap(hcx, hasher, map, |_, local_id| {\n+        *local_id\n+    });\n+}\n+\n \n pub fn hash_stable_btreemap<'a, 'tcx, 'gcx, K, V, SK, F, W>(\n     hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,"}, {"sha": "4c70816c0b83300e1337cc23c95f3fc437261dcf", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=7f2423eede51cc622420356988777db2473a0be2", "patch": "@@ -506,6 +506,7 @@ impl_stable_hash_for!(struct hir::Local {\n     ty,\n     init,\n     id,\n+    hir_id,\n     span,\n     attrs,\n     source"}, {"sha": "ab505141880205746ae0d57c21a2871cef3381ba", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=7f2423eede51cc622420356988777db2473a0be2", "patch": "@@ -638,12 +638,10 @@ for ty::TypeckTables<'gcx> {\n         } = *self;\n \n         hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n-            ich::hash_stable_hashmap(hcx, hasher, type_dependent_defs, |_, item_local_id| {\n-                *item_local_id\n-            });\n-            ich::hash_stable_nodemap(hcx, hasher, node_types);\n-            ich::hash_stable_nodemap(hcx, hasher, node_substs);\n-            ich::hash_stable_nodemap(hcx, hasher, adjustments);\n+            ich::hash_stable_itemlocalmap(hcx, hasher, type_dependent_defs);\n+            ich::hash_stable_itemlocalmap(hcx, hasher, node_types);\n+            ich::hash_stable_itemlocalmap(hcx, hasher, node_substs);\n+            ich::hash_stable_itemlocalmap(hcx, hasher, adjustments);\n             ich::hash_stable_nodemap(hcx, hasher, pat_binding_modes);\n             ich::hash_stable_hashmap(hcx, hasher, upvar_capture_map, |hcx, up_var_id| {\n                 let ty::UpvarId {"}, {"sha": "dcf84be0eeb3ad192fd6c0b0cc6256fb0bc14c44", "filename": "src/librustc/ich/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc%2Fich%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc%2Fich%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fmod.rs?ref=7f2423eede51cc622420356988777db2473a0be2", "patch": "@@ -14,7 +14,7 @@ pub use self::fingerprint::Fingerprint;\n pub use self::caching_codemap_view::CachingCodemapView;\n pub use self::hcx::{StableHashingContext, NodeIdHashingMode, hash_stable_hashmap,\n                     hash_stable_hashset, hash_stable_nodemap,\n-                    hash_stable_btreemap};\n+                    hash_stable_btreemap, hash_stable_itemlocalmap};\n mod fingerprint;\n mod caching_codemap_view;\n mod hcx;"}, {"sha": "22d9a9e313b77b1f7fa256a05f0bf65d5da6ff88", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=7f2423eede51cc622420356988777db2473a0be2", "patch": "@@ -8,13 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use hir::{self, Local, Pat, Body};\n+use hir::{self, Local, Pat, Body, HirId};\n use hir::intravisit::{self, Visitor, NestedVisitorMap};\n use infer::InferCtxt;\n use infer::type_variable::TypeVariableOrigin;\n use ty::{self, Ty, TyInfer, TyVar};\n-\n-use syntax::ast::NodeId;\n use syntax_pos::Span;\n \n struct FindLocalByTypeVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n@@ -26,7 +24,7 @@ struct FindLocalByTypeVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n }\n \n impl<'a, 'gcx, 'tcx> FindLocalByTypeVisitor<'a, 'gcx, 'tcx> {\n-    fn node_matches_type(&mut self, node_id: NodeId) -> bool {\n+    fn node_matches_type(&mut self, node_id: HirId) -> bool {\n         let ty_opt = self.infcx.in_progress_tables.and_then(|tables| {\n             tables.borrow().node_id_to_type_opt(node_id)\n         });\n@@ -56,15 +54,15 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindLocalByTypeVisitor<'a, 'gcx, 'tcx> {\n     }\n \n     fn visit_local(&mut self, local: &'gcx Local) {\n-        if self.found_local_pattern.is_none() && self.node_matches_type(local.id) {\n+        if self.found_local_pattern.is_none() && self.node_matches_type(local.hir_id) {\n             self.found_local_pattern = Some(&*local.pat);\n         }\n         intravisit::walk_local(self, local);\n     }\n \n     fn visit_body(&mut self, body: &'gcx Body) {\n         for argument in &body.arguments {\n-            if self.found_arg_pattern.is_none() && self.node_matches_type(argument.id) {\n+            if self.found_arg_pattern.is_none() && self.node_matches_type(argument.hir_id) {\n                 self.found_arg_pattern = Some(&*argument.pat);\n             }\n         }"}, {"sha": "c8f78367420e64e0c00a52c98cb80bdb6999bbb1", "filename": "src/librustc/infer/error_reporting/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc%2Finfer%2Ferror_reporting%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc%2Finfer%2Ferror_reporting%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Futil.rs?ref=7f2423eede51cc622420356988777db2473a0be2", "patch": "@@ -46,7 +46,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                             .iter()\n                             .enumerate()\n                             .filter_map(|(index, arg)| {\n-                                let ty = tables.borrow().node_id_to_type(arg.id);\n+                                let ty = tables.borrow().node_id_to_type(arg.hir_id);\n                                 let mut found_anon_region = false;\n                                 let new_arg_ty = self.tcx\n                                     .fold_regions(&ty, &mut false, |r, _| if *r == *anon_region {"}, {"sha": "0cca5690c018e676652b5aec1de496cc811f7d37", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=7f2423eede51cc622420356988777db2473a0be2", "patch": "@@ -121,7 +121,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                                   pats: &[codemap::Spanned<hir::FieldPat>]) {\n \n \n-        let variant = match self.tables.node_id_to_type(lhs.id).sty {\n+        let variant = match self.tables.node_id_to_type(lhs.hir_id).sty {\n             ty::TyAdt(adt, _) => adt.variant_of_def(def),\n             _ => span_bug!(lhs.span, \"non-ADT in struct pattern\")\n         };"}, {"sha": "b44f1c7da739e7e890b6aca6e1ab87731a934178", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=7f2423eede51cc622420356988777db2473a0be2", "patch": "@@ -296,7 +296,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         debug!(\"consume_body(body={:?})\", body);\n \n         for arg in &body.arguments {\n-            let arg_ty = return_if_err!(self.mc.node_ty(arg.pat.id));\n+            let arg_ty = return_if_err!(self.mc.node_ty(arg.pat.hir_id));\n \n             let fn_body_scope_r = self.tcx().node_scope_region(body.value.id);\n             let arg_cmt = self.mc.cat_rvalue(\n@@ -826,7 +826,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 let bm = *mc.tables.pat_binding_modes.get(&pat.id).expect(\"missing binding mode\");\n \n                 // pat_ty: the type of the binding being produced.\n-                let pat_ty = return_if_err!(mc.node_ty(pat.id));\n+                let pat_ty = return_if_err!(mc.node_ty(pat.hir_id));\n \n                 // Each match binding is effectively an assignment to the\n                 // binding being produced.\n@@ -923,8 +923,9 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                         -> mc::McResult<mc::cmt<'tcx>> {\n         // Create the cmt for the variable being borrowed, from the\n         // caller's perspective\n-        let var_id = self.tcx().hir.as_local_node_id(upvar_def.def_id()).unwrap();\n-        let var_ty = self.mc.node_ty(var_id)?;\n+        let var_node_id = self.tcx().hir.as_local_node_id(upvar_def.def_id()).unwrap();\n+        let var_hir_id = self.tcx().hir.node_to_hir_id(var_node_id);\n+        let var_ty = self.mc.node_ty(var_hir_id)?;\n         self.mc.cat_def(closure_id, closure_span, var_ty, upvar_def)\n     }\n }"}, {"sha": "0a4e5094cde773b949a07f9ea8b4215b4e581a35", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=7f2423eede51cc622420356988777db2473a0be2", "patch": "@@ -152,7 +152,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ExprVisitor<'a, 'tcx> {\n         };\n         if let Def::Fn(did) = def {\n             if self.def_id_is_transmute(did) {\n-                let typ = self.tables.node_id_to_type(expr.id);\n+                let typ = self.tables.node_id_to_type(expr.hir_id);\n                 let sig = typ.fn_sig(self.tcx);\n                 let from = sig.inputs().skip_binder()[0];\n                 let to = *sig.output().skip_binder();"}, {"sha": "7a949cf38b3623e49b3e694b2ac78ebb1ff0ea57", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=7f2423eede51cc622420356988777db2473a0be2", "patch": "@@ -435,7 +435,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n     }\n \n     fn resolve_type_vars_or_error(&self,\n-                                  id: ast::NodeId,\n+                                  id: hir::HirId,\n                                   ty: Option<Ty<'tcx>>)\n                                   -> McResult<Ty<'tcx>> {\n         match ty {\n@@ -451,26 +451,30 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             // FIXME\n             None if self.is_tainted_by_errors() => Err(()),\n             None => {\n+                let id = self.tcx.hir.definitions().find_node_for_hir_id(id);\n                 bug!(\"no type for node {}: {} in mem_categorization\",\n                      id, self.tcx.hir.node_to_string(id));\n             }\n         }\n     }\n \n-    pub fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>> {\n-        self.resolve_type_vars_or_error(id, self.tables.node_id_to_type_opt(id))\n+    pub fn node_ty(&self,\n+                   hir_id: hir::HirId)\n+                   -> McResult<Ty<'tcx>> {\n+        self.resolve_type_vars_or_error(hir_id,\n+                                        self.tables.node_id_to_type_opt(hir_id))\n     }\n \n     pub fn expr_ty(&self, expr: &hir::Expr) -> McResult<Ty<'tcx>> {\n-        self.resolve_type_vars_or_error(expr.id, self.tables.expr_ty_opt(expr))\n+        self.resolve_type_vars_or_error(expr.hir_id, self.tables.expr_ty_opt(expr))\n     }\n \n     pub fn expr_ty_adjusted(&self, expr: &hir::Expr) -> McResult<Ty<'tcx>> {\n-        self.resolve_type_vars_or_error(expr.id, self.tables.expr_ty_adjusted_opt(expr))\n+        self.resolve_type_vars_or_error(expr.hir_id, self.tables.expr_ty_adjusted_opt(expr))\n     }\n \n     fn pat_ty(&self, pat: &hir::Pat) -> McResult<Ty<'tcx>> {\n-        let base_ty = self.node_ty(pat.id)?;\n+        let base_ty = self.node_ty(pat.hir_id)?;\n         // FIXME (Issue #18207): This code detects whether we are\n         // looking at a `ref x`, and if so, figures out what the type\n         // *being borrowed* is.  But ideally we would put in a more\n@@ -714,7 +718,8 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n         let upvar_id = ty::UpvarId { var_id,\n                                      closure_expr_id: fn_node_id };\n-        let var_ty = self.node_ty(var_id)?;\n+        let var_hir_id = self.tcx.hir.node_to_hir_id(var_id);\n+        let var_ty = self.node_ty(var_hir_id)?;\n \n         // Mutability of original variable itself\n         let var_mutbl = MutabilityCategory::from_local(self.tcx, self.tables, var_id);"}, {"sha": "528fb4e2e7fcf85850ddd624baaa924091b44b86", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 24, "deletions": 18, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=7f2423eede51cc622420356988777db2473a0be2", "patch": "@@ -57,7 +57,7 @@ use std::ops::Deref;\n use std::iter;\n use std::rc::Rc;\n use syntax::abi;\n-use syntax::ast::{self, Name, NodeId};\n+use syntax::ast::{self, Name};\n use syntax::attr;\n use syntax::codemap::MultiSpan;\n use syntax::symbol::{Symbol, keywords};\n@@ -219,15 +219,15 @@ pub struct TypeckTables<'tcx> {\n     /// Stores the types for various nodes in the AST.  Note that this table\n     /// is not guaranteed to be populated until after typeck.  See\n     /// typeck::check::fn_ctxt for details.\n-    pub node_types: NodeMap<Ty<'tcx>>,\n+    pub node_types: ItemLocalMap<Ty<'tcx>>,\n \n     /// Stores the type parameters which were substituted to obtain the type\n     /// of this node.  This only applies to nodes that refer to entities\n     /// parameterized by type parameters, such as generic fns, types, or\n     /// other items.\n-    pub node_substs: NodeMap<&'tcx Substs<'tcx>>,\n+    pub node_substs: ItemLocalMap<&'tcx Substs<'tcx>>,\n \n-    pub adjustments: NodeMap<Vec<ty::adjustment::Adjustment<'tcx>>>,\n+    pub adjustments: ItemLocalMap<Vec<ty::adjustment::Adjustment<'tcx>>>,\n \n     // Stores the actual binding mode for all instances of hir::BindingAnnotation.\n     pub pat_binding_modes: NodeMap<BindingMode>,\n@@ -278,9 +278,9 @@ impl<'tcx> TypeckTables<'tcx> {\n         TypeckTables {\n             local_id_root,\n             type_dependent_defs: ItemLocalMap(),\n-            node_types: FxHashMap(),\n-            node_substs: NodeMap(),\n-            adjustments: NodeMap(),\n+            node_types: ItemLocalMap(),\n+            node_substs: ItemLocalMap(),\n+            adjustments: ItemLocalMap(),\n             pat_binding_modes: NodeMap(),\n             upvar_capture_map: FxHashMap(),\n             closure_tys: NodeMap(),\n@@ -305,32 +305,37 @@ impl<'tcx> TypeckTables<'tcx> {\n         }\n     }\n \n-    pub fn node_id_to_type(&self, id: NodeId) -> Ty<'tcx> {\n+    pub fn node_id_to_type(&self, id: hir::HirId) -> Ty<'tcx> {\n         match self.node_id_to_type_opt(id) {\n             Some(ty) => ty,\n             None => {\n                 bug!(\"node_id_to_type: no type for node `{}`\",\n-                     tls::with(|tcx| tcx.hir.node_to_string(id)))\n+                    tls::with(|tcx| {\n+                        let id = tcx.hir.definitions().find_node_for_hir_id(id);\n+                        tcx.hir.node_to_string(id)\n+                    }))\n             }\n         }\n     }\n \n-    pub fn node_id_to_type_opt(&self, id: NodeId) -> Option<Ty<'tcx>> {\n-        self.node_types.get(&id).cloned()\n+    pub fn node_id_to_type_opt(&self, id: hir::HirId) -> Option<Ty<'tcx>> {\n+        self.validate_hir_id(id);\n+        self.node_types.get(&id.local_id).cloned()\n     }\n \n-    pub fn node_substs(&self, id: NodeId) -> &'tcx Substs<'tcx> {\n-        self.node_substs.get(&id).cloned().unwrap_or(Substs::empty())\n+    pub fn node_substs(&self, id: hir::HirId) -> &'tcx Substs<'tcx> {\n+        self.validate_hir_id(id);\n+        self.node_substs.get(&id.local_id).cloned().unwrap_or(Substs::empty())\n     }\n \n     // Returns the type of a pattern as a monotype. Like @expr_ty, this function\n     // doesn't provide type parameter substitutions.\n     pub fn pat_ty(&self, pat: &hir::Pat) -> Ty<'tcx> {\n-        self.node_id_to_type(pat.id)\n+        self.node_id_to_type(pat.hir_id)\n     }\n \n     pub fn pat_ty_opt(&self, pat: &hir::Pat) -> Option<Ty<'tcx>> {\n-        self.node_id_to_type_opt(pat.id)\n+        self.node_id_to_type_opt(pat.hir_id)\n     }\n \n     // Returns the type of an expression as a monotype.\n@@ -344,16 +349,17 @@ impl<'tcx> TypeckTables<'tcx> {\n     // ask for the type of \"id\" in \"id(3)\", it will return \"fn(&isize) -> isize\"\n     // instead of \"fn(ty) -> T with T = isize\".\n     pub fn expr_ty(&self, expr: &hir::Expr) -> Ty<'tcx> {\n-        self.node_id_to_type(expr.id)\n+        self.node_id_to_type(expr.hir_id)\n     }\n \n     pub fn expr_ty_opt(&self, expr: &hir::Expr) -> Option<Ty<'tcx>> {\n-        self.node_id_to_type_opt(expr.id)\n+        self.node_id_to_type_opt(expr.hir_id)\n     }\n \n     pub fn expr_adjustments(&self, expr: &hir::Expr)\n                             -> &[ty::adjustment::Adjustment<'tcx>] {\n-        self.adjustments.get(&expr.id).map_or(&[], |a| &a[..])\n+        self.validate_hir_id(expr.hir_id);\n+        self.adjustments.get(&expr.hir_id.local_id).map_or(&[], |a| &a[..])\n     }\n \n     /// Returns the type of `expr`, considering any `Adjustment`"}, {"sha": "7a89d1f09d39ad51321ec2e89c54251c259b491b", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=7f2423eede51cc622420356988777db2473a0be2", "patch": "@@ -155,7 +155,9 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n     }\n \n     fn decl_without_init(&mut self, id: ast::NodeId, _span: Span) {\n-        let ty = self.bccx.tables.node_id_to_type(id);\n+        let ty = self.bccx\n+                     .tables\n+                     .node_id_to_type(self.bccx.tcx.hir.node_to_hir_id(id));\n         gather_moves::gather_decl(self.bccx, &self.move_data, id, ty);\n     }\n }"}, {"sha": "0d92bff02b12bdf50988178b2cb0fd40c8dc91e0", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=7f2423eede51cc622420356988777db2473a0be2", "patch": "@@ -188,7 +188,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n \n             // Then, if the match has no arms, check whether the scrutinee\n             // is uninhabited.\n-            let pat_ty = self.tables.node_id_to_type(scrut.id);\n+            let pat_ty = self.tables.node_id_to_type(scrut.hir_id);\n             let module = self.tcx.hir.get_module_parent(scrut.id);\n             if inlined_arms.is_empty() {\n                 let scrutinee_is_uninhabited = if self.tcx.sess.features.borrow().never_type {\n@@ -217,7 +217,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n                 .flat_map(|arm| &arm.0)\n                 .map(|pat| vec![pat.0])\n                 .collect();\n-            let scrut_ty = self.tables.node_id_to_type(scrut.id);\n+            let scrut_ty = self.tables.node_id_to_type(scrut.hir_id);\n             check_exhaustive(cx, scrut_ty, scrut.span, &matrix);\n         })\n     }\n@@ -494,7 +494,7 @@ fn check_legality_of_move_bindings(cx: &MatchVisitor,\n                 let bm = *cx.tables.pat_binding_modes.get(&p.id).expect(\"missing binding mode\");\n                 match bm {\n                     ty::BindByValue(..) => {\n-                        let pat_ty = cx.tables.node_id_to_type(p.id);\n+                        let pat_ty = cx.tables.node_id_to_type(p.hir_id);\n                         if pat_ty.moves_by_default(cx.tcx, cx.param_env, pat.span) {\n                             check_move(p, sub.as_ref().map(|p| &**p));\n                         }"}, {"sha": "c0a050cb6b43c904af273c96fd4d99ab33877eff", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=7f2423eede51cc622420356988777db2473a0be2", "patch": "@@ -275,7 +275,7 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n         }\n       }\n       hir::ExprPath(ref qpath) => {\n-        let substs = cx.tables.node_substs(e.id).subst(tcx, cx.substs);\n+        let substs = cx.tables.node_substs(e.hir_id).subst(tcx, cx.substs);\n           match cx.tables.qpath_def(qpath, e.hir_id) {\n               Def::Const(def_id) |\n               Def::AssociatedConst(def_id) => {"}, {"sha": "bad9895420a0035910560945012fc3cb64060a24", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=7f2423eede51cc622420356988777db2473a0be2", "patch": "@@ -303,7 +303,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n     }\n \n     pub fn lower_pattern(&mut self, pat: &hir::Pat) -> Pattern<'tcx> {\n-        let mut ty = self.tables.node_id_to_type(pat.id);\n+        let mut ty = self.tables.node_id_to_type(pat.hir_id);\n \n         let kind = match pat.node {\n             PatKind::Wild => PatternKind::Wild,\n@@ -321,7 +321,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             }\n \n             PatKind::Path(ref qpath) => {\n-                return self.lower_path(qpath, (pat.id, pat.hir_id), pat.id, pat.span);\n+                return self.lower_path(qpath, pat.hir_id, pat.id, pat.span);\n             }\n \n             PatKind::Ref(ref subpattern, _) |\n@@ -330,7 +330,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             }\n \n             PatKind::Slice(ref prefix, ref slice, ref suffix) => {\n-                let ty = self.tables.node_id_to_type(pat.id);\n+                let ty = self.tables.node_id_to_type(pat.hir_id);\n                 match ty.sty {\n                     ty::TyRef(_, mt) =>\n                         PatternKind::Deref {\n@@ -355,7 +355,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             }\n \n             PatKind::Tuple(ref subpatterns, ddpos) => {\n-                let ty = self.tables.node_id_to_type(pat.id);\n+                let ty = self.tables.node_id_to_type(pat.hir_id);\n                 match ty.sty {\n                     ty::TyTuple(ref tys, _) => {\n                         let subpatterns =\n@@ -376,7 +376,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n \n             PatKind::Binding(_, def_id, ref ident, ref sub) => {\n                 let id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n-                let var_ty = self.tables.node_id_to_type(pat.id);\n+                let var_ty = self.tables.node_id_to_type(pat.hir_id);\n                 let region = match var_ty.sty {\n                     ty::TyRef(r, _) => Some(r),\n                     _ => None,\n@@ -590,12 +590,12 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n \n     fn lower_path(&mut self,\n                   qpath: &hir::QPath,\n-                  (id, hir_id): (ast::NodeId, hir::HirId),\n+                  id: hir::HirId,\n                   pat_id: ast::NodeId,\n                   span: Span)\n                   -> Pattern<'tcx> {\n         let ty = self.tables.node_id_to_type(id);\n-        let def = self.tables.qpath_def(qpath, hir_id);\n+        let def = self.tables.qpath_def(qpath, id);\n         let kind = match def {\n             Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n                 let substs = self.tables.node_substs(id);\n@@ -695,7 +695,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                     hir::ExprPath(ref qpath) => qpath,\n                     _ => bug!()\n                 };\n-                let ty = self.tables.node_id_to_type(callee.id);\n+                let ty = self.tables.node_id_to_type(callee.hir_id);\n                 let def = self.tables.qpath_def(qpath, callee.hir_id);\n                 match def {\n                     Def::Fn(..) | Def::Method(..) => self.lower_lit(expr),\n@@ -755,7 +755,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             }\n \n             hir::ExprPath(ref qpath) => {\n-                return self.lower_path(qpath, (expr.id, expr.hir_id), pat_id, span);\n+                return self.lower_path(qpath, expr.hir_id, pat_id, span);\n             }\n \n             _ => self.lower_lit(expr)"}, {"sha": "56c0fa7b2adf28de9ab28b4e767f80d5de63e3ff", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=7f2423eede51cc622420356988777db2473a0be2", "patch": "@@ -139,7 +139,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoxPointers {\n     }\n \n     fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n-        let ty = cx.tables.node_id_to_type(e.id);\n+        let ty = cx.tables.node_id_to_type(e.hir_id);\n         self.check_heap_type(cx, e.span, ty);\n     }\n }\n@@ -934,9 +934,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n \n             // Check for method calls and overloaded operators.\n             if cx.tables.is_method_call(expr) {\n-                let local_id = cx.tcx.hir.definitions().node_to_hir_id(id).local_id;\n-                let def_id = cx.tables.type_dependent_defs[&local_id].def_id();\n-                let substs = cx.tables.node_substs(id);\n+                let hir_id = cx.tcx.hir.definitions().node_to_hir_id(id);\n+                let def_id = cx.tables.type_dependent_defs[&hir_id.local_id].def_id();\n+                let substs = cx.tables.node_substs(hir_id);\n                 if method_call_refers_to_method(cx, method, def_id, substs, id) {\n                     return true;\n                 }\n@@ -952,7 +952,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n                     };\n                     match def {\n                         Def::Method(def_id) => {\n-                            let substs = cx.tables.node_substs(callee.id);\n+                            let substs = cx.tables.node_substs(callee.hir_id);\n                             method_call_refers_to_method(cx, method, def_id, substs, id)\n                         }\n                         _ => false,\n@@ -1188,7 +1188,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableTransmutes {\n                 if !def_id_is_transmute(cx, did) {\n                     return None;\n                 }\n-                let sig = cx.tables.node_id_to_type(expr.id).fn_sig(cx.tcx);\n+                let sig = cx.tables.node_id_to_type(expr.hir_id).fn_sig(cx.tcx);\n                 let from = sig.inputs().skip_binder()[0];\n                 let to = *sig.output().skip_binder();\n                 return Some((&from.sty, &to.sty));"}, {"sha": "cdf0996796085a82120754bfcc3e6844df1cacc6", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=7f2423eede51cc622420356988777db2473a0be2", "patch": "@@ -92,7 +92,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                 }\n \n                 if binop.node.is_shift() {\n-                    let opt_ty_bits = match cx.tables.node_id_to_type(l.id).sty {\n+                    let opt_ty_bits = match cx.tables.node_id_to_type(l.hir_id).sty {\n                         ty::TyInt(t) => Some(int_ty_bits(t, cx.sess().target.int_type)),\n                         ty::TyUint(t) => Some(uint_ty_bits(t, cx.sess().target.uint_type)),\n                         _ => None,\n@@ -135,7 +135,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                 }\n             }\n             hir::ExprLit(ref lit) => {\n-                match cx.tables.node_id_to_type(e.id).sty {\n+                match cx.tables.node_id_to_type(e.hir_id).sty {\n                     ty::TyInt(t) => {\n                         match lit.node {\n                             ast::LitKind::Int(v, ast::LitIntType::Signed(_)) |\n@@ -285,7 +285,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n             // Normalize the binop so that the literal is always on the RHS in\n             // the comparison\n             let norm_binop = if swap { rev_binop(binop) } else { binop };\n-            match cx.tables.node_id_to_type(expr.id).sty {\n+            match cx.tables.node_id_to_type(expr.hir_id).sty {\n                 ty::TyInt(int_ty) => {\n                     let (min, max) = int_ty_range(int_ty);\n                     let lit_val: i128 = match lit.node {"}, {"sha": "66817fda5b7b32cfdb8237b08499c995736363fc", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=7f2423eede51cc622420356988777db2473a0be2", "patch": "@@ -202,7 +202,8 @@ fn closure_self_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              closure_expr_id: ast::NodeId,\n                              body_id: hir::BodyId)\n                              -> Ty<'tcx> {\n-    let closure_ty = tcx.body_tables(body_id).node_id_to_type(closure_expr_id);\n+    let closure_expr_hir_id = tcx.hir.node_to_hir_id(closure_expr_id);\n+    let closure_ty = tcx.body_tables(body_id).node_id_to_type(closure_expr_hir_id);\n \n     let closure_def_id = tcx.hir.local_def_id(closure_expr_id);\n     let region = ty::ReFree(ty::FreeRegion {"}, {"sha": "fa54925c6e75e1d2330eabc6070d9858dd2f6b9d", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=7f2423eede51cc622420356988777db2473a0be2", "patch": "@@ -95,7 +95,7 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n pub fn to_expr_ref<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                    block: &'tcx hir::Block)\n                                    -> ExprRef<'tcx> {\n-    let block_ty = cx.tables().node_id_to_type(block.id);\n+    let block_ty = cx.tables().node_id_to_type(block.hir_id);\n     let temp_lifetime = cx.region_maps.temporary_scope(block.id);\n     let expr = Expr {\n         ty: block_ty,"}, {"sha": "ea9a19c837824790a2e8f66fa0238cee133ac47b", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=7f2423eede51cc622420356988777db2473a0be2", "patch": "@@ -217,7 +217,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     None\n                 };\n                 if let Some((adt_def, index)) = adt_data {\n-                    let substs = cx.tables().node_substs(fun.id);\n+                    let substs = cx.tables().node_substs(fun.hir_id);\n                     let field_refs = args.iter()\n                         .enumerate()\n                         .map(|(idx, e)| {\n@@ -236,7 +236,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     }\n                 } else {\n                     ExprKind::Call {\n-                        ty: cx.tables().node_id_to_type(fun.id),\n+                        ty: cx.tables().node_id_to_type(fun.hir_id),\n                         fun: fun.to_ref(),\n                         args: args.to_ref(),\n                     }\n@@ -582,7 +582,7 @@ fn method_callee<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     let (def_id, substs) = custom_callee.unwrap_or_else(|| {\n         cx.tables().validate_hir_id(expr.hir_id);\n         (cx.tables().type_dependent_defs[&expr.hir_id.local_id].def_id(),\n-         cx.tables().node_substs(expr.id))\n+         cx.tables().node_substs(expr.hir_id))\n     });\n     Expr {\n         temp_lifetime: temp_lifetime,\n@@ -620,7 +620,7 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                      expr: &'tcx hir::Expr,\n                                      def: Def)\n                                      -> ExprKind<'tcx> {\n-    let substs = cx.tables().node_substs(expr.id);\n+    let substs = cx.tables().node_substs(expr.hir_id);\n     match def {\n         // A regular function, constructor function or a constant.\n         Def::Fn(def_id) |\n@@ -642,7 +642,7 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n         Def::StructCtor(def_id, CtorKind::Const) |\n         Def::VariantCtor(def_id, CtorKind::Const) => {\n-            match cx.tables().node_id_to_type(expr.id).sty {\n+            match cx.tables().node_id_to_type(expr.hir_id).sty {\n                 // A unit struct/variant which is used as a value.\n                 // We return a completely different ExprKind here to account for this special case.\n                 ty::TyAdt(adt_def, substs) => {\n@@ -684,10 +684,12 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                    id_var,\n                    index,\n                    closure_expr_id);\n-            let var_ty = cx.tables().node_id_to_type(id_var);\n+            let var_ty = cx.tables()\n+                           .node_id_to_type(cx.tcx.hir.node_to_hir_id(id_var));\n \n             // FIXME free regions in closures are not right\n-            let closure_ty = cx.tables().node_id_to_type(closure_expr_id);\n+            let closure_ty = cx.tables()\n+                               .node_id_to_type(cx.tcx.hir.node_to_hir_id(closure_expr_id));\n \n             // FIXME we're just hard-coding the idea that the\n             // signature will be &self or &mut self and hence will\n@@ -879,7 +881,8 @@ fn capture_freevar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     };\n     let upvar_capture = cx.tables().upvar_capture(upvar_id);\n     let temp_lifetime = cx.region_maps.temporary_scope(closure_expr.id);\n-    let var_ty = cx.tables().node_id_to_type(id_var);\n+    let var_ty = cx.tables()\n+                   .node_id_to_type(cx.tcx.hir.node_to_hir_id(id_var));\n     let captured_var = Expr {\n         temp_lifetime: temp_lifetime,\n         ty: var_ty,"}, {"sha": "c06ae721f365fbef5b544c5fa42afe89915e922d", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=7f2423eede51cc622420356988777db2473a0be2", "patch": "@@ -219,7 +219,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n         let outer = self.promotable;\n         self.promotable = true;\n \n-        let node_ty = self.tables.node_id_to_type(ex.id);\n+        let node_ty = self.tables.node_id_to_type(ex.hir_id);\n         check_expr(self, ex, node_ty);\n         check_adjustments(self, ex);\n \n@@ -297,7 +297,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n             v.promotable = false;\n         }\n         hir::ExprUnary(op, ref inner) => {\n-            match v.tables.node_id_to_type(inner.id).sty {\n+            match v.tables.node_id_to_type(inner.hir_id).sty {\n                 ty::TyRawPtr(_) => {\n                     assert!(op == hir::UnDeref);\n \n@@ -307,7 +307,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n             }\n         }\n         hir::ExprBinary(op, ref lhs, _) => {\n-            match v.tables.node_id_to_type(lhs.id).sty {\n+            match v.tables.node_id_to_type(lhs.hir_id).sty {\n                 ty::TyRawPtr(_) => {\n                     assert!(op.node == hir::BiEq || op.node == hir::BiNe ||\n                             op.node == hir::BiLe || op.node == hir::BiLt ||"}, {"sha": "1c5e528d887deba1e8447303a2721e79989b516b", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=7f2423eede51cc622420356988777db2473a0be2", "patch": "@@ -639,7 +639,7 @@ impl<'a, 'tcx> TypePrivacyVisitor<'a, 'tcx> {\n     }\n \n     // Take node ID of an expression or pattern and check its type for privacy.\n-    fn check_expr_pat_type(&mut self, id: ast::NodeId, span: Span) -> bool {\n+    fn check_expr_pat_type(&mut self, id: hir::HirId, span: Span) -> bool {\n         self.span = span;\n         if let Some(ty) = self.tables.node_id_to_type_opt(id) {\n             if ty.visit_with(self) {\n@@ -649,7 +649,7 @@ impl<'a, 'tcx> TypePrivacyVisitor<'a, 'tcx> {\n         if self.tables.node_substs(id).visit_with(self) {\n             return true;\n         }\n-        if let Some(adjustments) = self.tables.adjustments.get(&id) {\n+        if let Some(adjustments) = self.tables.adjustments.get(&id.local_id) {\n             for adjustment in adjustments {\n                 if adjustment.target.visit_with(self) {\n                     return true;\n@@ -735,14 +735,14 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n \n     // Check types of expressions\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n-        if self.check_expr_pat_type(expr.id, expr.span) {\n+        if self.check_expr_pat_type(expr.hir_id, expr.span) {\n             // Do not check nested expressions if the error already happened.\n             return;\n         }\n         match expr.node {\n             hir::ExprAssign(.., ref rhs) | hir::ExprMatch(ref rhs, ..) => {\n                 // Do not report duplicate errors for `x = y` and `match x { ... }`.\n-                if self.check_expr_pat_type(rhs.id, rhs.span) {\n+                if self.check_expr_pat_type(rhs.hir_id, rhs.span) {\n                     return;\n                 }\n             }\n@@ -783,7 +783,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n \n     // Check types of patterns\n     fn visit_pat(&mut self, pattern: &'tcx hir::Pat) {\n-        if self.check_expr_pat_type(pattern.id, pattern.span) {\n+        if self.check_expr_pat_type(pattern.hir_id, pattern.span) {\n             // Do not check nested patterns if the error already happened.\n             return;\n         }\n@@ -793,7 +793,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n \n     fn visit_local(&mut self, local: &'tcx hir::Local) {\n         if let Some(ref init) = local.init {\n-            if self.check_expr_pat_type(init.id, init.span) {\n+            if self.check_expr_pat_type(init.hir_id, init.span) {\n                 // Do not report duplicate errors for `let x = y`.\n                 return;\n             }"}, {"sha": "af816473033f8efde642c6b663eddeb6ed8529c1", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=7f2423eede51cc622420356988777db2473a0be2", "patch": "@@ -345,7 +345,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n             collector.visit_pat(&arg.pat);\n             let span_utils = self.span.clone();\n             for &(id, ref p, ..) in &collector.collected_paths {\n-                let typ = match self.save_ctxt.tables.node_types.get(&id) {\n+                let hir_id = self.tcx.hir.node_to_hir_id(id);\n+                let typ = match self.save_ctxt.tables.node_id_to_type_opt(hir_id) {\n                     Some(s) => s.to_string(),\n                     None => continue,\n                 };\n@@ -893,7 +894,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         match p.node {\n             PatKind::Struct(ref _path, ref fields, _) => {\n                 // FIXME do something with _path?\n-                let adt = match self.save_ctxt.tables.node_id_to_type_opt(p.id) {\n+                let hir_id = self.tcx.hir.node_to_hir_id(p.id);\n+                let adt = match self.save_ctxt.tables.node_id_to_type_opt(hir_id) {\n                     Some(ty) => ty.ty_adt_def().unwrap(),\n                     None => {\n                         visit::walk_pat(self, p);\n@@ -935,7 +937,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                 ast::Mutability::Immutable => value.to_string(),\n                 _ => String::new(),\n             };\n-            let typ = match self.save_ctxt.tables.node_types.get(&id) {\n+            let hir_id = self.tcx.hir.node_to_hir_id(id);\n+            let typ = match self.save_ctxt.tables.node_id_to_type_opt(hir_id) {\n                 Some(typ) => {\n                     let typ = typ.to_string();\n                     if !value.is_empty() {\n@@ -1466,8 +1469,12 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                     } else {\n                         \"<mutable>\".to_string()\n                     };\n-                    let typ = self.save_ctxt.tables.node_types\n-                                  .get(&id).map(|t| t.to_string()).unwrap_or(String::new());\n+                    let hir_id = self.tcx.hir.node_to_hir_id(id);\n+                    let typ = self.save_ctxt\n+                                  .tables\n+                                  .node_id_to_type_opt(hir_id)\n+                                  .map(|t| t.to_string())\n+                                  .unwrap_or(String::new());\n                     value.push_str(\": \");\n                     value.push_str(&typ);\n "}, {"sha": "e1ced048870b59bac2dff8631c2b571b52a0d1ae", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=7f2423eede51cc622420356988777db2473a0be2", "patch": "@@ -323,7 +323,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n         };\n \n-        self.write_ty(pat.id, ty);\n+        self.write_ty(pat.hir_id, ty);\n \n         // (*) In most of the cases above (literals and constants being\n         // the exception), we relate types using strict equality, evewn"}, {"sha": "460e2858b22ec091ea4272467e4bdc2cef4c1235", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=7f2423eede51cc622420356988777db2473a0be2", "patch": "@@ -314,7 +314,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                            TupleArgumentsFlag::TupleArguments,\n                                                            expected);\n \n-        self.write_method_call((call_expr.id, call_expr.hir_id), method_callee);\n+        self.write_method_call(call_expr.hir_id, method_callee);\n         output_type\n     }\n }\n@@ -364,7 +364,7 @@ impl<'a, 'gcx, 'tcx> DeferredCallResolution<'gcx, 'tcx> {\n                 adjustments.extend(autoref);\n                 fcx.apply_adjustments(self.callee_expr, adjustments);\n \n-                fcx.write_method_call((self.call_expr.id, self.call_expr.hir_id),\n+                fcx.write_method_call(self.call_expr.hir_id,\n                                       method_callee);\n             }\n             None => {"}, {"sha": "428938eae828b700163c8764c66b5e5029960466", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=7f2423eede51cc622420356988777db2473a0be2", "patch": "@@ -844,7 +844,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // First try to coerce the new expression to the type of the previous ones,\n         // but only if the new expression has no coercion already applied to it.\n         let mut first_error = None;\n-        if !self.tables.borrow().adjustments.contains_key(&new.id) {\n+        if !self.tables.borrow().adjustments.contains_key(&new.hir_id.local_id) {\n             let result = self.commit_if_ok(|_| coerce.coerce(new_ty, prev_ty));\n             match result {\n                 Ok(ok) => {\n@@ -866,7 +866,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     Adjustment { kind: Adjust::Deref(_), .. },\n                     Adjustment { kind: Adjust::Borrow(AutoBorrow::Ref(_, mutbl_adj)), .. }\n                 ] => {\n-                    match self.node_ty(expr.id).sty {\n+                    match self.node_ty(expr.hir_id).sty {\n                         ty::TyRef(_, mt_orig) => {\n                             // Reborrow that we can safely ignore, because\n                             // the next adjustment can only be a Deref"}, {"sha": "0294dab17d550d2b01b1420461416357677b2e16", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=7f2423eede51cc622420356988777db2473a0be2", "patch": "@@ -445,11 +445,14 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             // Fix up the autoderefs. Autorefs can only occur immediately preceding\n             // overloaded lvalue ops, and will be fixed by them in order to get\n             // the correct region.\n-            let mut source = self.node_ty(expr.id);\n+            let mut source = self.node_ty(expr.hir_id);\n             // Do not mutate adjustments in place, but rather take them,\n             // and replace them after mutating them, to avoid having the\n             // tables borrowed during (`deref_mut`) method resolution.\n-            let previous_adjustments = self.tables.borrow_mut().adjustments.remove(&expr.id);\n+            let previous_adjustments = self.tables\n+                                           .borrow_mut()\n+                                           .adjustments\n+                                           .remove(&expr.hir_id.local_id);\n             if let Some(mut adjustments) = previous_adjustments {\n                 let pref = LvaluePreference::PreferMutLvalue;\n                 for adjustment in &mut adjustments {\n@@ -466,12 +469,12 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                     }\n                     source = adjustment.target;\n                 }\n-                self.tables.borrow_mut().adjustments.insert(expr.id, adjustments);\n+                self.tables.borrow_mut().adjustments.insert(expr.hir_id.local_id, adjustments);\n             }\n \n             match expr.node {\n                 hir::ExprIndex(ref base_expr, ref index_expr) => {\n-                    let index_expr_ty = self.node_ty(index_expr.id);\n+                    let index_expr_ty = self.node_ty(index_expr.hir_id);\n                     self.convert_lvalue_op_to_mutable(\n                         LvalueOp::Index, expr, base_expr, &[index_expr_ty]);\n                 }\n@@ -498,7 +501,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         }\n \n         let base_ty = self.tables.borrow().expr_adjustments(base_expr).last()\n-            .map_or_else(|| self.node_ty(expr.id), |adj| adj.target);\n+            .map_or_else(|| self.node_ty(expr.hir_id), |adj| adj.target);\n         let base_ty = self.resolve_type_vars_if_possible(&base_ty);\n \n         // Need to deref because overloaded lvalue ops take self by-reference.\n@@ -513,7 +516,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             None => return self.tcx.sess.delay_span_bug(expr.span, \"re-trying op failed\")\n         };\n         debug!(\"convert_lvalue_op_to_mutable: method={:?}\", method);\n-        self.write_method_call((expr.id, expr.hir_id), method);\n+        self.write_method_call(expr.hir_id, method);\n \n         let (region, mutbl) = if let ty::TyRef(r, mt) = method.sig.inputs()[0].sty {\n             (r, mt.mutbl)\n@@ -523,8 +526,11 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n \n         // Convert the autoref in the base expr to mutable with the correct\n         // region and mutability.\n-        let base_expr_ty = self.node_ty(base_expr.id);\n-        if let Some(adjustments) = self.tables.borrow_mut().adjustments.get_mut(&base_expr.id) {\n+        let base_expr_ty = self.node_ty(base_expr.hir_id);\n+        if let Some(adjustments) = self.tables\n+                                       .borrow_mut()\n+                                       .adjustments\n+                                       .get_mut(&base_expr.hir_id.local_id) {\n             let mut source = base_expr_ty;\n             for adjustment in &mut adjustments[..] {\n                 if let Adjust::Borrow(AutoBorrow::Ref(..)) = adjustment.kind {"}, {"sha": "facacdc8d11445e26e76365a18405fb4c143d5f6", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 39, "deletions": 28, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=7f2423eede51cc622420356988777db2473a0be2", "patch": "@@ -1024,7 +1024,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n             fcx.require_type_is_sized(arg_ty, decl.output.span(), traits::MiscObligation);\n         }\n \n-        fcx.write_ty(arg.id, arg_ty);\n+        fcx.write_ty(arg.hir_id, arg_ty);\n     }\n \n     inherited.tables.borrow_mut().liberated_fn_sigs.insert(fn_id, fn_sig);\n@@ -1807,10 +1807,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     #[inline]\n-    pub fn write_ty(&self, node_id: ast::NodeId, ty: Ty<'tcx>) {\n-        debug!(\"write_ty({}, {:?}) in fcx {}\",\n-               node_id, self.resolve_type_vars_if_possible(&ty), self.tag());\n-        self.tables.borrow_mut().node_types.insert(node_id, ty);\n+    pub fn write_ty(&self, id: hir::HirId, ty: Ty<'tcx>) {\n+        debug!(\"write_ty({:?}, {:?}) in fcx {}\",\n+               id, self.resolve_type_vars_if_possible(&ty), self.tag());\n+        {\n+            let mut tables = self.tables.borrow_mut();\n+            tables.validate_hir_id(id);\n+            tables.node_types.insert(id.local_id, ty);\n+        }\n \n         if ty.references_error() {\n             self.has_errors.set(true);\n@@ -1821,24 +1825,26 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     // The NodeId and the ItemLocalId must identify the same item. We just pass\n     // both of them for consistency checking.\n     pub fn write_method_call(&self,\n-                             (node_id, hir_id): (ast::NodeId, hir::HirId),\n+                             hir_id: hir::HirId,\n                              method: MethodCallee<'tcx>) {\n         {\n             let mut tables = self.tables.borrow_mut();\n             tables.validate_hir_id(hir_id);\n             tables.type_dependent_defs.insert(hir_id.local_id, Def::Method(method.def_id));\n         }\n-        self.write_substs(node_id, method.substs);\n+        self.write_substs(hir_id, method.substs);\n     }\n \n-    pub fn write_substs(&self, node_id: ast::NodeId, substs: &'tcx Substs<'tcx>) {\n+    pub fn write_substs(&self, node_id: hir::HirId, substs: &'tcx Substs<'tcx>) {\n         if !substs.is_noop() {\n-            debug!(\"write_substs({}, {:?}) in fcx {}\",\n+            debug!(\"write_substs({:?}, {:?}) in fcx {}\",\n                    node_id,\n                    substs,\n                    self.tag());\n \n-            self.tables.borrow_mut().node_substs.insert(node_id, substs);\n+            let mut tables = self.tables.borrow_mut();\n+            tables.validate_hir_id(node_id);\n+            tables.node_substs.insert(node_id.local_id, substs);\n         }\n     }\n \n@@ -1849,7 +1855,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             return;\n         }\n \n-        match self.tables.borrow_mut().adjustments.entry(expr.id) {\n+        let mut tables = self.tables.borrow_mut();\n+        tables.validate_hir_id(expr.hir_id);\n+        match tables.adjustments.entry(expr.hir_id.local_id) {\n             Entry::Vacant(entry) => { entry.insert(adj); },\n             Entry::Occupied(mut entry) => {\n                 debug!(\" - composing on top of {:?}\", entry.get());\n@@ -2002,13 +2010,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         t\n     }\n \n-    pub fn node_ty(&self, id: ast::NodeId) -> Ty<'tcx> {\n-        match self.tables.borrow().node_types.get(&id) {\n+    pub fn node_ty(&self, id: hir::HirId) -> Ty<'tcx> {\n+        let tables = self.tables.borrow();\n+        tables.validate_hir_id(id);\n+        match tables.node_types.get(&id.local_id) {\n             Some(&t) => t,\n             None if self.err_count_since_creation() != 0 => self.tcx.types.err,\n             None => {\n+                let node_id = self.tcx.hir.definitions().find_node_for_hir_id(id);\n                 bug!(\"no type for node {}: {} in fcx {}\",\n-                     id, self.tcx.hir.node_to_string(id),\n+                     node_id, self.tcx.hir.node_to_string(node_id),\n                      self.tag());\n             }\n         }\n@@ -2276,7 +2287,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 self.apply_adjustments(base_expr, adjustments);\n \n-                self.write_method_call((expr.id, expr.hir_id), method);\n+                self.write_method_call(expr.hir_id, method);\n                 (input_ty, self.make_overloaded_lvalue_return_type(method).ty)\n             });\n             if result.is_some() {\n@@ -2665,7 +2676,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // While we don't allow *arbitrary* coercions here, we *do* allow\n         // coercions from ! to `expected`.\n         if ty.is_never() {\n-            assert!(!self.tables.borrow().adjustments.contains_key(&expr.id),\n+            assert!(!self.tables.borrow().adjustments.contains_key(&expr.hir_id.local_id),\n                     \"expression with never type wound up being adjusted\");\n             let adj_ty = self.next_diverging_ty_var(\n                 TypeVariableOrigin::AdjustmentType(expr.span));\n@@ -2816,7 +2827,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                               expr,\n                                               rcvr) {\n             Ok(method) => {\n-                self.write_method_call((expr.id, expr.hir_id), method);\n+                self.write_method_call(expr.hir_id, method);\n                 Ok(method)\n             }\n             Err(error) => {\n@@ -3448,7 +3459,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // Record the type, which applies it effects.\n         // We need to do this after the warning above, so that\n         // we don't warn for the diverging expression itself.\n-        self.write_ty(expr.id, ty);\n+        self.write_ty(expr.hir_id, ty);\n \n         // Combine the diverging and has_error flags.\n         self.diverges.set(self.diverges.get() | old_diverges);\n@@ -3521,7 +3532,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 }]);\n                             }\n                             oprnd_t = self.make_overloaded_lvalue_return_type(method).ty;\n-                            self.write_method_call((expr.id, expr.hir_id), method);\n+                            self.write_method_call(expr.hir_id, method);\n                         } else {\n                             type_error_struct!(tcx.sess, expr.span, oprnd_t, E0614,\n                                                \"type `{}` cannot be dereferenced\",\n@@ -3599,7 +3610,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n               // We always require that the type provided as the value for\n               // a type parameter outlives the moment of instantiation.\n-              let substs = self.tables.borrow().node_substs(expr.id);\n+              let substs = self.tables.borrow().node_substs(expr.hir_id);\n               self.add_wf_bounds(substs, expr);\n \n               ty\n@@ -4101,19 +4112,19 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn check_decl_local(&self, local: &'gcx hir::Local)  {\n         let t = self.local_ty(local.span, local.id);\n-        self.write_ty(local.id, t);\n+        self.write_ty(local.hir_id, t);\n \n         if let Some(ref init) = local.init {\n             let init_ty = self.check_decl_initializer(local, &init);\n             if init_ty.references_error() {\n-                self.write_ty(local.id, init_ty);\n+                self.write_ty(local.hir_id, init_ty);\n             }\n         }\n \n         self.check_pat(&local.pat, t);\n-        let pat_ty = self.node_ty(local.pat.id);\n+        let pat_ty = self.node_ty(local.pat.hir_id);\n         if pat_ty.references_error() {\n-            self.write_ty(local.id, pat_ty);\n+            self.write_ty(local.hir_id, pat_ty);\n         }\n     }\n \n@@ -4265,7 +4276,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             ty = self.tcx.types.err\n         }\n \n-        self.write_ty(blk.id, ty);\n+        self.write_ty(blk.hir_id, ty);\n \n         *self.ps.borrow_mut() = prev;\n         ty\n@@ -4443,7 +4454,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             hir::StmtSemi(ref e, _) => e,\n             _ => return,\n         };\n-        let last_expr_ty = self.node_ty(last_expr.id);\n+        let last_expr_ty = self.node_ty(last_expr.hir_id);\n         if self.can_sub(self.param_env, last_expr_ty, expected_ty).is_err() {\n             return;\n         }\n@@ -4586,7 +4597,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let nid = self.tcx.hir.as_local_node_id(def_id).unwrap();\n                 let ty = self.local_ty(span, nid);\n                 let ty = self.normalize_associated_types_in(span, &ty);\n-                self.write_ty(node_id, ty);\n+                self.write_ty(self.tcx.hir.node_to_hir_id(node_id), ty);\n                 return ty;\n             }\n             _ => {}\n@@ -4718,7 +4729,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"instantiate_value_path: type of {:?} is {:?}\",\n                node_id,\n                ty_substituted);\n-        self.write_substs(node_id, substs);\n+        self.write_substs(self.tcx.hir.node_to_hir_id(node_id), substs);\n         ty_substituted\n     }\n "}, {"sha": "f2104b8dbae03137c5804a1e88142199e4518b32", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=7f2423eede51cc622420356988777db2473a0be2", "patch": "@@ -210,11 +210,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         // some cases applied on the RHS, on top of which we need\n                         // to autoref, which is not allowed by apply_adjustments.\n                         // self.apply_adjustments(rhs_expr, vec![autoref]);\n-                        self.tables.borrow_mut().adjustments.entry(rhs_expr.id)\n+                        let mut tables = self.tables.borrow_mut();\n+                        tables.validate_hir_id(rhs_expr.hir_id);\n+                        tables.adjustments.entry(rhs_expr.hir_id.local_id)\n                             .or_insert(vec![]).push(autoref);\n                     }\n                 }\n-                self.write_method_call((expr.id, expr.hir_id), method);\n+                self.write_method_call(expr.hir_id, method);\n \n                 method.sig.output()\n             }\n@@ -340,7 +342,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         assert!(op.is_by_value());\n         match self.lookup_op_method(operand_ty, &[], Op::Unary(op, ex.span)) {\n             Ok(method) => {\n-                self.write_method_call((ex.id, ex.hir_id), method);\n+                self.write_method_call(ex.hir_id, method);\n                 method.sig.output()\n             }\n             Err(()) => {"}, {"sha": "d88ed888338cb156da24ef643bedd061a4d7b4e3", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 39, "deletions": 31, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=7f2423eede51cc622420356988777db2473a0be2", "patch": "@@ -284,7 +284,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Try to resolve the type for the given node.\n-    fn resolve_node_type(&self, id: ast::NodeId) -> Ty<'tcx> {\n+    fn resolve_node_type(&self, id: hir::HirId) -> Ty<'tcx> {\n         let t = self.node_ty(id);\n         self.resolve_type(t)\n     }\n@@ -338,8 +338,9 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"visit_fn_body body.id {:?} call_site_scope: {:?}\",\n                body.id(), call_site_scope);\n         let call_site_region = self.tcx.mk_region(ty::ReScope(call_site_scope));\n+        let body_hir_id = self.tcx.hir.node_to_hir_id(body_id.node_id);\n         self.type_of_node_must_outlive(infer::CallReturn(span),\n-                                       body_id.node_id,\n+                                       body_hir_id,\n                                        call_site_region);\n \n         self.region_bound_pairs.truncate(old_region_bounds_pairs_len);\n@@ -613,9 +614,10 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             let var_region = self.tcx.mk_region(ty::ReScope(var_scope));\n \n             let origin = infer::BindingTypeIsNotValidAtDecl(span);\n-            self.type_of_node_must_outlive(origin, id, var_region);\n+            let hir_id = self.tcx.hir.node_to_hir_id(id);\n+            self.type_of_node_must_outlive(origin, hir_id, var_region);\n \n-            let typ = self.resolve_node_type(id);\n+            let typ = self.resolve_node_type(hir_id);\n             let _ = dropck::check_safety_of_destructor_if_necessary(\n                 self, typ, span, var_scope);\n         })\n@@ -664,7 +666,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n \n         // No matter what, the type of each expression must outlive the\n         // scope of that expression. This also guarantees basic WF.\n-        let expr_ty = self.resolve_node_type(expr.id);\n+        let expr_ty = self.resolve_node_type(expr.hir_id);\n         // the region corresponding to this expression\n         let expr_region = self.tcx.node_scope_region(expr.id);\n         self.type_must_outlive(infer::ExprTypeIsNotInScope(expr_ty, expr.span),\n@@ -686,7 +688,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n                     infer::ParameterOrigin::OverloadedOperator\n             };\n \n-            let substs = self.tables.borrow().node_substs(expr.id);\n+            let substs = self.tables.borrow().node_substs(expr.hir_id);\n             self.substs_wf_in_scope(origin, substs, expr.span, expr_region);\n             // Arguments (sub-expressions) are checked via `constrain_call`, below.\n         }\n@@ -709,7 +711,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n                expr, self.repeating_scope);\n         match expr.node {\n             hir::ExprPath(_) => {\n-                let substs = self.tables.borrow().node_substs(expr.id);\n+                let substs = self.tables.borrow().node_substs(expr.hir_id);\n                 let origin = infer::ParameterOrigin::Path;\n                 self.substs_wf_in_scope(origin, substs, expr.span, expr_region);\n             }\n@@ -718,7 +720,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n                 if is_method_call {\n                     self.constrain_call(expr, Some(&callee), args.iter().map(|e| &*e));\n                 } else {\n-                    self.constrain_callee(callee.id, expr, &callee);\n+                    self.constrain_callee(&callee);\n                     self.constrain_call(expr, None, args.iter().map(|e| &*e));\n                 }\n \n@@ -812,7 +814,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n                 // adjustments*.\n                 //\n                 // FIXME(#6268) nested method calls requires that this rule change\n-                let ty0 = self.resolve_node_type(expr.id);\n+                let ty0 = self.resolve_node_type(expr.hir_id);\n                 self.type_must_outlive(infer::AddrOf(expr.span), ty0, expr_region);\n                 intravisit::walk_expr(self, expr);\n             }\n@@ -849,7 +851,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n                        ret_expr.id, call_site_scope);\n                 let call_site_region = self.tcx.mk_region(ty::ReScope(call_site_scope.unwrap()));\n                 self.type_of_node_must_outlive(infer::CallReturn(ret_expr.span),\n-                                               ret_expr.id,\n+                                               ret_expr.hir_id,\n                                                call_site_region);\n                 intravisit::walk_expr(self, expr);\n             }\n@@ -870,8 +872,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                cast_expr,\n                source_expr);\n \n-        let source_ty = self.resolve_node_type(source_expr.id);\n-        let target_ty = self.resolve_node_type(cast_expr.id);\n+        let source_ty = self.resolve_node_type(source_expr.hir_id);\n+        let target_ty = self.resolve_node_type(cast_expr.hir_id);\n \n         self.walk_cast(cast_expr, source_ty, target_ty);\n     }\n@@ -915,11 +917,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         self.set_repeating_scope(repeating_scope);\n     }\n \n-    fn constrain_callee(&mut self,\n-                        callee_id: ast::NodeId,\n-                        _call_expr: &hir::Expr,\n-                        _callee_expr: &hir::Expr) {\n-        let callee_ty = self.resolve_node_type(callee_id);\n+    fn constrain_callee(&mut self, callee_expr: &hir::Expr) {\n+        let callee_ty = self.resolve_node_type(callee_expr.hir_id);\n         match callee_ty.sty {\n             ty::TyFnDef(..) | ty::TyFnPtr(_) => { }\n             _ => {\n@@ -962,14 +961,16 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             // ensure that any regions appearing in the argument type are\n             // valid for at least the lifetime of the function:\n             self.type_of_node_must_outlive(infer::CallArg(arg_expr.span),\n-                                           arg_expr.id, callee_region);\n+                                           arg_expr.hir_id,\n+                                           callee_region);\n         }\n \n         // as loop above, but for receiver\n         if let Some(r) = receiver {\n             debug!(\"receiver: {:?}\", r);\n             self.type_of_node_must_outlive(infer::CallRcvr(r.span),\n-                                           r.id, callee_region);\n+                                           r.hir_id,\n+                                           callee_region);\n         }\n     }\n \n@@ -1038,7 +1039,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                 //\n                 // FIXME(#6268) remove to support nested method calls\n                 self.type_of_node_must_outlive(infer::AutoBorrow(expr.span),\n-                                               expr.id, expr_region);\n+                                               expr.hir_id,\n+                                               expr_region);\n             }\n \n             cmt = self.with_mc(|mc| mc.cat_expr_adjusted(expr, cmt, &adjustment))?;\n@@ -1109,21 +1111,27 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     /// adjustments) are valid for at least `minimum_lifetime`\n     fn type_of_node_must_outlive(&mut self,\n         origin: infer::SubregionOrigin<'tcx>,\n-        id: ast::NodeId,\n+        hir_id: hir::HirId,\n         minimum_lifetime: ty::Region<'tcx>)\n     {\n         // Try to resolve the type.  If we encounter an error, then typeck\n         // is going to fail anyway, so just stop here and let typeck\n         // report errors later on in the writeback phase.\n-        let ty0 = self.resolve_node_type(id);\n-        let ty = self.tables.borrow().adjustments.get(&id)\n-            .and_then(|adj| adj.last())\n-            .map_or(ty0, |adj| adj.target);\n+        let ty0 = self.resolve_node_type(hir_id);\n+\n+        let ty = {\n+            let tables = self.tables.borrow();\n+            tables.validate_hir_id(hir_id);\n+            tables.adjustments\n+                  .get(&hir_id.local_id)\n+                  .and_then(|adj| adj.last())\n+                  .map_or(ty0, |adj| adj.target)\n+        };\n         let ty = self.resolve_type(ty);\n         debug!(\"constrain_regions_in_type_of_node(\\\n-                ty={}, ty0={}, id={}, minimum_lifetime={:?})\",\n+                ty={}, ty0={}, id={:?}, minimum_lifetime={:?})\",\n                 ty,  ty0,\n-               id, minimum_lifetime);\n+                hir_id, minimum_lifetime);\n         self.type_must_outlive(origin, ty, minimum_lifetime);\n     }\n \n@@ -1137,7 +1145,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n         debug!(\"link_addr_of: cmt={:?}\", cmt);\n \n-        self.link_region_from_node_type(expr.span, expr.id, mutability, cmt);\n+        self.link_region_from_node_type(expr.span, expr.hir_id, mutability, cmt);\n     }\n \n     /// Computes the guarantors for any ref bindings in a `let` and\n@@ -1173,7 +1181,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     fn link_fn_args(&self, body_scope: CodeExtent, args: &[hir::Arg]) {\n         debug!(\"regionck::link_fn_args(body_scope={:?})\", body_scope);\n         for arg in args {\n-            let arg_ty = self.node_ty(arg.id);\n+            let arg_ty = self.node_ty(arg.hir_id);\n             let re_scope = self.tcx.mk_region(ty::ReScope(body_scope));\n             let arg_cmt = self.with_mc(|mc| {\n                 mc.cat_rvalue(arg.id, arg.pat.span, re_scope, arg_ty)\n@@ -1200,7 +1208,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                         let bm = *mc.tables.pat_binding_modes.get(&sub_pat.id)\n                                                              .expect(\"missing binding mode\");\n                         if let ty::BindByReference(mutbl) = bm {\n-                            self.link_region_from_node_type(sub_pat.span, sub_pat.id,\n+                            self.link_region_from_node_type(sub_pat.span, sub_pat.hir_id,\n                                                             mutbl, sub_cmt);\n                         }\n                     }\n@@ -1236,7 +1244,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     /// which must be some reference (`&T`, `&str`, etc).\n     fn link_region_from_node_type(&self,\n                                   span: Span,\n-                                  id: ast::NodeId,\n+                                  id: hir::HirId,\n                                   mutbl: hir::Mutability,\n                                   cmt_borrowed: mc::cmt<'tcx>) {\n         debug!(\"link_region_from_node_type(id={:?}, mutbl={:?}, cmt_borrowed={:?})\","}, {"sha": "22047ed583e2f4aa39c72552288de70b6eb1c7c8", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=7f2423eede51cc622420356988777db2473a0be2", "patch": "@@ -78,7 +78,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for InferBorrowKindVisitor<'a, 'gcx, 'tcx> {\n             hir::ExprClosure(cc, _, body_id, _) => {\n                 let body = self.fcx.tcx.hir.body(body_id);\n                 self.visit_body(body);\n-                self.fcx.analyze_closure(expr.id, expr.span, body, cc);\n+                self.fcx.analyze_closure((expr.id, expr.hir_id), expr.span, body, cc);\n             }\n \n             _ => { }\n@@ -90,7 +90,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for InferBorrowKindVisitor<'a, 'gcx, 'tcx> {\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn analyze_closure(&self,\n-                       id: ast::NodeId,\n+                       (id, hir_id): (ast::NodeId, hir::HirId),\n                        span: Span,\n                        body: &hir::Body,\n                        capture_clause: hir::CaptureClause) {\n@@ -172,7 +172,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // inference algorithm will reject it).\n \n         // Extract the type variables UV0...UVn.\n-        let (def_id, closure_substs) = match self.node_ty(id).sty {\n+        let (def_id, closure_substs) = match self.node_ty(hir_id).sty {\n             ty::TyClosure(def_id, substs) => (def_id, substs),\n             ref t => {\n                 span_bug!(\n@@ -216,7 +216,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             freevars.iter().map(|freevar| {\n                 let def_id = freevar.def.def_id();\n                 let var_id = tcx.hir.as_local_node_id(def_id).unwrap();\n-                let freevar_ty = self.node_ty(var_id);\n+                let freevar_ty = self.node_ty(tcx.hir.node_to_hir_id(var_id));\n                 let upvar_id = ty::UpvarId {\n                     var_id: var_id,\n                     closure_expr_id: closure_id"}, {"sha": "058cef71d4a828e7f1c46cfbff2420c395bb7339", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 39, "deletions": 33, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=7f2423eede51cc622420356988777db2473a0be2", "patch": "@@ -35,7 +35,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let mut wbcx = WritebackCx::new(self, body);\n         for arg in &body.arguments {\n-            wbcx.visit_node_id(arg.pat.span, (arg.id, arg.hir_id));\n+            wbcx.visit_node_id(arg.pat.span, arg.hir_id);\n         }\n         wbcx.visit_body(body);\n         wbcx.visit_upvar_borrow_map();\n@@ -90,10 +90,11 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         self.fcx.tcx\n     }\n \n-    fn write_ty_to_tables(&mut self, node_id: ast::NodeId, ty: Ty<'gcx>) {\n-        debug!(\"write_ty_to_tables({}, {:?})\", node_id,  ty);\n+    fn write_ty_to_tables(&mut self, hir_id: hir::HirId, ty: Ty<'gcx>) {\n+        debug!(\"write_ty_to_tables({:?}, {:?})\", hir_id,  ty);\n         assert!(!ty.needs_infer());\n-        self.tables.node_types.insert(node_id, ty);\n+        self.tables.validate_hir_id(hir_id);\n+        self.tables.node_types.insert(hir_id.local_id, ty);\n     }\n \n     // Hacky hack: During type-checking, we treat *all* operators\n@@ -104,39 +105,39 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         match e.node {\n             hir::ExprUnary(hir::UnNeg, ref inner) |\n             hir::ExprUnary(hir::UnNot, ref inner)  => {\n-                let inner_ty = self.fcx.node_ty(inner.id);\n+                let inner_ty = self.fcx.node_ty(inner.hir_id);\n                 let inner_ty = self.fcx.resolve_type_vars_if_possible(&inner_ty);\n \n                 if inner_ty.is_scalar() {\n                     let mut tables = self.fcx.tables.borrow_mut();\n                     tables.validate_hir_id(e.hir_id);\n                     tables.type_dependent_defs.remove(&e.hir_id.local_id);\n-                    tables.node_substs.remove(&e.id);\n+                    tables.node_substs.remove(&e.hir_id.local_id);\n                 }\n             }\n             hir::ExprBinary(ref op, ref lhs, ref rhs) |\n             hir::ExprAssignOp(ref op, ref lhs, ref rhs) => {\n-                let lhs_ty = self.fcx.node_ty(lhs.id);\n+                let lhs_ty = self.fcx.node_ty(lhs.hir_id);\n                 let lhs_ty = self.fcx.resolve_type_vars_if_possible(&lhs_ty);\n \n-                let rhs_ty = self.fcx.node_ty(rhs.id);\n+                let rhs_ty = self.fcx.node_ty(rhs.hir_id);\n                 let rhs_ty = self.fcx.resolve_type_vars_if_possible(&rhs_ty);\n \n                 if lhs_ty.is_scalar() && rhs_ty.is_scalar() {\n                     let mut tables = self.fcx.tables.borrow_mut();\n                     tables.validate_hir_id(e.hir_id);\n                     tables.type_dependent_defs.remove(&e.hir_id.local_id);\n-                    tables.node_substs.remove(&e.id);\n+                    tables.node_substs.remove(&e.hir_id.local_id);\n \n                     match e.node {\n                         hir::ExprBinary(..) => {\n                             if !op.node.is_by_value() {\n-                                tables.adjustments.get_mut(&lhs.id).map(|a| a.pop());\n-                                tables.adjustments.get_mut(&rhs.id).map(|a| a.pop());\n+                                tables.adjustments.get_mut(&lhs.hir_id.local_id).map(|a| a.pop());\n+                                tables.adjustments.get_mut(&rhs.hir_id.local_id).map(|a| a.pop());\n                             }\n                         },\n                         hir::ExprAssignOp(..) => {\n-                            tables.adjustments.get_mut(&lhs.id).map(|a| a.pop());\n+                            tables.adjustments.get_mut(&lhs.hir_id.local_id).map(|a| a.pop());\n                         },\n                         _ => {},\n                     }\n@@ -163,12 +164,12 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n     fn visit_expr(&mut self, e: &'gcx hir::Expr) {\n         self.fix_scalar_builtin_expr(e);\n \n-        self.visit_node_id(e.span, (e.id, e.hir_id));\n+        self.visit_node_id(e.span, e.hir_id);\n \n         if let hir::ExprClosure(_, _, body, _) = e.node {\n             let body = self.fcx.tcx.hir.body(body);\n             for arg in &body.arguments {\n-                self.visit_node_id(e.span, (arg.id, arg.hir_id));\n+                self.visit_node_id(e.span, arg.hir_id);\n             }\n \n             self.visit_body(body);\n@@ -178,7 +179,7 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n     }\n \n     fn visit_block(&mut self, b: &'gcx hir::Block) {\n-        self.visit_node_id(b.span, (b.id, b.hir_id));\n+        self.visit_node_id(b.span, b.hir_id);\n         intravisit::walk_block(self, b);\n     }\n \n@@ -192,15 +193,15 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n             _ => {}\n         };\n \n-        self.visit_node_id(p.span, (p.id, p.hir_id));\n+        self.visit_node_id(p.span, p.hir_id);\n         intravisit::walk_pat(self, p);\n     }\n \n     fn visit_local(&mut self, l: &'gcx hir::Local) {\n         intravisit::walk_local(self, l);\n         let var_ty = self.fcx.local_ty(l.span, l.id);\n         let var_ty = self.resolve(&var_ty, &l.span);\n-        self.write_ty_to_tables(l.id, var_ty);\n+        self.write_ty_to_tables(l.hir_id, var_ty);\n     }\n }\n \n@@ -279,13 +280,13 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                 }\n             });\n \n-            self.tables.node_types.insert(node_id, outside_ty);\n+            let hir_id = self.tcx().hir.node_to_hir_id(node_id);\n+            self.tables.validate_hir_id(hir_id);\n+            self.tables.node_types.insert(hir_id.local_id, outside_ty);\n         }\n     }\n \n-    fn visit_node_id(&mut self,\n-                     span: Span,\n-                     (node_id, hir_id): (ast::NodeId, hir::HirId)) {\n+    fn visit_node_id(&mut self, span: Span, hir_id: hir::HirId) {\n         {\n             let mut fcx_tables = self.fcx.tables.borrow_mut();\n             fcx_tables.validate_hir_id(hir_id);\n@@ -297,34 +298,39 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         }\n \n         // Resolve any borrowings for the node with id `node_id`\n-        self.visit_adjustments(span, node_id);\n+        self.visit_adjustments(span, hir_id);\n \n         // Resolve the type of the node with id `node_id`\n-        let n_ty = self.fcx.node_ty(node_id);\n+        let n_ty = self.fcx.node_ty(hir_id);\n         let n_ty = self.resolve(&n_ty, &span);\n-        self.write_ty_to_tables(node_id, n_ty);\n-        debug!(\"Node {} has type {:?}\", node_id, n_ty);\n+        self.write_ty_to_tables(hir_id, n_ty);\n+        debug!(\"Node {:?} has type {:?}\", hir_id, n_ty);\n \n         // Resolve any substitutions\n-        if let Some(&substs) = self.fcx.tables.borrow().node_substs.get(&node_id) {\n+        if let Some(&substs) = self.fcx.tables.borrow().node_substs.get(&hir_id.local_id) {\n             let substs = self.resolve(&substs, &span);\n-            debug!(\"write_substs_to_tcx({}, {:?})\", node_id, substs);\n+            debug!(\"write_substs_to_tcx({:?}, {:?})\", hir_id, substs);\n             assert!(!substs.needs_infer());\n-            self.tables.node_substs.insert(node_id, substs);\n+            self.tables.node_substs.insert(hir_id.local_id, substs);\n         }\n     }\n \n-    fn visit_adjustments(&mut self, span: Span, node_id: ast::NodeId) {\n-        let adjustment = self.fcx.tables.borrow_mut().adjustments.remove(&node_id);\n+    fn visit_adjustments(&mut self, span: Span, hir_id: hir::HirId) {\n+        let adjustment = {\n+            let mut fcx_tables = self.fcx.tables.borrow_mut();\n+            fcx_tables.validate_hir_id(hir_id);\n+            fcx_tables.adjustments.remove(&hir_id.local_id)\n+        };\n         match adjustment {\n             None => {\n-                debug!(\"No adjustments for node {}\", node_id);\n+                debug!(\"No adjustments for node {:?}\", hir_id);\n             }\n \n             Some(adjustment) => {\n                 let resolved_adjustment = self.resolve(&adjustment, &span);\n-                debug!(\"Adjustments for node {}: {:?}\", node_id, resolved_adjustment);\n-                self.tables.adjustments.insert(node_id, resolved_adjustment);\n+                debug!(\"Adjustments for node {:?}: {:?}\", hir_id, resolved_adjustment);\n+                self.tables.validate_hir_id(hir_id);\n+                self.tables.adjustments.insert(hir_id.local_id, resolved_adjustment);\n             }\n         }\n     }"}, {"sha": "7b63bd883f9724eee5d4bc120cd90a900602ef0d", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2423eede51cc622420356988777db2473a0be2/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=7f2423eede51cc622420356988777db2473a0be2", "patch": "@@ -1187,7 +1187,8 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         NodeTy(&hir::Ty { node: TyImplTrait(..), .. }) => {\n             let owner = tcx.hir.get_parent_did(node_id);\n-            tcx.typeck_tables_of(owner).node_id_to_type(node_id)\n+            let hir_id = tcx.hir.node_to_hir_id(node_id);\n+            tcx.typeck_tables_of(owner).node_id_to_type(hir_id)\n         }\n \n         x => {"}]}