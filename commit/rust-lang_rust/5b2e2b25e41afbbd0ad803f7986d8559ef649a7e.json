{"sha": "5b2e2b25e41afbbd0ad803f7986d8559ef649a7e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViMmUyYjI1ZTQxYWZiYmQwYWQ4MDNmNzk4NmQ4NTU5ZWY2NDlhN2U=", "commit": {"author": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2020-07-29T06:09:16Z"}, "committer": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2020-07-29T15:22:17Z"}, "message": "Moved structs/enums with repr(C) to LLVM types into ffi.rs crates\n\nSome were in librustc_codegen_llvm, but others are not tied to LLVM, so\nI put them in a new crate: librustc_codegen_ssa/coverageinfo/ffi.rs", "tree": {"sha": "3ce76954bad8fa939bb832d67a08cfbbf4086bb1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3ce76954bad8fa939bb832d67a08cfbbf4086bb1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b2e2b25e41afbbd0ad803f7986d8559ef649a7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b2e2b25e41afbbd0ad803f7986d8559ef649a7e", "html_url": "https://github.com/rust-lang/rust/commit/5b2e2b25e41afbbd0ad803f7986d8559ef649a7e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b2e2b25e41afbbd0ad803f7986d8559ef649a7e/comments", "author": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "committer": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b58afc088f34341cdffad8d12bf1a13331ff7deb", "url": "https://api.github.com/repos/rust-lang/rust/commits/b58afc088f34341cdffad8d12bf1a13331ff7deb", "html_url": "https://github.com/rust-lang/rust/commit/b58afc088f34341cdffad8d12bf1a13331ff7deb"}], "stats": {"total": 441, "additions": 227, "deletions": 214}, "files": [{"sha": "4d9747a43f2e2b64e3c9681c50414a1490faf953", "filename": "src/librustc_codegen_llvm/coverageinfo/mapgen.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5b2e2b25e41afbbd0ad803f7986d8559ef649a7e/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmapgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b2e2b25e41afbbd0ad803f7986d8559ef649a7e/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmapgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmapgen.rs?ref=5b2e2b25e41afbbd0ad803f7986d8559ef649a7e", "patch": "@@ -2,8 +2,9 @@ use crate::common::CodegenCx;\n use crate::coverageinfo;\n use crate::llvm;\n \n+use llvm::coverageinfo::CounterMappingRegion;\n use log::debug;\n-use rustc_codegen_ssa::coverageinfo::map::*;\n+use rustc_codegen_ssa::coverageinfo::map::{Counter, CounterExpression, Region};\n use rustc_codegen_ssa::traits::{BaseTypeMethods, ConstMethods};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_llvm::RustString;\n@@ -132,7 +133,7 @@ impl CoverageMapGenerator {\n                 };\n                 virtual_file_mapping.push(filenames_index);\n             }\n-            mapping_regions.push(coverageinfo::CounterMappingRegion::code_region(\n+            mapping_regions.push(CounterMappingRegion::code_region(\n                 counter,\n                 current_file_id,\n                 start_line,"}, {"sha": "9d2090eae8f19669429e42c172942afa0d901973", "filename": "src/librustc_codegen_llvm/coverageinfo/mod.rs", "status": "modified", "additions": 2, "deletions": 145, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/5b2e2b25e41afbbd0ad803f7986d8559ef649a7e/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b2e2b25e41afbbd0ad803f7986d8559ef649a7e/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmod.rs?ref=5b2e2b25e41afbbd0ad803f7986d8559ef649a7e", "patch": "@@ -4,8 +4,9 @@ use crate::builder::Builder;\n use crate::common::CodegenCx;\n \n use libc::c_uint;\n+use llvm::coverageinfo::CounterMappingRegion;\n use log::debug;\n-use rustc_codegen_ssa::coverageinfo::map::*;\n+use rustc_codegen_ssa::coverageinfo::map::{CounterExpression, ExprKind, FunctionCoverage};\n use rustc_codegen_ssa::traits::{\n     BaseTypeMethods, CoverageInfoBuilderMethods, CoverageInfoMethods, StaticMethods,\n };\n@@ -110,150 +111,6 @@ impl CoverageInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n }\n \n-/// Aligns with [llvm::coverage::CounterMappingRegion::RegionKind](https://github.com/rust-lang/llvm-project/blob/rustc/10.0-2020-05-05/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L205-L221)\n-#[derive(Copy, Clone, Debug)]\n-#[repr(C)]\n-enum RegionKind {\n-    /// A CodeRegion associates some code with a counter\n-    CodeRegion = 0,\n-\n-    /// An ExpansionRegion represents a file expansion region that associates\n-    /// a source range with the expansion of a virtual source file, such as\n-    /// for a macro instantiation or #include file.\n-    ExpansionRegion = 1,\n-\n-    /// A SkippedRegion represents a source range with code that was skipped\n-    /// by a preprocessor or similar means.\n-    SkippedRegion = 2,\n-\n-    /// A GapRegion is like a CodeRegion, but its count is only set as the\n-    /// line execution count when its the only region in the line.\n-    GapRegion = 3,\n-}\n-\n-/// This struct provides LLVM's representation of a \"CoverageMappingRegion\", encoded into the\n-/// coverage map, in accordance with the\n-/// [LLVM Code Coverage Mapping Format](https://github.com/rust-lang/llvm-project/blob/llvmorg-8.0.0/llvm/docs/CoverageMappingFormat.rst#llvm-code-coverage-mapping-format).\n-/// The struct composes fields representing the `Counter` type and value(s) (injected counter ID,\n-/// or expression type and operands), the source file (an indirect index into a \"filenames array\",\n-/// encoded separately), and source location (start and end positions of the represented code\n-/// region).\n-///\n-/// Aligns with [llvm::coverage::CounterMappingRegion](https://github.com/rust-lang/llvm-project/blob/rustc/10.0-2020-05-05/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L223-L226)\n-/// Important: The Rust struct layout (order and types of fields) must match its C++ counterpart.\n-#[derive(Copy, Clone, Debug)]\n-#[repr(C)]\n-pub struct CounterMappingRegion {\n-    /// The counter type and type-dependent counter data, if any.\n-    counter: Counter,\n-\n-    /// An indirect reference to the source filename. In the LLVM Coverage Mapping Format, the\n-    /// file_id is an index into a function-specific `virtual_file_mapping` array of indexes that,\n-    /// in turn, are used to look up the filename for this region.\n-    file_id: u32,\n-\n-    /// If the `RegionKind` is an `ExpansionRegion`, the `expanded_file_id` can be used to find the\n-    /// mapping regions created as a result of macro expansion, by checking if their file id matches\n-    /// the expanded file id.\n-    expanded_file_id: u32,\n-\n-    /// 1-based starting line of the mapping region.\n-    start_line: u32,\n-\n-    /// 1-based starting column of the mapping region.\n-    start_col: u32,\n-\n-    /// 1-based ending line of the mapping region.\n-    end_line: u32,\n-\n-    /// 1-based ending column of the mapping region. If the high bit is set, the current mapping\n-    /// region is a gap area.\n-    end_col: u32,\n-\n-    kind: RegionKind,\n-}\n-\n-impl CounterMappingRegion {\n-    pub fn code_region(\n-        counter: Counter,\n-        file_id: u32,\n-        start_line: u32,\n-        start_col: u32,\n-        end_line: u32,\n-        end_col: u32,\n-    ) -> Self {\n-        Self {\n-            counter,\n-            file_id,\n-            expanded_file_id: 0,\n-            start_line,\n-            start_col,\n-            end_line,\n-            end_col,\n-            kind: RegionKind::CodeRegion,\n-        }\n-    }\n-\n-    pub fn expansion_region(\n-        file_id: u32,\n-        expanded_file_id: u32,\n-        start_line: u32,\n-        start_col: u32,\n-        end_line: u32,\n-        end_col: u32,\n-    ) -> Self {\n-        Self {\n-            counter: Counter::zero(),\n-            file_id,\n-            expanded_file_id,\n-            start_line,\n-            start_col,\n-            end_line,\n-            end_col,\n-            kind: RegionKind::ExpansionRegion,\n-        }\n-    }\n-\n-    pub fn skipped_region(\n-        file_id: u32,\n-        start_line: u32,\n-        start_col: u32,\n-        end_line: u32,\n-        end_col: u32,\n-    ) -> Self {\n-        Self {\n-            counter: Counter::zero(),\n-            file_id,\n-            expanded_file_id: 0,\n-            start_line,\n-            start_col,\n-            end_line,\n-            end_col,\n-            kind: RegionKind::SkippedRegion,\n-        }\n-    }\n-\n-    pub fn gap_region(\n-        counter: Counter,\n-        file_id: u32,\n-        start_line: u32,\n-        start_col: u32,\n-        end_line: u32,\n-        end_col: u32,\n-    ) -> Self {\n-        Self {\n-            counter,\n-            file_id,\n-            expanded_file_id: 0,\n-            start_line,\n-            start_col,\n-            end_line,\n-            end_col: ((1 as u32) << 31) | end_col,\n-            kind: RegionKind::GapRegion,\n-        }\n-    }\n-}\n-\n pub(crate) fn write_filenames_section_to_buffer(filenames: &Vec<CString>, buffer: &RustString) {\n     let c_str_vec = filenames.iter().map(|cstring| cstring.as_ptr()).collect::<Vec<_>>();\n     unsafe {"}, {"sha": "eb7dc827f9391b38fa15c332c9f79d805038879c", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 152, "deletions": 3, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/5b2e2b25e41afbbd0ad803f7986d8559ef649a7e/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b2e2b25e41afbbd0ad803f7986d8559ef649a7e/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=5b2e2b25e41afbbd0ad803f7986d8559ef649a7e", "patch": "@@ -1,7 +1,7 @@\n #![allow(non_camel_case_types)]\n #![allow(non_upper_case_globals)]\n \n-use crate::coverageinfo::CounterMappingRegion;\n+use rustc_codegen_ssa::coverageinfo::map as coverage_map;\n \n use super::debuginfo::{\n     DIArray, DIBasicType, DIBuilder, DICompositeType, DIDerivedType, DIDescriptor, DIEnumerator,\n@@ -652,6 +652,155 @@ pub struct Linker<'a>(InvariantOpaque<'a>);\n pub type DiagnosticHandler = unsafe extern \"C\" fn(&DiagnosticInfo, *mut c_void);\n pub type InlineAsmDiagHandler = unsafe extern \"C\" fn(&SMDiagnostic, *const c_void, c_uint);\n \n+pub mod coverageinfo {\n+    use super::coverage_map;\n+\n+    /// Aligns with [llvm::coverage::CounterMappingRegion::RegionKind](https://github.com/rust-lang/llvm-project/blob/rustc/10.0-2020-05-05/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L205-L221)\n+    #[derive(Copy, Clone, Debug)]\n+    #[repr(C)]\n+    pub enum RegionKind {\n+        /// A CodeRegion associates some code with a counter\n+        CodeRegion = 0,\n+\n+        /// An ExpansionRegion represents a file expansion region that associates\n+        /// a source range with the expansion of a virtual source file, such as\n+        /// for a macro instantiation or #include file.\n+        ExpansionRegion = 1,\n+\n+        /// A SkippedRegion represents a source range with code that was skipped\n+        /// by a preprocessor or similar means.\n+        SkippedRegion = 2,\n+\n+        /// A GapRegion is like a CodeRegion, but its count is only set as the\n+        /// line execution count when its the only region in the line.\n+        GapRegion = 3,\n+    }\n+\n+    /// This struct provides LLVM's representation of a \"CoverageMappingRegion\", encoded into the\n+    /// coverage map, in accordance with the\n+    /// [LLVM Code Coverage Mapping Format](https://github.com/rust-lang/llvm-project/blob/llvmorg-8.0.0/llvm/docs/CoverageMappingFormat.rst#llvm-code-coverage-mapping-format).\n+    /// The struct composes fields representing the `Counter` type and value(s) (injected counter\n+    /// ID, or expression type and operands), the source file (an indirect index into a \"filenames\n+    /// array\", encoded separately), and source location (start and end positions of the represented\n+    /// code region).\n+    ///\n+    /// Aligns with [llvm::coverage::CounterMappingRegion](https://github.com/rust-lang/llvm-project/blob/rustc/10.0-2020-05-05/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L223-L226)\n+    /// Important: The Rust struct layout (order and types of fields) must match its C++\n+    /// counterpart.\n+    #[derive(Copy, Clone, Debug)]\n+    #[repr(C)]\n+    pub struct CounterMappingRegion {\n+        /// The counter type and type-dependent counter data, if any.\n+        counter: coverage_map::Counter,\n+\n+        /// An indirect reference to the source filename. In the LLVM Coverage Mapping Format, the\n+        /// file_id is an index into a function-specific `virtual_file_mapping` array of indexes\n+        /// that, in turn, are used to look up the filename for this region.\n+        file_id: u32,\n+\n+        /// If the `RegionKind` is an `ExpansionRegion`, the `expanded_file_id` can be used to find\n+        /// the mapping regions created as a result of macro expansion, by checking if their file id\n+        /// matches the expanded file id.\n+        expanded_file_id: u32,\n+\n+        /// 1-based starting line of the mapping region.\n+        start_line: u32,\n+\n+        /// 1-based starting column of the mapping region.\n+        start_col: u32,\n+\n+        /// 1-based ending line of the mapping region.\n+        end_line: u32,\n+\n+        /// 1-based ending column of the mapping region. If the high bit is set, the current\n+        /// mapping region is a gap area.\n+        end_col: u32,\n+\n+        kind: RegionKind,\n+    }\n+\n+    impl CounterMappingRegion {\n+        pub fn code_region(\n+            counter: coverage_map::Counter,\n+            file_id: u32,\n+            start_line: u32,\n+            start_col: u32,\n+            end_line: u32,\n+            end_col: u32,\n+        ) -> Self {\n+            Self {\n+                counter,\n+                file_id,\n+                expanded_file_id: 0,\n+                start_line,\n+                start_col,\n+                end_line,\n+                end_col,\n+                kind: RegionKind::CodeRegion,\n+            }\n+        }\n+\n+        pub fn expansion_region(\n+            file_id: u32,\n+            expanded_file_id: u32,\n+            start_line: u32,\n+            start_col: u32,\n+            end_line: u32,\n+            end_col: u32,\n+        ) -> Self {\n+            Self {\n+                counter: coverage_map::Counter::zero(),\n+                file_id,\n+                expanded_file_id,\n+                start_line,\n+                start_col,\n+                end_line,\n+                end_col,\n+                kind: RegionKind::ExpansionRegion,\n+            }\n+        }\n+\n+        pub fn skipped_region(\n+            file_id: u32,\n+            start_line: u32,\n+            start_col: u32,\n+            end_line: u32,\n+            end_col: u32,\n+        ) -> Self {\n+            Self {\n+                counter: coverage_map::Counter::zero(),\n+                file_id,\n+                expanded_file_id: 0,\n+                start_line,\n+                start_col,\n+                end_line,\n+                end_col,\n+                kind: RegionKind::SkippedRegion,\n+            }\n+        }\n+\n+        pub fn gap_region(\n+            counter: coverage_map::Counter,\n+            file_id: u32,\n+            start_line: u32,\n+            start_col: u32,\n+            end_line: u32,\n+            end_col: u32,\n+        ) -> Self {\n+            Self {\n+                counter,\n+                file_id,\n+                expanded_file_id: 0,\n+                start_line,\n+                start_col,\n+                end_line,\n+                end_col: ((1 as u32) << 31) | end_col,\n+                kind: RegionKind::GapRegion,\n+            }\n+        }\n+    }\n+}\n+\n pub mod debuginfo {\n     use super::{InvariantOpaque, Metadata};\n     use bitflags::bitflags;\n@@ -1646,9 +1795,9 @@ extern \"C\" {\n     pub fn LLVMRustCoverageWriteMappingToBuffer(\n         VirtualFileMappingIDs: *const c_uint,\n         NumVirtualFileMappingIDs: c_uint,\n-        Expressions: *const rustc_codegen_ssa::coverageinfo::map::CounterExpression,\n+        Expressions: *const coverage_map::CounterExpression,\n         NumExpressions: c_uint,\n-        MappingRegions: *mut CounterMappingRegion,\n+        MappingRegions: *mut coverageinfo::CounterMappingRegion,\n         NumMappingRegions: c_uint,\n         BufferOut: &RustString,\n     );"}, {"sha": "5b04f99499437fead897b7edfd29dd573bc52fd0", "filename": "src/librustc_codegen_ssa/coverageinfo/ffi.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/5b2e2b25e41afbbd0ad803f7986d8559ef649a7e/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b2e2b25e41afbbd0ad803f7986d8559ef649a7e/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fffi.rs?ref=5b2e2b25e41afbbd0ad803f7986d8559ef649a7e", "patch": "@@ -0,0 +1,67 @@\n+use super::map::{CounterValueReference, MappedExpressionIndex};\n+\n+/// Aligns with [llvm::coverage::Counter::CounterKind](https://github.com/rust-lang/llvm-project/blob/rustc/10.0-2020-05-05/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L91)\n+#[derive(Copy, Clone, Debug)]\n+#[repr(C)]\n+enum CounterKind {\n+    Zero = 0,\n+    CounterValueReference = 1,\n+    Expression = 2,\n+}\n+\n+/// A reference to an instance of an abstract \"counter\" that will yield a value in a coverage\n+/// report. Note that `id` has different interpretations, depending on the `kind`:\n+///   * For `CounterKind::Zero`, `id` is assumed to be `0`\n+///   * For `CounterKind::CounterValueReference`,  `id` matches the `counter_id` of the injected\n+///     instrumentation counter (the `index` argument to the LLVM intrinsic\n+///     `instrprof.increment()`)\n+///   * For `CounterKind::Expression`, `id` is the index into the coverage map's array of\n+///     counter expressions.\n+/// Aligns with [llvm::coverage::Counter](https://github.com/rust-lang/llvm-project/blob/rustc/10.0-2020-05-05/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L98-L99)\n+/// Important: The Rust struct layout (order and types of fields) must match its C++ counterpart.\n+#[derive(Copy, Clone, Debug)]\n+#[repr(C)]\n+pub struct Counter {\n+    // Important: The layout (order and types of fields) must match its C++ counterpart.\n+    kind: CounterKind,\n+    id: u32,\n+}\n+\n+impl Counter {\n+    pub fn zero() -> Self {\n+        Self { kind: CounterKind::Zero, id: 0 }\n+    }\n+\n+    pub fn counter_value_reference(counter_id: CounterValueReference) -> Self {\n+        Self { kind: CounterKind::CounterValueReference, id: counter_id.into() }\n+    }\n+\n+    pub fn expression(mapped_expression_index: MappedExpressionIndex) -> Self {\n+        Self { kind: CounterKind::Expression, id: mapped_expression_index.into() }\n+    }\n+}\n+\n+/// Aligns with [llvm::coverage::CounterExpression::ExprKind](https://github.com/rust-lang/llvm-project/blob/rustc/10.0-2020-05-05/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L146)\n+#[derive(Copy, Clone, Debug)]\n+#[repr(C)]\n+pub enum ExprKind {\n+    Subtract = 0,\n+    Add = 1,\n+}\n+\n+/// Aligns with [llvm::coverage::CounterExpression](https://github.com/rust-lang/llvm-project/blob/rustc/10.0-2020-05-05/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L147-L148)\n+/// Important: The Rust struct layout (order and types of fields) must match its C++\n+/// counterpart.\n+#[derive(Copy, Clone, Debug)]\n+#[repr(C)]\n+pub struct CounterExpression {\n+    kind: ExprKind,\n+    lhs: Counter,\n+    rhs: Counter,\n+}\n+\n+impl CounterExpression {\n+    pub fn new(lhs: Counter, kind: ExprKind, rhs: Counter) -> Self {\n+        Self { kind, lhs, rhs }\n+    }\n+}"}, {"sha": "1e36c90baafdf85ec039ec516c8972c4032de30d", "filename": "src/librustc_codegen_ssa/coverageinfo/map.rs", "status": "modified", "additions": 2, "deletions": 64, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/5b2e2b25e41afbbd0ad803f7986d8559ef649a7e/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b2e2b25e41afbbd0ad803f7986d8559ef649a7e/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmap.rs?ref=5b2e2b25e41afbbd0ad803f7986d8559ef649a7e", "patch": "@@ -1,3 +1,5 @@\n+pub use super::ffi::*;\n+\n use rustc_index::vec::IndexVec;\n use rustc_middle::ty::Instance;\n use rustc_middle::ty::TyCtxt;\n@@ -36,70 +38,6 @@ rustc_index::newtype_index! {\n     }\n }\n \n-/// Aligns with [llvm::coverage::Counter::CounterKind](https://github.com/rust-lang/llvm-project/blob/rustc/10.0-2020-05-05/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L91)\n-#[derive(Copy, Clone, Debug)]\n-#[repr(C)]\n-enum CounterKind {\n-    Zero = 0,\n-    CounterValueReference = 1,\n-    Expression = 2,\n-}\n-\n-/// A reference to an instance of an abstract \"counter\" that will yield a value in a coverage\n-/// report. Note that `id` has different interpretations, depending on the `kind`:\n-///   * For `CounterKind::Zero`, `id` is assumed to be `0`\n-///   * For `CounterKind::CounterValueReference`,  `id` matches the `counter_id` of the injected\n-///     instrumentation counter (the `index` argument to the LLVM intrinsic `instrprof.increment()`)\n-///   * For `CounterKind::Expression`, `id` is the index into the coverage map's array of counter\n-///     expressions.\n-/// Aligns with [llvm::coverage::Counter](https://github.com/rust-lang/llvm-project/blob/rustc/10.0-2020-05-05/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L98-L99)\n-/// Important: The Rust struct layout (order and types of fields) must match its C++ counterpart.\n-#[derive(Copy, Clone, Debug)]\n-#[repr(C)]\n-pub struct Counter {\n-    // Important: The layout (order and types of fields) must match its C++ counterpart.\n-    kind: CounterKind,\n-    id: u32,\n-}\n-\n-impl Counter {\n-    pub fn zero() -> Self {\n-        Self { kind: CounterKind::Zero, id: 0 }\n-    }\n-\n-    pub fn counter_value_reference(counter_id: CounterValueReference) -> Self {\n-        Self { kind: CounterKind::CounterValueReference, id: counter_id.into() }\n-    }\n-\n-    pub fn expression(mapped_expression_index: MappedExpressionIndex) -> Self {\n-        Self { kind: CounterKind::Expression, id: mapped_expression_index.into() }\n-    }\n-}\n-\n-/// Aligns with [llvm::coverage::CounterExpression::ExprKind](https://github.com/rust-lang/llvm-project/blob/rustc/10.0-2020-05-05/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L146)\n-#[derive(Copy, Clone, Debug)]\n-#[repr(C)]\n-pub enum ExprKind {\n-    Subtract = 0,\n-    Add = 1,\n-}\n-\n-/// Aligns with [llvm::coverage::CounterExpression](https://github.com/rust-lang/llvm-project/blob/rustc/10.0-2020-05-05/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L147-L148)\n-/// Important: The Rust struct layout (order and types of fields) must match its C++ counterpart.\n-#[derive(Copy, Clone, Debug)]\n-#[repr(C)]\n-pub struct CounterExpression {\n-    kind: ExprKind,\n-    lhs: Counter,\n-    rhs: Counter,\n-}\n-\n-impl CounterExpression {\n-    pub fn new(lhs: Counter, kind: ExprKind, rhs: Counter) -> Self {\n-        Self { kind, lhs, rhs }\n-    }\n-}\n-\n #[derive(Clone, Debug)]\n pub struct Region {\n     start: Loc,"}, {"sha": "1f0ffd289b13a7ca9a158ecb9d42634c8f1cce49", "filename": "src/librustc_codegen_ssa/coverageinfo/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5b2e2b25e41afbbd0ad803f7986d8559ef649a7e/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b2e2b25e41afbbd0ad803f7986d8559ef649a7e/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmod.rs?ref=5b2e2b25e41afbbd0ad803f7986d8559ef649a7e", "patch": "@@ -1,3 +1,4 @@\n+pub mod ffi;\n pub mod map;\n \n pub use map::ExprKind;"}]}