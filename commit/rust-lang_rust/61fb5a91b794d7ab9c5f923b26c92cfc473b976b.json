{"sha": "61fb5a91b794d7ab9c5f923b26c92cfc473b976b", "node_id": "C_kwDOAAsO6NoAKDYxZmI1YTkxYjc5NGQ3YWI5YzVmOTIzYjI2YzkyY2ZjNDczYjk3NmI", "commit": {"author": {"name": "The 8472", "email": "git@infinite-source.de", "date": "2023-04-22T17:24:39Z"}, "committer": {"name": "The 8472", "email": "git@infinite-source.de", "date": "2023-04-28T21:08:54Z"}, "message": "layout-alignment-promotion logic should depend on the niche-bias\n\nFor start-biased layout we want to avoid overpromoting so that\nthe niche doesn't get pushed back.\nFor end-biased layout we want to avoid promoting fields that\nmay contain one of the niches of interest.", "tree": {"sha": "fab8cdc1c35362e85b38171b32ed6133e7e41d6f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fab8cdc1c35362e85b38171b32ed6133e7e41d6f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/61fb5a91b794d7ab9c5f923b26c92cfc473b976b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/61fb5a91b794d7ab9c5f923b26c92cfc473b976b", "html_url": "https://github.com/rust-lang/rust/commit/61fb5a91b794d7ab9c5f923b26c92cfc473b976b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/61fb5a91b794d7ab9c5f923b26c92cfc473b976b/comments", "author": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "committer": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "afe106cdc8b5dbcbeedb292b87dc7d7ae58964f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/afe106cdc8b5dbcbeedb292b87dc7d7ae58964f1", "html_url": "https://github.com/rust-lang/rust/commit/afe106cdc8b5dbcbeedb292b87dc7d7ae58964f1"}], "stats": {"total": 48, "additions": 41, "deletions": 7}, "files": [{"sha": "b4597d5bc78450eee640215a88d51c042ed74d23", "filename": "compiler/rustc_abi/src/layout.rs", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/61fb5a91b794d7ab9c5f923b26c92cfc473b976b/compiler%2Frustc_abi%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61fb5a91b794d7ab9c5f923b26c92cfc473b976b/compiler%2Frustc_abi%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flayout.rs?ref=61fb5a91b794d7ab9c5f923b26c92cfc473b976b", "patch": "@@ -794,7 +794,7 @@ fn univariant(\n     let mut align = if pack.is_some() { dl.i8_align } else { dl.aggregate_align };\n     let mut inverse_memory_index: IndexVec<u32, FieldIdx> = fields.indices().collect();\n     let optimize = !repr.inhibit_struct_field_reordering_opt();\n-    if optimize {\n+    if optimize && fields.len() > 1 {\n         let end = if let StructKind::MaybeUnsized = kind { fields.len() - 1 } else { fields.len() };\n         let optimizing = &mut inverse_memory_index.raw[..end];\n \n@@ -814,7 +814,12 @@ fn univariant(\n             // Otherwise we just leave things alone and actually optimize the type's fields\n         } else {\n             let max_field_align = fields.iter().map(|f| f.align().abi.bytes()).max().unwrap_or(1);\n-            let any_niche = fields.iter().any(|f| f.largest_niche().is_some());\n+            let largest_niche_size = fields\n+                .iter()\n+                .filter_map(|f| f.largest_niche())\n+                .map(|n| n.available(dl))\n+                .max()\n+                .unwrap_or(0);\n \n             // Calculates a sort key to group fields by their alignment or possibly some size-derived\n             // pseudo-alignment.\n@@ -829,13 +834,23 @@ fn univariant(\n                     //\n                     let align = layout.align().abi.bytes();\n                     let size = layout.size().bytes();\n+                    let niche_size = layout.largest_niche().map(|n| n.available(dl)).unwrap_or(0);\n                     // group [u8; 4] with align-4 or [u8; 6] with align-2 fields\n                     let size_as_align = align.max(size).trailing_zeros();\n-                    // Given `A(u8, [u8; 16])` and `B(bool, [u8; 16])` we want to bump the array\n-                    // to the front in the first case (for aligned loads) but keep the bool in front\n-                    // in the second case for its niches.\n-                    let size_as_align = if any_niche {\n-                        max_field_align.trailing_zeros().min(size_as_align)\n+                    let size_as_align = if largest_niche_size > 0 {\n+                        match niche_bias {\n+                            // Given `A(u8, [u8; 16])` and `B(bool, [u8; 16])` we want to bump the array\n+                            // to the front in the first case (for aligned loads) but keep the bool in front\n+                            // in the second case for its niches.\n+                            NicheBias::Start => max_field_align.trailing_zeros().min(size_as_align),\n+                            // When moving niches towards the end of the struct then for\n+                            // A((u8, u8, u8, bool), (u8, bool, u8)) we want to keep the first tuple\n+                            // in the align-1 group because its bool can be moved closer to the end.\n+                            NicheBias::End if niche_size == largest_niche_size => {\n+                                align.trailing_zeros()\n+                            }\n+                            NicheBias::End => size_as_align,\n+                        }\n                     } else {\n                         size_as_align\n                     };"}, {"sha": "406e5c8441e7312e2d988e2b70a9022b260567e2", "filename": "tests/ui/structs-enums/type-sizes.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/61fb5a91b794d7ab9c5f923b26c92cfc473b976b/tests%2Fui%2Fstructs-enums%2Ftype-sizes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61fb5a91b794d7ab9c5f923b26c92cfc473b976b/tests%2Fui%2Fstructs-enums%2Ftype-sizes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstructs-enums%2Ftype-sizes.rs?ref=61fb5a91b794d7ab9c5f923b26c92cfc473b976b", "patch": "@@ -198,6 +198,18 @@ struct ReorderWithNiche {\n     ary: [u8; 8]\n }\n \n+#[repr(C)]\n+struct EndNiche8([u8; 7], bool);\n+\n+#[repr(C)]\n+struct MiddleNiche4(u8, u8, bool, u8);\n+\n+struct ReorderEndNiche {\n+    a: EndNiche8,\n+    b: MiddleNiche4,\n+}\n+\n+\n // standins for std types which we want to be laid out in a reasonable way\n struct RawVecDummy {\n     ptr: NonNull<u8>,\n@@ -316,4 +328,11 @@ pub fn main() {\n             \"here [u8; 8] should group with _at least_ align-4 fields\");\n     assert_eq!(ptr::from_ref(&v), ptr::from_ref(&v.b).cast(),\n                \"sort niches to the front where possible\");\n+\n+    // Neither field has a niche at the beginning so the layout algorithm should try move niches to\n+    // the end which means the 8-sized field shouldn't be alignment-promoted before the 4-sized one.\n+    let v = ReorderEndNiche { a: EndNiche8([0; 7], false), b: MiddleNiche4(0, 0, false, 0) };\n+    assert!(ptr::from_ref(&v.a).addr() > ptr::from_ref(&v.b).addr());\n+\n+\n }"}]}