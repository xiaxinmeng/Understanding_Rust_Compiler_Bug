{"sha": "72def9a3f559b5c4611d924540407896b9819d20", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyZGVmOWEzZjU1OWI1YzQ2MTFkOTI0NTQwNDA3ODk2Yjk4MTlkMjA=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2020-02-14T22:17:52Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-02-14T22:17:52Z"}, "message": "Rollup merge of #69150 - nnethercote:68848-follow-up, r=petrochenkov\n\nFollow-up to #68848\n\nThis PR contains some late changes to #68848 that somehow didn't get included when that PR was merged in a roll-up.\n\nr? @petrochenkov", "tree": {"sha": "4b81ce1d6f0c86eaaa7c5f9e0b3e0abddbed6e21", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b81ce1d6f0c86eaaa7c5f9e0b3e0abddbed6e21"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/72def9a3f559b5c4611d924540407896b9819d20", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeRxyQCRBK7hj4Ov3rIwAAdHIIAAqSgEDApu8lH745f/UZGD61\nz2YzUGBliG1bVhCoCMEAhAgW4mxSJeef05ppNlHulRR1AGfuLrCUufIp3D8wl4mr\neOZPlNLnFEmBrjFX50ZED3BjmdzQpWtfRsdk4mrKOyoCbXIhdsCXWmOELdwe1Yhm\nym3TvChB3z18IaMg7L35ki+1W8ZcmBMoy/+V9+y6iEkMycN8Gm8JJ2ZRHdEG9LfC\nvOis6hmFcK+samW9v0pspQeMFQnT+Umq0WV+LWzMm92+/z0u4wgdqrYwz48R30/8\n6hjoHbpDqGMnMWc/KSPpJvSxPnQI2T17BrlRYchsG48tOxY8Y0xGOI9cIoXqdKg=\n=Zfm1\n-----END PGP SIGNATURE-----\n", "payload": "tree 4b81ce1d6f0c86eaaa7c5f9e0b3e0abddbed6e21\nparent 940fff7250dec007a67e8bccd47051895a440cf7\nparent 88b0912d27afa0fa2f9593c3c7545207127ff91c\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1581718672 +0900\ncommitter GitHub <noreply@github.com> 1581718672 +0900\n\nRollup merge of #69150 - nnethercote:68848-follow-up, r=petrochenkov\n\nFollow-up to #68848\n\nThis PR contains some late changes to #68848 that somehow didn't get included when that PR was merged in a roll-up.\n\nr? @petrochenkov\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/72def9a3f559b5c4611d924540407896b9819d20", "html_url": "https://github.com/rust-lang/rust/commit/72def9a3f559b5c4611d924540407896b9819d20", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/72def9a3f559b5c4611d924540407896b9819d20/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "940fff7250dec007a67e8bccd47051895a440cf7", "url": "https://api.github.com/repos/rust-lang/rust/commits/940fff7250dec007a67e8bccd47051895a440cf7", "html_url": "https://github.com/rust-lang/rust/commit/940fff7250dec007a67e8bccd47051895a440cf7"}, {"sha": "88b0912d27afa0fa2f9593c3c7545207127ff91c", "url": "https://api.github.com/repos/rust-lang/rust/commits/88b0912d27afa0fa2f9593c3c7545207127ff91c", "html_url": "https://github.com/rust-lang/rust/commit/88b0912d27afa0fa2f9593c3c7545207127ff91c"}], "stats": {"total": 32, "additions": 15, "deletions": 17}, "files": [{"sha": "f6abcce4d3facb79592b6e258032d1be208af178", "filename": "src/librustc_expand/mbe/macro_rules.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/72def9a3f559b5c4611d924540407896b9819d20/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72def9a3f559b5c4611d924540407896b9819d20/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs?ref=72def9a3f559b5c4611d924540407896b9819d20", "patch": "@@ -191,9 +191,9 @@ fn generic_extension<'cx>(\n     let mut best_failure: Option<(Token, &str)> = None;\n \n     // We create a base parser that can be used for the \"black box\" parts.\n-    // Every iteration needs a fresh copy of that base parser. However, the\n-    // parser is not mutated on many of the iterations, particularly when\n-    // dealing with macros like this:\n+    // Every iteration needs a fresh copy of that parser. However, the parser\n+    // is not mutated on many of the iterations, particularly when dealing with\n+    // macros like this:\n     //\n     // macro_rules! foo {\n     //     (\"a\") => (A);\n@@ -209,11 +209,9 @@ fn generic_extension<'cx>(\n     // hacky, but speeds up the `html5ever` benchmark significantly. (Issue\n     // 68836 suggests a more comprehensive but more complex change to deal with\n     // this situation.)\n-    let base_parser = base_parser_from_cx(&cx.current_expansion, &cx.parse_sess, arg.clone());\n+    let parser = parser_from_cx(&cx.current_expansion, &cx.parse_sess, arg.clone());\n \n     for (i, lhs) in lhses.iter().enumerate() {\n-        let mut parser = Cow::Borrowed(&base_parser);\n-\n         // try each arm's matchers\n         let lhs_tt = match *lhs {\n             mbe::TokenTree::Delimited(_, ref delim) => &delim.tts[..],\n@@ -224,13 +222,14 @@ fn generic_extension<'cx>(\n         // This is used so that if a matcher is not `Success(..)`ful,\n         // then the spans which became gated when parsing the unsuccessful matcher\n         // are not recorded. On the first `Success(..)`ful matcher, the spans are merged.\n-        let mut gated_spans_snaphot = mem::take(&mut *cx.parse_sess.gated_spans.spans.borrow_mut());\n+        let mut gated_spans_snapshot =\n+            mem::take(&mut *cx.parse_sess.gated_spans.spans.borrow_mut());\n \n-        match parse_tt(&mut parser, lhs_tt) {\n+        match parse_tt(&mut Cow::Borrowed(&parser), lhs_tt) {\n             Success(named_matches) => {\n                 // The matcher was `Success(..)`ful.\n                 // Merge the gated spans from parsing the matcher with the pre-existing ones.\n-                cx.parse_sess.gated_spans.merge(gated_spans_snaphot);\n+                cx.parse_sess.gated_spans.merge(gated_spans_snapshot);\n \n                 let rhs = match rhses[i] {\n                     // ignore delimiters\n@@ -291,9 +290,9 @@ fn generic_extension<'cx>(\n \n         // The matcher was not `Success(..)`ful.\n         // Restore to the state before snapshotting and maybe try again.\n-        mem::swap(&mut gated_spans_snaphot, &mut cx.parse_sess.gated_spans.spans.borrow_mut());\n+        mem::swap(&mut gated_spans_snapshot, &mut cx.parse_sess.gated_spans.spans.borrow_mut());\n     }\n-    drop(base_parser);\n+    drop(parser);\n \n     let (token, label) = best_failure.expect(\"ran no matchers\");\n     let span = token.span.substitute_dummy(sp);\n@@ -311,9 +310,8 @@ fn generic_extension<'cx>(\n                 mbe::TokenTree::Delimited(_, ref delim) => &delim.tts[..],\n                 _ => continue,\n             };\n-            let base_parser =\n-                base_parser_from_cx(&cx.current_expansion, &cx.parse_sess, arg.clone());\n-            match parse_tt(&mut Cow::Borrowed(&base_parser), lhs_tt) {\n+            let parser = parser_from_cx(&cx.current_expansion, &cx.parse_sess, arg.clone());\n+            match parse_tt(&mut Cow::Borrowed(&parser), lhs_tt) {\n                 Success(_) => {\n                     if comma_span.is_dummy() {\n                         err.note(\"you might be missing a comma\");\n@@ -395,8 +393,8 @@ pub fn compile_declarative_macro(\n         ),\n     ];\n \n-    let base_parser = Parser::new(sess, body, None, true, true, rustc_parse::MACRO_ARGUMENTS);\n-    let argument_map = match parse_tt(&mut Cow::Borrowed(&base_parser), &argument_gram) {\n+    let parser = Parser::new(sess, body, None, true, true, rustc_parse::MACRO_ARGUMENTS);\n+    let argument_map = match parse_tt(&mut Cow::Borrowed(&parser), &argument_gram) {\n         Success(m) => m,\n         Failure(token, msg) => {\n             let s = parse_failure_msg(&token);\n@@ -1212,7 +1210,7 @@ fn quoted_tt_to_string(tt: &mbe::TokenTree) -> String {\n     }\n }\n \n-fn base_parser_from_cx<'cx>(\n+fn parser_from_cx<'cx>(\n     current_expansion: &'cx ExpansionData,\n     sess: &'cx ParseSess,\n     tts: TokenStream,"}]}