{"sha": "bcbcbad7746cdab8465d2df1d9296cd74e30082f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjYmNiYWQ3NzQ2Y2RhYjg0NjVkMmRmMWQ5Mjk2Y2Q3NGUzMDA4MmY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-04-20T04:18:33Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-04-20T04:58:45Z"}, "message": "syntax: Extract some functions into mod common", "tree": {"sha": "21da04db709f9ee64416fb068ca96b9d23d72e64", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/21da04db709f9ee64416fb068ca96b9d23d72e64"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bcbcbad7746cdab8465d2df1d9296cd74e30082f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bcbcbad7746cdab8465d2df1d9296cd74e30082f", "html_url": "https://github.com/rust-lang/rust/commit/bcbcbad7746cdab8465d2df1d9296cd74e30082f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bcbcbad7746cdab8465d2df1d9296cd74e30082f/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "628e80d525392ebbcb889bb5d9b37e73c82d335a", "url": "https://api.github.com/repos/rust-lang/rust/commits/628e80d525392ebbcb889bb5d9b37e73c82d335a", "html_url": "https://github.com/rust-lang/rust/commit/628e80d525392ebbcb889bb5d9b37e73c82d335a"}], "stats": {"total": 414, "additions": 208, "deletions": 206}, "files": [{"sha": "b7caa00a2af05b507bbe32bd6d588911f1a3a3f1", "filename": "src/librustsyntax/parse/attr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bcbcbad7746cdab8465d2df1d9296cd74e30082f/src%2Flibrustsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcbcbad7746cdab8465d2df1d9296cd74e30082f/src%2Flibrustsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse%2Fattr.rs?ref=bcbcbad7746cdab8465d2df1d9296cd74e30082f", "patch": "@@ -1,11 +1,11 @@\n import either::{either, left, right};\n-import parser::{parse_seq,\n+import common::{parse_seq,\n                 seq_sep,\n                 expect,\n-                parse_lit,\n                 parse_ident,\n-                parse_syntax_ext_naked,\n                 spanned};\n+import parser::{parse_lit,\n+                parse_syntax_ext_naked};\n \n export attr_or_ext;\n export parse_outer_attributes;"}, {"sha": "ba0d4530cffaf8c9fc9c89701c71446789b9e672", "filename": "src/librustsyntax/parse/common.rs", "status": "added", "additions": 201, "deletions": 0, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/bcbcbad7746cdab8465d2df1d9296cd74e30082f/src%2Flibrustsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcbcbad7746cdab8465d2df1d9296cd74e30082f/src%2Flibrustsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse%2Fcommon.rs?ref=bcbcbad7746cdab8465d2df1d9296cd74e30082f", "patch": "@@ -0,0 +1,201 @@\n+import std::map::{hashmap};\n+import ast::spanned;\n+import parser::parser;\n+\n+fn token_to_str(reader: reader, token: token::token) -> str {\n+    token::to_str(*reader.interner, token)\n+}\n+\n+fn unexpected_last(p: parser, t: token::token) -> ! {\n+    p.span_fatal(p.last_span,\n+                 \"unexpected token: '\" + token_to_str(p.reader, t) + \"'\");\n+}\n+\n+fn unexpected(p: parser) -> ! {\n+    p.fatal(\"unexpected token: '\" + token_to_str(p.reader, p.token) + \"'\");\n+}\n+\n+fn expect(p: parser, t: token::token) {\n+    if p.token == t {\n+        p.bump();\n+    } else {\n+        let mut s: str = \"expecting '\";\n+        s += token_to_str(p.reader, t);\n+        s += \"' but found '\";\n+        s += token_to_str(p.reader, p.token);\n+        p.fatal(s + \"'\");\n+    }\n+}\n+\n+fn spanned<T: copy>(lo: uint, hi: uint, node: T) -> spanned<T> {\n+    ret {node: node, span: ast_util::mk_sp(lo, hi)};\n+}\n+\n+fn parse_ident(p: parser) -> ast::ident {\n+    alt p.token {\n+      token::IDENT(i, _) { p.bump(); ret p.get_str(i); }\n+      _ { p.fatal(\"expecting ident, found \"\n+                  + token_to_str(p.reader, p.token)); }\n+    }\n+}\n+\n+fn parse_path_list_ident(p: parser) -> ast::path_list_ident {\n+    let lo = p.span.lo;\n+    let ident = parse_ident(p);\n+    let hi = p.span.hi;\n+    ret spanned(lo, hi, {name: ident, id: p.get_id()});\n+}\n+\n+fn parse_value_ident(p: parser) -> ast::ident {\n+    check_bad_word(p);\n+    ret parse_ident(p);\n+}\n+\n+fn eat(p: parser, tok: token::token) -> bool {\n+    ret if p.token == tok { p.bump(); true } else { false };\n+}\n+\n+// A sanity check that the word we are asking for is a known keyword\n+fn require_keyword(p: parser, word: str) {\n+    if !p.keywords.contains_key(word) {\n+        p.bug(#fmt(\"unknown keyword: %s\", word));\n+    }\n+}\n+\n+fn is_word(p: parser, word: str) -> bool {\n+    require_keyword(p, word);\n+    ret alt p.token {\n+          token::IDENT(sid, false) { str::eq(word, p.get_str(sid)) }\n+          _ { false }\n+        };\n+}\n+\n+fn eat_word(p: parser, word: str) -> bool {\n+    require_keyword(p, word);\n+    alt p.token {\n+      token::IDENT(sid, false) {\n+        if str::eq(word, p.get_str(sid)) {\n+            p.bump();\n+            ret true;\n+        } else { ret false; }\n+      }\n+      _ { ret false; }\n+    }\n+}\n+\n+fn expect_word(p: parser, word: str) {\n+    require_keyword(p, word);\n+    if !eat_word(p, word) {\n+        p.fatal(\"expecting \" + word + \", found \" +\n+                    token_to_str(p.reader, p.token));\n+    }\n+}\n+\n+fn check_bad_word(p: parser) {\n+    if token::is_bad_expr_word(p.token, p.bad_expr_words,\n+                               *p.reader.interner) {\n+        let w = token_to_str(p.reader, p.token);\n+        p.fatal(\"found \" + w + \" in expression position\");\n+    }\n+}\n+\n+fn expect_gt(p: parser) {\n+    if p.token == token::GT {\n+        p.bump();\n+    } else if p.token == token::BINOP(token::LSR) {\n+        p.swap(token::GT, p.span.lo + 1u, p.span.hi);\n+    } else if p.token == token::BINOP(token::ASR) {\n+        p.swap(token::BINOP(token::LSR), p.span.lo + 1u, p.span.hi);\n+    } else {\n+        let mut s: str = \"expecting \";\n+        s += token_to_str(p.reader, token::GT);\n+        s += \", found \";\n+        s += token_to_str(p.reader, p.token);\n+        p.fatal(s);\n+    }\n+}\n+\n+fn parse_seq_to_before_gt<T: copy>(sep: option<token::token>,\n+                                  f: fn(parser) -> T,\n+                                  p: parser) -> [T] {\n+    let mut first = true;\n+    let mut v = [];\n+    while p.token != token::GT && p.token != token::BINOP(token::LSR) &&\n+              p.token != token::BINOP(token::ASR) {\n+        alt sep {\n+          some(t) { if first { first = false; } else { expect(p, t); } }\n+          _ { }\n+        }\n+        v += [f(p)];\n+    }\n+\n+    ret v;\n+}\n+\n+fn parse_seq_to_gt<T: copy>(sep: option<token::token>,\n+                           f: fn(parser) -> T, p: parser) -> [T] {\n+    let v = parse_seq_to_before_gt(sep, f, p);\n+    expect_gt(p);\n+\n+    ret v;\n+}\n+\n+fn parse_seq_lt_gt<T: copy>(sep: option<token::token>,\n+                           f: fn(parser) -> T,\n+                           p: parser) -> spanned<[T]> {\n+    let lo = p.span.lo;\n+    expect(p, token::LT);\n+    let result = parse_seq_to_before_gt::<T>(sep, f, p);\n+    let hi = p.span.hi;\n+    expect_gt(p);\n+    ret spanned(lo, hi, result);\n+}\n+\n+fn parse_seq_to_end<T: copy>(ket: token::token, sep: seq_sep,\n+                            f: fn(parser) -> T, p: parser) -> [T] {\n+    let val = parse_seq_to_before_end(ket, sep, f, p);\n+    p.bump();\n+    ret val;\n+}\n+\n+type seq_sep = {\n+    sep: option<token::token>,\n+    trailing_opt: bool   // is trailing separator optional?\n+};\n+\n+fn seq_sep(t: token::token) -> seq_sep {\n+    ret {sep: option::some(t), trailing_opt: false};\n+}\n+fn seq_sep_opt(t: token::token) -> seq_sep {\n+    ret {sep: option::some(t), trailing_opt: true};\n+}\n+fn seq_sep_none() -> seq_sep {\n+    ret {sep: option::none, trailing_opt: false};\n+}\n+\n+fn parse_seq_to_before_end<T: copy>(ket: token::token,\n+                                   sep: seq_sep,\n+                                   f: fn(parser) -> T, p: parser) -> [T] {\n+    let mut first: bool = true;\n+    let mut v: [T] = [];\n+    while p.token != ket {\n+        alt sep.sep {\n+          some(t) { if first { first = false; } else { expect(p, t); } }\n+          _ { }\n+        }\n+        if sep.trailing_opt && p.token == ket { break; }\n+        v += [f(p)];\n+    }\n+    ret v;\n+}\n+\n+fn parse_seq<T: copy>(bra: token::token, ket: token::token,\n+                     sep: seq_sep, f: fn(parser) -> T,\n+                     p: parser) -> spanned<[T]> {\n+    let lo = p.span.lo;\n+    expect(p, bra);\n+    let result = parse_seq_to_before_end::<T>(ket, sep, f, p);\n+    let hi = p.span.hi;\n+    p.bump();\n+    ret spanned(lo, hi, result);\n+}"}, {"sha": "2a8e683dee59f14118c87ef7c248b745d47bdfa9", "filename": "src/librustsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 203, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/bcbcbad7746cdab8465d2df1d9296cd74e30082f/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcbcbad7746cdab8465d2df1d9296cd74e30082f/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse%2Fparser.rs?ref=bcbcbad7746cdab8465d2df1d9296cd74e30082f", "patch": "@@ -12,6 +12,7 @@ import attr::{parse_outer_attrs_or_ext,\n               parse_inner_attrs_and_next,\n               parse_outer_attributes,\n               parse_optional_meta};\n+import common::*;\n \n export expect;\n export file_type;\n@@ -27,11 +28,7 @@ export parse_pat;\n export parse_seq;\n export parse_stmt;\n export parse_ty;\n-\n-export spanned;\n-export seq_sep;\n export parse_lit;\n-export parse_ident;\n export parse_syntax_ext_naked;\n \n // FIXME: #ast expects to find this here but it's actually defined in `parse`\n@@ -108,119 +105,6 @@ impl parser for parser {\n     fn get_id() -> node_id { next_node_id(self.sess) }\n }\n \n-fn token_to_str(reader: reader, token: token::token) -> str {\n-    token::to_str(*reader.interner, token)\n-}\n-\n-fn unexpected_last(p: parser, t: token::token) -> ! {\n-    p.span_fatal(p.last_span,\n-                 \"unexpected token: '\" + token_to_str(p.reader, t) + \"'\");\n-}\n-\n-fn unexpected(p: parser) -> ! {\n-    p.fatal(\"unexpected token: '\" + token_to_str(p.reader, p.token) + \"'\");\n-}\n-\n-fn expect(p: parser, t: token::token) {\n-    if p.token == t {\n-        p.bump();\n-    } else {\n-        let mut s: str = \"expecting '\";\n-        s += token_to_str(p.reader, t);\n-        s += \"' but found '\";\n-        s += token_to_str(p.reader, p.token);\n-        p.fatal(s + \"'\");\n-    }\n-}\n-\n-fn expect_gt(p: parser) {\n-    if p.token == token::GT {\n-        p.bump();\n-    } else if p.token == token::BINOP(token::LSR) {\n-        p.swap(token::GT, p.span.lo + 1u, p.span.hi);\n-    } else if p.token == token::BINOP(token::ASR) {\n-        p.swap(token::BINOP(token::LSR), p.span.lo + 1u, p.span.hi);\n-    } else {\n-        let mut s: str = \"expecting \";\n-        s += token_to_str(p.reader, token::GT);\n-        s += \", found \";\n-        s += token_to_str(p.reader, p.token);\n-        p.fatal(s);\n-    }\n-}\n-\n-fn spanned<T: copy>(lo: uint, hi: uint, node: T) -> spanned<T> {\n-    ret {node: node, span: ast_util::mk_sp(lo, hi)};\n-}\n-\n-fn parse_ident(p: parser) -> ast::ident {\n-    alt p.token {\n-      token::IDENT(i, _) { p.bump(); ret p.get_str(i); }\n-      _ { p.fatal(\"expecting ident, found \"\n-                  + token_to_str(p.reader, p.token)); }\n-    }\n-}\n-\n-fn parse_path_list_ident(p: parser) -> ast::path_list_ident {\n-    let lo = p.span.lo;\n-    let ident = parse_ident(p);\n-    let hi = p.span.hi;\n-    ret spanned(lo, hi, {name: ident, id: p.get_id()});\n-}\n-\n-fn parse_value_ident(p: parser) -> ast::ident {\n-    check_bad_word(p);\n-    ret parse_ident(p);\n-}\n-\n-fn eat(p: parser, tok: token::token) -> bool {\n-    ret if p.token == tok { p.bump(); true } else { false };\n-}\n-\n-// A sanity check that the word we are asking for is a known keyword\n-fn require_keyword(p: parser, word: str) {\n-    if !p.keywords.contains_key(word) {\n-        p.bug(#fmt(\"unknown keyword: %s\", word));\n-    }\n-}\n-\n-fn is_word(p: parser, word: str) -> bool {\n-    require_keyword(p, word);\n-    ret alt p.token {\n-          token::IDENT(sid, false) { str::eq(word, p.get_str(sid)) }\n-          _ { false }\n-        };\n-}\n-\n-fn eat_word(p: parser, word: str) -> bool {\n-    require_keyword(p, word);\n-    alt p.token {\n-      token::IDENT(sid, false) {\n-        if str::eq(word, p.get_str(sid)) {\n-            p.bump();\n-            ret true;\n-        } else { ret false; }\n-      }\n-      _ { ret false; }\n-    }\n-}\n-\n-fn expect_word(p: parser, word: str) {\n-    require_keyword(p, word);\n-    if !eat_word(p, word) {\n-        p.fatal(\"expecting \" + word + \", found \" +\n-                    token_to_str(p.reader, p.token));\n-    }\n-}\n-\n-fn check_bad_word(p: parser) {\n-    if token::is_bad_expr_word(p.token, p.bad_expr_words,\n-                               *p.reader.interner) {\n-        let w = token_to_str(p.reader, p.token);\n-        p.fatal(\"found \" + w + \" in expression position\");\n-    }\n-}\n-\n fn parse_ty_fn(p: parser) -> ast::fn_decl {\n     fn parse_fn_input_ty(p: parser) -> ast::arg {\n         let mode = parse_arg_mode(p);\n@@ -557,92 +441,6 @@ fn parse_fn_block_arg(p: parser) -> ast::arg {\n     ret {mode: m, ty: t, ident: i, id: p.get_id()};\n }\n \n-fn parse_seq_to_before_gt<T: copy>(sep: option<token::token>,\n-                                  f: fn(parser) -> T,\n-                                  p: parser) -> [T] {\n-    let mut first = true;\n-    let mut v = [];\n-    while p.token != token::GT && p.token != token::BINOP(token::LSR) &&\n-              p.token != token::BINOP(token::ASR) {\n-        alt sep {\n-          some(t) { if first { first = false; } else { expect(p, t); } }\n-          _ { }\n-        }\n-        v += [f(p)];\n-    }\n-\n-    ret v;\n-}\n-\n-fn parse_seq_to_gt<T: copy>(sep: option<token::token>,\n-                           f: fn(parser) -> T, p: parser) -> [T] {\n-    let v = parse_seq_to_before_gt(sep, f, p);\n-    expect_gt(p);\n-\n-    ret v;\n-}\n-\n-fn parse_seq_lt_gt<T: copy>(sep: option<token::token>,\n-                           f: fn(parser) -> T,\n-                           p: parser) -> spanned<[T]> {\n-    let lo = p.span.lo;\n-    expect(p, token::LT);\n-    let result = parse_seq_to_before_gt::<T>(sep, f, p);\n-    let hi = p.span.hi;\n-    expect_gt(p);\n-    ret spanned(lo, hi, result);\n-}\n-\n-fn parse_seq_to_end<T: copy>(ket: token::token, sep: seq_sep,\n-                            f: fn(parser) -> T, p: parser) -> [T] {\n-    let val = parse_seq_to_before_end(ket, sep, f, p);\n-    p.bump();\n-    ret val;\n-}\n-\n-type seq_sep = {\n-    sep: option<token::token>,\n-    trailing_opt: bool   // is trailing separator optional?\n-};\n-\n-fn seq_sep(t: token::token) -> seq_sep {\n-    ret {sep: option::some(t), trailing_opt: false};\n-}\n-fn seq_sep_opt(t: token::token) -> seq_sep {\n-    ret {sep: option::some(t), trailing_opt: true};\n-}\n-fn seq_sep_none() -> seq_sep {\n-    ret {sep: option::none, trailing_opt: false};\n-}\n-\n-fn parse_seq_to_before_end<T: copy>(ket: token::token,\n-                                   sep: seq_sep,\n-                                   f: fn(parser) -> T, p: parser) -> [T] {\n-    let mut first: bool = true;\n-    let mut v: [T] = [];\n-    while p.token != ket {\n-        alt sep.sep {\n-          some(t) { if first { first = false; } else { expect(p, t); } }\n-          _ { }\n-        }\n-        if sep.trailing_opt && p.token == ket { break; }\n-        v += [f(p)];\n-    }\n-    ret v;\n-}\n-\n-\n-fn parse_seq<T: copy>(bra: token::token, ket: token::token,\n-                     sep: seq_sep, f: fn(parser) -> T,\n-                     p: parser) -> spanned<[T]> {\n-    let lo = p.span.lo;\n-    expect(p, bra);\n-    let result = parse_seq_to_before_end::<T>(ket, sep, f, p);\n-    let hi = p.span.hi;\n-    p.bump();\n-    ret spanned(lo, hi, result);\n-}\n-\n fn have_dollar(p: parser) -> option<ast::mac_> {\n     alt p.token {\n       token::DOLLAR_NUM(num) {"}, {"sha": "2e560eb01c19435e2149784e18f75a7ba4d13bbc", "filename": "src/librustsyntax/rustsyntax.rc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bcbcbad7746cdab8465d2df1d9296cd74e30082f/src%2Flibrustsyntax%2Frustsyntax.rc", "raw_url": "https://github.com/rust-lang/rust/raw/bcbcbad7746cdab8465d2df1d9296cd74e30082f/src%2Flibrustsyntax%2Frustsyntax.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Frustsyntax.rc?ref=bcbcbad7746cdab8465d2df1d9296cd74e30082f", "patch": "@@ -37,6 +37,9 @@ mod parse {\n     mod comments;\n     mod attr;\n \n+    #[doc = \"Common routines shared by parser mods\"]\n+    mod common;\n+\n     #[doc = \"Functions dealing with operator precedence\"]\n     mod prec;\n "}]}