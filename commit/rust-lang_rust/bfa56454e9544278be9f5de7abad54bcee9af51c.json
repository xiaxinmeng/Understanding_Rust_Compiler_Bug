{"sha": "bfa56454e9544278be9f5de7abad54bcee9af51c", "node_id": "C_kwDOAAsO6NoAKGJmYTU2NDU0ZTk1NDQyNzhiZTlmNWRlN2FiYWQ1NGJjZWU5YWY1MWM", "commit": {"author": {"name": "Andy Wang", "email": "cbeuw.andy@gmail.com", "date": "2022-05-25T20:10:00Z"}, "committer": {"name": "Andy Wang", "email": "cbeuw.andy@gmail.com", "date": "2022-06-06T18:15:58Z"}, "message": "Split extra_cpp tests into sound and unsafe", "tree": {"sha": "c34757b350f0114e2a9cba132d20769351294ca1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c34757b350f0114e2a9cba132d20769351294ca1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bfa56454e9544278be9f5de7abad54bcee9af51c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE7dcbcBMl24/h63ldGBtJ+fOPM3QFAmKeRF4ACgkQGBtJ+fOP\nM3SxOwv+Jobmo5OsblOTfEhY/E5wgBbsqXC/tGJCXQC020RKhkJQf0ADIZuXJ02u\nCV/2wZHCFhFfP2pS3pXfEptKpwrYD65BL8Efnt44NNPIbr8RdmNGzQNEev1E4W9m\n6JoKWu1fdCFICKkLKUE/pB7ybswuw+fGUHAaTq0JiKtjRhfJus5KN3ms7Q/2Mdne\ntZ2YdlMNRVQWnB77rtUrzkvZ44EXJinc3dcp6pUzCUoO2fLE7C2BpBnyIGLIRvhR\npc3Teei+2Y3FUT9zNEb56AFuZ4lHPEv7bQdlKBp4w9NBOCRVXPefefMdh19o7mDg\nvb1Az+Hwvlif87NxiC9s5tS+mngtRfobwyerPdFD/CK02TuKRcIP92NxmHh+MXLz\nAbWFH+PPiCZw0No1Jf0jYNKow5w66D6FEEuiyGkcaI7Rcm/iD1PFQ+yTCdGv/d7k\nTIL+gGc2lExgFRpabSvYoWTJ10BDIXT2uipJxLB9xvRboz5MATSOpLPL8n0DLb/D\n6SxdtYdh\n=xBqu\n-----END PGP SIGNATURE-----", "payload": "tree c34757b350f0114e2a9cba132d20769351294ca1\nparent 613d60db0bc0bfac9c3ad57245fc09e08795a550\nauthor Andy Wang <cbeuw.andy@gmail.com> 1653509400 +0100\ncommitter Andy Wang <cbeuw.andy@gmail.com> 1654539358 +0100\n\nSplit extra_cpp tests into sound and unsafe\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bfa56454e9544278be9f5de7abad54bcee9af51c", "html_url": "https://github.com/rust-lang/rust/commit/bfa56454e9544278be9f5de7abad54bcee9af51c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bfa56454e9544278be9f5de7abad54bcee9af51c/comments", "author": {"login": "cbeuw", "id": 7034308, "node_id": "MDQ6VXNlcjcwMzQzMDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7034308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cbeuw", "html_url": "https://github.com/cbeuw", "followers_url": "https://api.github.com/users/cbeuw/followers", "following_url": "https://api.github.com/users/cbeuw/following{/other_user}", "gists_url": "https://api.github.com/users/cbeuw/gists{/gist_id}", "starred_url": "https://api.github.com/users/cbeuw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cbeuw/subscriptions", "organizations_url": "https://api.github.com/users/cbeuw/orgs", "repos_url": "https://api.github.com/users/cbeuw/repos", "events_url": "https://api.github.com/users/cbeuw/events{/privacy}", "received_events_url": "https://api.github.com/users/cbeuw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cbeuw", "id": 7034308, "node_id": "MDQ6VXNlcjcwMzQzMDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7034308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cbeuw", "html_url": "https://github.com/cbeuw", "followers_url": "https://api.github.com/users/cbeuw/followers", "following_url": "https://api.github.com/users/cbeuw/following{/other_user}", "gists_url": "https://api.github.com/users/cbeuw/gists{/gist_id}", "starred_url": "https://api.github.com/users/cbeuw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cbeuw/subscriptions", "organizations_url": "https://api.github.com/users/cbeuw/orgs", "repos_url": "https://api.github.com/users/cbeuw/repos", "events_url": "https://api.github.com/users/cbeuw/events{/privacy}", "received_events_url": "https://api.github.com/users/cbeuw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "613d60db0bc0bfac9c3ad57245fc09e08795a550", "url": "https://api.github.com/repos/rust-lang/rust/commits/613d60db0bc0bfac9c3ad57245fc09e08795a550", "html_url": "https://github.com/rust-lang/rust/commit/613d60db0bc0bfac9c3ad57245fc09e08795a550"}], "stats": {"total": 183, "additions": 102, "deletions": 81}, "files": [{"sha": "942d71a52ff28c9899018f4ba7196455c39cfaac", "filename": "src/concurrency/weak_memory.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bfa56454e9544278be9f5de7abad54bcee9af51c/src%2Fconcurrency%2Fweak_memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfa56454e9544278be9f5de7abad54bcee9af51c/src%2Fconcurrency%2Fweak_memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency%2Fweak_memory.rs?ref=bfa56454e9544278be9f5de7abad54bcee9af51c", "patch": "@@ -36,6 +36,7 @@\n //! In Rust, these operations can only be done through a `&mut AtomicFoo` reference or one derived from it, therefore these operations\n //! can only happen after all previous accesses on the same locations. This implementation is adapted to allow these operations.\n //! A mixed size/atomicity read that races with writes, or a write that races with reads or writes will still cause UBs to be thrown.\n+//! You can refer to test cases in weak_memory/extra_cpp.rs and weak_memory/extra_cpp_unsafe.rs for examples of these operations.\n \n // Our and the author's own implementation (tsan11) of the paper have some deviations from the provided operational semantics in \u00a75.3:\n // 1. In the operational semantics, store elements keep a copy of the atomic object's vector clock (AtomicCellClocks::sync_vector in miri),"}, {"sha": "3edac581c353ce0c11e8cc0168c2690c24e4bbd1", "filename": "tests/run-pass/weak_memory/extra_cpp.rs", "status": "modified", "additions": 2, "deletions": 81, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/bfa56454e9544278be9f5de7abad54bcee9af51c/tests%2Frun-pass%2Fweak_memory%2Fextra_cpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfa56454e9544278be9f5de7abad54bcee9af51c/tests%2Frun-pass%2Fweak_memory%2Fextra_cpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fweak_memory%2Fextra_cpp.rs?ref=bfa56454e9544278be9f5de7abad54bcee9af51c", "patch": "@@ -15,19 +15,10 @@ fn static_atomic_mut(val: u32) -> &'static mut AtomicU32 {\n     ret\n }\n \n-fn static_atomic(val: u32) -> &'static AtomicU32 {\n-    let ret = Box::leak(Box::new(AtomicU32::new(val)));\n-    ret\n-}\n-\n fn split_u32(dword: &mut u32) -> &mut [u16; 2] {\n     unsafe { std::mem::transmute::<&mut u32, &mut [u16; 2]>(dword) }\n }\n \n-fn split_u32_ptr(dword: *const u32) -> *const [u16; 2] {\n-    unsafe { std::mem::transmute::<*const u32, *const [u16; 2]>(dword) }\n-}\n-\n fn mem_replace() {\n     let mut x = AtomicU32::new(0);\n \n@@ -71,6 +62,8 @@ fn from_mut_split() {\n         x_atomic.store(u32::from_be(0xabbafafa), Relaxed);\n     }\n \n+    // Split the `AtomicU32` into two `AtomicU16`.\n+    // Crucially, there is no non-atomic access to `x`! All accesses are atomic, but of different size.\n     let (x_hi, x_lo) = split_u32(&mut x).split_at_mut(1);\n \n     let x_hi_atomic = AtomicU16::from_mut(&mut x_hi[0]);\n@@ -80,81 +73,9 @@ fn from_mut_split() {\n     assert_eq!(x_lo_atomic.load(Relaxed), u16::from_be(0xfafa));\n }\n \n-// Although not possible to do in safe Rust,\n-// we allow non-atomic and atomic reads to race\n-// as this should be sound\n-fn racing_mixed_atomicity_read() {\n-    let x = static_atomic(0);\n-    x.store(42, Relaxed);\n-\n-    let j1 = spawn(move || x.load(Relaxed));\n-\n-    let j2 = spawn(move || {\n-        let x_ptr = x as *const AtomicU32 as *const u32;\n-        unsafe { std::intrinsics::atomic_load_relaxed(x_ptr) }\n-    });\n-\n-    let r1 = j1.join().unwrap();\n-    let r2 = j2.join().unwrap();\n-\n-    assert_eq!(r1, 42);\n-    assert_eq!(r2, 42);\n-}\n-\n-fn racing_mixed_size_read() {\n-    let x = static_atomic(0);\n-\n-    let j1 = spawn(move || {\n-        x.load(Relaxed);\n-    });\n-\n-    let j2 = spawn(move || {\n-        let x_ptr = x as *const AtomicU32 as *const u32;\n-        let x_split = split_u32_ptr(x_ptr);\n-        unsafe {\n-            let hi = &(*x_split)[0] as *const u16;\n-            std::intrinsics::atomic_load_relaxed(hi); //~ ERROR: imperfectly overlapping\n-        }\n-    });\n-\n-    j1.join().unwrap();\n-    j2.join().unwrap();\n-}\n-\n-fn racing_mixed_atomicity_and_size_read() {\n-    let x = static_atomic(u32::from_be(0xabbafafa));\n-\n-    let j1 = spawn(move || {\n-        x.load(Relaxed);\n-    });\n-\n-    let j2 = spawn(move || {\n-        let x_ptr = x as *const AtomicU32 as *const u32;\n-        unsafe { *x_ptr };\n-    });\n-\n-    let j3 = spawn(move || {\n-        let x_ptr = x as *const AtomicU32 as *const u32;\n-        let x_split = split_u32_ptr(x_ptr);\n-        unsafe {\n-            let hi = &(*x_split)[0] as *const u16;\n-            std::intrinsics::atomic_load_relaxed(hi)\n-        }\n-    });\n-\n-    j1.join().unwrap();\n-    j2.join().unwrap();\n-    let r3 = j3.join().unwrap();\n-\n-    assert_eq!(r3, u16::from_be(0xabba));\n-}\n-\n pub fn main() {\n     get_mut_write();\n     from_mut_split();\n     assign_to_mut();\n     mem_replace();\n-    racing_mixed_atomicity_read();\n-    racing_mixed_size_read();\n-    racing_mixed_atomicity_and_size_read();\n }"}, {"sha": "95cc97d4dbb27e80e66ce6e6e4cc3f46df0438f0", "filename": "tests/run-pass/weak_memory/extra_cpp_unsafe.rs", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/bfa56454e9544278be9f5de7abad54bcee9af51c/tests%2Frun-pass%2Fweak_memory%2Fextra_cpp_unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfa56454e9544278be9f5de7abad54bcee9af51c/tests%2Frun-pass%2Fweak_memory%2Fextra_cpp_unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fweak_memory%2Fextra_cpp_unsafe.rs?ref=bfa56454e9544278be9f5de7abad54bcee9af51c", "patch": "@@ -0,0 +1,97 @@\n+// compile-flags: -Zmiri-ignore-leaks\n+\n+// Tests operations not perfomable through C++'s atomic API\n+// but doable in unsafe Rust which we think *should* be fine.\n+// Nonetheless they may be determined as inconsistent with the\n+// memory model in the future.\n+\n+#![feature(atomic_from_mut)]\n+#![feature(core_intrinsics)]\n+\n+use std::sync::atomic::AtomicU32;\n+use std::sync::atomic::Ordering::*;\n+use std::thread::spawn;\n+\n+fn static_atomic(val: u32) -> &'static AtomicU32 {\n+    let ret = Box::leak(Box::new(AtomicU32::new(val)));\n+    ret\n+}\n+\n+fn split_u32_ptr(dword: *const u32) -> *const [u16; 2] {\n+    unsafe { std::mem::transmute::<*const u32, *const [u16; 2]>(dword) }\n+}\n+\n+// We allow non-atomic and atomic reads to race\n+fn racing_mixed_atomicity_read() {\n+    let x = static_atomic(0);\n+    x.store(42, Relaxed);\n+\n+    let j1 = spawn(move || x.load(Relaxed));\n+\n+    let j2 = spawn(move || {\n+        let x_ptr = x as *const AtomicU32 as *const u32;\n+        unsafe { std::intrinsics::atomic_load_relaxed(x_ptr) }\n+    });\n+\n+    let r1 = j1.join().unwrap();\n+    let r2 = j2.join().unwrap();\n+\n+    assert_eq!(r1, 42);\n+    assert_eq!(r2, 42);\n+}\n+\n+// We allow mixed-size atomic reads to race\n+fn racing_mixed_size_read() {\n+    let x = static_atomic(0);\n+\n+    let j1 = spawn(move || {\n+        x.load(Relaxed);\n+    });\n+\n+    let j2 = spawn(move || {\n+        let x_ptr = x as *const AtomicU32 as *const u32;\n+        let x_split = split_u32_ptr(x_ptr);\n+        unsafe {\n+            let hi = &(*x_split)[0] as *const u16;\n+            std::intrinsics::atomic_load_relaxed(hi);\n+        }\n+    });\n+\n+    j1.join().unwrap();\n+    j2.join().unwrap();\n+}\n+\n+// And the combination of both of above\n+fn racing_mixed_atomicity_and_size_read() {\n+    let x = static_atomic(u32::from_be(0xabbafafa));\n+\n+    let j1 = spawn(move || {\n+        x.load(Relaxed);\n+    });\n+\n+    let j2 = spawn(move || {\n+        let x_ptr = x as *const AtomicU32 as *const u32;\n+        unsafe { *x_ptr };\n+    });\n+\n+    let j3 = spawn(move || {\n+        let x_ptr = x as *const AtomicU32 as *const u32;\n+        let x_split = split_u32_ptr(x_ptr);\n+        unsafe {\n+            let hi = &(*x_split)[0] as *const u16;\n+            std::intrinsics::atomic_load_relaxed(hi)\n+        }\n+    });\n+\n+    j1.join().unwrap();\n+    j2.join().unwrap();\n+    let r3 = j3.join().unwrap();\n+\n+    assert_eq!(r3, u16::from_be(0xabba));\n+}\n+\n+pub fn main() {\n+    racing_mixed_atomicity_read();\n+    racing_mixed_size_read();\n+    racing_mixed_atomicity_and_size_read();\n+}"}, {"sha": "1d0ce4b3853dacd1621931ea3bf13724cf6fee68", "filename": "tests/run-pass/weak_memory/extra_cpp_unsafe.stderr", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfa56454e9544278be9f5de7abad54bcee9af51c/tests%2Frun-pass%2Fweak_memory%2Fextra_cpp_unsafe.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfa56454e9544278be9f5de7abad54bcee9af51c/tests%2Frun-pass%2Fweak_memory%2Fextra_cpp_unsafe.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fweak_memory%2Fextra_cpp_unsafe.stderr?ref=bfa56454e9544278be9f5de7abad54bcee9af51c", "patch": "@@ -0,0 +1,2 @@\n+warning: thread support is experimental: weak memory effects are not fully compatible with the Rust atomics memory model.\n+"}]}