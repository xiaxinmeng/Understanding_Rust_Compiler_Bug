{"sha": "23e21bdd25026e2839ebe946c2a937c1904887d2", "node_id": "C_kwDOAAsO6NoAKDIzZTIxYmRkMjUwMjZlMjgzOWViZTk0NmMyYTkzN2MxOTA0ODg3ZDI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-15T17:11:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-15T17:11:07Z"}, "message": "Auto merge of #99015 - lcnr:fn-ctxt-no-more, r=compiler-errors\n\nstop using `FnCtxt` outside of hir typeck\n\nthe requirements between **hir typeck**\u2122, and **not hir typeck**\u2122 are different enough to warrant a full split. with this PR `FnCtxt` is now only used for hir typeck (and for one clippy lint which seems to be emulating hir typeck).\n\nOnce this PR has landed I intend to move `FnCtxt` into a new crate. This should also allow some further general improvements here.\n\nr? rust-lang/types", "tree": {"sha": "b5ca9e8f856788d9a0f3c0e9136a7d2a586b6efe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b5ca9e8f856788d9a0f3c0e9136a7d2a586b6efe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/23e21bdd25026e2839ebe946c2a937c1904887d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/23e21bdd25026e2839ebe946c2a937c1904887d2", "html_url": "https://github.com/rust-lang/rust/commit/23e21bdd25026e2839ebe946c2a937c1904887d2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/23e21bdd25026e2839ebe946c2a937c1904887d2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0fe5390a885eb47f506bf481cd9ea2b449705d79", "url": "https://api.github.com/repos/rust-lang/rust/commits/0fe5390a885eb47f506bf481cd9ea2b449705d79", "html_url": "https://github.com/rust-lang/rust/commit/0fe5390a885eb47f506bf481cd9ea2b449705d79"}, {"sha": "16b2acc7c0d5188992065f369285a0fcd273dbfe", "url": "https://api.github.com/repos/rust-lang/rust/commits/16b2acc7c0d5188992065f369285a0fcd273dbfe", "html_url": "https://github.com/rust-lang/rust/commit/16b2acc7c0d5188992065f369285a0fcd273dbfe"}], "stats": {"total": 1095, "additions": 576, "deletions": 519}, "files": [{"sha": "6508c0da75f94cdf6c2562b0d2a0a998428b93dc", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/23e21bdd25026e2839ebe946c2a937c1904887d2/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23e21bdd25026e2839ebe946c2a937c1904887d2/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=23e21bdd25026e2839ebe946c2a937c1904887d2", "patch": "@@ -181,11 +181,11 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         let generic_ty = type_test.generic_kind.to_ty(self.infcx.tcx);\n                         let origin = RelateParamBound(type_test_span, generic_ty, None);\n                         self.buffer_error(self.infcx.construct_generic_bound_failure(\n+                            self.body.source.def_id().expect_local(),\n                             type_test_span,\n                             Some(origin),\n                             type_test.generic_kind,\n                             lower_bound_region,\n-                            self.body.source.def_id().as_local(),\n                         ));\n                     } else {\n                         // FIXME. We should handle this case better. It"}, {"sha": "d7505717bf3d2b57ce48fff2223a1b0f30fb7ba9", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 28, "deletions": 56, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/23e21bdd25026e2839ebe946c2a937c1904887d2/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23e21bdd25026e2839ebe946c2a937c1904887d2/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=23e21bdd25026e2839ebe946c2a937c1904887d2", "patch": "@@ -63,7 +63,7 @@ use rustc_errors::{Applicability, DiagnosticBuilder, DiagnosticStyledString, Mul\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::lang_items::LangItem;\n-use rustc_hir::{Item, ItemKind, Node};\n+use rustc_hir::Node;\n use rustc_middle::dep_graph::DepContext;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{\n@@ -348,7 +348,11 @@ pub fn same_type_modulo_infer<'tcx>(a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n }\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n-    pub fn report_region_errors(&self, errors: &[RegionResolutionError<'tcx>]) {\n+    pub fn report_region_errors(\n+        &self,\n+        generic_param_scope: LocalDefId,\n+        errors: &[RegionResolutionError<'tcx>],\n+    ) {\n         debug!(\"report_region_errors(): {} errors to start\", errors.len());\n \n         // try to pre-process the errors, which will group some of them\n@@ -379,6 +383,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n                     RegionResolutionError::GenericBoundFailure(origin, param_ty, sub) => {\n                         self.report_generic_bound_failure(\n+                            generic_param_scope,\n                             origin.span(),\n                             Some(origin),\n                             param_ty,\n@@ -2269,56 +2274,30 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     pub fn report_generic_bound_failure(\n         &self,\n+        generic_param_scope: LocalDefId,\n         span: Span,\n         origin: Option<SubregionOrigin<'tcx>>,\n         bound_kind: GenericKind<'tcx>,\n         sub: Region<'tcx>,\n     ) {\n-        let owner =\n-            self.in_progress_typeck_results.map(|typeck_results| typeck_results.borrow().hir_owner);\n-        self.construct_generic_bound_failure(span, origin, bound_kind, sub, owner).emit();\n+        self.construct_generic_bound_failure(generic_param_scope, span, origin, bound_kind, sub)\n+            .emit();\n     }\n \n     pub fn construct_generic_bound_failure(\n         &self,\n+        generic_param_scope: LocalDefId,\n         span: Span,\n         origin: Option<SubregionOrigin<'tcx>>,\n         bound_kind: GenericKind<'tcx>,\n         sub: Region<'tcx>,\n-        owner: Option<LocalDefId>,\n     ) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n-        let hir = self.tcx.hir();\n         // Attempt to obtain the span of the parameter so we can\n         // suggest adding an explicit lifetime bound to it.\n-        let generics = owner.map(|owner| {\n-            let hir_id = hir.local_def_id_to_hir_id(owner);\n-            let parent_id = hir.get_parent_item(hir_id);\n-            (\n-                // Parent item could be a `mod`, so we check the HIR before calling:\n-                if let Some(Node::Item(Item {\n-                    kind: ItemKind::Trait(..) | ItemKind::Impl { .. },\n-                    ..\n-                })) = hir.find_by_def_id(parent_id)\n-                {\n-                    Some(self.tcx.generics_of(parent_id))\n-                } else {\n-                    None\n-                },\n-                self.tcx.generics_of(owner.to_def_id()),\n-                hir.span(hir_id),\n-            )\n-        });\n-\n-        let span = match generics {\n-            // This is to get around the trait identity obligation, that has a `DUMMY_SP` as signal\n-            // for other diagnostics, so we need to recover it here.\n-            Some((_, _, node)) if span.is_dummy() => node,\n-            _ => span,\n-        };\n-\n+        let generics = self.tcx.generics_of(generic_param_scope);\n         // type_param_span is (span, has_bounds)\n-        let type_param_span = match (generics, bound_kind) {\n-            (Some((_, ref generics, _)), GenericKind::Param(ref param)) => {\n+        let type_param_span = match bound_kind {\n+            GenericKind::Param(ref param) => {\n                 // Account for the case where `param` corresponds to `Self`,\n                 // which doesn't have the expected type argument.\n                 if !(generics.has_self && param.index == 0) {\n@@ -2346,30 +2325,23 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             }\n             _ => None,\n         };\n-        let new_lt = generics\n-            .as_ref()\n-            .and_then(|(parent_g, g, _)| {\n-                let mut possible = (b'a'..=b'z').map(|c| format!(\"'{}\", c as char));\n-                let mut lts_names = g\n-                    .params\n-                    .iter()\n+\n+        let new_lt = {\n+            let mut possible = (b'a'..=b'z').map(|c| format!(\"'{}\", c as char));\n+            let lts_names =\n+                iter::successors(Some(generics), |g| g.parent.map(|p| self.tcx.generics_of(p)))\n+                    .flat_map(|g| &g.params)\n                     .filter(|p| matches!(p.kind, ty::GenericParamDefKind::Lifetime))\n                     .map(|p| p.name.as_str())\n                     .collect::<Vec<_>>();\n-                if let Some(g) = parent_g {\n-                    lts_names.extend(\n-                        g.params\n-                            .iter()\n-                            .filter(|p| matches!(p.kind, ty::GenericParamDefKind::Lifetime))\n-                            .map(|p| p.name.as_str()),\n-                    );\n-                }\n-                possible.find(|candidate| !lts_names.contains(&&candidate[..]))\n-            })\n-            .unwrap_or(\"'lt\".to_string());\n+            possible\n+                .find(|candidate| !lts_names.contains(&&candidate[..]))\n+                .unwrap_or(\"'lt\".to_string())\n+        };\n+\n         let add_lt_sugg = generics\n-            .as_ref()\n-            .and_then(|(_, g, _)| g.params.first())\n+            .params\n+            .first()\n             .and_then(|param| param.def_id.as_local())\n             .map(|def_id| (self.tcx.def_span(def_id).shrink_to_lo(), format!(\"{}, \", new_lt)));\n \n@@ -2571,7 +2543,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 );\n                 if let Some(infer::RelateParamBound(_, t, _)) = origin {\n                     let return_impl_trait =\n-                        owner.and_then(|owner| self.tcx.return_type_impl_trait(owner)).is_some();\n+                        self.tcx.return_type_impl_trait(generic_param_scope).is_some();\n                     let t = self.resolve_vars_if_possible(t);\n                     match t.kind() {\n                         // We've got:"}, {"sha": "c5a342c1ba2ca6abc0cb743858a4d857b3bc8a60", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/23e21bdd25026e2839ebe946c2a937c1904887d2/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23e21bdd25026e2839ebe946c2a937c1904887d2/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=23e21bdd25026e2839ebe946c2a937c1904887d2", "patch": "@@ -1301,7 +1301,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// result. After this, no more unification operations should be\n     /// done -- or the compiler will panic -- but it is legal to use\n     /// `resolve_vars_if_possible` as well as `fully_resolve`.\n-    pub fn resolve_regions_and_report_errors(&self, outlives_env: &OutlivesEnvironment<'tcx>) {\n+    pub fn resolve_regions_and_report_errors(\n+        &self,\n+        generic_param_scope: LocalDefId,\n+        outlives_env: &OutlivesEnvironment<'tcx>,\n+    ) {\n         let errors = self.resolve_regions(outlives_env);\n \n         if !self.is_tainted_by_errors() {\n@@ -1310,7 +1314,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             // this infcx was in use.  This is totally hokey but\n             // otherwise we have a hard time separating legit region\n             // errors from silly ones.\n-            self.report_region_errors(&errors);\n+            self.report_region_errors(generic_param_scope, &errors);\n         }\n     }\n "}, {"sha": "a57971bfb697dee6505787c334002c750682b6f9", "filename": "compiler/rustc_infer/src/infer/outlives/obligations.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/23e21bdd25026e2839ebe946c2a937c1904887d2/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23e21bdd25026e2839ebe946c2a937c1904887d2/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs?ref=23e21bdd25026e2839ebe946c2a937c1904887d2", "patch": "@@ -68,6 +68,7 @@ use crate::infer::{\n };\n use crate::traits::{ObligationCause, ObligationCauseCode};\n use rustc_data_structures::undo_log::UndoLogs;\n+use rustc_hir::def_id::LocalDefId;\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{self, Region, Ty, TyCtxt, TypeVisitable};\n use smallvec::smallvec;\n@@ -163,14 +164,15 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n \n     pub fn check_region_obligations_and_report_errors(\n         &self,\n+        generic_param_scope: LocalDefId,\n         outlives_env: &OutlivesEnvironment<'tcx>,\n     ) {\n         self.process_registered_region_obligations(\n             outlives_env.region_bound_pairs(),\n             outlives_env.param_env,\n         );\n \n-        self.resolve_regions_and_report_errors(outlives_env)\n+        self.resolve_regions_and_report_errors(generic_param_scope, outlives_env)\n     }\n }\n "}, {"sha": "0f7dc6a1257e5eee318905021a75fa539af7c8c7", "filename": "compiler/rustc_trait_selection/src/traits/engine.rs", "status": "modified", "additions": 105, "deletions": 1, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/23e21bdd25026e2839ebe946c2a937c1904887d2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23e21bdd25026e2839ebe946c2a937c1904887d2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs?ref=23e21bdd25026e2839ebe946c2a937c1904887d2", "patch": "@@ -1,10 +1,22 @@\n-use rustc_middle::ty::TyCtxt;\n+use std::cell::RefCell;\n \n use super::TraitEngine;\n use super::{ChalkFulfillmentContext, FulfillmentContext};\n+use crate::infer::InferCtxtExt;\n+use rustc_hir::def_id::DefId;\n+use rustc_infer::infer::{InferCtxt, InferOk};\n+use rustc_infer::traits::{\n+    FulfillmentError, Obligation, ObligationCause, PredicateObligation, TraitEngineExt as _,\n+};\n+use rustc_middle::ty::error::TypeError;\n+use rustc_middle::ty::ToPredicate;\n+use rustc_middle::ty::TypeFoldable;\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n \n pub trait TraitEngineExt<'tcx> {\n     fn new(tcx: TyCtxt<'tcx>) -> Box<Self>;\n+\n+    fn new_ignoring_regions(tcx: TyCtxt<'tcx>) -> Box<Self>;\n }\n \n impl<'tcx> TraitEngineExt<'tcx> for dyn TraitEngine<'tcx> {\n@@ -15,4 +27,96 @@ impl<'tcx> TraitEngineExt<'tcx> for dyn TraitEngine<'tcx> {\n             Box::new(FulfillmentContext::new())\n         }\n     }\n+\n+    fn new_ignoring_regions(tcx: TyCtxt<'tcx>) -> Box<Self> {\n+        if tcx.sess.opts.unstable_opts.chalk {\n+            Box::new(ChalkFulfillmentContext::new())\n+        } else {\n+            Box::new(FulfillmentContext::new_ignoring_regions())\n+        }\n+    }\n+}\n+\n+/// Used if you want to have pleasant experience when dealing\n+/// with obligations outside of hir or mir typeck.\n+pub struct ObligationCtxt<'a, 'tcx> {\n+    pub infcx: &'a InferCtxt<'a, 'tcx>,\n+    engine: RefCell<Box<dyn TraitEngine<'tcx>>>,\n+}\n+\n+impl<'a, 'tcx> ObligationCtxt<'a, 'tcx> {\n+    pub fn new(infcx: &'a InferCtxt<'a, 'tcx>) -> Self {\n+        Self { infcx, engine: RefCell::new(<dyn TraitEngine<'_>>::new(infcx.tcx)) }\n+    }\n+\n+    pub fn register_obligation(&self, obligation: PredicateObligation<'tcx>) {\n+        self.engine.borrow_mut().register_predicate_obligation(self.infcx, obligation);\n+    }\n+\n+    pub fn register_obligations(\n+        &self,\n+        obligations: impl IntoIterator<Item = PredicateObligation<'tcx>>,\n+    ) {\n+        // Can't use `register_predicate_obligations` because the iterator\n+        // may also use this `ObligationCtxt`.\n+        for obligation in obligations {\n+            self.engine.borrow_mut().register_predicate_obligation(self.infcx, obligation)\n+        }\n+    }\n+\n+    pub fn register_infer_ok_obligations<T>(&self, infer_ok: InferOk<'tcx, T>) -> T {\n+        let InferOk { value, obligations } = infer_ok;\n+        self.engine.borrow_mut().register_predicate_obligations(self.infcx, obligations);\n+        value\n+    }\n+\n+    /// Requires that `ty` must implement the trait with `def_id` in\n+    /// the given environment. This trait must not have any type\n+    /// parameters (except for `Self`).\n+    pub fn register_bound(\n+        &self,\n+        cause: ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        ty: Ty<'tcx>,\n+        def_id: DefId,\n+    ) {\n+        let tcx = self.infcx.tcx;\n+        let trait_ref = ty::TraitRef { def_id, substs: tcx.mk_substs_trait(ty, &[]) };\n+        self.register_obligation(Obligation {\n+            cause,\n+            recursion_depth: 0,\n+            param_env,\n+            predicate: ty::Binder::dummy(trait_ref).without_const().to_predicate(tcx),\n+        });\n+    }\n+\n+    pub fn normalize<T: TypeFoldable<'tcx>>(\n+        &self,\n+        cause: ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        value: T,\n+    ) -> T {\n+        let infer_ok = self.infcx.partially_normalize_associated_types_in(cause, param_env, value);\n+        self.register_infer_ok_obligations(infer_ok)\n+    }\n+\n+    pub fn equate_types(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        expected: Ty<'tcx>,\n+        actual: Ty<'tcx>,\n+    ) -> Result<(), TypeError<'tcx>> {\n+        match self.infcx.at(cause, param_env).eq(expected, actual) {\n+            Ok(InferOk { obligations, value: () }) => {\n+                self.register_obligations(obligations);\n+                Ok(())\n+            }\n+            Err(e) => Err(e),\n+        }\n+    }\n+\n+    pub fn select_all_or_error(&self) -> Vec<FulfillmentError<'tcx>> {\n+        self.engine.borrow_mut().select_all_or_error(self.infcx)\n+    }\n }"}, {"sha": "a14bf72242bed27ad40428f964cb77e8ef397fe5", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/23e21bdd25026e2839ebe946c2a937c1904887d2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23e21bdd25026e2839ebe946c2a937c1904887d2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=23e21bdd25026e2839ebe946c2a937c1904887d2", "patch": "@@ -47,7 +47,7 @@ pub use self::SelectionError::*;\n \n pub use self::coherence::{add_placeholder_note, orphan_check, overlapping_impls};\n pub use self::coherence::{OrphanCheckErr, OverlapResult};\n-pub use self::engine::TraitEngineExt;\n+pub use self::engine::{ObligationCtxt, TraitEngineExt};\n pub use self::fulfill::{FulfillmentContext, PendingPredicateObligation};\n pub use self::object_safety::astconv_object_safety_violations;\n pub use self::object_safety::is_vtable_safe_method;\n@@ -237,29 +237,37 @@ fn do_normalize_predicates<'tcx>(\n         // cares about declarations like `'a: 'b`.\n         let outlives_env = OutlivesEnvironment::new(elaborated_env);\n \n-        infcx.resolve_regions_and_report_errors(&outlives_env);\n+        // FIXME: It's very weird that we ignore region obligations but apparently\n+        // still need to use `resolve_regions` as we need the resolved regions in\n+        // the normalized predicates.\n+        let errors = infcx.resolve_regions(&outlives_env);\n+        if !errors.is_empty() {\n+            tcx.sess.delay_span_bug(\n+                span,\n+                format!(\n+                    \"failed region resolution while normalizing {elaborated_env:?}: {errors:?}\"\n+                ),\n+            );\n+        }\n \n-        let predicates = match infcx.fully_resolve(predicates) {\n-            Ok(predicates) => predicates,\n+        match infcx.fully_resolve(predicates) {\n+            Ok(predicates) => Ok(predicates),\n             Err(fixup_err) => {\n                 // If we encounter a fixup error, it means that some type\n                 // variable wound up unconstrained. I actually don't know\n                 // if this can happen, and I certainly don't expect it to\n                 // happen often, but if it did happen it probably\n                 // represents a legitimate failure due to some kind of\n-                // unconstrained variable, and it seems better not to ICE,\n-                // all things considered.\n-                let reported = tcx.sess.span_err(span, &fixup_err.to_string());\n-                return Err(reported);\n+                // unconstrained variable.\n+                //\n+                // @lcnr: Let's still ICE here for now. I want a test case\n+                // for that.\n+                span_bug!(\n+                    span,\n+                    \"inference variables in normalized parameter environment: {}\",\n+                    fixup_err\n+                );\n             }\n-        };\n-        if predicates.needs_infer() {\n-            let reported = tcx\n-                .sess\n-                .delay_span_bug(span, \"encountered inference variables after `fully_resolve`\");\n-            Err(reported)\n-        } else {\n-            Ok(predicates)\n         }\n     })\n }"}, {"sha": "449d7a7b47b1fcd82042d7156c0cb876c0ab25a2", "filename": "compiler/rustc_trait_selection/src/traits/query/normalize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/23e21bdd25026e2839ebe946c2a937c1904887d2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23e21bdd25026e2839ebe946c2a937c1904887d2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs?ref=23e21bdd25026e2839ebe946c2a937c1904887d2", "patch": "@@ -254,7 +254,7 @@ impl<'cx, 'tcx> FallibleTypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n                 let result = tcx.normalize_projection_ty(c_data)?;\n                 // We don't expect ambiguity.\n                 if result.is_ambiguous() {\n-                    return Err(NoSolution);\n+                    bug!(\"unexpected ambiguity: {:?} {:?}\", c_data, result);\n                 }\n                 let InferOk { value: result, obligations } =\n                     self.infcx.instantiate_query_response_and_region_obligations(\n@@ -293,7 +293,7 @@ impl<'cx, 'tcx> FallibleTypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n                 let result = tcx.normalize_projection_ty(c_data)?;\n                 // We don't expect ambiguity.\n                 if result.is_ambiguous() {\n-                    return Err(NoSolution);\n+                    bug!(\"unexpected ambiguity: {:?} {:?}\", c_data, result);\n                 }\n                 let InferOk { value: result, obligations } =\n                     self.infcx.instantiate_query_response_and_region_obligations("}, {"sha": "69f3f03cfa97c5a2c98538f4b8ddc44fc1cd078d", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/23e21bdd25026e2839ebe946c2a937c1904887d2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23e21bdd25026e2839ebe946c2a937c1904887d2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=23e21bdd25026e2839ebe946c2a937c1904887d2", "patch": "@@ -1,10 +1,9 @@\n-use crate::check::wfcheck::for_item;\n+use crate::check::intrinsicck::InlineAsmCtxt;\n \n use super::coercion::CoerceMany;\n use super::compare_method::check_type_bounds;\n use super::compare_method::{compare_const_impl, compare_impl_method, compare_ty_impl};\n use super::*;\n-\n use rustc_attr as attr;\n use rustc_errors::{Applicability, ErrorGuaranteed, MultiSpan};\n use rustc_hir as hir;\n@@ -29,8 +28,8 @@ use rustc_session::lint::builtin::{UNINHABITED_STATIC, UNSUPPORTED_CALLING_CONVE\n use rustc_span::symbol::sym;\n use rustc_span::{self, Span};\n use rustc_target::spec::abi::Abi;\n-use rustc_trait_selection::traits;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n+use rustc_trait_selection::traits::{self, ObligationCtxt};\n use rustc_ty_utils::representability::{self, Representability};\n \n use std::iter;\n@@ -733,14 +732,13 @@ fn check_opaque_meets_bounds<'tcx>(\n     let param_env = tcx.param_env(defining_use_anchor);\n \n     tcx.infer_ctxt().with_opaque_type_inference(defining_use_anchor).enter(move |infcx| {\n-        let inh = Inherited::new(infcx, def_id);\n-        let infcx = &inh.infcx;\n+        let ocx = ObligationCtxt::new(&infcx);\n         let opaque_ty = tcx.mk_opaque(def_id.to_def_id(), substs);\n \n         let misc_cause = traits::ObligationCause::misc(span, hir_id);\n \n         match infcx.at(&misc_cause, param_env).eq(opaque_ty, hidden_type) {\n-            Ok(infer_ok) => inh.register_infer_ok_obligations(infer_ok),\n+            Ok(infer_ok) => ocx.register_infer_ok_obligations(infer_ok),\n             Err(ty_err) => {\n                 tcx.sess.delay_span_bug(\n                     span,\n@@ -754,11 +752,11 @@ fn check_opaque_meets_bounds<'tcx>(\n         // hidden type is well formed even without those bounds.\n         let predicate =\n             ty::Binder::dummy(ty::PredicateKind::WellFormed(hidden_type.into())).to_predicate(tcx);\n-        inh.register_predicate(Obligation::new(misc_cause, param_env, predicate));\n+        ocx.register_obligation(Obligation::new(misc_cause, param_env, predicate));\n \n         // Check that all obligations are satisfied by the implementation's\n         // version.\n-        let errors = inh.fulfillment_cx.borrow_mut().select_all_or_error(&infcx);\n+        let errors = ocx.select_all_or_error();\n         if !errors.is_empty() {\n             infcx.report_fulfillment_errors(&errors, None, false);\n         }\n@@ -769,7 +767,10 @@ fn check_opaque_meets_bounds<'tcx>(\n             // Can have different predicates to their defining use\n             hir::OpaqueTyOrigin::TyAlias => {\n                 let outlives_environment = OutlivesEnvironment::new(param_env);\n-                infcx.check_region_obligations_and_report_errors(&outlives_environment);\n+                infcx.check_region_obligations_and_report_errors(\n+                    defining_use_anchor,\n+                    &outlives_environment,\n+                );\n             }\n         }\n \n@@ -940,10 +941,7 @@ fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {\n         DefKind::GlobalAsm => {\n             let it = tcx.hir().item(id);\n             let hir::ItemKind::GlobalAsm(asm) = it.kind else { span_bug!(it.span, \"DefKind::GlobalAsm but got {:#?}\", it) };\n-            for_item(tcx, it).with_fcx(|fcx| {\n-                fcx.check_asm(asm, it.hir_id());\n-                Default::default()\n-            })\n+            InlineAsmCtxt::new_global_asm(tcx).check_asm(asm, id.hir_id());\n         }\n         _ => {}\n     }"}, {"sha": "1f921ca835890ded16273278cc8658859e9c0d9a", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 57, "deletions": 54, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/23e21bdd25026e2839ebe946c2a937c1904887d2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23e21bdd25026e2839ebe946c2a937c1904887d2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=23e21bdd25026e2839ebe946c2a937c1904887d2", "patch": "@@ -1,4 +1,6 @@\n+use super::potentially_plural_count;\n use crate::check::regionck::OutlivesEnvironmentExt;\n+use crate::check::wfcheck;\n use crate::errors::LifetimesOrBoundsMismatchOnTrait;\n use rustc_data_structures::stable_set::FxHashSet;\n use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticId, ErrorGuaranteed};\n@@ -7,7 +9,7 @@ use rustc_hir::def::{DefKind, Res};\n use rustc_hir::intravisit;\n use rustc_hir::{GenericParamKind, ImplItemKind, TraitItemKind};\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n-use rustc_infer::infer::{self, InferOk, TyCtxtInferExt};\n+use rustc_infer::infer::{self, TyCtxtInferExt};\n use rustc_infer::traits::util;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::subst::{InternalSubsts, Subst};\n@@ -16,11 +18,11 @@ use rustc_middle::ty::{self, DefIdTree};\n use rustc_middle::ty::{GenericParamDefKind, ToPredicate, TyCtxt};\n use rustc_span::Span;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt;\n-use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode, Reveal};\n+use rustc_trait_selection::traits::{\n+    self, ObligationCause, ObligationCauseCode, ObligationCtxt, Reveal,\n+};\n use std::iter;\n \n-use super::{potentially_plural_count, FnCtxt, Inherited};\n-\n /// Checks that a method from an impl conforms to the signature of\n /// the same method as declared in the trait.\n ///\n@@ -205,21 +207,19 @@ fn compare_predicate_entailment<'tcx>(\n     );\n     let param_env = traits::normalize_param_env_or_error(tcx, param_env, normalize_cause);\n \n-    tcx.infer_ctxt().enter(|infcx| {\n-        let inh = Inherited::new(infcx, impl_m.def_id.expect_local());\n-        let infcx = &inh.infcx;\n+    tcx.infer_ctxt().enter(|ref infcx| {\n+        let ocx = ObligationCtxt::new(infcx);\n \n         debug!(\"compare_impl_method: caller_bounds={:?}\", param_env.caller_bounds());\n \n         let mut selcx = traits::SelectionContext::new(&infcx);\n-\n         let impl_m_own_bounds = impl_m_predicates.instantiate_own(tcx, impl_to_placeholder_substs);\n         for (predicate, span) in iter::zip(impl_m_own_bounds.predicates, impl_m_own_bounds.spans) {\n             let normalize_cause = traits::ObligationCause::misc(span, impl_m_hir_id);\n             let traits::Normalized { value: predicate, obligations } =\n                 traits::normalize(&mut selcx, param_env, normalize_cause, predicate);\n \n-            inh.register_predicates(obligations);\n+            ocx.register_obligations(obligations);\n             let cause = ObligationCause::new(\n                 span,\n                 impl_m_hir_id,\n@@ -228,7 +228,7 @@ fn compare_predicate_entailment<'tcx>(\n                     trait_item_def_id: trait_m.def_id,\n                 },\n             );\n-            inh.register_predicate(traits::Obligation::new(cause, param_env, predicate));\n+            ocx.register_obligation(traits::Obligation::new(cause, param_env, predicate));\n         }\n \n         // We now need to check that the signature of the impl method is\n@@ -254,32 +254,31 @@ fn compare_predicate_entailment<'tcx>(\n             infer::HigherRankedType,\n             tcx.fn_sig(impl_m.def_id),\n         );\n-        let impl_sig =\n-            inh.normalize_associated_types_in(impl_m_span, impl_m_hir_id, param_env, impl_sig);\n+\n+        let norm_cause = ObligationCause::misc(impl_m_span, impl_m_hir_id);\n+        let impl_sig = ocx.normalize(norm_cause.clone(), param_env, impl_sig);\n         let impl_fty = tcx.mk_fn_ptr(ty::Binder::dummy(impl_sig));\n         debug!(\"compare_impl_method: impl_fty={:?}\", impl_fty);\n \n         let trait_sig = tcx.bound_fn_sig(trait_m.def_id).subst(tcx, trait_to_placeholder_substs);\n         let trait_sig = tcx.liberate_late_bound_regions(impl_m.def_id, trait_sig);\n-        let trait_sig =\n-            inh.normalize_associated_types_in(impl_m_span, impl_m_hir_id, param_env, trait_sig);\n+        let trait_sig = ocx.normalize(norm_cause, param_env, trait_sig);\n         // Add the resulting inputs and output as well-formed.\n         wf_tys.extend(trait_sig.inputs_and_output.iter());\n         let trait_fty = tcx.mk_fn_ptr(ty::Binder::dummy(trait_sig));\n \n         debug!(\"compare_impl_method: trait_fty={:?}\", trait_fty);\n \n-        let sub_result = infcx.at(&cause, param_env).sup(trait_fty, impl_fty).map(\n-            |InferOk { obligations, .. }| {\n-                // FIXME: We'd want to keep more accurate spans than \"the method signature\" when\n-                // processing the comparison between the trait and impl fn, but we sadly lose them\n-                // and point at the whole signature when a trait bound or specific input or output\n-                // type would be more appropriate. In other places we have a `Vec<Span>`\n-                // corresponding to their `Vec<Predicate>`, but we don't have that here.\n-                // Fixing this would improve the output of test `issue-83765.rs`.\n-                inh.register_predicates(obligations);\n-            },\n-        );\n+        // FIXME: We'd want to keep more accurate spans than \"the method signature\" when\n+        // processing the comparison between the trait and impl fn, but we sadly lose them\n+        // and point at the whole signature when a trait bound or specific input or output\n+        // type would be more appropriate. In other places we have a `Vec<Span>`\n+        // corresponding to their `Vec<Predicate>`, but we don't have that here.\n+        // Fixing this would improve the output of test `issue-83765.rs`.\n+        let sub_result = infcx\n+            .at(&cause, param_env)\n+            .sup(trait_fty, impl_fty)\n+            .map(|infer_ok| ocx.register_infer_ok_obligations(infer_ok));\n \n         if let Err(terr) = sub_result {\n             debug!(\"sub_types failed: impl ty {:?}, trait ty {:?}\", impl_fty, trait_fty);\n@@ -385,7 +384,7 @@ fn compare_predicate_entailment<'tcx>(\n \n         // Check that all obligations are satisfied by the implementation's\n         // version.\n-        let errors = inh.fulfillment_cx.borrow_mut().select_all_or_error(&infcx);\n+        let errors = ocx.select_all_or_error();\n         if !errors.is_empty() {\n             let reported = infcx.report_fulfillment_errors(&errors, None, false);\n             return Err(reported);\n@@ -395,7 +394,10 @@ fn compare_predicate_entailment<'tcx>(\n         // lifetime parameters.\n         let mut outlives_environment = OutlivesEnvironment::new(param_env);\n         outlives_environment.add_implied_bounds(infcx, wf_tys, impl_m_hir_id);\n-        infcx.check_region_obligations_and_report_errors(&outlives_environment);\n+        infcx.check_region_obligations_and_report_errors(\n+            impl_m.def_id.expect_local(),\n+            &outlives_environment,\n+        );\n \n         Ok(())\n     })\n@@ -1058,8 +1060,7 @@ pub(crate) fn compare_const_impl<'tcx>(\n \n     tcx.infer_ctxt().enter(|infcx| {\n         let param_env = tcx.param_env(impl_c.def_id);\n-        let inh = Inherited::new(infcx, impl_c.def_id.expect_local());\n-        let infcx = &inh.infcx;\n+        let ocx = ObligationCtxt::new(&infcx);\n \n         // The below is for the most part highly similar to the procedure\n         // for methods above. It is simpler in many respects, especially\n@@ -1082,20 +1083,18 @@ pub(crate) fn compare_const_impl<'tcx>(\n         );\n \n         // There is no \"body\" here, so just pass dummy id.\n-        let impl_ty =\n-            inh.normalize_associated_types_in(impl_c_span, impl_c_hir_id, param_env, impl_ty);\n+        let impl_ty = ocx.normalize(cause.clone(), param_env, impl_ty);\n \n         debug!(\"compare_const_impl: impl_ty={:?}\", impl_ty);\n \n-        let trait_ty =\n-            inh.normalize_associated_types_in(impl_c_span, impl_c_hir_id, param_env, trait_ty);\n+        let trait_ty = ocx.normalize(cause.clone(), param_env, trait_ty);\n \n         debug!(\"compare_const_impl: trait_ty={:?}\", trait_ty);\n \n         let err = infcx\n             .at(&cause, param_env)\n             .sup(trait_ty, impl_ty)\n-            .map(|ok| inh.register_infer_ok_obligations(ok));\n+            .map(|ok| ocx.register_infer_ok_obligations(ok));\n \n         if let Err(terr) = err {\n             debug!(\n@@ -1142,14 +1141,15 @@ pub(crate) fn compare_const_impl<'tcx>(\n \n         // Check that all obligations are satisfied by the implementation's\n         // version.\n-        let errors = inh.fulfillment_cx.borrow_mut().select_all_or_error(&infcx);\n+        let errors = ocx.select_all_or_error();\n         if !errors.is_empty() {\n             infcx.report_fulfillment_errors(&errors, None, false);\n             return;\n         }\n \n         let outlives_environment = OutlivesEnvironment::new(param_env);\n-        infcx.resolve_regions_and_report_errors(&outlives_environment);\n+        infcx\n+            .resolve_regions_and_report_errors(impl_c.def_id.expect_local(), &outlives_environment);\n     });\n }\n \n@@ -1241,8 +1241,7 @@ fn compare_type_predicate_entailment<'tcx>(\n     );\n     let param_env = traits::normalize_param_env_or_error(tcx, param_env, normalize_cause.clone());\n     tcx.infer_ctxt().enter(|infcx| {\n-        let inh = Inherited::new(infcx, impl_ty.def_id.expect_local());\n-        let infcx = &inh.infcx;\n+        let ocx = ObligationCtxt::new(&infcx);\n \n         debug!(\"compare_type_predicate_entailment: caller_bounds={:?}\", param_env.caller_bounds());\n \n@@ -1252,13 +1251,13 @@ fn compare_type_predicate_entailment<'tcx>(\n             let traits::Normalized { value: predicate, obligations } =\n                 traits::normalize(&mut selcx, param_env, normalize_cause.clone(), predicate);\n \n-            inh.register_predicates(obligations);\n-            inh.register_predicate(traits::Obligation::new(cause.clone(), param_env, predicate));\n+            ocx.register_obligations(obligations);\n+            ocx.register_obligation(traits::Obligation::new(cause.clone(), param_env, predicate));\n         }\n \n         // Check that all obligations are satisfied by the implementation's\n         // version.\n-        let errors = inh.fulfillment_cx.borrow_mut().select_all_or_error(&infcx);\n+        let errors = ocx.select_all_or_error();\n         if !errors.is_empty() {\n             let reported = infcx.report_fulfillment_errors(&errors, None, false);\n             return Err(reported);\n@@ -1267,7 +1266,10 @@ fn compare_type_predicate_entailment<'tcx>(\n         // Finally, resolve all regions. This catches wily misuses of\n         // lifetime parameters.\n         let outlives_environment = OutlivesEnvironment::new(param_env);\n-        infcx.check_region_obligations_and_report_errors(&outlives_environment);\n+        infcx.check_region_obligations_and_report_errors(\n+            impl_ty.def_id.expect_local(),\n+            &outlives_environment,\n+        );\n \n         Ok(())\n     })\n@@ -1431,10 +1433,9 @@ pub fn check_type_bounds<'tcx>(\n         impl_ty_substs.rebase_onto(tcx, impl_ty.container.id(), impl_trait_ref.substs);\n \n     tcx.infer_ctxt().enter(move |infcx| {\n-        let inh = Inherited::new(infcx, impl_ty.def_id.expect_local());\n-        let infcx = &inh.infcx;\n-        let mut selcx = traits::SelectionContext::new(&infcx);\n+        let ocx = ObligationCtxt::new(&infcx);\n \n+        let mut selcx = traits::SelectionContext::new(&infcx);\n         let impl_ty_hir_id = tcx.hir().local_def_id_to_hir_id(impl_ty.def_id.expect_local());\n         let normalize_cause = ObligationCause::new(\n             impl_ty_span,\n@@ -1477,30 +1478,32 @@ pub fn check_type_bounds<'tcx>(\n             debug!(\"compare_projection_bounds: normalized predicate = {:?}\", normalized_predicate);\n             obligation.predicate = normalized_predicate;\n \n-            inh.register_predicates(obligations);\n-            inh.register_predicate(obligation);\n+            ocx.register_obligations(obligations);\n+            ocx.register_obligation(obligation);\n         }\n \n         // Check that all obligations are satisfied by the implementation's\n         // version.\n-        let errors = inh.fulfillment_cx.borrow_mut().select_all_or_error(&infcx);\n+        let errors = ocx.select_all_or_error();\n         if !errors.is_empty() {\n             let reported = infcx.report_fulfillment_errors(&errors, None, false);\n             return Err(reported);\n         }\n \n         // Finally, resolve all regions. This catches wily misuses of\n         // lifetime parameters.\n-        //\n-        // FIXME: Remove that `FnCtxt`.\n-        let fcx = FnCtxt::new(&inh, param_env, impl_ty_hir_id);\n         let implied_bounds = match impl_ty.container {\n             ty::TraitContainer(_) => FxHashSet::default(),\n-            ty::ImplContainer(def_id) => fcx.impl_implied_bounds(def_id, impl_ty_span),\n+            ty::ImplContainer(def_id) => {\n+                wfcheck::impl_implied_bounds(tcx, param_env, def_id.expect_local(), impl_ty_span)\n+            }\n         };\n         let mut outlives_environment = OutlivesEnvironment::new(param_env);\n-        outlives_environment.add_implied_bounds(infcx, implied_bounds, impl_ty_hir_id);\n-        infcx.check_region_obligations_and_report_errors(&outlives_environment);\n+        outlives_environment.add_implied_bounds(&infcx, implied_bounds, impl_ty_hir_id);\n+        infcx.check_region_obligations_and_report_errors(\n+            impl_ty.def_id.expect_local(),\n+            &outlives_environment,\n+        );\n \n         Ok(())\n     })"}, {"sha": "42a9a23559c9e17e74f6111df84d825f07c6d495", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/23e21bdd25026e2839ebe946c2a937c1904887d2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23e21bdd25026e2839ebe946c2a937c1904887d2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=23e21bdd25026e2839ebe946c2a937c1904887d2", "patch": "@@ -37,7 +37,6 @@ use rustc_trait_selection::infer::InferCtxtExt as _;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n use rustc_trait_selection::traits::{\n     self, ObligationCause, ObligationCauseCode, StatementAsExpression, TraitEngine, TraitEngineExt,\n-    WellFormedLoc,\n };\n \n use std::collections::hash_map::Entry;\n@@ -375,29 +374,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         (result, spans)\n     }\n \n-    /// Convenience method which tracks extra diagnostic information for normalization\n-    /// that occurs as a result of WF checking. The `hir_id` is the `HirId` of the hir item\n-    /// whose type is being wf-checked - this is used to construct a more precise span if\n-    /// an error occurs.\n-    ///\n-    /// It is never necessary to call this method - calling `normalize_associated_types_in` will\n-    /// just result in a slightly worse diagnostic span, and will still be sound.\n-    pub(in super::super) fn normalize_associated_types_in_wf<T>(\n-        &self,\n-        span: Span,\n-        value: T,\n-        loc: WellFormedLoc,\n-    ) -> T\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        self.inh.normalize_associated_types_in_with_cause(\n-            ObligationCause::new(span, self.body_id, ObligationCauseCode::WellFormed(Some(loc))),\n-            self.param_env,\n-            value,\n-        )\n-    }\n-\n     pub(in super::super) fn normalize_associated_types_in<T>(&self, span: Span, value: T) -> T\n     where\n         T: TypeFoldable<'tcx>,"}, {"sha": "89b376442a887aceaaa15eeac53e126cd1d953fd", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/23e21bdd25026e2839ebe946c2a937c1904887d2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23e21bdd25026e2839ebe946c2a937c1904887d2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=23e21bdd25026e2839ebe946c2a937c1904887d2", "patch": "@@ -4,6 +4,7 @@ use crate::check::fn_ctxt::arg_matrix::{\n     ArgMatrix, Compatibility, Error, ExpectedIdx, ProvidedIdx,\n };\n use crate::check::gather_locals::Declaration;\n+use crate::check::intrinsicck::InlineAsmCtxt;\n use crate::check::method::MethodCallee;\n use crate::check::Expectation::*;\n use crate::check::TupleArgumentsFlag::*;\n@@ -59,7 +60,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         debug!(\"FnCtxt::check_asm: {} deferred checks\", deferred_asm_checks.len());\n         for (asm, hir_id) in deferred_asm_checks.drain(..) {\n             let enclosing_id = self.tcx.hir().enclosing_body_owner(hir_id);\n-            self.check_asm(asm, enclosing_id);\n+            InlineAsmCtxt::new_in_fn(self).check_asm(asm, enclosing_id);\n         }\n     }\n "}, {"sha": "4afbc00b37c7359f67f89cec973e491e077f0bff", "filename": "compiler/rustc_typeck/src/check/inherited.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/23e21bdd25026e2839ebe946c2a937c1904887d2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23e21bdd25026e2839ebe946c2a937c1904887d2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs?ref=23e21bdd25026e2839ebe946c2a937c1904887d2", "patch": "@@ -103,7 +103,7 @@ impl<'tcx> InheritedBuilder<'tcx> {\n }\n \n impl<'a, 'tcx> Inherited<'a, 'tcx> {\n-    pub(super) fn new(infcx: InferCtxt<'a, 'tcx>, def_id: LocalDefId) -> Self {\n+    fn new(infcx: InferCtxt<'a, 'tcx>, def_id: LocalDefId) -> Self {\n         let tcx = infcx.tcx;\n         let item_id = tcx.hir().local_def_id_to_hir_id(def_id);\n         let body_id = tcx.hir().maybe_body_owned_by(item_id);\n@@ -113,7 +113,7 @@ impl<'a, 'tcx> Inherited<'a, 'tcx> {\n                 maybe_typeck_results: infcx.in_progress_typeck_results,\n             },\n             infcx,\n-            fulfillment_cx: RefCell::new(<dyn TraitEngine<'_>>::new(tcx)),\n+            fulfillment_cx: RefCell::new(<dyn TraitEngine<'_>>::new_ignoring_regions(tcx)),\n             locals: RefCell::new(Default::default()),\n             deferred_sized_obligations: RefCell::new(Vec::new()),\n             deferred_call_resolutions: RefCell::new(Default::default()),"}, {"sha": "0adf0d28aae10eb4a17b9a2807f5b36d78b0178d", "filename": "compiler/rustc_typeck/src/check/intrinsicck.rs", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/23e21bdd25026e2839ebe946c2a937c1904887d2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23e21bdd25026e2839ebe946c2a937c1904887d2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsicck.rs?ref=23e21bdd25026e2839ebe946c2a937c1904887d2", "patch": "@@ -111,6 +111,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n         false\n     }\n+}\n+\n+pub struct InlineAsmCtxt<'a, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    fcx: Option<&'a FnCtxt<'a, 'tcx>>,\n+}\n+\n+impl<'a, 'tcx> InlineAsmCtxt<'a, 'tcx> {\n+    pub fn new_global_asm(tcx: TyCtxt<'tcx>) -> Self {\n+        InlineAsmCtxt { tcx, fcx: None }\n+    }\n+\n+    pub fn new_in_fn(fcx: &'a FnCtxt<'a, 'tcx>) -> Self {\n+        InlineAsmCtxt { tcx: fcx.tcx, fcx: Some(fcx) }\n+    }\n \n     fn check_asm_operand_type(\n         &self,\n@@ -122,9 +137,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         tied_input: Option<(&hir::Expr<'tcx>, Option<InlineAsmType>)>,\n         target_features: &FxHashSet<Symbol>,\n     ) -> Option<InlineAsmType> {\n+        let fcx = self.fcx.unwrap_or_else(|| span_bug!(expr.span, \"asm operand for global asm\"));\n         // Check the type against the allowed types for inline asm.\n-        let ty = self.typeck_results.borrow().expr_ty_adjusted(expr);\n-        let ty = self.resolve_vars_if_possible(ty);\n+        let ty = fcx.typeck_results.borrow().expr_ty_adjusted(expr);\n+        let ty = fcx.resolve_vars_if_possible(ty);\n         let asm_ty_isize = match self.tcx.sess.target.pointer_width {\n             16 => InlineAsmType::I16,\n             32 => InlineAsmType::I32,\n@@ -134,7 +150,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Expect types to be fully resolved, no const or type variables.\n         if ty.has_infer_types_or_consts() {\n-            assert!(self.is_tainted_by_errors());\n+            assert!(fcx.is_tainted_by_errors());\n             return None;\n         }\n \n@@ -151,7 +167,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ty::Float(FloatTy::F32) => Some(InlineAsmType::F32),\n             ty::Float(FloatTy::F64) => Some(InlineAsmType::F64),\n             ty::FnPtr(_) => Some(asm_ty_isize),\n-            ty::RawPtr(ty::TypeAndMut { ty, mutbl: _ }) if self.is_thin_ptr_ty(ty) => {\n+            ty::RawPtr(ty::TypeAndMut { ty, mutbl: _ }) if fcx.is_thin_ptr_ty(ty) => {\n                 Some(asm_ty_isize)\n             }\n             ty::Adt(adt, substs) if adt.repr().simd() => {\n@@ -203,7 +219,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Check that the type implements Copy. The only case where this can\n         // possibly fail is for SIMD types which don't #[derive(Copy)].\n-        if !self.infcx.type_is_copy_modulo_regions(self.param_env, ty, DUMMY_SP) {\n+        if !fcx.infcx.type_is_copy_modulo_regions(fcx.param_env, ty, DUMMY_SP) {\n             let msg = \"arguments for inline assembly must be copyable\";\n             let mut err = self.tcx.sess.struct_span_err(expr.span, msg);\n             err.note(&format!(\"`{ty}` does not implement the Copy trait\"));\n@@ -224,8 +240,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let msg = \"incompatible types for asm inout argument\";\n                 let mut err = self.tcx.sess.struct_span_err(vec![in_expr.span, expr.span], msg);\n \n-                let in_expr_ty = self.typeck_results.borrow().expr_ty_adjusted(in_expr);\n-                let in_expr_ty = self.resolve_vars_if_possible(in_expr_ty);\n+                let in_expr_ty = fcx.typeck_results.borrow().expr_ty_adjusted(in_expr);\n+                let in_expr_ty = fcx.resolve_vars_if_possible(in_expr_ty);\n                 err.span_label(in_expr.span, &format!(\"type `{in_expr_ty}`\"));\n                 err.span_label(expr.span, &format!(\"type `{ty}`\"));\n                 err.note("}, {"sha": "6df59ea10969cfd3ed634170a4fc99e1414ddec3", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 300, "deletions": 294, "changes": 594, "blob_url": "https://github.com/rust-lang/rust/blob/23e21bdd25026e2839ebe946c2a937c1904887d2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23e21bdd25026e2839ebe946c2a937c1904887d2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=23e21bdd25026e2839ebe946c2a937c1904887d2", "patch": "@@ -1,7 +1,5 @@\n use crate::check::regionck::OutlivesEnvironmentExt;\n-use crate::check::{FnCtxt, Inherited};\n use crate::constrained_generic_params::{identify_constrained_generic_params, Parameter};\n-\n use rustc_ast as ast;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed};\n@@ -13,6 +11,7 @@ use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::outlives::obligations::TypeOutlives;\n use rustc_infer::infer::region_constraints::GenericKind;\n use rustc_infer::infer::{self, InferCtxt, TyCtxtInferExt};\n+use rustc_infer::traits::Normalized;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts, Subst};\n use rustc_middle::ty::trait_def::TraitSpecializationKind;\n@@ -23,53 +22,95 @@ use rustc_middle::ty::{\n use rustc_session::parse::feature_err;\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n+use rustc_trait_selection::autoderef::Autoderef;\n+use rustc_trait_selection::traits::error_reporting::InferCtxtExt;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n-use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode, WellFormedLoc};\n+use rustc_trait_selection::traits::query::normalize::AtExt;\n+use rustc_trait_selection::traits::query::NoSolution;\n+use rustc_trait_selection::traits::{\n+    self, ObligationCause, ObligationCauseCode, ObligationCtxt, WellFormedLoc,\n+};\n \n use std::cell::LazyCell;\n use std::convert::TryInto;\n use std::iter;\n-use std::ops::ControlFlow;\n+use std::ops::{ControlFlow, Deref};\n \n-/// Helper type of a temporary returned by `.for_item(...)`.\n-/// This is necessary because we can't write the following bound:\n-///\n-/// ```ignore (illustrative)\n-/// F: for<'b, 'tcx> where 'tcx FnOnce(FnCtxt<'b, 'tcx>)\n-/// ```\n-pub(super) struct CheckWfFcxBuilder<'tcx> {\n-    inherited: super::InheritedBuilder<'tcx>,\n-    id: hir::HirId,\n+pub(super) struct WfCheckingCtxt<'a, 'tcx> {\n+    pub(super) ocx: ObligationCtxt<'a, 'tcx>,\n     span: Span,\n+    body_id: hir::HirId,\n     param_env: ty::ParamEnv<'tcx>,\n }\n+impl<'a, 'tcx> Deref for WfCheckingCtxt<'a, 'tcx> {\n+    type Target = ObligationCtxt<'a, 'tcx>;\n+    fn deref(&self) -> &Self::Target {\n+        &self.ocx\n+    }\n+}\n+\n+impl<'tcx> WfCheckingCtxt<'_, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.ocx.infcx.tcx\n+    }\n \n-impl<'tcx> CheckWfFcxBuilder<'tcx> {\n-    pub(super) fn with_fcx<F>(&mut self, f: F)\n+    fn normalize<T>(&self, span: Span, loc: Option<WellFormedLoc>, value: T) -> T\n     where\n-        F: for<'b> FnOnce(&FnCtxt<'b, 'tcx>) -> FxHashSet<Ty<'tcx>>,\n+        T: TypeFoldable<'tcx>,\n     {\n-        let id = self.id;\n-        let span = self.span;\n-        let param_env = self.param_env;\n-        self.inherited.enter(|inh| {\n-            let fcx = FnCtxt::new(&inh, param_env, id);\n-            if !inh.tcx.features().trivial_bounds {\n-                // As predicates are cached rather than obligations, this\n-                // needs to be called first so that they are checked with an\n-                // empty `param_env`.\n-                check_false_global_bounds(&fcx, span, id);\n-            }\n-            let wf_tys = f(&fcx);\n-            fcx.select_all_obligations_or_error();\n+        self.ocx.normalize(\n+            ObligationCause::new(span, self.body_id, ObligationCauseCode::WellFormed(loc)),\n+            self.param_env,\n+            value,\n+        )\n+    }\n \n-            let mut outlives_environment = OutlivesEnvironment::new(param_env);\n-            outlives_environment.add_implied_bounds(&fcx.infcx, wf_tys, id);\n-            fcx.infcx.check_region_obligations_and_report_errors(&outlives_environment);\n-        });\n+    fn register_wf_obligation(\n+        &self,\n+        span: Span,\n+        loc: Option<WellFormedLoc>,\n+        arg: ty::GenericArg<'tcx>,\n+    ) {\n+        let cause =\n+            traits::ObligationCause::new(span, self.body_id, ObligationCauseCode::WellFormed(loc));\n+        self.ocx.register_obligation(traits::Obligation::new(\n+            cause,\n+            self.param_env,\n+            ty::Binder::dummy(ty::PredicateKind::WellFormed(arg)).to_predicate(self.tcx()),\n+        ));\n     }\n }\n \n+pub(super) fn enter_wf_checking_ctxt<'tcx, F>(\n+    tcx: TyCtxt<'tcx>,\n+    span: Span,\n+    body_def_id: LocalDefId,\n+    f: F,\n+) where\n+    F: for<'a> FnOnce(&WfCheckingCtxt<'a, 'tcx>) -> FxHashSet<Ty<'tcx>>,\n+{\n+    let param_env = tcx.param_env(body_def_id);\n+    let body_id = tcx.hir().local_def_id_to_hir_id(body_def_id);\n+    tcx.infer_ctxt().enter(|ref infcx| {\n+        let ocx = ObligationCtxt::new(infcx);\n+        let mut wfcx = WfCheckingCtxt { ocx, span, body_id, param_env };\n+\n+        if !tcx.features().trivial_bounds {\n+            wfcx.check_false_global_bounds()\n+        }\n+        let wf_tys = f(&mut wfcx);\n+        let errors = wfcx.select_all_or_error();\n+        if !errors.is_empty() {\n+            infcx.report_fulfillment_errors(&errors, None, false);\n+            return;\n+        }\n+\n+        let mut outlives_environment = OutlivesEnvironment::new(param_env);\n+        outlives_environment.add_implied_bounds(infcx, wf_tys, body_id);\n+        infcx.check_region_obligations_and_report_errors(body_def_id, &outlives_environment);\n+    })\n+}\n+\n fn check_well_formed(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     let node = tcx.hir().expect_owner(def_id);\n     match node {\n@@ -174,17 +215,17 @@ fn check_item<'tcx>(tcx: TyCtxt<'tcx>, item: &'tcx hir::Item<'tcx>) {\n             check_item_type(tcx, item.def_id, ty.span, false);\n         }\n         hir::ItemKind::Struct(ref struct_def, ref ast_generics) => {\n-            check_type_defn(tcx, item, false, |fcx| vec![fcx.non_enum_variant(struct_def)]);\n+            check_type_defn(tcx, item, false, |wfcx| vec![wfcx.non_enum_variant(struct_def)]);\n \n             check_variances_for_type_defn(tcx, item, ast_generics);\n         }\n         hir::ItemKind::Union(ref struct_def, ref ast_generics) => {\n-            check_type_defn(tcx, item, true, |fcx| vec![fcx.non_enum_variant(struct_def)]);\n+            check_type_defn(tcx, item, true, |wfcx| vec![wfcx.non_enum_variant(struct_def)]);\n \n             check_variances_for_type_defn(tcx, item, ast_generics);\n         }\n         hir::ItemKind::Enum(ref enum_def, ref ast_generics) => {\n-            check_type_defn(tcx, item, true, |fcx| fcx.enum_variants(enum_def));\n+            check_type_defn(tcx, item, true, |wfcx| wfcx.enum_variants(enum_def));\n \n             check_variances_for_type_defn(tcx, item, ast_generics);\n         }\n@@ -933,45 +974,45 @@ fn check_associated_item(\n     span: Span,\n     sig_if_method: Option<&hir::FnSig<'_>>,\n ) {\n-    let code = ObligationCauseCode::WellFormed(Some(WellFormedLoc::Ty(item_id)));\n-    for_id(tcx, item_id, span).with_fcx(|fcx| {\n-        let item = fcx.tcx.associated_item(item_id);\n+    let loc = Some(WellFormedLoc::Ty(item_id));\n+    enter_wf_checking_ctxt(tcx, span, item_id, |wfcx| {\n+        let item = tcx.associated_item(item_id);\n \n         let (mut implied_bounds, self_ty) = match item.container {\n-            ty::TraitContainer(_) => (FxHashSet::default(), fcx.tcx.types.self_param),\n-            ty::ImplContainer(def_id) => {\n-                (fcx.impl_implied_bounds(def_id, span), fcx.tcx.type_of(def_id))\n-            }\n+            ty::TraitContainer(_) => (FxHashSet::default(), tcx.types.self_param),\n+            ty::ImplContainer(def_id) => (\n+                impl_implied_bounds(tcx, wfcx.param_env, def_id.expect_local(), span),\n+                tcx.type_of(def_id),\n+            ),\n         };\n \n         match item.kind {\n             ty::AssocKind::Const => {\n-                let ty = fcx.tcx.type_of(item.def_id);\n-                let ty = fcx.normalize_associated_types_in_wf(span, ty, WellFormedLoc::Ty(item_id));\n-                fcx.register_wf_obligation(ty.into(), span, code.clone());\n+                let ty = tcx.type_of(item.def_id);\n+                let ty = wfcx.normalize(span, Some(WellFormedLoc::Ty(item_id)), ty);\n+                wfcx.register_wf_obligation(span, loc, ty.into());\n             }\n             ty::AssocKind::Fn => {\n-                let sig = fcx.tcx.fn_sig(item.def_id);\n+                let sig = tcx.fn_sig(item.def_id);\n                 let hir_sig = sig_if_method.expect(\"bad signature for method\");\n                 check_fn_or_method(\n-                    fcx,\n-                    item.ident(fcx.tcx).span,\n+                    wfcx,\n+                    item.ident(tcx).span,\n                     sig,\n                     hir_sig.decl,\n                     item.def_id.expect_local(),\n                     &mut implied_bounds,\n                 );\n-                check_method_receiver(fcx, hir_sig, item, self_ty);\n+                check_method_receiver(wfcx, hir_sig, item, self_ty);\n             }\n             ty::AssocKind::Type => {\n                 if let ty::AssocItemContainer::TraitContainer(_) = item.container {\n-                    check_associated_type_bounds(fcx, item, span)\n+                    check_associated_type_bounds(wfcx, item, span)\n                 }\n                 if item.defaultness.has_value() {\n-                    let ty = fcx.tcx.type_of(item.def_id);\n-                    let ty =\n-                        fcx.normalize_associated_types_in_wf(span, ty, WellFormedLoc::Ty(item_id));\n-                    fcx.register_wf_obligation(ty.into(), span, code.clone());\n+                    let ty = tcx.type_of(item.def_id);\n+                    let ty = wfcx.normalize(span, Some(WellFormedLoc::Ty(item_id)), ty);\n+                    wfcx.register_wf_obligation(span, loc, ty.into());\n                 }\n             }\n         }\n@@ -980,19 +1021,6 @@ fn check_associated_item(\n     })\n }\n \n-pub(super) fn for_item<'tcx>(tcx: TyCtxt<'tcx>, item: &hir::Item<'_>) -> CheckWfFcxBuilder<'tcx> {\n-    for_id(tcx, item.def_id, item.span)\n-}\n-\n-fn for_id(tcx: TyCtxt<'_>, def_id: LocalDefId, span: Span) -> CheckWfFcxBuilder<'_> {\n-    CheckWfFcxBuilder {\n-        inherited: Inherited::build(tcx, def_id),\n-        id: hir::HirId::make_owner(def_id),\n-        span,\n-        param_env: tcx.param_env(def_id),\n-    }\n-}\n-\n fn item_adt_kind(kind: &ItemKind<'_>) -> Option<AdtKind> {\n     match kind {\n         ItemKind::Struct(..) => Some(AdtKind::Struct),\n@@ -1009,19 +1037,19 @@ fn check_type_defn<'tcx, F>(\n     all_sized: bool,\n     mut lookup_fields: F,\n ) where\n-    F: for<'fcx> FnMut(&FnCtxt<'fcx, 'tcx>) -> Vec<AdtVariant<'tcx>>,\n+    F: FnMut(&WfCheckingCtxt<'_, 'tcx>) -> Vec<AdtVariant<'tcx>>,\n {\n-    for_item(tcx, item).with_fcx(|fcx| {\n-        let variants = lookup_fields(fcx);\n+    enter_wf_checking_ctxt(tcx, item.span, item.def_id, |wfcx| {\n+        let variants = lookup_fields(wfcx);\n         let packed = tcx.adt_def(item.def_id).repr().packed();\n \n         for variant in &variants {\n             // All field types must be well-formed.\n             for field in &variant.fields {\n-                fcx.register_wf_obligation(\n-                    field.ty.into(),\n+                wfcx.register_wf_obligation(\n                     field.span,\n-                    ObligationCauseCode::WellFormed(Some(WellFormedLoc::Ty(field.def_id))),\n+                    Some(WellFormedLoc::Ty(field.def_id)),\n+                    field.ty.into(),\n                 )\n             }\n \n@@ -1048,12 +1076,10 @@ fn check_type_defn<'tcx, F>(\n                 variant.fields[..variant.fields.len() - unsized_len].iter().enumerate()\n             {\n                 let last = idx == variant.fields.len() - 1;\n-                fcx.register_bound(\n-                    field.ty,\n-                    tcx.require_lang_item(LangItem::Sized, None),\n+                wfcx.register_bound(\n                     traits::ObligationCause::new(\n                         field.span,\n-                        fcx.body_id,\n+                        wfcx.body_id,\n                         traits::FieldSized {\n                             adt_kind: match item_adt_kind(&item.kind) {\n                                 Some(i) => i,\n@@ -1063,6 +1089,9 @@ fn check_type_defn<'tcx, F>(\n                             last,\n                         },\n                     ),\n+                    wfcx.param_env,\n+                    field.ty,\n+                    tcx.require_lang_item(LangItem::Sized, None),\n                 );\n             }\n \n@@ -1072,12 +1101,12 @@ fn check_type_defn<'tcx, F>(\n \n                 let cause = traits::ObligationCause::new(\n                     tcx.def_span(discr_def_id),\n-                    fcx.body_id,\n+                    wfcx.body_id,\n                     traits::MiscObligation,\n                 );\n-                fcx.register_predicate(traits::Obligation::new(\n+                wfcx.register_obligation(traits::Obligation::new(\n                     cause,\n-                    fcx.param_env,\n+                    wfcx.param_env,\n                     ty::Binder::dummy(ty::PredicateKind::ConstEvaluatable(ty::Unevaluated::new(\n                         ty::WithOptConstParam::unknown(discr_def_id.to_def_id()),\n                         discr_substs,\n@@ -1087,7 +1116,7 @@ fn check_type_defn<'tcx, F>(\n             }\n         }\n \n-        check_where_clauses(fcx, item.span, item.def_id, None);\n+        check_where_clauses(wfcx, item.span, item.def_id);\n \n         // No implied bounds in a struct definition.\n         FxHashSet::default()\n@@ -1113,9 +1142,8 @@ fn check_trait(tcx: TyCtxt<'_>, item: &hir::Item<'_>) {\n         }\n     }\n \n-    // FIXME: this shouldn't use an `FnCtxt` at all.\n-    for_item(tcx, item).with_fcx(|fcx| {\n-        check_where_clauses(fcx, item.span, item.def_id, None);\n+    enter_wf_checking_ctxt(tcx, item.span, item.def_id, |wfcx| {\n+        check_where_clauses(wfcx, item.span, item.def_id);\n \n         FxHashSet::default()\n     });\n@@ -1130,27 +1158,22 @@ fn check_trait(tcx: TyCtxt<'_>, item: &hir::Item<'_>) {\n ///\n /// Assuming the defaults are used, check that all predicates (bounds on the\n /// assoc type and where clauses on the trait) hold.\n-fn check_associated_type_bounds(fcx: &FnCtxt<'_, '_>, item: &ty::AssocItem, span: Span) {\n-    let tcx = fcx.tcx;\n-\n-    let bounds = tcx.explicit_item_bounds(item.def_id);\n+fn check_associated_type_bounds(wfcx: &WfCheckingCtxt<'_, '_>, item: &ty::AssocItem, span: Span) {\n+    let bounds = wfcx.tcx().explicit_item_bounds(item.def_id);\n \n     debug!(\"check_associated_type_bounds: bounds={:?}\", bounds);\n     let wf_obligations = bounds.iter().flat_map(|&(bound, bound_span)| {\n-        let normalized_bound = fcx.normalize_associated_types_in(span, bound);\n+        let normalized_bound = wfcx.normalize(span, None, bound);\n         traits::wf::predicate_obligations(\n-            fcx,\n-            fcx.param_env,\n-            fcx.body_id,\n+            wfcx.infcx,\n+            wfcx.param_env,\n+            wfcx.body_id,\n             normalized_bound,\n             bound_span,\n         )\n     });\n \n-    for obligation in wf_obligations {\n-        debug!(\"next obligation cause: {:?}\", obligation.cause);\n-        fcx.register_predicate(obligation);\n-    }\n+    wfcx.register_obligations(wf_obligations);\n }\n \n fn check_item_fn(\n@@ -1160,39 +1183,36 @@ fn check_item_fn(\n     span: Span,\n     decl: &hir::FnDecl<'_>,\n ) {\n-    for_id(tcx, def_id, span).with_fcx(|fcx| {\n+    enter_wf_checking_ctxt(tcx, span, def_id, |wfcx| {\n         let sig = tcx.fn_sig(def_id);\n         let mut implied_bounds = FxHashSet::default();\n-        check_fn_or_method(fcx, ident.span, sig, decl, def_id, &mut implied_bounds);\n+        check_fn_or_method(wfcx, ident.span, sig, decl, def_id, &mut implied_bounds);\n         implied_bounds\n     })\n }\n \n fn check_item_type(tcx: TyCtxt<'_>, item_id: LocalDefId, ty_span: Span, allow_foreign_ty: bool) {\n     debug!(\"check_item_type: {:?}\", item_id);\n \n-    for_id(tcx, item_id, ty_span).with_fcx(|fcx| {\n+    enter_wf_checking_ctxt(tcx, ty_span, item_id, |wfcx| {\n         let ty = tcx.type_of(item_id);\n-        let item_ty = fcx.normalize_associated_types_in_wf(ty_span, ty, WellFormedLoc::Ty(item_id));\n+        let item_ty = wfcx.normalize(ty_span, Some(WellFormedLoc::Ty(item_id)), ty);\n \n         let mut forbid_unsized = true;\n         if allow_foreign_ty {\n-            let tail = fcx.tcx.struct_tail_erasing_lifetimes(item_ty, fcx.param_env);\n+            let tail = tcx.struct_tail_erasing_lifetimes(item_ty, wfcx.param_env);\n             if let ty::Foreign(_) = tail.kind() {\n                 forbid_unsized = false;\n             }\n         }\n \n-        fcx.register_wf_obligation(\n-            item_ty.into(),\n-            ty_span,\n-            ObligationCauseCode::WellFormed(Some(WellFormedLoc::Ty(item_id))),\n-        );\n+        wfcx.register_wf_obligation(ty_span, Some(WellFormedLoc::Ty(item_id)), item_ty.into());\n         if forbid_unsized {\n-            fcx.register_bound(\n+            wfcx.register_bound(\n+                traits::ObligationCause::new(ty_span, wfcx.body_id, traits::WellFormed(None)),\n+                wfcx.param_env,\n                 item_ty,\n                 tcx.require_lang_item(LangItem::Sized, None),\n-                traits::ObligationCause::new(ty_span, fcx.body_id, traits::WellFormed(None)),\n             );\n         }\n \n@@ -1203,10 +1223,11 @@ fn check_item_type(tcx: TyCtxt<'_>, item_id: LocalDefId, ty_span: Span, allow_fo\n             && !tcx.is_thread_local_static(item_id.to_def_id());\n \n         if should_check_for_sync {\n-            fcx.register_bound(\n+            wfcx.register_bound(\n+                traits::ObligationCause::new(ty_span, wfcx.body_id, traits::SharedStatic),\n+                wfcx.param_env,\n                 item_ty,\n                 tcx.require_lang_item(LangItem::Sync, Some(ty_span)),\n-                traits::ObligationCause::new(ty_span, fcx.body_id, traits::SharedStatic),\n             );\n         }\n \n@@ -1222,56 +1243,47 @@ fn check_impl<'tcx>(\n     ast_self_ty: &hir::Ty<'_>,\n     ast_trait_ref: &Option<hir::TraitRef<'_>>,\n ) {\n-    for_item(tcx, item).with_fcx(|fcx| {\n+    enter_wf_checking_ctxt(tcx, item.span, item.def_id, |wfcx| {\n         match *ast_trait_ref {\n             Some(ref ast_trait_ref) => {\n                 // `#[rustc_reservation_impl]` impls are not real impls and\n                 // therefore don't need to be WF (the trait's `Self: Trait` predicate\n                 // won't hold).\n                 let trait_ref = tcx.impl_trait_ref(item.def_id).unwrap();\n-                let trait_ref =\n-                    fcx.normalize_associated_types_in(ast_trait_ref.path.span, trait_ref);\n+                let trait_ref = wfcx.normalize(ast_trait_ref.path.span, None, trait_ref);\n                 let obligations = traits::wf::trait_obligations(\n-                    fcx,\n-                    fcx.param_env,\n-                    fcx.body_id,\n+                    wfcx.infcx,\n+                    wfcx.param_env,\n+                    wfcx.body_id,\n                     &trait_ref,\n                     ast_trait_ref.path.span,\n                     item,\n                 );\n                 debug!(?obligations);\n-                for obligation in obligations {\n-                    fcx.register_predicate(obligation);\n-                }\n+                wfcx.register_obligations(obligations);\n             }\n             None => {\n                 let self_ty = tcx.type_of(item.def_id);\n-                let self_ty = fcx.normalize_associated_types_in(item.span, self_ty);\n-                fcx.register_wf_obligation(\n-                    self_ty.into(),\n+                let self_ty = wfcx.normalize(item.span, None, self_ty);\n+                wfcx.register_wf_obligation(\n                     ast_self_ty.span,\n-                    ObligationCauseCode::WellFormed(Some(WellFormedLoc::Ty(\n-                        item.hir_id().expect_owner(),\n-                    ))),\n+                    Some(WellFormedLoc::Ty(item.hir_id().expect_owner())),\n+                    self_ty.into(),\n                 );\n             }\n         }\n \n-        check_where_clauses(fcx, item.span, item.def_id, None);\n+        check_where_clauses(wfcx, item.span, item.def_id);\n \n-        fcx.impl_implied_bounds(item.def_id.to_def_id(), item.span)\n+        impl_implied_bounds(tcx, wfcx.param_env, item.def_id, item.span)\n     });\n }\n \n /// Checks where-clauses and inline bounds that are declared on `def_id`.\n-#[instrument(skip(fcx), level = \"debug\")]\n-fn check_where_clauses<'tcx, 'fcx>(\n-    fcx: &FnCtxt<'fcx, 'tcx>,\n-    span: Span,\n-    def_id: LocalDefId,\n-    return_ty: Option<(Ty<'tcx>, Span)>,\n-) {\n-    let tcx = fcx.tcx;\n+#[instrument(level = \"debug\", skip(wfcx))]\n+fn check_where_clauses<'tcx>(wfcx: &WfCheckingCtxt<'_, 'tcx>, span: Span, def_id: LocalDefId) {\n+    let infcx = wfcx.infcx;\n+    let tcx = wfcx.tcx();\n \n     let predicates = tcx.predicates_of(def_id);\n     let generics = tcx.generics_of(def_id);\n@@ -1299,11 +1311,7 @@ fn check_where_clauses<'tcx, 'fcx>(\n                     // parameter includes another (e.g., `<T, U = T>`). In those cases, we can't\n                     // be sure if it will error or not as user might always specify the other.\n                     if !ty.needs_subst() {\n-                        fcx.register_wf_obligation(\n-                            ty.into(),\n-                            tcx.def_span(param.def_id),\n-                            ObligationCauseCode::MiscObligation,\n-                        );\n+                        wfcx.register_wf_obligation(tcx.def_span(param.def_id), None, ty.into());\n                     }\n                 }\n             }\n@@ -1315,10 +1323,10 @@ fn check_where_clauses<'tcx, 'fcx>(\n                     // we should eagerly error.\n                     let default_ct = tcx.const_param_default(param.def_id);\n                     if !default_ct.needs_subst() {\n-                        fcx.register_wf_obligation(\n-                            default_ct.into(),\n+                        wfcx.register_wf_obligation(\n                             tcx.def_span(param.def_id),\n-                            ObligationCauseCode::WellFormed(None),\n+                            None,\n+                            default_ct.into(),\n                         );\n                     }\n                 }\n@@ -1429,148 +1437,132 @@ fn check_where_clauses<'tcx, 'fcx>(\n             // Note the subtle difference from how we handle `predicates`\n             // below: there, we are not trying to prove those predicates\n             // to be *true* but merely *well-formed*.\n-            let pred = fcx.normalize_associated_types_in(sp, pred);\n+            let pred = wfcx.normalize(sp, None, pred);\n             let cause = traits::ObligationCause::new(\n                 sp,\n-                fcx.body_id,\n+                wfcx.body_id,\n                 traits::ItemObligation(def_id.to_def_id()),\n             );\n-            traits::Obligation::new(cause, fcx.param_env, pred)\n+            traits::Obligation::new(cause, wfcx.param_env, pred)\n         });\n \n     let predicates = predicates.instantiate_identity(tcx);\n \n-    if let Some((return_ty, _)) = return_ty {\n-        if return_ty.has_infer_types_or_consts() {\n-            fcx.select_obligations_where_possible(false, |_| {});\n-        }\n-    }\n-\n-    let predicates = fcx.normalize_associated_types_in(span, predicates);\n+    let predicates = wfcx.normalize(span, None, predicates);\n \n     debug!(?predicates.predicates);\n     assert_eq!(predicates.predicates.len(), predicates.spans.len());\n     let wf_obligations =\n         iter::zip(&predicates.predicates, &predicates.spans).flat_map(|(&p, &sp)| {\n-            traits::wf::predicate_obligations(fcx, fcx.param_env, fcx.body_id, p, sp)\n+            traits::wf::predicate_obligations(infcx, wfcx.param_env, wfcx.body_id, p, sp)\n         });\n \n-    for obligation in wf_obligations.chain(default_obligations) {\n-        debug!(\"next obligation cause: {:?}\", obligation.cause);\n-        fcx.register_predicate(obligation);\n-    }\n+    let obligations: Vec<_> = wf_obligations.chain(default_obligations).collect();\n+    wfcx.register_obligations(obligations);\n }\n \n-#[tracing::instrument(level = \"debug\", skip(fcx, span, hir_decl))]\n-fn check_fn_or_method<'fcx, 'tcx>(\n-    fcx: &FnCtxt<'fcx, 'tcx>,\n+#[tracing::instrument(level = \"debug\", skip(wfcx, span, hir_decl))]\n+fn check_fn_or_method<'tcx>(\n+    wfcx: &WfCheckingCtxt<'_, 'tcx>,\n     span: Span,\n     sig: ty::PolyFnSig<'tcx>,\n     hir_decl: &hir::FnDecl<'_>,\n     def_id: LocalDefId,\n     implied_bounds: &mut FxHashSet<Ty<'tcx>>,\n ) {\n-    let sig = fcx.tcx.liberate_late_bound_regions(def_id.to_def_id(), sig);\n+    let tcx = wfcx.tcx();\n+    let sig = tcx.liberate_late_bound_regions(def_id.to_def_id(), sig);\n \n     // Normalize the input and output types one at a time, using a different\n     // `WellFormedLoc` for each. We cannot call `normalize_associated_types`\n     // on the entire `FnSig`, since this would use the same `WellFormedLoc`\n     // for each type, preventing the HIR wf check from generating\n     // a nice error message.\n     let ty::FnSig { mut inputs_and_output, c_variadic, unsafety, abi } = sig;\n-    inputs_and_output =\n-        fcx.tcx.mk_type_list(inputs_and_output.iter().enumerate().map(|(i, ty)| {\n-            fcx.normalize_associated_types_in_wf(\n-                span,\n-                ty,\n-                WellFormedLoc::Param {\n-                    function: def_id,\n-                    // Note that the `param_idx` of the output type is\n-                    // one greater than the index of the last input type.\n-                    param_idx: i.try_into().unwrap(),\n-                },\n-            )\n-        }));\n+    inputs_and_output = tcx.mk_type_list(inputs_and_output.iter().enumerate().map(|(i, ty)| {\n+        wfcx.normalize(\n+            span,\n+            Some(WellFormedLoc::Param {\n+                function: def_id,\n+                // Note that the `param_idx` of the output type is\n+                // one greater than the index of the last input type.\n+                param_idx: i.try_into().unwrap(),\n+            }),\n+            ty,\n+        )\n+    }));\n     // Manually call `normalize_associated_types_in` on the other types\n     // in `FnSig`. This ensures that if the types of these fields\n     // ever change to include projections, we will start normalizing\n     // them automatically.\n     let sig = ty::FnSig {\n         inputs_and_output,\n-        c_variadic: fcx.normalize_associated_types_in(span, c_variadic),\n-        unsafety: fcx.normalize_associated_types_in(span, unsafety),\n-        abi: fcx.normalize_associated_types_in(span, abi),\n+        c_variadic: wfcx.normalize(span, None, c_variadic),\n+        unsafety: wfcx.normalize(span, None, unsafety),\n+        abi: wfcx.normalize(span, None, abi),\n     };\n \n     for (i, (&input_ty, ty)) in iter::zip(sig.inputs(), hir_decl.inputs).enumerate() {\n-        fcx.register_wf_obligation(\n-            input_ty.into(),\n+        wfcx.register_wf_obligation(\n             ty.span,\n-            ObligationCauseCode::WellFormed(Some(WellFormedLoc::Param {\n-                function: def_id,\n-                param_idx: i.try_into().unwrap(),\n-            })),\n+            Some(WellFormedLoc::Param { function: def_id, param_idx: i.try_into().unwrap() }),\n+            input_ty.into(),\n         );\n     }\n \n     implied_bounds.extend(sig.inputs());\n \n-    fcx.register_wf_obligation(\n-        sig.output().into(),\n-        hir_decl.output.span(),\n-        ObligationCauseCode::ReturnType,\n-    );\n+    wfcx.register_wf_obligation(hir_decl.output.span(), None, sig.output().into());\n \n     // FIXME(#27579) return types should not be implied bounds\n     implied_bounds.insert(sig.output());\n \n     debug!(?implied_bounds);\n \n-    check_where_clauses(fcx, span, def_id, Some((sig.output(), hir_decl.output.span())));\n+    check_where_clauses(wfcx, span, def_id);\n }\n \n const HELP_FOR_SELF_TYPE: &str = \"consider changing to `self`, `&self`, `&mut self`, `self: Box<Self>`, \\\n      `self: Rc<Self>`, `self: Arc<Self>`, or `self: Pin<P>` (where P is one \\\n      of the previous types except `Self`)\";\n \n-#[tracing::instrument(level = \"debug\", skip(fcx))]\n-fn check_method_receiver<'fcx, 'tcx>(\n-    fcx: &FnCtxt<'fcx, 'tcx>,\n+#[tracing::instrument(level = \"debug\", skip(wfcx))]\n+fn check_method_receiver<'tcx>(\n+    wfcx: &WfCheckingCtxt<'_, 'tcx>,\n     fn_sig: &hir::FnSig<'_>,\n     method: &ty::AssocItem,\n     self_ty: Ty<'tcx>,\n ) {\n-    // Check that the method has a valid receiver type, given the type `Self`.\n-    debug!(\"check_method_receiver({:?}, self_ty={:?})\", method, self_ty);\n+    let tcx = wfcx.tcx();\n \n     if !method.fn_has_self_parameter {\n         return;\n     }\n \n     let span = fn_sig.decl.inputs[0].span;\n \n-    let sig = fcx.tcx.fn_sig(method.def_id);\n-    let sig = fcx.tcx.liberate_late_bound_regions(method.def_id, sig);\n-    let sig = fcx.normalize_associated_types_in(span, sig);\n+    let sig = tcx.fn_sig(method.def_id);\n+    let sig = tcx.liberate_late_bound_regions(method.def_id, sig);\n+    let sig = wfcx.normalize(span, None, sig);\n \n     debug!(\"check_method_receiver: sig={:?}\", sig);\n \n-    let self_ty = fcx.normalize_associated_types_in(span, self_ty);\n+    let self_ty = wfcx.normalize(span, None, self_ty);\n \n     let receiver_ty = sig.inputs()[0];\n-    let receiver_ty = fcx.normalize_associated_types_in(span, receiver_ty);\n+    let receiver_ty = wfcx.normalize(span, None, receiver_ty);\n \n-    if fcx.tcx.features().arbitrary_self_types {\n-        if !receiver_is_valid(fcx, span, receiver_ty, self_ty, true) {\n+    if tcx.features().arbitrary_self_types {\n+        if !receiver_is_valid(wfcx, span, receiver_ty, self_ty, true) {\n             // Report error; `arbitrary_self_types` was enabled.\n-            e0307(fcx, span, receiver_ty);\n+            e0307(tcx, span, receiver_ty);\n         }\n     } else {\n-        if !receiver_is_valid(fcx, span, receiver_ty, self_ty, false) {\n-            if receiver_is_valid(fcx, span, receiver_ty, self_ty, true) {\n+        if !receiver_is_valid(wfcx, span, receiver_ty, self_ty, false) {\n+            if receiver_is_valid(wfcx, span, receiver_ty, self_ty, true) {\n                 // Report error; would have worked with `arbitrary_self_types`.\n                 feature_err(\n-                    &fcx.tcx.sess.parse_sess,\n+                    &tcx.sess.parse_sess,\n                     sym::arbitrary_self_types,\n                     span,\n                     &format!(\n@@ -1582,15 +1574,15 @@ fn check_method_receiver<'fcx, 'tcx>(\n                 .emit();\n             } else {\n                 // Report error; would not have worked with `arbitrary_self_types`.\n-                e0307(fcx, span, receiver_ty);\n+                e0307(tcx, span, receiver_ty);\n             }\n         }\n     }\n }\n \n-fn e0307<'tcx>(fcx: &FnCtxt<'_, 'tcx>, span: Span, receiver_ty: Ty<'_>) {\n+fn e0307<'tcx>(tcx: TyCtxt<'tcx>, span: Span, receiver_ty: Ty<'_>) {\n     struct_span_err!(\n-        fcx.tcx.sess.diagnostic(),\n+        tcx.sess.diagnostic(),\n         span,\n         E0307,\n         \"invalid `self` parameter type: {receiver_ty}\"\n@@ -1609,26 +1601,30 @@ fn e0307<'tcx>(fcx: &FnCtxt<'_, 'tcx>, span: Span, receiver_ty: Ty<'_>) {\n /// N.B., there are cases this function returns `true` but causes an error to be emitted,\n /// particularly when `receiver_ty` derefs to a type that is the same as `self_ty` but has the\n /// wrong lifetime. Be careful of this if you are calling this function speculatively.\n-fn receiver_is_valid<'fcx, 'tcx>(\n-    fcx: &FnCtxt<'fcx, 'tcx>,\n+fn receiver_is_valid<'tcx>(\n+    wfcx: &WfCheckingCtxt<'_, 'tcx>,\n     span: Span,\n     receiver_ty: Ty<'tcx>,\n     self_ty: Ty<'tcx>,\n     arbitrary_self_types_enabled: bool,\n ) -> bool {\n-    let cause = fcx.cause(span, traits::ObligationCauseCode::MethodReceiver);\n+    let infcx = wfcx.infcx;\n+    let tcx = wfcx.tcx();\n+    let cause =\n+        ObligationCause::new(span, wfcx.body_id, traits::ObligationCauseCode::MethodReceiver);\n \n-    let can_eq_self = |ty| fcx.infcx.can_eq(fcx.param_env, self_ty, ty).is_ok();\n+    let can_eq_self = |ty| infcx.can_eq(wfcx.param_env, self_ty, ty).is_ok();\n \n     // `self: Self` is always valid.\n     if can_eq_self(receiver_ty) {\n-        if let Some(mut err) = fcx.demand_eqtype_with_origin(&cause, self_ty, receiver_ty) {\n-            err.emit();\n+        if let Err(err) = wfcx.equate_types(&cause, wfcx.param_env, self_ty, receiver_ty) {\n+            infcx.report_mismatched_types(&cause, self_ty, receiver_ty, err).emit();\n         }\n         return true;\n     }\n \n-    let mut autoderef = fcx.autoderef(span, receiver_ty);\n+    let mut autoderef =\n+        Autoderef::new(infcx, wfcx.param_env, wfcx.body_id, span, receiver_ty, span);\n \n     // The `arbitrary_self_types` feature allows raw pointer receivers like `self: *const Self`.\n     if arbitrary_self_types_enabled {\n@@ -1638,7 +1634,7 @@ fn receiver_is_valid<'fcx, 'tcx>(\n     // The first type is `receiver_ty`, which we know its not equal to `self_ty`; skip it.\n     autoderef.next();\n \n-    let receiver_trait_def_id = fcx.tcx.require_lang_item(LangItem::Receiver, None);\n+    let receiver_trait_def_id = tcx.require_lang_item(LangItem::Receiver, None);\n \n     // Keep dereferencing `receiver_ty` until we get to `self_ty`.\n     loop {\n@@ -1649,12 +1645,12 @@ fn receiver_is_valid<'fcx, 'tcx>(\n             );\n \n             if can_eq_self(potential_self_ty) {\n-                fcx.register_predicates(autoderef.into_obligations());\n+                wfcx.register_obligations(autoderef.into_obligations());\n \n-                if let Some(mut err) =\n-                    fcx.demand_eqtype_with_origin(&cause, self_ty, potential_self_ty)\n+                if let Err(err) =\n+                    wfcx.equate_types(&cause, wfcx.param_env, self_ty, potential_self_ty)\n                 {\n-                    err.emit();\n+                    infcx.report_mismatched_types(&cause, self_ty, potential_self_ty, err).emit();\n                 }\n \n                 break;\n@@ -1663,7 +1659,7 @@ fn receiver_is_valid<'fcx, 'tcx>(\n                 // deref chain implement `receiver`\n                 if !arbitrary_self_types_enabled\n                     && !receiver_is_implemented(\n-                        fcx,\n+                        wfcx,\n                         receiver_trait_def_id,\n                         cause.clone(),\n                         potential_self_ty,\n@@ -1682,7 +1678,7 @@ fn receiver_is_valid<'fcx, 'tcx>(\n \n     // Without `feature(arbitrary_self_types)`, we require that `receiver_ty` implements `Receiver`.\n     if !arbitrary_self_types_enabled\n-        && !receiver_is_implemented(fcx, receiver_trait_def_id, cause.clone(), receiver_ty)\n+        && !receiver_is_implemented(wfcx, receiver_trait_def_id, cause.clone(), receiver_ty)\n     {\n         return false;\n     }\n@@ -1691,23 +1687,21 @@ fn receiver_is_valid<'fcx, 'tcx>(\n }\n \n fn receiver_is_implemented<'tcx>(\n-    fcx: &FnCtxt<'_, 'tcx>,\n+    wfcx: &WfCheckingCtxt<'_, 'tcx>,\n     receiver_trait_def_id: DefId,\n     cause: ObligationCause<'tcx>,\n     receiver_ty: Ty<'tcx>,\n ) -> bool {\n+    let tcx = wfcx.tcx();\n     let trait_ref = ty::Binder::dummy(ty::TraitRef {\n         def_id: receiver_trait_def_id,\n-        substs: fcx.tcx.mk_substs_trait(receiver_ty, &[]),\n+        substs: tcx.mk_substs_trait(receiver_ty, &[]),\n     });\n \n-    let obligation = traits::Obligation::new(\n-        cause,\n-        fcx.param_env,\n-        trait_ref.without_const().to_predicate(fcx.tcx),\n-    );\n+    let obligation =\n+        traits::Obligation::new(cause, wfcx.param_env, trait_ref.without_const().to_predicate(tcx));\n \n-    if fcx.predicate_must_hold_modulo_regions(&obligation) {\n+    if wfcx.infcx.predicate_must_hold_modulo_regions(&obligation) {\n         true\n     } else {\n         debug!(\n@@ -1809,55 +1803,56 @@ fn report_bivariance(\n     err.emit()\n }\n \n-/// Feature gates RFC 2056 -- trivial bounds, checking for global bounds that\n-/// aren't true.\n-fn check_false_global_bounds(fcx: &FnCtxt<'_, '_>, mut span: Span, id: hir::HirId) {\n-    let empty_env = ty::ParamEnv::empty();\n-\n-    let def_id = fcx.tcx.hir().local_def_id(id);\n-    let predicates_with_span =\n-        fcx.tcx.predicates_of(def_id).predicates.iter().map(|(p, span)| (*p, *span));\n-    // Check elaborated bounds.\n-    let implied_obligations = traits::elaborate_predicates_with_span(fcx.tcx, predicates_with_span);\n-\n-    for obligation in implied_obligations {\n-        // We lower empty bounds like `Vec<dyn Copy>:` as\n-        // `WellFormed(Vec<dyn Copy>)`, which will later get checked by\n-        // regular WF checking\n-        if let ty::PredicateKind::WellFormed(..) = obligation.predicate.kind().skip_binder() {\n-            continue;\n-        }\n-        let pred = obligation.predicate;\n-        // Match the existing behavior.\n-        if pred.is_global() && !pred.has_late_bound_regions() {\n-            let pred = fcx.normalize_associated_types_in(span, pred);\n-            let hir_node = fcx.tcx.hir().find(id);\n+impl<'tcx> WfCheckingCtxt<'_, 'tcx> {\n+    /// Feature gates RFC 2056 -- trivial bounds, checking for global bounds that\n+    /// aren't true.\n+    fn check_false_global_bounds(&mut self) {\n+        let tcx = self.ocx.infcx.tcx;\n+        let mut span = self.span;\n+        let empty_env = ty::ParamEnv::empty();\n+\n+        let def_id = tcx.hir().local_def_id(self.body_id);\n+        let predicates_with_span = tcx.predicates_of(def_id).predicates.iter().copied();\n+        // Check elaborated bounds.\n+        let implied_obligations = traits::elaborate_predicates_with_span(tcx, predicates_with_span);\n+\n+        for obligation in implied_obligations {\n+            // We lower empty bounds like `Vec<dyn Copy>:` as\n+            // `WellFormed(Vec<dyn Copy>)`, which will later get checked by\n+            // regular WF checking\n+            if let ty::PredicateKind::WellFormed(..) = obligation.predicate.kind().skip_binder() {\n+                continue;\n+            }\n+            let pred = obligation.predicate;\n+            // Match the existing behavior.\n+            if pred.is_global() && !pred.has_late_bound_regions() {\n+                let pred = self.normalize(span, None, pred);\n+                let hir_node = tcx.hir().find(self.body_id);\n \n-            // only use the span of the predicate clause (#90869)\n+                // only use the span of the predicate clause (#90869)\n \n-            if let Some(hir::Generics { predicates, .. }) =\n-                hir_node.and_then(|node| node.generics())\n-            {\n-                let obligation_span = obligation.cause.span();\n-\n-                span = predicates\n-                    .iter()\n-                    // There seems to be no better way to find out which predicate we are in\n-                    .find(|pred| pred.span().contains(obligation_span))\n-                    .map(|pred| pred.span())\n-                    .unwrap_or(obligation_span);\n-            }\n+                if let Some(hir::Generics { predicates, .. }) =\n+                    hir_node.and_then(|node| node.generics())\n+                {\n+                    let obligation_span = obligation.cause.span();\n+\n+                    span = predicates\n+                        .iter()\n+                        // There seems to be no better way to find out which predicate we are in\n+                        .find(|pred| pred.span().contains(obligation_span))\n+                        .map(|pred| pred.span())\n+                        .unwrap_or(obligation_span);\n+                }\n \n-            let obligation = traits::Obligation::new(\n-                traits::ObligationCause::new(span, id, traits::TrivialBound),\n-                empty_env,\n-                pred,\n-            );\n-            fcx.register_predicate(obligation);\n+                let obligation = traits::Obligation::new(\n+                    traits::ObligationCause::new(span, self.body_id, traits::TrivialBound),\n+                    empty_env,\n+                    pred,\n+                );\n+                self.ocx.register_obligation(obligation);\n+            }\n         }\n     }\n-\n-    fcx.select_all_obligations_or_error();\n }\n \n fn check_mod_type_wf(tcx: TyCtxt<'_>, module: LocalDefId) {\n@@ -1887,17 +1882,16 @@ struct AdtField<'tcx> {\n     span: Span,\n }\n \n-impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> WfCheckingCtxt<'a, 'tcx> {\n     // FIXME(eddyb) replace this with getting fields through `ty::AdtDef`.\n     fn non_enum_variant(&self, struct_def: &hir::VariantData<'_>) -> AdtVariant<'tcx> {\n         let fields = struct_def\n             .fields()\n             .iter()\n             .map(|field| {\n-                let def_id = self.tcx.hir().local_def_id(field.hir_id);\n-                let field_ty = self.tcx.type_of(def_id);\n-                let field_ty = self.normalize_associated_types_in(field.ty.span, field_ty);\n-                let field_ty = self.resolve_vars_if_possible(field_ty);\n+                let def_id = self.tcx().hir().local_def_id(field.hir_id);\n+                let field_ty = self.tcx().type_of(def_id);\n+                let field_ty = self.normalize(field.ty.span, None, field_ty);\n                 debug!(\"non_enum_variant: type of field {:?} is {:?}\", field, field_ty);\n                 AdtField { ty: field_ty, span: field.ty.span, def_id }\n             })\n@@ -1913,32 +1907,44 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 fields: self.non_enum_variant(&variant.data).fields,\n                 explicit_discr: variant\n                     .disr_expr\n-                    .map(|explicit_discr| self.tcx.hir().local_def_id(explicit_discr.hir_id)),\n+                    .map(|explicit_discr| self.tcx().hir().local_def_id(explicit_discr.hir_id)),\n             })\n             .collect()\n     }\n+}\n \n-    pub(super) fn impl_implied_bounds(\n-        &self,\n-        impl_def_id: DefId,\n-        span: Span,\n-    ) -> FxHashSet<Ty<'tcx>> {\n-        match self.tcx.impl_trait_ref(impl_def_id) {\n+pub(super) fn impl_implied_bounds<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    impl_def_id: LocalDefId,\n+    span: Span,\n+) -> FxHashSet<Ty<'tcx>> {\n+    // We completely ignore any obligations caused by normalizing the types\n+    // we assume to be well formed. Considering that the user of the implied\n+    // bounds will also normalize them, we leave it to them to emit errors\n+    // which should result in better causes and spans.\n+    tcx.infer_ctxt().enter(|infcx| {\n+        let cause = ObligationCause::misc(span, tcx.hir().local_def_id_to_hir_id(impl_def_id));\n+        match tcx.impl_trait_ref(impl_def_id) {\n             Some(trait_ref) => {\n                 // Trait impl: take implied bounds from all types that\n                 // appear in the trait reference.\n-                let trait_ref = self.normalize_associated_types_in(span, trait_ref);\n-                trait_ref.substs.types().collect()\n+                match infcx.at(&cause, param_env).normalize(trait_ref) {\n+                    Ok(Normalized { value, obligations: _ }) => value.substs.types().collect(),\n+                    Err(NoSolution) => FxHashSet::default(),\n+                }\n             }\n \n             None => {\n                 // Inherent impl: take implied bounds from the `self` type.\n-                let self_ty = self.tcx.type_of(impl_def_id);\n-                let self_ty = self.normalize_associated_types_in(span, self_ty);\n-                FxHashSet::from_iter([self_ty])\n+                let self_ty = tcx.type_of(impl_def_id);\n+                match infcx.at(&cause, param_env).normalize(self_ty) {\n+                    Ok(Normalized { value, obligations: _ }) => FxHashSet::from_iter([value]),\n+                    Err(NoSolution) => FxHashSet::default(),\n+                }\n             }\n         }\n-    }\n+    })\n }\n \n fn error_392("}, {"sha": "a92c37ff143b4cd76a55e6996550b3bef130cdf2", "filename": "compiler/rustc_typeck/src/coherence/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/23e21bdd25026e2839ebe946c2a937c1904887d2/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23e21bdd25026e2839ebe946c2a937c1904887d2/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=23e21bdd25026e2839ebe946c2a937c1904887d2", "patch": "@@ -349,7 +349,7 @@ fn visit_implementation_of_dispatch_from_dyn<'tcx>(tcx: TyCtxt<'tcx>, impl_did:\n \n                     // Finally, resolve all regions.\n                     let outlives_env = OutlivesEnvironment::new(param_env);\n-                    infcx.resolve_regions_and_report_errors(&outlives_env);\n+                    infcx.resolve_regions_and_report_errors(impl_did, &outlives_env);\n                 }\n             }\n             _ => {\n@@ -606,7 +606,7 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n \n         // Finally, resolve all regions.\n         let outlives_env = OutlivesEnvironment::new(param_env);\n-        infcx.resolve_regions_and_report_errors(&outlives_env);\n+        infcx.resolve_regions_and_report_errors(impl_did, &outlives_env);\n \n         CoerceUnsizedInfo { custom_kind: kind }\n     })"}, {"sha": "6ece955de643c169649b14aabb80a023d096c3d3", "filename": "compiler/rustc_typeck/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/23e21bdd25026e2839ebe946c2a937c1904887d2/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23e21bdd25026e2839ebe946c2a937c1904887d2/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=23e21bdd25026e2839ebe946c2a937c1904887d2", "patch": "@@ -150,7 +150,7 @@ fn get_impl_substs<'tcx>(\n \n     // Conservatively use an empty `ParamEnv`.\n     let outlives_env = OutlivesEnvironment::new(ty::ParamEnv::empty());\n-    infcx.resolve_regions_and_report_errors(&outlives_env);\n+    infcx.resolve_regions_and_report_errors(impl1_def_id, &outlives_env);\n     let Ok(impl2_substs) = infcx.fully_resolve(impl2_substs) else {\n         let span = tcx.def_span(impl1_def_id);\n         tcx.sess.emit_err(SubstsOnOverriddenImpl { span });"}, {"sha": "95cf4fb168f1e5d25469411e38a2dce09511c059", "filename": "src/test/ui/fn/implied-bounds-unnorm-associated-type-3.stderr", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/23e21bdd25026e2839ebe946c2a937c1904887d2/src%2Ftest%2Fui%2Ffn%2Fimplied-bounds-unnorm-associated-type-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/23e21bdd25026e2839ebe946c2a937c1904887d2/src%2Ftest%2Fui%2Ffn%2Fimplied-bounds-unnorm-associated-type-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffn%2Fimplied-bounds-unnorm-associated-type-3.stderr?ref=23e21bdd25026e2839ebe946c2a937c1904887d2", "patch": "@@ -2,10 +2,12 @@ error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/implied-bounds-unnorm-associated-type-3.rs:19:5\n    |\n LL |     fn zero_copy_from<'b>(cart: &'b [T]) -> &'b [T] {\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `[T]` will meet its required lifetime bounds\n    |\n-   = help: consider adding an explicit lifetime bound `T: 'static`...\n-   = note: ...so that the type `[T]` will meet its required lifetime bounds\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | impl<T: 'static> ZeroCopyFrom<[T]> for &'static [T] {\n+   |       +++++++++\n \n error: aborting due to previous error\n "}, {"sha": "389f82e794be71289067ebbeac79ffb135dcbac1", "filename": "src/test/ui/regions/regions-normalize-in-where-clause-list.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/23e21bdd25026e2839ebe946c2a937c1904887d2/src%2Ftest%2Fui%2Fregions%2Fregions-normalize-in-where-clause-list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23e21bdd25026e2839ebe946c2a937c1904887d2/src%2Ftest%2Fui%2Fregions%2Fregions-normalize-in-where-clause-list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-normalize-in-where-clause-list.rs?ref=23e21bdd25026e2839ebe946c2a937c1904887d2", "patch": "@@ -23,7 +23,6 @@ where\n // Here we get an error: we need `'a: 'b`.\n fn bar<'a, 'b>()\n //~^ ERROR cannot infer\n-//~| ERROR cannot infer\n where\n     <() as Project<'a, 'b>>::Item: Eq,\n {"}, {"sha": "5672837290cb18041b62d729d91ee32455807eb5", "filename": "src/test/ui/regions/regions-normalize-in-where-clause-list.stderr", "status": "modified", "additions": 1, "deletions": 33, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/23e21bdd25026e2839ebe946c2a937c1904887d2/src%2Ftest%2Fui%2Fregions%2Fregions-normalize-in-where-clause-list.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/23e21bdd25026e2839ebe946c2a937c1904887d2/src%2Ftest%2Fui%2Fregions%2Fregions-normalize-in-where-clause-list.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-normalize-in-where-clause-list.stderr?ref=23e21bdd25026e2839ebe946c2a937c1904887d2", "patch": "@@ -1,35 +1,3 @@\n-error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` due to conflicting requirements\n-  --> $DIR/regions-normalize-in-where-clause-list.rs:24:1\n-   |\n-LL | / fn bar<'a, 'b>()\n-LL | |\n-LL | |\n-LL | | where\n-LL | |     <() as Project<'a, 'b>>::Item: Eq,\n-   | |______________________________________^\n-   |\n-note: first, the lifetime cannot outlive the lifetime `'a` as defined here...\n-  --> $DIR/regions-normalize-in-where-clause-list.rs:24:8\n-   |\n-LL | fn bar<'a, 'b>()\n-   |        ^^\n-note: ...but the lifetime must also be valid for the lifetime `'b` as defined here...\n-  --> $DIR/regions-normalize-in-where-clause-list.rs:24:12\n-   |\n-LL | fn bar<'a, 'b>()\n-   |            ^^\n-note: ...so that the types are compatible\n-  --> $DIR/regions-normalize-in-where-clause-list.rs:24:1\n-   |\n-LL | / fn bar<'a, 'b>()\n-LL | |\n-LL | |\n-LL | | where\n-LL | |     <() as Project<'a, 'b>>::Item: Eq,\n-   | |______________________________________^\n-   = note: expected `Project<'a, 'b>`\n-              found `Project<'_, '_>`\n-\n error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` due to conflicting requirements\n   --> $DIR/regions-normalize-in-where-clause-list.rs:24:4\n    |\n@@ -54,6 +22,6 @@ LL | fn bar<'a, 'b>()\n    = note: expected `Project<'a, 'b>`\n               found `Project<'_, '_>`\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0495`."}, {"sha": "cfb9007c7a28cd35639eabd340131b437df2789f", "filename": "src/test/ui/specialization/min_specialization/issue-79224.stderr", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/23e21bdd25026e2839ebe946c2a937c1904887d2/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fissue-79224.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/23e21bdd25026e2839ebe946c2a937c1904887d2/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fissue-79224.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fissue-79224.stderr?ref=23e21bdd25026e2839ebe946c2a937c1904887d2", "patch": "@@ -11,12 +11,10 @@ LL | impl<B: ?Sized + std::clone::Clone> Display for Cow<'_, B> {\n    |                +++++++++++++++++++\n \n error[E0277]: the trait bound `B: Clone` is not satisfied\n-  --> $DIR/issue-79224.rs:19:5\n+  --> $DIR/issue-79224.rs:19:12\n    |\n-LL | /     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-LL | |         write!(f, \"foo\")\n-LL | |     }\n-   | |_____^ the trait `Clone` is not implemented for `B`\n+LL |     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+   |            ^^^^^ the trait `Clone` is not implemented for `B`\n    |\n    = note: required because of the requirements on the impl of `ToOwned` for `B`\n help: consider further restricting this bound"}]}