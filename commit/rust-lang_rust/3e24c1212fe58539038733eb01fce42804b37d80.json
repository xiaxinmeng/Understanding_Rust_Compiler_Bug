{"sha": "3e24c1212fe58539038733eb01fce42804b37d80", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlMjRjMTIxMmZlNTg1MzkwMzg3MzNlYjAxZmNlNDI4MDRiMzdkODA=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-02-04T18:18:39Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-02-04T18:32:29Z"}, "message": "Refactor CPlace address handling", "tree": {"sha": "ef035543bb1009e6696990cdf7831d9a0a325051", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef035543bb1009e6696990cdf7831d9a0a325051"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e24c1212fe58539038733eb01fce42804b37d80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e24c1212fe58539038733eb01fce42804b37d80", "html_url": "https://github.com/rust-lang/rust/commit/3e24c1212fe58539038733eb01fce42804b37d80", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e24c1212fe58539038733eb01fce42804b37d80/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0d16dcfce11ef524f34f8179352d2dc701808cfc", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d16dcfce11ef524f34f8179352d2dc701808cfc", "html_url": "https://github.com/rust-lang/rust/commit/0d16dcfce11ef524f34f8179352d2dc701808cfc"}], "stats": {"total": 146, "additions": 72, "deletions": 74}, "files": [{"sha": "450e32011d749be842ebee5e17fbacc847c8247d", "filename": "src/abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e24c1212fe58539038733eb01fce42804b37d80/src%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e24c1212fe58539038733eb01fce42804b37d80/src%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi.rs?ref=3e24c1212fe58539038733eb01fce42804b37d80", "patch": "@@ -606,7 +606,7 @@ pub fn codegen_call_inner<'a, 'tcx: 'a>(\n     let return_ptr = match output_pass_mode {\n         PassMode::NoPass => None,\n         PassMode::ByRef => match ret_place {\n-            Some(ret_place) => Some(ret_place.expect_addr()),\n+            Some(ret_place) => Some(ret_place.cplace_to_addr(fx)),\n             None => Some(fx.bcx.ins().iconst(fx.pointer_type, 0)),\n         },\n         PassMode::ByVal(_) => None,"}, {"sha": "3ac41393c6a100cc55a1a162c1876ec6472c4d7e", "filename": "src/base.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3e24c1212fe58539038733eb01fce42804b37d80/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e24c1212fe58539038733eb01fce42804b37d80/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=3e24c1212fe58539038733eb01fce42804b37d80", "patch": "@@ -688,10 +688,9 @@ fn codegen_array_len<'a, 'tcx: 'a>(\n             let len = crate::constant::force_eval_const(fx, len).unwrap_usize(fx.tcx) as i64;\n             fx.bcx.ins().iconst(fx.pointer_type, len)\n         }\n-        ty::Slice(_elem_ty) => match place {\n-            CPlace::Addr(_, size, _) => size.unwrap(),\n-            CPlace::Var(_, _) => unreachable!(),\n-        },\n+        ty::Slice(_elem_ty) => {\n+            place.to_addr_maybe_unsized(fx).1.expect(\"Length metadata for slice place\")\n+        }\n         _ => bug!(\"Rvalue::Len({:?})\", place),\n     }\n }"}, {"sha": "12102175213f0805f06108d22c84d4908a645fd7", "filename": "src/common.rs", "status": "modified", "additions": 68, "deletions": 69, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/3e24c1212fe58539038733eb01fce42804b37d80/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e24c1212fe58539038733eb01fce42804b37d80/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=3e24c1212fe58539038733eb01fce42804b37d80", "patch": "@@ -293,10 +293,19 @@ impl<'a, 'tcx: 'a> CPlace<'tcx> {\n         }\n     }\n \n-    pub fn expect_addr(self) -> Value {\n+    pub fn cplace_to_addr(self, fx: &mut FunctionCx<'a, 'tcx, impl Backend>) -> Value {\n+        match self.to_addr_maybe_unsized(fx) {\n+            (addr, None) => addr,\n+            (_, Some(_)) => bug!(\"Expected sized cplace, found {:?}\", self),\n+        }\n+    }\n+\n+    pub fn to_addr_maybe_unsized(\n+        self,\n+        fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n+    ) -> (Value, Option<Value>) {\n         match self {\n-            CPlace::Addr(addr, None, _layout) => addr,\n-            CPlace::Addr(_, _, _) => bug!(\"Expected sized CPlace::Addr, found {:?}\", self),\n+            CPlace::Addr(addr, extra, _layout) => (addr, extra),\n             CPlace::Var(_, _) => bug!(\"Expected CPlace::Addr, found CPlace::Var\"),\n         }\n     }\n@@ -347,31 +356,32 @@ impl<'a, 'tcx: 'a> CPlace<'tcx> {\n             }\n         }\n \n-        match self {\n+        let (addr, dst_layout) = match self {\n             CPlace::Var(var, _) => {\n                 let data = from.load_scalar(fx);\n-                fx.bcx.def_var(mir_var(var), data)\n-            }\n-            CPlace::Addr(addr, None, dst_layout) => {\n-                match from {\n-                    CValue::ByVal(val, _src_layout) => {\n-                        fx.bcx.ins().store(MemFlags::new(), val, addr, 0);\n-                    }\n-                    CValue::ByValPair(val1, val2, _src_layout) => {\n-                        let val1_offset = dst_layout.fields.offset(0).bytes() as i32;\n-                        let val2_offset = dst_layout.fields.offset(1).bytes() as i32;\n-                        fx.bcx.ins().store(MemFlags::new(), val1, addr, val1_offset);\n-                        fx.bcx.ins().store(MemFlags::new(), val2, addr, val2_offset);\n-                    }\n-                    CValue::ByRef(from, src_layout) => {\n-                        let size = dst_layout.size.bytes();\n-                        let src_align = src_layout.align.abi.bytes() as u8;\n-                        let dst_align = dst_layout.align.abi.bytes() as u8;\n-                        fx.bcx.emit_small_memcpy(fx.module.target_config(), addr, from, size, dst_align, src_align);\n-                    }\n-                }\n+                fx.bcx.def_var(mir_var(var), data);\n+                return;\n             }\n+            CPlace::Addr(addr, None, dst_layout) => (addr, dst_layout),\n             CPlace::Addr(_, _, _) => bug!(\"Can't write value to unsized place {:?}\", self),\n+        };\n+\n+        match from {\n+            CValue::ByVal(val, _src_layout) => {\n+                fx.bcx.ins().store(MemFlags::new(), val, addr, 0);\n+            }\n+            CValue::ByValPair(val1, val2, _src_layout) => {\n+                let val1_offset = dst_layout.fields.offset(0).bytes() as i32;\n+                let val2_offset = dst_layout.fields.offset(1).bytes() as i32;\n+                fx.bcx.ins().store(MemFlags::new(), val1, addr, val1_offset);\n+                fx.bcx.ins().store(MemFlags::new(), val2, addr, val2_offset);\n+            }\n+            CValue::ByRef(from, src_layout) => {\n+                let size = dst_layout.size.bytes();\n+                let src_align = src_layout.align.abi.bytes() as u8;\n+                let dst_align = dst_layout.align.abi.bytes() as u8;\n+                fx.bcx.emit_small_memcpy(fx.module.target_config(), addr, from, size, dst_align, src_align);\n+            }\n         }\n     }\n \n@@ -380,25 +390,17 @@ impl<'a, 'tcx: 'a> CPlace<'tcx> {\n         fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n         field: mir::Field,\n     ) -> CPlace<'tcx> {\n-        match self {\n-            CPlace::Var(var, layout) => {\n-                bug!(\n-                    \"Tried to project {:?}, which is put in SSA var {:?}\",\n-                    layout.ty,\n-                    var\n-                );\n-            }\n-            CPlace::Addr(base, extra, layout) => {\n-                let (field_ptr, field_layout) = codegen_field(fx, base, layout, field);\n-                let extra = if field_layout.is_unsized() {\n-                    assert!(extra.is_some());\n-                    extra\n-                } else {\n-                    None\n-                };\n-                CPlace::Addr(field_ptr, extra, field_layout)\n-            }\n-        }\n+        let layout = self.layout();\n+        let (base, extra) = self.to_addr_maybe_unsized(fx);\n+\n+        let (field_ptr, field_layout) = codegen_field(fx, base, layout, field);\n+        let extra = if field_layout.is_unsized() {\n+            assert!(extra.is_some());\n+            extra\n+        } else {\n+            None\n+        };\n+        CPlace::Addr(field_ptr, extra, field_layout)\n     }\n \n     pub fn place_index(\n@@ -407,13 +409,10 @@ impl<'a, 'tcx: 'a> CPlace<'tcx> {\n         index: Value,\n     ) -> CPlace<'tcx> {\n         let (elem_layout, addr) = match self.layout().ty.sty {\n-            ty::Array(elem_ty, _) => (fx.layout_of(elem_ty), self.expect_addr()),\n+            ty::Array(elem_ty, _) => (fx.layout_of(elem_ty), self.cplace_to_addr(fx)),\n             ty::Slice(elem_ty) => (\n                 fx.layout_of(elem_ty),\n-                match self {\n-                    CPlace::Addr(addr, _, _) => addr,\n-                    CPlace::Var(_, _) => bug!(\"Expected CPlace::Addr found CPlace::Var\"),\n-                },\n+                self.to_addr_maybe_unsized(fx).0,\n             ),\n             _ => bug!(\"place_index({:?})\", self.layout().ty),\n         };\n@@ -433,7 +432,7 @@ impl<'a, 'tcx: 'a> CPlace<'tcx> {\n         } else {\n             match self.layout().abi {\n                 Abi::ScalarPair(ref a, ref b) => {\n-                    let addr = self.expect_addr();\n+                    let addr = self.cplace_to_addr(fx);\n                     let ptr =\n                         fx.bcx\n                             .ins()\n@@ -456,28 +455,28 @@ impl<'a, 'tcx: 'a> CPlace<'tcx> {\n \n     pub fn write_place_ref(self, fx: &mut FunctionCx<'a, 'tcx, impl Backend>, dest: CPlace<'tcx>) {\n         if !self.layout().is_unsized() {\n-            let ptr = CValue::ByVal(self.expect_addr(), dest.layout());\n+            let ptr = CValue::ByVal(self.cplace_to_addr(fx), dest.layout());\n             dest.write_cvalue(fx, ptr);\n         } else {\n-            match self {\n-                CPlace::Var(_, _) => bug!(\"expected CPlace::Addr found CPlace::Var\"),\n-                CPlace::Addr(value, extra, _) => match dest.layout().abi {\n-                    Abi::ScalarPair(ref a, _) => {\n-                        fx.bcx\n-                            .ins()\n-                            .store(MemFlags::new(), value, dest.expect_addr(), 0);\n-                        fx.bcx.ins().store(\n-                            MemFlags::new(),\n-                            extra.expect(\"unsized type without metadata\"),\n-                            dest.expect_addr(),\n-                            a.value.size(&fx.tcx).bytes() as u32 as i32,\n-                        );\n-                    }\n-                    _ => bug!(\n-                        \"Non ScalarPair abi {:?} in write_place_ref dest\",\n-                        dest.layout().abi\n-                    ),\n-                },\n+            let (value, extra) = self.to_addr_maybe_unsized(fx);\n+\n+            match dest.layout().abi {\n+                Abi::ScalarPair(ref a, _) => {\n+                    let dest_addr = dest.cplace_to_addr(fx);\n+                    fx.bcx\n+                        .ins()\n+                        .store(MemFlags::new(), value, dest_addr, 0);\n+                    fx.bcx.ins().store(\n+                        MemFlags::new(),\n+                        extra.expect(\"unsized type without metadata\"),\n+                        dest_addr,\n+                        a.value.size(&fx.tcx).bytes() as u32 as i32,\n+                    );\n+                }\n+                _ => bug!(\n+                    \"Non ScalarPair abi {:?} in write_place_ref dest\",\n+                    dest.layout().abi\n+                ),\n             }\n         }\n     }"}]}