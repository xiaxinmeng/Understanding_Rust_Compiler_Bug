{"sha": "05b6df49b86024eb4f41fb94478ad9cd80dc172c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1YjZkZjQ5Yjg2MDI0ZWI0ZjQxZmI5NDQ3OGFkOWNkODBkYzE3MmM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-01-22T15:02:40Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-01-28T18:01:59Z"}, "message": "Refactor to make inference code around unification more readable\n\nr=brson", "tree": {"sha": "1f8bd54e681d87904c0534048ae92e33f27f2aa1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f8bd54e681d87904c0534048ae92e33f27f2aa1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/05b6df49b86024eb4f41fb94478ad9cd80dc172c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/05b6df49b86024eb4f41fb94478ad9cd80dc172c", "html_url": "https://github.com/rust-lang/rust/commit/05b6df49b86024eb4f41fb94478ad9cd80dc172c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/05b6df49b86024eb4f41fb94478ad9cd80dc172c/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "923b3154c6b69748e951b04d874b7a28eb3cedf9", "url": "https://api.github.com/repos/rust-lang/rust/commits/923b3154c6b69748e951b04d874b7a28eb3cedf9", "html_url": "https://github.com/rust-lang/rust/commit/923b3154c6b69748e951b04d874b7a28eb3cedf9"}], "stats": {"total": 618, "additions": 335, "deletions": 283}, "files": [{"sha": "0726104788cda55721c063580124e6a39cf13188", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 39, "deletions": 55, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/05b6df49b86024eb4f41fb94478ad9cd80dc172c/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05b6df49b86024eb4f41fb94478ad9cd80dc172c/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=05b6df49b86024eb4f41fb94478ad9cd80dc172c", "patch": "@@ -55,7 +55,7 @@ export ProvidedMethodSource;\n export ProvidedMethodInfo;\n export ProvidedMethodsMap;\n export InstantiatedTraitRef;\n-export TyVid, IntVid, FloatVid, FnVid, RegionVid, Vid;\n+export TyVid, IntVid, FloatVid, RegionVid, Vid;\n export br_hashmap;\n export is_instantiable;\n export node_id_to_type;\n@@ -215,7 +215,7 @@ export ty_sort_str;\n export normalize_ty;\n export to_str;\n export bound_const;\n-export terr_no_integral_type, terr_no_floating_point_type;\n+export terr_int_mismatch, terr_float_mismatch, terr_sigil_mismatch;\n export terr_ty_param_size, terr_self_substs;\n export terr_in_field, terr_record_fields, terr_vstores_differ, terr_arg_count;\n export terr_sorts, terr_vec, terr_str, terr_record_size, terr_tuple_size;\n@@ -241,6 +241,7 @@ export AutoRef;\n export AutoRefKind, AutoPtr, AutoBorrowVec, AutoBorrowVecRef, AutoBorrowFn;\n export iter_bound_traits_and_supertraits;\n export count_traits_and_supertraits;\n+export IntVarValue, IntType, UintType;\n \n // Data types\n \n@@ -703,6 +704,12 @@ enum sty {\n     ty_unboxed_vec(mt),\n }\n \n+#[deriving_eq]\n+enum IntVarValue {\n+    IntType(ast::int_ty),\n+    UintType(ast::uint_ty),\n+}\n+\n enum terr_vstore_kind {\n     terr_vec, terr_str, terr_fn, terr_trait\n }\n@@ -740,8 +747,8 @@ enum type_err {\n     terr_sorts(expected_found<t>),\n     terr_self_substs,\n     terr_integer_as_char,\n-    terr_no_integral_type,\n-    terr_no_floating_point_type,\n+    terr_int_mismatch(expected_found<IntVarValue>),\n+    terr_float_mismatch(expected_found<ast::float_ty>)\n }\n \n enum param_bound {\n@@ -752,10 +759,16 @@ enum param_bound {\n     bound_trait(t),\n }\n \n+#[deriving_eq]\n enum TyVid = uint;\n+\n+#[deriving_eq]\n enum IntVid = uint;\n+\n+#[deriving_eq]\n enum FloatVid = uint;\n-enum FnVid = uint;\n+\n+#[deriving_eq]\n #[auto_encode]\n #[auto_decode]\n enum RegionVid = uint;\n@@ -851,14 +864,6 @@ impl FloatVid: ToStr {\n     pure fn to_str() -> ~str { fmt!(\"<VF%u>\", self.to_uint()) }\n }\n \n-impl FnVid: Vid {\n-    pure fn to_uint() -> uint { *self }\n-}\n-\n-impl FnVid: ToStr {\n-    pure fn to_str() -> ~str { fmt!(\"<F%u>\", self.to_uint()) }\n-}\n-\n impl RegionVid: Vid {\n     pure fn to_uint() -> uint { *self }\n }\n@@ -884,33 +889,36 @@ impl InferTy: ToStr {\n     }\n }\n \n-impl RegionVid : to_bytes::IterBytes {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n-        (**self).iter_bytes(lsb0, f)\n+impl IntVarValue : ToStr {\n+    pure fn to_str() -> ~str {\n+        match self {\n+            IntType(ref v) => v.to_str(),\n+            UintType(ref v) => v.to_str(),\n+        }\n     }\n }\n \n impl TyVid : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n-        (**self).iter_bytes(lsb0, f)\n+        self.to_uint().iter_bytes(lsb0, f)\n     }\n }\n \n impl IntVid : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n-        (**self).iter_bytes(lsb0, f)\n+        self.to_uint().iter_bytes(lsb0, f)\n     }\n }\n \n impl FloatVid : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n-        (**self).iter_bytes(lsb0, f)\n+        self.to_uint().iter_bytes(lsb0, f)\n     }\n }\n \n-impl FnVid : to_bytes::IterBytes {\n+impl RegionVid : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n-        (**self).iter_bytes(lsb0, f)\n+        self.to_uint().iter_bytes(lsb0, f)\n     }\n }\n \n@@ -3575,17 +3583,18 @@ fn type_err_to_str(cx: ctxt, err: &type_err) -> ~str {\n         terr_self_substs => {\n             ~\"inconsistent self substitution\" // XXX this is more of a bug\n         }\n-        terr_no_integral_type => {\n-            ~\"couldn't determine an appropriate integral type for integer \\\n-              literal\"\n-        }\n         terr_integer_as_char => {\n-            ~\"integer literals can't be inferred to char type \\\n-              (try an explicit cast)\"\n+            fmt!(\"expected an integral type but found char\")\n         }\n-        terr_no_floating_point_type => {\n-            ~\"couldn't determine an appropriate floating point type for \\\n-              floating point literal\"\n+        terr_int_mismatch(ref values) => {\n+            fmt!(\"expected %s but found %s\",\n+                 values.expected.to_str(),\n+                 values.found.to_str())\n+        }\n+        terr_float_mismatch(ref values) => {\n+            fmt!(\"expected %s but found %s\",\n+                 values.expected.to_str(),\n+                 values.found.to_str())\n         }\n     }\n }\n@@ -4451,31 +4460,6 @@ impl vstore : cmp::Eq {\n     pure fn ne(&self, other: &vstore) -> bool { !(*self).eq(other) }\n }\n \n-impl TyVid : cmp::Eq {\n-    pure fn eq(&self, other: &TyVid) -> bool { *(*self) == *(*other) }\n-    pure fn ne(&self, other: &TyVid) -> bool { *(*self) != *(*other) }\n-}\n-\n-impl IntVid : cmp::Eq {\n-    pure fn eq(&self, other: &IntVid) -> bool { *(*self) == *(*other) }\n-    pure fn ne(&self, other: &IntVid) -> bool { *(*self) != *(*other) }\n-}\n-\n-impl FloatVid : cmp::Eq {\n-    pure fn eq(&self, other: &FloatVid) -> bool { *(*self) == *(*other) }\n-    pure fn ne(&self, other: &FloatVid) -> bool { *(*self) != *(*other) }\n-}\n-\n-impl FnVid : cmp::Eq {\n-    pure fn eq(&self, other: &FnVid) -> bool { *(*self) == *(*other) }\n-    pure fn ne(&self, other: &FnVid) -> bool { *(*self) != *(*other) }\n-}\n-\n-impl RegionVid : cmp::Eq {\n-    pure fn eq(&self, other: &RegionVid) -> bool { *(*self) == *(*other) }\n-    pure fn ne(&self, other: &RegionVid) -> bool { *(*self) != *(*other) }\n-}\n-\n impl Region : cmp::Eq {\n     pure fn eq(&self, other: &Region) -> bool {\n         match (*self) {"}, {"sha": "cd4514f6a2c5dca7c389ef962ce46814fde2d08d", "filename": "src/librustc/middle/typeck/infer/assignment.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/05b6df49b86024eb4f41fb94478ad9cd80dc172c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fassignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05b6df49b86024eb4f41fb94478ad9cd80dc172c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fassignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fassignment.rs?ref=05b6df49b86024eb4f41fb94478ad9cd80dc172c", "patch": "@@ -103,8 +103,8 @@ impl Assign {\n             }\n \n             (ty::ty_infer(TyVar(a_id)), ty::ty_infer(TyVar(b_id))) => {\n-                let nde_a = self.infcx.get(&self.infcx.ty_var_bindings, a_id);\n-                let nde_b = self.infcx.get(&self.infcx.ty_var_bindings, b_id);\n+                let nde_a = self.infcx.get(a_id);\n+                let nde_b = self.infcx.get(b_id);\n                 let a_bounds = nde_a.possible_types;\n                 let b_bounds = nde_b.possible_types;\n \n@@ -114,15 +114,15 @@ impl Assign {\n             }\n \n             (ty::ty_infer(TyVar(a_id)), _) => {\n-                let nde_a = self.infcx.get(&self.infcx.ty_var_bindings, a_id);\n+                let nde_a = self.infcx.get(a_id);\n                 let a_bounds = nde_a.possible_types;\n \n                 let a_bnd = option::or(a_bounds.ub, a_bounds.lb);\n                 self.assign_tys_or_sub(a, b, a_bnd, Some(b))\n             }\n \n             (_, ty::ty_infer(TyVar(b_id))) => {\n-                let nde_b = self.infcx.get(&self.infcx.ty_var_bindings, b_id);\n+                let nde_b = self.infcx.get(b_id);\n                 let b_bounds = nde_b.possible_types;\n \n                 let b_bnd = option::or(b_bounds.lb, b_bounds.ub);"}, {"sha": "e9946ae7c13e67f63e6730ac983c9f5ef345e0fc", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 71, "deletions": 50, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/05b6df49b86024eb4f41fb94478ad9cd80dc172c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05b6df49b86024eb4f41fb94478ad9cd80dc172c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=05b6df49b86024eb4f41fb94478ad9cd80dc172c", "patch": "@@ -57,6 +57,7 @@\n use core::prelude::*;\n \n use middle::ty::{FloatVar, FnTyBase, FnMeta, FnSig, IntVar, TyVar};\n+use middle::ty::{IntType, UintType};\n use middle::ty;\n use middle::typeck::infer::glb::Glb;\n use middle::typeck::infer::lub::Lub;\n@@ -112,8 +113,8 @@ pub struct CombineFields {\n }\n \n fn expected_found<C:Combine,T>(\n-    self: &C, +a: T, +b: T) -> ty::expected_found<T> {\n-\n+    self: &C, +a: T, +b: T) -> ty::expected_found<T>\n+{\n     if self.a_is_expected() {\n         ty::expected_found {expected: move a, found: move b}\n     } else {\n@@ -392,7 +393,7 @@ fn super_tys<C:Combine>(\n     self: &C, a: ty::t, b: ty::t) -> cres<ty::t>\n {\n     let tcx = self.infcx().tcx;\n-    match (/*bad*/copy ty::get(a).sty, /*bad*/copy ty::get(b).sty) {\n+    return match (/*bad*/copy ty::get(a).sty, /*bad*/copy ty::get(b).sty) {\n       // The \"subtype\" ought to be handling cases involving bot or var:\n       (ty::ty_bot, _) |\n       (_, ty::ty_bot) |\n@@ -405,53 +406,46 @@ fn super_tys<C:Combine>(\n                  b.inf_str(self.infcx())));\n       }\n \n-      // Relate integral variables to other types\n-      (ty::ty_infer(IntVar(a_id)), ty::ty_infer(IntVar(b_id))) => {\n-        if_ok!(self.infcx().simple_vars(&self.infcx().int_var_bindings,\n-                                        ty::terr_no_integral_type,\n-                                        a_id, b_id));\n-        Ok(a)\n-      }\n-      (ty::ty_infer(IntVar(v_id)), ty::ty_int(v)) |\n-      (ty::ty_int(v), ty::ty_infer(IntVar(v_id))) => {\n-        if v == ast::ty_char {\n-            Err(ty::terr_integer_as_char)\n-        } else {\n-            if_ok!(self.infcx().simple_var_t(&self.infcx().int_var_bindings,\n-                                             ty::terr_no_integral_type,\n-                                             v_id, IntType(v)));\n-            Ok(ty::mk_mach_int(tcx, v))\n+        // Relate integral variables to other types\n+        (ty::ty_infer(IntVar(a_id)), ty::ty_infer(IntVar(b_id))) => {\n+            if_ok!(self.infcx().simple_vars(self.a_is_expected(),\n+                                            a_id, b_id));\n+            Ok(a)\n+        }\n+        (ty::ty_infer(IntVar(v_id)), ty::ty_int(v)) => {\n+            unify_integral_variable(self, self.a_is_expected(),\n+                                    v_id, IntType(v))\n+        }\n+        (ty::ty_int(v), ty::ty_infer(IntVar(v_id))) => {\n+            unify_integral_variable(self, !self.a_is_expected(),\n+                                    v_id, IntType(v))\n+        }\n+        (ty::ty_infer(IntVar(v_id)), ty::ty_uint(v)) => {\n+            unify_integral_variable(self, self.a_is_expected(),\n+                                    v_id, UintType(v))\n+        }\n+        (ty::ty_uint(v), ty::ty_infer(IntVar(v_id))) => {\n+            unify_integral_variable(self, !self.a_is_expected(),\n+                                    v_id, UintType(v))\n         }\n-      }\n-      (ty::ty_infer(IntVar(v_id)), ty::ty_uint(v)) |\n-      (ty::ty_uint(v), ty::ty_infer(IntVar(v_id))) => {\n-        if_ok!(self.infcx().simple_var_t(&self.infcx().int_var_bindings,\n-                                         ty::terr_no_integral_type,\n-                                         v_id, UintType(v)));\n-        Ok(ty::mk_mach_uint(tcx, v))\n-      }\n \n-      // Relate floating-point variables to other types\n-      (ty::ty_infer(FloatVar(a_id)), ty::ty_infer(FloatVar(b_id))) => {\n-        if_ok!(self.infcx().simple_vars(&self.infcx().float_var_bindings,\n-                                        ty::terr_no_floating_point_type,\n-                                        a_id, b_id));\n-        Ok(a)\n-      }\n-      (ty::ty_infer(FloatVar(v_id)), ty::ty_float(v)) |\n-      (ty::ty_float(v), ty::ty_infer(FloatVar(v_id))) => {\n-        if_ok!(self.infcx().simple_var_t(&self.infcx().float_var_bindings,\n-                                         ty::terr_no_floating_point_type,\n-                                         v_id, v));\n-        Ok(ty::mk_mach_float(tcx, v))\n-      }\n+        // Relate floating-point variables to other types\n+        (ty::ty_infer(FloatVar(a_id)), ty::ty_infer(FloatVar(b_id))) => {\n+            if_ok!(self.infcx().simple_vars(self.a_is_expected(),\n+                                            a_id, b_id));\n+            Ok(a)\n+        }\n+        (ty::ty_infer(FloatVar(v_id)), ty::ty_float(v)) => {\n+            unify_float_variable(self, self.a_is_expected(), v_id, v)\n+        }\n+        (ty::ty_float(v), ty::ty_infer(FloatVar(v_id))) => {\n+            unify_float_variable(self, !self.a_is_expected(), v_id, v)\n+        }\n \n       (ty::ty_int(_), _) |\n       (ty::ty_uint(_), _) |\n       (ty::ty_float(_), _) => {\n-        let as_ = /*bad*/copy ty::get(a).sty;\n-        let bs = /*bad*/copy ty::get(b).sty;\n-        if as_ == bs {\n+        if ty::get(a).sty == ty::get(b).sty {\n             Ok(a)\n         } else {\n             Err(ty::terr_sorts(expected_found(self, a, b)))\n@@ -516,11 +510,9 @@ fn super_tys<C:Combine>(\n       }\n \n       (ty::ty_rptr(a_r, a_mt), ty::ty_rptr(b_r, b_mt)) => {\n-        do self.contraregions(a_r, b_r).chain |r| {\n-            do self.mts(a_mt, b_mt).chain |mt| {\n-                Ok(ty::mk_rptr(tcx, r, mt))\n-            }\n-        }\n+          let r = if_ok!(self.contraregions(a_r, b_r));\n+          let mt = if_ok!(self.mts(a_mt, b_mt));\n+          Ok(ty::mk_rptr(tcx, r, mt))\n       }\n \n       (ty::ty_evec(a_mt, vs_a), ty::ty_evec(b_mt, vs_b)) => {\n@@ -565,5 +557,34 @@ fn super_tys<C:Combine>(\n       }\n \n       _ => Err(ty::terr_sorts(expected_found(self, a, b)))\n+    };\n+\n+    fn unify_integral_variable<C:Combine>(\n+        self: &C,\n+        vid_is_expected: bool,\n+        vid: ty::IntVid,\n+        val: ty::IntVarValue) -> cres<ty::t>\n+    {\n+        let tcx = self.infcx().tcx;\n+        if val == IntType(ast::ty_char) {\n+            Err(ty::terr_integer_as_char)\n+        } else {\n+            if_ok!(self.infcx().simple_var_t(vid_is_expected, vid, val));\n+            match val {\n+                IntType(v) => Ok(ty::mk_mach_int(tcx, v)),\n+                UintType(v) => Ok(ty::mk_mach_uint(tcx, v))\n+            }\n+        }\n     }\n-}\n+\n+    fn unify_float_variable<C:Combine>(\n+        self: &C,\n+        vid_is_expected: bool,\n+        vid: ty::FloatVid,\n+        val: ast::float_ty) -> cres<ty::t>\n+    {\n+        let tcx = self.infcx().tcx;\n+        if_ok!(self.infcx().simple_var_t(vid_is_expected, vid, val));\n+        Ok(ty::mk_mach_float(tcx, val))\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "6ae10b120fe720dcede170aa117b6463f515ed20", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 29, "deletions": 35, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/05b6df49b86024eb4f41fb94478ad9cd80dc172c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05b6df49b86024eb4f41fb94478ad9cd80dc172c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=05b6df49b86024eb4f41fb94478ad9cd80dc172c", "patch": "@@ -89,9 +89,9 @@ impl FnMeta: LatticeValue {\n }\n \n impl CombineFields {\n-    fn var_sub_var<V:Copy Eq Vid ToStr, T:Copy InferStr LatticeValue>(\n+    fn var_sub_var<T:Copy InferStr LatticeValue,\n+                   V:Copy Eq ToStr Vid UnifyVid<Bounds<T>>>(\n         &self,\n-        vb: &ValsAndBindings<V, Bounds<T>>,\n         +a_id: V,\n         +b_id: V) -> ures\n     {\n@@ -102,8 +102,8 @@ impl CombineFields {\n          * top of infer.rs*/\n \n         // Need to make sub_id a subtype of sup_id.\n-        let node_a = self.infcx.get(vb, a_id);\n-        let node_b = self.infcx.get(vb, b_id);\n+        let node_a = self.infcx.get(a_id);\n+        let node_b = self.infcx.get(b_id);\n         let a_id = node_a.root;\n         let b_id = node_b.root;\n         let a_bounds = node_a.possible_types;\n@@ -135,25 +135,25 @@ impl CombineFields {\n         // A remains a subtype of B.  Actually, there are other options,\n         // but that's the route we choose to take.\n \n-        self.infcx.unify(vb, &node_a, &node_b, |new_root, new_rank| {\n-            self.set_var_to_merged_bounds(vb, new_root,\n+        self.infcx.unify(&node_a, &node_b, |new_root, new_rank| {\n+            self.set_var_to_merged_bounds(new_root,\n                                           &a_bounds, &b_bounds,\n                                           new_rank)\n         })\n     }\n \n     /// make variable a subtype of T\n-    fn var_sub_t<V:Copy Eq Vid ToStr, T:Copy InferStr LatticeValue>(\n+    fn var_sub_t<T:Copy InferStr LatticeValue,\n+                 V:Copy Eq ToStr Vid UnifyVid<Bounds<T>>>(\n         &self,\n-        vb: &ValsAndBindings<V, Bounds<T>>,\n         +a_id: V,\n         +b: T) -> ures\n     {\n         /*!\n          *\n          * Make a variable (`a_id`) a subtype of the concrete type `b` */\n \n-        let node_a = self.infcx.get(vb, a_id);\n+        let node_a = self.infcx.get(a_id);\n         let a_id = node_a.root;\n         let a_bounds = &node_a.possible_types;\n         let b_bounds = &{lb: None, ub: Some(b)};\n@@ -164,12 +164,12 @@ impl CombineFields {\n                b.inf_str(self.infcx));\n \n         self.set_var_to_merged_bounds(\n-            vb, a_id, a_bounds, b_bounds, node_a.rank)\n+            a_id, a_bounds, b_bounds, node_a.rank)\n     }\n \n-    fn t_sub_var<V:Copy Eq Vid ToStr, T:Copy InferStr LatticeValue>(\n+    fn t_sub_var<T:Copy InferStr LatticeValue,\n+                 V:Copy Eq ToStr Vid UnifyVid<Bounds<T>>>(\n         &self,\n-        vb: &ValsAndBindings<V, Bounds<T>>,\n         +a: T,\n         +b_id: V) -> ures\n     {\n@@ -178,7 +178,7 @@ impl CombineFields {\n          * Make a concrete type (`a`) a subtype of the variable `b_id` */\n \n         let a_bounds = &{lb: Some(a), ub: None};\n-        let node_b = self.infcx.get(vb, b_id);\n+        let node_b = self.infcx.get(b_id);\n         let b_id = node_b.root;\n         let b_bounds = &node_b.possible_types;\n \n@@ -188,7 +188,7 @@ impl CombineFields {\n                b_bounds.inf_str(self.infcx));\n \n         self.set_var_to_merged_bounds(\n-            vb, b_id, a_bounds, b_bounds, node_b.rank)\n+            b_id, a_bounds, b_bounds, node_b.rank)\n     }\n \n     fn merge_bnd<T:Copy InferStr LatticeValue>(\n@@ -219,10 +219,9 @@ impl CombineFields {\n         }\n     }\n \n-    fn set_var_to_merged_bounds<V:Copy Eq Vid ToStr,\n-                                T:Copy InferStr LatticeValue>(\n+    fn set_var_to_merged_bounds<T:Copy InferStr LatticeValue,\n+                                V:Copy Eq ToStr Vid UnifyVid<Bounds<T>>>(\n         &self,\n-        vb: &ValsAndBindings<V, Bounds<T>>,\n         +v_id: V,\n         a: &Bounds<T>,\n         b: &Bounds<T>,\n@@ -278,7 +277,7 @@ impl CombineFields {\n         // the new bounds must themselves\n         // be relatable:\n         let () = if_ok!(self.bnds(&bounds.lb, &bounds.ub));\n-        self.infcx.set(vb, v_id, Root(bounds, rank));\n+        self.infcx.set(v_id, Root(bounds, rank));\n         uok()\n     }\n \n@@ -369,8 +368,7 @@ fn super_lattice_tys<L:LatticeDir TyLatticeDir Combine>(\n         (_, ty::ty_bot) => { return self.ty_bot(a); }\n \n         (ty::ty_infer(TyVar(a_id)), ty::ty_infer(TyVar(b_id))) => {\n-            let r = if_ok!(lattice_vars(self, &self.infcx().ty_var_bindings,\n-                                        a_id, b_id,\n+            let r = if_ok!(lattice_vars(self, a_id, b_id,\n                                         |x, y| self.tys(*x, *y)));\n             return match r {\n                 VarResult(v) => Ok(ty::mk_var(tcx, v)),\n@@ -379,14 +377,12 @@ fn super_lattice_tys<L:LatticeDir TyLatticeDir Combine>(\n         }\n \n         (ty::ty_infer(TyVar(a_id)), _) => {\n-            return lattice_var_and_t(self, &self.infcx().ty_var_bindings,\n-                                     a_id, &b,\n+            return lattice_var_and_t(self, a_id, &b,\n                                      |x, y| self.tys(*x, *y));\n         }\n \n         (_, ty::ty_infer(TyVar(b_id))) => {\n-            return lattice_var_and_t(self, &self.infcx().ty_var_bindings,\n-                                     b_id, &a,\n+            return lattice_var_and_t(self, b_id, &a,\n                                      |x, y| self.tys(*x, *y));\n         }\n \n@@ -419,17 +415,16 @@ enum LatticeVarResult<V,T> {\n  *   result is a variable.  This is indicated with a `VarResult`\n  *   return. */\n fn lattice_vars<L:LatticeDir Combine,\n-                V:Copy Eq Vid ToStr,\n-                T:Copy InferStr LatticeValue>(\n+                T:Copy InferStr LatticeValue,\n+                V:Copy Eq ToStr Vid UnifyVid<Bounds<T>>>(\n     self: &L,                           // defines whether we want LUB or GLB\n-    vb: &ValsAndBindings<V, Bounds<T>>, // relevant variable bindings\n     +a_vid: V,                          // first variable\n     +b_vid: V,                          // second variable\n     lattice_dir_op: LatticeDirOp<T>)    // LUB or GLB operation on types\n     -> cres<LatticeVarResult<V,T>>\n {\n-    let nde_a = self.infcx().get(vb, a_vid);\n-    let nde_b = self.infcx().get(vb, b_vid);\n+    let nde_a = self.infcx().get(a_vid);\n+    let nde_b = self.infcx().get(b_vid);\n     let a_vid = nde_a.root;\n     let b_vid = nde_b.root;\n     let a_bounds = &nde_a.possible_types;\n@@ -461,22 +456,21 @@ fn lattice_vars<L:LatticeDir Combine,\n     // Otherwise, we need to merge A and B into one variable.  We can\n     // then use either variable as an upper bound:\n     let cf = self.combine_fields();\n-    do cf.var_sub_var(vb, a_vid, b_vid).then {\n+    do cf.var_sub_var(a_vid, b_vid).then {\n         Ok(VarResult(a_vid))\n     }\n }\n \n fn lattice_var_and_t<L:LatticeDir Combine,\n-                     V:Copy Eq Vid ToStr,\n-                     T:Copy InferStr LatticeValue>(\n+                     T:Copy InferStr LatticeValue,\n+                     V:Copy Eq ToStr Vid UnifyVid<Bounds<T>>>(\n     self: &L,\n-    vb: &ValsAndBindings<V, Bounds<T>>,\n     +a_id: V,\n     b: &T,\n     lattice_dir_op: LatticeDirOp<T>)\n     -> cres<T>\n {\n-    let nde_a = self.infcx().get(vb, a_id);\n+    let nde_a = self.infcx().get(a_id);\n     let a_id = nde_a.root;\n     let a_bounds = &nde_a.possible_types;\n \n@@ -501,7 +495,7 @@ fn lattice_var_and_t<L:LatticeDir Combine,\n             debug!(\"bnd=None\");\n             let a_bounds = self.with_bnd(a_bounds, *b);\n             do self.combine_fields().bnds(&a_bounds.lb, &a_bounds.ub).then {\n-                self.infcx().set(vb, a_id, Root(a_bounds, nde_a.rank));\n+                self.infcx().set(a_id, Root(a_bounds, nde_a.rank));\n                 Ok(*b)\n             }\n         }"}, {"sha": "b702448fbf474fdd69db13fda18f7ed31dd2aaa3", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 23, "deletions": 27, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/05b6df49b86024eb4f41fb94478ad9cd80dc172c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05b6df49b86024eb4f41fb94478ad9cd80dc172c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=05b6df49b86024eb4f41fb94478ad9cd80dc172c", "patch": "@@ -251,6 +251,7 @@ use core::prelude::*;\n use middle::ty::{TyVid, IntVid, FloatVid, RegionVid, Vid};\n use middle::ty::{mk_fn, type_is_bot};\n use middle::ty::{ty_int, ty_uint, get, terr_fn, TyVar, IntVar, FloatVar};\n+use middle::ty::IntVarValue;\n use middle::ty;\n use middle::typeck::check::regionmanip::{replace_bound_regions_in_fn_sig};\n use middle::typeck::infer::assignment::Assign;\n@@ -351,35 +352,21 @@ type ures = cres<()>; // \"unify result\"\n type fres<T> = Result<T, fixup_err>; // \"fixup result\"\n type ares = cres<Option<@ty::AutoAdjustment>>; // \"assignment result\"\n \n-#[deriving_eq]\n-enum IntVarValue {\n-    IntType(ast::int_ty),\n-    UintType(ast::uint_ty),\n-}\n-\n struct InferCtxt {\n     tcx: ty::ctxt,\n \n     // We instantiate ValsAndBindings with bounds<ty::t> because the\n     // types that might instantiate a general type variable have an\n     // order, represented by its upper and lower bounds.\n     ty_var_bindings: ValsAndBindings<ty::TyVid, Bounds<ty::t>>,\n-\n-    // Number of type variables created thus far.\n     mut ty_var_counter: uint,\n \n-    // The types that might instantiate an integral type variable are\n-    // represented by an int_ty_set.\n+    // Map from integral variable to the kind of integer it represents\n     int_var_bindings: ValsAndBindings<ty::IntVid, Option<IntVarValue>>,\n-\n-    // Number of integral variables created thus far.\n     mut int_var_counter: uint,\n \n-    // The types that might instantiate a floating-point type variable are\n-    // represented by an float_ty_set.\n+    // Map from floating variable to the kind of float it represents\n     float_var_bindings: ValsAndBindings<ty::FloatVid, Option<ast::float_ty>>,\n-\n-    // Number of floating-point variables created thus far.\n     mut float_var_counter: uint,\n \n     // For region variables.\n@@ -582,6 +569,7 @@ fn rollback_to<V:Copy Vid, T:Copy>(\n struct Snapshot {\n     ty_var_bindings_len: uint,\n     int_var_bindings_len: uint,\n+    float_var_bindings_len: uint,\n     region_vars_snapshot: uint,\n }\n \n@@ -607,6 +595,8 @@ impl @InferCtxt {\n                 self.ty_var_bindings.bindings.len(),\n             int_var_bindings_len:\n                 self.int_var_bindings.bindings.len(),\n+            float_var_bindings_len:\n+                self.float_var_bindings.bindings.len(),\n             region_vars_snapshot:\n                 self.region_vars.start_snapshot(),\n         }\n@@ -616,9 +606,11 @@ impl @InferCtxt {\n         debug!(\"rollback!\");\n         rollback_to(&self.ty_var_bindings, snapshot.ty_var_bindings_len);\n \n-        // FIXME(#3211) -- int_var not transactional\n+        // FIXME(#3211) -- int_var and float_var not transactional\n         //rollback_to(&self.int_var_bindings,\n         //            snapshot.int_var_bindings_len);\n+        //rollback_to(&self.float_var_bindings,\n+        //            snapshot.float_var_bindings_len);\n \n         self.region_vars.rollback_to(snapshot.region_vars_snapshot);\n     }\n@@ -664,6 +656,16 @@ impl @InferCtxt {\n     }\n }\n \n+fn next_simple_var<V: Copy,T: Copy>(\n+    +counter: &mut uint,\n+    +bindings: &ValsAndBindings<V,Option<T>>) -> uint\n+{\n+    let id = *counter;\n+    *counter += 1;\n+    bindings.vals.insert(id, Root(None, 0));\n+    return id;\n+}\n+\n impl @InferCtxt {\n     fn next_ty_var_id() -> TyVid {\n         let id = self.ty_var_counter;\n@@ -682,23 +684,17 @@ impl @InferCtxt {\n     }\n \n     fn next_int_var_id() -> IntVid {\n-        let id = self.int_var_counter;\n-        self.int_var_counter += 1;\n-\n-        self.int_var_bindings.vals.insert(id, Root(None, 0));\n-        return IntVid(id);\n+        IntVid(next_simple_var(&mut self.int_var_counter,\n+                               &self.int_var_bindings))\n     }\n \n     fn next_int_var() -> ty::t {\n         ty::mk_int_var(self.tcx, self.next_int_var_id())\n     }\n \n     fn next_float_var_id() -> FloatVid {\n-        let id = self.float_var_counter;\n-        self.float_var_counter += 1;\n-\n-        self.float_var_bindings.vals.insert(id, Root(None, 0));\n-        return FloatVid(id);\n+        FloatVid(next_simple_var(&mut self.float_var_counter,\n+                                 &self.float_var_bindings))\n     }\n \n     fn next_float_var() -> ty::t {"}, {"sha": "01f4b86b48858a55c04103986f0b4055ff3c7ec7", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/05b6df49b86024eb4f41fb94478ad9cd80dc172c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05b6df49b86024eb4f41fb94478ad9cd80dc172c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=05b6df49b86024eb4f41fb94478ad9cd80dc172c", "patch": "@@ -49,11 +49,10 @@\n use core::prelude::*;\n \n use middle::ty::{FloatVar, FloatVid, IntVar, IntVid, RegionVid, TyVar, TyVid};\n-use middle::ty::{type_is_bot};\n+use middle::ty::{type_is_bot, IntType, UintType};\n use middle::ty;\n use middle::typeck::infer::{cyclic_ty, fixup_err, fres, InferCtxt};\n use middle::typeck::infer::{region_var_bound_by_region_var, unresolved_ty};\n-use middle::typeck::infer::{IntType, UintType};\n use middle::typeck::infer::to_str::InferStr;\n use middle::typeck::infer::unify::Root;\n use util::common::{indent, indenter};\n@@ -219,7 +218,7 @@ impl ResolveState {\n             // tend to carry more restrictions or higher\n             // perf. penalties, so it pays to know more.\n \n-            let nde = self.infcx.get(&self.infcx.ty_var_bindings, vid);\n+            let nde = self.infcx.get(vid);\n             let bounds = nde.possible_types;\n \n             let t1 = match bounds {\n@@ -243,17 +242,16 @@ impl ResolveState {\n             return ty::mk_int_var(self.infcx.tcx, vid);\n         }\n \n-        let node = self.infcx.get(&self.infcx.int_var_bindings, vid);\n+        let node = self.infcx.get(vid);\n         match node.possible_types {\n           Some(IntType(t)) => ty::mk_mach_int(self.infcx.tcx, t),\n           Some(UintType(t)) => ty::mk_mach_uint(self.infcx.tcx, t),\n           None => {\n             if self.should(force_ivar) {\n                 // As a last resort, default to int.\n                 let ty = ty::mk_int(self.infcx.tcx);\n-                self.infcx.set(\n-                    &self.infcx.int_var_bindings, vid,\n-                    Root(Some(IntType(ast::ty_i)), node.rank));\n+                self.infcx.set(vid,\n+                               Root(Some(IntType(ast::ty_i)), node.rank));\n                 ty\n             } else {\n                 ty::mk_int_var(self.infcx.tcx, vid)\n@@ -267,17 +265,14 @@ impl ResolveState {\n             return ty::mk_float_var(self.infcx.tcx, vid);\n         }\n \n-        let node = self.infcx.get(&self.infcx.float_var_bindings, vid);\n+        let node = self.infcx.get(vid);\n         match node.possible_types {\n           Some(t) => ty::mk_mach_float(self.infcx.tcx, t),\n           None => {\n             if self.should(force_fvar) {\n                 // As a last resort, default to float.\n                 let ty = ty::mk_float(self.infcx.tcx);\n-                self.infcx.set(\n-                    &self.infcx.float_var_bindings,\n-                    vid,\n-                    Root(Some(ast::ty_f), node.rank));\n+                self.infcx.set(vid, Root(Some(ast::ty_f), node.rank));\n                 ty\n             } else {\n                 ty::mk_float_var(self.infcx.tcx, vid)"}, {"sha": "4252580ac46cda84de306a9234d4eb6cf90c876e", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 22, "deletions": 29, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/05b6df49b86024eb4f41fb94478ad9cd80dc172c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05b6df49b86024eb4f41fb94478ad9cd80dc172c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=05b6df49b86024eb4f41fb94478ad9cd80dc172c", "patch": "@@ -102,38 +102,31 @@ impl Sub: Combine {\n         debug!(\"%s.tys(%s, %s)\", self.tag(),\n                a.inf_str(self.infcx), b.inf_str(self.infcx));\n         if a == b { return Ok(a); }\n-        do indent {\n-            match (ty::get(a).sty, ty::get(b).sty) {\n-                (ty::ty_bot, _) => {\n-                    Ok(a)\n-                }\n+        let _indenter = indenter();\n+        match (ty::get(a).sty, ty::get(b).sty) {\n+            (ty::ty_bot, _) => {\n+                Ok(a)\n+            }\n \n-                (ty::ty_infer(TyVar(a_id)), ty::ty_infer(TyVar(b_id))) => {\n-                    do self.var_sub_var(&self.infcx.ty_var_bindings,\n-                                        a_id, b_id).then {\n-                        Ok(a)\n-                    }\n-                }\n-                (ty::ty_infer(TyVar(a_id)), _) => {\n-                    do self.var_sub_t(&self.infcx.ty_var_bindings,\n-                                      a_id, b).then {\n-                        Ok(a)\n-                    }\n-                }\n-                (_, ty::ty_infer(TyVar(b_id))) => {\n-                    do self.t_sub_var(&self.infcx.ty_var_bindings,\n-                                      a, b_id).then {\n-                        Ok(a)\n-                    }\n-                }\n+            (ty::ty_infer(TyVar(a_id)), ty::ty_infer(TyVar(b_id))) => {\n+                if_ok!(self.var_sub_var(a_id, b_id));\n+                Ok(a)\n+            }\n+            (ty::ty_infer(TyVar(a_id)), _) => {\n+                if_ok!(self.var_sub_t(a_id, b));\n+                Ok(a)\n+            }\n+            (_, ty::ty_infer(TyVar(b_id))) => {\n+                if_ok!(self.t_sub_var(a, b_id));\n+                Ok(a)\n+            }\n \n-                (_, ty::ty_bot) => {\n-                    Err(ty::terr_sorts(expected_found(&self, a, b)))\n-                }\n+            (_, ty::ty_bot) => {\n+                Err(ty::terr_sorts(expected_found(&self, a, b)))\n+            }\n \n-                _ => {\n-                    super_tys(&self, a, b)\n-                }\n+            _ => {\n+                super_tys(&self, a, b)\n             }\n         }\n     }"}, {"sha": "a6d316db428720d6491904b39f258722b1b5fee1", "filename": "src/librustc/middle/typeck/infer/to_str.rs", "status": "modified", "additions": 22, "deletions": 26, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/05b6df49b86024eb4f41fb94478ad9cd80dc172c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05b6df49b86024eb4f41fb94478ad9cd80dc172c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs?ref=05b6df49b86024eb4f41fb94478ad9cd80dc172c", "patch": "@@ -10,10 +10,10 @@\n \n use core::prelude::*;\n \n-use middle::ty::{FnMeta, FnTyBase, FnSig, FnVid, Vid};\n+use middle::ty::{FnMeta, FnTyBase, FnSig, Vid};\n+use middle::ty::{IntVarValue, IntType, UintType};\n use middle::ty;\n use middle::typeck::infer::{Bound, Bounds};\n-use middle::typeck::infer::{IntVarValue, IntType, UintType};\n use middle::typeck::infer::InferCtxt;\n use middle::typeck::infer::unify::{Redirect, Root, VarValue};\n use util::ppaux::{mt_to_str, ty_to_str};\n@@ -25,67 +25,67 @@ use core::uint;\n use core::str;\n \n pub trait InferStr {\n-    fn inf_str(cx: @InferCtxt) -> ~str;\n+    fn inf_str(&self, cx: &InferCtxt) -> ~str;\n }\n \n impl ty::t : InferStr {\n-    fn inf_str(cx: @InferCtxt) -> ~str {\n-        ty_to_str(cx.tcx, self)\n+    fn inf_str(&self, cx: &InferCtxt) -> ~str {\n+        ty_to_str(cx.tcx, *self)\n     }\n }\n \n impl FnMeta : InferStr {\n-    fn inf_str(_cx: @InferCtxt) -> ~str {\n-        fmt!(\"%?\", self)\n+    fn inf_str(&self, _cx: &InferCtxt) -> ~str {\n+        fmt!(\"%?\", *self)\n     }\n }\n \n impl FnSig : InferStr {\n-    fn inf_str(cx: @InferCtxt) -> ~str {\n+    fn inf_str(&self, cx: &InferCtxt) -> ~str {\n         fmt!(\"(%s) -> %s\",\n              str::connect(self.inputs.map(|a| a.ty.inf_str(cx)), \", \"),\n              self.output.inf_str(cx))\n     }\n }\n \n impl<M:InferStr> FnTyBase<M> : InferStr {\n-    fn inf_str(cx: @InferCtxt) -> ~str {\n+    fn inf_str(&self, cx: &InferCtxt) -> ~str {\n         fmt!(\"%s%s\", self.meta.inf_str(cx), self.sig.inf_str(cx))\n     }\n }\n \n impl ty::mt : InferStr {\n-    fn inf_str(cx: @InferCtxt) -> ~str {\n-        mt_to_str(cx.tcx, self)\n+    fn inf_str(&self, cx: &InferCtxt) -> ~str {\n+        mt_to_str(cx.tcx, *self)\n     }\n }\n \n impl ty::Region : InferStr {\n-    fn inf_str(_cx: @InferCtxt) -> ~str {\n-        fmt!(\"%?\", self)\n+    fn inf_str(&self, _cx: &InferCtxt) -> ~str {\n+        fmt!(\"%?\", *self)\n     }\n }\n \n impl<V:InferStr> Bound<V> : InferStr {\n-    fn inf_str(cx: @InferCtxt) -> ~str {\n-        match self {\n+    fn inf_str(&self, cx: &InferCtxt) -> ~str {\n+        match *self {\n           Some(ref v) => v.inf_str(cx),\n           None => ~\"none\"\n         }\n     }\n }\n \n impl<T:InferStr> Bounds<T> : InferStr {\n-    fn inf_str(cx: @InferCtxt) -> ~str {\n+    fn inf_str(&self, cx: &InferCtxt) -> ~str {\n         fmt!(\"{%s <: %s}\",\n              self.lb.inf_str(cx),\n              self.ub.inf_str(cx))\n     }\n }\n \n impl<V:Vid ToStr, T:InferStr> VarValue<V, T> : InferStr {\n-    fn inf_str(cx: @InferCtxt) -> ~str {\n-        match self {\n+    fn inf_str(&self, cx: &InferCtxt) -> ~str {\n+        match *self {\n           Redirect(ref vid) => fmt!(\"Redirect(%s)\", vid.to_str()),\n           Root(ref pt, rk) => fmt!(\"Root(%s, %s)\", pt.inf_str(cx),\n                                uint::to_str(rk, 10u))\n@@ -94,17 +94,13 @@ impl<V:Vid ToStr, T:InferStr> VarValue<V, T> : InferStr {\n }\n \n impl IntVarValue : InferStr {\n-    fn inf_str(_cx: @InferCtxt) -> ~str {\n-        match self {\n-            IntType(t) => ast_util::int_ty_to_str(t),\n-            UintType(t) => ast_util::uint_ty_to_str(t)\n-        }\n+    fn inf_str(&self, _cx: &InferCtxt) -> ~str {\n+        self.to_str()\n     }\n }\n \n impl ast::float_ty : InferStr {\n-    fn inf_str(_cx: @InferCtxt) -> ~str {\n-        ast_util::float_ty_to_str(self)\n+    fn inf_str(&self, _cx: &InferCtxt) -> ~str {\n+        self.to_str()\n     }\n }\n-"}, {"sha": "6c831427b031eca32308947df20c36cd259582f0", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 118, "deletions": 45, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/05b6df49b86024eb4f41fb94478ad9cd80dc172c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05b6df49b86024eb4f41fb94478ad9cd80dc172c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=05b6df49b86024eb4f41fb94478ad9cd80dc172c", "patch": "@@ -9,24 +9,24 @@\n // except according to those terms.\n \n use core::prelude::*;\n+use core::result;\n+use std::smallintmap::SmallIntMap;\n \n-use middle::ty::Vid;\n+use middle::ty::{Vid, expected_found, IntVarValue};\n use middle::ty;\n use middle::typeck::infer::{Bound, Bounds, cres, uok, ures};\n use middle::typeck::infer::combine::Combine;\n use middle::typeck::infer::InferCtxt;\n use middle::typeck::infer::to_str::InferStr;\n+use syntax::ast;\n use util::common::{indent, indenter};\n \n-use core::result;\n-use std::smallintmap::SmallIntMap;\n-\n enum VarValue<V, T> {\n     Redirect(V),\n     Root(T, uint),\n }\n \n-struct ValsAndBindings<V:Copy, T:Copy> {\n+struct ValsAndBindings<V, T> {\n     vals: SmallIntMap<VarValue<V, T>>,\n     mut bindings: ~[(V, VarValue<V, T>)],\n }\n@@ -37,11 +37,15 @@ struct Node<V:Copy, T:Copy> {\n     rank: uint,\n }\n \n-impl @InferCtxt {\n-    fn get<V:Copy Eq Vid, T:Copy>(\n-        vb: &ValsAndBindings<V, T>,\n-        vid: V)\n-        -> Node<V, T>\n+trait UnifyVid<T> {\n+    static fn appropriate_vals_and_bindings(infcx: &v/InferCtxt)\n+        -> &v/ValsAndBindings<self, T>;\n+}\n+\n+impl InferCtxt {\n+    fn get<T:Copy, V:Copy Eq Vid UnifyVid<T>>(\n+        &self,\n+        +vid: V) -> Node<V, T>\n     {\n         /*!\n          *\n@@ -50,16 +54,17 @@ impl @InferCtxt {\n          * http://en.wikipedia.org/wiki/Disjoint-set_data_structure\n          */\n \n+        let vb = UnifyVid::appropriate_vals_and_bindings(self);\n         let vid_u = vid.to_uint();\n         match vb.vals.find(vid_u) {\n           None => {\n             self.tcx.sess.bug(fmt!(\"failed lookup of vid `%u`\", vid_u));\n           }\n           Some(ref var_val) => {\n             match (*var_val) {\n-              Redirect(ref vid) => {\n-                let node = self.get(vb, (*vid));\n-                if node.root.ne(vid) {\n+              Redirect(vid) => {\n+                let node: Node<V,T> = self.get(vid);\n+                if node.root != vid {\n                     // Path compression\n                     vb.vals.insert(vid.to_uint(), Redirect(node.root));\n                 }\n@@ -73,16 +78,17 @@ impl @InferCtxt {\n         }\n     }\n \n-    fn set<V:Copy Vid ToStr, T:Copy InferStr>(\n-        vb: &ValsAndBindings<V, T>,\n-        vid: V,\n+    fn set<T:Copy InferStr, V:Copy Vid ToStr UnifyVid<T>>(\n+        &self,\n+        +vid: V,\n         +new_v: VarValue<V, T>)\n     {\n         /*!\n          *\n          * Sets the value for `vid` to `new_v`.  `vid` MUST be a root node!\n          */\n \n+        let vb = UnifyVid::appropriate_vals_and_bindings(self);\n         let old_v = vb.vals.get(vid.to_uint());\n         vb.bindings.push((vid, old_v));\n         vb.vals.insert(vid.to_uint(), new_v);\n@@ -91,8 +97,8 @@ impl @InferCtxt {\n                vid.to_str(), old_v.inf_str(self), new_v.inf_str(self));\n     }\n \n-    fn unify<V:Copy Vid ToStr, T:Copy InferStr, R>(\n-        vb: &ValsAndBindings<V, T>,\n+    fn unify<T:Copy InferStr, V:Copy Vid ToStr UnifyVid<T>, R>(\n+        &self,\n         node_a: &Node<V, T>,\n         node_b: &Node<V, T>,\n         op: &fn(new_root: V, new_rank: uint) -> R\n@@ -108,17 +114,17 @@ impl @InferCtxt {\n         if node_a.rank > node_b.rank {\n             // a has greater rank, so a should become b's parent,\n             // i.e., b should redirect to a.\n-            self.set(vb, node_b.root, Redirect(node_a.root));\n+            self.set(node_b.root, Redirect(node_a.root));\n             op(node_a.root, node_a.rank)\n         } else if node_a.rank < node_b.rank {\n             // b has greater rank, so a should redirect to b.\n-            self.set(vb, node_a.root, Redirect(node_b.root));\n+            self.set(node_a.root, Redirect(node_b.root));\n             op(node_b.root, node_b.rank)\n         } else {\n             // If equal, redirect one to the other and increment the\n             // other's rank.\n             assert node_a.rank == node_b.rank;\n-            self.set(vb, node_b.root, Redirect(node_a.root));\n+            self.set(node_b.root, Redirect(node_a.root));\n             op(node_a.root, node_a.rank + 1)\n         }\n     }\n@@ -129,12 +135,30 @@ impl @InferCtxt {\n // Code to handle simple variables like ints, floats---anything that\n // doesn't have a subtyping relationship we need to worry about.\n \n-impl @InferCtxt {\n-    fn simple_vars<V:Copy Eq Vid ToStr, T:Copy Eq InferStr>(\n-        vb: &ValsAndBindings<V, Option<T>>,\n-        err: ty::type_err,\n-        a_id: V,\n-        b_id: V) -> ures\n+trait SimplyUnifiable {\n+    static fn to_type_err(expected_found<self>) -> ty::type_err;\n+}\n+\n+fn mk_err<T: SimplyUnifiable>(+a_is_expected: bool,\n+                              +a_t: T,\n+                              +b_t: T) -> ures\n+{\n+    if a_is_expected {\n+        Err(SimplyUnifiable::to_type_err(\n+            ty::expected_found {expected: a_t, found: b_t}))\n+    } else {\n+        Err(SimplyUnifiable::to_type_err(\n+            ty::expected_found {expected: b_t, found: a_t}))\n+    }\n+}\n+\n+impl InferCtxt {\n+    fn simple_vars<T:Copy Eq InferStr SimplyUnifiable,\n+                   V:Copy Eq Vid ToStr UnifyVid<Option<T>>>(\n+        &self,\n+        +a_is_expected: bool,\n+        +a_id: V,\n+        +b_id: V) -> ures\n     {\n         /*!\n          *\n@@ -143,8 +167,8 @@ impl @InferCtxt {\n          * have already been associated with a value, then those two\n          * values must be the same. */\n \n-        let node_a = self.get(vb, a_id);\n-        let node_b = self.get(vb, b_id);\n+        let node_a = self.get(a_id);\n+        let node_b = self.get(b_id);\n         let a_id = node_a.root;\n         let b_id = node_b.root;\n \n@@ -155,22 +179,24 @@ impl @InferCtxt {\n             (&None, &None) => None,\n             (&Some(ref v), &None) | (&None, &Some(ref v)) => Some(*v),\n             (&Some(ref v1), &Some(ref v2)) => {\n-                if *v1 != *v2 { return Err(err); }\n+                if *v1 != *v2 {\n+                    return mk_err(a_is_expected, *v1, *v2);\n+                }\n                 Some(*v1)\n             }\n         };\n \n-        self.unify(vb, &node_a, &node_b, |new_root, new_rank| {\n-            self.set(vb, new_root, Root(combined, new_rank));\n+        self.unify(&node_a, &node_b, |new_root, new_rank| {\n+            self.set(new_root, Root(combined, new_rank));\n         });\n         return uok();\n     }\n \n-    fn simple_var_t<V:Copy Eq Vid ToStr, T:Copy Eq InferStr>(\n-        vb: &ValsAndBindings<V, Option<T>>,\n-        err: ty::type_err,\n-        a_id: V,\n-        b: T) -> ures\n+    fn simple_var_t<T:Copy Eq InferStr SimplyUnifiable,\n+                    V:Copy Eq Vid ToStr UnifyVid<Option<T>>>(\n+        +a_is_expected: bool,\n+        +a_id: V,\n+        +b: T) -> ures\n     {\n         /*!\n          *\n@@ -179,19 +205,66 @@ impl @InferCtxt {\n          * if `a_id` already has a value, it must be the same as\n          * `b`. */\n \n-        let node_a = self.get(vb, a_id);\n+        let node_a = self.get(a_id);\n         let a_id = node_a.root;\n \n-        if node_a.possible_types.is_none() {\n-            self.set(vb, a_id, Root(Some(b), node_a.rank));\n-            return uok();\n-        }\n+        match node_a.possible_types {\n+            None => {\n+                self.set(a_id, Root(Some(b), node_a.rank));\n+                return uok();\n+            }\n \n-        if node_a.possible_types == Some(b) {\n-            return uok();\n+            Some(ref a_t) => {\n+                if *a_t == b {\n+                    return uok();\n+                } else {\n+                    return mk_err(a_is_expected, *a_t, b);\n+                }\n+            }\n         }\n+    }\n+}\n \n-        return Err(err);\n+// ______________________________________________________________________\n+\n+impl ty::TyVid : UnifyVid<Bounds<ty::t>> {\n+    static fn appropriate_vals_and_bindings(infcx: &v/InferCtxt)\n+        -> &v/ValsAndBindings<ty::TyVid, Bounds<ty::t>>\n+    {\n+        return &infcx.ty_var_bindings;\n+    }\n+}\n+\n+impl ty::IntVid : UnifyVid<Option<IntVarValue>> {\n+    static fn appropriate_vals_and_bindings(infcx: &v/InferCtxt)\n+        -> &v/ValsAndBindings<ty::IntVid, Option<IntVarValue>>\n+    {\n+        return &infcx.int_var_bindings;\n+    }\n+}\n+\n+impl IntVarValue : SimplyUnifiable {\n+    static fn to_type_err(err: expected_found<IntVarValue>)\n+        -> ty::type_err\n+    {\n+        return ty::terr_int_mismatch(err);\n     }\n }\n \n+impl ty::FloatVid : UnifyVid<Option<ast::float_ty>> {\n+    static fn appropriate_vals_and_bindings(infcx: &v/InferCtxt)\n+        -> &v/ValsAndBindings<ty::FloatVid, Option<ast::float_ty>>\n+    {\n+        return &infcx.float_var_bindings;\n+    }\n+}\n+\n+impl ast::float_ty : SimplyUnifiable {\n+    static fn to_type_err(err: expected_found<ast::float_ty>)\n+        -> ty::type_err\n+    {\n+        return ty::terr_float_mismatch(err);\n+    }\n+}\n+\n+"}]}