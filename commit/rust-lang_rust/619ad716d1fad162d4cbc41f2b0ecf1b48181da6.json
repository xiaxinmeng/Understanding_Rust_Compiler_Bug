{"sha": "619ad716d1fad162d4cbc41f2b0ecf1b48181da6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxOWFkNzE2ZDFmYWQxNjJkNGNiYzQxZjJiMGVjZjFiNDgxODFkYTY=", "commit": {"author": {"name": "Tatsuyuki Ishi", "email": "ishitatsuyuki@gmail.com", "date": "2018-02-18T03:32:23Z"}, "committer": {"name": "Tatsuyuki Ishi", "email": "ishitatsuyuki@gmail.com", "date": "2018-02-22T09:40:49Z"}, "message": "Fix exponential blowup on nested types", "tree": {"sha": "52e78fc14db07e06121cc8d7984527d62a32a6e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/52e78fc14db07e06121cc8d7984527d62a32a6e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/619ad716d1fad162d4cbc41f2b0ecf1b48181da6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/619ad716d1fad162d4cbc41f2b0ecf1b48181da6", "html_url": "https://github.com/rust-lang/rust/commit/619ad716d1fad162d4cbc41f2b0ecf1b48181da6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/619ad716d1fad162d4cbc41f2b0ecf1b48181da6/comments", "author": {"login": "ishitatsuyuki", "id": 12389383, "node_id": "MDQ6VXNlcjEyMzg5Mzgz", "avatar_url": "https://avatars.githubusercontent.com/u/12389383?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ishitatsuyuki", "html_url": "https://github.com/ishitatsuyuki", "followers_url": "https://api.github.com/users/ishitatsuyuki/followers", "following_url": "https://api.github.com/users/ishitatsuyuki/following{/other_user}", "gists_url": "https://api.github.com/users/ishitatsuyuki/gists{/gist_id}", "starred_url": "https://api.github.com/users/ishitatsuyuki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ishitatsuyuki/subscriptions", "organizations_url": "https://api.github.com/users/ishitatsuyuki/orgs", "repos_url": "https://api.github.com/users/ishitatsuyuki/repos", "events_url": "https://api.github.com/users/ishitatsuyuki/events{/privacy}", "received_events_url": "https://api.github.com/users/ishitatsuyuki/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ishitatsuyuki", "id": 12389383, "node_id": "MDQ6VXNlcjEyMzg5Mzgz", "avatar_url": "https://avatars.githubusercontent.com/u/12389383?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ishitatsuyuki", "html_url": "https://github.com/ishitatsuyuki", "followers_url": "https://api.github.com/users/ishitatsuyuki/followers", "following_url": "https://api.github.com/users/ishitatsuyuki/following{/other_user}", "gists_url": "https://api.github.com/users/ishitatsuyuki/gists{/gist_id}", "starred_url": "https://api.github.com/users/ishitatsuyuki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ishitatsuyuki/subscriptions", "organizations_url": "https://api.github.com/users/ishitatsuyuki/orgs", "repos_url": "https://api.github.com/users/ishitatsuyuki/repos", "events_url": "https://api.github.com/users/ishitatsuyuki/events{/privacy}", "received_events_url": "https://api.github.com/users/ishitatsuyuki/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "93e6b0d643099beb95d16da91a833781ac6b8e95", "url": "https://api.github.com/repos/rust-lang/rust/commits/93e6b0d643099beb95d16da91a833781ac6b8e95", "html_url": "https://github.com/rust-lang/rust/commit/93e6b0d643099beb95d16da91a833781ac6b8e95"}], "stats": {"total": 215, "additions": 114, "deletions": 101}, "files": [{"sha": "7f232b310c0b388c351e1ad22f31f37799673719", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/619ad716d1fad162d4cbc41f2b0ecf1b48181da6/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/619ad716d1fad162d4cbc41f2b0ecf1b48181da6/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=619ad716d1fad162d4cbc41f2b0ecf1b48181da6", "patch": "@@ -304,7 +304,7 @@ pub type SelectionResult<'tcx, T> = Result<Option<T>, SelectionError<'tcx>>;\n /// ### The type parameter `N`\n ///\n /// See explanation on `VtableImplData`.\n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n pub enum Vtable<'tcx, N> {\n     /// Vtable identifying a particular impl.\n     VtableImpl(VtableImplData<'tcx, N>),\n@@ -374,13 +374,13 @@ pub struct VtableClosureData<'tcx, N> {\n     pub nested: Vec<N>\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n pub struct VtableAutoImplData<N> {\n     pub trait_def_id: DefId,\n     pub nested: Vec<N>\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n pub struct VtableBuiltinData<N> {\n     pub nested: Vec<N>\n }"}, {"sha": "ca0f7a49f20236d35aa7de5e38ce56bd4f8c7d73", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 111, "deletions": 98, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/619ad716d1fad162d4cbc41f2b0ecf1b48181da6/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/619ad716d1fad162d4cbc41f2b0ecf1b48181da6/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=619ad716d1fad162d4cbc41f2b0ecf1b48181da6", "patch": "@@ -16,6 +16,7 @@ use super::translate_substs;\n use super::Obligation;\n use super::ObligationCause;\n use super::PredicateObligation;\n+use super::Selection;\n use super::SelectionContext;\n use super::SelectionError;\n use super::VtableClosureData;\n@@ -110,12 +111,59 @@ enum ProjectionTyCandidate<'tcx> {\n     TraitDef(ty::PolyProjectionPredicate<'tcx>),\n \n     // from a \"impl\" (or a \"pseudo-impl\" returned by select)\n-    Select,\n+    Select(Selection<'tcx>),\n }\n \n-struct ProjectionTyCandidateSet<'tcx> {\n-    vec: Vec<ProjectionTyCandidate<'tcx>>,\n-    ambiguous: bool\n+enum ProjectionTyCandidateSet<'tcx> {\n+    None,\n+    Single(ProjectionTyCandidate<'tcx>),\n+    Ambiguous,\n+    Error(SelectionError<'tcx>),\n+}\n+\n+impl<'tcx> ProjectionTyCandidateSet<'tcx> {\n+    fn mark_ambiguous(&mut self) {\n+        *self = ProjectionTyCandidateSet::Ambiguous;\n+    }\n+\n+    fn mark_error(&mut self, err: SelectionError<'tcx>) {\n+        *self = ProjectionTyCandidateSet::Error(err);\n+    }\n+\n+    // Returns true if the push was successful, or false if the candidate\n+    // was discarded -- this could be because of ambiguity, or because\n+    // a higher-priority candidate is already there.\n+    fn push_candidate(&mut self, candidate: ProjectionTyCandidate<'tcx>) -> bool {\n+        use self::ProjectionTyCandidateSet::*;\n+        use self::ProjectionTyCandidate::*;\n+        match self {\n+            None => {\n+                *self = Single(candidate);\n+                true\n+            }\n+            Single(current) => {\n+                // No duplicates are expected.\n+                assert_ne!(current, &candidate);\n+                // Prefer where-clauses. As in select, if there are multiple\n+                // candidates, we prefer where-clause candidates over impls.  This\n+                // may seem a bit surprising, since impls are the source of\n+                // \"truth\" in some sense, but in fact some of the impls that SEEM\n+                // applicable are not, because of nested obligations. Where\n+                // clauses are the safer choice. See the comment on\n+                // `select::SelectionCandidate` and #21974 for more details.\n+                match (current, candidate) {\n+                    (ParamEnv(..), ParamEnv(..)) => { *self = Ambiguous; }\n+                    (ParamEnv(..), _) => {}\n+                    (_, ParamEnv(..)) => { unreachable!(); }\n+                    (_, _) => { *self = Ambiguous; }\n+                }\n+                false\n+            }\n+            Ambiguous | Error(..) => {\n+                false\n+            }\n+        }\n+    }\n }\n \n /// Evaluates constraints of the form:\n@@ -803,11 +851,11 @@ fn project_type<'cx, 'gcx, 'tcx>(\n         return Ok(ProjectedTy::Progress(Progress::error(selcx.tcx())));\n     }\n \n-    let mut candidates = ProjectionTyCandidateSet {\n-        vec: Vec::new(),\n-        ambiguous: false,\n-    };\n+    let mut candidates = ProjectionTyCandidateSet::None;\n \n+    // Make sure that the following procedures are kept in order. ParamEnv\n+    // needs to be first because it has highest priority, and Select checks\n+    // the return value of push_candidate which assumes it's ran at last.\n     assemble_candidates_from_param_env(selcx,\n                                        obligation,\n                                        &obligation_trait_ref,\n@@ -818,57 +866,27 @@ fn project_type<'cx, 'gcx, 'tcx>(\n                                        &obligation_trait_ref,\n                                        &mut candidates);\n \n-    if let Err(e) = assemble_candidates_from_impls(selcx,\n-                                                   obligation,\n-                                                   &obligation_trait_ref,\n-                                                   &mut candidates) {\n-        return Err(ProjectionTyError::TraitSelectionError(e));\n-    }\n-\n-    debug!(\"{} candidates, ambiguous={}\",\n-           candidates.vec.len(),\n-           candidates.ambiguous);\n-\n-    // Inherent ambiguity that prevents us from even enumerating the\n-    // candidates.\n-    if candidates.ambiguous {\n-        return Err(ProjectionTyError::TooManyCandidates);\n-    }\n-\n-    // Prefer where-clauses. As in select, if there are multiple\n-    // candidates, we prefer where-clause candidates over impls.  This\n-    // may seem a bit surprising, since impls are the source of\n-    // \"truth\" in some sense, but in fact some of the impls that SEEM\n-    // applicable are not, because of nested obligations. Where\n-    // clauses are the safer choice. See the comment on\n-    // `select::SelectionCandidate` and #21974 for more details.\n-    if candidates.vec.len() > 1 {\n-        debug!(\"retaining param-env candidates only from {:?}\", candidates.vec);\n-        candidates.vec.retain(|c| match *c {\n-            ProjectionTyCandidate::ParamEnv(..) => true,\n-            ProjectionTyCandidate::TraitDef(..) |\n-            ProjectionTyCandidate::Select => false,\n-        });\n-        debug!(\"resulting candidate set: {:?}\", candidates.vec);\n-        if candidates.vec.len() != 1 {\n-            return Err(ProjectionTyError::TooManyCandidates);\n-        }\n-    }\n-\n-    assert!(candidates.vec.len() <= 1);\n+    assemble_candidates_from_impls(selcx,\n+                                   obligation,\n+                                   &obligation_trait_ref,\n+                                   &mut candidates);\n+\n+    match candidates {\n+        ProjectionTyCandidateSet::Single(candidate) => Ok(ProjectedTy::Progress(\n+            confirm_candidate(selcx,\n+                              obligation,\n+                              &obligation_trait_ref,\n+                              candidate))),\n+        ProjectionTyCandidateSet::None => Ok(ProjectedTy::NoProgress(\n+            selcx.tcx().mk_projection(\n+                obligation.predicate.item_def_id,\n+                obligation.predicate.substs))),\n+        // Error occurred while trying to processing impls.\n+        ProjectionTyCandidateSet::Error(e) => Err(ProjectionTyError::TraitSelectionError(e)),\n+        // Inherent ambiguity that prevents us from even enumerating the\n+        // candidates.\n+        ProjectionTyCandidateSet::Ambiguous => Err(ProjectionTyError::TooManyCandidates),\n \n-    match candidates.vec.pop() {\n-        Some(candidate) => {\n-            Ok(ProjectedTy::Progress(\n-                confirm_candidate(selcx,\n-                                  obligation,\n-                                  &obligation_trait_ref,\n-                                  candidate)))\n-        }\n-        None => Ok(ProjectedTy::NoProgress(\n-                    selcx.tcx().mk_projection(\n-                        obligation.predicate.item_def_id,\n-                        obligation.predicate.substs)))\n     }\n }\n \n@@ -918,7 +936,7 @@ fn assemble_candidates_from_trait_def<'cx, 'gcx, 'tcx>(\n         ty::TyInfer(ty::TyVar(_)) => {\n             // If the self-type is an inference variable, then it MAY wind up\n             // being a projected type, so induce an ambiguity.\n-            candidate_set.ambiguous = true;\n+            candidate_set.mark_ambiguous();\n             return;\n         }\n         _ => { return; }\n@@ -952,7 +970,7 @@ fn assemble_candidates_from_predicates<'cx, 'gcx, 'tcx, I>(\n         debug!(\"assemble_candidates_from_predicates: predicate={:?}\",\n                predicate);\n         match predicate {\n-            ty::Predicate::Projection(ref data) => {\n+            ty::Predicate::Projection(data) => {\n                 let same_def_id =\n                     data.0.projection_ty.item_def_id == obligation.predicate.item_def_id;\n \n@@ -975,10 +993,10 @@ fn assemble_candidates_from_predicates<'cx, 'gcx, 'tcx, I>(\n                        data, is_match, same_def_id);\n \n                 if is_match {\n-                    candidate_set.vec.push(ctor(data.clone()));\n+                    candidate_set.push_candidate(ctor(data));\n                 }\n             }\n-            _ => { }\n+            _ => {}\n         }\n     }\n }\n@@ -988,37 +1006,36 @@ fn assemble_candidates_from_impls<'cx, 'gcx, 'tcx>(\n     obligation: &ProjectionTyObligation<'tcx>,\n     obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n-    -> Result<(), SelectionError<'tcx>>\n {\n     // If we are resolving `<T as TraitRef<...>>::Item == Type`,\n     // start out by selecting the predicate `T as TraitRef<...>`:\n     let poly_trait_ref = obligation_trait_ref.to_poly_trait_ref();\n     let trait_obligation = obligation.with(poly_trait_ref.to_poly_trait_predicate());\n-    selcx.infcx().probe(|_| {\n+    let _ = selcx.infcx().commit_if_ok(|_| {\n         let vtable = match selcx.select(&trait_obligation) {\n             Ok(Some(vtable)) => vtable,\n             Ok(None) => {\n-                candidate_set.ambiguous = true;\n-                return Ok(());\n+                candidate_set.mark_ambiguous();\n+                return Err(());\n             }\n             Err(e) => {\n                 debug!(\"assemble_candidates_from_impls: selection error {:?}\",\n                        e);\n-                return Err(e);\n+                candidate_set.mark_error(e);\n+                return Err(());\n             }\n         };\n \n-        match vtable {\n+        let eligible = match &vtable {\n             super::VtableClosure(_) |\n             super::VtableGenerator(_) |\n             super::VtableFnPointer(_) |\n             super::VtableObject(_) => {\n                 debug!(\"assemble_candidates_from_impls: vtable={:?}\",\n                        vtable);\n-\n-                candidate_set.vec.push(ProjectionTyCandidate::Select);\n+                true\n             }\n-            super::VtableImpl(ref impl_data) => {\n+            super::VtableImpl(impl_data) => {\n                 // We have to be careful when projecting out of an\n                 // impl because of specialization. If we are not in\n                 // trans (i.e., projection mode is not \"any\"), and the\n@@ -1062,27 +1079,25 @@ fn assemble_candidates_from_impls<'cx, 'gcx, 'tcx>(\n                     node_item.item.defaultness.has_value()\n                 } else {\n                     node_item.item.defaultness.is_default() ||\n-                    selcx.tcx().impl_is_default(node_item.node.def_id())\n+                        selcx.tcx().impl_is_default(node_item.node.def_id())\n                 };\n \n                 // Only reveal a specializable default if we're past type-checking\n                 // and the obligations is monomorphic, otherwise passes such as\n                 // transmute checking and polymorphic MIR optimizations could\n                 // get a result which isn't correct for all monomorphizations.\n-                let new_candidate = if !is_default {\n-                    Some(ProjectionTyCandidate::Select)\n+                if !is_default {\n+                    true\n                 } else if obligation.param_env.reveal == Reveal::All {\n                     assert!(!poly_trait_ref.needs_infer());\n                     if !poly_trait_ref.needs_subst() {\n-                        Some(ProjectionTyCandidate::Select)\n+                        true\n                     } else {\n-                        None\n+                        false\n                     }\n                 } else {\n-                    None\n-                };\n-\n-                candidate_set.vec.extend(new_candidate);\n+                    false\n+                }\n             }\n             super::VtableParam(..) => {\n                 // This case tell us nothing about the value of an\n@@ -1110,6 +1125,7 @@ fn assemble_candidates_from_impls<'cx, 'gcx, 'tcx>(\n                 // in the compiler: a trait predicate (`T : SomeTrait`) and a\n                 // projection. And the projection where clause is handled\n                 // in `assemble_candidates_from_param_env`.\n+                false\n             }\n             super::VtableAutoImpl(..) |\n             super::VtableBuiltin(..) => {\n@@ -1119,10 +1135,18 @@ fn assemble_candidates_from_impls<'cx, 'gcx, 'tcx>(\n                     \"Cannot project an associated type from `{:?}`\",\n                     vtable);\n             }\n-        }\n+        };\n \n-        Ok(())\n-    })\n+        if eligible {\n+            if candidate_set.push_candidate(ProjectionTyCandidate::Select(vtable)) {\n+                Ok(())\n+            } else {\n+                Err(())\n+            }\n+        } else {\n+            Err(())\n+        }\n+    });\n }\n \n fn confirm_candidate<'cx, 'gcx, 'tcx>(\n@@ -1142,30 +1166,19 @@ fn confirm_candidate<'cx, 'gcx, 'tcx>(\n             confirm_param_env_candidate(selcx, obligation, poly_projection)\n         }\n \n-        ProjectionTyCandidate::Select => {\n-            confirm_select_candidate(selcx, obligation, obligation_trait_ref)\n+        ProjectionTyCandidate::Select(vtable) => {\n+            confirm_select_candidate(selcx, obligation, obligation_trait_ref, vtable)\n         }\n     }\n }\n \n fn confirm_select_candidate<'cx, 'gcx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    obligation_trait_ref: &ty::TraitRef<'tcx>)\n+    obligation_trait_ref: &ty::TraitRef<'tcx>,\n+    vtable: Selection<'tcx>)\n     -> Progress<'tcx>\n {\n-    let poly_trait_ref = obligation_trait_ref.to_poly_trait_ref();\n-    let trait_obligation = obligation.with(poly_trait_ref.to_poly_trait_predicate());\n-    let vtable = match selcx.select(&trait_obligation) {\n-        Ok(Some(vtable)) => vtable,\n-        _ => {\n-            span_bug!(\n-                obligation.cause.span,\n-                \"Failed to select `{:?}`\",\n-                trait_obligation);\n-        }\n-    };\n-\n     match vtable {\n         super::VtableImpl(data) =>\n             confirm_impl_candidate(selcx, obligation, data),"}]}