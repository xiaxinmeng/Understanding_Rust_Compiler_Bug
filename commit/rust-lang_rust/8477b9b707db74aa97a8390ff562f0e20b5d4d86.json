{"sha": "8477b9b707db74aa97a8390ff562f0e20b5d4d86", "node_id": "C_kwDOAAsO6NoAKDg0NzdiOWI3MDdkYjc0YWE5N2E4MzkwZmY1NjJmMGUyMGI1ZDRkODY", "commit": {"author": {"name": "mejrs", "email": "", "date": "2022-09-10T22:46:53Z"}, "committer": {"name": "mejrs", "email": "", "date": "2022-09-18T00:43:42Z"}, "message": "Note if mismatched types have a similar name", "tree": {"sha": "9e224546c70b180885590c159f2516cd587322af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e224546c70b180885590c159f2516cd587322af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8477b9b707db74aa97a8390ff562f0e20b5d4d86", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8477b9b707db74aa97a8390ff562f0e20b5d4d86", "html_url": "https://github.com/rust-lang/rust/commit/8477b9b707db74aa97a8390ff562f0e20b5d4d86", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8477b9b707db74aa97a8390ff562f0e20b5d4d86/comments", "author": {}, "committer": {}, "parents": [{"sha": "98ad6a5519651af36e246c0335c964dd52c554ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/98ad6a5519651af36e246c0335c964dd52c554ba", "html_url": "https://github.com/rust-lang/rust/commit/98ad6a5519651af36e246c0335c964dd52c554ba"}], "stats": {"total": 121, "additions": 117, "deletions": 4}, "files": [{"sha": "ab76b48847818fdd37c77b595e241ea2d7189566", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 48, "deletions": 4, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/8477b9b707db74aa97a8390ff562f0e20b5d4d86/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8477b9b707db74aa97a8390ff562f0e20b5d4d86/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=8477b9b707db74aa97a8390ff562f0e20b5d4d86", "patch": "@@ -51,6 +51,7 @@ use super::{InferCtxt, RegionVariableOrigin, SubregionOrigin, TypeTrace, ValuePa\n \n use crate::infer;\n use crate::infer::error_reporting::nice_region_error::find_anon_type::find_anon_type;\n+use crate::infer::ExpectedFound;\n use crate::traits::error_reporting::report_object_safety_error;\n use crate::traits::{\n     IfExpressionCause, MatchExpressionArmCause, ObligationCause, ObligationCauseCode,\n@@ -1653,8 +1654,51 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 ),\n                 Mismatch::Fixed(s) => (s.into(), s.into(), None),\n             };\n-            match (&terr, expected == found) {\n-                (TypeError::Sorts(values), extra) => {\n+            let looks_similar = |e: ExpectedFound<Ty<'_>>| {\n+                // We're only interested in adts\n+                if let (Some(e), Some(f)) = (e.expected.ty_adt_def(), e.found.ty_adt_def()) {\n+                    // Only compare the last parts of the path.\n+                    // `whatever::Foo` is pretty similar to `blah::Foo`\n+                    let e_path = self.tcx.def_path(e.did()).data;\n+                    let f_path = self.tcx.def_path(f.did()).data;\n+                    if let (Some(e), Some(f)) = (e_path.last(), f_path.last()) {\n+                        return e.data == f.data;\n+                    }\n+                }\n+                false\n+            };\n+\n+            match terr {\n+                // If two types mismatch but have similar names, mention that specifically.\n+                TypeError::Sorts(values) if looks_similar(values) => {\n+                    let found_adt = values.found.ty_adt_def().unwrap();\n+                    let expected_adt = values.expected.ty_adt_def().unwrap();\n+\n+                    let found_name = values.found.sort_string(self.tcx);\n+                    let expected_name = values.expected.sort_string(self.tcx);\n+\n+                    diag.note(format!(\"{found_name} and {expected_name} have similar names, but are actually distinct types\"));\n+\n+                    for (adt, name) in [(found_adt, found_name), (expected_adt, expected_name)] {\n+                        let defid = adt.did();\n+                        let def_span = self.tcx.def_span(defid);\n+\n+                        let msg = if defid.is_local() {\n+                            format!(\"{name} is defined in the current crate.\")\n+                        } else if self.tcx.all_diagnostic_items(()).id_to_name.get(&defid).is_some()\n+                        {\n+                            // if it's a diagnostic item, it's definitely defined in std/core/alloc\n+                            // otherwise might be, might not be.\n+                            format!(\"{name} is defined in the standard library.\")\n+                        } else {\n+                            let crate_name = self.tcx.crate_name(defid.krate);\n+                            format!(\"{name} is defined in crate `{crate_name}`.\")\n+                        };\n+                        diag.span_note(def_span, msg);\n+                    }\n+                }\n+                TypeError::Sorts(values) => {\n+                    let extra = expected == found;\n                     let sort_string = |ty: Ty<'tcx>| match (extra, ty.kind()) {\n                         (true, ty::Opaque(def_id, _)) => {\n                             let sm = self.tcx.sess.source_map();\n@@ -1707,10 +1751,10 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         );\n                     }\n                 }\n-                (TypeError::ObjectUnsafeCoercion(_), _) => {\n+                TypeError::ObjectUnsafeCoercion(_) => {\n                     diag.note_unsuccessful_coercion(found, expected);\n                 }\n-                (_, _) => {\n+                _ => {\n                     debug!(\n                         \"note_type_err: exp_found={:?}, expected={:?} found={:?}\",\n                         exp_found, expected, found"}, {"sha": "8729ea1740ce296d93ffec9105be67df152015df", "filename": "src/test/ui/fully-qualified-type/fully-qualified-type-name2.stderr", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8477b9b707db74aa97a8390ff562f0e20b5d4d86/src%2Ftest%2Fui%2Ffully-qualified-type%2Ffully-qualified-type-name2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8477b9b707db74aa97a8390ff562f0e20b5d4d86/src%2Ftest%2Fui%2Ffully-qualified-type%2Ffully-qualified-type-name2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffully-qualified-type%2Ffully-qualified-type-name2.stderr?ref=8477b9b707db74aa97a8390ff562f0e20b5d4d86", "patch": "@@ -5,6 +5,18 @@ LL | fn bar(x: x::Foo) -> y::Foo {\n    |                      ------ expected `y::Foo` because of return type\n LL |     return x;\n    |            ^ expected enum `y::Foo`, found enum `x::Foo`\n+   |\n+   = note: enum `x::Foo` and enum `y::Foo` have similar names, but are actually distinct types\n+note: enum `x::Foo` is defined in the current crate.\n+  --> $DIR/fully-qualified-type-name2.rs:4:5\n+   |\n+LL |     pub enum Foo { }\n+   |     ^^^^^^^^^^^^\n+note: enum `y::Foo` is defined in the current crate.\n+  --> $DIR/fully-qualified-type-name2.rs:8:5\n+   |\n+LL |     pub enum Foo { }\n+   |     ^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "3efa5f6d04093100638fcb047177690ae800c60d", "filename": "src/test/ui/issues/issue-56943.stderr", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8477b9b707db74aa97a8390ff562f0e20b5d4d86/src%2Ftest%2Fui%2Fissues%2Fissue-56943.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8477b9b707db74aa97a8390ff562f0e20b5d4d86/src%2Ftest%2Fui%2Fissues%2Fissue-56943.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-56943.stderr?ref=8477b9b707db74aa97a8390ff562f0e20b5d4d86", "patch": "@@ -5,6 +5,18 @@ LL |     let _: issue_56943::S = issue_56943::S2;\n    |            --------------   ^^^^^^^^^^^^^^^ expected struct `S`, found struct `S2`\n    |            |\n    |            expected due to this\n+   |\n+   = note: struct `S2` and struct `S` have similar names, but are actually distinct types\n+note: struct `S2` is defined in crate `issue_56943`.\n+  --> $DIR/auxiliary/issue-56943.rs:2:9\n+   |\n+LL | mod m { pub struct S; }\n+   |         ^^^^^^^^^^^^\n+note: struct `S` is defined in crate `issue_56943`.\n+  --> $DIR/auxiliary/issue-56943.rs:1:1\n+   |\n+LL | pub struct S;\n+   | ^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "4d3a2a1fcc61cd7238700036cbc64e6564b12f75", "filename": "src/test/ui/mismatched_types/similar_paths.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8477b9b707db74aa97a8390ff562f0e20b5d4d86/src%2Ftest%2Fui%2Fmismatched_types%2Fsimilar_paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8477b9b707db74aa97a8390ff562f0e20b5d4d86/src%2Ftest%2Fui%2Fmismatched_types%2Fsimilar_paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fsimilar_paths.rs?ref=8477b9b707db74aa97a8390ff562f0e20b5d4d86", "patch": "@@ -0,0 +1,11 @@\n+enum Option<T>{\n+    Some(T),\n+    None,\n+}\n+\n+pub fn foo() -> Option<u8>{\n+    Some(42_u8)\n+    //~^ ERROR mismatched types [E0308]\n+}\n+\n+fn main(){}"}, {"sha": "c12afd20b9cf52681441b340f2f21b4e53015c58", "filename": "src/test/ui/mismatched_types/similar_paths.stderr", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8477b9b707db74aa97a8390ff562f0e20b5d4d86/src%2Ftest%2Fui%2Fmismatched_types%2Fsimilar_paths.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8477b9b707db74aa97a8390ff562f0e20b5d4d86/src%2Ftest%2Fui%2Fmismatched_types%2Fsimilar_paths.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fsimilar_paths.stderr?ref=8477b9b707db74aa97a8390ff562f0e20b5d4d86", "patch": "@@ -0,0 +1,23 @@\n+error[E0308]: mismatched types\n+  --> $DIR/similar_paths.rs:7:5\n+   |\n+LL | pub fn foo() -> Option<u8>{\n+   |                 ---------- expected `Option<u8>` because of return type\n+LL |     Some(42_u8)\n+   |     ^^^^^^^^^^^ expected enum `Option`, found enum `std::option::Option`\n+   |\n+   = note: enum `std::option::Option` and enum `Option` have similar names, but are actually distinct types\n+note: enum `std::option::Option` is defined in the standard library.\n+  --> $SRC_DIR/core/src/option.rs:LL:COL\n+   |\n+LL | pub enum Option<T> {\n+   | ^^^^^^^^^^^^^^^^^^\n+note: enum `Option` is defined in the current crate.\n+  --> $DIR/similar_paths.rs:1:1\n+   |\n+LL | enum Option<T>{\n+   | ^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "38a36e8940fa1cfa70f2afeb5a6d776ee94e8c9e", "filename": "src/test/ui/type/type-mismatch-same-crate-name.stderr", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8477b9b707db74aa97a8390ff562f0e20b5d4d86/src%2Ftest%2Fui%2Ftype%2Ftype-mismatch-same-crate-name.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8477b9b707db74aa97a8390ff562f0e20b5d4d86/src%2Ftest%2Fui%2Ftype%2Ftype-mismatch-same-crate-name.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-mismatch-same-crate-name.stderr?ref=8477b9b707db74aa97a8390ff562f0e20b5d4d86", "patch": "@@ -6,6 +6,17 @@ LL |         a::try_foo(foo2);\n    |         |\n    |         arguments to this function are incorrect\n    |\n+   = note: struct `main::a::Foo` and struct `main::a::Foo` have similar names, but are actually distinct types\n+note: struct `main::a::Foo` is defined in crate `crate_a2`.\n+  --> $DIR/auxiliary/crate_a2.rs:1:1\n+   |\n+LL | pub struct Foo;\n+   | ^^^^^^^^^^^^^^\n+note: struct `main::a::Foo` is defined in crate `crate_a1`.\n+  --> $DIR/auxiliary/crate_a1.rs:1:1\n+   |\n+LL | pub struct Foo;\n+   | ^^^^^^^^^^^^^^\n    = note: perhaps two different versions of crate `crate_a1` are being used?\n note: function defined here\n   --> $DIR/auxiliary/crate_a1.rs:10:8"}]}