{"sha": "0efafac398ff7f28c5f0fe756c15b9008b3e0534", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlZmFmYWMzOThmZjdmMjhjNWYwZmU3NTZjMTViOTAwOGIzZTA1MzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-19T08:28:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-19T08:28:52Z"}, "message": "auto merge of #19654 : aturon/rust/merge-rt, r=alexcrichton\n\nThis PR substantially narrows the notion of a \"runtime\" in Rust, and allows calling into Rust code directly without any setup or teardown. \r\n\r\nAfter this PR, the basic \"runtime support\" in Rust will consist of:\r\n\r\n* Unwinding and backtrace support\r\n* Stack guards\r\n\r\nOther support, such as helper threads for timers or the notion of a \"current thread\" are initialized automatically upon first use.\r\n\r\nWhen using Rust in an embedded context, it should now be possible to call a Rust function directly as a C function with absolutely no setup, though in that case panics will cause the process to abort. In this regard, the C/Rust interface will look much like the C/C++ interface.\r\n\r\nIn more detail, this PR:\r\n\r\n* Merges `librustrt` back into `std::rt`, undoing the facade. While doing so, it removes a substantial amount of redundant functionality (such as mutexes defined in the `rt` module). Code using `librustrt` can now call into `std::rt` to e.g. start executing Rust code with unwinding support.\r\n\r\n* Allows all runtime data to be initialized lazily, including the \"current thread\", the \"at_exit\" infrastructure, and the \"args\" storage.\r\n\r\n* Deprecates and largely removes `std::task` along with the widespread requirement that there be a \"current task\" for many APIs in `std`. The entire task infrastructure is replaced with `std::thread`, which provides a more standard API for manipulating and creating native OS threads. In particular, it's possible to join on a created thread, and to get a handle to the currently-running thread. In addition, threads are equipped with some basic blocking support in the form of `park`/`unpark` operations (following a tradition in some OSes as well as the JVM). See the `std::thread` documentation for more details.\r\n\r\n* Channels are refactored to use a new internal blocking infrastructure that itself sits on top of `park`/`unpark`.\r\n\r\nOne important change here is that a Rust program ends when its main thread does, following most threading models. On the other hand, threads will often be created with an RAII-style join handle that will re-institute blocking semantics naturally (and with finer control).\r\n\r\nThis is very much a:\r\n\r\n[breaking-change]\r\n\r\nCloses #18000\r\nr? @alexcrichton", "tree": {"sha": "2e8279b94829b65868049d2e3df0b9a6c3365a8f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2e8279b94829b65868049d2e3df0b9a6c3365a8f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0efafac398ff7f28c5f0fe756c15b9008b3e0534", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0efafac398ff7f28c5f0fe756c15b9008b3e0534", "html_url": "https://github.com/rust-lang/rust/commit/0efafac398ff7f28c5f0fe756c15b9008b3e0534", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0efafac398ff7f28c5f0fe756c15b9008b3e0534/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6bdce25e155d846bb9252fa4a18baef7e74cf8bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/6bdce25e155d846bb9252fa4a18baef7e74cf8bf", "html_url": "https://github.com/rust-lang/rust/commit/6bdce25e155d846bb9252fa4a18baef7e74cf8bf"}, {"sha": "903c5a8f69714382ec9fc22745f902c3e219cb68", "url": "https://api.github.com/repos/rust-lang/rust/commits/903c5a8f69714382ec9fc22745f902c3e219cb68", "html_url": "https://github.com/rust-lang/rust/commit/903c5a8f69714382ec9fc22745f902c3e219cb68"}], "stats": {"total": 9556, "additions": 3960, "deletions": 5596}, "files": [{"sha": "fafe77c78da4e514b8903180e7bc788284b94de9", "filename": "mk/crates.mk", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -51,7 +51,7 @@\n \n TARGET_CRATES := libc std flate arena term \\\n                  serialize getopts collections test time rand \\\n-                 log regex graphviz core rbml alloc rustrt \\\n+                 log regex graphviz core rbml alloc \\\n                  unicode\n RUSTC_CRATES := rustc rustc_typeck rustc_borrowck rustc_driver rustc_trans rustc_back rustc_llvm \n HOST_CRATES := syntax $(RUSTC_CRATES) rustdoc regex_macros fmt_macros\n@@ -62,9 +62,8 @@ DEPS_core :=\n DEPS_libc := core\n DEPS_unicode := core\n DEPS_alloc := core libc native:jemalloc\n-DEPS_rustrt := alloc core libc collections native:rustrt_native\n-DEPS_std := core libc rand alloc collections rustrt unicode \\\n-\tnative:rust_builtin native:backtrace\n+DEPS_std := core libc rand alloc collections unicode \\\n+\tnative:rust_builtin native:backtrace native:rustrt_native\n DEPS_graphviz := std\n DEPS_syntax := std term serialize log fmt_macros arena libc\n DEPS_rustc_driver := arena flate getopts graphviz libc rustc rustc_back rustc_borrowck \\"}, {"sha": "1b445a6e7367fa77cf6ca20523b1d7e336b2a0fa", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -32,7 +32,7 @@ use std::io;\n use std::os;\n use std::str;\n use std::string::String;\n-use std::task;\n+use std::thread::Thread;\n use std::time::Duration;\n use test::MetricMap;\n \n@@ -445,9 +445,9 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n             loop {\n                 //waiting 1 second for gdbserver start\n                 timer::sleep(Duration::milliseconds(1000));\n-                let result = task::try(move || {\n+                let result = Thread::spawn(move || {\n                     tcp::TcpStream::connect(\"127.0.0.1:5039\").unwrap();\n-                });\n+                }).join();\n                 if result.is_err() {\n                     continue;\n                 }"}, {"sha": "87a3abd8f226bef6f68d36f86301db06037b2898", "filename": "src/doc/guide-tasks.md", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Fdoc%2Fguide-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Fdoc%2Fguide-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-tasks.md?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -1,5 +1,7 @@\n % The Rust Tasks and Communication Guide\n \n+**NOTE** This guide is badly out of date an needs to be rewritten.\n+\n # Introduction\n \n Rust provides safe concurrent abstractions through a number of core library\n@@ -22,7 +24,7 @@ from shared mutable state.\n At its simplest, creating a task is a matter of calling the `spawn` function\n with a closure argument. `spawn` executes the closure in the new task.\n \n-```{rust}\n+```{rust,ignore}\n # use std::task::spawn;\n \n // Print something profound in a different task using a named function\n@@ -49,7 +51,7 @@ closure is limited to capturing `Send`-able data from its environment\n ensures that `spawn` can safely move the entire closure and all its\n associated state into an entirely different task for execution.\n \n-```{rust}\n+```{rust,ignore}\n # use std::task::spawn;\n # fn generate_task_number() -> int { 0 }\n // Generate some state locally\n@@ -75,7 +77,7 @@ The simplest way to create a channel is to use the `channel` function to create\n of a channel, and a **receiver** is the receiving endpoint. Consider the following\n example of calculating two results concurrently:\n \n-```{rust}\n+```{rust,ignore}\n # use std::task::spawn;\n \n let (tx, rx): (Sender<int>, Receiver<int>) = channel();\n@@ -96,15 +98,15 @@ stream for sending and receiving integers (the left-hand side of the `let`,\n `(tx, rx)`, is an example of a destructuring let: the pattern separates a tuple\n into its component parts).\n \n-```{rust}\n+```{rust,ignore}\n let (tx, rx): (Sender<int>, Receiver<int>) = channel();\n ```\n \n The child task will use the sender to send data to the parent task, which will\n wait to receive the data on the receiver. The next statement spawns the child\n task.\n \n-```{rust}\n+```{rust,ignore}\n # use std::task::spawn;\n # fn some_expensive_computation() -> int { 42 }\n # let (tx, rx) = channel();\n@@ -123,7 +125,7 @@ computation, then sends the result over the captured channel.\n Finally, the parent continues with some other expensive computation, then waits\n for the child's result to arrive on the receiver:\n \n-```{rust}\n+```{rust,ignore}\n # fn some_other_expensive_computation() {}\n # let (tx, rx) = channel::<int>();\n # tx.send(0);\n@@ -154,7 +156,7 @@ spawn(move || {\n \n Instead we can clone the `tx`, which allows for multiple senders.\n \n-```{rust}\n+```{rust,ignore}\n let (tx, rx) = channel();\n \n for init_val in range(0u, 3) {\n@@ -179,7 +181,7 @@ Note that the above cloning example is somewhat contrived since you could also\n simply use three `Sender` pairs, but it serves to illustrate the point. For\n reference, written with multiple streams, it might look like the example below.\n \n-```{rust}\n+```{rust,ignore}\n # use std::task::spawn;\n \n // Create a vector of ports, one for each child task\n@@ -203,7 +205,7 @@ getting the result later.\n \n The basic example below illustrates this.\n \n-```{rust}\n+```{rust,ignore}\n use std::sync::Future;\n \n # fn main() {\n@@ -230,7 +232,7 @@ called.\n Here is another example showing how futures allow you to background\n computations. The workload will be distributed on the available cores.\n \n-```{rust}\n+```{rust,ignore}\n # use std::num::Float;\n # use std::sync::Future;\n fn partial_sum(start: uint) -> f64 {\n@@ -268,7 +270,7 @@ Here is a small example showing how to use Arcs. We wish to run concurrently\n several computations on a single large vector of floats. Each task needs the\n full vector to perform its duty.\n \n-```{rust}\n+```{rust,ignore}\n use std::num::Float;\n use std::rand;\n use std::sync::Arc;\n@@ -295,7 +297,7 @@ The function `pnorm` performs a simple computation on the vector (it computes\n the sum of its items at the power given as argument and takes the inverse power\n of this value). The Arc on the vector is created by the line:\n \n-```{rust}\n+```{rust,ignore}\n # use std::rand;\n # use std::sync::Arc;\n # fn main() {\n@@ -309,7 +311,7 @@ the wrapper and not its contents. Within the task's procedure, the captured\n Arc reference can be used as a shared reference to the underlying vector as\n if it were local.\n \n-```{rust}\n+```{rust,ignore}\n # use std::rand;\n # use std::sync::Arc;\n # fn pnorm(nums: &[f64], p: uint) -> f64 { 4.0 }\n@@ -346,17 +348,17 @@ and `()`, callers can pattern-match on a result to check whether it's an `Ok`\n result with an `int` field (representing a successful result) or an `Err` result\n (representing termination with an error).\n \n-```{rust}\n-# use std::task;\n+```{rust,ignore}\n+# use std::thread::Thread;\n # fn some_condition() -> bool { false }\n # fn calculate_result() -> int { 0 }\n-let result: Result<int, Box<std::any::Any + Send>> = task::try(move || {\n+let result: Result<int, Box<std::any::Any + Send>> = Thread::spawn(move || {\n     if some_condition() {\n         calculate_result()\n     } else {\n         panic!(\"oops!\");\n     }\n-});\n+}).join();\n assert!(result.is_err());\n ```\n "}, {"sha": "d739ad105fc873776a9e900088b2f32957acda8c", "filename": "src/doc/guide.md", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -5217,6 +5217,8 @@ the same function, so our binary is a little bit larger.\n \n # Tasks\n \n+**NOTE**: this section is currently out of date and will be rewritten soon.\n+\n Concurrency and parallelism are topics that are of increasing interest to a\n broad subsection of software developers. Modern computers are often multi-core,\n to the point that even embedded devices like cell phones have more than one\n@@ -5231,7 +5233,7 @@ library, and not part of the language. This means that in the future, other\n concurrency libraries can be written for Rust to help in specific scenarios.\n Here's an example of creating a task:\n \n-```{rust}\n+```{rust,ignore}\n spawn(move || {\n     println!(\"Hello from a task!\");\n });\n@@ -5261,7 +5263,7 @@ If tasks were only able to capture these values, they wouldn't be very useful.\n Luckily, tasks can communicate with each other through **channel**s. Channels\n work like this:\n \n-```{rust}\n+```{rust,ignore}\n let (tx, rx) = channel();\n \n spawn(move || {\n@@ -5280,7 +5282,7 @@ which returns an `Result<T, TryRecvError>` and does not block.\n \n If you want to send messages to the task as well, create two channels!\n \n-```{rust}\n+```{rust,ignore}\n let (tx1, rx1) = channel();\n let (tx2, rx2) = channel();\n \n@@ -5340,7 +5342,7 @@ we'll just get the value immediately.\n Tasks don't always succeed, they can also panic. A task that wishes to panic\n can call the `panic!` macro, passing a message:\n \n-```{rust}\n+```{rust,ignore}\n spawn(move || {\n     panic!(\"Nope.\");\n });\n@@ -5349,7 +5351,7 @@ spawn(move || {\n If a task panics, it is not possible for it to recover. However, it can\n notify other tasks that it has panicked. We can do this with `task::try`:\n \n-```{rust}\n+```{rust,ignore}\n use std::task;\n use std::rand;\n "}, {"sha": "5be97034357eb11dde654053571898fa2cc9a924", "filename": "src/doc/intro.md", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Fdoc%2Fintro.md", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Fdoc%2Fintro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fintro.md?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -389,11 +389,13 @@ safe concurrent programs.\n Here's an example of a concurrent Rust program:\n \n ```{rust}\n+use std::thread::Thread;\n+\n fn main() {\n     for _ in range(0u, 10u) {\n-        spawn(move || {\n+        Thread::spawn(move || {\n             println!(\"Hello, world!\");\n-        });\n+        }).detach();\n     }\n }\n ```\n@@ -403,7 +405,8 @@ This program creates ten threads, who all print `Hello, world!`. The\n double bars `||`. (The `move` keyword indicates that the closure takes\n ownership of any data it uses; we'll have more on the significance of\n this shortly.) This closure is executed in a new thread created by\n-`spawn`.\n+`spawn`. The `detach` method means that the child thread is allowed to\n+outlive its parent.\n \n One common form of problem in concurrent programs is a 'data race.'\n This occurs when two different threads attempt to access the same\n@@ -418,13 +421,15 @@ problem.\n Let's see an example. This Rust code will not compile:\n \n ```{rust,ignore}\n+use std::thread::Thread;\n+\n fn main() {\n     let mut numbers = vec![1i, 2i, 3i];\n \n     for i in range(0u, 3u) {\n-        spawn(move || {\n+        Thread::spawn(move || {\n             for j in range(0, 3) { numbers[j] += 1 }\n-        });\n+        }).detach();\n     }\n }\n ```\n@@ -469,20 +474,21 @@ mutation doesn't cause a data race.\n Here's what using an Arc with a Mutex looks like:\n \n ```{rust}\n+use std::thread::Thread;\n use std::sync::{Arc,Mutex};\n \n fn main() {\n     let numbers = Arc::new(Mutex::new(vec![1i, 2i, 3i]));\n \n     for i in range(0u, 3u) {\n         let number = numbers.clone();\n-        spawn(move || {\n+        Thread::spawn(move || {\n             let mut array = number.lock();\n \n             (*array)[i] += 1;\n \n             println!(\"numbers[{}] is {}\", i, (*array)[i]);\n-        });\n+        }).detach();\n     }\n }\n ```\n@@ -532,13 +538,15 @@ As an example, Rust's ownership system is _entirely_ at compile time. The\n safety check that makes this an error about moved values:\n \n ```{rust,ignore}\n+use std::thread::Thread;\n+\n fn main() {\n     let vec = vec![1i, 2, 3];\n \n     for i in range(1u, 3) {\n-        spawn(move || {\n+        Thread::spawn(move || {\n             println!(\"{}\", vec[i]);\n-        });\n+        }).detach();\n     }\n }\n ```"}, {"sha": "e909947ab08b0cb9e55d9915803c3fdf26503119", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -39,6 +39,7 @@ use heap::deallocate;\n ///\n /// ```rust\n /// use std::sync::Arc;\n+/// use std::thread::Thread;\n ///\n /// fn main() {\n ///     let numbers = Vec::from_fn(100, |i| i as f32);\n@@ -47,11 +48,11 @@ use heap::deallocate;\n ///     for _ in range(0u, 10) {\n ///         let child_numbers = shared_numbers.clone();\n ///\n-///         spawn(move || {\n+///         Thread::spawn(move || {\n ///             let local_numbers = child_numbers.as_slice();\n ///\n ///             // Work with the local numbers\n-///         });\n+///         }).detach();\n ///     }\n /// }\n /// ```"}, {"sha": "d3790e320ad651b955d6b675f15d25714eccec76", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -1344,8 +1344,7 @@ pub mod raw {\n \n #[cfg(test)]\n mod tests {\n-    extern crate rustrt;\n-\n+    use std::boxed::Box;\n     use std::cell::Cell;\n     use std::default::Default;\n     use std::mem;\n@@ -1629,9 +1628,10 @@ mod tests {\n     #[test]\n     fn test_swap_remove_noncopyable() {\n         // Tests that we don't accidentally run destructors twice.\n-        let mut v = vec![rustrt::exclusive::Exclusive::new(()),\n-                         rustrt::exclusive::Exclusive::new(()),\n-                         rustrt::exclusive::Exclusive::new(())];\n+        let mut v = Vec::new();\n+        v.push(box 0u8);\n+        v.push(box 0u8);\n+        v.push(box 0u8);\n         let mut _e = v.swap_remove(0);\n         assert_eq!(v.len(), 2);\n         _e = v.swap_remove(1);\n@@ -1736,7 +1736,7 @@ mod tests {\n         v2.dedup();\n         /*\n          * If the boxed pointers were leaked or otherwise misused, valgrind\n-         * and/or rustrt should raise errors.\n+         * and/or rt should raise errors.\n          */\n     }\n \n@@ -1750,7 +1750,7 @@ mod tests {\n         v2.dedup();\n         /*\n          * If the pointers were leaked or otherwise misused, valgrind and/or\n-         * rustrt should raise errors.\n+         * rt should raise errors.\n          */\n     }\n "}, {"sha": "979ddaecb4ae3087d809ba0a8b986f1f778e975e", "filename": "src/libcoretest/finally.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibcoretest%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibcoretest%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Ffinally.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use core::finally::{try_finally, Finally};\n-use std::task::failing;\n+use std::thread::Thread;\n \n #[test]\n fn test_success() {\n@@ -20,7 +20,7 @@ fn test_success() {\n             *i = 10;\n         },\n         |i| {\n-            assert!(!failing());\n+            assert!(!Thread::panicking());\n             assert_eq!(*i, 10);\n             *i = 20;\n         });\n@@ -38,7 +38,7 @@ fn test_fail() {\n             panic!();\n         },\n         |i| {\n-            assert!(failing());\n+            assert!(Thread::panicking());\n             assert_eq!(*i, 10);\n         })\n }"}, {"sha": "6ab00cfe8fa6a616cd67b54deec98bb7013065ef", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -138,7 +138,7 @@ pub use funcs::c95::stdio::{fread, freopen, fseek, fsetpos, ftell};\n pub use funcs::c95::stdio::{fwrite, perror, puts, remove, rename, rewind};\n pub use funcs::c95::stdio::{setbuf, setvbuf, tmpfile, ungetc};\n \n-pub use funcs::c95::stdlib::{abs, atof, atoi, calloc, exit, _exit};\n+pub use funcs::c95::stdlib::{abs, atof, atoi, calloc, exit, _exit, atexit};\n pub use funcs::c95::stdlib::{free, getenv, labs, malloc, rand};\n pub use funcs::c95::stdlib::{realloc, srand, strtod, strtol};\n pub use funcs::c95::stdlib::{strtoul, system};\n@@ -4102,7 +4102,7 @@ pub mod funcs {\n                 pub fn free(p: *mut c_void);\n                 pub fn exit(status: c_int) -> !;\n                 pub fn _exit(status: c_int) -> !;\n-                // Omitted: atexit.\n+                pub fn atexit(cb: extern fn()) -> c_int;\n                 pub fn system(s: *const c_char) -> c_int;\n                 pub fn getenv(s: *const c_char) -> *mut c_char;\n                 // Omitted: bsearch, qsort"}, {"sha": "120654678e96e9d2b83431b47b60e787f75eecef", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -55,7 +55,7 @@ use rustc::DIAGNOSTICS;\n use std::any::AnyRefExt;\n use std::io;\n use std::os;\n-use std::task::TaskBuilder;\n+use std::thread;\n \n use rustc::session::early_error;\n \n@@ -478,15 +478,15 @@ pub fn monitor<F:FnOnce()+Send>(f: F) {\n     let w = io::ChanWriter::new(tx);\n     let mut r = io::ChanReader::new(rx);\n \n-    let mut task = TaskBuilder::new().named(\"rustc\").stderr(box w);\n+    let mut cfg = thread::Builder::new().name(\"rustc\".to_string());\n \n     // FIXME: Hacks on hacks. If the env is trying to override the stack size\n     // then *don't* set it explicitly.\n     if os::getenv(\"RUST_MIN_STACK\").is_none() {\n-        task = task.stack_size(STACK_SIZE);\n+        cfg = cfg.stack_size(STACK_SIZE);\n     }\n \n-    match task.try(f) {\n+    match cfg.spawn(move || { std::io::stdio::set_stderr(box w); f() }).join() {\n         Ok(()) => { /* fallthrough */ }\n         Err(value) => {\n             // Task panicked without emitting a fatal diagnostic\n@@ -540,4 +540,3 @@ pub fn main() {\n     let result = run(args);\n     std::os::set_exit_status(result);\n }\n-"}, {"sha": "df7df2f08d9839f84b8ac6b7bd5ce77f340d6f33", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -30,7 +30,7 @@ use std::ptr;\n use std::str;\n use std::mem;\n use std::sync::{Arc, Mutex};\n-use std::task::TaskBuilder;\n+use std::thread;\n use libc::{c_uint, c_int, c_void};\n \n #[deriving(Clone, PartialEq, PartialOrd, Ord, Eq)]\n@@ -896,7 +896,11 @@ fn run_work_multithreaded(sess: &Session,\n         let diag_emitter = diag_emitter.clone();\n         let remark = sess.opts.cg.remark.clone();\n \n-        let future = TaskBuilder::new().named(format!(\"codegen-{}\", i)).try_future(move |:| {\n+        let (tx, rx) = channel();\n+        let mut tx = Some(tx);\n+        futures.push(rx);\n+\n+        thread::Builder::new().name(format!(\"codegen-{}\", i)).spawn(move |:| {\n             let diag_handler = mk_handler(box diag_emitter);\n \n             // Must construct cgcx inside the proc because it has non-Send\n@@ -921,13 +925,14 @@ fn run_work_multithreaded(sess: &Session,\n                     None => break,\n                 }\n             }\n-        });\n-        futures.push(future);\n+\n+            tx.take().unwrap().send(());\n+        }).detach();\n     }\n \n     let mut panicked = false;\n-    for future in futures.into_iter() {\n-        match future.into_inner() {\n+    for rx in futures.into_iter() {\n+        match rx.recv_opt() {\n             Ok(()) => {},\n             Err(_) => {\n                 panicked = true;"}, {"sha": "9b99956937c24cc6f270818c3835b9319e7d580e", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -102,7 +102,11 @@ struct Output {\n }\n \n pub fn main() {\n-    std::os::set_exit_status(main_args(std::os::args().as_slice()));\n+    static STACK_SIZE: uint = 32000000; // 32MB\n+    let res = std::thread::Builder::new().stack_size(STACK_SIZE).spawn(move || {\n+        main_args(std::os::args().as_slice())\n+    }).join();\n+    std::os::set_exit_status(res.map_err(|_| ()).unwrap());\n }\n \n pub fn opts() -> Vec<getopts::OptGroup> {\n@@ -342,10 +346,11 @@ fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matche\n \n     let cr = Path::new(cratefile);\n     info!(\"starting to run rustc\");\n-    let (mut krate, analysis) = std::task::try(move |:| {\n+\n+    let (mut krate, analysis) = std::thread::Thread::spawn(move |:| {\n         let cr = cr;\n         core::run_core(libs, cfgs, externs, &cr, triple)\n-    }).map_err(|_| \"rustc failed\").unwrap();\n+    }).join().map_err(|_| \"rustc failed\").unwrap();\n     info!(\"finished with rustc\");\n     let mut analysis = Some(analysis);\n     ANALYSISKEY.with(|s| {"}, {"sha": "b55097c0c5a1bd734acae3c14e570db29c94ba64", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -16,6 +16,7 @@ use std::os;\n use std::str;\n use std::string::String;\n use std::thunk::Thunk;\n+use std::thread::Thread;\n \n use std::collections::{HashSet, HashMap};\n use testing;\n@@ -143,7 +144,7 @@ fn runtest(test: &str, cratename: &str, libs: Vec<Path>, externs: core::Externs,\n     let w1 = io::ChanWriter::new(tx);\n     let w2 = w1.clone();\n     let old = io::stdio::set_stderr(box w1);\n-    spawn(move |:| {\n+    Thread::spawn(move |:| {\n         let mut p = io::ChanReader::new(rx);\n         let mut err = match old {\n             Some(old) => {\n@@ -154,7 +155,7 @@ fn runtest(test: &str, cratename: &str, libs: Vec<Path>, externs: core::Externs,\n             None => box io::stderr() as Box<Writer>,\n         };\n         io::util::copy(&mut p, &mut err).unwrap();\n-    });\n+    }).detach();\n     let emitter = diagnostic::EmitterWriter::new(box w2, None);\n \n     // Compile the code"}, {"sha": "8be77d9b34dddff5fdd8d9c49e7cabd1b05c3814", "filename": "src/librustrt/at_exit_imp.rs", "status": "removed", "additions": 0, "deletions": 65, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/6bdce25e155d846bb9252fa4a18baef7e74cf8bf/src%2Flibrustrt%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bdce25e155d846bb9252fa4a18baef7e74cf8bf/src%2Flibrustrt%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fat_exit_imp.rs?ref=6bdce25e155d846bb9252fa4a18baef7e74cf8bf", "patch": "@@ -1,65 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Implementation of running at_exit routines\n-//!\n-//! Documentation can be found on the `rt::at_exit` function.\n-\n-use core::prelude::*;\n-\n-use alloc::boxed::Box;\n-use collections::vec::Vec;\n-use core::atomic;\n-use core::mem;\n-use thunk::{Thunk};\n-\n-use exclusive::Exclusive;\n-\n-type Queue = Exclusive<Vec<Thunk>>;\n-\n-static QUEUE: atomic::AtomicUint = atomic::INIT_ATOMIC_UINT;\n-static RUNNING: atomic::AtomicBool = atomic::INIT_ATOMIC_BOOL;\n-\n-pub fn init() {\n-    let state: Box<Queue> = box Exclusive::new(Vec::new());\n-    unsafe {\n-        rtassert!(!RUNNING.load(atomic::SeqCst));\n-        assert!(QUEUE.swap(mem::transmute(state), atomic::SeqCst) == 0);\n-    }\n-}\n-\n-pub fn push(f: Thunk) {\n-    unsafe {\n-        // Note that the check against 0 for the queue pointer is not atomic at\n-        // all with respect to `run`, meaning that this could theoretically be a\n-        // use-after-free. There's not much we can do to protect against that,\n-        // however. Let's just assume a well-behaved runtime and go from there!\n-        rtassert!(!RUNNING.load(atomic::SeqCst));\n-        let queue = QUEUE.load(atomic::SeqCst);\n-        rtassert!(queue != 0);\n-        (*(queue as *const Queue)).lock().push(f);\n-    }\n-}\n-\n-pub fn run() {\n-    let cur = unsafe {\n-        rtassert!(!RUNNING.load(atomic::SeqCst));\n-        let queue = QUEUE.swap(0, atomic::SeqCst);\n-        rtassert!(queue != 0);\n-\n-        let queue: Box<Queue> = mem::transmute(queue);\n-        let v = mem::replace(&mut *queue.lock(), Vec::new());\n-        v\n-    };\n-\n-    for to_run in cur.into_iter() {\n-        to_run.invoke(());\n-    }\n-}"}, {"sha": "e918a496d55316d3e5ada32472b58c2aed098139", "filename": "src/librustrt/bookkeeping.rs", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/6bdce25e155d846bb9252fa4a18baef7e74cf8bf/src%2Flibrustrt%2Fbookkeeping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bdce25e155d846bb9252fa4a18baef7e74cf8bf/src%2Flibrustrt%2Fbookkeeping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fbookkeeping.rs?ref=6bdce25e155d846bb9252fa4a18baef7e74cf8bf", "patch": "@@ -1,61 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Task bookkeeping\n-//!\n-//! This module keeps track of the number of running tasks so that entry points\n-//! with libnative know when it's possible to exit the program (once all tasks\n-//! have exited).\n-//!\n-//! The green counterpart for this is bookkeeping on sched pools, and it's up to\n-//! each respective runtime to make sure that they call increment() and\n-//! decrement() manually.\n-\n-use core::atomic;\n-use core::ops::Drop;\n-\n-use mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n-\n-static TASK_COUNT: atomic::AtomicUint = atomic::INIT_ATOMIC_UINT;\n-static TASK_LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n-\n-#[allow(missing_copy_implementations)]\n-pub struct Token { _private: () }\n-\n-impl Drop for Token {\n-    fn drop(&mut self) { decrement() }\n-}\n-\n-/// Increment the number of live tasks, returning a token which will decrement\n-/// the count when dropped.\n-pub fn increment() -> Token {\n-    let _ = TASK_COUNT.fetch_add(1, atomic::SeqCst);\n-    Token { _private: () }\n-}\n-\n-pub fn decrement() {\n-    unsafe {\n-        if TASK_COUNT.fetch_sub(1, atomic::SeqCst) == 1 {\n-            let guard = TASK_LOCK.lock();\n-            guard.signal();\n-        }\n-    }\n-}\n-\n-/// Waits for all other native tasks in the system to exit. This is only used by\n-/// the entry points of native programs\n-pub fn wait_for_other_tasks() {\n-    unsafe {\n-        let guard = TASK_LOCK.lock();\n-        while TASK_COUNT.load(atomic::SeqCst) > 0 {\n-            guard.wait();\n-        }\n-    }\n-}"}, {"sha": "02ca7d3ce6d45a412f7850149c17dbabb8ac44d4", "filename": "src/librustrt/lib.rs", "status": "removed", "additions": 0, "deletions": 132, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/6bdce25e155d846bb9252fa4a18baef7e74cf8bf/src%2Flibrustrt%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bdce25e155d846bb9252fa4a18baef7e74cf8bf/src%2Flibrustrt%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flib.rs?ref=6bdce25e155d846bb9252fa4a18baef7e74cf8bf", "patch": "@@ -1,132 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![crate_name = \"rustrt\"]\n-#![crate_type = \"rlib\"]\n-#![crate_type = \"dylib\"]\n-#![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n-       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n-\n-#![allow(unknown_features)]\n-#![feature(macro_rules, phase, globs, thread_local, asm)]\n-#![feature(linkage, lang_items, unsafe_destructor, default_type_params)]\n-#![feature(import_shadowing, slicing_syntax)]\n-#![feature(unboxed_closures)]\n-#![no_std]\n-#![experimental]\n-\n-#[phase(plugin, link)] extern crate core;\n-extern crate alloc;\n-extern crate libc;\n-extern crate collections;\n-\n-#[cfg(test)] extern crate \"rustrt\" as realrustrt;\n-#[cfg(test)] extern crate test;\n-\n-#[cfg(test)] #[phase(plugin, link)] extern crate std;\n-\n-pub use self::util::{Stdio, Stdout, Stderr};\n-pub use self::unwind::{begin_unwind, begin_unwind_fmt};\n-\n-use core::prelude::*;\n-\n-mod macros;\n-\n-mod at_exit_imp;\n-mod local_ptr;\n-mod thread_local_storage;\n-mod util;\n-mod libunwind;\n-mod stack_overflow;\n-pub mod thunk;\n-\n-pub mod args;\n-pub mod bookkeeping;\n-pub mod c_str;\n-pub mod exclusive;\n-pub mod local;\n-pub mod mutex;\n-pub mod stack;\n-pub mod task;\n-pub mod thread;\n-pub mod unwind;\n-\n-/// The default error code of the rust runtime if the main task panics instead\n-/// of exiting cleanly.\n-pub const DEFAULT_ERROR_CODE: int = 101;\n-\n-/// One-time runtime initialization.\n-///\n-/// Initializes global state, including frobbing the crate's logging flags,\n-/// and storing the process arguments.\n-pub fn init(argc: int, argv: *const *const u8) {\n-    // FIXME: Derefing these pointers is not safe.\n-    // Need to propagate the unsafety to `start`.\n-    unsafe {\n-        args::init(argc, argv);\n-        local_ptr::init();\n-        at_exit_imp::init();\n-        thread::init();\n-    }\n-\n-    // FIXME(#14344) this shouldn't be necessary\n-    collections::fixme_14344_be_sure_to_link_to_collections();\n-    alloc::fixme_14344_be_sure_to_link_to_collections();\n-    libc::issue_14344_workaround();\n-}\n-\n-/// Enqueues a procedure to run when the runtime is cleaned up\n-///\n-/// The procedure passed to this function will be executed as part of the\n-/// runtime cleanup phase. For normal rust programs, this means that it will run\n-/// after all other tasks have exited.\n-///\n-/// The procedure is *not* executed with a local `Task` available to it, so\n-/// primitives like logging, I/O, channels, spawning, etc, are *not* available.\n-/// This is meant for \"bare bones\" usage to clean up runtime details, this is\n-/// not meant as a general-purpose \"let's clean everything up\" function.\n-///\n-/// It is forbidden for procedures to register more `at_exit` handlers when they\n-/// are running, and doing so will lead to a process abort.\n-pub fn at_exit<F:FnOnce()+Send>(f: F) {\n-    at_exit_imp::push(thunk::Thunk::new(f));\n-}\n-\n-/// One-time runtime cleanup.\n-///\n-/// This function is unsafe because it performs no checks to ensure that the\n-/// runtime has completely ceased running. It is the responsibility of the\n-/// caller to ensure that the runtime is entirely shut down and nothing will be\n-/// poking around at the internal components.\n-///\n-/// Invoking cleanup while portions of the runtime are still in use may cause\n-/// undefined behavior.\n-pub unsafe fn cleanup() {\n-    bookkeeping::wait_for_other_tasks();\n-    at_exit_imp::run();\n-    args::cleanup();\n-    thread::cleanup();\n-    local_ptr::cleanup();\n-}\n-\n-// FIXME: these probably shouldn't be public...\n-#[doc(hidden)]\n-pub mod shouldnt_be_public {\n-    #[cfg(not(test))]\n-    pub use super::local_ptr::native::maybe_tls_key;\n-    #[cfg(all(not(windows), not(target_os = \"android\"), not(target_os = \"ios\")))]\n-    pub use super::local_ptr::compiled::RT_TLS_PTR;\n-}\n-\n-#[cfg(not(test))]\n-mod std {\n-    pub use core::{fmt, option, cmp, kinds};\n-}"}, {"sha": "df733d7ee225be4a3b71e9c7bdb20e7211732ed9", "filename": "src/librustrt/local.rs", "status": "removed", "additions": 0, "deletions": 131, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/6bdce25e155d846bb9252fa4a18baef7e74cf8bf/src%2Flibrustrt%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bdce25e155d846bb9252fa4a18baef7e74cf8bf/src%2Flibrustrt%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flocal.rs?ref=6bdce25e155d846bb9252fa4a18baef7e74cf8bf", "patch": "@@ -1,131 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use core::prelude::*;\n-\n-use alloc::boxed::Box;\n-use local_ptr;\n-use task::Task;\n-\n-/// Encapsulates some task-local data.\n-pub trait Local<Borrowed> {\n-    fn put(value: Box<Self>);\n-    fn take() -> Box<Self>;\n-    fn try_take() -> Option<Box<Self>>;\n-    fn exists(unused_value: Option<Self>) -> bool;\n-    fn borrow(unused_value: Option<Self>) -> Borrowed;\n-    unsafe fn unsafe_take() -> Box<Self>;\n-    unsafe fn unsafe_borrow() -> *mut Self;\n-    unsafe fn try_unsafe_borrow() -> Option<*mut Self>;\n-}\n-\n-impl Local<local_ptr::Borrowed<Task>> for Task {\n-    #[inline]\n-    fn put(value: Box<Task>) { unsafe { local_ptr::put(value) } }\n-    #[inline]\n-    fn take() -> Box<Task> { unsafe { local_ptr::take() } }\n-    #[inline]\n-    fn try_take() -> Option<Box<Task>> { unsafe { local_ptr::try_take() } }\n-    fn exists(_: Option<Task>) -> bool { local_ptr::exists() }\n-    #[inline]\n-    fn borrow(_: Option<Task>) -> local_ptr::Borrowed<Task> {\n-        unsafe {\n-            local_ptr::borrow::<Task>()\n-        }\n-    }\n-    #[inline]\n-    unsafe fn unsafe_take() -> Box<Task> { local_ptr::unsafe_take() }\n-    #[inline]\n-    unsafe fn unsafe_borrow() -> *mut Task { local_ptr::unsafe_borrow() }\n-    #[inline]\n-    unsafe fn try_unsafe_borrow() -> Option<*mut Task> {\n-        local_ptr::try_unsafe_borrow()\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use std::prelude::*;\n-    use thread::Thread;\n-    use super::*;\n-    use task::Task;\n-\n-    #[test]\n-    fn thread_local_task_smoke_test() {\n-        Thread::start(move|| {\n-            let task = box Task::new(None, None);\n-            Local::put(task);\n-            let task: Box<Task> = Local::take();\n-            cleanup_task(task);\n-        }).join();\n-    }\n-\n-    #[test]\n-    fn thread_local_task_two_instances() {\n-        Thread::start(move|| {\n-            let task = box Task::new(None, None);\n-            Local::put(task);\n-            let task: Box<Task> = Local::take();\n-            cleanup_task(task);\n-            let task = box Task::new(None, None);\n-            Local::put(task);\n-            let task: Box<Task> = Local::take();\n-            cleanup_task(task);\n-        }).join();\n-    }\n-\n-    #[test]\n-    fn borrow_smoke_test() {\n-        Thread::start(move|| {\n-            let task = box Task::new(None, None);\n-            Local::put(task);\n-\n-            unsafe {\n-                let _task: *mut Task = Local::unsafe_borrow();\n-            }\n-            let task: Box<Task> = Local::take();\n-            cleanup_task(task);\n-        }).join();\n-    }\n-\n-    #[test]\n-    fn borrow_with_return() {\n-        Thread::start(move|| {\n-            let task = box Task::new(None, None);\n-            Local::put(task);\n-\n-            {\n-                let _ = Local::borrow(None::<Task>);\n-            }\n-\n-            let task: Box<Task> = Local::take();\n-            cleanup_task(task);\n-        }).join();\n-    }\n-\n-    #[test]\n-    fn try_take() {\n-        Thread::start(move|| {\n-            let task = box Task::new(None, None);\n-            Local::put(task);\n-\n-            let t: Box<Task> = Local::try_take().unwrap();\n-            let u: Option<Box<Task>> = Local::try_take();\n-            assert!(u.is_none());\n-\n-            cleanup_task(t);\n-        }).join();\n-    }\n-\n-    fn cleanup_task(t: Box<Task>) {\n-        t.drop();\n-    }\n-\n-}"}, {"sha": "58f8f8b310f5551dd14f591efa8de292de6371d9", "filename": "src/librustrt/local_ptr.rs", "status": "removed", "additions": 0, "deletions": 404, "changes": 404, "blob_url": "https://github.com/rust-lang/rust/blob/6bdce25e155d846bb9252fa4a18baef7e74cf8bf/src%2Flibrustrt%2Flocal_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bdce25e155d846bb9252fa4a18baef7e74cf8bf/src%2Flibrustrt%2Flocal_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flocal_ptr.rs?ref=6bdce25e155d846bb9252fa4a18baef7e74cf8bf", "patch": "@@ -1,404 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Access to a single thread-local pointer.\n-//!\n-//! The runtime will use this for storing Box<Task>.\n-//!\n-//! FIXME: Add runtime checks for usage of inconsistent pointer types.\n-//! and for overwriting an existing pointer.\n-\n-#![allow(dead_code)]\n-\n-use core::prelude::*;\n-\n-use core::mem;\n-use alloc::boxed::Box;\n-\n-#[cfg(any(windows, // mingw-w32 doesn't like thread_local things\n-          target_os = \"android\", // see #10686\n-          target_os = \"ios\"))]\n-pub use self::native::{init, cleanup, put, take, try_take, unsafe_take, exists,\n-                       unsafe_borrow, try_unsafe_borrow};\n-\n-#[cfg(not(any(windows, target_os = \"android\", target_os = \"ios\")))]\n-pub use self::compiled::{init, cleanup, put, take, try_take, unsafe_take, exists,\n-                         unsafe_borrow, try_unsafe_borrow};\n-\n-/// Encapsulates a borrowed value. When this value goes out of scope, the\n-/// pointer is returned.\n-pub struct Borrowed<T> {\n-    val: *const (),\n-}\n-\n-#[unsafe_destructor]\n-impl<T> Drop for Borrowed<T> {\n-    fn drop(&mut self) {\n-        unsafe {\n-            if self.val.is_null() {\n-                rtabort!(\"Aiee, returning null borrowed object!\");\n-            }\n-            let val: Box<T> = mem::transmute(self.val);\n-            put::<T>(val);\n-            rtassert!(exists());\n-        }\n-    }\n-}\n-\n-impl<T> Deref<T> for Borrowed<T> {\n-    fn deref<'a>(&'a self) -> &'a T {\n-        unsafe { &*(self.val as *const T) }\n-    }\n-}\n-\n-impl<T> DerefMut<T> for Borrowed<T> {\n-    fn deref_mut<'a>(&'a mut self) -> &'a mut T {\n-        unsafe { &mut *(self.val as *mut T) }\n-    }\n-}\n-\n-/// Borrow the thread-local value from thread-local storage.\n-/// While the value is borrowed it is not available in TLS.\n-///\n-/// # Safety note\n-///\n-/// Does not validate the pointer type.\n-#[inline]\n-pub unsafe fn borrow<T>() -> Borrowed<T> {\n-    let val: *const () = mem::transmute(take::<T>());\n-    Borrowed {\n-        val: val,\n-    }\n-}\n-\n-/// Compiled implementation of accessing the runtime local pointer. This is\n-/// implemented using LLVM's thread_local attribute which isn't necessarily\n-/// working on all platforms. This implementation is faster, however, so we use\n-/// it wherever possible.\n-#[cfg(not(any(windows, target_os = \"android\", target_os = \"ios\")))]\n-pub mod compiled {\n-    use core::prelude::*;\n-\n-    use alloc::boxed::Box;\n-    use core::mem;\n-\n-    #[cfg(test)]\n-    pub use realrustrt::shouldnt_be_public::RT_TLS_PTR;\n-\n-    #[cfg(not(test))]\n-    #[thread_local]\n-    pub static mut RT_TLS_PTR: *mut u8 = 0 as *mut u8;\n-\n-    pub fn init() {}\n-\n-    pub unsafe fn cleanup() {}\n-\n-    // Rationale for all of these functions being inline(never)\n-    //\n-    // The #[thread_local] annotation gets propagated all the way through to\n-    // LLVM, meaning the global is specially treated by LLVM to lower it to an\n-    // efficient sequence of instructions. This also involves dealing with fun\n-    // stuff in object files and whatnot. Regardless, it turns out this causes\n-    // trouble with green threads and lots of optimizations turned on. The\n-    // following case study was done on Linux x86_64, but I would imagine that\n-    // other platforms are similar.\n-    //\n-    // On Linux, the instruction sequence for loading the tls pointer global\n-    // looks like:\n-    //\n-    //      mov %fs:0x0, %rax\n-    //      mov -0x8(%rax), %rbx\n-    //\n-    // This code leads me to believe that (%fs:0x0) is a table, and then the\n-    // table contains the TLS values for the process. Hence, the slot at offset\n-    // -0x8 is the task TLS pointer. This leads us to the conclusion that this\n-    // table is the actual thread local part of each thread. The kernel sets up\n-    // the fs segment selector to point at the right region of memory for each\n-    // thread.\n-    //\n-    // Optimizations lead me to believe that this code is lowered to these\n-    // instructions in the LLVM codegen passes, because you'll see code like\n-    // this when everything is optimized:\n-    //\n-    //      mov %fs:0x0, %r14\n-    //      mov -0x8(%r14), %rbx\n-    //      // do something with %rbx, the rust Task pointer\n-    //\n-    //      ... // <- do more things\n-    //\n-    //      mov -0x8(%r14), %rbx\n-    //      // do something else with %rbx\n-    //\n-    // Note that the optimization done here is that the first load is not\n-    // duplicated during the lower instructions. This means that the %fs:0x0\n-    // memory location is only dereferenced once.\n-    //\n-    // Normally, this is actually a good thing! With green threads, however,\n-    // it's very possible for the code labeled \"do more things\" to context\n-    // switch to another thread. If this happens, then we *must* re-load %fs:0x0\n-    // because it's changed (we're on a different thread). If we don't re-load\n-    // the table location, then we'll be reading the original thread's TLS\n-    // values, not our thread's TLS values.\n-    //\n-    // Hence, we never inline these functions. By never inlining, we're\n-    // guaranteed that loading the table is a local decision which is forced to\n-    // *always* happen.\n-\n-    /// Give a pointer to thread-local storage.\n-    ///\n-    /// # Safety note\n-    ///\n-    /// Does not validate the pointer type.\n-    #[inline(never)] // see comments above\n-    pub unsafe fn put<T>(sched: Box<T>) {\n-        RT_TLS_PTR = mem::transmute(sched)\n-    }\n-\n-    /// Take ownership of a pointer from thread-local storage.\n-    ///\n-    /// # Safety note\n-    ///\n-    /// Does not validate the pointer type.\n-    #[inline(never)] // see comments above\n-    pub unsafe fn take<T>() -> Box<T> {\n-        let ptr = RT_TLS_PTR;\n-        rtassert!(!ptr.is_null());\n-        let ptr: Box<T> = mem::transmute(ptr);\n-        // can't use `as`, due to type not matching with `cfg(test)`\n-        RT_TLS_PTR = mem::transmute(0u);\n-        ptr\n-    }\n-\n-    /// Optionally take ownership of a pointer from thread-local storage.\n-    ///\n-    /// # Safety note\n-    ///\n-    /// Does not validate the pointer type.\n-    #[inline(never)] // see comments above\n-    pub unsafe fn try_take<T>() -> Option<Box<T>> {\n-        let ptr = RT_TLS_PTR;\n-        if ptr.is_null() {\n-            None\n-        } else {\n-            let ptr: Box<T> = mem::transmute(ptr);\n-            // can't use `as`, due to type not matching with `cfg(test)`\n-            RT_TLS_PTR = mem::transmute(0u);\n-            Some(ptr)\n-        }\n-    }\n-\n-    /// Take ownership of a pointer from thread-local storage.\n-    ///\n-    /// # Safety note\n-    ///\n-    /// Does not validate the pointer type.\n-    /// Leaves the old pointer in TLS for speed.\n-    #[inline(never)] // see comments above\n-    pub unsafe fn unsafe_take<T>() -> Box<T> {\n-        mem::transmute(RT_TLS_PTR)\n-    }\n-\n-    /// Check whether there is a thread-local pointer installed.\n-    #[inline(never)] // see comments above\n-    pub fn exists() -> bool {\n-        unsafe {\n-            RT_TLS_PTR.is_not_null()\n-        }\n-    }\n-\n-    #[inline(never)] // see comments above\n-    pub unsafe fn unsafe_borrow<T>() -> *mut T {\n-        if RT_TLS_PTR.is_null() {\n-            rtabort!(\"thread-local pointer is null. bogus!\");\n-        }\n-        RT_TLS_PTR as *mut T\n-    }\n-\n-    #[inline(never)] // see comments above\n-    pub unsafe fn try_unsafe_borrow<T>() -> Option<*mut T> {\n-        if RT_TLS_PTR.is_null() {\n-            None\n-        } else {\n-            Some(RT_TLS_PTR as *mut T)\n-        }\n-    }\n-}\n-\n-/// Native implementation of having the runtime thread-local pointer. This\n-/// implementation uses the `thread_local_storage` module to provide a\n-/// thread-local value.\n-pub mod native {\n-    use core::prelude::*;\n-\n-    use alloc::boxed::Box;\n-    use core::mem;\n-    use core::ptr;\n-    use thread_local_storage as tls;\n-\n-    static mut RT_TLS_KEY: tls::Key = -1;\n-\n-    /// Initialize the TLS key. Other ops will fail if this isn't executed\n-    /// first.\n-    pub fn init() {\n-        unsafe {\n-            tls::create(&mut RT_TLS_KEY);\n-        }\n-    }\n-\n-    pub unsafe fn cleanup() {\n-        rtassert!(RT_TLS_KEY != -1);\n-        tls::destroy(RT_TLS_KEY);\n-    }\n-\n-    /// Give a pointer to thread-local storage.\n-    ///\n-    /// # Safety note\n-    ///\n-    /// Does not validate the pointer type.\n-    #[inline]\n-    pub unsafe fn put<T>(sched: Box<T>) {\n-        let key = tls_key();\n-        let void_ptr: *mut u8 = mem::transmute(sched);\n-        tls::set(key, void_ptr);\n-    }\n-\n-    /// Take ownership of a pointer from thread-local storage.\n-    ///\n-    /// # Safety note\n-    ///\n-    /// Does not validate the pointer type.\n-    #[inline]\n-    pub unsafe fn take<T>() -> Box<T> {\n-        let key = tls_key();\n-        let void_ptr: *mut u8 = tls::get(key);\n-        if void_ptr.is_null() {\n-            rtabort!(\"thread-local pointer is null. bogus!\");\n-        }\n-        let ptr: Box<T> = mem::transmute(void_ptr);\n-        tls::set(key, ptr::null_mut());\n-        return ptr;\n-    }\n-\n-    /// Optionally take ownership of a pointer from thread-local storage.\n-    ///\n-    /// # Safety note\n-    ///\n-    /// Does not validate the pointer type.\n-    #[inline]\n-    pub unsafe fn try_take<T>() -> Option<Box<T>> {\n-        match maybe_tls_key() {\n-            Some(key) => {\n-                let void_ptr: *mut u8 = tls::get(key);\n-                if void_ptr.is_null() {\n-                    None\n-                } else {\n-                    let ptr: Box<T> = mem::transmute(void_ptr);\n-                    tls::set(key, ptr::null_mut());\n-                    Some(ptr)\n-                }\n-            }\n-            None => None\n-        }\n-    }\n-\n-    /// Take ownership of a pointer from thread-local storage.\n-    ///\n-    /// # Safety note\n-    ///\n-    /// Does not validate the pointer type.\n-    /// Leaves the old pointer in TLS for speed.\n-    #[inline]\n-    pub unsafe fn unsafe_take<T>() -> Box<T> {\n-        let key = tls_key();\n-        let void_ptr: *mut u8 = tls::get(key);\n-        if void_ptr.is_null() {\n-            rtabort!(\"thread-local pointer is null. bogus!\");\n-        }\n-        let ptr: Box<T> = mem::transmute(void_ptr);\n-        return ptr;\n-    }\n-\n-    /// Check whether there is a thread-local pointer installed.\n-    pub fn exists() -> bool {\n-        unsafe {\n-            match maybe_tls_key() {\n-                Some(key) => tls::get(key).is_not_null(),\n-                None => false\n-            }\n-        }\n-    }\n-\n-    /// Borrow a mutable reference to the thread-local value\n-    ///\n-    /// # Safety Note\n-    ///\n-    /// Because this leaves the value in thread-local storage it is possible\n-    /// For the Scheduler pointer to be aliased\n-    pub unsafe fn unsafe_borrow<T>() -> *mut T {\n-        let key = tls_key();\n-        let void_ptr = tls::get(key);\n-        if void_ptr.is_null() {\n-            rtabort!(\"thread-local pointer is null. bogus!\");\n-        }\n-        void_ptr as *mut T\n-    }\n-\n-    pub unsafe fn try_unsafe_borrow<T>() -> Option<*mut T> {\n-        match maybe_tls_key() {\n-            Some(key) => {\n-                let void_ptr = tls::get(key);\n-                if void_ptr.is_null() {\n-                    None\n-                } else {\n-                    Some(void_ptr as *mut T)\n-                }\n-            }\n-            None => None\n-        }\n-    }\n-\n-    #[inline]\n-    fn tls_key() -> tls::Key {\n-        match maybe_tls_key() {\n-            Some(key) => key,\n-            None => rtabort!(\"runtime tls key not initialized\")\n-        }\n-    }\n-\n-    #[inline]\n-    #[cfg(not(test))]\n-    pub fn maybe_tls_key() -> Option<tls::Key> {\n-        unsafe {\n-            // NB: This is a little racy because, while the key is\n-            // initialized under a mutex and it's assumed to be initialized\n-            // in the Scheduler ctor by any thread that needs to use it,\n-            // we are not accessing the key under a mutex.  Threads that\n-            // are not using the new Scheduler but still *want to check*\n-            // whether they are running under a new Scheduler may see a 0\n-            // value here that is in the process of being initialized in\n-            // another thread. I think this is fine since the only action\n-            // they could take if it was initialized would be to check the\n-            // thread-local value and see that it's not set.\n-            if RT_TLS_KEY != -1 {\n-                return Some(RT_TLS_KEY);\n-            } else {\n-                return None;\n-            }\n-        }\n-    }\n-\n-    #[inline] #[cfg(test)]\n-    pub fn maybe_tls_key() -> Option<tls::Key> {\n-        use realrustrt;\n-        unsafe {\n-            mem::transmute(realrustrt::shouldnt_be_public::maybe_tls_key())\n-        }\n-    }\n-}"}, {"sha": "cbfb86a6ac7b2ac7ada773d9afa131ae587108d4", "filename": "src/librustrt/mutex.rs", "status": "removed", "additions": 0, "deletions": 727, "changes": 727, "blob_url": "https://github.com/rust-lang/rust/blob/6bdce25e155d846bb9252fa4a18baef7e74cf8bf/src%2Flibrustrt%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bdce25e155d846bb9252fa4a18baef7e74cf8bf/src%2Flibrustrt%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fmutex.rs?ref=6bdce25e155d846bb9252fa4a18baef7e74cf8bf", "patch": "@@ -1,727 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! A native mutex and condition variable type.\n-//!\n-//! This module contains bindings to the platform's native mutex/condition\n-//! variable primitives. It provides two types: `StaticNativeMutex`, which can\n-//! be statically initialized via the `NATIVE_MUTEX_INIT` value, and a simple\n-//! wrapper `NativeMutex` that has a destructor to clean up after itself. These\n-//! objects serve as both mutexes and condition variables simultaneously.\n-//!\n-//! The static lock is lazily initialized, but it can only be unsafely\n-//! destroyed. A statically initialized lock doesn't necessarily have a time at\n-//! which it can get deallocated. For this reason, there is no `Drop`\n-//! implementation of the static mutex, but rather the `destroy()` method must\n-//! be invoked manually if destruction of the mutex is desired.\n-//!\n-//! The non-static `NativeMutex` type does have a destructor, but cannot be\n-//! statically initialized.\n-//!\n-//! It is not recommended to use this type for idiomatic rust use. These types\n-//! are appropriate where no other options are available, but other rust\n-//! concurrency primitives should be used before them: the `sync` crate defines\n-//! `StaticMutex` and `Mutex` types.\n-//!\n-//! # Example\n-//!\n-//! ```rust\n-//! use rustrt::mutex::{NativeMutex, StaticNativeMutex, NATIVE_MUTEX_INIT};\n-//!\n-//! // Use a statically initialized mutex\n-//! static LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n-//!\n-//! unsafe {\n-//!     let _guard = LOCK.lock();\n-//! } // automatically unlocked here\n-//!\n-//! // Use a normally initialized mutex\n-//! unsafe {\n-//!     let mut lock = NativeMutex::new();\n-//!\n-//!     {\n-//!         let _guard = lock.lock();\n-//!     } // unlocked here\n-//!\n-//!     // sometimes the RAII guard isn't appropriate\n-//!     lock.lock_noguard();\n-//!     lock.unlock_noguard();\n-//! } // `lock` is deallocated here\n-//! ```\n-\n-#![allow(non_camel_case_types)]\n-\n-use core::prelude::*;\n-\n-/// A native mutex suitable for storing in statics (that is, it has\n-/// the `destroy` method rather than a destructor).\n-///\n-/// Prefer the `NativeMutex` type where possible, since that does not\n-/// require manual deallocation.\n-pub struct StaticNativeMutex {\n-    inner: imp::Mutex,\n-}\n-\n-/// A native mutex with a destructor for clean-up.\n-///\n-/// See `StaticNativeMutex` for a version that is suitable for storing in\n-/// statics.\n-pub struct NativeMutex {\n-    inner: StaticNativeMutex\n-}\n-\n-/// Automatically unlocks the mutex that it was created from on\n-/// destruction.\n-///\n-/// Using this makes lock-based code resilient to unwinding/task\n-/// panic, because the lock will be automatically unlocked even\n-/// then.\n-#[must_use]\n-pub struct LockGuard<'a> {\n-    lock: &'a StaticNativeMutex\n-}\n-\n-pub const NATIVE_MUTEX_INIT: StaticNativeMutex = StaticNativeMutex {\n-    inner: imp::MUTEX_INIT,\n-};\n-\n-impl StaticNativeMutex {\n-    /// Creates a new mutex.\n-    ///\n-    /// Note that a mutex created in this way needs to be explicit\n-    /// freed with a call to `destroy` or it will leak.\n-    /// Also it is important to avoid locking until mutex has stopped moving\n-    pub unsafe fn new() -> StaticNativeMutex {\n-        StaticNativeMutex { inner: imp::Mutex::new() }\n-    }\n-\n-    /// Acquires this lock. This assumes that the current thread does not\n-    /// already hold the lock.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// use rustrt::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n-    /// static LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n-    /// unsafe {\n-    ///     let _guard = LOCK.lock();\n-    ///     // critical section...\n-    /// } // automatically unlocked in `_guard`'s destructor\n-    /// ```\n-    ///\n-    /// # Unsafety\n-    ///\n-    /// This method is unsafe because it will not function correctly if this\n-    /// mutex has been *moved* since it was last used. The mutex can move an\n-    /// arbitrary number of times before its first usage, but once a mutex has\n-    /// been used once it is no longer allowed to move (or otherwise it invokes\n-    /// undefined behavior).\n-    ///\n-    /// Additionally, this type does not take into account any form of\n-    /// scheduling model. This will unconditionally block the *os thread* which\n-    /// is not always desired.\n-    pub unsafe fn lock<'a>(&'a self) -> LockGuard<'a> {\n-        self.inner.lock();\n-\n-        LockGuard { lock: self }\n-    }\n-\n-    /// Attempts to acquire the lock. The value returned is `Some` if\n-    /// the attempt succeeded.\n-    ///\n-    /// # Unsafety\n-    ///\n-    /// This method is unsafe for the same reasons as `lock`.\n-    pub unsafe fn trylock<'a>(&'a self) -> Option<LockGuard<'a>> {\n-        if self.inner.trylock() {\n-            Some(LockGuard { lock: self })\n-        } else {\n-            None\n-        }\n-    }\n-\n-    /// Acquire the lock without creating a `LockGuard`.\n-    ///\n-    /// These needs to be paired with a call to `.unlock_noguard`. Prefer using\n-    /// `.lock`.\n-    ///\n-    /// # Unsafety\n-    ///\n-    /// This method is unsafe for the same reasons as `lock`. Additionally, this\n-    /// does not guarantee that the mutex will ever be unlocked, and it is\n-    /// undefined to drop an already-locked mutex.\n-    pub unsafe fn lock_noguard(&self) { self.inner.lock() }\n-\n-    /// Attempts to acquire the lock without creating a\n-    /// `LockGuard`. The value returned is whether the lock was\n-    /// acquired or not.\n-    ///\n-    /// If `true` is returned, this needs to be paired with a call to\n-    /// `.unlock_noguard`. Prefer using `.trylock`.\n-    ///\n-    /// # Unsafety\n-    ///\n-    /// This method is unsafe for the same reasons as `lock_noguard`.\n-    pub unsafe fn trylock_noguard(&self) -> bool {\n-        self.inner.trylock()\n-    }\n-\n-    /// Unlocks the lock. This assumes that the current thread already holds the\n-    /// lock.\n-    ///\n-    /// # Unsafety\n-    ///\n-    /// This method is unsafe for the same reasons as `lock`. Additionally, it\n-    /// is not guaranteed that this is unlocking a previously locked mutex. It\n-    /// is undefined to unlock an unlocked mutex.\n-    pub unsafe fn unlock_noguard(&self) { self.inner.unlock() }\n-\n-    /// Block on the internal condition variable.\n-    ///\n-    /// This function assumes that the lock is already held. Prefer\n-    /// using `LockGuard.wait` since that guarantees that the lock is\n-    /// held.\n-    ///\n-    /// # Unsafety\n-    ///\n-    /// This method is unsafe for the same reasons as `lock`. Additionally, this\n-    /// is unsafe because the mutex may not be currently locked.\n-    pub unsafe fn wait_noguard(&self) { self.inner.wait() }\n-\n-    /// Signals a thread in `wait` to wake up\n-    ///\n-    /// # Unsafety\n-    ///\n-    /// This method is unsafe for the same reasons as `lock`. Additionally, this\n-    /// is unsafe because the mutex may not be currently locked.\n-    pub unsafe fn signal_noguard(&self) { self.inner.signal() }\n-\n-    /// This function is especially unsafe because there are no guarantees made\n-    /// that no other thread is currently holding the lock or waiting on the\n-    /// condition variable contained inside.\n-    pub unsafe fn destroy(&self) { self.inner.destroy() }\n-}\n-\n-impl NativeMutex {\n-    /// Creates a new mutex.\n-    ///\n-    /// The user must be careful to ensure the mutex is not locked when its is\n-    /// being destroyed.\n-    /// Also it is important to avoid locking until mutex has stopped moving\n-    pub unsafe fn new() -> NativeMutex {\n-        NativeMutex { inner: StaticNativeMutex::new() }\n-    }\n-\n-    /// Acquires this lock. This assumes that the current thread does not\n-    /// already hold the lock.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// use rustrt::mutex::NativeMutex;\n-    /// unsafe {\n-    ///     let mut lock = NativeMutex::new();\n-    ///\n-    ///     {\n-    ///         let _guard = lock.lock();\n-    ///         // critical section...\n-    ///     } // automatically unlocked in `_guard`'s destructor\n-    /// }\n-    /// ```\n-    ///\n-    /// # Unsafety\n-    ///\n-    /// This method is unsafe due to the same reasons as\n-    /// `StaticNativeMutex::lock`.\n-    pub unsafe fn lock<'a>(&'a self) -> LockGuard<'a> {\n-        self.inner.lock()\n-    }\n-\n-    /// Attempts to acquire the lock. The value returned is `Some` if\n-    /// the attempt succeeded.\n-    ///\n-    /// # Unsafety\n-    ///\n-    /// This method is unsafe due to the same reasons as\n-    /// `StaticNativeMutex::trylock`.\n-    pub unsafe fn trylock<'a>(&'a self) -> Option<LockGuard<'a>> {\n-        self.inner.trylock()\n-    }\n-\n-    /// Acquire the lock without creating a `LockGuard`.\n-    ///\n-    /// These needs to be paired with a call to `.unlock_noguard`. Prefer using\n-    /// `.lock`.\n-    ///\n-    /// # Unsafety\n-    ///\n-    /// This method is unsafe due to the same reasons as\n-    /// `StaticNativeMutex::lock_noguard`.\n-    pub unsafe fn lock_noguard(&self) { self.inner.lock_noguard() }\n-\n-    /// Attempts to acquire the lock without creating a\n-    /// `LockGuard`. The value returned is whether the lock was\n-    /// acquired or not.\n-    ///\n-    /// If `true` is returned, this needs to be paired with a call to\n-    /// `.unlock_noguard`. Prefer using `.trylock`.\n-    ///\n-    /// # Unsafety\n-    ///\n-    /// This method is unsafe due to the same reasons as\n-    /// `StaticNativeMutex::trylock_noguard`.\n-    pub unsafe fn trylock_noguard(&self) -> bool {\n-        self.inner.trylock_noguard()\n-    }\n-\n-    /// Unlocks the lock. This assumes that the current thread already holds the\n-    /// lock.\n-    ///\n-    /// # Unsafety\n-    ///\n-    /// This method is unsafe due to the same reasons as\n-    /// `StaticNativeMutex::unlock_noguard`.\n-    pub unsafe fn unlock_noguard(&self) { self.inner.unlock_noguard() }\n-\n-    /// Block on the internal condition variable.\n-    ///\n-    /// This function assumes that the lock is already held. Prefer\n-    /// using `LockGuard.wait` since that guarantees that the lock is\n-    /// held.\n-    ///\n-    /// # Unsafety\n-    ///\n-    /// This method is unsafe due to the same reasons as\n-    /// `StaticNativeMutex::wait_noguard`.\n-    pub unsafe fn wait_noguard(&self) { self.inner.wait_noguard() }\n-\n-    /// Signals a thread in `wait` to wake up\n-    ///\n-    /// # Unsafety\n-    ///\n-    /// This method is unsafe due to the same reasons as\n-    /// `StaticNativeMutex::signal_noguard`.\n-    pub unsafe fn signal_noguard(&self) { self.inner.signal_noguard() }\n-}\n-\n-impl Drop for NativeMutex {\n-    fn drop(&mut self) {\n-        unsafe {self.inner.destroy()}\n-    }\n-}\n-\n-impl<'a> LockGuard<'a> {\n-    /// Block on the internal condition variable.\n-    pub unsafe fn wait(&self) {\n-        self.lock.wait_noguard()\n-    }\n-\n-    /// Signals a thread in `wait` to wake up.\n-    pub unsafe fn signal(&self) {\n-        self.lock.signal_noguard()\n-    }\n-}\n-\n-#[unsafe_destructor]\n-impl<'a> Drop for LockGuard<'a> {\n-    fn drop(&mut self) {\n-        unsafe {self.lock.unlock_noguard()}\n-    }\n-}\n-\n-#[cfg(unix)]\n-mod imp {\n-    use libc;\n-    use self::os::{PTHREAD_MUTEX_INITIALIZER, PTHREAD_COND_INITIALIZER,\n-                   pthread_mutex_t, pthread_cond_t};\n-    use core::cell::UnsafeCell;\n-\n-    type pthread_mutexattr_t = libc::c_void;\n-    type pthread_condattr_t = libc::c_void;\n-\n-    #[cfg(any(target_os = \"freebsd\", target_os = \"dragonfly\"))]\n-    mod os {\n-        use libc;\n-\n-        pub type pthread_mutex_t = *mut libc::c_void;\n-        pub type pthread_cond_t = *mut libc::c_void;\n-\n-        pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t =\n-            0 as pthread_mutex_t;\n-        pub const PTHREAD_COND_INITIALIZER: pthread_cond_t =\n-            0 as pthread_cond_t;\n-    }\n-\n-    #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n-    mod os {\n-        use core::kinds::Copy;\n-        use libc;\n-\n-        #[cfg(target_arch = \"x86_64\")]\n-        const __PTHREAD_MUTEX_SIZE__: uint = 56;\n-        #[cfg(target_arch = \"x86_64\")]\n-        const __PTHREAD_COND_SIZE__: uint = 40;\n-        #[cfg(target_arch = \"x86\")]\n-        const __PTHREAD_MUTEX_SIZE__: uint = 40;\n-        #[cfg(target_arch = \"x86\")]\n-        const __PTHREAD_COND_SIZE__: uint = 24;\n-        #[cfg(target_arch = \"arm\")]\n-        const __PTHREAD_MUTEX_SIZE__: uint = 40;\n-        #[cfg(target_arch = \"arm\")]\n-        const __PTHREAD_COND_SIZE__: uint = 24;\n-\n-        const _PTHREAD_MUTEX_SIG_INIT: libc::c_long = 0x32AAABA7;\n-        const _PTHREAD_COND_SIG_INIT: libc::c_long = 0x3CB0B1BB;\n-\n-        #[repr(C)]\n-        pub struct pthread_mutex_t {\n-            __sig: libc::c_long,\n-            __opaque: [u8, ..__PTHREAD_MUTEX_SIZE__],\n-        }\n-\n-        impl Copy for pthread_mutex_t {}\n-\n-        #[repr(C)]\n-        pub struct pthread_cond_t {\n-            __sig: libc::c_long,\n-            __opaque: [u8, ..__PTHREAD_COND_SIZE__],\n-        }\n-\n-        impl Copy for pthread_cond_t {}\n-\n-        pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = pthread_mutex_t {\n-            __sig: _PTHREAD_MUTEX_SIG_INIT,\n-            __opaque: [0, ..__PTHREAD_MUTEX_SIZE__],\n-        };\n-        pub const PTHREAD_COND_INITIALIZER: pthread_cond_t = pthread_cond_t {\n-            __sig: _PTHREAD_COND_SIG_INIT,\n-            __opaque: [0, ..__PTHREAD_COND_SIZE__],\n-        };\n-    }\n-\n-    #[cfg(target_os = \"linux\")]\n-    mod os {\n-        use core::kinds::Copy;\n-        use libc;\n-\n-        // minus 8 because we have an 'align' field\n-        #[cfg(target_arch = \"x86_64\")]\n-        const __SIZEOF_PTHREAD_MUTEX_T: uint = 40 - 8;\n-        #[cfg(target_arch = \"x86\")]\n-        const __SIZEOF_PTHREAD_MUTEX_T: uint = 24 - 8;\n-        #[cfg(target_arch = \"arm\")]\n-        const __SIZEOF_PTHREAD_MUTEX_T: uint = 24 - 8;\n-        #[cfg(target_arch = \"mips\")]\n-        const __SIZEOF_PTHREAD_MUTEX_T: uint = 24 - 8;\n-        #[cfg(target_arch = \"mipsel\")]\n-        const __SIZEOF_PTHREAD_MUTEX_T: uint = 24 - 8;\n-        #[cfg(target_arch = \"x86_64\")]\n-        const __SIZEOF_PTHREAD_COND_T: uint = 48 - 8;\n-        #[cfg(target_arch = \"x86\")]\n-        const __SIZEOF_PTHREAD_COND_T: uint = 48 - 8;\n-        #[cfg(target_arch = \"arm\")]\n-        const __SIZEOF_PTHREAD_COND_T: uint = 48 - 8;\n-        #[cfg(target_arch = \"mips\")]\n-        const __SIZEOF_PTHREAD_COND_T: uint = 48 - 8;\n-        #[cfg(target_arch = \"mipsel\")]\n-        const __SIZEOF_PTHREAD_COND_T: uint = 48 - 8;\n-\n-        #[repr(C)]\n-        pub struct pthread_mutex_t {\n-            __align: libc::c_longlong,\n-            size: [u8, ..__SIZEOF_PTHREAD_MUTEX_T],\n-        }\n-\n-        impl Copy for pthread_mutex_t {}\n-\n-        #[repr(C)]\n-        pub struct pthread_cond_t {\n-            __align: libc::c_longlong,\n-            size: [u8, ..__SIZEOF_PTHREAD_COND_T],\n-        }\n-\n-        impl Copy for pthread_cond_t {}\n-\n-        pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = pthread_mutex_t {\n-            __align: 0,\n-            size: [0, ..__SIZEOF_PTHREAD_MUTEX_T],\n-        };\n-        pub const PTHREAD_COND_INITIALIZER: pthread_cond_t = pthread_cond_t {\n-            __align: 0,\n-            size: [0, ..__SIZEOF_PTHREAD_COND_T],\n-        };\n-    }\n-    #[cfg(target_os = \"android\")]\n-    mod os {\n-        use libc;\n-\n-        #[repr(C)]\n-        pub struct pthread_mutex_t { value: libc::c_int }\n-        #[repr(C)]\n-        pub struct pthread_cond_t { value: libc::c_int }\n-\n-        pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = pthread_mutex_t {\n-            value: 0,\n-        };\n-        pub const PTHREAD_COND_INITIALIZER: pthread_cond_t = pthread_cond_t {\n-            value: 0,\n-        };\n-    }\n-\n-    pub struct Mutex {\n-        lock: UnsafeCell<pthread_mutex_t>,\n-        cond: UnsafeCell<pthread_cond_t>,\n-    }\n-\n-    pub const MUTEX_INIT: Mutex = Mutex {\n-        lock: UnsafeCell { value: PTHREAD_MUTEX_INITIALIZER },\n-        cond: UnsafeCell { value: PTHREAD_COND_INITIALIZER },\n-    };\n-\n-    impl Mutex {\n-        pub unsafe fn new() -> Mutex {\n-            // As mutex might be moved and address is changing it\n-            // is better to avoid initialization of potentially\n-            // opaque OS data before it landed\n-            let m = Mutex {\n-                lock: UnsafeCell::new(PTHREAD_MUTEX_INITIALIZER),\n-                cond: UnsafeCell::new(PTHREAD_COND_INITIALIZER),\n-            };\n-\n-            return m;\n-        }\n-\n-        pub unsafe fn lock(&self) { pthread_mutex_lock(self.lock.get()); }\n-        pub unsafe fn unlock(&self) { pthread_mutex_unlock(self.lock.get()); }\n-        pub unsafe fn signal(&self) { pthread_cond_signal(self.cond.get()); }\n-        pub unsafe fn wait(&self) {\n-            pthread_cond_wait(self.cond.get(), self.lock.get());\n-        }\n-        pub unsafe fn trylock(&self) -> bool {\n-            pthread_mutex_trylock(self.lock.get()) == 0\n-        }\n-        pub unsafe fn destroy(&self) {\n-            pthread_mutex_destroy(self.lock.get());\n-            pthread_cond_destroy(self.cond.get());\n-        }\n-    }\n-\n-    extern {\n-        fn pthread_mutex_destroy(lock: *mut pthread_mutex_t) -> libc::c_int;\n-        fn pthread_cond_destroy(cond: *mut pthread_cond_t) -> libc::c_int;\n-        fn pthread_mutex_lock(lock: *mut pthread_mutex_t) -> libc::c_int;\n-        fn pthread_mutex_trylock(lock: *mut pthread_mutex_t) -> libc::c_int;\n-        fn pthread_mutex_unlock(lock: *mut pthread_mutex_t) -> libc::c_int;\n-\n-        fn pthread_cond_wait(cond: *mut pthread_cond_t,\n-                             lock: *mut pthread_mutex_t) -> libc::c_int;\n-        fn pthread_cond_signal(cond: *mut pthread_cond_t) -> libc::c_int;\n-    }\n-}\n-\n-#[cfg(windows)]\n-mod imp {\n-    use alloc::heap;\n-    use core::atomic;\n-    use core::ptr;\n-    use core::ptr::RawPtr;\n-    use libc::{HANDLE, BOOL, LPSECURITY_ATTRIBUTES, c_void, DWORD, LPCSTR};\n-    use libc;\n-\n-    type LPCRITICAL_SECTION = *mut c_void;\n-    const SPIN_COUNT: DWORD = 4000;\n-    #[cfg(target_arch = \"x86\")]\n-    const CRIT_SECTION_SIZE: uint = 24;\n-    #[cfg(target_arch = \"x86_64\")]\n-    const CRIT_SECTION_SIZE: uint = 40;\n-\n-    pub struct Mutex {\n-        // pointers for the lock/cond handles, atomically updated\n-        lock: atomic::AtomicUint,\n-        cond: atomic::AtomicUint,\n-    }\n-\n-    pub const MUTEX_INIT: Mutex = Mutex {\n-        lock: atomic::INIT_ATOMIC_UINT,\n-        cond: atomic::INIT_ATOMIC_UINT,\n-    };\n-\n-    impl Mutex {\n-        pub unsafe fn new() -> Mutex {\n-            Mutex {\n-                lock: atomic::AtomicUint::new(init_lock()),\n-                cond: atomic::AtomicUint::new(init_cond()),\n-            }\n-        }\n-        pub unsafe fn lock(&self) {\n-            EnterCriticalSection(self.getlock() as LPCRITICAL_SECTION)\n-        }\n-        pub unsafe fn trylock(&self) -> bool {\n-            TryEnterCriticalSection(self.getlock() as LPCRITICAL_SECTION) != 0\n-        }\n-        pub unsafe fn unlock(&self) {\n-            LeaveCriticalSection(self.getlock() as LPCRITICAL_SECTION)\n-        }\n-\n-        pub unsafe fn wait(&self) {\n-            self.unlock();\n-            WaitForSingleObject(self.getcond() as HANDLE, libc::INFINITE);\n-            self.lock();\n-        }\n-\n-        pub unsafe fn signal(&self) {\n-            assert!(SetEvent(self.getcond() as HANDLE) != 0);\n-        }\n-\n-        /// This function is especially unsafe because there are no guarantees made\n-        /// that no other thread is currently holding the lock or waiting on the\n-        /// condition variable contained inside.\n-        pub unsafe fn destroy(&self) {\n-            let lock = self.lock.swap(0, atomic::SeqCst);\n-            let cond = self.cond.swap(0, atomic::SeqCst);\n-            if lock != 0 { free_lock(lock) }\n-            if cond != 0 { free_cond(cond) }\n-        }\n-\n-        unsafe fn getlock(&self) -> *mut c_void {\n-            match self.lock.load(atomic::SeqCst) {\n-                0 => {}\n-                n => return n as *mut c_void\n-            }\n-            let lock = init_lock();\n-            match self.lock.compare_and_swap(0, lock, atomic::SeqCst) {\n-                0 => return lock as *mut c_void,\n-                _ => {}\n-            }\n-            free_lock(lock);\n-            return self.lock.load(atomic::SeqCst) as *mut c_void;\n-        }\n-\n-        unsafe fn getcond(&self) -> *mut c_void {\n-            match self.cond.load(atomic::SeqCst) {\n-                0 => {}\n-                n => return n as *mut c_void\n-            }\n-            let cond = init_cond();\n-            match self.cond.compare_and_swap(0, cond, atomic::SeqCst) {\n-                0 => return cond as *mut c_void,\n-                _ => {}\n-            }\n-            free_cond(cond);\n-            return self.cond.load(atomic::SeqCst) as *mut c_void;\n-        }\n-    }\n-\n-    pub unsafe fn init_lock() -> uint {\n-        let block = heap::allocate(CRIT_SECTION_SIZE, 8) as *mut c_void;\n-        if block.is_null() { ::alloc::oom() }\n-        InitializeCriticalSectionAndSpinCount(block, SPIN_COUNT);\n-        return block as uint;\n-    }\n-\n-    pub unsafe fn init_cond() -> uint {\n-        return CreateEventA(ptr::null_mut(), libc::FALSE, libc::FALSE,\n-                            ptr::null()) as uint;\n-    }\n-\n-    pub unsafe fn free_lock(h: uint) {\n-        DeleteCriticalSection(h as LPCRITICAL_SECTION);\n-        heap::deallocate(h as *mut u8, CRIT_SECTION_SIZE, 8);\n-    }\n-\n-    pub unsafe fn free_cond(h: uint) {\n-        let block = h as HANDLE;\n-        libc::CloseHandle(block);\n-    }\n-\n-    #[allow(non_snake_case)]\n-    extern \"system\" {\n-        fn CreateEventA(lpSecurityAttributes: LPSECURITY_ATTRIBUTES,\n-                        bManualReset: BOOL,\n-                        bInitialState: BOOL,\n-                        lpName: LPCSTR) -> HANDLE;\n-        fn InitializeCriticalSectionAndSpinCount(\n-                        lpCriticalSection: LPCRITICAL_SECTION,\n-                        dwSpinCount: DWORD) -> BOOL;\n-        fn DeleteCriticalSection(lpCriticalSection: LPCRITICAL_SECTION);\n-        fn EnterCriticalSection(lpCriticalSection: LPCRITICAL_SECTION);\n-        fn LeaveCriticalSection(lpCriticalSection: LPCRITICAL_SECTION);\n-        fn TryEnterCriticalSection(lpCriticalSection: LPCRITICAL_SECTION) -> BOOL;\n-        fn SetEvent(hEvent: HANDLE) -> BOOL;\n-        fn WaitForSingleObject(hHandle: HANDLE, dwMilliseconds: DWORD) -> DWORD;\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use std::prelude::*;\n-\n-    use std::mem::drop;\n-    use super::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n-    use thread::Thread;\n-\n-    #[test]\n-    fn smoke_lock() {\n-        static LK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n-        unsafe {\n-            let _guard = LK.lock();\n-        }\n-    }\n-\n-    #[test]\n-    fn smoke_cond() {\n-        static LK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n-        unsafe {\n-            let guard = LK.lock();\n-            let t = Thread::start(move|| {\n-                let guard = LK.lock();\n-                guard.signal();\n-            });\n-            guard.wait();\n-            drop(guard);\n-\n-            t.join();\n-        }\n-    }\n-\n-    #[test]\n-    fn smoke_lock_noguard() {\n-        static LK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n-        unsafe {\n-            LK.lock_noguard();\n-            LK.unlock_noguard();\n-        }\n-    }\n-\n-    #[test]\n-    fn smoke_cond_noguard() {\n-        static LK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n-        unsafe {\n-            LK.lock_noguard();\n-            let t = Thread::start(move|| {\n-                LK.lock_noguard();\n-                LK.signal_noguard();\n-                LK.unlock_noguard();\n-            });\n-            LK.wait_noguard();\n-            LK.unlock_noguard();\n-\n-            t.join();\n-        }\n-    }\n-\n-    #[test]\n-    fn destroy_immediately() {\n-        unsafe {\n-            let m = StaticNativeMutex::new();\n-            m.destroy();\n-        }\n-    }\n-}"}, {"sha": "175e057c22f2ea3e5f70b3147a778a6dc17c24e9", "filename": "src/librustrt/thread.rs", "status": "removed", "additions": 0, "deletions": 559, "changes": 559, "blob_url": "https://github.com/rust-lang/rust/blob/6bdce25e155d846bb9252fa4a18baef7e74cf8bf/src%2Flibrustrt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bdce25e155d846bb9252fa4a18baef7e74cf8bf/src%2Flibrustrt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fthread.rs?ref=6bdce25e155d846bb9252fa4a18baef7e74cf8bf", "patch": "@@ -1,559 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Native os-thread management\n-//!\n-//! This modules contains bindings necessary for managing OS-level threads.\n-//! These functions operate outside of the rust runtime, creating threads\n-//! which are not used for scheduling in any way.\n-\n-#![allow(non_camel_case_types)]\n-\n-use core::prelude::*;\n-\n-use alloc::boxed::Box;\n-use core::mem;\n-use core::uint;\n-use libc;\n-use thunk::{Thunk};\n-\n-use stack;\n-use stack_overflow;\n-\n-pub unsafe fn init() {\n-    imp::guard::init();\n-    stack_overflow::init();\n-}\n-\n-pub unsafe fn cleanup() {\n-    stack_overflow::cleanup();\n-}\n-\n-#[cfg(target_os = \"windows\")]\n-type StartFn = extern \"system\" fn(*mut libc::c_void) -> imp::rust_thread_return;\n-\n-#[cfg(not(target_os = \"windows\"))]\n-type StartFn = extern \"C\" fn(*mut libc::c_void) -> imp::rust_thread_return;\n-\n-/// This struct represents a native thread's state. This is used to join on an\n-/// existing thread created in the join-able state.\n-pub struct Thread<T> {\n-    native: imp::rust_thread,\n-    joined: bool,\n-    packet: Box<Option<T>>,\n-}\n-\n-static DEFAULT_STACK_SIZE: uint = 1024 * 1024;\n-\n-// This is the starting point of rust os threads. The first thing we do\n-// is make sure that we don't trigger __morestack (also why this has a\n-// no_stack_check annotation), and then we extract the main function\n-// and invoke it.\n-#[no_stack_check]\n-fn start_thread(main: *mut libc::c_void) -> imp::rust_thread_return {\n-    unsafe {\n-        stack::record_os_managed_stack_bounds(0, uint::MAX);\n-        let handler = stack_overflow::Handler::new();\n-        let f: Box<Thunk> = mem::transmute(main);\n-        f.invoke(());\n-        drop(handler);\n-        mem::transmute(0 as imp::rust_thread_return)\n-    }\n-}\n-\n-#[no_stack_check]\n-#[cfg(target_os = \"windows\")]\n-extern \"system\" fn thread_start(main: *mut libc::c_void) -> imp::rust_thread_return {\n-    return start_thread(main);\n-}\n-\n-#[no_stack_check]\n-#[cfg(not(target_os = \"windows\"))]\n-extern fn thread_start(main: *mut libc::c_void) -> imp::rust_thread_return {\n-    return start_thread(main);\n-}\n-\n-/// Returns the last writable byte of the main thread's stack next to the guard\n-/// page. Must be called from the main thread.\n-pub fn main_guard_page() -> uint {\n-    unsafe {\n-        imp::guard::main()\n-    }\n-}\n-\n-/// Returns the last writable byte of the current thread's stack next to the\n-/// guard page. Must not be called from the main thread.\n-pub fn current_guard_page() -> uint {\n-    unsafe {\n-        imp::guard::current()\n-    }\n-}\n-\n-// There are two impl blocks b/c if T were specified at the top then it's just a\n-// pain to specify a type parameter on Thread::spawn (which doesn't need the\n-// type parameter).\n-impl Thread<()> {\n-\n-    /// Starts execution of a new OS thread.\n-    ///\n-    /// This function will not wait for the thread to join, but a handle to the\n-    /// thread will be returned.\n-    ///\n-    /// Note that the handle returned is used to acquire the return value of the\n-    /// procedure `main`. The `join` function will wait for the thread to finish\n-    /// and return the value that `main` generated.\n-    ///\n-    /// Also note that the `Thread` returned will *always* wait for the thread\n-    /// to finish executing. This means that even if `join` is not explicitly\n-    /// called, when the `Thread` falls out of scope its destructor will block\n-    /// waiting for the OS thread.\n-    pub fn start<T,F>(main: F) -> Thread<T>\n-        where T:Send, F:FnOnce() -> T, F:Send\n-    {\n-        Thread::start_stack(DEFAULT_STACK_SIZE, main)\n-    }\n-\n-    /// Performs the same functionality as `start`, but specifies an explicit\n-    /// stack size for the new thread.\n-    pub fn start_stack<T, F>(stack: uint, main: F) -> Thread<T>\n-        where T:Send, F:FnOnce() -> T, F:Send\n-    {\n-        // We need the address of the packet to fill in to be stable so when\n-        // `main` fills it in it's still valid, so allocate an extra box to do\n-        // so.\n-        let packet = box None;\n-        let packet2: *mut Option<T> = unsafe {\n-            *mem::transmute::<&Box<Option<T>>, *const *mut Option<T>>(&packet)\n-        };\n-        let native = unsafe {\n-            imp::create(stack, Thunk::new(move |:| {\n-                *packet2 = Some(main.call_once(()));\n-            }))\n-        };\n-\n-        Thread {\n-            native: native,\n-            joined: false,\n-            packet: packet,\n-        }\n-    }\n-\n-    /// This will spawn a new thread, but it will not wait for the thread to\n-    /// finish, nor is it possible to wait for the thread to finish.\n-    ///\n-    /// This corresponds to creating threads in the 'detached' state on unix\n-    /// systems. Note that platforms may not keep the main program alive even if\n-    /// there are detached thread still running around.\n-    pub fn spawn<F>(main: F)\n-        where F : FnOnce() + Send\n-    {\n-        Thread::spawn_stack(DEFAULT_STACK_SIZE, main)\n-    }\n-\n-    /// Performs the same functionality as `spawn`, but explicitly specifies a\n-    /// stack size for the new thread.\n-    pub fn spawn_stack<F>(stack: uint, main: F)\n-        where F : FnOnce() + Send\n-    {\n-        unsafe {\n-            let handle = imp::create(stack, Thunk::new(main));\n-            imp::detach(handle);\n-        }\n-    }\n-\n-    /// Relinquishes the CPU slot that this OS-thread is currently using,\n-    /// allowing another thread to run for awhile.\n-    pub fn yield_now() {\n-        unsafe { imp::yield_now(); }\n-    }\n-}\n-\n-impl<T: Send> Thread<T> {\n-    /// Wait for this thread to finish, returning the result of the thread's\n-    /// calculation.\n-    pub fn join(mut self) -> T {\n-        assert!(!self.joined);\n-        unsafe { imp::join(self.native) };\n-        self.joined = true;\n-        assert!(self.packet.is_some());\n-        self.packet.take().unwrap()\n-    }\n-}\n-\n-#[unsafe_destructor]\n-impl<T: Send> Drop for Thread<T> {\n-    fn drop(&mut self) {\n-        // This is required for correctness. If this is not done then the thread\n-        // would fill in a return box which no longer exists.\n-        if !self.joined {\n-            unsafe { imp::join(self.native) };\n-        }\n-    }\n-}\n-\n-#[cfg(windows)]\n-#[allow(non_snake_case)]\n-mod imp {\n-    use alloc::boxed::Box;\n-    use core::cmp;\n-    use core::mem;\n-    use core::ptr;\n-    use libc;\n-    use libc::types::os::arch::extra::{LPSECURITY_ATTRIBUTES, SIZE_T, BOOL,\n-                                       LPVOID, DWORD, LPDWORD, HANDLE};\n-    use stack::RED_ZONE;\n-    use thunk::Thunk;\n-\n-    pub type rust_thread = HANDLE;\n-    pub type rust_thread_return = DWORD;\n-\n-    pub mod guard {\n-        pub unsafe fn main() -> uint {\n-            0\n-        }\n-\n-        pub unsafe fn current() -> uint {\n-            0\n-        }\n-\n-        pub unsafe fn init() {\n-        }\n-    }\n-\n-    pub unsafe fn create(stack: uint, p: Thunk) -> rust_thread {\n-        let arg: *mut libc::c_void = mem::transmute(box p);\n-\n-        // FIXME On UNIX, we guard against stack sizes that are too small but\n-        // that's because pthreads enforces that stacks are at least\n-        // PTHREAD_STACK_MIN bytes big.  Windows has no such lower limit, it's\n-        // just that below a certain threshold you can't do anything useful.\n-        // That threshold is application and architecture-specific, however.\n-        // For now, the only requirement is that it's big enough to hold the\n-        // red zone.  Round up to the next 64 kB because that's what the NT\n-        // kernel does, might as well make it explicit.  With the current\n-        // 20 kB red zone, that makes for a 64 kB minimum stack.\n-        let stack_size = (cmp::max(stack, RED_ZONE) + 0xfffe) & (-0xfffe - 1);\n-        let ret = CreateThread(ptr::null_mut(), stack_size as libc::size_t,\n-                               super::thread_start, arg, 0, ptr::null_mut());\n-\n-        if ret as uint == 0 {\n-            // be sure to not leak the closure\n-            let _p: Box<Thunk> = mem::transmute(arg);\n-            panic!(\"failed to spawn native thread: {}\", ret);\n-        }\n-        return ret;\n-    }\n-\n-    pub unsafe fn join(native: rust_thread) {\n-        use libc::consts::os::extra::INFINITE;\n-        WaitForSingleObject(native, INFINITE);\n-    }\n-\n-    pub unsafe fn detach(native: rust_thread) {\n-        assert!(libc::CloseHandle(native) != 0);\n-    }\n-\n-    pub unsafe fn yield_now() {\n-        // This function will return 0 if there are no other threads to execute,\n-        // but this also means that the yield was useless so this isn't really a\n-        // case that needs to be worried about.\n-        SwitchToThread();\n-    }\n-\n-    #[allow(non_snake_case)]\n-    extern \"system\" {\n-        fn CreateThread(lpThreadAttributes: LPSECURITY_ATTRIBUTES,\n-                        dwStackSize: SIZE_T,\n-                        lpStartAddress: super::StartFn,\n-                        lpParameter: LPVOID,\n-                        dwCreationFlags: DWORD,\n-                        lpThreadId: LPDWORD) -> HANDLE;\n-        fn WaitForSingleObject(hHandle: HANDLE, dwMilliseconds: DWORD) -> DWORD;\n-        fn SwitchToThread() -> BOOL;\n-    }\n-}\n-\n-#[cfg(unix)]\n-mod imp {\n-    use core::prelude::*;\n-\n-    use alloc::boxed::Box;\n-    use core::cmp;\n-    use core::mem;\n-    use core::ptr;\n-    use libc::consts::os::posix01::{PTHREAD_CREATE_JOINABLE, PTHREAD_STACK_MIN};\n-    use libc;\n-    use thunk::Thunk;\n-\n-    use stack::RED_ZONE;\n-\n-    pub type rust_thread = libc::pthread_t;\n-    pub type rust_thread_return = *mut u8;\n-\n-    #[cfg(all(not(target_os = \"linux\"), not(target_os = \"macos\")))]\n-    pub mod guard {\n-        pub unsafe fn current() -> uint {\n-            0\n-        }\n-\n-        pub unsafe fn main() -> uint {\n-            0\n-        }\n-\n-        pub unsafe fn init() {\n-        }\n-    }\n-\n-    #[cfg(any(target_os = \"linux\", target_os = \"macos\"))]\n-    pub mod guard {\n-        use super::*;\n-        #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-        use core::mem;\n-        #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-        use core::ptr;\n-        use libc;\n-        use libc::funcs::posix88::mman::{mmap};\n-        use libc::consts::os::posix88::{PROT_NONE,\n-                                        MAP_PRIVATE,\n-                                        MAP_ANON,\n-                                        MAP_FAILED,\n-                                        MAP_FIXED};\n-\n-        // These are initialized in init() and only read from after\n-        static mut PAGE_SIZE: uint = 0;\n-        static mut GUARD_PAGE: uint = 0;\n-\n-        #[cfg(target_os = \"macos\")]\n-        unsafe fn get_stack_start() -> *mut libc::c_void {\n-            current() as *mut libc::c_void\n-        }\n-\n-        #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-        unsafe fn get_stack_start() -> *mut libc::c_void {\n-            let mut attr: libc::pthread_attr_t = mem::zeroed();\n-            if pthread_getattr_np(pthread_self(), &mut attr) != 0 {\n-                panic!(\"failed to get thread attributes\");\n-            }\n-            let mut stackaddr = ptr::null_mut();\n-            let mut stacksize = 0;\n-            if pthread_attr_getstack(&attr, &mut stackaddr, &mut stacksize) != 0 {\n-                panic!(\"failed to get stack information\");\n-            }\n-            if pthread_attr_destroy(&mut attr) != 0 {\n-                panic!(\"failed to destroy thread attributes\");\n-            }\n-            stackaddr\n-        }\n-\n-        pub unsafe fn init() {\n-            let psize = libc::sysconf(libc::consts::os::sysconf::_SC_PAGESIZE);\n-            if psize == -1 {\n-                panic!(\"failed to get page size\");\n-            }\n-\n-            PAGE_SIZE = psize as uint;\n-\n-            let stackaddr = get_stack_start();\n-\n-            // Rellocate the last page of the stack.\n-            // This ensures SIGBUS will be raised on\n-            // stack overflow.\n-            let result = mmap(stackaddr,\n-                              PAGE_SIZE as libc::size_t,\n-                              PROT_NONE,\n-                              MAP_PRIVATE | MAP_ANON | MAP_FIXED,\n-                              -1,\n-                              0);\n-\n-            if result != stackaddr || result == MAP_FAILED {\n-                panic!(\"failed to allocate a guard page\");\n-            }\n-\n-            let offset = if cfg!(target_os = \"linux\") {\n-                2\n-            } else {\n-                1\n-            };\n-\n-            GUARD_PAGE = stackaddr as uint + offset * PAGE_SIZE;\n-        }\n-\n-        pub unsafe fn main() -> uint {\n-            GUARD_PAGE\n-        }\n-\n-        #[cfg(target_os = \"macos\")]\n-        pub unsafe fn current() -> uint {\n-            (pthread_get_stackaddr_np(pthread_self()) as libc::size_t -\n-             pthread_get_stacksize_np(pthread_self())) as uint\n-        }\n-\n-        #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-        pub unsafe fn current() -> uint {\n-            let mut attr: libc::pthread_attr_t = mem::zeroed();\n-            if pthread_getattr_np(pthread_self(), &mut attr) != 0 {\n-                panic!(\"failed to get thread attributes\");\n-            }\n-            let mut guardsize = 0;\n-            if pthread_attr_getguardsize(&attr, &mut guardsize) != 0 {\n-                panic!(\"failed to get stack guard page\");\n-            }\n-            if guardsize == 0 {\n-                panic!(\"there is no guard page\");\n-            }\n-            let mut stackaddr = ptr::null_mut();\n-            let mut stacksize = 0;\n-            if pthread_attr_getstack(&attr, &mut stackaddr, &mut stacksize) != 0 {\n-                panic!(\"failed to get stack information\");\n-            }\n-            if pthread_attr_destroy(&mut attr) != 0 {\n-                panic!(\"failed to destroy thread attributes\");\n-            }\n-\n-            stackaddr as uint + guardsize as uint\n-        }\n-    }\n-\n-    pub unsafe fn create(stack: uint, p: Thunk) -> rust_thread {\n-        let mut native: libc::pthread_t = mem::zeroed();\n-        let mut attr: libc::pthread_attr_t = mem::zeroed();\n-        assert_eq!(pthread_attr_init(&mut attr), 0);\n-        assert_eq!(pthread_attr_setdetachstate(&mut attr,\n-                                               PTHREAD_CREATE_JOINABLE), 0);\n-\n-        // Reserve room for the red zone, the runtime's stack of last resort.\n-        let stack_size = cmp::max(stack, RED_ZONE + min_stack_size(&attr) as uint);\n-        match pthread_attr_setstacksize(&mut attr, stack_size as libc::size_t) {\n-            0 => {\n-            },\n-            libc::EINVAL => {\n-                // EINVAL means |stack_size| is either too small or not a\n-                // multiple of the system page size.  Because it's definitely\n-                // >= PTHREAD_STACK_MIN, it must be an alignment issue.\n-                // Round up to the nearest page and try again.\n-                let page_size = libc::sysconf(libc::_SC_PAGESIZE) as uint;\n-                let stack_size = (stack_size + page_size - 1) &\n-                                 (-(page_size as int - 1) as uint - 1);\n-                assert_eq!(pthread_attr_setstacksize(&mut attr, stack_size as libc::size_t), 0);\n-            },\n-            errno => {\n-                // This cannot really happen.\n-                panic!(\"pthread_attr_setstacksize() error: {}\", errno);\n-            },\n-        };\n-\n-        let arg: *mut libc::c_void = mem::transmute(box p); // must box since sizeof(p)=2*uint\n-        let ret = pthread_create(&mut native, &attr, super::thread_start, arg);\n-        assert_eq!(pthread_attr_destroy(&mut attr), 0);\n-\n-        if ret != 0 {\n-            // be sure to not leak the closure\n-            let _p: Box<Box<FnOnce()+Send>> = mem::transmute(arg);\n-            panic!(\"failed to spawn native thread: {}\", ret);\n-        }\n-        native\n-    }\n-\n-    pub unsafe fn join(native: rust_thread) {\n-        assert_eq!(pthread_join(native, ptr::null_mut()), 0);\n-    }\n-\n-    pub unsafe fn detach(native: rust_thread) {\n-        assert_eq!(pthread_detach(native), 0);\n-    }\n-\n-    pub unsafe fn yield_now() { assert_eq!(sched_yield(), 0); }\n-    // glibc >= 2.15 has a __pthread_get_minstack() function that returns\n-    // PTHREAD_STACK_MIN plus however many bytes are needed for thread-local\n-    // storage.  We need that information to avoid blowing up when a small stack\n-    // is created in an application with big thread-local storage requirements.\n-    // See #6233 for rationale and details.\n-    //\n-    // Link weakly to the symbol for compatibility with older versions of glibc.\n-    // Assumes that we've been dynamically linked to libpthread but that is\n-    // currently always the case.  Note that you need to check that the symbol\n-    // is non-null before calling it!\n-    #[cfg(target_os = \"linux\")]\n-    fn min_stack_size(attr: *const libc::pthread_attr_t) -> libc::size_t {\n-        type F = unsafe extern \"C\" fn(*const libc::pthread_attr_t) -> libc::size_t;\n-        extern {\n-            #[linkage = \"extern_weak\"]\n-            static __pthread_get_minstack: *const ();\n-        }\n-        if __pthread_get_minstack.is_null() {\n-            PTHREAD_STACK_MIN\n-        } else {\n-            unsafe { mem::transmute::<*const (), F>(__pthread_get_minstack)(attr) }\n-        }\n-    }\n-\n-    // __pthread_get_minstack() is marked as weak but extern_weak linkage is\n-    // not supported on OS X, hence this kludge...\n-    #[cfg(not(target_os = \"linux\"))]\n-    fn min_stack_size(_: *const libc::pthread_attr_t) -> libc::size_t {\n-        PTHREAD_STACK_MIN\n-    }\n-\n-    #[cfg(any(target_os = \"linux\"))]\n-    extern {\n-        pub fn pthread_self() -> libc::pthread_t;\n-        pub fn pthread_getattr_np(native: libc::pthread_t,\n-                                  attr: *mut libc::pthread_attr_t) -> libc::c_int;\n-        pub fn pthread_attr_getguardsize(attr: *const libc::pthread_attr_t,\n-                                         guardsize: *mut libc::size_t) -> libc::c_int;\n-        pub fn pthread_attr_getstack(attr: *const libc::pthread_attr_t,\n-                                     stackaddr: *mut *mut libc::c_void,\n-                                     stacksize: *mut libc::size_t) -> libc::c_int;\n-    }\n-\n-    #[cfg(target_os = \"macos\")]\n-    extern {\n-        pub fn pthread_self() -> libc::pthread_t;\n-        pub fn pthread_get_stackaddr_np(thread: libc::pthread_t) -> *mut libc::c_void;\n-        pub fn pthread_get_stacksize_np(thread: libc::pthread_t) -> libc::size_t;\n-    }\n-\n-    extern {\n-        fn pthread_create(native: *mut libc::pthread_t,\n-                          attr: *const libc::pthread_attr_t,\n-                          f: super::StartFn,\n-                          value: *mut libc::c_void) -> libc::c_int;\n-        fn pthread_join(native: libc::pthread_t,\n-                        value: *mut *mut libc::c_void) -> libc::c_int;\n-        fn pthread_attr_init(attr: *mut libc::pthread_attr_t) -> libc::c_int;\n-        pub fn pthread_attr_destroy(attr: *mut libc::pthread_attr_t) -> libc::c_int;\n-        fn pthread_attr_setstacksize(attr: *mut libc::pthread_attr_t,\n-                                     stack_size: libc::size_t) -> libc::c_int;\n-        fn pthread_attr_setdetachstate(attr: *mut libc::pthread_attr_t,\n-                                       state: libc::c_int) -> libc::c_int;\n-        fn pthread_detach(thread: libc::pthread_t) -> libc::c_int;\n-        fn sched_yield() -> libc::c_int;\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::Thread;\n-\n-    #[test]\n-    fn smoke() { Thread::start(move|| {}).join(); }\n-\n-    #[test]\n-    fn data() { assert_eq!(Thread::start(move|| { 1i }).join(), 1); }\n-\n-    #[test]\n-    fn detached() { Thread::spawn(move|| {}) }\n-\n-    #[test]\n-    fn small_stacks() {\n-        assert_eq!(42i, Thread::start_stack(0, move|| 42i).join());\n-        assert_eq!(42i, Thread::start_stack(1, move|| 42i).join());\n-    }\n-}"}, {"sha": "aee70980bbaf7145e62eee52a36e7bbda01c07bc", "filename": "src/librustrt/thread_local_storage.rs", "status": "removed", "additions": 0, "deletions": 115, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/6bdce25e155d846bb9252fa4a18baef7e74cf8bf/src%2Flibrustrt%2Fthread_local_storage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bdce25e155d846bb9252fa4a18baef7e74cf8bf/src%2Flibrustrt%2Fthread_local_storage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fthread_local_storage.rs?ref=6bdce25e155d846bb9252fa4a18baef7e74cf8bf", "patch": "@@ -1,115 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![allow(dead_code)]\n-\n-#[cfg(unix)] use libc::c_int;\n-#[cfg(unix)] use core::ptr::null;\n-#[cfg(windows)] use libc::types::os::arch::extra::{DWORD, LPVOID, BOOL};\n-\n-#[cfg(unix)]\n-pub type Key = pthread_key_t;\n-\n-#[cfg(unix)]\n-pub unsafe fn create(key: &mut Key) {\n-    assert!(pthread_key_create(key, null()) == 0);\n-}\n-\n-#[cfg(unix)]\n-pub unsafe fn set(key: Key, value: *mut u8) {\n-    assert!(pthread_setspecific(key, value) == 0);\n-}\n-\n-#[cfg(unix)]\n-pub unsafe fn get(key: Key) -> *mut u8 {\n-    pthread_getspecific(key)\n-}\n-\n-#[cfg(unix)]\n-pub unsafe fn destroy(key: Key) {\n-    assert!(pthread_key_delete(key) == 0);\n-}\n-\n-#[cfg(target_os = \"macos\")]\n-#[allow(non_camel_case_types)] // foreign type\n-type pthread_key_t = ::libc::c_ulong;\n-\n-#[cfg(any(target_os=\"linux\",\n-          target_os=\"freebsd\",\n-          target_os=\"dragonfly\",\n-          target_os=\"android\",\n-          target_os = \"ios\"))]\n-#[allow(non_camel_case_types)] // foreign type\n-type pthread_key_t = ::libc::c_uint;\n-\n-#[cfg(unix)]\n-extern {\n-    fn pthread_key_create(key: *mut pthread_key_t, dtor: *const u8) -> c_int;\n-    fn pthread_key_delete(key: pthread_key_t) -> c_int;\n-    fn pthread_getspecific(key: pthread_key_t) -> *mut u8;\n-    fn pthread_setspecific(key: pthread_key_t, value: *mut u8) -> c_int;\n-}\n-\n-#[cfg(windows)]\n-pub type Key = DWORD;\n-\n-#[cfg(windows)]\n-pub unsafe fn create(key: &mut Key) {\n-    static TLS_OUT_OF_INDEXES: DWORD = 0xFFFFFFFF;\n-    *key = TlsAlloc();\n-    assert!(*key != TLS_OUT_OF_INDEXES);\n-}\n-\n-#[cfg(windows)]\n-pub unsafe fn set(key: Key, value: *mut u8) {\n-    assert!(0 != TlsSetValue(key, value as *mut ::libc::c_void))\n-}\n-\n-#[cfg(windows)]\n-pub unsafe fn get(key: Key) -> *mut u8 {\n-    TlsGetValue(key) as *mut u8\n-}\n-\n-#[cfg(windows)]\n-pub unsafe fn destroy(key: Key) {\n-    assert!(TlsFree(key) != 0);\n-}\n-\n-#[cfg(windows)]\n-#[allow(non_snake_case)]\n-extern \"system\" {\n-    fn TlsAlloc() -> DWORD;\n-    fn TlsFree(dwTlsIndex: DWORD) -> BOOL;\n-    fn TlsGetValue(dwTlsIndex: DWORD) -> LPVOID;\n-    fn TlsSetValue(dwTlsIndex: DWORD, lpTlsvalue: LPVOID) -> BOOL;\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use std::prelude::*;\n-    use super::*;\n-\n-    #[test]\n-    fn tls_smoke_test() {\n-        use std::mem::transmute;\n-        unsafe {\n-            let mut key = 0;\n-            let value = box 20i;\n-            create(&mut key);\n-            set(key, transmute(value));\n-            let value: Box<int> = transmute(get(key));\n-            assert_eq!(value, box 20i);\n-            let value = box 30i;\n-            set(key, transmute(value));\n-            let value: Box<int> = transmute(get(key));\n-            assert_eq!(value, box 30i);\n-        }\n-    }\n-}"}, {"sha": "74f918b8ee3b46c8f6e6a2c49df91947d8483f44", "filename": "src/librustrt/util.rs", "status": "removed", "additions": 0, "deletions": 136, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/6bdce25e155d846bb9252fa4a18baef7e74cf8bf/src%2Flibrustrt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bdce25e155d846bb9252fa4a18baef7e74cf8bf/src%2Flibrustrt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Futil.rs?ref=6bdce25e155d846bb9252fa4a18baef7e74cf8bf", "patch": "@@ -1,136 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-//\n-// ignore-lexer-test FIXME #15677\n-\n-use core::prelude::*;\n-\n-use core::cmp;\n-use core::fmt;\n-use core::intrinsics;\n-use core::slice;\n-use core::str;\n-use libc;\n-\n-// Indicates whether we should perform expensive sanity checks, including rtassert!\n-//\n-// FIXME: Once the runtime matures remove the `true` below to turn off rtassert,\n-//        etc.\n-pub const ENFORCE_SANITY: bool = true || !cfg!(rtopt) || cfg!(rtdebug) ||\n-                                  cfg!(rtassert);\n-\n-pub struct Stdio(libc::c_int);\n-\n-#[allow(non_upper_case_globals)]\n-impl Copy for Stdio {}\n-\n-#[allow(non_upper_case_globals)]\n-pub const Stdout: Stdio = Stdio(libc::STDOUT_FILENO);\n-#[allow(non_upper_case_globals)]\n-pub const Stderr: Stdio = Stdio(libc::STDERR_FILENO);\n-\n-impl fmt::FormatWriter for Stdio {\n-    fn write(&mut self, data: &[u8]) -> fmt::Result {\n-        #[cfg(unix)]\n-        type WriteLen = libc::size_t;\n-        #[cfg(windows)]\n-        type WriteLen = libc::c_uint;\n-        unsafe {\n-            let Stdio(fd) = *self;\n-            libc::write(fd,\n-                        data.as_ptr() as *const libc::c_void,\n-                        data.len() as WriteLen);\n-        }\n-        Ok(()) // yes, we're lying\n-    }\n-}\n-\n-pub fn dumb_print(args: &fmt::Arguments) {\n-    use core::fmt::FormatWriter;\n-    let mut w = Stderr;\n-    let _ = w.write_fmt(args);\n-}\n-\n-pub fn abort(args: &fmt::Arguments) -> ! {\n-    use core::fmt::FormatWriter;\n-\n-    struct BufWriter<'a> {\n-        buf: &'a mut [u8],\n-        pos: uint,\n-    }\n-    impl<'a> FormatWriter for BufWriter<'a> {\n-        fn write(&mut self, bytes: &[u8]) -> fmt::Result {\n-            let left = self.buf[mut self.pos..];\n-            let to_write = bytes[..cmp::min(bytes.len(), left.len())];\n-            slice::bytes::copy_memory(left, to_write);\n-            self.pos += to_write.len();\n-            Ok(())\n-        }\n-    }\n-\n-    // Convert the arguments into a stack-allocated string\n-    let mut msg = [0u8, ..512];\n-    let mut w = BufWriter { buf: &mut msg, pos: 0 };\n-    let _ = write!(&mut w, \"{}\", args);\n-    let msg = str::from_utf8(w.buf[mut ..w.pos]).unwrap_or(\"aborted\");\n-    let msg = if msg.is_empty() {\"aborted\"} else {msg};\n-\n-    // Give some context to the message\n-    let hash = msg.bytes().fold(0, |accum, val| accum + (val as uint) );\n-    let quote = match hash % 10 {\n-        0 => \"\n-It was from the artists and poets that the pertinent answers came, and I\n-know that panic would have broken loose had they been able to compare notes.\n-As it was, lacking their original letters, I half suspected the compiler of\n-having asked leading questions, or of having edited the correspondence in\n-corroboration of what he had latently resolved to see.\",\n-        1 => \"\n-There are not many persons who know what wonders are opened to them in the\n-stories and visions of their youth; for when as children we listen and dream,\n-we think but half-formed thoughts, and when as men we try to remember, we are\n-dulled and prosaic with the poison of life. But some of us awake in the night\n-with strange phantasms of enchanted hills and gardens, of fountains that sing\n-in the sun, of golden cliffs overhanging murmuring seas, of plains that stretch\n-down to sleeping cities of bronze and stone, and of shadowy companies of heroes\n-that ride caparisoned white horses along the edges of thick forests; and then\n-we know that we have looked back through the ivory gates into that world of\n-wonder which was ours before we were wise and unhappy.\",\n-        2 => \"\n-Instead of the poems I had hoped for, there came only a shuddering blackness\n-and ineffable loneliness; and I saw at last a fearful truth which no one had\n-ever dared to breathe before \u2014 the unwhisperable secret of secrets \u2014 The fact\n-that this city of stone and stridor is not a sentient perpetuation of Old New\n-York as London is of Old London and Paris of Old Paris, but that it is in fact\n-quite dead, its sprawling body imperfectly embalmed and infested with queer\n-animate things which have nothing to do with it as it was in life.\",\n-        3 => \"\n-The ocean ate the last of the land and poured into the smoking gulf, thereby\n-giving up all it had ever conquered. From the new-flooded lands it flowed\n-again, uncovering death and decay; and from its ancient and immemorial bed it\n-trickled loathsomely, uncovering nighted secrets of the years when Time was\n-young and the gods unborn. Above the waves rose weedy remembered spires. The\n-moon laid pale lilies of light on dead London, and Paris stood up from its damp\n-grave to be sanctified with star-dust. Then rose spires and monoliths that were\n-weedy but not remembered; terrible spires and monoliths of lands that men never\n-knew were lands...\",\n-        4 => \"\n-There was a night when winds from unknown spaces whirled us irresistibly into\n-limitless vacuum beyond all thought and entity. Perceptions of the most\n-maddeningly untransmissible sort thronged upon us; perceptions of infinity\n-which at the time convulsed us with joy, yet which are now partly lost to my\n-memory and partly incapable of presentation to others.\",\n-        _ => \"You've met with a terrible fate, haven't you?\"\n-    };\n-    rterrln!(\"{}\", \"\");\n-    rterrln!(\"{}\", quote);\n-    rterrln!(\"{}\", \"\");\n-    rterrln!(\"fatal runtime error: {}\", msg);\n-    unsafe { intrinsics::abort(); }\n-}"}, {"sha": "8fe3642e702d44ce6d3f1a9e1cd9ea2db9d69f9b", "filename": "src/libstd/c_str.rs", "status": "renamed", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -67,17 +67,17 @@\n //! }\n //! ```\n \n+use string::String;\n+use hash;\n+use fmt;\n+use kinds::marker;\n+use mem;\n use core::prelude::*;\n \n-use collections::string::String;\n-use core::hash;\n-use core::fmt;\n-use core::kinds::{Sized, marker};\n-use core::mem;\n-use core::ptr;\n-use core::raw::Slice;\n-use core::slice;\n-use core::str;\n+use ptr;\n+use raw::Slice;\n+use slice;\n+use str;\n use libc;\n \n /// The representation of a C String.\n@@ -534,9 +534,9 @@ pub unsafe fn from_c_multistring<F>(buf: *const libc::c_char,\n \n #[cfg(test)]\n mod tests {\n-    use std::prelude::*;\n-    use std::ptr;\n-    use std::task;\n+    use prelude::*;\n+    use ptr;\n+    use thread::Thread;\n     use libc;\n \n     use super::*;\n@@ -637,7 +637,7 @@ mod tests {\n \n     #[test]\n     fn test_to_c_str_fail() {\n-        assert!(task::try(move|| { \"he\\x00llo\".to_c_str() }).is_err());\n+        assert!(Thread::spawn(move|| { \"he\\x00llo\".to_c_str() }).join().is_err());\n     }\n \n     #[test]\n@@ -726,9 +726,11 @@ mod tests {\n \n #[cfg(test)]\n mod bench {\n-    use test::Bencher;\n+    extern crate test;\n+\n+    use self::test::Bencher;\n     use libc;\n-    use std::prelude::*;\n+    use prelude::*;\n \n     #[inline]\n     fn check(s: &str, c_str: *const libc::c_char) {", "previous_filename": "src/librustrt/c_str.rs"}, {"sha": "c477acd70aa8d7260ce6e1bfe5666adbe69da35d", "filename": "src/libstd/comm/blocking.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fcomm%2Fblocking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fcomm%2Fblocking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fblocking.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -0,0 +1,83 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Generic support for building blocking abstractions.\n+\n+use thread::Thread;\n+use sync::atomic::{AtomicBool, INIT_ATOMIC_BOOL, Ordering};\n+use sync::Arc;\n+use kinds::marker::{NoSend, NoSync};\n+use mem;\n+use clone::Clone;\n+\n+struct Inner {\n+    thread: Thread,\n+    woken: AtomicBool,\n+}\n+\n+#[deriving(Clone)]\n+pub struct SignalToken {\n+    inner: Arc<Inner>,\n+}\n+\n+pub struct WaitToken {\n+    inner: Arc<Inner>,\n+    no_send: NoSend,\n+    no_sync: NoSync,\n+}\n+\n+pub fn tokens() -> (WaitToken, SignalToken) {\n+    let inner = Arc::new(Inner {\n+        thread: Thread::current(),\n+        woken: INIT_ATOMIC_BOOL,\n+    });\n+    let wait_token = WaitToken {\n+        inner: inner.clone(),\n+        no_send: NoSend,\n+        no_sync: NoSync,\n+    };\n+    let signal_token = SignalToken {\n+        inner: inner\n+    };\n+    (wait_token, signal_token)\n+}\n+\n+impl SignalToken {\n+    pub fn signal(&self) -> bool {\n+        let wake = !self.inner.woken.compare_and_swap(false, true, Ordering::SeqCst);\n+        if wake {\n+            self.inner.thread.unpark();\n+        }\n+        wake\n+    }\n+\n+    /// Convert to an unsafe uint value. Useful for storing in a pipe's state\n+    /// flag.\n+    #[inline]\n+    pub unsafe fn cast_to_uint(self) -> uint {\n+        mem::transmute(self.inner)\n+    }\n+\n+    /// Convert from an unsafe uint value. Useful for retrieving a pipe's state\n+    /// flag.\n+    #[inline]\n+    pub unsafe fn cast_from_uint(signal_ptr: uint) -> SignalToken {\n+        SignalToken { inner: mem::transmute(signal_ptr) }\n+    }\n+\n+}\n+\n+impl WaitToken {\n+    pub fn wait(self) {\n+        while !self.inner.woken.load(Ordering::SeqCst) {\n+            Thread::park()\n+        }\n+    }\n+}"}, {"sha": "8f945fec4d5625b766e8bdfdf9f06dd57224613b", "filename": "src/libstd/comm/mod.rs", "status": "modified", "additions": 62, "deletions": 123, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmod.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -54,42 +54,35 @@\n //! There are methods on both of senders and receivers to perform their\n //! respective operations without panicking, however.\n //!\n-//! ## Runtime Requirements\n-//!\n-//! The channel types defined in this module generally have very few runtime\n-//! requirements in order to operate. The major requirement they have is for a\n-//! local rust `Task` to be available if any *blocking* operation is performed.\n-//!\n-//! If a local `Task` is not available (for example an FFI callback), then the\n-//! `send` operation is safe on a `Sender` (as well as a `send_opt`) as well as\n-//! the `try_send` method on a `SyncSender`, but no other operations are\n-//! guaranteed to be safe.\n-//!\n //! # Example\n //!\n //! Simple usage:\n //!\n //! ```\n+//! use std::thread::Thread;\n+//!\n //! // Create a simple streaming channel\n //! let (tx, rx) = channel();\n-//! spawn(move|| {\n+//! Thread::spawn(move|| {\n //!     tx.send(10i);\n-//! });\n+//! }).detach();\n //! assert_eq!(rx.recv(), 10i);\n //! ```\n //!\n //! Shared usage:\n //!\n //! ```\n-//! // Create a shared channel that can be sent along from many tasks\n+//! use std::thread::Thread;\n+//!\n+//! // Create a shared channel that can be sent along from many threads\n //! // where tx is the sending half (tx for transmission), and rx is the receiving\n //! // half (rx for receiving).\n //! let (tx, rx) = channel();\n //! for i in range(0i, 10i) {\n //!     let tx = tx.clone();\n-//!     spawn(move|| {\n+//!     Thread::spawn(move|| {\n //!         tx.send(i);\n-//!     })\n+//!     }).detach()\n //! }\n //!\n //! for _ in range(0i, 10i) {\n@@ -111,11 +104,13 @@\n //! Synchronous channels:\n //!\n //! ```\n+//! use std::thread::Thread;\n+//!\n //! let (tx, rx) = sync_channel::<int>(0);\n-//! spawn(move|| {\n+//! Thread::spawn(move|| {\n //!     // This will wait for the parent task to start receiving\n //!     tx.send(53);\n-//! });\n+//! }).detach();\n //! rx.recv();\n //! ```\n //!\n@@ -327,28 +322,30 @@ use alloc::arc::Arc;\n use core::kinds::marker;\n use core::mem;\n use core::cell::UnsafeCell;\n-use rustrt::task::BlockedTask;\n \n-pub use comm::select::{Select, Handle};\n+pub use self::select::{Select, Handle};\n+use self::select::StartResult;\n+use self::select::StartResult::*;\n+use self::blocking::SignalToken;\n \n macro_rules! test {\n     { fn $name:ident() $b:block $(#[$a:meta])*} => (\n         mod $name {\n             #![allow(unused_imports)]\n \n-            extern crate rustrt;\n-\n             use prelude::*;\n+            use rt;\n \n             use comm::*;\n             use super::*;\n-            use task;\n+            use thread::Thread;\n \n             $(#[$a])* #[test] fn f() { $b }\n         }\n     )\n }\n \n+mod blocking;\n mod oneshot;\n mod select;\n mod shared;\n@@ -460,15 +457,17 @@ impl<T> UnsafeFlavor<T> for Receiver<T> {\n /// # Example\n ///\n /// ```\n+/// use std::thread::Thread;\n+///\n /// // tx is is the sending half (tx for transmission), and rx is the receiving\n /// // half (rx for receiving).\n /// let (tx, rx) = channel();\n ///\n /// // Spawn off an expensive computation\n-/// spawn(move|| {\n+/// Thread::spawn(move|| {\n /// #   fn expensive_computation() {}\n ///     tx.send(expensive_computation());\n-/// });\n+/// }).detach();\n ///\n /// // Do some useful work for awhile\n ///\n@@ -499,15 +498,17 @@ pub fn channel<T: Send>() -> (Sender<T>, Receiver<T>) {\n /// # Example\n ///\n /// ```\n+/// use std::thread::Thread;\n+///\n /// let (tx, rx) = sync_channel(1);\n ///\n /// // this returns immediately\n /// tx.send(1i);\n ///\n-/// spawn(move|| {\n+/// Thread::spawn(move|| {\n ///     // this will block until the previous message has been received\n ///     tx.send(2i);\n-/// });\n+/// }).detach();\n ///\n /// assert_eq!(rx.recv(), 1i);\n /// assert_eq!(rx.recv(), 2i);\n@@ -604,12 +605,12 @@ impl<T: Send> Sender<T> {\n                                 (a, ret)\n                             }\n                             oneshot::UpDisconnected => (a, Err(t)),\n-                            oneshot::UpWoke(task) => {\n-                                // This send cannot panic because the task is\n+                            oneshot::UpWoke(token) => {\n+                                // This send cannot panic because the thread is\n                                 // asleep (we're looking at it), so the receiver\n                                 // can't go away.\n                                 (*a.get()).send(t).ok().unwrap();\n-                                task.wake().map(|t| t.reawaken());\n+                                token.signal();\n                                 (a, Ok(()))\n                             }\n                         }\n@@ -948,34 +949,33 @@ impl<T: Send> select::Packet for Receiver<T> {\n         }\n     }\n \n-    fn start_selection(&self, mut task: BlockedTask) -> Result<(), BlockedTask>{\n+    fn start_selection(&self, mut token: SignalToken) -> StartResult {\n         loop {\n             let (t, new_port) = match *unsafe { self.inner() } {\n                 Oneshot(ref p) => {\n-                    match unsafe { (*p.get()).start_selection(task) } {\n-                        oneshot::SelSuccess => return Ok(()),\n-                        oneshot::SelCanceled(task) => return Err(task),\n+                    match unsafe { (*p.get()).start_selection(token) } {\n+                        oneshot::SelSuccess => return Installed,\n+                        oneshot::SelCanceled => return Abort,\n                         oneshot::SelUpgraded(t, rx) => (t, rx),\n                     }\n                 }\n                 Stream(ref p) => {\n-                    match unsafe { (*p.get()).start_selection(task) } {\n-                        stream::SelSuccess => return Ok(()),\n-                        stream::SelCanceled(task) => return Err(task),\n+                    match unsafe { (*p.get()).start_selection(token) } {\n+                        stream::SelSuccess => return Installed,\n+                        stream::SelCanceled => return Abort,\n                         stream::SelUpgraded(t, rx) => (t, rx),\n                     }\n                 }\n                 Shared(ref p) => {\n-                    return unsafe { (*p.get()).start_selection(task) };\n+                    return unsafe { (*p.get()).start_selection(token) };\n                 }\n                 Sync(ref p) => {\n-                    return unsafe { (*p.get()).start_selection(task) };\n+                    return unsafe { (*p.get()).start_selection(token) };\n                 }\n             };\n-            task = t;\n+            token = t;\n             unsafe {\n-                mem::swap(self.inner_mut(),\n-                          new_port.inner_mut());\n+                mem::swap(self.inner_mut(), new_port.inner_mut());\n             }\n         }\n     }\n@@ -1252,11 +1252,11 @@ mod test {\n \n     test! { fn oneshot_single_thread_recv_chan_close() {\n         // Receiving on a closed chan will panic\n-        let res = task::try(move|| {\n+        let res = Thread::spawn(move|| {\n             let (tx, rx) = channel::<int>();\n             drop(tx);\n             rx.recv();\n-        });\n+        }).join();\n         // What is our res?\n         assert!(res.is_err());\n     } }\n@@ -1324,9 +1324,9 @@ mod test {\n         spawn(move|| {\n             drop(tx);\n         });\n-        let res = task::try(move|| {\n+        let res = Thread::spawn(move|| {\n             assert!(rx.recv() == box 10);\n-        });\n+        }).join();\n         assert!(res.is_err());\n     } }\n \n@@ -1346,19 +1346,19 @@ mod test {\n             spawn(move|| {\n                 drop(rx);\n             });\n-            let _ = task::try(move|| {\n+            let _ = Thread::spawn(move|| {\n                 tx.send(1);\n-            });\n+            }).join();\n         }\n     } }\n \n     test! { fn oneshot_multi_thread_recv_close_stress() {\n         for _ in range(0, stress_factor()) {\n             let (tx, rx) = channel::<int>();\n             spawn(move|| {\n-                let res = task::try(move|| {\n+                let res = Thread::spawn(move|| {\n                     rx.recv();\n-                });\n+                }).join();\n                 assert!(res.is_err());\n             });\n             spawn(move|| {\n@@ -1507,7 +1507,7 @@ mod test {\n             tx2.send(());\n         });\n         // make sure the other task has gone to sleep\n-        for _ in range(0u, 5000) { task::deschedule(); }\n+        for _ in range(0u, 5000) { Thread::yield_now(); }\n \n         // upgrade to a shared chan and send a message\n         let t = tx.clone();\n@@ -1516,45 +1516,7 @@ mod test {\n \n         // wait for the child task to exit before we exit\n         rx2.recv();\n-    } }\n-\n-    test! { fn sends_off_the_runtime() {\n-        use rustrt::thread::Thread;\n-\n-        let (tx, rx) = channel();\n-        let t = Thread::start(move|| {\n-            for _ in range(0u, 1000) {\n-                tx.send(());\n-            }\n-        });\n-        for _ in range(0u, 1000) {\n-            rx.recv();\n-        }\n-        t.join();\n-    } }\n-\n-    test! { fn try_recvs_off_the_runtime() {\n-        use rustrt::thread::Thread;\n-\n-        let (tx, rx) = channel();\n-        let (cdone, pdone) = channel();\n-        let t = Thread::start(move|| {\n-            let mut hits = 0u;\n-            while hits < 10 {\n-                match rx.try_recv() {\n-                    Ok(()) => { hits += 1; }\n-                    Err(Empty) => { Thread::yield_now(); }\n-                    Err(Disconnected) => return,\n-                }\n-            }\n-            cdone.send(());\n-        });\n-        for _ in range(0u, 10) {\n-            tx.send(());\n-        }\n-        t.join();\n-        pdone.recv();\n-    } }\n+    }}\n }\n \n #[cfg(test)]\n@@ -1712,11 +1674,11 @@ mod sync_tests {\n \n     test! { fn oneshot_single_thread_recv_chan_close() {\n         // Receiving on a closed chan will panic\n-        let res = task::try(move|| {\n+        let res = Thread::spawn(move|| {\n             let (tx, rx) = sync_channel::<int>(0);\n             drop(tx);\n             rx.recv();\n-        });\n+        }).join();\n         // What is our res?\n         assert!(res.is_err());\n     } }\n@@ -1789,9 +1751,9 @@ mod sync_tests {\n         spawn(move|| {\n             drop(tx);\n         });\n-        let res = task::try(move|| {\n+        let res = Thread::spawn(move|| {\n             assert!(rx.recv() == box 10);\n-        });\n+        }).join();\n         assert!(res.is_err());\n     } }\n \n@@ -1811,19 +1773,19 @@ mod sync_tests {\n             spawn(move|| {\n                 drop(rx);\n             });\n-            let _ = task::try(move|| {\n+            let _ = Thread::spawn(move || {\n                 tx.send(1);\n-            });\n+            }).join();\n         }\n     } }\n \n     test! { fn oneshot_multi_thread_recv_close_stress() {\n         for _ in range(0, stress_factor()) {\n             let (tx, rx) = sync_channel::<int>(0);\n             spawn(move|| {\n-                let res = task::try(move|| {\n+                let res = Thread::spawn(move|| {\n                     rx.recv();\n-                });\n+                }).join();\n                 assert!(res.is_err());\n             });\n             spawn(move|| {\n@@ -1972,7 +1934,7 @@ mod sync_tests {\n             tx2.send(());\n         });\n         // make sure the other task has gone to sleep\n-        for _ in range(0u, 5000) { task::deschedule(); }\n+        for _ in range(0u, 5000) { Thread::yield_now(); }\n \n         // upgrade to a shared chan and send a message\n         let t = tx.clone();\n@@ -1983,29 +1945,6 @@ mod sync_tests {\n         rx2.recv();\n     } }\n \n-    test! { fn try_recvs_off_the_runtime() {\n-        use rustrt::thread::Thread;\n-\n-        let (tx, rx) = sync_channel::<()>(0);\n-        let (cdone, pdone) = channel();\n-        let t = Thread::start(move|| {\n-            let mut hits = 0u;\n-            while hits < 10 {\n-                match rx.try_recv() {\n-                    Ok(()) => { hits += 1; }\n-                    Err(Empty) => { Thread::yield_now(); }\n-                    Err(Disconnected) => return,\n-                }\n-            }\n-            cdone.send(());\n-        });\n-        for _ in range(0u, 10) {\n-            tx.send(());\n-        }\n-        t.join();\n-        pdone.recv();\n-    } }\n-\n     test! { fn send_opt1() {\n         let (tx, rx) = sync_channel::<int>(0);\n         spawn(move|| { rx.recv(); });\n@@ -2064,7 +2003,7 @@ mod sync_tests {\n     test! { fn try_send4() {\n         let (tx, rx) = sync_channel::<int>(0);\n         spawn(move|| {\n-            for _ in range(0u, 1000) { task::deschedule(); }\n+            for _ in range(0u, 1000) { Thread::yield_now(); }\n             assert_eq!(tx.try_send(1), Ok(()));\n         });\n         assert_eq!(rx.recv(), 1);"}, {"sha": "9c5a6518845300413c32ffb6fd2517c9856fd010", "filename": "src/libstd/comm/oneshot.rs", "status": "modified", "additions": 50, "deletions": 52, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fcomm%2Foneshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fcomm%2Foneshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Foneshot.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -39,18 +39,20 @@ use self::MyUpgrade::*;\n \n use core::prelude::*;\n \n-use alloc::boxed::Box;\n+use comm::Receiver;\n+use comm::blocking::{mod, SignalToken};\n use core::mem;\n-use rustrt::local::Local;\n-use rustrt::task::{Task, BlockedTask};\n-\n use sync::atomic;\n-use comm::Receiver;\n \n // Various states you can find a port in.\n-const EMPTY: uint = 0;\n-const DATA: uint = 1;\n-const DISCONNECTED: uint = 2;\n+const EMPTY: uint = 0;          // initial state: no data, no blocked reciever\n+const DATA: uint = 1;           // data ready for receiver to take\n+const DISCONNECTED: uint = 2;   // channel is disconnected OR upgraded\n+// Any other value represents a pointer to a SignalToken value. The\n+// protocol ensures that when the state moves *to* a pointer,\n+// ownership of the token is given to the packet, and when the state\n+// moves *from* a pointer, ownership of the token is transferred to\n+// whoever changed the state.\n \n pub struct Packet<T> {\n     // Internal state of the chan/port pair (stores the blocked task as well)\n@@ -71,12 +73,12 @@ pub enum Failure<T> {\n pub enum UpgradeResult {\n     UpSuccess,\n     UpDisconnected,\n-    UpWoke(BlockedTask),\n+    UpWoke(SignalToken),\n }\n \n pub enum SelectionResult<T> {\n-    SelCanceled(BlockedTask),\n-    SelUpgraded(BlockedTask, Receiver<T>),\n+    SelCanceled,\n+    SelUpgraded(SignalToken, Receiver<T>),\n     SelSuccess,\n }\n \n@@ -118,12 +120,10 @@ impl<T: Send> Packet<T> {\n             // Not possible, these are one-use channels\n             DATA => unreachable!(),\n \n-            // Anything else means that there was a task waiting on the other\n-            // end. We leave the 'DATA' state inside so it'll pick it up on the\n-            // other end.\n-            n => unsafe {\n-                let t = BlockedTask::cast_from_uint(n);\n-                t.wake().map(|t| t.reawaken());\n+            // There is a thread waiting on the other end. We leave the 'DATA'\n+            // state inside so it'll pick it up on the other end.\n+            ptr => unsafe {\n+                SignalToken::cast_from_uint(ptr).signal();\n                 Ok(())\n             }\n         }\n@@ -142,23 +142,17 @@ impl<T: Send> Packet<T> {\n         // Attempt to not block the task (it's a little expensive). If it looks\n         // like we're not empty, then immediately go through to `try_recv`.\n         if self.state.load(atomic::SeqCst) == EMPTY {\n-            let t: Box<Task> = Local::take();\n-            t.deschedule(1, |task| {\n-                let n = unsafe { task.cast_to_uint() };\n-                match self.state.compare_and_swap(EMPTY, n, atomic::SeqCst) {\n-                    // Nothing on the channel, we legitimately block\n-                    EMPTY => Ok(()),\n-\n-                    // If there's data or it's a disconnected channel, then we\n-                    // failed the cmpxchg, so we just wake ourselves back up\n-                    DATA | DISCONNECTED => {\n-                        unsafe { Err(BlockedTask::cast_from_uint(n)) }\n-                    }\n-\n-                    // Only one thread is allowed to sleep on this port\n-                    _ => unreachable!()\n-                }\n-            });\n+            let (wait_token, signal_token) = blocking::tokens();\n+            let ptr = unsafe { signal_token.cast_to_uint() };\n+\n+            // race with senders to enter the blocking state\n+            if self.state.compare_and_swap(EMPTY, ptr, atomic::SeqCst) == EMPTY {\n+                wait_token.wait();\n+                debug_assert!(self.state.load(atomic::SeqCst) != EMPTY);\n+            } else {\n+                // drop the signal token, since we never blocked\n+                drop(unsafe { SignalToken::cast_from_uint(ptr) });\n+            }\n         }\n \n         self.try_recv()\n@@ -197,6 +191,9 @@ impl<T: Send> Packet<T> {\n                     }\n                 }\n             }\n+\n+            // We are the sole receiver; there cannot be a blocking\n+            // receiver already.\n             _ => unreachable!()\n         }\n     }\n@@ -223,7 +220,7 @@ impl<T: Send> Packet<T> {\n             DISCONNECTED => { self.upgrade = prev; UpDisconnected }\n \n             // If someone's waiting, we gotta wake them up\n-            n => UpWoke(unsafe { BlockedTask::cast_from_uint(n) })\n+            ptr => UpWoke(unsafe { SignalToken::cast_from_uint(ptr) })\n         }\n     }\n \n@@ -232,9 +229,8 @@ impl<T: Send> Packet<T> {\n             DATA | DISCONNECTED | EMPTY => {}\n \n             // If someone's waiting, we gotta wake them up\n-            n => unsafe {\n-                let t = BlockedTask::cast_from_uint(n);\n-                t.wake().map(|t| t.reawaken());\n+            ptr => unsafe {\n+                SignalToken::cast_from_uint(ptr).signal();\n             }\n         }\n     }\n@@ -286,30 +282,34 @@ impl<T: Send> Packet<T> {\n \n     // Attempts to start selection on this port. This can either succeed, fail\n     // because there is data, or fail because there is an upgrade pending.\n-    pub fn start_selection(&mut self, task: BlockedTask) -> SelectionResult<T> {\n-        let n = unsafe { task.cast_to_uint() };\n-        match self.state.compare_and_swap(EMPTY, n, atomic::SeqCst) {\n+    pub fn start_selection(&mut self, token: SignalToken) -> SelectionResult<T> {\n+        let ptr = unsafe { token.cast_to_uint() };\n+        match self.state.compare_and_swap(EMPTY, ptr, atomic::SeqCst) {\n             EMPTY => SelSuccess,\n-            DATA => SelCanceled(unsafe { BlockedTask::cast_from_uint(n) }),\n+            DATA => {\n+                drop(unsafe { SignalToken::cast_from_uint(ptr) });\n+                SelCanceled\n+            }\n             DISCONNECTED if self.data.is_some() => {\n-                SelCanceled(unsafe { BlockedTask::cast_from_uint(n) })\n+                drop(unsafe { SignalToken::cast_from_uint(ptr) });\n+                SelCanceled\n             }\n             DISCONNECTED => {\n                 match mem::replace(&mut self.upgrade, SendUsed) {\n                     // The other end sent us an upgrade, so we need to\n                     // propagate upwards whether the upgrade can receive\n                     // data\n                     GoUp(upgrade) => {\n-                        SelUpgraded(unsafe { BlockedTask::cast_from_uint(n) },\n-                                    upgrade)\n+                        SelUpgraded(unsafe { SignalToken::cast_from_uint(ptr) }, upgrade)\n                     }\n \n                     // If the other end disconnected without sending an\n                     // upgrade, then we have data to receive (the channel is\n                     // disconnected).\n                     up => {\n                         self.upgrade = up;\n-                        SelCanceled(unsafe { BlockedTask::cast_from_uint(n) })\n+                        drop(unsafe { SignalToken::cast_from_uint(ptr) });\n+                        SelCanceled\n                     }\n                 }\n             }\n@@ -331,7 +331,7 @@ impl<T: Send> Packet<T> {\n \n             // If we've got a blocked task, then use an atomic to gain ownership\n             // of it (may fail)\n-            n => self.state.compare_and_swap(n, EMPTY, atomic::SeqCst)\n+            ptr => self.state.compare_and_swap(ptr, EMPTY, atomic::SeqCst)\n         };\n \n         // Now that we've got ownership of our state, figure out what to do\n@@ -358,11 +358,9 @@ impl<T: Send> Packet<T> {\n                 }\n             }\n \n-            // We woke ourselves up from select. Assert that the task should be\n-            // trashed and returned that we don't have any data.\n-            n => {\n-                let t = unsafe { BlockedTask::cast_from_uint(n) };\n-                t.trash();\n+            // We woke ourselves up from select.\n+            ptr => unsafe {\n+                drop(SignalToken::cast_from_uint(ptr));\n                 Ok(false)\n             }\n         }"}, {"sha": "690b5861c2239d94b4db607c2b6f7b196e057b6b", "filename": "src/libstd/comm/select.rs", "status": "modified", "additions": 47, "deletions": 37, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fcomm%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fcomm%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fselect.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -54,15 +54,13 @@\n \n use core::prelude::*;\n \n-use alloc::boxed::Box;\n use core::cell::Cell;\n use core::kinds::marker;\n use core::mem;\n use core::uint;\n-use rustrt::local::Local;\n-use rustrt::task::{Task, BlockedTask};\n \n use comm::Receiver;\n+use comm::blocking::{mod, SignalToken};\n \n /// The \"receiver set\" of the select interface. This structure is used to manage\n /// a set of receivers which are being selected over.\n@@ -93,10 +91,17 @@ pub struct Handle<'rx, T:'rx> {\n \n struct Packets { cur: *mut Handle<'static, ()> }\n \n+#[doc(hidden)]\n+#[deriving(PartialEq)]\n+pub enum StartResult {\n+    Installed,\n+    Abort,\n+}\n+\n #[doc(hidden)]\n pub trait Packet {\n     fn can_recv(&self) -> bool;\n-    fn start_selection(&self, task: BlockedTask) -> Result<(), BlockedTask>;\n+    fn start_selection(&self, token: SignalToken) -> StartResult;\n     fn abort_selection(&self) -> bool;\n }\n \n@@ -165,36 +170,39 @@ impl Select {\n         // Most notably, the iterations over all of the receivers shouldn't be\n         // necessary.\n         unsafe {\n-            let mut amt = 0;\n-            for p in self.iter() {\n-                amt += 1;\n-                if do_preflight_checks && (*p).packet.can_recv() {\n-                    return (*p).id;\n+            // Stage 1: preflight checks. Look for any packets ready to receive\n+            if do_preflight_checks {\n+                for handle in self.iter() {\n+                    if (*handle).packet.can_recv() {\n+                        return (*handle).id();\n+                    }\n                 }\n             }\n-            assert!(amt > 0);\n \n-            let mut ready_index = amt;\n-            let mut ready_id = uint::MAX;\n-            let mut iter = self.iter().enumerate();\n-\n-            // Acquire a number of blocking contexts, and block on each one\n-            // sequentially until one fails. If one fails, then abort\n-            // immediately so we can go unblock on all the other receivers.\n-            let task: Box<Task> = Local::take();\n-            task.deschedule(amt, |task| {\n-                // Prepare for the block\n-                let (i, handle) = iter.next().unwrap();\n-                match (*handle).packet.start_selection(task) {\n-                    Ok(()) => Ok(()),\n-                    Err(task) => {\n-                        ready_index = i;\n-                        ready_id = (*handle).id;\n-                        Err(task)\n+            // Stage 2: begin the blocking process\n+            //\n+            // Create a number of signal tokens, and install each one\n+            // sequentially until one fails. If one fails, then abort the\n+            // selection on the already-installed tokens.\n+            let (wait_token, signal_token) = blocking::tokens();\n+            for (i, handle) in self.iter().enumerate() {\n+                match (*handle).packet.start_selection(signal_token.clone()) {\n+                    StartResult::Installed => {}\n+                    StartResult::Abort => {\n+                        // Go back and abort the already-begun selections\n+                        for handle in self.iter().take(i) {\n+                            (*handle).packet.abort_selection();\n+                        }\n+                        return (*handle).id;\n                     }\n                 }\n-            });\n+            }\n+\n+            // Stage 3: no messages available, actually block\n+            wait_token.wait();\n \n+            // Stage 4: there *must* be message available; find it.\n+            //\n             // Abort the selection process on each receiver. If the abort\n             // process returns `true`, then that means that the receiver is\n             // ready to receive some data. Note that this also means that the\n@@ -216,12 +224,14 @@ impl Select {\n             // A rewrite should focus on avoiding a yield loop, and for now this\n             // implementation is tying us over to a more efficient \"don't\n             // iterate over everything every time\" implementation.\n-            for handle in self.iter().take(ready_index) {\n+            let mut ready_id = uint::MAX;\n+            for handle in self.iter() {\n                 if (*handle).packet.abort_selection() {\n                     ready_id = (*handle).id;\n                 }\n             }\n \n+            // We must have found a ready receiver\n             assert!(ready_id != uint::MAX);\n             return ready_id;\n         }\n@@ -404,10 +414,10 @@ mod test {\n         let (tx3, rx3) = channel::<int>();\n \n         spawn(move|| {\n-            for _ in range(0u, 20) { task::deschedule(); }\n+            for _ in range(0u, 20) { Thread::yield_now(); }\n             tx1.send(1);\n             rx3.recv();\n-            for _ in range(0u, 20) { task::deschedule(); }\n+            for _ in range(0u, 20) { Thread::yield_now(); }\n         });\n \n         select! {\n@@ -427,7 +437,7 @@ mod test {\n         let (tx3, rx3) = channel::<()>();\n \n         spawn(move|| {\n-            for _ in range(0u, 20) { task::deschedule(); }\n+            for _ in range(0u, 20) { Thread::yield_now(); }\n             tx1.send(1);\n             tx2.send(2);\n             rx3.recv();\n@@ -528,7 +538,7 @@ mod test {\n             tx3.send(());\n         });\n \n-        for _ in range(0u, 1000) { task::deschedule(); }\n+        for _ in range(0u, 1000) { Thread::yield_now(); }\n         drop(tx1.clone());\n         tx2.send(());\n         rx3.recv();\n@@ -631,7 +641,7 @@ mod test {\n             tx2.send(());\n         });\n \n-        for _ in range(0u, 100) { task::deschedule() }\n+        for _ in range(0u, 100) { Thread::yield_now() }\n         tx1.send(());\n         rx2.recv();\n     } }\n@@ -650,7 +660,7 @@ mod test {\n             tx2.send(());\n         });\n \n-        for _ in range(0u, 100) { task::deschedule() }\n+        for _ in range(0u, 100) { Thread::yield_now() }\n         tx1.send(());\n         rx2.recv();\n     } }\n@@ -668,7 +678,7 @@ mod test {\n             tx2.send(());\n         });\n \n-        for _ in range(0u, 100) { task::deschedule() }\n+        for _ in range(0u, 100) { Thread::yield_now() }\n         tx1.send(());\n         rx2.recv();\n     } }\n@@ -684,7 +694,7 @@ mod test {\n     test! { fn sync2() {\n         let (tx, rx) = sync_channel::<int>(0);\n         spawn(move|| {\n-            for _ in range(0u, 100) { task::deschedule() }\n+            for _ in range(0u, 100) { Thread::yield_now() }\n             tx.send(1);\n         });\n         select! {"}, {"sha": "1022694e634f607a64418f79f62f93ad61dd2dce", "filename": "src/libstd/comm/shared.rs", "status": "modified", "additions": 68, "deletions": 76, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fcomm%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fcomm%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fshared.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -22,15 +22,15 @@ pub use self::Failure::*;\n \n use core::prelude::*;\n \n-use alloc::boxed::Box;\n use core::cmp;\n use core::int;\n-use rustrt::local::Local;\n-use rustrt::task::{Task, BlockedTask};\n-use rustrt::thread::Thread;\n \n use sync::{atomic, Mutex, MutexGuard};\n use comm::mpsc_queue as mpsc;\n+use comm::blocking::{mod, SignalToken};\n+use comm::select::StartResult;\n+use comm::select::StartResult::*;\n+use thread::Thread;\n \n const DISCONNECTED: int = int::MIN;\n const FUDGE: int = 1024;\n@@ -43,7 +43,7 @@ pub struct Packet<T> {\n     queue: mpsc::Queue<T>,\n     cnt: atomic::AtomicInt, // How many items are on this channel\n     steals: int, // How many times has a port received without blocking?\n-    to_wake: atomic::AtomicUint, // Task to wake up\n+    to_wake: atomic::AtomicUint, // SignalToken for wake up\n \n     // The number of channels which are currently using this packet.\n     channels: atomic::AtomicInt,\n@@ -95,41 +95,34 @@ impl<T: Send> Packet<T> {\n     //\n     // This can only be called at channel-creation time\n     pub fn inherit_blocker(&mut self,\n-                           task: Option<BlockedTask>,\n+                           token: Option<SignalToken>,\n                            guard: MutexGuard<()>) {\n-        match task {\n-            Some(task) => {\n-                assert_eq!(self.cnt.load(atomic::SeqCst), 0);\n-                assert_eq!(self.to_wake.load(atomic::SeqCst), 0);\n-                self.to_wake.store(unsafe { task.cast_to_uint() },\n-                                   atomic::SeqCst);\n-                self.cnt.store(-1, atomic::SeqCst);\n-\n-                // This store is a little sketchy. What's happening here is\n-                // that we're transferring a blocker from a oneshot or stream\n-                // channel to this shared channel. In doing so, we never\n-                // spuriously wake them up and rather only wake them up at the\n-                // appropriate time. This implementation of shared channels\n-                // assumes that any blocking recv() will undo the increment of\n-                // steals performed in try_recv() once the recv is complete.\n-                // This thread that we're inheriting, however, is not in the\n-                // middle of recv. Hence, the first time we wake them up,\n-                // they're going to wake up from their old port, move on to the\n-                // upgraded port, and then call the block recv() function.\n-                //\n-                // When calling this function, they'll find there's data\n-                // immediately available, counting it as a steal. This in fact\n-                // wasn't a steal because we appropriately blocked them waiting\n-                // for data.\n-                //\n-                // To offset this bad increment, we initially set the steal\n-                // count to -1. You'll find some special code in\n-                // abort_selection() as well to ensure that this -1 steal count\n-                // doesn't escape too far.\n-                self.steals = -1;\n-            }\n-            None => {}\n-        }\n+        token.map(|token| {\n+            assert_eq!(self.cnt.load(atomic::SeqCst), 0);\n+            assert_eq!(self.to_wake.load(atomic::SeqCst), 0);\n+            self.to_wake.store(unsafe { token.cast_to_uint() }, atomic::SeqCst);\n+            self.cnt.store(-1, atomic::SeqCst);\n+\n+            // This store is a little sketchy. What's happening here is that\n+            // we're transferring a blocker from a oneshot or stream channel to\n+            // this shared channel. In doing so, we never spuriously wake them\n+            // up and rather only wake them up at the appropriate time. This\n+            // implementation of shared channels assumes that any blocking\n+            // recv() will undo the increment of steals performed in try_recv()\n+            // once the recv is complete.  This thread that we're inheriting,\n+            // however, is not in the middle of recv. Hence, the first time we\n+            // wake them up, they're going to wake up from their old port, move\n+            // on to the upgraded port, and then call the block recv() function.\n+            //\n+            // When calling this function, they'll find there's data immediately\n+            // available, counting it as a steal. This in fact wasn't a steal\n+            // because we appropriately blocked them waiting for data.\n+            //\n+            // To offset this bad increment, we initially set the steal count to\n+            // -1. You'll find some special code in abort_selection() as well to\n+            // ensure that this -1 steal count doesn't escape too far.\n+            self.steals = -1;\n+        });\n \n         // When the shared packet is constructed, we grabbed this lock. The\n         // purpose of this lock is to ensure that abort_selection() doesn't\n@@ -175,7 +168,7 @@ impl<T: Send> Packet<T> {\n         self.queue.push(t);\n         match self.cnt.fetch_add(1, atomic::SeqCst) {\n             -1 => {\n-                self.take_to_wake().wake().map(|t| t.reawaken());\n+                self.take_to_wake().signal();\n             }\n \n             // In this case, we have possibly failed to send our data, and\n@@ -232,10 +225,10 @@ impl<T: Send> Packet<T> {\n             data => return data,\n         }\n \n-        let task: Box<Task> = Local::take();\n-        task.deschedule(1, |task| {\n-            self.decrement(task)\n-        });\n+        let (wait_token, signal_token) = blocking::tokens();\n+        if self.decrement(signal_token) == Installed {\n+            wait_token.wait()\n+        }\n \n         match self.try_recv() {\n             data @ Ok(..) => { self.steals -= 1; data }\n@@ -244,10 +237,11 @@ impl<T: Send> Packet<T> {\n     }\n \n     // Essentially the exact same thing as the stream decrement function.\n-    fn decrement(&mut self, task: BlockedTask) -> Result<(), BlockedTask> {\n+    // Returns true if blocking should proceed.\n+    fn decrement(&mut self, token: SignalToken) -> StartResult {\n         assert_eq!(self.to_wake.load(atomic::SeqCst), 0);\n-        let n = unsafe { task.cast_to_uint() };\n-        self.to_wake.store(n, atomic::SeqCst);\n+        let ptr = unsafe { token.cast_to_uint() };\n+        self.to_wake.store(ptr, atomic::SeqCst);\n \n         let steals = self.steals;\n         self.steals = 0;\n@@ -258,33 +252,33 @@ impl<T: Send> Packet<T> {\n             // data, we successfully sleep\n             n => {\n                 assert!(n >= 0);\n-                if n - steals <= 0 { return Ok(()) }\n+                if n - steals <= 0 { return Installed }\n             }\n         }\n \n         self.to_wake.store(0, atomic::SeqCst);\n-        Err(unsafe { BlockedTask::cast_from_uint(n) })\n+        drop(unsafe { SignalToken::cast_from_uint(ptr) });\n+        Abort\n     }\n \n     pub fn try_recv(&mut self) -> Result<T, Failure> {\n         let ret = match self.queue.pop() {\n             mpsc::Data(t) => Some(t),\n             mpsc::Empty => None,\n \n-            // This is a bit of an interesting case. The channel is\n-            // reported as having data available, but our pop() has\n-            // failed due to the queue being in an inconsistent state.\n-            // This means that there is some pusher somewhere which has\n-            // yet to complete, but we are guaranteed that a pop will\n-            // eventually succeed. In this case, we spin in a yield loop\n-            // because the remote sender should finish their enqueue\n+            // This is a bit of an interesting case. The channel is reported as\n+            // having data available, but our pop() has failed due to the queue\n+            // being in an inconsistent state.  This means that there is some\n+            // pusher somewhere which has yet to complete, but we are guaranteed\n+            // that a pop will eventually succeed. In this case, we spin in a\n+            // yield loop because the remote sender should finish their enqueue\n             // operation \"very quickly\".\n             //\n             // Avoiding this yield loop would require a different queue\n-            // abstraction which provides the guarantee that after M\n-            // pushes have succeeded, at least M pops will succeed. The\n-            // current queues guarantee that if there are N active\n-            // pushes, you can pop N times once all N have finished.\n+            // abstraction which provides the guarantee that after M pushes have\n+            // succeeded, at least M pops will succeed. The current queues\n+            // guarantee that if there are N active pushes, you can pop N times\n+            // once all N have finished.\n             mpsc::Inconsistent => {\n                 let data;\n                 loop {\n@@ -354,7 +348,7 @@ impl<T: Send> Packet<T> {\n         }\n \n         match self.cnt.swap(DISCONNECTED, atomic::SeqCst) {\n-            -1 => { self.take_to_wake().wake().map(|t| t.reawaken()); }\n+            -1 => { self.take_to_wake().signal(); }\n             DISCONNECTED => {}\n             n => { assert!(n >= 0); }\n         }\n@@ -366,8 +360,7 @@ impl<T: Send> Packet<T> {\n         self.port_dropped.store(true, atomic::SeqCst);\n         let mut steals = self.steals;\n         while {\n-            let cnt = self.cnt.compare_and_swap(\n-                            steals, DISCONNECTED, atomic::SeqCst);\n+            let cnt = self.cnt.compare_and_swap(steals, DISCONNECTED, atomic::SeqCst);\n             cnt != DISCONNECTED && cnt != steals\n         } {\n             // See the discussion in 'try_recv' for why we yield\n@@ -382,11 +375,11 @@ impl<T: Send> Packet<T> {\n     }\n \n     // Consumes ownership of the 'to_wake' field.\n-    fn take_to_wake(&mut self) -> BlockedTask {\n-        let task = self.to_wake.load(atomic::SeqCst);\n+    fn take_to_wake(&mut self) -> SignalToken {\n+        let ptr = self.to_wake.load(atomic::SeqCst);\n         self.to_wake.store(0, atomic::SeqCst);\n-        assert!(task != 0);\n-        unsafe { BlockedTask::cast_from_uint(task) }\n+        assert!(ptr != 0);\n+        unsafe { SignalToken::cast_from_uint(ptr) }\n     }\n \n     ////////////////////////////////////////////////////////////////////////////\n@@ -414,19 +407,18 @@ impl<T: Send> Packet<T> {\n         }\n     }\n \n-    // Inserts the blocked task for selection on this port, returning it back if\n-    // the port already has data on it.\n+    // Inserts the signal token for selection on this port, returning true if\n+    // blocking should proceed.\n     //\n     // The code here is the same as in stream.rs, except that it doesn't need to\n     // peek at the channel to see if an upgrade is pending.\n-    pub fn start_selection(&mut self,\n-                           task: BlockedTask) -> Result<(), BlockedTask> {\n-        match self.decrement(task) {\n-            Ok(()) => Ok(()),\n-            Err(task) => {\n+    pub fn start_selection(&mut self, token: SignalToken) -> StartResult {\n+        match self.decrement(token) {\n+            Installed => Installed,\n+            Abort => {\n                 let prev = self.bump(1);\n                 assert!(prev == DISCONNECTED || prev >= 0);\n-                return Err(task);\n+                Abort\n             }\n         }\n     }\n@@ -464,7 +456,7 @@ impl<T: Send> Packet<T> {\n             let cur = prev + steals + 1;\n             assert!(cur >= 0);\n             if prev < 0 {\n-                self.take_to_wake().trash();\n+                drop(self.take_to_wake());\n             } else {\n                 while self.to_wake.load(atomic::SeqCst) != 0 {\n                     Thread::yield_now();"}, {"sha": "b68f626060eda78ee106a8b46017ee99f58eb8f5", "filename": "src/libstd/comm/stream.rs", "status": "modified", "additions": 28, "deletions": 30, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fcomm%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fcomm%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fstream.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -24,16 +24,14 @@ use self::Message::*;\n \n use core::prelude::*;\n \n-use alloc::boxed::Box;\n use core::cmp;\n use core::int;\n-use rustrt::local::Local;\n-use rustrt::task::{Task, BlockedTask};\n-use rustrt::thread::Thread;\n+use thread::Thread;\n \n use sync::atomic;\n use comm::spsc_queue as spsc;\n use comm::Receiver;\n+use comm::blocking::{mod, SignalToken};\n \n const DISCONNECTED: int = int::MIN;\n #[cfg(test)]\n@@ -46,7 +44,7 @@ pub struct Packet<T> {\n \n     cnt: atomic::AtomicInt, // How many items are on this channel\n     steals: int, // How many times has a port received without blocking?\n-    to_wake: atomic::AtomicUint, // Task to wake up\n+    to_wake: atomic::AtomicUint, // SignalToken for the blocked thread to wake up\n \n     port_dropped: atomic::AtomicBool, // flag if the channel has been destroyed.\n }\n@@ -60,13 +58,13 @@ pub enum Failure<T> {\n pub enum UpgradeResult {\n     UpSuccess,\n     UpDisconnected,\n-    UpWoke(BlockedTask),\n+    UpWoke(SignalToken),\n }\n \n pub enum SelectionResult<T> {\n     SelSuccess,\n-    SelCanceled(BlockedTask),\n-    SelUpgraded(BlockedTask, Receiver<T>),\n+    SelCanceled,\n+    SelUpgraded(SignalToken, Receiver<T>),\n }\n \n // Any message could contain an \"upgrade request\" to a new shared port, so the\n@@ -89,7 +87,6 @@ impl<T: Send> Packet<T> {\n         }\n     }\n \n-\n     pub fn send(&mut self, t: T) -> Result<(), T> {\n         // If the other port has deterministically gone away, then definitely\n         // must return the data back up the stack. Otherwise, the data is\n@@ -98,10 +95,11 @@ impl<T: Send> Packet<T> {\n \n         match self.do_send(Data(t)) {\n             UpSuccess | UpDisconnected => {},\n-            UpWoke(task) => { task.wake().map(|t| t.reawaken()); }\n+            UpWoke(token) => { token.signal(); }\n         }\n         Ok(())\n     }\n+\n     pub fn upgrade(&mut self, up: Receiver<T>) -> UpgradeResult {\n         // If the port has gone away, then there's no need to proceed any\n         // further.\n@@ -144,20 +142,20 @@ impl<T: Send> Packet<T> {\n     }\n \n     // Consumes ownership of the 'to_wake' field.\n-    fn take_to_wake(&mut self) -> BlockedTask {\n-        let task = self.to_wake.load(atomic::SeqCst);\n+    fn take_to_wake(&mut self) -> SignalToken {\n+        let ptr = self.to_wake.load(atomic::SeqCst);\n         self.to_wake.store(0, atomic::SeqCst);\n-        assert!(task != 0);\n-        unsafe { BlockedTask::cast_from_uint(task) }\n+        assert!(ptr != 0);\n+        unsafe { SignalToken::cast_from_uint(ptr) }\n     }\n \n     // Decrements the count on the channel for a sleeper, returning the sleeper\n     // back if it shouldn't sleep. Note that this is the location where we take\n     // steals into account.\n-    fn decrement(&mut self, task: BlockedTask) -> Result<(), BlockedTask> {\n+    fn decrement(&mut self, token: SignalToken) -> Result<(), SignalToken> {\n         assert_eq!(self.to_wake.load(atomic::SeqCst), 0);\n-        let n = unsafe { task.cast_to_uint() };\n-        self.to_wake.store(n, atomic::SeqCst);\n+        let ptr = unsafe { token.cast_to_uint() };\n+        self.to_wake.store(ptr, atomic::SeqCst);\n \n         let steals = self.steals;\n         self.steals = 0;\n@@ -173,7 +171,7 @@ impl<T: Send> Packet<T> {\n         }\n \n         self.to_wake.store(0, atomic::SeqCst);\n-        Err(unsafe { BlockedTask::cast_from_uint(n) })\n+        Err(unsafe { SignalToken::cast_from_uint(ptr) })\n     }\n \n     pub fn recv(&mut self) -> Result<T, Failure<T>> {\n@@ -185,10 +183,10 @@ impl<T: Send> Packet<T> {\n \n         // Welp, our channel has no data. Deschedule the current task and\n         // initiate the blocking protocol.\n-        let task: Box<Task> = Local::take();\n-        task.deschedule(1, |task| {\n-            self.decrement(task)\n-        });\n+        let (wait_token, signal_token) = blocking::tokens();\n+        if self.decrement(signal_token).is_ok() {\n+            wait_token.wait()\n+        }\n \n         match self.try_recv() {\n             // Messages which actually popped from the queue shouldn't count as\n@@ -269,7 +267,7 @@ impl<T: Send> Packet<T> {\n         // Dropping a channel is pretty simple, we just flag it as disconnected\n         // and then wakeup a blocker if there is one.\n         match self.cnt.swap(DISCONNECTED, atomic::SeqCst) {\n-            -1 => { self.take_to_wake().wake().map(|t| t.reawaken()); }\n+            -1 => { self.take_to_wake().signal(); }\n             DISCONNECTED => {}\n             n => { assert!(n >= 0); }\n         }\n@@ -364,19 +362,19 @@ impl<T: Send> Packet<T> {\n \n     // Attempts to start selecting on this port. Like a oneshot, this can fail\n     // immediately because of an upgrade.\n-    pub fn start_selection(&mut self, task: BlockedTask) -> SelectionResult<T> {\n-        match self.decrement(task) {\n+    pub fn start_selection(&mut self, token: SignalToken) -> SelectionResult<T> {\n+        match self.decrement(token) {\n             Ok(()) => SelSuccess,\n-            Err(task) => {\n+            Err(token) => {\n                 let ret = match self.queue.peek() {\n                     Some(&GoUp(..)) => {\n                         match self.queue.pop() {\n-                            Some(GoUp(port)) => SelUpgraded(task, port),\n+                            Some(GoUp(port)) => SelUpgraded(token, port),\n                             _ => unreachable!(),\n                         }\n                     }\n-                    Some(..) => SelCanceled(task),\n-                    None => SelCanceled(task),\n+                    Some(..) => SelCanceled,\n+                    None => SelCanceled,\n                 };\n                 // Undo our decrement above, and we should be guaranteed that the\n                 // previous value is positive because we're not going to sleep\n@@ -439,7 +437,7 @@ impl<T: Send> Packet<T> {\n             // final solution but rather out of necessity for now to get\n             // something working.\n             if prev < 0 {\n-                self.take_to_wake().trash();\n+                drop(self.take_to_wake());\n             } else {\n                 while self.to_wake.load(atomic::SeqCst) != 0 {\n                     Thread::yield_now();"}, {"sha": "f75186e70e3d4a6a4f89e33fb0a799fac3fda994", "filename": "src/libstd/comm/sync.rs", "status": "modified", "additions": 136, "deletions": 151, "changes": 287, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fcomm%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fcomm%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fsync.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -38,24 +38,19 @@ use core::prelude::*;\n pub use self::Failure::*;\n use self::Blocker::*;\n \n-use alloc::boxed::Box;\n use vec::Vec;\n use core::mem;\n-use core::cell::UnsafeCell;\n-use rustrt::local::Local;\n-use rustrt::mutex::{NativeMutex, LockGuard};\n-use rustrt::task::{Task, BlockedTask};\n \n-use sync::atomic;\n+use sync::{atomic, Mutex, MutexGuard};\n+use comm::blocking::{mod, WaitToken, SignalToken};\n+use comm::select::StartResult::{mod, Installed, Abort};\n \n pub struct Packet<T> {\n     /// Only field outside of the mutex. Just done for kicks, but mainly because\n     /// the other shared channel already had the code implemented\n     channels: atomic::AtomicUint,\n \n-    /// The state field is protected by this mutex\n-    lock: NativeMutex,\n-    state: UnsafeCell<State<T>>,\n+    lock: Mutex<State<T>>,\n }\n \n struct State<T> {\n@@ -74,10 +69,10 @@ struct State<T> {\n     canceled: Option<&'static mut bool>,\n }\n \n-/// Possible flavors of tasks who can be blocked on this channel.\n+/// Possible flavors of threads who can be blocked on this channel.\n enum Blocker {\n-    BlockedSender(BlockedTask),\n-    BlockedReceiver(BlockedTask),\n+    BlockedSender(SignalToken),\n+    BlockedReceiver(SignalToken),\n     NoneBlocked\n }\n \n@@ -89,7 +84,7 @@ struct Queue {\n }\n \n struct Node {\n-    task: Option<BlockedTask>,\n+    token: Option<SignalToken>,\n     next: *mut Node,\n }\n \n@@ -106,36 +101,36 @@ pub enum Failure {\n     Disconnected,\n }\n \n-/// Atomically blocks the current task, placing it into `slot`, unlocking `lock`\n+/// Atomically blocks the current thread, placing it into `slot`, unlocking `lock`\n /// in the meantime. This re-locks the mutex upon returning.\n-fn wait(slot: &mut Blocker, f: fn(BlockedTask) -> Blocker,\n-        lock: &NativeMutex) {\n-    let me: Box<Task> = Local::take();\n-    me.deschedule(1, |task| {\n-        match mem::replace(slot, f(task)) {\n-            NoneBlocked => {}\n-            _ => unreachable!(),\n-        }\n-        unsafe { lock.unlock_noguard(); }\n-        Ok(())\n-    });\n-    unsafe { lock.lock_noguard(); }\n+fn wait<'a, 'b, T: Send>(lock: &'a Mutex<State<T>>,\n+                         mut guard: MutexGuard<'b, State<T>>,\n+                         f: fn(SignalToken) -> Blocker)\n+                         -> MutexGuard<'a, State<T>>\n+{\n+    let (wait_token, signal_token) = blocking::tokens();\n+    match mem::replace(&mut guard.blocker, f(signal_token)) {\n+        NoneBlocked => {}\n+        _ => unreachable!(),\n+    }\n+    drop(guard);        // unlock\n+    wait_token.wait();  // block\n+    lock.lock()         // relock\n }\n \n-/// Wakes up a task, dropping the lock at the correct time\n-fn wakeup(task: BlockedTask, guard: LockGuard) {\n+/// Wakes up a thread, dropping the lock at the correct time\n+fn wakeup<T>(token: SignalToken, guard: MutexGuard<State<T>>) {\n     // We need to be careful to wake up the waiting task *outside* of the mutex\n     // in case it incurs a context switch.\n-    mem::drop(guard);\n-    task.wake().map(|t| t.reawaken());\n+    drop(guard);\n+    token.signal();\n }\n \n impl<T: Send> Packet<T> {\n     pub fn new(cap: uint) -> Packet<T> {\n         Packet {\n             channels: atomic::AtomicUint::new(1),\n-            lock: unsafe { NativeMutex::new() },\n-            state: UnsafeCell::new(State {\n+            lock: Mutex::new(State {\n                 disconnected: false,\n                 blocker: NoneBlocked,\n                 cap: cap,\n@@ -153,79 +148,77 @@ impl<T: Send> Packet<T> {\n         }\n     }\n \n-    // Locks this channel, returning a guard for the state and the mutable state\n-    // itself. Care should be taken to ensure that the state does not escape the\n-    // guard!\n-    //\n-    // Note that we're ok promoting an & reference to an &mut reference because\n-    // the lock ensures that we're the only ones in the world with a pointer to\n-    // the state.\n-    fn lock<'a>(&'a self) -> (LockGuard<'a>, &'a mut State<T>) {\n-        unsafe {\n-            let guard = self.lock.lock();\n-            (guard, &mut *self.state.get())\n+    // wait until a send slot is available, returning locked access to\n+    // the channel state.\n+    fn acquire_send_slot(&self) -> MutexGuard<State<T>> {\n+        let mut node = Node { token: None, next: 0 as *mut Node };\n+        loop {\n+            let mut guard = self.lock.lock();\n+            // are we ready to go?\n+            if guard.disconnected || guard.buf.size() < guard.buf.cap() {\n+                return guard;\n+            }\n+            // no room; actually block\n+            let wait_token = guard.queue.enqueue(&mut node);\n+            drop(guard);\n+            wait_token.wait();\n         }\n     }\n \n     pub fn send(&self, t: T) -> Result<(), T> {\n-        let (guard, state) = self.lock();\n-\n-        // wait for a slot to become available, and enqueue the data\n-        while !state.disconnected && state.buf.size() == state.buf.cap() {\n-            state.queue.enqueue(&self.lock);\n-        }\n-        if state.disconnected { return Err(t) }\n-        state.buf.enqueue(t);\n+        let mut guard = self.acquire_send_slot();\n+        if guard.disconnected { return Err(t) }\n+        guard.buf.enqueue(t);\n \n-        match mem::replace(&mut state.blocker, NoneBlocked) {\n+        match mem::replace(&mut guard.blocker, NoneBlocked) {\n             // if our capacity is 0, then we need to wait for a receiver to be\n             // available to take our data. After waiting, we check again to make\n             // sure the port didn't go away in the meantime. If it did, we need\n             // to hand back our data.\n-            NoneBlocked if state.cap == 0 => {\n+            NoneBlocked if guard.cap == 0 => {\n                 let mut canceled = false;\n-                assert!(state.canceled.is_none());\n-                state.canceled = Some(unsafe { mem::transmute(&mut canceled) });\n-                wait(&mut state.blocker, BlockedSender, &self.lock);\n-                if canceled {Err(state.buf.dequeue())} else {Ok(())}\n+                assert!(guard.canceled.is_none());\n+                guard.canceled = Some(unsafe { mem::transmute(&mut canceled) });\n+                let mut guard = wait(&self.lock, guard, BlockedSender);\n+                if canceled {Err(guard.buf.dequeue())} else {Ok(())}\n             }\n \n             // success, we buffered some data\n             NoneBlocked => Ok(()),\n \n             // success, someone's about to receive our buffered data.\n-            BlockedReceiver(task) => { wakeup(task, guard); Ok(()) }\n+            BlockedReceiver(token) => { wakeup(token, guard); Ok(()) }\n \n             BlockedSender(..) => panic!(\"lolwut\"),\n         }\n     }\n \n     pub fn try_send(&self, t: T) -> Result<(), super::TrySendError<T>> {\n-        let (guard, state) = self.lock();\n-        if state.disconnected {\n+        let mut guard = self.lock.lock();\n+        if guard.disconnected {\n             Err(super::RecvDisconnected(t))\n-        } else if state.buf.size() == state.buf.cap() {\n+        } else if guard.buf.size() == guard.buf.cap() {\n             Err(super::Full(t))\n-        } else if state.cap == 0 {\n+        } else if guard.cap == 0 {\n             // With capacity 0, even though we have buffer space we can't\n             // transfer the data unless there's a receiver waiting.\n-            match mem::replace(&mut state.blocker, NoneBlocked) {\n+            match mem::replace(&mut guard.blocker, NoneBlocked) {\n                 NoneBlocked => Err(super::Full(t)),\n                 BlockedSender(..) => unreachable!(),\n-                BlockedReceiver(task) => {\n-                    state.buf.enqueue(t);\n-                    wakeup(task, guard);\n+                BlockedReceiver(token) => {\n+                    guard.buf.enqueue(t);\n+                    wakeup(token, guard);\n                     Ok(())\n                 }\n             }\n         } else {\n             // If the buffer has some space and the capacity isn't 0, then we\n             // just enqueue the data for later retrieval, ensuring to wake up\n             // any blocked receiver if there is one.\n-            assert!(state.buf.size() < state.buf.cap());\n-            state.buf.enqueue(t);\n-            match mem::replace(&mut state.blocker, NoneBlocked) {\n-                BlockedReceiver(task) => wakeup(task, guard),\n+            assert!(guard.buf.size() < guard.buf.cap());\n+            guard.buf.enqueue(t);\n+            match mem::replace(&mut guard.blocker, NoneBlocked) {\n+                BlockedReceiver(token) => wakeup(token, guard),\n                 NoneBlocked => {}\n                 BlockedSender(..) => unreachable!(),\n             }\n@@ -238,34 +231,34 @@ impl<T: Send> Packet<T> {\n     // When reading this, remember that there can only ever be one receiver at\n     // time.\n     pub fn recv(&self) -> Result<T, ()> {\n-        let (guard, state) = self.lock();\n+        let mut guard = self.lock.lock();\n \n         // Wait for the buffer to have something in it. No need for a while loop\n         // because we're the only receiver.\n         let mut waited = false;\n-        if !state.disconnected && state.buf.size() == 0 {\n-            wait(&mut state.blocker, BlockedReceiver, &self.lock);\n+        if !guard.disconnected && guard.buf.size() == 0 {\n+            guard = wait(&self.lock, guard, BlockedReceiver);\n             waited = true;\n         }\n-        if state.disconnected && state.buf.size() == 0 { return Err(()) }\n+        if guard.disconnected && guard.buf.size() == 0 { return Err(()) }\n \n         // Pick up the data, wake up our neighbors, and carry on\n-        assert!(state.buf.size() > 0);\n-        let ret = state.buf.dequeue();\n-        self.wakeup_senders(waited, guard, state);\n+        assert!(guard.buf.size() > 0);\n+        let ret = guard.buf.dequeue();\n+        self.wakeup_senders(waited, guard);\n         return Ok(ret);\n     }\n \n     pub fn try_recv(&self) -> Result<T, Failure> {\n-        let (guard, state) = self.lock();\n+        let mut guard = self.lock.lock();\n \n         // Easy cases first\n-        if state.disconnected { return Err(Disconnected) }\n-        if state.buf.size() == 0 { return Err(Empty) }\n+        if guard.disconnected { return Err(Disconnected) }\n+        if guard.buf.size() == 0 { return Err(Empty) }\n \n         // Be sure to wake up neighbors\n-        let ret = Ok(state.buf.dequeue());\n-        self.wakeup_senders(false, guard, state);\n+        let ret = Ok(guard.buf.dequeue());\n+        self.wakeup_senders(false, guard);\n \n         return ret;\n     }\n@@ -275,31 +268,29 @@ impl<T: Send> Packet<T> {\n     // * `waited` - flag if the receiver blocked to receive some data, or if it\n     //              just picked up some data on the way out\n     // * `guard` - the lock guard that is held over this channel's lock\n-    fn wakeup_senders(&self, waited: bool,\n-                      guard: LockGuard,\n-                      state: &mut State<T>) {\n-        let pending_sender1: Option<BlockedTask> = state.queue.dequeue();\n+    fn wakeup_senders(&self, waited: bool, mut guard: MutexGuard<State<T>>) {\n+        let pending_sender1: Option<SignalToken> = guard.queue.dequeue();\n \n         // If this is a no-buffer channel (cap == 0), then if we didn't wait we\n         // need to ACK the sender. If we waited, then the sender waking us up\n         // was already the ACK.\n-        let pending_sender2 = if state.cap == 0 && !waited {\n-            match mem::replace(&mut state.blocker, NoneBlocked) {\n+        let pending_sender2 = if guard.cap == 0 && !waited {\n+            match mem::replace(&mut guard.blocker, NoneBlocked) {\n                 NoneBlocked => None,\n                 BlockedReceiver(..) => unreachable!(),\n-                BlockedSender(task) => {\n-                    state.canceled.take();\n-                    Some(task)\n+                BlockedSender(token) => {\n+                    guard.canceled.take();\n+                    Some(token)\n                 }\n             }\n         } else {\n             None\n         };\n-        mem::drop((state, guard));\n+        mem::drop(guard);\n \n         // only outside of the lock do we wake up the pending tasks\n-        pending_sender1.map(|t| t.wake().map(|t| t.reawaken()));\n-        pending_sender2.map(|t| t.wake().map(|t| t.reawaken()));\n+        pending_sender1.map(|t| t.signal());\n+        pending_sender2.map(|t| t.signal());\n     }\n \n     // Prepares this shared packet for a channel clone, essentially just bumping\n@@ -316,54 +307,54 @@ impl<T: Send> Packet<T> {\n         }\n \n         // Not much to do other than wake up a receiver if one's there\n-        let (guard, state) = self.lock();\n-        if state.disconnected { return }\n-        state.disconnected = true;\n-        match mem::replace(&mut state.blocker, NoneBlocked) {\n+        let mut guard = self.lock.lock();\n+        if guard.disconnected { return }\n+        guard.disconnected = true;\n+        match mem::replace(&mut guard.blocker, NoneBlocked) {\n             NoneBlocked => {}\n             BlockedSender(..) => unreachable!(),\n-            BlockedReceiver(task) => wakeup(task, guard),\n+            BlockedReceiver(token) => wakeup(token, guard),\n         }\n     }\n \n     pub fn drop_port(&self) {\n-        let (guard, state) = self.lock();\n+        let mut guard = self.lock.lock();\n \n-        if state.disconnected { return }\n-        state.disconnected = true;\n+        if guard.disconnected { return }\n+        guard.disconnected = true;\n \n         // If the capacity is 0, then the sender may want its data back after\n         // we're disconnected. Otherwise it's now our responsibility to destroy\n         // the buffered data. As with many other portions of this code, this\n         // needs to be careful to destroy the data *outside* of the lock to\n         // prevent deadlock.\n-        let _data = if state.cap != 0 {\n-            mem::replace(&mut state.buf.buf, Vec::new())\n+        let _data = if guard.cap != 0 {\n+            mem::replace(&mut guard.buf.buf, Vec::new())\n         } else {\n             Vec::new()\n         };\n-        let mut queue = mem::replace(&mut state.queue, Queue {\n+        let mut queue = mem::replace(&mut guard.queue, Queue {\n             head: 0 as *mut Node,\n             tail: 0 as *mut Node,\n         });\n \n-        let waiter = match mem::replace(&mut state.blocker, NoneBlocked) {\n+        let waiter = match mem::replace(&mut guard.blocker, NoneBlocked) {\n             NoneBlocked => None,\n-            BlockedSender(task) => {\n-                *state.canceled.take().unwrap() = true;\n-                Some(task)\n+            BlockedSender(token) => {\n+                *guard.canceled.take().unwrap() = true;\n+                Some(token)\n             }\n             BlockedReceiver(..) => unreachable!(),\n         };\n-        mem::drop((state, guard));\n+        mem::drop(guard);\n \n         loop {\n             match queue.dequeue() {\n-                Some(task) => { task.wake().map(|t| t.reawaken()); }\n+                Some(token) => { token.signal(); }\n                 None => break,\n             }\n         }\n-        waiter.map(|t| t.wake().map(|t| t.reawaken()));\n+        waiter.map(|t| t.signal());\n     }\n \n     ////////////////////////////////////////////////////////////////////////////\n@@ -373,23 +364,23 @@ impl<T: Send> Packet<T> {\n     // If Ok, the value is whether this port has data, if Err, then the upgraded\n     // port needs to be checked instead of this one.\n     pub fn can_recv(&self) -> bool {\n-        let (_g, state) = self.lock();\n-        state.disconnected || state.buf.size() > 0\n+        let guard = self.lock.lock();\n+        guard.disconnected || guard.buf.size() > 0\n     }\n \n     // Attempts to start selection on this port. This can either succeed or fail\n     // because there is data waiting.\n-    pub fn start_selection(&self, task: BlockedTask) -> Result<(), BlockedTask>{\n-        let (_g, state) = self.lock();\n-        if state.disconnected || state.buf.size() > 0 {\n-            Err(task)\n+    pub fn start_selection(&self, token: SignalToken) -> StartResult {\n+        let mut guard = self.lock.lock();\n+        if guard.disconnected || guard.buf.size() > 0 {\n+            Abort\n         } else {\n-            match mem::replace(&mut state.blocker, BlockedReceiver(task)) {\n+            match mem::replace(&mut guard.blocker, BlockedReceiver(token)) {\n                 NoneBlocked => {}\n                 BlockedSender(..) => unreachable!(),\n                 BlockedReceiver(..) => unreachable!(),\n             }\n-            Ok(())\n+            Installed\n         }\n     }\n \n@@ -398,14 +389,14 @@ impl<T: Send> Packet<T> {\n     //\n     // The return value indicates whether there's data on this port.\n     pub fn abort_selection(&self) -> bool {\n-        let (_g, state) = self.lock();\n-        match mem::replace(&mut state.blocker, NoneBlocked) {\n+        let mut guard = self.lock.lock();\n+        match mem::replace(&mut guard.blocker, NoneBlocked) {\n             NoneBlocked => true,\n-            BlockedSender(task) => {\n-                state.blocker = BlockedSender(task);\n+            BlockedSender(token) => {\n+                guard.blocker = BlockedSender(token);\n                 true\n             }\n-            BlockedReceiver(task) => { task.trash(); false }\n+            BlockedReceiver(token) => { drop(token); false }\n         }\n     }\n }\n@@ -414,9 +405,9 @@ impl<T: Send> Packet<T> {\n impl<T: Send> Drop for Packet<T> {\n     fn drop(&mut self) {\n         assert_eq!(self.channels.load(atomic::SeqCst), 0);\n-        let (_g, state) = self.lock();\n-        assert!(state.queue.dequeue().is_none());\n-        assert!(state.canceled.is_none());\n+        let mut guard = self.lock.lock();\n+        assert!(guard.queue.dequeue().is_none());\n+        assert!(guard.canceled.is_none());\n     }\n }\n \n@@ -449,31 +440,25 @@ impl<T> Buffer<T> {\n ////////////////////////////////////////////////////////////////////////////////\n \n impl Queue {\n-    fn enqueue(&mut self, lock: &NativeMutex) {\n-        let task: Box<Task> = Local::take();\n-        let mut node = Node {\n-            task: None,\n-            next: 0 as *mut Node,\n-        };\n-        task.deschedule(1, |task| {\n-            node.task = Some(task);\n-            if self.tail.is_null() {\n-                self.head = &mut node as *mut Node;\n-                self.tail = &mut node as *mut Node;\n-            } else {\n-                unsafe {\n-                    (*self.tail).next = &mut node as *mut Node;\n-                    self.tail = &mut node as *mut Node;\n-                }\n+    fn enqueue(&mut self, node: &mut Node) -> WaitToken {\n+        let (wait_token, signal_token) = blocking::tokens();\n+        node.token = Some(signal_token);\n+        node.next = 0 as *mut Node;\n+\n+        if self.tail.is_null() {\n+            self.head = node as *mut Node;\n+            self.tail = node as *mut Node;\n+        } else {\n+            unsafe {\n+                (*self.tail).next = node as *mut Node;\n+                self.tail = node as *mut Node;\n             }\n-            unsafe { lock.unlock_noguard(); }\n-            Ok(())\n-        });\n-        unsafe { lock.lock_noguard(); }\n-        assert!(node.next.is_null());\n+        }\n+\n+        wait_token\n     }\n \n-    fn dequeue(&mut self) -> Option<BlockedTask> {\n+    fn dequeue(&mut self) -> Option<SignalToken> {\n         if self.head.is_null() {\n             return None\n         }\n@@ -484,7 +469,7 @@ impl Queue {\n         }\n         unsafe {\n             (*node).next = 0 as *mut Node;\n-            Some((*node).task.take().unwrap())\n+            Some((*node).token.take().unwrap())\n         }\n     }\n }"}, {"sha": "8e1e3dc4af92231c86f5de7a3ce135ffe7876f9e", "filename": "src/libstd/failure.rs", "status": "modified", "additions": 32, "deletions": 66, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Ffailure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Ffailure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffailure.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -10,21 +10,15 @@\n \n #![experimental]\n \n-use alloc::boxed::Box;\n+use prelude::*;\n+\n use any::{Any, AnyRefExt};\n use cell::RefCell;\n use fmt;\n-use io::{Writer, IoResult};\n-use kinds::Send;\n-use option::Option;\n-use option::Option::{Some, None};\n-use result::Result::Ok;\n-use rt::backtrace;\n-use rustrt::{Stderr, Stdio};\n-use rustrt::local::Local;\n-use rustrt::task::Task;\n-use str::Str;\n-use string::String;\n+use io::IoResult;\n+use rt::{backtrace, unwind};\n+use rt::util::{Stderr, Stdio};\n+use thread::Thread;\n \n // Defined in this module instead of io::stdio so that the unwinding\n thread_local! {\n@@ -52,63 +46,35 @@ pub fn on_fail(obj: &(Any+Send), file: &'static str, line: uint) {\n         }\n     };\n     let mut err = Stderr;\n-\n-    // It is assumed that all reasonable rust code will have a local task at\n-    // all times. This means that this `exists` will return true almost all of\n-    // the time. There are border cases, however, when the runtime has\n-    // *almost* set up the local task, but hasn't quite gotten there yet. In\n-    // order to get some better diagnostics, we print on panic and\n-    // immediately abort the whole process if there is no local task\n-    // available.\n-    if !Local::exists(None::<Task>) {\n-        let _ = writeln!(&mut err, \"panicked at '{}', {}:{}\", msg, file, line);\n-        if backtrace::log_enabled() {\n-            let _ = backtrace::write(&mut err);\n-        } else {\n-            let _ = writeln!(&mut err, \"run with `RUST_BACKTRACE=1` to \\\n-                                        see a backtrace\");\n-        }\n-        return\n-    }\n-\n-    // Peel the name out of local task so we can print it. We've got to be sure\n-    // that the local task is in TLS while we're printing as I/O may occur.\n-    let (name, unwinding) = {\n-        let mut t = Local::borrow(None::<Task>);\n-        (t.name.take(), t.unwinder.unwinding())\n-    };\n-    {\n-        let n = name.as_ref().map(|n| n.as_slice()).unwrap_or(\"<unnamed>\");\n-\n-        let prev = LOCAL_STDERR.with(|s| s.borrow_mut().take());\n-        match prev {\n-            Some(mut stderr) => {\n-                // FIXME: what to do when the task printing panics?\n-                let _ = writeln!(stderr,\n-                                 \"task '{}' panicked at '{}', {}:{}\\n\",\n-                                 n, msg, file, line);\n-                if backtrace::log_enabled() {\n-                    let _ = backtrace::write(&mut *stderr);\n-                }\n-                let mut s = Some(stderr);\n-                LOCAL_STDERR.with(|slot| {\n-                    *slot.borrow_mut() = s.take();\n-                });\n+    let thread = Thread::current();\n+    let name = thread.name().unwrap_or(\"<unnamed>\");\n+    let prev = LOCAL_STDERR.with(|s| s.borrow_mut().take());\n+    match prev {\n+        Some(mut stderr) => {\n+            // FIXME: what to do when the thread printing panics?\n+            let _ = writeln!(stderr,\n+                             \"thread '{}' panicked at '{}', {}:{}\\n\",\n+                             name, msg, file, line);\n+            if backtrace::log_enabled() {\n+                let _ = backtrace::write(&mut *stderr);\n             }\n-            None => {\n-                let _ = writeln!(&mut err, \"task '{}' panicked at '{}', {}:{}\",\n-                                 n, msg, file, line);\n-                if backtrace::log_enabled() {\n-                    let _ = backtrace::write(&mut err);\n-                }\n+            let mut s = Some(stderr);\n+            LOCAL_STDERR.with(|slot| {\n+                *slot.borrow_mut() = s.take();\n+            });\n+        }\n+        None => {\n+            let _ = writeln!(&mut err, \"thread '{}' panicked at '{}', {}:{}\",\n+                             name, msg, file, line);\n+            if backtrace::log_enabled() {\n+                let _ = backtrace::write(&mut err);\n             }\n         }\n+    }\n \n-        // If this is a double panic, make sure that we printed a backtrace\n-        // for this panic.\n-        if unwinding && !backtrace::log_enabled() {\n-            let _ = backtrace::write(&mut err);\n-        }\n+    // If this is a double panic, make sure that we printed a backtrace\n+    // for this panic.\n+    if unwind::panicking() && !backtrace::log_enabled() {\n+        let _ = backtrace::write(&mut err);\n     }\n-    Local::borrow(None::<Task>).name = name;\n }"}, {"sha": "e865bf42bd01d5239c6d912a05a6bba572d9526a", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -156,18 +156,18 @@ mod test {\n     use prelude::*;\n     use super::*;\n     use io;\n-    use task;\n+    use thread::Thread;\n \n     #[test]\n     fn test_rx_reader() {\n         let (tx, rx) = channel();\n-        task::spawn(move|| {\n+        Thread::spawn(move|| {\n           tx.send(vec![1u8, 2u8]);\n           tx.send(vec![]);\n           tx.send(vec![3u8, 4u8]);\n           tx.send(vec![5u8, 6u8]);\n           tx.send(vec![7u8, 8u8]);\n-        });\n+        }).detach();\n \n         let mut reader = ChanReader::new(rx);\n         let mut buf = [0u8, ..3];\n@@ -203,14 +203,14 @@ mod test {\n     #[test]\n     fn test_rx_buffer() {\n         let (tx, rx) = channel();\n-        task::spawn(move|| {\n+        Thread::spawn(move|| {\n           tx.send(b\"he\".to_vec());\n           tx.send(b\"llo wo\".to_vec());\n           tx.send(b\"\".to_vec());\n           tx.send(b\"rld\\nhow \".to_vec());\n           tx.send(b\"are you?\".to_vec());\n           tx.send(b\"\".to_vec());\n-        });\n+        }).detach();\n \n         let mut reader = ChanReader::new(rx);\n \n@@ -229,7 +229,7 @@ mod test {\n         writer.write_be_u32(42).unwrap();\n \n         let wanted = vec![0u8, 0u8, 0u8, 42u8];\n-        let got = match task::try(move|| { rx.recv() }) {\n+        let got = match Thread::spawn(move|| { rx.recv() }).join() {\n             Ok(got) => got,\n             Err(_) => panic!(),\n         };"}, {"sha": "5807a3bc4662e436d1f7c70e5fb7fa383ddc9c2b", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -105,6 +105,7 @@\n //!     # #![allow(dead_code)]\n //!     use std::io::{TcpListener, TcpStream};\n //!     use std::io::{Acceptor, Listener};\n+//!     use std::thread::Thread;\n //!\n //!     let listener = TcpListener::bind(\"127.0.0.1:80\");\n //!\n@@ -119,10 +120,10 @@\n //!     for stream in acceptor.incoming() {\n //!         match stream {\n //!             Err(e) => { /* connection failed */ }\n-//!             Ok(stream) => spawn(move|| {\n+//!             Ok(stream) => Thread::spawn(move|| {\n //!                 // connection succeeded\n //!                 handle_client(stream)\n-//!             })\n+//!             }).detach()\n //!         }\n //!     }\n //!"}, {"sha": "01eb33b44f92faf4f850a83ef16e5369a4f25c43", "filename": "src/libstd/io/net/pipe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -549,7 +549,7 @@ mod tests {\n                 Err(ref e) if e.kind == TimedOut => {}\n                 Err(e) => panic!(\"error: {}\", e),\n             }\n-            ::task::deschedule();\n+            ::thread::Thread::yield_now();\n             if i == 1000 { panic!(\"should have a pending connection\") }\n         }\n         drop(l);"}, {"sha": "6bc952f30af6c912f71a657bf7851cfabd87f01b", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -136,16 +136,17 @@ impl TcpStream {\n     /// use std::io::timer;\n     /// use std::io::TcpStream;\n     /// use std::time::Duration;\n+    /// use std::thread::Thread;\n     ///\n     /// let mut stream = TcpStream::connect(\"127.0.0.1:34254\").unwrap();\n     /// let stream2 = stream.clone();\n     ///\n-    /// spawn(move|| {\n+    /// Thread::spawn(move|| {\n     ///     // close this stream after one second\n     ///     timer::sleep(Duration::seconds(1));\n     ///     let mut stream = stream2;\n     ///     stream.close_read();\n-    /// });\n+    /// }).detach();\n     ///\n     /// // wait for some data, will get canceled after one second\n     /// let mut buf = [0];\n@@ -279,6 +280,7 @@ impl sys_common::AsInner<TcpStreamImp> for TcpStream {\n /// # #![allow(dead_code)]\n /// use std::io::{TcpListener, TcpStream};\n /// use std::io::{Acceptor, Listener};\n+/// use std::thread::Thread;\n ///\n /// let listener = TcpListener::bind(\"127.0.0.1:80\");\n ///\n@@ -293,10 +295,10 @@ impl sys_common::AsInner<TcpStreamImp> for TcpStream {\n /// for stream in acceptor.incoming() {\n ///     match stream {\n ///         Err(e) => { /* connection failed */ }\n-///         Ok(stream) => spawn(move|| {\n+///         Ok(stream) => Thread::spawn(move|| {\n ///             // connection succeeded\n ///             handle_client(stream)\n-///         })\n+///         }).detach()\n ///     }\n /// }\n ///\n@@ -416,11 +418,12 @@ impl TcpAcceptor {\n     /// ```\n     /// # #![allow(experimental)]\n     /// use std::io::{TcpListener, Listener, Acceptor, EndOfFile};\n+    /// use std::thread::Thread;\n     ///\n     /// let mut a = TcpListener::bind(\"127.0.0.1:8482\").listen().unwrap();\n     /// let a2 = a.clone();\n     ///\n-    /// spawn(move|| {\n+    /// Thread::spawn(move|| {\n     ///     let mut a2 = a2;\n     ///     for socket in a2.incoming() {\n     ///         match socket {\n@@ -429,7 +432,7 @@ impl TcpAcceptor {\n     ///             Err(e) => panic!(\"unexpected error: {}\", e),\n     ///         }\n     ///     }\n-    /// });\n+    /// }).detach();\n     ///\n     /// # fn wait_for_sigint() {}\n     /// // Now that our accept loop is running, wait for the program to be\n@@ -1155,7 +1158,7 @@ mod test {\n                     Err(ref e) if e.kind == TimedOut => {}\n                     Err(e) => panic!(\"error: {}\", e),\n                 }\n-                ::task::deschedule();\n+                ::thread::Thread::yield_now();\n                 if i == 1000 { panic!(\"should have a pending connection\") }\n             }\n         }\n@@ -1378,7 +1381,7 @@ mod test {\n \n         // Try to ensure that the reading clone is indeed reading\n         for _ in range(0i, 50) {\n-            ::task::deschedule();\n+            ::thread::Thread::yield_now();\n         }\n \n         // clone the handle again while it's reading, then let it finish the"}, {"sha": "60360a2bc6445cf29d6c5618632a2f782f3a9944", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -30,6 +30,7 @@ use hash::Hash;\n use std::hash::sip::SipState;\n use io::pipe::{PipeStream, PipePair};\n use path::BytesContainer;\n+use thread::Thread;\n \n use sys;\n use sys::fs::FileDesc;\n@@ -693,10 +694,12 @@ impl Process {\n         fn read(stream: Option<io::PipeStream>) -> Receiver<IoResult<Vec<u8>>> {\n             let (tx, rx) = channel();\n             match stream {\n-                Some(stream) => spawn(move |:| {\n-                    let mut stream = stream;\n-                    tx.send(stream.read_to_end())\n-                }),\n+                Some(stream) => {\n+                    Thread::spawn(move |:| {\n+                        let mut stream = stream;\n+                        tx.send(stream.read_to_end())\n+                    }).detach();\n+                }\n                 None => tx.send(Ok(Vec::new()))\n             }\n             rx"}, {"sha": "aa50597c816980d0e56fc64e6c321f310452edc3", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 13, "deletions": 25, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -42,9 +42,6 @@ use option::Option::{Some, None};\n use ops::{Deref, DerefMut, FnOnce};\n use result::Result::{Ok, Err};\n use rt;\n-use rustrt;\n-use rustrt::local::Local;\n-use rustrt::task::Task;\n use slice::SliceExt;\n use str::StrPrelude;\n use string::String;\n@@ -329,25 +326,17 @@ pub fn set_stderr(stderr: Box<Writer + Send>) -> Option<Box<Writer + Send>> {\n //          // io1 aliases io2\n //      })\n //  })\n-fn with_task_stdout<F>(f: F) where\n-    F: FnOnce(&mut Writer) -> IoResult<()>,\n-{\n-    let result = if Local::exists(None::<Task>) {\n-        let mut my_stdout = LOCAL_STDOUT.with(|slot| {\n-            slot.borrow_mut().take()\n-        }).unwrap_or_else(|| {\n-            box stdout() as Box<Writer + Send>\n-        });\n-        let result = f(&mut *my_stdout);\n-        let mut var = Some(my_stdout);\n-        LOCAL_STDOUT.with(|slot| {\n-            *slot.borrow_mut() = var.take();\n-        });\n-        result\n-    } else {\n-        let mut io = rustrt::Stdout;\n-        f(&mut io as &mut Writer)\n-    };\n+fn with_task_stdout(f: |&mut Writer| -> IoResult<()>) {\n+    let mut my_stdout = LOCAL_STDOUT.with(|slot| {\n+        slot.borrow_mut().take()\n+    }).unwrap_or_else(|| {\n+        box stdout() as Box<Writer + Send>\n+    });\n+    let result = f(&mut *my_stdout);\n+    let mut var = Some(my_stdout);\n+    LOCAL_STDOUT.with(|slot| {\n+        *slot.borrow_mut() = var.take();\n+    });\n     match result {\n         Ok(()) => {}\n         Err(e) => panic!(\"failed printing to stdout: {}\", e),\n@@ -546,13 +535,12 @@ mod tests {\n \n     #[test]\n     fn capture_stderr() {\n-        use realstd::comm::channel;\n-        use realstd::io::{ChanReader, ChanWriter, Reader};\n+        use io::{ChanReader, ChanWriter, Reader};\n \n         let (tx, rx) = channel();\n         let (mut r, w) = (ChanReader::new(rx), ChanWriter::new(tx));\n         spawn(move|| {\n-            ::realstd::io::stdio::set_stderr(box w);\n+            set_stderr(box w);\n             panic!(\"my special message\");\n         });\n         let s = r.read_to_string().unwrap();"}, {"sha": "78c194745a88838c9c3bc3a082b6146e34164ab1", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -104,9 +104,9 @@\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n #![allow(unknown_features)]\n-#![feature(macro_rules, globs, linkage)]\n+#![feature(macro_rules, globs, linkage, thread_local, asm)]\n #![feature(default_type_params, phase, lang_items, unsafe_destructor)]\n-#![feature(import_shadowing, slicing_syntax)]\n+#![feature(import_shadowing, slicing_syntax, tuple_indexing)]\n #![feature(unboxed_closures)]\n \n // Don't link to std. We are std.\n@@ -124,7 +124,6 @@ extern crate core;\n extern crate \"collections\" as core_collections;\n extern crate \"rand\" as core_rand;\n extern crate libc;\n-extern crate rustrt;\n \n // Make std testable by not duplicating lang items. See #2912\n #[cfg(test)] extern crate \"std\" as realstd;\n@@ -167,12 +166,8 @@ pub use core_collections::str;\n pub use core_collections::string;\n pub use core_collections::vec;\n \n-pub use rustrt::c_str;\n-\n pub use unicode::char;\n \n-pub use rustrt::thunk;\n-\n /* Exported macros */\n \n pub mod macros;\n@@ -207,6 +202,7 @@ pub mod prelude;\n #[path = \"num/f64.rs\"]   pub mod f64;\n \n pub mod ascii;\n+pub mod thunk;\n \n /* Common traits */\n \n@@ -216,6 +212,7 @@ pub mod num;\n /* Runtime and platform support */\n \n pub mod thread_local;\n+pub mod c_str;\n pub mod c_vec;\n pub mod dynamic_lib;\n pub mod fmt;\n@@ -230,9 +227,10 @@ pub mod time;\n pub mod collections;\n pub mod hash;\n \n-/* Tasks and communication */\n+/* Threads and communication */\n \n pub mod task;\n+pub mod thread;\n pub mod sync;\n pub mod comm;\n "}, {"sha": "3d03b5324b9c109b91b15cf6f10881d786da281f", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -353,13 +353,15 @@ macro_rules! vec {\n /// # Example\n ///\n /// ```\n+/// use std::thread::Thread;\n+///\n /// let (tx1, rx1) = channel();\n /// let (tx2, rx2) = channel();\n /// # fn long_running_task() {}\n /// # fn calculate_the_answer() -> int { 42i }\n ///\n-/// spawn(move|| { long_running_task(); tx1.send(()) });\n-/// spawn(move|| { tx2.send(calculate_the_answer()) });\n+/// Thread::spawn(move|| { long_running_task(); tx1.send(()) }).detach();\n+/// Thread::spawn(move|| { tx2.send(calculate_the_answer()) }).detach();\n ///\n /// select! (\n ///     () = rx1.recv() => println!(\"the long running task finished first\"),"}, {"sha": "a049ea01b6d49c7e3a67cea0eaee9e50f0de08f0", "filename": "src/libstd/os.rs", "status": "modified", "additions": 30, "deletions": 391, "changes": 421, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -26,6 +26,7 @@\n \n #![allow(missing_docs)]\n #![allow(non_snake_case)]\n+#![allow(unused_imports)]\n \n pub use self::MemoryMapKind::*;\n pub use self::MapOption::*;\n@@ -37,29 +38,26 @@ use fmt;\n use io::{IoResult, IoError};\n use iter::{Iterator, IteratorExt};\n use kinds::Copy;\n-use libc::{c_void, c_int};\n+use libc::{c_void, c_int, c_char};\n use libc;\n use boxed::Box;\n use ops::{Drop, FnOnce};\n use option::Option;\n use option::Option::{Some, None};\n-use os;\n use path::{Path, GenericPath, BytesContainer};\n use sys;\n-use sys::os as os_imp;\n use ptr::RawPtr;\n use ptr;\n use result::Result;\n use result::Result::{Err, Ok};\n-use slice::{AsSlice, SliceExt, PartialEqSliceExt};\n+use slice::{AsSlice, SliceExt};\n use slice::CloneSliceExt;\n use str::{Str, StrPrelude, StrAllocating};\n use string::{String, ToString};\n use sync::atomic::{AtomicInt, INIT_ATOMIC_INT, SeqCst};\n use vec::Vec;\n \n #[cfg(unix)] use c_str::ToCStr;\n-#[cfg(unix)] use libc::c_char;\n \n #[cfg(unix)]\n pub use sys::ext as unix;\n@@ -78,7 +76,6 @@ pub fn num_cpus() -> uint {\n }\n \n pub const TMPBUF_SZ : uint = 1000u;\n-const BUF_BYTES : uint = 2048u;\n \n /// Returns the current working directory as a `Path`.\n ///\n@@ -96,118 +93,12 @@ const BUF_BYTES : uint = 2048u;\n /// ```rust\n /// use std::os;\n ///\n-/// // We assume that we are in a valid directory like \"/home\".\n+/// // We assume that we are in a valid directory.\n /// let current_working_directory = os::getcwd().unwrap();\n /// println!(\"The current directory is {}\", current_working_directory.display());\n-/// // /home\n /// ```\n-#[cfg(unix)]\n pub fn getcwd() -> IoResult<Path> {\n-    use c_str::CString;\n-\n-    let mut buf = [0 as c_char, ..BUF_BYTES];\n-    unsafe {\n-        if libc::getcwd(buf.as_mut_ptr(), buf.len() as libc::size_t).is_null() {\n-            Err(IoError::last_error())\n-        } else {\n-            Ok(Path::new(CString::new(buf.as_ptr(), false)))\n-        }\n-    }\n-}\n-\n-/// Returns the current working directory as a `Path`.\n-///\n-/// # Errors\n-///\n-/// Returns an `Err` if the current working directory value is invalid.\n-/// Possible cases:\n-///\n-/// * Current directory does not exist.\n-/// * There are insufficient permissions to access the current directory.\n-/// * The internal buffer is not large enough to hold the path.\n-///\n-/// # Example\n-///\n-/// ```rust\n-/// use std::os;\n-///\n-/// // We assume that we are in a valid directory like \"C:\\\\Windows\".\n-/// let current_working_directory = os::getcwd().unwrap();\n-/// println!(\"The current directory is {}\", current_working_directory.display());\n-/// // C:\\\\Windows\n-/// ```\n-#[cfg(windows)]\n-pub fn getcwd() -> IoResult<Path> {\n-    use libc::DWORD;\n-    use libc::GetCurrentDirectoryW;\n-    use io::OtherIoError;\n-\n-    let mut buf = [0 as u16, ..BUF_BYTES];\n-    unsafe {\n-        if libc::GetCurrentDirectoryW(buf.len() as DWORD, buf.as_mut_ptr()) == 0 as DWORD {\n-            return Err(IoError::last_error());\n-        }\n-    }\n-\n-    match String::from_utf16(::str::truncate_utf16_at_nul(&buf)) {\n-        Some(ref cwd) => Ok(Path::new(cwd)),\n-        None => Err(IoError {\n-            kind: OtherIoError,\n-            desc: \"GetCurrentDirectoryW returned invalid UTF-16\",\n-            detail: None,\n-        }),\n-    }\n-}\n-\n-#[cfg(windows)]\n-pub mod windoze {\n-    use libc::types::os::arch::extra::DWORD;\n-    use libc;\n-    use ops::FnMut;\n-    use option::Option;\n-    use option::Option::None;\n-    use option;\n-    use os::TMPBUF_SZ;\n-    use slice::SliceExt;\n-    use string::String;\n-    use str::StrPrelude;\n-    use vec::Vec;\n-\n-    pub fn fill_utf16_buf_and_decode<F>(mut f: F) -> Option<String> where\n-        F: FnMut(*mut u16, DWORD) -> DWORD,\n-    {\n-\n-        unsafe {\n-            let mut n = TMPBUF_SZ as DWORD;\n-            let mut res = None;\n-            let mut done = false;\n-            while !done {\n-                let mut buf = Vec::from_elem(n as uint, 0u16);\n-                let k = f(buf.as_mut_ptr(), n);\n-                if k == (0 as DWORD) {\n-                    done = true;\n-                } else if k == n &&\n-                          libc::GetLastError() ==\n-                          libc::ERROR_INSUFFICIENT_BUFFER as DWORD {\n-                    n *= 2 as DWORD;\n-                } else if k >= n {\n-                    n = k;\n-                } else {\n-                    done = true;\n-                }\n-                if k != 0 && done {\n-                    let sub = buf.slice(0, k as uint);\n-                    // We want to explicitly catch the case when the\n-                    // closure returned invalid UTF-16, rather than\n-                    // set `res` to None and continue.\n-                    let s = String::from_utf16(sub)\n-                        .expect(\"fill_utf16_buf_and_decode: closure created invalid UTF-16\");\n-                    res = option::Option::Some(s)\n-                }\n-            }\n-            return res;\n-        }\n-    }\n+    sys::os::getcwd()\n }\n \n /*\n@@ -253,71 +144,6 @@ pub fn env() -> Vec<(String,String)> {\n /// environment variables of the current process.\n pub fn env_as_bytes() -> Vec<(Vec<u8>,Vec<u8>)> {\n     unsafe {\n-        #[cfg(windows)]\n-        unsafe fn get_env_pairs() -> Vec<Vec<u8>> {\n-            use slice;\n-\n-            use libc::funcs::extra::kernel32::{\n-                GetEnvironmentStringsW,\n-                FreeEnvironmentStringsW\n-            };\n-            let ch = GetEnvironmentStringsW();\n-            if ch as uint == 0 {\n-                panic!(\"os::env() failure getting env string from OS: {}\",\n-                       os::last_os_error());\n-            }\n-            // Here, we lossily decode the string as UTF16.\n-            //\n-            // The docs suggest that the result should be in Unicode, but\n-            // Windows doesn't guarantee it's actually UTF16 -- it doesn't\n-            // validate the environment string passed to CreateProcess nor\n-            // SetEnvironmentVariable.  Yet, it's unlikely that returning a\n-            // raw u16 buffer would be of practical use since the result would\n-            // be inherently platform-dependent and introduce additional\n-            // complexity to this code.\n-            //\n-            // Using the non-Unicode version of GetEnvironmentStrings is even\n-            // worse since the result is in an OEM code page.  Characters that\n-            // can't be encoded in the code page would be turned into question\n-            // marks.\n-            let mut result = Vec::new();\n-            let mut i = 0;\n-            while *ch.offset(i) != 0 {\n-                let p = &*ch.offset(i);\n-                let mut len = 0;\n-                while *(p as *const _).offset(len) != 0 {\n-                    len += 1;\n-                }\n-                let p = p as *const u16;\n-                let s = slice::from_raw_buf(&p, len as uint);\n-                result.push(String::from_utf16_lossy(s).into_bytes());\n-                i += len as int + 1;\n-            }\n-            FreeEnvironmentStringsW(ch);\n-            result\n-        }\n-        #[cfg(unix)]\n-        unsafe fn get_env_pairs() -> Vec<Vec<u8>> {\n-            use c_str::CString;\n-\n-            extern {\n-                fn rust_env_pairs() -> *const *const c_char;\n-            }\n-            let mut environ = rust_env_pairs();\n-            if environ as uint == 0 {\n-                panic!(\"os::env() failure getting env string from OS: {}\",\n-                       os::last_os_error());\n-            }\n-            let mut result = Vec::new();\n-            while *environ != 0 as *const _ {\n-                let env_pair =\n-                    CString::new(*environ, false).as_bytes_no_nul().to_vec();\n-                result.push(env_pair);\n-                environ = environ.offset(1);\n-            }\n-            result\n-        }\n-\n         fn env_convert(input: Vec<Vec<u8>>) -> Vec<(Vec<u8>, Vec<u8>)> {\n             let mut pairs = Vec::new();\n             for p in input.iter() {\n@@ -330,7 +156,7 @@ pub fn env_as_bytes() -> Vec<(Vec<u8>,Vec<u8>)> {\n             pairs\n         }\n         with_env_lock(|| {\n-            let unparsed_environ = get_env_pairs();\n+            let unparsed_environ = sys::os::get_env_pairs();\n             env_convert(unparsed_environ)\n         })\n     }\n@@ -390,7 +216,7 @@ pub fn getenv_as_bytes(n: &str) -> Option<Vec<u8>> {\n pub fn getenv(n: &str) -> Option<String> {\n     unsafe {\n         with_env_lock(|| {\n-            use os::windoze::{fill_utf16_buf_and_decode};\n+            use sys::os::fill_utf16_buf_and_decode;\n             let mut n: Vec<u16> = n.utf16_units().collect();\n             n.push(0);\n             fill_utf16_buf_and_decode(|buf, sz| {\n@@ -506,52 +332,7 @@ pub fn unsetenv(n: &str) {\n /// }\n /// ```\n pub fn split_paths<T: BytesContainer>(unparsed: T) -> Vec<Path> {\n-    #[cfg(unix)]\n-    fn _split_paths<T: BytesContainer>(unparsed: T) -> Vec<Path> {\n-        unparsed.container_as_bytes()\n-                .split(|b| *b == b':')\n-                .map(Path::new)\n-                .collect()\n-    }\n-\n-    #[cfg(windows)]\n-    fn _split_paths<T: BytesContainer>(unparsed: T) -> Vec<Path> {\n-        // On Windows, the PATH environment variable is semicolon separated.  Double\n-        // quotes are used as a way of introducing literal semicolons (since\n-        // c:\\some;dir is a valid Windows path). Double quotes are not themselves\n-        // permitted in path names, so there is no way to escape a double quote.\n-        // Quoted regions can appear in arbitrary locations, so\n-        //\n-        //   c:\\foo;c:\\som\"e;di\"r;c:\\bar\n-        //\n-        // Should parse as [c:\\foo, c:\\some;dir, c:\\bar].\n-        //\n-        // (The above is based on testing; there is no clear reference available\n-        // for the grammar.)\n-\n-        let mut parsed = Vec::new();\n-        let mut in_progress = Vec::new();\n-        let mut in_quote = false;\n-\n-        for b in unparsed.container_as_bytes().iter() {\n-            match *b {\n-                b';' if !in_quote => {\n-                    parsed.push(Path::new(in_progress.as_slice()));\n-                    in_progress.truncate(0)\n-                }\n-                b'\"' => {\n-                    in_quote = !in_quote;\n-                }\n-                _  => {\n-                    in_progress.push(*b);\n-                }\n-            }\n-        }\n-        parsed.push(Path::new(in_progress));\n-        parsed\n-    }\n-\n-    _split_paths(unparsed)\n+    sys::os::split_paths(unparsed.container_as_bytes())\n }\n \n /// Joins a collection of `Path`s appropriately for the `PATH`\n@@ -576,42 +357,7 @@ pub fn split_paths<T: BytesContainer>(unparsed: T) -> Vec<Path> {\n /// os::setenv(key, os::join_paths(paths.as_slice()).unwrap());\n /// ```\n pub fn join_paths<T: BytesContainer>(paths: &[T]) -> Result<Vec<u8>, &'static str> {\n-    #[cfg(windows)]\n-    fn _join_paths<T: BytesContainer>(paths: &[T]) -> Result<Vec<u8>, &'static str> {\n-        let mut joined = Vec::new();\n-        let sep = b';';\n-\n-        for (i, path) in paths.iter().map(|p| p.container_as_bytes()).enumerate() {\n-            if i > 0 { joined.push(sep) }\n-            if path.contains(&b'\"') {\n-                return Err(\"path segment contains `\\\"`\");\n-            } else if path.contains(&sep) {\n-                joined.push(b'\"');\n-                joined.push_all(path);\n-                joined.push(b'\"');\n-            } else {\n-                joined.push_all(path);\n-            }\n-        }\n-\n-        Ok(joined)\n-    }\n-\n-    #[cfg(unix)]\n-    fn _join_paths<T: BytesContainer>(paths: &[T]) -> Result<Vec<u8>, &'static str> {\n-        let mut joined = Vec::new();\n-        let sep = b':';\n-\n-        for (i, path) in paths.iter().map(|p| p.container_as_bytes()).enumerate() {\n-            if i > 0 { joined.push(sep) }\n-            if path.contains(&sep) { return Err(\"path segment contains separator `:`\") }\n-            joined.push_all(path);\n-        }\n-\n-        Ok(joined)\n-    }\n-\n-    _join_paths(paths)\n+    sys::os::join_paths(paths)\n }\n \n /// A low-level OS in-memory pipe.\n@@ -664,69 +410,7 @@ pub fn dll_filename(base: &str) -> String {\n /// };\n /// ```\n pub fn self_exe_name() -> Option<Path> {\n-\n-    #[cfg(any(target_os = \"freebsd\", target_os = \"dragonfly\"))]\n-    fn load_self() -> Option<Vec<u8>> {\n-        unsafe {\n-            use libc::funcs::bsd44::*;\n-            use libc::consts::os::extra::*;\n-            let mut mib = vec![CTL_KERN as c_int,\n-                               KERN_PROC as c_int,\n-                               KERN_PROC_PATHNAME as c_int,\n-                               -1 as c_int];\n-            let mut sz: libc::size_t = 0;\n-            let err = sysctl(mib.as_mut_ptr(), mib.len() as ::libc::c_uint,\n-                             ptr::null_mut(), &mut sz, ptr::null_mut(),\n-                             0u as libc::size_t);\n-            if err != 0 { return None; }\n-            if sz == 0 { return None; }\n-            let mut v: Vec<u8> = Vec::with_capacity(sz as uint);\n-            let err = sysctl(mib.as_mut_ptr(), mib.len() as ::libc::c_uint,\n-                             v.as_mut_ptr() as *mut c_void, &mut sz,\n-                             ptr::null_mut(), 0u as libc::size_t);\n-            if err != 0 { return None; }\n-            if sz == 0 { return None; }\n-            v.set_len(sz as uint - 1); // chop off trailing NUL\n-            Some(v)\n-        }\n-    }\n-\n-    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-    fn load_self() -> Option<Vec<u8>> {\n-        use std::io;\n-\n-        match io::fs::readlink(&Path::new(\"/proc/self/exe\")) {\n-            Ok(path) => Some(path.into_vec()),\n-            Err(..) => None\n-        }\n-    }\n-\n-    #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n-    fn load_self() -> Option<Vec<u8>> {\n-        unsafe {\n-            use libc::funcs::extra::_NSGetExecutablePath;\n-            let mut sz: u32 = 0;\n-            _NSGetExecutablePath(ptr::null_mut(), &mut sz);\n-            if sz == 0 { return None; }\n-            let mut v: Vec<u8> = Vec::with_capacity(sz as uint);\n-            let err = _NSGetExecutablePath(v.as_mut_ptr() as *mut i8, &mut sz);\n-            if err != 0 { return None; }\n-            v.set_len(sz as uint - 1); // chop off trailing NUL\n-            Some(v)\n-        }\n-    }\n-\n-    #[cfg(windows)]\n-    fn load_self() -> Option<Vec<u8>> {\n-        unsafe {\n-            use os::windoze::fill_utf16_buf_and_decode;\n-            fill_utf16_buf_and_decode(|buf, sz| {\n-                libc::GetModuleFileNameW(0u as libc::DWORD, buf, sz)\n-            }).map(|s| s.into_string().into_bytes())\n-        }\n-    }\n-\n-    load_self().and_then(Path::new_opt)\n+    sys::os::load_self().and_then(Path::new_opt)\n }\n \n /// Optionally returns the filesystem path to the current executable which is\n@@ -842,7 +526,6 @@ pub fn tmpdir() -> Path {\n     }\n }\n \n-///\n /// Convert a relative path to an absolute path\n ///\n /// If the given path is relative, return it prepended with the current working\n@@ -887,37 +570,12 @@ pub fn make_absolute(p: &Path) -> IoResult<Path> {\n /// println!(\"Successfully changed working directory to {}!\", root.display());\n /// ```\n pub fn change_dir(p: &Path) -> IoResult<()> {\n-    return chdir(p);\n-\n-    #[cfg(windows)]\n-    fn chdir(p: &Path) -> IoResult<()> {\n-        let mut p = p.as_str().unwrap().utf16_units().collect::<Vec<u16>>();\n-        p.push(0);\n-\n-        unsafe {\n-            match libc::SetCurrentDirectoryW(p.as_ptr()) != (0 as libc::BOOL) {\n-                true => Ok(()),\n-                false => Err(IoError::last_error()),\n-            }\n-        }\n-    }\n-\n-    #[cfg(unix)]\n-    fn chdir(p: &Path) -> IoResult<()> {\n-        p.with_c_str(|buf| {\n-            unsafe {\n-                match libc::chdir(buf) == (0 as c_int) {\n-                    true => Ok(()),\n-                    false => Err(IoError::last_error()),\n-                }\n-            }\n-        })\n-    }\n+    return sys::os::chdir(p);\n }\n \n /// Returns the platform-specific value of errno\n pub fn errno() -> uint {\n-    os_imp::errno() as uint\n+    sys::os::errno() as uint\n }\n \n /// Return the string corresponding to an `errno()` value of `errnum`.\n@@ -930,7 +588,7 @@ pub fn errno() -> uint {\n /// println!(\"{}\", os::error_string(os::errno() as uint));\n /// ```\n pub fn error_string(errnum: uint) -> String {\n-    return os_imp::error_string(errnum as i32);\n+    return sys::os::error_string(errnum as i32);\n }\n \n /// Get a string representing the platform-dependent last error\n@@ -1042,12 +700,8 @@ fn real_args_as_bytes() -> Vec<Vec<u8>> {\n           target_os = \"freebsd\",\n           target_os = \"dragonfly\"))]\n fn real_args_as_bytes() -> Vec<Vec<u8>> {\n-    use rustrt;\n-\n-    match rustrt::args::clone() {\n-        Some(args) => args,\n-        None => panic!(\"process arguments not initialized\")\n-    }\n+    use rt;\n+    rt::args::clone().unwrap_or_else(|| vec![])\n }\n \n #[cfg(not(windows))]\n@@ -1144,38 +798,9 @@ extern {\n     pub fn _NSGetArgv() -> *mut *mut *mut c_char;\n }\n \n-// Round up `from` to be divisible by `to`\n-fn round_up(from: uint, to: uint) -> uint {\n-    let r = if from % to == 0 {\n-        from\n-    } else {\n-        from + to - (from % to)\n-    };\n-    if r == 0 {\n-        to\n-    } else {\n-        r\n-    }\n-}\n-\n-/// Returns the page size of the current architecture in bytes.\n-#[cfg(unix)]\n-pub fn page_size() -> uint {\n-    unsafe {\n-        libc::sysconf(libc::_SC_PAGESIZE) as uint\n-    }\n-}\n-\n /// Returns the page size of the current architecture in bytes.\n-#[cfg(windows)]\n pub fn page_size() -> uint {\n-    use mem;\n-    unsafe {\n-        let mut info = mem::zeroed();\n-        libc::GetSystemInfo(&mut info);\n-\n-        return info.dwPageSize as uint;\n-    }\n+    sys::os::page_size()\n }\n \n /// A memory mapped file or chunk of memory. This is a very system-specific\n@@ -1325,6 +950,20 @@ impl FromError<MapError> for Box<Error> {\n     }\n }\n \n+// Round up `from` to be divisible by `to`\n+fn round_up(from: uint, to: uint) -> uint {\n+    let r = if from % to == 0 {\n+        from\n+    } else {\n+        from + to - (from % to)\n+    };\n+    if r == 0 {\n+        to\n+    } else {\n+        r\n+    }\n+}\n+\n #[cfg(unix)]\n impl MemoryMap {\n     /// Create a new mapping with the given `options`, at least `min_len` bytes"}, {"sha": "62f64159c047a0865b9e031abe2c3490044ba9b9", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -514,20 +514,20 @@ mod tests {\n \n     #[test]\n     fn test_null_byte() {\n-        use task;\n-        let result = task::try(move|| {\n+        use thread::Thread;\n+        let result = Thread::spawn(move|| {\n             Path::new(b\"foo/bar\\0\")\n-        });\n+        }).join();\n         assert!(result.is_err());\n \n-        let result = task::try(move|| {\n+        let result = Thread::spawn(move|| {\n             Path::new(\"test\").set_filename(b\"f\\0o\")\n-        });\n+        }).join();\n         assert!(result.is_err());\n \n-        let result = task::try(move|| {\n+        let result = Thread::spawn(move|| {\n             Path::new(\"test\").push(b\"f\\0o\");\n-        });\n+        }).join();\n         assert!(result.is_err());\n     }\n "}, {"sha": "5cbefb0d3d8e0016a887fc964686685ce85d6ece", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -1298,20 +1298,20 @@ mod tests {\n \n     #[test]\n     fn test_null_byte() {\n-        use task;\n-        let result = task::try(move|| {\n+        use thread::Thread;\n+        let result = Thread::spawn(move|| {\n             Path::new(b\"foo/bar\\0\")\n-        });\n+        }).join();\n         assert!(result.is_err());\n \n-        let result = task::try(move|| {\n+        let result = Thread::spawn(move|| {\n             Path::new(\"test\").set_filename(b\"f\\0o\")\n-        });\n+        }).join();\n         assert!(result.is_err());\n \n-        let result = task::try(move|| {\n+        let result = Thread::spawn(move || {\n             Path::new(\"test\").push(b\"f\\0o\");\n-        });\n+        }).join();\n         assert!(result.is_err());\n     }\n "}, {"sha": "dbe5f9193298a7de0c4d3ad88c27bd7a1df492d0", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -340,7 +340,7 @@ mod test {\n \n     use super::OsRng;\n     use rand::Rng;\n-    use task;\n+    use thread::Thread;\n \n     #[test]\n     fn test_os_rng() {\n@@ -360,25 +360,26 @@ mod test {\n         for _ in range(0u, 20) {\n             let (tx, rx) = channel();\n             txs.push(tx);\n-            task::spawn(move|| {\n+\n+            Thread::spawn(move|| {\n                 // wait until all the tasks are ready to go.\n                 rx.recv();\n \n                 // deschedule to attempt to interleave things as much\n                 // as possible (XXX: is this a good test?)\n                 let mut r = OsRng::new().unwrap();\n-                task::deschedule();\n+                Thread::yield_now();\n                 let mut v = [0u8, .. 1000];\n \n                 for _ in range(0u, 100) {\n                     r.next_u32();\n-                    task::deschedule();\n+                    Thread::yield_now();\n                     r.next_u64();\n-                    task::deschedule();\n+                    Thread::yield_now();\n                     r.fill_bytes(&mut v);\n-                    task::deschedule();\n+                    Thread::yield_now();\n                 }\n-            })\n+            }).detach();\n         }\n \n         // start all the tasks"}, {"sha": "3a4705f58b49c9455c8f82eada4770ebfdfcfe9a", "filename": "src/libstd/rt/args.rs", "status": "renamed", "additions": 19, "deletions": 23, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -20,7 +20,7 @@\n //! FIXME #7756: Would be nice for this to not exist.\n \n use core::prelude::*;\n-use collections::vec::Vec;\n+use vec::Vec;\n \n /// One-time global initialization.\n pub unsafe fn init(argc: int, argv: *const *const u8) { imp::init(argc, argv) }\n@@ -46,53 +46,49 @@ pub fn clone() -> Option<Vec<Vec<u8>>> { imp::clone() }\n mod imp {\n     use core::prelude::*;\n \n-    use alloc::boxed::Box;\n-    use collections::vec::Vec;\n-    use collections::string::String;\n-    use core::mem;\n+    use boxed::Box;\n+    use vec::Vec;\n+    use string::String;\n+    use mem;\n \n-    use mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n+    use sync::{StaticMutex, MUTEX_INIT};\n \n     static mut GLOBAL_ARGS_PTR: uint = 0;\n-    static LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n+    static LOCK: StaticMutex = MUTEX_INIT;\n \n     pub unsafe fn init(argc: int, argv: *const *const u8) {\n         let args = load_argc_and_argv(argc, argv);\n         put(args);\n     }\n \n     pub unsafe fn cleanup() {\n-        rtassert!(take().is_some());\n+        take();\n         LOCK.destroy();\n     }\n \n     pub fn take() -> Option<Vec<Vec<u8>>> {\n-        with_lock(|| unsafe {\n+        let _guard = LOCK.lock();\n+        unsafe {\n             let ptr = get_global_ptr();\n             let val = mem::replace(&mut *ptr, None);\n             val.as_ref().map(|s: &Box<Vec<Vec<u8>>>| (**s).clone())\n-        })\n+        }\n     }\n \n     pub fn put(args: Vec<Vec<u8>>) {\n-        with_lock(|| unsafe {\n+        let _guard = LOCK.lock();\n+        unsafe {\n             let ptr = get_global_ptr();\n             rtassert!((*ptr).is_none());\n             (*ptr) = Some(box args.clone());\n-        })\n+        }\n     }\n \n     pub fn clone() -> Option<Vec<Vec<u8>>> {\n-        with_lock(|| unsafe {\n+        let _guard = LOCK.lock();\n+        unsafe {\n             let ptr = get_global_ptr();\n             (*ptr).as_ref().map(|s: &Box<Vec<Vec<u8>>>| (**s).clone())\n-        })\n-    }\n-\n-    fn with_lock<T, F>(f: F) -> T where F: FnOnce() -> T {\n-        unsafe {\n-            let _guard = LOCK.lock();\n-            f()\n         }\n     }\n \n@@ -108,8 +104,8 @@ mod imp {\n \n     #[cfg(test)]\n     mod tests {\n-        use std::prelude::*;\n-        use std::finally::Finally;\n+        use prelude::*;\n+        use finally::Finally;\n \n         use super::*;\n \n@@ -145,7 +141,7 @@ mod imp {\n           target_os = \"windows\"))]\n mod imp {\n     use core::prelude::*;\n-    use collections::vec::Vec;\n+    use vec::Vec;\n \n     pub unsafe fn init(_argc: int, _argv: *const *const u8) {\n     }", "previous_filename": "src/librustrt/args.rs"}, {"sha": "5823f8453d84a3ffc8f87d7f2efe137db6786932", "filename": "src/libstd/rt/at_exit_imp.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fat_exit_imp.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -0,0 +1,75 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Implementation of running at_exit routines\n+//!\n+//! Documentation can be found on the `rt::at_exit` function.\n+\n+use core::prelude::*;\n+\n+use boxed::Box;\n+use vec::Vec;\n+use mem;\n+use thunk::Thunk;\n+use sys_common::mutex::{Mutex, MUTEX_INIT};\n+\n+type Queue = Vec<Thunk>;\n+\n+// NB these are specifically not types from `std::sync` as they currently rely\n+// on poisoning and this module needs to operate at a lower level than requiring\n+// the thread infrastructure to be in place (useful on the borders of\n+// initialization/destruction).\n+static LOCK: Mutex = MUTEX_INIT;\n+static mut QUEUE: *mut Queue = 0 as *mut Queue;\n+\n+unsafe fn init() {\n+    if QUEUE.is_null() {\n+        let state: Box<Queue> = box Vec::new();\n+        QUEUE = mem::transmute(state);\n+    } else {\n+        // can't re-init after a cleanup\n+        rtassert!(QUEUE as uint != 1);\n+    }\n+\n+    // FIXME: switch this to use atexit as below. Currently this\n+    // segfaults (the queue's memory is mysteriously gone), so\n+    // instead the cleanup is tied to the `std::rt` entry point.\n+    //\n+    // ::libc::atexit(cleanup);\n+}\n+\n+pub fn cleanup() {\n+    unsafe {\n+        LOCK.lock();\n+        let queue = QUEUE;\n+        QUEUE = 1 as *mut _;\n+        LOCK.unlock();\n+\n+        // make sure we're not recursively cleaning up\n+        rtassert!(queue as uint != 1);\n+\n+        // If we never called init, not need to cleanup!\n+        if queue as uint != 0 {\n+            let queue: Box<Queue> = mem::transmute(queue);\n+            for to_run in queue.into_iter() {\n+                to_run.invoke(());\n+            }\n+        }\n+    }\n+}\n+\n+pub fn push(f: Thunk) {\n+    unsafe {\n+        LOCK.lock();\n+        init();\n+        (*QUEUE).push(f);\n+        LOCK.unlock();\n+    }\n+}"}, {"sha": "4a692bccf9eea61ab5170ff99f883403e4c3b33d", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 3, "deletions": 979, "changes": 982, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -12,16 +12,11 @@\n \n #![allow(non_camel_case_types)]\n \n-use io::{IoResult, Writer};\n-use iter::{Iterator, IteratorExt};\n use option::Option::{Some, None};\n use os;\n-use result::Result::{Ok, Err};\n-use str::{StrPrelude, from_str};\n use sync::atomic;\n-use unicode::char::UnicodeChar;\n \n-pub use self::imp::write;\n+pub use sys::backtrace::write;\n \n // For now logging is turned off by default, and this function checks to see\n // whether the magical environment variable is present to see if it's turned on.\n@@ -41,984 +36,13 @@ pub fn log_enabled() -> bool {\n     val == 2\n }\n \n-#[cfg(target_word_size = \"64\")] const HEX_WIDTH: uint = 18;\n-#[cfg(target_word_size = \"32\")] const HEX_WIDTH: uint = 10;\n-\n-// All rust symbols are in theory lists of \"::\"-separated identifiers. Some\n-// assemblers, however, can't handle these characters in symbol names. To get\n-// around this, we use C++-style mangling. The mangling method is:\n-//\n-// 1. Prefix the symbol with \"_ZN\"\n-// 2. For each element of the path, emit the length plus the element\n-// 3. End the path with \"E\"\n-//\n-// For example, \"_ZN4testE\" => \"test\" and \"_ZN3foo3bar\" => \"foo::bar\".\n-//\n-// We're the ones printing our backtraces, so we can't rely on anything else to\n-// demangle our symbols. It's *much* nicer to look at demangled symbols, so\n-// this function is implemented to give us nice pretty output.\n-//\n-// Note that this demangler isn't quite as fancy as it could be. We have lots\n-// of other information in our symbols like hashes, version, type information,\n-// etc. Additionally, this doesn't handle glue symbols at all.\n-fn demangle(writer: &mut Writer, s: &str) -> IoResult<()> {\n-    // First validate the symbol. If it doesn't look like anything we're\n-    // expecting, we just print it literally. Note that we must handle non-rust\n-    // symbols because we could have any function in the backtrace.\n-    let mut valid = true;\n-    let mut inner = s;\n-    if s.len() > 4 && s.starts_with(\"_ZN\") && s.ends_with(\"E\") {\n-        inner = s.slice(3, s.len() - 1);\n-    // On Windows, dbghelp strips leading underscores, so we accept \"ZN...E\" form too.\n-    } else if s.len() > 3 && s.starts_with(\"ZN\") && s.ends_with(\"E\") {\n-        inner = s.slice(2, s.len() - 1);\n-    } else {\n-        valid = false;\n-    }\n-\n-    if valid {\n-        let mut chars = inner.chars();\n-        while valid {\n-            let mut i = 0;\n-            for c in chars {\n-                if c.is_numeric() {\n-                    i = i * 10 + c as uint - '0' as uint;\n-                } else {\n-                    break\n-                }\n-            }\n-            if i == 0 {\n-                valid = chars.next().is_none();\n-                break\n-            } else if chars.by_ref().take(i - 1).count() != i - 1 {\n-                valid = false;\n-            }\n-        }\n-    }\n-\n-    // Alright, let's do this.\n-    if !valid {\n-        try!(writer.write_str(s));\n-    } else {\n-        let mut first = true;\n-        while inner.len() > 0 {\n-            if !first {\n-                try!(writer.write_str(\"::\"));\n-            } else {\n-                first = false;\n-            }\n-            let mut rest = inner;\n-            while rest.char_at(0).is_numeric() {\n-                rest = rest.slice_from(1);\n-            }\n-            let i: uint = from_str(inner.slice_to(inner.len() - rest.len())).unwrap();\n-            inner = rest.slice_from(i);\n-            rest = rest.slice_to(i);\n-            while rest.len() > 0 {\n-                if rest.starts_with(\"$\") {\n-                    macro_rules! demangle {\n-                        ($($pat:expr => $demangled:expr),*) => ({\n-                            $(if rest.starts_with($pat) {\n-                                try!(writer.write_str($demangled));\n-                                rest = rest.slice_from($pat.len());\n-                              } else)*\n-                            {\n-                                try!(writer.write_str(rest));\n-                                break;\n-                            }\n-\n-                        })\n-                    }\n-\n-                    // see src/librustc/back/link.rs for these mappings\n-                    demangle! (\n-                        \"$SP$\" => \"@\",\n-                        \"$UP$\" => \"Box\",\n-                        \"$RP$\" => \"*\",\n-                        \"$BP$\" => \"&\",\n-                        \"$LT$\" => \"<\",\n-                        \"$GT$\" => \">\",\n-                        \"$LP$\" => \"(\",\n-                        \"$RP$\" => \")\",\n-                        \"$C$\"  => \",\",\n-\n-                        // in theory we can demangle any Unicode code point, but\n-                        // for simplicity we just catch the common ones.\n-                        \"$x20\" => \" \",\n-                        \"$x27\" => \"'\",\n-                        \"$x5b\" => \"[\",\n-                        \"$x5d\" => \"]\"\n-                    )\n-                } else {\n-                    let idx = match rest.find('$') {\n-                        None => rest.len(),\n-                        Some(i) => i,\n-                    };\n-                    try!(writer.write_str(rest.slice_to(idx)));\n-                    rest = rest.slice_from(idx);\n-                }\n-            }\n-        }\n-    }\n-\n-    Ok(())\n-}\n-\n-/// Backtrace support built on libgcc with some extra OS-specific support\n-///\n-/// Some methods of getting a backtrace:\n-///\n-/// * The backtrace() functions on unix. It turns out this doesn't work very\n-///   well for green threads on OSX, and the address to symbol portion of it\n-///   suffers problems that are described below.\n-///\n-/// * Using libunwind. This is more difficult than it sounds because libunwind\n-///   isn't installed everywhere by default. It's also a bit of a hefty library,\n-///   so possibly not the best option. When testing, libunwind was excellent at\n-///   getting both accurate backtraces and accurate symbols across platforms.\n-///   This route was not chosen in favor of the next option, however.\n-///\n-/// * We're already using libgcc_s for exceptions in rust (triggering task\n-///   unwinding and running destructors on the stack), and it turns out that it\n-///   conveniently comes with a function that also gives us a backtrace. All of\n-///   these functions look like _Unwind_*, but it's not quite the full\n-///   repertoire of the libunwind API. Due to it already being in use, this was\n-///   the chosen route of getting a backtrace.\n-///\n-/// After choosing libgcc_s for backtraces, the sad part is that it will only\n-/// give us a stack trace of instruction pointers. Thankfully these instruction\n-/// pointers are accurate (they work for green and native threads), but it's\n-/// then up to us again to figure out how to translate these addresses to\n-/// symbols. As with before, we have a few options. Before, that, a little bit\n-/// of an interlude about symbols. This is my very limited knowledge about\n-/// symbol tables, and this information is likely slightly wrong, but the\n-/// general idea should be correct.\n-///\n-/// When talking about symbols, it's helpful to know a few things about where\n-/// symbols are located. Some symbols are located in the dynamic symbol table\n-/// of the executable which in theory means that they're available for dynamic\n-/// linking and lookup. Other symbols end up only in the local symbol table of\n-/// the file. This loosely corresponds to pub and priv functions in Rust.\n-///\n-/// Armed with this knowledge, we know that our solution for address to symbol\n-/// translation will need to consult both the local and dynamic symbol tables.\n-/// With that in mind, here's our options of translating an address to\n-/// a symbol.\n-///\n-/// * Use dladdr(). The original backtrace()-based idea actually uses dladdr()\n-///   behind the scenes to translate, and this is why backtrace() was not used.\n-///   Conveniently, this method works fantastically on OSX. It appears dladdr()\n-///   uses magic to consult the local symbol table, or we're putting everything\n-///   in the dynamic symbol table anyway. Regardless, for OSX, this is the\n-///   method used for translation. It's provided by the system and easy to do.o\n-///\n-///   Sadly, all other systems have a dladdr() implementation that does not\n-///   consult the local symbol table. This means that most functions are blank\n-///   because they don't have symbols. This means that we need another solution.\n-///\n-/// * Use unw_get_proc_name(). This is part of the libunwind api (not the\n-///   libgcc_s version of the libunwind api), but involves taking a dependency\n-///   to libunwind. We may pursue this route in the future if we bundle\n-///   libunwind, but libunwind was unwieldy enough that it was not chosen at\n-///   this time to provide this functionality.\n-///\n-/// * Shell out to a utility like `readelf`. Crazy though it may sound, it's a\n-///   semi-reasonable solution. The stdlib already knows how to spawn processes,\n-///   so in theory it could invoke readelf, parse the output, and consult the\n-///   local/dynamic symbol tables from there. This ended up not getting chosen\n-///   due to the craziness of the idea plus the advent of the next option.\n-///\n-/// * Use `libbacktrace`. It turns out that this is a small library bundled in\n-///   the gcc repository which provides backtrace and symbol translation\n-///   functionality. All we really need from it is the backtrace functionality,\n-///   and we only really need this on everything that's not OSX, so this is the\n-///   chosen route for now.\n-///\n-/// In summary, the current situation uses libgcc_s to get a trace of stack\n-/// pointers, and we use dladdr() or libbacktrace to translate these addresses\n-/// to symbols. This is a bit of a hokey implementation as-is, but it works for\n-/// all unix platforms we support right now, so it at least gets the job done.\n-#[cfg(unix)]\n-mod imp {\n-    use prelude::*;\n-\n-    use c_str::CString;\n-    use io::IoResult;\n-    use libc;\n-    use mem;\n-    use sync::{StaticMutex, MUTEX_INIT};\n-\n-    /// As always - iOS on arm uses SjLj exceptions and\n-    /// _Unwind_Backtrace is even not available there. Still,\n-    /// backtraces could be extracted using a backtrace function,\n-    /// which thanks god is public\n-    ///\n-    /// As mentioned in a huge comment block above, backtrace doesn't\n-    /// play well with green threads, so while it is extremely nice\n-    /// and simple to use it should be used only on iOS devices as the\n-    /// only viable option.\n-    #[cfg(all(target_os = \"ios\", target_arch = \"arm\"))]\n-    #[inline(never)]\n-    pub fn write(w: &mut Writer) -> IoResult<()> {\n-        use result;\n-\n-        extern {\n-            fn backtrace(buf: *mut *mut libc::c_void,\n-                         sz: libc::c_int) -> libc::c_int;\n-        }\n-\n-        // while it doesn't requires lock for work as everything is\n-        // local, it still displays much nicer backtraces when a\n-        // couple of tasks panic simultaneously\n-        static LOCK: StaticMutex = MUTEX_INIT;\n-        let _g = LOCK.lock();\n-\n-        try!(writeln!(w, \"stack backtrace:\"));\n-        // 100 lines should be enough\n-        const SIZE: uint = 100;\n-        let mut buf: [*mut libc::c_void, ..SIZE] = unsafe {mem::zeroed()};\n-        let cnt = unsafe { backtrace(buf.as_mut_ptr(), SIZE as libc::c_int) as uint};\n-\n-        // skipping the first one as it is write itself\n-        let iter = range(1, cnt).map(|i| {\n-            print(w, i as int, buf[i])\n-        });\n-        result::fold(iter, (), |_, _| ())\n-    }\n-\n-    #[cfg(not(all(target_os = \"ios\", target_arch = \"arm\")))]\n-    #[inline(never)] // if we know this is a function call, we can skip it when\n-                     // tracing\n-    pub fn write(w: &mut Writer) -> IoResult<()> {\n-        use io::IoError;\n-\n-        struct Context<'a> {\n-            idx: int,\n-            writer: &'a mut (Writer+'a),\n-            last_error: Option<IoError>,\n-        }\n-\n-        // When using libbacktrace, we use some necessary global state, so we\n-        // need to prevent more than one thread from entering this block. This\n-        // is semi-reasonable in terms of printing anyway, and we know that all\n-        // I/O done here is blocking I/O, not green I/O, so we don't have to\n-        // worry about this being a native vs green mutex.\n-        static LOCK: StaticMutex = MUTEX_INIT;\n-        let _g = LOCK.lock();\n-\n-        try!(writeln!(w, \"stack backtrace:\"));\n-\n-        let mut cx = Context { writer: w, last_error: None, idx: 0 };\n-        return match unsafe {\n-            uw::_Unwind_Backtrace(trace_fn,\n-                                  &mut cx as *mut Context as *mut libc::c_void)\n-        } {\n-            uw::_URC_NO_REASON => {\n-                match cx.last_error {\n-                    Some(err) => Err(err),\n-                    None => Ok(())\n-                }\n-            }\n-            _ => Ok(()),\n-        };\n-\n-        extern fn trace_fn(ctx: *mut uw::_Unwind_Context,\n-                           arg: *mut libc::c_void) -> uw::_Unwind_Reason_Code {\n-            let cx: &mut Context = unsafe { mem::transmute(arg) };\n-            let ip = unsafe { uw::_Unwind_GetIP(ctx) as *mut libc::c_void };\n-            // dladdr() on osx gets whiny when we use FindEnclosingFunction, and\n-            // it appears to work fine without it, so we only use\n-            // FindEnclosingFunction on non-osx platforms. In doing so, we get a\n-            // slightly more accurate stack trace in the process.\n-            //\n-            // This is often because panic involves the last instruction of a\n-            // function being \"call std::rt::begin_unwind\", with no ret\n-            // instructions after it. This means that the return instruction\n-            // pointer points *outside* of the calling function, and by\n-            // unwinding it we go back to the original function.\n-            let ip = if cfg!(target_os = \"macos\") || cfg!(target_os = \"ios\") {\n-                ip\n-            } else {\n-                unsafe { uw::_Unwind_FindEnclosingFunction(ip) }\n-            };\n-\n-            // Don't print out the first few frames (they're not user frames)\n-            cx.idx += 1;\n-            if cx.idx <= 0 { return uw::_URC_NO_REASON }\n-            // Don't print ginormous backtraces\n-            if cx.idx > 100 {\n-                match write!(cx.writer, \" ... <frames omitted>\\n\") {\n-                    Ok(()) => {}\n-                    Err(e) => { cx.last_error = Some(e); }\n-                }\n-                return uw::_URC_FAILURE\n-            }\n-\n-            // Once we hit an error, stop trying to print more frames\n-            if cx.last_error.is_some() { return uw::_URC_FAILURE }\n-\n-            match print(cx.writer, cx.idx, ip) {\n-                Ok(()) => {}\n-                Err(e) => { cx.last_error = Some(e); }\n-            }\n-\n-            // keep going\n-            return uw::_URC_NO_REASON\n-        }\n-    }\n-\n-    #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n-    fn print(w: &mut Writer, idx: int, addr: *mut libc::c_void) -> IoResult<()> {\n-        use intrinsics;\n-        #[repr(C)]\n-        struct Dl_info {\n-            dli_fname: *const libc::c_char,\n-            dli_fbase: *mut libc::c_void,\n-            dli_sname: *const libc::c_char,\n-            dli_saddr: *mut libc::c_void,\n-        }\n-        extern {\n-            fn dladdr(addr: *const libc::c_void,\n-                      info: *mut Dl_info) -> libc::c_int;\n-        }\n-\n-        let mut info: Dl_info = unsafe { intrinsics::init() };\n-        if unsafe { dladdr(addr as *const libc::c_void, &mut info) == 0 } {\n-            output(w, idx,addr, None)\n-        } else {\n-            output(w, idx, addr, Some(unsafe {\n-                CString::new(info.dli_sname, false)\n-            }))\n-        }\n-    }\n-\n-    #[cfg(not(any(target_os = \"macos\", target_os = \"ios\")))]\n-    fn print(w: &mut Writer, idx: int, addr: *mut libc::c_void) -> IoResult<()> {\n-        use os;\n-        use ptr;\n-\n-        ////////////////////////////////////////////////////////////////////////\n-        // libbacktrace.h API\n-        ////////////////////////////////////////////////////////////////////////\n-        type backtrace_syminfo_callback =\n-            extern \"C\" fn(data: *mut libc::c_void,\n-                          pc: libc::uintptr_t,\n-                          symname: *const libc::c_char,\n-                          symval: libc::uintptr_t,\n-                          symsize: libc::uintptr_t);\n-        type backtrace_error_callback =\n-            extern \"C\" fn(data: *mut libc::c_void,\n-                          msg: *const libc::c_char,\n-                          errnum: libc::c_int);\n-        enum backtrace_state {}\n-        #[link(name = \"backtrace\", kind = \"static\")]\n-        #[cfg(not(test))]\n-        extern {}\n-\n-        extern {\n-            fn backtrace_create_state(filename: *const libc::c_char,\n-                                      threaded: libc::c_int,\n-                                      error: backtrace_error_callback,\n-                                      data: *mut libc::c_void)\n-                                            -> *mut backtrace_state;\n-            fn backtrace_syminfo(state: *mut backtrace_state,\n-                                 addr: libc::uintptr_t,\n-                                 cb: backtrace_syminfo_callback,\n-                                 error: backtrace_error_callback,\n-                                 data: *mut libc::c_void) -> libc::c_int;\n-        }\n-\n-        ////////////////////////////////////////////////////////////////////////\n-        // helper callbacks\n-        ////////////////////////////////////////////////////////////////////////\n-\n-        extern fn error_cb(_data: *mut libc::c_void, _msg: *const libc::c_char,\n-                           _errnum: libc::c_int) {\n-            // do nothing for now\n-        }\n-        extern fn syminfo_cb(data: *mut libc::c_void,\n-                             _pc: libc::uintptr_t,\n-                             symname: *const libc::c_char,\n-                             _symval: libc::uintptr_t,\n-                             _symsize: libc::uintptr_t) {\n-            let slot = data as *mut *const libc::c_char;\n-            unsafe { *slot = symname; }\n-        }\n-\n-        // The libbacktrace API supports creating a state, but it does not\n-        // support destroying a state. I personally take this to mean that a\n-        // state is meant to be created and then live forever.\n-        //\n-        // I would love to register an at_exit() handler which cleans up this\n-        // state, but libbacktrace provides no way to do so.\n-        //\n-        // With these constraints, this function has a statically cached state\n-        // that is calculated the first time this is requested. Remember that\n-        // backtracing all happens serially (one global lock).\n-        //\n-        // An additionally oddity in this function is that we initialize the\n-        // filename via self_exe_name() to pass to libbacktrace. It turns out\n-        // that on Linux libbacktrace seamlessly gets the filename of the\n-        // current executable, but this fails on freebsd. by always providing\n-        // it, we make sure that libbacktrace never has a reason to not look up\n-        // the symbols. The libbacktrace API also states that the filename must\n-        // be in \"permanent memory\", so we copy it to a static and then use the\n-        // static as the pointer.\n-        //\n-        // FIXME: We also call self_exe_name() on DragonFly BSD. I haven't\n-        //        tested if this is required or not.\n-        unsafe fn init_state() -> *mut backtrace_state {\n-            static mut STATE: *mut backtrace_state = 0 as *mut backtrace_state;\n-            static mut LAST_FILENAME: [libc::c_char, ..256] = [0, ..256];\n-            if !STATE.is_null() { return STATE }\n-            let selfname = if cfg!(target_os = \"freebsd\") ||\n-                              cfg!(target_os = \"dragonfly\") {\n-                os::self_exe_name()\n-            } else {\n-                None\n-            };\n-            let filename = match selfname {\n-                Some(path) => {\n-                    let bytes = path.as_vec();\n-                    if bytes.len() < LAST_FILENAME.len() {\n-                        let i = bytes.iter();\n-                        for (slot, val) in LAST_FILENAME.iter_mut().zip(i) {\n-                            *slot = *val as libc::c_char;\n-                        }\n-                        LAST_FILENAME.as_ptr()\n-                    } else {\n-                        ptr::null()\n-                    }\n-                }\n-                None => ptr::null(),\n-            };\n-            STATE = backtrace_create_state(filename, 0, error_cb,\n-                                           ptr::null_mut());\n-            return STATE\n-        }\n-\n-        ////////////////////////////////////////////////////////////////////////\n-        // translation\n-        ////////////////////////////////////////////////////////////////////////\n-\n-        // backtrace errors are currently swept under the rug, only I/O\n-        // errors are reported\n-        let state = unsafe { init_state() };\n-        if state.is_null() {\n-            return output(w, idx, addr, None)\n-        }\n-        let mut data = 0 as *const libc::c_char;\n-        let data_addr = &mut data as *mut *const libc::c_char;\n-        let ret = unsafe {\n-            backtrace_syminfo(state, addr as libc::uintptr_t,\n-                              syminfo_cb, error_cb,\n-                              data_addr as *mut libc::c_void)\n-        };\n-        if ret == 0 || data.is_null() {\n-            output(w, idx, addr, None)\n-        } else {\n-            output(w, idx, addr, Some(unsafe { CString::new(data, false) }))\n-        }\n-    }\n-\n-    // Finally, after all that work above, we can emit a symbol.\n-    fn output(w: &mut Writer, idx: int, addr: *mut libc::c_void,\n-              s: Option<CString>) -> IoResult<()> {\n-        try!(write!(w, \"  {:2}: {:2$} - \", idx, addr, super::HEX_WIDTH));\n-        match s.as_ref().and_then(|c| c.as_str()) {\n-            Some(string) => try!(super::demangle(w, string)),\n-            None => try!(write!(w, \"<unknown>\")),\n-        }\n-        w.write(&['\\n' as u8])\n-    }\n-\n-    /// Unwind library interface used for backtraces\n-    ///\n-    /// Note that the native libraries come from librustrt, not this\n-    /// module.\n-    /// Note that dead code is allowed as here are just bindings\n-    /// iOS doesn't use all of them it but adding more\n-    /// platform-specific configs pollutes the code too much\n-    #[allow(non_camel_case_types)]\n-    #[allow(non_snake_case)]\n-    #[allow(dead_code)]\n-    mod uw {\n-        pub use self::_Unwind_Reason_Code::*;\n-\n-        use libc;\n-\n-        #[repr(C)]\n-        pub enum _Unwind_Reason_Code {\n-            _URC_NO_REASON = 0,\n-            _URC_FOREIGN_EXCEPTION_CAUGHT = 1,\n-            _URC_FATAL_PHASE2_ERROR = 2,\n-            _URC_FATAL_PHASE1_ERROR = 3,\n-            _URC_NORMAL_STOP = 4,\n-            _URC_END_OF_STACK = 5,\n-            _URC_HANDLER_FOUND = 6,\n-            _URC_INSTALL_CONTEXT = 7,\n-            _URC_CONTINUE_UNWIND = 8,\n-            _URC_FAILURE = 9, // used only by ARM EABI\n-        }\n-\n-        pub enum _Unwind_Context {}\n-\n-        pub type _Unwind_Trace_Fn =\n-                extern fn(ctx: *mut _Unwind_Context,\n-                          arg: *mut libc::c_void) -> _Unwind_Reason_Code;\n-\n-        extern {\n-            // No native _Unwind_Backtrace on iOS\n-            #[cfg(not(all(target_os = \"ios\", target_arch = \"arm\")))]\n-            pub fn _Unwind_Backtrace(trace: _Unwind_Trace_Fn,\n-                                     trace_argument: *mut libc::c_void)\n-                        -> _Unwind_Reason_Code;\n-\n-            #[cfg(all(not(target_os = \"android\"),\n-                      not(all(target_os = \"linux\", target_arch = \"arm\"))))]\n-            pub fn _Unwind_GetIP(ctx: *mut _Unwind_Context) -> libc::uintptr_t;\n-\n-            #[cfg(all(not(target_os = \"android\"),\n-                      not(all(target_os = \"linux\", target_arch = \"arm\"))))]\n-            pub fn _Unwind_FindEnclosingFunction(pc: *mut libc::c_void)\n-                -> *mut libc::c_void;\n-        }\n-\n-        // On android, the function _Unwind_GetIP is a macro, and this is the\n-        // expansion of the macro. This is all copy/pasted directly from the\n-        // header file with the definition of _Unwind_GetIP.\n-        #[cfg(any(target_os = \"android\",\n-                  all(target_os = \"linux\", target_arch = \"arm\")))]\n-        pub unsafe fn _Unwind_GetIP(ctx: *mut _Unwind_Context) -> libc::uintptr_t {\n-            #[repr(C)]\n-            enum _Unwind_VRS_Result {\n-                _UVRSR_OK = 0,\n-                _UVRSR_NOT_IMPLEMENTED = 1,\n-                _UVRSR_FAILED = 2,\n-            }\n-            #[repr(C)]\n-            enum _Unwind_VRS_RegClass {\n-                _UVRSC_CORE = 0,\n-                _UVRSC_VFP = 1,\n-                _UVRSC_FPA = 2,\n-                _UVRSC_WMMXD = 3,\n-                _UVRSC_WMMXC = 4,\n-            }\n-            #[repr(C)]\n-            enum _Unwind_VRS_DataRepresentation {\n-                _UVRSD_UINT32 = 0,\n-                _UVRSD_VFPX = 1,\n-                _UVRSD_FPAX = 2,\n-                _UVRSD_UINT64 = 3,\n-                _UVRSD_FLOAT = 4,\n-                _UVRSD_DOUBLE = 5,\n-            }\n-\n-            type _Unwind_Word = libc::c_uint;\n-            extern {\n-                fn _Unwind_VRS_Get(ctx: *mut _Unwind_Context,\n-                                   klass: _Unwind_VRS_RegClass,\n-                                   word: _Unwind_Word,\n-                                   repr: _Unwind_VRS_DataRepresentation,\n-                                   data: *mut libc::c_void)\n-                    -> _Unwind_VRS_Result;\n-            }\n-\n-            let mut val: _Unwind_Word = 0;\n-            let ptr = &mut val as *mut _Unwind_Word;\n-            let _ = _Unwind_VRS_Get(ctx, _Unwind_VRS_RegClass::_UVRSC_CORE, 15,\n-                                    _Unwind_VRS_DataRepresentation::_UVRSD_UINT32,\n-                                    ptr as *mut libc::c_void);\n-            (val & !1) as libc::uintptr_t\n-        }\n-\n-        // This function also doesn't exist on Android or ARM/Linux, so make it\n-        // a no-op\n-        #[cfg(any(target_os = \"android\",\n-                  all(target_os = \"linux\", target_arch = \"arm\")))]\n-        pub unsafe fn _Unwind_FindEnclosingFunction(pc: *mut libc::c_void)\n-            -> *mut libc::c_void\n-        {\n-            pc\n-        }\n-    }\n-}\n-\n-/// As always, windows has something very different than unix, we mainly want\n-/// to avoid having to depend too much on libunwind for windows.\n-///\n-/// If you google around, you'll find a fair bit of references to built-in\n-/// functions to get backtraces on windows. It turns out that most of these are\n-/// in an external library called dbghelp. I was unable to find this library\n-/// via `-ldbghelp`, but it is apparently normal to do the `dlopen` equivalent\n-/// of it.\n-///\n-/// You'll also find that there's a function called CaptureStackBackTrace\n-/// mentioned frequently (which is also easy to use), but sadly I didn't have a\n-/// copy of that function in my mingw install (maybe it was broken?). Instead,\n-/// this takes the route of using StackWalk64 in order to walk the stack.\n-#[cfg(windows)]\n-#[allow(dead_code, non_snake_case)]\n-mod imp {\n-    use c_str::CString;\n-    use intrinsics;\n-    use io::{IoResult, Writer};\n-    use libc;\n-    use mem;\n-    use ops::Drop;\n-    use option::Option::{Some, None};\n-    use path::Path;\n-    use result::Result::{Ok, Err};\n-    use sync::{StaticMutex, MUTEX_INIT};\n-    use slice::SliceExt;\n-    use str::StrPrelude;\n-    use dynamic_lib::DynamicLibrary;\n-\n-    #[allow(non_snake_case)]\n-    extern \"system\" {\n-        fn GetCurrentProcess() -> libc::HANDLE;\n-        fn GetCurrentThread() -> libc::HANDLE;\n-        fn RtlCaptureContext(ctx: *mut arch::CONTEXT);\n-    }\n-\n-    type SymFromAddrFn =\n-        extern \"system\" fn(libc::HANDLE, u64, *mut u64,\n-                           *mut SYMBOL_INFO) -> libc::BOOL;\n-    type SymInitializeFn =\n-        extern \"system\" fn(libc::HANDLE, *mut libc::c_void,\n-                           libc::BOOL) -> libc::BOOL;\n-    type SymCleanupFn =\n-        extern \"system\" fn(libc::HANDLE) -> libc::BOOL;\n-\n-    type StackWalk64Fn =\n-        extern \"system\" fn(libc::DWORD, libc::HANDLE, libc::HANDLE,\n-                           *mut STACKFRAME64, *mut arch::CONTEXT,\n-                           *mut libc::c_void, *mut libc::c_void,\n-                           *mut libc::c_void, *mut libc::c_void) -> libc::BOOL;\n-\n-    const MAX_SYM_NAME: uint = 2000;\n-    const IMAGE_FILE_MACHINE_I386: libc::DWORD = 0x014c;\n-    const IMAGE_FILE_MACHINE_IA64: libc::DWORD = 0x0200;\n-    const IMAGE_FILE_MACHINE_AMD64: libc::DWORD = 0x8664;\n-\n-    #[repr(C)]\n-    struct SYMBOL_INFO {\n-        SizeOfStruct: libc::c_ulong,\n-        TypeIndex: libc::c_ulong,\n-        Reserved: [u64, ..2],\n-        Index: libc::c_ulong,\n-        Size: libc::c_ulong,\n-        ModBase: u64,\n-        Flags: libc::c_ulong,\n-        Value: u64,\n-        Address: u64,\n-        Register: libc::c_ulong,\n-        Scope: libc::c_ulong,\n-        Tag: libc::c_ulong,\n-        NameLen: libc::c_ulong,\n-        MaxNameLen: libc::c_ulong,\n-        // note that windows has this as 1, but it basically just means that\n-        // the name is inline at the end of the struct. For us, we just bump\n-        // the struct size up to MAX_SYM_NAME.\n-        Name: [libc::c_char, ..MAX_SYM_NAME],\n-    }\n-\n-\n-    #[repr(C)]\n-    enum ADDRESS_MODE {\n-        AddrMode1616,\n-        AddrMode1632,\n-        AddrModeReal,\n-        AddrModeFlat,\n-    }\n-\n-    struct ADDRESS64 {\n-        Offset: u64,\n-        Segment: u16,\n-        Mode: ADDRESS_MODE,\n-    }\n-\n-    struct STACKFRAME64 {\n-        AddrPC: ADDRESS64,\n-        AddrReturn: ADDRESS64,\n-        AddrFrame: ADDRESS64,\n-        AddrStack: ADDRESS64,\n-        AddrBStore: ADDRESS64,\n-        FuncTableEntry: *mut libc::c_void,\n-        Params: [u64, ..4],\n-        Far: libc::BOOL,\n-        Virtual: libc::BOOL,\n-        Reserved: [u64, ..3],\n-        KdHelp: KDHELP64,\n-    }\n-\n-    struct KDHELP64 {\n-        Thread: u64,\n-        ThCallbackStack: libc::DWORD,\n-        ThCallbackBStore: libc::DWORD,\n-        NextCallback: libc::DWORD,\n-        FramePointer: libc::DWORD,\n-        KiCallUserMode: u64,\n-        KeUserCallbackDispatcher: u64,\n-        SystemRangeStart: u64,\n-        KiUserExceptionDispatcher: u64,\n-        StackBase: u64,\n-        StackLimit: u64,\n-        Reserved: [u64, ..5],\n-    }\n-\n-    #[cfg(target_arch = \"x86\")]\n-    mod arch {\n-        use libc;\n-\n-        const MAXIMUM_SUPPORTED_EXTENSION: uint = 512;\n-\n-        #[repr(C)]\n-        pub struct CONTEXT {\n-            ContextFlags: libc::DWORD,\n-            Dr0: libc::DWORD,\n-            Dr1: libc::DWORD,\n-            Dr2: libc::DWORD,\n-            Dr3: libc::DWORD,\n-            Dr6: libc::DWORD,\n-            Dr7: libc::DWORD,\n-            FloatSave: FLOATING_SAVE_AREA,\n-            SegGs: libc::DWORD,\n-            SegFs: libc::DWORD,\n-            SegEs: libc::DWORD,\n-            SegDs: libc::DWORD,\n-            Edi: libc::DWORD,\n-            Esi: libc::DWORD,\n-            Ebx: libc::DWORD,\n-            Edx: libc::DWORD,\n-            Ecx: libc::DWORD,\n-            Eax: libc::DWORD,\n-            Ebp: libc::DWORD,\n-            Eip: libc::DWORD,\n-            SegCs: libc::DWORD,\n-            EFlags: libc::DWORD,\n-            Esp: libc::DWORD,\n-            SegSs: libc::DWORD,\n-            ExtendedRegisters: [u8, ..MAXIMUM_SUPPORTED_EXTENSION],\n-        }\n-\n-        #[repr(C)]\n-        pub struct FLOATING_SAVE_AREA {\n-            ControlWord: libc::DWORD,\n-            StatusWord: libc::DWORD,\n-            TagWord: libc::DWORD,\n-            ErrorOffset: libc::DWORD,\n-            ErrorSelector: libc::DWORD,\n-            DataOffset: libc::DWORD,\n-            DataSelector: libc::DWORD,\n-            RegisterArea: [u8, ..80],\n-            Cr0NpxState: libc::DWORD,\n-        }\n-\n-        pub fn init_frame(frame: &mut super::STACKFRAME64,\n-                          ctx: &CONTEXT) -> libc::DWORD {\n-            frame.AddrPC.Offset = ctx.Eip as u64;\n-            frame.AddrPC.Mode = super::ADDRESS_MODE::AddrModeFlat;\n-            frame.AddrStack.Offset = ctx.Esp as u64;\n-            frame.AddrStack.Mode = super::ADDRESS_MODE::AddrModeFlat;\n-            frame.AddrFrame.Offset = ctx.Ebp as u64;\n-            frame.AddrFrame.Mode = super::ADDRESS_MODE::AddrModeFlat;\n-            super::IMAGE_FILE_MACHINE_I386\n-        }\n-    }\n-\n-    #[cfg(target_arch = \"x86_64\")]\n-    mod arch {\n-        use libc::{c_longlong, c_ulonglong};\n-        use libc::types::os::arch::extra::{WORD, DWORD, DWORDLONG};\n-        use simd;\n-\n-        #[repr(C)]\n-        pub struct CONTEXT {\n-            _align_hack: [simd::u64x2, ..0], // FIXME align on 16-byte\n-            P1Home: DWORDLONG,\n-            P2Home: DWORDLONG,\n-            P3Home: DWORDLONG,\n-            P4Home: DWORDLONG,\n-            P5Home: DWORDLONG,\n-            P6Home: DWORDLONG,\n-\n-            ContextFlags: DWORD,\n-            MxCsr: DWORD,\n-\n-            SegCs: WORD,\n-            SegDs: WORD,\n-            SegEs: WORD,\n-            SegFs: WORD,\n-            SegGs: WORD,\n-            SegSs: WORD,\n-            EFlags: DWORD,\n-\n-            Dr0: DWORDLONG,\n-            Dr1: DWORDLONG,\n-            Dr2: DWORDLONG,\n-            Dr3: DWORDLONG,\n-            Dr6: DWORDLONG,\n-            Dr7: DWORDLONG,\n-\n-            Rax: DWORDLONG,\n-            Rcx: DWORDLONG,\n-            Rdx: DWORDLONG,\n-            Rbx: DWORDLONG,\n-            Rsp: DWORDLONG,\n-            Rbp: DWORDLONG,\n-            Rsi: DWORDLONG,\n-            Rdi: DWORDLONG,\n-            R8:  DWORDLONG,\n-            R9:  DWORDLONG,\n-            R10: DWORDLONG,\n-            R11: DWORDLONG,\n-            R12: DWORDLONG,\n-            R13: DWORDLONG,\n-            R14: DWORDLONG,\n-            R15: DWORDLONG,\n-\n-            Rip: DWORDLONG,\n-\n-            FltSave: FLOATING_SAVE_AREA,\n-\n-            VectorRegister: [M128A, .. 26],\n-            VectorControl: DWORDLONG,\n-\n-            DebugControl: DWORDLONG,\n-            LastBranchToRip: DWORDLONG,\n-            LastBranchFromRip: DWORDLONG,\n-            LastExceptionToRip: DWORDLONG,\n-            LastExceptionFromRip: DWORDLONG,\n-        }\n-\n-        #[repr(C)]\n-        pub struct M128A {\n-            _align_hack: [simd::u64x2, ..0], // FIXME align on 16-byte\n-            Low:  c_ulonglong,\n-            High: c_longlong\n-        }\n-\n-        #[repr(C)]\n-        pub struct FLOATING_SAVE_AREA {\n-            _align_hack: [simd::u64x2, ..0], // FIXME align on 16-byte\n-            _Dummy: [u8, ..512] // FIXME: Fill this out\n-        }\n-\n-        pub fn init_frame(frame: &mut super::STACKFRAME64,\n-                          ctx: &CONTEXT) -> DWORD {\n-            frame.AddrPC.Offset = ctx.Rip as u64;\n-            frame.AddrPC.Mode = super::ADDRESS_MODE::AddrModeFlat;\n-            frame.AddrStack.Offset = ctx.Rsp as u64;\n-            frame.AddrStack.Mode = super::ADDRESS_MODE::AddrModeFlat;\n-            frame.AddrFrame.Offset = ctx.Rbp as u64;\n-            frame.AddrFrame.Mode = super::ADDRESS_MODE::AddrModeFlat;\n-            super::IMAGE_FILE_MACHINE_AMD64\n-        }\n-    }\n-\n-    #[repr(C)]\n-    struct Cleanup {\n-        handle: libc::HANDLE,\n-        SymCleanup: SymCleanupFn,\n-    }\n-\n-    impl Drop for Cleanup {\n-        fn drop(&mut self) { (self.SymCleanup)(self.handle); }\n-    }\n-\n-    pub fn write(w: &mut Writer) -> IoResult<()> {\n-        // According to windows documentation, all dbghelp functions are\n-        // single-threaded.\n-        static LOCK: StaticMutex = MUTEX_INIT;\n-        let _g = LOCK.lock();\n-\n-        // Open up dbghelp.dll, we don't link to it explicitly because it can't\n-        // always be found. Additionally, it's nice having fewer dependencies.\n-        let path = Path::new(\"dbghelp.dll\");\n-        let lib = match DynamicLibrary::open(Some(&path)) {\n-            Ok(lib) => lib,\n-            Err(..) => return Ok(()),\n-        };\n-\n-        macro_rules! sym { ($e:expr, $t:ident) => (unsafe {\n-            match lib.symbol($e) {\n-                Ok(f) => mem::transmute::<*mut u8, $t>(f),\n-                Err(..) => return Ok(())\n-            }\n-        }) }\n-\n-        // Fetch the symbols necessary from dbghelp.dll\n-        let SymFromAddr = sym!(\"SymFromAddr\", SymFromAddrFn);\n-        let SymInitialize = sym!(\"SymInitialize\", SymInitializeFn);\n-        let SymCleanup = sym!(\"SymCleanup\", SymCleanupFn);\n-        let StackWalk64 = sym!(\"StackWalk64\", StackWalk64Fn);\n-\n-        // Allocate necessary structures for doing the stack walk\n-        let process = unsafe { GetCurrentProcess() };\n-        let thread = unsafe { GetCurrentThread() };\n-        let mut context: arch::CONTEXT = unsafe { intrinsics::init() };\n-        unsafe { RtlCaptureContext(&mut context); }\n-        let mut frame: STACKFRAME64 = unsafe { intrinsics::init() };\n-        let image = arch::init_frame(&mut frame, &context);\n-\n-        // Initialize this process's symbols\n-        let ret = SymInitialize(process, 0 as *mut libc::c_void, libc::TRUE);\n-        if ret != libc::TRUE { return Ok(()) }\n-        let _c = Cleanup { handle: process, SymCleanup: SymCleanup };\n-\n-        // And now that we're done with all the setup, do the stack walking!\n-        let mut i = 0i;\n-        try!(write!(w, \"stack backtrace:\\n\"));\n-        while StackWalk64(image, process, thread, &mut frame, &mut context,\n-                          0 as *mut libc::c_void,\n-                          0 as *mut libc::c_void,\n-                          0 as *mut libc::c_void,\n-                          0 as *mut libc::c_void) == libc::TRUE{\n-            let addr = frame.AddrPC.Offset;\n-            if addr == frame.AddrReturn.Offset || addr == 0 ||\n-               frame.AddrReturn.Offset == 0 { break }\n-\n-            i += 1;\n-            try!(write!(w, \"  {:2}: {:#2$x}\", i, addr, super::HEX_WIDTH));\n-            let mut info: SYMBOL_INFO = unsafe { intrinsics::init() };\n-            info.MaxNameLen = MAX_SYM_NAME as libc::c_ulong;\n-            // the struct size in C.  the value is different to\n-            // `size_of::<SYMBOL_INFO>() - MAX_SYM_NAME + 1` (== 81)\n-            // due to struct alignment.\n-            info.SizeOfStruct = 88;\n-\n-            let mut displacement = 0u64;\n-            let ret = SymFromAddr(process, addr as u64, &mut displacement,\n-                                  &mut info);\n-\n-            if ret == libc::TRUE {\n-                try!(write!(w, \" - \"));\n-                let cstr = unsafe { CString::new(info.Name.as_ptr(), false) };\n-                let bytes = cstr.as_bytes();\n-                match cstr.as_str() {\n-                    Some(s) => try!(super::demangle(w, s)),\n-                    None => try!(w.write(bytes[..bytes.len()-1])),\n-                }\n-                if displacement != 0 {\n-                    try!(write!(w, \"+{:#x}\", displacement));\n-                }\n-            }\n-            try!(w.write(&['\\n' as u8]));\n-        }\n-\n-        Ok(())\n-    }\n-}\n-\n #[cfg(test)]\n mod test {\n     use prelude::*;\n-    use io::MemWriter;\n-\n+    use sys_common;\n     macro_rules! t { ($a:expr, $b:expr) => ({\n         let mut m = Vec::new();\n-        super::demangle(&mut m, $a).unwrap();\n+        sys_common::backtrace::demangle(&mut m, $a).unwrap();\n         assert_eq!(String::from_utf8(m).unwrap(), $b);\n     }) }\n "}, {"sha": "1d3082d1b4cc4d3465d675a56a56e89350b7dedd", "filename": "src/libstd/rt/exclusive.rs", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Frt%2Fexclusive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Frt%2Fexclusive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fexclusive.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -10,8 +10,8 @@\n \n use core::prelude::*;\n \n-use core::cell::UnsafeCell;\n-use mutex;\n+use cell::UnsafeCell;\n+use rt::mutex;\n \n /// An OS mutex over some data.\n ///\n@@ -79,10 +79,10 @@ impl<'a, T: Send> DerefMut<T> for ExclusiveGuard<'a, T> {\n \n #[cfg(test)]\n mod tests {\n-    use std::prelude::*;\n-    use alloc::arc::Arc;\n+    use prelude::*;\n+    use sync::Arc;\n     use super::Exclusive;\n-    use std::task;\n+    use task;\n \n     #[test]\n     fn exclusive_new_arc() {", "previous_filename": "src/librustrt/exclusive.rs"}, {"sha": "2feea7fa0a4382df63156ec8a48880fd160c86dc", "filename": "src/libstd/rt/libunwind.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Frt%2Flibunwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Frt%2Flibunwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flibunwind.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "previous_filename": "src/librustrt/libunwind.rs"}, {"sha": "bee8b5b82f48e18a29b1d678dca1268ea4e11519", "filename": "src/libstd/rt/macros.rs", "status": "renamed", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Frt%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Frt%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmacros.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -17,7 +17,7 @@\n \n macro_rules! rterrln {\n     ($fmt:expr $($arg:tt)*) => ( {\n-        format_args!(::util::dumb_print, concat!($fmt, \"\\n\") $($arg)*)\n+        format_args!(::rt::util::dumb_print, concat!($fmt, \"\\n\") $($arg)*)\n     } )\n }\n \n@@ -32,15 +32,14 @@ macro_rules! rtdebug {\n \n macro_rules! rtassert {\n     ( $arg:expr ) => ( {\n-        if ::util::ENFORCE_SANITY {\n+        if ::rt::util::ENFORCE_SANITY {\n             if !$arg {\n                 rtabort!(\" assertion failed: {}\", stringify!($arg));\n             }\n         }\n     } )\n }\n \n-\n macro_rules! rtabort {\n-    ($($arg:tt)*) => (format_args!(::util::abort, $($arg)*))\n+    ($($arg:tt)*) => (format_args!(::rt::util::abort, $($arg)*))\n }", "previous_filename": "src/librustrt/macros.rs"}, {"sha": "8d9c1268e7e33dc51f09ceea84aa520b046ce37b", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 103, "deletions": 101, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -8,38 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Runtime services, including the task scheduler and I/O dispatcher\n+//! Runtime services\n //!\n-//! The `rt` module provides the private runtime infrastructure necessary to support core language\n-//! features like the exchange and local heap, logging, local data and unwinding. It also\n-//! implements the default task scheduler and task model. Initialization routines are provided for\n-//! setting up runtime resources in common configurations, including that used by `rustc` when\n-//! generating executables.\n-//!\n-//! It is intended that the features provided by `rt` can be factored in a way such that the core\n-//! library can be built with different 'profiles' for different use cases, e.g. excluding the task\n-//! scheduler. A number of runtime features though are critical to the functioning of the language\n-//! and an implementation must be provided regardless of the execution environment.\n-//!\n-//! Of foremost importance is the global exchange heap, in the module `heap`. Very little practical\n-//! Rust code can be written without access to the global heap. Unlike most of `rt` the global heap\n-//! is truly a global resource and generally operates independently of the rest of the runtime.\n-//!\n-//! All other runtime features are task-local, including the local heap, local storage, logging and\n-//! the stack unwinder.\n-//!\n-//! The relationship between `rt` and the rest of the core library is not entirely clear yet and\n-//! some modules will be moving into or out of `rt` as development proceeds.\n-//!\n-//! Several modules in `core` are clients of `rt`:\n-//!\n-//! * `std::task` - The user-facing interface to the Rust task model.\n-//! * `std::local_data` - The interface to local data.\n-//! * `std::unstable::lang` - Miscellaneous lang items, some of which rely on `std::rt`.\n-//! * `std::cleanup` - Local heap destruction.\n-//! * `std::io` - In the future `std::io` will use an `rt` implementation.\n-//! * `std::logging`\n-//! * `std::comm`\n+//! The `rt` module provides a narrow set of runtime services,\n+//! including the global heap (exported in `heap`) and unwinding and\n+//! backtrace support. The APIs in this module are highly unstable,\n+//! and should be considered as private implementation details for the\n+//! time being.\n \n #![experimental]\n \n@@ -48,65 +23,51 @@\n \n #![allow(dead_code)]\n \n-use borrow::IntoCow;\n-use failure;\n-use rustrt;\n use os;\n use thunk::Thunk;\n+use kinds::Send;\n+use thread::Thread;\n+use ops::FnOnce;\n+use sys;\n+use sys_common;\n+use sys_common::thread_info::{mod, NewThread};\n \n // Reexport some of our utilities which are expected by other crates.\n pub use self::util::{default_sched_threads, min_stack, running_on_valgrind};\n+pub use self::unwind::{begin_unwind, begin_unwind_fmt};\n \n-// Reexport functionality from librustrt and other crates underneath the\n-// standard library which work together to create the entire runtime.\n+// Reexport some functionality from liballoc.\n pub use alloc::heap;\n-pub use rustrt::{begin_unwind, begin_unwind_fmt, at_exit};\n \n // Simple backtrace functionality (to print on panic)\n pub mod backtrace;\n \n-// Just stuff\n-mod util;\n+// Internals\n+mod macros;\n \n-/// One-time runtime initialization.\n-///\n-/// Initializes global state, including frobbing\n-/// the crate's logging flags, registering GC\n-/// metadata, and storing the process arguments.\n-#[allow(experimental)]\n-pub fn init(argc: int, argv: *const *const u8) {\n-    rustrt::init(argc, argv);\n-    unsafe { rustrt::unwind::register(failure::on_fail); }\n-}\n+// These should be refactored/moved/made private over time\n+pub mod util;\n+pub mod unwind;\n+pub mod args;\n+\n+mod at_exit_imp;\n+mod libunwind;\n+\n+/// The default error code of the rust runtime if the main task panics instead\n+/// of exiting cleanly.\n+pub const DEFAULT_ERROR_CODE: int = 101;\n \n #[cfg(any(windows, android))]\n-static OS_DEFAULT_STACK_ESTIMATE: uint = 1 << 20;\n+const OS_DEFAULT_STACK_ESTIMATE: uint = 1 << 20;\n #[cfg(all(unix, not(android)))]\n-static OS_DEFAULT_STACK_ESTIMATE: uint = 2 * (1 << 20);\n+const OS_DEFAULT_STACK_ESTIMATE: uint = 2 * (1 << 20);\n \n #[cfg(not(test))]\n #[lang = \"start\"]\n fn lang_start(main: *const u8, argc: int, argv: *const *const u8) -> int {\n     use mem;\n-    start(argc, argv, Thunk::new(move|| {\n-        let main: extern \"Rust\" fn() = unsafe { mem::transmute(main) };\n-        main();\n-    }))\n-}\n-\n-/// Executes the given procedure after initializing the runtime with the given\n-/// argc/argv.\n-///\n-/// This procedure is guaranteed to run on the thread calling this function, but\n-/// the stack bounds for this rust task will *not* be set. Care must be taken\n-/// for this function to not overflow its stack.\n-///\n-/// This function will only return once *all* native threads in the system have\n-/// exited.\n-pub fn start(argc: int, argv: *const *const u8, main: Thunk) -> int {\n     use prelude::*;\n     use rt;\n-    use rustrt::task::Task;\n \n     let something_around_the_top_of_the_stack = 1;\n     let addr = &something_around_the_top_of_the_stack as *const int;\n@@ -117,40 +78,76 @@ pub fn start(argc: int, argv: *const *const u8, main: Thunk) -> int {\n     // frames above our current position.\n     let my_stack_bottom = my_stack_top + 20000 - OS_DEFAULT_STACK_ESTIMATE;\n \n-    // When using libgreen, one of the first things that we do is to turn off\n-    // the SIGPIPE signal (set it to ignore). By default, some platforms will\n-    // send a *signal* when a EPIPE error would otherwise be delivered. This\n-    // runtime doesn't install a SIGPIPE handler, causing it to kill the\n-    // program, which isn't exactly what we want!\n-    //\n-    // Hence, we set SIGPIPE to ignore when the program starts up in order to\n-    // prevent this problem.\n-    #[cfg(windows)] fn ignore_sigpipe() {}\n-    #[cfg(unix)] fn ignore_sigpipe() {\n-        use libc;\n-        use libc::funcs::posix01::signal::signal;\n-        unsafe {\n-            assert!(signal(libc::SIGPIPE, libc::SIG_IGN) != -1);\n+    let failed = unsafe {\n+        // First, make sure we don't trigger any __morestack overflow checks,\n+        // and next set up our stack to have a guard page and run through our\n+        // own fault handlers if we hit it.\n+        sys_common::stack::record_os_managed_stack_bounds(my_stack_bottom,\n+                                                          my_stack_top);\n+        sys::thread::guard::init();\n+        sys::stack_overflow::init();\n+\n+        // Next, set up the current Thread with the guard information we just\n+        // created. Note that this isn't necessary in general for new threads,\n+        // but we just do this to name the main thread and to give it correct\n+        // info about the stack bounds.\n+        let thread: Thread = NewThread::new(Some(\"<main>\".into_string()));\n+        thread_info::set((my_stack_bottom, my_stack_top),\n+                         sys::thread::guard::main(),\n+                         thread);\n+\n+        // By default, some platforms will send a *signal* when a EPIPE error\n+        // would otherwise be delivered. This runtime doesn't install a SIGPIPE\n+        // handler, causing it to kill the program, which isn't exactly what we\n+        // want!\n+        //\n+        // Hence, we set SIGPIPE to ignore when the program starts up in order\n+        // to prevent this problem.\n+        #[cfg(windows)] fn ignore_sigpipe() {}\n+        #[cfg(unix)] fn ignore_sigpipe() {\n+            use libc;\n+            use libc::funcs::posix01::signal::signal;\n+            unsafe {\n+                assert!(signal(libc::SIGPIPE, libc::SIG_IGN) != -1);\n+            }\n         }\n+        ignore_sigpipe();\n+\n+        // Store our args if necessary in a squirreled away location\n+        args::init(argc, argv);\n+\n+        // And finally, let's run some code!\n+        let res = unwind::try(|| {\n+            let main: fn() = mem::transmute(main);\n+            main();\n+        });\n+        cleanup();\n+        res.is_err()\n+    };\n+\n+    // If the exit code wasn't set, then the try block must have panicked.\n+    if failed {\n+        rt::DEFAULT_ERROR_CODE\n+    } else {\n+        os::get_exit_status()\n     }\n-    ignore_sigpipe();\n-\n-    init(argc, argv);\n-    let mut exit_code = None;\n-    let mut main = Some(main);\n-    let mut task = box Task::new(Some((my_stack_bottom, my_stack_top)),\n-                                 Some(rustrt::thread::main_guard_page()));\n-    task.name = Some(\"<main>\".into_cow());\n-    drop(task.run(|| {\n-        unsafe {\n-            rustrt::stack::record_os_managed_stack_bounds(my_stack_bottom, my_stack_top);\n-        }\n-        (main.take().unwrap()).invoke(());\n-        exit_code = Some(os::get_exit_status());\n-    }).destroy());\n-    unsafe { rt::cleanup(); }\n-    // If the exit code wasn't set, then the task block must have panicked.\n-    return exit_code.unwrap_or(rustrt::DEFAULT_ERROR_CODE);\n+}\n+\n+/// Enqueues a procedure to run when the runtime is cleaned up\n+///\n+/// The procedure passed to this function will be executed as part of the\n+/// runtime cleanup phase. For normal rust programs, this means that it will run\n+/// after all other tasks have exited.\n+///\n+/// The procedure is *not* executed with a local `Task` available to it, so\n+/// primitives like logging, I/O, channels, spawning, etc, are *not* available.\n+/// This is meant for \"bare bones\" usage to clean up runtime details, this is\n+/// not meant as a general-purpose \"let's clean everything up\" function.\n+///\n+/// It is forbidden for procedures to register more `at_exit` handlers when they\n+/// are running, and doing so will lead to a process abort.\n+pub fn at_exit<F:FnOnce()+Send>(f: F) {\n+    at_exit_imp::push(Thunk::new(f));\n }\n \n /// One-time runtime cleanup.\n@@ -163,5 +160,10 @@ pub fn start(argc: int, argv: *const *const u8, main: Thunk) -> int {\n /// Invoking cleanup while portions of the runtime are still in use may cause\n /// undefined behavior.\n pub unsafe fn cleanup() {\n-    rustrt::cleanup();\n+    args::cleanup();\n+    sys::stack_overflow::cleanup();\n+    // FIXME: (#20012): the resources being cleaned up by at_exit\n+    // currently are not prepared for cleanup to happen asynchronously\n+    // with detached threads using the resources; for now, we leak.\n+    // at_exit_imp::cleanup();\n }"}, {"sha": "98940a2b381c7b40600920d4ab9391be0e30e9d9", "filename": "src/libstd/rt/task.rs", "status": "renamed", "additions": 23, "deletions": 30, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -15,27 +15,27 @@\n pub use self::BlockedTask::*;\n use self::TaskState::*;\n \n-use alloc::arc::Arc;\n-use alloc::boxed::Box;\n-use core::any::Any;\n-use core::atomic::{AtomicUint, SeqCst};\n-use core::iter::{IteratorExt, Take};\n-use core::ops::FnOnce;\n-use core::mem;\n-use core::ops::FnMut;\n+use any::Any;\n+use boxed::Box;\n+use sync::Arc;\n+use sync::atomic::{AtomicUint, SeqCst};\n+use iter::{IteratorExt, Take};\n+use kinds::marker;\n+use mem;\n+use ops::FnMut;\n use core::prelude::{Clone, Drop, Err, Iterator, None, Ok, Option, Send, Some};\n use core::prelude::{drop};\n-\n-use bookkeeping;\n-use mutex::NativeMutex;\n-use local::Local;\n-use thread::{mod, Thread};\n-use stack;\n-use unwind;\n-use unwind::Unwinder;\n-use collections::str::SendStr;\n+use str::SendStr;\n use thunk::Thunk;\n \n+use rt;\n+use rt::mutex::NativeMutex;\n+use rt::local::Local;\n+use rt::thread::{mod, Thread};\n+use sys_common::stack;\n+use rt::unwind;\n+use rt::unwind::Unwinder;\n+\n /// State associated with Rust tasks.\n ///\n /// This structure is currently undergoing major changes, and is\n@@ -129,14 +129,7 @@ impl Task {\n         task.name = name;\n         task.death.on_exit = on_exit;\n \n-        // FIXME: change this back after moving rustrt into std\n-        // let stack = stack_size.unwrap_or(rt::min_stack());\n-        let stack = stack_size.unwrap_or(2 * 1024 * 1024);\n-\n-        // Note that this increment must happen *before* the spawn in order to\n-        // guarantee that if this task exits it will always end up waiting for\n-        // the spawned task to exit.\n-        let token = bookkeeping::increment();\n+        let stack = stack_size.unwrap_or(rt::min_stack());\n \n         // Spawning a new OS thread guarantees that __morestack will never get\n         // triggered, but we must manually set up the actual stack bounds once\n@@ -157,7 +150,6 @@ impl Task {\n \n             let mut f = Some(f);\n             drop(task.run(|| { f.take().unwrap().invoke(()) }).destroy());\n-            drop(token);\n         })\n     }\n \n@@ -504,8 +496,9 @@ impl Death {\n #[cfg(test)]\n mod test {\n     use super::*;\n-    use std::prelude::*;\n-    use std::task;\n+    use prelude::*;\n+    use task;\n+    use rt::unwind;\n \n     #[test]\n     fn unwind() {\n@@ -519,7 +512,7 @@ mod test {\n \n     #[test]\n     fn rng() {\n-        use std::rand::{StdRng, Rng};\n+        use rand::{StdRng, Rng};\n         let mut r = StdRng::new().ok().unwrap();\n         let _ = r.next_u32();\n     }\n@@ -541,7 +534,7 @@ mod test {\n     #[test]\n     #[should_fail]\n     fn test_begin_unwind() {\n-        use unwind::begin_unwind;\n+        use rt::unwind::begin_unwind;\n         begin_unwind(\"cause\", &(file!(), line!()))\n     }\n ", "previous_filename": "src/librustrt/task.rs"}, {"sha": "5d5440b887d8941004ca2bf4011de214d297624c", "filename": "src/libstd/rt/unwind.rs", "status": "renamed", "additions": 46, "deletions": 70, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -57,30 +57,20 @@\n //!\n //! Currently Rust uses unwind runtime provided by libgcc.\n \n-use core::prelude::*;\n-\n-use alloc::boxed::Box;\n-use collections::string::String;\n-use collections::str::StrAllocating;\n-use collections::vec::Vec;\n-use core::any::Any;\n-use core::atomic;\n-use core::cmp;\n-use core::fmt;\n-use core::intrinsics;\n-use core::mem;\n-use core::raw::Closure;\n+use prelude::*;\n+\n+use any::Any;\n+use cell::Cell;\n+use cmp;\n+use failure;\n+use fmt;\n+use intrinsics;\n use libc::c_void;\n+use mem;\n+use sync::atomic;\n+use sync::{Once, ONCE_INIT};\n \n-use local::Local;\n-use task::Task;\n-\n-use libunwind as uw;\n-\n-#[allow(missing_copy_implementations)]\n-pub struct Unwinder {\n-    unwinding: bool,\n-}\n+use rt::libunwind as uw;\n \n struct Exception {\n     uwe: uw::_Unwind_Exception,\n@@ -104,17 +94,7 @@ static CALLBACKS: [atomic::AtomicUint, ..MAX_CALLBACKS] =\n          atomic::INIT_ATOMIC_UINT, atomic::INIT_ATOMIC_UINT];\n static CALLBACK_CNT: atomic::AtomicUint = atomic::INIT_ATOMIC_UINT;\n \n-impl Unwinder {\n-    pub fn new() -> Unwinder {\n-        Unwinder {\n-            unwinding: false,\n-        }\n-    }\n-\n-    pub fn unwinding(&self) -> bool {\n-        self.unwinding\n-    }\n-}\n+thread_local! { static PANICKING: Cell<bool> = Cell::new(false) }\n \n /// Invoke a closure, capturing the cause of panic if one occurs.\n ///\n@@ -136,10 +116,13 @@ impl Unwinder {\n ///   guaranteed that a rust task is in place when invoking this function.\n ///   Unwinding twice can lead to resource leaks where some destructors are not\n ///   run.\n-pub unsafe fn try(f: ||) -> ::core::result::Result<(), Box<Any + Send>> {\n-    let closure: Closure = mem::transmute(f);\n-    let ep = rust_try(try_fn, closure.code as *mut c_void,\n-                      closure.env as *mut c_void);\n+pub unsafe fn try<F: FnOnce()>(f: F) -> Result<(), Box<Any + Send>> {\n+    let mut f = Some(f);\n+\n+    let prev = PANICKING.with(|s| s.get());\n+    PANICKING.with(|s| s.set(false));\n+    let ep = rust_try(try_fn::<F>, &mut f as *mut _ as *mut c_void);\n+    PANICKING.with(|s| s.set(prev));\n     return if ep.is_null() {\n         Ok(())\n     } else {\n@@ -150,14 +133,9 @@ pub unsafe fn try(f: ||) -> ::core::result::Result<(), Box<Any + Send>> {\n         Err(cause.unwrap())\n     };\n \n-    extern fn try_fn(code: *mut c_void, env: *mut c_void) {\n-        unsafe {\n-            let closure: || = mem::transmute(Closure {\n-                code: code as *mut (),\n-                env: env as *mut (),\n-            });\n-            closure();\n-        }\n+    extern fn try_fn<F: FnOnce()>(opt_closure: *mut c_void) {\n+        let opt_closure = opt_closure as *mut Option<F>;\n+        unsafe { (*opt_closure).take().unwrap()(); }\n     }\n \n     #[link(name = \"rustrt_native\", kind = \"static\")]\n@@ -169,12 +147,16 @@ pub unsafe fn try(f: ||) -> ::core::result::Result<(), Box<Any + Send>> {\n         // When f(...) returns normally, the return value is null.\n         // When f(...) throws, the return value is a pointer to the caught\n         // exception object.\n-        fn rust_try(f: extern \"C\" fn(*mut c_void, *mut c_void),\n-                    code: *mut c_void,\n+        fn rust_try(f: extern fn(*mut c_void),\n                     data: *mut c_void) -> *mut uw::_Unwind_Exception;\n     }\n }\n \n+/// Test if the current thread is currently panicking.\n+pub fn panicking() -> bool {\n+    PANICKING.with(|s| s.get())\n+}\n+\n // An uninlined, unmangled function upon which to slap yer breakpoints\n #[inline(never)]\n #[no_mangle]\n@@ -241,7 +223,7 @@ fn rust_exception_class() -> uw::_Unwind_Exception_Class {\n           not(test)))]\n #[doc(hidden)]\n pub mod eabi {\n-    use libunwind as uw;\n+    use rt::libunwind as uw;\n     use libc::c_int;\n \n     extern \"C\" {\n@@ -294,7 +276,7 @@ pub mod eabi {\n #[cfg(all(target_os = \"ios\", target_arch = \"arm\", not(test)))]\n #[doc(hidden)]\n pub mod eabi {\n-    use libunwind as uw;\n+    use rt::libunwind as uw;\n     use libc::c_int;\n \n     extern \"C\" {\n@@ -349,7 +331,7 @@ pub mod eabi {\n #[cfg(all(target_arch = \"arm\", not(target_os = \"ios\"), not(test)))]\n #[doc(hidden)]\n pub mod eabi {\n-    use libunwind as uw;\n+    use rt::libunwind as uw;\n     use libc::c_int;\n \n     extern \"C\" {\n@@ -400,9 +382,9 @@ pub mod eabi {\n #[allow(non_camel_case_types, non_snake_case)]\n pub mod eabi {\n     pub use self::EXCEPTION_DISPOSITION::*;\n-    use core::prelude::*;\n-    use libunwind as uw;\n+    use rt::libunwind as uw;\n     use libc::{c_void, c_int};\n+    use kinds::Copy;\n \n     #[repr(C)]\n     #[allow(missing_copy_implementations)]\n@@ -513,7 +495,7 @@ pub extern fn rust_begin_unwind(msg: &fmt::Arguments,\n /// the actual formatting into this shared place.\n #[inline(never)] #[cold]\n pub fn begin_unwind_fmt(msg: &fmt::Arguments, file_line: &(&'static str, uint)) -> ! {\n-    use core::fmt::FormatWriter;\n+    use fmt::FormatWriter;\n \n     // We do two allocations here, unfortunately. But (a) they're\n     // required with the current scheme, and (b) we don't handle\n@@ -557,10 +539,15 @@ pub fn begin_unwind<M: Any + Send>(msg: M, file_line: &(&'static str, uint)) ->\n /// we need the `Any` object anyway, we're not just creating it to\n /// avoid being generic.)\n ///\n-/// Do this split took the LLVM IR line counts of `fn main() { panic!()\n+/// Doing this split took the LLVM IR line counts of `fn main() { panic!()\n /// }` from ~1900/3700 (-O/no opts) to 180/590.\n #[inline(never)] #[cold] // this is the slow path, please never inline this\n fn begin_unwind_inner(msg: Box<Any + Send>, file_line: &(&'static str, uint)) -> ! {\n+    // Make sure the default failure handler is registered before we look at the\n+    // callbacks.\n+    static INIT: Once = ONCE_INIT;\n+    INIT.doit(|| unsafe { register(failure::on_fail); });\n+\n     // First, invoke call the user-defined callbacks triggered on task panic.\n     //\n     // By the time that we see a callback has been registered (by reading\n@@ -584,27 +571,16 @@ fn begin_unwind_inner(msg: Box<Any + Send>, file_line: &(&'static str, uint)) ->\n     };\n \n     // Now that we've run all the necessary unwind callbacks, we actually\n-    // perform the unwinding. If we don't have a task, then it's time to die\n-    // (hopefully someone printed something about this).\n-    let mut task: Box<Task> = match Local::try_take() {\n-        Some(task) => task,\n-        None => rust_panic(msg),\n-    };\n-\n-    if task.unwinder.unwinding {\n-        // If a task panics while it's already unwinding then we\n+    // perform the unwinding.\n+    if panicking() {\n+        // If a thread panics while it's already unwinding then we\n         // have limited options. Currently our preference is to\n         // just abort. In the future we may consider resuming\n         // unwinding or otherwise exiting the task cleanly.\n-        rterrln!(\"task failed during unwinding. aborting.\");\n+        rterrln!(\"thread panicked while panicking. aborting.\");\n         unsafe { intrinsics::abort() }\n     }\n-    task.unwinder.unwinding = true;\n-\n-    // Put the task back in TLS because the unwinding process may run code which\n-    // requires the task. We need a handle to its unwinder, however, so after\n-    // this we unsafely extract it and continue along.\n-    Local::put(task);\n+    PANICKING.with(|s| s.set(true));\n     rust_panic(msg);\n }\n ", "previous_filename": "src/librustrt/unwind.rs"}, {"sha": "fa527a70f83958ee8fb3533a1f1ace2c6a60a6bb", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 139, "deletions": 3, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -7,10 +7,18 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n+//\n+// ignore-lexer-test FIXME #15677\n+\n+use core::prelude::*;\n \n-use libc::uintptr_t;\n-use option::Option;\n-use option::Option::{Some, None};\n+use core::cmp;\n+use core::fmt;\n+use core::intrinsics;\n+use core::slice;\n+use core::str;\n+\n+use libc::{mod, uintptr_t};\n use os;\n use str::{FromStr, from_str, Str};\n use sync::atomic;\n@@ -73,3 +81,131 @@ pub fn default_sched_threads() -> uint {\n         }\n     }\n }\n+\n+// Indicates whether we should perform expensive sanity checks, including rtassert!\n+//\n+// FIXME: Once the runtime matures remove the `true` below to turn off rtassert,\n+//        etc.\n+pub const ENFORCE_SANITY: bool = true || !cfg!(rtopt) || cfg!(rtdebug) ||\n+                                  cfg!(rtassert);\n+\n+#[allow(missing_copy_implementations)]\n+pub struct Stdio(libc::c_int);\n+\n+#[allow(non_upper_case_globals)]\n+pub const Stdout: Stdio = Stdio(libc::STDOUT_FILENO);\n+#[allow(non_upper_case_globals)]\n+pub const Stderr: Stdio = Stdio(libc::STDERR_FILENO);\n+\n+impl fmt::FormatWriter for Stdio {\n+    fn write(&mut self, data: &[u8]) -> fmt::Result {\n+        #[cfg(unix)]\n+        type WriteLen = libc::size_t;\n+        #[cfg(windows)]\n+        type WriteLen = libc::c_uint;\n+        unsafe {\n+            let Stdio(fd) = *self;\n+            libc::write(fd,\n+                        data.as_ptr() as *const libc::c_void,\n+                        data.len() as WriteLen);\n+        }\n+        Ok(()) // yes, we're lying\n+    }\n+}\n+\n+pub fn dumb_print(args: &fmt::Arguments) {\n+    use fmt::FormatWriter;\n+    let mut w = Stderr;\n+    let _ = w.write_fmt(args);\n+}\n+\n+pub fn abort(args: &fmt::Arguments) -> ! {\n+    use fmt::FormatWriter;\n+\n+    struct BufWriter<'a> {\n+        buf: &'a mut [u8],\n+        pos: uint,\n+    }\n+    impl<'a> FormatWriter for BufWriter<'a> {\n+        fn write(&mut self, bytes: &[u8]) -> fmt::Result {\n+            let left = self.buf[mut self.pos..];\n+            let to_write = bytes[..cmp::min(bytes.len(), left.len())];\n+            slice::bytes::copy_memory(left, to_write);\n+            self.pos += to_write.len();\n+            Ok(())\n+        }\n+    }\n+\n+    // Convert the arguments into a stack-allocated string\n+    let mut msg = [0u8, ..512];\n+    let mut w = BufWriter { buf: &mut msg, pos: 0 };\n+    let _ = write!(&mut w, \"{}\", args);\n+    let msg = str::from_utf8(w.buf[mut ..w.pos]).unwrap_or(\"aborted\");\n+    let msg = if msg.is_empty() {\"aborted\"} else {msg};\n+\n+    // Give some context to the message\n+    let hash = msg.bytes().fold(0, |accum, val| accum + (val as uint) );\n+    let quote = match hash % 10 {\n+        0 => \"\n+It was from the artists and poets that the pertinent answers came, and I\n+know that panic would have broken loose had they been able to compare notes.\n+As it was, lacking their original letters, I half suspected the compiler of\n+having asked leading questions, or of having edited the correspondence in\n+corroboration of what he had latently resolved to see.\",\n+        1 => \"\n+There are not many persons who know what wonders are opened to them in the\n+stories and visions of their youth; for when as children we listen and dream,\n+we think but half-formed thoughts, and when as men we try to remember, we are\n+dulled and prosaic with the poison of life. But some of us awake in the night\n+with strange phantasms of enchanted hills and gardens, of fountains that sing\n+in the sun, of golden cliffs overhanging murmuring seas, of plains that stretch\n+down to sleeping cities of bronze and stone, and of shadowy companies of heroes\n+that ride caparisoned white horses along the edges of thick forests; and then\n+we know that we have looked back through the ivory gates into that world of\n+wonder which was ours before we were wise and unhappy.\",\n+        2 => \"\n+Instead of the poems I had hoped for, there came only a shuddering blackness\n+and ineffable loneliness; and I saw at last a fearful truth which no one had\n+ever dared to breathe before \u2014 the unwhisperable secret of secrets \u2014 The fact\n+that this city of stone and stridor is not a sentient perpetuation of Old New\n+York as London is of Old London and Paris of Old Paris, but that it is in fact\n+quite dead, its sprawling body imperfectly embalmed and infested with queer\n+animate things which have nothing to do with it as it was in life.\",\n+        3 => \"\n+The ocean ate the last of the land and poured into the smoking gulf, thereby\n+giving up all it had ever conquered. From the new-flooded lands it flowed\n+again, uncovering death and decay; and from its ancient and immemorial bed it\n+trickled loathsomely, uncovering nighted secrets of the years when Time was\n+young and the gods unborn. Above the waves rose weedy remembered spires. The\n+moon laid pale lilies of light on dead London, and Paris stood up from its damp\n+grave to be sanctified with star-dust. Then rose spires and monoliths that were\n+weedy but not remembered; terrible spires and monoliths of lands that men never\n+knew were lands...\",\n+        4 => \"\n+There was a night when winds from unknown spaces whirled us irresistibly into\n+limitless vacuum beyond all thought and entity. Perceptions of the most\n+maddeningly untransmissible sort thronged upon us; perceptions of infinity\n+which at the time convulsed us with joy, yet which are now partly lost to my\n+memory and partly incapable of presentation to others.\",\n+        _ => \"You've met with a terrible fate, haven't you?\"\n+    };\n+    rterrln!(\"{}\", \"\");\n+    rterrln!(\"{}\", quote);\n+    rterrln!(\"{}\", \"\");\n+    rterrln!(\"fatal runtime error: {}\", msg);\n+    unsafe { intrinsics::abort(); }\n+}\n+\n+pub unsafe fn report_overflow() {\n+    use thread::Thread;\n+\n+    // See the message below for why this is not emitted to the\n+    // ^ Where did the message below go?\n+    // task's logger. This has the additional conundrum of the\n+    // logger may not be initialized just yet, meaning that an FFI\n+    // call would happen to initialized it (calling out to libuv),\n+    // and the FFI call needs 2MB of stack when we just ran out.\n+\n+    rterrln!(\"\\nthread '{}' has overflowed its stack\",\n+             Thread::current().name().unwrap_or(\"<unknown>\"));\n+}"}, {"sha": "862808a9e3d90f4897cddd67f34a48c93c019b9f", "filename": "src/libstd/rtdeps.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Frtdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Frtdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frtdeps.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -22,7 +22,7 @@ extern {}\n // LLVM implements the `frem` instruction as a call to `fmod`, which lives in\n // libm. Hence, we must explicitly link to it.\n //\n-// On Linux, librt and libdl are indirect dependencies via rustrt,\n+// On Linux, librt and libdl are indirect dependencies via std,\n // and binutils 2.22+ won't add them automatically\n #[cfg(target_os = \"linux\")]\n #[link(name = \"dl\")]"}, {"sha": "26778ef70b3cad5782e617a498d87096fe6a1873", "filename": "src/libstd/sync/atomic.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fatomic.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -42,14 +42,15 @@\n //! ```\n //! use std::sync::Arc;\n //! use std::sync::atomic::{AtomicUint, SeqCst};\n+//! use std::thread::Thread;\n //!\n //! fn main() {\n //!     let spinlock = Arc::new(AtomicUint::new(1));\n //!\n //!     let spinlock_clone = spinlock.clone();\n-//!     spawn(move|| {\n+//!     Thread::spawn(move|| {\n //!         spinlock_clone.store(0, SeqCst);\n-//!     });\n+//!     }).detach();\n //!\n //!     // Wait for the other task to release the lock\n //!     while spinlock.load(SeqCst) != 0 {}\n@@ -61,21 +62,22 @@\n //! ```\n //! use std::sync::Arc;\n //! use std::sync::atomic::{AtomicOption, SeqCst};\n+//! use std::thread::Thread;\n //!\n //! fn main() {\n //!     struct BigObject;\n //!\n //!     let shared_big_object = Arc::new(AtomicOption::empty());\n //!\n //!     let shared_big_object_clone = shared_big_object.clone();\n-//!     spawn(move|| {\n+//!     Thread::spawn(move|| {\n //!         let unwrapped_big_object = shared_big_object_clone.take(SeqCst);\n //!         if unwrapped_big_object.is_some() {\n //!             println!(\"got a big object from another task\");\n //!         } else {\n //!             println!(\"other task hasn't sent big object yet\");\n //!         }\n-//!     });\n+//!     }).detach();\n //!\n //!     shared_big_object.swap(box BigObject, SeqCst);\n //! }"}, {"sha": "6573d9273ceffd9fb91e62f33abf4a314b1bf0d2", "filename": "src/libstd/sync/barrier.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsync%2Fbarrier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsync%2Fbarrier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fbarrier.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -15,17 +15,18 @@ use sync::{Mutex, Condvar};\n ///\n /// ```rust\n /// use std::sync::{Arc, Barrier};\n+/// use std::thread::Thread;\n ///\n /// let barrier = Arc::new(Barrier::new(10));\n /// for _ in range(0u, 10) {\n ///     let c = barrier.clone();\n ///     // The same messages will be printed together.\n ///     // You will NOT see any interleaving.\n-///     spawn(move|| {\n+///     Thread::spawn(move|| {\n ///         println!(\"before wait\");\n ///         c.wait();\n ///         println!(\"after wait\");\n-///     });\n+///     }).detach();\n /// }\n /// ```\n pub struct Barrier {"}, {"sha": "be27c06b83cd306953e9ac864a57fd72261df73b", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -36,17 +36,18 @@ use time::Duration;\n ///\n /// ```\n /// use std::sync::{Arc, Mutex, Condvar};\n+/// use std::thread::Thread;\n ///\n /// let pair = Arc::new((Mutex::new(false), Condvar::new()));\n /// let pair2 = pair.clone();\n ///\n /// // Inside of our lock, spawn a new thread, and then wait for it to start\n-/// spawn(move|| {\n+/// Thread::spawn(move|| {\n ///     let &(ref lock, ref cvar) = &*pair2;\n ///     let mut started = lock.lock();\n ///     *started = true;\n ///     cvar.notify_one();\n-/// });\n+/// }).detach();\n ///\n /// // wait for the thread to start up\n /// let &(ref lock, ref cvar) = &*pair;\n@@ -362,4 +363,3 @@ mod tests {\n \n     }\n }\n-"}, {"sha": "5e9d234c6423df1de25631c2e6ed9a9797f86203", "filename": "src/libstd/sync/future.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsync%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsync%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ffuture.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -29,8 +29,8 @@ use core::mem::replace;\n \n use self::FutureState::*;\n use comm::{Receiver, channel};\n-use task::spawn;\n use thunk::{Thunk};\n+use thread::Thread;\n \n /// A type encapsulating the result of a computation which may not be complete\n pub struct Future<A> {\n@@ -139,10 +139,10 @@ impl<A:Send> Future<A> {\n \n         let (tx, rx) = channel();\n \n-        spawn(move |:| {\n+        Thread::spawn(move |:| {\n             // Don't panic if the other end has hung up\n             let _ = tx.send_opt(blk());\n-        });\n+        }).detach();\n \n         Future::from_receiver(rx)\n     }"}, {"sha": "4829be569cc973901cd17db9093d69ef203ab3ef", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -35,6 +35,7 @@ use sys_common::mutex as sys;\n ///\n /// ```rust\n /// use std::sync::{Arc, Mutex};\n+/// use std::thread::Thread;\n /// const N: uint = 10;\n ///\n /// // Spawn a few threads to increment a shared variable (non-atomically), and\n@@ -47,7 +48,7 @@ use sys_common::mutex as sys;\n /// let (tx, rx) = channel();\n /// for _ in range(0u, 10) {\n ///     let (data, tx) = (data.clone(), tx.clone());\n-///     spawn(move|| {\n+///     Thread::spawn(move|| {\n ///         // The shared static can only be accessed once the lock is held.\n ///         // Our non-atomic increment is safe because we're the only thread\n ///         // which can access the shared state when the lock is held.\n@@ -57,7 +58,7 @@ use sys_common::mutex as sys;\n ///             tx.send(());\n ///         }\n ///         // the lock is unlocked here when `data` goes out of scope.\n-///     });\n+///     }).detach();\n /// }\n ///\n /// rx.recv();\n@@ -274,7 +275,7 @@ impl Drop for StaticMutexGuard {\n mod test {\n     use prelude::*;\n \n-    use task;\n+    use thread::Thread;\n     use sync::{Arc, Mutex, StaticMutex, MUTEX_INIT, Condvar};\n \n     #[test]\n@@ -386,10 +387,10 @@ mod test {\n     fn test_mutex_arc_poison() {\n         let arc = Arc::new(Mutex::new(1i));\n         let arc2 = arc.clone();\n-        let _ = task::try(move|| {\n+        let _ = Thread::spawn(move|| {\n             let lock = arc2.lock();\n             assert_eq!(*lock, 2);\n-        });\n+        }).join();\n         let lock = arc.lock();\n         assert_eq!(*lock, 1);\n     }\n@@ -414,7 +415,7 @@ mod test {\n     fn test_mutex_arc_access_in_unwind() {\n         let arc = Arc::new(Mutex::new(1i));\n         let arc2 = arc.clone();\n-        let _ = task::try(move|| -> () {\n+        let _ = Thread::spawn(move|| -> () {\n             struct Unwinder {\n                 i: Arc<Mutex<int>>,\n             }\n@@ -425,7 +426,7 @@ mod test {\n             }\n             let _u = Unwinder { i: arc2 };\n             panic!();\n-        });\n+        }).join();\n         let lock = arc.lock();\n         assert_eq!(*lock, 2);\n     }"}, {"sha": "a43f822e351db7c85299139080933b51f60423e2", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -121,7 +121,7 @@ impl Once {\n mod test {\n     use prelude::*;\n \n-    use task;\n+    use thread::Thread;\n     use super::{ONCE_INIT, Once};\n \n     #[test]\n@@ -143,7 +143,7 @@ mod test {\n         for _ in range(0u, 10) {\n             let tx = tx.clone();\n             spawn(move|| {\n-                for _ in range(0u, 4) { task::deschedule() }\n+                for _ in range(0u, 4) { Thread::yield_now() }\n                 unsafe {\n                     O.doit(|| {\n                         assert!(!run);"}, {"sha": "ad08e9873faad1ef0393bd3969c6de682e8b6306", "filename": "src/libstd/sync/poison.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsync%2Fpoison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsync%2Fpoison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fpoison.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -8,21 +8,19 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use option::Option::None;\n-use rustrt::task::Task;\n-use rustrt::local::Local;\n+use thread::Thread;\n \n pub struct Flag { pub failed: bool }\n \n impl Flag {\n     pub fn borrow(&mut self) -> Guard {\n-        Guard { flag: &mut self.failed, failing: failing() }\n+        Guard { flag: &mut self.failed, panicking: Thread::panicking() }\n     }\n }\n \n pub struct Guard<'a> {\n     flag: &'a mut bool,\n-    failing: bool,\n+    panicking: bool,\n }\n \n impl<'a> Guard<'a> {\n@@ -33,16 +31,8 @@ impl<'a> Guard<'a> {\n     }\n \n     pub fn done(&mut self) {\n-        if !self.failing && failing() {\n+        if !self.panicking && Thread::panicking() {\n             *self.flag = true;\n         }\n     }\n }\n-\n-fn failing() -> bool {\n-    if Local::exists(None::<Task>) {\n-        Local::borrow(None::<Task>).unwinder.unwinding()\n-    } else {\n-        false\n-    }\n-}"}, {"sha": "07b2f2cf541e5e1b763f33e10905af3fd82c39b5", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -356,7 +356,7 @@ mod tests {\n     use prelude::*;\n \n     use rand::{mod, Rng};\n-    use task;\n+    use thread::Thread;\n     use sync::{Arc, RWLock, StaticRWLock, RWLOCK_INIT};\n \n     #[test]\n@@ -409,10 +409,10 @@ mod tests {\n     fn test_rw_arc_poison_wr() {\n         let arc = Arc::new(RWLock::new(1i));\n         let arc2 = arc.clone();\n-        let _ = task::try(move|| {\n+        let _ = Thread::spawn(move|| {\n             let lock = arc2.write();\n             assert_eq!(*lock, 2);\n-        });\n+        }).join();\n         let lock = arc.read();\n         assert_eq!(*lock, 1);\n     }\n@@ -422,10 +422,10 @@ mod tests {\n     fn test_rw_arc_poison_ww() {\n         let arc = Arc::new(RWLock::new(1i));\n         let arc2 = arc.clone();\n-        let _ = task::try(move|| {\n+        let _ = Thread::spawn(move|| {\n             let lock = arc2.write();\n             assert_eq!(*lock, 2);\n-        });\n+        }).join();\n         let lock = arc.write();\n         assert_eq!(*lock, 1);\n     }\n@@ -434,21 +434,21 @@ mod tests {\n     fn test_rw_arc_no_poison_rr() {\n         let arc = Arc::new(RWLock::new(1i));\n         let arc2 = arc.clone();\n-        let _ = task::try(move|| {\n+        let _ = Thread::spawn(move|| {\n             let lock = arc2.read();\n             assert_eq!(*lock, 2);\n-        });\n+        }).join();\n         let lock = arc.read();\n         assert_eq!(*lock, 1);\n     }\n     #[test]\n     fn test_rw_arc_no_poison_rw() {\n         let arc = Arc::new(RWLock::new(1i));\n         let arc2 = arc.clone();\n-        let _ = task::try(move|| {\n+        let _ = Thread::spawn(move|| {\n             let lock = arc2.read();\n             assert_eq!(*lock, 2);\n-        });\n+        }).join();\n         let lock = arc.write();\n         assert_eq!(*lock, 1);\n     }\n@@ -459,30 +459,30 @@ mod tests {\n         let arc2 = arc.clone();\n         let (tx, rx) = channel();\n \n-        task::spawn(move|| {\n+        Thread::spawn(move|| {\n             let mut lock = arc2.write();\n             for _ in range(0u, 10) {\n                 let tmp = *lock;\n                 *lock = -1;\n-                task::deschedule();\n+                Thread::yield_now();\n                 *lock = tmp + 1;\n             }\n             tx.send(());\n-        });\n+        }).detach();\n \n         // Readers try to catch the writer in the act\n         let mut children = Vec::new();\n         for _ in range(0u, 5) {\n             let arc3 = arc.clone();\n-            children.push(task::try_future(move|| {\n+            children.push(Thread::spawn(move|| {\n                 let lock = arc3.read();\n                 assert!(*lock >= 0);\n             }));\n         }\n \n         // Wait for children to pass their asserts\n-        for r in children.iter_mut() {\n-            assert!(r.get_ref().is_ok());\n+        for r in children.into_iter() {\n+            assert!(r.join().is_ok());\n         }\n \n         // Wait for writer to finish\n@@ -495,7 +495,7 @@ mod tests {\n     fn test_rw_arc_access_in_unwind() {\n         let arc = Arc::new(RWLock::new(1i));\n         let arc2 = arc.clone();\n-        let _ = task::try(move|| -> () {\n+        let _ = Thread::spawn(move|| -> () {\n             struct Unwinder {\n                 i: Arc<RWLock<int>>,\n             }\n@@ -507,7 +507,7 @@ mod tests {\n             }\n             let _u = Unwinder { i: arc2 };\n             panic!();\n-        });\n+        }).join();\n         let lock = arc.read();\n         assert_eq!(*lock, 2);\n     }"}, {"sha": "793825f1b08f5c2b83807b8c7b90a371492f608b", "filename": "src/libstd/sync/task_pool.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsync%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsync%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ftask_pool.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -12,7 +12,7 @@\n \n use core::prelude::*;\n \n-use task::{spawn};\n+use thread::Thread;\n use comm::{channel, Sender, Receiver};\n use sync::{Arc, Mutex};\n use thunk::Thunk;\n@@ -105,7 +105,7 @@ impl TaskPool {\n }\n \n fn spawn_in_pool(jobs: Arc<Mutex<Receiver<Thunk>>>) {\n-    spawn(move |:| {\n+    Thread::spawn(move |:| {\n         // Will spawn a new task on panic unless it is cancelled.\n         let sentinel = Sentinel::new(&jobs);\n \n@@ -126,7 +126,7 @@ fn spawn_in_pool(jobs: Arc<Mutex<Receiver<Thunk>>>) {\n         }\n \n         sentinel.cancel();\n-    })\n+    }).detach();\n }\n \n #[cfg(test)]\n@@ -206,4 +206,3 @@ mod test {\n         waiter.wait();\n     }\n }\n-"}, {"sha": "a39c8d6d8fed8b722c9d870edf62bd23cbd1e602", "filename": "src/libstd/sys/common/backtrace.rs", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -0,0 +1,139 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use io::{IoResult, Writer};\n+use iter::{Iterator, IteratorExt};\n+use option::Option::{Some, None};\n+use result::Result::{Ok, Err};\n+use str::{StrPrelude, from_str};\n+use unicode::char::UnicodeChar;\n+\n+#[cfg(target_word_size = \"64\")] pub const HEX_WIDTH: uint = 18;\n+#[cfg(target_word_size = \"32\")] pub const HEX_WIDTH: uint = 10;\n+\n+// All rust symbols are in theory lists of \"::\"-separated identifiers. Some\n+// assemblers, however, can't handle these characters in symbol names. To get\n+// around this, we use C++-style mangling. The mangling method is:\n+//\n+// 1. Prefix the symbol with \"_ZN\"\n+// 2. For each element of the path, emit the length plus the element\n+// 3. End the path with \"E\"\n+//\n+// For example, \"_ZN4testE\" => \"test\" and \"_ZN3foo3bar\" => \"foo::bar\".\n+//\n+// We're the ones printing our backtraces, so we can't rely on anything else to\n+// demangle our symbols. It's *much* nicer to look at demangled symbols, so\n+// this function is implemented to give us nice pretty output.\n+//\n+// Note that this demangler isn't quite as fancy as it could be. We have lots\n+// of other information in our symbols like hashes, version, type information,\n+// etc. Additionally, this doesn't handle glue symbols at all.\n+pub fn demangle(writer: &mut Writer, s: &str) -> IoResult<()> {\n+    // First validate the symbol. If it doesn't look like anything we're\n+    // expecting, we just print it literally. Note that we must handle non-rust\n+    // symbols because we could have any function in the backtrace.\n+    let mut valid = true;\n+    let mut inner = s;\n+    if s.len() > 4 && s.starts_with(\"_ZN\") && s.ends_with(\"E\") {\n+        inner = s.slice(3, s.len() - 1);\n+    // On Windows, dbghelp strips leading underscores, so we accept \"ZN...E\" form too.\n+    } else if s.len() > 3 && s.starts_with(\"ZN\") && s.ends_with(\"E\") {\n+        inner = s.slice(2, s.len() - 1);\n+    } else {\n+        valid = false;\n+    }\n+\n+    if valid {\n+        let mut chars = inner.chars();\n+        while valid {\n+            let mut i = 0;\n+            for c in chars {\n+                if c.is_numeric() {\n+                    i = i * 10 + c as uint - '0' as uint;\n+                } else {\n+                    break\n+                }\n+            }\n+            if i == 0 {\n+                valid = chars.next().is_none();\n+                break\n+            } else if chars.by_ref().take(i - 1).count() != i - 1 {\n+                valid = false;\n+            }\n+        }\n+    }\n+\n+    // Alright, let's do this.\n+    if !valid {\n+        try!(writer.write_str(s));\n+    } else {\n+        let mut first = true;\n+        while inner.len() > 0 {\n+            if !first {\n+                try!(writer.write_str(\"::\"));\n+            } else {\n+                first = false;\n+            }\n+            let mut rest = inner;\n+            while rest.char_at(0).is_numeric() {\n+                rest = rest.slice_from(1);\n+            }\n+            let i: uint = from_str(inner.slice_to(inner.len() - rest.len())).unwrap();\n+            inner = rest.slice_from(i);\n+            rest = rest.slice_to(i);\n+            while rest.len() > 0 {\n+                if rest.starts_with(\"$\") {\n+                    macro_rules! demangle {\n+                        ($($pat:expr => $demangled:expr),*) => ({\n+                            $(if rest.starts_with($pat) {\n+                                try!(writer.write_str($demangled));\n+                                rest = rest.slice_from($pat.len());\n+                              } else)*\n+                            {\n+                                try!(writer.write_str(rest));\n+                                break;\n+                            }\n+\n+                        })\n+                    }\n+\n+                    // see src/librustc/back/link.rs for these mappings\n+                    demangle! (\n+                        \"$SP$\" => \"@\",\n+                        \"$UP$\" => \"Box\",\n+                        \"$RP$\" => \"*\",\n+                        \"$BP$\" => \"&\",\n+                        \"$LT$\" => \"<\",\n+                        \"$GT$\" => \">\",\n+                        \"$LP$\" => \"(\",\n+                        \"$RP$\" => \")\",\n+                        \"$C$\"  => \",\",\n+\n+                        // in theory we can demangle any Unicode code point, but\n+                        // for simplicity we just catch the common ones.\n+                        \"$x20\" => \" \",\n+                        \"$x27\" => \"'\",\n+                        \"$x5b\" => \"[\",\n+                        \"$x5d\" => \"]\"\n+                    )\n+                } else {\n+                    let idx = match rest.find('$') {\n+                        None => rest.len(),\n+                        Some(i) => i,\n+                    };\n+                    try!(writer.write_str(rest.slice_to(idx)));\n+                    rest = rest.slice_from(idx);\n+                }\n+            }\n+        }\n+    }\n+\n+    Ok(())\n+}"}, {"sha": "421778e20123fc0fcf0c0655a94c41b0ad138bd4", "filename": "src/libstd/sys/common/helper_thread.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -24,12 +24,11 @@ use prelude::*;\n \n use cell::UnsafeCell;\n use mem;\n-use rustrt::bookkeeping;\n-use rustrt;\n use sync::{StaticMutex, StaticCondvar};\n+use rt;\n use sys::helper_signal;\n \n-use task;\n+use thread::Thread;\n \n /// A structure for management of a helper thread.\n ///\n@@ -83,15 +82,14 @@ impl<M: Send> Helper<M> {\n                 *self.signal.get() = send as uint;\n \n                 let t = f();\n-                task::spawn(move |:| {\n-                    bookkeeping::decrement();\n+                Thread::spawn(move |:| {\n                     helper(receive, rx, t);\n                     let _g = self.lock.lock();\n                     *self.shutdown.get() = true;\n                     self.cond.notify_one()\n-                });\n+                }).detach();\n \n-                rustrt::at_exit(move|:| { self.shutdown() });\n+                rt::at_exit(move|:| { self.shutdown() });\n                 *self.initialized.get() = true;\n             }\n         }"}, {"sha": "dc0ad08cdbef637100a7f8477897af5643ddcedf", "filename": "src/libstd/sys/common/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -19,11 +19,15 @@ use num::Int;\n use path::BytesContainer;\n use collections;\n \n+pub mod backtrace;\n pub mod condvar;\n pub mod helper_thread;\n pub mod mutex;\n pub mod net;\n pub mod rwlock;\n+pub mod stack;\n+pub mod thread;\n+pub mod thread_info;\n pub mod thread_local;\n \n // common error constructors"}, {"sha": "2a88e20c8fa1f1e727cdc1546812e48fa30fde81", "filename": "src/libstd/sys/common/stack.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsys%2Fcommon%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsys%2Fcommon%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fstack.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -55,7 +55,7 @@ pub const RED_ZONE: uint = 20 * 1024;\n #[cfg(not(test))] // in testing, use the original libstd's version\n #[lang = \"stack_exhausted\"]\n extern fn stack_exhausted() {\n-    use core::intrinsics;\n+    use intrinsics;\n \n     unsafe {\n         // We're calling this function because the stack just ran out. We need\n@@ -100,7 +100,7 @@ extern fn stack_exhausted() {\n         //  #9854 - unwinding on windows through __morestack has never worked\n         //  #2361 - possible implementation of not using landing pads\n \n-        ::stack_overflow::report();\n+        ::rt::util::report_overflow();\n \n         intrinsics::abort();\n     }", "previous_filename": "src/librustrt/stack.rs"}, {"sha": "048e33399a3c46478e5f586d8a11549f1524419a", "filename": "src/libstd/sys/common/thread.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsys%2Fcommon%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsys%2Fcommon%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fthread.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::prelude::*;\n+\n+use boxed::Box;\n+use mem;\n+use uint;\n+use libc;\n+use thunk::Thunk;\n+use sys_common::stack;\n+use sys::{thread, stack_overflow};\n+\n+// This is the starting point of rust os threads. The first thing we do\n+// is make sure that we don't trigger __morestack (also why this has a\n+// no_stack_check annotation), and then we extract the main function\n+// and invoke it.\n+#[no_stack_check]\n+pub fn start_thread(main: *mut libc::c_void) -> thread::rust_thread_return {\n+    unsafe {\n+        stack::record_os_managed_stack_bounds(0, uint::MAX);\n+        let handler = stack_overflow::Handler::new();\n+        let f: Box<Thunk> = mem::transmute(main);\n+        f.invoke(());\n+        drop(handler);\n+        mem::transmute(0 as thread::rust_thread_return)\n+    }\n+}"}, {"sha": "dc21feb17a8e83c660788c6d720399debf17cb8c", "filename": "src/libstd/sys/common/thread_info.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -0,0 +1,68 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::prelude::*;\n+\n+use thread::Thread;\n+use cell::RefCell;\n+use string::String;\n+\n+struct ThreadInfo {\n+    // This field holds the known bounds of the stack in (lo, hi)\n+    // form. Not all threads necessarily know their precise bounds,\n+    // hence this is optional.\n+    stack_bounds: (uint, uint),\n+    stack_guard: uint,\n+    thread: Thread,\n+}\n+\n+thread_local! { static THREAD_INFO: RefCell<Option<ThreadInfo>> = RefCell::new(None) }\n+\n+impl ThreadInfo {\n+    fn with<R>(f: |&mut ThreadInfo| -> R) -> R {\n+        if THREAD_INFO.destroyed() {\n+            panic!(\"Use of std::thread::Thread::current() is not possible after \\\n+                    the thread's local data has been destroyed\");\n+        }\n+\n+        THREAD_INFO.with(|c| {\n+            if c.borrow().is_none() {\n+                *c.borrow_mut() = Some(ThreadInfo {\n+                    stack_bounds: (0, 0),\n+                    stack_guard: 0,\n+                    thread: NewThread::new(None),\n+                })\n+            }\n+            f(c.borrow_mut().as_mut().unwrap())\n+        })\n+    }\n+}\n+\n+pub fn current_thread() -> Thread {\n+    ThreadInfo::with(|info| info.thread.clone())\n+}\n+\n+pub fn stack_guard() -> uint {\n+    ThreadInfo::with(|info| info.stack_guard)\n+}\n+\n+pub fn set(stack_bounds: (uint, uint), stack_guard: uint, thread: Thread) {\n+    THREAD_INFO.with(|c| assert!(c.borrow().is_none()));\n+    THREAD_INFO.with(move |c| *c.borrow_mut() = Some(ThreadInfo{\n+        stack_bounds: stack_bounds,\n+        stack_guard: stack_guard,\n+        thread: thread,\n+    }));\n+}\n+\n+// a hack to get around privacy restrictions; implemented by `std::thread::Thread`\n+pub trait NewThread {\n+    fn new(name: Option<String>) -> Self;\n+}"}, {"sha": "fe7a7d8d0371688540bd19b327340f7a5b268afe", "filename": "src/libstd/sys/common/thread_local.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -58,9 +58,8 @@\n \n use prelude::*;\n \n-use rustrt::exclusive::Exclusive;\n use sync::atomic::{mod, AtomicUint};\n-use sync::{Once, ONCE_INIT};\n+use sync::{Mutex, Once, ONCE_INIT};\n \n use sys::thread_local as imp;\n \n@@ -142,7 +141,7 @@ pub const INIT_INNER: StaticKeyInner = StaticKeyInner {\n };\n \n static INIT_KEYS: Once = ONCE_INIT;\n-static mut KEYS: *mut Exclusive<Vec<imp::Key>> = 0 as *mut _;\n+static mut KEYS: *mut Mutex<Vec<imp::Key>> = 0 as *mut _;\n \n impl StaticKey {\n     /// Gets the value associated with this TLS key\n@@ -283,4 +282,3 @@ mod tests {\n         }\n     }\n }\n-"}, {"sha": "df9dbad2ec787d81428de57046978eed4770bfaa", "filename": "src/libstd/sys/unix/backtrace.rs", "status": "added", "additions": 493, "deletions": 0, "changes": 493, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -0,0 +1,493 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// Backtrace support built on libgcc with some extra OS-specific support\n+///\n+/// Some methods of getting a backtrace:\n+///\n+/// * The backtrace() functions on unix. It turns out this doesn't work very\n+///   well for green threads on OSX, and the address to symbol portion of it\n+///   suffers problems that are described below.\n+///\n+/// * Using libunwind. This is more difficult than it sounds because libunwind\n+///   isn't installed everywhere by default. It's also a bit of a hefty library,\n+///   so possibly not the best option. When testing, libunwind was excellent at\n+///   getting both accurate backtraces and accurate symbols across platforms.\n+///   This route was not chosen in favor of the next option, however.\n+///\n+/// * We're already using libgcc_s for exceptions in rust (triggering task\n+///   unwinding and running destructors on the stack), and it turns out that it\n+///   conveniently comes with a function that also gives us a backtrace. All of\n+///   these functions look like _Unwind_*, but it's not quite the full\n+///   repertoire of the libunwind API. Due to it already being in use, this was\n+///   the chosen route of getting a backtrace.\n+///\n+/// After choosing libgcc_s for backtraces, the sad part is that it will only\n+/// give us a stack trace of instruction pointers. Thankfully these instruction\n+/// pointers are accurate (they work for green and native threads), but it's\n+/// then up to us again to figure out how to translate these addresses to\n+/// symbols. As with before, we have a few options. Before, that, a little bit\n+/// of an interlude about symbols. This is my very limited knowledge about\n+/// symbol tables, and this information is likely slightly wrong, but the\n+/// general idea should be correct.\n+///\n+/// When talking about symbols, it's helpful to know a few things about where\n+/// symbols are located. Some symbols are located in the dynamic symbol table\n+/// of the executable which in theory means that they're available for dynamic\n+/// linking and lookup. Other symbols end up only in the local symbol table of\n+/// the file. This loosely corresponds to pub and priv functions in Rust.\n+///\n+/// Armed with this knowledge, we know that our solution for address to symbol\n+/// translation will need to consult both the local and dynamic symbol tables.\n+/// With that in mind, here's our options of translating an address to\n+/// a symbol.\n+///\n+/// * Use dladdr(). The original backtrace()-based idea actually uses dladdr()\n+///   behind the scenes to translate, and this is why backtrace() was not used.\n+///   Conveniently, this method works fantastically on OSX. It appears dladdr()\n+///   uses magic to consult the local symbol table, or we're putting everything\n+///   in the dynamic symbol table anyway. Regardless, for OSX, this is the\n+///   method used for translation. It's provided by the system and easy to do.o\n+///\n+///   Sadly, all other systems have a dladdr() implementation that does not\n+///   consult the local symbol table. This means that most functions are blank\n+///   because they don't have symbols. This means that we need another solution.\n+///\n+/// * Use unw_get_proc_name(). This is part of the libunwind api (not the\n+///   libgcc_s version of the libunwind api), but involves taking a dependency\n+///   to libunwind. We may pursue this route in the future if we bundle\n+///   libunwind, but libunwind was unwieldy enough that it was not chosen at\n+///   this time to provide this functionality.\n+///\n+/// * Shell out to a utility like `readelf`. Crazy though it may sound, it's a\n+///   semi-reasonable solution. The stdlib already knows how to spawn processes,\n+///   so in theory it could invoke readelf, parse the output, and consult the\n+///   local/dynamic symbol tables from there. This ended up not getting chosen\n+///   due to the craziness of the idea plus the advent of the next option.\n+///\n+/// * Use `libbacktrace`. It turns out that this is a small library bundled in\n+///   the gcc repository which provides backtrace and symbol translation\n+///   functionality. All we really need from it is the backtrace functionality,\n+///   and we only really need this on everything that's not OSX, so this is the\n+///   chosen route for now.\n+///\n+/// In summary, the current situation uses libgcc_s to get a trace of stack\n+/// pointers, and we use dladdr() or libbacktrace to translate these addresses\n+/// to symbols. This is a bit of a hokey implementation as-is, but it works for\n+/// all unix platforms we support right now, so it at least gets the job done.\n+\n+use c_str::CString;\n+use io::{IoResult, Writer};\n+use libc;\n+use mem;\n+use option::Option::{mod, Some, None};\n+use result::Result::{Ok, Err};\n+use sync::{StaticMutex, MUTEX_INIT};\n+\n+use sys_common::backtrace::*;\n+\n+/// As always - iOS on arm uses SjLj exceptions and\n+/// _Unwind_Backtrace is even not available there. Still,\n+/// backtraces could be extracted using a backtrace function,\n+/// which thanks god is public\n+///\n+/// As mentioned in a huge comment block above, backtrace doesn't\n+/// play well with green threads, so while it is extremely nice\n+/// and simple to use it should be used only on iOS devices as the\n+/// only viable option.\n+#[cfg(all(target_os = \"ios\", target_arch = \"arm\"))]\n+#[inline(never)]\n+pub fn write(w: &mut Writer) -> IoResult<()> {\n+    use iter::{Iterator, range};\n+    use result;\n+    use slice::SliceExt;\n+\n+    extern {\n+        fn backtrace(buf: *mut *mut libc::c_void,\n+                     sz: libc::c_int) -> libc::c_int;\n+    }\n+\n+    // while it doesn't requires lock for work as everything is\n+    // local, it still displays much nicer backtraces when a\n+    // couple of tasks panic simultaneously\n+    static LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n+    let _g = unsafe { LOCK.lock() };\n+\n+    try!(writeln!(w, \"stack backtrace:\"));\n+    // 100 lines should be enough\n+    const SIZE: uint = 100;\n+    let mut buf: [*mut libc::c_void, ..SIZE] = unsafe {mem::zeroed()};\n+    let cnt = unsafe { backtrace(buf.as_mut_ptr(), SIZE as libc::c_int) as uint};\n+\n+    // skipping the first one as it is write itself\n+    let iter = range(1, cnt).map(|i| {\n+        print(w, i as int, buf[i])\n+    });\n+    result::fold(iter, (), |_, _| ())\n+}\n+\n+#[cfg(not(all(target_os = \"ios\", target_arch = \"arm\")))]\n+#[inline(never)] // if we know this is a function call, we can skip it when\n+                 // tracing\n+pub fn write(w: &mut Writer) -> IoResult<()> {\n+    use io::IoError;\n+\n+    struct Context<'a> {\n+        idx: int,\n+        writer: &'a mut (Writer+'a),\n+        last_error: Option<IoError>,\n+    }\n+\n+    // When using libbacktrace, we use some necessary global state, so we\n+    // need to prevent more than one thread from entering this block. This\n+    // is semi-reasonable in terms of printing anyway, and we know that all\n+    // I/O done here is blocking I/O, not green I/O, so we don't have to\n+    // worry about this being a native vs green mutex.\n+    static LOCK: StaticMutex = MUTEX_INIT;\n+    let _g = unsafe { LOCK.lock() };\n+\n+    try!(writeln!(w, \"stack backtrace:\"));\n+\n+    let mut cx = Context { writer: w, last_error: None, idx: 0 };\n+    return match unsafe {\n+        uw::_Unwind_Backtrace(trace_fn,\n+                              &mut cx as *mut Context as *mut libc::c_void)\n+    } {\n+        uw::_URC_NO_REASON => {\n+            match cx.last_error {\n+                Some(err) => Err(err),\n+                None => Ok(())\n+            }\n+        }\n+        _ => Ok(()),\n+    };\n+\n+    extern fn trace_fn(ctx: *mut uw::_Unwind_Context,\n+                       arg: *mut libc::c_void) -> uw::_Unwind_Reason_Code {\n+        let cx: &mut Context = unsafe { mem::transmute(arg) };\n+        let ip = unsafe { uw::_Unwind_GetIP(ctx) as *mut libc::c_void };\n+        // dladdr() on osx gets whiny when we use FindEnclosingFunction, and\n+        // it appears to work fine without it, so we only use\n+        // FindEnclosingFunction on non-osx platforms. In doing so, we get a\n+        // slightly more accurate stack trace in the process.\n+        //\n+        // This is often because panic involves the last instruction of a\n+        // function being \"call std::rt::begin_unwind\", with no ret\n+        // instructions after it. This means that the return instruction\n+        // pointer points *outside* of the calling function, and by\n+        // unwinding it we go back to the original function.\n+        let ip = if cfg!(target_os = \"macos\") || cfg!(target_os = \"ios\") {\n+            ip\n+        } else {\n+            unsafe { uw::_Unwind_FindEnclosingFunction(ip) }\n+        };\n+\n+        // Don't print out the first few frames (they're not user frames)\n+        cx.idx += 1;\n+        if cx.idx <= 0 { return uw::_URC_NO_REASON }\n+        // Don't print ginormous backtraces\n+        if cx.idx > 100 {\n+            match write!(cx.writer, \" ... <frames omitted>\\n\") {\n+                Ok(()) => {}\n+                Err(e) => { cx.last_error = Some(e); }\n+            }\n+            return uw::_URC_FAILURE\n+        }\n+\n+        // Once we hit an error, stop trying to print more frames\n+        if cx.last_error.is_some() { return uw::_URC_FAILURE }\n+\n+        match print(cx.writer, cx.idx, ip) {\n+            Ok(()) => {}\n+            Err(e) => { cx.last_error = Some(e); }\n+        }\n+\n+        // keep going\n+        return uw::_URC_NO_REASON\n+    }\n+}\n+\n+#[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n+fn print(w: &mut Writer, idx: int, addr: *mut libc::c_void) -> IoResult<()> {\n+    use intrinsics;\n+    #[repr(C)]\n+    struct Dl_info {\n+        dli_fname: *const libc::c_char,\n+        dli_fbase: *mut libc::c_void,\n+        dli_sname: *const libc::c_char,\n+        dli_saddr: *mut libc::c_void,\n+    }\n+    extern {\n+        fn dladdr(addr: *const libc::c_void,\n+                  info: *mut Dl_info) -> libc::c_int;\n+    }\n+\n+    let mut info: Dl_info = unsafe { intrinsics::init() };\n+    if unsafe { dladdr(addr as *const libc::c_void, &mut info) == 0 } {\n+        output(w, idx,addr, None)\n+    } else {\n+        output(w, idx, addr, Some(unsafe {\n+            CString::new(info.dli_sname, false)\n+        }))\n+    }\n+}\n+\n+#[cfg(not(any(target_os = \"macos\", target_os = \"ios\")))]\n+fn print(w: &mut Writer, idx: int, addr: *mut libc::c_void) -> IoResult<()> {\n+    use iter::{Iterator, IteratorExt};\n+    use os;\n+    use path::GenericPath;\n+    use ptr::RawPtr;\n+    use ptr;\n+    use slice::SliceExt;\n+\n+    ////////////////////////////////////////////////////////////////////////\n+    // libbacktrace.h API\n+    ////////////////////////////////////////////////////////////////////////\n+    type backtrace_syminfo_callback =\n+        extern \"C\" fn(data: *mut libc::c_void,\n+                      pc: libc::uintptr_t,\n+                      symname: *const libc::c_char,\n+                      symval: libc::uintptr_t,\n+                      symsize: libc::uintptr_t);\n+    type backtrace_error_callback =\n+        extern \"C\" fn(data: *mut libc::c_void,\n+                      msg: *const libc::c_char,\n+                      errnum: libc::c_int);\n+    enum backtrace_state {}\n+    #[link(name = \"backtrace\", kind = \"static\")]\n+    #[cfg(not(test))]\n+    extern {}\n+\n+    extern {\n+        fn backtrace_create_state(filename: *const libc::c_char,\n+                                  threaded: libc::c_int,\n+                                  error: backtrace_error_callback,\n+                                  data: *mut libc::c_void)\n+                                        -> *mut backtrace_state;\n+        fn backtrace_syminfo(state: *mut backtrace_state,\n+                             addr: libc::uintptr_t,\n+                             cb: backtrace_syminfo_callback,\n+                             error: backtrace_error_callback,\n+                             data: *mut libc::c_void) -> libc::c_int;\n+    }\n+\n+    ////////////////////////////////////////////////////////////////////////\n+    // helper callbacks\n+    ////////////////////////////////////////////////////////////////////////\n+\n+    extern fn error_cb(_data: *mut libc::c_void, _msg: *const libc::c_char,\n+                       _errnum: libc::c_int) {\n+        // do nothing for now\n+    }\n+    extern fn syminfo_cb(data: *mut libc::c_void,\n+                         _pc: libc::uintptr_t,\n+                         symname: *const libc::c_char,\n+                         _symval: libc::uintptr_t,\n+                         _symsize: libc::uintptr_t) {\n+        let slot = data as *mut *const libc::c_char;\n+        unsafe { *slot = symname; }\n+    }\n+\n+    // The libbacktrace API supports creating a state, but it does not\n+    // support destroying a state. I personally take this to mean that a\n+    // state is meant to be created and then live forever.\n+    //\n+    // I would love to register an at_exit() handler which cleans up this\n+    // state, but libbacktrace provides no way to do so.\n+    //\n+    // With these constraints, this function has a statically cached state\n+    // that is calculated the first time this is requested. Remember that\n+    // backtracing all happens serially (one global lock).\n+    //\n+    // An additionally oddity in this function is that we initialize the\n+    // filename via self_exe_name() to pass to libbacktrace. It turns out\n+    // that on Linux libbacktrace seamlessly gets the filename of the\n+    // current executable, but this fails on freebsd. by always providing\n+    // it, we make sure that libbacktrace never has a reason to not look up\n+    // the symbols. The libbacktrace API also states that the filename must\n+    // be in \"permanent memory\", so we copy it to a static and then use the\n+    // static as the pointer.\n+    //\n+    // FIXME: We also call self_exe_name() on DragonFly BSD. I haven't\n+    //        tested if this is required or not.\n+    unsafe fn init_state() -> *mut backtrace_state {\n+        static mut STATE: *mut backtrace_state = 0 as *mut backtrace_state;\n+        static mut LAST_FILENAME: [libc::c_char, ..256] = [0, ..256];\n+        if !STATE.is_null() { return STATE }\n+        let selfname = if cfg!(target_os = \"freebsd\") ||\n+                          cfg!(target_os = \"dragonfly\") {\n+            os::self_exe_name()\n+        } else {\n+            None\n+        };\n+        let filename = match selfname {\n+            Some(path) => {\n+                let bytes = path.as_vec();\n+                if bytes.len() < LAST_FILENAME.len() {\n+                    let i = bytes.iter();\n+                    for (slot, val) in LAST_FILENAME.iter_mut().zip(i) {\n+                        *slot = *val as libc::c_char;\n+                    }\n+                    LAST_FILENAME.as_ptr()\n+                } else {\n+                    ptr::null()\n+                }\n+            }\n+            None => ptr::null(),\n+        };\n+        STATE = backtrace_create_state(filename, 0, error_cb,\n+                                       ptr::null_mut());\n+        return STATE\n+    }\n+\n+    ////////////////////////////////////////////////////////////////////////\n+    // translation\n+    ////////////////////////////////////////////////////////////////////////\n+\n+    // backtrace errors are currently swept under the rug, only I/O\n+    // errors are reported\n+    let state = unsafe { init_state() };\n+    if state.is_null() {\n+        return output(w, idx, addr, None)\n+    }\n+    let mut data = 0 as *const libc::c_char;\n+    let data_addr = &mut data as *mut *const libc::c_char;\n+    let ret = unsafe {\n+        backtrace_syminfo(state, addr as libc::uintptr_t,\n+                          syminfo_cb, error_cb,\n+                          data_addr as *mut libc::c_void)\n+    };\n+    if ret == 0 || data.is_null() {\n+        output(w, idx, addr, None)\n+    } else {\n+        output(w, idx, addr, Some(unsafe { CString::new(data, false) }))\n+    }\n+}\n+\n+// Finally, after all that work above, we can emit a symbol.\n+fn output(w: &mut Writer, idx: int, addr: *mut libc::c_void,\n+          s: Option<CString>) -> IoResult<()> {\n+    try!(write!(w, \"  {:2}: {:2$} - \", idx, addr, HEX_WIDTH));\n+    match s.as_ref().and_then(|c| c.as_str()) {\n+        Some(string) => try!(demangle(w, string)),\n+        None => try!(write!(w, \"<unknown>\")),\n+    }\n+    w.write(&['\\n' as u8])\n+}\n+\n+/// Unwind library interface used for backtraces\n+///\n+/// Note that dead code is allowed as here are just bindings\n+/// iOS doesn't use all of them it but adding more\n+/// platform-specific configs pollutes the code too much\n+#[allow(non_camel_case_types)]\n+#[allow(non_snake_case)]\n+#[allow(dead_code)]\n+mod uw {\n+    pub use self::_Unwind_Reason_Code::*;\n+\n+    use libc;\n+\n+    #[repr(C)]\n+    pub enum _Unwind_Reason_Code {\n+        _URC_NO_REASON = 0,\n+        _URC_FOREIGN_EXCEPTION_CAUGHT = 1,\n+        _URC_FATAL_PHASE2_ERROR = 2,\n+        _URC_FATAL_PHASE1_ERROR = 3,\n+        _URC_NORMAL_STOP = 4,\n+        _URC_END_OF_STACK = 5,\n+        _URC_HANDLER_FOUND = 6,\n+        _URC_INSTALL_CONTEXT = 7,\n+        _URC_CONTINUE_UNWIND = 8,\n+        _URC_FAILURE = 9, // used only by ARM EABI\n+    }\n+\n+    pub enum _Unwind_Context {}\n+\n+    pub type _Unwind_Trace_Fn =\n+            extern fn(ctx: *mut _Unwind_Context,\n+                      arg: *mut libc::c_void) -> _Unwind_Reason_Code;\n+\n+    extern {\n+        // No native _Unwind_Backtrace on iOS\n+        #[cfg(not(all(target_os = \"ios\", target_arch = \"arm\")))]\n+        pub fn _Unwind_Backtrace(trace: _Unwind_Trace_Fn,\n+                                 trace_argument: *mut libc::c_void)\n+                    -> _Unwind_Reason_Code;\n+\n+        #[cfg(all(not(target_os = \"android\"),\n+                  not(all(target_os = \"linux\", target_arch = \"arm\"))))]\n+        pub fn _Unwind_GetIP(ctx: *mut _Unwind_Context) -> libc::uintptr_t;\n+\n+        #[cfg(all(not(target_os = \"android\"),\n+                  not(all(target_os = \"linux\", target_arch = \"arm\"))))]\n+        pub fn _Unwind_FindEnclosingFunction(pc: *mut libc::c_void)\n+            -> *mut libc::c_void;\n+    }\n+\n+    // On android, the function _Unwind_GetIP is a macro, and this is the\n+    // expansion of the macro. This is all copy/pasted directly from the\n+    // header file with the definition of _Unwind_GetIP.\n+    #[cfg(any(target_os = \"android\",\n+              all(target_os = \"linux\", target_arch = \"arm\")))]\n+    pub unsafe fn _Unwind_GetIP(ctx: *mut _Unwind_Context) -> libc::uintptr_t {\n+        #[repr(C)]\n+        enum _Unwind_VRS_Result {\n+            _UVRSR_OK = 0,\n+            _UVRSR_NOT_IMPLEMENTED = 1,\n+            _UVRSR_FAILED = 2,\n+        }\n+        #[repr(C)]\n+        enum _Unwind_VRS_RegClass {\n+            _UVRSC_CORE = 0,\n+            _UVRSC_VFP = 1,\n+            _UVRSC_FPA = 2,\n+            _UVRSC_WMMXD = 3,\n+            _UVRSC_WMMXC = 4,\n+        }\n+        #[repr(C)]\n+        enum _Unwind_VRS_DataRepresentation {\n+            _UVRSD_UINT32 = 0,\n+            _UVRSD_VFPX = 1,\n+            _UVRSD_FPAX = 2,\n+            _UVRSD_UINT64 = 3,\n+            _UVRSD_FLOAT = 4,\n+            _UVRSD_DOUBLE = 5,\n+        }\n+\n+        type _Unwind_Word = libc::c_uint;\n+        extern {\n+            fn _Unwind_VRS_Get(ctx: *mut _Unwind_Context,\n+                               klass: _Unwind_VRS_RegClass,\n+                               word: _Unwind_Word,\n+                               repr: _Unwind_VRS_DataRepresentation,\n+                               data: *mut libc::c_void)\n+                -> _Unwind_VRS_Result;\n+        }\n+\n+        let mut val: _Unwind_Word = 0;\n+        let ptr = &mut val as *mut _Unwind_Word;\n+        let _ = _Unwind_VRS_Get(ctx, _Unwind_VRS_RegClass::_UVRSC_CORE, 15,\n+                                _Unwind_VRS_DataRepresentation::_UVRSD_UINT32,\n+                                ptr as *mut libc::c_void);\n+        (val & !1) as libc::uintptr_t\n+    }\n+\n+    // This function also doesn't exist on Android or ARM/Linux, so make it\n+    // a no-op\n+    #[cfg(any(target_os = \"android\",\n+              all(target_os = \"linux\", target_arch = \"arm\")))]\n+    pub unsafe fn _Unwind_FindEnclosingFunction(pc: *mut libc::c_void)\n+        -> *mut libc::c_void\n+    {\n+        pc\n+    }\n+}"}, {"sha": "f3babca32871ae86d8b36da38c2ac4c899a63522", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -34,6 +34,7 @@ macro_rules! helper_init { (static $name:ident: Helper<$m:ty>) => (\n     };\n ) }\n \n+pub mod backtrace;\n pub mod c;\n pub mod ext;\n pub mod condvar;\n@@ -44,8 +45,10 @@ pub mod os;\n pub mod pipe;\n pub mod process;\n pub mod rwlock;\n+pub mod stack_overflow;\n pub mod sync;\n pub mod tcp;\n+pub mod thread;\n pub mod thread_local;\n pub mod timer;\n pub mod tty;"}, {"sha": "0ed079df55b353f79e882346738db8ddc56dd350", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 132, "deletions": 3, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -8,14 +8,24 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use libc;\n-use libc::{c_int, c_char};\n+//! Implementation of `std::os` functionality for unix systems\n+\n use prelude::*;\n-use io::IoResult;\n+\n+use error::{FromError, Error};\n+use fmt;\n+use io::{IoError, IoResult};\n+use libc::{mod, c_int, c_char, c_void};\n+use path::{Path, GenericPath, BytesContainer};\n+use ptr::{mod, RawPtr};\n+use sync::atomic::{AtomicInt, INIT_ATOMIC_INT, SeqCst};\n use sys::fs::FileDesc;\n+use os;\n \n use os::TMPBUF_SZ;\n \n+const BUF_BYTES : uint = 2048u;\n+\n /// Returns the platform-specific value of errno\n pub fn errno() -> int {\n     #[cfg(any(target_os = \"macos\",\n@@ -110,3 +120,122 @@ pub unsafe fn pipe() -> IoResult<(FileDesc, FileDesc)> {\n         Err(super::last_error())\n     }\n }\n+\n+pub fn getcwd() -> IoResult<Path> {\n+    use c_str::CString;\n+\n+    let mut buf = [0 as c_char, ..BUF_BYTES];\n+    unsafe {\n+        if libc::getcwd(buf.as_mut_ptr(), buf.len() as libc::size_t).is_null() {\n+            Err(IoError::last_error())\n+        } else {\n+            Ok(Path::new(CString::new(buf.as_ptr(), false)))\n+        }\n+    }\n+}\n+\n+pub unsafe fn get_env_pairs() -> Vec<Vec<u8>> {\n+    use c_str::CString;\n+\n+    extern {\n+        fn rust_env_pairs() -> *const *const c_char;\n+    }\n+    let mut environ = rust_env_pairs();\n+    if environ as uint == 0 {\n+        panic!(\"os::env() failure getting env string from OS: {}\",\n+               os::last_os_error());\n+    }\n+    let mut result = Vec::new();\n+    while *environ != 0 as *const _ {\n+        let env_pair =\n+            CString::new(*environ, false).as_bytes_no_nul().to_vec();\n+        result.push(env_pair);\n+        environ = environ.offset(1);\n+    }\n+    result\n+}\n+\n+pub fn split_paths(unparsed: &[u8]) -> Vec<Path> {\n+    unparsed.split(|b| *b == b':').map(Path::new).collect()\n+}\n+\n+pub fn join_paths<T: BytesContainer>(paths: &[T]) -> Result<Vec<u8>, &'static str> {\n+    let mut joined = Vec::new();\n+    let sep = b':';\n+\n+    for (i, path) in paths.iter().map(|p| p.container_as_bytes()).enumerate() {\n+        if i > 0 { joined.push(sep) }\n+        if path.contains(&sep) { return Err(\"path segment contains separator `:`\") }\n+        joined.push_all(path);\n+    }\n+\n+    Ok(joined)\n+}\n+\n+#[cfg(any(target_os = \"freebsd\", target_os = \"dragonfly\"))]\n+pub fn load_self() -> Option<Vec<u8>> {\n+    unsafe {\n+        use libc::funcs::bsd44::*;\n+        use libc::consts::os::extra::*;\n+        let mut mib = vec![CTL_KERN as c_int,\n+                           KERN_PROC as c_int,\n+                           KERN_PROC_PATHNAME as c_int,\n+                           -1 as c_int];\n+        let mut sz: libc::size_t = 0;\n+        let err = sysctl(mib.as_mut_ptr(), mib.len() as ::libc::c_uint,\n+                         ptr::null_mut(), &mut sz, ptr::null_mut(),\n+                         0u as libc::size_t);\n+        if err != 0 { return None; }\n+        if sz == 0 { return None; }\n+        let mut v: Vec<u8> = Vec::with_capacity(sz as uint);\n+        let err = sysctl(mib.as_mut_ptr(), mib.len() as ::libc::c_uint,\n+                         v.as_mut_ptr() as *mut c_void, &mut sz,\n+                         ptr::null_mut(), 0u as libc::size_t);\n+        if err != 0 { return None; }\n+        if sz == 0 { return None; }\n+        v.set_len(sz as uint - 1); // chop off trailing NUL\n+        Some(v)\n+    }\n+}\n+\n+#[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+pub fn load_self() -> Option<Vec<u8>> {\n+    use std::io;\n+\n+    match io::fs::readlink(&Path::new(\"/proc/self/exe\")) {\n+        Ok(path) => Some(path.into_vec()),\n+        Err(..) => None\n+    }\n+}\n+\n+#[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n+pub fn load_self() -> Option<Vec<u8>> {\n+    unsafe {\n+        use libc::funcs::extra::_NSGetExecutablePath;\n+        let mut sz: u32 = 0;\n+        _NSGetExecutablePath(ptr::null_mut(), &mut sz);\n+        if sz == 0 { return None; }\n+        let mut v: Vec<u8> = Vec::with_capacity(sz as uint);\n+        let err = _NSGetExecutablePath(v.as_mut_ptr() as *mut i8, &mut sz);\n+        if err != 0 { return None; }\n+        v.set_len(sz as uint - 1); // chop off trailing NUL\n+        Some(v)\n+    }\n+}\n+\n+pub fn chdir(p: &Path) -> IoResult<()> {\n+    p.with_c_str(|buf| {\n+        unsafe {\n+            match libc::chdir(buf) == (0 as c_int) {\n+                true => Ok(()),\n+                false => Err(IoError::last_error()),\n+            }\n+        }\n+    })\n+}\n+\n+pub fn page_size() -> uint {\n+    unsafe {\n+        libc::sysconf(libc::_SC_PAGESIZE) as uint\n+    }\n+}"}, {"sha": "340f95142419c043936b30e2569b6b57e710061a", "filename": "src/libstd/sys/unix/stack_overflow.rs", "status": "renamed", "additions": 21, "deletions": 151, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -8,167 +8,40 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(non_camel_case_types)]\n-\n-use core::prelude::*;\n use libc;\n-use local::Local;\n-use task::Task;\n-\n-pub unsafe fn init() {\n-    imp::init();\n-}\n+use core::prelude::*;\n+use self::imp::{make_handler, drop_handler};\n \n-pub unsafe fn cleanup() {\n-    imp::cleanup();\n-}\n+pub use self::imp::{init, cleanup};\n \n pub struct Handler {\n     _data: *mut libc::c_void\n }\n \n impl Handler {\n     pub unsafe fn new() -> Handler {\n-        imp::make_handler()\n+        make_handler()\n     }\n }\n \n impl Drop for Handler {\n     fn drop(&mut self) {\n         unsafe {\n-            imp::drop_handler(self);\n-        }\n-    }\n-}\n-\n-pub unsafe fn report() {\n-    // See the message below for why this is not emitted to the\n-    // ^ Where did the message below go?\n-    // task's logger. This has the additional conundrum of the\n-    // logger may not be initialized just yet, meaning that an FFI\n-    // call would happen to initialized it (calling out to libuv),\n-    // and the FFI call needs 2MB of stack when we just ran out.\n-\n-    let task: Option<*mut Task> = Local::try_unsafe_borrow();\n-\n-    let name = task.and_then(|task| {\n-        (*task).name.as_ref().map(|n| n.as_slice())\n-    });\n-\n-    rterrln!(\"\\ntask '{}' has overflowed its stack\", name.unwrap_or(\"<unknown>\"));\n-}\n-\n-// get_task_info is called from an exception / signal handler.\n-// It returns the guard page of the current task or 0 if that\n-// guard page doesn't exist. None is returned if there's currently\n-// no local task.\n-#[cfg(any(windows, target_os = \"linux\", target_os = \"macos\"))]\n-unsafe fn get_task_guard_page() -> Option<uint> {\n-    let task: Option<*mut Task> = Local::try_unsafe_borrow();\n-    task.map(|task| (&*task).stack_guard().unwrap_or(0))\n-}\n-\n-#[cfg(windows)]\n-#[allow(non_snake_case)]\n-mod imp {\n-    use core::ptr;\n-    use core::mem;\n-    use libc;\n-    use libc::types::os::arch::extra::{LPVOID, DWORD, LONG, BOOL};\n-    use stack;\n-    use super::{Handler, get_task_guard_page, report};\n-\n-    // This is initialized in init() and only read from after\n-    static mut PAGE_SIZE: uint = 0;\n-\n-    #[no_stack_check]\n-    extern \"system\" fn vectored_handler(ExceptionInfo: *mut EXCEPTION_POINTERS) -> LONG {\n-        unsafe {\n-            let rec = &(*(*ExceptionInfo).ExceptionRecord);\n-            let code = rec.ExceptionCode;\n-\n-            if code != EXCEPTION_STACK_OVERFLOW {\n-                return EXCEPTION_CONTINUE_SEARCH;\n-            }\n-\n-            // We're calling into functions with stack checks,\n-            // however stack checks by limit should be disabled on Windows\n-            stack::record_sp_limit(0);\n-\n-            if get_task_guard_page().is_some() {\n-               report();\n-            }\n-\n-            EXCEPTION_CONTINUE_SEARCH\n+            drop_handler(self);\n         }\n     }\n-\n-    pub unsafe fn init() {\n-        let mut info = mem::zeroed();\n-        libc::GetSystemInfo(&mut info);\n-        PAGE_SIZE = info.dwPageSize as uint;\n-\n-        if AddVectoredExceptionHandler(0, vectored_handler) == ptr::null_mut() {\n-            panic!(\"failed to install exception handler\");\n-        }\n-\n-        mem::forget(make_handler());\n-    }\n-\n-    pub unsafe fn cleanup() {\n-    }\n-\n-    pub unsafe fn make_handler() -> Handler {\n-        if SetThreadStackGuarantee(&mut 0x5000) == 0 {\n-            panic!(\"failed to reserve stack space for exception handling\");\n-        }\n-\n-        super::Handler { _data: 0i as *mut libc::c_void }\n-    }\n-\n-    pub unsafe fn drop_handler(_handler: &mut Handler) {\n-    }\n-\n-    pub struct EXCEPTION_RECORD {\n-        pub ExceptionCode: DWORD,\n-        pub ExceptionFlags: DWORD,\n-        pub ExceptionRecord: *mut EXCEPTION_RECORD,\n-        pub ExceptionAddress: LPVOID,\n-        pub NumberParameters: DWORD,\n-        pub ExceptionInformation: [LPVOID, ..EXCEPTION_MAXIMUM_PARAMETERS]\n-    }\n-\n-    pub struct EXCEPTION_POINTERS {\n-        pub ExceptionRecord: *mut EXCEPTION_RECORD,\n-        pub ContextRecord: LPVOID\n-    }\n-\n-    pub type PVECTORED_EXCEPTION_HANDLER = extern \"system\"\n-            fn(ExceptionInfo: *mut EXCEPTION_POINTERS) -> LONG;\n-\n-    pub type ULONG = libc::c_ulong;\n-\n-    const EXCEPTION_CONTINUE_SEARCH: LONG = 0;\n-    const EXCEPTION_MAXIMUM_PARAMETERS: uint = 15;\n-    const EXCEPTION_STACK_OVERFLOW: DWORD = 0xc00000fd;\n-\n-    extern \"system\" {\n-        fn AddVectoredExceptionHandler(FirstHandler: ULONG,\n-                                       VectoredHandler: PVECTORED_EXCEPTION_HANDLER)\n-                                      -> LPVOID;\n-        fn SetThreadStackGuarantee(StackSizeInBytes: *mut ULONG) -> BOOL;\n-    }\n }\n \n #[cfg(any(target_os = \"linux\", target_os = \"macos\"))]\n mod imp {\n     use core::prelude::*;\n-    use stack;\n+    use sys_common::stack;\n \n-    use super::{Handler, get_task_guard_page, report};\n-    use core::mem;\n-    use core::ptr;\n-    use core::intrinsics;\n+    use super::Handler;\n+    use rt::util::report_overflow;\n+    use mem;\n+    use ptr;\n+    use intrinsics;\n     use self::signal::{siginfo, sigaction, SIGBUS, SIG_DFL,\n                        SA_SIGINFO, SA_ONSTACK, sigaltstack,\n                        SIGSTKSZ};\n@@ -181,6 +54,8 @@ mod imp {\n                                     MAP_ANON,\n                                     MAP_FAILED};\n \n+    use sys_common::thread_info;\n+\n \n     // This is initialized in init() and only read from after\n     static mut PAGE_SIZE: uint = 0;\n@@ -204,20 +79,16 @@ mod imp {\n         // We're calling into functions with stack checks\n         stack::record_sp_limit(0);\n \n-        match get_task_guard_page() {\n-            Some(guard) => {\n-                let addr = (*info).si_addr as uint;\n+        let guard = thread_info::stack_guard();\n+        let addr = (*info).si_addr as uint;\n \n-                if guard == 0 || addr < guard - PAGE_SIZE || addr >= guard {\n-                    term(signum);\n-                }\n+        if guard == 0 || addr < guard - PAGE_SIZE || addr >= guard {\n+            term(signum);\n+        }\n \n-                report();\n+        report_overflow();\n \n-                intrinsics::abort()\n-            }\n-            None => term(signum)\n-        }\n+        intrinsics::abort()\n     }\n \n     static mut MAIN_ALTSTACK: *mut libc::c_void = 0 as *mut libc::c_void;\n@@ -387,8 +258,7 @@ mod imp {\n }\n \n #[cfg(not(any(target_os = \"linux\",\n-              target_os = \"macos\",\n-              windows)))]\n+              target_os = \"macos\")))]\n mod imp {\n     use libc;\n ", "previous_filename": "src/librustrt/stack_overflow.rs"}, {"sha": "2416b64f98f43ededa4cf99af04cd81db2063146", "filename": "src/libstd/sys/unix/thread.rs", "status": "added", "additions": 271, "deletions": 0, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -0,0 +1,271 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::prelude::*;\n+\n+use boxed::Box;\n+use cmp;\n+use mem;\n+use ptr;\n+use libc::consts::os::posix01::{PTHREAD_CREATE_JOINABLE, PTHREAD_STACK_MIN};\n+use libc;\n+use thunk::Thunk;\n+\n+use sys_common::stack::RED_ZONE;\n+use sys_common::thread::*;\n+\n+pub type rust_thread = libc::pthread_t;\n+pub type rust_thread_return = *mut u8;\n+pub type StartFn = extern \"C\" fn(*mut libc::c_void) -> rust_thread_return;\n+\n+#[no_stack_check]\n+pub extern fn thread_start(main: *mut libc::c_void) -> rust_thread_return {\n+    return start_thread(main);\n+}\n+\n+#[cfg(all(not(target_os = \"linux\"), not(target_os = \"macos\")))]\n+pub mod guard {\n+    pub unsafe fn current() -> uint {\n+        0\n+    }\n+\n+    pub unsafe fn main() -> uint {\n+        0\n+    }\n+\n+    pub unsafe fn init() {\n+    }\n+}\n+\n+#[cfg(any(target_os = \"linux\", target_os = \"macos\"))]\n+pub mod guard {\n+    use super::*;\n+    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+    use mem;\n+    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+    use ptr;\n+    use libc;\n+    use libc::funcs::posix88::mman::{mmap};\n+    use libc::consts::os::posix88::{PROT_NONE,\n+                                    MAP_PRIVATE,\n+                                    MAP_ANON,\n+                                    MAP_FAILED,\n+                                    MAP_FIXED};\n+\n+    // These are initialized in init() and only read from after\n+    static mut PAGE_SIZE: uint = 0;\n+    static mut GUARD_PAGE: uint = 0;\n+\n+    #[cfg(target_os = \"macos\")]\n+    unsafe fn get_stack_start() -> *mut libc::c_void {\n+        current() as *mut libc::c_void\n+    }\n+\n+    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+    unsafe fn get_stack_start() -> *mut libc::c_void {\n+        let mut attr: libc::pthread_attr_t = mem::zeroed();\n+        if pthread_getattr_np(pthread_self(), &mut attr) != 0 {\n+            panic!(\"failed to get thread attributes\");\n+        }\n+        let mut stackaddr = ptr::null_mut();\n+        let mut stacksize = 0;\n+        if pthread_attr_getstack(&attr, &mut stackaddr, &mut stacksize) != 0 {\n+            panic!(\"failed to get stack information\");\n+        }\n+        if pthread_attr_destroy(&mut attr) != 0 {\n+            panic!(\"failed to destroy thread attributes\");\n+        }\n+        stackaddr\n+    }\n+\n+    pub unsafe fn init() {\n+        let psize = libc::sysconf(libc::consts::os::sysconf::_SC_PAGESIZE);\n+        if psize == -1 {\n+            panic!(\"failed to get page size\");\n+        }\n+\n+        PAGE_SIZE = psize as uint;\n+\n+        let stackaddr = get_stack_start();\n+\n+        // Rellocate the last page of the stack.\n+        // This ensures SIGBUS will be raised on\n+        // stack overflow.\n+        let result = mmap(stackaddr,\n+                          PAGE_SIZE as libc::size_t,\n+                          PROT_NONE,\n+                          MAP_PRIVATE | MAP_ANON | MAP_FIXED,\n+                          -1,\n+                          0);\n+\n+        if result != stackaddr || result == MAP_FAILED {\n+            panic!(\"failed to allocate a guard page\");\n+        }\n+\n+        let offset = if cfg!(target_os = \"linux\") {\n+            2\n+        } else {\n+            1\n+        };\n+\n+        GUARD_PAGE = stackaddr as uint + offset * PAGE_SIZE;\n+    }\n+\n+    pub unsafe fn main() -> uint {\n+        GUARD_PAGE\n+    }\n+\n+    #[cfg(target_os = \"macos\")]\n+    pub unsafe fn current() -> uint {\n+        (pthread_get_stackaddr_np(pthread_self()) as libc::size_t -\n+         pthread_get_stacksize_np(pthread_self())) as uint\n+    }\n+\n+    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+    pub unsafe fn current() -> uint {\n+        let mut attr: libc::pthread_attr_t = mem::zeroed();\n+        if pthread_getattr_np(pthread_self(), &mut attr) != 0 {\n+            panic!(\"failed to get thread attributes\");\n+        }\n+        let mut guardsize = 0;\n+        if pthread_attr_getguardsize(&attr, &mut guardsize) != 0 {\n+            panic!(\"failed to get stack guard page\");\n+        }\n+        if guardsize == 0 {\n+            panic!(\"there is no guard page\");\n+        }\n+        let mut stackaddr = ptr::null_mut();\n+        let mut stacksize = 0;\n+        if pthread_attr_getstack(&attr, &mut stackaddr, &mut stacksize) != 0 {\n+            panic!(\"failed to get stack information\");\n+        }\n+        if pthread_attr_destroy(&mut attr) != 0 {\n+            panic!(\"failed to destroy thread attributes\");\n+        }\n+\n+        stackaddr as uint + guardsize as uint\n+    }\n+}\n+\n+pub unsafe fn create(stack: uint, p: Thunk) -> rust_thread {\n+    let mut native: libc::pthread_t = mem::zeroed();\n+    let mut attr: libc::pthread_attr_t = mem::zeroed();\n+    assert_eq!(pthread_attr_init(&mut attr), 0);\n+    assert_eq!(pthread_attr_setdetachstate(&mut attr,\n+                                           PTHREAD_CREATE_JOINABLE), 0);\n+\n+    // Reserve room for the red zone, the runtime's stack of last resort.\n+    let stack_size = cmp::max(stack, RED_ZONE + min_stack_size(&attr) as uint);\n+    match pthread_attr_setstacksize(&mut attr, stack_size as libc::size_t) {\n+        0 => {\n+        },\n+        libc::EINVAL => {\n+            // EINVAL means |stack_size| is either too small or not a\n+            // multiple of the system page size.  Because it's definitely\n+            // >= PTHREAD_STACK_MIN, it must be an alignment issue.\n+            // Round up to the nearest page and try again.\n+            let page_size = libc::sysconf(libc::_SC_PAGESIZE) as uint;\n+            let stack_size = (stack_size + page_size - 1) &\n+                             (-(page_size as int - 1) as uint - 1);\n+            assert_eq!(pthread_attr_setstacksize(&mut attr, stack_size as libc::size_t), 0);\n+        },\n+        errno => {\n+            // This cannot really happen.\n+            panic!(\"pthread_attr_setstacksize() error: {}\", errno);\n+        },\n+    };\n+\n+    let arg: *mut libc::c_void = mem::transmute(box p); // must box since sizeof(p)=2*uint\n+    let ret = pthread_create(&mut native, &attr, thread_start, arg);\n+    assert_eq!(pthread_attr_destroy(&mut attr), 0);\n+\n+    if ret != 0 {\n+        // be sure to not leak the closure\n+        let _p: Box<Box<FnOnce()+Send>> = mem::transmute(arg);\n+        panic!(\"failed to spawn native thread: {}\", ret);\n+    }\n+    native\n+}\n+\n+pub unsafe fn join(native: rust_thread) {\n+    assert_eq!(pthread_join(native, ptr::null_mut()), 0);\n+}\n+\n+pub unsafe fn detach(native: rust_thread) {\n+    assert_eq!(pthread_detach(native), 0);\n+}\n+\n+pub unsafe fn yield_now() { assert_eq!(sched_yield(), 0); }\n+// glibc >= 2.15 has a __pthread_get_minstack() function that returns\n+// PTHREAD_STACK_MIN plus however many bytes are needed for thread-local\n+// storage.  We need that information to avoid blowing up when a small stack\n+// is created in an application with big thread-local storage requirements.\n+// See #6233 for rationale and details.\n+//\n+// Link weakly to the symbol for compatibility with older versions of glibc.\n+// Assumes that we've been dynamically linked to libpthread but that is\n+// currently always the case.  Note that you need to check that the symbol\n+// is non-null before calling it!\n+#[cfg(target_os = \"linux\")]\n+fn min_stack_size(attr: *const libc::pthread_attr_t) -> libc::size_t {\n+    type F = unsafe extern \"C\" fn(*const libc::pthread_attr_t) -> libc::size_t;\n+    extern {\n+        #[linkage = \"extern_weak\"]\n+        static __pthread_get_minstack: *const ();\n+    }\n+    if __pthread_get_minstack.is_null() {\n+        PTHREAD_STACK_MIN\n+    } else {\n+        unsafe { mem::transmute::<*const (), F>(__pthread_get_minstack)(attr) }\n+    }\n+}\n+\n+// __pthread_get_minstack() is marked as weak but extern_weak linkage is\n+// not supported on OS X, hence this kludge...\n+#[cfg(not(target_os = \"linux\"))]\n+fn min_stack_size(_: *const libc::pthread_attr_t) -> libc::size_t {\n+    PTHREAD_STACK_MIN\n+}\n+\n+#[cfg(any(target_os = \"linux\"))]\n+extern {\n+    pub fn pthread_self() -> libc::pthread_t;\n+    pub fn pthread_getattr_np(native: libc::pthread_t,\n+                              attr: *mut libc::pthread_attr_t) -> libc::c_int;\n+    pub fn pthread_attr_getguardsize(attr: *const libc::pthread_attr_t,\n+                                     guardsize: *mut libc::size_t) -> libc::c_int;\n+    pub fn pthread_attr_getstack(attr: *const libc::pthread_attr_t,\n+                                 stackaddr: *mut *mut libc::c_void,\n+                                 stacksize: *mut libc::size_t) -> libc::c_int;\n+}\n+\n+#[cfg(target_os = \"macos\")]\n+extern {\n+    pub fn pthread_self() -> libc::pthread_t;\n+    pub fn pthread_get_stackaddr_np(thread: libc::pthread_t) -> *mut libc::c_void;\n+    pub fn pthread_get_stacksize_np(thread: libc::pthread_t) -> libc::size_t;\n+}\n+\n+extern {\n+    fn pthread_create(native: *mut libc::pthread_t,\n+                      attr: *const libc::pthread_attr_t,\n+                      f: StartFn,\n+                      value: *mut libc::c_void) -> libc::c_int;\n+    fn pthread_join(native: libc::pthread_t,\n+                    value: *mut *mut libc::c_void) -> libc::c_int;\n+    fn pthread_attr_init(attr: *mut libc::pthread_attr_t) -> libc::c_int;\n+    pub fn pthread_attr_destroy(attr: *mut libc::pthread_attr_t) -> libc::c_int;\n+    fn pthread_attr_setstacksize(attr: *mut libc::pthread_attr_t,\n+                                 stack_size: libc::size_t) -> libc::c_int;\n+    fn pthread_attr_setdetachstate(attr: *mut libc::pthread_attr_t,\n+                                   state: libc::c_int) -> libc::c_int;\n+    fn pthread_detach(thread: libc::pthread_t) -> libc::c_int;\n+    fn sched_yield() -> libc::c_int;\n+}"}, {"sha": "f2f543dd9697f228d5ce78b4fd6f0190c085c44a", "filename": "src/libstd/sys/windows/backtrace.rs", "status": "added", "additions": 371, "deletions": 0, "changes": 371, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -0,0 +1,371 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+/// As always, windows has something very different than unix, we mainly want\n+/// to avoid having to depend too much on libunwind for windows.\n+///\n+/// If you google around, you'll find a fair bit of references to built-in\n+/// functions to get backtraces on windows. It turns out that most of these are\n+/// in an external library called dbghelp. I was unable to find this library\n+/// via `-ldbghelp`, but it is apparently normal to do the `dlopen` equivalent\n+/// of it.\n+///\n+/// You'll also find that there's a function called CaptureStackBackTrace\n+/// mentioned frequently (which is also easy to use), but sadly I didn't have a\n+/// copy of that function in my mingw install (maybe it was broken?). Instead,\n+/// this takes the route of using StackWalk64 in order to walk the stack.\n+\n+use c_str::CString;\n+use intrinsics;\n+use io::{IoResult, Writer};\n+use libc;\n+use mem;\n+use ops::Drop;\n+use option::Option::{Some, None};\n+use path::Path;\n+use result::Result::{Ok, Err};\n+use sync::{StaticMutex, MUTEX_INIT};\n+use slice::SliceExt;\n+use str::StrPrelude;\n+use dynamic_lib::DynamicLibrary;\n+\n+use sys_common::backtrace::*;\n+\n+#[allow(non_snake_case)]\n+extern \"system\" {\n+    fn GetCurrentProcess() -> libc::HANDLE;\n+    fn GetCurrentThread() -> libc::HANDLE;\n+    fn RtlCaptureContext(ctx: *mut arch::CONTEXT);\n+}\n+\n+type SymFromAddrFn =\n+    extern \"system\" fn(libc::HANDLE, u64, *mut u64,\n+                       *mut SYMBOL_INFO) -> libc::BOOL;\n+type SymInitializeFn =\n+    extern \"system\" fn(libc::HANDLE, *mut libc::c_void,\n+                       libc::BOOL) -> libc::BOOL;\n+type SymCleanupFn =\n+    extern \"system\" fn(libc::HANDLE) -> libc::BOOL;\n+\n+type StackWalk64Fn =\n+    extern \"system\" fn(libc::DWORD, libc::HANDLE, libc::HANDLE,\n+                       *mut STACKFRAME64, *mut arch::CONTEXT,\n+                       *mut libc::c_void, *mut libc::c_void,\n+                       *mut libc::c_void, *mut libc::c_void) -> libc::BOOL;\n+\n+const MAX_SYM_NAME: uint = 2000;\n+const IMAGE_FILE_MACHINE_I386: libc::DWORD = 0x014c;\n+const IMAGE_FILE_MACHINE_IA64: libc::DWORD = 0x0200;\n+const IMAGE_FILE_MACHINE_AMD64: libc::DWORD = 0x8664;\n+\n+#[repr(C)]\n+struct SYMBOL_INFO {\n+    SizeOfStruct: libc::c_ulong,\n+    TypeIndex: libc::c_ulong,\n+    Reserved: [u64, ..2],\n+    Index: libc::c_ulong,\n+    Size: libc::c_ulong,\n+    ModBase: u64,\n+    Flags: libc::c_ulong,\n+    Value: u64,\n+    Address: u64,\n+    Register: libc::c_ulong,\n+    Scope: libc::c_ulong,\n+    Tag: libc::c_ulong,\n+    NameLen: libc::c_ulong,\n+    MaxNameLen: libc::c_ulong,\n+    // note that windows has this as 1, but it basically just means that\n+    // the name is inline at the end of the struct. For us, we just bump\n+    // the struct size up to MAX_SYM_NAME.\n+    Name: [libc::c_char, ..MAX_SYM_NAME],\n+}\n+\n+\n+#[repr(C)]\n+enum ADDRESS_MODE {\n+    AddrMode1616,\n+    AddrMode1632,\n+    AddrModeReal,\n+    AddrModeFlat,\n+}\n+\n+struct ADDRESS64 {\n+    Offset: u64,\n+    Segment: u16,\n+    Mode: ADDRESS_MODE,\n+}\n+\n+struct STACKFRAME64 {\n+    AddrPC: ADDRESS64,\n+    AddrReturn: ADDRESS64,\n+    AddrFrame: ADDRESS64,\n+    AddrStack: ADDRESS64,\n+    AddrBStore: ADDRESS64,\n+    FuncTableEntry: *mut libc::c_void,\n+    Params: [u64, ..4],\n+    Far: libc::BOOL,\n+    Virtual: libc::BOOL,\n+    Reserved: [u64, ..3],\n+    KdHelp: KDHELP64,\n+}\n+\n+struct KDHELP64 {\n+    Thread: u64,\n+    ThCallbackStack: libc::DWORD,\n+    ThCallbackBStore: libc::DWORD,\n+    NextCallback: libc::DWORD,\n+    FramePointer: libc::DWORD,\n+    KiCallUserMode: u64,\n+    KeUserCallbackDispatcher: u64,\n+    SystemRangeStart: u64,\n+    KiUserExceptionDispatcher: u64,\n+    StackBase: u64,\n+    StackLimit: u64,\n+    Reserved: [u64, ..5],\n+}\n+\n+#[cfg(target_arch = \"x86\")]\n+mod arch {\n+    use libc;\n+\n+    const MAXIMUM_SUPPORTED_EXTENSION: uint = 512;\n+\n+    #[repr(C)]\n+    pub struct CONTEXT {\n+        ContextFlags: libc::DWORD,\n+        Dr0: libc::DWORD,\n+        Dr1: libc::DWORD,\n+        Dr2: libc::DWORD,\n+        Dr3: libc::DWORD,\n+        Dr6: libc::DWORD,\n+        Dr7: libc::DWORD,\n+        FloatSave: FLOATING_SAVE_AREA,\n+        SegGs: libc::DWORD,\n+        SegFs: libc::DWORD,\n+        SegEs: libc::DWORD,\n+        SegDs: libc::DWORD,\n+        Edi: libc::DWORD,\n+        Esi: libc::DWORD,\n+        Ebx: libc::DWORD,\n+        Edx: libc::DWORD,\n+        Ecx: libc::DWORD,\n+        Eax: libc::DWORD,\n+        Ebp: libc::DWORD,\n+        Eip: libc::DWORD,\n+        SegCs: libc::DWORD,\n+        EFlags: libc::DWORD,\n+        Esp: libc::DWORD,\n+        SegSs: libc::DWORD,\n+        ExtendedRegisters: [u8, ..MAXIMUM_SUPPORTED_EXTENSION],\n+    }\n+\n+    #[repr(C)]\n+    pub struct FLOATING_SAVE_AREA {\n+        ControlWord: libc::DWORD,\n+        StatusWord: libc::DWORD,\n+        TagWord: libc::DWORD,\n+        ErrorOffset: libc::DWORD,\n+        ErrorSelector: libc::DWORD,\n+        DataOffset: libc::DWORD,\n+        DataSelector: libc::DWORD,\n+        RegisterArea: [u8, ..80],\n+        Cr0NpxState: libc::DWORD,\n+    }\n+\n+    pub fn init_frame(frame: &mut super::STACKFRAME64,\n+                      ctx: &CONTEXT) -> libc::DWORD {\n+        frame.AddrPC.Offset = ctx.Eip as u64;\n+        frame.AddrPC.Mode = super::ADDRESS_MODE::AddrModeFlat;\n+        frame.AddrStack.Offset = ctx.Esp as u64;\n+        frame.AddrStack.Mode = super::ADDRESS_MODE::AddrModeFlat;\n+        frame.AddrFrame.Offset = ctx.Ebp as u64;\n+        frame.AddrFrame.Mode = super::ADDRESS_MODE::AddrModeFlat;\n+        super::IMAGE_FILE_MACHINE_I386\n+    }\n+}\n+\n+#[cfg(target_arch = \"x86_64\")]\n+mod arch {\n+    use libc::{c_longlong, c_ulonglong};\n+    use libc::types::os::arch::extra::{WORD, DWORD, DWORDLONG};\n+    use simd;\n+\n+    #[repr(C)]\n+    pub struct CONTEXT {\n+        _align_hack: [simd::u64x2, ..0], // FIXME align on 16-byte\n+        P1Home: DWORDLONG,\n+        P2Home: DWORDLONG,\n+        P3Home: DWORDLONG,\n+        P4Home: DWORDLONG,\n+        P5Home: DWORDLONG,\n+        P6Home: DWORDLONG,\n+\n+        ContextFlags: DWORD,\n+        MxCsr: DWORD,\n+\n+        SegCs: WORD,\n+        SegDs: WORD,\n+        SegEs: WORD,\n+        SegFs: WORD,\n+        SegGs: WORD,\n+        SegSs: WORD,\n+        EFlags: DWORD,\n+\n+        Dr0: DWORDLONG,\n+        Dr1: DWORDLONG,\n+        Dr2: DWORDLONG,\n+        Dr3: DWORDLONG,\n+        Dr6: DWORDLONG,\n+        Dr7: DWORDLONG,\n+\n+        Rax: DWORDLONG,\n+        Rcx: DWORDLONG,\n+        Rdx: DWORDLONG,\n+        Rbx: DWORDLONG,\n+        Rsp: DWORDLONG,\n+        Rbp: DWORDLONG,\n+        Rsi: DWORDLONG,\n+        Rdi: DWORDLONG,\n+        R8:  DWORDLONG,\n+        R9:  DWORDLONG,\n+        R10: DWORDLONG,\n+        R11: DWORDLONG,\n+        R12: DWORDLONG,\n+        R13: DWORDLONG,\n+        R14: DWORDLONG,\n+        R15: DWORDLONG,\n+\n+        Rip: DWORDLONG,\n+\n+        FltSave: FLOATING_SAVE_AREA,\n+\n+        VectorRegister: [M128A, .. 26],\n+        VectorControl: DWORDLONG,\n+\n+        DebugControl: DWORDLONG,\n+        LastBranchToRip: DWORDLONG,\n+        LastBranchFromRip: DWORDLONG,\n+        LastExceptionToRip: DWORDLONG,\n+        LastExceptionFromRip: DWORDLONG,\n+    }\n+\n+    #[repr(C)]\n+    pub struct M128A {\n+        _align_hack: [simd::u64x2, ..0], // FIXME align on 16-byte\n+        Low:  c_ulonglong,\n+        High: c_longlong\n+    }\n+\n+    #[repr(C)]\n+    pub struct FLOATING_SAVE_AREA {\n+        _align_hack: [simd::u64x2, ..0], // FIXME align on 16-byte\n+        _Dummy: [u8, ..512] // FIXME: Fill this out\n+    }\n+\n+    pub fn init_frame(frame: &mut super::STACKFRAME64,\n+                      ctx: &CONTEXT) -> DWORD {\n+        frame.AddrPC.Offset = ctx.Rip as u64;\n+        frame.AddrPC.Mode = super::ADDRESS_MODE::AddrModeFlat;\n+        frame.AddrStack.Offset = ctx.Rsp as u64;\n+        frame.AddrStack.Mode = super::ADDRESS_MODE::AddrModeFlat;\n+        frame.AddrFrame.Offset = ctx.Rbp as u64;\n+        frame.AddrFrame.Mode = super::ADDRESS_MODE::AddrModeFlat;\n+        super::IMAGE_FILE_MACHINE_AMD64\n+    }\n+}\n+\n+#[repr(C)]\n+struct Cleanup {\n+    handle: libc::HANDLE,\n+    SymCleanup: SymCleanupFn,\n+}\n+\n+impl Drop for Cleanup {\n+    fn drop(&mut self) { (self.SymCleanup)(self.handle); }\n+}\n+\n+pub fn write(w: &mut Writer) -> IoResult<()> {\n+    // According to windows documentation, all dbghelp functions are\n+    // single-threaded.\n+    static LOCK: StaticMutex = MUTEX_INIT;\n+    let _g = unsafe { LOCK.lock() };\n+\n+    // Open up dbghelp.dll, we don't link to it explicitly because it can't\n+    // always be found. Additionally, it's nice having fewer dependencies.\n+    let path = Path::new(\"dbghelp.dll\");\n+    let lib = match DynamicLibrary::open(Some(&path)) {\n+        Ok(lib) => lib,\n+        Err(..) => return Ok(()),\n+    };\n+\n+    macro_rules! sym{ ($e:expr, $t:ident) => (unsafe {\n+        match lib.symbol($e) {\n+            Ok(f) => mem::transmute::<*mut u8, $t>(f),\n+            Err(..) => return Ok(())\n+        }\n+    }) }\n+\n+    // Fetch the symbols necessary from dbghelp.dll\n+    let SymFromAddr = sym!(\"SymFromAddr\", SymFromAddrFn);\n+    let SymInitialize = sym!(\"SymInitialize\", SymInitializeFn);\n+    let SymCleanup = sym!(\"SymCleanup\", SymCleanupFn);\n+    let StackWalk64 = sym!(\"StackWalk64\", StackWalk64Fn);\n+\n+    // Allocate necessary structures for doing the stack walk\n+    let process = unsafe { GetCurrentProcess() };\n+    let thread = unsafe { GetCurrentThread() };\n+    let mut context: arch::CONTEXT = unsafe { intrinsics::init() };\n+    unsafe { RtlCaptureContext(&mut context); }\n+    let mut frame: STACKFRAME64 = unsafe { intrinsics::init() };\n+    let image = arch::init_frame(&mut frame, &context);\n+\n+    // Initialize this process's symbols\n+    let ret = SymInitialize(process, 0 as *mut libc::c_void, libc::TRUE);\n+    if ret != libc::TRUE { return Ok(()) }\n+    let _c = Cleanup { handle: process, SymCleanup: SymCleanup };\n+\n+    // And now that we're done with all the setup, do the stack walking!\n+    let mut i = 0i;\n+    try!(write!(w, \"stack backtrace:\\n\"));\n+    while StackWalk64(image, process, thread, &mut frame, &mut context,\n+                      0 as *mut libc::c_void,\n+                      0 as *mut libc::c_void,\n+                      0 as *mut libc::c_void,\n+                      0 as *mut libc::c_void) == libc::TRUE{\n+        let addr = frame.AddrPC.Offset;\n+        if addr == frame.AddrReturn.Offset || addr == 0 ||\n+           frame.AddrReturn.Offset == 0 { break }\n+\n+        i += 1;\n+        try!(write!(w, \"  {:2}: {:#2$x}\", i, addr, HEX_WIDTH));\n+        let mut info: SYMBOL_INFO = unsafe { intrinsics::init() };\n+        info.MaxNameLen = MAX_SYM_NAME as libc::c_ulong;\n+        // the struct size in C.  the value is different to\n+        // `size_of::<SYMBOL_INFO>() - MAX_SYM_NAME + 1` (== 81)\n+        // due to struct alignment.\n+        info.SizeOfStruct = 88;\n+\n+        let mut displacement = 0u64;\n+        let ret = SymFromAddr(process, addr as u64, &mut displacement,\n+                              &mut info);\n+\n+        if ret == libc::TRUE {\n+            try!(write!(w, \" - \"));\n+            let cstr = unsafe { CString::new(info.Name.as_ptr(), false) };\n+            let bytes = cstr.as_bytes();\n+            match cstr.as_str() {\n+                Some(s) => try!(demangle(w, s)),\n+                None => try!(w.write(bytes[..bytes.len()-1])),\n+            }\n+        }\n+        try!(w.write(&['\\n' as u8]));\n+    }\n+\n+    Ok(())\n+}"}, {"sha": "0fb52c758d5db08063a57ab7e575357d2b37f52a", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -15,7 +15,7 @@ use libc::{mod, c_int};\n \n use c_str::CString;\n use mem;\n-use os::windoze::fill_utf16_buf_and_decode;\n+use sys::os::fill_utf16_buf_and_decode;\n use path;\n use ptr;\n use str;"}, {"sha": "6924687d8c470235bed45caa3f5384fd07fe70db", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -35,6 +35,7 @@ macro_rules! helper_init { (static $name:ident: Helper<$m:ty>) => (\n     };\n ) }\n \n+pub mod backtrace;\n pub mod c;\n pub mod ext;\n pub mod condvar;\n@@ -46,7 +47,9 @@ pub mod pipe;\n pub mod process;\n pub mod rwlock;\n pub mod sync;\n+pub mod stack_overflow;\n pub mod tcp;\n+pub mod thread;\n pub mod thread_local;\n pub mod timer;\n pub mod tty;"}, {"sha": "2fbb9494c710bdba8d1eb57f14ceb352a60e8df9", "filename": "src/libstd/sys/windows/os.rs", "status": "modified", "additions": 198, "deletions": 3, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -8,17 +8,30 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! Implementation of `std::os` functionality for Windows\n+\n // FIXME: move various extern bindings from here into liblibc or\n // something similar\n \n-use libc;\n-use libc::{c_int, c_char, c_void};\n use prelude::*;\n+\n+use fmt;\n use io::{IoResult, IoError};\n+use libc::{c_int, c_char, c_void};\n+use libc;\n+use os;\n+use path::{Path, GenericPath, BytesContainer};\n+use ptr::{mod, RawPtr};\n+use sync::atomic::{AtomicInt, INIT_ATOMIC_INT, SeqCst};\n use sys::fs::FileDesc;\n-use ptr;\n+use option::Option;\n+use option::Option::{Some, None};\n+use slice;\n \n use os::TMPBUF_SZ;\n+use libc::types::os::arch::extra::DWORD;\n+\n+const BUF_BYTES : uint = 2048u;\n \n pub fn errno() -> uint {\n     use libc::types::os::arch::extra::DWORD;\n@@ -101,3 +114,185 @@ pub unsafe fn pipe() -> IoResult<(FileDesc, FileDesc)> {\n         _ => Err(IoError::last_error()),\n     }\n }\n+\n+pub fn fill_utf16_buf_and_decode(f: |*mut u16, DWORD| -> DWORD) -> Option<String> {\n+    unsafe {\n+        let mut n = TMPBUF_SZ as DWORD;\n+        let mut res = None;\n+        let mut done = false;\n+        while !done {\n+            let mut buf = Vec::from_elem(n as uint, 0u16);\n+            let k = f(buf.as_mut_ptr(), n);\n+            if k == (0 as DWORD) {\n+                done = true;\n+            } else if k == n &&\n+                      libc::GetLastError() ==\n+                      libc::ERROR_INSUFFICIENT_BUFFER as DWORD {\n+                n *= 2 as DWORD;\n+            } else if k >= n {\n+                n = k;\n+            } else {\n+                done = true;\n+            }\n+            if k != 0 && done {\n+                let sub = buf.slice(0, k as uint);\n+                // We want to explicitly catch the case when the\n+                // closure returned invalid UTF-16, rather than\n+                // set `res` to None and continue.\n+                let s = String::from_utf16(sub)\n+                    .expect(\"fill_utf16_buf_and_decode: closure created invalid UTF-16\");\n+                res = Some(s)\n+            }\n+        }\n+        return res;\n+    }\n+}\n+\n+pub fn getcwd() -> IoResult<Path> {\n+    use libc::DWORD;\n+    use libc::GetCurrentDirectoryW;\n+    use io::OtherIoError;\n+\n+    let mut buf = [0 as u16, ..BUF_BYTES];\n+    unsafe {\n+        if libc::GetCurrentDirectoryW(buf.len() as DWORD, buf.as_mut_ptr()) == 0 as DWORD {\n+            return Err(IoError::last_error());\n+        }\n+    }\n+\n+    match String::from_utf16(::str::truncate_utf16_at_nul(&buf)) {\n+        Some(ref cwd) => Ok(Path::new(cwd)),\n+        None => Err(IoError {\n+            kind: OtherIoError,\n+            desc: \"GetCurrentDirectoryW returned invalid UTF-16\",\n+            detail: None,\n+        }),\n+    }\n+}\n+\n+pub unsafe fn get_env_pairs() -> Vec<Vec<u8>> {\n+    use libc::funcs::extra::kernel32::{\n+        GetEnvironmentStringsW,\n+        FreeEnvironmentStringsW\n+    };\n+    let ch = GetEnvironmentStringsW();\n+    if ch as uint == 0 {\n+        panic!(\"os::env() failure getting env string from OS: {}\",\n+               os::last_os_error());\n+    }\n+    // Here, we lossily decode the string as UTF16.\n+    //\n+    // The docs suggest that the result should be in Unicode, but\n+    // Windows doesn't guarantee it's actually UTF16 -- it doesn't\n+    // validate the environment string passed to CreateProcess nor\n+    // SetEnvironmentVariable.  Yet, it's unlikely that returning a\n+    // raw u16 buffer would be of practical use since the result would\n+    // be inherently platform-dependent and introduce additional\n+    // complexity to this code.\n+    //\n+    // Using the non-Unicode version of GetEnvironmentStrings is even\n+    // worse since the result is in an OEM code page.  Characters that\n+    // can't be encoded in the code page would be turned into question\n+    // marks.\n+    let mut result = Vec::new();\n+    let mut i = 0;\n+    while *ch.offset(i) != 0 {\n+        let p = &*ch.offset(i);\n+        let mut len = 0;\n+        while *(p as *const _).offset(len) != 0 {\n+            len += 1;\n+        }\n+        let p = p as *const u16;\n+        let s = slice::from_raw_buf(&p, len as uint);\n+        result.push(String::from_utf16_lossy(s).into_bytes());\n+        i += len as int + 1;\n+    }\n+    FreeEnvironmentStringsW(ch);\n+    result\n+}\n+\n+pub fn split_paths(unparsed: &[u8]) -> Vec<Path> {\n+    // On Windows, the PATH environment variable is semicolon separated.  Double\n+    // quotes are used as a way of introducing literal semicolons (since\n+    // c:\\some;dir is a valid Windows path). Double quotes are not themselves\n+    // permitted in path names, so there is no way to escape a double quote.\n+    // Quoted regions can appear in arbitrary locations, so\n+    //\n+    //   c:\\foo;c:\\som\"e;di\"r;c:\\bar\n+    //\n+    // Should parse as [c:\\foo, c:\\some;dir, c:\\bar].\n+    //\n+    // (The above is based on testing; there is no clear reference available\n+    // for the grammar.)\n+\n+    let mut parsed = Vec::new();\n+    let mut in_progress = Vec::new();\n+    let mut in_quote = false;\n+\n+    for b in unparsed.iter() {\n+        match *b {\n+            b';' if !in_quote => {\n+                parsed.push(Path::new(in_progress.as_slice()));\n+                in_progress.truncate(0)\n+            }\n+            b'\"' => {\n+                in_quote = !in_quote;\n+            }\n+            _  => {\n+                in_progress.push(*b);\n+            }\n+        }\n+    }\n+    parsed.push(Path::new(in_progress));\n+    parsed\n+}\n+\n+pub fn join_paths<T: BytesContainer>(paths: &[T]) -> Result<Vec<u8>, &'static str> {\n+    let mut joined = Vec::new();\n+    let sep = b';';\n+\n+    for (i, path) in paths.iter().map(|p| p.container_as_bytes()).enumerate() {\n+        if i > 0 { joined.push(sep) }\n+        if path.contains(&b'\"') {\n+            return Err(\"path segment contains `\\\"`\");\n+        } else if path.contains(&sep) {\n+            joined.push(b'\"');\n+            joined.push_all(path);\n+            joined.push(b'\"');\n+        } else {\n+            joined.push_all(path);\n+        }\n+    }\n+\n+    Ok(joined)\n+}\n+\n+pub fn load_self() -> Option<Vec<u8>> {\n+    unsafe {\n+        fill_utf16_buf_and_decode(|buf, sz| {\n+            libc::GetModuleFileNameW(0u as libc::DWORD, buf, sz)\n+        }).map(|s| s.into_string().into_bytes())\n+    }\n+}\n+\n+pub fn chdir(p: &Path) -> IoResult<()> {\n+    let mut p = p.as_str().unwrap().utf16_units().collect::<Vec<u16>>();\n+    p.push(0);\n+\n+    unsafe {\n+        match libc::SetCurrentDirectoryW(p.as_ptr()) != (0 as libc::BOOL) {\n+            true => Ok(()),\n+            false => Err(IoError::last_error()),\n+        }\n+    }\n+}\n+\n+pub fn page_size() -> uint {\n+    use mem;\n+    unsafe {\n+        let mut info = mem::zeroed();\n+        libc::GetSystemInfo(&mut info);\n+\n+        return info.dwPageSize as uint;\n+    }\n+}"}, {"sha": "bdf2e0bccb1a07695e27b6ccb86d601854a20d96", "filename": "src/libstd/sys/windows/stack_overflow.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -0,0 +1,115 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rt::util::report_overflow;\n+use core::prelude::*;\n+use ptr;\n+use mem;\n+use libc;\n+use libc::types::os::arch::extra::{LPVOID, DWORD, LONG, BOOL};\n+use sys_common::{stack, thread_info};\n+\n+pub struct Handler {\n+    _data: *mut libc::c_void\n+}\n+\n+impl Handler {\n+    pub unsafe fn new() -> Handler {\n+        make_handler()\n+    }\n+}\n+\n+impl Drop for Handler {\n+    fn drop(&mut self) {}\n+}\n+\n+// get_task_info is called from an exception / signal handler.\n+// It returns the guard page of the current task or 0 if that\n+// guard page doesn't exist. None is returned if there's currently\n+// no local task.\n+unsafe fn get_task_guard_page() -> uint {\n+    thread_info::stack_guard()\n+}\n+\n+// This is initialized in init() and only read from after\n+static mut PAGE_SIZE: uint = 0;\n+\n+#[no_stack_check]\n+extern \"system\" fn vectored_handler(ExceptionInfo: *mut EXCEPTION_POINTERS) -> LONG {\n+    unsafe {\n+        let rec = &(*(*ExceptionInfo).ExceptionRecord);\n+        let code = rec.ExceptionCode;\n+\n+        if code != EXCEPTION_STACK_OVERFLOW {\n+            return EXCEPTION_CONTINUE_SEARCH;\n+        }\n+\n+        // We're calling into functions with stack checks,\n+        // however stack checks by limit should be disabled on Windows\n+        stack::record_sp_limit(0);\n+\n+        report_overflow();\n+\n+        EXCEPTION_CONTINUE_SEARCH\n+    }\n+}\n+\n+pub unsafe fn init() {\n+    let mut info = mem::zeroed();\n+    libc::GetSystemInfo(&mut info);\n+    PAGE_SIZE = info.dwPageSize as uint;\n+\n+    if AddVectoredExceptionHandler(0, vectored_handler) == ptr::null_mut() {\n+        panic!(\"failed to install exception handler\");\n+    }\n+\n+    mem::forget(make_handler());\n+}\n+\n+pub unsafe fn cleanup() {\n+}\n+\n+pub unsafe fn make_handler() -> Handler {\n+    if SetThreadStackGuarantee(&mut 0x5000) == 0 {\n+        panic!(\"failed to reserve stack space for exception handling\");\n+    }\n+\n+    Handler { _data: 0i as *mut libc::c_void }\n+}\n+\n+pub struct EXCEPTION_RECORD {\n+    pub ExceptionCode: DWORD,\n+    pub ExceptionFlags: DWORD,\n+    pub ExceptionRecord: *mut EXCEPTION_RECORD,\n+    pub ExceptionAddress: LPVOID,\n+    pub NumberParameters: DWORD,\n+    pub ExceptionInformation: [LPVOID, ..EXCEPTION_MAXIMUM_PARAMETERS]\n+}\n+\n+pub struct EXCEPTION_POINTERS {\n+    pub ExceptionRecord: *mut EXCEPTION_RECORD,\n+    pub ContextRecord: LPVOID\n+}\n+\n+pub type PVECTORED_EXCEPTION_HANDLER = extern \"system\"\n+        fn(ExceptionInfo: *mut EXCEPTION_POINTERS) -> LONG;\n+\n+pub type ULONG = libc::c_ulong;\n+\n+const EXCEPTION_CONTINUE_SEARCH: LONG = 0;\n+const EXCEPTION_MAXIMUM_PARAMETERS: uint = 15;\n+const EXCEPTION_STACK_OVERFLOW: DWORD = 0xc00000fd;\n+\n+extern \"system\" {\n+    fn AddVectoredExceptionHandler(FirstHandler: ULONG,\n+                                   VectoredHandler: PVECTORED_EXCEPTION_HANDLER)\n+                                  -> LPVOID;\n+    fn SetThreadStackGuarantee(StackSizeInBytes: *mut ULONG) -> BOOL;\n+}"}, {"sha": "4498f56c00a1e4adcefdc3e1b21885e1bc4587dd", "filename": "src/libstd/sys/windows/thread.rs", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -0,0 +1,96 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::prelude::*;\n+\n+use boxed::Box;\n+use cmp;\n+use mem;\n+use ptr;\n+use libc;\n+use libc::types::os::arch::extra::{LPSECURITY_ATTRIBUTES, SIZE_T, BOOL,\n+                                   LPVOID, DWORD, LPDWORD, HANDLE};\n+use thunk::Thunk;\n+use sys_common::stack::RED_ZONE;\n+use sys_common::thread::*;\n+\n+pub type rust_thread = HANDLE;\n+pub type rust_thread_return = DWORD;\n+\n+pub type StartFn = extern \"system\" fn(*mut libc::c_void) -> rust_thread_return;\n+\n+#[no_stack_check]\n+pub extern \"system\" fn thread_start(main: *mut libc::c_void) -> rust_thread_return {\n+    return start_thread(main);\n+}\n+\n+pub mod guard {\n+    pub unsafe fn main() -> uint {\n+        0\n+    }\n+\n+    pub unsafe fn current() -> uint {\n+        0\n+    }\n+\n+    pub unsafe fn init() {\n+    }\n+}\n+\n+pub unsafe fn create(stack: uint, p: Thunk) -> rust_thread {\n+    let arg: *mut libc::c_void = mem::transmute(box p);\n+    // FIXME On UNIX, we guard against stack sizes that are too small but\n+    // that's because pthreads enforces that stacks are at least\n+    // PTHREAD_STACK_MIN bytes big.  Windows has no such lower limit, it's\n+    // just that below a certain threshold you can't do anything useful.\n+    // That threshold is application and architecture-specific, however.\n+    // For now, the only requirement is that it's big enough to hold the\n+    // red zone.  Round up to the next 64 kB because that's what the NT\n+    // kernel does, might as well make it explicit.  With the current\n+    // 20 kB red zone, that makes for a 64 kB minimum stack.\n+    let stack_size = (cmp::max(stack, RED_ZONE) + 0xfffe) & (-0xfffe - 1);\n+    let ret = CreateThread(ptr::null_mut(), stack_size as libc::size_t,\n+                           thread_start, arg, 0, ptr::null_mut());\n+\n+    if ret as uint == 0 {\n+        // be sure to not leak the closure\n+        let _p: Box<Thunk> = mem::transmute(arg);\n+        panic!(\"failed to spawn native thread: {}\", ret);\n+    }\n+    return ret;\n+}\n+\n+pub unsafe fn join(native: rust_thread) {\n+    use libc::consts::os::extra::INFINITE;\n+    WaitForSingleObject(native, INFINITE);\n+}\n+\n+pub unsafe fn detach(native: rust_thread) {\n+    assert!(libc::CloseHandle(native) != 0);\n+}\n+\n+pub unsafe fn yield_now() {\n+    // This function will return 0 if there are no other threads to execute,\n+    // but this also means that the yield was useless so this isn't really a\n+    // case that needs to be worried about.\n+    SwitchToThread();\n+}\n+\n+#[allow(non_snake_case)]\n+extern \"system\" {\n+    fn CreateThread(lpThreadAttributes: LPSECURITY_ATTRIBUTES,\n+                    dwStackSize: SIZE_T,\n+                    lpStartAddress: StartFn,\n+                    lpParameter: LPVOID,\n+                    dwCreationFlags: DWORD,\n+                    lpThreadId: LPDWORD) -> HANDLE;\n+    fn WaitForSingleObject(hHandle: HANDLE, dwMilliseconds: DWORD) -> DWORD;\n+    fn SwitchToThread() -> BOOL;\n+}"}, {"sha": "60b0d584db3a7a6936fa8c1f160c19109739d331", "filename": "src/libstd/sys/windows/thread_local.rs", "status": "modified", "additions": 43, "deletions": 22, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -13,9 +13,8 @@ use prelude::*;\n use libc::types::os::arch::extra::{DWORD, LPVOID, BOOL};\n \n use mem;\n-use rustrt;\n-use rustrt::exclusive::Exclusive;\n-use sync::{ONCE_INIT, Once};\n+use rt;\n+use sys_common::mutex::{MUTEX_INIT, Mutex};\n \n pub type Key = DWORD;\n pub type Dtor = unsafe extern fn(*mut u8);\n@@ -54,8 +53,12 @@ pub type Dtor = unsafe extern fn(*mut u8);\n // [2]: https://github.com/ChromiumWebApps/chromium/blob/master/base\n //                        /threading/thread_local_storage_win.cc#L42\n \n-static INIT_DTORS: Once = ONCE_INIT;\n-static mut DTORS: *mut Exclusive<Vec<(Key, Dtor)>> = 0 as *mut _;\n+// NB these are specifically not types from `std::sync` as they currently rely\n+// on poisoning and this module needs to operate at a lower level than requiring\n+// the thread infrastructure to be in place (useful on the borders of\n+// initialization/destruction).\n+static DTOR_LOCK: Mutex = MUTEX_INIT;\n+static mut DTORS: *mut Vec<(Key, Dtor)> = 0 as *mut _;\n \n // -------------------------------------------------------------------------\n // Native bindings\n@@ -125,30 +128,40 @@ extern \"system\" {\n //\n // FIXME: This could probably be at least a little faster with a BTree.\n \n-fn init_dtors() {\n-    let dtors = box Exclusive::new(Vec::<(Key, Dtor)>::new());\n-    unsafe {\n-        DTORS = mem::transmute(dtors);\n-    }\n+unsafe fn init_dtors() {\n+    if !DTORS.is_null() { return }\n+\n+    let dtors = box Vec::<(Key, Dtor)>::new();\n+    DTORS = mem::transmute(dtors);\n \n-    rustrt::at_exit(move|| unsafe {\n-        mem::transmute::<_, Box<Exclusive<Vec<(Key, Dtor)>>>>(DTORS);\n+    rt::at_exit(move|| {\n+        DTOR_LOCK.lock();\n+        let dtors = DTORS;\n         DTORS = 0 as *mut _;\n+        mem::transmute::<_, Box<Vec<(Key, Dtor)>>>(dtors);\n+        assert!(DTORS.is_null()); // can't re-init after destructing\n+        DTOR_LOCK.unlock();\n     });\n }\n \n unsafe fn register_dtor(key: Key, dtor: Dtor) {\n-    INIT_DTORS.doit(init_dtors);\n-    let mut dtors = (*DTORS).lock();\n-    dtors.push((key, dtor));\n+    DTOR_LOCK.lock();\n+    init_dtors();\n+    (*DTORS).push((key, dtor));\n+    DTOR_LOCK.unlock();\n }\n \n unsafe fn unregister_dtor(key: Key) -> bool {\n-    if DTORS.is_null() { return false }\n-    let mut dtors = (*DTORS).lock();\n-    let before = dtors.len();\n-    dtors.retain(|&(k, _)| k != key);\n-    dtors.len() != before\n+    DTOR_LOCK.lock();\n+    init_dtors();\n+    let ret = {\n+        let dtors = &mut *DTORS;\n+        let before = dtors.len();\n+        dtors.retain(|&(k, _)| k != key);\n+        dtors.len() != before\n+    };\n+    DTOR_LOCK.unlock();\n+    ret\n }\n \n // -------------------------------------------------------------------------\n@@ -220,12 +233,20 @@ unsafe extern \"system\" fn on_tls_callback(h: LPVOID,\n }\n \n unsafe fn run_dtors() {\n-    if DTORS.is_null() { return }\n     let mut any_run = true;\n     for _ in range(0, 5i) {\n         if !any_run { break }\n         any_run = false;\n-        let dtors = (*DTORS).lock().iter().map(|p| *p).collect::<Vec<_>>();\n+        let dtors = {\n+            DTOR_LOCK.lock();\n+            let ret = if DTORS.is_null() {\n+                Vec::new()\n+            } else {\n+                (*DTORS).iter().map(|s| *s).collect()\n+            };\n+            DTOR_LOCK.unlock();\n+            ret\n+        };\n         for &(key, dtor) in dtors.iter() {\n             let ptr = TlsGetValue(key);\n             if !ptr.is_null() {"}, {"sha": "0f08108fee547744a2a459253d61e93b7fc03667", "filename": "src/libstd/task.rs", "status": "modified", "additions": 19, "deletions": 518, "changes": 537, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -8,536 +8,37 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Task creation\n-//!\n-//! An executing Rust program consists of a collection of tasks, each\n-//! with their own stack and local state.\n-//!\n-//! Tasks generally have their memory *isolated* from each other by\n-//! virtue of Rust's owned types (which of course may only be owned by\n-//! a single task at a time). Communication between tasks is primarily\n-//! done through [channels](../../std/comm/index.html), Rust's\n-//! message-passing types, though [other forms of task\n-//! synchronization](../../std/sync/index.html) are often employed to\n-//! achieve particular performance goals. In particular, types that\n-//! are guaranteed to be threadsafe are easily shared between threads\n-//! using the atomically-reference-counted container,\n-//! [`Arc`](../../std/sync/struct.Arc.html).\n-//!\n-//! Fatal logic errors in Rust cause *task panic*, during which\n-//! a task will unwind the stack, running destructors and freeing\n-//! owned resources. Task panic is unrecoverable from within\n-//! the panicking task (i.e. there is no 'try/catch' in Rust), but\n-//! panic may optionally be detected from a different task. If\n-//! the main task panics the application will exit with a non-zero\n-//! exit code.\n-//!\n-//! # Examples\n-//!\n-//! ```rust\n-//! spawn(move|| {\n-//!     println!(\"Hello, World!\");\n-//! })\n-//! ```\n+//! Deprecated in favor of `thread`.\n \n-#![unstable = \"The task spawning model will be changed as part of runtime reform, and the module \\\n-               will likely be renamed from `task` to `thread`.\"]\n+#![deprecated = \"use std::thread instead\"]\n \n use any::Any;\n-use borrow::IntoCow;\n use boxed::Box;\n-use comm::channel;\n-use core::ops::FnOnce;\n-use io::{Writer, stdio};\n+use thread;\n use kinds::Send;\n-use option::Option;\n-use option::Option::{None, Some};\n use result::Result;\n-use rustrt::local::Local;\n-use rustrt::task::Task;\n-use rustrt::task;\n-use str::SendStr;\n-use string::{String, ToString};\n-use thunk::{Thunk};\n-use sync::Future;\n+use ops::FnOnce;\n \n-/// The task builder type.\n-///\n-/// Provides detailed control over the properties and behavior of new tasks.\n+/// Deprecate: use `std::thread::Builder` instead.\n+#[deprecated = \"use std::thread::Builder instead\"]\n+pub type TaskBuilder = thread::Builder;\n \n-// NB: Builders are designed to be single-use because they do stateful\n-// things that get weird when reusing - e.g. if you create a result future\n-// it only applies to a single task, so then you have to maintain Some\n-// potentially tricky state to ensure that everything behaves correctly\n-// when you try to reuse the builder to spawn a new task. We'll just\n-// sidestep that whole issue by making builders uncopyable and making\n-// the run function move them in.\n-pub struct TaskBuilder {\n-    // A name for the task-to-be, for identification in panic messages\n-    name: Option<SendStr>,\n-    // The size of the stack for the spawned task\n-    stack_size: Option<uint>,\n-    // Task-local stdout\n-    stdout: Option<Box<Writer + Send>>,\n-    // Task-local stderr\n-    stderr: Option<Box<Writer + Send>>,\n-    // Optionally wrap the eventual task body\n-    gen_body: Option<Thunk<Thunk, Thunk>>,\n+/// Deprecated: use `std::thread::Thread::spawn` and `detach` instead.\n+#[deprecated = \"use std::thread::Thread::spawn and detach instead\"]\n+pub fn spawn<F>(f: F) where F: FnOnce(), F: Send {\n+    thread::Thread::spawn(f).detach();\n }\n \n-impl TaskBuilder {\n-    /// Generate the base configuration for spawning a task, off of which more\n-    /// configuration methods can be chained.\n-    pub fn new() -> TaskBuilder {\n-        TaskBuilder {\n-            name: None,\n-            stack_size: None,\n-            stdout: None,\n-            stderr: None,\n-            gen_body: None,\n-        }\n-    }\n-}\n-\n-impl TaskBuilder {\n-    /// Name the task-to-be. Currently the name is used for identification\n-    /// only in panic messages.\n-    #[unstable = \"IntoMaybeOwned will probably change.\"]\n-    pub fn named<T: IntoCow<'static, String, str>>(mut self, name: T) -> TaskBuilder {\n-        self.name = Some(name.into_cow());\n-        self\n-    }\n-\n-    /// Set the size of the stack for the new task.\n-    pub fn stack_size(mut self, size: uint) -> TaskBuilder {\n-        self.stack_size = Some(size);\n-        self\n-    }\n-\n-    /// Redirect task-local stdout.\n-    #[experimental = \"May not want to make stdio overridable here.\"]\n-    pub fn stdout(mut self, stdout: Box<Writer + Send>) -> TaskBuilder {\n-        self.stdout = Some(stdout);\n-        self\n-    }\n-\n-    /// Redirect task-local stderr.\n-    #[experimental = \"May not want to make stdio overridable here.\"]\n-    pub fn stderr(mut self, stderr: Box<Writer + Send>) -> TaskBuilder {\n-        self.stderr = Some(stderr);\n-        self\n-    }\n-\n-    // Where spawning actually happens (whether yielding a future or not)\n-    fn spawn_internal(\n-        self,\n-        f: Thunk,\n-        on_exit: Option<Thunk<task::Result>>)\n-    {\n-        let TaskBuilder {\n-            name, stack_size, stdout, stderr, mut gen_body\n-        } = self;\n-\n-        let f = match gen_body.take() {\n-            Some(gen) => gen.invoke(f),\n-            None => f\n-        };\n-\n-        let opts = task::TaskOpts {\n-            on_exit: on_exit,\n-            name: name,\n-            stack_size: stack_size,\n-        };\n-        if stdout.is_some() || stderr.is_some() {\n-            Task::spawn(opts, move|:| {\n-                let _ = stdout.map(stdio::set_stdout);\n-                let _ = stderr.map(stdio::set_stderr);\n-                f.invoke(());\n-            });\n-        } else {\n-            Task::spawn(opts, move|:| f.invoke(()))\n-        }\n-    }\n-\n-    /// Creates and executes a new child task.\n-    ///\n-    /// Sets up a new task with its own call stack and schedules it to run\n-    /// the provided function. The task has the properties and behavior\n-    /// specified by the `TaskBuilder`.\n-    pub fn spawn<F:FnOnce()+Send>(self, f: F) {\n-        self.spawn_internal(Thunk::new(f), None)\n-    }\n-\n-    /// Execute a function in a newly-spawned task and return a future representing\n-    /// the task's result. The task has the properties and behavior\n-    /// specified by the `TaskBuilder`.\n-    ///\n-    /// Taking the value of the future will block until the child task\n-    /// terminates.\n-    ///\n-    /// # Return value\n-    ///\n-    /// If the child task executes successfully (without panicking) then the\n-    /// future returns `result::Result::Ok` containing the value returned by the\n-    /// function. If the child task panics then the future returns\n-    /// `result::Result::Err` containing the argument to `panic!(...)` as an\n-    /// `Any` trait object.\n-    #[experimental = \"Futures are experimental.\"]\n-    pub fn try_future<T:Send,F:FnOnce()->(T)+Send>(self, f: F)\n-                                                   -> Future<Result<T, Box<Any + Send>>> {\n-        // currently, the on_exit fn provided by librustrt only works for unit\n-        // results, so we use an additional side-channel to communicate the\n-        // result.\n-\n-        let (tx_done, rx_done) = channel(); // signal that task has exited\n-        let (tx_retv, rx_retv) = channel(); // return value from task\n-\n-        let on_exit: Thunk<task::Result> = Thunk::with_arg(move |: res: task::Result| {\n-            let _ = tx_done.send_opt(res);\n-        });\n-        self.spawn_internal(Thunk::new(move |:| { let _ = tx_retv.send_opt(f()); }),\n-                            Some(on_exit));\n-\n-        Future::from_fn(move|:| {\n-            rx_done.recv().map(|_| rx_retv.recv())\n-        })\n-    }\n-\n-    /// Execute a function in a newly-spawnedtask and block until the task\n-    /// completes or panics. Equivalent to `.try_future(f).unwrap()`.\n-    #[unstable = \"Error type may change.\"]\n-    pub fn try<T,F>(self, f: F) -> Result<T, Box<Any + Send>>\n-        where F : FnOnce() -> T, F : Send, T : Send\n-    {\n-        self.try_future(f).into_inner()\n-    }\n-}\n-\n-/* Convenience functions */\n-\n-/// Creates and executes a new child task\n-///\n-/// Sets up a new task with its own call stack and schedules it to run\n-/// the provided unique closure.\n-///\n-/// This function is equivalent to `TaskBuilder::new().spawn(f)`.\n-pub fn spawn<F:FnOnce()+Send>(f: F) {\n-    TaskBuilder::new().spawn(f)\n-}\n-\n-/// Execute a function in a newly-spawned task and return either the return\n-/// value of the function or an error if the task panicked.\n-///\n-/// This is equivalent to `TaskBuilder::new().try`.\n-#[unstable = \"Error type may change.\"]\n-pub fn try<T,F>(f: F) -> Result<T, Box<Any + Send>>\n-    where T : Send, F : FnOnce() -> T, F : Send\n-{\n-    TaskBuilder::new().try(f)\n-}\n-\n-/// Execute a function in another task and return a future representing the\n-/// task's result.\n-///\n-/// This is equivalent to `TaskBuilder::new().try_future`.\n-#[experimental = \"Futures are experimental.\"]\n-pub fn try_future<T,F>(f: F) -> Future<Result<T, Box<Any + Send>>>\n-    where T:Send, F:FnOnce()->T, F:Send\n+/// Deprecated: use `std::thread::Thread::spawn` and `join` instead.\n+#[deprecated = \"use std::thread::Thread::spawn and join instead\"]\n+pub fn try<T, F>(f: F) -> Result<T, Box<Any + Send>> where\n+    T: Send, F: FnOnce() -> T, F: Send\n {\n-    TaskBuilder::new().try_future(f)\n-}\n-\n-/* Lifecycle functions */\n-\n-/// Read the name of the current task.\n-#[stable]\n-pub fn name() -> Option<String> {\n-    use rustrt::task::Task;\n-\n-    let task = Local::borrow(None::<Task>);\n-    match task.name {\n-        Some(ref name) => Some(name.to_string()),\n-        None => None\n-    }\n+    thread::Thread::spawn(f).join()\n }\n \n-/// Yield control to the task scheduler.\n-#[unstable = \"Name will change.\"]\n+/// Deprecated: use `std::thread::Thread::yield_now instead`.\n+#[deprecated = \"use std::thread::Thread::yield_now instead\"]\n pub fn deschedule() {\n-    use rustrt::task::Task;\n-    Task::yield_now();\n-}\n-\n-/// True if the running task is currently panicking (e.g. will return `true` inside a\n-/// destructor that is run while unwinding the stack after a call to `panic!()`).\n-#[unstable = \"May move to a different module.\"]\n-pub fn failing() -> bool {\n-    use rustrt::task::Task;\n-    Local::borrow(None::<Task>).unwinder.unwinding()\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use any::{Any, AnyRefExt};\n-    use borrow::IntoCow;\n-    use boxed::BoxAny;\n-    use prelude::*;\n-    use result::Result::{Ok, Err};\n-    use result;\n-    use std::io::{ChanReader, ChanWriter};\n-    use string::String;\n-    use thunk::Thunk;\n-    use prelude::*;\n-    use super::*;\n-\n-    // !!! These tests are dangerous. If something is buggy, they will hang, !!!\n-    // !!! instead of exiting cleanly. This might wedge the buildbots.       !!!\n-\n-    #[test]\n-    fn test_unnamed_task() {\n-        try(move|| {\n-            assert!(name().is_none());\n-        }).map_err(|_| ()).unwrap();\n-    }\n-\n-    #[test]\n-    fn test_owned_named_task() {\n-        TaskBuilder::new().named(\"ada lovelace\".to_string()).try(move|| {\n-            assert!(name().unwrap() == \"ada lovelace\");\n-        }).map_err(|_| ()).unwrap();\n-    }\n-\n-    #[test]\n-    fn test_static_named_task() {\n-        TaskBuilder::new().named(\"ada lovelace\").try(move|| {\n-            assert!(name().unwrap() == \"ada lovelace\");\n-        }).map_err(|_| ()).unwrap();\n-    }\n-\n-    #[test]\n-    fn test_send_named_task() {\n-        TaskBuilder::new().named(\"ada lovelace\".into_cow()).try(move|| {\n-            assert!(name().unwrap() == \"ada lovelace\");\n-        }).map_err(|_| ()).unwrap();\n-    }\n-\n-    #[test]\n-    fn test_run_basic() {\n-        let (tx, rx) = channel();\n-        TaskBuilder::new().spawn(move|| {\n-            tx.send(());\n-        });\n-        rx.recv();\n-    }\n-\n-    #[test]\n-    fn test_try_future() {\n-        let result = TaskBuilder::new().try_future(move|| {});\n-        assert!(result.unwrap().is_ok());\n-\n-        let result = TaskBuilder::new().try_future(move|| -> () {\n-            panic!();\n-        });\n-        assert!(result.unwrap().is_err());\n-    }\n-\n-    #[test]\n-    fn test_try_success() {\n-        match try(move|| {\n-            \"Success!\".to_string()\n-        }).as_ref().map(|s| s.as_slice()) {\n-            result::Result::Ok(\"Success!\") => (),\n-            _ => panic!()\n-        }\n-    }\n-\n-    #[test]\n-    fn test_try_panic() {\n-        match try(move|| {\n-            panic!()\n-        }) {\n-            result::Result::Err(_) => (),\n-            result::Result::Ok(()) => panic!()\n-        }\n-    }\n-\n-    #[test]\n-    fn test_spawn_sched() {\n-        use clone::Clone;\n-\n-        let (tx, rx) = channel();\n-\n-        fn f(i: int, tx: Sender<()>) {\n-            let tx = tx.clone();\n-            spawn(move|| {\n-                if i == 0 {\n-                    tx.send(());\n-                } else {\n-                    f(i - 1, tx);\n-                }\n-            });\n-\n-        }\n-        f(10, tx);\n-        rx.recv();\n-    }\n-\n-    #[test]\n-    fn test_spawn_sched_childs_on_default_sched() {\n-        let (tx, rx) = channel();\n-\n-        spawn(move|| {\n-            spawn(move|| {\n-                tx.send(());\n-            });\n-        });\n-\n-        rx.recv();\n-    }\n-\n-    fn avoid_copying_the_body<F>(spawnfn: F) where\n-        F: FnOnce(Thunk),\n-    {\n-        let (tx, rx) = channel::<uint>();\n-\n-        let x = box 1;\n-        let x_in_parent = (&*x) as *const int as uint;\n-\n-        spawnfn(Thunk::new(move|| {\n-            let x_in_child = (&*x) as *const int as uint;\n-            tx.send(x_in_child);\n-        }));\n-\n-        let x_in_child = rx.recv();\n-        assert_eq!(x_in_parent, x_in_child);\n-    }\n-\n-    #[test]\n-    fn test_avoid_copying_the_body_spawn() {\n-        avoid_copying_the_body(|t| spawn(move|| t.invoke(())));\n-    }\n-\n-    #[test]\n-    fn test_avoid_copying_the_body_task_spawn() {\n-        avoid_copying_the_body(|f| {\n-            let builder = TaskBuilder::new();\n-            builder.spawn(move|| f.invoke(()));\n-        })\n-    }\n-\n-    #[test]\n-    fn test_avoid_copying_the_body_try() {\n-        avoid_copying_the_body(|f| {\n-            let _ = try(move|| f.invoke(()));\n-        })\n-    }\n-\n-    #[test]\n-    fn test_child_doesnt_ref_parent() {\n-        // If the child refcounts the parent task, this will stack overflow when\n-        // climbing the task tree to dereference each ancestor. (See #1789)\n-        // (well, it would if the constant were 8000+ - I lowered it to be more\n-        // valgrind-friendly. try this at home, instead..!)\n-        static GENERATIONS: uint = 16;\n-        fn child_no(x: uint) -> Thunk {\n-            return Thunk::new(move|| {\n-                if x < GENERATIONS {\n-                    TaskBuilder::new().spawn(move|| child_no(x+1).invoke(()));\n-                }\n-            });\n-        }\n-        TaskBuilder::new().spawn(|| child_no(0).invoke(()));\n-    }\n-\n-    #[test]\n-    fn test_simple_newsched_spawn() {\n-        spawn(move|| ())\n-    }\n-\n-    #[test]\n-    fn test_try_panic_message_static_str() {\n-        match try(move|| {\n-            panic!(\"static string\");\n-        }) {\n-            Err(e) => {\n-                type T = &'static str;\n-                assert!(e.is::<T>());\n-                assert_eq!(*e.downcast::<T>().unwrap(), \"static string\");\n-            }\n-            Ok(()) => panic!()\n-        }\n-    }\n-\n-    #[test]\n-    fn test_try_panic_message_owned_str() {\n-        match try(move|| {\n-            panic!(\"owned string\".to_string());\n-        }) {\n-            Err(e) => {\n-                type T = String;\n-                assert!(e.is::<T>());\n-                assert_eq!(*e.downcast::<T>().unwrap(), \"owned string\");\n-            }\n-            Ok(()) => panic!()\n-        }\n-    }\n-\n-    #[test]\n-    fn test_try_panic_message_any() {\n-        match try(move|| {\n-            panic!(box 413u16 as Box<Any + Send>);\n-        }) {\n-            Err(e) => {\n-                type T = Box<Any + Send>;\n-                assert!(e.is::<T>());\n-                let any = e.downcast::<T>().unwrap();\n-                assert!(any.is::<u16>());\n-                assert_eq!(*any.downcast::<u16>().unwrap(), 413u16);\n-            }\n-            Ok(()) => panic!()\n-        }\n-    }\n-\n-    #[test]\n-    fn test_try_panic_message_unit_struct() {\n-        struct Juju;\n-\n-        match try(move|| {\n-            panic!(Juju)\n-        }) {\n-            Err(ref e) if e.is::<Juju>() => {}\n-            Err(_) | Ok(()) => panic!()\n-        }\n-    }\n-\n-    #[test]\n-    fn test_stdout() {\n-        let (tx, rx) = channel();\n-        let mut reader = ChanReader::new(rx);\n-        let stdout = ChanWriter::new(tx);\n-\n-        let r = TaskBuilder::new().stdout(box stdout as Box<Writer + Send>)\n-                                  .try(move|| {\n-                print!(\"Hello, world!\");\n-            });\n-        assert!(r.is_ok());\n-\n-        let output = reader.read_to_string().unwrap();\n-        assert_eq!(output, \"Hello, world!\");\n-    }\n-\n-    // NOTE: the corresponding test for stderr is in run-pass/task-stderr, due\n-    // to the test harness apparently interfering with stderr configuration.\n-}\n-\n-#[test]\n-fn task_abort_no_kill_runtime() {\n-    use std::io::timer;\n-    use time::Duration;\n-    use mem;\n-\n-    let tb = TaskBuilder::new();\n-    let rx = tb.try_future(move|| {});\n-    mem::drop(rx);\n-    timer::sleep(Duration::milliseconds(1000));\n+    thread::Thread::yield_now()\n }"}, {"sha": "8ef53a22aeb04c765f2ae6ecd2165df40ae054eb", "filename": "src/libstd/thread.rs", "status": "added", "additions": 652, "deletions": 0, "changes": 652, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -0,0 +1,652 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Native threads\n+//!\n+//! ## The threading model\n+//!\n+//! An executing Rust program consists of a collection of native OS threads,\n+//! each with their own stack and local state.\n+//!\n+//! Communication between threads can be done through\n+//! [channels](../../std/comm/index.html), Rust's message-passing\n+//! types, along with [other forms of thread\n+//! synchronization](../../std/sync/index.html) and shared-memory data\n+//! structures. In particular, types that are guaranteed to be\n+//! threadsafe are easily shared between threads using the\n+//! atomically-reference-counted container,\n+//! [`Arc`](../../std/sync/struct.Arc.html).\n+//!\n+//! Fatal logic errors in Rust cause *thread panic*, during which\n+//! a thread will unwind the stack, running destructors and freeing\n+//! owned resources. Thread panic is unrecoverable from within\n+//! the panicking thread (i.e. there is no 'try/catch' in Rust), but\n+//! panic may optionally be detected from a different thread. If\n+//! the main thread panics the application will exit with a non-zero\n+//! exit code.\n+//!\n+//! When the main thread of a Rust program terminates, the entire program shuts\n+//! down, even if other threads are still running. However, this module provides\n+//! convenient facilities for automatically waiting for the termination of a\n+//! child thread (i.e., join), described below.\n+//!\n+//! ## The `Thread` type\n+//!\n+//! Already-running threads are represented via the `Thread` type, which you can\n+//! get in one of two ways:\n+//!\n+//! * By spawning a new thread, e.g. using the `Thread::spawn` constructor;\n+//! * By requesting the current thread, using the `Thread::current` function.\n+//!\n+//! Threads can be named, and provide some built-in support for low-level\n+//! synchronization described below.\n+//!\n+//! The `Thread::current()` function is available even for threads not spawned\n+//! by the APIs of this module.\n+//!\n+//! ## Spawning a thread\n+//!\n+//! A new thread can be spawned using the `Thread::spawn` function:\n+//!\n+//! ```rust\n+//! use std::thread::Thread;\n+//!\n+//! let guard = Thread::spawn(move || {\n+//!     println!(\"Hello, World!\");\n+//!     // some computation here\n+//! });\n+//! let result = guard.join();\n+//! ```\n+//!\n+//! The `spawn` function doesn't return a `Thread` directly; instead, it returns\n+//! a *join guard* from which a `Thread` can be extracted. The join guard is an\n+//! RAII-style guard that will automatically join the child thread (block until\n+//! it terminates) when it is dropped. You can join the child thread in advance\n+//! by calling the `join` method on the guard, which will also return the result\n+//! produced by the thread.\n+//!\n+//! If you instead wish to *detach* the child thread, allowing it to outlive its\n+//! parent, you can use the `detach` method on the guard,\n+//!\n+//! A handle to the thread itself is available via the `thread` method on the\n+//! join guard.\n+//!\n+//! ## Configuring threads\n+//!\n+//! A new thread can be configured before it is spawned via the `Builder` type,\n+//! which currently allows you to set the name, stack size, and writers for\n+//! `println!` and `panic!` for the child thread:\n+//!\n+//! ```rust\n+//! use std::thread;\n+//!\n+//! thread::Builder::new().name(\"child1\".to_string()).spawn(move || {\n+//!     println!(\"Hello, world!\")\n+//! }).detach();\n+//! ```\n+//!\n+//! ## Blocking support: park and unpark\n+//!\n+//! Every thread is equipped with some basic low-level blocking support, via the\n+//! `park` and `unpark` functions.\n+//!\n+//! Conceptually, each `Thread` handle has an associated token, which is\n+//! initially not present:\n+//!\n+//! * The `Thread::park()` function blocks the current thread unless or until\n+//!   the token is available for its thread handle, at which point It atomically\n+//!   consumes the token. It may also return *spuriously*, without consuming the\n+//!   token.\n+//!\n+//! * The `unpark()` method on a `Thread` atomically makes the token available\n+//!   if it wasn't already.\n+//!\n+//! In other words, each `Thread` acts a bit like a semaphore with initial count\n+//! 0, except that the semaphore is *saturating* (the count cannot go above 1),\n+//! and can return spuriously.\n+//!\n+//! The API is typically used by acquiring a handle to the current thread,\n+//! placing that handle in a shared data structure so that other threads can\n+//! find it, and then `park`ing. When some desired condition is met, another\n+//! thread calls `unpark` on the handle.\n+//!\n+//! The motivation for this design is twofold:\n+//!\n+//! * It avoids the need to allocate mutexes and condvars when building new\n+//!   synchronization primitives; the threads already provide basic blocking/signaling.\n+//!\n+//! * It can be implemented highly efficiently on many platforms.\n+\n+use core::prelude::*;\n+\n+use any::Any;\n+use borrow::IntoCow;\n+use boxed::Box;\n+use cell::UnsafeCell;\n+use sync::{Mutex, Condvar, Arc};\n+use string::String;\n+use rt::{mod, unwind};\n+use io::{Writer, stdio};\n+use thunk::Thunk;\n+\n+use sys::thread as imp;\n+use sys_common::{stack, thread_info};\n+\n+/// Thread configuation. Provides detailed control over the properties\n+/// and behavior of new threads.\n+pub struct Builder {\n+    // A name for the thread-to-be, for identification in panic messages\n+    name: Option<String>,\n+    // The size of the stack for the spawned thread\n+    stack_size: Option<uint>,\n+    // Thread-local stdout\n+    stdout: Option<Box<Writer + Send>>,\n+    // Thread-local stderr\n+    stderr: Option<Box<Writer + Send>>,\n+}\n+\n+impl Builder {\n+    /// Generate the base configuration for spawning a thread, from which\n+    /// configuration methods can be chained.\n+    pub fn new() -> Builder {\n+        Builder {\n+            name: None,\n+            stack_size: None,\n+            stdout: None,\n+            stderr: None,\n+        }\n+    }\n+\n+    /// Name the thread-to-be. Currently the name is used for identification\n+    /// only in panic messages.\n+    pub fn name(mut self, name: String) -> Builder {\n+        self.name = Some(name);\n+        self\n+    }\n+\n+    /// Deprecated: use `name` instead\n+    #[deprecated = \"use name instead\"]\n+    pub fn named<T: IntoCow<'static, String, str>>(self, name: T) -> Builder {\n+        self.name(name.into_cow().into_owned())\n+    }\n+\n+    /// Set the size of the stack for the new thread.\n+    pub fn stack_size(mut self, size: uint) -> Builder {\n+        self.stack_size = Some(size);\n+        self\n+    }\n+\n+    /// Redirect thread-local stdout.\n+    #[experimental = \"Will likely go away after proc removal\"]\n+    pub fn stdout(mut self, stdout: Box<Writer + Send>) -> Builder {\n+        self.stdout = Some(stdout);\n+        self\n+    }\n+\n+    /// Redirect thread-local stderr.\n+    #[experimental = \"Will likely go away after proc removal\"]\n+    pub fn stderr(mut self, stderr: Box<Writer + Send>) -> Builder {\n+        self.stderr = Some(stderr);\n+        self\n+    }\n+\n+    /// Spawn a new joinable thread, and return a JoinGuard guard for it.\n+    ///\n+    /// See `Thead::spawn` and the module doc for more details.\n+    pub fn spawn<T, F>(self, f: F) -> JoinGuard<T> where\n+        T: Send, F: FnOnce() -> T, F: Send\n+    {\n+        self.spawn_inner(Thunk::new(f))\n+    }\n+\n+    fn spawn_inner<T: Send>(self, f: Thunk<(), T>) -> JoinGuard<T> {\n+        let my_packet = Arc::new(UnsafeCell::new(None));\n+        let their_packet = my_packet.clone();\n+\n+        let Builder { name, stack_size, stdout, stderr } = self;\n+\n+        let stack_size = stack_size.unwrap_or(rt::min_stack());\n+        let my_thread = Thread::new(name);\n+        let their_thread = my_thread.clone();\n+\n+        // Spawning a new OS thread guarantees that __morestack will never get\n+        // triggered, but we must manually set up the actual stack bounds once\n+        // this function starts executing. This raises the lower limit by a bit\n+        // because by the time that this function is executing we've already\n+        // consumed at least a little bit of stack (we don't know the exact byte\n+        // address at which our stack started).\n+        let main = move |:| {\n+            let something_around_the_top_of_the_stack = 1;\n+            let addr = &something_around_the_top_of_the_stack as *const int;\n+            let my_stack_top = addr as uint;\n+            let my_stack_bottom = my_stack_top - stack_size + 1024;\n+            unsafe {\n+                stack::record_os_managed_stack_bounds(my_stack_bottom, my_stack_top);\n+            }\n+            thread_info::set(\n+                (my_stack_bottom, my_stack_top),\n+                unsafe { imp::guard::current() },\n+                their_thread\n+            );\n+\n+            let mut output = None;\n+            let f: Thunk<(), T> = if stdout.is_some() || stderr.is_some() {\n+                Thunk::new(move |:| {\n+                    let _ = stdout.map(stdio::set_stdout);\n+                    let _ = stderr.map(stdio::set_stderr);\n+                    f.invoke(())\n+                })\n+            } else {\n+                f\n+            };\n+\n+            let try_result = {\n+                let ptr = &mut output;\n+\n+                // There are two primary reasons that general try/catch is\n+                // unsafe. The first is that we do not support nested\n+                // try/catch. The fact that this is happening in a newly-spawned\n+                // thread suffices. The second is that unwinding while unwinding\n+                // is not defined.  We take care of that by having an\n+                // 'unwinding' flag in the thread itself. For these reasons,\n+                // this unsafety should be ok.\n+                unsafe {\n+                    unwind::try(move || *ptr = Some(f.invoke(())))\n+                }\n+            };\n+            unsafe {\n+                *their_packet.get() = Some(match (output, try_result) {\n+                    (Some(data), Ok(_)) => Ok(data),\n+                    (None, Err(cause)) => Err(cause),\n+                    _ => unreachable!()\n+                });\n+            }\n+        };\n+\n+        JoinGuard {\n+            native: unsafe { imp::create(stack_size, Thunk::new(main)) },\n+            joined: false,\n+            packet: my_packet,\n+            thread: my_thread,\n+        }\n+    }\n+}\n+\n+struct Inner {\n+    name: Option<String>,\n+    lock: Mutex<bool>,          // true when there is a buffered unpark\n+    cvar: Condvar,\n+}\n+\n+#[deriving(Clone)]\n+/// A handle to a thread.\n+pub struct Thread {\n+    inner: Arc<Inner>,\n+}\n+\n+impl Thread {\n+    // Used only internally to construct a thread object without spawning\n+    fn new(name: Option<String>) -> Thread {\n+        Thread {\n+            inner: Arc::new(Inner {\n+                name: name,\n+                lock: Mutex::new(false),\n+                cvar: Condvar::new(),\n+            })\n+        }\n+    }\n+\n+    /// Spawn a new joinable thread, returning a `JoinGuard` for it.\n+    ///\n+    /// The join guard can be used to explicitly join the child thead (via\n+    /// `join`), returning `Result<T>`, or it will implicitly join the child\n+    /// upon being dropped. To detach the child, allowing it to outlive the\n+    /// current thread, use `detach`.  See the module documentation for additional details.\n+    pub fn spawn<T, F>(f: F) -> JoinGuard<T> where\n+        T: Send, F: FnOnce() -> T, F: Send\n+    {\n+        Builder::new().spawn(f)\n+    }\n+\n+    /// Gets a handle to the thread that invokes it.\n+    pub fn current() -> Thread {\n+        thread_info::current_thread()\n+    }\n+\n+    /// Cooperatively give up a timeslice to the OS scheduler.\n+    pub fn yield_now() {\n+        unsafe { imp::yield_now() }\n+    }\n+\n+    /// Determines whether the current thread is panicking.\n+    pub fn panicking() -> bool {\n+        unwind::panicking()\n+    }\n+\n+    /// Block unless or until the current thread's token is made available (may wake spuriously).\n+    ///\n+    /// See the module doc for more detail.\n+    //\n+    // The implementation currently uses the trivial strategy of a Mutex+Condvar\n+    // with wakeup flag, which does not actually allow spurious wakeups. In the\n+    // future, this will be implemented in a more efficient way, perhaps along the lines of\n+    //   http://cr.openjdk.java.net/~stefank/6989984.1/raw_files/new/src/os/linux/vm/os_linux.cpp\n+    // or futuxes, and in either case may allow spurious wakeups.\n+    pub fn park() {\n+        let thread = Thread::current();\n+        let mut guard = thread.inner.lock.lock();\n+        while !*guard {\n+            thread.inner.cvar.wait(&guard);\n+        }\n+        *guard = false;\n+    }\n+\n+    /// Atomically makes the handle's token available if it is not already.\n+    ///\n+    /// See the module doc for more detail.\n+    pub fn unpark(&self) {\n+        let mut guard = self.inner.lock.lock();\n+        if !*guard {\n+            *guard = true;\n+            self.inner.cvar.notify_one();\n+        }\n+    }\n+\n+    /// Get the thread's name.\n+    pub fn name(&self) -> Option<&str> {\n+        self.inner.name.as_ref().map(|s| s.as_slice())\n+    }\n+}\n+\n+// a hack to get around privacy restrictions\n+impl thread_info::NewThread for Thread {\n+    fn new(name: Option<String>) -> Thread { Thread::new(name) }\n+}\n+\n+/// Indicates the manner in which a thread exited.\n+///\n+/// A thread that completes without panicking is considered to exit successfully.\n+pub type Result<T> = ::result::Result<T, Box<Any + Send>>;\n+\n+#[must_use]\n+/// An RAII-style guard that will block until thread termination when dropped.\n+///\n+/// The type `T` is the return type for the thread's main function.\n+pub struct JoinGuard<T> {\n+    native: imp::rust_thread,\n+    thread: Thread,\n+    joined: bool,\n+    packet: Arc<UnsafeCell<Option<Result<T>>>>,\n+}\n+\n+impl<T: Send> JoinGuard<T> {\n+    /// Extract a handle to the thread this guard will join on.\n+    pub fn thread(&self) -> &Thread {\n+        &self.thread\n+    }\n+\n+    /// Wait for the associated thread to finish, returning the result of the thread's\n+    /// calculation.\n+    ///\n+    /// If the child thread panics, `Err` is returned with the parameter given\n+    /// to `panic`.\n+    pub fn join(mut self) -> Result<T> {\n+        assert!(!self.joined);\n+        unsafe { imp::join(self.native) };\n+        self.joined = true;\n+        unsafe {\n+            (*self.packet.get()).take().unwrap()\n+        }\n+    }\n+\n+    /// Detaches the child thread, allowing it to outlive its parent.\n+    pub fn detach(mut self) {\n+        unsafe { imp::detach(self.native) };\n+        self.joined = true; // avoid joining in the destructor\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<T: Send> Drop for JoinGuard<T> {\n+    fn drop(&mut self) {\n+        if !self.joined {\n+            unsafe { imp::join(self.native) };\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use any::{Any, AnyRefExt};\n+    use boxed::BoxAny;\n+    use prelude::*;\n+    use result::Result::{Ok, Err};\n+    use result;\n+    use std::io::{ChanReader, ChanWriter};\n+    use string::String;\n+    use thunk::Thunk;\n+    use super::{Thread, Builder};\n+\n+    // !!! These tests are dangerous. If something is buggy, they will hang, !!!\n+    // !!! instead of exiting cleanly. This might wedge the buildbots.       !!!\n+\n+    #[test]\n+    fn test_unnamed_thread() {\n+        Thread::spawn(move|| {\n+            assert!(Thread::current().name().is_none());\n+        }).join().map_err(|_| ()).unwrap();\n+    }\n+\n+    #[test]\n+    fn test_named_thread() {\n+        Builder::new().name(\"ada lovelace\".to_string()).spawn(move|| {\n+            assert!(Thread::current().name().unwrap() == \"ada lovelace\".to_string());\n+        }).join().map_err(|_| ()).unwrap();\n+    }\n+\n+    #[test]\n+    fn test_run_basic() {\n+        let (tx, rx) = channel();\n+        Thread::spawn(move|| {\n+            tx.send(());\n+        }).detach();\n+        rx.recv();\n+    }\n+\n+    #[test]\n+    fn test_join_success() {\n+        match Thread::spawn(move|| -> String {\n+            \"Success!\".to_string()\n+        }).join().as_ref().map(|s| s.as_slice()) {\n+            result::Result::Ok(\"Success!\") => (),\n+            _ => panic!()\n+        }\n+    }\n+\n+    #[test]\n+    fn test_join_panic() {\n+        match Thread::spawn(move|| {\n+            panic!()\n+        }).join() {\n+            result::Result::Err(_) => (),\n+            result::Result::Ok(()) => panic!()\n+        }\n+    }\n+\n+    #[test]\n+    fn test_spawn_sched() {\n+        use clone::Clone;\n+\n+        let (tx, rx) = channel();\n+\n+        fn f(i: int, tx: Sender<()>) {\n+            let tx = tx.clone();\n+            Thread::spawn(move|| {\n+                if i == 0 {\n+                    tx.send(());\n+                } else {\n+                    f(i - 1, tx);\n+                }\n+            }).detach();\n+\n+        }\n+        f(10, tx);\n+        rx.recv();\n+    }\n+\n+    #[test]\n+    fn test_spawn_sched_childs_on_default_sched() {\n+        let (tx, rx) = channel();\n+\n+        Thread::spawn(move|| {\n+            Thread::spawn(move|| {\n+                tx.send(());\n+            }).detach();\n+        }).detach();\n+\n+        rx.recv();\n+    }\n+\n+    fn avoid_copying_the_body<F>(spawnfn: F) where F: FnOnce(Thunk) {\n+        let (tx, rx) = channel::<uint>();\n+\n+        let x = box 1;\n+        let x_in_parent = (&*x) as *const int as uint;\n+\n+        spawnfn(Thunk::new(move|| {\n+            let x_in_child = (&*x) as *const int as uint;\n+            tx.send(x_in_child);\n+        }));\n+\n+        let x_in_child = rx.recv();\n+        assert_eq!(x_in_parent, x_in_child);\n+    }\n+\n+    #[test]\n+    fn test_avoid_copying_the_body_spawn() {\n+        avoid_copying_the_body(|v| {\n+            Thread::spawn(move || v.invoke(())).detach();\n+        });\n+    }\n+\n+    #[test]\n+    fn test_avoid_copying_the_body_thread_spawn() {\n+        avoid_copying_the_body(|f| {\n+            Thread::spawn(move|| {\n+                f.invoke(());\n+            }).detach();\n+        })\n+    }\n+\n+    #[test]\n+    fn test_avoid_copying_the_body_join() {\n+        avoid_copying_the_body(|f| {\n+            let _ = Thread::spawn(move|| {\n+                f.invoke(())\n+            }).join();\n+        })\n+    }\n+\n+    #[test]\n+    fn test_child_doesnt_ref_parent() {\n+        // If the child refcounts the parent task, this will stack overflow when\n+        // climbing the task tree to dereference each ancestor. (See #1789)\n+        // (well, it would if the constant were 8000+ - I lowered it to be more\n+        // valgrind-friendly. try this at home, instead..!)\n+        static GENERATIONS: uint = 16;\n+        fn child_no(x: uint) -> Thunk {\n+            return Thunk::new(move|| {\n+                if x < GENERATIONS {\n+                    Thread::spawn(move|| child_no(x+1).invoke(())).detach();\n+                }\n+            });\n+        }\n+        Thread::spawn(|| child_no(0).invoke(())).detach();\n+    }\n+\n+    #[test]\n+    fn test_simple_newsched_spawn() {\n+        Thread::spawn(move || {}).detach();\n+    }\n+\n+    #[test]\n+    fn test_try_panic_message_static_str() {\n+        match Thread::spawn(move|| {\n+            panic!(\"static string\");\n+        }).join() {\n+            Err(e) => {\n+                type T = &'static str;\n+                assert!(e.is::<T>());\n+                assert_eq!(*e.downcast::<T>().unwrap(), \"static string\");\n+            }\n+            Ok(()) => panic!()\n+        }\n+    }\n+\n+    #[test]\n+    fn test_try_panic_message_owned_str() {\n+        match Thread::spawn(move|| {\n+            panic!(\"owned string\".to_string());\n+        }).join() {\n+            Err(e) => {\n+                type T = String;\n+                assert!(e.is::<T>());\n+                assert_eq!(*e.downcast::<T>().unwrap(), \"owned string\".to_string());\n+            }\n+            Ok(()) => panic!()\n+        }\n+    }\n+\n+    #[test]\n+    fn test_try_panic_message_any() {\n+        match Thread::spawn(move|| {\n+            panic!(box 413u16 as Box<Any + Send>);\n+        }).join() {\n+            Err(e) => {\n+                type T = Box<Any + Send>;\n+                assert!(e.is::<T>());\n+                let any = e.downcast::<T>().unwrap();\n+                assert!(any.is::<u16>());\n+                assert_eq!(*any.downcast::<u16>().unwrap(), 413u16);\n+            }\n+            Ok(()) => panic!()\n+        }\n+    }\n+\n+    #[test]\n+    fn test_try_panic_message_unit_struct() {\n+        struct Juju;\n+\n+        match Thread::spawn(move|| {\n+            panic!(Juju)\n+        }).join() {\n+            Err(ref e) if e.is::<Juju>() => {}\n+            Err(_) | Ok(()) => panic!()\n+        }\n+    }\n+\n+    #[test]\n+    fn test_stdout() {\n+        let (tx, rx) = channel();\n+        let mut reader = ChanReader::new(rx);\n+        let stdout = ChanWriter::new(tx);\n+\n+        let r = Builder::new().stdout(box stdout as Box<Writer + Send>).spawn(move|| {\n+            print!(\"Hello, world!\");\n+        }).join();\n+        assert!(r.is_ok());\n+\n+        let output = reader.read_to_string().unwrap();\n+        assert_eq!(output, \"Hello, world!\".to_string());\n+    }\n+\n+    // NOTE: the corresponding test for stderr is in run-pass/task-stderr, due\n+    // to the test harness apparently interfering with stderr configuration.\n+}"}, {"sha": "4c33d1c418d962d0e22ab7a58c67c8a449387773", "filename": "src/libstd/thread_local/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fthread_local%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fthread_local%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fmod.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -68,6 +68,7 @@ pub mod scoped;\n ///\n /// ```\n /// use std::cell::RefCell;\n+/// use std::thread::Thread;\n ///\n /// thread_local!(static FOO: RefCell<uint> = RefCell::new(1));\n ///\n@@ -77,12 +78,12 @@ pub mod scoped;\n /// });\n ///\n /// // each thread starts out with the initial value of 1\n-/// spawn(move|| {\n+/// Thread::spawn(move|| {\n ///     FOO.with(|f| {\n ///         assert_eq!(*f.borrow(), 1);\n ///         *f.borrow_mut() = 3;\n ///     });\n-/// });\n+/// }).detach();\n ///\n /// // we retain our original value of 2 despite the child thread\n /// FOO.with(|f| {\n@@ -217,9 +218,8 @@ impl<T: 'static> Key<T> {\n     /// This function will `panic!()` if the key currently has its\n     /// destructor running, and it **may** panic if the destructor has\n     /// previously been run for this thread.\n-    pub fn with<R, F>(&'static self, f: F) -> R where\n-        F: FnOnce(&T) -> R,\n-    {\n+    pub fn with<F, R>(&'static self, f: F) -> R\n+                      where F: FnOnce(&T) -> R {\n         let slot = (self.inner)();\n         unsafe {\n             let slot = slot.get().expect(\"cannot access a TLS value during or \\\n@@ -446,7 +446,7 @@ mod tests {\n     use prelude::*;\n \n     use cell::UnsafeCell;\n-    use rustrt::thread::Thread;\n+    use thread::Thread;\n \n     struct Foo(Sender<()>);\n \n@@ -534,7 +534,7 @@ mod tests {\n             }\n         }\n \n-        Thread::start(move|| {\n+        Thread::spawn(move|| {\n             drop(S1);\n         }).join();\n     }\n@@ -552,7 +552,7 @@ mod tests {\n             }\n         }\n \n-        Thread::start(move|| unsafe {\n+        Thread::spawn(move|| unsafe {\n             K1.with(|s| *s.get() = Some(S1));\n         }).join();\n     }"}, {"sha": "96f09190c2fe4c00bbe2f969fca85cbcc83e7349", "filename": "src/libstd/thread_local/scoped.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fthread_local%2Fscoped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fthread_local%2Fscoped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fscoped.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -262,4 +262,3 @@ mod tests {\n         });\n     }\n }\n-"}, {"sha": "067926042f121ba38c6c77e30ba3d449a9638323", "filename": "src/libstd/thunk.rs", "status": "renamed", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fthunk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibstd%2Fthunk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthunk.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// Because this module is temporary...\n+#![allow(missing_docs)]\n+\n use alloc::boxed::Box;\n use core::kinds::Send;\n use core::ops::FnOnce;", "previous_filename": "src/librustrt/thunk.rs"}, {"sha": "56af8785a76d47356d5035ca855cfb86c6eb32a8", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -69,7 +69,7 @@ use std::num::{Float, FloatMath, Int};\n use std::os;\n use std::str::FromStr;\n use std::string::String;\n-use std::task::TaskBuilder;\n+use std::thread::{mod, Thread};\n use std::time::Duration;\n use std::thunk::{Thunk, Invoke};\n \n@@ -1121,28 +1121,27 @@ pub fn run_test(opts: &TestOpts,\n                       monitor_ch: Sender<MonitorMsg>,\n                       nocapture: bool,\n                       testfn: Thunk) {\n-        spawn(move || {\n+        Thread::spawn(move || {\n             let (tx, rx) = channel();\n             let mut reader = ChanReader::new(rx);\n             let stdout = ChanWriter::new(tx.clone());\n             let stderr = ChanWriter::new(tx);\n-            let mut task = TaskBuilder::new().named(match desc.name {\n+            let mut cfg = thread::Builder::new().name(match desc.name {\n                 DynTestName(ref name) => name.clone().to_string(),\n                 StaticTestName(name) => name.to_string(),\n             });\n             if nocapture {\n                 drop((stdout, stderr));\n             } else {\n-                task = task.stdout(box stdout as Box<Writer + Send>);\n-                task = task.stderr(box stderr as Box<Writer + Send>);\n+                cfg = cfg.stdout(box stdout as Box<Writer + Send>);\n+                cfg = cfg.stderr(box stderr as Box<Writer + Send>);\n             }\n-            let result_future = task.try_future(move || testfn.invoke(()));\n \n+            let result_guard = cfg.spawn(move || { testfn.invoke(()) });\n             let stdout = reader.read_to_end().unwrap().into_iter().collect();\n-            let task_result = result_future.into_inner();\n-            let test_result = calc_result(&desc, task_result);\n+            let test_result = calc_result(&desc, result_guard.join());\n             monitor_ch.send((desc.clone(), test_result, stdout));\n-        })\n+        }).detach();\n     }\n \n     match testfn {"}, {"sha": "226dc55cb8d5af5b4f8ed604290eb8bd572a0c1e", "filename": "src/rt/rust_try.ll", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Frt%2Frust_try.ll", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Frt%2Frust_try.ll", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_try.ll?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -12,11 +12,11 @@\n ; When f(...) returns normally, the return value is null.\n ; When f(...) throws, the return value is a pointer to the caught exception object.\n \n-; See also: librustrt/unwind.rs\n+; See also: libstd/rt/unwind.rs\n \n-define i8* @rust_try(void (i8*,i8*)* %f, i8* %fptr, i8* %env) {\n+define i8* @rust_try(void (i8*)* %f, i8* %env) {\n \n-    %1 = invoke i8* @rust_try_inner(void (i8*,i8*)* %f, i8* %fptr, i8* %env)\n+    %1 = invoke i8* @rust_try_inner(void (i8*)* %f, i8* %env)\n         to label %normal\n         unwind label %catch\n \n@@ -30,9 +30,9 @@ catch:\n     ret i8* null\n }\n \n-define internal i8* @rust_try_inner(void (i8*,i8*)* %f, i8* %fptr, i8* %env) {\n+define internal i8* @rust_try_inner(void (i8*)* %f, i8* %env) {\n \n-    invoke void %f(i8* %fptr, i8* %env)\n+    invoke void %f(i8* %env)\n         to label %normal\n         unwind label %catch\n "}, {"sha": "645c029f935a712a6023cc77dd0e17bdbf018d26", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -20,7 +20,7 @@\n \n use std::comm;\n use std::os;\n-use std::task;\n+use std::thread::Thread;\n use std::time::Duration;\n use std::uint;\n \n@@ -64,20 +64,20 @@ fn run(args: &[String]) {\n         let mut worker_results = Vec::new();\n         for _ in range(0u, workers) {\n             let to_child = to_child.clone();\n-            worker_results.push(task::try_future(move|| {\n+            worker_results.push(Thread::spawn(move|| {\n                 for _ in range(0u, size / workers) {\n                     //println!(\"worker {}: sending {} bytes\", i, num_bytes);\n                     to_child.send(request::bytes(num_bytes));\n                 }\n                 //println!(\"worker {} exiting\", i);\n             }));\n         }\n-        task::spawn(move|| {\n+        Thread::spawn(move|| {\n             server(&from_parent, &to_parent);\n-        });\n+        }).detach();\n \n         for r in worker_results.into_iter() {\n-            r.unwrap();\n+            let _ = r.join();\n         }\n \n         //println!(\"sending stop message\");"}, {"sha": "ed96c6406d836d7b3cf264b240a095239bf581f7", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -15,7 +15,7 @@\n // I *think* it's the same, more or less.\n \n use std::os;\n-use std::task;\n+use std::thread::Thread;\n use std::time::Duration;\n use std::uint;\n \n@@ -58,7 +58,7 @@ fn run(args: &[String]) {\n         let mut worker_results = Vec::new();\n         let from_parent = if workers == 1 {\n             let (to_child, from_parent) = channel();\n-            worker_results.push(task::try_future(move|| {\n+            worker_results.push(Thread::spawn(move|| {\n                 for _ in range(0u, size / workers) {\n                     //println!(\"worker {}: sending {} bytes\", i, num_bytes);\n                     to_child.send(request::bytes(num_bytes));\n@@ -70,7 +70,7 @@ fn run(args: &[String]) {\n             let (to_child, from_parent) = channel();\n             for _ in range(0u, workers) {\n                 let to_child = to_child.clone();\n-                worker_results.push(task::try_future(move|| {\n+                worker_results.push(Thread::spawn(move|| {\n                     for _ in range(0u, size / workers) {\n                         //println!(\"worker {}: sending {} bytes\", i, num_bytes);\n                         to_child.send(request::bytes(num_bytes));\n@@ -80,12 +80,12 @@ fn run(args: &[String]) {\n             }\n             from_parent\n         };\n-        task::spawn(move|| {\n+        Thread::spawn(move|| {\n             server(&from_parent, &to_parent);\n-        });\n+        }).detach();\n \n         for r in worker_results.into_iter() {\n-            r.unwrap();\n+            let _ = r.join();\n         }\n \n         //println!(\"sending stop message\");"}, {"sha": "f7e8fc8fe1b7adb58199ff2bc45025d8b2141bf7", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -22,7 +22,7 @@ extern crate getopts;\n \n use std::os;\n use std::result::Result::{Ok, Err};\n-use std::task;\n+use std::thread::Thread;\n use std::time::Duration;\n \n fn fib(n: int) -> int {\n@@ -34,15 +34,15 @@ fn fib(n: int) -> int {\n         } else {\n             let (tx1, rx) = channel();\n             let tx2 = tx1.clone();\n-            task::spawn(move|| pfib(&tx2, n - 1));\n+            Thread::spawn(move|| pfib(&tx2, n - 1)).detach();\n             let tx2 = tx1.clone();\n-            task::spawn(move|| pfib(&tx2, n - 2));\n+            Thread::spawn(move|| pfib(&tx2, n - 2)).detach();\n             tx.send(rx.recv() + rx.recv());\n         }\n     }\n \n     let (tx, rx) = channel();\n-    spawn(move|| pfib(&tx, n) );\n+    Thread::spawn(move|| pfib(&tx, n) ).detach();\n     rx.recv()\n }\n \n@@ -77,12 +77,12 @@ fn stress_task(id: int) {\n fn stress(num_tasks: int) {\n     let mut results = Vec::new();\n     for i in range(0, num_tasks) {\n-        results.push(task::try_future(move|| {\n+        results.push(Thread::spawn(move|| {\n             stress_task(i);\n         }));\n     }\n     for r in results.into_iter() {\n-        r.unwrap();\n+        let _ = r.join();\n     }\n }\n "}, {"sha": "b8ff1be71bf2b0e231161fd90680656c0f412d9c", "filename": "src/test/run-fail/main-panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Ftest%2Frun-fail%2Fmain-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Ftest%2Frun-fail%2Fmain-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmain-panic.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:task '<main>' panicked at\n+// error-pattern:thread '<main>' panicked at\n \n fn main() {\n     panic!()"}, {"sha": "c943dfe9f0c604b9351b11b309b8e930df259b9c", "filename": "src/test/run-fail/panic-task-name-none.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Ftest%2Frun-fail%2Fpanic-task-name-none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Ftest%2Frun-fail%2Fpanic-task-name-none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fpanic-task-name-none.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -8,14 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:task '<unnamed>' panicked at 'test'\n+// error-pattern:thread '<unnamed>' panicked at 'test'\n \n-use std::task;\n+use std::thread::Thread;\n \n fn main() {\n-    let r: Result<int,_> = task::try(move|| {\n+    let r: Result<int,_> = Thread::spawn(move|| {\n         panic!(\"test\");\n         1i\n-    });\n+    }).join();\n     assert!(r.is_ok());\n }"}, {"sha": "57901ebcfc622d176cae53eb995060407711bf20", "filename": "src/test/run-fail/panic-task-name-owned.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Ftest%2Frun-fail%2Fpanic-task-name-owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Ftest%2Frun-fail%2Fpanic-task-name-owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fpanic-task-name-owned.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -8,15 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:task 'owned name' panicked at 'test'\n+// error-pattern:thread 'owned name' panicked at 'test'\n \n-use std::task::TaskBuilder;\n+use std::thread::Builder;\n \n fn main() {\n-    let r: Result<int,_> = TaskBuilder::new().named(\"owned name\".to_string())\n-                                             .try(move|| {\n+    let r: Result<int,_> = Builder::new().name(\"owned name\".to_string()).spawn(move|| {\n         panic!(\"test\");\n         1i\n-    });\n+    }).join();\n     assert!(r.is_ok());\n }"}, {"sha": "92ebb3b4587af6b277a3cfb8f71ecb6c482d8a60", "filename": "src/test/run-fail/panic-task-name-send-str.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6bdce25e155d846bb9252fa4a18baef7e74cf8bf/src%2Ftest%2Frun-fail%2Fpanic-task-name-send-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bdce25e155d846bb9252fa4a18baef7e74cf8bf/src%2Ftest%2Frun-fail%2Fpanic-task-name-send-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fpanic-task-name-send-str.rs?ref=6bdce25e155d846bb9252fa4a18baef7e74cf8bf", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern:task 'send name' panicked at 'test'\n-\n-fn main() {\n-    let r: Result<int,_> =\n-        ::std::task::TaskBuilder::new().named(\"send name\".into_cow())\n-                                       .try(move|| {\n-            panic!(\"test\");\n-            3i\n-        });\n-    assert!(r.is_ok());\n-}"}, {"sha": "f8dfe9245b4389345a491d62428d84d5e7852509", "filename": "src/test/run-fail/panic-task-name-static.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6bdce25e155d846bb9252fa4a18baef7e74cf8bf/src%2Ftest%2Frun-fail%2Fpanic-task-name-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bdce25e155d846bb9252fa4a18baef7e74cf8bf/src%2Ftest%2Frun-fail%2Fpanic-task-name-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fpanic-task-name-static.rs?ref=6bdce25e155d846bb9252fa4a18baef7e74cf8bf", "patch": "@@ -1,19 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern:task 'static name' panicked at 'test'\n-\n-fn main() {\n-    let r: Result<int,_> =\n-        ::std::task::TaskBuilder::new().named(\"static name\").try(move|| {\n-            panic!(\"test\");\n-        });\n-    assert!(r.is_ok());\n-}"}, {"sha": "fa360570253b0f0e947eaaf1b2fe669d40704f21", "filename": "src/test/run-fail/test-panic.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Ftest%2Frun-fail%2Ftest-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Ftest%2Frun-fail%2Ftest-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ftest-panic.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -9,12 +9,11 @@\n // except according to those terms.\n \n // check-stdout\n-// error-pattern:task 'test_foo' panicked at\n+// error-pattern:thread 'test_foo' panicked at\n // compile-flags: --test\n // ignore-pretty: does not work well with `--test`\n \n #[test]\n fn test_foo() {\n     panic!()\n }\n-"}, {"sha": "5a5bb53a33a209f12f25f928a01fb662e034e7ff", "filename": "src/test/run-fail/test-should-fail-bad-message.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Ftest%2Frun-fail%2Ftest-should-fail-bad-message.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Ftest%2Frun-fail%2Ftest-should-fail-bad-message.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ftest-should-fail-bad-message.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // check-stdout\n-// error-pattern:task 'test_foo' panicked at\n+// error-pattern:thread 'test_foo' panicked at\n // compile-flags: --test\n // ignore-pretty: does not work well with `--test`\n \n@@ -18,5 +18,3 @@\n fn test_foo() {\n     panic!(\"blah\")\n }\n-\n-"}, {"sha": "572447097b775b2d0c00ab206d04eeb9e516b8a4", "filename": "src/test/run-make/bootstrap-from-c-with-native/Makefile", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6bdce25e155d846bb9252fa4a18baef7e74cf8bf/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/6bdce25e155d846bb9252fa4a18baef7e74cf8bf/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2FMakefile?ref=6bdce25e155d846bb9252fa4a18baef7e74cf8bf", "patch": "@@ -1,12 +0,0 @@\n--include ../tools.mk\n-\n-HOST_LIB_DIR=$(TMPDIR)/../../../stage$(RUST_BUILD_STAGE)/lib\n-# This overrides the LD_LIBRARY_PATH for RUN\n-TARGET_RPATH_DIR:=$(TARGET_RPATH_DIR):$(TMPDIR)\n-\n-all:\n-\t$(RUSTC) lib.rs\n-\t$(CC) main.c -o $(call RUN_BINFILE,main) $(call RPATH_LINK_SEARCH,$(HOST_LIB_DIR)) -lboot $(EXTRACFLAGS)\n-\t$(call RUN,main)\n-\t$(call REMOVE_DYLIBS,boot)\n-\t$(call FAIL,main)"}, {"sha": "d2fd5393834ebfbd32ae83308bc9af0902448528", "filename": "src/test/run-make/bootstrap-from-c-with-native/lib.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6bdce25e155d846bb9252fa4a18baef7e74cf8bf/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bdce25e155d846bb9252fa4a18baef7e74cf8bf/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2Flib.rs?ref=6bdce25e155d846bb9252fa4a18baef7e74cf8bf", "patch": "@@ -1,24 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![crate_name=\"boot\"]\n-#![crate_type=\"dylib\"]\n-\n-use std::rt;\n-use std::thunk::Thunk;\n-\n-#[no_mangle] // this needs to get called from C\n-pub extern \"C\" fn foo(argc: int, argv: *const *const u8) -> int {\n-    rt::start(argc, argv, Thunk::new(move|| {\n-        spawn(move|| {\n-            println!(\"hello\");\n-        });\n-    }))\n-}"}, {"sha": "1872c1ea43b1139cfaf90e728d6f11d8c07c2c52", "filename": "src/test/run-make/bootstrap-from-c-with-native/main.c", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6bdce25e155d846bb9252fa4a18baef7e74cf8bf/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2Fmain.c", "raw_url": "https://github.com/rust-lang/rust/raw/6bdce25e155d846bb9252fa4a18baef7e74cf8bf/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2Fmain.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2Fmain.c?ref=6bdce25e155d846bb9252fa4a18baef7e74cf8bf", "patch": "@@ -1,16 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// this is the rust entry point that we're going to call.\n-int foo(int argc, char *argv[]);\n-\n-int main(int argc, char *argv[]) {\n-  return foo(argc, argv);\n-}"}, {"sha": "440b7afa984f796ca2d7aab32420dd6f27b1ceb8", "filename": "src/test/run-pass/cleanup-rvalue-temp-during-incomplete-alloc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Ftest%2Frun-pass%2Fcleanup-rvalue-temp-during-incomplete-alloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Ftest%2Frun-pass%2Fcleanup-rvalue-temp-during-incomplete-alloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcleanup-rvalue-temp-during-incomplete-alloc.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -24,7 +24,7 @@\n // It's unclear how likely such a bug is to recur, but it seems like a\n // scenario worth testing.\n \n-use std::task;\n+use std::thread::Thread;\n \n enum Conzabble {\n     Bickwick(Foo)\n@@ -45,5 +45,5 @@ pub fn fails() {\n }\n \n pub fn main() {\n-    task::try(fails);\n+    Thread::spawn(fails).join();\n }"}, {"sha": "ce3e447350d40cb57877b5c936e647a53411ce33", "filename": "src/test/run-pass/foreign-call-no-runtime.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Ftest%2Frun-pass%2Fforeign-call-no-runtime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Ftest%2Frun-pass%2Fforeign-call-no-runtime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeign-call-no-runtime.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -9,10 +9,9 @@\n // except according to those terms.\n \n extern crate libc;\n-extern crate rustrt;\n \n use std::mem;\n-use rustrt::thread::Thread;\n+use std::thread::Thread;\n \n #[link(name = \"rust_test_helpers\")]\n extern {\n@@ -22,7 +21,7 @@ extern {\n \n pub fn main() {\n     unsafe {\n-        Thread::start(move|| {\n+        Thread::spawn(move|| {\n             let i = &100i;\n             rust_dbg_call(callback, mem::transmute(i));\n         }).join();"}, {"sha": "99758f9f777d6511e8b837a533b8478d60243642", "filename": "src/test/run-pass/issue-16671.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Ftest%2Frun-pass%2Fissue-16671.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Ftest%2Frun-pass%2Fissue-16671.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-16671.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -18,9 +18,11 @@\n // A var moved into a proc, that has a mutable loan path should\n // not trigger a misleading unused_mut warning.\n \n+use std::thread::Thread;\n+\n pub fn main() {\n     let mut stdin = std::io::stdin();\n-    spawn(move|| {\n+    Thread::spawn(move|| {\n         let _ = stdin.read_to_end();\n-    });\n+    }).detach();\n }"}, {"sha": "4bbbe978192b13f2e85ab112f2a69e9129acb40e", "filename": "src/test/run-pass/issue-2190-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Ftest%2Frun-pass%2Fissue-2190-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Ftest%2Frun-pass%2Fissue-2190-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2190-1.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -8,13 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::task::TaskBuilder;\n+use std::thread::Builder;\n use std::thunk::Thunk;\n \n static generations: uint = 1024+256+128+49;\n \n fn spawn(f: Thunk) {\n-    TaskBuilder::new().stack_size(32 * 1024).spawn(move|| f.invoke(()))\n+    Builder::new().stack_size(32 * 1024).spawn(move|| f.invoke(())).detach()\n }\n \n fn child_no(x: uint) -> Thunk {"}, {"sha": "9bb912e081ce68363d78686e223845dc413a0106", "filename": "src/test/run-pass/match-ref-binding-in-guard-3256.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Ftest%2Frun-pass%2Fmatch-ref-binding-in-guard-3256.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Ftest%2Frun-pass%2Fmatch-ref-binding-in-guard-3256.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-ref-binding-in-guard-3256.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate rustrt;\n+use std::sync::Mutex;\n \n pub fn main() {\n     unsafe {\n-        let x = Some(::rustrt::exclusive::Exclusive::new(true));\n+        let x = Some(Mutex::new(true));\n         match x {\n             Some(ref z) if *z.lock() => {\n                 assert!(*z.lock());"}, {"sha": "81e75ba2cd53dc4ede60399ef9f5d960cbf8b5ab", "filename": "src/test/run-pass/out-of-stack.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Ftest%2Frun-pass%2Fout-of-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Ftest%2Frun-pass%2Fout-of-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fout-of-stack.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-android: FIXME (#20004)\n+\n #![feature(asm)]\n \n use std::io::process::Command;"}, {"sha": "4cf8c52f2bb44ab42d3b91c59cea9791905b2031", "filename": "src/test/run-pass/running-with-no-runtime.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -8,15 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate rustrt;\n-\n use std::io::process::{Command, ProcessOutput};\n use std::os;\n use std::str;\n use std::rt;\n use std::thunk::Thunk;\n \n-use rustrt::unwind::try;\n+use std::rt::unwind::try;\n \n #[start]\n fn start(argc: int, argv: *const *const u8) -> int {\n@@ -35,11 +33,11 @@ fn start(argc: int, argv: *const *const u8) -> int {\n         return 0\n     }\n \n-    rt::start(argc, argv, Thunk::new(main))\n-}\n-\n-fn main() {\n-    let args = os::args();\n+    let args = unsafe {\n+        Vec::from_fn(argc as uint, |i| {\n+            String::from_raw_buf(*argv.offset(i as int)).into_bytes()\n+        })\n+    };\n     let me = args[0].as_slice();\n \n     let x: &[u8] = &[1u8];\n@@ -54,6 +52,8 @@ fn main() {\n     pass(Command::new(me).arg(x).output().unwrap());\n     let x: &[u8] = &[6u8];\n     pass(Command::new(me).arg(x).output().unwrap());\n+\n+    0\n }\n \n fn pass(output: ProcessOutput) {"}, {"sha": "ea594977f905cf81b37912afc1bc8027a830ce3c", "filename": "src/test/run-pass/spawning-with-debug.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Ftest%2Frun-pass%2Fspawning-with-debug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Ftest%2Frun-pass%2Fspawning-with-debug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawning-with-debug.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -13,9 +13,9 @@\n \n // regression test for issue #10405, make sure we don't call println! too soon.\n \n-use std::task::TaskBuilder;\n+use std::thread::Builder;\n \n pub fn main() {\n-    let mut t = TaskBuilder::new();\n-    t.spawn(move|| ());\n+    let mut t = Builder::new();\n+    t.spawn(move|| ()).detach();\n }"}, {"sha": "561c9e91553dd17fc5d9254f99cfc90d94610da7", "filename": "src/test/run-pass/task-comm-12.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -8,27 +8,27 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::task;\n+use std::thread::Thread;\n \n pub fn main() { test00(); }\n \n fn start(_task_number: int) { println!(\"Started / Finished task.\"); }\n \n fn test00() {\n     let i: int = 0;\n-    let mut result = task::try_future(move|| {\n+    let mut result = Thread::spawn(move|| {\n         start(i)\n     });\n \n     // Sleep long enough for the task to finish.\n     let mut i = 0u;\n     while i < 10000 {\n-        task::deschedule();\n+        Thread::yield_now();\n         i += 1;\n     }\n \n     // Try joining tasks that have already finished.\n-    result.unwrap();\n+    result.join();\n \n     println!(\"Joined task.\");\n }"}, {"sha": "73f6eb563c1ceb5b7da77e8d9ccc4bcc72bd29c4", "filename": "src/test/run-pass/task-comm-3.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -10,7 +10,7 @@\n \n // no-pretty-expanded FIXME #15189\n \n-use std::task;\n+use std::thread::Thread;\n \n pub fn main() { println!(\"===== WITHOUT THREADS =====\"); test00(); }\n \n@@ -39,7 +39,7 @@ fn test00() {\n     let mut results = Vec::new();\n     while i < number_of_tasks {\n         let tx = tx.clone();\n-        results.push(task::try_future({\n+        results.push(Thread::spawn({\n             let i = i;\n             move|| {\n                 test00_start(&tx, i, number_of_messages)\n@@ -60,7 +60,7 @@ fn test00() {\n     }\n \n     // Join spawned tasks...\n-    for r in results.iter_mut() { r.get_ref(); }\n+    for r in results.into_iter() { r.join(); }\n \n     println!(\"Completed: Final number is: \");\n     println!(\"{}\", sum);"}, {"sha": "69d70050437f18fcb87dd219af6c8eb3ddca09b2", "filename": "src/test/run-pass/task-comm-9.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::task;\n+use std::thread::Thread;\n \n pub fn main() { test00(); }\n \n@@ -23,7 +23,7 @@ fn test00() {\n     let (tx, rx) = channel();\n     let number_of_messages: int = 10;\n \n-    let result = task::try_future(move|| {\n+    let result = Thread::spawn(move|| {\n         test00_start(&tx, number_of_messages);\n     });\n \n@@ -34,7 +34,7 @@ fn test00() {\n         i += 1;\n     }\n \n-    result.unwrap();\n+    result.join();\n \n     assert_eq!(sum, number_of_messages * (number_of_messages - 1) / 2);\n }"}, {"sha": "ddeffcdf722048f2dd8405bfa19123988fa9e569", "filename": "src/test/run-pass/task-stderr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Ftest%2Frun-pass%2Ftask-stderr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Ftest%2Frun-pass%2Ftask-stderr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-stderr.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -9,16 +9,16 @@\n // except according to those terms.\n \n use std::io::{ChanReader, ChanWriter};\n-use std::task::TaskBuilder;\n+use std::thread;\n \n fn main() {\n     let (tx, rx) = channel();\n     let mut reader = ChanReader::new(rx);\n     let stderr = ChanWriter::new(tx);\n \n-    let res = TaskBuilder::new().stderr(box stderr as Box<Writer + Send>).try(move|| -> () {\n+    let res = thread::Builder::new().stderr(box stderr as Box<Writer + Send>).spawn(move|| -> () {\n         panic!(\"Hello, world!\")\n-    });\n+    }).join();\n     assert!(res.is_err());\n \n     let output = reader.read_to_string().unwrap();"}, {"sha": "b3391669d35d0dd2fec04a2e1a04d7c01b60e74e", "filename": "src/test/run-pass/tcp-stress.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Ftest%2Frun-pass%2Ftcp-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Ftest%2Frun-pass%2Ftcp-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-stress.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -19,7 +19,7 @@ extern crate libc;\n \n use std::io::net::tcp::{TcpListener, TcpStream};\n use std::io::{Acceptor, Listener};\n-use std::task::TaskBuilder;\n+use std::thread::Builder;\n use std::time::Duration;\n \n fn main() {\n@@ -53,7 +53,7 @@ fn main() {\n     let (tx, rx) = channel();\n     for _ in range(0u, 1000) {\n         let tx = tx.clone();\n-        TaskBuilder::new().stack_size(64 * 1024).spawn(move|| {\n+        Builder::new().stack_size(64 * 1024).spawn(move|| {\n             match TcpStream::connect(addr) {\n                 Ok(stream) => {\n                     let mut stream = stream;\n@@ -64,7 +64,7 @@ fn main() {\n                 Err(e) => debug!(\"{}\", e)\n             }\n             tx.send(());\n-        });\n+        }).detach();\n     }\n \n     // Wait for all clients to exit, but don't wait for the server to exit. The"}, {"sha": "f48272366e2fdbeb047290d7ae6bcb9c7ed19024", "filename": "src/test/run-pass/writealias.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Ftest%2Frun-pass%2Fwritealias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Ftest%2Frun-pass%2Fwritealias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwritealias.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate rustrt;\n+use std::sync::Mutex;\n \n struct Point {x: int, y: int, z: int}\n \n fn f(p: &mut Point) { p.z = 13; }\n \n pub fn main() {\n     unsafe {\n-        let x = Some(::rustrt::exclusive::Exclusive::new(true));\n+        let x = Some(Mutex::new(true));\n         match x {\n             Some(ref z) if *z.lock() => {\n                 assert!(*z.lock());"}, {"sha": "9a96b483f2c92d3b3dec452fba69bfc9cff085ea", "filename": "src/test/run-pass/yield.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Ftest%2Frun-pass%2Fyield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Ftest%2Frun-pass%2Fyield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fyield.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -8,18 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::task;\n+use std::thread::Thread;\n \n pub fn main() {\n-    let mut result = task::try_future(child);\n+    let mut result = Thread::spawn(child);\n     println!(\"1\");\n-    task::deschedule();\n+    Thread::yield_now();\n     println!(\"2\");\n-    task::deschedule();\n+    Thread::yield_now();\n     println!(\"3\");\n-    result.unwrap();\n+    result.join();\n }\n \n fn child() {\n-    println!(\"4\"); task::deschedule(); println!(\"5\"); task::deschedule(); println!(\"6\");\n+    println!(\"4\"); Thread::yield_now(); println!(\"5\"); Thread::yield_now(); println!(\"6\");\n }"}, {"sha": "13119e5d909cd26b5e05e8b633e3e403bd668a93", "filename": "src/test/run-pass/yield1.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Ftest%2Frun-pass%2Fyield1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Ftest%2Frun-pass%2Fyield1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fyield1.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -8,13 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::task;\n+use std::thread::Thread;\n \n pub fn main() {\n-    let mut result = task::try_future(child);\n+    let mut result = Thread::spawn(child);\n     println!(\"1\");\n-    task::deschedule();\n-    result.unwrap();\n+    Thread::yield_now();\n+    result.join();\n }\n \n fn child() { println!(\"2\"); }"}]}