{"sha": "a93dace55c588badca5475de570e45063deaf0be", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5M2RhY2U1NWM1ODhiYWRjYTU0NzVkZTU3MGU0NTA2M2RlYWYwYmU=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-12-29T19:00:57Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-01-23T09:30:39Z"}, "message": "Never create an temporary PassMode::Direct when it is not a valid pass mode for a type", "tree": {"sha": "b727c704f7aaa73a29970a8723a83d1e8191473f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b727c704f7aaa73a29970a8723a83d1e8191473f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a93dace55c588badca5475de570e45063deaf0be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a93dace55c588badca5475de570e45063deaf0be", "html_url": "https://github.com/rust-lang/rust/commit/a93dace55c588badca5475de570e45063deaf0be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a93dace55c588badca5475de570e45063deaf0be/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ba484de538640305b0ba5f574d809c1a71feda26", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba484de538640305b0ba5f574d809c1a71feda26", "html_url": "https://github.com/rust-lang/rust/commit/ba484de538640305b0ba5f574d809c1a71feda26"}], "stats": {"total": 96, "additions": 46, "deletions": 50}, "files": [{"sha": "c2e2efc40db249f8f3f52b8287e623070017c22c", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 15, "deletions": 33, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a93dace55c588badca5475de570e45063deaf0be/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a93dace55c588badca5475de570e45063deaf0be/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=a93dace55c588badca5475de570e45063deaf0be", "patch": "@@ -2745,7 +2745,11 @@ where\n                 cx.layout_of(ty)\n             };\n \n-            let mut arg = ArgAbi::new(layout);\n+            let mut arg = ArgAbi::new(cx, layout, |layout, scalar, offset| {\n+                let mut attrs = ArgAttributes::new();\n+                adjust_for_rust_scalar(&mut attrs, scalar, *layout, offset, is_return);\n+                attrs\n+            });\n \n             if arg.layout.is_zst() {\n                 // For some forsaken reason, x86_64-pc-windows-gnu\n@@ -2762,27 +2766,6 @@ where\n                 }\n             }\n \n-            if let Abi::ScalarPair(ref a, ref b) = arg.layout.abi {\n-                let mut a_attrs = ArgAttributes::new();\n-                let mut b_attrs = ArgAttributes::new();\n-                adjust_for_rust_scalar(&mut a_attrs, a, arg.layout, Size::ZERO, is_return);\n-                adjust_for_rust_scalar(\n-                    &mut b_attrs,\n-                    b,\n-                    arg.layout,\n-                    a.value.size(cx).align_to(b.value.align(cx).abi),\n-                    is_return,\n-                );\n-                arg.mode = PassMode::Pair(a_attrs, b_attrs);\n-                return arg;\n-            }\n-\n-            if let Abi::Scalar(ref scalar) = arg.layout.abi {\n-                if let PassMode::Direct(ref mut attrs) = arg.mode {\n-                    adjust_for_rust_scalar(attrs, scalar, arg.layout, Size::ZERO, is_return);\n-                }\n-            }\n-\n             arg\n         };\n \n@@ -2859,9 +2842,12 @@ where\n                 let max_by_val_size = Pointer.size(cx) * 2;\n                 let size = arg.layout.size;\n \n-                if arg.layout.is_unsized() || size > max_by_val_size {\n-                    arg.make_indirect();\n-                } else {\n+                assert!(\n+                    matches!(arg.mode, PassMode::Indirect { on_stack: false, .. }),\n+                    \"{:?}\",\n+                    arg\n+                );\n+                if !arg.layout.is_unsized() && size <= max_by_val_size {\n                     // We want to pass small aggregates as immediates, but using\n                     // a LLVM aggregate type for this leads to bad optimizations,\n                     // so we pick an appropriately sized integer type instead.\n@@ -2881,15 +2867,11 @@ where\n     }\n }\n \n-fn make_thin_self_ptr<'tcx, C>(\n-    cx: &C,\n-    mut layout: TyAndLayout<'tcx>,\n-) -> TyAndLayout<'tcx>\n-where C: LayoutOf<Ty = Ty<'tcx>, TyAndLayout = TyAndLayout<'tcx>>\n-        //+ HasDataLayout\n-        //+ HasTargetSpec\n+fn make_thin_self_ptr<'tcx, C>(cx: &C, mut layout: TyAndLayout<'tcx>) -> TyAndLayout<'tcx>\n+where\n+    C: LayoutOf<Ty = Ty<'tcx>, TyAndLayout = TyAndLayout<'tcx>>\n         + HasTyCtxt<'tcx>\n-        + HasParamEnv<'tcx>\n+        + HasParamEnv<'tcx>,\n {\n     let fat_pointer_ty = if layout.is_unsized() {\n         // unsized `self` is passed as a pointer to `self`"}, {"sha": "e889c3c415ca9c7b45826566dbe9f7cc0172a99b", "filename": "compiler/rustc_target/src/abi/call/mod.rs", "status": "modified", "additions": 31, "deletions": 17, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a93dace55c588badca5475de570e45063deaf0be/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a93dace55c588badca5475de570e45063deaf0be/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs?ref=a93dace55c588badca5475de570e45063deaf0be", "patch": "@@ -434,31 +434,49 @@ pub struct ArgAbi<'a, Ty> {\n }\n \n impl<'a, Ty> ArgAbi<'a, Ty> {\n-    pub fn new(layout: TyAndLayout<'a, Ty>) -> Self {\n-        ArgAbi { layout, pad: None, mode: PassMode::Direct(ArgAttributes::new()) }\n+    pub fn new(\n+        cx: &impl HasDataLayout,\n+        layout: TyAndLayout<'a, Ty>,\n+        scalar_attrs: impl Fn(&TyAndLayout<'a, Ty>, &abi::Scalar, Size) -> ArgAttributes,\n+    ) -> Self {\n+        let mode = match &layout.abi {\n+            Abi::Uninhabited => PassMode::Ignore,\n+            Abi::Scalar(scalar) => PassMode::Direct(scalar_attrs(&layout, scalar, Size::ZERO)),\n+            Abi::ScalarPair(a, b) => PassMode::Pair(\n+                scalar_attrs(&layout, a, Size::ZERO),\n+                scalar_attrs(&layout, b, a.value.size(cx).align_to(b.value.align(cx).abi)),\n+            ),\n+            Abi::Vector { .. } => PassMode::Direct(ArgAttributes::new()),\n+            Abi::Aggregate { .. } => Self::indirect_pass_mode(&layout),\n+        };\n+        ArgAbi { layout, pad: None, mode }\n     }\n \n-    pub fn make_indirect(&mut self) {\n-        match self.mode {\n-            PassMode::Direct(_) | PassMode::Pair(_, _) => {}\n-            _ => panic!(\"Tried to make {:?} indirect\", self.mode),\n-        }\n-\n-        // Start with fresh attributes for the pointer.\n+    fn indirect_pass_mode(layout: &TyAndLayout<'a, Ty>) -> PassMode {\n         let mut attrs = ArgAttributes::new();\n \n         // For non-immediate arguments the callee gets its own copy of\n         // the value on the stack, so there are no aliases. It's also\n         // program-invisible so can't possibly capture\n         attrs.set(ArgAttribute::NoAlias).set(ArgAttribute::NoCapture).set(ArgAttribute::NonNull);\n-        attrs.pointee_size = self.layout.size;\n+        attrs.pointee_size = layout.size;\n         // FIXME(eddyb) We should be doing this, but at least on\n         // i686-pc-windows-msvc, it results in wrong stack offsets.\n-        // attrs.pointee_align = Some(self.layout.align.abi);\n+        // attrs.pointee_align = Some(layout.align.abi);\n \n-        let extra_attrs = self.layout.is_unsized().then_some(ArgAttributes::new());\n+        let extra_attrs = layout.is_unsized().then_some(ArgAttributes::new());\n \n-        self.mode = PassMode::Indirect { attrs, extra_attrs, on_stack: false };\n+        PassMode::Indirect { attrs, extra_attrs, on_stack: false }\n+    }\n+\n+    pub fn make_indirect(&mut self) {\n+        match self.mode {\n+            PassMode::Direct(_) | PassMode::Pair(_, _) => {}\n+            PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: false } => return,\n+            _ => panic!(\"Tried to make {:?} indirect\", self.mode),\n+        }\n+\n+        self.mode = Self::indirect_pass_mode(&self.layout);\n     }\n \n     pub fn make_indirect_byval(&mut self) {\n@@ -489,10 +507,6 @@ impl<'a, Ty> ArgAbi<'a, Ty> {\n     }\n \n     pub fn cast_to<T: Into<CastTarget>>(&mut self, target: T) {\n-        match self.mode {\n-            PassMode::Direct(_) | PassMode::Pair(_, _) => {}\n-            _ => panic!(\"Tried to cast {:?} to {:?}\", self.mode, target.into()),\n-        }\n         self.mode = PassMode::Cast(target.into());\n     }\n "}]}